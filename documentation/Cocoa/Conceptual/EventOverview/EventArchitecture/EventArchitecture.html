<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>Cocoa Event-Handling Guide: Event Architecture</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Event Architecture"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/10000060i-CH3" title="Event Architecture"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../index.html#//apple_ref/doc/uid/TP30000440-TP30000416" target="_top">Cocoa</a> &gt; <a href="../../../EventsOtherInput-date.html#//apple_ref/doc/uid/TP30000440-TP30000416-TP30000447" target="_top">Events &amp; Other Input</a> &gt; <a href="../Introduction/Introduction.html#//apple_ref/doc/uid/10000060i-CH1-SW1">Cocoa Event-Handling Guide</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../Introduction/Introduction.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../EventObjectsTypes/EventObjectsTypes.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/10000060i-CH3-SW11" title="Event Architecture"></a><h1>Event Architecture</h1><p>The path taken by an event to the object in a Cocoa application that finally handles it can be a complicated one. This chapter traces the possible paths of events of various types and describes the mechanisms and architectural designs for handling events in the Application Kit.</p><p>For further background, “<span class="content_text"><a href="../../CocoaFundamentals/CoreAppArchitecture/CoreAppArchitecture.html#//apple_ref/doc/uid/TP40002974-CH8" target="_top">The Core Application Architecture on Mac OS X</a></span>“ in <em><a href="../../CocoaFundamentals/index.html#//apple_ref/doc/uid/TP40002974" target="_top">Cocoa Fundamentals Guide</a></em> is recommended reading.</p>
<!-- This template is being used for both PDF and HTML. -->

    
    <h4>In this section:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="EventArchitecture.html#//apple_ref/doc/uid/10000060i-CH3-SW1">How an Event Enters a Cocoa Application</a>
				
			<br/>
			
        
			
			
				<a href="EventArchitecture.html#//apple_ref/doc/uid/10000060i-CH3-SW4">Event Dispatch</a>
				
			<br/>
			
        
			
			
				<a href="EventArchitecture.html#//apple_ref/doc/uid/10000060i-CH3-SW7">Action Messages</a>
				
			<br/>
			
        
			
			
				<a href="EventArchitecture.html#//apple_ref/doc/uid/10000060i-CH3-SW23">Responders</a>
				
			<br/>
			
        
			
			
				<a href="EventArchitecture.html#//apple_ref/doc/uid/10000060i-CH3-SW2">The Responder Chain</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/10000060i-CH3-SW1" title="How an Event Enters a Cocoa Application"></a><h2>How an Event Enters a Cocoa Application</h2><p>An event is a low-level record of a user action that is usually routed to the application in which the action occurred. A typical event in Mac OS X originates when the user manipulates an input device attached to a computer system, such as a keyboard, mouse, or tablet stylus. When the user presses a key or clicks a button or moves a stylus, the device detects the action and initiates a transfer of data to the device driver associated with it. Through the I/O Kit, the device driver creates a low-level event, puts it in the window server's event queue, and notifies the window server. The window server dispatches the event to the appropriate run-loop port of the target process. From there the event is forwarded to the event-handling mechanism appropriate to the application environment. <span class="content_text">Figure 1-1</span> depicts this event-delivery system.</p><br/><div><a name="//apple_ref/doc/uid/10000060i-CH3-SW16" title="Figure 1-1The event stream"></a><p><strong>Figure 1-1&nbsp;&nbsp;</strong>The event stream</p><img src = "../Art/event_stream.jpg" alt = "The event stream" ></div><br/><div class="notebox"><a name="//apple_ref/doc/uid/10000060i-CH3-SW19" title="Note"></a><p><strong>Note:</strong>&nbsp;Applications normally receive events from the keyboard and mouse only when they are in the foreground (that is, active).  Although applications running in the background do not normally receive key and mouse events, low-level mechanisms called event taps make it possible for a background application to receive events and act upon them.</p></div><p>Before it dispatches an event to an application, the window server processes it in various ways; it time-stamps it, annotates it with the associated window and process port, and possibly performs other tasks as well. As an example, consider what happens when a user presses a key. The device driver translates the raw scan code into a virtual key code which it then passes off (along with other information about the keypress) to the window server in an event record. The window server has a translation facility that converts the virtual key code into a Unicode character. </p><p>In Mac OS X, events are delivered as an asynchronous stream. This event stream proceeds “upward” (in an architectural sense) through the various levels of the system—the hardware to the window server to the Event Manager—until each event reaches its final destination: an application. As it passes through each subsystem, an event may change structure but it still identifies a specific user action.</p><div class="notebox"><a name="//apple_ref/doc/uid/10000060i-CH3-SW20" title="Note"></a><p><strong>Note:</strong>&nbsp;Lower levels of the system trap and handle some events early in the event stream. These events are never routed to a Cocoa application. These events are generated by reserved keys or key combinations, such as the power and media-eject keys.</p></div><p>Every application has a mechanism specific to its environment for receiving events from the window server. For a Cocoa application, that mechanism is called the main event loop. A run loop, which in Cocoa is an <code><a href="../../../Reference/Foundation/Classes/NSRunLoop_Class/Reference/Reference.html#//apple_ref/occ/cl/NSRunLoop" target="_top">NSRunLoop</a></code> object, enables a process to receive input from various sources. By default, every thread in Mac OS X has its own run loop, and the run loop of the main thread of a Cocoa application is called the main event loop. What especially distinguishes the main event loop is an input source called the event source, which is constructed when the global <code><a href="../../../Reference/ApplicationKit/Classes/NSApplication_Class/Reference/Reference.html#//apple_ref/occ/cl/NSApplication" target="_top">NSApplication</a></code> object (<code><a href="../../../Reference/ApplicationKit/Classes/NSApplication_Class/Reference/Reference.html#//apple_ref/c/data/NSApp" target="_top">NSApp</a></code>) is initialized. The event source consists of a port for receiving events from the window server and a FIFO queue—the event queue—for holding those events until the application can process them, as shown in <span class="content_text">Figure 1-2</span>.</p><br/><div><a name="//apple_ref/doc/uid/10000060i-CH3-SW5" title="Figure 1-2The main event loop, with event source"></a><p><strong>Figure 1-2&nbsp;&nbsp;</strong>The main event loop, with event source</p><img src = "../Art/main_event_loop1.gif" alt = "The main event loop, with event source" width="384" height="208"></div><br/><p>A Cocoa application is event driven: It fetches an event from the queue, dispatches it to an appropriate object, and, after the event is handled, fetches the next event. With some exceptions (such as modal event loops) an application continues in this pattern until the user quits it. The following section, <span class="content_text">“Event Dispatch,”</span> describes how an application fetches and dispatches events.</p><p>Events delivered via the event source are not the only kinds of events that enter Cocoa applications. An application can also respond to Apple events, high-level interprocess events typically sent by other processes such as the Finder and Launch Services. For example, when users double-click an application icon to open the application or double-click a document to open the document, an Apple event is sent to the target application. An application also fetches Apple events from the queue but it does not convert them into <code>NSEvent</code> objects. Instead an Apple event is handled directly by an event handler. When an application launches, it automatically registers several event handlers for this purpose. For more on Apple events and event handlers, see <em><a href="../../../../AppleScript/Conceptual/AppleEvents/index.html#//apple_ref/doc/uid/TP40001449" target="_top">Apple Events Programming Guide</a></em>.</p><a name="//apple_ref/doc/uid/10000060i-CH3-SW4" title="Event Dispatch"></a><h2>Event Dispatch</h2><p>In the main event loop, the application object (<code>NSApp</code>) continuously gets the next (topmost) event in the event queue, converts it to an <code><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/Reference/Reference.html#//apple_ref/occ/cl/NSEvent" target="_top">NSEvent</a></code> object, and dispatches it toward its final destination. It performs this fetching of events by invoking the <code><a href="../../../Reference/ApplicationKit/Classes/NSApplication_Class/Reference/Reference.html#//apple_ref/occ/instm/NSApplication/nextEventMatchingMask:untilDate:inMode:dequeue:" target="_top">nextEventMatchingMask:untilDate:inMode:dequeue:</a></code> method in a closed loop. When there are no events in the event queue, this method blocks, resuming only when there are more events to process. </p><p>After fetching and converting an event, <code>NSApp</code> performs the first stage of event dispatching in the <code><a href="../../../Reference/ApplicationKit/Classes/NSApplication_Class/Reference/Reference.html#//apple_ref/occ/instm/NSApplication/sendEvent:" target="_top">sendEvent:</a></code> method. In most cases <code>NSApp</code> merely forwards the event to the window in which the user action occurred by invoking the <code><a href="../../../Reference/ApplicationKit/Classes/NSWindow_Class/Reference/Reference.html#//apple_ref/occ/instm/NSWindow/sendEvent:" target="_top">sendEvent:</a></code> method of that <code>NSWindow</code> object. The window object then dispatches most events to the <code><a href="../../../Reference/ApplicationKit/Classes/NSView_Class/Reference/NSView.html#//apple_ref/occ/cl/NSView" target="_top">NSView</a></code> object associated with the user action in an <code>NSResponder</code> message such as <code><a href="../../../Reference/ApplicationKit/Classes/NSResponder_Class/Reference/Reference.html#//apple_ref/occ/instm/NSResponder/mouseDown:" target="_top">mouseDown:</a></code> or <code><a href="../../../Reference/ApplicationKit/Classes/NSResponder_Class/Reference/Reference.html#//apple_ref/occ/instm/NSResponder/keyDown:" target="_top">keyDown:</a></code>. An event message includes as its sole argument an <code><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/Reference/Reference.html#//apple_ref/occ/cl/NSEvent" target="_top">NSEvent</a></code> object describing the event. </p><p>The object receiving an event message differs slightly by type of event. For mouse and tablet events, the <code><a href="../../../Reference/ApplicationKit/Classes/NSWindow_Class/Reference/Reference.html#//apple_ref/occ/cl/NSWindow" target="_top">NSWindow</a></code> object dispatches the event to the view over which the user pressed the mouse or stylus button. It dispatches most key events to the first responder of the key window. <span class="content_text">Figure 1-3</span> and <span class="content_text">Figure 1-4</span> illustrate these different general delivery paths. The destination view may decide not to handle the event, instead passing it up the responder chain (see <span class="content_text"><a href="EventArchitecture.html#//apple_ref/doc/uid/10000060i-CH3-SW2">“The Responder Chain”</a></span>).</p><br/><div><a name="//apple_ref/doc/uid/10000060i-CH3-SW12" title="Figure 1-3Path of a mouse event"></a><p><strong>Figure 1-3&nbsp;&nbsp;</strong>Path of a mouse event</p><img src = "../Art/event_dispatch_mouse.jpg" alt = "Path of a mouse event" ></div><br/><br/><div><a name="//apple_ref/doc/uid/10000060i-CH3-SW13" title="Figure 1-4Path of a key event (character to insert)"></a><p><strong>Figure 1-4&nbsp;&nbsp;</strong>Path of a key event (character to insert)</p><img src = "../Art/event_dispatch_key_char.jpg" alt = "Path of a key event (character to insert)" ></div><br/><p>In the preceding paragraph you might have noticed the use of qualifiers such as “in most cases” and “usually.“  The delivery of an event (and especially a key event) in Cocoa can take many different paths depending on the particular kind of the event. Some events, many of which are defined by the Application Kit (type <code><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/Reference/Reference.html#//apple_ref/c/econst/NSAppKitDefined" target="_top">NSAppKitDefined</a></code>), have to do with actions controlled by a window or the application object itself. Examples of these events are those related to activating, deactivating, hiding, and showing the application. <code>NSApp</code> filters out these events early in its dispatch routine and handles them itself. </p><p>The following sections describe the different paths of the events that can reach your view objects. For detailed information on these event types, read <span class="content_text"><a href="../EventObjectsTypes/EventObjectsTypes.html#//apple_ref/doc/uid/10000060i-CH4-SW4">“Event Objects and Types.”</a></span> </p><a name="//apple_ref/doc/uid/10000060i-CH3-SW21" title="The Path of Mouse and Tablet Events"></a><h3>The Path of Mouse and Tablet Events</h3><p>As noted above, an <code>NSWindow</code> object in its <code><a href="../../../Reference/ApplicationKit/Classes/NSWindow_Class/Reference/Reference.html#//apple_ref/occ/instm/NSWindow/sendEvent:" target="_top">sendEvent:</a></code> method forwards mouse events to the view over which the user action involving the mouse occurred. It identifies the view to receive the event by invoking the <code>NSView</code> method <code><a href="../../../Reference/ApplicationKit/Classes/NSView_Class/Reference/NSView.html#//apple_ref/occ/instm/NSView/hitTest:" target="_top">hitTest:</a></code>, which returns the lowest descendant that contains the cursor location of the event (this is usually the topmost view displayed). The window object forwards the mouse event to this view by sending it a mouse-related <code>NSResponder</code> message specific to its exact type, such as <code><a href="../../../Reference/ApplicationKit/Classes/NSResponder_Class/Reference/Reference.html#//apple_ref/occ/instm/NSResponder/mouseDown:" target="_top">mouseDown:</a></code>, <code><a href="../../../Reference/ApplicationKit/Classes/NSResponder_Class/Reference/Reference.html#//apple_ref/occ/instm/NSResponder/mouseDragged:" target="_top">mouseDragged:</a></code>, or <code><a href="../../../Reference/ApplicationKit/Classes/NSResponder_Class/Reference/Reference.html#//apple_ref/occ/instm/NSResponder/rightMouseUp:" target="_top">rightMouseUp:</a></code>, On (left) mouse-down events, the window object also asks the receiving view whether it is willing to become first responder for subsequent key events and action messages. </p><p>A view object can receive mouse events of three general types: mouse clicks, mouse drags, and mouse movements. Mouse-click events are further categorized—as specific <code><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/Reference/Reference.html#//apple_ref/c/tdef/NSEventType" target="_top">NSEventType</a></code> constants and <code>NSResponder</code> methods—by mouse button (left, right, or other) and direction of click (up or down). Mouse-dragged and mouse-up events are typically sent to the same view that received the most recent mouse-down event. Mouse-moved events are sent to the first responder. Mouse-down, mouse-dragged, mouse-up, and mouse-moved events can occur only in certain situations relative to other mouse events: </p><ul class="spaceabove"><li class="li"><p>Each mouse-up event must be preceded by a mouse-down event.</p></li><li class="li"><p>Mouse-dragged events occur only between a mouse-down event and a mouse-up event.</p></li><li class="li"><p>Mouse-moved events do not occur between a mouse-down and a mouse-up event.</p></li></ul><p>Mouse-down events are sent when a user presses the mouse button while the cursor is over a view object. If the window containing the view is not the key window, the window becomes the key window and discards the mouse-down event. However, a view can circumvent this default behavior by overriding the  <code><a href="../../../Reference/ApplicationKit/Classes/NSView_Class/Reference/NSView.html#//apple_ref/occ/instm/NSView/acceptsFirstMouse:" target="_top">acceptsFirstMouse:</a></code> method of <code>NSView</code> to return <code>YES</code>.</p><p>Views automatically receive mouse-clicked and mouse-dragged events, but because mouse-moved events occur so often and can bog down the event queue, a view object must explicitly request its window to watch for them using the <code>NSWindow</code> method <code><a href="../../../Reference/ApplicationKit/Classes/NSWindow_Class/Reference/Reference.html#//apple_ref/occ/instm/NSWindow/setAcceptsMouseMovedEvents:" target="_top">setAcceptsMouseMovedEvents:</a></code>. Tracking rectangles, described in <span class="content_text"><a href="EventArchitecture.html#//apple_ref/doc/uid/10000060i-CH3-SW6">“Other Event Dispatching,”</a></span> are a less expensive way of following the mouse’s location.</p><p>In its implementation of an <code>NSResponder</code> mouse-event method, a subclass of <code><a href="../../../Reference/ApplicationKit/Classes/NSView_Class/Reference/NSView.html#//apple_ref/occ/cl/NSView" target="_top">NSView</a></code> can interpret a mouse event as a cue to perform a certain action, such as sending a target-action message, selecting a graphic element, redrawing itself at a different location, and so on. Each event method includes as its sole parameter an <code><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/Reference/Reference.html#//apple_ref/occ/cl/NSEvent" target="_top">NSEvent</a></code> object from which the view can obtain information about the event. For example, the view can use the <code><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/Reference/Reference.html#//apple_ref/occ/instm/NSEvent/locationInWindow" target="_top">locationInWindow</a></code> to locate the mouse cursor’s hot spot in the coordinate system of the receiver’s window. To convert it to the view’s coordinate system, use <code><a href="../../../Reference/ApplicationKit/Classes/NSView_Class/Reference/NSView.html#//apple_ref/occ/instm/NSView/convertPoint:fromView:" target="_top">convertPoint:fromView:</a></code> with a <code><a href="../../../Reference/ObjCRuntimeRef/Reference/reference.html#//apple_ref/doc/c_ref/nil" target="_top">nil</a></code> view argument. From here, you can use <code><a href="../../../Reference/ApplicationKit/Classes/NSView_Class/Reference/NSView.html#//apple_ref/occ/instm/NSView/mouse:inRect:" target="_top">mouse:inRect:</a></code> to determine whether the click occurred in an interesting area.</p><p>Tablet events take a path to delivery to a view that is similar to that for mouse events. The <code>NSWindow</code> object representing the window in which the table event occurred forwards the event to the view under the cursor. However, there are two kinds of tablet events, proximity events and pointer events. The former are generally native tablet events (of type <code><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/Reference/Reference.html#//apple_ref/c/econst/NSTabletProximity" target="_top">NSTabletProximity</a></code>) generated when the stylus moves into and out of proximity to the tablet. Tablet pointer events occur between proximity-entering and proximity-leaving tablet events and indicate such things as stylus direction, pressure, and button click. Pointer events are generally subtypes of mouse events. Refer to <span class="content_text"><a href="../HandlingTabletEvents/HandlingTabletEvents.html#//apple_ref/doc/uid/10000060i-CH10-SW1">“Handling Tablet Events”</a></span> for more information.</p><p>For the paths taken by mouse-tracking and cursor-update events, see <span class="content_text"><a href="EventArchitecture.html#//apple_ref/doc/uid/10000060i-CH3-SW6">“Other Event Dispatching.”</a></span></p><a name="//apple_ref/doc/uid/10000060i-CH3-SW10" title="The Path of Key Events"></a><h3>The Path of Key Events</h3><p>Processing keyboard input is by far the most complex part of event dispatch. The Application Kit goes to great lengths to ease this process for you, and in fact handling the key events that get to your custom objects is fairly straightforward. However, a lot happens to those events on their way from the hardware to the responder chain. Of particular interest are the types of key events that arrive in a Cocoa application as <code><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/Reference/Reference.html#//apple_ref/occ/cl/NSEvent" target="_top">NSEvent</a></code> objects and the order and way these types of events are handled.</p><p>A Cocoa application evaluates each key event to determine what kind of key event it is and then handles in an appropriate way. The path a key event can take before it is handled can be quite long. <span class="content_text">Figure 1-5</span> shows these potential paths.</p><br/><div><a name="//apple_ref/doc/uid/10000060i-CH3-SW14" title="Figure 1-5Possible path of a key event"></a><p><strong>Figure 1-5&nbsp;&nbsp;</strong>Possible path of a key event</p><img src = "../Art/event_key_path_flow.jpg" alt = "Possible path of a key event" ></div><br/><p>The following list describes in detail the possible paths for key events, in the order in which an application evaluates each key event;</p><ol class="ol"><li class="li"><p><strong>Key equivalents</strong>. A key equivalent is a key or key combination (usually a key modified by the Command key) that is bound typically to some menu item or control object in the application. Pressing the key combination simulates the action of clicking the control or choosing the menu item.</p><p>The application object handles key equivalents by going <em>down</em> the view hierarchy in the key window, sending each object a <code><a href="../../../Reference/ApplicationKit/Classes/NSResponder_Class/Reference/Reference.html#//apple_ref/occ/instm/NSResponder/performKeyEquivalent:" target="_top">performKeyEquivalent:</a></code> message until an object returns <code>YES</code>. If the message isn’t handled by an object in the view hierarchy, <code>NSApp</code> then sends it to the menus in the menu bar. Some Cocoa classes, such as <code><a href="../../../Reference/ApplicationKit/Classes/NSButton_Class/Reference/Reference.html#//apple_ref/occ/cl/NSButton" target="_top">NSButton</a></code>, <code><a href="../../../Reference/ApplicationKit/Classes/NSMenu_Class/Reference/Reference.html#//apple_ref/occ/cl/NSMenu" target="_top">NSMenu</a></code>, <code><a href="../../../Reference/ApplicationKit/Classes/NSMatrix_Class/Reference/Reference.html#//apple_ref/occ/cl/NSMatrix" target="_top">NSMatrix</a></code>, and <code><a href="../../../Reference/ApplicationKit/Classes/NSSavePanel_Class/Reference/Reference.html#//apple_ref/occ/cl/NSSavePanel" target="_top">NSSavePanel</a></code> provide default implementations.</p><p>For more information, see <span class="content_text"><a href="../HandlingKeyEvents/HandlingKeyEvents.html#//apple_ref/doc/uid/10000060i-CH7-SW11">“Handling Key Equivalents.”</a></span></p></li><li class="li"><p><strong>Keyboard interface control</strong>. A keyboard interface control event manipulates the input focus among objects in a user interface. In the key window, <code><a href="../../../Reference/ApplicationKit/Classes/NSWindow_Class/Reference/Reference.html#//apple_ref/occ/cl/NSWindow" target="_top">NSWindow</a></code> interprets certain keys as commands to move control to a different interface object, to simulate a mouse click on it, and so on. For example, pressing the Tab key moves input focus to the next object; Shift-Tab reverses the direction; pressing the space bar simulates a click on a button. The order of interface objects controlled through this mechanism is specified by a key view loop. You can set up the key view loop in Interface Builder and you can manipulate the key view loop programmatically through the   <code><a href="../../../Reference/ApplicationKit/Classes/NSView_Class/Reference/NSView.html#//apple_ref/occ/instm/NSView/setNextKeyView:" target="_top">setNextKeyView:</a></code> and <code><a href="../../../Reference/ApplicationKit/Classes/NSView_Class/Reference/NSView.html#//apple_ref/occ/instm/NSView/nextKeyView" target="_top">nextKeyView</a></code> methods of <code>NSView</code>.</p><p>For more information, see <span class="content_text"><a href="../HandlingKeyEvents/HandlingKeyEvents.html#//apple_ref/doc/uid/10000060i-CH7-SW9">“Keyboard Interface Control.”</a></span></p></li><li class="li"><p><strong>Keyboard action</strong>.  Unlike the action messages that controls send to their targets (see <span class="content_text"><a href="EventArchitecture.html#//apple_ref/doc/uid/10000060i-CH3-SW7">“Action Messages”</a></span>), keyboard actions are commands (represented by methods defined by the <code><a href="../../../Reference/ApplicationKit/Classes/NSResponder_Class/Reference/Reference.html#//apple_ref/occ/cl/NSResponder" target="_top">NSResponder</a></code> class) that are per-view functional interpretations of physical keystrokes (as identified by the constant returned by the <code><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/Reference/Reference.html#//apple_ref/occ/instm/NSEvent/characters" target="_top">characters</a></code> method of <code>NSEvent</code>). In other words, keyboard actions are bound to physical keys through the key bindings mechanism described in <span class="content_text"><a href="../TextDefaultsBindings/TextDefaultsBindings.html#//apple_ref/doc/uid/20000468-CJBDEADF">“Text System Defaults and Key Bindings.”</a></span> For example, <code><a href="../../../Reference/ApplicationKit/Classes/NSResponder_Class/Reference/Reference.html#//apple_ref/occ/instm/NSResponder/pageDown:" target="_top">pageDown:</a></code>, <code><a href="../../../Reference/ApplicationKit/Classes/NSResponder_Class/Reference/Reference.html#//apple_ref/occ/instm/NSResponder/moveToBeginningOfLine:" target="_top">moveToBeginningOfLine:</a></code>, and <code><a href="../../../Reference/ApplicationKit/Classes/NSResponder_Class/Reference/Reference.html#//apple_ref/occ/instm/NSResponder/capitalizeWord:" target="_top">capitalizeWord:</a></code> are methods invoked by keyboard actions when the bound key is pressed. Such actions are sent to the first responder, and the methods handling these actions can be implemented in that view or in a superview further up the responder chain. </p><p>See <span class="content_text"><a href="../HandlingKeyEvents/HandlingKeyEvents.html#//apple_ref/doc/uid/10000060i-CH7-SW2">“Overriding the keyDown: Method”</a></span> for more information about the handling of keyboard actions.</p></li><li class="li"><p><strong>Character (or characters) for insertion as text</strong>. </p></li></ol><p>If the application object processes a key event and it turns out <em>not</em> to be a key equivalent or a key interface control event, it then sends it to the key window in a <code><a href="../../../Reference/ApplicationKit/Classes/NSWindow_Class/Reference/Reference.html#//apple_ref/occ/instm/NSWindow/sendEvent:" target="_top">sendEvent:</a></code> message. The window object invokes the <code><a href="../../../Reference/ApplicationKit/Classes/NSResponder_Class/Reference/Reference.html#//apple_ref/occ/instm/NSResponder/keyDown:" target="_top">keyDown:</a></code> method in the first responder, from whence the key event travels <em>up</em> the responder chain until it is handled. At this point, the key event can be either one or more Unicode character to be inserted into a view’s displayed text , a key or key combination to be specially interpreted, or a keyboard-action event.</p><p>See <span class="content_text"><a href="../HandlingKeyEvents/HandlingKeyEvents.html#//apple_ref/doc/uid/10000060i-CH7-SW1">“Handling Key Events”</a></span> for more information about how key events are dispatched and handled.</p><a name="//apple_ref/doc/uid/10000060i-CH3-SW6" title="Other Event Dispatching"></a><h3>Other Event Dispatching</h3><p>An <code>NSWindow</code> object monitors tracking-rectangle events and dispatches these events directly to the owning object in  <code><a href="../../../Reference/ApplicationKit/Classes/NSResponder_Class/Reference/Reference.html#//apple_ref/occ/instm/NSResponder/mouseEntered:" target="_top">mouseEntered:</a></code> and <code><a href="../../../Reference/ApplicationKit/Classes/NSResponder_Class/Reference/Reference.html#//apple_ref/occ/instm/NSResponder/mouseExited:" target="_top">mouseExited:</a></code> messages. The owner is specified in the second parameter of the <code>NSTrackingArea</code> method <code><a href="../../../Reference/NSTrackingArea_class/Reference/Reference.html#//apple_ref/occ/instm/NSTrackingArea/initWithRect:options:owner:userInfo:" target="_top">initWithRect:options:owner:userInfo:</a></code> and the <code>NSView</code> method<code><a href="../../../Reference/ApplicationKit/Classes/NSView_Class/Reference/NSView.html#//apple_ref/occ/instm/NSView/addTrackingRect:owner:userData:assumeInside:" target="_top">addTrackingRect:owner:userData:assumeInside:</a></code>. <span class="content_text"><a href="../TrackingAreaObjects/TrackingAreaObjects.html#//apple_ref/doc/uid/10000060i-CH8-SW1">“Using Tracking-Area Objects”</a></span> describes how to set up tracking rectangles and handle the related events. </p><p>Periodic events (type <code><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/Reference/Reference.html#//apple_ref/c/econst/NSPeriodic" target="_top">NSPeriodic</a></code>) are generated by the application at a specified frequency and placed in the event queue. However, unlike most other types of events, periodic events aren’t dispatched using the <code><a href="../../../Reference/ApplicationKit/Classes/NSApplication_Class/Reference/Reference.html#//apple_ref/occ/instm/NSApplication/sendEvent:" target="_top">sendEvent:</a></code> mechanism of <code><a href="../../../Reference/ApplicationKit/Classes/NSApplication_Class/Reference/Reference.html#//apple_ref/occ/cl/NSApplication" target="_top">NSApplication</a></code> and <code><a href="../../../Reference/ApplicationKit/Classes/NSWindow_Class/Reference/Reference.html#//apple_ref/occ/cl/NSWindow" target="_top">NSWindow</a></code>. Instead the object registering for the periodic events typically retrieves them in a modal event loop using the <code><a href="../../../Reference/ApplicationKit/Classes/NSApplication_Class/Reference/Reference.html#//apple_ref/occ/instm/NSApplication/nextEventMatchingMask:untilDate:inMode:dequeue:" target="_top">nextEventMatchingMask:untilDate:inMode:dequeue:</a></code> method. See <span class="content_text"><a href="../EventObjectsTypes/EventObjectsTypes.html#//apple_ref/doc/uid/10000060i-CH4-SW6">“Other Types of Events”</a></span> for more information about periodic events.</p><a name="//apple_ref/doc/uid/10000060i-CH3-SW7" title="Action Messages"></a><h2>Action Messages</h2><p>The discussion so far has focused on event messages: messages arising from an device-related event such as a mouse click or a keypress. The Application Kit sends an event message of the appropriate form—for example, <code><a href="../../../Reference/ApplicationKit/Classes/NSResponder_Class/Reference/Reference.html#//apple_ref/occ/instm/NSResponder/mouseDown:" target="_top">mouseDown:</a></code> and <code><a href="../../../Reference/ApplicationKit/Classes/NSResponder_Class/Reference/Reference.html#//apple_ref/occ/instm/NSResponder/keyDown:" target="_top">keyDown:</a></code>—to an <code><a href="../../../Reference/ApplicationKit/Classes/NSResponder_Class/Reference/Reference.html#//apple_ref/occ/cl/NSResponder" target="_top">NSResponder</a></code> object for handling. </p><p>But <code>NSResponder</code> objects are also expected to handle another kind of message: action messages. Actions are commands that objects, usually <code><a href="../../../Reference/ApplicationKit/Classes/NSControl_Class/Reference/Reference.html#//apple_ref/occ/cl/NSControl" target="_top">NSControl</a></code> or <code><a href="../../../Reference/ApplicationKit/Classes/NSMenu_Class/Reference/Reference.html#//apple_ref/occ/cl/NSMenu" target="_top">NSMenu</a></code> objects, give to the application object to dispatch as messages to a particular target or to any target that’s willing to respond to them. The methods invoked by action messages have a specific signature: a single parameter holding a reference to the object initiating the action message; by convention, the name of this parameter is <em>sender</em>. For example, </p><div class="codesample"><table><tr><td scope="row"><pre>- (void)moveToEndOfLine:(id)sender; // from NSResponder.h<span></span></pre></td></tr></table></div><p>Event and action methods are dispatched in different ways, by different methods. Nearly all events enter an application from the window server and are dispatched automatically by the  <code><a href="../../../Reference/ApplicationKit/Classes/NSApplication_Class/Reference/Reference.html#//apple_ref/occ/instm/NSApplication/sendEvent:" target="_top">sendEvent:</a></code> method of <code>NSApplication</code>. Action messages, on the other hand, are dispatched by the <code><a href="../../../Reference/ApplicationKit/Classes/NSApplication_Class/Reference/Reference.html#//apple_ref/occ/instm/NSApplication/sendAction:to:from:" target="_top">sendAction:to:from:</a></code> method of the global application object (<code>NSApp</code>) to their proper destinations. </p><div class="notebox"><a name="//apple_ref/doc/uid/10000060i-CH3-SW22" title="Note"></a><p><strong>Note:</strong>&nbsp;A major difference between event messages and action messages is the different paths they can possibly take up the responder chain. See <span class="content_text"><a href="EventArchitecture.html#//apple_ref/doc/uid/10000060i-CH3-SW2">“The Responder Chain”</a></span> for details.</p></div><p>As illustrated in <span class="content_text">Figure 1-6</span>, action messages are generally sent as a secondary effect of an event message. When a user clicks a control object such as a button, two event messages (<code>mouseDown:</code> and <code>mouseUp:</code>) are sent as a result. The control and its associated cell handle the <code>mouseUp:</code> message (in part) by sending the application object a <code>sendAction:to:from:</code> message. The first argument is the selector identifying the action method to invoke. The second is the intended recipient of the message, called the target, which can be <code>nil</code>. The final argument is usually the object invoking <code>sendAction:to:from:</code>, thus indicating which object initiated the action message. The target of an action message can send messages back to <em>sender</em> to get further information. A similar sequence occurs for menus and menu items. For more on the architecture of controls and cells (and menus and menu items) see “<span class="content_text"><a href="../../CocoaFundamentals/CoreAppArchitecture/CoreAppArchitecture.html#//apple_ref/doc/uid/TP40002974-CH8" target="_top">The Core Application Architecture on Mac OS X</a></span>“ in <em><a href="../../CocoaFundamentals/index.html#//apple_ref/doc/uid/TP40002974" target="_top">Cocoa Fundamentals Guide</a></em>.</p><br/><div><a name="//apple_ref/doc/uid/10000060i-CH3-SW15" title="Figure 1-6From event message to action message"></a><p><strong>Figure 1-6&nbsp;&nbsp;</strong>From event message to action message</p><img src = "../Art/action_from_event.gif" alt = "From event message to action message" width="602" height="157"></div><br/><p>The target of an action message is handled by the Application Kit in a special way. If the intended target isn’t <code><a href="../../../Reference/ObjCRuntimeRef/Reference/reference.html#//apple_ref/doc/c_ref/nil" target="_top">nil</a></code>, the action is simply sent directly to that object; this is called a targeted action message. In the case of an untargeted action message (that is, the target parameter is <code><a href="../../../Reference/ObjCRuntimeRef/Reference/reference.html#//apple_ref/doc/c_ref/nil" target="_top">nil</a></code>), <code>sendAction:to:from:</code> searches up the full responder chain (starting with the first responder) for an object that implements the action method specified. If it finds one, it sends the message to that object with the initiator of the action message as the sole argument. The receiver of the action message can then query the sender for additional information. You can find the recipient of an untargeted action message without actually sending the message using <code>targetForAction:</code>. </p><p>Event messages form a well-known set, so <code>NSResponder</code> provides declarations and default implementations for all of them. Most action messages, however, are defined by custom classes and can’t be predicted. However, <code>NSResponder</code> does declare a number of keyboard action methods, such as <code><a href="../../../Reference/ApplicationKit/Classes/NSResponder_Class/Reference/Reference.html#//apple_ref/occ/instm/NSResponder/pageDown:" target="_top">pageDown:</a></code>, <code><a href="../../../Reference/ApplicationKit/Classes/NSResponder_Class/Reference/Reference.html#//apple_ref/occ/instm/NSResponder/moveToBeginningOfDocument:" target="_top">moveToBeginningOfDocument:</a></code>, and <code><a href="../../../Reference/ApplicationKit/Classes/NSResponder_Class/Reference/Reference.html#//apple_ref/occ/instm/NSResponder/cancelOperation:" target="_top">cancelOperation:</a></code>. These action methods are typically bound to specific keys using the key-bindings mechanism and are meant to perform cursor movement, text operations, and similar operations.</p><p>A more general mechanism of action-message dispatch is provided by the <code>NSResponder</code> method <code><a href="../../../Reference/ApplicationKit/Classes/NSResponder_Class/Reference/Reference.html#//apple_ref/occ/instm/NSResponder/tryToPerform:with:" target="_top">tryToPerform:with:</a></code>. This method checks the receiver to see if it responds to the selector provided, if so invoking the message. If not, it sends <code>tryToPerform:with:</code> to its next responder. <code>NSWindow</code> and <code>NSApplication</code> override this method to include their delegates, but they don’t link individual responder chains in the way that the <code>sendAction:to:from:</code> method does. Similar to <code>tryToPerform:with:</code> is <code><a href="../../../Reference/ApplicationKit/Classes/NSResponder_Class/Reference/Reference.html#//apple_ref/occ/instm/NSResponder/doCommandBySelector:" target="_top">doCommandBySelector:</a></code>, which takes a method selector and tries to find a responder that implements it. If none is found, the method causes the hardware to beep.</p><div class="warningbox"><img src="../../../../Resources/Images/icon_warning.gif" alt="!" width="20" height="20" border="0" class="warningicon" /><a name="//apple_ref/doc/uid/10000060i-CH3-DontLinkElementID_4" title="Warning:"></a><p><strong>Warning:</strong>&nbsp;Although <code>NSResponder</code> declares a number of action messages, it doesn’t actually implement them. You should never send an action message directly to a responder object of an unknown class. Always use the <code>NSApplication</code> method <code>sendAction:to:from:</code>, the <code>NSResponder</code> methods <code>tryToPerform:with:</code> or <code>doCommandBySelector:</code>, or check that the target responds using the <code>NSObject</code> method <code><a href="../../../Reference/Foundation/Protocols/NSObject_Protocol/Reference/NSObject.html#//apple_ref/occ/intfm/NSObject/respondsToSelector:" target="_top">respondsToSelector:</a></code>.</p><p></p><div class="clear"></div></div><a name="//apple_ref/doc/uid/10000060i-CH3-SW23" title="Responders"></a><h2>Responders</h2><p>A responder is an object that can receive events, either directly or through the responder chain, by virtue of its inheritance from the <code><a href="../../../Reference/ApplicationKit/Classes/NSResponder_Class/Reference/Reference.html#//apple_ref/occ/cl/NSResponder" target="_top">NSResponder</a></code> class. <code><a href="../../../Reference/ApplicationKit/Classes/NSApplication_Class/Reference/Reference.html#//apple_ref/occ/cl/NSApplication" target="_top">NSApplication</a></code>, <code><a href="../../../Reference/ApplicationKit/Classes/NSWindow_Class/Reference/Reference.html#//apple_ref/occ/cl/NSWindow" target="_top">NSWindow</a></code>, <code><a href="../../../Reference/ApplicationKit/Classes/NSDrawer_Class/Reference/Reference.html#//apple_ref/occ/cl/NSDrawer" target="_top">NSDrawer</a></code>, <code><a href="../../../Reference/ApplicationKit/Classes/NSWindowController_Class/Reference/Reference.html#//apple_ref/occ/cl/NSWindowController" target="_top">NSWindowController</a></code>, <code><a href="../../../Reference/ApplicationKit/Classes/NSView_Class/Reference/NSView.html#//apple_ref/occ/cl/NSView" target="_top">NSView</a></code> and the many descendants of these classes in the Application Kit inherit from <code>NSResponder</code>. This class defines the programmatic interface for the reception of event messages and many action messages. It also defines the general structure of responder behavior. Within the responder chain there is a first responder and a  sequence of next responders</p><p>For more on the responder chain, see <span class="content_text"><a href="EventArchitecture.html#//apple_ref/doc/uid/10000060i-CH3-SW2">“The Responder Chain.”</a></span> <em><a href="../../CocoaFundamentals/index.html#//apple_ref/doc/uid/TP40002974" target="_top">Cocoa Fundamentals Guide</a></em> also contains an overview of responders and the responder chain in “<span class="content_text"><a href="../../CocoaFundamentals/CoreAppArchitecture/CoreAppArchitecture.html#//apple_ref/doc/uid/TP40002974-CH8" target="_top">The Core Application Architecture on Mac OS X</a></span>.“</p><a name="//apple_ref/doc/uid/10000060i-CH3-SW24" title="First Responders"></a><h3>First Responders</h3><p>A first responder is typically a user-interface object that the user selects or activates with the mouse or keyboard. It is usually the first object in a responder chain to receive an event or action message. An <code>NSWindow</code> object’s first responder is initially itself; however, you can set, programmatically and in Interface Builder, the object that is made first responder when the window is first placed on-screen. </p><p>When an <code>NSWindow</code> object receives a mouse-down event, it automatically tries to make the <code><a href="../../../Reference/ApplicationKit/Classes/NSView_Class/Reference/NSView.html#//apple_ref/occ/cl/NSView" target="_top">NSView</a></code> object under the event the first responder. It does so by asking the view whether it wants to become first responder, using the <code><a href="../../../Reference/ApplicationKit/Classes/NSResponder_Class/Reference/Reference.html#//apple_ref/occ/instm/NSResponder/acceptsFirstResponder" target="_top">acceptsFirstResponder</a></code> method defined by this class. This method returns <code><a href="../../../Reference/ObjCRuntimeRef/Reference/reference.html#//apple_ref/doc/c_ref/NO" target="_top">NO</a></code> by default; responder subclasses that need to be first responder must override it to return <code><a href="../../../Reference/ObjCRuntimeRef/Reference/reference.html#//apple_ref/doc/c_ref/YES" target="_top">YES</a></code>. The <code><a href="../../../Reference/ApplicationKit/Classes/NSResponder_Class/Reference/Reference.html#//apple_ref/occ/instm/NSResponder/acceptsFirstResponder" target="_top">acceptsFirstResponder</a></code> method is also invoked when the user changes the first responder through the keyboard interface control feature.</p><p>You can programmatically change the first responder by sending <code><a href="../../../Reference/ApplicationKit/Classes/NSWindow_Class/Reference/Reference.html#//apple_ref/occ/instm/NSWindow/makeFirstResponder:" target="_top">makeFirstResponder:</a></code> to an <code>NSWindow</code> object. This message initiates a kind of protocol in which one object loses its first responder status and another gains it. See <span class="content_text"><a href="../EventHandlingBasics/EventHandlingBasics.html#//apple_ref/doc/uid/10000060i-CH5-SW2">“Setting the First Responder”</a></span> for further information.</p><p>An <code><a href="../../../Reference/ApplicationKit/Classes/NSPanel_Class/Reference/Reference.html#//apple_ref/occ/cl/NSPanel" target="_top">NSPanel</a></code> object presents a variation of first-responder behavior that permits panels to present a user interface that doesn’t take away key focus from the main window. If the panel object representing an inactive window and returning <code>YES</code> from <code><a href="../../../Reference/ApplicationKit/Classes/NSPanel_Class/Reference/Reference.html#//apple_ref/occ/instm/NSPanel/becomesKeyOnlyIfNeeded" target="_top">becomesKeyOnlyIfNeeded</a></code> receives a mouse-down event, it attempts to make the view object under the mouse pointer the first responder, but <em>only</em> if that object returns <code>YES</code> in <code><a href="../../../Reference/ApplicationKit/Classes/NSResponder_Class/Reference/Reference.html#//apple_ref/occ/instm/NSResponder/acceptsFirstResponder" target="_top">acceptsFirstResponder</a></code> and <code><a href="../../../Reference/ApplicationKit/Classes/NSView_Class/Reference/NSView.html#//apple_ref/occ/instm/NSView/needsPanelToBecomeKey" target="_top">needsPanelToBecomeKey</a></code>.</p><p>Mouse-moved events (type <code><a href="../../../Reference/ApplicationKit/Classes/NSEvent_Class/Reference/Reference.html#//apple_ref/c/econst/NSMouseMoved" target="_top">NSMouseMoved</a></code>) are always sent to the first responder, not to the view under the mouse.</p><a name="//apple_ref/doc/uid/10000060i-CH3-SW25" title="Next Responders"></a><h3>Next Responders</h3><p>Every responder object has a built-in capability for getting the next responder up the responder chain. The <code><a href="../../../Reference/ApplicationKit/Classes/NSResponder_Class/Reference/Reference.html#//apple_ref/occ/instm/NSResponder/nextResponder" target="_top">nextResponder</a></code> method, which returns this object, is the essential mechanism of the responder chain. <span class="content_text">Figure 1-7</span> shows the sequence of next responders.</p><br/><div><a name="//apple_ref/doc/uid/10000060i-CH3-SW8" title="Figure 1-7The chain of next responders"></a><p><strong>Figure 1-7&nbsp;&nbsp;</strong>The chain of next responders</p><img src = "../Art/responder_chain.gif" alt = "The chain of next responders" width="312" height="373"></div><br/><p>A view’s next responder is always its superview—most of the responder chain, in fact, comprises the views from a window’s first responder up to its content view. When you create a window or add subviews to existing views, either programmatically or in Interface Builder, the Application Kit automatically hooks up the next responders in the responder chain. The <code><a href="../../../Reference/ApplicationKit/Classes/NSView_Class/Reference/NSView.html#//apple_ref/occ/instm/NSView/addSubview:" target="_top">addSubview:</a></code> method of <code>NSView</code> automatically sets the receiver as the new subview’s superview. You should never send <code><a href="../../../Reference/ApplicationKit/Classes/NSResponder_Class/Reference/Reference.html#//apple_ref/occ/instm/NSResponder/setNextResponder:" target="_top">setNextResponder:</a></code> to an <code>NSView</code> object. You can safely add responders to the top end of a window’s responder chain—the <code>NSWindow</code> object itself if it has no delegate or, if it has a delegate, after the delegate.</p><a name="//apple_ref/doc/uid/10000060i-CH3-SW2" title="The Responder Chain"></a><h2>The Responder Chain</h2><p>The responder chain is a linked series of responder objects to which an event or action message is applied. When a given responder object doesn’t handle a particular message, the object passes the message to its successor in the chain (that is, its next responder). This allows responder objects to delegate responsibility for handling the message to other, typically higher-level objects. The Application Kit automatically constructs the responder chain as described below, but you can insert custom objects into parts of it using the <code><a href="../../../Reference/ApplicationKit/Classes/NSResponder_Class/Reference/Reference.html#//apple_ref/occ/cl/NSResponder" target="_top">NSResponder</a></code> method <code><a href="../../../Reference/ApplicationKit/Classes/NSResponder_Class/Reference/Reference.html#//apple_ref/occ/instm/NSResponder/setNextResponder:" target="_top">setNextResponder:</a></code> and you can examine it (or traverse it) with <code><a href="../../../Reference/ApplicationKit/Classes/NSResponder_Class/Reference/Reference.html#//apple_ref/occ/instm/NSResponder/nextResponder" target="_top">nextResponder</a></code>.</p><p>An application can contain any number of responder chains, but only one is active at any given time. The responder chain is different for event messages and action messages, as described in the following sections.</p><a name="//apple_ref/doc/uid/10000060i-CH3-SW26" title="Responder Chain for Event Messages"></a><h3>Responder Chain for Event Messages</h3><p>Nearly all event messages apply to a single window’s responder chain—the window in which the associated user event occurred. The default responder chain for event messages begins with the view that the <code><a href="../../../Reference/ApplicationKit/Classes/NSWindow_Class/Reference/Reference.html#//apple_ref/occ/cl/NSWindow" target="_top">NSWindow</a></code> object first delivers the message to. The default responder chain for a key event message begins with the first responder in a window; the default responder chain for a mouse or tablet event begins with the view on which the user event occurred. From there the event, if not handled, proceeds up the view hierarchy to the <code><a href="../../../Reference/ApplicationKit/Classes/NSWindow_Class/Reference/Reference.html#//apple_ref/occ/cl/NSWindow" target="_top">NSWindow</a></code> object representing the window itself. The first responder is typically the “selected” view object within the window, and its next responder is its containing view (also called its superview), and so on up to the <code>NSWindow</code> object. If an <code><a href="../../../Reference/ApplicationKit/Classes/NSWindowController_Class/Reference/Reference.html#//apple_ref/occ/cl/NSWindowController" target="_top">NSWindowController</a></code> object is managing the window, it becomes the final next responder. You can insert other responders between <code><a href="../../../Reference/ApplicationKit/Classes/NSView_Class/Reference/NSView.html#//apple_ref/occ/cl/NSView" target="_top">NSView</a></code> objects and even above the <code>NSWindow</code> object near the top of the chain. These inserted responders receive both event and action messages. If no object is found to handle the event, the last responder in the chain invokes <code><a href="../../../Reference/ApplicationKit/Classes/NSResponder_Class/Reference/Reference.html#//apple_ref/occ/instm/NSResponder/noResponderFor:" target="_top">noResponderFor:</a></code>, which for a key-down event simply beeps. Event-handling objects (subclasses of <code>NSWindow</code> and <code>NSView</code>) can override this method to perform additional steps as needed. </p><a name="//apple_ref/doc/uid/10000060i-CH3-SW9" title="Responder Chain for Action Messages"></a><h3>Responder Chain for Action Messages</h3><p>For action messages, the Application Kit constructs a more elaborate responder chain that varies according to two factors:</p><ul class="spaceabove"><li class="li"><p>Whether the application is based on the document architecture and, if it isn't, whether it uses <code><a href="../../../Reference/ApplicationKit/Classes/NSWindowController_Class/Reference/Reference.html#//apple_ref/occ/cl/NSWindowController" target="_top">NSWindowController</a></code> objects for its windows</p></li><li class="li"><p>Whether the application is currently displaying a key window as well as a main window</p></li></ul><p>Action messages have a more elaborate responder chain than do event messages because actions require a more flexible runtime mechanism for determining their targets. They are not restricted to a single window, as are event messages.</p><p>The simplest case is an active non-document-based window that has no associated panel or secondary window displayed—in other words, a main window that is also the key window. In this case, the responder chain is the following:</p><ol class="ol"><li class="li"><p>The main window’s first responder and the successive responder objects up the view hierarchy</p></li><li class="li"><p>The main window itself</p></li><li class="li"><p>The main window’s delegate (which need not inherit from <code><a href="../../../Reference/ApplicationKit/Classes/NSResponder_Class/Reference/Reference.html#//apple_ref/occ/cl/NSResponder" target="_top">NSResponder</a></code>)</p></li><li class="li"><p>The application object, <code><a href="../../../Reference/ApplicationKit/Classes/NSApplication_Class/Reference/Reference.html#//apple_ref/doc/c_ref/NSApp" target="_top">NSApp</a></code></p></li><li class="li"><p>The application object’s delegate (which need not inherit from <code>NSResponder</code>)</p></li></ol><p>This chain is shown graphically in <span class="content_text">Figure 1-8</span>.</p><br/><div><a name="//apple_ref/doc/uid/10000060i-CH3-SW17" title="Figure 1-8Responder chain of a non-document-based application"></a><p><strong>Figure 1-8&nbsp;&nbsp;</strong>Responder chain of a non-document-based application</p><img src = "../Art/nondoc.gif" alt = "Responder chain of a non-document-based application" width="342" height="135"></div><br/><p>As this sequence indicates, the <code>NSWindow</code> object and the <code>NSApplication</code> object give their delegates a chance to handle action messages as though they were responders, even though a delegate isn’t formally in the responder chain (that is, a <code>nextResponder</code> message to a window or application object doesn’t return the delegate).  </p><p>When an application is displaying both a main window and a key window, the responder chains of both windows can be involved in an action message. As explained in "<span class="content_text"><a href="../../WinPanel/Concepts/ChangingMainKeyWindow.html#//apple_ref/doc/uid/20000236" target="_top">Window Layering and Types of Windows</a></span>," the main window is the frontmost document or application window. Often main windows also have key status, meaning they are the current focus of user input. But a main window can have a secondary window or panel associated with it, such as the Find panel or a Info window showing details of a selection in the document window. When this secondary window is the focus of user input, then it is the key window.</p><p>When an application has a main window <em>and</em> a separate key window displayed, the responder chain of the key window gets first crack at action messages, and the responder chain of the main window follows. The full responder chain comprises these responders and delegates:</p><ol class="ol"><li class="li"><p>The key window’s first responder and the successive responder objects up the view hierarchy</p></li><li class="li"><p>The key window itself</p></li><li class="li"><p>The key window’s delegate (which need not inherit from <code>NSResponder</code>)</p></li><li class="li"><p>The main window’s first responder and the successive responder objects up the view hierarchy</p></li><li class="li"><p>The main window itself</p></li><li class="li"><p>The main window’s delegate (which need not inherit from <code>NSResponder</code>)</p></li><li class="li"><p>The application object, <code><a href="../../../Reference/ApplicationKit/Classes/NSApplication_Class/Reference/Reference.html#//apple_ref/doc/c_ref/NSApp" target="_top">NSApp</a></code></p></li><li class="li"><p>The application object’s delegate (which need not inherit from <code>NSResponder</code>)</p></li></ol><p>As you can see, the responder chains for the key window and the main window are identical with the global application object and its delegate being the responders at the end of the main window's responder chain. This design is true for the responder chains of the other kinds of applications: those based on the document architecture and those that use an <code>NSWindowController</code> object for window management. In the latter case, the default main-window responder chain consists of the following responders and delegates:</p><ol class="ol"><li class="li"><p>The main window’s first responder and the successive responder objects up the view hierarchy</p></li><li class="li"><p>The main window itself</p></li><li class="li"><p>The main window’s delegate</p></li><li class="li"><p>The window's <code>NSWindowController</code> object (which inherits from <code>NSResponder</code>)</p></li><li class="li"><p>The application object, <code>NSApp</code></p></li><li class="li"><p>The application object's delegate</p></li></ol><p><span class="content_text">Figure 1-9</span> shows the responder chain of non-document-based application that uses an NSWindowController object.</p><br/><div><a name="//apple_ref/doc/uid/10000060i-CH3-SW3" title="Figure 1-9Responder chain of a non-document application with an NSWindowController object"></a><p><strong>Figure 1-9&nbsp;&nbsp;</strong>Responder chain of a non-document application with an <code>NSWindowController</code> object</p><img src = "../Art/nondoc_withcontroller.gif" alt = "Responder chain of a non-document application with an NSWindowController object" width="443" height="134"></div><br/><p>For document-based applications, the default responder chain for the main window consists of the following responders and delegates:</p><ol class="ol"><li class="li"><p>The main window’s first responder and the successive responder objects up the view hierarchy</p></li><li class="li"><p>The main window itself</p></li><li class="li"><p>The main window’s delegate.</p></li><li class="li"><p>The window's <code>NSWindowController</code> object (which inherits from <code>NSResponder</code>)</p></li><li class="li"><p>The <code>NSDocument</code> object (if different from the main window’s delegate)</p></li><li class="li"><p>The application object, <code>NSApp</code></p></li><li class="li"><p>The application object's delegate</p></li><li class="li"><p>The application's document controller (an <code><a href="../../../Reference/ApplicationKit/Classes/NSDocumentController_Class/Reference/Reference.html#//apple_ref/occ/cl/NSDocumentController" target="_top">NSDocumentController</a></code> object, which does not inherit from <code>NSResponder</code>)</p></li></ol><p><span class="content_text">Figure 1-10</span> shows the responder chain of a document-based application.</p><br/><div><a name="//apple_ref/doc/uid/10000060i-CH3-SW18" title="Figure 1-10Responder chain of a document-based application"></a><p><strong>Figure 1-10&nbsp;&nbsp;</strong>Responder chain of a document-based application</p><img src = "../Art/doc_based.gif" alt = "Responder chain of a document-based application" width="614" height="134"></div><br/><a name="//apple_ref/doc/uid/10000060i-CH3-148895" title="Other Uses"></a><h3>Other Uses</h3><p>The responder chain is used by three other mechanisms in the Application Kit:  </p><ul class="spaceabove"><li class="li"><p><strong>Automatic menu enabling</strong>: In automatically enabling and disabling a menu item with a <code>nil</code> target, an <code><a href="../../../Reference/ApplicationKit/Classes/NSMenu_Class/Reference/Reference.html#//apple_ref/occ/cl/NSMenu" target="_top">NSMenu</a></code> searches different responder chains depending on whether the menu object represents the application menu or a context menu. For the application menu, <code>NSMenu</code> consults the full responder chain—that is, first key, then main window—to find an object that implements the menu item’s action method and (if it implements it) returns <code>YES</code> from <code><a href="../../../Reference/ApplicationKit/Protocols/NSMenuValidation_Protocol/Reference/Reference.html#//apple_ref/occ/instm/NSObject/validateMenuItem:" target="_top">validateMenuItem:</a></code>. For a context menu, the search is restricted to the responder chain of the window in which the context menu was displayed, starting with the associated view. </p><p>For more on automatic menu enabling, see “<span class="content_text"><a href="../../MenuList/Articles/EnablingMenuItems.html#//apple_ref/doc/uid/20000261" target="_top">Enabling Menu Items</a></span>".</p></li><li class="li"><p><strong>Services eligibility</strong>: Similarly, the Services facility passes <code><a href="../../../Reference/ApplicationKit/Classes/NSResponder_Class/Reference/Reference.html#//apple_ref/occ/instm/NSResponder/validRequestorForSendType:returnType:" target="_top">validRequestorForSendType:returnType:</a></code> messages along the full responder chain to check for objects that are eligible for services offered by other applications.</p><p>For further information, see <em><a href="../../SysServices/index.html#//apple_ref/doc/uid/10000101i" target="_top">System Services</a></em>.</p></li><li class="li"><p><strong>Error presentation</strong>: The Application Kit uses a modified version of the responder chain for error handling and error presentation, centered upon the <code>NSResponder</code> methods <code><a href="../../../Reference/ApplicationKit/Classes/NSResponder_Class/Reference/Reference.html#//apple_ref/occ/instm/NSResponder/presentError:modalForWindow:delegate:didPresentSelector:contextInfo:" target="_top">presentError:modalForWindow:delegate:didPresentSelector:contextInfo:</a></code> and <code><a href="../../../Reference/ApplicationKit/Classes/NSResponder_Class/Reference/Reference.html#//apple_ref/occ/instm/NSResponder/presentError:" target="_top">presentError:</a></code>.</p><p>For more information on the error-responder chain, see <em><a href="../../ErrorHandlingCocoa/index.html#//apple_ref/doc/uid/TP40001806" target="_top">Error Handling Programming Guide For Cocoa</a></em>.</p></li></ul>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../Introduction/Introduction.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../EventObjectsTypes/EventObjectsTypes.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2009 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2009-02-04<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Cocoa/Conceptual/EventOverview/EventArchitecture/EventArchitecture.html%3Fid%3D10000060i-5.2&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Cocoa/Conceptual/EventOverview/EventArchitecture/EventArchitecture.html%3Fid%3D10000060i-5.2&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Cocoa/Conceptual/EventOverview/EventArchitecture/EventArchitecture.html%3Fid%3D10000060i-5.2&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>