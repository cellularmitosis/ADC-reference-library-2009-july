<html><head><link rel="stylesheet" href="../../adcstyle.css" type="text/css"><link rel="Stylesheet" href="../../style.css" type="text/css"><title>Technical Note TN2033: How to use the ATSUI Low Level APIs to get glyph outlines</title> <meta name="keywords" content="ATSUI glyph outline ATM"><meta name="Description" content="Technical Note TN2033: TN2033: This technote covers the ATSUIlow-level APIs."><meta name="categories" content="Human Interface Toolbox and Text"><meta name="week-posted" content="Nov 26, 2001 - Nov 30, 2001"><LINK REL="stylesheet" HREF="../../css/adcstyle.css" TYPE="text/css"><script language="JavaScript" type="text/javascript" src="../../js/adc.js"></script></head><body bgcolor="#FFFFFF"><a name="//apple_ref/doc/uid/DTS10003070" title="How to use the ATSUI Low Level APIs to get glyph outlines"></a><a name="top"> </a> <!-- top_of_header_marker_comment --><!-- begin_header_information --><!--#include virtual="/adcnavbar" --><p><a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../technicalnotes/index.html">Technical Notes</a> &gt; <a href="../../technicalnotes/TextFonts/index.html">Text & Fonts</a> &gt; <a href="../../technicalnotes/TextFonts/idxCarbon-date.html">Carbon</a> &gt; </p><!-- end_header_information --><!-- bottom_of_header_marker_comment --><!-- top_of_titles_marker_comment --><CENTER><table width="600" cellpadding="0" cellspacing="0" border="0">
<tr><td align="left" scope="row">
<h1>
<div id="pagehead">Technical Note TN2033</div>
<div id="pageheadsub">How to use the ATSUI Low Level APIs to get glyph outlines</div>
</h1>
</td></tr></table></CENTER><!-- bottom_of_titles_marker_comment --><center><table border="0" cellspacing="1" width="600"><tr><td align="left" scope="row"><!-- begin_header_box --><table width="600" cellpadding="0" cellspacing="0" border="0"><tr><td width=300 valign="top" align=left><table border="0" width="300" cellpadding="0" cellspacing="0"><tr><td width=300 align=left><img src="images/tnmenutop.gif" alt="" align="bottom" width=300 height=7> </td></tr><tr bgcolor="#e6e6e6"><td background="images/tnmenubody.gif" width=300 align=left><span id="menutitle"> CONTENTS <br><br></span> </td></tr><tr bgcolor="#e6e6e6"><td background="images/tnmenubody.gif" width=300 align=left><!-- begin_toc --><p id="menutext"><a href="#Glyphs"> Getting Glyph Information </a> <br><br><a href="#Outlines"> Retrieving Glyph Outlines </a> <br><br><a href="#Metrics"> Retrieving Glyph Metrics </a> <br><br><a href="#DataReference"> Data Type Reference </a> <br><br><a href="#APIReference"> API Reference </a> <br><br><a href="#Downloads">Downloadables</a> </p><!-- end_toc --></td></tr><tr><td width=300 align=left scope="row"><img src="images/tnmenubottom.gif" alt="" width=300 height=16> </td></tr></table></td><td width=300 valign="top" align=left><!-- begin_intro_text --><p id="introtext">This document assumes you are familiar with the APIs and concepts for ATSUI (<a href="http://developer.apple.com/documentation/Carbon/text/ATSUI/atsui.html">Apple Type Services for Unicode Imaging</a>). </p><p id="introtext">ATSUI is Apple's API for drawing Unicode text. In addition to the high-level ATSUI APIs, ATSUI has added a set of APIs that enable you to access text information at a lower level. These APIs contain functions that let you: </p><p id="introtext">- Get information on the glyphs and glyph positions associated with an <code>ATSUTextLayout</code>. For each glyph, you can determine the glyph ID in the corresponding font, which character in the original text the glyph is derived from, and positioning information for the glyph.</p><p id="introtext">- For a given glyph in a particular font, retrieve the outline data for the glyph. These are the curves that make up the glyph's shape.</p><p id="introtext">- For a given glyph in a particular font, retrieve both the ideal (resolution-independent) metrics and the screen (resolution-dependent) metrics for that glyph.</p><p id="introtext">- Given a set of glyphs and positions that have been obtained from an <code>ATSUTextLayout</code>, draw them, after having possibly modified the glyph positioning information.</p><p id="introtext">This is functionality that was previously available on Mac OS 9 through a combination of special TrueType scaler calls or calls to APIs exported by Adobe&reg; Type Manager. Neither of these API sets are available to native OS X applications. By calling these ATSUI low-level APIs, you can use one API set for both TrueType and Type 1 fonts, and your code can run both on CarbonLib and native on OS X. </p><!-- end_intro_text --><!-- begin_date --><h3 align=center>[Nov 26 2001]</h3> <!-- end_date --></td></tr></table><!-- end_table_box --><br><br><hr width=500 align=center><br><br><!-- begin_content --><a name="Glyphs"></a> <h2> Getting Glyph Information </h2> <p>Getting the glyph information from an <code>ATSUTextLayout</code> is the starting point for all of the APIs described in this document. You need the glyph information in order to call all of the other APIs. </p><p>Even if you don't need information on individual glyph properties, having the glyph information allows you to reposition the glyphs before drawing them. You can draw text in ways ATSUI doesn't support directly, such as drawing text along a curve. </p><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>To draw text along a curve, you must obtain and draw the glyphs in small groups. If you are handling arbitrary Unicode text, you need to determine what those groups are while being sensitive to international issues. For example, Arabic is a cursive script, and breaking in the middle of a ligature or between two cursively connected glyphs will result in an incorrect appearance in your output.</P></TD></TR></TABLE></CENTER><BR><p>The API function <code>ATSUGetGlyphInfo</code> returns the following information about each glyph in the range you specify: </p><ul><li>The <code>ATSUStyle</code> associated with the glyph. <BR><BR></li><li>The ID of the glyph within the font specified by the <code>ATSUStyle</code>.  <BR><BR></li><li>The offset of the character in the original text with which this glyph is associated.  <BR><BR></li><li>The cross-stream shift (if any) of the glyph.  <BR><BR></li><li>The x offset in ideal (resolution-independent) coordinates from the beginning of the line the glyph is on.  <BR><BR></li><li>The x offset in screen (resolution-dependent) coordinates of the original of the glyph relative to the beginning of the line the glyph is on.  <BR><BR></li><li>The x offset in screen (resolution-dependent) coordinates from the beginning of the line where a leading caret for this glyph crosses the baseline.  <BR><BR></li><li>Additional fields whose contents are currently reserved by Apple.  <BR><BR></li></ul><p>It's important to note that the relationship between the original Unicode characters in the <code>ATSUTextLayout</code> and the glyphs returned by <code>ATSUGetGlyphInfo</code> is not necessarily one to one, and can often be quite complicated. Even the simple accented latin character &eacute; can be represented by an e with a combining &acute; accent. In this case, two characters map to one glyph. </p><p>Common ligatures such as &#64257; also form automatically for some fonts, causing two characters to map to one glyph. Right-to-left scripts such as Arabic, and complex scripts such as Devanagari or Thai have even more complicated mappings from characters to glyphs. Assuming a one to one mapping between characters and glyphs will make it incompatible with such languages, and perhaps not even compatible with European languages and Japanese in some cases. </p><p>For this reason it's best to use the high level ATSUI APIs whenever possible, and to let ATSUI lay out an entire paragraph of text at a time. Your application is then completely insulated from such issues. </p><p>Here is a code snippet for fetching the glyph information associated with the first glyph of an <code>ATSUTextLayout</code>. For details on the API, including how to draw a possibly modified <code>ATSUGlyphInfoArray</code>, see the API reference at the end of this document. </p><center><table border="0" cellpadding="0" width="480"><tr><td align="left" scope="row"><p>&nbsp;<b>Listing 1</b>. Retrieving glyph information. </p><table border="0" cellpadding="5" width="470"><tr><td bgcolor="#E6E6E6" align=left><pre>                           &nbsp;char giaBuffer[128];&nbsp;ByteCount giabc = 128;ATSUGlyphInfoArray *gia = (ATSUGlyphInfoArray *)giaBuffer;status = ATSUGetGlyphInfo(atsuLayout, 0, 1, &amp;giabc, gia);</pre> </td></tr></table><br></td></tr></table></center><p><a name="Outlines"></a> </p><p><a href="#top">Back to top</a></p><h2> Retrieving Glyph Outlines </h2> <p>One of the things you can do with a glyph when you know both its ID and the font it came from is to retrieve the curves that make up the shape of the glyph, known as the glyph outlines. ATSUI provides several APIs to assist in this. Using these APIs, you can: </p><ul><li>Determine the native curve type of the font in question. TrueType fonts use quadratic curves, and Type 1 (PostScript) fonts use cubic curves. Use <code>ATSUGetNativeCurveType</code> for this.  <BR><BR></li><li>Retrieve the curves making up one glyph's shape by passing in callback functions which get called for each segment of the curves and lines making up the glyph's shape.  <BR><BR></li><li>Retrieve raw quadratic curve data from a TrueType font or a Type 1 font (Type 1 cubic curves will have been converted to quadratic form).  <BR><BR></li></ul><p>There are two APIs for retrieving curves via callback, <code>ATSUGetQuadraticGlyphPaths</code> and <code>ATSUGetCubicGlyphPaths</code>. You can call <code>ATSUGetQuadraticGlyphPaths</code> even for a font whose native curve type is cubic, and you can call <code>ATSUGetCubicGlyphPaths</code> for a font whose native curve type is quadratic. In each case, the font's curves are converted to the desired format. </p><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>As of Mac OS X 10.1, all curves pass through a quadratic form before being returned to the caller. It is not possible to retrieve the cubic curves directly without passing through this intermediate conversion. </P></TD></TR></TABLE></CENTER><BR><p>When retrieving quadratic paths, the callbacks used are for: </p><ul><li>The start of a new path.  <BR><BR></li><li>Each line in a path, giving its start and end points.  <BR><BR></li><li>Each quadratic curve in a path, giving its start point, end point, and off-curve control point.  <BR><BR></li><li>The end of the currently open path.  <BR><BR></li></ul><p>When retrieving cubic paths, the callbacks used are for: </p><ul><li>Each move of the pen position to a new location.  <BR><BR></li><li>Each line from the current pen position to an ending position.  <BR><BR></li><li>Each curve from the current pen position to an ending position, with two off-curve control points.  <BR><BR></li><li>The end of the currently open path.  <BR><BR></li></ul><p>Note that for cubic paths, the starting position for each curve or line is implicit from the current pen position. The start of a path is also implicit, and will be signalled by the initial move to establish the initial pen position. </p><p>Also note that the curves returned are the ones modified by hints present in the font. If you need unhinted outlines, use a very large point size (e.g., 1000 points), and scale the resultant curves down. Alternatively, you can set the <code>ATSUStyleRenderngOptions</code> of the <code>ATSUStyle</code> to zero. </p><p>The coordinates returned for the curves and lines are in QuickDraw coordinates, with the y axis pointing down. </p><p>See the API reference at the end of this document for further details. </p><p><a name="Metrics"></a> </p><p><a href="#top">Back to top</a></p><h2> Retrieving Glyph Metrics </h2> <p>ATSUI lets you retrieve both the ideal (resolution-independent) and screen (resolution-dependent) metrics for a glyph. </p><p>For the ideal metrics, ATSUI returns: </p><ul><li>The advance of the glyph (the amount by which the pen is advanced after drawing the glyph).  <BR><BR></li><li>The side bearing of the glyph. This is the offset from the glyph origin to the beginning of the glyph image. <BR><BR></li><li>The other side bearing of the glyph. This is the offset from the end of the glyph image to the end of the glyph advance. <BR><BR></li></ul><p>For the screen metrics, ATSUI returns: </p><ul><li>The device advance. This is the number of pixels of the advance for the glyph as actually drawn on the screen. <BR><BR></li><li>The top left point of the glyph in device coordinates. <BR><BR></li><li>The height and width of the glyph in pixels. Note that glyphs may possibly overlap when drawn. <BR><BR></li><li>The side bearing and other side bearing in pixels. <BR><BR></li></ul><p>For further details, see the API reference below. </p><p><a name="DataReference"></a> </p><p><a href="#top">Back to top</a></p><h2> Data Type Reference </h2> <h3>Data Types and Constants </h3> <p>These new APIs make use of the following constants and data types: </p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>/* Glyph outline path constants used in ATSUGetNativeCurveType */enum { kATSCubicCurveType = 0x0001,       kATSQuadCurveType = 0x0002,       kATSOtherCurveType = 0x0003     };typedef UInt16 GlyphID;typedef UInt16 ATSCurveType;struct ATSGlyphIdealMetrics {        /* used with API routine ATSGetGlyphIdealMetrics */        Float32Point advance;        Float32Point sideBearing;        Float32Point otherSideBearing;        };struct ATSGlyphScreenMetrics {        /* used with API routine ATSGetGlyphScreenMetrics */        Float32Point deviceAdvance;        Float32Point topLeft;        UInt32 height;        UInt32 width;        Float32Point sideBearing;        Float32Point otherSideBearing;        };</pre>	</TD></TR></TABLE></CENTER> <h3> ATSUGetQuadraticGlyphPaths callbacks </h3> <p>For quadratic curves, pt1 is the starting point, pt2 is the ending point, and controlPt is the off-curve control point. In <a href="http://fonts.apple.com/TTRefMan/RM01/Chap1.html">Chapter 1 of the TrueType reference manual</a>, these are referred to as p0, p2, and p1 respectively. For both curves and lines, the starting point is passed explicitly to the callback function. Moves are implicit; there is no <code>MoveTo</code> callback. </p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>typedef CALLBACK_API( OSStatus , ATSQuadraticNewPathProcPtr )    (void *callBackDataPtr);typedef CALLBACK_API( OSStatus , ATSQuadraticLineProcPtr )    (const Float32Point *pt1, const Float32Point *pt2, void *callBackDataPtr);typedef CALLBACK_API( OSStatus , ATSQuadraticCurveProcPtr )    (const Float32Point *pt1, const Float32Point *controlPt,     const Float32Point *pt2, void *callBackDataPtr);typedef CALLBACK_API( OSStatus , ATSQuadraticClosePathProcPtr )    (void *callBackDataPtr);</pre>	</TD></TR></TABLE></CENTER> <h3> ATSUGetCubicGlyphPaths callbacks </h3> <p>For cubic curves, the points are defined as in the PostScript Language Reference Manual. p0, the starting point, is implicit from the current pen position. p3 is the ending point; p1 and p2 are the off-curve control points. For both curves and lines, the starting point is implicit; there is an explicit <code>MoveTo</code> callback to move the pen. Conversely, there is no <code>NewPath</code> callback for the cubic case. </p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>typedef CALLBACK_API( OSStatus , ATSCubicMoveToProcPtr )    (const Float32Point *pt, void *callBackDataPtr);typedef CALLBACK_API( OSStatus , ATSCubicLineToProcPtr )    (const Float32Point *pt, void *callBackDataPtr);typedef CALLBACK_API( OSStatus , ATSCubicCurveToProcPtr )    (const Float32Point *pt1, const Float32Point *pt2,     const Float32Point *pt3, void *callBackDataPtr);typedef CALLBACK_API( OSStatus , ATSCubicClosePathProcPtr )    (void *callBackDataPtr);struct Float32Point {    Float32 x;    Float32 y;};</pre>	</TD></TR></TABLE></CENTER> <BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR><code>Float32Point</code> is defined in MacTypes.h </P></TD></TR></TABLE></CENTER><BR><p>The following data structures are used to return glyph outlines. The format of the data is the same as that in the glyph table of a TrueType font; this is documented in <a href="http://fonts.apple.com/TTRefMan/RM06/Chap6glyf.html">chapter 6 of the TrueType Reference Manual</a>. The data is modified as follows before being returned to the caller: the control bits are padded to an integral number of longs, and all coordinates are converted from fixed to floating point. See the TrueType reference manual for further details. </p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>struct ATSUCurvePath {    UInt32 vectors;    UInt32 controlBits[1];    Float32Point vector[1];};&nbsp;struct ATSUCurvePaths {    UInt32 contours;    ATSUCurvePath contour[1];};</pre>	</TD></TR></TABLE></CENTER> <p>The following data structures are used to return the glyph information associated with an <code>ATSUTextLayout</code>. For each glyph, the following information is returned: the 16 bit glyph identifier (unique to the associated font), the reserved fields "reserved" and "layoutFlags," the index of the character in the associated Unicode character stream from which this glyph is derived, the <code>ATSUStyle</code> used for this glyph, any cross-stream shift for the glyph, its ideal with-stream offset from the origin of this layout, its device-adjusted with-stream offset from the origin of this layout, and the position in device coordinates where a trailing caret for this glyph would intersect the baseline. </p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>struct ATSUGlyphInfo {    GlyphID glyphID;    UInt16 reserved;    UInt32 layoutFlags;    UniCharArrayOffset charIndex;    ATSUStyle style;    Float32 deltaY;    Float32 idealX;    SInt16 screenX;    SInt16 caretX;};struct ATSUGlyphInfoArray {    ItemCount numGlyphs;    ATSUTextLayout layout;    ATSUGlyphInfo glyphs[1];};</pre>	</TD></TR></TABLE></CENTER> <p><a name="APIReference"></a> </p><p><a href="#top">Back to top</a></p><h2>API Reference </h2> <h3> Metrics </h3> <h4> ATSUGlyphGetIdealMetrics </h4> <CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>OSStatus ATSUGlyphGetIdealMetrics (    ATSUStyle iATSUStyle,    ItemCount iNumOfGlyphs,    GlyphID * iGlyphIDs,    Sint32 iInputOffset,    ATSGlyphIdealMetrics * oIdealMetrics );</pre>	</TD></TR></TABLE></CENTER> <p>This function is used to get the ideal metrics of glyphs specified by the array of input <code>glyphIDs</code> and an <code>ATSUStyle</code>. The ideal metrics are derived from the glyph outlines and specific style attributes such as the font, point size, and verticality. Since you can pass only a single style, at most one style run can be handled per call. <code>oIdealMetrics</code> must have been previously allocated by the caller to contain the requested number of returned metrics. </p><p>If vertical metrics are needed, set <code>kATSUVerticalCharacterTag</code> in the <code>ATSUStyle</code>. </p><h5>Input Parameters</h5> <table><tr valign="baseline"><td nowrap align=left><P><code>ATSUStyle iATSUStyle</code></p></td><td align="left"><P>The opaque ATSUI style object, needed to specify the font and other information that can affect the metrics. </p></td></tr><tr valign="baseline"><td nowrap align=left><P><code>ItemCount iNumOfGlyphs</code></p></td><td align="left"><P>The number of glyph metrics requested and hence the number of <code>glyphIDs</code> provided as input. </p></td></tr><tr valign="baseline"><td nowrap align=left><P><code>GlyphID *iGlyphIDs</code></p></td><td align="left"><P>The address of the first element of an array of <code>glyphID</code> values whose metrics are desired. </p></td></tr><tr valign="baseline"><td nowrap align=left><P><code>Sint32 iInputOffset</code></p></td><td align="left"><P>The number of bytes for <code>ATSGetGlyphFractionalMetrics</code> to increment or decrement to find each successive <code>glyphID</code> provided as input starting at <code>iGlyphIDs</code>. This is useful when the <code>glyphIDs</code> are imbedded in an array of data structures. If you are passing in just an array of <code>glyphIDs</code>, set this to <code>sizeof(GlyphID)</code>. </p></td></tr></table><h5> Output Parameters </h5> <table><tr valign="baseline"><td nowrap align=left><P><code>ATSGlyphIdealMetrics *oIdealMetrics</code></p></td><td align="left"><P>The pointer to the caller supplied allocated block of memory filled with the requested number of metrics. </p></td></tr></table><h5> Return Values </h5> <table><tr valign="baseline"><td nowrap align=left><P><code>noErr</code></p></td><td align="left"><P>success</p></td></tr><tr valign="baseline"><td nowrap align=left><P><code>paramErr</code></p></td><td align="left"><P><code>oIdealMetrics</code> and <code>iGlyphIDs</code> must not be NULL. </p></td></tr><tr valign="baseline"><td align="left"><P>Memory manager errors</p></td></tr></table><h4>ATSUGetNativeCurveType</h4> <CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>OSStatus ATSUGetNativeCurveType(    ATSUStyle iATSUStyle,    CurveType * oCurveType);</pre>	</TD></TR></TABLE></CENTER> <p>This function is used to get the native curve type of the font referred to by the <code>ATSUStyle</code> - cubic or quadratic. </p><h5> Input Parameters </h5> <table><tr valign="baseline"><td nowrap align=left><P><code>ATSUStyle iATSUStyle</code></p></td><td align="left"><P>The opaque ATSUI style object.</p></td></tr></table><h5> Output Parameters </h5> <table><tr valign="baseline"><td nowrap align=left><P><code>CurveType * oCurveType</code></p></td><td align="left"><P>The format in which the curves of the selected font are stored - cubic or quadratic.</p></td></tr></table><h3> Glyph Paths </h3> <h4> ATSUGlyphGetCubicPaths &amp; ATSUGlyphGetQuadraticPaths </h4> <CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>OSStatus ATSUGlyphGetCubicPaths(ATSUStyle iATSUStyle,GlyphID iGlyphID,ATSCubicMoveToUPP iMoveToProc,ATSCubicLineToUPP iLineToProc,ATSCubicCurveToUPP iCurveToProc,ATSCubicClosePathUPP iClosePathProc,void *iCallBackDataPtr,OSStatus *oCallBackResult);</pre>	</TD></TR></TABLE></CENTER> <p>This function returns the cubic outline paths for a single glyph via callback functions. The outlines that are returned are the hinted outlines at the size specified; to obtain the effect of unhinted outlines, request a very large size (e.g., 1000 points) and scale the curves back down to the desired size. </p><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>As of Mac OS X 10.1, the curves returned by this function are derived from quadratic curves, irrespective of the native curve type of the font. </p></TD></TR></TABLE></CENTER><BR><p>Some fonts restrict access to their glyph paths; in that case, <code>ATSUGlyphGetCubicPaths</code> will return the error code <code>kATSNotPublicOutlinesErr</code>. </p><h5> Input Parameters </h5> <table><tr valign="baseline"><td nowrap align=left><P><code>ATSUStyle iATSUStyle</code></p></td><td align="left"><P>The opaque ATSUI style object. </p></td></tr><tr valign="baseline"><td nowrap align=left><P><code>GlyphID iGlyphID</code></p></td><td align="left"><P>The <code>glyphID</code> for which to retrieve outline data. This must be a valid glyph in the font specified by <code>iATSUStyle</code>. </p></td></tr><tr valign="baseline"><td nowrap align=left><P><code>ATSCubicMoveToUPP iMoveToProc</code></p></td><td align="left"><P>The pointer to a function that will handle pen movement. </p></td></tr><tr valign="baseline"><td nowrap align=left><P><code>ATSCubicLineToUPP iLineToProc</code></p></td><td align="left"><P>The pointer to a function that will handle the LineTo operation. </p></td></tr><tr valign="baseline"><td nowrap align=left><P><code>ATSCubicCurveToUPP iCurveToProc</code></p></td><td align="left"><P>The pointer to a function that will handle the <code>CurveTo</code> operation. </p></td></tr><tr valign="baseline"><td nowrap align=left><P><code>ATSCubicClosePathUPP iClosePathProc</code></p></td><td align="left"><P>The pointer to a function that will handle the <code>ClosePath</code> operation. </p></td></tr><tr valign="baseline"><td nowrap align=left><P><code>void *iCallBackDataPtr</code></p></td><td align="left"><P>This pointer is passed through to callback functions. The caller can use this pointer to pass data to the functions. </p></td></tr></table><h5> Output Parameters </h5> <table><tr valign="baseline"><td nowrap align=left><P><code>OSStatus * oCallBackResult</code></p></td><td align="left"><P>When a callback function returns a non-zero result, <code>ATSGlyphGetCubicPaths</code> stops parsing the path and returns the result <code>kATSOutlineParseAbortedErr</code>; the value returned by the callback is returned in <code>oCallBackResult</code>. </p></td></tr></table><h5> Return Values </h5> <table><tr valign="baseline"><td nowrap align=left><P><code>noErr</code></p></td><td align="left"><P>success </p></td></tr><tr valign="baseline"><td nowrap align=left><P><code>paramErr</code></p></td><td align="left"><P><code>iATSUStyle</code> must be a pointer to a valid <code>ATSUStyle ATSUStyle</code>. The <code>iGlyphID</code> must be valid. </p></td></tr><tr valign="baseline"><td nowrap align=left><P>Memory manager errors </p></td></tr></table><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>OSStatus ATSUGlyphGetQuadraticPaths(    ATSUStyle iATSUStyle,    GlyphID iGlyphID,    ATSQuadraticNewPathUPP iNewPathProc,    ATSQuadraticLineUPP iLineToProc,    ATSQuadraticCurveUPP iCurveToProc,    ATSQuadraticClosePathUPP iClosePathProc,    void *iCallBackDataPtr,    OSStatus *oCallBackResult);</pre>	</TD></TR></TABLE></CENTER> <p>This function returns the quadratic outline paths for a single glyph via callback functions. The outlines that are returned are the hinted outlines at the size specified; to obtain the effect of unhinted outlines, request a very large size (e.g., 1000 points) and scale the curves back down to the desired size. </p><p>Some fonts restrict access to their glyph paths; in that case, <code>ATSGlyphGetQuadraticPaths</code> will return the error code <code>kATSNotPublicOutlinesErr</code>. </p><h5> Input Parameters </h5> <table><tr valign="baseline"><td nowrap align=left><P><code>ATSUStyle iATSUStyle</code></p></td><td align="left"><P>The opaque ATSUI style object. </p></td></tr><tr valign="baseline"><td nowrap align=left><P><code>GlyphID iGlyphID</code></p></td><td align="left"><P>The <code>glyphID</code> for which to retrieve outline data. This must be a valid glyph in the font specified by <code>iATSUStyle</code>. </p></td></tr><tr valign="baseline"><td nowrap align=left><P><code>ATSQuadraticNewPathUPP iNewPathProc</code></p></td><td align="left"><P>The pointer to a function that will handle the <code>NewPath</code> operation. </p></td></tr><tr valign="baseline"><td nowrap align=left><P><code>ATSQuadraticLineUPP iLineToProc</code></p></td><td align="left"><P>The pointer to a function that will handle the <code>LineTo</code> operation. </p></td></tr><tr valign="baseline"><td nowrap align=left><P><code>ATSQuadraticCurveUPP iCurveToProc</code></p></td><td align="left"><P>The pointer to a function that will handle the <code>CurveTo</code> operation. </p></td></tr><tr valign="baseline"><td nowrap align=left><P><code>ATSQuadraticClosePathUPP iClosePathProc</code></p></td><td align="left"><P>The pointer to a function that will handle the <code>ClosePath</code> operation. </p></td></tr><tr valign="baseline"><td nowrap align=left><P><code>void *iCallBackDataPtr</code></p></td><td align="left"><P>This pointer is passed through to callback functions. The caller can use this pointer to pass data to the functions. </p></td></tr></table><h5> Output Parameters </h5> <table><tr valign="baseline"><td nowrap align=left><P><code>OSStatus * oCallBackResult</code></p></td><td align="left"><P>When a callback function returns a non-zero result, <code>ATSGlyphGetQuadraticPaths</code> stops parsing the path and returns the result <code>kATSOutlineParseAbortedErr</code>; the value returned by the callback is returned in <code>oCallBackResult</code>. </p></td></tr></table><h5> Return Values </h5> <table><tr valign="baseline"><td nowrap align=left><P><code>noErr</code></p></td><td align="left"><P>success </p></td></tr><tr valign="baseline"><td nowrap align=left><P><code>paramErr</code></p></td><td align="left"><P><code>iATSUStyle</code> must be a pointer to a valid <code>ATSUStyle ATSUStyle</code>. The <code>iGlyphID</code> must be valid. </p></td></tr><tr valign="baseline"><td nowrap align=left><P>Memory manager errors </p></td></tr></table><h4> ATSUGlyphGetCurvePaths </h4> <CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>OSStatus ATSUGlyphGetCurvePaths (    ATSUStyle iATSUStyle,    GlyphID iGlyphID,    ByteCount *ioBufferSize,    ATSUCurvePaths *oPaths);</pre>	</TD></TR></TABLE></CENTER> <p>This function returns the outline paths for a single glyph via data structures. The outlines that are returned are the hinted outlines at the size specified; to obtain the effect of unhinted outlines, request a very large size (e.g., 1000 points) and scale the curves back down to the desired size. </p><p>This function will only return quadratic paths. Apple recommends that you use the callback APIs, <code>ATSUGlyphGetCubicPaths</code> and <code>ATSUGlyphGetQuadraticPaths</code>, if possible. </p><p>Some fonts restrict access to their glyph paths; in that case, <code>ATSUGetCurvePaths</code> will return the error code <code>kATSNotPublicOutlinesErr</code> and NULL for oPaths. </p><h5> Input Parameters </h5> <table><tr valign="baseline"><td nowrap align=left><P><code>ATSUStyle iATSUStyle</code></p></td><td align="left"><P>The opaque ATSUI style object. </p></td></tr><tr valign="baseline"><td nowrap align=left><P><code>GlyphID iGlyphID</code></p></td><td align="left"><P>The <code>glyphID</code> for which to retrieve outline data. This must be a valid glyph in the font specified by <code>iATSUStyle</code>. </p></td></tr><tr valign="baseline"><td nowrap align=left><P><code>ByteCount *ioBufferSize</code></p></td><td align="left"><P>If <code>oPaths</code> is NULL, on output this parameter will contain the size of the buffer that would need to be allocated. If <code>oPaths</code> is not NULL, on input this is the maximum size of the passed in <code>ATSUCurvePaths</code> struct array; on output the actual size used. </p></td></tr><tr valign="baseline"><td nowrap align=left><P><code>ATSUCurvePaths oPaths</code></p></td><td align="left"><P>The glyph paths. </p></td></tr></table><h5> Return Values </h5> <table><tr valign="baseline"><td nowrap align=left><P><code>noErr</code></p></td><td align="left"><P>success </p></td></tr><tr valign="baseline"><td nowrap align=left><P><code>paramErr</code></p></td><td align="left"><P>the <code>ioBufferSize</code> must not be NULL. <code>iATSUStyle</code> must be a valid <code>ATSUStyle</code>. The <code>iGlyphID</code> must be a valid <code>glyphID</code> for the font selected by the <code>ATSUStyle</code>. </p></td></tr><tr valign="baseline"><td nowrap align=left><P>Memory manager errors </p></td></tr></table><h3> Glyph Data Access </h3> <h4> ATSUGetGlyphInfo </h4> <CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>OSStatus ATSUGetGlyphInfo(    ATSUTextLayout iTextLayout,    UniCharArrayOffset iLineStart,    UniCharCount iLineLength,    ByteCount *ioBufferSize,    ATSGlyphInfoArray *oGlyphInfoPtr );</pre>	</TD></TR></TABLE></CENTER> <p>This function returns the glyph information from an <code>ATSUTextLayout</code>. The data is a copy of the internal information used by ATSUI, and can be modified. However, if you are going to use this <code>ATSGlyphInfoArray</code> when calling <code>ATSUIDrawGlyphInfo</code>, changing any information other than the following can cause undefined behavior when you attempt to draw: deltaY, idealX, screenX, caretX. </p><p>You should not change or dispose of the <code>ATSUTextLayout</code> associated with the returned glyph information until you are done with that glyph information. </p><h5> Input Parameters </h5> <table><tr valign="baseline"><td nowrap align=left><P><code>ATSUTextLayout iTextLayout</code></p></td><td align="left"><P>The opaque ATSUI text layout object. </p></td></tr><tr valign="baseline"><td nowrap align=left><P><code>UniCharArrayOffset iLineStart</code></p></td><td align="left"><P>The offset of the first Unicode character to get glyph data from. </p></td></tr><tr valign="baseline"><td nowrap align=left><P><code>UniCharCount iLineLength</code></p></td><td align="left"><P>Number of Unicode characters to get glyph data from. </p></td></tr><tr valign="baseline"><td nowrap align=left><P><code>ByteCount *ioBufferSize</code></p></td><td align="left"><P>If <code>oGlyphInfoPtr</code> is NULL, on output this parameter will contain the size of the buffer that needs to be allocated. As input, the size of the passed in <code>ATSGlyphInfoArray</code> struct, as output the actual size of <code>oGlyphInfoPtr</code>. </p></td></tr><tr valign="baseline"><td nowrap align=left><P><code>ATSGlyphInfoArray oGlyphInfoPtr</code></p></td><td align="left"><P>Pointer to the glyph info array for output. </p></td></tr></table><h5> Return Values </h5> <table><tr valign="baseline"><td nowrap align=left><P><code>noErr</code></p></td><td align="left"><P>success </p></td></tr><tr valign="baseline"><td nowrap align=left><P><code>paramErr</code></p></td><td align="left"><P><code>ioBufferSize</code> must not be NULL. <code>iTextLayout</code> must be a pointer to a valid <code>ATSUTextLayout</code>. </p></td></tr><tr valign="baseline"><td nowrap align=left><P>Memory manager errors </p></td></tr></table><h4> ATSUDrawGlyphInfo </h4> <CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>OSStatus ATSUDrawGlyphInfo(    ATSGlyphInfoArray *iGlyphInfoArray,    Float32Point iLocation);</pre>	</TD></TR></TABLE></CENTER> <p>This function is used to draw the glyphs in an <code>ATSGlyphInfoArray</code>. If the caller has modified data in <code>iGlyphInfoArray</code> other than the following, the results are undefined: deltaY, idealX, screenX, caretX. </p><h5> Input Parameters </h5> <table><tr valign="baseline"><td nowrap align=left><P><code>ATSGlyphInfoArray iGlyphInfoArray</code></p></td><td align="left"><P>Pointer to the glyph info data </p></td></tr><tr valign="baseline"><td nowrap align=left><P><code>Float32Point iLocation</code></p></td><td align="left"><P>The location in the current graphics environment at which to begin drawing all the glyphs in the glyph info array. </p></td></tr></table><h5> Return Values </h5> <table><tr valign="baseline"><td nowrap align=left><P><code>noErr</code></p></td><td align="left"><P>success </p></td></tr><tr valign="baseline"><td nowrap align=left><P><code>paramErr</code></p></td><td align="left"><P>the <code>iGlyphInfoArray</code> must not be NULL. </p></td></tr><tr valign="baseline"><td nowrap align=left><P>Memory manager errors </p></td></tr></table><h3> Device Specific Routines </h3> <h4> ATSUGlyphGetScreenMetrics </h4> <CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>OSStatus ATSUGlyphGetScreenMetrics (    ATSUStyle iATSUStyle,    ItemCount iNumOfGlyphs,    GlyphID * iGlyphIDs,    Sint32 iInputOffset,    ATSGlyphScreenMetrics * oScreenMetrics );</pre>	</TD></TR></TABLE></CENTER> <p>This function is used to get the screen metrics of glyphs specified by an array of input <code>glyphIDs</code> and an <code>ATSUStyle</code>. The screen metrics are derived from the supplied style's font scaler's calculations based on the current QuickDraw grafPort's resolution and bit-depth, whether anti-aliasing is set for the style's point size, the style transform, and other set style attributes. Since there is only a single style input, only a single style run can be measured with each call. </p><p>Screen metrics are useful when you are working at the level of pixels, e.g., if you need to know exactly how many pixels a particular glyph will occupy. </p><p><code>oScreenMetrics</code> must have been previously allocated by the caller to contain the requested number of returned metrics. </p><h5> Input Parameters </h5> <table><tr valign="baseline"><td nowrap align=left><P><code>ATSUStyle iATSUStyle</code></p></td><td align="left"><P>The ATSUI opaque style. </p></td></tr><tr valign="baseline"><td nowrap align=left><P><code>ItemCount iNumOfGlyphs</code></p></td><td align="left"><P>The number of glyph metrics requested and hence the number of <code>glyphIDs</code> provided as input. </p></td></tr><tr valign="baseline"><td nowrap align=left><P><code>GlyphID *iGlyphIDs</code></p></td><td align="left"><P>The address to the first <code>glyphID</code> for <code>ATSGetGlyphRenderingMetrics</code> to access its metrics. </p></td></tr><tr valign="baseline"><td nowrap align=left><P><code>Sint32 iInputOffset</code></p></td><td align="left"><P>The number of bytes for <code>ATSGetGlyphRenderingMetrics</code> to increment or decrement to find each successive <code>glyphID</code> provided as input starting at <code>iGlyphIDs</code>. </p></td></tr></table><h5> Output Parameters </h5> <table><tr valign="baseline"><td nowrap align=left><P><code>ATSGlyphScreenMetrics *oScreenMetrics</code></p></td><td align="left"><P>The pointer to the caller supplied allocated block of memory filled with the requested number of metrics. </p></td></tr></table><h5> Return Values </h5> <table><tr valign="baseline"><td nowrap align=left><P><code>noErr</code></p></td><td align="left"><P>success </p></td></tr><tr valign="baseline"><td nowrap align=left><P><code>paramErr</code></p></td><td align="left"><P>the <code>oScreenMetrics</code> and <code>iGlyphIDs</code> must not be NULL. </p></td></tr><tr valign="baseline"><td nowrap align=left><P>Memory manager errors </p></td></tr></table><p><a href="#top">Back to top</a></p> <P><A NAME=Downloads></A></P>                  <H2>Downloadables</H2>                  <TABLE BORDER=0 CELLPADDING=3 WIDTH="100%">            <TR>               <td width=50 align=left>                  <P ALIGN=center><img src="images/acrobatsmall.gif" width=22 height=23 align=middle alt="Acrobat gif"></P>               </TD>               <td align="left">                  <P>Acrobat version of this Note (56K)</P>               </TD>               <td width=60 align=left>                  <P><A HREF="pdf/tn2033.pdf">Download</A></P>               </TD>            </TR>         </TABLE>         <BR>                  <P><A HREF="#top">Back to top</A></P></TD></TR></TABLE></CENTER><!-- end_content --><!-- begin_footer_information -->	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/technotes/tn/tn2033.html%3Fid%3DDTS10003070-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/technotes/tn/tn2033.html%3Fid%3DDTS10003070-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/technotes/tn/tn2033.html%3Fid%3DDTS10003070-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>
<!--#include virtual="/includes/footer"--><!-- end_footer_information --></BODY></HTML>