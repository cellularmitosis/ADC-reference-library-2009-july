<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"			"http://www.w3.org/TR/REC-html40/loose.dtd"><html><head><LINK REL="stylesheet" HREF="../../adcstyle.css" TYPE="text/css"><LINK REL="stylesheet" HREF="../../style.css" TYPE="text/css"><title>Technical Note QD05: Displaying Large PICT Files</title><meta name="keywords" content="Mac OS 8 Quickdraw PICT displaying large files resource"><meta name="Description" content="Technical Note QD05: This Technical Note explains how todispaly a PICT format object that is bigger than a PICT resourceis allowed to be. Included is a small code fragment hat demonstrateshow to spool in a picture from [the data fork of] a PICTfile.">                                       <meta name="categories" content="QuickDraw"><meta name="week-posted" content="Jun 29, 1987 - Jul 3, 1987"><LINK REL="stylesheet" HREF="../../css/adcstyle.css" TYPE="text/css"><script language="JavaScript" type="text/javascript" src="../../js/adc.js"></script></HEAD><BODY BGCOLOR="#FFFFFF"><a name="//apple_ref/doc/uid/DTS10002718" title="Displaying Large PICT Files"></a><a name="top"></A><!-- top_of_header_marker_comment --><!-- begin_header_information --><!--#include virtual="/adcnavbar" --><p><a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../technicalnotes/index.html">Technical Notes</a> &gt; <a href="../../technicalnotes/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../technicalnotes/LegacyTechnologies/idxCarbon-date.html">Carbon</a> &gt; </p><div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/Carbon/idxGraphicsImaging-date.html" target="_blank">Carbon > Graphics & Imaging</a></li>
	</ul>
</div>




</div></div></div><!-- end_header_information --><!-- bottom_of_header_marker_comment --><!-- top_of_titles_marker_comment --><CENTER><table width="600" cellpadding="0" cellspacing="0" border="0">
<tr><td align="left" scope="row">
<h1>
<div id="pagehead">Technical Note QD05</div>
<div id="pageheadsub">Displaying Large PICT Files</div>
</h1>
</td></tr></table></CENTER><!-- bottom_of_titles_marker_comment --><CENTER><TABLE BORDER=0 CELLSPACING=1 WIDTH=600><TR><td align="left"><!-- begin_header_box --><table width="600" cellpadding="0" cellspacing="0" border="0">    <tr>        <td width=300 valign="top" align=left scope="row">            <table border="0" width="300" cellpadding="0" cellspacing="0">			<tr>                        <td width=300 align=left> <img src="images/tnmenutop.gif" alt="" align="bottom" width=300 height=7></td>                </tr>                <tr bgcolor="#e6e6e6">                    <td background="images/tnmenubody.gif" width=300 align=left>                                         <span id="menutitle">                            CONTENTS                             <br>                            <br>                        </span>                    </td>                </tr>                <tr bgcolor="#e6e6e6">                    <td background="images/tnmenubody.gif" width=300 align=left>					<!-- begin_toc -->										<p id="menutext"><A HREF="#Section1">Future Compatibility</A><BR><BR><A HREF="#Section2">Spooling from a PICT file</A><BR><BR><A HREF="#Section3">MPW Pascal Example</A><BR><BR><A HREF="#Section4">MPW C Example</A><BR><BR><A HREF="#Section5">More on Picture Compatibility</A><BR><BR><A HREF="#References">References</A><BR><BR><A HREF="#Downloads">Downloadables</A></P>                   <!-- end_toc -->                  </td>                </tr>                <tr>                    <td width=300 align=left scope="row">                        <img src="images/tnmenubottom.gif" alt="" width=300 height=16>                    </td>                </tr>            </table>        </td>        <td width=300 valign="top" align=left><!-- begin_intro_text --><p id="introtext">Now that we have scanners and other massive-picture producing types ofapplications, there is a need to address the problem of how to display a PICTformat object that is bigger than a current PICT resource is allowed to be.Note that this technique applies equally well to version 1 and version 2(word-opcode) pictures as produced by the Macintosh II.   </p><!-- end_intro_text --><!-- begin_date --><h3 align=center>[Jul 01 1987]</h3><!-- end_date -->                </TD>             </TR>          </TABLE>          <!-- end_table_box --> <BR><BR>          <hr width=500 align=center>          <BR><BR>          <!-- begin_content --><a name=Section1></A><H2>Future Compatibility</h2><p>Think of the handle returned by a <code>GetResource('PICT',ID)</code> as a "handle"in the more general sense of being an abstract "tag"--something that the ROMroutines can use to draw the picture with. Don't assume that the entire picturehas been read into memory or that you can directly read any bytes beyond thebasic <code>Picture</code> record structure (<code>picSize</code> followed by<code>picFrame</code>). Someday we may provide a mechanism for the resource to bedisk- instead of memory-based. The QuickDraw bottleneck procedures will knowhow to get data from and put data into the pictures in any case.</p><a name="Section2"></a><P><A HREF="#top">Back to top</A></p><H2>Spooling from a PICT file</h2><p>In order to display pictures of arbitrary size, your application should be ableto import a QuickDraw picture from a file of type PICT. This is the file produced by a "Save as..." from MacDraw with the PICT option selected.</p><p>What follows is a small program fragment that demonstrates how to spool in apicture from [the data fork of] a PICT file. The picture can be larger than thehistorical 32K resource size. See technical note #88 if you are unfamiliar withthe <code>Signal</code> mechanism. We assume that a <code>CatchSignals</code> has beendone before <code>GetandDrawPICTFile</code> is called.</p><a name="Section3"></a><P><A HREF="#top">Back to top</A></p><H2>MPW Pascal Example</h2><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>    {the following variable must be at the top level}    VAR       globalRef   : INTEGER;      {refNum of the file to read from}    {the following procedure must be at the top level}    PROCEDURE GetPICTData(dataPtr: Ptr; byteCount: INTEGER);    {replacement for the QuickDraw bottleneck routine}       VAR          err         : OSErr;          longCount   : LONGINT;       BEGIN          longCount := byteCount;          err := FSRead(globalRef,longCount,dataPtr);          {can't check for an error because we don't know how to handle it}       END;    CONST       abortPICT    = 128;         {error code if DrawPicture aborted}    PROCEDURE GetDrawPICTFile;     {read in a PICT FILE selected by the user}       VAR          wher        : Point;     {where to display dialog}          reply       : SFReply;   {reply record}          myFileTypes : SFTypeList; {more Standard FILE goodies}          numFileTypes: INTEGER;          savedProcs  : QDProcsPtr;          myProcs     : QDProcs;   {use CQDProcs for a color window}          myPicture   : PicHandle; {we need a picture handle for DrawPicture}          longCount   : LONGINT;          myEOF       : LONGINT;          myFilePos   : LONGINT;       BEGIN          wher.h := 20;          wher.v := 20;          numFileTypes := 1;       {display PICT files}          myFileTypes[0] := 'PICT';          SFGetFile(wher,'',NIL,numFileTypes,myFileTypes,NIL,reply);          IF reply.good THEN BEGIN             SetStdProcs(myProcs); {use SetStdCProcs for a CGrafPort}             myProcs.getPicProc := @GetPICTData;             savedProcs := thePort^.grafProcs; {set the grafProcs to ours}             thePort^.grafProcs := @myProcs;             myPicture := PicHandle(NewHandle(SizeOf(myPicture)));             Signal(FSOpen(reply.fname,reply.vRefNum,globalRef));             Signal(GetEOF(globalRef,myEOF)); {get EOF for later check}             Signal(SetFPos(globalRef,fsFromStart,512)); {skip header}             {read in the (obsolete) size word and the picFrame}             longCount := SizeOf(myPicture);             Signal(FSRead(globalRef,longCount,Ptr(myPicture^)));             DrawPicture(myPicture,myPicture^^.picFrame); {draw the picture}             Signal(GetFPos(globalRef,filePos)); {get position for check}             Signal(FSClose(globalRef));             DisposHandle(Handle(myPicture));             thePort^.grafProcs := savedProcs; {restore the procs}             {Check for errors. If there wasn't enough room,}             {DrawPicture will abort; the FILE position mark}             {won't be at the end of the FILE.}             IF filePos &lt;&gt; myEOF THEN Signal(abortPICT);          END; {IF reply.good}       END; {GetDrawPICTFile}</pre>	</TD></TR></TABLE></CENTER><a name="Section4"></a><P><A HREF="#top">Back to top</A></p><H2>MPW C Example</h2><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>/*replacement for the QuickDraw bottleneck routine*/pascal void GetPICTData(dataPtr,byteCount)Ptr            dataPtr;short            byteCount;{ /* GetPICTData */    OSErr            err;    long            longCount;    longCount = byteCount;    err = FSRead(globalRef,&amp;longCount,dataPtr);    /*can't check for an error because we don't know how to handle it*/} /* GetPICTData *//*error code if DrawPicture aborted*/#define       abortPICT     128OSErr GetDrawPICTFile()        /*read in a PICT FILE selected by the user*/{    /* GetDrawPICTFile */    Point         wher;         /*where to display dialog*/    SFReply    reply;      /*reply record*/    SFTypeList    myFileTypes;    /*more Standard FILE goodies*/    short         numFileTypes;    OSErr        err;    QDProcsPtr    savedProcs;    QDProcs    myProcs;    /*use CQDProcs for a color window*/    PicHandle    myPicture;    /*we need a picture handle for DrawPicture*/    long        longCount,myEOF,filePos;          wher.h = 20;          wher.v = 20;          numFileTypes = 1;                   /*display PICT files*/          myFileTypes[0] = 'PICT';          SFGetFile(wher,'',nil,numFileTypes,myFileTypes,nil,&amp;reply);          if (reply.good)        {            SetStdProcs(&amp;myProcs);            /*use SetStdCProcs for a CGrafPort*/                 myProcs.getPicProc = GetPICTData;                 savedProcs = (*qd.thePort).grafProcs;            /*set the grafProcs to ours*/                 (*qd.thePort).grafProcs = &amp;myProcs;                 myPicture = (PicHandle)NewHandle(sizeof(Picture));            err = FSOpen(&amp;reply.fName,reply.vRefNum,&amp;globalRef);            if (err != noErr) return err;                  err = GetEOF(globalRef,&amp;myEOF);            /*get EOF for later check*/            if (err != noErr) return err;            err = SetFPos(globalRef,fsFromStart,512);/*skip header*/                 if (err != noErr) return err;                 /*read in the (obsolete) size word and the picFrame*/                 longCount = sizeof(Picture);                 err = FSRead(globalRef,&amp;longCount,(Ptr)*myPicture);                 if (err != noErr) return err;                 DrawPicture(myPicture,&amp;(**myPicture).picFrame); /*draw the picture*/            err = GetFPos(globalRef,&amp;filePos);/*get position for check*/                 if (err != noErr) return err;                 err = FSClose(globalRef);                 if (err != noErr) return err;                 DisposHandle((Handle)myPicture);                 (*qd.thePort).grafProcs = savedProcs;/*restore the procs*/                 /*Check for errors. if there wasn't enough room,*/                 /*DrawPicture will abort; the FILE position mark*/                 /*won't be at the end of the FILE.*/            if (filePos != myEOF)  return abortPICT;            else return noErr;          } /*if (reply.good) */}     /* GetDrawPICTFile */</pre>	</TD></TR></TABLE></CENTER><a name="Section5"></a><P><A HREF="#top">Back to top</A></p><H2>More on Picture Compatibility</h2><p>Many applications already support PICT resources larger than 32K. The 128K ROMs(and later) allow pictures as large as memory (or spooling) will accommodate.This was made possible by having QuickDraw ignore the size word and simply readthe picture until the end-of-picture opcode was reached.</p><p><i>For maximum safety and convenience, let QuickDraw generate and interpret your pictures.</i></p><p>While Apple has provided you with the data formats that allow you to read orwrite picture data directly, we recommend that you always let <code>DrawPicture</code> or<code>OpenPicture</code> and <code>ClosePicture</code> process the opcodes.</p><p>One reason to read a picture directly by scanning the opcodes would be todisassemble it to, for example, extract a Color QuickDraw pixel map to save offin a private data structure. This shouldn't normally be necessary.</p><p>If you do look at the picture data be sure and check the version information.You may want to put up an alert in your application that indicates to the userwhen a picture was created using a later version of the picture format thanyour application recognizes, letting them know that some elements of thepicture cannot be displayed. If the version information indicates a QuickDrawpicture version later than the one recognized by your application, your programshould skip over the new opcodes and only attempt to parse the ones it knows.</p><p>As with reading picture data directly, it is best to use QuickDraw to createdata in the PICT format. If you do need to create PICT format data directly, itis essential that you use the latest opcode specifications and that youthoroughly test the data produced on both color and black and white Macintoshmachines. Contact Macintosh Developer Technical Support if you are not surethat you have the latest specifications.</p><p><i>Apple does not guarantee that a picture which wasn't produced by QuickDraw will work.</i></p><P><A HREF="#top">Back to top</A></p><a name="References"></a><h2>References</h2><P>QuickDraw</p><P>Technical Note M.IM.gifureOpcodes -- <A HREF = "qd_14.html">Internal Picture Format</a></p><P>Technical Note M.PT.Signals -- <A HREF = "../pt/pt_34.html">Signals</a></p>         <a name="Downloads"></a>         <P><A HREF="#top">Back to top</A></p><H2>Downloadables</H2>                  <TABLE BORDER=0 CELLPADDING=3 WIDTH="100%">            <TR>               <td width=50 align=left>                  <P ALIGN=center><img src="images/acrobatsmall.gif" width=22 height=23 align=middle alt="Acrobat gif"></P>               </TD>               <td align="left">                  <P>Acrobat version of this Note (56K).</P>               </TD>               <td width=60 align=left>                  <P><A HREF="pdf/qd_05.pdf">Download</A></P>               </TD>            </TR>                    </TABLE>         <BR></TD></TR></table></center><!-- begin_footer_information -->	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/technotes/qd/qd_05.html%3Fid%3DDTS10002718-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/technotes/qd/qd_05.html%3Fid%3DDTS10002718-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/technotes/qd/qd_05.html%3Fid%3DDTS10002718-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>
<!--#include virtual="/includes/footer"--><!-- end_footer_information --></BODY></HTML>