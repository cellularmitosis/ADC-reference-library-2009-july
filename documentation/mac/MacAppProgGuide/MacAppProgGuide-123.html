<!-- Generated by Harlequin WebMaker 2.2.3 (30-Apr-1996)
Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->
<HTML> <HEAD>
<TITLE>Memory Overview (MacApp PG)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING123></A>


<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="MacAppProgGuide-122.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="MacAppProgGuide-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="MacAppProgGuide-158.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="MacAppProgGuide-124.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="MacAppProgGuide-2.html"><B>Programmer's Guide to MacApp</B></A> / <A HREF="MacAppProgGuide-78.html"><B>Part 2 - Working With MacApp</B></A><BR><DD><A HREF="MacAppProgGuide-122.html"><B>Chapter 24 - Working With Memory and Failure Handling</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING123-0></A>
<H1>Memory Overview</H1>
 <A NAME=MARKER-2-20></A>MacApp provides a sophisticated memory management system, described in detail in <A HREF=MacAppProgGuide-25.html#MARKER-9-21>Chapter 3, "Core Technologies."</A> MacApp's memory management was designed to meet two important goals:<P>
<UL>
<LI>to ensure that critical memory requests always succeed
<LI>to manage object allocation efficiently<P>
</UL>
<A NAME=HEADING123-4></A>
<H2>Ensuring That Critical Memory Requests Succeed</H2>
 To meet the first goal, MacApp defines two types of memory requests, <I>permanent</I> and <I>temporary</I>.<P>
 You use <I>permanent</I> memory requests for most items your application allocates, such as handle and pointer memory requests. If a permanent memory request fails, no harm is done. A user may be unable to open an additional window or perform some other noncritical operation, but the application continues running and other operations can still be performed. Memory from a successful permanent allocation remains in use until you specifically free it.<P>
 You use <I>temporary</I> memory requests for allocations that must not fail. Suppose a user attempts to save a document and your application requests memory needed to write the document's data. If the request fails, the user will be unable to save the document. Because changes to the document will be lost, it is critical that the allocation not fail. Memory from a successful temporary allocation can be purged by MacApp (subject to your control) to make room for another allocation.<P>
 As long as there is sufficient memory in the application heap, all requests are satisfied from the available memory. It is only when a request cannot be satisfied that its type, temporary or permanent, becomes important. When a memory request can't be satisfied, the operating system calls the application's grow-zone procedure to attempt to free more memory. MacApp's grow-zone procedure, <CODE>GrowZoneProc</CODE>, uses a different algorithm for a temporary request than for a permanent request. That algorithm, together with the application's temporary reserve and low-space reserve, ensures that all temporary requests are satisfied.<P>
<A NAME=HEADING123-9></A>
<H2>Managing Object Allocation Efficiently</H2>
 MacApp uses a global heap object, <CODE>gObjectHeap</CODE>, to store objects created by your application. The global heap object allocates objects from a block of nonrelocatable memory it manages. Using nonrelocatable memory for the object heap reduces the number of blocks that the Toolbox Memory Manager has to manage in the application heap.<P>
 The heap object can allocate a large number of small objects efficiently, and it reuses the memory released when an object is freed. However, memory managed by the object heap cannot be used by the application for nonobject allocations. (See <A HREF=MacAppProgGuide-30.html#MARKER-9-180>"Allocating Objects," beginning on page 72</A>, for more information on the global heap object.)<P>
 MacApp makes it possible for you to manage your own object allocation rather than use the global heap object. For a description of how to modify object creation and deletion, see <A HREF=MacAppProgGuide-30.html#MARKER-9-199>"Replacing MacApp's Global New and Delete Operators," beginning on page 74</A>.<P>
<A NAME=HEADING123-13></A>
<H2><A NAME=MARKER-9-21></A>Allocating Permanent and Temporary Memory</H2>
 MacApp maintains a flag, <CODE>pTemporaryAllocation</CODE>, to control the allocation of temporary and permanent memory. Since system requests are temporary and tend to occur at unpredictable times, the <CODE>pTemporaryAllocation</CODE> flag is normally set to <CODE>TRUE</CODE> so that memory requests will be temporary by default. You use the global <CODE>TemporaryAllocation</CODE> routine to set <CODE>pTemporaryAllocation</CODE>, as described in <A HREF=#MARKER-9-28>"Allocating Permanent Memory," beginning on page 546</A>.<P>
 <A HREF=#MARKER-9-22>Figure 24-1</A> shows MacApp's global memory allocation routines. The <CODE>PermAllocation</CODE> method is provided for compatibility with previous versions of MacApp--it sets the value of the <CODE>pTemporaryAllocation</CODE> flag to the opposite of the passed value.<P>
<B>Figure 24-1  <A NAME=MARKER-9-22></A>MacApp's global memory allocation routines</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/MacApp_PG-L-089.gif"><P>
<DL>
<DT><B>Note</B>
<DD>The code samples in the first part of this chapter (covering memory operations) do not include failure handling. Failure handling is demonstrated starting on <A HREF=MacAppProgGuide-125.html#MARKER-9-59>page 560</A>.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
<A NAME=HEADING123-19></A>
<H3><A NAME=MARKER-2-23></A>MacApp's Memory Allocation Routines</H3>
 MacApp defines <A NAME=MARKER-2-24></A>several memory allocation routines that request permanent memory. Each of these routines sets the <CODE>pTemporaryAllocation</CODE> flag to <CODE>FALSE</CODE>, calls a corresponding Toolbox routine to allocate the requested memory, then restores the previous state of the flag:<P>
<DL>
<DT><CODE><A NAME=MARKER-2-25></A>NewPermPtr<B></B></CODE>
<DD> The <CODE>NewPermPtr</CODE> routine calls <CODE>NewPtr</CODE> to allocate a pointer to a permanent memory allocation.
<DT><CODE><A NAME=MARKER-2-26></A>SetPermPtrSize<B></B></CODE>
<DD> The <CODE>SetPermPtrSize</CODE> routine calls <CODE>SetPtrSize</CODE> to set the size of a permanent memory allocation pointed to by a pointer. The resized memory allocation is still permanent.
<DT><CODE>NewPermHandle<B></B></CODE>
<DD> The <CODE>NewPermHandle</CODE> routine calls <CODE>NewHandle</CODE> to allocate a handle to a permanent memory allocation.
<DT><CODE>SetPermHandleSize</CODE>
<DD> The <CODE>SetPermHandleSize</CODE> routine calls <CODE>SetHandleSize</CODE> to set the size of a permanent memory allocation pointed to by a handle. The resized memory allocation is still permanent.
</DL>
 When the <CODE>pTemporaryAllocation</CODE> flag is in its default state of <CODE>TRUE</CODE>, the Toolbox routines <CODE>NewPtr</CODE>, <CODE>SetPtrSize</CODE>, <CODE>NewHandle</CODE>, and <CODE>SetHandleSize</CODE> request temporary memory.<P>
<A NAME=HEADING123-26></A>
<H3><A NAME=MARKER-2-27></A><A NAME=MARKER-9-28></A>Allocating Permanent Memory</H3>
 <A NAME=MARKER-2-29></A>When you create handles or pointers for long-lived data, such as document or window data structures, you should allocate them with <CODE>NewPermHandle</CODE> or <CODE>NewPermPtr</CODE>. <P>
 You can also call the <CODE><A NAME=MARKER-2-30></A>TemporaryAllocation</CODE> routine to set <CODE>pTemporaryAllocation</CODE>, passing the value <CODE>FALSE</CODE> to specify permanent allocation. All subsequent allocations will be permanent until the flag is set to TRUE. The following code fragments show two ways to perform the same task--make a permanent memory request for two handles of arbitrary size:<P>
<UL>
<LI>Allocating two permanent handles with <CODE><A NAME=MARKER-2-31></A>NewPermHandle</CODE>:<P>
<pre>aHandle = NewPermHandle(100);<BR>anotherHandle = NewPermHandle(200);</pre>
<LI>Allocating two permanent handles with <CODE>TemporaryAllocation</CODE>:<P>
<pre>// Save current state and make all subsequent requests permanent.<BR>Boolean oldTemp = TemporaryAllocation(FALSE);<BR>aHandle  = NewHandle(100);        // Permanent allocation.<BR>anotherHandle = NewPermHandle(200); // Also permanent.<BR>// Restore previous state of flag.<BR>oldTemp  = TemporaryAllocation(oldTemp);</pre><P>
</UL>
<DL>
<DT><B>IMPORTANT</B>
<DD>When you set the <CODE><A NAME=MARKER-2-32></A>pTemporaryAllocation</CODE> flag by calling <CODE>TemporaryAllocation</CODE>, it stays the same for any number of subsequent memory requests. However, MacApp sets allocation to temporary (sets the <CODE>pTemporaryAllocation</CODE> flag to <CODE>TRUE</CODE>) in certain circumstances. So your application should specifically set allocation to permanent when necessary and not assume it is still permanent from a previous operation.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
 Whenever the <CODE>TemporaryAllocation</CODE> routine changes the <CODE>pTemporaryAllocation</CODE> flag from <CODE>FALSE</CODE> to <CODE>TRUE</CODE>, MacApp rebuilds its temporary and low-space reserves. Frequent rebuilding can lead to purging and compacting of memory, which can harm performance, so you should avoid excessive changes to the allocation state.<P>
 There is another reason to specify permanent memory only when it is absolutely necessary. If you set <CODE>pTemporaryAllocation</CODE> to <CODE>FALSE</CODE> and the following code causes a segment load or some other system memory request, the application could run out of permanent memory and fail (or even crash), when a temporary request would have succeeded. Minimizing the number of times you specifically ask for permanent memory will maximize MacApp's ability to guarantee that crucial memory requests are successful.<P>
<A NAME=HEADING123-36></A>
<H3><A NAME=MARKER-2-33></A>Allocating Temporary Memory</H3>
 <A NAME=MARKER-2-34></A>Your application uses temporary memory requests for allocations that cannot fail, such as memory needed in the course of saving a document or quitting the application. MacApp uses temporary memory for allocating code segments, WDEFs and CDEFs, error dialog boxes, and critical resources.<P>
 Handles and pointers allocated for short-term use, such as those allocated and disposed of in the same routine, can also be allocated with a temporary request. Since the normal state for the <CODE><A NAME=MARKER-2-35></A>pTemporaryAllocation</CODE> flag is <CODE>TRUE</CODE>, or temporary, routines such as <CODE>NewHandle</CODE> and <CODE>NewPtr</CODE> will default to temporary requests. However, if an allocation <I>must not fail</I>, you should specifically set <CODE>pTemporaryAllocation</CODE> to TRUE. Consider the following two code fragments:<P>
<UL>
<LI>Allocating two temporary handles--the following code assumes that the <CODE>pTemporaryAllocation</CODE> flag is already set to TRUE from a previous operation:<P>
<pre>// NOTE: Can't be sure allocation will be temporary,<BR>//   so only do this if not essential that<BR>//   allocation is temporary.<BR>aHandle = NewHandle(100);<BR>anotherHandle = NewHandle(200);</pre>
<LI>Allocating two temporary handles using <CODE>TemporaryAllocation</CODE>:<P>
<pre>// Make sure all subsequent requests are <CODE>temporary</CODE>.<BR>Boolean oldTemp = TemporaryAllocation(TRUE);<BR>aHandle  = NewHandle(100);       // Definitely temporary.<BR>anotherHandle  = NewHandle(200);       // Definitely temporary.<BR>// Restore previous state of flag.<BR>oldTemp  = TemporaryAllocation(oldTemp);</pre><P>
</UL>
<A NAME=HEADING123-43></A>
<H3>Allocating Memory for Objects</H3>
 MacApp uses a global object, <CODE>gObjectHeap</CODE>, to allocate memory for your application's objects. The object heap is initialized to a default size determined by your application's <CODE>'mem!'</CODE> resources, which are described beginning on <A HREF=#MARKER-9-44>page 551</A>. The initial memory allocation for the object heap is made in permanent memory. The object heap allocates objects from its block of memory until that memory is exhausted--then it increases the size of the heap by an increment size that is also defined by your application's memory resources.<P>
 When the object heap has to increase its size, it allocates additional permanent memory using the Toolbox routine <CODE>NewPtr</CODE>.<P>
<A NAME=HEADING123-46></A>
<H3>Allocating Memory for Lists</H3>
 MacApp maintains an additional flag, <CODE>pAllocateObjectsFromPerm</CODE>, that determines whether the memory used by an array object should be grown with a permanent or a temporary request.<P>
<DL>
<DT><B>IMPORTANT</B>
<DD>Although the name <CODE>pAllocateObjectsFromPerm</CODE> might sound like it controls the request type (permanent or temporary) for object allocations, it does not. It used to, but now MacApp uses <CODE>pAllocateObjectsFromPerm</CODE> <I>only</I> when setting the array size in the <CODE>TDynamicArray</CODE> class.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
 MacApp's array classes include many list classes that descend from <CODE><A NAME=MARKER-2-36></A>TDynamicArray</CODE>. The <CODE>TDynamicArray::<A NAME=MARKER-2-37></A>SetArraySize</CODE> method calls <CODE><A NAME=MARKER-2-38></A>GetPermObjectAllocationState</CODE> to get the current value of <CODE>pAllocateObjectsFromPerm</CODE>. If the value is <CODE>TRUE</CODE>, <CODE>SetArraySize</CODE> calls <CODE>SetPermHandleSize</CODE>; otherwise, it calls <CODE>SetHandleSize</CODE>.<P>
 If your application performs an operation that must not fail and that operation can cause an array object to grow (for example, it can add an entry to a list object), you can specify temporary memory with code like the following:<P>
<PRE>
// Make sure all subsequent array requests are temporary.
Boolean oldArrayPerm = AllocateObjectsFromPerm(FALSE);
// Perform operation that may cause list to grow.
.
.
.
// Restore previous state of flag.
oldArrayPerm = AllocateObjectsFromPerm(oldArrayPerm);
</PRE>
<A NAME=HEADING123-52></A>
<H3>Allocating Memory for List and Objects</H3>
 As a final example of making a temporary-memory request for an allocation that must not fail, consider the case where <I>both</I> an object allocation and a list allocation must not fail. In the code fragment that follows, the application must create and post a critical command. To ensure that the command object is created, you must set <CODE>pTemporaryAllocation</CODE> to TRUE (for temporary). To ensure that posting the command (which inserts the command into the application's command list, causing the list to grow) succeeds, you must also set <CODE><A NAME=MARKER-2-39></A>pAllocateObjectsFromPerm</CODE> to <CODE>FALSE</CODE>.<P>
<PRE>
// Make sure object allocation is temporary.
Boolean oldTemp = TemporaryAllocation(TRUE);

// Create critical command object.
TCriticalCmd theCriticalCmd = new TCriticalCmd;

// Make sure all subsequent array requests are temporary.
Boolean oldArrayPerm = AllocateObjectsFromPerm(FALSE);

// Perform operation that may cause list to grow.
this-&gt;PostCommand(theCriticalCmd);

// Restore state of pAllocateObjectsFromPerm flag.
oldArrayPerm = AllocateObjectsFromPerm(oldArrayPerm);

// Restore previous state of pTemporaryAllocation flag.
oldTemp = TemporaryAllocation(oldTemp);
</PRE>
<DL>
<DT><B>Note</B>
<DD>Another option is to create a TCriticalCmd object at startup and reuse it whenever necessary. Then the command will always be available when it is needed.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
<A NAME=HEADING123-56></A>
<H2><A NAME=MARKER-2-40></A>Allocating Master Pointers for the Application</H2>
 Application initialization is described in detail in <A HREF=MacAppProgGuide-33.html#MARKER-9-19>Chapter 4, "Launching and Terminating an Application."</A> As part of initialization, your application makes a call similar to one of the following two calls:<P>
<PRE>
InitUMacApp(4);
</PRE>
 or<P>
<PRE>
InitUMacApp_Step3(4);
</PRE>
 When expanded, the <CODE>InitUMacApp</CODE> macro includes a call to <A NAME=MARKER-2-41></A>InitUMacApp_Step3. The value 4, passed as a parameter, tells MacApp's memory initialization to call the Toolbox routine <CODE><A NAME=MARKER-2-42></A>MoreMasters</CODE> four times. The <CODE>MoreMasters</CODE> routine allocates space for a block of master pointers. By calling this routine during MacApp initialization, the master pointers are allocated in the heap first, and so memory fragmentation is minimized.<P>
 Each call to <CODE>MoreMasters</CODE> creates a block of 64 master pointers. The number you pass to <CODE>InitUMacApp</CODE> or InitUMacApp_Step3 should equal the greatest number of dynamically allocated blocks of memory that your application will need at any one time, divided by 64.<P>
<A NAME=HEADING123-63></A>
<H2><A NAME=MARKER-2-43></A><A NAME=MARKER-9-44></A>'mem!', '68k!', and 'ppc!' Resources</H2>
 <A NAME=MARKER-2-45></A>MacApp uses the <CODE>'mem!'</CODE> and <CODE>'ppc!'</CODE> (<CODE>'68k!'</CODE> for a 68K application) resource types to specify several memory-related values for the application. Each of these resource types has the same format--five consecutive <CODE>longint</CODE> fields. The value of each field can be positive, negative, or 0. The five fields are used to specify, in order<P>
<UL>
<LI>the initial size for the global heap object (used to allocate objects)
<LI>the default increment for the global heap object (when the heap object needs more memory to satisfy a request, it asks for a minimum of this amount)
<LI>a value to add to other components of the application's temporary reserve (see <A HREF=MacAppProgGuide-44.html#MARKER-9-151>"Determining the Size of Memory Reserves," beginning on page 65</A>, for a full description of the components of the temporary reserve)
<LI>the size of the application's low-space reserve
<LI>the size of the application's stack<P>
</UL>
 For <CODE>'68k!'</CODE> and <CODE>'ppc!'</CODE> resources, only the first two fields are normally used. The other fields are set to 0. MacApp's default <CODE>'mem!'</CODE> resource, in the file <CODE>Memory.r</CODE>, is defined as follows:<P>
<PRE>
resource 'mem!' (kBaseMacApp,
#if qNames
   &quot;BaseMacApp&quot;,
#endif
   purgeable) {
   32 * 1024,  // Initial pointer-based object heap size.
   30 * 1024,  // Minimum amount to grow object heap.
   6 * 1024,   // Add to temporary reserve.
   6 * 1024,   // Add to permanent reserve.
   32 * 1024   // Base stack size.
};
</PRE>
 This resource specifies default values for each of the five memory-related fields. During memory initialization, MacApp totals the values of the five fields for each <CODE>'mem!'</CODE> resource in the application, including MacApp's default resource. It then adds the values from each <CODE>'68K!'</CODE> resource for 68K applications or the values from each <CODE>'ppc!'</CODE> resource for Power Macintosh applications. For example, the <CODE>'ppc!'</CODE> resource adds 30 KB to the permanent memory reserve.<P>
 <A NAME=MARKER-2-46></A>MacApp then uses the totals computed from these resources to set the initial size for the heap object, set the heap object's increment, allocate temporary and low-space reserves, and set the application's stack size. Since you can specify negative numbers in these resources, you can shrink the values found in MacApp's default <CODE>'mem!'</CODE> resource. For example, the default initial size for the heap object is 32 KB. If your application needs less memory for allocating objects, you can decrease this value by specifying a negative number in the first field of your own <CODE>'mem!'</CODE> resource.<P>
<DL>
<DT><B>Note</B>
<DD>For Power Macintosh applications, the <CODE>'<A NAME=MARKER-2-47></A>cfrg'</CODE> resource also has a field to specify stack size. Some integrated development environments allow you to directly specify a stack size using this resource, but MacApp ignores this resource and uses the value specified in the <CODE>'mem!'</CODE> resource.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
 MacApp provides additional <CODE>'mem!'</CODE> resources to accompany certain units:<P>
<UL>
<LI>The <CODE>'mem!'</CODE> resource from <CODE>Debug.r</CODE> increases the temporary reserve by 4 KB for application that use MacApp's built-in debugging. 
<LI>The <CODE>'mem!'</CODE> resource from <CODE>Printing.r</CODE> increases the temporary reserve by 43 KB for applications that use printing.<P>
</UL>
 <A HREF=MacAppProgGuide-44.html#MARKER-9-151>"Determining the Size of Memory Reserves," beginning on page 65</A>, provides information to help determine appropriate sizes for your application.<A NAME=MARKER-2-48></A><A NAME=MARKER-2-49></A><P>
<DL>
<DT><B>Note</B>
<DD><A NAME=MARKER-2-50></A>Additional information about MacApp memory resource issues can be found in the technical note "PT 21--MacApp Segmentation Illuminations," available from Apple's Developer Technical Services.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
</BLOCKQUOTE>
<HR>
<center>
<A HREF="MacAppProgGuide-122.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="MacAppProgGuide-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="MacAppProgGuide-158.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="MacAppProgGuide-124.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="MacAppProgGuide-3.html">&copy; Apple Computer, Inc.</A><br>25 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>  
