#include	<Quickdraw.h>#include	<Windows.h>#include	<dialogs.h>#include	<OSEvents.h>#include	<Memory.h>#include	<Packages.h>#include	<Sound.h>#include	<SoundInput.h>#include	<OSUtils.h>#define	TRUE			0xFF#define	FALSE			0#define buffSize		0x10000typedef struct {	short		OnOff;	short	 	Level;} Level;struct LocalVars {    long		bytesTotal;    Ptr			dataPtr;};typedef struct LocalVars LocalVars;typedef LocalVars *LocalVarsPtr;pascal void MyDoubleBackProc (SndChannelPtr channel,                              SndDoubleBufferPtr doubleBufferPtr);pascal void MyRecComp (SPBPtr inParamPtr);main(){	LocalVars				myVars;	SoundHeaderPtr			Head;	SndDoubleBufferHeader	doubleHeader;	SndDoubleBufferPtr		doubleBuffer;	OSErr					err;	SPBPtr					RecordRec;	long					SoundRefNum;	Handle					Buffer, Buffer2;	SndChannelPtr			chan;	Level					myLevel;	short					headerlength, headerlength2, dummy;	Fixed					sampleRate;	Boolean					First, Second;	int						i;	SndCommand				mycmd;	SICompletionUPP         mySICompletionUPP;	SndDoubleBackUPP        mySndDoubleBackUPP;		First = TRUE;	Second = TRUE;		err = SPBOpenDevice (nil, siWritePermission, &SoundRefNum);	if (err != noErr)		Debugger();			myLevel.OnOff = 0;	myLevel.Level = 0;	err = SPBSetDeviceInfo (SoundRefNum,siPlayThruOnOff, (Ptr) &myLevel);	if (err != noErr)		Debugger();			myLevel.OnOff = 0;	myLevel.Level = 0;	err = SPBSetDeviceInfo (SoundRefNum,siTwosComplementOnOff, (Ptr) &myLevel);	if (err != noErr)		Debugger();			err = SPBGetDeviceInfo (SoundRefNum,siSampleRate, (Ptr) &sampleRate);	if (err != noErr)		Debugger();			RecordRec = (SPBPtr) NewPtr(sizeof (SPB));	if (MemError() != noErr || RecordRec == nil)		Debugger();	Buffer = NewHandle(buffSize);	if (MemError() != noErr || Buffer == nil)		Debugger();	HLock (Buffer);	err = SetupSndHeader (Buffer, 1, sampleRate, 8, 'NONE', 0x3C, 0, &headerlength);	if (err != noErr)		Debugger();	err = SetupSndHeader (Buffer, 1, sampleRate, 8, 'NONE', 0x3C, buffSize - headerlength, &dummy);	if (err != noErr)		Debugger();	Buffer2 = NewHandle(buffSize);	if (MemError() != noErr || Buffer2 == nil)		Debugger();	HLock (Buffer2);	err = SetupSndHeader (Buffer2, 1, sampleRate, 8, 'NONE', 0x3C, 0, &headerlength2);	if (err != noErr)		Debugger();			err = SetupSndHeader (Buffer2, 1, sampleRate, 8, 'NONE', 0x3C, buffSize - headerlength2, &dummy);	if (err != noErr)		Debugger();			/* set up the UPP for the sound input completion routine */	mySICompletionUPP = NewSICompletionProc(MyRecComp);			RecordRec->inRefNum = SoundRefNum;	RecordRec->count = 0;	RecordRec->milliseconds = 15000;	RecordRec->bufferLength = buffSize - headerlength;	RecordRec->bufferPtr = (Ptr) ((*Buffer) + headerlength);	RecordRec->completionRoutine = mySICompletionUPP;	RecordRec->interruptRoutine = nil;	RecordRec->userLong = 0;	RecordRec->error = 0;	RecordRec->unused1 = 0;	chan = nil;	err = SndNewChannel (&chan, sampledSynth, 0, nil);	if (err != noErr)		Debugger();			Head = (SoundHeaderPtr) NewPtrClear (sizeof(SoundHeader));	Head->samplePtr = (Ptr) (*Buffer) + headerlength;	Head->length = buffSize - headerlength;	Head->sampleRate = 0x56EE8BA3;		//recorded at 22KHz	Head->loopStart = 0;	Head->loopEnd = 0;	Head->encode = 0;	Head->baseFrequency = 60;	Head->sampleArea[0] = 0;		/* create the UPP for MyDoubleBackProc */	mySndDoubleBackUPP = NewSndDoubleBackProc(MyDoubleBackProc);	doubleHeader.dbhNumChannels = 1;	doubleHeader.dbhSampleSize = 8;	doubleHeader.dbhCompressionID = 0;	doubleHeader.dbhPacketSize = 0;	doubleHeader.dbhSampleRate = Head->sampleRate;	doubleHeader.dbhDoubleBack = mySndDoubleBackUPP;	do {		err = SPBRecord (RecordRec, TRUE);		if (err != noErr)			Debugger();					do {			} while (RecordRec->userLong == 0);				if (RecordRec->userLong == 10) {			if (RecordRec->bufferPtr == (Ptr) ((*Buffer) + headerlength)) {				RecordRec->bufferPtr = (Ptr) ((*Buffer2) + headerlength2);					if (First) {					myVars.bytesTotal = Head->length;					myVars.dataPtr = (Ptr) (*Buffer2) + headerlength;					doubleBuffer = (SndDoubleBufferPtr)NewPtrClear(sizeof(SndDoubleBuffer)+buffSize-headerlength);						if (doubleBuffer == nil || MemError() != 0)						Debugger();							doubleBuffer->dbNumFrames = 0;					doubleBuffer->dbFlags = 0;					doubleBuffer->dbUserInfo [0] = (long) &myVars;						MyDoubleBackProc (chan, doubleBuffer);			// initialize the buffers					doubleHeader.dbhBufferPtr [1] = doubleBuffer;					myVars.bytesTotal = Head->length;					myVars.dataPtr = Head->samplePtr;					doubleBuffer = (SndDoubleBufferPtr)NewPtrClear(sizeof(SndDoubleBuffer)						+buffSize-headerlength);						if (doubleBuffer == nil || MemError() != 0)						Debugger();							doubleBuffer->dbNumFrames = 0;					doubleBuffer->dbFlags = 0;					doubleBuffer->dbUserInfo [0] = (long) &myVars;							MyDoubleBackProc (chan, doubleBuffer);			// initialize the buffers						doubleHeader.dbhBufferPtr [0] = doubleBuffer;										err = SndPlayDoubleBuffer (chan, &doubleHeader);					if (err != noErr)						Debugger();					First = FALSE;					}					else {					Head->samplePtr = (Ptr) (*Buffer) + headerlength;					myVars.dataPtr = Head->samplePtr;					}				}			else {				if (Second) {					myVars.bytesTotal = Head->length;					myVars.dataPtr = (Ptr) (*Buffer2) + headerlength;					doubleBuffer = (SndDoubleBufferPtr)NewPtrClear(sizeof(SndDoubleBuffer)+buffSize-headerlength);						if (doubleBuffer == nil || MemError() != 0)						Debugger();							doubleBuffer->dbNumFrames = 0;					doubleBuffer->dbFlags = 0;					doubleBuffer->dbUserInfo [0] = (long) &myVars;						MyDoubleBackProc (chan, doubleBuffer);			// initialize the buffers					doubleHeader.dbhBufferPtr [1] = doubleBuffer;					Second = FALSE;					}				else {					RecordRec->bufferPtr = (Ptr) ((*Buffer) + headerlength);					Head->samplePtr = (Ptr) (*Buffer2) + headerlength;					myVars.dataPtr = Head->samplePtr;					}				}			RecordRec->userLong = 0;			} 		} while (RecordRec->userLong != 1);			mycmd.cmd = quietCmd;	mycmd.param1 = 0;	mycmd.param2 = 0;		err = SndDoImmediate (chan, &mycmd);	if (err != noErr)		Debugger();			for (i = 0; i <= 1; ++i)		DisposePtr ((Ptr) doubleHeader.dbhBufferPtr[i]);	err = SndDisposeChannel (chan,FALSE);	if (err != noErr)		Debugger();	SPBCloseDevice (SoundRefNum);			HUnlock (Buffer);	HUnlock (Buffer2);	DisposeHandle (Buffer);	DisposeHandle (Buffer2);	DisposePtr ((Ptr) RecordRec);		DisposeRoutineDescriptor(mySICompletionUPP);	DisposeRoutineDescriptor(mySndDoubleBackUPP);}/**********************************/pascal void MyRecComp (SPBPtr inParamPtr){	inParamPtr->userLong = 10;			if (Button())		inParamPtr->userLong = 1;		return;}/**********************************/pascal void MyDoubleBackProc (SndChannelPtr chan,SndDoubleBufferPtr doubleBuffer){LocalVarsPtr	myVarsPtr;myVarsPtr = (LocalVarsPtr) doubleBuffer->dbUserInfo[0];BlockMove (myVarsPtr->dataPtr, &doubleBuffer->dbSoundData[0], myVarsPtr->bytesTotal);doubleBuffer->dbNumFrames = myVarsPtr->bytesTotal;doubleBuffer->dbFlags = (doubleBuffer->dbFlags) | dbBufferReady;return;}/**********************************/