<!-- legacy work start -->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<!-- legacy work end -->


<!-- Generated by Harlequin WebMaker 2.2.3 (23-Apr-1996)

LispWorks 3.2.2 -->
<HTML> <HEAD>
<TITLE>Using Double Buffers (IM: S)  (deprecated)</Title>

<!-- legacy work start -->
        <META NAME="Generator" CONTENT="manual">
        <META http-equiv="content-type" CONTENT="text/html;charset=utf-8">
        <META NAME = "Copyright" CONTENT="Copyright 2007 Apple Inc. All Rights Reserved.">
        <META NAME="IndexTitle" CONTENT="Inside Macintosh: Sound (Not Recommended)">
        <meta name="xcode-display" content="render">

        <LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css"> <!-- before submitting, globally replace ".." with "developer.apple.com" -->
        <script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
<!-- legacy work end -->

</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<A NAME=HEADING58></A>


<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="Sound-57.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Sound-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Sound-336.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="Sound-59.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="Sound-2.html"><B>Sound</B></A> / <BR><DD><A HREF="Sound-44.html"><B>Chapter 2 - Sound Manager</B></A> / <A HREF="Sound-50.html"><B>Using the Sound Manager</B></A></DL></FONT><P>
<HR>

<!-- legacy work start -->
<script type="text/javascript"> placeWatermark()</script>
<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
<i>Inside Macintosh: Sound</i> is deprecated as of Mac OS X v10.5. For new audio development in Mac OS X, use Core Audio. See the <a href="http://developer.apple.com/referencelibrary/MusicAudio/" target="_top">Audio</a> page in the ADC Reference Library.</p></div></div></div>
<!-- legacy work end -->


<BLOCKQUOTE>
<A NAME=HEADING58-0></A>
<H2><A NAME=MARKER-9-385></A>Using Double Buffers<A NAME=MARKER-2-386></A></H2>
 The play-from-disk routines make extensive use of the <CODE>SndPlayDoubleBuffer</CODE> function. You can use this function in your application directly if you wish to bypass the normal play-from-disk routines. You might want to do this to maximize the efficiency of your application while maintaining compatibility with the Sound Manager. Or, you might define your own double-buffering routines so that your application can convert 16-bit sound data on disk to 8-bit data that all versions of the Sound Manager can play. By using <CODE>SndPlayDoubleBuffer</CODE> instead of the normal play-from-disk routines, you can specify your own doubleback procedure (that is, the algorithm used to switch back and forth between buffers) and customize several other buffering parameters.<A NAME=MARKER-2-216></A><P>
<DL>
<DT><B>IMPORTANT</B>
<DD><CODE>SndPlayDoubleBuffer</CODE> is a very low-level routine and is not intended for general use. In most cases, you should use the high-level Sound Manager routines (such as <CODE>SndPlay</CODE> or <CODE>SndStartFilePlay</CODE>) or standard sound commands (such as <CODE>bufferCmd</CODE>) to play sounds. You should use <CODE>SndPlayDoubleBuffer</CODE> only if you require very fine control over double buffering. Remember also that the <CODE>SndPlayDoubleBuffer</CODE> function is not always available. You'll need to ensure that it's available in the current operating environment before calling it. See <A HREF=Sound-53.html#MARKER-9-235>"Testing for Multichannel Sound and Play-From-Disk Capabilities" beginning on page 2-35</A> for details.<EM></EM>   <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
 You call <CODE>SndPlayDoubleBuffer</CODE> by passing it a pointer to a sound channel (into which the double-buffered data is to be written) and a pointer to a sound double buffer header record. Here's an example:<P>
<PRE>
myErr := SndPlayDoubleBuffer(mySndChan, @myDoubleHeader);
</PRE>
 A sound double buffer header record has the following structure:<P>
<PRE>
TYPE SndDoubleBufferHeader =
PACKED RECORD
   dbhNumChannels:   Integer;    {number of sound channels}
   dbhSampleSize:    Integer;    {sample size, if noncompressed}
   dbhCompressionID: Integer;    {ID of compression algorithm}
   dbhPacketSize:    Integer;    {number of bits per packet}
   dbhSampleRate:    Fixed;      {sample rate}
   dbhBufferPtr:     ARRAY[0..1] OF SndDoubleBufferPtr;
                                 {pointers to SndDoubleBuffer}
   dbhDoubleBack:    ProcPtr;    {pointer to doubleback procedure}
END;
</PRE>
 The values for the <CODE>dbhCompressionID</CODE>, <CODE>dbhNumChannels</CODE>, and <CODE>dbhPacketSize</CODE> fields are the same as those for the <CODE>compressionID</CODE>, <CODE>numChannels</CODE>, and <CODE>packetSize</CODE> fields of the compressed sound header, respectively.<P>
 The <CODE>dbhBufferPtr</CODE> array contains pointers to two records of type <CODE>SndDoubleBuffer</CODE>. These are the two buffers between which the Sound Manager switches until all the sound data has been sent into the sound channel. When the call to <CODE>SndPlayDoubleBuffer</CODE> is made, the two buffers should both already contain a nonzero number of frames of data.<P>
<DL>
<DT><B>IMPORTANT</B>
<DD>The Sound Manager defines the data type <CODE>SndDoubleBufferHeader2</CODE> that is identical to the <CODE>SndDoubleBufferHeader</CODE> data type except that it contains the <CODE>dbhFormat</CODE> field (of type <CODE>OSType</CODE>) that defines a custom codec to be used to decompress the sound data. The <CODE>dbhFormat</CODE> field is used only if the <CODE>dbhCompressionID</CODE> field contains the value <CODE>fixedCompression</CODE>. See <A HREF=Sound-77.html#MARKER-9-731>"Sound Double Buffer Header Records" beginning on page 2-111</A> for details.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
 Here is the structure of a sound double buffer:<P>
<PRE>
TYPE SndDoubleBuffer =
PACKED RECORD
   dbNumFrames:   LongInt;       {number of frames in buffer}
   dbFlags:       LongInt;       {buffer status flags}
   dbUserInfo:    ARRAY[0..1] OF LongInt;
                                 {for application's use}
   dbSoundData:   PACKED ARRAY[0..0] OF Byte;
                                 {array of data}
END;
</PRE>
 The buffer status flags field for each of the two buffers might contain either of these values:<P>
<PRE>
CONST
   dbBufferReady     = $00000001;
   dbLastBuffer      = $00000004;
</PRE>
 All other bits in the <CODE>dbFlags</CODE> field are reserved by Apple; your application should not modify them.<P>
 The following two sections illustrate how to fill out these data structures, create your two buffers, and define a doubleback procedure to refill the buffers when they become empty.<P>
<A NAME=HEADING58-16></A>
<H3>Setting Up Double Buffers<A NAME=MARKER-2-389></A></H3>
 Before you can call <CODE>SndPlayDoubleBuffer</CODE>, you need to allocate two buffers (of type <CODE>SndDoubleBuffer</CODE>), fill them both with data, set the flags for the two buffers to <CODE>dbBufferReady</CODE>, and then fill out a record of type <CODE>SndDoubleBufferHeader</CODE> with the appropriate information. <A HREF=#MARKER-9-390>Listing 2-34</A> illustrates how you can accomplish these tasks.<P>
<B>Listing 2-34  <A NAME=MARKER-9-390></A>Setting up double buffers</B><P>
<PRE>
CONST
   kDoubleBufferSize = 4096;     {size of each buffer (in bytes)}
TYPE
   LocalVars =                   {variables used by the doubleback procedure}
   RECORD
      bytesTotal:    LongInt;    {total number of samples}
      bytesCopied:   LongInt;    {number of samples copied to buffers}
      dataPtr:       Ptr;        {pointer to sample to copy}
   END;
   LocalVarsPtr = ^LocalVars;

{This function uses SndPlayDoubleBuffer to play the sound specified.}
FUNCTION MyDBSndPlay (chan: SndChannelPtr; sndHeader: SoundHeaderPtr): OSErr;
VAR
   myVars:           LocalVars;
   myDblHeader:      SndDoubleBufferHeader;
   myDblBuffer:      SndDoubleBufferPtr;
   myStatus:         SCStatus;
   myIndex:          Integer;
   myErr:            OSErr;
BEGIN
   {Set up myVars with initial information.}
   myVars.bytesTotal := sndHeader^.length;
   myVars.bytesCopied := 0;               {no samples copied yet}
   myVars.dataPtr := Ptr(@sndHeader^.sampleArea[0]);
                                          {pointer to first sample}
   {Set up SndDoubleBufferHeader.}
   WITH myDblHeader DO
   BEGIN
      dbhNumChannels := 1;                {one channel}
      dbhSampleSize := 8;                 {8-bit samples}
      dbhCompressionID := 0;              {no compression}
      dbhPacketSize := 0;                 {no compression}
      dbhSampleRate := sndHeader^.sampleRate;
      dbhDoubleBack := @MyDoubleBackProc;
   END;

   FOR myIndex := 0 TO 1 DO               {initialize both buffers}
   BEGIN
      {Get memory for double buffer.}
      myDblBuffer := SndDoubleBufferPtr(NewPtr(Sizeof(SndDoubleBuffer) + 
                                                   kDoubleBufferSize));
      IF myDblBuffer = NIL THEN
      BEGIN
         MyDBSndPlay := MemError;
         Exit(MyDBSndPlay);
      END;

      myDblBuffer^.dbNumFrames := 0;      {no frames yet}
      myDblBuffer^.dbFlags := 0;          {buffer is empty}
      myDblBuffer^.dbUserInfo[0] := LongInt(@myVars);

      {Fill buffer with samples.}
      MyDoubleBackProc(sndChan, myDblBuffer);

      {Store buffer pointer in header.}
      myDblHeader.dbhBufferPtr[myIndex] := myDblBuffer;
   END;
   {Start the sound playing.}
   myErr := SndPlayDoubleBuffer(sndChan, @myDblHeader);
   IF myErr &lt;&gt; noErr THEN
   BEGIN
      MyDBSndPlay := myErr;
      Exit(MyDBSndPlay);
   END;

   {Wait for the sound's end by checking the channel status.}
   REPEAT
      myErr := SndChannelStatus(chan, sizeof(myStatus), @status);
   UNTIL NOT myStatus.scChannelBusy;

   {Dispose double buffer memory.}
   FOR myIndex := 0 TO 1 DO
      DisposePtr(Ptr(myDblHeader.dbhBufferPtr[myIndex]));

   MyDBSndPlay := noErr;
END;
</PRE>
 The function <CODE>MyDBSndPlay</CODE> takes two parameters, a pointer to a sound channel and a pointer to a sound header. For information about obtaining a pointer to a sound header, see <A HREF=Sound-56.html#MARKER-9-341>"Obtaining a Pointer to a Sound Header" on page 2-57</A>. The <CODE>MyDBSndPlay</CODE> function reads the sound header to determine the characteristics of the sound to be played (for example, how many samples are to be sent into the sound channel). Then <CODE>MyDBSndPlay</CODE> fills in the fields of the double buffer header, creates two buffers, and starts the sound playing. The doubleback procedure <CODE>MyDoubleBackProc</CODE> is defined in the next section.<A NAME=MARKER-2-391></A><P>
<A NAME=HEADING58-21></A>
<H3>Writing a Doubleback Procedure<A NAME=MARKER-2-392></A></H3>
 <A NAME=MARKER-2-393></A>The <CODE>dbhDoubleBack</CODE> field of a double buffer header specifies the address of a doubleback procedure, an application-defined procedure that is called when the double buffers are switched and the exhausted buffer needs to be refilled. The doubleback procedure should have this format:<A NAME=MARKER-2-23></A><P>
<PRE>
PROCEDURE MyDoubleBackProc (chan: SndChannelPtr; 
                           exhaustedBuffer: SndDoubleBufferPtr);
</PRE>
 The primary responsibility of the doubleback procedure is to refill an exhausted buffer of samples and to mark the newly filled buffer as ready for processing. <A HREF=#MARKER-9-398>Listing 2-35</A> illustrates how to define a doubleback procedure. Note that the sound channel pointer passed to the doubleback procedure is not used in this procedure.<P>
 This doubleback procedure extracts the address of its local variables from the <CODE>dbUserInfo</CODE> field of the double buffer record passed to it. These variables are used to keep track of how many total bytes need to be copied and how many bytes have been copied so far. Then the procedure copies at most a bufferfull of bytes into the empty buffer and updates several fields in the double buffer record and in the structure containing the local variables. Finally, if all the bytes to be copied have been copied, the buffer is marked as the last buffer.<P>
<DL>
<DT><B>Note</B>
<DD>Because the doubleback procedure is called at interrupt time, it cannot make any calls that move memory either directly or indirectly. (Despite its name, the <CODE>BlockMove</CODE> procedure does not cause blocks of memory to move or be purged, so you can safely call it in your doubleback procedure, as illustrated in <A HREF=#MARKER-9-398>Listing 2-35</A>.)<EM></EM><A NAME=MARKER-2-395></A> <A NAME=MARKER-2-397></A>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
<B>Listing 2-35  <A NAME=MARKER-9-398></A>Defining a doubleback procedure</B><P>
<PRE>
PROCEDURE MyDoubleBackProc (chan: SndChannelPtr; 
                              doubleBuffer: SndDoubleBufferPtr);
VAR
   myVarsPtr:        LocalVarsPtr;
   myNumBytes:       LongInt;
BEGIN
   {Get pointer to my local variables.}
   myVarsPtr := LocalVarsPtr(doubleBuffer^.dbUserInfo[0]);
   
   {Get number of bytes left to copy.}
   myNumBytes := myVarsPtr^.bytesTotal - myVarsPtr^.bytesCopied;

   {If the amount left is greater than double buffer size, limit the number }
   { of bytes to copy to the size of the buffer.}
   IF myNumBytes &gt; kDoubleBufferSize THEN
      myNumBytes := kDoubleBufferSize;
   
   {Copy samples to double buffer.}
   BlockMove(myVarsPtr^.dataPtr, @doubleBuffer^.dbSoundData[0], myNumBytes);
   
   {Store number of samples in buffer and mark buffer as ready.}
   doubleBuffer^.dbNumFrames := myNumBytes;
   doubleBuffer^.dbFlags := BOR(doubleBuffer^.dbFlags, dbBufferReady);
   
   {Update data pointer and number of bytes copied.}
   myVarsPtr^.dataPtr := Ptr(ORD4(myVarsPtr^.dataPtr) + myNumBytes);
   myVarsPtr^.bytesCopied := myVarsPtr^.bytesCopied + myNumBytes;

   {If all samples have been copied, then this is the last buffer.}
   IF myVarsPtr^.bytesCopied = myVarsPtr^.bytesTotal THEN
      doubleBuffer^.dbFlags := BOR(doubleBuffer^.dbFlags, dbLastBuffer);
END;
</PRE>
</BLOCKQUOTE>
<HR>
<center>
<A HREF="Sound-57.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Sound-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Sound-336.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="Sound-59.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="Sound-3.html">&copy; Apple Computer, Inc.</A><br>2 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>  
