{	File:		UGlobals.p	Contains:	This unit contains declarations and routines that didn’t seem to fit into any				other unit in this application.	Written by: Forrest Tanaka		Copyright:	Copyright © 1988-1999 by Apple Computer, Inc., All Rights Reserved.				You may incorporate this Apple sample source code into your program(s) without				restriction. This Apple sample source code has been provided "AS IS" and the				responsibility for its operation is yours. You are not permitted to redistribute				this Apple sample source code as "Apple sample source code" after having made				changes. If you're going to re-distribute the source, we require that you make				it clear in the source that the code was descended from Apple sample source				code, but that you've made changes.	Change History (most recent first):				7/27/1999	Karl Groethe	Updated for Metrowerks Codewarror Pro 2.1				}UNIT UGlobals;{[j=20/57/1$] Pasmat Options}INTERFACE(******************************************************************************** Used Units*******************************************************************************)	USES		Dialogs		;		(******************************************************************************** Constants*******************************************************************************)	CONST		rMemErrMessages        = 1000; {Resource ID of memory error message STR#}		kMemErrAppOpenMsg      = 1;    {Not enough memory to open application}		kMemErrProcListOpenMsg = 2;    {Not enough mem to open process list wind}		kMemErrLowMemWarnMsg   = 3;    {Free memory is low; proceed with caution}		kMemErrProcInfoOpenMsg = 4;    {Not enough mem to open process info wind}		rResErrMessages     = 1001; {Resource ID of resource error message STR#}		kResErrAppDamageMsg = 1;    {Application is damaged}		rMiscErrMessages   = 1002; {Resource ID of misc. error message STR#}		kMiscErrUnknownMsg = 1;    {Unknown error}		kMiscSystemTooSmall = 2;    {Unknown error}		rMiscWrnMessages     = 2000; {Resource ID of misc. warning message STR#}		kMiscWrnUncleanMsg   = 1;    {Application not 32-bit clean warning}		kMiscWrnLaunchMemMsg = 2;    {Not enough memory to launch}		kMiscWrnQuitSureMsg	 = 3;    {Sure you want to Quit?}		kMaxSleepTime = 60; {Max WNE sleep time in ticks, 1 second in this case}(******************************************************************************** Global Variables*******************************************************************************)	VAR		gError:        Integer; {Generic application error code}		gQuitting:     Boolean; {TRUE if user chose Quit command}(******************************************************************************** DoQuit - Handle Quit command** This routine is called when this application should quit.  It’s called* when the user chooses the Quit command from the file menu or when a 'quit'* AppleEvent is received.  It puts up a quit confirm dialog and returns noErr if* the user OKs the quit.*******************************************************************************)	FUNCTION DoQuit: OSErr;(******************************************************************************** HasColourQuickDraw - Returns true if we have Colour QuickDraw*******************************************************************************)	FUNCTION HasColourQuickDraw : Boolean;(******************************************************************************** ShowStopAlert - Show a stop alert** This routine puts up a standard stop alert with just an OK button and a* specified message.  messageClass specifies the STR# resource ID which contains* the message to display and messageIndex specifies the index (the first message* is index 1) into that STR# of the message to display.*******************************************************************************)	FUNCTION ShowStopAlert (messageClass: Integer;	                        messageIndex: Integer; VAR itemHit: Integer): OSErr;(******************************************************************************** ShowCautionOKCancelAlert - Show a caution alert with an OK and Cancel button** This routine puts up a standard caution alert with just an OK button, a Cancel* button, and a specified message.  messageClass specifies the STR# resource ID* which contains the message to display and messageIndex specifies the index* (the first message is index 1) into that STR# of the message to display.*******************************************************************************)	FUNCTION ShowCautionOKCancelAlert (messageClass: Integer;	                                   messageIndex: Integer; VAR itemHit: Integer): OSErr;(******************************************************************************** ShowCautionOKAlert - Show a caution alert with just an OK button** This routine puts up a standard caution alert with just an OK button and a* specified message.  messageClass specifies the STR# resource ID which contains* the message to display and messageIndex specifies the index (the first message* is index 1) into that STR# of the message to display.*******************************************************************************)	FUNCTION ShowCautionOKAlert (messageClass: Integer;	                             messageIndex: Integer; VAR itemHit: Integer): OSErr;(******************************************************************************** ShowAboutBox - Show the About box** The About box for this application is displayed.  This is just a simple alert* box with an OK button.  The name of this application is displayed as is its* version number.*******************************************************************************)	PROCEDURE ShowAboutBox;(******************************************************************************** CreateWindow - Create a window** This routine creates a window using the WIND resource template with a resource* ID of windowTmplID in front of all existing windows.  A pointer to this window* is returned.  If we’re running on a Color QuickDraw machine, the window is* created as a color window.  This window must be disposed of by calling* CloseWindow followed by DisposePtr on the window’s WindowRecord.  The window* shouldn’t be closed using DisposeWindow.  When this routine returns, the new* window is the current GrafPort.** The window isn’t explicitly repositioned from its position as defined by the* resource definition.  Instead, I use the window-positioning utilities.  This* isn’t documented at this time and it isn’t even certain the these utilities* will be implemented in the final release of system software 7.0.  Use ResEdit* 2.1’s WIND editor to control the window-positioning utilities.** If there isn’t enough memory for the window, then gError global is set to* memFullErr.  If the WIND resource couldn’t be loaded, gError is set to* resNotFound.  If anything else went wrong while creating the window, then* gError is set to dsSysErr.*******************************************************************************)	FUNCTION CreateWindow (windowTmplID: Integer): WindowPtr;(******************************************************************************** CreateDialog - Create a dialog window** This routine creates a dialog window using the WIND resource template with a* resource ID of windowTmplID in front of all existing windows.  A pointer to* this window is returned.  If we’re running on a Color QuickDraw machine, the* window is created as a color window.  This window must be disposed of by* calling CloseWindow followed by DisposePtr on the window’s DialogRecord.  The* window shouldn’t be closed using DisposeWindow.  When this routine returns,* the new dialog is the current GrafPort.** The window isn’t explicitly repositioned from its position as defined by the* resource definition.  Instead, I use the window-positioning utilities.  This* isn’t documented at this time and it isn’t even certain the these utilities* will be implemented in the final release of system software 7.0.  Use ResEdit* 2.1’s WIND editor to control the window-positioning utilities.** If there isn’t enough memory for the window, then gError global is set to* memFullErr.  If the WIND resource couldn’t be loaded, gError is set to* resNotFound.  If anything else went wrong while creating the window, then* gError is set to dsSysErr.*******************************************************************************)	FUNCTION CreateDialog (dialogTmplID: Integer): DialogPtr;(******************************************************************************** InitGlobals - Initialise this module*******************************************************************************)	PROCEDURE InitGlobals;IMPLEMENTATION	USES		Notification		,Resources		,TextUtils		,GestaltEqu		,AppleEvents				,UEmergMem		,UEvents		;(******************************************************************************** Constants*******************************************************************************)	CONST		rOKAlertID       = 6010; {Resource ID of alert with OK button}		rOKCancelAlertID = 6011; {Resource ID of alert with OK and Cancel buttons}		rIconSuiteID   = 128; {Resource ID of application icon suite}		rAppNameString = 0;   {Resource ID of application name}		rAboutAlert    = 258; {Resource ID of About alert}(******************************************************************************** Variables*******************************************************************************)	VAR		gNotifyAlertIdleUPP: AEIdleUPP;	VAR		gNotification: NMRec; {Notification record}{$S Main}(******************************************************************************** Public: DoQuit** The gQuitting global variable is set to TRUE.  This causes the main event loop* to terminate on the next iteration.*******************************************************************************)	FUNCTION DoQuit: OSErr;		VAR			error: OSErr;			itemHit: Integer;	BEGIN		error := ShowCautionOKCancelAlert (rMiscWrnMessages, kMiscWrnQuitSureMsg, itemHit);		IF error = noErr THEN			if itemHit = ok THEN				gQuitting := TRUE			ELSE				error := userCanceledErr;		DoQuit := error;	END;{$S Main}(******************************************************************************** HasColourQuickDraw** Returns true if we have Colour QuickDraw.  Note we do not use * gestaltQuickdrawFeatures -> gestaltHasColor because that bit is set* on a 68000 machine running System 7.*******************************************************************************)	FUNCTION HasColourQuickDraw : Boolean;		VAR			qdVersion : LongInt;	BEGIN		HasColourQuickDraw := ( ( Gestalt (gestaltQuickdrawVersion, (*<*)qdVersion) = noErr) &				(qdVersion > gestaltOriginalQD) );	END;{$S Main}(******************************************************************************** Private: NotifyAlert - Present a notification for an alert** This routine is called to present a notification to the user in the form of a* flashing icon in the application menu whenever an alert from this program is* displayed and the application is in the background.  We do this by calling* AEInteractWithUser, which is very useful utility routine provided by the* AppleEvent Manager for this very purpose.*******************************************************************************)	FUNCTION NotifyAlertIdleProc(VAR theEvent: EventRecord; VAR sleepTime: LONGINT; VAR mouseRgn: RgnHandle): BOOLEAN;	BEGIN		{$unused sleepTime}		{$unused mouseRgn}		CASE theEvent.what OF			updateEvt,	     	activateEvt,	     	osEvt:				BEGIN					DoEvent(theEvent);				END;			OTHERWISE				(* do nothing *)		END;		NotifyAlertIdleProc := FALSE;		(* Continue waiting. *)	END;	FUNCTION NotifyAlert : OSErr;		VAR			iconSuite: Handle;      {Handle to the icon suite}			error:     OSErr;	BEGIN		(* If this application isn’t in front, post a notification *)		(* Get the small icon for this application *)		iconSuite := Get1Resource ('SICN', rIconSuiteID);		WITH gNotification DO			BEGIN				(*WITH*)qType := ORD (nmtype);				(*WITH*)nmMark := 1;				(*WITH*)nmIcon := iconSuite;				(*WITH*)nmSound := Handle(-1);				(*WITH*)nmStr := NIL;				(*WITH*)nmResp := NIL;				(*WITH*)nmRefCon := 0			END;		error := AEInteractWithUser(kAEDefaultTimeout, @gNotification, gNotifyAlertIdleUPP);		IF error = noErr THEN			InitCursor;		NotifyAlert := error;	END;{$S Main}(******************************************************************************** Public: ShowStopAlert** NotifyAlert is called to present a notification to the user in case this* application is in the background at the time of the alert.  This routine then* removes the notification after StopAlert is called.*******************************************************************************)	FUNCTION ShowStopAlert (messageClass: Integer;	                        messageIndex: Integer; VAR itemHit: Integer): OSErr;		VAR			aMessage: Str255; {Contents of message to place in alert}			error: OSErr;				BEGIN		(* Put the specified message into the dialog parameter text *)		GetIndString ((*<*)aMessage, messageClass, messageIndex);		ParamText (aMessage, '', '', '');		(* Show the stop alert *)		error := NotifyAlert;		IF error = noErr THEN			itemHit := StopAlert (rOKAlertID, NIL);						ShowStopAlert := error;	END;{$S Main}(******************************************************************************** Public: ShowCautionOKCancelAlert** NotifyAlert is called to present a notification to the user in case this* application is in the background at the time of the alert.  This routine then* removes the notification after ShowCautionOKCancelAlert is called.*******************************************************************************)	FUNCTION ShowCautionOKCancelAlert (messageClass: Integer;	                                   messageIndex: Integer; VAR itemHit: Integer): OSErr;		VAR			aMessage: Str255; {Contents of message to place in alert}			error: OSErr;	BEGIN		(* Put the specified message into the dialog parameter text *)		GetIndString ((*<*)aMessage, messageClass, messageIndex);		ParamText (aMessage, '', '', '');		(* Show the stop alert *)		error := NotifyAlert;		IF error = noErr THEN			itemHit := CautionAlert (rOKCancelAlertID, NIL);		ShowCautionOKCancelAlert := error;	END;{$S Main}(******************************************************************************** Public: ShowCautionOKAlert** NotifyAlert is called to present a notification to the user in case this* application is in the background at the time of the alert.  This routine then* removes the notification after ShowCautionOKAlert is called.*******************************************************************************)	FUNCTION ShowCautionOKAlert (messageClass: Integer;	                             messageIndex: Integer; VAR itemHit: Integer): OSErr;		VAR			aMessage: Str255; {Contents of message to place in alert}			error:    OSErr;	BEGIN		(* Put the specified message into the dialog parameter text *)		GetIndString ((*<*)aMessage, messageClass, messageIndex);		ParamText (aMessage, '', '', '');		(* Show the stop alert *)		error := NotifyAlert;		IF error = noErr THEN			itemHit := CautionAlert (rOKAlertID, NIL);				ShowCautionOKAlert := error;	END;{$S Main}(******************************************************************************** Public: ShowAboutBox** The name and the version number of this application are retrieved from* resources.  They’re then displayed in the About box using the ParamText* mechanism.*******************************************************************************)	PROCEDURE ShowAboutBox;		VAR			appNameRes: StringHandle; {Handle to name of application}			curVersion: VersRecHndl;  {Handle to version record of this app}			appName:    Str255;       {Name of this application}			verNum:     Str255;       {Long version number of this application}			itemHit:    Integer;      {Item number of clicked alert item; ignored}	BEGIN		(* Get the name of this application *)		appNameRes := GetString (rAppNameString);		IF appNameRes <> NIL THEN			appName := appNameRes^^		ELSE			appName := '?';		(* Get the version information of this application *)		curVersion := VersRecHndl (Get1Resource ('vers', 1));		IF curVersion <> NIL THEN			(* Get the long version number *)			verNum := StringPtr(ORD(@curVersion^^.shortVersion) +					ORD(curVersion^^.shortVersion[0]) + 1)^		ELSE			verNum := '?';		(* Show the About alert *)		ParamText(appName, verNum, '', '');		itemHit := Alert (rAboutAlert, NIL);	END;{$S Main}(******************************************************************************** Public: CreateWindow** A WindowRecord is allocated on the heap before GetNewWindow is called.  This* is done to reduce heap fragmentation.*******************************************************************************)	FUNCTION CreateWindow (windowTmplID: Integer): WindowPtr;		VAR			windStore: Ptr;       {Pointer to window record}			aWindow:   WindowPtr; {Pointer to the new window}		PROCEDURE RecoverError (error: Integer);		BEGIN			IF aWindow <> NIL THEN				CloseWindow (aWindow);			IF windStore <> NIL THEN				DisposePtr (windStore);			gError := error;			CreateWindow := NIL;			EXIT (CreateWindow)		END;	BEGIN		windStore := NIL;		aWindow := NIL;		(* Allocate window record *)		windStore := NewPtrMargin (SIZEOF (WindowRecord), kAllocApp,				NOT kAllocClr);		(* Create the new window *)		IF windStore = NIL THEN			RecoverError (memFullErr)		ELSE			BEGIN				(* Create the new window *)				IF NOT HasColourQuickDraw THEN					aWindow := GetNewWindow (windowTmplID, windStore, WindowPtr(-1))				ELSE					aWindow := GetNewCWindow (windowTmplID, windStore,							 WindowPtr(-1));				IF FailLowMemory (0) THEN					RecoverError (memFullErr)				ELSE IF ResError <> noErr THEN					IF ResError = memFullErr THEN						RecoverError (memFullErr)					ELSE IF (ResError = noErr) | (ResError = resNotFound) THEN						RecoverError (resNotFound)					ELSE						RecoverError (dsSysErr);				SetPort (aWindow);				SetWRefCon (aWindow, 0)			END;		CreateWindow := aWindow	END;{$S Main}(******************************************************************************** Public: CreateDialog** A DialogRecord is allocated on the heap before GetNewWindow is called.  This* is done to reduce heap fragmentation.*******************************************************************************)	FUNCTION CreateDialog (dialogTmplID: Integer): DialogPtr;		VAR			dlogStore: Ptr;       {Pointer to dialog record}			aDialog:   DialogPtr; {Pointer to the new dialog window}		PROCEDURE RecoverError (error: Integer);		BEGIN			IF aDialog <> NIL THEN				CloseWindow (aDialog);			IF dlogStore <> NIL THEN				DisposePtr (dlogStore);			gError := error;			CreateDialog := NIL;			EXIT (CreateDialog)		END;	BEGIN		dlogStore := NIL;		aDialog := NIL;		(* Allocate window record *)		dlogStore := NewPtrMargin (SizeOf (DialogRecord), kAllocApp,				NOT kAllocClr);		(* Create the new window *)		IF dlogStore = NIL THEN			RecoverError (memFullErr)		ELSE			BEGIN				IF NOT HasColourQuickDraw THEN					aDialog := GetNewWindow (dialogTmplID, dlogStore, WindowPtr(-1))				ELSE					aDialog := GetNewCWindow (dialogTmplID, dlogStore,							WindowPtr(-1));				IF FailLowMemory (0) THEN					RecoverError (memFullErr)				ELSE IF ResError <> noErr THEN					IF ResError = memFullErr THEN						RecoverError (memFullErr)					ELSE IF (ResError = noErr) | (ResError = resNotFound) THEN						RecoverError (resNotFound)					ELSE						RecoverError (dsSysErr);				SetPort (aDialog);				SetWRefCon (aDialog, 0)			END;		CreateDialog := aDialog	END;{$S Startup}(******************************************************************************** Public: InitGlobals*******************************************************************************)	PROCEDURE InitGlobals;	BEGIN		gNotifyAlertIdleUPP := NewAEIdleProc(@NotifyAlertIdleProc);	END;END.