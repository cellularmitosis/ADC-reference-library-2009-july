<html><head><title>Mac OS X
 Manual Page For perlmodstyle(1)</title>
<style type="text/css"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { font-size: 1px; background: #ffffff; color: #ffffff; } --></style>
<style type="text/css" media="print, aural, braille, embossed, projection, tty"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { display: none; } --></style>
</head><body bgcolor="white">
<a name="//apple_ref/doc/man/1/perlmodstyle" title="Mac OS X
 Manual Page for perlmodstyle(1)"><!-- headerDoc=man; indexgroup=Section 1; uid="//apple_ref/doc/man/1/perlmodstyle"; name=perlmodstyle(1) --></a>
<!--#include virtual="/includes/framesetheader"-->
<table width=600><tr><td scope="row">
<!-- begin breadcrumb insert request --><font face="Geneva,Helvetica,Arial" size="1">
 <a target="_top" href="http://developer.apple.com">ADC Home</a> <b>&gt;</b> <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> <b>&gt;</b> <a href="../../../../../reference/index.html#//apple_ref/doc/uid/TP30001281" target="_top">Reference</a> <b>&gt;</b> <!-- a href="" target="_top" -->Mac OS X<!-- /a --> <b>&gt;</b> <a href="../index.html#//apple_ref/doc/framework/manpages" target="_top">Mac OS X Man Pages</a></font>
<!-- end breadcrumb insert request -->
<p>&nbsp;</p>
</td></tr></table>
<!-- end of header -->
<table border="0"  cellpadding="2" cellspacing="2" width="630pt"><tr><td valign="top" height="12" colspan="5" scope="row">
<p style='text-align:justify;'>This document is a Mac OS X manual page.  Manual pages are a command-line technology
for providing documentation.  You can view these manual pages locally using the
<a href="man.1.html#//apple_ref/doc/man/1/man">man(1)</a> command.
These manual pages come from many different sources, and thus, have a variety of writing
styles.</p>
<p style='text-align:justify;'>For more information about the manual page format, see the manual page for 
<a href="../man5/manpages.5.html#//apple_ref/doc/man/5/manpages">manpages(5)</a>.</p>
</td></tr></table>
<hr />
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row"><pre class="manpages"><tt>
PERLMODSTYLE(1)                       Perl Programmers Reference Guide                       PERLMODSTYLE(1)



<b>NAME</b>
       perlmodstyle - Perl module style guide

<b>INTRODUCTION</b>
       This document attempts to describe the Perl Community's "best practice" for writing Perl modules.  It
       extends the recommendations found in perlstyle , which should be considered required reading before
       reading this document.

       While this document is intended to be useful to all module authors, it is particularly aimed at
       authors who wish to publish their modules on CPAN.

       The focus is on elements of style which are visible to the users of a module, rather than those parts
       which are only seen by the module's developers.  However, many of the guidelines presented in this
       document can be extrapolated and applied successfully to a module's internals.

       This document differs from perlnewmod in that it is a style guide rather than a tutorial on creating
       CPAN modules.  It provides a checklist against which modules can be compared to determine whether
       they conform to best practice, without necessarily describing in detail how to achieve this.

       All the advice contained in this document has been gleaned from extensive conversations with experi-<font color="#ffffff" class="whiteout">enced&nbsp;experienced</font>
       enced CPAN authors and users.  Every piece of advice given here is the result of previous mistakes.
       This information is here to help you avoid the same mistakes and the extra work that would inevitably
       be required to fix them.

       The first section of this document provides an itemized checklist; subsequent sections provide a more
       detailed discussion of the items on the list.  The final section, "Common Pitfalls", describes some
       of the most popular mistakes made by CPAN authors.

<b>QUICK</b> <b>CHECKLIST</b>
       For more detail on each item in this checklist, see below.

       <b>Before</b> <b>you</b> <b>start</b>


          Don't re-invent the wheel

          Patch, extend or subclass an existing module where possible

          Do one thing and do it well

          Choose an appropriate name

       <b>The</b> <b>API</b>


          API should be understandable by the average programmer

          Simple methods for simple tasks

          Separate functionality from output

          Consistent naming of subroutines or methods

          Use named parameters (a hash or hashref) when there are more than two parameters

       <b>Stability</b>


          Ensure your module works under "use strict" and "-w"

          Stable modules should maintain backwards compatibility

       <b>Documentation</b>


          Write documentation in POD

          Document purpose, scope and target applications

          Document each publically accessible method or subroutine, including params and return values

          Give examples of use in your documentation

          Provide a README file and perhaps also release notes, changelog, etc

          Provide links to further information (URL, email)

       <b>Release</b> <b>considerations</b>


          Specify pre-requisites in Makefile.PL or Build.PL

          Specify Perl version requirements with "use"

          Include tests with your module

          Choose a sensible and consistent version numbering scheme (X.YY is the common Perl module number-<font color="#ffffff" class="whiteout">ing&nbsp;numbering</font>
           ing scheme)

          Increment the version number for every change, no matter how small

          Package the module using "make dist"

          Choose an appropriate license (GPL/Artistic is a good default)

<b>BEFORE</b> <b>YOU</b> <b>START</b> <b>WRITING</b> <b>A</b> <b>MODULE</b>
       Try not to launch headlong into developing your module without spending some time thinking first.  A
       little forethought may save you a vast amount of effort later on.

       <b>Has</b> <b>it</b> <b>been</b> <b>done</b> <b>before?</b>

       You may not even need to write the module.  Check whether it's already been done in Perl, and avoid
       re-inventing the wheel unless you have a good reason.

       Good places to look for pre-existing modules include <a href="http://search.cpan.org/">http://search.cpan.org/</a> and asking on mod-
       ules@perl.org

       If an existing module <b>almost</b> does what you want, consider writing a patch, writing a subclass, or
       otherwise extending the existing module rather than rewriting it.

       <b>Do</b> <b>one</b> <b>thing</b> <b>and</b> <b>do</b> <b>it</b> <b>well</b>

       At the risk of stating the obvious, modules are intended to be modular.  A Perl developer should be
       able to use modules to put together the building blocks of their application.  However, it's impor-
       tant that the blocks are the right shape, and that the developer shouldn't have to use a big block
       when all they need is a small one.

       Your module should have a clearly defined scope which is no longer than a single sentence.  Can your
       module be broken down into a family of related modules?

       Bad example:

       "FooBar.pm provides an implementation of the FOO protocol and the related BAR standard."

       Good example:

       "Foo.pm provides an implementation of the FOO protocol.  Bar.pm implements the related BAR protocol."

       This means that if a developer only needs a module for the BAR standard, they should not be forced to
       install libraries for FOO as well.

       <b>What's</b> <b>in</b> <b>a</b> <b>name?</b>

       Make sure you choose an appropriate name for your module early on.  This will help people find and
       remember your module, and make programming with your module more intuitive.

       When naming your module, consider the following:

          Be descriptive (i.e. accurately describes the purpose of the module).

          Be consistent with existing modules.

          Reflect the functionality of the module, not the implementation.

          Avoid starting a new top-level hierarchy, especially if a suitable hierarchy already exists under
           which you could place your module.

       You should contact modules@perl.org to ask them about your module name before publishing your module.
       You should also try to ask people who are already familiar with the module's application domain and
       the CPAN naming system.  Authors of similar modules, or modules with similar names, may be a good
       place to start.

<b>DESIGNING</b> <b>AND</b> <b>WRITING</b> <b>YOUR</b> <b>MODULE</b>
       Considerations for module design and coding:

       <b>To</b> <b>OO</b> <b>or</b> <b>not</b> <b>to</b> <b>OO?</b>

       Your module may be object oriented (OO) or not, or it may have both kinds of interfaces available.
       There are pros and cons of each technique, which should be considered when you design your API.

       According to Damian Conway, you should consider using OO:

          When the system is large or likely to become so

          When the data is aggregated in obvious structures that will become objects

          When the types of data form a natural hierarchy that can make use of inheritance

          When operations on data vary according to data type (making polymorphic invocation of methods
           feasible)

          When it is likely that new data types may be later introduced into the system, and will need to
           be handled by existing code

          When interactions between data are best represented by overloaded operators

          When the implementation of system components is likely to change over time (and hence should be
           encapsulated)

          When the system design is itself object-oriented

          When large amounts of client code will use the software (and should be insulated from changes in
           its implementation)

          When many separate operations will need to be applied to the same set of data

       Think carefully about whether OO is appropriate for your module.  Gratuitous object orientation
       results in complex APIs which are difficult for the average module user to understand or use.

       <b>Designing</b> <b>your</b> <b>API</b>

       Your interfaces should be understandable by an average Perl programmer.  The following guidelines may
       help you judge whether your API is sufficiently straightforward:

       Write simple routines to do simple things.
           It's better to have numerous simple routines than a few monolithic ones.  If your routine changes
           its behaviour significantly based on its arguments, it's a sign that you should have two (or
           more) separate routines.

       Separate functionality from output.
           Return your results in the most generic form possible and allow the user to choose how to use
           them.  The most generic form possible is usually a Perl data structure which can then be used to
           generate a text report, HTML, XML, a database query, or whatever else your users require.

           If your routine iterates through some kind of list (such as a list of files, or records in a
           database) you may consider providing a callback so that users can manipulate each element of the
           list in turn.  File::Find provides an example of this with its "find(\&amp;wanted, $dir)" syntax.

       Provide sensible shortcuts and defaults.
           Don't require every module user to jump through the same hoops to achieve a simple result.  You
           can always include optional parameters or routines for more complex or non-standard behaviour.
           If most of your users have to type a few almost identical lines of code when they start using
           your module, it's a sign that you should have made that behaviour a default.  Another good indi-
           cator that you should use defaults is if most of your users call your routines with the same
           arguments.

       Naming conventions
           Your naming should be consistent.  For instance, it's better to have:

                   display_day();
                   display_week();
                   display_year();

           than

                   display_day();
                   week_display();
                   show_year();

           This applies equally to method names, parameter names, and anything else which is visible to the
           user (and most things that aren't!)

       Parameter passing
           Use named parameters. It's easier to use a hash like this:

               $obj-&gt;do_something(
                       name =&gt; "wibble",
                       type =&gt; "text",
                       size =&gt; 1024,
               );

           ... than to have a long list of unnamed parameters like this:

               $obj-&gt;do_something("wibble", "text", 1024);

           While the list of arguments might work fine for one, two or even three arguments, any more argu-
           ments become hard for the module user to remember, and hard for the module author to manage.  If
           you want to add a new parameter you will have to add it to the end of the list for backward com-
           patibility, and this will probably make your list order unintuitive.  Also, if many elements may
           be undefined you may see the following unattractive method calls:

               $obj-&gt;do_something(undef, undef, undef, undef, undef, undef, 1024);

           Provide sensible defaults for parameters which have them.  Don't make your users specify parame-
           ters which will almost always be the same.

           The issue of whether to pass the arguments in a hash or a hashref is largely a matter of personal
           style.

           The use of hash keys starting with a hyphen ("-name") or entirely in upper case ("NAME") is a
           relic of older versions of Perl in which ordinary lower case strings were not handled correctly
           by the "=&gt;" operator.  While some modules retain uppercase or hyphenated argument keys for his-
           torical reasons or as a matter of personal style, most new modules should use simple lower case
           keys.  Whatever you choose, be consistent!

       <b>Strictness</b> <b>and</b> <b>warnings</b>

       Your module should run successfully under the strict pragma and should run without generating any
       warnings.  Your module should also handle taint-checking where appropriate, though this can cause
       difficulties in many cases.

       <b>Backwards</b> <b>compatibility</b>

       Modules which are "stable" should not break backwards compatibility without at least a long transi-
       tion phase and a major change in version number.

       <b>Error</b> <b>handling</b> <b>and</b> <b>messages</b>

       When your module encounters an error it should do one or more of:

          Return an undefined value.

          set $Module::errstr or similar ("errstr" is a common name used by DBI and other popular modules;
           if you choose something else, be sure to document it clearly).

          "warn()" or "carp()" a message to STDERR.

          "croak()" only when your module absolutely cannot figure out what to do.  ("croak()" is a better
           version of "die()" for use within modules, which reports its errors from the perspective of the
           caller.  See Carp for details of "croak()", "carp()" and other useful routines.)

          As an alternative to the above, you may prefer to throw exceptions using the Error module.

       Configurable error handling can be very useful to your users.  Consider offering a choice of levels
       for warning and debug messages, an option to send messages to a separate file, a way to specify an
       error-handling routine, or other such features.  Be sure to default all these options to the common-
       est use.

<b>DOCUMENTING</b> <b>YOUR</b> <b>MODULE</b>
       <b>POD</b>

       Your module should include documentation aimed at Perl developers.  You should use Perl's "plain old
       documentation" (POD) for your general technical documentation, though you may wish to write addi-
       tional documentation (white papers, tutorials, etc) in some other format.  You need to cover the fol-
       lowing subjects:

          A synopsis of the common uses of the module

          The purpose, scope and target applications of your module

          Use of each publically accessible method or subroutine, including parameters and return values

          Examples of use

          Sources of further information

          A contact email address for the author/maintainer

       The level of detail in Perl module documentation generally goes from less detailed to more detailed.
       Your SYNOPSIS section should contain a minimal example of use (perhaps as little as one line of code;
       skip the unusual use cases or anything not needed by most users); the DESCRIPTION should describe
       your module in broad terms, generally in just a few paragraphs; more detail of the module's routines
       or methods, lengthy code examples, or other in-depth material should be given in subsequent sections.

       Ideally, someone who's slightly familiar with your module should be able to refresh their memory
       without hitting "page down".  As your reader continues through the document, they should receive a
       progressively greater amount of knowledge.

       The recommended order of sections in Perl module documentation is:

          NAME

          SYNOPSIS

          DESCRIPTION

          One or more sections or subsections giving greater detail of available methods and routines and
           any other relevant information.

          BUGS/CAVEATS/etc

          AUTHOR

          SEE ALSO

          COPYRIGHT and LICENSE

       Keep your documentation near the code it documents ("inline" documentation).  Include POD for a given
       method right above that method's subroutine.  This makes it easier to keep the documentation up to
       date, and avoids having to document each piece of code twice (once in POD and once in comments).

       <b>README,</b> <b>INSTALL,</b> <b>release</b> <b>notes,</b> <b>changelogs</b>

       Your module should also include a README file describing the module and giving pointers to further
       information (website, author email).

       An INSTALL file should be included, and should contain simple installation instructions. When using
       ExtUtils::MakeMaker this will usually be:

       perl Makefile.PL
       make
       make test
       make install

       When using Module::Build, this will usually be:

       perl Build.PL
       perl Build
       perl Build test
       perl Build install

       Release notes or changelogs should be produced for each release of your software describing user-vis-
       ible changes to your module, in terms relevant to the user.

<b>RELEASE</b> <b>CONSIDERATIONS</b>
       <b>Version</b> <b>numbering</b>

       Version numbers should indicate at least major and minor releases, and possibly sub-minor releases.
       A major release is one in which most of the functionality has changed, or in which major new func-
       tionality is added.  A minor release is one in which a small amount of functionality has been added
       or changed.  Sub-minor version numbers are usually used for changes which do not affect functional-
       ity, such as documentation patches.

       The most common CPAN version numbering scheme looks like this:

           1.00, 1.10, 1.11, 1.20, 1.30, 1.31, 1.32

       A correct CPAN version number is a floating point number with at least 2 digits after the decimal.
       You can test whether it conforms to CPAN by using

           perl -MExtUtils::MakeMaker -le 'print MM-&gt;parse_version(shift)' 'Foo.pm'

       If you want to release a 'beta' or 'alpha' version of a module but don't want CPAN.pm to list it as
       most recent use an '_' after the regular version number followed by at least 2 digits, eg. 1.20_01.
       If you do this, the following idiom is recommended:

         $VERSION = "1.12_01";
         $XS_VERSION = $VERSION; # only needed if you have XS code
         $VERSION = eval $VERSION;

       With that trick MakeMaker will only read the first line and thus read the underscore, while the perl
       interpreter will evaluate the $VERSION and convert the string into a number. Later operations that
       treat $VERSION as a number will then be able to do so without provoking a warning about $VERSION not
       being a number.

       Never release anything (even a one-word documentation patch) without incrementing the number.  Even a
       one-word documentation patch should result in a change in version at the sub-minor level.

       <b>Pre-requisites</b>

       Module authors should carefully consider whether to rely on other modules, and which modules to rely
       on.

       Most importantly, choose modules which are as stable as possible.  In order of preference:

          Core Perl modules

          Stable CPAN modules

          Unstable CPAN modules

          Modules not available from CPAN

       Specify version requirements for other Perl modules in the pre-requisites in your Makefile.PL or
       Build.PL.

       Be sure to specify Perl version requirements both in Makefile.PL or Build.PL and with "require 5.6.1"
       or similar. See the section on "use VERSION" of "require" in perlfunc for details.

       <b>Testing</b>

       All modules should be tested before distribution (using "make disttest"), and the tests should also
       be available to people installing the modules (using "make test").  For Module::Build you would use
       the "make test" equivalent "perl Build test".

       The importance of these tests is proportional to the alleged stability of a module -- a module which
       purports to be stable or which hopes to achieve wide use should adhere to as strict a testing regime
       as possible.

       Useful modules to help you write tests (with minimum impact on your development process or your time)
       include Test::Simple, Carp::Assert and Test::Inline.  For more sophisticated test suites there are
       Test::More and Test::MockObject.

       <b>Packaging</b>

       Modules should be packaged using one of the standard packaging tools.  Currently you have the choice
       between ExtUtils::MakeMaker and the more platform independent Module::Build, allowing modules to be
       installed in a consistent manner.  When using ExtUtils::MakeMaker, you can use "make dist" to create
       your package. Tools exist to help you to build your module in a MakeMaker-friendly style. These
       include ExtUtils::ModuleMaker and h2xs.  See also perlnewmod.

       <b>Licensing</b>

       Make sure that your module has a license, and that the full text of it is included in the distribu-
       tion (unless it's a common one and the terms of the license don't require you to include it).

       If you don't know what license to use, dual licensing under the GPL and Artistic licenses (the same
       as Perl itself) is a good idea.  See perlgpl and perlartistic.

<b>COMMON</b> <b>PITFALLS</b>
       <b>Reinventing</b> <b>the</b> <b>wheel</b>

       There are certain application spaces which are already very, very well served by CPAN.  One example
       is templating systems, another is date and time modules, and there are many more.  While it is a rite
       of passage to write your own version of these things, please consider carefully whether the Perl
       world really needs you to publish it.

       <b>Trying</b> <b>to</b> <b>do</b> <b>too</b> <b>much</b>

       Your module will be part of a developer's toolkit.  It will not, in itself, form the <b>entire</b> toolkit.
       It's tempting to add extra features until your code is a monolithic system rather than a set of modu-
       lar building blocks.

       <b>Inappropriate</b> <b>documentation</b>

       Don't fall into the trap of writing for the wrong audience.  Your primary audience is a reasonably
       experienced developer with at least a moderate understanding of your module's application domain,
       who's just downloaded your module and wants to start using it as quickly as possible.

       Tutorials, end-user documentation, research papers, FAQs etc are not appropriate in a module's main
       documentation.  If you really want to write these, include them as sub-documents such as "My::Mod-
       ule::Tutorial" or "My::Module::FAQ" and provide a link in the SEE ALSO section of the main documenta-
       tion.

<b>SEE</b> <b>ALSO</b>
       perlstyle
           General Perl style guide

       perlnewmod
           How to create a new module

       perlpod
           POD documentation

       podchecker
           Verifies your POD's correctness

       Packaging Tools
           ExtUtils::MakeMaker, Module::Build

       Testing tools
           Test::Simple, Test::Inline, Carp::Assert, Test::More, Test::MockObject

       <a href="http://pause.perl.org/">http://pause.perl.org/</a>
           Perl Authors Upload Server.  Contains links to information for module authors.

       Any good book on software engineering

<b>AUTHOR</b>
       Kirrily "Skud" Robert &lt;skud@cpan.org&gt;



perl v5.8.8                                      2006-01-07                                  PERLMODSTYLE(1)
</tt></pre>
</td></tr></table>
	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Darwin/Reference/ManPages/man1/perlmodstyle.1.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Darwin/Reference/ManPages/man1/perlmodstyle.1.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Darwin/Reference/ManPages/man1/perlmodstyle.1.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

</body></html>
