<!-- Generated by Harlequin WebMaker 2.2.3 (30-Apr-1996)
Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->
<HTML> <HEAD>
<TITLE>Implementing an Expression Evaluation Method(IM:PN)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>

<A NAME="HEADING182"></A>


<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="PPCNumerics-181.html"><IMG ALIGN="BOTTOM" SRC="prev.gif" BORDER="none" HSPACE="20" ALT="Previous"></A> <A HREF="PPCNumerics-2.html"><IMG ALIGN="BOTTOM" SRC="content.gif" BORDER="none" HSPACE="20" ALT="Book Contents"></A> <A HREF="PPCNumerics-192.html"><IMG ALIGN="BOTTOM" SRC="index.gif" BORDER="none" HSPACE="20" ALT="Book Index"></A> <A HREF="PPCNumerics-183.html"><IMG ALIGN="BOTTOM" SRC="next.gif" BORDER="none" HSPACE="20" ALT="Next"></A> </CENTER><P>
<FONT SIZE="-1"><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="PPCNumerics-2.html"><B>PowerPC Numerics </B></A> / <A HREF="PPCNumerics-165.html"><B>Part 3 - Appendixes</B></A><BR><DD><A HREF="PPCNumerics-178.html"><B>Appendix D - FPCE Recommendations for Compilers</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME="HEADING182-0"></A>
<H1><A NAME="MARKER-9-19"></A>Implementing an Expression Evaluation Method</H1>
 <A NAME="MARKER-2-20"></A><A NAME="MARKER-2-21"></A><A NAME="MARKER-2-22"></A>Though PowerPC Numerics can recommend certain expression evaluation methods, these methods must be implemented by the compiler. As described in <A HREF="PPCNumerics-20.html#MARKER-9-1">Chapter 3, "Expression Evaluation,"</A> compilers may or may not support widest-need evaluation. This section describes <P>
<UL>
<LI>the advantages and disadvantages of supporting and not supporting widest-need evaluation
<LI>some special issues compilers must consider regarding evaluating floating-point constants and initializing floating-point variables
<LI>the FPCE-recommended macros and pragmas that help programmers use the most efficient types possible and determine which expression evaluation method is being used<P>
</UL>
<A NAME="HEADING182-5"></A>
<H2>Expression Evaluation Without Widest Need</H2>
 <A NAME="MARKER-2-23"></A>The main advantage of using an expression evaluation method without widest-need evaluation is that it is simple to implement. The PowerPC architecture is based on single-precision and double-precision operations, so either single or double is a logical choice for the minimum evaluation format. <P>
 <A NAME="MARKER-2-24"></A>Choosing single as the minimum format provides the highest performance for single-precision algorithms yet still allows double and double-double algorithms to be performed with greater precision and range. A single minimum evaluation format, then, allows the best possible performance for all expressions by allowing the semantic type of a simple expression to determine its evaluation format.<A NAME="MARKER-2-25"></A><P>
 <A NAME="MARKER-2-26"></A>Choosing double as the minimum format provides extra precision and range to single-precision operations and conforms to the traditional behavior of the C programming language (traditional C performs all floating-point operations in double precision). Performing all single-precision operations in double precision protects the operations against roundoff errors and against encountering an overflow or underflow in an intermediate value. For example, consider the following expression:<P>
 
<MATH>
10<SUP>38</SUP>&#215;10<SUP>20</SUP> OVER 10<SUP>20</SUP>
</MATH>

<P>
 If you perform this expression by hand, you get 
<MATH>
10<SUP>38</SUP>
</MATH>

. If all constants are in single format, the expression produces + <IMG BORDER="NONE" SRC="graphics/infinity.gif"> . The constant 
<MATH>
10<SUP>38</SUP>
</MATH>

 is near the end of the range of single format. Multiplying by 
<MATH>
10<SUP>20</SUP>
</MATH>

 produces <EM>
<MATH>
10<SUP>58</SUP>
</MATH>

</EM>, which is rounded to + <IMG BORDER="NONE" SRC="graphics/infinity.gif"> . Then, + <IMG BORDER="NONE" SRC="graphics/infinity.gif">  is divided by <EM>
<MATH>
10<SUP>20</SUP>
</MATH>

</EM>, and the answer is still + <IMG BORDER="NONE" SRC="graphics/infinity.gif"> .<P>
 If the minimum evaluation format is double, the constants 
<MATH>
10<SUP>38</SUP>
</MATH>

 and 
<MATH>
10<SUP>20</SUP>
</MATH>

 are converted to double format before the result is calculated. The multiplication operation no longer overflows the range of the data type because the double format can easily hold <EM>
<MATH>
10<SUP>58</SUP>
</MATH>

</EM>. The value <EM>
<MATH>
10<SUP>58</SUP>
</MATH>

</EM> divided by 
<MATH>
10<SUP>20</SUP>
</MATH>

 produces 
<MATH>
10<SUP>38</SUP>
</MATH>

, which is then converted back to single format. <A NAME="MARKER-2-27"></A><P>
 <A NAME="MARKER-9-40"></A>Choosing the double-double format provides the greatest available precision to all floating-point operations, protecting double-precision operations as well as single-precision operations from roundoff errors. However, it significantly decreases performance for those expressions that would normally be evaluated in a narrower format. In most cases, the extra precision is not necessary. <A NAME="MARKER-2-23"></A><P>
 Imposing a narrow format allows the best possible performance for narrow-format operations but might produce more roundoff errors in places where the extra precision really is necessary. <A NAME="MARKER-2-30"></A><A NAME="MARKER-2-31"></A>Using widest-need evaluation for complex expressions in conjunction with a minimum evaluation format minimizes the disadvantages of choosing one minimum evaluation format.<A NAME="MARKER-2-32"></A><P>
<A NAME="HEADING182-14"></A>
<H2>Expression Evaluation With Widest Need</H2>
 <A NAME="MARKER-2-33"></A><A NAME="MARKER-2-34"></A>Widest-need evaluation provides some of the advantages of using double-double as the minimum format while eliminating the pitfalls. With widest-need evaluation, if an expression contains a double-double variable, all other variables in that expression will ultimately be converted to double-double format, thus reducing the chance of roundoff error in these expressions. If an expression does not contain a double-double variable, widest-need evaluation allows the expression to be evaluated in the narrowest format possible, allowing the best possible performance for that expression. <A NAME="MARKER-2-35"></A><P>
 <A NAME="MARKER-2-36"></A>Widest-need evaluation can seriously inhibit the common subexpression removal optimization for subexpressions of narrower types. If the type of a subexpression is narrower than the type of its enclosing expression, the format of the enclosing expression is imposed on that subexpression. The subexpression's operands are converted to the wider format. Because the conversion must occur as if at run time, the common subexpression removal optimization is in effect disabled for this subexpression.<A NAME="MARKER-2-37"></A><A NAME="MARKER-2-38"></A><P>
<A NAME="HEADING182-17"></A>
<H2>Floating-Point Constant Evaluation</H2>
 <A NAME="MARKER-2-39"></A>When a floating-point constant expression appears in a program, the expression evaluation method determines its evaluation format. When widest-need evaluation is not used, the constant is the wider of the minimum evaluation format and the semantic type of the expression. With widest-need evaluation in effect, the constant is converted to the evaluation format of the complex expression it is part of. <P>
 <A NAME="MARKER-2-40"></A><A NAME="MARKER-2-41"></A>In most cases, floating-point constant expressions must be evaluated as if at run time, although they may actually be evaluated at compile time. At compile time, the default rounding direction is in effect, and no floating-point exceptions may be flagged. (These conditions are known as the default floating-point environment. See <A HREF="PPCNumerics-55.html#MARKER-9-12">Chapter 4, "Environmental Controls,"</A> for more information.) However, if evaluation takes place as if at run time, the floating-point environment may affect or be affected by the evaluation. This means that if an expression is unexceptional and the default rounding direction is in effect, the expression can be evaluated at compile time. If the expression is exceptional or the current environment is not in the default state, the expression must be evaluated at run time.<A NAME="MARKER-2-42"></A><A NAME="MARKER-2-43"></A><P>
 In the following two cases the evaluation always takes place at compile time:<P>
<UL>
<LI>The constant expression appears within the declaration of a variable explicitly declared to be static:<P>
<PRE>static double x = 0.3 + 0.3;</PRE>
<LI>The constant expression appears within the declaration of an aggregate type variable (array, structure, or union):<P>
<PRE>struct {int x = 0; double y = 0.3 + 0.3;} numbers;</PRE><P>
</UL>
 The requirement that floating-point constant expressions be evaluated as if at run time usually inhibits the constant folding optimization, in which values of constants are combined at compile time to produce fewer operations at run time. However, constant folding can occur<P>
<UL>
<LI>if a floating-point constant expression is required to be evaluated at compile time (that is, if the expression is part of the declaration of either an explicitly declared static variable or an aggregate type)
<LI>if the evaluation of the expression at compile time has exactly the same results as it would if evaluated at run time. This can happen under the following conditions:<P>
<UL>
<LI>If an expression evaluates to be nonexceptional at compile time, it would also evaluate to be nonexceptional at run time.
<LI>If the expression appears in a portion of the program where access to the floating-point environment is disabled, the default environment will be in effect at run time, just as it is at compile time.<P>
</UL>
</UL>
 The following example illustrates when floating-point constant expressions are evaluated:<P>
<PRE>
#pragma fenv_access on
void f(void) {
   float w[] = {0.0 / 0.0};      /* no exception raised */
   static float x = 0.0 / 0.0;   /* no exception raised */
   float y = 0.0 / 0.0;          /* exception raised */
   
   x = 1.0 / 4.0;                /* exact (no exception raised) */
   y = 1.0 / 3.0;                /* exception raised */
}
#pragma fenv_access off
void g(void) {
   double z;

   z = 0.0 / 0.0;                /* no exception raised */
}
</PRE>
 In the declaration of the array <CODE>w</CODE>, a floating-point constant expression contains division by zero. This operation is evaluated at compile time because it appears in the declaration of an aggregate type. Similarly, the division by zero in the declaration of <CODE>x</CODE> is evaluated at compile time because it is declared static. Neither of these expressions generates an exception, because they occur at compile time, although the compiler should generate a warning message in each case.<P>
 The next declaration (of <CODE>float y</CODE>) also includes the expression 
<MATH>
0.0/0.0
</MATH>

. This expression is evaluated at run time, and the invalid-operation exception is raised.<P>
 The first statement in function <CODE>f</CODE> assigns to <CODE>x</CODE> the value of the floating-point constant expression 
<MATH>
1.0/4.0
</MATH>

. The compiler looks at this expression to determine if it will raise any exceptions. The expression is found to be exact, so the compiler can optimize it.<P>
 The second statement of the function <CODE>f</CODE> assigns to <CODE>y</CODE> the value of the floating-point constant expression 
<MATH>
1.0/3.0
</MATH>

. The compiler determines that this expression will raise the inexact exception, so it must be evaluated at run time. The compiler cannot optimize it.<P>
 Finally, function <CODE>g</CODE> assigns to the double variable <CODE>z</CODE> the value of the floating-point constant expression 
<MATH>
0.0/0.0
</MATH>

. This statement appears after the <CODE>fenv_access</CODE> pragma has been turned off. This pragma (described in the section <A HREF="PPCNumerics-179.html#MARKER-9-4">"Environmental Access Switch" on page D-1</A>) signals to the compiler that the default environment will be in effect at run time. Because exceptions are disabled in the default environment, this statement will not raise a run-time exception, and so it may be evaluated at compile time and optimized. <A NAME="MARKER-9-1"></A><P>
<A NAME="HEADING182-37"></A>
<H2>Initializing Floating-Point Objects</H2>
 <A NAME="MARKER-2-45"></A>A program achieves better performance if it initializes data (including floating-point data) at compile time. The degree to which this is possible depends on the programming language and the compiler options that are supported.<P>
 As specified for the C programming language, floating-point constant expressions are generally evaluated as if at run time. This includes floating-point constants that initialize floating-point variables. However a floating-point variable may be initialized at compile time<P>
<UL>
<LI>if the variable is declared to be static<P>
<PRE>static float x = 0.3;</PRE>
<LI>if the variable is part of an aggregate type<P>
<PRE>struct {int x = 0; float y = 0.3;} numbers;</PRE>
<LI>if the initializing value is nonexceptional (exact) and is in the format of the variable<P>
<PRE>double y = 0.0;<BR>float x = 0.0f;</PRE>
<LI>if access to the floating-point environment is disabled in the part of the program where the variable is initialized<P>
<PRE>#pragma fenv_acess off<BR>float x = 0.3;</PRE><P>
</UL>
 For programming languages other than C, the data initialization model may be simpler. For example, in Fortran static initialization is accomplished with the DATA statement (embedded in a BLOCK DATA subprogram for labeled COMMON initialization), and the initializing values may only be constants or parameters. Such initialization is accomplished as if at compile time. Variables not initialized by the DATA statement are considered uninitialized and are assigned values at execution time with executable statements.<P>
 Data initialization rules for Pascal compilers are implementation defined and must be fully documented. In MPW Pascal targeting 680x0-based Macintosh computers, for example, a unit requiring initialization of its data declares a public procedure, called at execution time by the host program, that performs the initialization. Apple II Pascal, on the other hand, supports an initialization section within the unit.<A NAME="MARKER-2-46"></A><P>
<A NAME="HEADING182-50"></A>
<H2>Compiler Extensions for Expression Evaluation</H2>
 <A NAME="MARKER-2-2"></A>The FPCE technical report recommends that compilers implement two macros that help a programmer determine which expression evaluation method is being used and three pragmas that help a programmer use the most efficient data type for functions.<P>
<A NAME="HEADING182-52"></A>
<H3>Determining the Expression Evaluation Method</H3>
 Two macros that characterize the evaluation method for floating-point expressions may be defined in the <CODE>float.h</CODE> header file. The macro <CODE>_MIN_EVAL_FORMAT</CODE> tells which numeric data format is used as the minimum evaluation format:<CODE><A NAME="MARKER-2-48"></A></CODE>
<TABLE BORDER="0" CELLPADDING="3"><TD>0<TD><CODE>float</CODE> (single)<TR>
<TD>1<TD><CODE>double</CODE><TR>
<TD>2<TD><CODE>long double</CODE> (double-double)</TABLE>
<P>
 The macro <CODE>_WIDEST_NEED_EVAL</CODE> specifies if widest-need evaluation is performed:<A NAME="MARKER-2-49"></A>
<TABLE BORDER="0" CELLPADDING="3"><TD>0<TD>no<TR>
<TD>1<TD>yes<A NAME="MARKER-2-21"></A></TABLE>
<P>
<A NAME="HEADING182-55"></A>
<H3>Widening for Efficiency</H3>
 <A NAME="MARKER-2-50"></A><A NAME="MARKER-2-51"></A><A NAME="MARKER-2-52"></A>In general, programmers want to use the most efficient floating-point data type for the architecture on which their applications will run. If the application is to run on more than one architecture, you cannot guarantee that the most efficient type on one architecture will be the most efficient type for the others. The FPCE technical report recommends three preprocessor pragmas to facilitate running the same application efficiently on different architectures. When these pragmas are turned on, the compiler uses the wider of the architecture's most efficient type and the declared type for any function, parameter, or local variable declared after the pragma. <P>
<PRE>
#pragma fp_wide_function_returns    on | off
#pragma fp_wide_function_parameters on | off
#pragma fp_wide_variables           on | off
</PRE>
 If the first pragma, <CODE>fp_wide_function_returns</CODE>, is turned on in a module, all of the functions defined below the pragma will have return values in the most efficient data type for the architecture if it is wider than the declared return type. If the following example is compiled for the 680x0 architecture, both functions <CODE>ffunc</CODE> and <CODE>ldfunc</CODE> return type <CODE>long double</CODE>. If compiled for the PowerPC architecture, <CODE>ffunc</CODE> returns type <CODE>double</CODE> and <CODE>ldfunc</CODE> returns type <CODE>long double</CODE> (because data types may be widened to the most efficient type but not narrowed).<P>
<PRE>
#pragma fp_wide_function_returns on
float ffunc (float f) { /* code for ffunc */ }
long double ldfunc (double y) { /* code for ldfunc */ }
</PRE>
 <A NAME="MARKER-2-53"></A>If the second pragma, <CODE>fp_wide_function_parameters</CODE>, is turned on in a module, all of the parameters for all of the functions defined below the pragma are converted to the most efficient data type for the architecture if it is wider than the declared types of the parameters. In the following example, the parameters <CODE>x</CODE> and <CODE>y</CODE> are both type <CODE>double</CODE> on the PowerPC architecture and type <CODE>long double</CODE> on the 680x0 architecture. If an architecture's most efficient type was <CODE>float</CODE>, the types for both parameters would remain the same (because a parameter's type may be widened to the most efficient type but never narrowed).<P>
<PRE>
#pragma fp_wide_function_parameters on 
float func(float x, double y) { /* code for func */ }
</PRE>
 <A NAME="MARKER-2-54"></A>If the third pragma, <CODE>fp_wide_variables</CODE>, is turned on in a module, all local variables defined below the pragma are converted to the most efficient data type for the architecture if it is wider than the declared types of the variables. In the following example, the variables <CODE>z</CODE> and <CODE>q</CODE> are both type <CODE>double</CODE> on the PowerPC architecture and type <CODE>long double</CODE> on the 680x0 architecture. If an architecture's most efficient type was <CODE>float</CODE>, the types for both variables would remain the same (because a variables's type may be widened to the most efficient type but never narrowed).<P>
<PRE>
#pragma fp_wide_variables on 
float func(float x) 
{ 
   float z; 
   double q; 

   /* code */
}
</PRE>
 These pragmas can occur only outside external declarations. Each pragma remains in effect until it is explicitly turned off or until the end of the module. The default state for all three pragmas is off.<P>
 If an address or <CODE>sizeof</CODE> operator is applied to a widened parameter or variable, a compile-time warning is issued. Casts avoid widening in areas where one of these pragmas is turned on. <A NAME="MARKER-2-55"></A><A NAME="MARKER-2-56"></A><P>
 <A NAME="MARKER-2-57"></A><A NAME="MARKER-2-58"></A><A NAME="MARKER-9-1"></A><A NAME="MARKER-2-60"></A><A NAME="MARKER-2-61"></A><P>
 <P>

</BLOCKQUOTE>
<HR>
<CENTER>
<A HREF="PPCNumerics-181.html"><IMG ALIGN="BOTTOM" SRC="prev.gif" BORDER="none" HSPACE="20" ALT="Previous"></A> <A HREF="PPCNumerics-2.html"><IMG ALIGN="BOTTOM" SRC="content.gif" BORDER="none" HSPACE="20" ALT="Book Contents"></A> <A HREF="PPCNumerics-192.html"><IMG ALIGN="BOTTOM" SRC="index.gif" BORDER="none" HSPACE="20" ALT="Book Index"></A> <A HREF="PPCNumerics-183.html"><IMG ALIGN="BOTTOM" SRC="next.gif" BORDER="none" HSPACE="20" ALT="Next"></A> </CENTER><P>
<CENTER><FONT SIZE="-1"><A HREF="PPCNumerics-3.html">&copy; Apple Computer, Inc.</A><BR>13 JUL 1996</CENTER></FONT><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>  
