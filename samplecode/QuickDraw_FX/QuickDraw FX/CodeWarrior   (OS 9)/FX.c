/*	File:		FX.c	Contains:		Written by: EL		Copyright:	Copyright © 1992-1999 by Apple Computer, Inc., All Rights Reserved.				You may incorporate this Apple sample source code into your program(s) without				restriction. This Apple sample source code has been provided "AS IS" and the				responsibility for its operation is yours. You are not permitted to redistribute				this Apple sample source code as "Apple sample source code" after having made				changes. If you're going to re-distribute the source, we require that you make				it clear in the source that the code was descended from Apple sample source				code, but that you've made changes.	Change History (most recent first):				08/2000		JM				Carbonized, non-Carbon code is commented out											for demonstration purposes.				7/13/1999	KG				Updated for Metrowerks Codewarror Pro 2.1				*/#include "FX.h"long drawFXImage(){	int		exampleNumber, exampleItem;	Rect	rect, rect2;	Rect	outlineRect;	long	startTicks, endTicks;	Point	point = { 0, 0 };	Rect	frame;	Rect	windowRect, gWorldRect;		/*SetRect( &rect, (*gWindow).portRect.right - (*gGWorld).portRect.right - 20, 37,				(*gWindow).portRect.right - 20, 37 + (*gGWorld).portRect.bottom );*/	GetPortBounds(GetWindowPort(gWindow), &windowRect);	GetPortBounds(gGWorld, &gWorldRect);	SetRect( &rect, windowRect.right - gWorldRect.right - 20, 37,				windowRect.right - 20, 37 + gWorldRect.bottom );		outlineRect = rect;	InsetRect( &outlineRect, -5, -5 );	drawDeepBox( &outlineRect );		frame = rect;		if (settings.bItem == 1)	{		ForeColor( whiteColor );		PaintRect( &rect );	}	else if (settings.bItem == 2)	{		ForeColor( blackColor );		PaintRect( &rect );	}	else	{		rect2 = rect;				rect2.right = (rect2.right - rect2.left) / 2 + rect2.left;		ForeColor( whiteColor );		PaintRect( &rect2 );				rect2.left = rect2.right;		rect2.right = rect.right;		ForeColor( blackColor );		PaintRect( &rect2 );	}	ForeColor( blackColor );	BackColor( whiteColor );		exampleNumber = gCurrentExample / 10;	exampleItem = gCurrentExample % 10;		startTicks = TickCount();		if (exampleNumber == 1)		transferExample( &rect, exampleItem );	else if (exampleNumber == 2)		arithmeticExample( &rect, exampleItem );	else if (exampleNumber == 3)		ditherExample( &rect, exampleItem );	else if (exampleNumber == 4)		colorizationExample( &rect, exampleItem );	else if (exampleNumber == 5)		mappingExample( &rect, exampleItem );	else if (exampleNumber == 6)		paintBucketExample( &rect, exampleItem, point );	else if (exampleNumber == 7)		lassoToolExample( &rect, exampleItem, &frame );	else if (exampleNumber == 8)		pixelAverageExample( &rect, exampleItem );	else if (exampleNumber == 9)		customExample( &rect, exampleItem );			endTicks = TickCount();		return (endTicks - startTicks);}void transferExample( Rect *rect, int item ){	int		transferMode;		resetItems();	settings.tItem = item;		transferMode = setTransferMode( item );		/*CopyBits( (BitMap *)(*(*gGWorld).portPixMap), &gWindow->portBits,				&(**(*gGWorld).portPixMap).bounds, rect, transferMode, nil );*/	CopyBits( (BitMap *)(*(GetPortPixMap(gGWorld))), GetPortBitMapForCopyBits(GetWindowPort(gWindow)),				&((**(GetPortPixMap(gGWorld))).bounds), rect, transferMode, nil );}int setTransferMode(int	 item ){	item--;	return item;}void arithmeticExample( Rect *rect, int item ){	int			arithmeticMode;	RGBColor	color;		resetItems();	settings.aItem = item;		arithmeticMode = setArithmeticMode( item );		/*CopyBits( (BitMap *)(*(*gGWorld).portPixMap), &gWindow->portBits,				&(**(*gGWorld).portPixMap).bounds, rect, arithmeticMode, nil );*/	CopyBits( (BitMap *)(*(GetPortPixMap(gGWorld))), GetPortBitMapForCopyBits(GetWindowPort(gWindow)),				&((**(GetPortPixMap(gGWorld))).bounds), rect, arithmeticMode, nil );					color.red = color.green = color.blue = 0;	OpColor( &color );}int setArithmeticMode(int item){	RGBColor	color;		if (item <= 4)		item = 31 + item;	else if (item == 9)		item = transparent;	else		item = 32 + item;		color.red = color.green = color.blue = 0xffff / 2;	OpColor( &color );		return item;}void colorizationExample(Rect *rect, int item ){	int			i;	Rect		srcRect, dstRect;	RGBColor	color;		resetItems();	settings.cItem = item;		//srcRect = (**(*gGWorld).portPixMap).bounds;	srcRect = (**(GetPortPixMap(gGWorld))).bounds;	srcRect.right = srcRect.left + (srcRect.right - srcRect.left) / 3;		dstRect = *rect;	dstRect.right = dstRect.left + (dstRect.right - dstRect.left) / 3;		for (i = 0; i < 3; i++)	{		if (item == 1)		{			ForeColor( blackColor );			BackColor( whiteColor );		}			else if (item == 2)		{			ForeColor( whiteColor );			BackColor( blackColor );		}		else		{			color.red = color.green = color.blue = 0;					if (i == 0)				color.red = 0xffff;			else if (i == 1)				color.green = 0xffff;			else if (i == 2)				color.blue = 0xffff;						if (item == 3)			{				RGBForeColor( &color );				BackColor( whiteColor );			}			else			{				RGBBackColor( &color );				ForeColor( blackColor );			}		}						/*CopyBits( (BitMap *)(*(*gGWorld).portPixMap), &gWindow->portBits,				&srcRect, &dstRect, srcCopy, nil );*/		CopyBits( (BitMap *)(*(GetPortPixMap(gGWorld))), GetPortBitMapForCopyBits(GetWindowPort(gWindow)),				&srcRect, &dstRect, srcCopy, nil );						OffsetRect( &srcRect, srcRect.right - srcRect.left, 0 );		OffsetRect( &dstRect, dstRect.right - dstRect.left, 0 );	}}void ditherExample(Rect	* rect,int item ){	#pragma unused(rect)	int		ditherMode;		/* This function shows an example of using copybits with the dithering. */		resetItems();	settings.dItem = item;		ditherMode = setDitherMode( item );		/*CopyBits( (BitMap *)(*(*gGWorld).portPixMap), &gWindow->portBits,				&(**(*gGWorld).portPixMap).bounds, rect, srcCopy + ditherMode, nil );*/	CopyBits( (BitMap *)(*(GetPortPixMap(gGWorld))), GetPortBitMapForCopyBits(GetWindowPort(gWindow)),				&(**(GetPortPixMap(gGWorld))).bounds, rect, srcCopy + ditherMode, nil );}int setDitherMode(int item){	if (item == 1)		return 0;	else		return ditherCopy;}void mappingExample(Rect * rect, int	item ){	int			i;	GWorldPtr	gworld;	CTabHandle	ictable;	Rect		tempRect1;		resetItems();	settings.mItem = item;		if (item == 1)		/*CopyBits( (BitMap *)(*(*gGWorld).portPixMap), &gWindow->portBits,			&(**(*gGWorld).portPixMap).bounds, rect, srcCopy, nil );*/		CopyBits( (BitMap *)(*(GetPortPixMap(gGWorld))), GetPortBitMapForCopyBits(GetWindowPort(gWindow)),				&((**(GetPortPixMap(gGWorld))).bounds), rect, srcCopy, nil );	else if (item == 2)	{		ColorSearchUPP searchProcUPP=NewColorSearchProc(searchProc);		AddSearch(searchProcUPP);				/*CopyBits( (BitMap *)(*(*gGWorld).portPixMap), &gWindow->portBits,			&(**(*gGWorld).portPixMap).bounds, rect, srcCopy, nil );*/		CopyBits( (BitMap *)(*(GetPortPixMap(gGWorld))), GetPortBitMapForCopyBits(GetWindowPort(gWindow)),				&((**(GetPortPixMap(gGWorld))).bounds), rect, srcCopy, nil );				DelSearch(searchProcUPP);	}	else if (item == 3)	{		//NewGWorld( &gworld, 8, &(*gGWorld).portRect, GetCTable( 8 + 64 ), nil, 0 );		NewGWorld( &gworld, 8, GetPortBounds(gGWorld, &tempRect1), GetCTable( 8 + 64 ), nil, 0 );				/*CopyBits( (BitMap *)(*(*gGWorld).portPixMap), (BitMap *)(*(*gworld).portPixMap),					&(**(*gGWorld).portPixMap).bounds, &(**(*gworld).portPixMap).bounds,					srcCopy, nil );*/		CopyBits( (BitMap *)(*(GetPortPixMap(gGWorld))), (BitMap *)(*(GetPortPixMap(gworld))),					&((**(GetPortPixMap(gGWorld))).bounds), &((**(GetPortPixMap(gworld))).bounds), 					srcCopy, nil );				ictable = GetCTable( 8 );				/*for (i = 0; i <= (**(**(*gworld).portPixMap).pmTable).ctSize; i++)			(**(**(*gworld).portPixMap).pmTable).ctTable[i].rgb =					(**ictable).ctTable[255 - i].rgb;				(**(**(*gworld).portPixMap).pmTable).ctSeed = 67;	//			(**(**(*(CGrafPtr)gWindow).portPixMap).pmTable).ctSeed; 				CopyBits( (BitMap *)(*(*gworld).portPixMap), &gWindow->portBits,			&(**(*gworld).portPixMap).bounds, rect, srcCopy, nil );*/				for (i = 0; i <= (**(**(GetPortPixMap(gworld))).pmTable).ctSize; i++)			(**(**(GetPortPixMap(gworld))).pmTable).ctTable[i].rgb =					(**ictable).ctTable[255 - i].rgb;				(**(**(GetPortPixMap(gworld))).pmTable).ctSeed = 67;				CopyBits( (BitMap *)(*(GetPortPixMap(gworld))), GetPortBitMapForCopyBits(GetWindowPort(gWindow)),			&(**(GetPortPixMap(gworld))).bounds, rect, srcCopy, nil );				DisposeGWorld( gworld );	}}pascal Boolean searchProc( RGBColor	* color, long		*position ){	#pragma unused(position)	(*color).red = 0;		return false;}void paintBucketExample(Rect *rect, int exampleItem, Point point ){	#pragma unused(exampleItem)	GrafPtr     mask;	Point		newPoint;	GWorldPtr	gworld;	Rect		tempRect1;		resetItems();	newPoint.h = point.h - 20;	newPoint.v = point.v - 37;	/*if (newPoint.h < 0 || newPoint.v < 0 ||		newPoint.h > ((**(*gGWorld).portPixMap).bounds.right - (**(*gGWorld).portPixMap).bounds.left) ||		newPoint.v > ((**(*gGWorld).portPixMap).bounds.bottom - (**(*gGWorld).portPixMap).bounds.top))		return;*/	tempRect1 = (**(GetPortPixMap(gGWorld))).bounds;	if (newPoint.h < 0 || newPoint.v < 0 ||		newPoint.h > tempRect1.right - tempRect1.left ||		newPoint.v > tempRect1.bottom - tempRect1.top)		return;			//mask = CreateGrafPort( &(*gGWorld).portRect );	mask = CreateGrafPort(GetPortBounds(gGWorld, &tempRect1));		ForeColor( redColor );	MoveTo( point.h - 2, point.v );	LineTo( point.h + 2, point.v );	MoveTo( point.h, point.v - 2 );	LineTo( point.h, point.v + 2 );	ForeColor( blackColor );	//NewGWorld( &gworld, 8, &(*gGWorld).portRect, GetCTable( 8 + 64 ), nil, 0 );	NewGWorld( &gworld, 8, GetPortBounds(gGWorld, &tempRect1), GetCTable( 8 + 64 ), nil, 0 );			/*CopyBits( (BitMap *)(*(*gGWorld).portPixMap), (BitMap *)(*(*gworld).portPixMap),					&(**(*gGWorld).portPixMap).bounds, &(**(*gworld).portPixMap).bounds,					srcCopy, nil );*/	CopyBits( (BitMap *)(*(GetPortPixMap(gGWorld))), (BitMap *)(*(GetPortPixMap(gworld))),					&((**(GetPortPixMap(gGWorld))).bounds), &((**(GetPortPixMap(gworld))).bounds), 					srcCopy, nil );					//	GetGWorld( &currentPort, &currentDevice );//	SetGWorld( gworld, nil );		/*SeedCFill( (BitMap *)(*(*gworld).portPixMap), &mask->portBits,				&(**(*gworld).portPixMap).bounds, &mask->portRect,				newPoint.h, newPoint.v, nil, 0 );*/	SeedCFill( (BitMap *)(*(GetPortPixMap(gworld))), GetPortBitMapForCopyBits(mask),				&((**(GetPortPixMap(gworld))).bounds), GetPortBounds(mask, &tempRect1),				newPoint.h, newPoint.v, nil, 0 );//	SetGWorld( currentPort, currentDevice );		/*CopyMask( (BitMap *)(*(*gworld).portPixMap), &mask->portBits, &gWindow->portBits,				&(**(*gworld).portPixMap).bounds, &mask->portRect, rect );*/	CopyMask( (BitMap *)(*(GetPortPixMap(gworld))), GetPortBitMapForCopyBits(mask), GetPortBitMapForCopyBits(GetWindowPort(gWindow)),				&(**(GetPortPixMap(gworld))).bounds, GetPortBounds(mask, &tempRect1), rect );		DisposeGrafPort( mask );}void lassoToolExample(Rect	* rect, int	exampleItem,Rect *frame ){	#pragma unused(exampleItem,frame)	GrafPtr     mask;	RGBColor	color;	CGrafPtr	currentPort;	GDHandle	currentDevice;	Rect		tempRect1;		pascal Boolean matchProc();		resetItems();	//mask = CreateGrafPort( &(*gGWorld).portRect );	mask = CreateGrafPort(GetPortBounds(gGWorld, &tempRect1));	GetGWorld( &currentPort, &currentDevice );	SetGWorld( gGWorld, nil );		color.red = color.green = color.blue = 0;		/*CalcCMask( (BitMap *)(*(*gGWorld).portPixMap), &mask->portBits,				&(**(*gGWorld).portPixMap).bounds, &mask->portRect,				&color, NewColorSearchProc(matchProc), 0 );*/	CalcCMask( (BitMap *)(*(GetPortPixMap(gGWorld))),GetPortBitMapForCopyBits(mask),				&(**(GetPortPixMap(gGWorld))).bounds, GetPortBounds(mask, &tempRect1),				&color, NewColorSearchProc(matchProc), 0 );			SetGWorld( currentPort, currentDevice );		/*CopyMask( (BitMap *)(*(*gGWorld).portPixMap), &mask->portBits, &gWindow->portBits,				&(**(*gGWorld).portPixMap).bounds, &mask->portRect, rect );*/	CopyMask( (BitMap *)(*(GetPortPixMap(gGWorld))), GetPortBitMapForCopyBits(mask), GetPortBitMapForCopyBits(GetWindowPort(gWindow)),				&(**(GetPortPixMap(gGWorld))).bounds, GetPortBounds(mask, &tempRect1), rect );				/*	bounds = *frame;	OffsetRect( &bounds, -bounds.left, -bounds.top );		mask = CreateGrafPort( &bounds );	GetGWorld( &currentPort, &currentDevice );	SetGWorld( gGWorld, nil );		color.red = color.green = color.blue = 0;		CalcCMask( (BitMap *)(*(*gGWorld).portPixMap), &mask->portBits,				&bounds, &mask->portRect, &color, matchProc, 0 );					SetGWorld( currentPort, currentDevice );			CopyMask( (BitMap *)(*(*gGWorld).portPixMap), &mask->portBits, &gWindow->portBits,				&bounds, &mask->portRect, frame );*/		DisposeGrafPort( mask );}pascal Boolean matchProc(RGBColor *color, long		*position ){		GDHandle	currDevice;	MatchRec	*matchInfo;		currDevice = GetGDevice();	matchInfo = (MatchRec *)(**currDevice).gdRefCon;	if (matchInfo->red == color->red && matchInfo->green == color->green &&		matchInfo->blue == color->blue)		*position = 0;	else		*position = 1;			return true;}void pixelAverageExample(Rect	*rect, int	 item ){	#pragma unused(item)	Rect		bounds;	GWorldPtr	gworld;	GWorldPtr	source;	Rect		tempRect1;		resetItems();		/* Create 8-bit gworld from 32-bit original. */		//NewGWorld( &source, 8, &(*gGWorld).portRect, GetCTable( 8 + 64 ), nil, 0 );	NewGWorld( &source, 8, GetPortBounds(gGWorld, &tempRect1), GetCTable( 8 + 64 ), nil, 0 );	/*CopyBits( (BitMap *)(*(*gGWorld).portPixMap), (BitMap *)(*(*source).portPixMap),			&(**(*gGWorld).portPixMap).bounds, &(**(*source).portPixMap).bounds,			srcCopy, nil );*/	CopyBits( (BitMap *)(*(GetPortPixMap(gGWorld))), (BitMap *)(*(GetPortPixMap(source))),					&((**(GetPortPixMap(gGWorld))).bounds), &((**(GetPortPixMap(source))).bounds), 					srcCopy, nil );		/* Create another 8-bit gworld at quarter size of original. */			/*SetRect( &bounds, 0, 0, (*gGWorld).portRect.right / 4,				(*gGWorld).portRect.bottom / 4 );*/					GetPortBounds(gGWorld, &tempRect1);	SetRect( &bounds, 0, 0, tempRect1.right / 4,				tempRect1.bottom / 4);		NewGWorld( &gworld, 8, &bounds, GetCTable( 8 + 64 ), nil, 0 );	/* Copy the 8-bit original to 8-bit quarter image without pixel averaging. */		//bounds = (*source).portRect;	GetPortBounds(source, &bounds);		/*CopyBits( (BitMap *)(*(*source).portPixMap), (BitMap *)(*(*gworld).portPixMap),			&(**(*source).portPixMap).bounds, &(**(*gworld).portPixMap).bounds,			srcCopy, nil );*/	CopyBits( (BitMap *)(*(GetPortPixMap(source))), (BitMap *)(*(GetPortPixMap(gworld))),					&((**(GetPortPixMap(source))).bounds), &((**(GetPortPixMap(gworld))).bounds), 					srcCopy, nil );		/* Copy the quarter image to screen. */		OffsetRect( &bounds, 20, 37 );	/*CopyBits( (BitMap *)(*(*gworld).portPixMap), &(*gWindow).portBits,			&(**(*gworld).portPixMap).bounds, &bounds, srcCopy, nil );*/	CopyBits( (BitMap *)(*(GetPortPixMap(gworld))), GetPortBitMapForCopyBits(GetWindowPort(gWindow)),			&(**(GetPortPixMap(gworld))).bounds, &bounds, srcCopy, nil );		/* Now, copy the 8-bit original to 8-bit quarter image with pixel averaging. */		//bounds = (*source).portRect;	GetPortBounds(source, &bounds);		/*CopyBits( (BitMap *)(*(*source).portPixMap), (BitMap *)(*(*gworld).portPixMap),			&(**(*source).portPixMap).bounds, &(**(*gworld).portPixMap).bounds,			srcCopy + ditherCopy, nil );*/	CopyBits( (BitMap *)(*(GetPortPixMap(source))), (BitMap *)(*(GetPortPixMap(gworld))),					&((**(GetPortPixMap(source))).bounds), &((**(GetPortPixMap(gworld))).bounds), 					srcCopy + ditherCopy, nil );		/* Finally, copy pixel averaged quarter image to screen. */				OffsetRect( &bounds, (*rect).left, (*rect).top );	/*CopyBits( (BitMap *)(*(*gworld).portPixMap), &(*gWindow).portBits,			&(**(*gworld).portPixMap).bounds, &bounds, srcCopy, nil );*/	CopyBits( (BitMap *)(*(GetPortPixMap(gworld))), GetPortBitMapForCopyBits(GetWindowPort(gWindow)),			&(**(GetPortPixMap(gworld))).bounds, &bounds, srcCopy, nil );		DisposeGWorld( source );	DisposeGWorld( gworld );}void customExample(Rect	* rect,int	item ){	#pragma unused(item)	int			transferMode;	int			ditherMode;	RGBColor	color;	ColorSearchUPP searchProcUPP=NewColorSearchProc(searchProc);			transferMode = setTransferMode( settings.tItem );	ditherMode = setDitherMode( settings.dItem );		if (settings.cItem == 1)	{		ForeColor( blackColor );		BackColor( whiteColor );	}	else if (settings.cItem == 2)	{		ForeColor( whiteColor );		BackColor( blackColor );	}	else if (settings.cItem == 3)	{		color.green = 0xffff;		color.red = color.blue = 0;		RGBForeColor( &color );		BackColor( whiteColor );	}	else if (settings.cItem == 4)	{		color.green = 0xffff;		color.red = color.blue = 0;		ForeColor( blackColor );		RGBBackColor( &color );	}			if (settings.mItem == 2)		AddSearch(searchProcUPP);			/*CopyBits( (BitMap *)(*(*gGWorld).portPixMap), &gWindow->portBits,				&(**(*gGWorld).portPixMap).bounds, rect,				transferMode + ditherMode, nil );*/	CopyBits( (BitMap *)(*(GetPortPixMap(gGWorld))), GetPortBitMapForCopyBits(GetWindowPort(gWindow)),				&(**(GetPortPixMap(gGWorld))).bounds, rect,				transferMode + ditherMode, nil );					if (settings.mItem == 2)		DelSearch(searchProcUPP);}GrafPtr CreateGrafPort( Rect *bounds )	/* CreateGrafPort originally written by Forrest Tanaka. */{	GrafPtr	savedPort;		/* Saved GrafPtr for later restore. */	GrafPtr	newPort;		/* New GrafPort. */	Rect	localBounds;	/* Local copy of bounds. */	RgnHandle		rgnHandle = NewRgn();	// Used for carbonization	GetPort( &savedPort );	/* Set the top-left corner of bounds to (0,0). */	localBounds = *bounds;	OffsetRect( &localBounds, -bounds->left, -bounds->top );	/* Allocate a new GrafPort. */	//newPort = (GrafPtr)NewPtrClear( sizeof( GrafPort ) );	newPort = CreateNewPort();		if (newPort != nil)	{		/* Initialize the new port and make the current port. */		//OpenPort( newPort );		SetPort( newPort);		/* Initialize and allocate the bitmap. */		/*newPort->portBits.bounds = localBounds;  		newPort->portBits.rowBytes = ((localBounds.right + 15) >> 4) << 1;		newPort->portBits.baseAddr =  NewPtrClear( newPort->portBits.rowBytes *													(long)localBounds.bottom );*/		(*(GetPortPixMap(newPort)))->bounds = localBounds;		(*(GetPortPixMap(newPort)))->rowBytes = ((localBounds.right + 15) >> 4) <<1;		(*(GetPortPixMap(newPort)))->baseAddr = NewPtrClear(GetPortBitMapForCopyBits(newPort)->rowBytes *														(long)localBounds.bottom );				//if (newPort->portBits.baseAddr != nil)		if (GetPortBitMapForCopyBits(newPort)->baseAddr != nil)		{			/* Clean up the new port. */			//newPort->portRect = localBounds;			SetPortBounds(newPort, &localBounds);			ClipRect( &localBounds );			//RectRgn( newPort->visRgn, &localBounds );			RectRgn( GetPortVisibleRegion(newPort, rgnHandle), &localBounds );			EraseRect( &localBounds );		}		else		{			/* Allocation failed; deallocate the port. */			/*ClosePort( newPort );			DisposePtr( (Ptr)newPort );*/			DisposePort( newPort );			newPort = nil;		}	}		DisposeRgn(rgnHandle);	SetPort( savedPort );	return newPort;}void DisposeGrafPort( GrafPtr doomedPort )	/* DisposeGrafPort originally written by Forrest Tanaka. */{	//ClosePort( doomedPort );	//DisposePtr( doomedPort->portBits.baseAddr );	DisposePtr( GetPortBitMapForCopyBits(doomedPort)->baseAddr );	//DisposePtr( (Ptr)doomedPort );	DisposePort( doomedPort );}