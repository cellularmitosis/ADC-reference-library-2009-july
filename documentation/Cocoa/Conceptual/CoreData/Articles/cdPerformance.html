<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>Core Data Programming Guide: Core Data Performance</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Core Data Performance"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP40003468" title="Core Data Performance"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../index.html#//apple_ref/doc/uid/TP30000440-TP30000416" target="_top">Cocoa</a> &gt; <a href="../../../DesignGuidelines-date.html#//apple_ref/doc/uid/TP30000440-TP30000416-TP30000556" target="_top">Design Guidelines</a> &gt; <a href="../index.html" target="_top">Core Data Programming Guide</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="cdMultiThreading.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="cdTroubleshooting.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>
        
        
        <a name="//apple_ref/doc/uid/TP40003468-SW1" title="Core Data Performance"></a><hr /><H1>Core Data Performance</H1><p>In general, Core Data is very efficient. For many applications, an implementation that uses Core Data may be more efficient than a <em>comparable</em> application that does not. It is possible, however, to use the framework in such a way that its efficiency is reduced. This article describes how to get the most out of Core Data. </p>
<!-- This template is being used for both PDF and HTML. -->

    
    <!-- TopicBook.pm uses this template for its miniTOCs, but needs a different title. -->
    <h4>Contents:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="cdPerformance.html#//apple_ref/doc/uid/TP40003468-SW9">Introduction</a>
				
			<br/>
			
        
			
			
				<a href="cdPerformance.html#//apple_ref/doc/uid/TP40003468-SW2">Fetching Managed Objects</a>
				
			<br/>
			
        
			
			
				<a href="cdPerformance.html#//apple_ref/doc/uid/TP40003468-SW3">Faulting Behavior</a>
				
			<br/>
			
        
			
			
				<a href="cdPerformance.html#//apple_ref/doc/uid/TP40003468-SW4">Reducing Memory Overhead</a>
				
			<br/>
			
        
			
			
				<a href="cdPerformance.html#//apple_ref/doc/uid/TP40003468-SW5">Large Data Objects (BLOBs)</a>
				
			<br/>
			
        
			
			
				<a href="cdPerformance.html#//apple_ref/doc/uid/TP40003468-SW12">Analyzing Performance</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP40003468-SW9" title="Introduction"></a><h2>Introduction</h2><p>Core Data is a rich and sophisticated object graph management framework capable of dealing with large volumes of data. The SQLite store can scale to terabyte sized databases with billions of rows/tables/columns. Unless your entities themselves have very large attributes (although see <span class="content_text"><a href="cdPerformance.html#//apple_ref/doc/uid/TP40003468-SW5">“Large Data Objects (BLOBs)”</a></span>) or large numbers of properties, 10,000 objects is considered to be a fairly small size for a data set.</p><p>For a very simple application it is certainly the case that Core Data adds some overhead (compare a vanilla Cocoa document-based application with a Cocoa Core Data document-based application), however Core Data adds significant functionality. For a small overhead, even a simple Core Data-based application supports undo and redo, validation, object graph maintenance, and provides the ability to save objects to a persistent store. If you implemented this functionality yourself, if it quite likely that the overhead would exceed that imposed by Core Data. As the complexity of an application increases, so the proportionate overhead that Core Data imposes typically decreases while at the same time the benefit typically increases (supporting undo and redo in a large application, for example, is usually <em>hard</em>).</p><p><code>NSManagedObject</code> uses an internal storage mechanism for data that is highly optimized. In particular, it leverages the information about the types of data that is available through introspecting the model. When you store and retrieve data in a manner that is key-value coding and key-value observing compliant, it is likely that using <code>NSManagedObject</code> will be faster than any other storage mechanism—including for the the simple get/set cases. In a modern Cocoa application that leverages Cocoa Bindings, given that Cocoa Bindings is reliant upon key-value coding and key-value observing it would be difficult to build a raw data storage mechanism that provides the same level of efficiency as Core Data. </p><p>Like all technologies, however, Core Data can be abused. Using Core Data does not free you from the need to consider basic Cocoa patterns, such as memory management. You should also consider how you fetch data from a persistent store. If you find that your application is not performing as well as you would like, you should use profiling tools such as Shark to determine where the problem lies (see <span class="content_text"><a href="http://developer.apple.com/tools/performance/" target="_top">Performance &amp; Debugging</a></span>). </p><a name="//apple_ref/doc/uid/TP40003468-SW2" title="Fetching Managed Objects"></a><h2>Fetching Managed Objects</h2><p>Each round trip to the persistent store (each fetch) incurs an overhead, both in accessing the store and in merging the returned objects into the persistence stack. You should avoid executing multiple requests if you can instead combine them into a single request that will return all the objects you require. You can also minimize the number of objects you have in memory.</p><a name="//apple_ref/doc/uid/TP40003468-SW10" title="Fetch Predicates"></a><h3>Fetch Predicates</h3><p>How you use predicates can significantly affect the performance of your application. If a fetch request requires a compound predicate, you can make the fetch more efficient by ensuring that the most restrictive predicate is the first, especially if the predicate involves text matching (<code>contains</code>, <code>endsWith</code>, <code>like</code>, and <code>matches</code>) since correct Unicode searching is slow. If the predicate combines textual and non-textual comparisons, then it is likely to be more efficient to specify the non-textual predicates first, for example <code>(salary > 5000000) AND (lastName LIKE 'Quincey')</code> is better than <code>(lastName LIKE 'Quincey') AND (salary > 5000000)</code>. For more about creating predicates, see <em><a href="../../Predicates/index.html#//apple_ref/doc/uid/TP40001789" target="_top">Predicate Programming Guide</a></em>.</p><a name="//apple_ref/doc/uid/TP40003468-SW11" title="Fetch Limits"></a><h3>Fetch Limits</h3><p>You can set a limit to the number of objects a fetch will return using the method <code>setFetchLimit:</code> as shown in the following example.</p><div class="codesample"><table><tr><td scope="row"><pre>NSFetchRequest *request = [[[NSFetchRequest alloc] init] autorelease];<span></span></pre></td></tr><tr><td scope="row"><pre>[request setFetchLimit:100];<span></span></pre></td></tr></table></div><p>If you are using the SQLite store, you can use a fetch limit to minimize the working set of managed objects in memory, and so improve the performance of your application.</p><p>If you do need to retrieve a large number of objects, you can make your application appear more responsive by executing two fetches. In the first fetch, you retrieve a comparatively small number of objects—for example, 100—and populate the user interface with these objects. You then execute a second fetch to retrieve the complete result set (that is, you execute a fetch without a fetch limit).</p><p>Note that there is no way to "batch" fetches (or in database terms, to set a cursor). That is, you cannot fetch the "first" 100 objects, then the second 100, then the third, and so on.</p><p>In general, however, you are encouraged to use predicates to ensure that you retrieve only those objects you require.</p><a name="//apple_ref/doc/uid/TP40003468-SW3" title="Faulting Behavior"></a><h2>Faulting Behavior</h2><p>Firing faults can be a comparatively expensive process (potentially requiring a round trip to the persistent store), and you may wish to avoid unnecessarily firing a fault. You can safely invoke the following methods on a fault without causing it to fire: <code>isEqual:</code>, <code>hash</code>, <code>superclass</code>, <code>class</code>, <code>self</code>, <code>zone</code>, <code>isProxy</code>, <code>isKindOfClass:</code>, <code>isMemberOfClass:</code>, <code>conformsToProtocol:</code>, <code>respondsToSelector:</code>, <code>retain</code>, <code>release</code>, <code>autorelease</code>, <code>retainCount</code>, <code>description</code>, <code>managedObjectContext</code>, <code>entity</code>, <code>objectID</code>, <code>isInserted</code>, <code>isUpdated</code>, <code>isDeleted</code>, and <code>isFault</code>.</p><p>Since <code>isEqual</code> and <code>hash</code> do not cause a fault to fire, managed objects can typically be placed in collections without firing a fault. Note, however, that invoking key-value coding methods on the collection object might in turn result in an invocation of <code>valueForKey:</code> on a managed object, which would fire a fault. In addition, although the default implementation of <code>description</code> does not cause a fault to fire, if you implement a custom <code>description</code> method that accesses the object’s persistent properties, this will cause a fault to fire.</p><p>Note that just because a managed object is a fault, it does not necessarily mean that the data for the object are not in memory—see the definition for <code><a href="../../../Reference/CoreDataFramework/Classes/NSManagedObject_Class/Reference/NSManagedObject.html#//apple_ref/occ/instm/NSManagedObject/isFault" target="_top">isFault</a></code>.</p><a name="//apple_ref/doc/uid/TP40003468-SW6" title="Batch Faulting and Pre-fetching with the SQLite Store"></a><h3>Batch Faulting and Pre-fetching with the SQLite Store</h3><p>When you execute a fetch, Core Data fetches just instances of the entity you specify. In some situations (see <span class="content_text"><a href="cdFaultingUniquing.html#//apple_ref/doc/uid/TP30001202-185436">“Faulting”</a></span>), the destination of a relationship is represented by a fault. Core Data automatically resolves (fires) the fault when you access data in the fault. This lazy loading of the related objects is much better for memory use, and much faster for fetching objects related to rarely used (or very large) objects. It can also, however, lead to a situation where Core Data executes separate fetch requests for a number of individual objects.</p><p>If data for a fault has not been cached (see <span class="content_text"><a href="cdFaultingUniquing.html#//apple_ref/doc/uid/TP30001202-185436">“Faulting”</a></span>), Core Data performs a separate round trip to the persistent store for each fault fired. This incurs a comparatively high overhead. Since Core Data automatically resolves the fault when you access data in the fault, this can lead to an inefficient pattern where a Core Data executes fetch requests for a number of individual objects. For example, given a model:</p><br/><div><img src = "../Art/relationship_cardinality.gif" alt = "image: ../Art/relationship_cardinality.gif" width="468" height="88"></div><br/><p>you might fetch a number of Employees and ask each in turn for their Department's name, as shown in the following code fragment.</p><div class="codesample"><table><tr><td scope="row"><pre>// create fetch request for Employees -- includes predicate<span></span></pre></td></tr><tr><td scope="row"><pre>// (if you don't have a predicate here, you should probably just fetch all the Departments...)<span></span></pre></td></tr><tr><td scope="row"><pre>NSArray *fetchedEmployees = [moc executeFetchRequest:employeesFetch error:&amp;error];<span></span></pre></td></tr><tr><td scope="row"><pre>for (Employee *employee in fetchedEmployees)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    NSLog(@"%@ -> %@ department", employee.name, employee.department.name);<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>This might lead to the following behavior:</p><div class="codesample"><table><tr><td scope="row"><pre>Jack -> Sales [fault fires]<span></span></pre></td></tr><tr><td scope="row"><pre>Jill -> Marketing [fault fires]<span></span></pre></td></tr><tr><td scope="row"><pre>Benjy -> Sales<span></span></pre></td></tr><tr><td scope="row"><pre>Gillian -> Sales<span></span></pre></td></tr><tr><td scope="row"><pre>Hector -> Engineering [fault fires]<span></span></pre></td></tr><tr><td scope="row"><pre>Michelle -> Marketing<span></span></pre></td></tr></table></div><p>Here, there are four round trips to the persistent store (one for the original fetch of Employees, and three for individual Departments) which represents a considerable overhead on top of the minimum (two—one for each entity).</p><p>There are two techniques you can use to mitigate this effect—<strong>batch faulting</strong> and <strong>pre-fetching</strong>.</p><a name="//apple_ref/doc/uid/TP40003468-SW8" title="Batch faulting"></a><h4>Batch faulting</h4><p>You can batch fault a collection of objects by executing a fetch request using a predicate with an <code>IN</code> operator, as illustrated by the following example. (In a predicate, <code>self</code> represents the object being evaluated—see <span class="content_text"><a href="../../Predicates/Articles/pSyntax.html#//apple_ref/doc/uid/TP40001795" target="_top">Predicate Format String Syntax</a></span>.) </p><div class="codesample"><table><tr><td scope="row"><pre>NSArray *array = [NSArray arrayWithObjects:fault1, fault2, ..., nil];<span></span></pre></td></tr><tr><td scope="row"><pre>NSPredicate *predicate = [NSPredicate predicateWithFormat:@"self IN %@", array];<span></span></pre></td></tr></table></div>	<p>On Mac OS X v10.5, when you create a fetch request you can use the <code><a href="../../../Reference/CoreDataFramework/Classes/NSFetchRequest_Class/Reference/Reference.html#//apple_ref/occ/cl/NSFetchRequest" target="_top">NSFetchRequest</a></code> method <code><a href="../../../Reference/CoreDataFramework/Classes/NSFetchRequest_Class/Reference/Reference.html#//apple_ref/occ/instm/NSFetchRequest/setReturnsObjectsAsFaults:" target="_top">setReturnsObjectsAsFaults:</a></code> to ensure that managed objects are not returned as faults.</p><a name="//apple_ref/doc/uid/TP40003468-SW7" title="Pre-fetching"></a><h4>Pre-fetching</h4><p>Pre-fetching is in effect a special case of batch-faulting, performed immediately after another fetch. The idea behind pre-fetching is the anticipation of future needs. When you fetch some objects, sometimes you know that soon after you will also need related objects which may be represented by faults. To avoid the inefficiency of individual faults firing, you can pre-fetch the objects at the destination.</p><p>On Mac OS X v10.5, you can use the <code><a href="../../../Reference/CoreDataFramework/Classes/NSFetchRequest_Class/Reference/Reference.html#//apple_ref/occ/cl/NSFetchRequest" target="_top">NSFetchRequest</a></code> method <code><a href="../../../Reference/CoreDataFramework/Classes/NSFetchRequest_Class/Reference/Reference.html#//apple_ref/occ/instm/NSFetchRequest/setRelationshipKeyPathsForPrefetching:" target="_top">setRelationshipKeyPathsForPrefetching:</a></code> to specify an array of relationship keypaths to prefetch along with the entity for the request. For example, given an Employee entity with a relationship to a Department entity: if you fetch all the employees then for each print out their name and the name of the department to which they belong, you can avoid the possibility of a fault being fired for each Department instance by prefetching the department relationship, as illustrated in the following code fragment:</p><div class="codesample"><table><tr><td scope="row"><pre>NSManagedObjectContext *context = /* get the context */;<span></span></pre></td></tr><tr><td scope="row"><pre>NSEntityDescription *employeeEntity = [NSEntityDescription<span></span></pre></td></tr><tr><td scope="row"><pre>    entityForName:@"Employee" inManagedObjectContext:context];<span></span></pre></td></tr><tr><td scope="row"><pre>NSFetchRequest *request = [[NSFetchRequest alloc] init];<span></span></pre></td></tr><tr><td scope="row"><pre>[request setEntity:employeeEntity];<span></span></pre></td></tr><tr><td scope="row"><pre>[request setRelationshipKeyPathsForPrefetching:<span></span></pre></td></tr><tr><td scope="row"><pre>    [NSArray arrayWithObject:@"department"]];<span></span></pre></td></tr></table></div><p>On Mac OS X v10.4, you create a fetch request to fetch just those instances of the destination entity that are related to the source objects you just retrieved, this reduces the number of fetches to two (the minimum). How (or whether) you implement the pre-fetch depends on the cardinality of the relationship.</p><ul class="spaceabove"><li class="li"><p>If the inverse relationship is a to-one, you can use a predicate with the format, <code>@"%K IN %@"</code> where the first argument is the key name for the inverse relationship, and the second argument an array of the original objects.</p></li><li class="li"><p>If the inverse relationship is a to-many, you first collect the object IDs from the faults you care about (being careful not touch other attributes). You then create a predicate with the format, <code>@"SELF IN %@"</code>, where the argument is the array of object IDs.</p></li><li class="li"><p>If the relationship is a many-to-many, pre-fetching is not recommended.</p></li></ul><p>You could implement pre-fetching for the department relationship in the previous example as follows.</p><div class="codesample"><table><tr><td scope="row"><pre>NSEntityDescription *deptEntity = [NSEntityDescription entityForName:@"Department"<span></span></pre></td></tr><tr><td scope="row"><pre>        inManagedObjectContext:moc];<span></span></pre></td></tr><tr><td scope="row"><pre>NSArray *deptOIDs = [fetchedEmployees valueForKeyPath:@"department.objectID"];<span></span></pre></td></tr><tr><td scope="row"><pre>NSPredicate *deptsPredicate = [NSPredicate predicateWithFormat:<span></span></pre></td></tr><tr><td scope="row"><pre>        @"SELF in %@", deptOIDs];<span></span></pre></td></tr><tr><td scope="row"><pre>NSFetchRequest *deptFetch = [[[NSFetchRequest alloc] init] autorelease];<span></span></pre></td></tr><tr><td scope="row"><pre>[deptFetch setEntity:deptEntity];<span></span></pre></td></tr><tr><td scope="row"><pre>[deptFetch setPredicate:deptsPredicate];<span></span></pre></td></tr><tr><td scope="row"><pre>// execute fetch...<span></span></pre></td></tr></table></div><p>If you know something about how the data will be accessed or presented, you can further refine the fetch predicate to reduce the number of objects fetched. Note, though, that this technique can be fragile—if the application changes and needs a different set of data, then you can end up pre-fetching the wrong objects.</p><p>For more about faulting, and in particular the meaning of the value returned from <code>isFault</code>, see <span class="content_text"><a href="cdFaultingUniquing.html#//apple_ref/doc/uid/TP30001202-CJBDBHCB">“Faulting and Uniquing.”</a></span></p><a name="//apple_ref/doc/uid/TP40003468-SW4" title="Reducing Memory Overhead"></a><h2>Reducing Memory Overhead</h2><p>It is sometimes the case that you want to use managed objects on a temporary basis, for example to calculate an average value for a particular attribute. This causes your object graph, and memory consumption, to grow. You can reduce the memory overhead by re-faulting individual managed objects that you no longer need, or you can reset a managed object context to clear an entire object graph. You can also use patterns that apply to Cocoa programming in general.</p><ul class="ul"><li class="li"><p>You can re-fault an individual managed object using <code>NSManagedObjectContext</code>'s <code>refreshObject:mergeChanges:</code> method. This has the effect of clearing its in-memory property values thereby reducing its memory overhead. (Note that this is not the same as setting the property values to <code>nil</code>—the values will be retrieved on demand if the fault is fired—see <span class="content_text"><a href="cdFaultingUniquing.html#//apple_ref/doc/uid/TP30001202-CJBDBHCB">“Faulting and Uniquing.”</a></span>) </p></li><li class="li"><p>On Mac OS X v10.5, when you create a fetch request you can set <code><a href="../../../Reference/CoreDataFramework/Classes/NSFetchRequest_Class/Reference/Reference.html#//apple_ref/occ/instm/NSFetchRequest/includesPropertyValues" target="_top">includesPropertyValues</a></code> to <code>NO</code> to reduce memory overhead by avoiding creation of objects to represent the property values. You should typically only do so, however, if you are sure that either you will not need the actual property data or you already have the information in the row cache, otherwise you will incur multiple trips to the persistent store.</p></li><li class="li"><p>You can use <code>NSManagedObjectContext</code>'s <code>reset</code> method to remove all managed objects associated with a context and "start over" as if you'd just created it. Note that any managed object associated with that context will be invalidated, and so you will need to discard any references to and re-fetch any objects associated with that context in which you are still interested.</p></li><li class="li"><p>Objects returned by fetching and other API are usually autoreleased as required by the Cocoa programming guidelines. If you iterate over a lot of objects, you may need to allocate and release your own autorelease pools to gain a finer-grain level of memory management.</p></li><li class="li"><p>If you do not intend to use Core Data's undo functionality, you can reduce your application's resource requirements by setting the context’s undo manager to <code>nil</code>. This may be especially beneficial for background worker threads, as well as for large import or batch operations.</p></li><li class="li"><p>Finally, Core Data does not by default retain managed objects (unless they have unsaved changes). If you have lots of objects in memory, you should determine why they are still retained. Managed objects do retain each other through relationships, which can easily create cycles. You can break retain cycles by re-faulting objects (again by using <code>NSManagedObjectContext</code>'s <code>refreshObject:mergeChanges:</code> method).</p></li></ul><a name="//apple_ref/doc/uid/TP40003468-SW5" title="Large Data Objects (BLOBs)"></a><h2>Large Data Objects (BLOBs)</h2><p>If your application uses large BLOBs ("Binary Large OBjects" such as image and sound data), you need to take care to minimize overheads. The exact definition of "small", "modest", and "large" is fluid and depends on an application's usage. A loose rule of thumb is that objects in the order of kilobytes in size are of a "modest" sized and those in the order of megabytes in size are "large" sized. Some developers have achieved good performance with 10MB BLOBs in a database. On the other hand, if an application has millions of rows in a table, even 128 bytes might be a "modest" sized CLOB (Character Large OBject) that needs to be normalized into a separate table.</p><p>In general, if you <em>need</em> to store BLOBs in a persistent store, you should use an SQLite store. The XML and binary stores require that the whole object graph reside in memory, and store writes are atomic (see <span class="content_text"><a href="cdPersistentStores.html#//apple_ref/doc/uid/TP40002875-SW1">“Persistent Store Features”</a></span>) which means that they do not efficiently deal with large data objects. SQLite can scale to handle extremely large databases. Properly used, SQLite provides good performance for databases up to 100GB, and a single row can hold up to 1GB (although of course reading 1GB of data into memory is an expensive operation no matter how efficient the repository).</p><p>A BLOB often represents an attribute of an entity—for example, a photograph might be an attribute of an Employee entity. For small to modest sized BLOBs (and CLOBs), you should create a separate entity for the data and create a to-one relationship in place of the attribute. For example, you might create Employee and Photograph entities with a one-to-one relationship between them, where the relationship from Employee to Photograph replaces the Employee's photograph attribute. This pattern maximizes the benefits of object faulting (see <span class="content_text"><a href="cdFaultingUniquing.html#//apple_ref/doc/uid/TP30001202-CJBDBHCB">“Faulting and Uniquing”</a></span>). Any given photograph is only retrieved if it is actually needed (if the relationship is traversed). </p><p>It is better, however, if you are able to store BLOBs as resources on the filesystem, and to maintain links (such as URLs or paths) to those resources. You can then load a BLOB as and when necessary. </p><a name="//apple_ref/doc/uid/TP40003468-SW12" title="Analyzing Performance"></a><h2>Analyzing Performance</h2><a name="//apple_ref/doc/uid/TP40003468-SW13" title="Analyzing Fetch Behavior with SQLite"></a><h3>Analyzing Fetch Behavior with SQLite</h3><p>With Mac OS X version 10.4.3 and later, you can use the user default <code>com.apple.CoreData.SQLDebug</code> to log to <code>stderr</code> the actual SQL sent to SQLite. (Note that user default names are case sensitive.) For example, you can pass the following as an argument to the application:</p><div class="codesample"><table><tr><td scope="row"><pre>-com.apple.CoreData.SQLDebug 1<span></span></pre></td></tr></table></div><p>Higher levels of debug numbers produce more information, although this is likely to be of diminishing utility.</p><p>The information the output provides can be useful when debugging performance problems—in particular it may tell you when Core Data is performing a large number of small fetches (such as when firing faults individually). The output differentiates between fetches that you execute using a fetch request and fetches that are performed automatically to realize faults.</p><a name="//apple_ref/doc/uid/TP40003468-SW14" title="Instruments"></a><h3>Instruments</h3><p>With Mac OS X version 10.5, you can use the Instruments application (by default in /Developer/Applications/) to analyze the behavior of your application. There are several Instruments probes specific to Core Data:</p><ul class="spaceabove"><li class="li"><p>Core Data Fetches</p><p>Records invocations of <code><a href="../../../Reference/CoreDataFramework/Classes/NSManagedObjectContext_Class/Reference/Reference.html#//apple_ref/occ/instm/NSManagedObjectContext/executeFetchRequest:error:" target="_top">executeFetchRequest:error:</a></code>, providing information about the entity against which the request was made, the number of objects returned, and the time taken for the fetch. </p></li><li class="li"><p>Core Data Saves</p><p>Records invocations of <code><a href="../../../Reference/CoreDataFramework/Classes/NSManagedObjectContext_Class/Reference/Reference.html#//apple_ref/occ/instm/NSManagedObjectContext/save:" target="_top">save:</a></code> and the time taken to do the save.</p></li><li class="li"><p>Core Data Faults</p><p>Records information about object and relationship fault firing. For object faults, records the object being faulted; for relationship faults, records the source object and the relationship being fired. In both cases, records the time taken to fire the fault.</p></li><li class="li"><p>Core Data Cache Misses</p><p>Traces fault behavior that specifically results in filesystem activity—indicating that a fault was fired for which no data was available—and records the time taken to retrieve the data.</p></li></ul><p>All the instruments provide a stack trace for each event so that you can see what caused it to happen.</p><p>When analyzing your application, you should of course also take into account factors not directly related to Core Data, such as overall memory footprint, object allocations, use and abuse of other API such as the key-value technologies and so on. </p>

        <br/><br/> 

        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="cdMultiThreading.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="cdTroubleshooting.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2004, 2009 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2009-03-04<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Cocoa/Conceptual/CoreData/Articles/cdPerformance.html%3Fid%3DTP40001075-5.6&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Cocoa/Conceptual/CoreData/Articles/cdPerformance.html%3Fid%3DTP40001075-5.6&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Cocoa/Conceptual/CoreData/Articles/cdPerformance.html%3Fid%3DTP40001075-5.6&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>
