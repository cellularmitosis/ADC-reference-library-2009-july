<html><head><title>Mac OS X
 Manual Page For perlapio(1)</title>
<style type="text/css"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { font-size: 1px; background: #ffffff; color: #ffffff; } --></style>
<style type="text/css" media="print, aural, braille, embossed, projection, tty"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { display: none; } --></style>
</head><body bgcolor="white">
<a name="//apple_ref/doc/man/1/perlapio" title="Mac OS X
 Manual Page for perlapio(1)"><!-- headerDoc=man; indexgroup=Section 1; uid="//apple_ref/doc/man/1/perlapio"; name=perlapio(1) --></a>
<!--#include virtual="/includes/framesetheader"-->
<table width=600><tr><td scope="row">
<!-- begin breadcrumb insert request --><font face="Geneva,Helvetica,Arial" size="1">
 <a target="_top" href="http://developer.apple.com">ADC Home</a> <b>&gt;</b> <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> <b>&gt;</b> <a href="../../../../../reference/index.html#//apple_ref/doc/uid/TP30001281" target="_top">Reference</a> <b>&gt;</b> <!-- a href="" target="_top" -->Mac OS X<!-- /a --> <b>&gt;</b> <a href="../index.html#//apple_ref/doc/framework/manpages" target="_top">Mac OS X Man Pages</a></font>
<!-- end breadcrumb insert request -->
<p>&nbsp;</p>
</td></tr></table>
<!-- end of header -->
<table border="0"  cellpadding="2" cellspacing="2" width="630pt"><tr><td valign="top" height="12" colspan="5" scope="row">
<p style='text-align:justify;'>This document is a Mac OS X manual page.  Manual pages are a command-line technology
for providing documentation.  You can view these manual pages locally using the
<a href="man.1.html#//apple_ref/doc/man/1/man">man(1)</a> command.
These manual pages come from many different sources, and thus, have a variety of writing
styles.</p>
<p style='text-align:justify;'>For more information about the manual page format, see the manual page for 
<a href="../man5/manpages.5.html#//apple_ref/doc/man/5/manpages">manpages(5)</a>.</p>
</td></tr></table>
<hr />
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row"><pre class="manpages"><tt>
PERLAPIO(1)                           Perl Programmers Reference Guide                           PERLAPIO(1)



<b>NAME</b>
       perlapio - perl's IO abstraction interface.

<b>SYNOPSIS</b>
           #define PERLIO_NOT_STDIO 0    /* For co-existence with stdio only */
           #include &lt;perlio.h&gt;           /* Usually via #include &lt;perl.h&gt; */

           PerlIO *PerlIO_stdin(void);
           PerlIO *PerlIO_stdout(void);
           PerlIO *PerlIO_stderr(void);

           PerlIO *PerlIO_open(const char *path,const char *mode);
           PerlIO *PerlIO_fdopen(int fd, const char *mode);
           PerlIO *PerlIO_reopen(const char *path, const char *mode, PerlIO *old);  /* deprecated */
           int     PerlIO_close(PerlIO *f);

           int     PerlIO_stdoutf(const char *fmt,...)
           int     PerlIO_puts(PerlIO *f,const char *string);
           int     PerlIO_putc(PerlIO *f,int ch);
           int     PerlIO_write(PerlIO *f,const void *buf,size_t numbytes);
           int     PerlIO_printf(PerlIO *f, const char *fmt,...);
           int     PerlIO_vprintf(PerlIO *f, const char *fmt, va_list args);
           int     PerlIO_flush(PerlIO *f);

           int     PerlIO_eof(PerlIO *f);
           int     PerlIO_error(PerlIO *f);
           void    PerlIO_clearerr(PerlIO *f);

           int     PerlIO_getc(PerlIO *d);
           int     PerlIO_ungetc(PerlIO *f,int ch);
           int     PerlIO_read(PerlIO *f, void *buf, size_t numbytes);

           int     PerlIO_fileno(PerlIO *f);

           void    PerlIO_setlinebuf(PerlIO *f);

           Off_t   PerlIO_tell(PerlIO *f);
           int     PerlIO_seek(PerlIO *f, Off_t offset, int whence);
           void    PerlIO_rewind(PerlIO *f);

           int     PerlIO_getpos(PerlIO *f, SV *save);        /* prototype changed */
           int     PerlIO_setpos(PerlIO *f, SV *saved);       /* prototype changed */

           int     PerlIO_fast_gets(PerlIO *f);
           int     PerlIO_has_cntptr(PerlIO *f);
           int     PerlIO_get_cnt(PerlIO *f);
           char   *PerlIO_get_ptr(PerlIO *f);
           void    PerlIO_set_ptrcnt(PerlIO *f, char *ptr, int count);

           int     PerlIO_canset_cnt(PerlIO *f);              /* deprecated */
           void    PerlIO_set_cnt(PerlIO *f, int count);      /* deprecated */

           int     PerlIO_has_base(PerlIO *f);
           char   *PerlIO_get_base(PerlIO *f);
           int     PerlIO_get_bufsiz(PerlIO *f);

           PerlIO *PerlIO_importFILE(FILE *stdio, const char *mode);
           FILE   *PerlIO_exportFILE(PerlIO *f, int flags);
           FILE   *PerlIO_findFILE(PerlIO *f);
           void    PerlIO_releaseFILE(PerlIO *f,FILE *stdio);

           int     PerlIO_apply_layers(PerlIO *f, const char *mode, const char *layers);
           int     PerlIO_binmode(PerlIO *f, int ptype, int imode, const char *layers);
           void    PerlIO_debug(const char *fmt,...)

<b>DESCRIPTION</b>
       Perl's source code, and extensions that want maximum portability, should use the above functions
       instead of those defined in ANSI C's <u>stdio.h</u>.  The perl headers (in particular "perlio.h") will
       "#define" them to the I/O mechanism selected at Configure time.

       The functions are modeled on those in <u>stdio.h</u>, but parameter order has been "tidied up a little".

       "PerlIO *" takes the place of FILE *. Like FILE * it should be treated as opaque (it is probably safe
       to assume it is a pointer to something).

       There are currently three implementations:

       1. USE_STDIO
           All above are #define'd to stdio functions or are trivial wrapper functions which call stdio. In
           this case <u>only</u> PerlIO * is a FILE *.  This has been the default implementation since the abstrac-<font color="#ffffff" class="whiteout">tion&nbsp;abstraction</font>
           tion was introduced in perl5.003_02.

       2. USE_SFIO
           A "legacy" implementation in terms of the "sfio" library. Used for some specialist applications
           on Unix machines ("sfio" is not widely ported away from Unix).  Most of above are #define'd to
           the sfio functions. PerlIO * is in this case Sfio_t *.

       3. USE_PERLIO
           Introduced just after perl5.7.0, this is a re-implementation of the above abstraction which
           allows perl more control over how IO is done as it decouples IO from the way the operating system
           and C library choose to do things. For USE_PERLIO PerlIO * has an extra layer of indirection - it
           is a pointer-to-a-pointer.  This allows the PerlIO * to remain with a known value while swapping
           the implementation around underneath <u>at</u> <u>run</u> <u>time</u>. In this case all the above are true (but very
           simple) functions which call the underlying implementation.

           This is the only implementation for which "PerlIO_apply_layers()" does anything "interesting".

           The USE_PERLIO implementation is described in perliol.

       Because "perlio.h" is a thin layer (for efficiency) the semantics of these functions are somewhat
       dependent on the underlying implementation.  Where these variations are understood they are noted
       below.

       Unless otherwise noted, functions return 0 on success, or a negative value (usually "EOF" which is
       usually -1) and set "errno" on error.

       <u></u><b><u>P</u></b><u></u><b><u>r</u></b><u></u><b><u>I</u></b><b>_</b><u></u><b><u>s</u></b><u></u><b><u>d</u></b><u></u><b><u>n</u></b><u></u><b><u>)</u></b>, <u></u><b><u>P</u></b><u></u><b><u>r</u></b><u></u><b><u>I</u></b><b>_</b><u></u><b><u>s</u></b><u></u><b><u>d</u></b><u></u><b><u>u</u></b><u></u><b><u>(</u></b>, <u></u><b><u>P</u></b><u></u><b><u>r</u></b><u></u><b><u>I</u></b><b>_</b><u></u><b><u>s</u></b><u></u><b><u>d</u></b><u></u><b><u>r</u></b><u></u><b><u>(</u></b>
           Use these rather than "stdin", "stdout", "stderr". They are written to look like "function calls"
           rather than variables because this makes it easier to <u>make</u> <u>them</u> function calls if platform cannot
           export data to loaded modules, or if (say) different "threads" might have different values.

       <b>PerlIO_open(path,</b> <b>mode)</b>, <b>PerlIO_fdopen(fd,mode)</b>
           These correspond to <u>fopen()</u>/<u>fdopen()</u> and the arguments are the same.  Return "NULL" and set
           "errno" if there is an error.  There may be an implementation limit on the number of open han-<font color="#ffffff" class="whiteout">dles,&nbsp;handles,</font>
           dles, which may be lower than the limit on the number of open files - "errno" may not be set when
           "NULL" is returned if this limit is exceeded.

       <b>PerlIO_reopen(path,mode,f)</b>
           While this currently exists in all three implementations perl itself does not use it. <u>As</u> <u>perl</u>
           <u>does</u> <u>not</u> <u>use</u> <u>it,</u> <u>it</u> <u>is</u> <u>not</u> <u>well</u> <u>tested.</u>

           Perl prefers to "dup" the new low-level descriptor to the descriptor used by the existing PerlIO.
           This may become the behaviour of this function in the future.

       <b>PerlIO_printf(f,fmt,...)</b>, <b>PerlIO_vprintf(f,fmt,a)</b>
           These are <u>fprintf()</u>/<u>vfprintf()</u> equivalents.

       <b>PerlIO_stdoutf(fmt,...)</b>
           This is <u>printf()</u> equivalent. printf is #defined to this function, so it is (currently) legal to
           use "printf(fmt,...)" in perl sources.

       <b>PerlIO_read(f,buf,count)</b>, <b>PerlIO_write(f,buf,count)</b>
           These correspond functionally to <u>fread()</u> and <u>fwrite()</u> but the arguments and return values are
           different.  The <u>PerlIO</u><b>_</b><u>read()</u> and <u>PerlIO</u><b>_</b><u>write()</u> signatures have been modeled on the more sane
           low level <u>read()</u> and <u>write()</u> functions instead: The "file" argument is passed first, there is
           only one "count", and the return value can distinguish between error and "EOF".

           Returns a byte count if successful (which may be zero or positive), returns negative value and
           sets "errno" on error.  Depending on implementation "errno" may be "EINTR" if operation was
           interrupted by a signal.

       <!-- a --><b>PerlIO_close(f)</b><!-- /a --><b></b>
           Depending on implementation "errno" may be "EINTR" if operation was interrupted by a signal.

       <b>PerlIO_puts(f,s)</b>, <b>PerlIO_putc(f,c)</b>
           These correspond to <u>fputs()</u> and <u>fputc()</u>.  Note that arguments have been revised to have "file"
           first.

       <b>PerlIO_ungetc(f,c)</b>
           This corresponds to <u>ungetc()</u>.  Note that arguments have been revised to have "file" first.
           Arranges that next read operation will return the byte <b>c</b>.  Despite the implied "character" in the
           name only values in the range 0..0xFF are defined. Returns the byte <b>c</b> on success or -1 ("EOF") on
           error.  The number of bytes that can be "pushed back" may vary, only 1 character is certain, and
           then only if it is the last character that was read from the handle.

       <!-- a --><b>PerlIO_getc(f)</b><!-- /a --><b></b>
           This corresponds to <u>getc()</u>.  Despite the c in the name only byte range 0..0xFF is supported.
           Returns the character read or -1 ("EOF") on error.

       <!-- a --><b>PerlIO_eof(f)</b><!-- /a --><b></b>
           This corresponds to <u>feof()</u>.  Returns a true/false indication of whether the handle is at end of
           file.  For terminal devices this may or may not be "sticky" depending on the implementation.  The
           flag is cleared by <u>PerlIO</u><b>_</b><u>seek()</u>, or <u>PerlIO</u><b>_</b><u>rewind()</u>.

       <!-- a --><b>PerlIO_error(f)</b><!-- /a --><b></b>
           This corresponds to <u>ferror()</u>.  Returns a true/false indication of whether there has been an IO
           error on the handle.

       <!-- a --><b>PerlIO_fileno(f)</b><!-- /a --><b></b>
           This corresponds to <u>fileno()</u>, note that on some platforms, the meaning of "fileno" may not match
           Unix. Returns -1 if the handle has no open descriptor associated with it.

       <!-- a --><b>PerlIO_clearerr(f)</b><!-- /a --><b></b>
           This corresponds to <u>clearerr()</u>, i.e., clears 'error' and (usually) 'eof' flags for the "stream".
           Does not return a value.

       <!-- a --><b>PerlIO_flush(f)</b><!-- /a --><b></b>
           This corresponds to <u>fflush()</u>.  Sends any buffered write data to the underlying file.  If called
           with "NULL" this may flush all open streams (or core dump with some USE_STDIO implementations).
           Calling on a handle open for read only, or on which last operation was a read of some kind may
           lead to undefined behaviour on some USE_STDIO implementations.  The USE_PERLIO (layers) implemen-<font color="#ffffff" class="whiteout">tation&nbsp;implementation</font>
           tation tries to behave better: it flushes all open streams when passed "NULL", and attempts to
           retain data on read streams either in the buffer or by seeking the handle to the current logical
           position.

       <b>PerlIO_seek(f,offset,whence)</b>
           This corresponds to <u>fseek()</u>.  Sends buffered write data to the underlying file, or discards any
           buffered read data, then positions the file descriptor as specified by <b>offset</b> and <b>whence</b> (sic).
           This is the correct thing to do when switching between read and write on the same handle (see
           issues with <u>PerlIO</u><b>_</b><u>flush()</u> above).  Offset is of type "Off_t" which is a perl Configure value
           which may not be same as stdio's "off_t".

       <!-- a --><b>PerlIO_tell(f)</b><!-- /a --><b></b>
           This corresponds to <u>ftell()</u>.  Returns the current file position, or (Off_t) -1 on error.  May
           just return value system "knows" without making a system call or checking the underlying file
           descriptor (so use on shared file descriptors is not safe without a <u>PerlIO</u><b>_</b><u>seek()</u>). Return value
           is of type "Off_t" which is a perl Configure value which may not be same as stdio's "off_t".

       <b>PerlIO_getpos(f,p)</b>, <b>PerlIO_setpos(f,p)</b>
           These correspond (loosely) to <u>fgetpos()</u> and <u>fsetpos()</u>. Rather than stdio's Fpos_t they expect a
           "Perl Scalar Value" to be passed. What is stored there should be considered opaque. The layout of
           the data may vary from handle to handle.  When not using stdio or if platform does not have the
           stdio calls then they are implemented in terms of <u>PerlIO</u><b>_</b><u>tell()</u> and <u>PerlIO</u><b>_</b><u>seek()</u>.

       <!-- a --><b>PerlIO_rewind(f)</b><!-- /a --><b></b>
           This corresponds to <u>rewind()</u>. It is usually defined as being

               PerlIO_seek(f,(Off_t)0L, SEEK_SET);
               <!-- a -->PerlIO_clearerr(f)<!-- /a -->;

       <u></u><b><u>P</u></b><u></u><b><u>r</u></b><u></u><b><u>I</u></b><b>_</b><u></u><b><u>t</u></b><u></u><b><u>p</u></b><u></u><b><u>i</u></b><u></u><b><u>e</u></b><u></u><b><u>)</u></b>
           This corresponds to <u>tmpfile()</u>, i.e., returns an anonymous PerlIO or NULL on error.  The system
           will attempt to automatically delete the file when closed.  On Unix the file is usually
           "unlink"-ed just after it is created so it does not matter how it gets closed. On other systems
           the file may only be deleted if closed via <u>PerlIO</u><b>_</b><u>close()</u> and/or the program exits via "exit".
           Depending on the implementation there may be "race conditions" which allow other processes access
           to the file, though in general it will be safer in this regard than ad. hoc. schemes.

       <!-- a --><b>PerlIO_setlinebuf(f)</b><!-- /a --><b></b>
           This corresponds to <u>setlinebuf()</u>.  Does not return a value. What constitutes a "line" is imple-<font color="#ffffff" class="whiteout">mentation&nbsp;implementation</font>
           mentation dependent but usually means that writing "\n" flushes the buffer.  What happens with
           things like "this\nthat" is uncertain.  (Perl core uses it <u>only</u> when "dumping"; it has nothing to
           do with $| auto-flush.)

       <b>Co-existence</b> <b>with</b> <b>stdio</b>

       There is outline support for co-existence of PerlIO with stdio.  Obviously if PerlIO is implemented
       in terms of stdio there is no problem. However in other cases then mechanisms must exist to create a
       FILE * which can be passed to library code which is going to use stdio calls.

       The first step is to add this line:

          #define PERLIO_NOT_STDIO 0

       <u>before</u> including any perl header files. (This will probably become the default at some point).  That
       prevents "perlio.h" from attempting to #define stdio functions onto PerlIO functions.

       XS code is probably better using "typemap" if it expects FILE * arguments.  The standard typemap will
       be adjusted to comprehend any changes in this area.

       <b>PerlIO_importFILE(f,mode)</b>
           Used to get a PerlIO * from a FILE *.

           The mode argument should be a string as would be passed to fopen/PerlIO_open.  If it is NULL then
           - for legacy support - the code will (depending upon the platform and the implementation) either
           attempt to empirically determine the mode in which <u>f</u> is open, or use "r+" to indicate a
           read/write stream.

           Once called the FILE * should <u>ONLY</u> be closed by calling "PerlIO_close()" on the returned PerlIO
           *.

           The PerlIO is set to textmode. Use PerlIO_binmode if this is not the desired mode.

           This is <b>not</b> the reverse of <u>PerlIO</u><b>_</b><u>exportFILE()</u>.

       <b>PerlIO_exportFILE(f,mode)</b>
           Given a PerlIO * create a 'native' FILE * suitable for passing to code expecting to be compiled
           and linked with ANSI C <u>stdio.h</u>.  The mode argument should be a string as would be passed to
           fopen/PerlIO_open.  If it is NULL then - for legacy support - the FILE * is opened in same mode
           as the PerlIO *.

           The fact that such a FILE * has been 'exported' is recorded, (normally by pushing a new :stdio
           "layer" onto the PerlIO *), which may affect future PerlIO operations on the original PerlIO *.
           You should not call "fclose()" on the file unless you call "PerlIO_releaseFILE()" to disassociate
           it from the PerlIO *.  (Do not use <u>PerlIO</u><b>_</b><u>importFILE()</u> for doing the disassociation.)

           Calling this function repeatedly will create a FILE * on each call (and will push an :stdio layer
           each time as well).

       <b>PerlIO_releaseFILE(p,f)</b>
           Calling PerlIO_releaseFILE informs PerlIO that all use of FILE * is complete. It is removed from
           the list of 'exported' FILE *s, and the associated PerlIO * should revert to its original behav-<font color="#ffffff" class="whiteout">iour.&nbsp;behaviour.</font>
           iour.

           Use this to disassociate a file from a PerlIO * that was associated using <u>PerlIO</u><b>_</b><u>exportFILE()</u>.

       <!-- a --><b>PerlIO_findFILE(f)</b><!-- /a --><b></b>
           Returns a native FILE * used by a stdio layer. If there is none, it will create one with Per-<font color="#ffffff" class="whiteout">lIO_exportFILE.&nbsp;PerlIO_exportFILE.</font>
           lIO_exportFILE. In either case the FILE * should be considered as belonging to PerlIO subsystem
           and should only be closed by calling "PerlIO_close()".

       <b>"Fast</b> <b>gets"</b> <b>Functions</b>

       In addition to standard-like API defined so far above there is an "implementation" interface which
       allows perl to get at internals of PerlIO.  The following calls correspond to the various FILE_xxx
       macros determined by Configure - or their equivalent in other implementations. This section is really
       of interest to only those concerned with detailed perl-core behaviour, implementing a PerlIO mapping
       or writing code which can make use of the "read ahead" that has been done by the IO system in the
       same way perl does. Note that any code that uses these interfaces must be prepared to do things the
       traditional way if a handle does not support them.

       <!-- a --><b>PerlIO_fast_gets(f)</b><!-- /a --><b></b>
           Returns true if implementation has all the interfaces required to allow perl's "sv_gets" to
           "bypass" normal IO mechanism.  This can vary from handle to handle.

             <!-- a -->PerlIO_fast_gets(f)<!-- /a --> = <!-- a -->PerlIO_has_cntptr(f)<!-- /a --> &amp;&amp; \
                                   <!-- a -->PerlIO_canset_cnt(f)<!-- /a --> &amp;&amp; \
                                   `Can set pointer into buffer'

       <!-- a --><b>PerlIO_has_cntptr(f)</b><!-- /a --><b></b>
           Implementation can return pointer to current position in the "buffer" and a count of bytes avail-<font color="#ffffff" class="whiteout">able&nbsp;available</font>
           able in the buffer.  Do not use this - use PerlIO_fast_gets.

       <!-- a --><b>PerlIO_get_cnt(f)</b><!-- /a --><b></b>
           Return count of readable bytes in the buffer. Zero or negative return means no more bytes avail-<font color="#ffffff" class="whiteout">able.&nbsp;available.</font>
           able.

       <!-- a --><b>PerlIO_get_ptr(f)</b><!-- /a --><b></b>
           Return pointer to next readable byte in buffer, accessing via the pointer (dereferencing) is only
           safe if <u>PerlIO</u><b>_</b><u>get</u><b>_</b><u>cnt()</u> has returned a positive value.  Only positive offsets up to value
           returned by <u>PerlIO</u><b>_</b><u>get</u><b>_</b><u>cnt()</u> are allowed.

       <b>PerlIO_set_ptrcnt(f,p,c)</b>
           Set pointer into buffer, and a count of bytes still in the buffer. Should be used only to set
           pointer to within range implied by previous calls to "PerlIO_get_ptr" and "PerlIO_get_cnt". The
           two values <u>must</u> be consistent with each other (implementation may only use one or the other or
           may require both).

       <!-- a --><b>PerlIO_canset_cnt(f)</b><!-- /a --><b></b>
           Implementation can adjust its idea of number of bytes in the buffer.  Do not use this - use Per-<font color="#ffffff" class="whiteout">lIO_fast_gets.&nbsp;PerlIO_fast_gets.</font>
           lIO_fast_gets.

       <b>PerlIO_set_cnt(f,c)</b>
           Obscure - set count of bytes in the buffer. Deprecated.  Only usable if <u>PerlIO</u><b>_</b><u>canset</u><b>_</b><u>cnt()</u>
           returns true.  Currently used in only doio.c to force count less than -1 to -1.  Perhaps should
           be PerlIO_set_empty or similar.  This call may actually do nothing if "count" is deduced from
           pointer and a "limit".  Do not use this - use <u>PerlIO</u><b>_</b><u>set</u><b>_</b><u>ptrcnt()</u>.

       <!-- a --><b>PerlIO_has_base(f)</b><!-- /a --><b></b>
           Returns true if implementation has a buffer, and can return pointer to whole buffer and its size.
           Used by perl for <b>-T</b> / <b>-B</b> tests.  Other uses would be very obscure...

       <!-- a --><b>PerlIO_get_base(f)</b><!-- /a --><b></b>
           Return <u>start</u> of buffer. Access only positive offsets in the buffer up to the value returned by
           <u>PerlIO</u><b>_</b><u>get</u><b>_</b><u>bufsiz()</u>.

       <!-- a --><b>PerlIO_get_bufsiz(f)</b><!-- /a --><b></b>
           Return the <u>total</u> <u>number</u> <u>of</u> <u>bytes</u> in the buffer, this is neither the number that can be read, nor
           the amount of memory allocated to the buffer. Rather it is what the operating system and/or
           implementation happened to "read()" (or whatever) last time IO was requested.

       <b>Other</b> <b>Functions</b>


       PerlIO_apply_layers(f,mode,layers)
           The new interface to the USE_PERLIO implementation. The layers ":crlf" and ":raw" are only ones
           allowed for other implementations and those are silently ignored. (As of perl5.8 ":raw" is depre-<font color="#ffffff" class="whiteout">cated.)&nbsp;deprecated.)</font>
           cated.)  Use <u>PerlIO</u><b>_</b><u>binmode()</u> below for the portable case.

       PerlIO_binmode(f,ptype,imode,layers)
           The hook used by perl's "binmode" operator.  <b>ptype</b> is perl's character for the kind of IO:

           '&lt;' read
           '&gt;' write
           '+' read/write

           <b>imode</b> is "O_BINARY" or "O_TEXT".

           <b>layers</b> is a string of layers to apply, only ":crlf" makes sense in the non USE_PERLIO case. (As
           of perl5.8 ":raw" is deprecated in favour of passing NULL.)

           Portable cases are:

               PerlIO_binmode(f,ptype,O_BINARY,Nullch);
           and
               PerlIO_binmode(f,ptype,O_TEXT,":crlf");

           On Unix these calls probably have no effect whatsoever.  Elsewhere they alter "\n" to CR,LF
           translation and possibly cause a special text "end of file" indicator to be written or honoured
           on read. The effect of making the call after doing any IO to the handle depends on the implemen-<font color="#ffffff" class="whiteout">tation.&nbsp;implementation.</font>
           tation. (It may be ignored, affect any data which is already buffered as well, or only apply to
           subsequent data.)

       PerlIO_debug(fmt,...)
           PerlIO_debug is a <u>printf()</u>-like function which can be used for debugging.  No return value. Its
           main use is inside PerlIO where using real printf, <u>warn()</u> etc. would recursively call PerlIO and
           be a problem.

           PerlIO_debug writes to the file named by $ENV{'PERLIO_DEBUG'} typical use might be

             Bourne shells (sh, ksh, bash, zsh, ash, ...):
              PERLIO_DEBUG=/dev/tty ./perl somescript some args

             Csh/Tcsh:
              setenv PERLIO_DEBUG /dev/tty
              ./perl somescript some args

             If you have the "env" utility:
              env PERLIO_DEBUG=/dev/tty ./perl somescript some args

             Win32:
              set PERLIO_DEBUG=CON
              perl somescript some args

           If $ENV{'PERLIO_DEBUG'} is not set <u>PerlIO</u><b>_</b><u>debug()</u> is a no-op.



perl v5.8.8                                      2006-01-07                                      PERLAPIO(1)
</tt></pre>
</td></tr></table>
	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Darwin/Reference/ManPages/man1/perlapio.1.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Darwin/Reference/ManPages/man1/perlapio.1.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Darwin/Reference/ManPages/man1/perlapio.1.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

</body></html>
