<html>

<body bgcolor="#FFFFFF">

<CENTER><H1>Class next.eo.FetchSpecification</H1></CENTER>

<a name="description"></a><CENTER><H2>CLASS DESCRIPTION</H2></CENTER>

<!-- extends:next.util.NextObject -->

<DL>

<DT><B>Extends:</B></DT><DD>next.util.NextObject</DD>

</DL>

<P>

A FetchSpecification collects the criteria needed to select and order a group of records or enterprise objects, whether from an external repository such as a relational database or an internal store such as an EditingContext. A FetchSpecification contains these elements:
<UL>
<LI>The name of an entity for which to fetch records or objects. This is the only mandatory element.
<LI>A Qualifier, indicating which properties to select by and how to do so.
<LI>An array of SortOrderings, which indicate how the selected records or objects should be ordered when fetched.
<LI>An indicator of whether to produce distinct results or not. Normally if a record or object is selected several times, such as when forming a join, it appears several times in the fetched results. A FetchSpecification that makes distinct selections causes duplicates to be filtered out, so that each record or object selected appears exactly once in the result set.
<LI>An indicator of whether to fetch deeply or not. This is used with inheritance hierarchies when fetching for an entity with sub-entities. A deep fetch produces all instances of the entity and its sub-entities, while a shallow fetch produces instances only of the entity in the fetch specification.
<LI>A dictionary of hints, which a DatabaseContext or other object can use to optimize or alter the results of the fetch.
</UL>
FetchSpecifications are used most often in the <B>objectsWithFetchSpecification</B> method defined by <!--EOObjectStore,--> EditingContext.<!--, and EODatabaseContext, as well as objectsWithFetchSpecification:, defined by EOEditingContext alone. EOAdaptorChannel and EODatabaseChannel also define methods that use FetchSpecifications.--> 
<hr>

</body>

</html><html>

<body bgcolor="#FFFFFF"><!-- constructors -->

<a name="constructors"><CENTER><H2>CONSTRUCTORS</H2></CENTER></a>

<!-- consKey:FetchSpecification(public) cons:FetchSpecification descr:<TT>public  <B>FetchSpecification</B>()</TT>:<TT>public  <B>FetchSpecification</B>(java.lang.String <I>aString</I>, next.eo.Qualifier <I>aQualifier</I>, next.util.ImmutableVector <I>anImmutableVector</I>)</TT> -->

<H3><a name="FetchSpecification(public)">FetchSpecification</a></H3>

<TT>public  <B>FetchSpecification</B>()</TT><br>

<TT>public  <B>FetchSpecification</B>(java.lang.String <I>entityName</I>, next.eo.Qualifier <I>aQualifier</I>, next.util.ImmutableVector <I>sortOrderings</I>)</TT>

<P>

Returns a newly-allocated and initialized FetchSpecification object. If the parameters are supplied, this method returns a FetchSpecification for <I>entityName</I>, using qualifier to select and <I>sortOrderings</I> to sort the results. This FetchSpecification doesn't perform distinct selection, is deep, and has no hints.
<P>

<!-- <B>See Also: </B>[See Also's go here] -->

<hr>

</body>

</html><html>

<body bgcolor="#FFFFFF"><!-- methods -->

<a name="methods"><CENTER><H2>METHODS</H2></CENTER></a>

<!-- methKey:entityName(public) meth:entityName descr:<TT>public java.lang.String <B>entityName</B>()</TT> -->

<H3><a name="entityName(public)">entityName</a></H3>

<TT>public java.lang.String <B>entityName</B>()</TT>

<P>

Returns the name of the entity to be fetched.
<P>

<!-- <B>See Also: </B>[See Also's go here] -->

<hr>

<!-- methKey:hints(public) meth:hints descr:<TT>public next.util.ImmutableHashtable <B>hints</B>()</TT> -->

<H3><a name="hints(public)">hints</a></H3>

<TT>public next.util.ImmutableHashtable <B>hints</B>()</TT>

<P>

Returns the receiver's hints, which other objects can use to alter or optimize fetch operations. <!--DatabaseContext's objectsWithFetchSpecification:editingContext: uses a hint to prefetch the destinations of relationships, for example. See the EODatabaseContext class specification for more information.-->
<P>

<!-- <B>See Also: </B>[See Also's go here] -->

<hr>

<!-- methKey:isDeep(public) meth:isDeep descr:<TT>public boolean <B>isDeep</B>()</TT> -->

<H3><a name="isDeep(public)">isDeep</a></H3>

<TT>public boolean <B>isDeep</B>()</TT>

<P>

Returns <B>true</B> if a fetch should include sub-entities of the receiver's entity, <B>false</B> if it shouldn't. FetchSpecifications are deep by default.
For example, if you have a Person entity with two sub-entities, Employee and Customer, fetching Persons deeply also fetches all Employees and Customers matching the qualifier, and fetching Persons shallowly fetches only Persons matching the qualifier.
<P>

<!-- <B>See Also: </B>[See Also's go here] -->

<hr>

<!-- methKey:locksObjects(public) meth:locksObjects descr:<TT>public boolean <B>locksObjects</B>()</TT> -->

<H3><a name="locksObjects(public)">locksObjects</a></H3>

<TT>public boolean <B>locksObjects</B>()</TT>

<P>

Returns <B>true</B> if a fetch should result in the selected objects being locked in the data repository, <B>false</B> if it shouldn't. The default is <B>false</B>.
<P>

<!-- <B>See Also: </B>[See Also's go here] -->

<hr>

<!-- methKey:qualifier(public) meth:qualifier descr:<TT>public next.eo.Qualifier <B>qualifier</B>()</TT> -->

<H3><a name="qualifier(public)">qualifier</a></H3>

<TT>public next.eo.Qualifier <B>qualifier</B>()</TT>

<P>

Returns the Qualifier that indicates which records or objects to fetch.
<P>

<!-- <B>See Also: </B>[See Also's go here] -->

<hr>

<!-- methKey:refreshesRefetchedObjects(public) meth:refreshesRefetchedObjects descr:<TT>public boolean <B>refreshesRefetchedObjects</B>()</TT> -->

<H3><a name="refreshesRefetchedObjects(public)">refreshesRefetchedObjects</a></H3>

<TT>public boolean <B>refreshesRefetchedObjects</B>()</TT>

<P>

Returns <B>true</B> if existing objects are overwritten with fetched values when they've have been updated or changed. Returns <B>false</B> if existing objects aren't touched when their data is refetched (the fetched data is simply discarded). The default is <B>false</B>.
<P>

<!-- <B>See Also: </B>[See Also's go here] -->

<hr>

<!-- methKey:setEntityName(public) meth:setEntityName descr:<TT>public void <B>setEntityName</B>(java.lang.String <I>aString</I>)</TT> -->

<H3><a name="setEntityName(public)">setEntityName</a></H3>

<TT>public void <B>setEntityName</B>(java.lang.String <I>entityName</I>)</TT>

<P>

Sets the name of the root entity to be fetched to <I>entityName</I>.
<P>

<!-- <B>See Also: </B>[See Also's go here] -->

<hr>

<!-- methKey:setHints(public) meth:setHints descr:<TT>public void <B>setHints</B>(next.util.ImmutableHashtable <I>anImmutableHashtable</I>)</TT> -->

<H3><a name="setHints(public)">setHints</a></H3>

<TT>public void <B>setHints</B>(next.util.ImmutableHashtable <I>hints</I>)</TT>

<P>

Sets the receiver's hints to <I>hints</I>. Other objects can use these to alter or optimize fetch operations. <!-- See the description of the objectsWithFetchSpecification:editingContext: method in the EODatabaseContext class specification for an example.-->
<P>

<!-- <B>See Also: </B>[See Also's go here] -->

<hr>

<!-- methKey:setIsDeep(public) meth:setIsDeep descr:<TT>public void <B>setIsDeep</B>(boolean <I>flag</I>)</TT> -->

<H3><a name="setIsDeep(public)">setIsDeep</a></H3>

<TT>public void <B>setIsDeep</B>(boolean <I>flag</I>)</TT>

<P>

Controls whether a fetch should include sub-entities of the receiver's entity. If flag is <B>true</B>, sub-entities are also fetched; if flag is <B>false</B>, they aren't. FetchSpecifications are deep by default.
<P>
For example, if you have a Person entity/class/table with two sub-entities and subclasses, Employee and Customer, fetching Persons deeply also fetches all Employees and Customers matching the qualifier, while fetching Persons shallowly fetches only Persons matching the qualifier.
<P>

<!-- <B>See Also: </B>[See Also's go here] -->

<hr>

<!-- methKey:setLocksObjects(public) meth:setLocksObjects descr:<TT>public void <B>setLocksObjects</B>(boolean <I>flag</I>)</TT> -->

<H3><a name="setLocksObjects(public)">setLocksObjects</a></H3>

<TT>public void <B>setLocksObjects</B>(boolean <I>flag</I>)</TT>

<P>

Controls whether a fetch should result in the selected objects being locked in the data repository. If <I>flag</I> is <B>true</B> it should, if <B>false</B> it shouldn't. The default is <B>false</B>.
<P>

<!-- <B>See Also: </B>[See Also's go here] -->

<hr>

<!-- methKey:setQualifier(public) meth:setQualifier descr:<TT>public void <B>setQualifier</B>(next.eo.Qualifier <I>aQualifier</I>)</TT> -->

<H3><a name="setQualifier(public)">setQualifier</a></H3>

<TT>public void <B>setQualifier</B>(next.eo.Qualifier <I>aQualifier</I>)</TT>

<P>

Sets the receiver's qualifier to <I>aQualifier</I>.
<P>

<!-- <B>See Also: </B>[See Also's go here] -->

<hr>

<!-- methKey:setRefreshesRefetchedObjects(public) meth:setRefreshesRefetchedObjects descr:<TT>public void <B>setRefreshesRefetchedObjects</B>(boolean <I>flag</I>)</TT> -->

<H3><a name="setRefreshesRefetchedObjects(public)">setRefreshesRefetchedObjects</a></H3>

<TT>public void <B>setRefreshesRefetchedObjects</B>(boolean <I>flag</I>)</TT>

<P>

Controls whether existing objects are overwritten with fetched values when they've have been updated or changed. If <I>flag</I> is <B>true</B>, they are; if <I>flag</I> is <B>false</B>, they aren't (the fetched data is simply discarded). The default is <B>false</B>.
<P>

<!-- <B>See Also: </B>[See Also's go here] -->

<hr>

<!-- methKey:setSortOrderings(public) meth:setSortOrderings descr:<TT>public void <B>setSortOrderings</B>(next.util.ImmutableVector <I>anImmutableVector</I>)</TT> -->

<H3><a name="setSortOrderings(public)">setSortOrderings</a></H3>

<TT>public void <B>setSortOrderings</B>(next.util.ImmutableVector <I>sortOrderings</I>)</TT>

<P>

Sets the receiver's array of SortOrderings to <I>sortOrderings</I>. When a fetch is performed with the receiver, the results are sorted by applying each SortOrdering in the array.
<P>

<!-- <B>See Also: </B>[See Also's go here] -->

<hr>

<!-- methKey:setUsesDistinct(public) meth:setUsesDistinct descr:<TT>public void <B>setUsesDistinct</B>(boolean <I>flag</I>)</TT> -->

<H3><a name="setUsesDistinct(public)">setUsesDistinct</a></H3>

<TT>public void <B>setUsesDistinct</B>(boolean <I>flag</I>)</TT>

<P>

Controls whether duplicate objects or records are removed after fetching. If <I>flag</I> is <B>true</B> they're removed; if <I>flag</I> is <B>false</B> they aren't. FetchSpecifications by default don't use distinct.
<P>

<!-- <B>See Also: </B>[See Also's go here] -->

<hr>

<!-- methKey:sortOrderings(public) meth:sortOrderings descr:<TT>public next.util.ImmutableVector <B>sortOrderings</B>()</TT> -->

<H3><a name="sortOrderings(public)">sortOrderings</a></H3>

<TT>public next.util.ImmutableVector <B>sortOrderings</B>()</TT>

<P>

Returns the receiver's array of SortOrderings. When a fetch is performed with the receiver, the results are sorted by applying each SortOrdering in the array.
<P>

<!-- <B>See Also: </B>[See Also's go here] -->

<hr>

<!-- methKey:usesDistinct(public) meth:usesDistinct descr:<TT>public boolean <B>usesDistinct</B>()</TT> -->

<H3><a name="usesDistinct(public)">usesDistinct</a></H3>

<TT>public boolean <B>usesDistinct</B>()</TT>

<P>

Returns <B>true</B> if duplicate objects or records are removed after fetching, <B>false</B> if they aren't. FetchSpecifications by default don't use distinct.
<P>

<!-- <B>See Also: </B>[See Also's go here] -->

<hr>

</body>

</html>