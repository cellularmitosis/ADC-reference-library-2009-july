<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>Mass Storage Device Driver Programming Guide: Mass Storage Overview</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Mass Storage Overview"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP30000734" title="Mass Storage Overview"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../../HardwareDrivers/index.html#//apple_ref/doc/uid/TP30000440-TP40003576" target="_top">Hardware &amp; Drivers</a> &gt; <a href="../../../../HardwareDrivers/MassStorageDevices-date.html#//apple_ref/doc/uid/TP30000440-TP40003576-TP30001039" target="_top">Storage</a> &gt; <a href="../01_Introduction/Introduction.html#//apple_ref/doc/uid/TP30000733-TPXREF101">Mass Storage Device Driver Programming Guide</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../01_Introduction/Introduction.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../03_Compliance/MS_Compliance.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP30000734-BGCJABAJ" title="Mass Storage Overview"></a><h1>Mass Storage Overview</h1><p>The term mass storage encompasses a wide range of devices. Broadly defined, a mass storage device is any storage device that has media local to a machine and can support a file system. Mac OS X supports mass storage devices with a stack of drivers that manage the physical connection of the device to the bus, the translation of commands from the system to the device, and the device partitions that the user sees.</p><p>This chapter describes the construction and implementation of the mass storage driver stack. It also describes the SCSI Architecture Model family which implements the SCSI Architecture Model specifications in the transport driver layer and the Storage family which supports the device services layer.</p>
<!-- This template is being used for both PDF and HTML. -->

    
    <h4>In this section:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="MS_Overview.html#//apple_ref/doc/uid/TP30000734-DontLinkElementID_3">Mass Storage Devices in Mac OS X</a>
				
			<br/>
			
        
			
			
				<a href="MS_Overview.html#//apple_ref/doc/uid/TP30000734-TPXREF101">Mass Storage Drivers</a>
				
			<br/>
			
        
			
			
				<a href="MS_Overview.html#//apple_ref/doc/uid/TP30000734-BJGCIFBA">The Mass Storage Driver Stack</a>
				
			<br/>
			
        
			
			
				<a href="MS_Overview.html#//apple_ref/doc/uid/TP30000734-TPXREF102">Mass Storage Stack Implementation</a>
				
			<br/>
			
        
			
			
				<a href="MS_Overview.html#//apple_ref/doc/uid/TP30000734-BJGFJIJA">Construction of a Mass Storage Driver Stack</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP30000734-DontLinkElementID_3" title="Mass Storage Devices in Mac OS X"></a><h2>Mass Storage Devices in Mac OS X</h2><p>The Mac OS X mass storage driver stack represents a completely different model of mass storage device support from that in earlier versions of the Mac OS. Instead of a unique driver for every mass storage device, the Mac OS X mass storage driver stack separates device communication into different layers that comprise separate drivers. Apple-provided drivers provide services such as event handling and hot-plugging support, allowing you to write a driver that supports only the different or additional functionality your device requires.</p><p>In Mac OS X, ATA mass storage device drivers<a name="//apple_ref/doc/uid/TP30000734-DontLinkElementID_18"></a> do not fully participate in the mass storage driver stack. A driver for an ATA mass storage device exists in a separate stack, providing the same functionality as the drivers in the lower layers of the mass storage driver stack. It does communicate with the device services layer, however, through an interface it provides.</p><p>The mass storage driver stack in Mac OS X version 10.1 and later supports SCSI devices of peripheral device types $00, $05, $07, and $0E. This includes devices such as CD-ROM and DVD-ROM drives, flash cards, and magneto-optical devices. In later versions of Mac OS X, however, the mass storage stack will include support for other SCSI peripheral devices, such as scanners. Until then, separate drivers outside the mass storage driver stack continue to provide support for these devices.</p><p>Traditionally, the term “SCSI” referred to the original parallel bus defined by the SCSI Architecture Model-1 and SCSI Architecture Model-2 specifications. With the introduction of Fibre Channel and Serial Storage Architecture (SSA), however, the SCSI Architecture Model-3 specification expanded the term to define an architecture that treats in a consistent manner devices that adhere to the SCSI Architecture Model<a name="//apple_ref/doc/uid/TP30000734-DontLinkElementID_19"></a> specifications, independent of the physical bus the device is attached to.</p><p>In this document, the term “SCSI” refers to any physical bus (FireWire, ATAPI, parallel SCSI, or USB) or device that complies with the SCSI Architecture Model-2 specifications. This document refers to the original SCSI parallel bus technology as SCSI Parallel Interconnect (SPI) or parallel SCSI<a name="//apple_ref/doc/uid/TP30000734-DontLinkElementID_20"></a>.</p><a name="//apple_ref/doc/uid/TP30000734-TPXREF101" title="Mass Storage Drivers"></a><h2>Mass Storage Drivers</h2><p>In versions of the Mac OS before Mac OS X, mass storage I/O requests were serviced by a monolithic device driver that was responsible for every partition scheme, command set, and bus protocol associated with its device. There was a one-to-one correspondence between drivers and devices: A new device required a new driver, no matter how similar the new driver might be to a preexisting one. With the introduction of Mac OS X, however, this device driver model was replaced by the I/O Kit, an object-oriented driver development framework emphasizing modularity and reusability.</p><p>In Mac OS X, a driver for a mass storage device that mounts a file system or is bootable is a kernel extension, or KEXT. This KEXT inherits much of its functionality from an I/O Kit family that implements software abstractions common to all devices of a particular type.</p><p>In Mac OS X, a single mass storage device driver is therefore no longer responsible for partition information, bus protocols, or parameter block controls because these details are handled by other objects in the mass storage driver stack. In addition, the complexities introduced by features of Mac OS X such as its multithreaded kernel and hot-plugging support are handled by family code, freeing the driver to support the functions unique to its device or device type.</p><p>The I/O Kit’s concept of family provides the perfect framework for the implementation of the industry standard SCSI Architecture Model<a name="//apple_ref/doc/uid/TP30000734-DontLinkElementID_21"></a>. The SCSI Architecture Model specifications (<span class="content_text"><a href="http://t10.org" target="_blank">http://t10.org</a></span>) provide guidelines for implementing a system across all SCSI interconnect and protocol environments. The SCSI Architecture Model specifications are in no way confined to parallel SCSI <a name="//apple_ref/doc/uid/TP30000734-DontLinkElementID_22"></a>devices alone. Transcending SCSI hardware, the SCSI Architecture Model defines the functional partitioning of the SCSI command sets and protocol standards for devices that understand command descriptor blocks and adhere to the SCSI Architecture Model specifications, regardless of the physical bus they are attached to.</p><p>The SCSI Architecture Model family (described in <span class="content_text"><a href="MS_Overview.html#//apple_ref/doc/uid/TP30000734-BJGFJFFH">“The SCSI Architecture Model Family”</a></span>) implements the SCSI Architecture Model specifications in code abstractions that provide support for a wide range of devices across different buses. The Storage family (described in <span class="content_text"><a href="MS_Overview.html#//apple_ref/doc/uid/TP30000734-BBCJIEGH">“The Storage Family”</a></span>) provides APIs that support access to the storage space represented by devices, independent of the underlying technology involved in the transport of data.</p><p><span class="content_text"><a href="MS_Overview.html#//apple_ref/doc/uid/TP30000734-BJGCIFBA">“The Mass Storage Driver Stack”</a></span> gives an overview of the mass storage driver stack, concentrating on the architecture of the stack and introducing the interaction of its layers. Although it’s important to remember that the objects inhabiting these layers inherit from I/O Kit base classes and partake of functionality provided by I/O Kit families, it is equally important to avoid confusing the architecture of the driver stack with the “architecture” of the class hierarchy. To emphasize the distinction between the logical stacking of mass storage drivers and the I/O Kit class hierarchy of those drivers, the I/O Kit implementation of the driver stack is described separately in <span class="content_text"><a href="MS_Overview.html#//apple_ref/doc/uid/TP30000734-BJGJFDHD">“Mass Storage Driver Objects.”</a></span></p><a name="//apple_ref/doc/uid/TP30000734-BJGCIFBA" title="The Mass Storage Driver Stack"></a><h2>The Mass Storage Driver Stack</h2><p>The mass storage driver stack consists of three fundamental layers, shown in <span class="content_text"><a href="MS_Overview.html#//apple_ref/doc/uid/TP30000734-BGCIAIEH">Figure 1-1</a></span>. The stack is oriented with the physical device at the bottom and the ultimate client of that device (the application or the system) at the top.</p><br/><div><a name="//apple_ref/doc/uid/TP30000734-BGCIAIEH" title="Figure 1-1The mass storage driver stack"></a><p><strong>Figure 1-1&nbsp;&nbsp;</strong>The mass storage driver stack</p><a name="//apple_ref/doc/uid/TP30000734-DontLinkElementID_23"></a><img src = "../art/massstrodrvstack.gif" alt = "The mass storage driver stack" width="247" height="272"></div><br/><p>At the top of the figure, above the device services layer<a name="//apple_ref/doc/uid/TP30000734-DontLinkElementID_24"></a>, is the user-kernel boundary. Applications reside above this boundary along with application-based drivers, like those for scanners, tape drives, and digital cameras.</p><p>On the kernel side of the boundary is the top layer of the mass storage stack, the device services layer. This layer contains the generic block storage driver and optional filter schemes that can implement encryption or validation<a name="//apple_ref/doc/uid/TP30000734-DontLinkElementID_25"></a>.</p><p>The generic block storage driver views a mass storage device as simply a storage space with no knowledge of device command sets or physical interconnect protocols. The filter schemes view mass storage devices even more abstractly: Mass storage devices can contain media objects that may represent any subset of a device, such as a disk partition, or even a set of multiple devices, such as a RAID disk controller that harnesses several disks together to appear as a single volume.</p><p>It is not likely that you will need to subclass the generic block storage driver to support a particular device’s idiosyncrasies. A much better solution is to subclass a logical unit or protocol services driver in the transport driver layer. Creating a filter-scheme driver, however, is a good way to provide support for additional data manipulation your device may require. <span class="content_text"><a href="MS_Overview.html#//apple_ref/doc/uid/TP30000734-BBCIIHJJ">“The Device Services Layer”</a></span> describes this layer in more detail.</p><p>The middle layer of the mass storage stack is the transport driver layer. This layer comprises information about communicating with particular types of devices. I/O requests from the device services layer come into the transport driver layer where they are translated into commands suitable for the target device and then sent via the appropriate bus in the physical interconnect layer. The logical unit drivers and protocol services drivers from which you can subclass your device-specific and bus-specific drivers are in this layer. The transport driver layer itself is multilayered and is the focus of <span class="content_text"><a href="MS_Overview.html#//apple_ref/doc/uid/TP30000734-BJGEJCJJ">“The Transport Driver Layer.”</a></span></p><p>The layer above the device is the physical interconnect layer<a name="//apple_ref/doc/uid/TP30000734-DontLinkElementID_26"></a>. As its name suggests, this layer consists of a collection of objects that are associated with the connection of the device to the bus. The bus controller drivers for FireWire, USB, and ATAPI are here, along with objects representing the device and, in some cases, logical portions of the device.</p><p>Unless there are bus-related issues you need to address for your device, it is not likely that you will need to subclass any physical interconnect driver.</p><a name="//apple_ref/doc/uid/TP30000734-BJGEJCJJ" title="The Transport Driver Layer"></a><h3>The Transport Driver Layer</h3><p><a name="//apple_ref/doc/uid/TP30000734-DontLinkElementID_27"></a>The transport driver layer transforms generic I/O requests into device-specific commands, suitable for transport on a particular bus. This layer (shown in <span class="content_text"><a href="MS_Overview.html#//apple_ref/doc/uid/TP30000734-BBCJCDHC">Figure 1-2</a></span>) consists of a link to the device services layer and two primary sublayers that accomplish the translation of I/O requests.</p><br/><div><a name="//apple_ref/doc/uid/TP30000734-BBCJCDHC" title="Figure 1-2The transport driver layer"></a><p><strong>Figure 1-2&nbsp;&nbsp;</strong>The transport driver layer</p><a name="//apple_ref/doc/uid/TP30000734-DontLinkElementID_28"></a><img src = "../art/transpdrvlayer.gif" alt = "The transport driver layer" width="265" height="273"></div><br/><p>Between the device services layer and the transport driver layer proper is the device services nub<a name="//apple_ref/doc/uid/TP30000734-DontLinkElementID_29"></a>. This nub presents the APIs the device implements and provides an attachment point between the block storage driver in the device services layer and the logical unit driver in the transport driver layer.</p><p>When a logical unit driver<a name="//apple_ref/doc/uid/TP30000734-DontLinkElementID_30"></a> loads for a particular device, it publishes the corresponding device services nub which contains the device’s type in the I/O Registry so that the appropriate block storage driver can be loaded. Once the block storage driver loads, it communicates with the objects in the transport driver layer through the device services nub.</p><p>The main responsibility of the SCSI application sublayer<a name="//apple_ref/doc/uid/TP30000734-DontLinkElementID_31"></a><a name="//apple_ref/doc/uid/TP30000734-DontLinkElementID_32"></a> is to translate generic I/O requests into device-specific commands. This is done in the logical unit driver specific to the type of device. The SCSI Architecture Model specifications define several device categories, called peripheral device types. For example, sequential access devices such as tape drives are defined as peripheral device type $01 and printers are defined as peripheral device type $02.</p><p>Because neither tape drives nor printers are bootable or mount file systems, their logical unit drivers do not need to be in the kernel. Logical unit drivers for peripheral devices such as CD-ROM drives that are bootable and do mount file systems, however, must reside in the kernel. Apple provides four logical unit drivers corresponding to peripheral device types $00, $05, $07, and $0E:</p><ul class="spaceabove"><li class="li"><p><code>IOSCSIPeripheralDeviceType00</code> for block storage devices such as internal disk drives</p></li><li class="li"><p><code>IOSCSIPeripheralDeviceType05</code> for multimedia devices such as CD and DVD drives</p></li><li class="li"><p><code>IOSCSIPeripheralDeviceType07</code> for magneto-optical devices</p></li><li class="li"><p><code>IOSCSIPeripheralDeviceType0E</code> for reduced block command devices such as flash cards and smart media devices</p></li></ul><p>The logical unit driver uses an associated utility class called a command set builder<a name="//apple_ref/doc/uid/TP30000734-DontLinkElementID_33"></a> to create an object called <code>SCSITask</code><a name="//apple_ref/doc/uid/TP30000734-DontLinkElementID_34"></a>. The <code>SCSITask</code> object (described more fully in <span class="content_text"><a href="MS_Overview.html#//apple_ref/doc/uid/TP30000734-BGCDHGIJ">“The SCSITask Object”</a></span>) contains the command descriptor block<a name="//apple_ref/doc/uid/TP30000734-DontLinkElementID_35"></a>, or CDB<a name="//apple_ref/doc/uid/TP30000734-DontLinkElementID_36"></a>, created from the generic I/O request together with all the data required during the life span of a single I/O transaction. This data includes information such as potential errors encountered, callback function pointers, and retry status. The <code>SCSITask</code> object is the fundamental unit of I/O transactions in the transport driver layer.</p><p>The other part of the SCSI application sublayer shown in <span class="content_text"><a href="MS_Overview.html#//apple_ref/doc/uid/TP30000734-BBCJCDHC">Figure 1-2</a></span> is the peripheral device nub<a name="//apple_ref/doc/uid/TP30000734-DontLinkElementID_37"></a><a name="//apple_ref/doc/uid/TP30000734-DontLinkElementID_38"></a>. The function of the peripheral device nub is to determine what type of logical unit driver a particular device needs. When a device is discovered on the bus, the peripheral device nub queries it and publishes its device type in the I/O Registry so the appropriate logical unit driver can be loaded for it. After the peripheral device nub has fulfilled its function in the building of the mass storage driver stack, it is not involved in the subsequent processing of I/O requests.</p><p>The SCSI protocol sublayer<a name="//apple_ref/doc/uid/TP30000734-DontLinkElementID_39"></a><a name="//apple_ref/doc/uid/TP30000734-DontLinkElementID_40"></a> contains physical interconnect protocol–specific information. The protocol services drivers<a name="//apple_ref/doc/uid/TP30000734-DontLinkElementID_41"></a>, <code>IOUSBMassStorageClass</code>, <code>IOATAPIProtocolTransport</code><a name="//apple_ref/doc/uid/TP30000734-DontLinkElementID_42"></a>, and <code>IOFireWireSerialBusProtocolTransport</code>, are responsible for translating the <code>SCSITask</code> object received from the SCSI application sublayer into a bus-specific format. For example, a hard drive plugged into a FireWire SBP-2 bus understands the CDB inside the <code>SCSITask</code> object but the FireWire SBP-2 bus does not. In order to process the <code>SCSITask</code> object, the <code>IOFireWireSerialBusProtocolTransport</code> driver removes the CDB and other elements from the <code>SCSITask</code> object and repackages them in an operation request block (or ORB) that is understood by the FireWire SBP-2 bus.<a name="//apple_ref/doc/uid/TP30000734-DontLinkElementID_43"></a></p><a name="//apple_ref/doc/uid/TP30000734-BBCIIHJJ" title="The Device Services Layer"></a><h3>The Device Services Layer</h3><p>The device services layer<a name="//apple_ref/doc/uid/TP30000734-DontLinkElementID_44"></a> of the mass storage driver stack provides high-level support for random-access mass storage devices. The Storage family supports the device services layer and is responsible for sending generic I/O requests through the interface provided by the device services nub. The device services layer (shown in <span class="content_text"><a href="MS_Overview.html#//apple_ref/doc/uid/TP30000734-BBCJFICD">Figure 1-3</a></span>) consists of the block storage driver layer and an arbitrary number of media filter layers.</p><br/><div><a name="//apple_ref/doc/uid/TP30000734-BBCJFICD" title="Figure 1-3The device services layer"></a><p><strong>Figure 1-3&nbsp;&nbsp;</strong>The device services layer</p><a name="//apple_ref/doc/uid/TP30000734-DontLinkElementID_45"></a><img src = "../art/deviceserviceslayer.gif" alt = "The device services layer" width="236" height="401"></div><br/><p>At the top of the device services layer are the optional media filter<a name="//apple_ref/doc/uid/TP30000734-DontLinkElementID_46"></a><a name="//apple_ref/doc/uid/TP30000734-DontLinkElementID_47"></a> layers<a name="//apple_ref/doc/uid/TP30000734-DontLinkElementID_48"></a>. Each media filter layer comprises a filter-scheme driver and the media object it publishes. A filter-scheme driver<a name="//apple_ref/doc/uid/TP30000734-DontLinkElementID_49"></a> is both a provider and a client of media objects: It receives abstract mass storage I/O requests from its client, performs the required data or offset manipulation, and passes on the modified request to its provider.</p><p>There are four basic kinds of media filter schemes<a name="//apple_ref/doc/uid/TP30000734-DontLinkElementID_50"></a>:</p><ul class="spaceabove"><li class="li"><p>One-to-one—A block-level encryption<a name="//apple_ref/doc/uid/TP30000734-DontLinkElementID_51"></a> or compression<a name="//apple_ref/doc/uid/TP30000734-DontLinkElementID_52"></a> scheme, for example, matches against one media object and produces one media object that represents the unencrypted or uncompressed content.</p></li><li class="li"><p>One-to-many—A partition scheme, for example, matches against one media object and produces multiple media objects each representing the content of one partition.</p></li><li class="li"><p>Many-to-one—A RAID scheme<a name="//apple_ref/doc/uid/TP30000734-DontLinkElementID_53"></a>, for example, matches against multiple media objects and produces a single media object that represents the aggregate content.</p></li><li class="li"><p>Many-to-many—A media filter driver matches against multiple media objects and produces multiple media objects.</p></li></ul><p>The block storage layer<a name="//apple_ref/doc/uid/TP30000734-DontLinkElementID_54"></a> consists of the generic block storage driver<a name="//apple_ref/doc/uid/TP30000734-DontLinkElementID_55"></a><a name="//apple_ref/doc/uid/TP30000734-DontLinkElementID_56"></a> and the media object it publishes. When the generic block storage driver appropriate to the device type loads, it publishes a media object representing the device in the I/O Registry. In addition to representing the device, the media object presents an interface to the device with APIs implemented by the generic block storage driver. These APIs include <code>open</code>, <code>close</code>, <code>read</code>, and <code>write</code> functions that are appropriate to the device. The media object also has properties that reflect the properties of the device type it represents, such as natural block size and writability.</p><p>Between the device services layer and the transport driver layer proper, is the device services nub. This nub supplies the interface between the generic block storage driver in the device services layer and the device-specific logical unit driver<a name="//apple_ref/doc/uid/TP30000734-DontLinkElementID_57"></a> in the transport driver layer.</p><p>When a logical unit driver loads for a mass storage device, it publishes the corresponding device services nub<a name="//apple_ref/doc/uid/TP30000734-DontLinkElementID_58"></a> in the I/O Registry. The appropriate generic block storage driver matches on the device type published in the device services nub and loads. It then communicates all mass storage I/O requests across the interface the device services nub provides. This frees the generic block storage driver from all knowledge of the specific commands and mechanisms the transport driver layer objects employ to communicate with the device or bus.<a name="//apple_ref/doc/uid/TP30000734-DontLinkElementID_59"></a></p><a name="//apple_ref/doc/uid/TP30000734-TPXREF102" title=" Mass Storage Stack Implementation"></a><h2> Mass Storage Stack Implementation</h2><p>The section <span class="content_text"><a href="MS_Overview.html#//apple_ref/doc/uid/TP30000734-BJGCIFBA">“The Mass Storage Driver Stack”</a></span> describes the mass storage stack in architectural terms with only superficial regard to its implementation. This section describes the object-oriented implementation of the objects in the stack and the I/O Kit families that support the device services layer and the transport driver layer.</p><a name="//apple_ref/doc/uid/TP30000734-BJGJFDHD" title="Mass Storage Driver Objects"></a><h3>Mass Storage Driver Objects</h3><p>The mass storage driver stack comprises I/O Kit objects that inherit from I/O Kit families. The I/O Kit defines a family as one or more C++ classes that implement software abstractions common to all devices of a particular type. A driver becomes a member of a family through inheritance: A driver’s class is almost always a subclass of some class in a family. Being a member of a family means that a driver inherits the instance variables (data structures) and behaviors that are common to all members of the family.</p><p>When a device is discovered on the bus, the I/O Kit finds and loads an appropriate driver for it, using a subtractive matching process (for more information on this process, see <span class="content_text"><a href="../04_Matching/MS_Matching.html#//apple_ref/doc/uid/TP30000736-BBIDJJGD">“Driver Personalities and the Matching Process”</a></span>). Loading the driver causes the driver’s family and all other objects the driver depends on to be loaded as well. The loading of the generic block storage driver, for example, causes the loading of the Storage family and all dependent classes, such as IOMedia.</p><p><a name="//apple_ref/doc/uid/TP30000734-DontLinkElementID_60"></a>The I/O Kit’s object-oriented approach to driver development provides a way to separate common functionality from specific functionality and achieve modular and reusable code. For example, if your device is a FireWire SBP-2 hard drive that complies with the SCSI Architecture Model specifications for block storage devices, the Apple logical unit driver <code>IOSCSIPeripheralDeviceType00</code> is sufficient to drive it. If, however, your hard drive implements its <code>read</code> command differently than the specification, you can simply subclass the <code>IOSCSIPeripheralDeviceType00</code> driver to create a new driver whose only function is to override the <code>read</code> command implementation.</p><p>Then, by placing properties that uniquely describe your device into your driver’s personality, your driver gets loaded when your device is discovered on the bus. Your driver then implements the <code>read</code> command, relying on the <code>IOSCSIPeripheralDeviceType00</code> driver to implement the remaining commands common to block storage devices. Similarly, the <code>IOSCSIPeripheralDeviceType00</code> logical unit driver relies on the SCSI Architecture Model family to implement functionality needed by all device drivers such as power management and work loops.</p><p>If you’re developing a filter-scheme driver that implements an encryption or validation scheme, the process is similar except that you do not subclass an existing filter-scheme driver. Instead, you subclass<a name="//apple_ref/doc/uid/TP30000734-DontLinkElementID_61"></a> <code>IOStorage</code> and implement the appropriate methods to create a new filter scheme. Then, your disk utility program <a name="//apple_ref/doc/uid/TP30000734-DontLinkElementID_62"></a>places a string that uniquely identifies your content into a partition. In your driver’s personality, you place the same string and when the I/O Kit initiates matching on the new media objects the partition scheme publishes, your driver matches and loads.</p><p><span class="content_text"><a href="MS_Overview.html#//apple_ref/doc/uid/TP30000734-BJGFJIJA">“Construction of a Mass Storage Driver Stack”</a></span> describes the building of an example mass storage driver stack and how a subclassed logical unit driver and a new filter-scheme driver fit in.<a name="//apple_ref/doc/uid/TP30000734-DontLinkElementID_63"></a></p><a name="//apple_ref/doc/uid/TP30000734-BJGFJFFH" title="The SCSI Architecture Model Family"></a><h3>The SCSI Architecture Model Family</h3><p><a name="//apple_ref/doc/uid/TP30000734-DontLinkElementID_64"></a>The SCSI Architecture Model family supports the transport driver layer of the mass storage driver stack. <span class="content_text"><a href="MS_Overview.html#//apple_ref/doc/uid/TP30000734-BGCJBJEI">Figure 1-4</a></span> illustrates the scope of the SCSI Architecture Model family by listing most of its leaf classes in a hierarchical inheritance chart.</p><br/><div><a name="//apple_ref/doc/uid/TP30000734-BGCJBJEI" title="Figure 1-4SCSI Architecture Model family inheritance"></a><p><strong>Figure 1-4&nbsp;&nbsp;</strong>SCSI Architecture Model family inheritance</p><img src = "../art/scsiarch.gif" alt = "SCSI Architecture Model family inheritance" width="469" height="511"></div><br/><p>At the top of the chart, inheriting from <code>SCSIPrimaryCommands</code><a name="//apple_ref/doc/uid/TP30000734-DontLinkElementID_65"></a>, are the three command set builder classes, <code>SCSIBlockCommands</code><a name="//apple_ref/doc/uid/TP30000734-DontLinkElementID_66"></a>, <code>SCSIMultimediaCommands</code><a name="//apple_ref/doc/uid/TP30000734-DontLinkElementID_67"></a>, and <code>SCSIReducedBlockCommands</code><a name="//apple_ref/doc/uid/TP30000734-DontLinkElementID_68"></a>. Each command set builder class corresponds to one of the shared command sets defined by the SCSI Architecture Model specifications: SCSI block commands, SCSI multimedia commands, and SCSI reduced block commands.</p><p>Each command set builder<a name="//apple_ref/doc/uid/TP30000734-DontLinkElementID_69"></a> class implements every command listed in the corresponding shared command set specification. This allows the instantiated command set builder object to create a <code>SCSITask</code> object that is consistent with the shared command set specification the device is compliant with.</p><p>The base class for all logical unit drivers and protocol services drivers is <code>IOSCSIProtocolInterface</code><a name="//apple_ref/doc/uid/TP30000734-DontLinkElementID_70"></a>. This class provides the methods for sending, completing, and aborting commands.</p><p>Inheriting from <code>IOSCSIProtocolInterface</code> is the base class of the SCSI protocol sublayer, <code>IOSCSIProtocolServices</code><a name="//apple_ref/doc/uid/TP30000734-DontLinkElementID_71"></a>, and the peripheral device nub, <code>IOSCSIPeripheralDeviceNub</code><a name="//apple_ref/doc/uid/TP30000734-DontLinkElementID_72"></a>. The <code>IOSCSIProtocolServices</code> class provides the queueing model for sending commands across the physical interconnect. Some of the other methods the <code>IOSCSIProtocolServices</code> class provides are methods for accessing the <code>SCSITask</code> object and its attributes and methods that get information about the CDB inside the <code>SCSITask</code> object.</p><p>Although the protocol services drivers such as <code>IOFireWireSerialBusProtocolTransport</code> and <code>IOUSBMassStorageClass</code> inherit from the SCSI protocol sublayer base class, they are not considered to be part of the SCSI Architecture Model family and therefore do not appear in <span class="content_text"><a href="MS_Overview.html#//apple_ref/doc/uid/TP30000734-BGCJBJEI">Figure 1-4</a></span>. Instead, they are considered to be members of specific protocol families such as the FireWire family or the USB family.</p><p>Also inheriting from <code>IOSCSIProtocolInterface</code> is <code>IOSCSIPrimaryCommandsDevice</code><a name="//apple_ref/doc/uid/TP30000734-DontLinkElementID_73"></a>, the base class of the SCSI application sublayer. Some of the methods this class provides are methods to get, manipulate, and release <code>SCSITask</code> objects and methods to get and release objects instantiated from the command set builder classes.</p><p>The three subclasses of <code>IOSCSIPrimaryCommandsDevice</code>, <code>IOSCSIMultimediaCommandsDevice</code><a name="//apple_ref/doc/uid/TP30000734-DontLinkElementID_74"></a>, <code>IOSCSIBlockCommandsDevice</code><a name="//apple_ref/doc/uid/TP30000734-DontLinkElementID_75"></a>, and <code>IOSCSIReducedBlockCommandsDevice</code><a name="//apple_ref/doc/uid/TP30000734-DontLinkElementID_76"></a>, correspond to three of the shared command sets defined in the SCSI Architecture Model specifications. The in-kernel logical unit drivers are subclasses of these three classes.</p><p>Although the device services nubs, <code>IOBlockStorageServices</code><a name="//apple_ref/doc/uid/TP30000734-DontLinkElementID_77"></a>, <code>IOReducedBlockServices</code><a name="//apple_ref/doc/uid/TP30000734-DontLinkElementID_78"></a>, <code>IOCompactDiscServices</code><a name="//apple_ref/doc/uid/TP30000734-DontLinkElementID_79"></a>, and <code>IODVDServices</code><a name="//apple_ref/doc/uid/TP30000734-DontLinkElementID_80"></a>, inherit from base classes in the Storage family, they are considered to be members of the SCSI Architecture Model family. These nubs export APIs from the device services layer to the transport driver layer. Each nub exports the API that corresponds to the device’s type. For example, the <code>IOCompactDiscServices</code> nub exports special methods for reading a disc’s table of contents, getting and setting the audio volume, and getting and setting disc speed.</p><p>Inheriting from <code>IOUserClient</code><a name="//apple_ref/doc/uid/TP30000734-DontLinkElementID_81"></a>, the <code>SCSITaskUserClient</code><a name="//apple_ref/doc/uid/TP30000734-DontLinkElementID_82"></a> class provides application-based drivers with access to devices that can be supported by SCSI Architecture Model drivers. The <code>SCSITaskUserClient</code> class provides device interfaces for device access (described in <span class="content_text"><a href="MS_Overview.html#//apple_ref/doc/uid/TP30000734-BGCIICHH">“SCSI Architecture Model Family Device Interfaces”</a></span>) and should not itself be subclassed.</p><p>The <code>SCSITask</code> class, which inherits from <code>IOCommand</code><a name="//apple_ref/doc/uid/TP30000734-DontLinkElementID_83"></a>, provides methods to get and set the values of the <code>SCSITask</code> object’s attributes and populate the CDB, among many others. The <code>SCSITask</code> class should not be subclassed.</p><a name="//apple_ref/doc/uid/TP30000734-BGCDHGIJ" title="The SCSITask Object"></a><h4>The SCSITask Object</h4><p>The SCSI Architecture Model family provides the logical unit and protocol services drivers access to CDBs<a name="//apple_ref/doc/uid/TP30000734-DontLinkElementID_84"></a> through the <code>SCSITask</code><a name="//apple_ref/doc/uid/TP30000734-DontLinkElementID_85"></a> object<a name="//apple_ref/doc/uid/TP30000734-DontLinkElementID_86"></a>. The <code>SCSITask</code> object is based on the SCSI command model, described in section 5 of the SCSI Architecture Model specification. The SCSI command model defines the format of the CDB and several status indicators relating to the execution of a SCSI command. The <code>SCSITask</code> object encapsulates these elements, giving you access to extensive information about the status of the command in addition to access to the CDB itself.</p><p>Status attributes of the <code>SCSITask</code> object include the following:</p><ul class="spaceabove"><li class="li"><p>Task attribute—defines how this task should be managed when determining order for queueing and submission to the appropriate device server.</p></li><li class="li"><p>Task state—represents the current state of the task such as new, enabled, or blocked.</p></li><li class="li"><p>Task status—represents the completion status of the task.</p></li></ul><p>The <code>SCSITask</code> object also includes information such as the service response from the transport driver, the data transfer direction, and memory buffers. The header file defining the <code>SCSITask</code> object and its accessor methods is in <code>/System/Library/Frameworks/IOKit.framework/Headers/scsi-commands/SCSITask.h</code>.</p><a name="//apple_ref/doc/uid/TP30000734-BGCIICHH" title="SCSI Architecture Model Family Device Interfaces"></a><h4>SCSI Architecture Model Family Device Interfaces</h4><p>The SCSI Architecture Model family provides a device interface<a name="//apple_ref/doc/uid/TP30000734-DontLinkElementID_87"></a><a name="//apple_ref/doc/uid/TP30000734-DontLinkElementID_88"></a> mechanism that allows applications to send commands to mass storage devices that are controlled by SCSI Architecture Model family drivers. For more detailed information on how to use this device interface mechanism, see <em><a href="../../WorkingWithSAM/index.html#//apple_ref/doc/uid/TP40000971" target="_top">SCSI Architecture Model Device Interface Guide</a></em>.</p><p>There are two access modes available to applications: Exclusive and nonexclusive. Exclusive access consists of an application acting as the logical unit driver for a device. For example, if a tape drive is discovered on the FireWire bus, the peripheral device nub (described in <span class="content_text"><a href="MS_Overview.html#//apple_ref/doc/uid/TP30000734-BJGEJCJJ">“The Transport Driver Layer”</a></span>) publishes device type $01 in the I/O Registry. There are no in-kernel logical unit drivers for that peripheral device type so the matching and loading process comes to a halt.</p><p>When an application-based driver for peripheral device type $01 launches, however, it finds the nub representing the tape drive in the I/O Registry and instantiates a <code>SCSITaskDeviceInterface</code> object. This gives the application unrestricted access to the device—in short, the application becomes the logical unit driver.</p><p>Nonexclusive access is available for authoring applications. If a CD or DVD drive is discovered, the I/O Kit finds and loads the in-kernel logical unit driver for peripheral device type $05 and the rest of the stack is built as usual. As long as no other client currently holds exclusive access to the device, an authoring application can gain nonexclusive access to the device by instantiating an <code>MMCDeviceInterface</code> object. It can then use device interface APIs to get information such as the amount of free space on the device.</p><p>If the authoring application later requires exclusive access to the device, for example, to burn a CD or DVD, it first reserves the media in the drive. Then it instantiates a <code>SCSITaskDeviceInterface</code> object and requests exclusive access. At this point, the in-kernel logical unit driver yields control to the application and the device services layer of the mass storage stack is torn down. The application then serves as the logical unit driver until it is closed, at which point the in-kernel logical unit driver regains control and the rest of the stack is rebuilt.</p><p>When an application has exclusive access to a device, it uses objects provided by a third device interface, the <code>SCSITaskInterface</code>, to manipulate the in-kernel <code>SCSITask</code> objects. Each <code>SCSITaskInterface</code> object corresponds to exactly one <code>SCSITask</code> object, allowing the application the same access to commands enjoyed by in-kernel logical unit drivers.<a name="//apple_ref/doc/uid/TP30000734-DontLinkElementID_89"></a></p><a name="//apple_ref/doc/uid/TP30000734-BBCJIEGH" title="The Storage Family"></a><h3>The Storage Family</h3><p><a name="//apple_ref/doc/uid/TP30000734-DontLinkElementID_90"></a>The Storage family supports the device services layer of the mass storage driver stack. <span class="content_text"><a href="MS_Overview.html#//apple_ref/doc/uid/TP30000734-BBCEDECE">Figure 1-5</a></span> shows the Storage family in a hierarchical inheritance chart.</p><br/><div><a name="//apple_ref/doc/uid/TP30000734-BBCEDECE" title="Figure 1-5Storage family inheritance"></a><p><strong>Figure 1-5&nbsp;&nbsp;</strong>Storage family inheritance</p><a name="//apple_ref/doc/uid/TP30000734-DontLinkElementID_91"></a><img src = "../art/storage.gif" alt = "Storage family inheritance" width="460" height="245"></div><br/><p>At the top of the chart is the abstract class <code>IOBlockStorageDevice</code><a name="//apple_ref/doc/uid/TP30000734-DontLinkElementID_92"></a>. This class declares the interface to the underlying mechanisms of the transport driver layer that transport data to and from the represented storage space. Mass storage I/O requests pass through this interface without any involvement in the actual commands the transport driver layer objects use to communicate with the device. A transport family or driver subclasses <code>IOBlockStorageDevice</code>, implements the interface APIs, and instantiates a device services nub object. The generic block storage driver then drives this object, unconcerned with the device-specific and bus-specific objects below it.</p><p>The SCSI Architecture Model family declares two subclasses of <code>IOBlockStorageDevice</code>, the device services nubs <code>IOBlockStorageServices</code><a name="//apple_ref/doc/uid/TP30000734-DontLinkElementID_93"></a> and <code>IOReducedBlockServices</code><a name="//apple_ref/doc/uid/TP30000734-DontLinkElementID_94"></a>. These device services nubs relay generic requests from the <a name="//apple_ref/doc/uid/TP30000734-DontLinkElementID_95"></a>generic block storage driver to the device-specific logical unit driver in the transport driver layer (for more information on this family, see <span class="content_text"><a href="MS_Overview.html#//apple_ref/doc/uid/TP30000734-BJGFJFFH">“The SCSI Architecture Model Family”</a></span>). </p><p>There are other families and drivers that subclass <code>IOBlockStorageDevice</code> to create nubs that provide the interface between device-specific transport drivers and the generic block storage driver. These include the ATA transport layer (<code>IOATABlockStorage</code>), the USB UFI transport layer, and the Disk Images transport layer.</p><p>The Storage family declares two subclasses of <code>IOBlockStorageDevice</code>: <code>IOCDBlockStorageDevice</code><a name="//apple_ref/doc/uid/TP30000734-DontLinkElementID_96"></a> and <code>IODVDBlockStorageDevice</code><a name="//apple_ref/doc/uid/TP30000734-DontLinkElementID_97"></a>. These subclasses provide the protocol for generic CD and DVD functionality, independent of the underlying physical interconnect protocol. The SCSI Architecture Model family subclasses <code>IOCDBlockStorageDevice</code> for the device services nub <code>IOCompactDiscServices</code><a name="//apple_ref/doc/uid/TP30000734-DontLinkElementID_98"></a> and subclasses <code>IODVDBlockStorageDevice</code> for the device services nub <code>IODVDServices</code><a name="//apple_ref/doc/uid/TP30000734-DontLinkElementID_99"></a>.</p><p>The <code>IOStorage</code><a name="//apple_ref/doc/uid/TP30000734-DontLinkElementID_100"></a> class is the common base class for both driver and media objects. It is an abstract class that declares the basic <code>open</code>, <code>close</code>, <code>read</code>, and <code>write</code> interfaces that its subclasses implement. The <code>read</code> and <code>write</code> interfaces provide byte-level access to the storage space. The <code>IOStorage</code> class also establishes the protocol media objects use to communicate with driver objects without needing media objects to be subclassed for each driver.</p><p>The <code>IOMedia</code><a name="//apple_ref/doc/uid/TP30000734-DontLinkElementID_101"></a> subclass of <code>IOStorage</code> is a random-access disk device abstraction. It provides a consistent interface for both real and virtual disk devices, for subdivisions of disks, such as partitions, and for supersets of disks, such as RAID volumes. The <code>IOMedia</code> class implements the appropriate <code>open</code>, <code>close</code>, <code>read</code>, <code>write</code>, and matching semantics for media objects. It has properties that reflect the properties of actual media, such as its total size in bytes and whether it is ejectable.</p><p>The subclasses of <code>IOMedia</code> provide properties, methods, and advanced interfaces that are specific to CD and DVD media objects. The <code>IOCDMedia</code><a name="//apple_ref/doc/uid/TP30000734-DontLinkElementID_102"></a> subclass includes properties such as the type of CD media object and its table of contents, and implements methods that read special areas of the CD. The <code>IODVDMedia</code><a name="//apple_ref/doc/uid/TP30000734-DontLinkElementID_103"></a> subclass includes properties that describe the type of DVD media object, such as DVD-ROM or DVD-R/W, and implements additional methods specific to DVDs. </p><p>The <code>IOMediaBSDClient</code><a name="//apple_ref/doc/uid/TP30000734-DontLinkElementID_104"></a> class publishes a BSD interface for all media objects. The <code>IOMediaBSDClient</code> driver represents <code>IOMedia</code> objects as device files in the Mac OS X BSD execution environment. You can access these device files using BSD APIs such as <code>open</code>, <code>close</code>, <code>read</code>, <code>write</code>, and <code>ioctl</code><a name="//apple_ref/doc/uid/TP30000734-DontLinkElementID_105"></a>. The <code>ioctl</code> system call provides methods to determine various media properties and control various aspects of the media. The subclasses of <code>IOMediaBSDClient</code>, <code>IOCDMediaBSDClient</code><a name="//apple_ref/doc/uid/TP30000734-DontLinkElementID_106"></a> and <code>IODVDMediaBSDClient</code><a name="//apple_ref/doc/uid/TP30000734-DontLinkElementID_107"></a>, extend <code>ioctl</code> behavior to include CD-specific and DVD-specific functionality.</p><p>Partition-scheme drivers<a name="//apple_ref/doc/uid/TP30000734-DontLinkElementID_108"></a><a name="//apple_ref/doc/uid/TP30000734-DontLinkElementID_109"></a> inherit from <code>IOPartitionScheme</code><a name="//apple_ref/doc/uid/TP30000734-DontLinkElementID_110"></a>, an abstract subclass of <code>IOStorage</code>. Apple provides the following partition schemes:</p><ul class="spaceabove"><li class="li"><p><code>IOApplePartitionScheme</code><a name="//apple_ref/doc/uid/TP30000734-DontLinkElementID_111"></a>, the standard Apple partition-scheme driver</p></li><li class="li"><p><code>IOFDiskPartitionScheme</code><a name="//apple_ref/doc/uid/TP30000734-DontLinkElementID_112"></a>, the standard PC partition-scheme driver</p></li><li class="li"><p><code>IONeXTPartitionScheme</code><a name="//apple_ref/doc/uid/TP30000734-DontLinkElementID_113"></a>, the NeXT partition-scheme driver</p></li><li class="li"><p><code>IOCDPartitionScheme</code><a name="//apple_ref/doc/uid/TP30000734-DontLinkElementID_114"></a>, the partition-scheme driver for CD tracks that require treatment as partitions</p></li></ul><p>The <code>IOPartitionScheme</code> class provides a basic framework for a partition-scheme driver that implements the appropriate <code>open</code> and <code>close</code> semantics for partition objects, and the default <code>read</code> and <code>write</code> interfaces. Although the <code>open</code>, <code>close</code>, <code>read</code>, and <code>write</code> implementations <code>IOPartitionScheme</code> provides are sufficient for simple partition schemes, more complicated schemes may need to perform more processing.</p><p>The <code>IOBlockStorageDriver</code><a name="//apple_ref/doc/uid/TP30000734-DontLinkElementID_115"></a> subclass of <code>IOStorage</code> is the common base class for generic block storage drivers. It extends the <code>IOStorage</code> protocol by implementing methods such as deblocking for unaligned transfers, polling for ejectable media, and statistics gathering and reporting. Because the <code>IOBlockStorageDriver</code> functions independently of the underlying device and bus transport protocols, you should not subclass it to handle device idiosyncrasies. A new type of generic device, however, might require the subclassing of the <code>IOBlockStorageDriver</code>.</p><p>The <code>IOCDBlockStorageDriver</code><a name="//apple_ref/doc/uid/TP30000734-DontLinkElementID_116"></a> subclass of <code>IOBlockStorageDriver</code> implements methods that support CD drives, such as getting information related to the table of contents and reading special areas of the disc. The <code>IODVDBlockStorageDriver</code><a name="//apple_ref/doc/uid/TP30000734-DontLinkElementID_117"></a> subclass of <code>IOCDBlockStorageDriver</code> implements methods that support DVD drives such as getting information related to the encryption and key for the drive<a name="//apple_ref/doc/uid/TP30000734-DontLinkElementID_118"></a>.</p><a name="//apple_ref/doc/uid/TP30000734-TPXREF103" title="Filter Schemes"></a><h4>Filter Schemes</h4><p>A mentioned in <span class="content_text"><a href="MS_Overview.html#//apple_ref/doc/uid/TP30000734-BBCIIHJJ">“The Device Services Layer,”</a></span> a filter scheme driver is both the client of an <code>IOMedia</code> object and the provider of <code>IOMedia</code> objects. If you’re interested in developing a filter-scheme driver<a name="//apple_ref/doc/uid/TP30000734-DontLinkElementID_119"></a> you might assume that you need to subclass<a name="//apple_ref/doc/uid/TP30000734-DontLinkElementID_120"></a> an existing partition scheme. This is unnecessary, however, because you can access your content within an existing partition. A partition-scheme driver, such as <code>IOApplePartitionScheme</code>, publishes a distinct <code>IOMedia</code> object for each partition’s contents. If you’ve placed your content within a partition, your filter-scheme driver can match on your unique identifier, contained in the content hint property of the <code>IOMedia</code> object representing that partition (see <span class="content_text"><a href="MS_Overview.html#//apple_ref/doc/uid/TP30000734-BBCDJHCD">Figure 1-9</a></span> for an example of how this might look). As a subclass of <code>IOStorage</code>, therefore, your filter-scheme driver can match directly on your content within a partition and avoid the I/O overhead and potential stale data issues associated with actively probing the media for your signature.</p><p>It's important to realize that a filter-scheme driver should never produce an <code>IOCDMedia</code> or <code>IODVDMedia</code> object, because these objects have provider requirements a filter-scheme driver would be unable to meet. For example, an <code>IODVDMedia</code> object has requirements specific to DVD media that only an <code>IODVDBlockStorageDriver</code> (or subclass) can meet. An <code>IOMedia</code> object, on the other hand, has more generic requirements that an <code>IOStorage</code> subclass (such as a custom filter-scheme driver) can meet. See <span class="content_text"><a href="../08_Media_Example/MS_Media_Example.html#//apple_ref/doc/uid/TP30000739-TPXREF101">“Developing a Filter Scheme”</a></span> for information on how to implement a filter-scheme driver.</p><a name="//apple_ref/doc/uid/TP30000734-TPXREF104" title="Accessing IOMedia Objects From Applications"></a><h4>Accessing IOMedia Objects From Applications</h4><p>The Storage family provides a device interface<a name="//apple_ref/doc/uid/TP30000734-DontLinkElementID_121"></a><a name="//apple_ref/doc/uid/TP30000734-DontLinkElementID_122"></a> to access <code>IOMedia</code><a name="//apple_ref/doc/uid/TP30000734-DontLinkElementID_123"></a> objects from applications using the BSD device interface. Each <code>IOMedia</code> object<a name="//apple_ref/doc/uid/TP30000734-DontLinkElementID_124"></a> has a BSD client driver that produces a device node (in the form of <code>/dev/disk</code>) in the Mac OS X BSD execution environment. Applications can use the <code>read</code> and <code>write</code> system calls to access the data represented by an <code>IOMedia</code> object and <code>ioctl</code><a name="//apple_ref/doc/uid/TP30000734-DontLinkElementID_125"></a> system calls to manipulate the special characteristics of devices.</p><p>Applications can use standard I/O Kit search and notification APIs to find specific <code>IOMedia</code> objects. An application searching for a CD, for example, can create a matching dictionary for the subclass <code>IOCDMedia</code> and, using properties the <code>IOMedia</code> object publishes, narrow the search to ejectable media only. An example of this process is in <em><a href="../../WorkingWStorage/index.html#//apple_ref/doc/uid/TP40000968" target="_top">Device File Access Guide for Storage Devices</a></em>.<a name="//apple_ref/doc/uid/TP30000734-DontLinkElementID_126"></a></p><a name="//apple_ref/doc/uid/TP30000734-BJGFJIJA" title="Construction of a Mass Storage Driver Stack"></a><h2>Construction of a Mass Storage Driver Stack</h2><p>This section<a name="//apple_ref/doc/uid/TP30000734-DontLinkElementID_127"></a> describes how the mass storage driver stack is built up from the discovery of a specific device. Then, it shows how a subclassed logical unit driver and a new filter-scheme driver fit into the stack.</p><p>The illustrations in this section use a “puzzle piece” shape (shown in <span class="content_text"><a href="MS_Overview.html#//apple_ref/doc/uid/TP30000734-BGCCJAHE">Figure 1-6</a></span>) to show the inheritance chain of each subclassed driver.</p><br/><div><a name="//apple_ref/doc/uid/TP30000734-BGCCJAHE" title="Figure 1-6Subclasses inheriting from a base class"></a><p><strong>Figure 1-6&nbsp;&nbsp;</strong>Subclasses inheriting from a base class</p><img src = "../art/inchain.gif" alt = "Subclasses inheriting from a base class" width="257" height="40"></div><br/><p>Inheritance runs from right to left: Each subclass locks onto its ancestor on its right edge and provides a projection for another (potential) subclass on its left edge.</p><p>The device in this example is a FireWire SBP-2 hard drive. <span class="content_text"><a href="MS_Overview.html#//apple_ref/doc/uid/TP30000734-BGCIHFAH">Figure 1-7</a></span> shows the stack layers built up above the hard drive, with inheritance chains shown for the logical unit driver and the protocol services driver.</p><br/><div><a name="//apple_ref/doc/uid/TP30000734-BGCIHFAH" title="Figure 1-7An example mass storage stack"></a><p><strong>Figure 1-7&nbsp;&nbsp;</strong>An example mass storage stack</p><img src = "../art/exmassstordrvstack.gif" alt = "An example mass storage stack" width="448" height="516"></div><br/><p>When you plug in the hard drive, the FireWire bus controller in the physical interconnect layer discovers it and instantiates an <code>IOFireWireDevice</code> object. The <code>IOFireWireDevice</code> object scans the device’s configuration ROM and produces an <code>IOFireWireUnit</code> object for each unit directory in the device. The I/O Kit performs matching on the <code>IOFireWireUnit</code> and, since the hard drive is a FireWire SBP-2 device, instantiates an <code>IOFireWireSBP2Target</code> object.</p><p>The <code>IOFireWireSBP2Target</code> object scans the device’s configuration ROM and produces an <code>IOFireWireSBP2LUN</code> object for each logical unit it finds. After performing matching on the <code>IOFireWireSBP2Target</code> object, the I/O Kit instantiates the <code>IOFireWireSerialBusProtocolTransport</code> driver object.</p><p>The instantiation of the protocol services driver causes the instantiation of the peripheral device nub, which sends an inquiry command to the device. The response to this inquiry describes the device’s type and the peripheral device nub publishes a nub containing the key “peripheral device type 00” in the I/O Registry.</p><p>The I/O Kit performs matching on this nub, ultimately finding and loading the <code>IOSCSIPeripheralDeviceType00</code> driver. When the <code>IOSCSIPeripheralDeviceType00</code> driver object instantiates, the corresponding device services nub, <code>IOBlockStorageServices</code>, instantiates and initiates the matching process for the block storage driver<a name="//apple_ref/doc/uid/TP30000734-DontLinkElementID_128"></a>.</p><p>When the matching block storage driver is found, it loads and publishes an <code>IOMedia</code> object that represents the whole device. The I/O Kit then finds and loads a partition-scheme driver that matches on the whole device. For Apple-formatted disks, this will probably be <code>IOApplePartitionScheme</code>. <code>IOApplePartitionScheme</code> then publishes an <code>IOMedia</code> object for each partition it finds.</p><p><a name="//apple_ref/doc/uid/TP30000734-DontLinkElementID_129"></a><a name="//apple_ref/doc/uid/TP30000734-DontLinkElementID_130"></a>Now, imagine you need to support a FireWire SBP-2 hard drive that implements the <code>read</code> command differently than as defined by the SCSI Architecture Model specifications. You subclass the <code>IOSCSIPeripheralDeviceType00</code> driver and override the <code>read</code> method. Because your driver should be loaded only for your device, you place matching information that uniquely identifies your device in your driver’s personality dictionary<a name="//apple_ref/doc/uid/TP30000734-DontLinkElementID_131"></a>.</p><p>When the I/O Kit discovers your device, it builds the mass storage driver stack as before until it searches for a logical unit driver. The I/O Kit matching process gives the driver with the most matching keys the first chance to drive a device. Since your driver matches on vendor, product, and perhaps even software revision values associated with your device, the I/O Kit favors your driver over the <code>IOSCSIPeripheralDeviceType00</code> driver which matches only on the peripheral device type. Your driver loads, along with the SCSI Architecture Model family and other dependencies. </p><p><span class="content_text"><a href="MS_Overview.html#//apple_ref/doc/uid/TP30000734-BGCHFABB">Figure 1-8</a></span> shows the mass storage stack after your logical unit driver (named “MyLogicalUnitDriver”) matches and loads.<a name="//apple_ref/doc/uid/TP30000734-DontLinkElementID_132"></a></p><br/><div><a name="//apple_ref/doc/uid/TP30000734-BGCHFABB" title="Figure 1-8Adding a subclassed logical unit driver"></a><p><strong>Figure 1-8&nbsp;&nbsp;</strong>Adding a subclassed logical unit driver</p><a name="//apple_ref/doc/uid/TP30000734-DontLinkElementID_133"></a><img src = "../art/ex02massstordrvstack.gif" alt = "Adding a subclassed logical unit driver" width="501" height="501"></div><br/><p><a name="//apple_ref/doc/uid/TP30000734-DontLinkElementID_134"></a><a name="//apple_ref/doc/uid/TP30000734-DontLinkElementID_135"></a><a name="//apple_ref/doc/uid/TP30000734-DontLinkElementID_136"></a>Now suppose you want to implement an encryption scheme that works over any transport. This new encryption-scheme driver would match on an <code>IOMedia</code> object and produce another <code>IOMedia</code> object. To create the driver, you subclass <code>IOStorage</code> and implement the encryption and decryption behavior in the driver’s <code>read</code> and <code>write</code> methods. Because your filter-scheme driver should be loaded only for a partition containing your content, you place a content-hint string, of the form <em>MyCompany_MyContent</em>, in your driver’s personality.</p><p>Then, you make a disk utility program available so a user can format the disk to contain your encryption scheme. When the disk utility program<a name="//apple_ref/doc/uid/TP30000734-DontLinkElementID_137"></a> reformats the disk, it also places your content-hint string in one of the partitions.</p><p>When the disk utility program completes its task, the partition-scheme driver publishes an <code>IOMedia</code> object for each partition. This causes an update to the I/O Registry. The I/O Kit then searches for a filter-scheme driver to match on the content-hint property in the new <code>IOMedia</code> object and it finds just one—your encryption-scheme driver.</p><p>Because your driver matches on the same content-hint<a name="//apple_ref/doc/uid/TP30000734-DontLinkElementID_138"></a> string your disk utility program placed in the partition, there is no doubt that this is your content, so implementing the <code>probe</code> method is optional. If you don’t implement the <code>probe</code> method, by default it returns <code>true</code>.</p><p>When your encryption-scheme driver loads, it publishes an <code>IOMedia</code> object representing the unencrypted content on the media. <span class="content_text"><a href="MS_Overview.html#//apple_ref/doc/uid/TP30000734-BBCDJHCD">Figure 1-9</a></span> shows the mass storage driver stack after your driver, called “MyEncryptionScheme,“ loads.</p><br/><div><a name="//apple_ref/doc/uid/TP30000734-BBCDJHCD" title="Figure 1-9Adding an encryption scheme"></a><p><strong>Figure 1-9&nbsp;&nbsp;</strong>Adding an encryption scheme</p><a name="//apple_ref/doc/uid/TP30000734-DontLinkElementID_139"></a><a name="//apple_ref/doc/uid/TP30000734-DontLinkElementID_140"></a><a name="//apple_ref/doc/uid/TP30000734-DontLinkElementID_141"></a><img src = "../art/ex03massstordrvstack.gif" alt = "Adding an encryption scheme" width="371" height="559"></div><br/>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../01_Introduction/Introduction.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../03_Compliance/MS_Compliance.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2002, 2007 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2007-04-03<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/DeviceDrivers/Conceptual/MassStorage/02_Overview/MS_Overview.html%3Fid%3DTP40000974-4.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/DeviceDrivers/Conceptual/MassStorage/02_Overview/MS_Overview.html%3Fid%3DTP40000974-4.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/DeviceDrivers/Conceptual/MassStorage/02_Overview/MS_Overview.html%3Fid%3DTP40000974-4.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>