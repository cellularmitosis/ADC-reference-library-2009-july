<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>Audio Queue Services Programming Guide: Playing Audio</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Playing Audio"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP40005343-CH3" title="Playing Audio"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../index.html#//apple_ref/doc/uid/TP30000440-TP30000428" target="_top">Audio</a> &gt; <a href="../../../CoreAudio-date.html#//apple_ref/doc/uid/TP30000440-TP30000428-TP30000500" target="_top">Core Audio</a> &gt; <a href="../Introduction/Introduction.html#//apple_ref/doc/uid/TP40005343-CH1-SW1">Audio Queue Services Programming Guide</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../AQRecord/RecordingAudio.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../RevisionHistory.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP40005343-CH3-SW1" title="Playing Audio"></a><h1>Playing Audio</h1><p>When you play audio using Audio Queue Services, the source can be just about anything—an on-disk file, a software-based audio synthesizer, an object in memory, and so on. This chapter describes the most common scenario: playing back an on-disk file.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40005343-CH3-DontLinkElementID_28" title="Note"></a><p><strong>Note:</strong>&nbsp;The code examples in this document are sometimes simplified by using C++ classes from the Core Audio SDK. However, neither the SDK nor the C++ language is necessary to use Audio Queue Services.</p>For additional simplicity, these code examples do not include robust error handling. Make sure to add code to handle potential errors when you implement recording or playback with Audio Queue Services.</p></div><p>To add playback functionality to your application, you typically perform the following steps:</p><ol class="ol"><li class="li"><p>Define a custom structure to manage state, format, and path information.</p></li><li class="li"><p>Write an audio queue callback function to perform the actual playback. </p></li><li class="li"><p>Write code to determine a good size for the audio queue buffers.</p></li><li class="li"><p>Open an audio file for playback and determine its audio data format.</p></li><li class="li"><p>Create a playback audio queue and configure it for playback.</p></li><li class="li"><p>Allocate and enqueue audio queue buffers. Tell the audio queue to start playing. When done, the playback callback tells the audio queue to stop.</p></li><li class="li"><p>Dispose of the audio queue. Release resources.</p></li></ol><p>The remainder of this chapter describes each of these steps in detail.</p>
<!-- This template is being used for both PDF and HTML. -->

    
    <h4>In this section:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="PlayingAudio.html#//apple_ref/doc/uid/TP40005343-CH3-SW15">Define a Custom Structure to Manage State</a>
				
			<br/>
			
        
			
			
				<a href="PlayingAudio.html#//apple_ref/doc/uid/TP40005343-CH3-SW2">Write a Playback Audio Queue Callback</a>
				
			<br/>
			
        
			
			
				<a href="PlayingAudio.html#//apple_ref/doc/uid/TP40005343-CH3-SW23">Write a Function to Derive Playback Audio Queue Buffer Size</a>
				
			<br/>
			
        
			
			
				<a href="PlayingAudio.html#//apple_ref/doc/uid/TP40005343-CH3-DontLinkElementID_6">Open an Audio File for Playback</a>
				
			<br/>
			
        
			
			
				<a href="PlayingAudio.html#//apple_ref/doc/uid/TP40005343-CH3-SW5">Create a Playback Audio Queue</a>
				
			<br/>
			
        
			
			
				<a href="PlayingAudio.html#//apple_ref/doc/uid/TP40005343-CH3-SW9">Set Sizes for a Playback Audio Queue</a>
				
			<br/>
			
        
			
			
				<a href="PlayingAudio.html#//apple_ref/doc/uid/TP40005343-CH3-DontLinkElementID_9">Set a Magic Cookie for a Playback Audio Queue</a>
				
			<br/>
			
        
			
			
				<a href="PlayingAudio.html#//apple_ref/doc/uid/TP40005343-CH3-DontLinkElementID_10">Allocate and Prime Audio Queue Buffers</a>
				
			<br/>
			
        
			
			
				<a href="PlayingAudio.html#//apple_ref/doc/uid/TP40005343-CH3-DontLinkElementID_11">Set an Audio Queue’s Playback Gain</a>
				
			<br/>
			
        
			
			
				<a href="PlayingAudio.html#//apple_ref/doc/uid/TP40005343-CH3-DontLinkElementID_12">Start and Run an Audio Queue</a>
				
			<br/>
			
        
			
			
				<a href="PlayingAudio.html#//apple_ref/doc/uid/TP40005343-CH3-DontLinkElementID_13">Clean Up After Playing</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP40005343-CH3-SW15" title="Define a Custom Structure to Manage State"></a><h2>Define a Custom Structure to Manage State</h2><p>To start, define a custom structure that you’ll use to manage audio format and audio queue state information. <span class="content_text">Listing 3-1</span> illustrates such a structure:</p><a name="//apple_ref/doc/uid/TP40005343-CH3-SW14" title="Listing 3-1A custom structure for a playback audio queue"></a><p class="codesample"><strong>Listing 3-1&nbsp;&nbsp;</strong>A custom structure for a playback audio queue</p><div class="codesample"><table><tr><td scope="row"><pre>static const int kNumberBuffers = 3;                              // 1<span></span></pre></td></tr><tr><td scope="row"><pre>struct AQPlayerState {<span></span></pre></td></tr><tr><td scope="row"><pre>    AudioStreamBasicDescription   mDataFormat;                    // 2<span></span></pre></td></tr><tr><td scope="row"><pre>    AudioQueueRef                 mQueue;                         // 3<span></span></pre></td></tr><tr><td scope="row"><pre>    AudioQueueBufferRef           mBuffers[kNumberBuffers];       // 4<span></span></pre></td></tr><tr><td scope="row"><pre>    AudioFileID                   mAudioFile;                     // 5<span></span></pre></td></tr><tr><td scope="row"><pre>    UInt32                        bufferByteSize;                 // 6<span></span></pre></td></tr><tr><td scope="row"><pre>    SInt64                        mCurrentPacket;                 // 7<span></span></pre></td></tr><tr><td scope="row"><pre>    UInt32                        mNumPacketsToRead;              // 8<span></span></pre></td></tr><tr><td scope="row"><pre>    AudioStreamPacketDescription  *mPacketDescs;                  // 9<span></span></pre></td></tr><tr><td scope="row"><pre>    bool                          mIsRunning;                     // 10<span></span></pre></td></tr><tr><td scope="row"><pre>};<span></span></pre></td></tr></table></div>	<p>Most fields in this structure are identical (or nearly so) to those in the custom structure used for recording, as described in the <span class="content_text">“Recording Audio”</span> chapter in <span class="content_text"><a href="../AQRecord/RecordingAudio.html#//apple_ref/doc/uid/TP40005343-CH4-SW15">“Define a Custom Structure to Manage State.”</a></span> For example, the <code>mDataFormat</code> field is used here to hold the format of the file being played. When recording, the analogous field holds the format of the file being written to disk.</p><p>Here’s a description of the fields in this structure:</p><ol class="ol"><li class="li"><p>Sets the number of audio queue buffers to use. Three is typically a good number, as described in <span class="content_text"><a href="../AboutAudioQueues/AboutAudioQueues.html#//apple_ref/doc/uid/TP40005343-CH5-SW13">“Audio Queue Buffers.”</a></span></p></li><li class="li"><p>An <code>AudioStreamBasicDescription</code> structure (from <code>CoreAudioTypes.h</code>) representing the audio data format of the file being played. This format gets used by the audio queue specified in the <code>mQueue</code> field.</p><p>The <code>mDataFormat</code> field gets filled by querying an audio file's <code>kAudioFilePropertyDataFormat</code> property, as described in <span class="content_text"><a href="PlayingAudio.html#//apple_ref/doc/uid/TP40005343-CH3-SW25">“Obtaining a File’s Audio Data Format.”</a></span></p><p>For details on the <code>AudioStreamBasicDescription</code> structure, see <em><a href="../../../Reference/CoreAudioDataTypesRef/index.html#//apple_ref/doc/uid/TP40004488" target="_top">Core Audio Data Types Reference</a></em>.</p></li><li class="li"><p>The playback audio queue created by your application.</p></li><li class="li"><p>An array holding pointers to the audio queue buffers managed by the audio queue.</p></li><li class="li"><p>An audio file object that represents the audio file your program plays.</p></li><li class="li"><p>The size, in bytes, for each audio queue buffer. This value is calculated in these examples in the <code><!--a-->DeriveBufferSize<!--/a--></code> function, after the audio queue is created and before it is started. See <span class="content_text"><a href="PlayingAudio.html#//apple_ref/doc/uid/TP40005343-CH3-SW23">“Write a Function to Derive Playback Audio Queue Buffer Size.”</a></span></p></li><li class="li"><p>The packet index for the next packet to play from the audio file.</p></li><li class="li"><p>The number of packets to read on each invocation of the audio queue’s playback callback. Like the <code>bufferByteSize</code> field, this value is calculated in these examples in the <code><!--a-->DeriveBufferSize<!--/a--></code> function, after the audio queue is created and before it is started.</p></li><li class="li"><p>For VBR audio data, the array of packet descriptions for the file being played. For CBR data, the value of this field is <code>NULL</code>.</p></li><li class="li"><p>A Boolean value indicating whether or not the audio queue is running.</p></li></ol><a name="//apple_ref/doc/uid/TP40005343-CH3-SW2" title="Write a Playback Audio Queue Callback"></a><h2>Write a Playback Audio Queue Callback</h2><p>Next, write a playback audio queue callback function. This callback does three main things:</p><ul class="ul"><li class="li"><p>Reads a specified amount of data from an audio file and puts it into an audio queue buffer</p></li><li class="li"><p>Enqueues the audio queue buffer to the buffer queue</p></li><li class="li"><p>When there’s no more data to read from the audio file, tells the audio queue to stop</p></li></ul><p>This section shows an example callback declaration, describes each of these tasks separately, and finally presents an entire playback callback. For an illustration of the role of a playback callback, you can refer back to <span class="content_text"><a href="../AboutAudioQueues/AboutAudioQueues.html#//apple_ref/doc/uid/TP40005343-CH5-SW3">Figure 1-4</a></span>.</p><a name="//apple_ref/doc/uid/TP40005343-CH3-DontLinkElementID_1" title="The Playback Audio Queue Callback Declaration"></a><h3>The Playback Audio Queue Callback Declaration</h3><p><span class="content_text">Listing 3-2</span> shows an example declaration for a playback audio queue callback function, declared as <code><a href="../../../Reference/AudioQueueReference/Reference/reference.html#//apple_ref/doc/c_ref/AudioQueueOutputCallback" target="_top">AudioQueueOutputCallback</a></code> in the <code>AudioQueue.h</code> header file:</p><a name="//apple_ref/doc/uid/TP40005343-CH3-SW16" title="Listing 3-2The playback audio queue callback declaration"></a><p class="codesample"><strong>Listing 3-2&nbsp;&nbsp;</strong>The playback audio queue callback declaration</p><div class="codesample"><table><tr><td scope="row"><pre>static void HandleOutputBuffer (<span></span></pre></td></tr><tr><td scope="row"><pre>    void                 *aqData,                 // 1<span></span></pre></td></tr><tr><td scope="row"><pre>    AudioQueueRef        inAQ,                    // 2<span></span></pre></td></tr><tr><td scope="row"><pre>    AudioQueueBufferRef  inBuffer                 // 3<span></span></pre></td></tr><tr><td scope="row"><pre>)<span></span></pre></td></tr></table></div>	<p>Here’s how this code works:</p><ol class="ol"><li class="li"><p>Typically, <code>aqData</code> is the custom structure that contains state information for the audio queue, as described in <span class="content_text"><a href="PlayingAudio.html#//apple_ref/doc/uid/TP40005343-CH3-SW15">“Define a Custom Structure to Manage State.”</a></span></p></li><li class="li"><p>The audio queue that owns this callback.</p></li><li class="li"><p>An audio queue buffer that the callback is to fill with data by reading from an audio file.</p></li></ol><a name="//apple_ref/doc/uid/TP40005343-CH3-DontLinkElementID_2" title="Reading From a File into an Audio Queue Buffer"></a><h3>Reading From a File into an Audio Queue Buffer</h3><p>The first action of a playback audio queue callback is to read data from an audio file and place it in an audio queue buffer. <span class="content_text">Listing 3-3</span> shows how to do this.</p><a name="//apple_ref/doc/uid/TP40005343-CH3-SW11" title="Listing 3-3Reading from an audio fiie into an audio queue buffer"></a><p class="codesample"><strong>Listing 3-3&nbsp;&nbsp;</strong>Reading from an audio fiie into an audio queue buffer</p><div class="codesample"><table><tr><td scope="row"><pre>AudioFileReadPackets (                        // 1<span></span></pre></td></tr><tr><td scope="row"><pre>    pAqData->mAudioFile,                      // 2<span></span></pre></td></tr><tr><td scope="row"><pre>    false,                                    // 3<span></span></pre></td></tr><tr><td scope="row"><pre>    &amp;numBytesReadFromFile,                    // 4<span></span></pre></td></tr><tr><td scope="row"><pre>    pAqData->mPacketDescs,                    // 5<span></span></pre></td></tr><tr><td scope="row"><pre>    pAqData->mCurrentPacket,                  // 6<span></span></pre></td></tr><tr><td scope="row"><pre>    &amp;numPackets,                              // 7<span></span></pre></td></tr><tr><td scope="row"><pre>    inBuffer->mAudioData                      // 8<span></span></pre></td></tr><tr><td scope="row"><pre>);<span></span></pre></td></tr></table></div>	<p>Here’s how this code works:</p><ol class="ol"><li class="li"><p>The <code><a href="../../../Reference/AudioFileConvertRef/Reference/reference.html#//apple_ref/doc/c_ref/AudioFileReadPackets" target="_top">AudioFileReadPackets</a></code> function, declared in the <code>AudioFile.h</code> header file, reads data from an audio file and places it into a buffer.</p></li><li class="li"><p>The audio file to read from.</p></li><li class="li"><p>Uses a value of <code>false</code> to indicate that the function should not cache the data when reading.</p></li><li class="li"><p>On output, the number of bytes of audio data that were read from the audio file.</p></li><li class="li"><p>On output, an array of packet descriptions for the data that was read from the audio file. For CBR data, the input value of this parameter is <code>NULL</code>.</p></li><li class="li"><p>The packet index for the first packet to read from the audio file.</p></li><li class="li"><p>On input, the number of packets to read from the audio file. On output, the number of packets actually read.</p></li><li class="li"><p>On output, the filled audio queue buffer containing data that was read from the audio file.</p></li></ol><a name="//apple_ref/doc/uid/TP40005343-CH3-DontLinkElementID_3" title="Enqueuing an Audio Queue Buffer"></a><h3>Enqueuing an Audio Queue Buffer</h3><p>Now that data has been read from an audio file and placed in an audio queue buffer, the callback enqueues the buffer, as shown in <span class="content_text">Listing 3-4</span>. Once in the buffer queue, the audio data in the buffer is available for the audio queue to send to the output device.</p><a name="//apple_ref/doc/uid/TP40005343-CH3-SW17" title="Listing 3-4Enqueuing an audio queue buffer after reading from disk"></a><p class="codesample"><strong>Listing 3-4&nbsp;&nbsp;</strong>Enqueuing an audio queue buffer after reading from disk</p><div class="codesample"><table><tr><td scope="row"><pre>AudioQueueEnqueueBuffer (                      // 1<span></span></pre></td></tr><tr><td scope="row"><pre>    pAqData->mQueue,                           // 2<span></span></pre></td></tr><tr><td scope="row"><pre>    inBuffer,                                  // 3<span></span></pre></td></tr><tr><td scope="row"><pre>    (pAqData->mPacketDescs ? numPackets : 0),  // 4<span></span></pre></td></tr><tr><td scope="row"><pre>    pAqData->mPacketDescs                      // 5<span></span></pre></td></tr><tr><td scope="row"><pre>);<span></span></pre></td></tr></table></div>	<p>Here’s how this code works:</p><ol class="ol"><li class="li"><p>The <code><a href="../../../Reference/AudioQueueReference/Reference/reference.html#//apple_ref/doc/c_ref/AudioQueueEnqueueBuffer" target="_top">AudioQueueEnqueueBuffer</a></code> function adds an audio queue buffer to a buffer queue.</p></li><li class="li"><p>The audio queue that owns the buffer queue.</p></li><li class="li"><p>The audio queue buffer to enqueue</p></li><li class="li"><p>The number of packets represented in the audio queue buffer’s data. For CBR data, which uses no packet descriptions, uses <code>0</code>.</p></li><li class="li"><p>For compressed audio data formats that use packet descriptions, the packet descriptions for the packets in the buffer. .</p></li></ol><a name="//apple_ref/doc/uid/TP40005343-CH3-DontLinkElementID_4" title="Stopping an Audio Queue"></a><h3>Stopping an Audio Queue</h3><p>The last thing your callback does is to check if there’s no more data to read from the audio file that you’re playing. Upon discovering the end of the file, your callback tells the playback audio queue to stop. <span class="content_text">Listing 3-5</span> illustrates this.</p><a name="//apple_ref/doc/uid/TP40005343-CH3-SW18" title="Listing 3-5Stopping an audio queue"></a><p class="codesample"><strong>Listing 3-5&nbsp;&nbsp;</strong>Stopping an audio queue</p><div class="codesample"><table><tr><td scope="row"><pre>if (numPackets == 0) {                          // 1<span></span></pre></td></tr><tr><td scope="row"><pre>    AudioQueueStop (                            // 2<span></span></pre></td></tr><tr><td scope="row"><pre>        pAqData->mQueue,                        // 3<span></span></pre></td></tr><tr><td scope="row"><pre>        false                                   // 4<span></span></pre></td></tr><tr><td scope="row"><pre>    );<span></span></pre></td></tr><tr><td scope="row"><pre>    pAqData->mIsRunning = false;                // 5<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div>	<p>Here’s how this code works:</p><ol class="ol"><li class="li"><p>Checks if the number of packets read by the <code><a href="../../../Reference/AudioFileConvertRef/Reference/reference.html#//apple_ref/doc/c_ref/AudioFileReadPackets" target="_top">AudioFileReadPackets</a></code> function (invoked earlier by the callback) is <code>0</code>.</p></li><li class="li"><p>The <code><a href="../../../Reference/AudioQueueReference/Reference/reference.html#//apple_ref/doc/c_ref/AudioQueueStop" target="_top">AudioQueueStop</a></code> function stops the audio queue.</p></li><li class="li"><p>The audio queue to stop.</p></li><li class="li"><p>Stops the audio queue asynchronously, when all queued buffers have been played. See <span class="content_text"><a href="../AboutAudioQueues/AboutAudioQueues.html#//apple_ref/doc/uid/TP40005343-CH5-SW17">“Audio Queue Control and State.”</a></span></p></li><li class="li"><p>Sets a flag in the custom structure to indicate that playback is finished.</p></li></ol><a name="//apple_ref/doc/uid/TP40005343-CH3-DontLinkElementID_5" title="A Full Playback Audio Queue Callback"></a><h3>A Full Playback Audio Queue Callback</h3><p><span class="content_text">Listing 3-6</span> shows a basic version of a full playback audio queue callback. As with the rest of the code examples in this document, this listing excludes error handling.</p><a name="//apple_ref/doc/uid/TP40005343-CH3-SW13" title="Listing 3-6A playback audio queue callback function"></a><p class="codesample"><strong>Listing 3-6&nbsp;&nbsp;</strong>A playback audio queue callback function</p><div class="codesample"><table><tr><td scope="row"><pre>static void HandleOutputBuffer (
    void                *aqData,
    AudioQueueRef       inAQ,
    AudioQueueBufferRef inBuffer
) {
    AQPlayerState *pAqData = (AQPlayerState *) aqData;        // 1
    if (pAqData->mIsRunning == 0) return;                     // 2
    UInt32 numBytesReadFromFile;                              // 3
    UInt32 numPackets = pAqData->mNumPacketsToRead;           // 4
    AudioFileReadPackets (
        pAqData->mAudioFile,
        false,
        &amp;numBytesReadFromFile,
        pAqData->mPacketDescs, 
        pAqData->mCurrentPacket,
        &amp;numPackets,
        inBuffer->mAudioData 
    );
    if (numPackets > 0) {                                     // 5
        inBuffer->mAudioDataByteSize = numBytesReadFromFile;  // 6
       AudioQueueEnqueueBuffer ( 
            pAqData->mQueue,
            inBuffer,
            (pAqData->mPacketDescs ? numPackets : 0),
            pAqData->mPacketDescs
        );
        pAqData->mCurrentPacket += numPackets;                // 7 
    } else {
        AudioQueueStop (
            pAqData->mQueue,
            false
        );
        pAqData->mIsRunning = false; 
    }
}<span></span></pre></td></tr></table></div>	<p>Here’s how this code works:</p><ol class="ol"><li class="li"><p>The custom data supplied to the audio queue upon instantiation, including the audio file object (of type <code>AudioFileID</code>) representing the file to play as well as a variety of state data. See <span class="content_text"><a href="PlayingAudio.html#//apple_ref/doc/uid/TP40005343-CH3-SW15">“Define a Custom Structure to Manage State.”</a></span></p></li><li class="li"><p>If the audio queue is stopped, returns immediately.</p></li><li class="li"><p>A variable to hold the number of bytes of audio data read from the file being played.</p></li><li class="li"><p>Initializes the <code>numPackets</code> variable with the number of packets to read from the file being played.</p></li><li class="li"><p>Tests whether some audio data was retrieved from the file. If so, enqueues the newly-filled buffer. If not, stops the audio queue.</p></li><li class="li"><p>Tells the audio queue buffer structure the number of bytes of data that were read.</p></li><li class="li"><p>Increments the packet index according to the number of packets that were read.</p></li></ol><a name="//apple_ref/doc/uid/TP40005343-CH3-SW23" title="Write a Function to Derive Playback Audio Queue Buffer Size"></a><h2>Write a Function to Derive Playback Audio Queue Buffer Size</h2><p>Audio Queue Services expects your application to specify a size for the audio queue buffers you use. <span class="content_text">Listing 3-7</span> shows one way to do this. It derives a buffer size large enough to hold a given duration of audio data.</p><p>You’ll call this <code><!--a-->DeriveBufferSize<!--/a--></code> function in your application, after creating a playback audio queue, as a prerequisite to asking the audio queue to allocate buffers. See <span class="content_text"><a href="PlayingAudio.html#//apple_ref/doc/uid/TP40005343-CH3-SW9">“Set Sizes for a Playback Audio Queue.”</a></span></p><p>The code here does two additional things compared to the analogous function you saw in <span class="content_text"><a href="../AQRecord/RecordingAudio.html#//apple_ref/doc/uid/TP40005343-CH4-SW14">“Write a Function to Derive Recording Audio Queue Buffer Size.”</a></span> For playback you also:</p><ul class="ul"><li class="li"><p>Derive the number of packets to read each time your callback invokes the <code><a href="../../../Reference/AudioFileConvertRef/Reference/reference.html#//apple_ref/doc/c_ref/AudioFileReadPackets" target="_top">AudioFileReadPackets</a></code> function</p></li><li class="li"><p>Set a lower bound on buffer size, to avoid overly frequent disk access</p></li></ul><p>The calculation here takes into account the audio data format you’re reading from disk. The format includes all the factors that might affect buffer size, such as the number of audio channels.</p><a name="//apple_ref/doc/uid/TP40005343-CH3-SW4" title="Listing 3-7Deriving a playback audio queue buffer size"></a><p class="codesample"><strong>Listing 3-7&nbsp;&nbsp;</strong>Deriving a playback audio queue buffer size</p><div class="codesample"><table><tr><td scope="row"><pre>void DeriveBufferSize (<span></span></pre></td></tr><tr><td scope="row"><pre>    AudioStreamBasicDescription &amp;ASBDesc,                            // 1<span></span></pre></td></tr><tr><td scope="row"><pre>    UInt32                      maxPacketSize,                       // 2<span></span></pre></td></tr><tr><td scope="row"><pre>    Float64                     seconds,                             // 3<span></span></pre></td></tr><tr><td scope="row"><pre>    UInt32                      *outBufferSize,                      // 4<span></span></pre></td></tr><tr><td scope="row"><pre>    UInt32                      *outNumPacketsToRead                 // 5<span></span></pre></td></tr><tr><td scope="row"><pre>) {<span></span></pre></td></tr><tr><td scope="row"><pre>    static const int maxBufferSize = 0x50000;                        // 6<span></span></pre></td></tr><tr><td scope="row"><pre>    static const int minBufferSize = 0x4000;                         // 7<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if (ASBDesc.mFramesPerPacket != 0) {                             // 8<span></span></pre></td></tr><tr><td scope="row"><pre>        Float64 numPacketsForTime =<span></span></pre></td></tr><tr><td scope="row"><pre>            ASBDesc.mSampleRate / ASBDesc.mFramesPerPacket * seconds;<span></span></pre></td></tr><tr><td scope="row"><pre>        *outBufferSize = numPacketsForTime * maxPacketSize;<span></span></pre></td></tr><tr><td scope="row"><pre>    } else {                                                         // 9<span></span></pre></td></tr><tr><td scope="row"><pre>        *outBufferSize =<span></span></pre></td></tr><tr><td scope="row"><pre>            maxBufferSize > maxPacketSize ?<span></span></pre></td></tr><tr><td scope="row"><pre>                maxBufferSize : maxPacketSize;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if (                                                             // 10<span></span></pre></td></tr><tr><td scope="row"><pre>        *outBufferSize > maxBufferSize &amp;&amp;<span></span></pre></td></tr><tr><td scope="row"><pre>        *outBufferSize > maxPacketSize<span></span></pre></td></tr><tr><td scope="row"><pre>    )<span></span></pre></td></tr><tr><td scope="row"><pre>        *outBufferSize = maxBufferSize;<span></span></pre></td></tr><tr><td scope="row"><pre>    else {                                                           // 11<span></span></pre></td></tr><tr><td scope="row"><pre>        if (*outBufferSize &lt; minBufferSize)<span></span></pre></td></tr><tr><td scope="row"><pre>            *outBufferSize = minBufferSize;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    *outNumPacketsToRead = *outBufferSize / maxPacketSize;           // 12<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div>	<p>Here’s how this code works:</p><ol class="ol"><li class="li"><p>The <code>AudioStreamBasicDescription</code> structure for the audio queue.</p></li><li class="li"><p>The estimated maximum packet size for the data in the audio file you’re playing. You can determine this value by invoking the <code><a href="../../../Reference/AudioFileConvertRef/Reference/reference.html#//apple_ref/doc/c_ref/AudioFileGetProperty" target="_top">AudioFileGetProperty</a></code> function (declared in the <code>AudioFile.h</code> header file) with a property ID of <code>kAudioFilePropertyPacketSizeUpperBound</code>.  See <span class="content_text"><a href="PlayingAudio.html#//apple_ref/doc/uid/TP40005343-CH3-SW9">“Set Sizes for a Playback Audio Queue.”</a></span></p></li><li class="li"><p>The size you are specifying for each audio queue buffer, in terms of seconds of audio.</p></li><li class="li"><p>On output, the size for each audio queue buffer, in bytes.</p></li><li class="li"><p>On output, the number of packets of audio data to read from the file on each invocation of the playback audio queue callback.</p></li><li class="li"><p>An upper bound for the audio queue buffer size, in bytes. In this example, the upper bound is set to 320 KB. This corresponds to approximately five seconds of stereo, 24 bit audio at a sample rate of 96 kHz.</p></li><li class="li"><p>A lower bound for the audio queue buffer size, in bytes. In this example, the lower bound is set to 16 KB.</p></li><li class="li"><p>For audio data formats that define a fixed number of frames per packet, derives the audio queue buffer size.</p></li><li class="li"><p>For audio data formats that do not define a fixed number of frames per packet, derives a reasonable audio queue buffer size based on the maximum packet size and the upper bound you’ve set.</p></li><li class="li"><p>If the derived buffer size is above the upper bound you’ve set, adjusts it the bound—taking into account the estimated maximum packet size.</p></li><li class="li"><p>If the derived buffer size is below the lower bound you’ve set, adjusts it to the bound.</p></li><li class="li"><p>Calculates the number of packets to read from the audio file on each invocation of the callback.</p></li></ol><a name="//apple_ref/doc/uid/TP40005343-CH3-DontLinkElementID_6" title="Open an Audio File for Playback"></a><h2>Open an Audio File for Playback</h2><p>Now you open an audio file for playback, using these three steps:</p><ol class="ol"><li class="li"><p>Obtain a CFURL object representing the audio file you want to play.</p></li><li class="li"><p>Open the file.</p></li><li class="li"><p>Obtain the file’s audio data format.</p></li></ol><a name="//apple_ref/doc/uid/TP40005343-CH3-DontLinkElementID_7" title="Obtaining a CFURL Object for an Audio File"></a><h3>Obtaining a CFURL Object for an Audio File</h3><p><span class="content_text">Listing 3-8</span> demonstrates how to obtain a CFURL object for the audio file you want to play. You use the CFURL object in the next step, opening the file..</p><a name="//apple_ref/doc/uid/TP40005343-CH3-SW12" title="Listing 3-8Obtaining a CFURL object for an audio file"></a><p class="codesample"><strong>Listing 3-8&nbsp;&nbsp;</strong>Obtaining a CFURL object for an audio file</p><div class="codesample"><table><tr><td scope="row"><pre>CFURLRef audioFileURL =<span></span></pre></td></tr><tr><td scope="row"><pre>    CFURLCreateFromFileSystemRepresentation (           // 1<span></span></pre></td></tr><tr><td scope="row"><pre>        NULL,                                           // 2<span></span></pre></td></tr><tr><td scope="row"><pre>        (const UInt8 *) filePath,                       // 3<span></span></pre></td></tr><tr><td scope="row"><pre>        strlen (filePath),                              // 4<span></span></pre></td></tr><tr><td scope="row"><pre>        false                                           // 5<span></span></pre></td></tr><tr><td scope="row"><pre>    );<span></span></pre></td></tr></table></div>	<p>Here’s how this code works:</p><ol class="ol"><li class="li"><p>The <code><a href="../../../../CoreFoundation/Reference/CFURLRef/Reference/reference.html#//apple_ref/doc/c_ref/CFURLCreateFromFileSystemRepresentation" target="_top">CFURLCreateFromFileSystemRepresentation</a></code> function, declared in the <code>CFURL.h</code> header file, creates a CFURL object representing the file to play.</p></li><li class="li"><p>Uses <code>NULL</code> (or <code>kCFAllocatorDefault</code>) to use the current default memory allocator.</p></li><li class="li"><p>The file-system path you want to convert to a CFURL object. In production code, you would typically obtain a value for <code>filePath</code> from the user.</p></li><li class="li"><p>The number of bytes in the file-system path.</p></li><li class="li"><p>A value of <code>false</code> indicates that <code>filePath</code> represents a file, not a directory.</p></li></ol><a name="//apple_ref/doc/uid/TP40005343-CH3-SW24" title="Opening an Audio File"></a><h3>Opening an Audio File</h3><p><span class="content_text">Listing 3-9</span> demonstrates how to open an audio file for playback.</p><a name="//apple_ref/doc/uid/TP40005343-CH3-SW19" title="Listing 3-9Opening an audio file for playback"></a><p class="codesample"><strong>Listing 3-9&nbsp;&nbsp;</strong>Opening an audio file for playback</p><div class="codesample"><table><tr><td scope="row"><pre>AQPlayerState aqData;                                   // 1<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>OSStatus result =<span></span></pre></td></tr><tr><td scope="row"><pre>    AudioFileOpenURL (                                  // 2<span></span></pre></td></tr><tr><td scope="row"><pre>        audioFileURL,                                   // 3<span></span></pre></td></tr><tr><td scope="row"><pre>        fsRdPerm,                                       // 4<span></span></pre></td></tr><tr><td scope="row"><pre>        0,                                              // 5<span></span></pre></td></tr><tr><td scope="row"><pre>        &amp;aqData.mAudioFile                              // 6<span></span></pre></td></tr><tr><td scope="row"><pre>    );<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>CFRelease (audioFileURL);                               // 7<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr></table></div>	<p>Here’s how this code works:</p><ol class="ol"><li class="li"><p>Creates an instance of the <code>AQPlayerState</code> custom structure (see <span class="content_text"><a href="PlayingAudio.html#//apple_ref/doc/uid/TP40005343-CH3-SW15">“Define a Custom Structure to Manage State”</a></span>). You use this instance when you open an audio file for playback, as a place to hold the audio file object (of type <code>AudioFileID</code>) that represents the audio file.</p></li><li class="li"><p>The <code><a href="../../../Reference/AudioFileConvertRef/Reference/reference.html#//apple_ref/doc/c_ref/AudioFileOpenURL" target="_top">AudioFileOpenURL</a></code> function, declared in the <code>AudioFile.h</code> header file, opens the file you want to play.</p></li><li class="li"><p>A reference to the file to play.</p></li><li class="li"><p>The file permissions you want to use with the file you’re playing. The available permissions are defined in the File Manager’s <span class="content_text"><a href="../../../../Carbon/Reference/File_Manager/Reference/reference.html#//apple_ref/doc/constant_group/File_Access_Permission_Constants" target="_top">File Access Permission Constants</a></span> enumeration. In this example you request permission to read the file.</p></li><li class="li"><p>An optional file type hint. A value of <code>0</code> here indicates that the example does not use this facility.</p></li><li class="li"><p>On output, a reference to the audio file is placed in the custom structure’s <code>mAudioFile</code> field.</p></li><li class="li"><p>Releases the CFURL object that was created in step 1.</p></li></ol><a name="//apple_ref/doc/uid/TP40005343-CH3-SW25" title="Obtaining a File&acirc;&#128;&#153;s Audio Data Format"></a><h3>Obtaining a File’s Audio Data Format</h3><p><span class="content_text">Listing 3-10</span> shows how to obtain a file’s audio data format.</p><a name="//apple_ref/doc/uid/TP40005343-CH3-SW20" title="Listing 3-10Obtaining a file&acirc;&#128;&#153;s audio data format"></a><p class="codesample"><strong>Listing 3-10&nbsp;&nbsp;</strong>Obtaining a file’s audio data format</p><div class="codesample"><table><tr><td scope="row"><pre>UInt32 dataFormatSize = sizeof (aqData.mDataFormat);    // 1<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>AudioFileGetProperty (                                  // 2<span></span></pre></td></tr><tr><td scope="row"><pre>    aqData.mAudioFile,                                  // 3<span></span></pre></td></tr><tr><td scope="row"><pre>    kAudioFilePropertyDataFormat,                       // 4<span></span></pre></td></tr><tr><td scope="row"><pre>    &amp;dataFormatSize,                                    // 5<span></span></pre></td></tr><tr><td scope="row"><pre>    &amp;aqData.mDataFormat                                 // 6<span></span></pre></td></tr><tr><td scope="row"><pre>);<span></span></pre></td></tr></table></div>	<p>Here’s how this code works:</p><ol class="ol"><li class="li"><p>Gets an expected property value size to use when querying the audio file about its audio data format.</p></li><li class="li"><p>The <code><a href="../../../Reference/AudioFileConvertRef/Reference/reference.html#//apple_ref/doc/c_ref/AudioFileGetProperty" target="_top">AudioFileGetProperty</a></code> function, declared in the <code>AudioFile.h</code> header file, obtains the value for a specified property in an audio file.</p></li><li class="li"><p>An audio file object (of type <code>AudioFileID</code>) representing the file whose audio data format you want to obtain.</p></li><li class="li"><p>The property ID for obtaining the value of the audio file’s data format.</p></li><li class="li"><p>On input, the expected size of the <code>AudioStreamBasicDescription</code> structure that describes the audio file’s data format. On output, the actual size. Your playback application does not need to make use of this value.</p></li><li class="li"><p>On output, the full audio data format, in the form of an <code>AudioStreamBasicDescription</code> structure, obtained from the audio file. This line applies the file’s audio data format to the audio queue by storing it in the audio queue’s custom structure.</p></li></ol><a name="//apple_ref/doc/uid/TP40005343-CH3-SW5" title="Create a Playback Audio Queue"></a><h2>Create a Playback Audio Queue</h2><p><span class="content_text">Listing 3-11</span> shows how to create a playback audio queue. Notice that the <code><a href="../../../Reference/AudioQueueReference/Reference/reference.html#//apple_ref/doc/c_ref/AudioQueueNewOutput" target="_top">AudioQueueNewOutput</a></code> function uses the custom structure and the callback that were configured in previous steps, as well as the audio data format of the file to be played.</p><a name="//apple_ref/doc/uid/TP40005343-CH3-SW21" title="Listing 3-11Creating a playback audio queue"></a><p class="codesample"><strong>Listing 3-11&nbsp;&nbsp;</strong>Creating a playback audio queue</p><div class="codesample"><table><tr><td scope="row"><pre>AudioQueueNewOutput (                                // 1
    &amp;aqData.mDataFormat,                             // 2
    HandleOutputBuffer,                              // 3
    &amp;aqData,                                         // 4
    CFRunLoopGetCurrent (),                          // 5
    kCFRunLoopCommonModes,                           // 6
    0,                                               // 7
    &amp;aqData.mQueue                                   // 8
);
<span></span></pre></td></tr></table></div>	<p>Here’s how this code works:</p><ol class="ol"><li class="li"><p>The <code><a href="../../../Reference/AudioQueueReference/Reference/reference.html#//apple_ref/doc/c_ref/AudioQueueNewOutput" target="_top">AudioQueueNewOutput</a></code> function creates a new playback audio queue.</p></li><li class="li"><p>The audio data format of the file that the audio queue is being set up to play. See <span class="content_text"><a href="PlayingAudio.html#//apple_ref/doc/uid/TP40005343-CH3-SW25">“Obtaining a File’s Audio Data Format.”</a></span></p></li><li class="li"><p>The callback function to use with the playback audio queue. See <span class="content_text"><a href="PlayingAudio.html#//apple_ref/doc/uid/TP40005343-CH3-SW2">“Write a Playback Audio Queue Callback.”</a></span></p></li><li class="li"><p>The custom data structure for the playback audio queue. See <span class="content_text"><a href="PlayingAudio.html#//apple_ref/doc/uid/TP40005343-CH3-SW15">“Define a Custom Structure to Manage State.”</a></span></p></li><li class="li"><p>The current run loop, and the one on which the audio queue playback callback will be invoked.</p></li><li class="li"><p>The run loop modes in which the callback can be invoked. Normally, use the <code>kCFRunLoopCommonModes</code> constant here.</p></li><li class="li"><p>Reserved. Must be <code>0</code>.</p></li><li class="li"><p>On output, the newly allocated playback audio queue.</p></li></ol><a name="//apple_ref/doc/uid/TP40005343-CH3-SW9" title="Set Sizes for a Playback Audio Queue"></a><h2>Set Sizes for a Playback Audio Queue</h2><p>Next, you set some sizes for the playback audio queue. You use these sizes when you allocate buffers for an audio queue and before you start reading an audio file.</p><p>The code listings in this section show how to set:</p><ul class="ul"><li class="li"><p>Audio queue buffer size</p></li><li class="li"><p>Number of packets to read for each invocation of the playback audio queue callback</p></li><li class="li"><p>Array size for holding the packet descriptions for one buffer’s worth of audio data</p></li></ul><a name="//apple_ref/doc/uid/TP40005343-CH3-SW26" title="Setting Buffer Size and Number of Packets to Read"></a><h3>Setting Buffer Size and Number of Packets to Read</h3><p><span class="content_text">Listing 3-12</span> demonstrates how to use the <code><!--a-->DeriveBufferSize<!--/a--></code> function you wrote earlier (see <span class="content_text"><a href="PlayingAudio.html#//apple_ref/doc/uid/TP40005343-CH3-SW23">“Write a Function to Derive Playback Audio Queue Buffer Size”</a></span>). The goal here is to set a size, in bytes, for each audio queue buffer, and to determine the number of packets to read for each invocation of the playback audio queue callback.</p><p>This code uses a conservative estimate of maximum packet size, which Core Audio provides by way of the <code>kAudioFilePropertyPacketSizeUpperBound</code> property. In most cases, it is better to use this technique—which is approximate but fast—than to take the time to read an entire audio file to obtain the actual maximum packet size.</p><a name="//apple_ref/doc/uid/TP40005343-CH3-SW22" title="Listing 3-12Setting playback audio queue buffer size and number of packets to read"></a><p class="codesample"><strong>Listing 3-12&nbsp;&nbsp;</strong>Setting playback audio queue buffer size and number of packets to read</p><div class="codesample"><table><tr><td scope="row"><pre>UInt32 maxPacketSize;<span></span></pre></td></tr><tr><td scope="row"><pre>UInt32 propertySize = sizeof (maxPacketSize);<span></span></pre></td></tr><tr><td scope="row"><pre>AudioFileGetProperty (                               // 1<span></span></pre></td></tr><tr><td scope="row"><pre>    aqData.mAudioFile,                               // 2<span></span></pre></td></tr><tr><td scope="row"><pre>    kAudioFilePropertyPacketSizeUpperBound,          // 3<span></span></pre></td></tr><tr><td scope="row"><pre>    &amp;propertySize,                                   // 4<span></span></pre></td></tr><tr><td scope="row"><pre>    &amp;maxPacketSize                                   // 5<span></span></pre></td></tr><tr><td scope="row"><pre>);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>DeriveBufferSize (                                   // 6<span></span></pre></td></tr><tr><td scope="row"><pre>    aqData.mDataFormat,                              // 7<span></span></pre></td></tr><tr><td scope="row"><pre>    maxPacketSize,                                   // 8<span></span></pre></td></tr><tr><td scope="row"><pre>    0.5,                                             // 9<span></span></pre></td></tr><tr><td scope="row"><pre>    &amp;aqData.bufferByteSize,                          // 10<span></span></pre></td></tr><tr><td scope="row"><pre>    &amp;aqData.mNumPacketsToRead                        // 11<span></span></pre></td></tr><tr><td scope="row"><pre>);<span></span></pre></td></tr></table></div>	<p>Here’s how this code works:</p><ol class="ol"><li class="li"><p>The <code><a href="../../../Reference/AudioFileConvertRef/Reference/reference.html#//apple_ref/doc/c_ref/AudioFileGetProperty" target="_top">AudioFileGetProperty</a></code> function, declared in the <code>AudioFile.h</code> header file, obtains the value of a specified property for an audio file. Here you use it to get a conservative upper bound, in bytes, for the size of the audio data packets in the file you want to play.</p></li><li class="li"><p>An audio file object (of type <code>AudioFileID</code>) representing the file you want to play. See <span class="content_text"><a href="PlayingAudio.html#//apple_ref/doc/uid/TP40005343-CH3-SW24">“Opening an Audio File.”</a></span></p></li><li class="li"><p>The property ID for obtaining a conservative upper bound for packet size in an audio file.</p></li><li class="li"><p>On output, the size, in bytes, for the <code>kAudioFilePropertyPacketSizeUpperBound</code> property.</p></li><li class="li"><p>On output, a conservative upper bound for packet size, in bytes, for the file you want to play.</p></li><li class="li"><p>The <code><!--a-->DeriveBufferSize<!--/a--></code> function, described in <span class="content_text"><a href="PlayingAudio.html#//apple_ref/doc/uid/TP40005343-CH3-SW23">“Write a Function to Derive Playback Audio Queue Buffer Size,”</a></span> sets a buffer size and a number of packets to read on each invocation of the playback audio queue callback.</p></li><li class="li"><p>The audio data format of the file you want to play. See <span class="content_text"><a href="PlayingAudio.html#//apple_ref/doc/uid/TP40005343-CH3-SW25">“Obtaining a File’s Audio Data Format.”</a></span></p></li><li class="li"><p>The estimated maximum packet size in the audio file, from line 5 of this listing.</p></li><li class="li"><p>The number of seconds of audio that each audio queue buffer should hold. One half second, as set here, is typically a good choice.</p></li><li class="li"><p>On output, the size for each audio queue buffer, in bytes. This value is placed in the custom structure for the audio queue.</p></li><li class="li"><p>On output, the number of packets to read on each invocation of the playback audio queue callback. This value is also placed in the custom structure for the audio queue.</p></li></ol><a name="//apple_ref/doc/uid/TP40005343-CH3-DontLinkElementID_8" title="Allocating Memory for a Packet Descriptions Array"></a><h3>Allocating Memory for a Packet Descriptions Array</h3><p>Now you allocate memory for an array to hold the packet descriptions for one buffer’s worth of audio data. Constant bitrate data does not use packet descriptions, so the CBR case—step 3 in <span class="content_text">Listing 3-13</span>—is very simple.</p><a name="//apple_ref/doc/uid/TP40005343-CH3-SW27" title="Listing 3-13Allocating memory for a packet descriptions array"></a><p class="codesample"><strong>Listing 3-13&nbsp;&nbsp;</strong>Allocating memory for a packet descriptions array</p><div class="codesample"><table><tr><td scope="row"><pre>bool isFormatVBR = (                                       // 1<span></span></pre></td></tr><tr><td scope="row"><pre>    aqData.mDataFormat.mBytesPerPacket == 0 ||<span></span></pre></td></tr><tr><td scope="row"><pre>    aqData.mDataFormat.mFramesPerPacket == 0<span></span></pre></td></tr><tr><td scope="row"><pre>);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>if (isFormatVBR) {                                         // 2<span></span></pre></td></tr><tr><td scope="row"><pre>    aqData.mPacketDescs =<span></span></pre></td></tr><tr><td scope="row"><pre>      (AudioStreamPacketDescription*) malloc (<span></span></pre></td></tr><tr><td scope="row"><pre>        aqData.mNumPacketsToRead * sizeof (AudioStreamPacketDescription)<span></span></pre></td></tr><tr><td scope="row"><pre>      );<span></span></pre></td></tr><tr><td scope="row"><pre>} else {                                                   // 3<span></span></pre></td></tr><tr><td scope="row"><pre>    aqData.mPacketDescs = NULL;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div>	<p>Here’s how this code works:</p><ol class="ol"><li class="li"><p>Determines if the audio file’s data format is VBR or CBR. In VBR data, one or both of the bytes-per-packet or frames-per-packet values is variable, and so will be listed as <code>0</code> in the audio queue’s <code>AudioStreamBasicDescription</code> structure.</p></li><li class="li"><p>For an audio file that contains VBR data, allocates memory for the packet descriptions array. Calculates the memory needed based on the number of audio data packets to be read on each invocation of the playback callback. See <span class="content_text"><a href="PlayingAudio.html#//apple_ref/doc/uid/TP40005343-CH3-SW26">“Setting Buffer Size and Number of Packets to Read.”</a></span></p></li><li class="li"><p>For an audio file that contains CBR data, such as linear PCM, the audio queue does not use a packet descriptions array.</p></li></ol><a name="//apple_ref/doc/uid/TP40005343-CH3-DontLinkElementID_9" title="Set a Magic Cookie for a Playback Audio Queue"></a><h2>Set a Magic Cookie for a Playback Audio Queue</h2><p>Some compressed audio formats, such as MPEG 4 AAC, make use of structures to contain audio metadata. These structures are called <strong>magic cookies</strong>. When you play a file in such a format using Audio Queue Services, you get the magic cookie from the audio file and add it to the audio queue before you start playing.</p><p><span class="content_text">Listing 3-14</span> shows how to obtain a magic cookie from a file and apply it to an audio queue. Your code would call this function before starting playback.</p><a name="//apple_ref/doc/uid/TP40005343-CH3-SW3" title="Listing 3-14Setting a magic cookie for a playback audio queue"></a><p class="codesample"><strong>Listing 3-14&nbsp;&nbsp;</strong>Setting a magic cookie for a playback audio queue</p><div class="codesample"><table><tr><td scope="row"><pre>UInt32 cookieSize = sizeof (UInt32);                   // 1<span></span></pre></td></tr><tr><td scope="row"><pre>bool couldNotGetProperty =                             // 2<span></span></pre></td></tr><tr><td scope="row"><pre>    AudioFileGetPropertyInfo (                         // 3<span></span></pre></td></tr><tr><td scope="row"><pre>        aqData.mAudioFile,                             // 4<span></span></pre></td></tr><tr><td scope="row"><pre>        kAudioFilePropertyMagicCookieData,             // 5<span></span></pre></td></tr><tr><td scope="row"><pre>        &amp;cookieSize,                                   // 6<span></span></pre></td></tr><tr><td scope="row"><pre>        NULL                                           // 7<span></span></pre></td></tr><tr><td scope="row"><pre>    );<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>if (!couldNotGetProperty &amp;&amp; cookieSize) {              // 8<span></span></pre></td></tr><tr><td scope="row"><pre>    char* magicCookie =<span></span></pre></td></tr><tr><td scope="row"><pre>        (char *) malloc (cookieSize);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    AudioFileGetProperty (                             // 9<span></span></pre></td></tr><tr><td scope="row"><pre>        aqData.mAudioFile,                             // 10<span></span></pre></td></tr><tr><td scope="row"><pre>        kAudioFilePropertyMagicCookieData,             // 11<span></span></pre></td></tr><tr><td scope="row"><pre>        &amp;cookieSize,                                   // 12<span></span></pre></td></tr><tr><td scope="row"><pre>        magicCookie                                    // 13<span></span></pre></td></tr><tr><td scope="row"><pre>    );<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    AudioQueueSetProperty (                            // 14<span></span></pre></td></tr><tr><td scope="row"><pre>        aqData.mQueue,                                 // 15<span></span></pre></td></tr><tr><td scope="row"><pre>        kAudioQueueProperty_MagicCookie,               // 16<span></span></pre></td></tr><tr><td scope="row"><pre>        magicCookie,                                   // 17<span></span></pre></td></tr><tr><td scope="row"><pre>        cookieSize                                     // 18<span></span></pre></td></tr><tr><td scope="row"><pre>    );<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    free (magicCookie);                                // 19<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div>	<p>Here’s how this code works:</p><ol class="ol"><li class="li"><p>Sets an estimated size for the magic cookie data.</p></li><li class="li"><p>Captures the result of the <code><a href="../../../Reference/AudioFileConvertRef/Reference/reference.html#//apple_ref/doc/c_ref/AudioFileGetPropertyInfo" target="_top">AudioFileGetPropertyInfo</a></code> function. If successful, this function returns a value of <code>NoErr</code>, equivalent to Boolean <code>false</code>.</p></li><li class="li"><p>The <code><a href="../../../Reference/AudioFileConvertRef/Reference/reference.html#//apple_ref/doc/c_ref/AudioFileGetPropertyInfo" target="_top">AudioFileGetPropertyInfo</a></code> function, declared in the <code>AudioFile.h</code> header file, gets the size of the value of a specified property. You use this to set the size of the variable that holds the property value.</p></li><li class="li"><p>An audio file object (of type <code>AudioFileID</code>) that represents the audio file you want to play.</p></li><li class="li"><p>The property ID representing an audio file’s magic cookie data.</p></li><li class="li"><p>On input, an estimated size for the magic cookie data. On output, the actual size.</p></li><li class="li"><p>Uses <code>NULL</code> to indicate that you don’t care about the read/write access for the property.</p></li><li class="li"><p>If the audio file does contain a magic cookie, allocate memory to hold it.</p></li><li class="li"><p>The <code><a href="../../../Reference/AudioFileConvertRef/Reference/reference.html#//apple_ref/doc/c_ref/AudioFileGetProperty" target="_top">AudioFileGetProperty</a></code> function, declared in the <code>AudioFile.h</code> header file, gets the value of a specified property. In this case, it gets the audio file’s magic cookie.</p></li><li class="li"><p>An audio file object (of type <code>AudioFileID</code>) that represents the audio file you want to play, and whose magic cookie you are getting.</p></li><li class="li"><p>The property ID representing the audio file’s magic cookie data.</p></li><li class="li"><p>On input, the size of the <code>magicCookie</code> variable obtained using the <code><a href="../../../Reference/AudioFileConvertRef/Reference/reference.html#//apple_ref/doc/c_ref/AudioFileGetPropertyInfo" target="_top">AudioFileGetPropertyInfo</a></code> function. On output, the actual size of the magic cookie in terms of the number of bytes written to the <code>magicCookie</code> variable.</p></li><li class="li"><p>On output, the audio file’s magic cookie.</p></li><li class="li"><p>The <code><a href="../../../Reference/AudioQueueReference/Reference/reference.html#//apple_ref/doc/c_ref/AudioQueueSetProperty" target="_top">AudioQueueSetProperty</a></code> function sets a property in an audio queue. In this case, it sets a magic cookie for the audio queue, matching the magic cookie in the audio file to be played.</p></li><li class="li"><p>The audio queue that you want to set a magic cookie for.</p></li><li class="li"><p>The property ID representing an audio queue’s magic cookie.</p></li><li class="li"><p>The magic cookie from the audio file that you want to play.</p></li><li class="li"><p>The size, in bytes, of the magic cookie.</p></li><li class="li"><p>Releases the memory that was allocated for the magic cookie.</p></li></ol><a name="//apple_ref/doc/uid/TP40005343-CH3-DontLinkElementID_10" title="Allocate and Prime Audio Queue Buffers"></a><h2>Allocate and Prime Audio Queue Buffers</h2><p>You now ask the audio queue that you’ve created (in <span class="content_text"><a href="PlayingAudio.html#//apple_ref/doc/uid/TP40005343-CH3-SW5">“Create a Playback Audio Queue”</a></span>) to prepare a set of audio queue buffers. <span class="content_text">Listing 3-15</span> demonstrates how to do this.</p><a name="//apple_ref/doc/uid/TP40005343-CH3-SW6" title="Listing 3-15Allocating and priming audio queue buffers for playback"></a><p class="codesample"><strong>Listing 3-15&nbsp;&nbsp;</strong>Allocating and priming audio queue buffers for playback</p><div class="codesample"><table><tr><td scope="row"><pre>aqData.mCurrentPacket = 0;                                // 1<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>for (int i = 0; i &lt; kNumberBuffers; ++i) {                // 2<span></span></pre></td></tr><tr><td scope="row"><pre>    AudioQueueAllocateBuffer (                            // 3<span></span></pre></td></tr><tr><td scope="row"><pre>        aqData.mQueue,                                    // 4<span></span></pre></td></tr><tr><td scope="row"><pre>        aqData.bufferByteSize,                            // 5<span></span></pre></td></tr><tr><td scope="row"><pre>        &amp;aqData.mBuffers[i]                               // 6<span></span></pre></td></tr><tr><td scope="row"><pre>    );<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    HandleOutputBuffer (                                  // 7<span></span></pre></td></tr><tr><td scope="row"><pre>        &amp;aqData,                                          // 8<span></span></pre></td></tr><tr><td scope="row"><pre>        aqData.mQueue,                                    // 9<span></span></pre></td></tr><tr><td scope="row"><pre>        aqData.mBuffers[i]                                // 10<span></span></pre></td></tr><tr><td scope="row"><pre>    );<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div>	<p>Here’s how this code works:</p><ol class="ol"><li class="li"><p>Sets the packet index to <code>0</code>, so that when the audio queue callback starts filling buffers (step 7) it starts at the beginning of the audio file.</p></li><li class="li"><p>Allocates and primes a set of audio queue buffers. (You set this number, <code>kNumberBuffers</code>, to <code>3</code> in <span class="content_text"><a href="PlayingAudio.html#//apple_ref/doc/uid/TP40005343-CH3-SW15">“Define a Custom Structure to Manage State.”</a></span>)</p></li><li class="li"><p>The <code><a href="../../../Reference/AudioQueueReference/Reference/reference.html#//apple_ref/doc/c_ref/AudioQueueAllocateBuffer" target="_top">AudioQueueAllocateBuffer</a></code> function creates an audio queue buffer by allocating memory for it.</p></li><li class="li"><p>The audio queue that is allocating the audio queue buffer.</p></li><li class="li"><p>The size, in bytes, for the new audio queue buffer.</p></li><li class="li"><p>On output, adds the new audio queue buffer to the <code>mBuffers</code> array in the custom structure.</p></li><li class="li"><p>The <code><!--a-->HandleOutputBuffer<!--/a--></code> function is the playback audio queue callback you wrote. See <span class="content_text"><a href="PlayingAudio.html#//apple_ref/doc/uid/TP40005343-CH3-SW2">“Write a Playback Audio Queue Callback.”</a></span></p></li><li class="li"><p>The custom structure for the audio queue.</p></li><li class="li"><p>The audio queue whose callback you’re invoking.</p></li><li class="li"><p>The audio queue buffer that you’re passing to the audio queue callback.</p></li></ol><a name="//apple_ref/doc/uid/TP40005343-CH3-DontLinkElementID_11" title="Set an Audio Queue&acirc;&#128;&#153;s Playback Gain"></a><h2>Set an Audio Queue’s Playback Gain</h2><p>Before you tell an audio queue to begin playing, you set its gain by way of the audio queue parameter mechanism. <span class="content_text">Listing 3-16</span> shows how to do this. For more on the parameter mechanism, see <span class="content_text"><a href="../AboutAudioQueues/AboutAudioQueues.html#//apple_ref/doc/uid/TP40005343-CH5-SW15">“Audio Queue Parameters.”</a></span></p><a name="//apple_ref/doc/uid/TP40005343-CH3-SW7" title="Listing 3-16Setting an audio queue&acirc;&#128;&#153;s playback gain"></a><p class="codesample"><strong>Listing 3-16&nbsp;&nbsp;</strong>Setting an audio queue’s playback gain</p><div class="codesample"><table><tr><td scope="row"><pre>Float32 gain = 1.0;                                       // 1<span></span></pre></td></tr><tr><td scope="row"><pre>    // Optionally, allow user to override gain setting here<span></span></pre></td></tr><tr><td scope="row"><pre>AudioQueueSetParameter (                                  // 2<span></span></pre></td></tr><tr><td scope="row"><pre>    aqData.mQueue,                                        // 3<span></span></pre></td></tr><tr><td scope="row"><pre>    kAudioQueueParam_Volume,                              // 4<span></span></pre></td></tr><tr><td scope="row"><pre>    gain                                                  // 5<span></span></pre></td></tr><tr><td scope="row"><pre>);<span></span></pre></td></tr></table></div>	<p>Here’s how this code works:</p><ol class="ol"><li class="li"><p>Sets a gain to use with the audio queue, between <code>0</code> (for silence) and <code>1</code> (for unity gain).</p></li><li class="li"><p>The <code><a href="../../../Reference/AudioQueueReference/Reference/reference.html#//apple_ref/doc/c_ref/AudioQueueSetParameter" target="_top">AudioQueueSetParameter</a></code> function sets the value of a parameter for an audio queue.</p></li><li class="li"><p>The audio queue that you are setting a parameter on.</p></li><li class="li"><p>The ID of the parameter you are setting. The <code>kAudioQueueParam_Volume</code> constant lets you set an audio queue’s gain.</p></li><li class="li"><p>The gain setting that you are applying to the audio queue.</p></li></ol><a name="//apple_ref/doc/uid/TP40005343-CH3-DontLinkElementID_12" title="Start and Run an Audio Queue"></a><h2>Start and Run an Audio Queue</h2><p>All of the preceding code has led up to the process of playing a file. This includes starting an audio queue and maintaining a run loop while a file is playing, as shown in <span class="content_text">Listing 3-17</span>.</p><a name="//apple_ref/doc/uid/TP40005343-CH3-SW8" title="Listing 3-17Starting and running an audio queue"></a><p class="codesample"><strong>Listing 3-17&nbsp;&nbsp;</strong>Starting and running an audio queue</p><div class="codesample"><table><tr><td scope="row"><pre>aqData.mIsRunning = true;                          // 1<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>AudioQueueStart (                                  // 2<span></span></pre></td></tr><tr><td scope="row"><pre>    aqData.mQueue,                                 // 3<span></span></pre></td></tr><tr><td scope="row"><pre>    NULL                                           // 4<span></span></pre></td></tr><tr><td scope="row"><pre>);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>do {                                               // 5<span></span></pre></td></tr><tr><td scope="row"><pre>    CFRunLoopRunInMode (                           // 6<span></span></pre></td></tr><tr><td scope="row"><pre>        kCFRunLoopDefaultMode,                     // 7<span></span></pre></td></tr><tr><td scope="row"><pre>        0.25,                                      // 8<span></span></pre></td></tr><tr><td scope="row"><pre>        false                                      // 9<span></span></pre></td></tr><tr><td scope="row"><pre>    );<span></span></pre></td></tr><tr><td scope="row"><pre>} while (aqData.mIsRunning);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>CFRunLoopRunInMode (                               // 10<span></span></pre></td></tr><tr><td scope="row"><pre>    kCFRunLoopDefaultMode,<span></span></pre></td></tr><tr><td scope="row"><pre>    1,<span></span></pre></td></tr><tr><td scope="row"><pre>    false<span></span></pre></td></tr><tr><td scope="row"><pre>);<span></span></pre></td></tr></table></div>	<p>Here’s how this code works:</p><ol class="ol"><li class="li"><p>Sets a flag in the custom structure to indicate that the audio queue is running.</p></li><li class="li"><p>The <code><a href="../../../Reference/AudioQueueReference/Reference/reference.html#//apple_ref/doc/c_ref/AudioQueueStart" target="_top">AudioQueueStart</a></code> function starts the audio queue, on its own thread.</p></li><li class="li"><p>The audio queue to start.</p></li><li class="li"><p>Uses <code>NULL</code> to indicate that the audio queue should start playing immediately.</p></li><li class="li"><p>Polls the custom structure’s <code>mIsRunning</code> field regularly to check if the audio queue has stopped.</p></li><li class="li"><p>The <code><a href="../../../../CoreFoundation/Reference/CFRunLoopRef/Reference/reference.html#//apple_ref/doc/c_ref/CFRunLoopRunInMode" target="_top">CFRunLoopRunInMode</a></code> function runs the run loop that contains the audio queue’s thread.</p></li><li class="li"><p>Uses the default mode for the run loop.</p></li><li class="li"><p>Sets the run loop’s running time to <code>0.25</code> seconds.</p></li><li class="li"><p>Uses <code>false</code> to indicate that the run loop should continue for the full time specified.</p></li><li class="li"><p>After the audio queue has stopped, runs the run loop a bit longer to ensure that the audio queue buffer currently playing has time to finish.</p></li></ol><a name="//apple_ref/doc/uid/TP40005343-CH3-DontLinkElementID_13" title="Clean Up After Playing"></a><h2>Clean Up After Playing</h2><p>When you’re finished playing a file, dispose of the audio queue, close the audio file, and free any remaining resources. <span class="content_text">Listing 3-18</span> illustrates these steps.</p><a name="//apple_ref/doc/uid/TP40005343-CH3-SW10" title="Listing 3-18Cleaning up after playing an audio file"></a><p class="codesample"><strong>Listing 3-18&nbsp;&nbsp;</strong>Cleaning up after playing an audio file</p><div class="codesample"><table><tr><td scope="row"><pre>AudioQueueDispose (                            // 1<span></span></pre></td></tr><tr><td scope="row"><pre>    aqData.mQueue,                             // 2<span></span></pre></td></tr><tr><td scope="row"><pre>    true                                       // 3<span></span></pre></td></tr><tr><td scope="row"><pre>);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>AudioFileClose (aqData.mAudioFile);            // 4<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>free (aqData.mPacketDescs);                    // 5<span></span></pre></td></tr></table></div>	<p>Here’s how this code works:</p><ol class="ol"><li class="li"><p>The <code><a href="../../../Reference/AudioQueueReference/Reference/reference.html#//apple_ref/doc/c_ref/AudioQueueDispose" target="_top">AudioQueueDispose</a></code> function disposes of the audio queue and all of its resources, including its buffers.</p></li><li class="li"><p>The audio queue you want to dispose of.</p></li><li class="li"><p>Use <code>true</code> to dispose of the audio queue synchronously.</p></li><li class="li"><p>Closes the audio file that was played. The <code><a href="../../../Reference/AudioFileConvertRef/Reference/reference.html#//apple_ref/doc/c_ref/AudioFileClose" target="_top">AudioFileClose</a></code> function is declared in the <code>AudioFile.h</code> header file.</p></li><li class="li"><p>Releases the memory that was used to hold the packet descriptions.</p></li></ol><!-- <Section><Name>Implementing a Property Listener Callback Function</Name><Para>You can implement a property listener callback function that is called when a specified property changes value. In this case, you are looking for a change in the <codeVoice xml:space="preserve">kAudioQueueProperty_IsRunning</codeVoice> property. If you name your function <codeVoice xml:space="preserve">MyAudioQueuePropertyListenerProc</codeVoice>, you would declare it, as shown in <xName-No-Link DestinationChapterID="CH3" Id="SW4" targetElementType="CodeListing">“Deriving a playback audio queue buffer size”</xName-No-Link>, to send you an <codeVoice xml:space="preserve">isRunning</codeVoice> notification with a value of <codeVoice xml:space="preserve">false</codeVoice> when audio playback stops. Then you call <codeVoice xml:space="preserve">AudioQueueGetProperty</codeVoice> to register for the the notification.</Para><CodeListing XRefSourceID="SW5"><Name>Determining when an audio queue stops</Name><CodeLines-Full><CodeLine xml:space="preserve"> MyAudioQueuePropertyListenerProc (  </CodeLine><CodeLine xml:space="preserve">      void *inUserData,</CodeLine><CodeLine xml:space="preserve">      AudioQueueRef inAQ,</CodeLine><CodeLine xml:space="preserve">      AudioQueuePropertyID inID)</CodeLine><CodeLine xml:space="preserve">{</CodeLine><CodeLine xml:space="preserve">    UInt32 size = sizeof(gIsRunning);</CodeLine><CodeLine xml:space="preserve">    AudioQueueGetProperty (</CodeLine><CodeLine xml:space="preserve">      inAQ, </CodeLine><CodeLine xml:space="preserve">      kAudioQueueProperty_IsRunning,</CodeLine><CodeLine xml:space="preserve">      &amp;gIsRunning,</CodeLine><CodeLine xml:space="preserve">      &amp;size</CodeLine><CodeLine xml:space="preserve">    );</CodeLine><CodeLine xml:space="preserve">}</CodeLine></CodeLines-Full></CodeListing><Para>You assign your property listener callback when calling <codeVoice xml:space="preserve">AudioQueueAddPropertyListener</codeVoice>. For details on this function, see <bookName>Audio Queue Services Reference</bookName>.</Para><Para>In your property listener callback:</Para><List-Bullet><Item><Para>Define (in the <codeVoice xml:space="preserve">inUserData</codeVoice> parameter) a pointer to the data specified in the <codeVoice xml:space="preserve">inUserData</codeVoice> parameter of <codeVoice xml:space="preserve">AudioQueueAddPropertyListener</codeVoice>. </Para></Item><Item><Para>Specify (in the <codeVoice xml:space="preserve">inAQ</codeVoice> parameter) the audio queue that invoked the callback.</Para></Item><Item><Para> Specify (in the <codeVoice xml:space="preserve">inID</codeVoice> parameter) the ID of the property that invoked the callback. </Para></Item></List-Bullet><Para>In the <codeVoice xml:space="preserve">AudioQueueGetProperty</codeVoice> function: </Para><List-Bullet><Item><Para>Specify (in the <codeVoice xml:space="preserve">inAQ</codeVoice> parameter) the audio queue whose <codeVoice xml:space="preserve">AudioQueueProperty_IsRunning </codeVoice>property value you want to obtain.</Para></Item><Item><Para>Specify the ID of <codeVoice xml:space="preserve">AudioQueueProperty_IsRunning</codeVoice>. </Para></Item><Item><Para>Provide (in the <codeVoice xml:space="preserve">&amp;gIsRunning</codeVoice> parameter) a pointer to the size of the property data. On input, it points to the maximum number of bytes of space the caller expects to receive. </Para></Item></List-Bullet><Para>On return, the <codeVoice xml:space="preserve">&amp;gIsRunning</codeVoice> parameter points to the desired property value.</Para></Section> -->

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../AQRecord/RecordingAudio.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../RevisionHistory.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2007 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2007-10-31<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/MusicAudio/Conceptual/AudioQueueProgrammingGuide/AQPlayback/PlayingAudio.html%3Fid%3DTP40005343-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/MusicAudio/Conceptual/AudioQueueProgrammingGuide/AQPlayback/PlayingAudio.html%3Fid%3DTP40005343-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/MusicAudio/Conceptual/AudioQueueProgrammingGuide/AQPlayback/PlayingAudio.html%3Fid%3DTP40005343-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>