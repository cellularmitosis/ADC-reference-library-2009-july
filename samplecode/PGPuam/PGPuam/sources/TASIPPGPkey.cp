//	TASIPPGPkey.cp - AppleShare PGP Key Object  // // Apple Macintosh Developer Technical Support// Written by:  Vinnie Moscaritolo////  Copyright (work in progress)  Apple Computer, Inc All rights reserved.//// You may incorporate this sample code into your applications without// restriction, though the sample code has been provided "AS IS" and the// responsibility for its operation is 100% yours.  However, what you are// not permitted to do is to redistribute the source as "DSC Sample Code"// after having made changes. If you're going to re-distribute the source,// we require that you make it clear in the source that the code was// descended from Apple Sample Code, but that you've made changes.// #include <string.h>#include "TASIPPGPkey.h"#include "TPGPException.h"// ---------------------------------------------------------------------------void TASIPPGPkey::Initialize(const unsigned char* serverSigBuf)// ---------------------------------------------------------------------------{	 	PGPFilterRef	theFilter 		= kInvalidPGPFilterRef;	PGPKeyIterRef	theIterator 	= kInvalidPGPKeyIterRef;	PGPKeyListRef	theKeyListRef 	= kInvalidPGPKeyListRef;	PGPKeyRef		bestKey		 	= kInvalidPGPKeyRef;	PGPKeyRef		expiredKey		 = kInvalidPGPKeyRef;	PGPKeyRef		aKey		 	= kInvalidPGPKeyRef;	PGPKeySetRef	newKeySet 		= NULL;	PGPUInt32 		numKeys;		const 	char hexDigit[] = "0123456789ABCDEF"; 	char	*p;	int		strIndex;// calculate server name  	strcpy(fNameString, "asip:"); 	p = &fNameString[5];  	for(strIndex = 0 ; strIndex < 16 ; strIndex++)	{		*p++ = hexDigit[serverSigBuf[strIndex]>>4];		*p++ = hexDigit[serverSigBuf[strIndex]&0xF];	};	*p = '\0';  	// Find key in database  	ThrowIfPGPErr( PGPNewUserIDEmailFilter(fgContext,fNameString, kPGPMatchEqual, &theFilter));	ThrowIfPGPErr( PGPFilterKeySet(fgPGPKeySetRef , theFilter, &newKeySet));	PGPFreeFilter(theFilter);	ThrowIfPGPErr( PGPOrderKeySet(newKeySet,kPGPAnyOrdering, &theKeyListRef));	ThrowIfPGPErr( PGPNewKeyIter( theKeyListRef, &theIterator ));	 	ThrowIfPGPErr( PGPCountKeys(newKeySet, &numKeys));	if(numKeys > 0) 	{		Boolean canVerify, isExpired;		while(IsntPGPError (PGPKeyIterNext( theIterator, &aKey ))) 		{ 			ThrowIfPGPErr( PGPGetKeyBoolean (aKey, kPGPKeyPropCanVerify,  &canVerify)); 			ThrowIfPGPErr( PGPGetKeyBoolean (aKey, kPGPKeyPropIsExpired,  &isExpired));						if(canVerify)				if(!isExpired) bestKey = aKey;				else expiredKey = aKey;  		}     	if ( PGPKeyRefIsValid( bestKey ) ) TPGPkey::Initialize( bestKey );  	else if (PGPKeyRefIsValid(expiredKey) ) TPGPkey::Initialize( expiredKey );  	}  	    PGPFreeKeyIter(theIterator );	PGPFreeKeyList(theKeyListRef );	PGPFreeKeySet(newKeySet ); }// ---------------------------------------------------------------------------void TASIPPGPkey::GetKeyNamePString(StringPtr buf)// ---------------------------------------------------------------------------{	if(buf)	{		memcpy(fNameString, &buf[1], strlen(fNameString));		buf[0] = strlen(fNameString);	} }