<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>Core Data Programming Guide: Mac OS X v10.4: Non-Standard Persistent Attributes</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Mac OS X v10.4: Non-Standard Persistent Attributes"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP40006648" title="Mac OS X v10.4: Non-Standard Persistent Attributes"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../index.html#//apple_ref/doc/uid/TP30000440-TP30000416" target="_top">Cocoa</a> &gt; <a href="../../../DesignGuidelines-date.html#//apple_ref/doc/uid/TP30000440-TP30000416-TP30000556" target="_top">Design Guidelines</a> &gt; <a href="../index.html" target="_top">Core Data Programming Guide</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="cdZ104Accessors.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="cdZ104Versioning.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>
        
        
        <a name="//apple_ref/doc/uid/TP40006648-SW1" title="Mac OS X v10.4: Non-Standard Persistent Attributes"></a><hr /><H1>Mac OS X v10.4: Non-Standard Persistent Attributes</H1><p>On Mac OS X v10.5, Core Data provides transformable attributes to make it easy to use non-standard attribute types. For the benefit of developers who need to develop for earlier releases, this article describes how to support non-standard attribute types on Mac OS X v10.4.</p><p>Core Data supports a range of common types for values of persistent attributes, including string, date, and number. Sometimes, however, you want an attribute's value to be a type that is not supported directly. For example, in a graphics application you might want to define a Rectangle entity that has attributes <code>color</code> and <code>bounds</code> that are an instance of <code>NSColor</code> and an <code>NSRect</code> struct respectively. This article how you can use non-standard attribute types by using a transient property to represent the non-standard attribute backed by a supported persistent property. </p>
<!-- This template is being used for both PDF and HTML. -->

    
    <!-- TopicBook.pm uses this template for its miniTOCs, but needs a different title. -->
    <h4>Contents:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="cdZ104NSAttributes.html#//apple_ref/doc/uid/TP40006648-SW2">Introduction</a>
				
			<br/>
			
        
			
			
				<a href="cdZ104NSAttributes.html#//apple_ref/doc/uid/TP40006648-SW5">The Persistent Attribute</a>
				
			<br/>
			
        
			
			
				<a href="cdZ104NSAttributes.html#//apple_ref/doc/uid/TP40006648-SW6">An Object Attribute</a>
				
			<br/>
			
        
			
			
				<a href="cdZ104NSAttributes.html#//apple_ref/doc/uid/TP40006648-SW11">A Non-Object Attribute</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP40006648-SW2" title="Introduction"></a><h2>Introduction</h2><p>Persistent attributes must be of a type recognized by the Core Data framework so that they can be properly stored to and retrieved from a persistent store. Core Data provides support for a range of common types for persistent attribute values, including string, date, and number (see <code><a href="../../../Reference/CoreDataFramework/Classes/NSAttributeDescription_Class/Reference/Reference.html#//apple_ref/occ/cl/NSAttributeDescription" target="_top">NSAttributeDescription</a></code> for full details). Sometimes, however, you want to use types that are not supported directly, such as colors and C structures. </p><p>You can use non-standard types for persistent attributes by using a <em>transient</em> property to represent the non-standard attribute backed by a supported persistent property. You present to consumers of your entity an attribute of the type you want, and “behind the scenes” it’s converted into a type that Core Data can manage. You use a transient property to represent the non-standard attribute and write code to convert it to a standard persistent property.</p><p>The following sections illustrate implementations for object and scalar values. Both start, however, with a common task—you must specify a persistent attribute.</p><a name="//apple_ref/doc/uid/TP40006648-SW3" title="Basic Approach"></a><h3>Basic Approach</h3><p>To use non-supported types, in the managed object model you define two attributes. One is the attribute you actually want (its value is for example a color object or a rectangle struct). This attribute is transient. The other is a "shadow" representation of that attribute. This attribute is persistent. You specify the type of the transient attribute as undefined ( <code><a href="../../../Reference/CoreDataFramework/Classes/NSAttributeDescription_Class/Reference/Reference.html#//apple_ref/doc/c_ref/NSUndefinedAttributeType" target="_top">NSUndefinedAttributeType</a></code> ). The type of the shadow attribute must be one of the "concrete" supported types. You then implement a custom managed object class with suitable accessor methods for the transient attribute that retrieve the value from and store the value to the persistent attribute. The basic approach for object and scalar values is the same—you must find a way to represent the unsupported data type as one of the supported data types—however there is a further constraint in the case of scalar values.</p><a name="//apple_ref/doc/uid/TP40006648-SW4" title="Scalar Value Constraints"></a><h3>Scalar Value Constraints</h3><p>A requirement of the accessor methods you write is that they must be key-value coding (and key-value observing) compliant. Key-value coding only supports a limited number of structures—<code>NSPoint</code>, <code>NSSize</code>, <code>NSRect</code>, and <code>NSRange</code>. </p><p>If you want to use a scalar type or structure that is not one of those supported directly by Core Data and not one of the structures supported by key-value coding, you must store it in your managed object as an object—typically an <code>NSValue</code> instance, although you can also define your own custom class. You will then treat it as an object value as described later in this article. It is up to users of the object to extract the required structure from the <code>NSValue</code> (or custom) object when retrieving the value, and to transform a structure into an <code>NSValue</code> (or custom) object when setting the value.</p><a name="//apple_ref/doc/uid/TP40006648-SW5" title="The Persistent Attribute"></a><h2>The Persistent Attribute</h2><p>For any non-standard attribute type you want to use, you must choose a supported attribute type that you will use to store the value. Which supported type you choose depends on the non-standard type and what means there are of transforming it into a supported type. In many cases you can easily transform a non-supported object into an <code>NSData</code> object using an archiver. For example, you can archive a color object as shown in the following code sample. The same technique can be used if you represent the attribute as an instance of <code>NSValue</code> or of a custom class (note that your custom class would, of course, need to adopt the <code>NSCoding</code> protocol or provide some other means of being transformed into a supported data type).</p><div class="codesample"><table><tr><td scope="row"><pre>NSData *colorAsData = [NSKeyedArchiver archivedDataWithRootObject:aColor];<span></span></pre></td></tr></table></div><p>You are free to use whatever means you wish to effect the transformation. For example, you could transform an <code>NSRect</code> structure into a string object (strings can of course be used in a persistent store).</p><div class="codesample"><table><tr><td scope="row"><pre>NSRect aRect; // instance variable<span></span></pre></td></tr><tr><td scope="row"><pre>NSString *rectAsString = NSStringFromRect(aRect);<span></span></pre></td></tr></table></div><p>You can transform the string back into a rectangle using <code>NSRectFromString</code>. You should bear in mind, however, that since the transformation process may happen frequently, you should ensure that it is as efficient as possible.</p><p>Typically you do not need to implement custom accessor methods for the persistent attribute. It is an implementation detail, the value should not be accessed other than by the entity itself. If you do modify this value directly, it is possible that the entity object will get into an inconsistent state.</p><a name="//apple_ref/doc/uid/TP40006648-SW6" title="An Object Attribute"></a><h2>An Object Attribute</h2><p>If the non-supported attribute is an object, then in the managed object model you specify its type as undefined, and that it is transient. When you implement the entity’s custom class, there is no need to add an instance variable for the attribute—you can use the managed object's private internal store. A point to note about the implementations described below is that they cache the transient value. This makes accessing the value more efficient—it is also necessary for change management.</p><p>There are two strategies both for getting and for setting the transient value. You can retrieve the transient value either "lazily" (on demand—described in <span class="content_text"><a href="cdNSAttributes.html#//apple_ref/doc/uid/TP40001919-SW2">“The On-demand Get Accessor”</a></span>) or during awakeFromFetch (described in <span class="content_text"><a href="cdNSAttributes.html#//apple_ref/doc/uid/TP40001919-SW3">“The Pre-calculated Get”</a></span>). It may be preferable to retrieve it lazily if the value may be large (if for example it is a bitmap). For the persistent value, you can either update it every time the transient value is changed (described in <span class="content_text"><a href="cdNSAttributes.html#//apple_ref/doc/uid/TP40001919-SW4">“The Immediate-Update Set Accessor”</a></span>), or you can defer the update until the object is saved (described in <span class="content_text"><a href="cdNSAttributes.html#//apple_ref/doc/uid/TP40001919-SW5">“The Delayed-Update Set Accessor”</a></span>).</p><a name="//apple_ref/doc/uid/TP40006648-SW7" title="The On-demand Get Accessor"></a><h3>The On-demand Get Accessor</h3><p>In the get accessor, you retrieve the attribute value from the managed object's private internal store. If the value is <code>nil</code>, then it is possible it has not yet been cached, so you retrieve the corresponding persistent value, then if that value is not <code>nil</code>, transform it into the appropriate type and cache it. The following example illustrates the on-demand get accessor for a color attribute.</p><div class="codesample"><table><tr><td scope="row"><pre>- (NSColor *)color<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    [self willAccessValueForKey:@"color"];<span></span></pre></td></tr><tr><td scope="row"><pre>    NSColor *color = [self primitiveValueForKey:@"color"];<span></span></pre></td></tr><tr><td scope="row"><pre>    [self didAccessValueForKey:@"color"];<span></span></pre></td></tr><tr><td scope="row"><pre>    if (color == nil) {<span></span></pre></td></tr><tr><td scope="row"><pre>        NSData *colorData = [self valueForKey:@"colorData"];<span></span></pre></td></tr><tr><td scope="row"><pre>        if (colorData != nil) {<span></span></pre></td></tr><tr><td scope="row"><pre>            color = [NSKeyedUnarchiver unarchiveObjectWithData:colorData];<span></span></pre></td></tr><tr><td scope="row"><pre>            [self setPrimitiveValue:color forKey:@"color"];<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    return color;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40006648-SW8" title="The Pre-calculated Get"></a><h3>The Pre-calculated Get</h3><p>Using this approach, you retrieve and cache the persistent value in <code>awakeFromFetch</code>.</p><div class="codesample"><table><tr><td scope="row"><pre>- (void)awakeFromFetch<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    [super awakeFromFetch];<span></span></pre></td></tr><tr><td scope="row"><pre>    NSData *colorData = [self valueForKey:@"colorData"];<span></span></pre></td></tr><tr><td scope="row"><pre>    if (colorData != nil) {<span></span></pre></td></tr><tr><td scope="row"><pre>        NSColor *color;<span></span></pre></td></tr><tr><td scope="row"><pre>        color = [NSKeyedUnarchiver unarchiveObjectWithData:colorData];<span></span></pre></td></tr><tr><td scope="row"><pre>        [self setPrimitiveValue:color forKey:@"color"];<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>In the get accessor you then simply return the cached value.</p><div class="codesample"><table><tr><td scope="row"><pre>- (NSColor *)color<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    [self willAccessValueForKey:@"color"];<span></span></pre></td></tr><tr><td scope="row"><pre>    NSColor *color = [self primitiveValueForKey:@"color"];<span></span></pre></td></tr><tr><td scope="row"><pre>    [self didAccessValueForKey:@"color"];<span></span></pre></td></tr><tr><td scope="row"><pre>    return color;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>This technique is useful if you are likely to access the attribute frequently—you avoid the conditional statement in the get accessor.</p><a name="//apple_ref/doc/uid/TP40006648-SW9" title="The Immediate-Update Set Accessor"></a><h3>The Immediate-Update Set Accessor</h3><p>In this set accessor, you set the value for both the transient and the persistent attributes at the same time. You transform the unsupported type into the supported type to set as the persistent value. You must ensure that you invoke the key-value observing change notification methods, so that objects observing the managed object—including the managed object context—are notified of the modification. The following example illustrates the set accessor for a color attribute.</p><div class="codesample"><table><tr><td scope="row"><pre>- (void)setColor:(NSColor *)aColor<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    [self willChangeValueForKey:@"color"];<span></span></pre></td></tr><tr><td scope="row"><pre>    [self setPrimitiveValue:aColor forKey:@"color"];<span></span></pre></td></tr><tr><td scope="row"><pre>    [self didChangeValueForKey:@"color"];<span></span></pre></td></tr><tr><td scope="row"><pre>    [self setValue:[NSKeyedArchiver archivedDataWithRootObject:aColor]<span></span></pre></td></tr><tr><td scope="row"><pre>                forKey:@"colorData"];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>The main disadvantage with this approach is that the persistent value is recalculated each time the transient value is updated, which may be a performance issue.</p><a name="//apple_ref/doc/uid/TP40006648-SW10" title="The Delayed-Update Set Accessor"></a><h3>The Delayed-Update Set Accessor</h3><p>In this technique, in the set accessor you only set the value for the transient attribute. You implement a <code>willSave</code> method that updates the persistent value just before the object is saved.</p><div class="codesample"><table><tr><td scope="row"><pre>- (void)setColor:(NSColor *)aColor<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    [self willChangeValueForKey:@"color"];<span></span></pre></td></tr><tr><td scope="row"><pre>    [self setPrimitiveValue:aColor forKey:@"color"];<span></span></pre></td></tr><tr><td scope="row"><pre>    [self didChangeValueForKey:@"color"];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (void)willSave<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    NSColor *color = [self primitiveValueForKey:@"color"];<span></span></pre></td></tr><tr><td scope="row"><pre>    if (color != nil) {<span></span></pre></td></tr><tr><td scope="row"><pre>        [self setPrimitiveValue:[NSKeyedArchiver archivedDataWithRootObject:color]<span></span></pre></td></tr><tr><td scope="row"><pre>                forKey:@"colorData"];<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    else {<span></span></pre></td></tr><tr><td scope="row"><pre>        [self setPrimitiveValue:nil forKey:@"colorData"];<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    [super willSave];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>If you adopt this approach, you must take care when specifying your optionality rules. If color is a required attribute, then (unless you take other steps) you must specify the color attribute as not optional, and the color data attribute as optional. If you do not, then the first save operation may generate a validation error.</p><p>When the object is first created, the value of <code>colorData</code> is <code>nil</code>. When you update the color attribute, the <code>colorData</code> attribute is unaffected (that is, it remains <code>nil</code> ). When you save, <code>validateForUpdate:</code> is invoked before <code>willSave</code>. In the validation stage, the value of <code>colorData</code> is still <code>nil</code>, and therefore validation fails. </p><a name="//apple_ref/doc/uid/TP40006648-SW11" title="A Non-Object Attribute"></a><h2>A Non-Object Attribute</h2><p>If the non-supported attribute is one of the structures supported by key-value coding (<code>NSPoint</code>, <code>NSSize</code>, <code>NSRect</code>, or <code>NSRange</code>), then in the managed object model you again specify its type as undefined, and that it is transient. When you implement the entity’s custom class, you typically add an instance variable for the attribute. For example, given an attribute called <code>bounds</code> that you want to represent using an <code>NSRect</code> structure, your class interface might be like that shown in the following example.</p><div class="codesample"><table><tr><td scope="row"><pre>@interface MyManagedObject : NSManagedObject<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    NSRect bounds;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre>- (NSRect)bounds;<span></span></pre></td></tr><tr><td scope="row"><pre>- (void)setBounds:(NSRect)aRect;<span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr></table></div><p>Alternatively, if you want to give the instance variable a name other than the name of the attribute, you should also implement primitive get and set accessors (see <span class="content_text"><a href="cdAccessorMethods.html#//apple_ref/doc/uid/TP40002154-SW5">“Custom Primitive Accessor Methods”</a></span>), as shown in the following example.</p><div class="codesample"><table><tr><td scope="row"><pre>@interface MyManagedObject : NSManagedObject<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    NSRect myBounds;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre>- (NSRect)primitiveBounds;<span></span></pre></td></tr><tr><td scope="row"><pre>- (void)setPrimitiveBounds:(NSRect)aRect;<span></span></pre></td></tr><tr><td scope="row"><pre>- (NSRect)bounds;<span></span></pre></td></tr><tr><td scope="row"><pre>- (void)setBounds:(NSRect)aRect;<span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr></table></div><p>The primitive methods simply get and set the instance variable—they do not invoke key-value observing change or access notification methods—as shown in the following example.</p><div class="codesample"><table><tr><td scope="row"><pre>- (NSRect)primitiveBounds<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    return myBounds;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre>- (void)setPrimitiveBounds:(NSRect)aRect<span></span></pre></td></tr><tr><td scope="row"><pre>    myBounds = aRect;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>Whichever strategy you adopt, you then implement accessor methods mostly as described for the object value. For the get accessor you can adopt either the lazy or pre-calculated technique, and for the set accessor you can adopt either the immediate update or delayed update technique. The following sections illustrate only the former versions of each.</p><a name="//apple_ref/doc/uid/TP40006648-SW12" title="The Get Accessor"></a><h3>The Get Accessor</h3><p>In the get accessor, you retrieve the attribute value from the managed object's private internal store. If the value has not yet been set, then it is possible it has not yet been cached, so you retrieve the corresponding persistent value, then if that value is not <code>nil</code>, transform it into the appropriate type and cache it. The following example illustrates the get accessor for a rectangle (this example makes a simplifying assumption that the bounds width cannot be <code>0</code>, so if the value is <code>0</code> then the bounds has not yet been unarchived).</p><div class="codesample"><table><tr><td scope="row"><pre>- (NSRect)bounds<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    [self willAccessValueForKey:@"bounds"];<span></span></pre></td></tr><tr><td scope="row"><pre>    NSRect aRect = bounds;<span></span></pre></td></tr><tr><td scope="row"><pre>    [self didAccessValueForKey:@"bounds"];<span></span></pre></td></tr><tr><td scope="row"><pre>    if (aRect.size.width == 0) {<span></span></pre></td></tr><tr><td scope="row"><pre>        NSString *boundsAsString = [self boundsAsString];<span></span></pre></td></tr><tr><td scope="row"><pre>        if (boundsAsString != nil) {<span></span></pre></td></tr><tr><td scope="row"><pre>            bounds = NSRectFromString(boundsAsString);<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    return bounds;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40006648-SW13" title="The Set Accessor"></a><h3>The Set Accessor</h3><p>In the set accessor, you must set the value for both the transient and the persistent attributes. You transform the unsupported type into the supported type to set as the persistent value. You must ensure that you invoke the key-value observing change notification methods, so that objects observing the managed object—including the managed object context—are notified of the modification. The following example illustrates the set accessor for a rectangle.</p><div class="codesample"><table><tr><td scope="row"><pre>- (void)setBounds:(NSRect)aRect<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    [self willChangeValueForKey:@"bounds"];<span></span></pre></td></tr><tr><td scope="row"><pre>    bounds = aRect;<span></span></pre></td></tr><tr><td scope="row"><pre>    [self didChangeValueForKey:@"bounds"];<span></span></pre></td></tr><tr><td scope="row"><pre>    NSString *rectAsString = NSStringFromRect(aRect);<span></span></pre></td></tr><tr><td scope="row"><pre>    [self setValue:rectAsString forKey:@"boundsAsString"]; }<span></span></pre></td></tr></table></div>

        <br/><br/> 

        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="cdZ104Accessors.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="cdZ104Versioning.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2004, 2009 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2009-03-04<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Cocoa/Conceptual/CoreData/Articles/cdZ104NSAttributes.html%3Fid%3DTP40001075-5.6&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Cocoa/Conceptual/CoreData/Articles/cdZ104NSAttributes.html%3Fid%3DTP40001075-5.6&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Cocoa/Conceptual/CoreData/Articles/cdZ104NSAttributes.html%3Fid%3DTP40001075-5.6&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>
