<html><head><title>Mac OS X
 Manual Page For MIME::Tools(3pm)</title>
<style type="text/css"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { font-size: 1px; background: #ffffff; color: #ffffff; } --></style>
<style type="text/css" media="print, aural, braille, embossed, projection, tty"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { display: none; } --></style>
</head><body bgcolor="white">
<a name="//apple_ref/doc/man/3pm/MIME::Tools" title="Mac OS X
 Manual Page for MIME::Tools(3pm)"><a name="//apple_ref/doc/man/3/MIME::Tools" title="Mac OS X
 Manual Page for MIME::Tools(3pm)"><!-- headerDoc=man; indexgroup=Section 3pm; uid="//apple_ref/doc/man/3pm/MIME::Tools"; name=MIME::Tools(3pm) --></a>
<!--#include virtual="/includes/framesetheader"-->
<table width=600><tr><td scope="row">
<!-- begin breadcrumb insert request --><font face="Geneva,Helvetica,Arial" size="1">
 <a target="_top" href="http://developer.apple.com">ADC Home</a> <b>&gt;</b> <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> <b>&gt;</b> <a href="../../../../../reference/index.html#//apple_ref/doc/uid/TP30001281" target="_top">Reference</a> <b>&gt;</b> <!-- a href="" target="_top" -->Mac OS X<!-- /a --> <b>&gt;</b> <a href="../index.html#//apple_ref/doc/framework/manpages" target="_top">Mac OS X Man Pages</a></font>
<!-- end breadcrumb insert request -->
<p>&nbsp;</p>
</td></tr></table>
<!-- end of header -->
<table border="0"  cellpadding="2" cellspacing="2" width="630pt"><tr><td valign="top" height="12" colspan="5" scope="row">
<p style='text-align:justify;'>This document is a Mac OS X manual page.  Manual pages are a command-line technology
for providing documentation.  You can view these manual pages locally using the
<a href="../man1/man.1.html#//apple_ref/doc/man/1/man">man(1)</a> command.
These manual pages come from many different sources, and thus, have a variety of writing
styles.</p>
<p style='text-align:justify;'>For more information about the manual page format, see the manual page for 
<a href="../man5/manpages.5.html#//apple_ref/doc/man/5/manpages">manpages(5)</a>.</p>
</td></tr></table>
<hr />
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row"><pre class="manpages"><tt>
MIME::Tools(3)                       User Contributed Perl Documentation                      MIME::Tools(3)



<b>NAME</b>
       MIME-tools - modules for parsing (and creating!) MIME entities

<b>SYNOPSIS</b>
       Here's some pretty basic code for <b>parsing</b> <b>a</b> <b>MIME</b> <b>message,</b> and outputting its decoded components to a
       given directory:

           use MIME::Parser;

           ### Create parser, and set some parsing options:
           my $parser = new MIME::Parser;
           $parser-&gt;output_under("$ENV{HOME}/mimemail");

           ### Parse input:
           $entity = $parser-&gt;parse(\*STDIN) or die "parse failed\n";

           ### Take a look at the top-level entity (and any parts it has):
           $entity-&gt;dump_skeleton;

       Here's some code which <b>composes</b> <b>and</b> <b>sends</b> <b>a</b> <b>MIME</b> <b>message</b> containing three parts: a text file, an
       attached GIF, and some more text:

           use MIME::Entity;

           ### Create the top-level, and set up the mail headers:
           $top = MIME::Entity-&gt;build(Type    =&gt;"multipart/mixed",
                                      From    =&gt; "me\@myhost.com",
                                      To      =&gt; "you\@yourhost.com",
                                      Subject =&gt; "Hello, nurse!");

           ### Part #1: a simple text document:
           $top-&gt;attach(Path=&gt;"./testin/short.txt");

           ### Part #2: a GIF file:
           $top-&gt;attach(Path        =&gt; "./docs/mime-sm.gif",
                        Type        =&gt; "image/gif",
                        Encoding    =&gt; "base64");

           ### Part #3: some literal text:
           $top-&gt;attach(Data=&gt;$message);

           ### Send it:
           open MAIL, "| /usr/lib/sendmail -t -oi -oem" or die "open: $!";
           $top-&gt;print(\*MAIL);
           close MAIL;

       For more examples, look at the scripts in the <b>examples</b> directory of the MIME-tools distribution.

<b>DESCRIPTION</b>
       MIME-tools is a collection of Perl5 MIME:: modules for parsing, decoding, <u>and</u> <u>generating</u> single- or
       multipart (even nested multipart) MIME messages.  (Yes, kids, that means you can send messages with
       attached GIF files).

<b>REQUIREMENTS</b>
       You will need the following installed on your system:

               File::Path
               File::Spec
               IPC::Open2              (optional)
               IO::Scalar, ...         from the IO-stringy distribution
               MIME::Base64
               MIME::QuotedPrint
               Net::SMTP
               Mail::Internet, ...     from the MailTools distribution.

       See the Makefile.PL in your distribution for the most-comprehensive list of prerequisite modules and
       their version numbers.

<b>A</b> <b>QUICK</b> <b>TOUR</b>
       <b>Overview</b> <b>of</b> <b>the</b> <b>classes</b>

       Here are the classes you'll generally be dealing with directly:

           (START HERE)            results() .-----------------.
                 \                 .--------&gt;| MIME::          |
                  .-----------.   /          | Parser::Results |
                  | MIME::    |--'           `-----------------'
                  | Parser    |--.           .-----------------.
                  `-----------'   \ filer()  | MIME::          |
                     | parse()     `--------&gt;| Parser::Filer   |
                     | gives you             `-----------------'
                     | a...                                  | output_path()
                     |                                       | determines
                     |                                       | path() of...
                     |    head()       .--------.            |
                     |    returns...   | MIME:: | get()      |
                     V       .--------&gt;| Head   | etc...     |
                  .--------./          `--------'            |
            .---&gt; | MIME:: |                                 |
            `-----| Entity |           .--------.            |
          parts() `--------'\          | MIME:: |           /
          returns            `--------&gt;| Body   |&lt;---------'
          sub-entities    bodyhandle() `--------'
          (if any)        returns...       | open()
                                           | returns...
                                           |
                                           V
                                       .--------. read()
                                       | IO::   | getline()
                                       | Handle | print()
                                       `--------' etc...

       To illustrate, parsing works this way:

          <b>The</b> <b>"parser"</b> <b>parses</b> <b>the</b> <b>MIME</b> <b>stream.</b>  A parser is an instance of "MIME::Parser".  You hand it an
           input stream (like a filehandle) to parse a message from: if the parse is successful, the result
           is an "entity".

          <b>A</b> <b>parsed</b> <b>message</b> <b>is</b> <b>represented</b> <b>by</b> <b>an</b> <b>"entity".</b>  An entity is an instance of "MIME::Entity" (a
           subclass of "Mail::Internet").  If the message had "parts" (e.g., attachments), then those parts
           are "entities" as well, contained inside the top-level entity.  Each entity has a "head" and a
           "body".

          <b>The</b> <b>entity's</b> <b>"head"</b> <b>contains</b> <b>information</b> <b>about</b> <b>the</b> <b>message.</b>  A "head" is an instance of
           "MIME::Head" (a subclass of "Mail::Header").  It contains information from the message header:
           content type, sender, subject line, etc.

          <b>The</b> <b>entity's</b> <b>"body"</b> <b>knows</b> <b>where</b> <b>the</b> <b>message</b> <b>data</b> <b>is.</b>  You can ask to "open" this data source for
           <u>reading</u> or <u>writing</u>, and you will get back an "I/O handle".

          <b>You</b> <b>can</b> <u></u><b><u>o</u></b><u></u><b><u>e</u></b><u></u><b><u>(</u></b> <b>a</b> <b>"body"</b> <b>and</b> <b>get</b> <b>an</b> <b>"I/O</b> <b>handle"</b> <b>to</b> <b>read/write</b> <b>message</b> <b>data.</b>  This handle is an
           object that is basically like an IO::Handle or a FileHandle... it can be any class, so long as it
           supports a small, standard set of methods for reading from or writing to the underlying data
           source.

       A typical multipart message containing two parts -- a textual greeting and an "attached" GIF file --
       would be a tree of MIME::Entity objects, each of which would have its own MIME::Head.  Like this:

           .--------.
           | MIME:: | Content-type: multipart/mixed
           | Entity | Subject: Happy Samhaine!
           `--------'
                |
                `----.
               parts |
                     |   .--------.
                     |---| MIME:: | Content-type: text/plain; charset=us-ascii
                     |   | Entity | Content-transfer-encoding: 7bit
                     |   `--------'
                     |   .--------.
                     |---| MIME:: | Content-type: image/gif
                         | Entity | Content-transfer-encoding: base64
                         `--------' Content-disposition: inline;
                                      filename="hs.gif"

       <b>Parsing</b> <b>messages</b>

       You usually start by creating an instance of <b>MIME::Parser</b> and setting up certain parsing parameters:
       what directory to save extracted files to, how to name the files, etc.

       You then give that instance a readable filehandle on which waits a MIME message.  If all goes well,
       you will get back a <b>MIME::Entity</b> object (a subclass of <b>Mail::Internet</b>), which consists of...

          A <b>MIME::Head</b> (a subclass of <b>Mail::Header</b>) which holds the MIME header data.

          A <b>MIME::Body</b>, which is a object that knows where the body data is.  You ask this object to "open"
           itself for reading, and it will hand you back an "I/O handle" for reading the data: this is a
           FileHandle-like object, and could be of any class, so long as it conforms to a subset of the
           <b>IO::Handle</b> interface.

       If the original message was a multipart document, the MIME::Entity object will have a non-empty list
       of "parts", each of which is in turn a MIME::Entity (which might also be a multipart entity, etc,
       etc...).

       Internally, the parser (in MIME::Parser) asks for instances of <b>MIME::Decoder</b> whenever it needs to
       decode an encoded file.  MIME::Decoder has a mapping from supported encodings (e.g., 'base64') to
       classes whose instances can decode them.  You can add to this mapping to try out new/experiment
       encodings.  You can also use MIME::Decoder by itself.

       <b>Composing</b> <b>messages</b>

       All message composition is done via the <b>MIME::Entity</b> class.  For single-part messages, you can use
       the <b>MIME::Entity/build</b> constructor to create MIME entities very easily.

       For multipart messages, you can start by creating a top-level "multipart" entity with
       <u></u><b><u>M</u></b><u></u><b><u>M</u></b><u></u><b><u>:</u></b><u></u><b><u>E</u></b><u></u><b><u>t</u></b><u></u><b><u>t</u></b><u></u><b><u>:</u></b><u></u><b><u>b</u></b><u></u><b><u>i</u></b><u></u><b><u>d</u></b><u></u><b><u>)</u></b>, and then use the similar <u></u><b><u>M</u></b><u></u><b><u>M</u></b><u></u><b><u>:</u></b><u></u><b><u>E</u></b><u></u><b><u>t</u></b><u></u><b><u>t</u></b><u></u><b><u>:</u></b><u></u><b><u>a</u></b><u></u><b><u>t</u></b><u></u><b><u>c</u></b><u></u><b><u>(</u></b> method to attach parts to that
       message.  <u>Please</u> <u>note:</u> what most people think of as "a text message with an attached GIF file" is
       <u>really</u> a multipart message with 2 parts: the first being the text message, and the second being the
       GIF file.

       When building MIME a entity, you'll have to provide two very important pieces of information: the
       <u>content</u> <u>type</u> and the <u>content</u> <u>transfer</u> <u>encoding</u>.  The type is usually easy, as it is directly
       determined by the file format; e.g., an HTML file is "text/html".  The encoding, however, is
       trickier... for example, some HTML files are "7bit"-compliant, but others might have very long lines
       and would need to be sent "quoted-printable" for reliability.

       See the section on encoding/decoding for more details, as well as "A MIME PRIMER".

       <b>Sending</b> <b>email</b>

       Since MIME::Entity inherits directly from Mail::Internet, you can use the normal Mail::Internet
       mechanisms to send email.  For example,

           $entity-&gt;smtpsend;

       <b>Encoding/decoding</b> <b>support</b>

       The <b>MIME::Decoder</b> class can be used to <u>encode</u> as well; this is done when printing MIME entities.  All
       the standard encodings are supported (see "A MIME PRIMER" for details):

           Encoding:        | Normally used when message contents are:
           -------------------------------------------------------------------<font color="#ffffff" class="whiteout">7bit&nbsp;------------------------------------------------------------------7bit</font>
           7bit             | 7-bit data with under 1000 chars/line, or multipart.
           8bit             | 8-bit data with under 1000 chars/line.
           binary           | 8-bit data with some long lines (or no line breaks).
           quoted-printable | Text files with some 8-bit chars (e.g., Latin-1 text).
           base64           | Binary files.

       Which encoding you choose for a given document depends largely on (1) what you know about the
       document's contents (text vs binary), and (2) whether you need the resulting message to have a
       reliable encoding for 7-bit Internet email transport.

       In general, only "quoted-printable" and "base64" guarantee reliable transport of all data; the other
       three "no-encoding" encodings simply pass the data through, and are only reliable if that data is
       7bit ASCII with under 1000 characters per line, and has no conflicts with the multipart boundaries.

       I've considered making it so that the content-type and encoding can be automatically inferred from
       the file's path, but that seems to be asking for trouble... or at least, for Mail::Cap...

       <b>Message-logging</b>

       MIME-tools is a large and complex toolkit which tries to deal with a wide variety of external input.
       It's sometimes helpful to see what's really going on behind the scenes.  There are several kinds of
       messages logged by the toolkit itself:

       Debug messages
           These are printed directly to the STDERR, with a prefix of "MIME-tools: debug".

           Debug message are only logged if you have turned "debugging" on in the MIME::Tools configuration.

       Warning messages
           These are logged by the standard Perl <u>warn()</u> mechanism to indicate an unusual situation.  They
           all have a prefix of "MIME-tools: warning".

           Warning messages are only logged if $^W is set true and MIME::Tools is not configured to be
           "quiet".

       Error messages
           These are logged by the standard Perl <u>warn()</u> mechanism to indicate that something actually
           failed.  They all have a prefix of "MIME-tools: error".

           Error messages are only logged if $^W is set true and MIME::Tools is not configured to be
           "quiet".

       Usage messages
           Unlike "typical" warnings above, which warn about problems processing data, usage-warnings are
           for alerting developers of deprecated methods and suspicious invocations.

           Usage messages are currently only logged if $^W is set true and MIME::Tools is not configured to
           be "quiet".

       When a MIME::Parser (or one of its internal helper classes) wants to report a message, it generally
       does so by recording the message to the <b>MIME::Parser::Results</b> object immediately before invoking the
       appropriate function above.  That means each parsing run has its own trace-log which can be examined
       for problems.

       <b>Configuring</b> <b>the</b> <b>toolkit</b>

       If you want to tweak the way this toolkit works (for example, to turn on debugging), use the routines
       in the <b>MIME::Tools</b> module.

       debugging
           Turn debugging on or off.  Default is false (off).

                MIME::Tools-&gt;debugging(1);

       quiet
           Turn the reporting of warning/error messages on or off.  Default is true, meaning that these
           message are silenced.

                MIME::Tools-&gt;quiet(1);

       version
           Return the toolkit version.

                print MIME::Tools-&gt;version, "\n";

<b>THINGS</b> <b>YOU</b> <b>SHOULD</b> <b>DO</b>
       <b>Take</b> <b>a</b> <b>look</b> <b>at</b> <b>the</b> <b>examples</b>

       The MIME-Tools distribution comes with an "examples" directory.  The scripts in there are basically
       just tossed-together, but they'll give you some ideas of how to use the parser.

       <b>Run</b> <b>with</b> <b>warnings</b> <b>enabled</b>

       <u>Always</u> run your Perl script with "-w".  If you see a warning about a deprecated method, change your
       code ASAP.  This will ease upgrades tremendously.

       <b>Avoid</b> <b>non-standard</b> <b>encodings</b>

       Don't try to MIME-encode using the non-standard MIME encodings.  It's just not a good practice if you
       want people to be able to read your messages.

       <b>Plan</b> <b>for</b> <b>thrown</b> <b>exceptions</b>

       For example, if your mail-handling code absolutely must not die, then perform mail parsing like this:

           $entity = eval { $parser-&gt;parse(\*INPUT) };

       Parsing is a complex process, and some components may throw exceptions if seriously-bad things
       happen.  Since "seriously-bad" is in the eye of the beholder, you're better off <u>catching</u> possible
       exceptions instead of asking me to propagate "undef" up the stack.  Use of exceptions in reusable
       modules is one of those religious issues we're never all going to agree upon; thankfully, that's what
       "eval{}" is good for.

       <b>Check</b> <b>the</b> <b>parser</b> <b>results</b> <b>for</b> <b>warnings/errors</b>

       As of 5.3xx, the parser tries extremely hard to give you a MIME::Entity.  If there were any problems,
       it logs warnings/errors to the underlying "results" object (see MIME::Parser::Results).  Look at that
       object after each parse.  Print out the warnings and errors, <u>especially</u> if messages don't parse the
       way you thought they would.

       <b>Don't</b> <b>plan</b> <b>on</b> <b>printing</b> <b>exactly</b> <b>what</b> <b>you</b> <b>parsed!</b>

       <u>Parsing</u> <u>is</u> <u>a</u> <u>(slightly)</u> <u>lossy</u> <u>operation.</u>  Because of things like ambiguities in base64-encoding, the
       following is <u>not</u> going to spit out its input unchanged in all cases:

           $entity = $parser-&gt;parse(\*STDIN);
           $entity-&gt;print(\*STDOUT);

       If you're using MIME::Tools to process email, remember to save the data you parse if you want to send
       it on unchanged.  This is vital for things like PGP-signed email.

       <b>Understand</b> <b>how</b> <b>international</b> <b>characters</b> <b>are</b> <b>represented</b>

       The MIME standard allows for text strings in headers to contain characters from any character set, by
       using special sequences which look like this:

           =?ISO-8859-1?Q?Keld_J=F8rn_Simonsen?=

       To be consistent with the existing Mail::Field classes, MIME::Tools does <u>not</u> automatically unencode
       these strings, since doing so would lose the character-set information and interfere with the parsing
       of fields (see "decode_headers" in MIME::Parser for a full explanation).  That means you should be
       prepared to deal with these encoded strings.

       The most common question then is, <b>how</b> <b>do</b> <b>I</b> <b>decode</b> <b>these</b> <b>encoded</b> <b>strings?</b>  The answer depends on what
       you want to decode them <u>to</u>: ASCII, Latin1, UTF-8, etc.  Be aware that your "target" representation
       may not support all possible character sets you might encounter; for example, Latin1 (ISO-8859-1) has
       no way of representing Big5 (Chinese) characters.  A common practice is to represent
       "untranslateable" characters as "?"s, or to ignore them completely.

       To unencode the strings into some of the more-popular Western byte representations (e.g., Latin1,
       Latin2, etc.), you can use the decoders in MIME::WordDecoder (see MIME::WordDecoder).  The simplest
       way is by using "unmime()", a function wrapped around your "default" decoder, as follows:

           use MIME::WordDecoder;
           ...
           $subject = unmime $entity-&gt;head-&gt;get('subject');

       One place this <u>is</u> done automatically is in extracting the recommended filename for a part while
       parsing.  That's why you should start by setting up the best "default" decoder if the default target
       of Latin1 isn't to your liking.

<b>THINGS</b> <b>I</b> <b>DO</b> <b>THAT</b> <b>YOU</b> <b>SHOULD</b> <b>KNOW</b> <b>ABOUT</b>
       <b>Fuzzing</b> <b>of</b> <b>CRLF</b> <b>and</b> <b>newline</b> <b>on</b> <b>input</b>

       RFC-1521 dictates that MIME streams have lines terminated by CRLF ("\r\n").  However, it is extremely
       likely that folks will want to parse MIME streams where each line ends in the local newline character
       "\n" instead.

       An attempt has been made to allow the parser to handle both CRLF and newline-terminated input.

       <b>Fuzzing</b> <b>of</b> <b>CRLF</b> <b>and</b> <b>newline</b> <b>when</b> <b>decoding</b>

       The "7bit" and "8bit" decoders will decode both a "\n" and a "\r\n" end-of-line sequence into a "\n".

       The "binary" decoder (default if no encoding specified) still outputs stuff verbatim... so a MIME
       message with CRLFs and no explicit encoding will be output as a text file that, on many systems, will
       have an annoying ^M at the end of each line... <u>but</u> <u>this</u> <u>is</u> <u>as</u> <u>it</u> <u>should</u> <u>be</u>.

       <b>Fuzzing</b> <b>of</b> <b>CRLF</b> <b>and</b> <b>newline</b> <b>when</b> <b>encoding/composing</b>

       All encoders currently output the end-of-line sequence as a "\n", with the assumption that the local
       mail agent will perform the conversion from newline to CRLF when sending the mail.  However, there
       probably should be an option to output CRLF as per RFC-1521.

       <b>Inability</b> <b>to</b> <b>handle</b> <b>multipart</b> <b>boundaries</b> <b>with</b> <b>embedded</b> <b>newlines</b>

       Let's get something straight: this is an evil, EVIL practice.  If your mailer creates multipart
       boundary strings that contain newlines, give it two weeks notice and find another one.  If your mail
       robot receives MIME mail like this, regard it as syntactically incorrect, which it is.

       <b>Ignoring</b> <b>non-header</b> <b>headers</b>

       People like to hand the parser raw messages straight from POP3 or from a mailbox.  There is often
       predictable non-header information in front of the real headers; e.g., the initial "From" line in the
       following message:

           From - Wed Mar 22 02:13:18 2000
           Return-Path: &lt;eryq@zeegee.com&gt;
           Subject: Hello

       The parser simply ignores such stuff quietly.  Perhaps it shouldn't, but most people seem to want
       that behavior.

       <b>Fuzzing</b> <b>of</b> <b>empty</b> <b>multipart</b> <b>preambles</b>

       Please note that there is currently an ambiguity in the way preambles are parsed in.  The following
       message fragments <u>both</u> are regarded as having an empty preamble (where "\n" indicates a newline
       character):

            Content-type: multipart/mixed; boundary="xyz"\n
            Subject: This message (#1) has an empty preamble\n
            \n
            --xyz\n
            ...

            Content-type: multipart/mixed; boundary="xyz"\n
            Subject: This message (#2) also has an empty preamble\n
            \n
            \n
            --xyz\n
            ...

       In both cases, the <u>first</u> completely-empty line (after the "Subject") marks the end of the header.

       But we should clearly ignore the <u>second</u> empty line in message #2, since it fills the role of <u>"the</u>
       <u>newline</u> <u>which</u> <u>is</u> <u>only</u> <u>there</u> <u>to</u> <u>make</u> <u>sure</u> <u>that</u> <u>the</u> <u>boundary</u> <u>is</u> <u>at</u> <u>the</u> <u>beginning</u> <u>of</u> <u>a</u> <u>line"</u>.  Such
       newlines are <u>never</u> part of the content preceding the boundary; thus, there is no preamble "content"
       in message #2.

       However, it seems clear that message #1 <u>also</u> has no preamble "content", and is in fact merely a
       compact representation of an empty preamble.

       <b>Use</b> <b>of</b> <b>a</b> <b>temp</b> <b>file</b> <b>during</b> <b>parsing</b>

       <u>Why</u> <u>not</u> <u>do</u> <u>everything</u> <u>in</u> <u>core?</u>  Although the amount of core available on even a modest home system
       continues to grow, the size of attachments continues to grow with it.  I wanted to make sure that
       even users with small systems could deal with decoding multi-megabyte sounds and movie files.  That
       means not being core-bound.

       As of the released 5.3xx, MIME::Parser gets by with only one temp file open per parser.  This temp
       file provides a sort of infinite scratch space for dealing with the current message part.  It's fast
       and lightweight, but you should know about it anyway.

       <b>Why</b> <b>do</b> <b>I</b> <b>assume</b> <b>that</b> <b>MIME</b> <b>objects</b> <b>are</b> <b>email</b> <b>objects?</b>

       Achim Bohnet once pointed out that MIME headers do nothing more than store a collection of
       attributes, and thus could be represented as objects which don't inherit from Mail::Header.

       I agree in principle, but RFC-1521 says otherwise.  RFC-1521 [MIME] headers are a syntactic subset of
       RFC-822 [email] headers.  Perhaps a better name for these modules would have been RFC1521:: instead
       of MIME::, but we're a little beyond that stage now.

       When I originally wrote these modules for the CPAN, I agonized for a long time about whether or not
       they really should subclass from <b>Mail::Internet</b> (then at version 1.17).  Thanks to Graham Barr, who
       graciously evolved MailTools 1.06 to be more MIME-friendly, unification was achieved at MIME-tools
       release 2.0.  The benefits in reuse alone have been substantial.

<b>A</b> <b>MIME</b> <b>PRIMER</b>
       So you need to parse (or create) MIME, but you're not quite up on the specifics?  No problem...

       <b>Glossary</b>

       Here are some definitions adapted from RFC-1521 explaining the terminology we use; each is
       accompanied by the equivalent in MIME:: module terms...

       attachment
           An "attachment" is common slang for any part of a multipart message -- except, perhaps, for the
           first part, which normally carries a user message describing the attachments that follow (e.g.:
           "Hey dude, here's that GIF file I promised you.").

           In our system, an attachment is just a <b>MIME::Entity</b> under the top-level entity, probably one of
           its parts.

       body
           The "body" of an entity is that portion of the entity which follows the header and which contains
           the real message content.  For example, if your MIME message has a GIF file attachment, then the
           body of that attachment is the base64-encoded GIF file itself.

           A body is represented by an instance of <b>MIME::Body</b>.  You get the body of an entity by sending it
           a <u>bodyhandle()</u> message.

       body part
           One of the parts of the body of a multipart <b>/entity</b>.  A body part has a <b>/header</b> and a <b>/body</b>, so
           it makes sense to speak about the body of a body part.

           Since a body part is just a kind of entity, it's represented by an instance of <b>MIME::Entity</b>.

       entity
           An "entity" means either a <b>/message</b> or a <b>/body</b> <b>part</b>.  All entities have a <b>/header</b> and a <b>/body</b>.

           An entity is represented by an instance of <b>MIME::Entity</b>.  There are instance methods for
           recovering the header (a <b>MIME::Head</b>) and the body (a <b>MIME::Body</b>).

       header
           This is the top portion of the MIME message, which contains the "Content-type", "Content-<font color="#ffffff" class="whiteout">transfer-encoding",&nbsp;"Contenttransfer-encoding",</font>
           transfer-encoding", etc.  Every MIME entity has a header, represented by an instance of
           <b>MIME::Head</b>.  You get the header of an entity by sending it a <u>head()</u> message.

       message
           A "message" generally means the complete (or "top-level") message being transferred on a network.

           There currently is no explicit package for "messages"; under MIME::, messages are streams of data
           which may be read in from files or filehandles.  You can think of the <b>MIME::Entity</b> returned by
           the <b>MIME::Parser</b> as representing the full message.

       <b>Content</b> <b>types</b>

       This indicates what kind of data is in the MIME message, usually as <u>majortype/minortype</u>.  The
       standard major types are shown below.  A more-comprehensive listing may be found in RFC-2046.

       application
           Data which does not fit in any of the other categories, particularly data to be processed by some
           type of application program.  "application/octet-stream", "application/gzip",
           "application/postscript"...

       audio
           Audio data.  "audio/basic"...

       image
           Graphics data.  "image/gif", "image/jpeg"...

       message
           A message, usually another mail or MIME message.  "message/rfc822"...

       multipart
           A message containing other messages.  "multipart/mixed", "multipart/alternative"...

       text
           Textual data, meant for humans to read.  "text/plain", "text/html"...

       video
           Video or video+audio data.  "video/mpeg"...

       <b>Content</b> <b>transfer</b> <b>encodings</b>

       This is how the message body is packaged up for safe transit.  There are the 5 major MIME encodings.
       A more-comprehensive listing may be found in RFC-2045.

       7bit
           No encoding is done at all.  This label simply asserts that no 8-bit characters are present, and
           that lines do not exceed 1000 characters in length (including the CRLF).

       8bit
           No encoding is done at all.  This label simply asserts that the message might contain 8-bit
           characters, and that lines do not exceed 1000 characters in length (including the CRLF).

       binary
           No encoding is done at all.  This label simply asserts that the message might contain 8-bit
           characters, and that lines may exceed 1000 characters in length.  Such messages are the <u>least</u>
           likely to get through mail gateways.

       base64
           A standard encoding, which maps arbitrary binary data to the 7bit domain.  Like "uuencode", but
           very well-defined.  This is how you should send essentially binary information (tar files, GIFs,
           JPEGs, etc.).

       quoted-printable
           A standard encoding, which maps arbitrary line-oriented data to the 7bit domain.  Useful for
           encoding messages which are textual in nature, yet which contain non-ASCII characters (e.g.,
           Latin-1, Latin-2, or any other 8-bit alphabet).

<b>TERMS</b> <b>AND</b> <b>CONDITIONS</b>
       Eryq (<u>eryq@zeegee.com</u>), ZeeGee Software Inc (<a href="http://www.zeegee.com)"><u>http://www.zeegee.com</u>)</u></a><u>  David F. Skoll
       (dfs@roaringpenguin.com) <a href="http://www.roaringpenguin.com">http://www.roaringpenguin.com</u></a><u>

       Copyright (c) 1998, 1999 by ZeeGee Software Inc (www.zeegee.com).  Copyright (c) 2004 by Roaring
       Penguin Software Inc (www.roaringpenguin.com)

       All rights reserved.  This program is free software; you can redistribute it and/or modify it under
       the same terms as Perl itself.  See the COPYING file in the distribution for details.

<b>SUPPORT</b>
       Please email me directly with questions/problems (see AUTHOR below).

       If you want to be placed on an email distribution list (not a mailing list!)  for MIME-tools, and
       receive bug reports, patches, and updates as to when new MIME-tools releases are planned, just email
       me and say so.  If your project is using MIME-tools, it might not be a bad idea to find out about
       those bugs <u>before</u> they become problems...

<b>VERSION</b>
       $Revision: 1.15 $

<b>CHANGE</b> <b>LOG</b>
       Version 5.411
           <b>Regenerated</b> <b>docs.</b>  Bug in HTML docs, now all fixed.

       Version 5.410   (2000/11/23)
           <b>Better</b> <b>detection</b> <b>of</b> <b>evil</b> <b>filenames.</b>  Now we check for filenames which are suspiciously long, and
           a new <u>MIME::Filer::exorcise</u><b>_</b><u>filename()</u> method is used to try and remove the evil.  <u>Thanks</u> <u>to</u>
           <u>Jason</u> <u>Haar</u> <u>for</u> <u>the</u> <u>suggestion.</u>

       Version 5.409   (2000/11/12)
           <b>Added</b> <b>functionality</b> <b>to</b> <b>MIME::WordDecoder,</b> including support for plain US-ASCII.

           <u></u><b><u>M</u></b><u></u><b><u>M</u></b><u></u><b><u>:</u></b><u></u><b><u>T</u></b><u></u><b><u>o</u></b><u></u><b><u>s</u></b><u></u><b><u>:</u></b><u></u><b><u>m</u></b><u></u><b><u>o</u></b><u></u><b><u>e</u></b><u></u><b><u>(</u></b> made more flexible.  You can now override the tmpfile-opening behavior.

       Version 5.408   (2000/11/10)
           <b>Added</b> <b>new</b> <b>Beta</b> <u></u><b><u>u</u></b><u></u><b><u>m</u></b><u></u><b><u>m</u></b><u></u><b><u>(</u></b> <b>mechanism.</b>  See MIME::WordDecoder for full details.  Also see "Understand
           how international characters are represented".

       Version 5.405   (2000/11/05)
           <b>Added</b> <b>a</b> <u></u><b><u>p</u></b><u></u><b><u>r</u></b><u></u><b><u>e</u></b><u></u><b><u>)</u></b> <b>that</b> <b>does</b> <b>what</b> <b>people</b> <b>want</b> <b>it</b> <b>to.</b>  Now, when a parse finishes and you want to
           delete everything that was created by it, you can invoke "purge()" on the parser's filer.  All
           files/directories created during the last parse should vanish.  <u>Thanks</u> <u>to</u> <u>everyone</u> <u>who</u> <u>complained</u>
           <u>about</u> <u>MIME::Entity::purge.</u>

       Version 5.404   (2000/11/04)
           <b>Added</b> <b>new</b> <b>automatic</b> <b>MIME-decoding</b> <b>of</b> <b>attachment</b> <b>filenames</b> <b>with</b> <b>encoded</b> <b>(non-ASCII)</b> <b>characters.</b>
           Hopefully this will do more good than harm.  The use of <u>MIME::Parser::decode</u><b>_</b><u>headers()</u> and
           <u>MIME::Head::decode()</u> has been deprecated in favor of the new MIME::Words "unmime" mechanism.
           Please see "unmime" in MIME::Words.

           <b>Added</b> <b>tolerance</b> <b>for</b> <b>unquoted</b> <b>=?...?=</b> <b>in</b> <b>param</b> <b>values.</b>  This is in violation of the RFCs, but
           then, so are some MUAs.  <u>Thanks</u> <u>to</u> <u>desti</u> <u>for</u> <u>bringing</u> <u>this</u> <u>to</u> <u>my</u> <u>attention.</u>

           <b>Fixed</b> <b>supposedly-bad</b> <b>B-encoding.</b>  <u>Thanks</u> <u>to</u> <u>Otto</u> <u>Frost</u> <u>for</u> <u>bringing</u> <u>this</u> <u>to</u> <u>my</u> <u>attention.</u>

       Version 5.316   (2000/09/21)
           <b>Increased</b> <b>tolerance</b> <b>in</b> <b>MIME::Parser.</b>  Now will ignore bogus POP3 "+OK" line before header, as
           well as bogus mailbox "From " line (both with warnings).  <u>Thanks</u> <u>to</u> <u>Antony</u> <u>OSullivan</u> <u>(ajos1)</u> <u>for</u>
           <u>suggesting</u> <u>this</u> <u>feature.</u>

           <b>Fixed</b> <b>small</b> <b>epilogue-related</b> <b>bug</b> <b>in</b> <u></u><b><u>M</u></b><u></u><b><u>M</u></b><u></u><b><u>:</u></b><u></u><b><u>E</u></b><u></u><b><u>t</u></b><u></u><b><u>t</u></b><u></u><b><u>:</u></b><u></u><b><u>p</u></b><u></u><b><u>i</u></b><u></u><b><u>t</u></b><b>_</b><u></u><b><u>b</u></b><u></u><b><u>d</u></b><u></u><b><u>(</u></b><b>.</b>  Now it only outputs a final
           newline if the epilogue does not end in one already.  Support for checking the preamble/epilogue
           in regression tests was also added.  <u>Thanks</u> <u>to</u> <u>Lars</u> <u>Hecking</u> <u>for</u> <u>bringing</u> <u>this</u> <u>issue</u> <u>up.</u>

           <b>Updated</b> <b>documentation.</b>  All module manual pages should now direct readers to the main MIME-tools
           manual page.

       Version 5.314   (2000/09/06)
           Fixed Makefile.PL to have less-restrictive requirement for File::Spec (0.6).

       Version 5.313   (2000/09/05)
           <b>Fixed</b> <b>nasty</b> <b>bug</b> <b>with</b> <b>evil</b> <b>filenames.</b>  Certain evil filenames were getting replaced by internally-
           generated filenames which were just as evil... ouch!  If your parser occasionally throws a fatal
           exception with a "write-open" error message, then you have this bug.  <u>Thanks</u> <u>to</u> <u>Julian</u> <u>Field</u> <u>and</u>
           <u>Antony</u> <u>OSullivan</u> <u>(ajos1)</u> <u>for</u> <u>delivering</u> <u>the</u> <u>evidence!</u>

                  Beware the doctor
                     who cures seasonal head cold
                  by killing patient

           <b>Improved</b> <b>naming</b> <b>of</b> <b>extracted</b> <b>files.</b>  If a filename is regarded as evil, we guess that it might
           just be because of part information, and attempt to find and use the final path element.

           <b>Simplified</b> <b>message</b> <b>logging</b> <b>and</b> <b>made</b> <b>it</b> <b>more</b> <b>consistent.</b>  For details, see "Message-logging".

       Version 5.312   (2000/09/03)
           <b>Fixed</b> <b>a</b> <b>Perl</b> <b>5.7</b> <u></u><b><u>s</u></b><u></u><b><u>l</u></b><u></u><b><u>c</u></b><u></u><b><u>(</u></b> <b>incompatibility</b> which caused "make test" to fail.  <u>Thanks</u> <u>to</u> <u>Nick</u> <u>Ing</u>-
           <u>Simmons</u> <u>for</u> <u>the</u> <u>patch.</u>

       Version 5.311   (2000/08/16)
           <b>Blind</b> <b>fix</b> <b>for</b> <b>Win32</b> <b>uudecoding</b> <b>bug.</b>  A missing binmode seems to be the culprit here; let's see if
           this fixes it.  <u>Thanks</u> <u>to</u> <u>ajos1</u> <u>for</u> <u>finding</u> <u>the</u> <u>culprit!</u>

                  The carriage return
                     thumbs its nose at me, laughing:
                  DOS I/O *still* sucks

       Version 5.310   (2000/08/15)
           <b>Fixed</b> <b>a</b> <b>bug</b> <b>in</b> <b>the</b> <b>back-compat</b> <u></u><b><u>o</u></b><u></u><b><u>t</u></b><u></u><b><u>u</u></b><b>_</b><u></u><b><u>p</u></b><u></u><b><u>e</u></b><u></u><b><u>i</u></b><u></u><b><u>(</u></b> <b>method</b> <b>of</b> <b>MIME::Parser.</b>  Basically, output
           prefixes were not being set through this mechanism.  <u>Thanks</u> <u>to</u> <u>ajos1</u> <u>for</u> <u>the</u> <u>alert.</u>

                   shift @_,                               ### "shift at-underscore"
                      or @_ will have
                   bogus "self" object

           <b>Added</b> <b>some</b> <b>backcompat</b> <b>methods,</b> like <u>parse</u><b>_</b><u>FH()</u>.  <u>Thanks</u> <u>(and</u> <u>apologies)</u> <u>to</u> <u>Alain</u> <u>Kotoujansky.</u>

           <b>Added</b> <b>filenames-with-spaces</b> <b>support</b> <b>to</b> <b>MIME::Decoder::UU.</b>  <u>Thanks</u> <u>to</u> <u>Richard</u> <u>Pun</u> <u>for</u> <u>the</u>
           <u>suggestion.</u>

       Version 5.305   (2000/07/20)
           <b>Added</b> <b>MIME::Entity::parts_DFS</b> as convenient way to "get all parts".  <u>Thanks</u> <u>to</u> <u>Xavier</u> <u>Armengou</u>
           <u>for</u> <u>suggesting</u> <u>this</u> <u>method.</u>

           Removed the Alpha notice.  Still a few features to tweak, but those will be minor.

       Version 5.303   (2000/07/07)
           <b>Fixed</b> <b>output</b> <b>bugs</b> <b>in</b> <b>new</b> <b>Filers</b>.  Scads of them: bad handling of filename collisions, bad
           implementation of <u>output</u><b>_</b><u>under()</u>, bad linking to results, POD errors, you name it.  If this had
           gone to CPAN, I'd have issued a factory recall. ":-("

                  Errors, like beetles,
                     Multiply ferociously
                  In the small hours

       Version 5.301   (2000/07/06)
           <b>READ</b> <b>ME</b> <b>BEFORE</b> <b>UPGRADING</b> <b>PAST</b> <b>THIS</b> <b>POINT!</b>  <b>New</b> <b>MIME::Parser::Filer</b> <b>class</b> <b>--</b> <b>not</b> <b>fully</b> <b>backwards</b>-
           <b>compatible.</b>  In response to demand for more-comprehensive file-output strategies, I have decided
           that the best thing to do is to split all the file-output logic (<u>output</u><b>_</b><u>path()</u>, <u>evil</u><b>_</b><u>filename()</u>,
           etc.)  into its own separate class, inheriting from the new MIME::Parser::Filer class.  If you
           <u>override</u> any of the following in a MIME::Parser subclass, you will need to change your code
           accordingly:

                   evil_filename
                   output_dir
                   output_filename
                   output_path
                   output_prefix
                   output_under

           My sincere apologies for any inconvenience this will cause, but it's ultimately for the best, and
           is quite likely the last structural change to 5.x.  <u>Thanks</u> <u>to</u> <u>Tyson</u> <u>Ackland</u> <u>for</u> <u>all</u> <u>the</u> <u>ideas.</u>
           Incidentally, the new code also fixes a bug where identically-named files in the same message
           could clobber each other.

                  A message arrives:
                      "Here are three files, all named 'Foo'"
                  Only one survives.  :-(

           <b>Fixed</b> <b>bug</b> <b>in</b> <b>MIME::Words</b> <b>header</b> <b>decoding.</b>  Underscores were not being handled properly.  <u>Thanks</u>
           <u>to</u> <u>Dominique</u> <u>Unruh</u> <u>and</u> <u>Doru</u> <u>Petrescu,</u> who independently submitted the same fix within 2 hours of
           each other, after this bug has lain dormant for months:

                  Two users, same bug,
                     same patch -- mere hours apart:
                  Truly, life is odd.

           <b>Removed</b> <b>escaping</b> <b>of</b> <b>underscore</b> <b>in</b> <b>regexps.</b>  Escaping the underscore (\_) in regexps was sloppy
           and wrong (escaped metacharacters may include anything in \w), and the newest Perls warn about
           it.  <u>Thanks</u> <u>to</u> <u>David</u> <u>Dyck</u> <u>for</u> <u>bringing</u> <u>this</u> <u>to</u> <u>my</u> <u>attention.</u>

                  What, then, is a word?
                     Some letters, digits, and, yes:
                  Underscores as well

           <b>Added</b> <b>Force</b> <b>option</b> <b>to</b> <b>MIME::Entity's</b> <b>make_multipart</b>.  <u>Thanks</u> <u>to</u> <u>Bob</u> <u>Glickstein</u> <u>for</u> <u>suggesting</u>
           <u>this.</u>

           <b>Numerous</b> <b>fixlets</b> <b>to</b> <b>example</b> <b>code.</b>  <u>Thanks</u> <u>to</u> <u>Doru</u> <u>Petrescu</u> <u>for</u> <u>these.</u>

           <b>Added</b> <b>REQUIREMENTS</b> <b>section</b> <b>in</b> <b>docs.</b>  Long-overdue.  <u>Thanks</u> <u>to</u> <u>Ingo</u> <u>Schmiegel</u> <u>for</u> <u>motivating</u> <u>this.</u>

       Version 5.211   (2000/06/24)
           <b>Fixed</b> <b>auto-uudecode</b> <b>bug.</b>  Parser was failing with "part did not end with expected boundary" error
           when uuencoded entity was a <u>singlepart</u> message (ironically, uuencoded parts of multiparts worked
           fine).  <u>Thanks</u> <u>to</u> <u>Michael</u> <u>Mohlere</u> <u>for</u> <u>testing</u> <u>uudecode</u> <u>and</u> <u>finding</u> <u>this.</u>

                  The hurrying bee
                     Flies far for nectar, missing
                  The nearest flowers

                  Say ten thousand times:
                     Complex cases may succeed
                  Where simple ones fail

           <b>Parse</b> <b>errors</b> <b>now</b> <b>generate</b> <b>warnings.</b>  Parser errors now cause <u>warn()</u>s to be generated if they are
           not turned into fatal exceptions.  This might be a little redundant, seeing as they are available
           in the "results", but parser-warnings already cause <u>warn()</u>s.  I can always put in a "quiet"
           switch if people complain.

           <b>Miscellaneous</b> <b>cleanup.</b>  Documentation of MIME::Parser improved slightly, and a redundant warning
           was removed.

       Version 5.210   (2000/06/20)
           <b>Change</b> <b>in</b> <b>"evil"</b> <b>filename.</b>  Made MIME::Parser's evil_filename stricter by having it reject "path"
           characters: any of '/' '\' ':' '[' ']'.

                  Just as with beauty
                     The eye of the beholder
                  Is where "evil" lives.

           <b>Documentation</b> <b>fixes.</b>  Corrected a number of docs in MIME::Entity which were obsoleted in the
           transition from 4.x to 5.x.  <u>Thanks</u> <u>to</u> <u>Michael</u> <u>Fischer</u> <u>for</u> <u>pointing</u> <u>these</u> <u>out.</u>  For this one, a
           special 5-5-5-5 Haiku of anagrams:

                  Documentation
                     in mutant code, O!
                  Edit -- no, CUT! [moan]
                     I meant to un-doc...

           <b>IO::Lines</b> <b>usage</b> <b>bug</b> <b>fixed.</b>  MIME::Entity was missing a "use IO::Lines", which caused an exception
           when you tried to use the <u>body()</u> method of MIME::Entity.  <u>Thanks</u> <u>to</u> <u>Hideyo</u> <u>Imazu</u> <u>and</u> <u>Michael</u>
           <u>Fischer</u> <u>for</u> <u>pointing</u> <u>this</u> <u>out.</u>

                  Bareword looks fine, but
                     Perl cries: "Whoa there... IO::Lines?
                  Never heard of it."

       Version 5.209   (2000/06/10)
           <b>Autodetection</b> <b>of</b> <b>uuencode.</b>  You can now tell the parser to hunt for uuencode inside what should
           be text parts.  See <u>extract</u><b>_</b><u>uuencode()</u> for full details.  <b>Beware:</b> this is largely untested at the
           moment.  <u>Special</u> <u>thanks</u> <u>to</u> <u>Michael</u> <u>Mohlere</u> <u>at</u> <u>ADJE</u> <u>Webmail,</u> <u>who</u> <u>was</u> <u>the</u>
             <u>first</u> <u>--</u> <u>and</u> <u>most-insistent</u> <u>--</u> <u>user</u> <u>to</u> <u>request</u> <u>this</u> <u>feature.</u>

           <b>Faster</b> <b>parsing.</b>  Sped up the MIME::Decoder::NBit decoder quite a bit by using a variant of the
           chunking trick I used for MIME::Decoder::Base64.  I suspect that the same trick (reading a big
           chunk plus the next line to get a big block of lines) would work with MIME::Decoder::QuotedPrint,
           but I don't have the time or resources to check that right now (tested contributions would be
           welcome).  NBit encoding is more-conveniently done line-by-line for now, because individual line
           lengths must be checked.

           <b>Better</b> <b>use</b> <b>of</b> <b>core.</b>  MIME::Body::InCore is now used when you <u>build()</u> an entity with the Data
           parameter, instead of MIME::Body::Scalar.

           <b>More</b> <b>documentation</b> on toolkit configuration.

       Version 5.207   (2000/06/09)
           <b>Fixed</b> <u></u><b><u>w</u></b><u></u><b><u>i</u></b><u></u><b><u>e</u></b><u></u><b><u>)</u></b> <b>bug</b> <b>in</b> <b>MIME::Parser</b> where the "warning" method <u>whine()</u> was called as a static
           function instead of invoked as an instance method.  <u>Thanks</u> <u>to</u> <u>Todd</u> <u>A.</u> <u>Bradfute</u> <u>for</u> <u>reporting</u>
           <u>this.</u>

                  A simple warning
                     Invokes method as function:
                  "Warning" makes us die

       Version 5.206   (2000/06/08)
           Ahem.  Cough cough:

                  Way too many bugs
                     Thus, a self-imposed penance:
                  Write haiku for each

           <b>Fixed</b> <b>bug</b> <b>in</b> <b>MIME::Parser:</b> the reader was not handling the odd (but legal) case where a multipart
           boundary is followed by linear whitespace.  <u>Thanks</u> <u>to</u> <u>Jon</u> <u>Agnew</u> <u>for</u> <u>reporting</u> <u>this</u> <u>with</u> <u>the</u> <u>RFC</u>
           <u>citation.</u>

                  Legal message fails
                     And 'round the globe, thousands cry:
                  READ THE RFC

           Empty preambles are now handled properly by MIME::Entity when printing: there is now no space
           between the header-terminator and the initial boundary.  <u>Thanks</u> <u>to</u> <u>"sen</u><b>_</b><u>ml"</u> <u>for</u> <u>suggesting</u> <u>this.</u>

                  Nature hates vacuum
                     But please refrain from tossing
                  Newlines in the void

           Started using Benchmark for benchmarking.

       Version 5.205   (2000/06/06)
           Added terminating newline to all parser messages, and fixed small parser bug that was dropping
           parts when errors occurred in certain places.

       Version 5.203   (2000/06/05)
           Brand new parser based on new (private) MIME::Parser::Reader and (public) MIME::Parser::Results.
           Fast and yet simple and very tolerant of bad MIME when desired.  Message reporting needs some
           muzzling.

           MIME::Parser now has <u>ignore</u><b>_</b><u>errors()</u> set true by default.

       Version 5.116   (2000/05/26)
           Removed Tmpfile.t test, which was causing a bogus failure in "make test".  Now we require 5.004
           for MIME::Parser anyway, so we don't need it.  <u>Thanks</u> <u>to</u> <u>Jonathan</u> <u>Cohn</u> <u>for</u> <u>reporting</u> <u>this.</u>

       Version 5.115   (2000/05/24)
           Fixed Ref.t bug, and documented how to remove parts from a MIME::Entity.

       Version 5.114   (2000/05/23)
           Entity now uses MIME::Lite-style default suggested encoding.

           More regression test have been added, and the "Size" tests in Ref.t are skipped for text document
           (due to CRLF differences between platforms).

       Version 5.113   (2000/05/21)
           <b>Major</b> <b>speed</b> <b>and</b> <b>structural</b> <b>improvements</b> <b>to</b> <b>the</b> <b>parser.</b>
               <u>Major,</u> <u>MAJOR</u> <u>thanks</u> <u>to</u> <u>Noel</u> <u>Burton-Krahn,</u> <u>Jeremy</u> <u>Gilbert,</u>
                 <u>and</u> <u>Doru</u> <u>Petrescu</u> <u>for</u> <u>all</u> <u>the</u> <u>patches,</u> <u>benchmarking,</u>
                 <u>and</u> <u>Beta-testing!</u>

           <b>Convenient</b> <b>new</b> <b>one-directory-per-message</b> <b>parsing</b> <b>mechanism.</b>
               Now through "MIME::Parser" method "output_under()",
               you can tell the parser that you want it to create
               a unique directory for each message parsed, to hold the
               resulting parts.

           <b>Elimination</b> <b>of</b> <b>$',</b> <b>$`</b> <b>and</b> <b>$&amp;.</b>
               Wow... I still can't believe I missed this.  D'OH!
               <u>Thanks</u> <u>to</u> <u>Noel</u> <u>Burton-Krahn</u> <u>for</u> <u>all</u> <u>his</u> <u>patches.</u>

           <b>Parser</b> <b>is</b> <b>more</b> <b>tolerant</b> <b>of</b> <b>weird</b> <b>EOL</b> <b>termination.</b>
               Some mailagents are can terminate lines with "\r\r\n".
               We're okay with that now when we extract the header.
               <u>Thanks</u> <u>to</u> <u>Joao</u> <u>Fonseca</u> <u>for</u> <u>pointing</u> <u>this</u> <u>out.</u>

           <b>Parser</b> <b>is</b> <b>tolerant</b> <b>of</b> <b>"From</b> <b>"</b> <b>lines</b> <b>in</b> <b>headers.</b>
               <u>Thanks</u> <u>to</u> <u>Joachim</u> <u>Wieland,</u> <u>Anthony</u> <u>Hinsinger,</u> <u>Marius</u> <u>Stan,</u>
                 <u>and</u> <u>numerous</u> <u>others.</u>

           <b>Parser</b> <b>catches</b> <b>syntax</b> <b>errors</b> <b>in</b> <b>headers.</b>
               <u>Thanks</u> <u>to</u> <u>Russell</u> <u>P.</u> <u>Sutherland</u> <u>for</u> <u>catching</u> <u>this.</u>

           <b>Parser</b> <b>no</b> <b>longer</b> <b>warns</b> <b>when</b> <b>subtype</b> <b>is</b> <b>undefined.</b>
               <u>Thanks</u> <u>to</u> <u>Eric-Olivier</u> <u>Le</u> <u>Bigot</u> <u>for</u> <u>his</u> <u>fix.</u>

           <b>Better</b> <b>integration</b> <b>with</b> <b>Mail::Internet.</b>
               For example, <u>smtpsend()</u> should work fine.
               <u>Thanks</u> <u>to</u> <u>Michael</u> <u>Fischer</u> <u>and</u> <u>others</u> <u>for</u> <u>the</u> <u>patch.</u>

           <b>Miscellaneous</b> <b>cleanup.</b>
               <u>Thanks</u> <u>to</u> <u>Marcus</u> <u>Brinkmann</u> <u>for</u> <u>additional</u> <u>helpful</u> <u>input.</u>
               <u>Thanks</u> <u>to</u> <u>Klaus</u> <u>Seidenfaden</u> <u>for</u> <u>good</u> <u>feedback</u> <u>on</u> <u>5.x</u> <u>Alpha!</u>

       Version 4.123   (1999/05/12)
           Cleaned up some of the tests for non-Unix OS'es.  Will require a few iterations, no doubt.

       Version 4.122   (1999/02/09)
           <b>Resolved</b> <b>CORE::open</b> <b>warnings</b> <b>for</b> <b>5.005.</b>
                   <u>Thanks</u> <u>to</u> <u>several</u> <u>folks</u> <u>for</u> <u>this</u> <u>bug</u> <u>report.</u>

       Version 4.121   (1998/06/03)
           <b>Fixed</b> <b>MIME::Words</b> <b>infinite</b> <b>recursion.</b>
                   <u>Thanks</u> <u>to</u> <u>several</u> <u>folks</u> <u>for</u> <u>this</u> <u>bug</u> <u>report.</u>

       Version 4.117   (1998/05/01)
           <b>Nicer</b> <b>MIME::Entity::build.</b>
                   No longer outputs warnings with undefined Filename, and now
                   accepts Charset as well.       <u>Thanks</u> <u>to</u> <u>Jason</u> <u>Tibbits</u> <u>III</u> <u>for</u> <u>the</u> <u>inspirational</u> <u>patch.</u>

           <b>Documentation</b> <b>fixes.</b>
                   Hopefully we've seen the last of the pod2man warnings...

           <b>Better</b> <b>test</b> <b>logging.</b>
                   Now uses ExtUtils::TBone.

       Version 4.116   (1998/02/14)
           <b>Bug</b> <b>fix:</b>
                   MIME::Head and MIME::Entity were not downcasing the
                   content-type as they claimed.  This has now been fixed.       <u>Thanks</u> <u>to</u> <u>Rodrigo</u> <u>de</u>
           <u>Almeida</u> <u>Siqueira</u> <u>for</u> <u>finding</u> <u>this.</u>

       Version 4.114   (1998/02/12)
           <b>Gzip64-encoding</b> <b>has</b> <b>been</b> <b>improved,</b> <b>and</b> <b>turned</b> <b>off</b> <b>as</b> <b>a</b> <b>default,</b>      since it depends on having
           gzip installed.
                   See MIME::Decoder::Gzip64 if you want to activate it in your app.       You can   now set
           up the gzip/gunzip commands to use, as well.       <u>Thanks</u> <u>to</u> <u>Paul</u> <u>J.</u> <u>Schinder</u> <u>for</u> <u>finding</u> <u>this</u>
           <u>bug.</u>

       Version 4.113   (1998/01/20)
           <b>Bug</b> <b>fix:</b>
                   MIME::ParserBase was accidentally folding newlines in header fields.       <u>Thanks</u> <u>to</u>
           <u>Jason</u> <u>L.</u> <u>Tibbitts</u> <u>III</u> <u>for</u> <u>spotting</u> <u>this.</u>

       Version 4.112   (1998/01/17)
           <b>MIME::Entity::print_body</b> <b>now</b> <b>recurses</b> when printing multipart      entities, and prints
           "everything following the header."  This is more      likely what people expect to happen.
           PLEASE read the
                   "two body problem" section of MIME::Entity's docs.

       Version 4.111   (1998/01/14)
           Clean build/test on Win95 using 5.004.  Whew.

       Version 4.110   (1998/01/11)
           <b>Added</b> <u>make</u><b>_</b><u>multipart()</u> and <u>make</u><b>_</b><u>singlepart()</u> in MIME::Entity.

           <b>Improved</b> handling/saving of preamble/epilogue.

       Version 4.109   (1998/01/10)
           Overall
               <b>Major</b> <b>version</b> <b>shift</b> <b>to</b> <b>4.x</b>      accompanies numerous structural changes, and      the
               deletion of some long-deprecated code.  Many apologies to those      who are inconvenienced
               by the upgrade.

               <b>MIME::IO</b> <b>deprecated.</b>       You'll see IO::Scalar, IO::ScalarArray, and IO::Wrap      to make
               this toolkit work.

               <b>MIME::Entity</b> <b>deep</b> <b>code.</b>       You can now deep-copy MIME entities (except for on-disk data
               files).

           Encoding/decoding
               <b>MIME::Latin1</b> <b>deprecated,</b> <b>and</b> <b>8-to-7</b> <b>mapping</b> <b>removed.</b>       Really, MIME::Latin1 was one of my
               more dumber ideas.       It's still there, but if you want to map 8-bit characters to
                    Latin1 ASCII approximations when 7bit encoding, you'll have to      request it
               explicitly.   <u>But</u> <u>use</u> <u>quoted-printable</u> <u>for</u> <u>your</u> <u>8-bit</u>      <u>documents;</u> <u>that's</u> <u>what</u> <u>it's</u> <u>there</u>
               <u>for!</u>

               <b>7bit</b> <b>and</b> <b>8bit</b> <b>"encoders"</b> <b>no</b> <b>longer</b> <b>encode.</b>       As per RFC-2045, these just do a pass-
               through of the data,      but they'll warn you if you send bad data through.

               <b>MIME::Entity</b> <b>suggests</b> <b>encoding.</b>       Now you can ask MIME::Entity's <u>build()</u> method to
               "suggest"      a legal encoding based on the body and the content-type.       No more
               guesswork!  See the "mimesend" example.

               <b>New</b> <b>module</b> <b>structure</b> <b>for</b> <b>MIME::Decoder</b> <b>classes.</b>       It should be easier for you to see
               what's happening.

               <b>New</b> <b>MIME</b> <b>decoders!</b>       Support added for decoding "x-uuencode", and for
                    decoding/encoding "x-gzip64".  You'll need "gzip" to make      the latter work.

               <b>Quoted-printable</b> <b>back</b> <b>on</b> <b>track...</b> <b>and</b> <b>then</b> <b>some.</b>       The 'quoted-printable' decoder now
               uses the newest MIME::QuotedPrint,      and amends its output with guideline #8 from RFC2049
               (From/.).       <u>Thanks</u> <u>to</u> <u>Denis</u> <u>N.</u> <u>Antonioli</u> <u>for</u> <u>suggesting</u> <u>this.</u>

           Parsing
               <b>Preamble</b> <b>and</b> <b>epilogue</b> <b>are</b> <b>now</b> <b>saved.</b>       These are saved in the parsed entities as simple
                    string-arrays, and are output by <u>print()</u> if there.       <u>Thanks</u> <u>to</u> <u>Jason</u> <u>L.</u> <u>Tibbitts</u> <u>for</u>
               <u>suggesting</u> <u>this.</u>

               <b>The</b> <b>"multipart/digest"</b> <b>semantics</b> <b>are</b> <b>now</b> <b>preserved.</b>       Parts of digest messages have their
               <u>mime</u><b>_</b><u>type()</u> defaulted      to "message/rfc822" instead of "text/plain", as per the RFC.
                    <u>Thanks</u> <u>to</u> <u>Carsten</u> <u>Heyl</u> <u>for</u> <u>suggesting</u> <u>this.</u>

           Output
               <b>Well-defined,</b> <b>more-complete</b> <u></u><b><u>p</u></b><u></u><b><u>i</u></b><u></u><b><u>t</u></b><u></u><b><u>)</u></b> <b>output.</b>       When printing an entity, the output is now
               well-defined if the      entity came from a MIME::Parser, even if using
               parse_nested_messages.       See MIME::Entity for details.

               <b>You</b> <b>can</b> <b>prevent</b> <b>recommended</b> <b>filenames</b> <b>from</b> <b>being</b> <b>output.</b>       This possible security hole
               has been plugged; when building MIME      entities, you can specify a body path but suppress
               the filename      in the header.       <u>Thanks</u> <u>to</u> <u>Jason</u> <u>L.</u> <u>Tibbitts</u> <u>for</u> <u>suggesting</u> <u>this.</u>

           Bug fixes
               <b>Win32</b> <b>installations</b> <b>should</b> <b>work.</b>       The <u>binmode()</u> calls should work fine on Win32 now.
                    <u>Thanks</u> <u>to</u> <u>numerous</u> <u>folks</u> <u>for</u> <u>their</u> <u>patches.</u>

               <u></u><b><u>M</u></b><u></u><b><u>M</u></b><u></u><b><u>:</u></b><u></u><b><u>H</u></b><u></u><b><u>a</u></b><u></u><b><u>:</u></b><u></u><b><u>a</u></b><u></u><b><u>d</u></b><u></u><b><u>)</u></b> now no longer downcases its argument.       <u>Thanks</u> <u>to</u> <u>Brandon</u> <u>Browning</u> <u>&amp;</u>
               <u>Jason</u> <u>L.</u> <u>Tibbitts</u> <u>for</u> <u>finding</u> <u>this</u> <u>bug.</u>

       Version 3.204
           <b>Bug</b> <b>in</b> <b>MIME::Head::original_text</b> <b>fixed.</b>       Well, it took a while, but another bug surfaced
           from my transition      from 1.x to 2.x.  This method was, quite idiotically, sorting the
                header fields.       <u>Thanks,</u> <u>as</u> <u>usual,</u> <u>to</u> <u>Andreas</u> <u>Koenig</u> <u>for</u> <u>spotting</u> <u>this</u> <u>one.</u>

           <b>MIME::ParserBase</b> <b>no</b> <b>longer</b> <b>defaults</b> <b>to</b> <b>RFC-1522-decoding</b> <b>headers.</b>       The documentation
           correctly stated that the default setting was      to <u>not</u> RFC-1522-decode the headers.  The code,
           on the other hand,      was init'ing this parser option in the "on" position.       This has been
           fixed.

           <b>MIME::ParserBase::parse_nested_messages</b> <b>reexamined.</b>       If you use this feature, please re-read
           the documentation.       It explains a little more precisely what the ramifications are.

           <b>MIME::Entity</b> <b>tries</b> <b>harder</b> <b>to</b> <b>ensure</b> <b>MIME</b> <b>compliance.</b>       It is now a fatal error to use certain
           bad combinations of content      type and encoding when "building", or to attempt to "attach" to
                anything that is not a multipart document.  My apologies if this      inconveniences anyone,
           but it was just too darn easy before for folks      to create bad MIME, and gosh darn it, good
           libraries should at least      <u>try</u> to protect you from mistakes.

           <b>The</b> <b>"make"</b> <b>now</b> <b>halts</b> <b>if</b> <b>you</b> <b>don't</b> <b>have</b> <b>the</b> <b>right</b> <b>stuff,</b>      provided your MakeMaker supports
           PREREQ_PM.  See "REQUIREMENTS"      for what you need to install this package.  I still provide
                old courtesy copies of the MIME:: decoding modules.  <u>Thanks</u> <u>to</u> <u>Hugo</u> <u>van</u> <u>der</u> <u>Sanden</u> <u>for</u>
           <u>suggesting</u> <u>this.</u>

           <b>The</b> <b>"make</b> <b>test"</b> <b>is</b> <b>far</b> <b>less</b> <b>chatty.</b>       Okay, okay, STDERR is evil.  Now a "make test" will
           just give you      the important stuff: do a "make test TEST_VERBOSE=1" if you want      the gory
           details (advisable if sending me a bug report).  <u>Thanks</u> <u>to</u> <u>Andreas</u> <u>Koenig</u> <u>for</u> <u>suggesting</u> <u>this.</u>

       Version 3.203
           <b>No,</b> <b>there</b> <b>haven't</b> <b>been</b> <b>any</b> <b>major</b> <b>changes</b> <b>between</b> <b>2.x</b> <b>and</b> <b>3.x.</b>       The major-version increase
           was from a few more tweaks to get $VERSION      to be calculated better and more efficiently (I
           had been using RCS      version numbers in a way which created problems for users of CPAN::).
                After a couple of false starts, all modules have been upgraded to RCS      3.201 or higher.

           <b>You</b> <b>can</b> <b>now</b> <b>parse</b> <b>a</b> <b>MIME</b> <b>message</b> <b>from</b> <b>a</b> <b>scalar,</b>      an array-of-scalars, or any
           MIME::IO-compliant object (including IO::      objects.)  Take a look at <u>parse</u><b>_</b><u>data()</u> in
           MIME::ParserBase.  The      parser code has been modified to support the MIME::IO interface.
                <u>Thanks</u> <u>to</u> <u>fellow</u> <u>Chicagoan</u> <u>Tim</u> <u>Pierce</u> <u>(and</u> <u>countless</u> <u>others)</u>      <u>for</u> <u>asking.</u>

           <b>More</b> <b>sensible</b> <b>toolkit</b> <b>configuration.</b>       A new <u>config()</u> method in MIME::ToolUtils makes a lot
           of toolkit-wide      configuration cleaner.  Your old calls will still work, but with
                deprecation warnings.

           <b>You</b> <b>can</b> <b>now</b> <b>sign</b> <b>messages</b> just like in Mail::Internet.       See MIME::Entity for the interface.

           <b>You</b> <b>can</b> <b>now</b> <b>remove</b> <b>signatures</b> <b>from</b> <b>messages</b> just like in Mail::Internet.       See MIME::Entity
           for the interface.

           <b>You</b> <b>can</b> <b>now</b> <b>compute/strip</b> <b>content</b> <b>lengths</b>      and other non-standard MIME fields.       See
           <u>sync</u><b>_</b><u>headers()</u> in MIME::Entity.       <u>Thanks</u> <u>to</u> <u>Tim</u> <u>Pierce</u> <u>for</u> <u>bringing</u> <u>the</u> <u>basic</u> <u>problem</u> <u>to</u> <u>my</u>
           <u>attention.</u>

           <b>Many</b> <b>warnings</b> <b>are</b> <b>now</b> <b>silent</b> <b>unless</b> <b>$^W</b> <b>is</b> <b>true.</b>       That means unless you run your Perl with
           "-w", you won't see
                   deprecation warnings, non-fatal-error messages, etc.
                   But of course you run with "-w", so this doesn't affect you.  ":-)"

           <b>Completed</b> <b>the</b> <b>7-bit</b> <b>encodings</b> <b>in</b> <b>MIME::Latin1.</b>       We hadn't had complete coverage in the
           conversion from 8- to 7-bit;      now we do. <u>Thanks</u> <u>to</u> <u>Rolf</u> <u>Nelson</u> <u>for</u> <u>bringing</u> <u>this</u> <u>to</u> <u>my</u>
           <u>attention.</u>

           <b>Fixed</b> <b>broken</b> <u></u><b><u>p</u></b><u></u><b><u>r</u></b><u></u><b><u>e</u></b><b>_</b><u></u><b><u>t</u></b><u></u><b><u>o</u></b><u></u><b><u>)</u></b> <b>in</b> <b>MIME::ParserBase.</b>       BTW, if your code worked with the "broken"
           code, it should <u>still</u>      work.       <u>Thanks</u> <u>again</u> <u>to</u> <u>Tim</u> <u>Pierce</u> <u>for</u> <u>bringing</u> <u>this</u> <u>to</u> <u>my</u>
           <u>attention.</u>

       Version 2.14
           Just a few bug fixes to improve compatibility with Mail-Tools 1.08, and with the upcoming Perl
           5.004 release.  <u>Thanks</u> <u>to</u> <u>Jason</u> <u>L.</u> <u>Tibbitts</u> <u>III</u> <u>for</u> <u>reporting</u> <u>the</u> <u>problems</u> <u>so</u> <u>quickly.</u>

       Version 2.13
           New features
               <b>Added</b> <b>RFC-1522-style</b> <b>decoding</b> <b>of</b> <b>encoded</b> <b>header</b> <b>fields.</b>       Header decoding can now be done
               automatically during parsing via the      new "decode()" method in MIME::Head... just tell
               your parser      object that you want to "decode_headers()".       <u>Thanks</u> <u>to</u> <u>Kent</u> <u>Boortz</u> <u>for</u>
               <u>providing</u> <u>the</u> <u>idea,</u> <u>and</u> <u>the</u> <u>baseline</u>      <u>RFC-1522-decoding</u> <u>code!</u>

               <b>Building</b> <b>MIME</b> <b>messages</b> <b>is</b> <b>even</b> <b>easier.</b>       Now, when you use MIME::Entity's "build()" or
               "attach()",      you can also supply individual      mail headers to set (e.g., "-Subject",
               "-From", "-To").

               Added "Disposition" to MIME::Entity's "build()" method.       <u>Thanks</u> <u>to</u> <u>Kurt</u> <u>Freytag</u> <u>for</u>
               <u>suggesting</u> <u>this</u> <u>feature.</u>

               An "X-Mailer" header is now output      by default in all MIME-Entity-prepared messages,
                    so any bad MIME we generate can be traced back to this toolkit.

               Added "purge()" method to MIME::Entity for deleteing leftover files.       <u>Thanks</u> <u>to</u> <u>Jason</u> <u>L.</u>
               <u>Tibbitts</u> <u>III</u> <u>for</u> <u>suggesting</u> <u>this</u> <u>feature.</u>

               Added "seek()" and "tell()" methods to built-in MIME::IO classes.       Only guaranteed to
               work when reading!       <u>Thanks</u> <u>to</u> <u>Jason</u> <u>L.</u> <u>Tibbitts</u> <u>III</u> <u>for</u> <u>suggesting</u> <u>this</u> <u>feature.</u>

               When parsing a multipart message with apparently no boundaries,      the error message you
               get has been improved.       <u>Thanks</u> <u>to</u> <u>Andreas</u> <u>Koenig</u> <u>for</u> <u>suggesting</u> <u>this.</u>

           Bug fixes
               <b>Patched</b> <b>over</b> <b>a</b> <b>Perl</b> <b>5.002</b> <b>(and</b> <b>maybe</b> <b>earlier</b> <b>and</b> <b>later)</b> <b>bug</b> <b>involving</b>
               <b>FileHandle::new_tmpfile.</b>  It seems that the underlying filehandles were not being closed when
               the FileHandle objects went out of scope!  There is now an internal routine that creates true
               FileHandle objects for anonymous temp files.  <u>Thanks</u> <u>to</u> <u>Dragomir</u> <u>R.</u> <u>Radev</u> <u>and</u> <u>Zyx</u> <u>for</u>
               <u>reporting</u> <u>the</u> <u>weird</u> <u>behavior</u> <u>that</u> <u>led</u> <u>to</u> <u>the</u> <u>discovery</u> <u>of</u> <u>this</u> <u>bug.</u>

               MIME::Entity's "build()" method now warns you if you give it an illegal boundary string, and
               substitutes one of its own.

               MIME::Entity's "build()" method now generates safer, fully-RFC-1521-compliant boundary
               strings.

               Bug in MIME::Decoder's "install()" method was fixed.  <u>Thanks</u> <u>to</u> <u>Rolf</u> <u>Nelson</u> <u>and</u> <u>Nickolay</u>
               <u>Saukh</u> <u>for</u> <u>finding</u> <u>this.</u>

               Changed FileHandle::new_tmpfile to FileHandle-&gt;new_tmpfile, so some Perl installations will
               be happier.  <u>Thanks</u> <u>to</u> <u>Larry</u> <u>W.</u> <u>Virden</u> <u>for</u> <u>finding</u> <u>this</u> <u>bug.</u>

               Gave "=over" an arg of 4 in all PODs.  <u>Thanks</u> <u>to</u> <u>Larry</u> <u>W.</u> <u>Virden</u> <u>for</u> <u>pointing</u> <u>out</u> <u>the</u>
               <u>problems</u> <u>of</u> <u>bare</u> <u>=over's</u>

       Version 2.04
           <b>A</b> <b>bug</b> <b>in</b> <b>MIME::Entity's</b> <b>output</b> <b>method</b> <b>was</b> <b>corrected.</b>  MIME::Entity::print now outputs everything
           to the desired filehandle explicitly.  <u>Thanks</u> <u>to</u> <u>Jake</u> <u>Morrison</u> <u>for</u> <u>pointing</u> <u>out</u> <u>the</u>
           <u>incompatibility</u> <u>with</u> <u>Mail::Header.</u>

       Version 2.03
           <b>Fixed</b> <b>bug</b> <b>in</b> <b>autogenerated</b> <b>filenames</b> resulting from transposed "if" statement in MIME::Parser,
           removing spurious printing of header as well.  (Annoyingly, this bug is invisible if debugging is
           turned on!)  <u>Thanks</u> <u>to</u> <u>Andreas</u> <u>Koenig</u> <u>for</u> <u>bringing</u> <u>this</u> <u>to</u> <u>my</u> <u>attention.</u>

           Fixed bug in <u>MIME::Entity::body()</u> where it was using the bodyhandle completely incorrectly.
           <u>Thanks</u> <u>to</u> <u>Joel</u> <u>Noble</u> <u>for</u> <u>bringing</u> <u>this</u> <u>to</u> <u>my</u> <u>attention.</u>

           Fixed MIME::Head::VERSION so CPAN:: is happier.  <u>Thanks</u> <u>to</u> <u>Larry</u> <u>Virden</u> <u>for</u> <u>bringing</u> <u>this</u> <u>to</u> <u>my</u>
           <u>attention.</u>

           Fixed undefined-variable warnings when dumping skeleton (happened when there was no Subject:
           line) <u>Thanks</u> <u>to</u> <u>Joel</u> <u>Noble</u> <u>for</u> <u>bringing</u> <u>this</u> <u>to</u> <u>my</u> <u>attention.</u>

       Version 2.02
           <b>Stupid,</b> <b>stupid</b> <b>bugs</b> <b>in</b> <b>both</b> <b>BASE64</b> <b>encoding</b> <b>and</b> <b>decoding</b> <b>were</b> <b>fixed.</b>  <u>Thanks</u> <u>to</u> <u>Phil</u> <u>Abercrombie</u>
           <u>for</u> <u>locating</u> <u>them.</u>

       Version 2.01
           <b>Modules</b> <b>now</b> <b>inherit</b> <b>from</b> <b>the</b> <b>new</b> <b>Mail::</b> <b>modules!</b>  This means big changes in behavior.

           <b>MIME::Parser</b> <b>can</b> <b>now</b> <b>store</b> <b>message</b> <b>data</b> <b>in-core.</b>  There were a <u>lot</u> of requests for this feature.

           <b>MIME::Entity</b> <b>can</b> <b>now</b> <b>compose</b> <b>messages.</b>  There were a <u>lot</u> of requests for this feature.

           Added option to parse "message/rfc822" as a pseduo-multipart document.  <u>Thanks</u> <u>to</u> <u>Andreas</u> <u>Koenig</u>
           <u>for</u> <u>suggesting</u> <u>this.</u>

       Version 1.13
           MIME::Head now no longer requires space after ":", although either a space or a tab after the ":"
           will be swallowed if there.  <u>Thanks</u> <u>to</u> <u>Igor</u> <u>Starovoitov</u> <u>for</u> <u>pointing</u> <u>out</u> <u>this</u> <u>shortcoming.</u>

       Version 1.12
           Fixed bugs in parser where CRLF-terminated lines were blowing out the handling of
           preambles/epilogues.  <u>Thanks</u> <u>to</u> <u>Russell</u> <u>Sutherland</u> <u>for</u> <u>reporting</u> <u>this</u> <u>bug.</u>

           Fixed idiotic <u>is</u><b>_</b><u>multipart()</u> bug.  <u>Thanks</u> <u>to</u> <u>Andreas</u> <u>Koenig</u> <u>for</u> <u>noticing</u> <u>it.</u>

           Added untested <u>binmode()</u> calls to parser for DOS, etc.  systems.  No idea if this will work...

           Reorganized the <u>output</u><b>_</b><u>path()</u> methods to allow easy use of inheritance, as per Achim Bohnet's
           suggestion.

           Changed MIME::Head to report mime_type more accurately.

           POSIX module no longer loaded by Parser if perl &gt;= 5.002.  Hey, 5.001'ers: let me know if this
           breaks stuff, okay?

           Added unsupported ./examples directory.

       Version 1.11
           Converted over to using Makefile.PL.  <u>Thanks</u> <u>to</u> <u>Andreas</u> <u>Koenig</u> <u>for</u> <u>the</u> <u>much-needed</u> <u>kick</u> <u>in</u> <u>the</u>
           <u>pants...</u>

           Added t/*.t files for testing.  Eeeeeeeeeeeh...it's a start.

           Fixed bug in default parsing routine for generating output paths; it was warning about evil
           filenames if there simply <u>were</u> no recommended filenames.  D'oh!

           Fixed redefined <u>parts()</u> method in Entity.

           Fixed bugs in Head where field name wasn't being case folded.

       Version 1.10
           A typo was causing the epilogue of an inner multipart message to be swallowed to the end of the
           OUTER multipart message; this has now been fixed.  <u>Thanks</u> <u>to</u> <u>Igor</u> <u>Starovoitov</u> <u>for</u> <u>reporting</u> <u>this</u>
           <u>bug.</u>

           A bad regexp for parameter names was causing some parameters to be parsed incorrectly; this has
           also been fixed.  <u>Thanks</u> <u>again</u> <u>to</u> <u>Igor</u> <u>Starovoitov</u> <u>for</u> <u>reporting</u> <u>this</u> <u>bug.</u>

           It is now possible to get full control of the filenaming algorithm before output files are
           generated, and the default algorithm is safer.  <u>Thanks</u> <u>to</u> <u>Laurent</u> <u>Amon</u> <u>for</u> <u>pointing</u> <u>out</u> <u>the</u>
           <u>problems,</u> <u>and</u> <u>suggesting</u> <u>some</u> <u>solutions.</u>

           Fixed illegal "simple" multipart test file.  D'OH!

       Version 1.9
           No changes: 1.8 failed CPAN registration

       Version 1.8
           Fixed incompatibility with 5.001 and FileHandle::new_tmpfile Added COPYING file, and improved
           README.

<b>AUTHOR</b>
       MIME-tools was created by:

           ___  _ _ _   _  ___ _
          / _ \| '_| | | |/ _ ' /    Eryq, (eryq@zeegee.com)
         |  __/| | | |_| | |_| |     President, ZeeGee Software Inc.
          \___||_|  \__, |\__, |__   <a href="http://www.zeegee.com/">http://www.zeegee.com/</u></a><u>
                    |___/    |___/

       Released as MIME-parser (1.0): 28 April 1996.  Released as MIME-tools (2.0): Halloween 1996.
       Released as MIME-tools (4.0): Christmas 1997.  Released as MIME-tools (5.0): Mother's Day 2000.

<b>ACKNOWLEDGMENTS</b>
       <b>This</b> <b>kit</b> <b>would</b> <b>not</b> <b>have</b> <b>been</b> <b>possible</b> but for the direct contributions of the following:

           Gisle Aas             The MIME encoding/decoding modules.
           Laurent Amon          Bug reports and suggestions.
           Graham Barr           The new MailTools.
           Achim Bohnet          Numerous good suggestions, including the I/O model.
           Kent Boortz           Initial code for RFC-1522-decoding of MIME headers.
           Andreas Koenig        Numerous good ideas, tons of beta testing,
                                   and help with CPAN-friendly packaging.
           Igor Starovoitov      Bug reports and suggestions.
           Jason L Tibbitts III  Bug reports, suggestions, patches.

       Not to mention the Accidental Beta Test Team, whose bug reports (and comments) have been invaluable
       in improving the whole:

           Phil Abercrombie
           Mike Blazer
           Brandon Browning
           Kurt Freytag
           Steve Kilbane
           Jake Morrison
           Rolf Nelson
           Joel Noble
           Michael W. Normandin
           Tim Pierce
           Andrew Pimlott
           Dragomir R. Radev
           Nickolay Saukh
           Russell Sutherland
           Larry Virden
           Zyx

       Please forgive me if I've accidentally left you out.  Better yet, email me, and I'll put you in.

<b>SEE</b> <b>ALSO</b>
       At the time of this writing ($Date: 2006/03/17 21:03:23 $), the MIME-tools homepage was
       <a href="http://www.mimedefang.org/static/mime-tools.php"><u>http://www.mimedefang.org/static/mime-tools.php</u></u></a><u>  Check there for updates and support.

       Users of this toolkit may wish to read the documentation of Mail::Header and Mail::Internet.

       The MIME format is documented in RFCs 1521-1522, and more recently in RFCs 2045-2049.

       The MIME header format is an outgrowth of the mail header format documented in RFC 822.



perl v5.8.8                                      2006-03-17                                   MIME::Tools(3)
</tt></pre>
</td></tr></table>
	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Darwin/Reference/ManPages/man3/MIME__Tools.3pm.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Darwin/Reference/ManPages/man3/MIME__Tools.3pm.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Darwin/Reference/ManPages/man3/MIME__Tools.3pm.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

</body></html>
