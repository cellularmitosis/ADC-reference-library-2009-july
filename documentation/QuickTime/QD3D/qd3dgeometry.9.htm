<HTML><HEAD><META NAME="GENERATOR" CONTENT="Adobe FrameMaker 5.5/HTML Export Filter"><script language="JavaScript" src="frametest.js"></script><TITLE> Using Polyhedrons</TITLE></HEAD><BODY BGCOLOR="#ffffff"><!-- start of header --><!--#include virtual="/includes/framesetheader" --><!-- end of header --><!-- path goes here --><H1 CLASS="H2.Heading2"><A NAME="pgfId=34214"> </A>Using Polyhedrons</H1><P CLASS="T1.Text1"><A NAME="pgfId=34215"> </A>The polyhedron is the primitive of choice for most programming situations, as well as for the creation and distribution of editable model files. Thus if your application requires the creation, conversion, or distribution of polyhedral models, you should produce them in polyhedron format instead of mesh or trimesh. User applications such as modelers and animation tools should also generally manipulate polyhedrons. Plug-in renderers are required to support certain basic primitives (triangles, points, lines, and markers) and are strongly urged to support the polyhedron as well.</P><P CLASS="T1.Text1"><A NAME="pgfId=34216"> </A>The polyhedron format gives you these features:</P><UL><LI CLASS="B1.Bullet1"><A NAME="pgfId=34217"> </A>It can easily represent many different polyhedral models in a space-efficient fashion.</LI><LI CLASS="B1.Bullet1"><A NAME="pgfId=34218"> </A>It's capable of fast rendering.</LI><LI CLASS="B1.Bullet1"><A NAME="pgfId=34219"> </A>It's highly consistent with the rest of the QuickDraw 3D API.</LI><LI CLASS="B1.Bullet1"><A NAME="pgfId=34220"> </A>Attributes can be attached in whatever combination is appropriate for the model.</LI></UL><P CLASS="T1.Text1"><A NAME="pgfId=34221"> </A>Polyhedrons make geometric editing operations, which change the positions of existing vertices, easy and convenient. In immediate mode, you can simply alter a point's position in the array in the polyhedron data structure and render the shape again. In retained mode, several function calls let you change vertex locations, as well as providing the usual assortment of Get and Set calls for attributes, faces, face attributes, and so on. </P><P CLASS="T1.Text1"><A NAME="pgfId=34222"> </A>You can use topological editing operations to change the relationships between vertices, faces, edges, and the whole polyhedron. However, the addition or deletion of vertices, faces, or edges may require reallocation of one or more of the polyhedron's arrays. Because the polyhedron has a public data structure, these operations are possible in both immediate mode and retained mode. If adding and deleting vertices, faces, or edges aren't the primary operations required for using the polyhedron, array reallocation will not be a problem; if they are, you should use the mesh primitive instead.</P><P CLASS="T1.Text1"><A NAME="pgfId=34223"> </A>The polyhedron uses memory and disk space efficiently because shared locations and attributes are stored only once and only those parts that logically require attributes get them. This produces good I/O speed, although, as with all geometric primitives, the addition of textures can increase I/O time significantly. The polyhedron also features superior rendering speed because its vertices are shared.</P><DIV><H2 CLASS="H3.Heading3"><A NAME="pgfId=31179"> </A>Creating a Polyhedron</H2><P CLASS="T1.Text1"><A NAME="pgfId=33409"> </A>The normal way to make a polyhedron is to create an array of points and a list of triangular faces that organize the points. Each face consists of a list of indices into the list of vertices, forming a polygon with one level of array-based indirection. If there is more than one face, the vertices can be shared by reusing the same array indices in each face. This allows the graphics system to run faster because the same point doesn't have to be transformed or shaded more than once, and it saves storage space. In addition, because two or more faces share only one real vertex, this format makes it easier to do interactive editing programming.</P><P CLASS="T1.Text1"><A NAME="pgfId=33410"> </A>Polyhedrons--objects of type <TT CLASS="cv">kQ3GeometryTypePolyhedron</TT>--implement this process in a way that is consistent with the other QuickDraw 3D primitives. Its basic component is the vertex of type <TT CLASS="cv">TQ3Vertex3D</TT>, an {x, y, z} location with an attribute set. The vertices of adjacent triangular faces are shared simply by using the same vertex indices. Also, sets of attributes may be shared like other objects in QuickDraw 3D:</P><P CLASS="T1.Text1"><A NAME="pgfId=33412"> </A><TT CLASS="cv">vertex-&gt;attributeSet = Q3Shared_GetReference(otherVertex-&gt;attributeSet);</TT></P><P CLASS="T1.Text1"><A NAME="pgfId=33413"> </A>Vertices can contain the same locations, but need not share attributes. This can be useful, for example, when creating a polyhedron that is generally smooth but has some edges or corners where you want a discontinuity. For example, consider the cross section of a polyhedron shown in <A HREF="qd3dgeometry.9.htm#36958" CLASS="XRef">Figure&nbsp;12</A>, which has vertices sharing locations but not attributes. </P><P CLASS="T1.Text1"><A NAME="pgfId=33806"> </A>In <A HREF="qd3dgeometry.9.htm#36958" CLASS="XRef">Figure&nbsp;12</A>, each location is shared, and vertices at positions A, B, D, and E share normals, while the vertices at position C share the location but not the normal. So when smooth-shaded, the object has an edge or corner at position C but appears smooth elsewhere.</P><P CLASS="Fg.Figure"><A NAME="pgfId=33710"> </A>Figure&nbsp;12<A NAME="36958"> </A>Cross-section of a polyhedron </P><DIV><IMG SRC="qd3dgeometry-19.gif"></DIV><P CLASS="T1.Text1"><A NAME="pgfId=33417"> </A>Because values in an attribute set apply to all vertices or faces sharing that attribute set, operations on it will affect all these elements. For example, you can associate a single texture with a group of faces by simply giving each face a shared reference to the texture-containing attribute set. For a single texture to span a number of faces, you need to make sure their shared vertices share texture coordinates. You can do this by making shared vertices of faces that are spanned by a single texture use the same attribute set, as shown in <A HREF="qd3dgeometry.9.htm#26379" CLASS="XRef">Figure&nbsp;13</A>.</P><P CLASS="Fg.Figure"><A NAME="pgfId=33418"> </A>Figure&nbsp;13<A NAME="26379"> </A>Applying textures that span several faces</P><DIV><IMG SRC="qd3dgeometry-20.gif"></DIV><P CLASS="T1.Text1"><A NAME="pgfId=33422"> </A>Besides an attribute set for the face, the three vertices defining a face of a polyhedron are in an array of size 3. The polyhedron also uses an enumerated type that defines which edges are drawn and which not: </P><CODE CLASS="Cv.Code"><A NAME="pgfId=39406"> </A>typedef enum TQ3PolyhedronEdgeMasks {<BR>&nbsp;&nbsp;&nbsp;&nbsp;kQ3PolyhedronEdgeNone&nbsp;&nbsp;&nbsp;= 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;kQ3PolyhedronEdge01&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= 1 &lt;&lt; 0,<BR>&nbsp;&nbsp;&nbsp;&nbsp;kQ3PolyhedronEdge12&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= 1 &lt;&lt; 1,<BR>&nbsp;&nbsp;&nbsp;&nbsp;kQ3PolyhedronEdge20&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= 1 &lt;&lt; 2,<BR>&nbsp;&nbsp;&nbsp;&nbsp;kQ3PolyhedronEdgeAll&nbsp;&nbsp;&nbsp;&nbsp;= kQ3PolyhedronEdge01 | <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;kQ3PolyhedronEdge12 |<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;kQ3PolyhedronEdge20<BR>} TQ3PolyhedronEdgeMasks;<BR></CODE><CODE CLASS="Cv.Code"><A NAME="pgfId=39412"> </A>typedef unsigned long TQ3PolyhedronEdge;<BR></CODE><P CLASS="T1.Text1"><A NAME="pgfId=33434"> </A>By OR-combining these flags you can select which edges of a particular triangle you want drawn. For example, if you're using a wireframe renderer to draw an object like the one shown in <A HREF="qd3dgeometry.9.htm#26890" CLASS="XRef">Figure&nbsp;14</A>, you wouldn't have to show the &quot;internal&quot; edges, just the edges that represent the true border of the face. For face 0 in <A HREF="qd3dgeometry.9.htm#26890" CLASS="XRef">Figure&nbsp;14</A>, you could specify that you want to display only the edges between vertices 0 and 1 and vertices 2 and 0, leaving undrawn the edge between vertices 1 and 2. You'd do this by specifying <TT CLASS="cv">(kQ3PolyhedronEdge01 | kQ3PolyhedronEdge20)</TT> as the edge mask.</P><P CLASS="Fg.Figure"><A NAME="pgfId=33435"> </A>Figure&nbsp;14<A NAME="26890"> </A>Wireframe polyhedron</P><DIV><IMG SRC="qd3dgeometry-21.gif"></DIV><P CLASS="T1.Text1"><A NAME="pgfId=33438"> </A>All the information discussed so far is collected in this data structure: </P><CODE CLASS="Cv.Code"><A NAME="pgfId=39418"> </A>typedef struct TQ3PolyhedronTriangleData {<BR>&nbsp;&nbsp;&nbsp;&nbsp;unsigned long&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vertexIndices[3];<BR>&nbsp;&nbsp;&nbsp;&nbsp;TQ3PolyhedronEdge&nbsp;&nbsp;&nbsp;edgeFlag;<BR>&nbsp;&nbsp;&nbsp;&nbsp;TQ3AttributeSet&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;triangleAttributeSet;<BR>} TQ3PolyhedronTriangleData;<BR></CODE><P CLASS="T1.Text1"><A NAME="pgfId=33444"> </A>An alternative to using a mask to specify the edges is to create a list of edges for the entire polyhedron. If the renderer draws the edges (or lines, in the case of a wireframe renderer) from an edge list, the renderer can transform the points just once each and draw each edge just once, resulting in much faster rendering. The renderer ignores the edge flags in the face data structure if an array of these edges is present:</P><CODE CLASS="Cv.Code"><A NAME="pgfId=39424"> </A>typedef struct TQ3PolyhedronEdgeData {<BR>&nbsp;&nbsp;&nbsp;&nbsp;unsigned long&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vertexIndices[2];<BR>&nbsp;&nbsp;&nbsp;&nbsp;unsigned long&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;triangleIndices[2];<BR>&nbsp;&nbsp;&nbsp;&nbsp;TQ3AttributeSet&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;edgeAttributeSet;<BR>} TQ3PolyhedronEdgeData;<BR></CODE><P CLASS="T1.Text1"><A NAME="pgfId=33450"> </A>As shown in <A HREF="qd3dgeometry.9.htm#40698" CLASS="XRef">Figure&nbsp;15</A>, the <TT CLASS="cv">vertexIndices</TT> field specifies indices into the vertex array, one for the vertex at each end of each edge.</P><P CLASS="Fg.Figure"><A NAME="pgfId=33451"> </A>Figure&nbsp;15<A NAME="40698"> </A>Filling out a polyhedron's edge data structure</P><DIV><IMG SRC="qd3dgeometry-22.gif"></DIV><P CLASS="T1.Text1"><A NAME="pgfId=33452"> </A>The <TT CLASS="cv">triangleIndices</TT> field shown in <A HREF="qd3dgeometry.9.htm#40698" CLASS="XRef">Figure&nbsp;15</A> specifies indices into the array of faces. You need to provide the indices to the faces that share an edge because performing correct backface removal requires that the edge be drawn only if at least one of the faces that it's part of is facing forward. </P><P CLASS="T1.Text1"><A NAME="pgfId=33454"> </A>The <TT CLASS="cv">edgeAttributeSet</TT> field allows the application to specify the color and other attributes of edges independently. If no attribute is set for an edge, the attributes are inherited from the geometric object, or from the view's state if that's not present. Every edge must have two points, but edges may have one or two faces adjacent to them; those with just one are on a boundary of the object. To represent a boundary in an array-based representation, you use the identifier <TT CLASS="cv">kQ3ArrayIndexNULL</TT> as a face index for the side of an edge that has no face attached to it. </P><P CLASS="Note"><A NAME="pgfId=33954"> </A>When going from the vertex at index 0 to the vertex at index 1 in <A HREF="qd3dgeometry.9.htm#40698" CLASS="XRef">Figure&nbsp;15</A>, the 0th face is to the left. If possible, fill out your data structures to conform to this practice. Other code may want to traverse the edge list and be assured of knowing exactly which face is on which side of each edge. </P><P CLASS="T1.Text1"><A NAME="pgfId=33455"> </A>The following is the entire polyhedron data structure:</P><CODE CLASS="Cv.Code"><A NAME="pgfId=39430"> </A>typedef struct TQ3PolyhedronData {<BR>&nbsp;&nbsp;&nbsp;&nbsp;unsigned long&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;numVertices;<BR>&nbsp;&nbsp;&nbsp;&nbsp;TQ3Vertex3D&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*vertices;<BR>&nbsp;&nbsp;&nbsp;&nbsp;unsigned long&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;numEdges;<BR>&nbsp;&nbsp;&nbsp;&nbsp;TQ3PolyhedronEdgeData&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*edges;<BR>&nbsp;&nbsp;&nbsp;&nbsp;unsigned long&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;numTriangles;<BR>&nbsp;&nbsp;&nbsp;&nbsp;TQ3PolyhedronTriangleData&nbsp;&nbsp;&nbsp;*triangles;<BR>&nbsp;&nbsp;&nbsp;&nbsp;TQ3AttributeSet&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;polyhedronAttributeSet;<BR>} TQ3PolyhedronData;<BR></CODE><P CLASS="T1.Text1"><A NAME="pgfId=33467"> </A><A HREF="qd3dgeometry.9.htm#38376" CLASS="XRef">Listing&nbsp;7</A> shows the code that creates the four-faced polyhedron shown in <A HREF="qd3dgeometry.9.htm#26890" CLASS="XRef">Figure&nbsp;14</A>.</P><P CLASS="L.Listing"><A NAME="pgfId=33468"> </A>Listing&nbsp;7<A NAME="38376"> </A>Creating a four-faced polyhedron</P><CODE CLASS="Cv.Code"><A NAME="pgfId=39436"> </A>TQ3ColorRGB&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;color;<BR>TQ3PolyhedronData&nbsp;&nbsp;&nbsp;polyhedronData;<BR>TQ3GeometryObject&nbsp;&nbsp;&nbsp;polyhedron;<BR>TQ3Vector3D&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;normal;<BR></CODE><CODE CLASS="Cv.Code"><A NAME="pgfId=39440"> </A>static TQ3Vertex3Dvertices[7] = {<BR>&nbsp;&nbsp;&nbsp;&nbsp;{ { -1.0,  1.0,  0.0 }, NULL },<BR>&nbsp;&nbsp;&nbsp;&nbsp;{ { -1.0, -1.0,  0.0 }, NULL },<BR>&nbsp;&nbsp;&nbsp;&nbsp;{ {  0.0,  1.0,  1.0 }, NULL },<BR>&nbsp;&nbsp;&nbsp;&nbsp;{ {  0.0, -1.0,  1.0 }, NULL },<BR>&nbsp;&nbsp;&nbsp;&nbsp;{ {  2.0,  1.0,  1.0 }, NULL },<BR>&nbsp;&nbsp;&nbsp;&nbsp;{ {  2.0, -1.0,  0.0 }, NULL },<BR>&nbsp;&nbsp;&nbsp;&nbsp;{ {  0.0, -1.0,  1.0 }, NULL }<BR>};<BR></CODE><CODE CLASS="Cv.Code"><A NAME="pgfId=39444"> </A>TQ3PolyhedronTriangleData&nbsp;&nbsp;&nbsp;triangles[4] = {<BR>&nbsp;&nbsp;&nbsp;&nbsp;{  /* Face 0 */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ 0, 1, 2 },&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* vertexIndices */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;kQ3PolyhedronEdge01 | kQ3PolyhedronEdge20,&nbsp;&nbsp;/* edgeFlag */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NULL&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* triangleAttributeSet */<BR>&nbsp;&nbsp;&nbsp;&nbsp;},<BR>&nbsp;&nbsp;&nbsp;&nbsp;{  /* Face 1 */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ 1, 3, 2 },<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;kQ3PolyhedronEdge01 | kQ3PolyhedronEdge12,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NULL<BR>&nbsp;&nbsp;&nbsp;&nbsp;},<BR>&nbsp;&nbsp;&nbsp;&nbsp;{  /* Face 2 */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ 2, 3, 4 },<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;kQ3PolyhedronEdgeAll,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NULL<BR>&nbsp;&nbsp;&nbsp;&nbsp;},<BR>&nbsp;&nbsp;&nbsp;&nbsp;{../* Face 3 */<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ 6, 5, 4 },<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;kQ3PolyhedronEdgeAll,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NULL<BR>&nbsp;&nbsp;&nbsp;&nbsp;}<BR>};<BR></CODE><CODE CLASS="Cv.Code"><A NAME="pgfId=39448"> </A>/* Set up vertices, edges, and triangular faces. */<BR>polyhedronData.numVertices&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= 7;<BR>polyhedronData.vertices&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= vertices;<BR>polyhedronData.numEdges&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= 0;<BR>polyhedronData.edges&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= NULL;<BR>polyhedronData.numTriangles&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= 4;<BR>polyhedronData.triangles&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= triangles;<BR></CODE><CODE CLASS="Cv.Code"><A NAME="pgfId=39452"> </A>/* Inherit the attribute set from the current state. */<BR>polyhedronData.polyhedronAttributeSet = NULL;<BR></CODE><CODE CLASS="Cv.Code"><A NAME="pgfId=39456"> </A>/* Put a normal on the first vertex. */<BR>Q3Vector3D_Set(&amp;normal, -1, 0, 1);<BR>Q3Vector3D_Normalize(&amp;normal, &amp;normal);<BR>vertices[0].attributeSet = Q3AttributeSet_New();<BR>Q3AttributeSet_Add(vertices[0].attributeSet, kQ3AttributeTypeNormal, <BR>&nbsp;&nbsp;&nbsp;&nbsp;&amp;normal);<BR></CODE><CODE CLASS="Cv.Code"><A NAME="pgfId=39460"> </A>/* Same normal on the second. */<BR>vertices[1].attributeSet = <BR>&nbsp;&nbsp;&nbsp;&nbsp;Q3Shared_GetReference(vertices[0].attributeSet);<BR></CODE><CODE CLASS="Cv.Code"><A NAME="pgfId=39464"> </A>/* Different normal on the third. */<BR>Q3Vector3D_Set(&amp;normal, -0.5, 0.0, 1.0);<BR>Q3Vector3D_Normalize(&amp;normal, &amp;normal);<BR>vertices[2].attributeSet = Q3AttributeSet_New();<BR>Q3AttributeSet_Add(vertices[2].attributeSet, kQ3AttributeTypeNormal, <BR>&nbsp;&nbsp;&nbsp;&nbsp;&amp;normal);<BR></CODE><CODE CLASS="Cv.Code"><A NAME="pgfId=39468"> </A>/* Same normal on the fourth. */<BR>vertices[3].attributeSet = <BR>&nbsp;&nbsp;&nbsp;&nbsp;Q3Shared_GetReference(vertices[2].attributeSet);<BR></CODE><CODE CLASS="Cv.Code"><A NAME="pgfId=39472"> </A>/* Put a color on the third triangle. */<BR>triangles[3].triangleAttributeSet = Q3AttributeSet_New();<BR>Q3ColorRGB_Set(&amp;polyhedronColor, 0, 0, 1);<BR>Q3AttributeSet_Add(triangles[3].triangleAttributeSet,<BR>&nbsp;&nbsp;&nbsp;&nbsp;kQ3AttributeTypeDiffuseColor, &amp;polyhedronColor);<BR></CODE><CODE CLASS="Cv.Code"><A NAME="pgfId=39476"> </A>/* Create the polyhedron object. */<BR>polyhedron = Q3Polyhedron_New(&amp;polyhedronData);<BR></CODE><CODE CLASS="Cv.Code"><A NAME="pgfId=39480"> </A>...&nbsp;/* Dispose of attributes created and referenced. */<BR></CODE><P CLASS="T1.Text1"><A NAME="pgfId=34028"> </A><A HREF="qd3dgeometry.9.htm#22422" CLASS="XRef">Listing&nbsp;8</A> shows code that specifies the edges of the polyhedron shown in <A HREF="qd3dgeometry.9.htm#26890" CLASS="XRef">Figure&nbsp;14</A>, but using the optional edge list. It is added to the code in <A HREF="qd3dgeometry.9.htm#38376" CLASS="XRef">Listing&nbsp;7</A>. When using an edge list, you would set the edge flags in the triangle data of <A HREF="qd3dgeometry.9.htm#38376" CLASS="XRef">Listing&nbsp;7</A> to a legitimate value, such as <TT CLASS="cv">kQ3EdgeFlagAll</TT>, that will be ignored.</P><P CLASS="L.Listing"><A NAME="pgfId=34029"> </A>Listing&nbsp;8<A NAME="22422"> </A>Using an edge list to specify the edges of a polyhedron</P><CODE CLASS="Cv.Code"><A NAME="pgfId=39484"> </A>polyhedronData.numEdges &nbsp;&nbsp;&nbsp;&nbsp;= 8;<BR>polyhedronData.edges &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= malloc(8 * sizeof(TQ3PolyhedronEdgeData));<BR></CODE><CODE CLASS="Cv.Code"><A NAME="pgfId=39488"> </A>polyhedronData.edges[0].vertexIndices[0]&nbsp;&nbsp;&nbsp;&nbsp;= 0;<BR>polyhedronData.edges[0].vertexIndices[1]&nbsp;&nbsp;&nbsp;&nbsp;= 1;<BR>polyhedronData.edges[0].triangleIndices[0]&nbsp;&nbsp;= 0;<BR>polyhedronData.edges[0].triangleIndices[1]&nbsp;&nbsp;= kQ3ArrayIndexNULL;<BR>polyhedronData.edges[0].edgeAttributeSet&nbsp;&nbsp;&nbsp;&nbsp;= NULL;<BR></CODE><CODE CLASS="Cv.Code"><A NAME="pgfId=39492"> </A>polyhedronData.edges[1].vertexIndices[0]&nbsp;&nbsp;&nbsp;&nbsp;= 2;<BR>polyhedronData.edges[1].vertexIndices[1]&nbsp;&nbsp;&nbsp;&nbsp;= 0;<BR>polyhedronData.edges[1].triangleIndices[0]&nbsp;&nbsp;= 0;<BR>polyhedronData.edges[1].triangleIndices[1]&nbsp;&nbsp;= kQ3ArrayIndexNULL;<BR>polyhedronData.edges[1].edgeAttributeSet&nbsp;&nbsp;&nbsp;&nbsp;= NULL;<BR></CODE><CODE CLASS="Cv.Code"><A NAME="pgfId=39496"> </A>polyhedronData.edges[2].vertexIndices[0]&nbsp;&nbsp;&nbsp;&nbsp;= 1;<BR>polyhedronData.edges[2].vertexIndices[1]&nbsp;&nbsp;&nbsp;&nbsp;= 3;<BR>polyhedronData.edges[2].triangleIndices[0]&nbsp;&nbsp;= 1;<BR>polyhedronData.edges[2].triangleIndices[1] &nbsp;= kQ3ArrayIndexNULL;<BR>polyhedronData.edges[2].edgeAttributeSet&nbsp;&nbsp;&nbsp;&nbsp;= NULL;<BR></CODE><CODE CLASS="Cv.Code"><A NAME="pgfId=39500"> </A>polyhedronData.edges[3].vertexIndices[0]&nbsp;&nbsp;&nbsp;&nbsp;= 3;<BR>polyhedronData.edges[3].vertexIndices[1]&nbsp;&nbsp;&nbsp;&nbsp;= 2;<BR>polyhedronData.edges[3].triangleIndices[0]&nbsp;&nbsp;= 1;<BR>polyhedronData.edges[3].triangleIndices[1]&nbsp;&nbsp;= 2;<BR>polyhedronData.edges[3].edgeAttributeSet&nbsp;&nbsp;&nbsp;&nbsp;= NULL;<BR></CODE><CODE CLASS="Cv.Code"><A NAME="pgfId=39504"> </A>...&nbsp;/* Specify the rest of the edges. */<BR></CODE></DIV><hr>&#169; 1997 Apple Computer, Inc.</DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV><!-- start of footer --><!--#include virtual="/includes/framesetfooter" --><!-- end of footer --></BODY></HTML>