/*	File:		WDEFColorSampleWDEF.c	Contains:	This file contains the routines that show how to obtain the colors				needed to display system 7 windows.					Please check the WDEF sample for details on how to write one.	Written by: 		Copyright:	Copyright © 1989-1999 by Apple Computer, Inc., All Rights Reserved.				You may incorporate this Apple sample source code into your program(s) without				restriction. This Apple sample source code has been provided "AS IS" and the				responsibility for its operation is yours. You are not permitted to redistribute				this Apple sample source code as "Apple sample source code" after having made				changes. If you're going to re-distribute the source, we require that you make				it clear in the source that the code was descended from Apple sample source				code, but that you've made changes.	Change History (most recent first):				8/11/1999	Karl Groethe	Updated for Metrowerks Codewarror Pro 2.1											Enabled C++ compiler to for it's more relaxed											constant initializer rules.				*/#include <Types.h>#include <Resources.h>#include <QuickDraw.h>#include <Fonts.h>#include <Events.h>#include <Windows.h>#include <Menus.h>#include <TextEdit.h>#include <Dialogs.h>#include <Desk.h>#include <ToolUtils.h>#include <Memory.h>#include <SegLoad.h>#include <Files.h>#include <OSUtils.h>#include <OSEvents.h>#include <DiskInit.h>#include <Packages.h>#include <Traps.h>#include <Script.h>#include "WDEFColorSample.h"		/* bring in all the #defines for WDEFSample */#define minTitleH			19 /* minumum height without SICN */#define minTitleHIcon		21 /* minumum height with SICN */#define wContentColor 0#define wFrameColor 1#define wHiliteLight 5		/* these are the part numbers for the sys 7 WCTB record */#define wTitleBarLight 7#define wTitleBarDark 8#define wTingeBarLight 11#define wTingeBarDark 12struct WInfoRec {		short ascent;		short descent;		short height;		short delta;		};typedef struct WInfoRec WInfoRec;/* use this struct to pass around the different state parameters. */struct 	DataRecord {		Boolean gadgetHilite;		WindowPtr window;		Boolean isColor;		CTabHandle awCTable;		Boolean threeDWind;		WInfoRec WInfo;		};		typedef struct DataRecord DataRecord;typedef DataRecord *DataRecordPtr;typedef DataRecord **DataRecordHandle;Boolean CheckShades(short what, DataRecordHandle data);void SetUpRatioColor(short hilitePart, short percent, RGBColor *tempRGB, DataRecordHandle data);void SetUpColor(short part, RGBColor *rgb, DataRecordHandle data);//extern void MakeRatioRGB(RGBColor *start, RGBColor *end, RGBColor *dest, short percent);Boolean CheckCTab(short part, CTabHandle target, RGBColor *rgb);void FakeWDEF(WindowPtr window, Boolean hilite);void SetForeBackColors (RGBColor *fore, RGBColor *back,  DataRecordHandle data);void DrawTitleString(Rect tempRect, short *indentL, short *indentR, DataRecordHandle data);pascal void DoDraw(short depth, short flags, GDHandle device, DataRecordHandle data);void CheckAvailableColors(short depth, GDHandle device, DataRecordHandle data);void BuildTitleRect(Rect *main, Rect *final, DataRecordHandle data);short CalculateTHeight( DataRecordHandle data);void MakeRatioRGB(RGBColor *start, RGBColor *end, RGBColor *dest, short percent);void DrawStripes(Rect tempRect, short indentL, short indentR, DataRecordHandle data);void DrawGoAwayBox(Rect tempRect, DataRecordHandle data);void DrawZoomBox(Rect tempRect, DataRecordHandle data);/* IMPORTANT: The window manager messes up with the current port and obtains   any results it wants; in this sample we take whatever port is the window,   so you better get the window with NewCWindow or GetNewCWindow for the color   cute stuff to work.      The hilite parameter is used to display the goaway and zoom boxes in their   un/hilited states.      This sample draws the standard window with title bar; nothing else!      Note that although this code mimics the WDEF it is not one, make sure you   check the WDEF sample before attempting to write your own.*//* === A C version of the MakeRatioRGB, in case you're compiling for PowerPC. === */void MakeRatioRGB(RGBColor *start, RGBColor *end, RGBColor *dest, short percent){	enum {			kMultVal = 0x1111 };	unsigned short	multValue;	short			counter, *destPtr;	short			blendValue, darkValue, lightValue;	Boolean			flipIt;	multValue = (unsigned short)(kMultVal * percent);		for (counter = 0; counter < 3; counter ++) {		darkValue = ((short *)end)[counter];	// get the proper colors for		lightValue = ((short *)start)[counter];	// this time through the loop		flipIt = ((unsigned long)lightValue > (unsigned long)darkValue);		blendValue = darkValue - lightValue;		if (flipIt == true)						// flip if subtraction would overflow			blendValue = -blendValue;					blendValue = ((unsigned short)blendValue * multValue) >> 16;												// quick multiply and shift		if (flipIt == true)						// flip it back if it's flipped			blendValue = -blendValue;					destPtr = &(((short *)dest)[counter]);	// get pointer to the right location												// in dest RGB record		*destPtr = blendValue + lightValue;		// fill it in with right color	}}/* Shows how to blend the colors in the 'wctb' to obtain the system 7 look]   for windows.*/void FakeWDEF(WindowPtr window, Boolean hilite){DataRecordHandle dataHandle;AuxWinHandle auxWind;RGBColor fore, back;short fontID;	fontID = window->txFont;		TextFont(GetSysFont());	dataHandle = (DataRecordHandle)NewHandle(sizeof(DataRecord));		if ((((CGrafPtr)window)->portVersion) && 0xC000) {	  (*dataHandle) -> isColor = true;	  GetAuxWin(window, &(auxWind));	  (*dataHandle) ->awCTable = (*auxWind)->awCTable;	  GetForeColor(&fore);	  GetBackColor(&back);	}	else {	  (*dataHandle) -> isColor = false;	}	(*dataHandle) -> window = window;	(*dataHandle) -> gadgetHilite = hilite;		PenNormal();		/* the main routine calls device loop passing the address of the routine	   that does the actual drawing.	*/	/* see IM VI for details on DeviceLoop */	DeviceLoop(window->visRgn, NewDeviceLoopDrawingProc(DoDraw), (long)dataHandle, 0);		/**** Unlock and dispose of stuff ****/	SetForeBackColors(&fore, &back, dataHandle);	TextFont(fontID);		DisposeHandle((Handle) dataHandle);}void DrawTitleString(Rect tempRect, short *indentL, short *indentR, DataRecordHandle data){RGBColor foreColor, backColor;RgnHandle tempRgn;short slop;	tempRgn = NewRgn();	if ( ((WindowPeek)((*data) -> window))-> hilited ) { /* window is hilited */	  SetUpColor(wFrameColor, &foreColor, data);	  SetUpRatioColor(wTitleBarLight, 0x1, &backColor, data); /* back color is a shade */	}	else {	/* unhilited requires a shade for fore color */	  SetUpRatioColor(wHiliteLight, 0xA, &foreColor, data);	  SetUpColor(wContentColor, &backColor, data);	}	SetForeBackColors(&foreColor, &backColor, data);	FrameRect(&tempRect);		InsetRect(&tempRect, 1, 1);	EraseRect(&tempRect);		if ( ((WindowPeek)((*data) -> window))-> hilited && (*data) -> threeDWind ) { /* window is hilited draw tinges */	/* the colors in the title bar are combinations of colors taken from	   discontiguous parts; so first we get the two colors	   and then we mix them directly.	*/	  SetUpColor(wTingeBarLight, &foreColor, data);	  SetUpColor(wTitleBarDark, &backColor, data);	  MakeRatioRGB(&foreColor, &backColor, &foreColor, 0x0);	  SetForeBackColors(&foreColor, 0L, data); /* set fore color */	  	  MoveTo(tempRect.left, tempRect.bottom-1);	  Line(0, -(tempRect.bottom-tempRect.top-1));	  Line(tempRect.right-tempRect.left-1,0);	  SetUpRatioColor(wTingeBarLight, 0x4, &foreColor, data);	  SetForeBackColors(&foreColor, 0L, data); /* set fore color */	  Line(0, tempRect.bottom-tempRect.top-1);	  Line(-(tempRect.right-tempRect.left-1), 0);	}		*indentL = (tempRect.right-tempRect.left-((WindowPeek)((*data) -> window))-> titleWidth) >> 1;		slop = 2; /* minimum distance from edge */	if ( ((WindowPeek)((*data) -> window))-> goAwayFlag ) slop = 32; /* make room for box */		if ( *indentL < slop ) *indentL = slop;  /* normalize it if needed */	*indentR = *indentL;	/* we'll need this for right side of title bar */	slop = 2; /* minimum distance from edge */	if ( ((WindowPeek)((*data) -> window))-> spareFlag ) slop = 32; /* make room for box */		if ( *indentR < slop ) *indentR = slop;  /* normalize it if needed */		*indentL += tempRect.left; /* this puts us at the beginning of the title string */	MoveTo(*indentL, tempRect.top + (*data)->WInfo.ascent + 1);	 /* we want to clip the right edge in case the title is too long */	    GetClip(tempRgn);	tempRect.right -= *indentR;	ClipRect(&tempRect);	SectRgn(tempRgn, (((*data) -> window))->clipRgn, (((*data) -> window))->clipRgn);		if ( ((WindowPeek)((*data) -> window))-> hilited ) { /* window is hilited */	  SetUpColor(wTextColor, &foreColor, data);	}	else {	/* unhilited requires a shade for fore color */	  SetUpRatioColor(wHiliteLight, 0x7, &foreColor, data);	}	SetUpRatioColor(wTitleBarLight, 0x1, &backColor, data); /* back color is a shade */	SetForeBackColors(&foreColor, &backColor, data);	TextMode(srcOr);	HLock((Handle)((WindowPeek)((*data) -> window))-> titleHandle);	DrawString(*(((WindowPeek)((*data) -> window))-> titleHandle));	HUnlock((Handle)((WindowPeek)((*data) -> window))-> titleHandle);		SetClip(tempRgn); /* restore clip */	DisposeRgn(tempRgn);}void DrawStripes(Rect tempRect, short indentL, short indentR, DataRecordHandle data){RGBColor foreColor;Rect saveRect = tempRect;short hilitePattern[] = {0xFF00, 0xFF00, 0xFF00, 0xFF00};	  SetUpRatioColor(wHiliteLight, 0x8, &foreColor, data);	  SetForeBackColors(&foreColor, 0L, data);	  tempRect.right = indentL;	/* where the title string begins */	  if (((WindowPeek)((*data) -> window))-> titleWidth ) 	  	tempRect.right -= 6 ; /* a little bit to the left is there is a title */		SetZone(SystemZone());		FillRect(&tempRect,(ConstPatternParam) hilitePattern);		tempRect = saveRect;		/* start again for right half */	tempRect.left =  tempRect.right - indentR; /* at the end of string */		if (((WindowPeek)((*data) -> window))-> titleWidth ) 	  tempRect.left += 6;		/* make a litle room for title */		FillRect(&tempRect,(ConstPatternParam) hilitePattern);	}/* draws the go away box if any */void DrawGoAwayBox(Rect tempRect, DataRecordHandle data){RGBColor foreColor, backColor;CTabHandle ct;	/* needed for colorization to work *//* the WDEF carries these pixmaps as resources carrying the pieces; this   is what the currently used stuff looks like.*//* for a WDEF you may want to store the data in a more convenient place *//* go away box pixel data unhilited */short  pixelsUn [] = {0xAAAA,0xAAAA,0xAAAA,0xAAAA,0xAAAA,0xAAAA,0xAAAA,0xAAAA,					0xAAAA,0xAAAA,0xAAAA,0xAAAA,0xAAAA,0xAAAA,0xAAAA,0xAAAA,					0xAAAA,0xAAAA,0xAAAA,0xAAAA,0xAAAA,0xAAAA,0xAAAA,0xAAAA,					0xAAAA,0xAAAA,0xAAAA,0xAAAA,0xAAAA,0xAAAA,0xAAAA,0xAAAA,0xAAAA};					/* go away box pixel data hilited */short pixelsHi[] = {0xFFFF,0xFFFF,0xFFF0,					0xF555,0x5F55,0x5500,					0xF5F5,0x5F55,0xF500,					0xF55F,0x5F5F,0x5500,					0xF555,0x5555,0x5500,					0xFFFF,0x555F,0xFF00,					0xF555,0x5555,0x5500,					0xF55F,0x5F5F,0x5500,					0xF5F5,0x5F55,0xF500,					0xF555,0x5F55,0x5500,					0xF000,0x0000,0x0000};const Rect pixMapBoundsRect = {0, 0, 0xB, 0xB};/* go away box pixel data unhilited */short bitsUn[] = {0xFFE0,0x8020,0x8020,0x8020,0x8020,0x8020,0x8020,0x8020,0x8020,0x8020,0xFFE0};/* go away box pixel data unhilited */short bitsHi[] = {0xFFE0,0x8420,0xA4A0,0x9520,0x8020,0xF1E0,0x8020,0x9520,0xA4A0,0x8420,0xFFE0};/* used when shades are available */PixMap pmUn =   {(Ptr)pixelsUn, 0x8006, 				{0, 0, 0xB, 0xB},				0,0,0,0x00480000, 0x00480000, 0, 4,1,4, 0, 0L, 0};PixMap pmHi =   {(Ptr)pixelsHi, 0x8006, 				{0, 0, 0xB, 0xB},				0,0,0,0x00480000, 0x00480000, 0, 4,1,4, 0, 0L, 0};/* used when colored windows are not possible */BitMap bwBmUn = {(Ptr)bitsUn, 2, pixMapBoundsRect};BitMap bwBmHi = {(Ptr)bitsHi, 2, pixMapBoundsRect};BitMapPtr bmPtr;	ct = (CTabHandle)NewHandleClear(16);		pmUn.pmTable = pmHi.pmTable = ct;		tempRect.left +=6;	tempRect.right = tempRect.left+13;	tempRect.bottom = tempRect.top+11;		SetUpRatioColor(wTitleBarLight, 0x1, &backColor, data); /* back color is a shade */	SetForeBackColors(0L, &backColor, data);	EraseRect(&tempRect); /* erase to title bar back color */		InsetRect(&tempRect, 1, 0);		if ( ! (*data)->threeDWind ) {  /* do black and white */	  if (  (*data) -> gadgetHilite )  /* draw it is hilited */	    bmPtr = &bwBmHi;	  else	    bmPtr = &bwBmUn;	}	else {/* colored calls are ok */	  if (  (*data) -> gadgetHilite ) { /* draw it is hilited */	    SetUpColor(wTitleBarDark, &foreColor, data);	    SetUpColor(wTingeBarLight, &backColor, data); /* back color is a shade */		bmPtr = (BitMap *)(&pmHi);	  }	  else {	/* unhilited requires a shade for fore color */	    SetUpColor(wTitleBarDark, &backColor, data);	    SetUpColor(wTitleBarLight, &foreColor, data); /* back color is a shade */	 	bmPtr =  (BitMap *)(&pmUn);	  }		  SetForeBackColors(&foreColor, &backColor, data);    }	CopyBits(bmPtr,&( ((*data)->window)->portBits),&(bmPtr->bounds),&tempRect,srcCopy, 0L);	if ( (*data)->threeDWind  &&  ! (*data)->gadgetHilite ) {  /* tinge only when colors are available */	  SetUpColor(wTitleBarLight, &foreColor, data); /* back color is a shade */	  SetUpColor(wTingeBarDark, &backColor, data);	  MakeRatioRGB(&foreColor, &backColor, &foreColor, 0xF);	  SetForeBackColors(&foreColor, 0L, data);	  FrameRect(&tempRect);	  MoveTo(tempRect.left+2, tempRect.bottom-2);	  LineTo(tempRect.right-2, tempRect.bottom-2);	  LineTo(tempRect.right-2, tempRect.top+2);	  tempRect.top +=1;	  tempRect.left += 1;	  SetUpRatioColor(wTingeBarLight, 0x0, &foreColor, data); /* back color is a shade */	  SetForeBackColors(&foreColor, 0L, data);	  FrameRect(&tempRect);	}	DisposeHandle((Handle) ct);}/* draws the zoom box if any */void DrawZoomBox(Rect tempRect, DataRecordHandle data){RGBColor foreColor, backColor;CTabHandle ct;	/* needed for colorization to work *//* the WDEF carries these pixmaps as resources carrying the pieces; this   is what the currently used stuff looks like.   You may want to stuff it in a more convenient place.*//* go zoom box pixel data unhilited */const short pixelsUn[] = {0xAAAA,0xAAAA,0xAAAA,0xAAAA,0xAAAA,0xAAAA,0xAAAA,0xAAAA,					0xAAAA,0xAAAA,0xAAAA,0xAAAA,0xAAAA,0xAAAA,0xAAAA,0xAAAA,					0xAAAA,0xAAAA,0xAAAA,0xAAAA,0xAAAA,0xAAAA,0xAAAA,0xAAAA,					0xAAAA,0xAAAA,0xAAAA,0xAAAA,0xAAAA,0xAAAA,0xAAAA,0xAAAA,0xAAAA};					/* go zoom box pixel data hilited */const short pixelsHi[] = {0xFFFF,0xFFFF,0xFFF0,					0xF555,0x5F55,0x5500,					0xF5F5,0x5F55,0xF500,					0xF55F,0x5F5F,0x5500,					0xF555,0x5555,0x5500,					0xFFFF,0x555F,0xFF00,					0xF555,0x5555,0x5500,					0xF55F,0x5F5F,0x5500,					0xF5F5,0x5F55,0xF500,					0xF555,0x5F55,0x5500,					0xF000,0x0000,0x0000};/* for b/w: bitmap pixels, un/hilited */			const short bitsUn[] = {0xFFE0,0x8220,0x8220,0x8220,0x8220,0x8220,0xFE20,0x8020,0x8020,0x8020,0xFFE0};const short bitsHi[] = {0xFFE0,0x8420,0xA4A0,0x9520,0x8020,0xF1E0,0x8020,0x9520,0xA4A0,0x8420,0xFFE0};/* used when shades are available */PixMap pmUn =   {(Ptr)pixelsUn, 0x8006, 				{0,0,0xB, 0xB},				0,0,0,0x00480000, 0x00480000, 0, 4,1,4, 0, 0L, 0};PixMap pmHi =   {(Ptr)pixelsHi, 0x8006, 				{0,0,0xB, 0xB},				0,0,0,0x00480000, 0x00480000, 0, 4,1,4, 0, 0L, 0};/* used when colored windows are not possible */BitMap bwBmUn = {(Ptr)bitsUn, 2, {0, 0, 0xB, 0xB}};BitMap bwBmHi = {(Ptr)bitsHi, 2, {0, 0, 0xB, 0xB}};BitMapPtr bmPtr;	ct = (CTabHandle)NewHandleClear(16);		pmUn.pmTable = pmHi.pmTable = ct;		tempRect.right -=6;	tempRect.left = tempRect.right-13;	tempRect.bottom = tempRect.top+11;		SetUpRatioColor(wTitleBarLight, 0x1, &backColor, data); /* back color is a shade */	SetForeBackColors(0L, &backColor, data);	EraseRect(&tempRect); /* erase to title bar back color */		InsetRect(&tempRect, 1, 0);		if ( ! (*data)->threeDWind ) {  /* do black and white */	  if (  (*data) -> gadgetHilite )  /* draw it is hilited */	    bmPtr = &bwBmHi;	  else	    bmPtr = &bwBmUn;	}	else {/* colored calls are ok */	  if (  (*data) -> gadgetHilite ) { /* draw it is hilited */	    SetUpColor(wTitleBarDark, &foreColor, data);	    SetUpColor(wTingeBarLight, &backColor, data); /* back color is a shade */		bmPtr = (BitMap *)(&pmHi);	  }	  else {	/* unhilited requires a shade for fore color */	    SetUpColor(wTitleBarDark, &backColor, data);	    SetUpColor(wTitleBarLight, &foreColor, data); /* back color is a shade */	 	bmPtr =  (BitMap *)(&pmUn);	  }		  SetForeBackColors(&foreColor, &backColor, data);    }	CopyBits(bmPtr,&( ((*data)->window)->portBits),&(bmPtr->bounds),&tempRect,srcCopy, 0L);	if ( (*data)->threeDWind  &&  ! (*data)->gadgetHilite ) {  /* tinge only when colors are available */	  SetUpColor(wTitleBarLight, &foreColor, data); /* back color is a shade */	  SetUpColor(wTingeBarDark, &backColor, data);	  MakeRatioRGB(&foreColor, &backColor, &foreColor, 0xF);	  SetForeBackColors(&foreColor, 0L, data);	  FrameRect(&tempRect);	  MoveTo(tempRect.left+2, tempRect.bottom-2);	  LineTo(tempRect.right-2, tempRect.bottom-2);	  LineTo(tempRect.right-2, tempRect.top+2);	  MoveTo(tempRect.left+2, tempRect.bottom-5);	  LineTo(tempRect.right-5, tempRect.bottom-5);	  LineTo(tempRect.right-5, tempRect.top+2);	  tempRect.top +=1;	  tempRect.left += 1;	  SetUpRatioColor(wTingeBarLight, 0x0, &foreColor, data); /* back color is a shade */	  SetForeBackColors(&foreColor, 0L, data);	  FrameRect(&tempRect);	}	DisposeHandle((Handle) ct);}/* this routine is called for each device intersected by the call to DeviceLoop;    QuickDraw sets the device and calls this routine.*/pascal void DoDraw(short depth, short flags,GDHandle device, DataRecordHandle data){#pragma unused (flags)RGBColor foreColor, backColor;Rect	mainRect, tempRect;short indentL, indentR;THz saveZone;		saveZone = GetZone();		CheckAvailableColors(depth, device, data);	if ( ((WindowPeek)((*data) -> window))-> hilited ) /* window is hilited */	  SetUpColor(wFrameColor, &foreColor, data);	else {	/* unhilited requires a shade get it first */	  SetUpRatioColor(wHiliteLight, 0xA, &foreColor, data);	}		SetUpColor(wContentColor, &backColor, data);		SetForeBackColors(&foreColor, &backColor, data);		mainRect = ((*data)->window)->portRect;	InsetRect(&mainRect, 10,10);	/* make the fake window smaller than the port rect so we can see it well */	FrameRect(&mainRect);		/* frame the body */		/* shadow drawing would go here */		BuildTitleRect(&mainRect, &tempRect, data);	DrawTitleString(tempRect, &indentL, &indentR, data);		InsetRect(&tempRect, 1, 1); /* make it smaller */			/* all this stuff (title bar pattern, and gadgets are drawn only if window is hilited */	if ( ((WindowPeek)((*data) -> window))-> hilited ) { /* window is hilited */	  InsetRect(&tempRect, 1, (*data)->WInfo.delta);	  mainRect = tempRect;								/* save  */	  	  DrawStripes(tempRect, indentL, indentR, data);	  if ( ((WindowPeek)((*data) -> window))-> goAwayFlag )	    DrawGoAwayBox(tempRect, data); 	  if ( ((WindowPeek)((*data) -> window))-> spareFlag ) /* if we have a zoom box */	    DrawZoomBox(tempRect, data); 	}	SetZone(saveZone);	/* just in case */	}short CalculateTHeight( DataRecordHandle data){short result, temp;	GetFontInfo((FontInfo *)&((*data)->WInfo));	result = ((*data)->WInfo.ascent + (*data)->WInfo.descent + 4) | 0x1; /* height odd for symmetry ???? */	if ( result < minTitleH ) { /* need to enforce a minimun height */	  temp = (minTitleH - result) >> 1; /* how much more small is it */	  (*data)->WInfo.ascent += temp;	/* make ascent a the minimum */	  result = minTitleH;	}	(*data)->WInfo.height = result;	(*data)->WInfo.delta = (result - 13) >> 1;		return result;}void BuildTitleRect(Rect *main, Rect *final, DataRecordHandle data){	final->top = main->top;	final->bottom = main->top + CalculateTHeight(data);	final->left = main->left;	final->right = main->right -1;}/* gets and set the fore/background colors for an operation and sets them in.   My theory is that if SetUpColor has to return black and white for all shades   then the boolean for color windows is off at the time we get here; so we use   it to decide what call to make to set the colors.*/void SetForeBackColors (RGBColor *fore, RGBColor *back,  DataRecordHandle data){	if ( (*data)->threeDWind ) { /* colored calls are ok */	  if (fore) RGBForeColor(fore);	  if (back) RGBBackColor(back);	}	else { /* need to use old style calls ************* */	  if (fore) ForeColor( *((long *)fore));	  if (back) BackColor(*((long *)back));	}}/* This proc makes sure the shades (colors) needed to draw the new style   window are present; if not the window is drawn using black and white.   The 'result' of the search is put in (*data)->threeDWind; if true then   color drawing is possible.*/void CheckAvailableColors(short depth, GDHandle device, DataRecordHandle data){GDHandle saveDevice;Boolean result = false;	saveDevice = GetGDevice();	SetGDevice(device);	(*data)->threeDWind = true; /* prime it */	if (depth >= 2) {	  if ( result = CheckShades(wHiliteLight, data) ) { 	    if ( result = CheckShades(wTitleBarLight, data) ) {		  result = CheckShades(wTingeBarLight, data); /* we found all the shades, maybe */		}	  }	}	SetGDevice(saveDevice);	(*data)->threeDWind = result;}/* this routine checks if the colors needed are present; if colors are   available it returns true otherwise it returns false.   we differ from the WDEF in the sense that the tinge shades are    tingeLight, titleBarDark, 0   tingeLight, tingeDark,	 4   titleBarLight, tingeDark, F      but in the following code we treat them as percentages of   tingeLight + tingeDark      Note that the routines where the correct shades are needed do   use the exact combination of colors (and percentage.)*/Boolean CheckShades(short what, DataRecordHandle data){long newIndex, oldIndex = 'csd ';	/* a weird index value to start with */char percent[11] =	{0x0, 0x7, 0x8, 0xA, 0xD,	/* window highlite shade percentage */					 0x0, 0x1, 0x4,				/* wTitleBar shade percentage		*/					 0x0, 0x4, 0xF};			/* Tinge shade percentages			*/RGBColor tempColor;Boolean result = true;	/* optimist */short start, next, i;	switch (what) {			case wHiliteLight:			  start = 0;			  next = 5;			  break;			case wTitleBarLight:			  start = 5;			  next = 8;			  break;			case wTingeBarLight: 			/* tinge shades should be treated differently but this is a good approximation */			  start = 8;			  next = 11;			  break;			  }	for (i=start; i< next; i++) {	  SetUpRatioColor(what, percent[i], &tempColor, data);	  newIndex = Color2Index(&tempColor);	/* get corresponding index */	  if (newIndex != oldIndex ) { /* got a different color for all shades */	    oldIndex = newIndex; /* prime index for next round */	  }	  else {	    result = false;	    goto bail;	  }	}bail:	return result;}/* this procedure returns the color in between two other colors modulo percent */void SetUpRatioColor(short hilitePart, short percent, RGBColor *tempRGB, DataRecordHandle data){RGBColor startRGB, endRGB;	SetUpColor(hilitePart, &startRGB, data);		/* parts come in pairs; once we have the light	*/	SetUpColor(hilitePart+1, &endRGB, data);		/* color the dark follows.						*/	MakeRatioRGB(&startRGB, &endRGB, tempRGB, percent);/* now find the in between color.				*/}/* takes a part number and returns the RGB color associated with it.   This proc ALWAYS returns a color.*/void SetUpColor(short part, RGBColor *rgb, DataRecordHandle data){CTabHandle auxCTable;RGBColor defaultThreeDColors[] = {{0xFFFF, 0xFFFF, 0xFFFF},		/* wContentColor 				*/								  {0x0000, 0x0000, 0x0000},		/* wFrameColor 					*/								  {0x0000, 0x0000, 0x0000},		/* wTextColor 					*/								  {0x0000, 0x0000, 0x0000},		/* wHiliteColor (not used) 		*/								 								  {0xFFFF, 0xFFFF, 0xFFFF},		/* wTitleBarColor (not used) 	*/								  {0xFFFF, 0xFFFF, 0xFFFF},		/* wHiliteLight 				*/								  {0x0000, 0x0000, 0x0000},		/* wHiliteDark 					*/								  {0xFFFF, 0xFFFF, 0xFFFF},		/* wTitleBarLight 				*/								  								  {0x0000, 0x0000, 0x0000},		/* wTitleBarDark 				*/								  {0xCCCC, 0xCCCC, 0xFFFF},		/* wDialogLight 				*/								  {0x0000, 0x0000, 0x0000},		/* wDialogDark 					*/								  {0xCCCC, 0xCCCC, 0xFFFF},		/* wTingeLight 					*/								  {0x3333, 0x3333, 0x6666}};	/* wTingeLight 					*/								  char bwColors[] = {0xFF, 0x0, 0x0, 0x0, 				   0xFF, 0x0, 0x0, 0xFF, 				   0xFF, 0x0, 0x0, 0x0, 0x0};	if ( (*data)->threeDWind ) { /* color can be used */	  if ( ! CheckCTab(part, (*data)->awCTable, rgb ) ) { /* true means we are done */	    if ( auxCTable = (CTabHandle)GetResource('wctb', 0) ) {/* the auxWind CTable is not good try loading wctb */		  if ( CheckCTab(part, auxCTable, rgb ) ) { 		    return;		  }		}		*rgb = defaultThreeDColors[part];	/* can not find colors, pass default ones */	  }	}	else { /* use black and white */	  if (part > 12 ) DebugStr("\pweird part in bw search");	  else	  	if ( bwColors[part] ) (*(long *)rgb) = whiteColor;		else (*(long *)rgb) = blackColor;	}}/* Checks if the part number is in the window color table, if it is returns true   and passes back the color. If not found it returns false and the color   remains undefined.*/Boolean CheckCTab(short part, CTabHandle target, RGBColor *rgb){short i;Boolean result = false;	for (i = 0; i <= (*target)->ctSize; i++) {	  if ( (*target)->ctTable[i].value == part ) {	    result = true;		*rgb = (*target)->ctTable[i].rgb;	    break;	  }	}	return result;}