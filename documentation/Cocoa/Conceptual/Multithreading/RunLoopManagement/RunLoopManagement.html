<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>Threading Programming Guide: Run Loop Management</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Run Loop Management"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/10000057i-CH16" title="Run Loop Management"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../index.html#//apple_ref/doc/uid/TP30000440-TP30000416" target="_top">Cocoa</a> &gt; <a href="../../../ProcessManagement-date.html#//apple_ref/doc/uid/TP30000440-TP30000416-TP30000456" target="_top">Process Management</a> &gt; <a href="../Introduction/Introduction.html#//apple_ref/doc/uid/10000057i-CH1-SW1">Threading Programming Guide</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../ThreadSafety/ThreadSafety.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../ThreadSafetySummary/ThreadSafetySummary.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/10000057i-CH16-SW1" title="Run Loop Management"></a><h1>Run Loop Management</h1><p>Run loops are part of the fundamental infrastructure associated with threads. A <strong>run loop</strong> is an event processing loop that you use to schedule work and coordinate the receipt of incoming events. The purpose of a run loop is to keep your thread busy when there is work to do and put your thread to sleep when there is none. </p><p>Run loop management is not entirely automatic. You must still design your thread’s code to start the run loop at appropriate times and respond to incoming events. Both Cocoa and Core Foundation provide <strong>run loop objects</strong> to help you configure and manage your thread’s run loop. Your application does not need to create these objects explicitly; each thread, including the application’s main thread, has an associated run loop object. Only secondary threads need to run their run loop explicitly, however. In both Carbon and Cocoa applications, the main thread automatically sets up and runs its run loop as part of the general application startup process.  </p><p>The following sections provide more information about run loops and how you configure them for your application. For additional information about run loop objects, see <em><a href="../../../Reference/Foundation/Classes/NSRunLoop_Class/index.html#//apple_ref/doc/uid/TP40003725" target="_top">NSRunLoop Class Reference</a></em> and <em><a href="../../../../CoreFoundation/Reference/CFRunLoopRef/index.html#//apple_ref/doc/uid/20001441" target="_top">CFRunLoop Reference</a></em>. </p>
<!-- This template is being used for both PDF and HTML. -->

    
    <h4>In this section:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW20">Anatomy of a Run Loop</a>
				
			<br/>
			
        
			
			
				<a href="RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW24">When Would You Use a Run Loop?</a>
				
			<br/>
			
        
			
			
				<a href="RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW5">Using Run Loop Objects</a>
				
			<br/>
			
        
			
			
				<a href="RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW7">Configuring Run Loop Sources</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/10000057i-CH16-SW20" title="Anatomy of a Run Loop"></a><h2>Anatomy of a Run Loop</h2><p>A run loop is very much like its name sounds. It is a loop your thread enters and uses to run event handlers in response to incoming events. Your code provides the control statements used to implement the actual loop portion of the run loop—in other words, your code provides the <code>while</code> or <code>for</code> loop that drives the run loop. Within your loop, you use a run loop object to "run” the event-processing code that receives events and calls the installed handlers.</p><p>A run loop receives events from two different types of sources. <strong>Input sources</strong> deliver asynchronous events, usually messages from another thread or from a different application. <strong>Timer sources</strong> deliver synchronous events, occurring at a scheduled time or repeating interval. Both types of source use an application-specific handler routine to process the event when it arrives.</p><p><span class="content_text">Figure 5-1</span> shows the conceptual structure of a run loop and a variety of sources. The input sources deliver asynchronous events to the corresponding handlers and cause the <code>runUntilDate:</code> method (called on the thread’s associated <code>NSRunLoop</code> object) to exit. Timer sources deliver events to their handler routines but do not cause the run loop to exit.</p><br/><div><a name="//apple_ref/doc/uid/10000057i-CH16-SW2" title="Figure 5-1Structure of a run loop and its sources"></a><p><strong>Figure 5-1&nbsp;&nbsp;</strong>Structure of a run loop and its sources</p><img src = "../Art/runloop.jpg" alt = "Structure of a run loop and its sources" ></div><br/><p>In addition to handling sources of input, run loops also generate notifications about the run loop’s behavior. Registered <strong>run-loop observers</strong> can receive these notifications and use them to do additional processing on the thread. You use Core Foundation to install run-loop observers on your threads. </p><p>The following sections provide more information about the components of a run loop and the modes in which they operate. They also describe the notifications that are generated at different times during the handling of events. </p><a name="//apple_ref/doc/uid/10000057i-CH16-SW12" title="Run Loop Modes"></a><h3>Run Loop Modes</h3><p>A <strong>run loop mode</strong> is a collection of input sources and timers to be monitored and a collection of run loop observers to be notified. Each time you run your run loop, you specify (either explicitly or implicitly) a particular “mode” in which to run. During that pass of the run loop, only sources associated with that mode are monitored and allowed to deliver their events. (Similarly, only observers associated with that mode are notified of the run loop’s progress.) Sources associated with other modes hold on to any new events until subsequent passes through the loop in the appropriate mode.</p><p>In your code, you identify modes by name. Both Cocoa and Core Foundation define a default mode and several commonly used modes, along with strings for specifying those modes in your code. You can define custom modes by simply specifying a custom string for the mode name. Although the names you assign to custom modes are arbitrary, the contents of those modes are not. You must be sure to add one or more input sources, timers, or run-loop observers to any modes you create for them to be useful.</p><p>You use modes to filter out events from unwanted sources during a particular pass through your run loop. Most of the time, you will want to run your run loop in the system-defined “default” mode. A modal panel, however, might run in the “modal” mode. While in this mode, only sources relevant to the modal panel would deliver events to the thread. For secondary threads, you might use custom modes to prevent low-priority sources from delivering events during time-critical operations. </p><div class="notebox"><a name="//apple_ref/doc/uid/10000057i-CH16-SW48" title="Note"></a><p><strong>Note:</strong>&nbsp;Modes discriminate based on the source of the event, not the type of the event. For example, you would not use modes to match only mouse-down events or only keyboard events. You could use modes to listen to a different set of ports, suspend timers temporarily, or otherwise change the sources and run loop observers currently being monitored.  </p></div><p><span class="content_text">Table 5-1</span> lists the standard modes defined by Cocoa and Core Foundation along with a description of when you use that mode. The name column lists the actual constants you use to specify the mode in your code.  </p><a name="//apple_ref/doc/uid/10000057i-CH16-SW17" title="Table 5-1Predefined run loop modes"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 5-1&nbsp;&nbsp;</strong>Predefined run loop modes</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Mode</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Name</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Description</p></th></tr><tr><td  scope="row"><p>Default</p></td><td ><p><code>NSDefaultRunLoopMode</code> (Cocoa)</p><p><code>kCFRunLoopDefaultMode</code> (Core Foundation)</p></td><td ><p>The default mode is the one used for most operations. Most of the time, you should use this mode to start your run loop and configure your input sources. </p></td></tr><tr><td  scope="row"><p>Connection</p></td><td ><p><code>NSConnectionReplyMode</code> (Cocoa)</p></td><td ><p>Cocoa uses this mode in conjunction with <code>NSConnection</code> objects to monitor replies. You should rarely need to use this mode yourself.</p></td></tr><tr><td  scope="row"><p>Modal</p></td><td ><p><code>NSModalPanelRunLoopMode</code> (Cocoa)</p></td><td ><p>Cocoa uses this mode to identify events intended for modal panels. </p></td></tr><tr><td  scope="row"><p>Event tracking</p></td><td ><p><code>NSEventTrackingRunLoopMode</code> (Cocoa)</p></td><td ><p>Cocoa uses this mode to restrict incoming events during mouse-dragging loops and other sorts of user interface tracking loops. </p></td></tr><tr><td  scope="row"><p>Common modes</p></td><td ><p><code>NSRunLoopCommonModes</code> (Cocoa)</p><p><code>kCFRunLoopCommonModes</code> (Core Foundation)</p></td><td ><p>This is a configurable group of commonly used modes. Associating an input source with this mode also associates it with each of the modes in the group. For Cocoa applications, this set includes the default, modal, and event tracking modes by default. Core Foundation includes just the default mode initially. You can add custom modes to the set using the <code><a href="../../../../CoreFoundation/Reference/CFRunLoopRef/Reference/reference.html#//apple_ref/c/func/CFRunLoopAddCommonMode" target="_top">CFRunLoopAddCommonMode</a></code> function.</p></td></tr></table></div><a name="//apple_ref/doc/uid/10000057i-CH16-SW19" title="Input Sources"></a><h3>Input Sources</h3><p>Input sources deliver events asynchronously to your threads. The source of the event depends on the type of the input source, which is generally one of two categories. Port-based input sources monitor your application’s Mach ports. Custom input sources monitor custom sources of events. As far as your run loop is concerned, it should not matter whether an input source is port-based or custom. Mac OS X itself implements input sources of both types that you can use as is. The only difference between the two sources is how they are signaled. Port-based sources are signaled automatically by the kernel, and custom sources must be signaled manually from another thread. </p><p>When you create an input source, you assign it to one or more modes of your run loop. Modes affect which input sources are monitored at any given moment. Most of the time, you run the run loop in the default mode, but you can specify custom modes too. If an input source is not in the currently monitored mode, any events it generates are held until the run loop runs in the correct mode. </p><p>The following sections describe some of the input sources found in Mac OS X.</p><a name="//apple_ref/doc/uid/10000057i-CH16-SW45" title="Port-Based Sources"></a><h4>Port-Based Sources</h4><p>Cocoa and Core Foundation provide built-in support for creating port-based input sources using port-related objects and functions. For example, in Cocoa, you never have to create an input source directly at all. You simply create a port object and use the methods of <code>NSPort</code> to add that port to the run loop. The port object handles the creation and configuration of the needed input source for you.</p><p>In Core Foundation, you must manually create both the port and its run loop source. In both cases, you use the functions associated with the port opaque type (<code><a href="../../../../CoreFoundation/Reference/CFMachPortRef/Reference/reference.html#//apple_ref/c/tdef/CFMachPortRef" target="_top">CFMachPortRef</a></code>, <code><a href="../../../../CoreFoundation/Reference/CFMessagePortRef/Reference/reference.html#//apple_ref/c/tdef/CFMessagePortRef" target="_top">CFMessagePortRef</a></code>, or <code><a href="../../../../CoreFoundation/Reference/CFSocketRef/Reference/reference.html#//apple_ref/c/tdef/CFSocketRef" target="_top">CFSocketRef</a></code>) to create the appropriate objects.</p><p>For examples of how to set up and configure custom port-based sources, see <span class="content_text"><a href="RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-131281">“Configuring a Port-Based Input Source.”</a></span> </p><a name="//apple_ref/doc/uid/10000057i-CH16-SW46" title="Custom Input Sources"></a><h4>Custom Input Sources</h4><p>To create a custom input source, you must use the functions associated with the <code>CFRunLoopSourceRef</code> opaque type in Core Foundation. You configure a custom input source using several callback functions. Core Foundation calls these functions at different points to configure the source, handle any incoming events, and tear down the source when it is removed from the run loop. </p><p>In addition to defining the behavior of the custom source when an event arrives, you must also define the event delivery mechanism. This part of the source runs on a separate thread and is responsible for providing the input source with its data and for signaling it when that data is ready for processing. The event delivery mechanism is up to you but need not be overly complex.</p><p>For an example of how to create a custom input source, see <span class="content_text"><a href="RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW3">“Defining a Custom Input Source.”</a></span> For reference information for custom input sources, see also <em><a href="../../../../CoreFoundation/Reference/CFRunLoopSourceRef/index.html#//apple_ref/doc/uid/20001443" target="_top">CFRunLoopSource Reference</a></em>. </p><a name="//apple_ref/doc/uid/10000057i-CH16-SW44" title="Cocoa Perform Selector Sources"></a><h4>Cocoa Perform Selector Sources</h4><p>In addition to port-based sources, Cocoa defines a custom input source that allows you to perform a selector on any thread. Like a port-based source, perform selector requests are serialized on the target thread, alleviating many of the synchronization problems that might occur with multiple methods being run on one thread. Unlike a port-based source, a perform selector source removes itself from the run loop after it performs its selector. </p><div class="notebox"><a name="//apple_ref/doc/uid/10000057i-CH16-SW49" title="Note"></a><p><strong>Note:</strong>&nbsp;Prior to Mac OS X v10.5, perform selector sources were used mostly to send messages to the main thread, but in Mac OS X v10.5 and later, you can use them to send messages to any thread.</p></div><p>When performing a selector on another thread, the target thread must have an active run loop. For threads you create, this means waiting until your code explicitly starts the run loop. Because the main thread starts its own run loop, however, you can begin issuing calls on that thread as soon as your application sends its <code>applicationDidFinishLaunching:</code> notification. The run loop processes all queued perform selector calls each time through the loop, rather than processing one during each loop iteration.</p><p><span class="content_text">Table 5-2</span> lists the methods defined on <code>NSObject</code> that can be used to perform selectors on other threads. Because these methods are declared on <code>NSObject</code>, you can use them from any threads where you have access to Objective-C objects, including POSIX threads. These methods do not actually create a new thread to perform the selector. </p><a name="//apple_ref/doc/uid/10000057i-CH16-SW43" title="Table 5-2Performing selectors on other threads"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 5-2&nbsp;&nbsp;</strong>Performing selectors on other threads</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Methods</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Description</p></th></tr><tr><td  scope="row"><p><code>performSelectorOnMainThread:withObject:waitUntilDone:</code></p><p><code>performSelectorOnMainThread:withObject:waitUntilDone:modes:</code></p></td><td ><p>Performs the specified selector on the application’s main thread during that thread’s next run loop cycle. These methods give you the option of blocking the current thread until the selector is performed. </p></td></tr><tr><td  scope="row"><p><code>performSelector:onThread:withObject:waitUntilDone:</code></p><p><code>performSelector:onThread:withObject:waitUntilDone:modes:</code></p></td><td ><p>Performs the specified selector on any thread for which you have an <code>NSThread</code> object. These methods give you the option of blocking the current thread until the selector is performed.</p></td></tr><tr><td  scope="row"><p><code>performSelector:withObject:afterDelay:</code></p><p><code>performSelector:withObject:afterDelay:inModes:</code></p></td><td ><p>Performs the specified selector on the current thread during the next run loop cycle and after an optional delay period. Because it waits until the next run loop cycle to perform the selector, these methods provide an automatic mini delay from the currently executing code. Multiple queued selectors are performed one after another in the order they were queued.</p></td></tr><tr><td  scope="row"><p><code>cancelPreviousPerformRequestsWithTarget:</code></p><p><code>cancelPreviousPerformRequestsWithTarget:selector:object:</code></p></td><td ><p>Lets you cancel a message sent to the current thread using the <code>performSelector:withObject:afterDelay:</code> or <code>performSelector:withObject:afterDelay:inModes:</code> method.</p></td></tr></table></div><p>For detailed information about each of these methods, see <em><a href="../../../Reference/Foundation/Classes/NSObject_Class/index.html#//apple_ref/doc/uid/TP40003706" target="_top">NSObject Class Reference</a></em>. </p><a name="//apple_ref/doc/uid/10000057i-CH16-SW21" title="Timer Sources"></a><h3>Timer Sources</h3><p>Timer sources deliver events synchronously to your threads at a preset time in the future. Timers are a way for a thread to notify itself to do something. For example, a search field could use a timer to initiate an automatic search once a certain amount of time has passed between successive key strokes from the user. The use of this delay time gives the user a chance to type as much of the desired search string as possible before beginning the search. </p><p>Although it generates time-based notifications, a timer is not a real-time mechanism. Like input sources, timers are associated with specific modes of your run loop. If a timer is not in the mode currently being monitored by the run loop, it does not fire until you run the run loop in one of the timer’s supported modes. Similarly, if a timer fires when the run loop is in the middle of executing a handler routine, the timer waits until the next time through the run loop to invoke its handler routine. If the run loop is not running at all, the timer never fires. </p><p>You can configure timers to generate events only once or repeatedly. A repeating timer reschedules itself automatically based on the scheduled firing time, not the actual firing time. For example, if a timer is scheduled to fire at a particular time and every 5 seconds after that, the scheduled firing time will always fall on the original 5 second time intervals, even if the actual firing time gets delayed. If the firing time is delayed so much that it misses one or more of the scheduled firing times, the timer is fired only once for the missed time period. After firing for the missed period, the timer is rescheduled for the next scheduled firing time.</p><p>For more information on configuring timer sources, see <span class="content_text"><a href="RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW6">“Configuring Timer Sources.”</a></span> For reference information, see <em><a href="../../../Reference/Foundation/Classes/NSTimer_Class/index.html#//apple_ref/doc/uid/TP40003747" target="_top">NSTimer Class Reference</a></em> or <em><a href="../../../../CoreFoundation/Reference/CFRunLoopTimerRef/index.html#//apple_ref/doc/uid/20001444" target="_top">CFRunLoopTimer Reference</a></em>. </p><a name="//apple_ref/doc/uid/10000057i-CH16-SW22" title="Run Loop Observers"></a><h3>Run Loop Observers</h3><p>In contrast to sources, which fire when an appropriate asynchronous or synchronous event occurs, run loop observers fire at special locations during the execution of the run loop itself. You might use run loop observers to prepare your thread to process a given event or to prepare the thread before it goes to sleep. You can associate run loop observers with the following events in your run loop:</p><ul class="spaceabove"><li class="li"><p>The entrance to the run loop. </p></li><li class="li"><p>When the run loop is about to process a timer.</p></li><li class="li"><p>When the run loop is about to process an input source.</p></li><li class="li"><p>When the run loop is about to go to sleep.</p></li><li class="li"><p>When the run loop has woken up, but before it has processed the event that woke it up.</p></li><li class="li"><p>The exit from the run loop. </p></li></ul><p>You can add run loop observers to both Cocoa and Carbon applications, but to define one and add it to your run loop, you must use Core Foundation. To create a run loop observer, you create a new instance of the <code>CFRunLoopObserver</code> opaque type. This type keeps track of your custom callback function and the activities in which it is interested. </p><p>Similar to timers, run-loop observers can be used once or repeatedly. A one-shot observer removes itself from the run loop after it fires, while a repeating observer remains attached. You specify whether an observer runs once or repeatedly when you create it. </p><p>For an example of how to create a run-loop observer, see <span class="content_text"><a href="RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW18">“Configuring the Run Loop.”</a></span> For reference information, see <em><a href="../../../../CoreFoundation/Reference/CFRunLoopObserverRef/index.html#//apple_ref/doc/uid/20001442" target="_top">CFRunLoopObserver Reference</a></em>. </p><a name="//apple_ref/doc/uid/10000057i-CH16-SW23" title="The Run Loop Sequence of Events"></a><h3>The Run Loop Sequence of Events</h3><p>Each time you run it, your thread’s run loop processes pending events and generates notifications for any attached observers. The order in which it does this is very specific and is as follows: </p><ol class="ol"><li class="li"><p>Notify observers that the run loop has been entered.</p></li><li class="li"><p>Notify observers that any ready timers are about to fire.</p></li><li class="li"><p>Notify observers that any input sources that are not port based are about to fire.</p></li><li class="li"><p>Fire any non-port-based input sources that are ready to fire.</p></li><li class="li"><p>If a port-based input source is ready and waiting to fire, process the event immediately. Go to step 9. </p></li><li class="li"><p>Notify observers that the thread is about to sleep.</p></li><li class="li"><p>Put the thread to sleep until one of the following events occurs:</p><ul class="ul"><li class="li"><p>An event arrives for a port-based input source.</p></li><li class="li"><p>A timer fires.</p></li><li class="li"><p>The timeout value set for the run loop expires.</p></li><li class="li"><p>The run loop is explicitly woken up. </p></li></ul></li><li class="li"><p>Notify observers that the thread just woke up.</p></li><li class="li"><p>Process the pending event.</p><ul class="ul"><li class="li"><p>If a user-defined timer fired, process the timer event and restart the loop. Go to step 2.</p></li><li class="li"><p>If an input source fired, deliver the event.</p></li><li class="li"><p>If the run loop was explicitly woken up but has not yet timed out, restart the loop. Go to step 2.</p></li></ul></li><li class="li"><p>Notify observers that the run loop has exited.</p></li></ol><p>Because observer notifications for timer and input sources are delivered before those events actually occur, there may be a gap between the time of the notifications and the time of the actual events. If the timing between these events is critical, you can use the sleep and awake-from-sleep notifications to help you correlate the timing between the actual events.</p><p>Because timers and other periodic events are delivered when you run the run loop, circumventing that loop disrupts the delivery of those events. The typical example of this behavior occurs whenever you implement a mouse-tracking routine by entering a loop and repeatedly requesting events from the application. Because your code is grabbing events directly, rather than letting the application dispatch those events normally, active timers would be unable to fire until after your mouse-tracking routine exited and returned control to the application.</p><p>A run loop can be explicitly woken up using the run loop object. Other events may also cause the run loop to be woken up. For example, adding another non-port-based input source wakes up the run loop so that the input source can be processed immediately, rather than waiting until some other event occurs.</p><a name="//apple_ref/doc/uid/10000057i-CH16-SW24" title="When Would You Use a Run Loop?"></a><h2>When Would You Use a Run Loop?</h2><p>The only time you need to run a run loop explicitly is when you create secondary threads for your application. The run loop for your application’s main thread is a crucial piece of infrastructure. As a result, both Cocoa and Carbon provide the code for running the main application loop and start that loop automatically. The <code>run</code> method of <code>NSApplication</code> starts a Cocoa application’s main loop as part of the normal startup sequence. Similarly, the <code>RunApplicationEventLoop</code> function starts the main loop for Carbon applications. If you use the Xcode template projects to create your application, you should never have to call these routines explicitly.</p><p>For secondary threads, you need to decide whether a run loop is necessary, and if it is, configure and start it yourself. You do not need to start a thread’s run loop in all cases. For example, if you use a thread to perform some long-running and predetermined task, you can probably avoid starting the run loop. Run loops are intended for situations where you want more interactivity with the thread. For example, you need to start a run loop if you plan to do any of the following: </p><ul class="ul"><li class="li"><p>Use ports or custom input sources to communicate with other threads. </p></li><li class="li"><p>Use timers on the thread. </p></li><li class="li"><p>Use any of the <code>performSelector</code>… methods in a Cocoa application.  </p></li><li class="li"><p>Keep the thread around to perform periodic tasks.</p></li></ul><p>If you do choose to use a run loop, the configuration and setup is straightforward. As with all threaded programming though, you should have a plan for exiting your secondary threads in appropriate situations. It is always better to end a thread cleanly by letting it exit than to force it to terminate. Information on how to configure and exit a run loop is described in <span class="content_text"><a href="RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW5">“Using Run Loop Objects.”</a></span> </p><a name="//apple_ref/doc/uid/10000057i-CH16-SW5" title="Using Run Loop Objects"></a><h2>Using Run Loop Objects</h2><p>A run loop object provides the main interface for adding input sources, timers, and run-loop observers to your run loop and then running it. Every thread has a single run loop object associated with it. In Cocoa, this object is an instance of the <code><a href="../../../Reference/Foundation/Classes/NSRunLoop_Class/Reference/Reference.html#//apple_ref/occ/cl/NSRunLoop" target="_top">NSRunLoop</a></code> class. In a Carbon or BSD application, it is a pointer to a <code><a href="../../../../CoreFoundation/Reference/CFRunLoopRef/Reference/reference.html#//apple_ref/c/tdef/CFRunLoopRef" target="_top">CFRunLoopRef</a></code> opaque type.</p><a name="//apple_ref/doc/uid/10000057i-CH16-SW47" title="Getting a Run Loop Object"></a><h3>Getting a Run Loop Object</h3><p>To get the run loop for the current thread, you use one of the following:</p><ul class="spaceabove"><li class="li"><p>In a Cocoa application, use the <code>currentRunLoop</code> class method of <code>NSRunLoop</code> to retrieve an <code>NSRunLoop</code> object. </p></li><li class="li"><p>Use the <code>CFRunLoopGetCurrent</code> function.</p></li></ul><p>Although they are not toll-free bridged types, you can get a <code>CFRunLoopRef</code> opaque type from an <code>NSRunLoop</code> object when needed. The <code>NSRunLoop</code> class defines a <code>getCFRunLoop</code> method that returns a <code>CFRunLoopRef</code> type that you can pass to Core Foundation routines. Because both objects refer to the same run loop, you can intermix calls to the <code>NSRunLoop</code> object and <code>CFRunLoopRef</code> opaque type as needed. </p><a name="//apple_ref/doc/uid/10000057i-CH16-SW18" title="Configuring the Run Loop"></a><h3>Configuring the Run Loop</h3><p>Before you run a run loop on a secondary thread, you must add at least one input source or timer to it. If a run loop does not have any sources to monitor, it exits immediately when you try to run it. For examples of how to add sources to a run loop, see <span class="content_text"><a href="RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW7">“Configuring Run Loop Sources.”</a></span></p><p>In addition to installing sources, you can also install run loop observers and use them to detect different execution stages of the run loop. To install a run loop observer, you create a <code>CFRunLoopObserverRef</code> opaque type and use the <code>CFRunLoopAddObserver</code> function to add it to your run loop. Run loop observers must be created using Core Foundation, even for Cocoa applications.</p><p><span class="content_text">Listing 5-1</span> shows the main routine for a thread that attaches a run loop observer to its run loop. The purpose of the example is to show you how to create a run loop observer, so the code simply sets up a run loop observer to monitor all run loop activities. The basic handler routine (not shown) simply logs the run loop activity as it processes the timer requests.  </p><a name="//apple_ref/doc/uid/10000057i-CH16-SW13" title="Listing 5-1Creating a run loop observer"></a><p class="codesample"><strong>Listing 5-1&nbsp;&nbsp;</strong>Creating a run loop observer</p><div class="codesample"><table><tr><td scope="row"><pre>- (void)threadMain<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    // The application uses garbage collection, so no autorelease pool is needed.<span></span></pre></td></tr><tr><td scope="row"><pre>    NSRunLoop* myRunLoop = [NSRunLoop currentRunLoop];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Create a run loop observer and attach it to the run loop.<span></span></pre></td></tr><tr><td scope="row"><pre>    CFRunLoopObserverContext  context = {0, self, NULL, NULL, NULL};<span></span></pre></td></tr><tr><td scope="row"><pre>    CFRunLoopObserverRef    observer = CFRunLoopObserverCreate(kCFAllocatorDefault,<span></span></pre></td></tr><tr><td scope="row"><pre>            kCFRunLoopAllActivities, YES, 0, &amp;myRunLoopObserver, &amp;context);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if (observer)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        CFRunLoopRef    cfLoop = [myRunLoop getCFRunLoop];<span></span></pre></td></tr><tr><td scope="row"><pre>        CFRunLoopAddObserver(cfLoop, observer, kCFRunLoopDefaultMode);<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Create and schedule the timer.<span></span></pre></td></tr><tr><td scope="row"><pre>    [NSTimer scheduledTimerWithTimeInterval:0.1 target:self<span></span></pre></td></tr><tr><td scope="row"><pre>                selector:@selector(doFireTimer:) userInfo:nil repeats:YES];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    NSInteger    loopCount = 10;<span></span></pre></td></tr><tr><td scope="row"><pre>    do<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        // Run the run loop 10 times to let the timer fire.<span></span></pre></td></tr><tr><td scope="row"><pre>        [myRunLoop runUntilDate:[NSDate dateWithTimeIntervalSinceNow:1]];<span></span></pre></td></tr><tr><td scope="row"><pre>        loopCount--;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    while (loopCount);<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>When configuring the run loop for a long-lived thread, it is better to add at least one input source to receive messages. Although you can enter the run loop with only a timer attached, once the timer fires, it is typically invalidated, which would then cause the run loop to exit. Attaching a repeating timer could keep the run loop running over a longer period of time, but would involve firing the timer periodically to wake your thread, which is effectively another form of polling. By contrast, an input source waits for an event to happen, keeping your thread asleep until it does.</p><a name="//apple_ref/doc/uid/10000057i-CH16-SW25" title="Starting the Run Loop"></a><h3>Starting the Run Loop</h3><p>Starting the run loop is necessary only for the secondary threads in your application. A run loop must have at least one input source or timer to monitor. If one is not attached, the run loop exits immediately. </p><p>There are several ways to start the run loop, including the following: </p><ul class="spaceabove"><li class="li"><p>Unconditionally</p></li><li class="li"><p>With a set time limit</p></li><li class="li"><p>In a particular mode</p></li></ul><p>Entering your run loop unconditionally is the simplest option, but it is also the least desirable. Running your run loop unconditionally puts the thread into a permanent loop, which gives you very little control over the run loop itself. You can add and remove input sources and timers, but the only way to stop the run loop is to kill it. There is also no way to run the run loop in a custom mode.</p><p>Instead of running a run loop unconditionally, it is better to run the run loop with a timeout value. When you use a timeout value, the run loop runs until an event arrives or the allotted time expires. If an event arrives, that event is dispatched to a handler for processing and then the run loop exits. Your code can then restart the run loop to handle the next event. If the allotted time expires instead, you can simply restart the run loop or use the time to do any needed housekeeping.</p><p>In addition to a timeout value, you can also run your run loop using a specific mode. Modes and timeout values are not mutually exclusive and can both be used when starting a run loop. Modes limit the types of sources that deliver events to the run loop and are described in more detail in <span class="content_text"><a href="RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW12">“Run Loop Modes.”</a></span></p><p><span class="content_text">Listing 5-2</span> shows a skeleton version of a thread’s main entry routine. The key portion of this example shows the basic structure of a run loop. In essence, you add your input sources and timers to the run loop and then repeatedly call one of the routines to start the run loop. Each time the the run loop routine returns, you check to see if any conditions have arisen that might warrant exiting the thread. The example uses the Core Foundation run loop routines so that it can check the return result and determine why the run loop exited. You could also use the methods of the <code>NSRunLoop</code> class to run the run loop in a similar manner if you are using Cocoa and do not need to check the return value. (For an example of a run loop that calls methods of the <code>NSRunLoop</code> class, see <span class="content_text"><a href="RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW9">Listing 5-14</a></span>.) </p><a name="//apple_ref/doc/uid/10000057i-CH16-SW14" title="Listing 5-2Running a run loop"></a><p class="codesample"><strong>Listing 5-2&nbsp;&nbsp;</strong>Running a run loop</p><div class="codesample"><table><tr><td scope="row"><pre>- (void)skeletonThreadMain<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    // Set up an autorelease pool here if not using garbage collection.<span></span></pre></td></tr><tr><td scope="row"><pre>    BOOL done = NO;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Add your sources or timers to the run loop and do any other setup.<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    do<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        // Start the run loop but return after each source is handled.<span></span></pre></td></tr><tr><td scope="row"><pre>        SInt32    result = CFRunLoopRunInMode(kCFRunLoopDefaultMode, 10, YES);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        // If a source explicitly stopped the run loop, or if there are no<span></span></pre></td></tr><tr><td scope="row"><pre>        // sources or timers, go ahead and exit.<span></span></pre></td></tr><tr><td scope="row"><pre>        if ((result == kCFRunLoopRunStopped) || (result == kCFRunLoopRunFinished))<span></span></pre></td></tr><tr><td scope="row"><pre>            done = YES;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        // Check for any other exit conditions here and set the<span></span></pre></td></tr><tr><td scope="row"><pre>        // done variable as needed.<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    while (!done);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Clean up code here. Be sure to release any allocated autorelease pools.<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>It is possible to run a run loop recursively. In other words, you can call <code>CFRunLoopRun</code>,  <code>CFRunLoopRunInMode</code>, or any of the <code>NSRunLoop</code> methods for starting the run loop from within the handler routine of an input source or timer. When doing so, you can use any mode you want to run the nested run loop, including the mode in use by the outer run loop.</p><a name="//apple_ref/doc/uid/10000057i-CH16-SW4" title="Exiting the Run Loop"></a><h3>Exiting the Run Loop</h3><p>There are two ways to make a run loop exit before it has processed an event: </p><ul class="spaceabove"><li class="li"><p>Configure the run loop to run with a timeout value. </p></li><li class="li"><p>Tell the run loop to stop.</p></li></ul><p>Using a timeout value is certainly preferred, if you can manage it. Specifying a timeout value lets the run loop finish all of its normal processing, including delivering notifications to run loop observers, before exiting. </p><p>Stopping the run loop explicitly with the <code>CFRunLoopStop</code> function produces a result similar to a timeout. The run loop sends out any remaining run-loop notifications and then exits. The difference is that you can use this technique on run loops you started unconditionally. </p><p>Although removing a run loop’s input sources and timers may also cause the run loop to exit, this is not a reliable way to stop a run loop. Some system routines add input sources to a run loop to handle needed events. Because your code might not be aware of these input sources, it would be unable to remove them, which would prevent the run loop from exiting. </p><a name="//apple_ref/doc/uid/10000057i-CH16-SW26" title="Thread Safety and Run Loop Objects"></a><h3>Thread Safety and Run Loop Objects</h3><p>Thread safety varies depending on which API you are using to manipulate your run loop. The functions in Core Foundation are generally thread-safe and can be called from any thread. If you are performing operations that alter the configuration of the run loop, however, it is still good practice to do so from the thread that owns the run loop whenever possible. </p><p>The Cocoa <code>NSRunLoop</code> class is not as inherently thread safe as its Core Foundation counterpart. If you are using the <code>NSRunLoop</code> class to modify your run loop, you should do so only from the same thread that owns that run loop. Adding an input source or timer to a run loop belonging to a different thread could cause your code to crash or behave in an unexpected way. </p><a name="//apple_ref/doc/uid/10000057i-CH16-SW7" title="Configuring Run Loop Sources"></a><h2>Configuring Run Loop Sources</h2><p>The following sections show examples of how to set up different types of input sources in both Cocoa and Core Foundation.</p><a name="//apple_ref/doc/uid/10000057i-CH16-SW3" title="Defining a Custom Input Source"></a><h3>Defining a Custom Input Source</h3><p>Creating a custom input source involves defining the following: </p><ul class="spaceabove"><li class="li"><p>The information you want your input source to process. </p></li><li class="li"><p>A scheduler routine to let interested clients know how to contact your input source.</p></li><li class="li"><p>A handler routine to perform requests sent by any clients.</p></li><li class="li"><p>A cancellation routine to invalidate your input source. </p></li></ul><p>Because you create a custom input source to process custom information, the actual configuration is designed to be flexible. The scheduler, handler, and cancellation routines are the key routines you almost always need for your custom input source. Most of the rest of the input source behavior, however, happens outside of those handler routines. For example, it is up to you to define the mechanism for passing data to your input source and for communicating the presence of your input source to other threads.</p><p><span class="content_text">Figure 5-2</span> shows a sample configuration of a custom input source. In this example, the application’s main thread maintains references to the input source, the custom command buffer for that input source, and the run loop on which the input source is installed. When the main thread has a task it wants to hand off to the worker thread, it posts a command to the command buffer along with any information needed by the worker thread to start the task. (Because both the main thread and the input source of the worker thread have access to the command buffer, that access must be synchronized.) Once the command is posted, the main thread signals the input source and wakes up the worker thread’s run loop. Upon receiving the wake up command, the run loop calls the handler for the input source, which processes the commands found in the command buffer.</p><br/><div><a name="//apple_ref/doc/uid/10000057i-CH16-SW31" title="Figure 5-2Operating a custom input source"></a><p><strong>Figure 5-2&nbsp;&nbsp;</strong>Operating a custom input source</p><img src = "../Art/custominputsource.jpg" alt = "Operating a custom input source" ></div><br/><p>The following sections explain the implementation of the custom input source from the preceding figure and show the key code you would need to implement.</p><a name="//apple_ref/doc/uid/10000057i-CH16-SW40" title="Defining the Input Source"></a><h4>Defining the Input Source</h4><p>Defining a custom input source requires the use of Core Foundation routines to configure your run loop source and attach it to a run loop. Although the basic handlers are C-based functions, that does not preclude you from writing wrappers for those functions and using Objective-C or C++ to implement the body of your code. </p><p>The input source introduced in <span class="content_text"><a href="RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW31">Figure 5-2</a></span> uses an Objective-C object to manage a command buffer and coordinate with the run loop. <span class="content_text">Listing 5-3</span> shows the definition of this object. The <code>RunLoopSource</code> object manages a command buffer and uses that buffer to receive messages from other threads. This listing also shows the definition of the <code>RunLoopContext</code> object, which is really just a container object used to pass a <code>RunLoopSource</code> object and a run loop reference to the application’s main thread.  </p><a name="//apple_ref/doc/uid/10000057i-CH16-SW38" title="Listing 5-3The custom input source object definition"></a><p class="codesample"><strong>Listing 5-3&nbsp;&nbsp;</strong>The custom input source object definition</p><div class="codesample"><table><tr><td scope="row"><pre>@interface RunLoopSource : NSObject<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    CFRunLoopSourceRef runLoopSource;<span></span></pre></td></tr><tr><td scope="row"><pre>    NSMutableArray* commands;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (id)init;<span></span></pre></td></tr><tr><td scope="row"><pre>- (void)addToCurrentRunLoop;<span></span></pre></td></tr><tr><td scope="row"><pre>- (void)invalidate;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>// Handler method<span></span></pre></td></tr><tr><td scope="row"><pre>- (void)sourceFired;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>// Client interface for registering commands to process<span></span></pre></td></tr><tr><td scope="row"><pre>- (void)addCommand:(NSInteger)command withData:(id)data;<span></span></pre></td></tr><tr><td scope="row"><pre>- (void)fireAllCommandsOnRunLoop:(CFRunLoopRef)runloop;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>// These are the CFRunLoopSourceRef callback functions.<span></span></pre></td></tr><tr><td scope="row"><pre>void RunLoopSourceScheduleRoutine (void *info, CFRunLoopRef rl, CFStringRef mode);<span></span></pre></td></tr><tr><td scope="row"><pre>void RunLoopSourcePerformRoutine (void *info);<span></span></pre></td></tr><tr><td scope="row"><pre>void RunLoopSourceCancelRoutine (void *info, CFRunLoopRef rl, CFStringRef mode);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>// RunLoopContext is a container object used during registration of the input source.<span></span></pre></td></tr><tr><td scope="row"><pre>@interface RunLoopContext : NSObject<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    CFRunLoopRef        runLoop;<span></span></pre></td></tr><tr><td scope="row"><pre>    RunLoopSource*        source;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre>@property (readonly) CFRunLoopRef runLoop;<span></span></pre></td></tr><tr><td scope="row"><pre>@property (readonly) RunLoopSource* source;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (id)initWithSource:(RunLoopSource*)src andLoop:(CFRunLoopRef)loop;<span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr></table></div><p>Although the Objective-C code manages the custom data of the input source, attaching the input source to a run loop requires C-based callback functions. The first of these functions is called when you actually attach the run loop source to your run loop, and is shown in <span class="content_text">Listing 5-4</span>. Because this input source has only one client (the main thread), it uses the scheduler function to send a message to register itself with the application delegate on that thread. When the delegate wants to communicate with the input source, it uses the information in <code>RunLoopContext</code> object to do so. </p><a name="//apple_ref/doc/uid/10000057i-CH16-SW32" title="Listing 5-4Scheduling a run loop source"></a><p class="codesample"><strong>Listing 5-4&nbsp;&nbsp;</strong>Scheduling a run loop source</p><div class="codesample"><table><tr><td scope="row"><pre>void RunLoopSourceScheduleRoutine (void *info, CFRunLoopRef rl, CFStringRef mode)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    RunLoopSource* obj = (RunLoopSource*)info;<span></span></pre></td></tr><tr><td scope="row"><pre>    AppDelegate*   del = [AppDelegate sharedAppDelegate];<span></span></pre></td></tr><tr><td scope="row"><pre>    RunLoopContext* theContext = [[RunLoopContext alloc] initWithSource:obj andLoop:rl];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    [del performSelectorOnMainThread:@selector(registerSource:)<span></span></pre></td></tr><tr><td scope="row"><pre>                                withObject:theContext waitUntilDone:NO];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>One of the most important callback routines is the one used to process custom data when your input source is signaled. <span class="content_text">Listing 5-5</span> shows the perform callback routine associated with the <code>RunLoopSource</code> object. This function simply forwards the request to do the work to the <code>sourceFired</code> method, which then processes any commands present in the command buffer. </p><a name="//apple_ref/doc/uid/10000057i-CH16-SW33" title="Listing 5-5Performing work in the input source"></a><p class="codesample"><strong>Listing 5-5&nbsp;&nbsp;</strong>Performing work in the input source</p><div class="codesample"><table><tr><td scope="row"><pre>void RunLoopSourcePerformRoutine (void *info)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    RunLoopSource*  obj = (RunLoopSource*)info;<span></span></pre></td></tr><tr><td scope="row"><pre>    [obj sourceFired];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>If you ever remove your input source from its run loop using the <code>CFRunLoopSourceInvalidate</code> function, the system calls your input source’s cancellation routine. You can use this routine to notify clients that your input source is no longer valid and that they should remove any references to it.  <span class="content_text">Listing 5-6</span> shows the cancellation callback routine registered with the <code>RunLoopSource</code> object. This function sends another <code>RunLoopContext</code> object to the application delegate, but this time asks the delegate to remove references to the run loop source. </p><a name="//apple_ref/doc/uid/10000057i-CH16-SW34" title="Listing 5-6Invalidating an input source"></a><p class="codesample"><strong>Listing 5-6&nbsp;&nbsp;</strong>Invalidating an input source</p><div class="codesample"><table><tr><td scope="row"><pre>void RunLoopSourceCancelRoutine (void *info, CFRunLoopRef rl, CFStringRef mode)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    RunLoopSource* obj = (RunLoopSource*)info;<span></span></pre></td></tr><tr><td scope="row"><pre>    AppDelegate* del = [AppDelegate sharedAppDelegate];<span></span></pre></td></tr><tr><td scope="row"><pre>    RunLoopContext* theContext = [[RunLoopContext alloc] initWithSource:obj andLoop:rl];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    [del performSelectorOnMainThread:@selector(removeSource:)<span></span></pre></td></tr><tr><td scope="row"><pre>                                withObject:theContext waitUntilDone:YES];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><div class="notebox"><a name="//apple_ref/doc/uid/10000057i-CH16-SW50" title="Note"></a><p><strong>Note:</strong>&nbsp;The code for the application delegate’s <code>registerSource:</code> and <code>removeSource:</code> methods is shown in <span class="content_text"><a href="RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW37">“Coordinating with Clients of the Input Source.”</a></span> </p></div><a name="//apple_ref/doc/uid/10000057i-CH16-SW41" title="Installing the Input Source on the Run Loop"></a><h4>Installing the Input Source on the Run Loop</h4><p><span class="content_text">Listing 5-7</span> shows the <code>init</code> and <code>addToCurrentRunLoop</code> methods of the <code>RunLoopSource</code> class. The <code>init</code> method creates the <code>CFRunLoopSourceRef</code> opaque type that must actually be attached to the run loop. It passes the <code>RunLoopSource</code> object itself as the contextual information so that the callback routines have a pointer to the object. Installation of the input source does not occur until the worker thread invokes the <code>addToCurrentRunLoop</code> method, at which point the <code>RunLoopSourceScheduleRoutine</code> callback function is called. Once the input source is added to the run loop, the thread can run its run loop to wait on it.</p><a name="//apple_ref/doc/uid/10000057i-CH16-SW36" title="Listing 5-7Installing the run loop source"></a><p class="codesample"><strong>Listing 5-7&nbsp;&nbsp;</strong>Installing the run loop source</p><div class="codesample"><table><tr><td scope="row"><pre>- (id)init<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    CFRunLoopSourceContext    context = {0, self, NULL, NULL, NULL, NULL, NULL,<span></span></pre></td></tr><tr><td scope="row"><pre>                                        &amp;RunLoopSourceScheduleRoutine,<span></span></pre></td></tr><tr><td scope="row"><pre>                                        RunLoopSourceCancelRoutine,<span></span></pre></td></tr><tr><td scope="row"><pre>                                        RunLoopSourcePerformRoutine};<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    runLoopSource = CFRunLoopSourceCreate(NULL, 0, &amp;context);<span></span></pre></td></tr><tr><td scope="row"><pre>    commands = [[NSMutableArray alloc] init];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    return self;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (void)addToCurrentRunLoop<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    CFRunLoopRef runLoop = CFRunLoopGetCurrent();<span></span></pre></td></tr><tr><td scope="row"><pre>    CFRunLoopAddSource(runLoop, runLoopSource, kCFRunLoopDefaultMode);<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/10000057i-CH16-SW37" title="Coordinating with Clients of the Input Source"></a><h4>Coordinating with Clients of the Input Source</h4><p>For your input source to be useful, you need to manipulate it and signal it from another thread. The whole point of an input source is to put its associated thread to sleep until there is something to do. That fact necessitates having other threads in your application know about the input source and have a way to communicate with it.  </p><p>One way to notify clients about your input source is to send out registration requests when your input source is first installed on its run loop. You can register your input source with as many clients as you want, or you can simply register it with some central agency that then vends your input source to interested clients. <span class="content_text">Listing 5-8</span> shows the registration method defined by the application delegate and invoked when the <code>RunLoopSource</code> object’s scheduler function is called. This method receives the <code>RunLoopContext</code> object provided by the <code>RunLoopSource</code> object and adds it to its list of sources. This listing also shows the routine used to unregister the input source when it is removed from its run loop.  </p><a name="//apple_ref/doc/uid/10000057i-CH16-SW35" title="Listing 5-8Registering and removing an input source with the application delegate"></a><p class="codesample"><strong>Listing 5-8&nbsp;&nbsp;</strong>Registering and removing an input source with the application delegate</p><div class="codesample"><table><tr><td scope="row"><pre>- (void)registerSource:(RunLoopContext*)sourceInfo;<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    [sourcesToPing addObject:sourceInfo];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (void)removeSource:(RunLoopContext*)sourceInfo<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    id    objToRemove = nil;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    for (RunLoopContext* context in sourcesToPing)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        if ([context isEqual:sourceInfo])<span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>            objToRemove = context;<span></span></pre></td></tr><tr><td scope="row"><pre>            break;<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if (objToRemove)<span></span></pre></td></tr><tr><td scope="row"><pre>        [sourcesToPing removeObject:objToRemove];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><div class="notebox"><a name="//apple_ref/doc/uid/10000057i-CH16-SW51" title="Note"></a><p><strong>Note:</strong>&nbsp;The callback functions that call the methods in the preceding listing are shown in <span class="content_text"><a href="RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW32">Listing 5-4</a></span> and <span class="content_text"><a href="RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW34">Listing 5-6</a></span>. </p></div><a name="//apple_ref/doc/uid/10000057i-CH16-SW42" title="Signaling the Input Source"></a><h4>Signaling the Input Source</h4><p>After it hands off its data to the input source, a client must signal the source and wake up its run loop. Signaling the source lets the run loop know that the source is ready to be processed. And because the thread might be asleep when the signal occurs, you should always wake up the run loop explicitly. Failing to do so might result in a delay in processing the input source.</p><p><span class="content_text">Listing 5-9</span> shows the <code>fireCommandsOnRunLoop</code> method of the <code>RunLoopSource</code> object. Clients invoke this method when they are ready for the source to process the commands they added to the buffer. </p><a name="//apple_ref/doc/uid/10000057i-CH16-SW39" title="Listing 5-9Waking up the run loop"></a><p class="codesample"><strong>Listing 5-9&nbsp;&nbsp;</strong>Waking up the run loop</p><div class="codesample"><table><tr><td scope="row"><pre>- (void)fireCommandsOnRunLoop:(CFRunLoopRef)runloop<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    CFRunLoopSourceSignal(runLoopSource);<span></span></pre></td></tr><tr><td scope="row"><pre>    CFRunLoopWakeUp(runloop);<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><div class="notebox"><a name="//apple_ref/doc/uid/10000057i-CH16-SW52" title="Note"></a><p><strong>Note:</strong>&nbsp;You should never try to handle a <code>SIGHUP</code> or other type of process-level signal by messaging a custom input source. The Core Foundation functions for waking up the run loop are not signal safe and should not be used inside your application’s signal handler routines. For more information about signal handler routines, see the <code><a href="../../../../Darwin/Reference/ManPages/man2/sigaction.2.html#//apple_ref/doc/man/2/sigaction" target="_top">sigaction</a></code> man page. </p></div><a name="//apple_ref/doc/uid/10000057i-CH16-SW6" title="Configuring Timer Sources"></a><h3>Configuring Timer Sources</h3><p>To create a timer source, all you have to do is create a timer object and schedule it on your run loop. In Cocoa, you use the <code>NSTimer</code> class to create new timer objects, and in Core Foundation you use the <code>CFRunLoopTimerRef</code> opaque type. Internally, the <code>NSTimer</code> class is simply an extension of Core Foundation that provides some convenience features, like the ability to create and schedule a timer using the same method.</p><p>In Cocoa, you can create and schedule a timer all at once using either of these class methods:</p><ul class="spaceabove"><li class="li"><p><code><a href="../../../Reference/Foundation/Classes/NSTimer_Class/Reference/NSTimer.html#//apple_ref/occ/clm/NSTimer/scheduledTimerWithTimeInterval:target:selector:userInfo:repeats:" target="_top">scheduledTimerWithTimeInterval:target:selector:userInfo:repeats:</a></code></p></li><li class="li"><p><code><a href="../../../Reference/Foundation/Classes/NSTimer_Class/Reference/NSTimer.html#//apple_ref/occ/clm/NSTimer/scheduledTimerWithTimeInterval:invocation:repeats:" target="_top">scheduledTimerWithTimeInterval:invocation:repeats:</a></code></p></li></ul><p>These methods create the timer and add it to the current thread’s run loop in the default mode (<code><!--a target="_top" -->NSDefaultRunLoopMode<!--/a--></code>). You can also schedule a timer manually if you want by creating your <code>NSTimer</code> object and then adding it to the run loop using the <code>addTimer:forMode:</code> method of <code>NSRunLoop</code>. Both techniques do basically the same thing but give you different levels of control over the timer’s configuration. For example, if you create the timer and add it to the run loop manually, you can do so using a mode other than the default mode. <span class="content_text">Listing 5-10</span> shows how to create timers using both techniques. The first timer has an initial delay of 1 second but then fires regularly every 0.1 seconds after that. The second timer begins firing after an initial 0.2 second delay and then fires every 0.2 seconds after that.</p><a name="//apple_ref/doc/uid/10000057i-CH16-SW15" title="Listing 5-10Creating and scheduling timers using NSTimer"></a><p class="codesample"><strong>Listing 5-10&nbsp;&nbsp;</strong>Creating and scheduling timers using NSTimer</p><div class="codesample"><table><tr><td scope="row"><pre>NSRunLoop* myRunLoop = [NSRunLoop currentRunLoop];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>// Create and schedule the first timer.<span></span></pre></td></tr><tr><td scope="row"><pre>NSDate* futureDate = [NSDate dateWithTimeIntervalSinceNow:1.0];<span></span></pre></td></tr><tr><td scope="row"><pre>NSTimer* myTimer = [[NSTimer alloc] initWithFireDate:futureDate<span></span></pre></td></tr><tr><td scope="row"><pre>                        interval:0.1<span></span></pre></td></tr><tr><td scope="row"><pre>                        target:self<span></span></pre></td></tr><tr><td scope="row"><pre>                        selector:@selector(myDoFireTimer1:)<span></span></pre></td></tr><tr><td scope="row"><pre>                        userInfo:nil<span></span></pre></td></tr><tr><td scope="row"><pre>                        repeats:YES];<span></span></pre></td></tr><tr><td scope="row"><pre>[myRunLoop addTimer:myTimer forMode:NSDefaultRunLoopMode];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>// Create and schedule the second timer.<span></span></pre></td></tr><tr><td scope="row"><pre>[NSTimer scheduledTimerWithTimeInterval:0.2<span></span></pre></td></tr><tr><td scope="row"><pre>                        target:self<span></span></pre></td></tr><tr><td scope="row"><pre>                        selector:@selector(myDoFireTimer2:)<span></span></pre></td></tr><tr><td scope="row"><pre>                        userInfo:nil<span></span></pre></td></tr><tr><td scope="row"><pre>                        repeats:YES];<span></span></pre></td></tr></table></div><p><span class="content_text">Listing 5-11</span> shows the code needed to configure a timer using Core Foundation functions. Although this example does not pass any user-defined information in the context structure, you could use this structure to pass around any custom data you needed for your timer. For more information about the contents of this structure, see its description in <em><a href="../../../../CoreFoundation/Reference/CFRunLoopTimerRef/index.html#//apple_ref/doc/uid/20001444" target="_top">CFRunLoopTimer Reference</a></em>.  </p><a name="//apple_ref/doc/uid/10000057i-CH16-SW16" title="Listing 5-11Creating and scheduling a timer using Core Foundation"></a><p class="codesample"><strong>Listing 5-11&nbsp;&nbsp;</strong>Creating and scheduling a timer using Core Foundation</p><div class="codesample"><table><tr><td scope="row"><pre>CFRunLoopRef runLoop = CFRunLoopGetCurrent();<span></span></pre></td></tr><tr><td scope="row"><pre>CFRunLoopTimerContext context = {0, NULL, NULL, NULL, NULL};<span></span></pre></td></tr><tr><td scope="row"><pre>CFRunLoopTimerRef timer = CFRunLoopTimerCreate(kCFAllocatorDefault, 0.1, 0.3, 0, 0,<span></span></pre></td></tr><tr><td scope="row"><pre>                                        &amp;myCFTimerCallback, &amp;context);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>CFRunLoopAddTimer(runLoop, timer, kCFRunLoopCommonModes);<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/10000057i-CH16-131281" title="Configuring a Port-Based Input Source"></a><h3>Configuring a Port-Based Input Source</h3><p>Both Cocoa and Core Foundation provide port-based objects for communicating between threads or between processes. The following sections show you how to set up port communication using several different types of ports.<a name="//apple_ref/doc/uid/10000057i-CH16-DontLinkElementID_14"></a> </p><a name="//apple_ref/doc/uid/10000057i-CH16-SW27" title="Configuring an NSMachPort Object"></a><h4>Configuring an NSMachPort Object</h4><p>To establish a local connection with an <code>NSMachPort</code> object, you create the port object and add it to your primary thread's run loop. When launching your secondary thread, you pass the same object to your thread's entry-point function. The secondary thread can use the same object to send messages back to your primary thread. </p><a name="//apple_ref/doc/uid/10000057i-CH16-SW28" title="Implementing the Main Thread Code"></a><h5>Implementing the Main Thread Code</h5><p><span class="content_text">Listing 5-12</span> shows the primary thread code for launching a secondary worker thread. Because the Cocoa framework performs many of the intervening steps for configuring the port and run loop, the <code>launchThread</code> method is noticeably shorter than its Core Foundation equivalent (<span class="content_text"><a href="RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-139726-BAJBGHHB">Listing 5-17</a></span>); however, the behavior of the two is nearly identical. One difference is that instead of sending the name of the local port to the worker thread, this method sends the <code>NSPort</code> object directly. </p><a name="//apple_ref/doc/uid/10000057i-CH16-139363-BAJHDDBB" title="Listing 5-12Main thread launch method"></a><p class="codesample"><a name="//apple_ref/doc/uid/TP40001479-139363" title="Listing 5-12Main thread launch method"></a><strong>Listing 5-12&nbsp;&nbsp;</strong>Main thread launch method</p><div class="codesample"><table><tr><td scope="row"><pre>- (void)launchThread<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    NSPort* myPort = [NSMachPort port];<span></span></pre></td></tr><tr><td scope="row"><pre>    if (myPort)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        // This class handles incoming port messages.<span></span></pre></td></tr><tr><td scope="row"><pre>        [myPort setDelegate:self];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        // Install the port as an input source on the current run loop.<span></span></pre></td></tr><tr><td scope="row"><pre>        [[NSRunLoop currentRunLoop] addPort:myPort forMode:NSDefaultRunLoopMode];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        // Detach the thread. Let the worker release the port.<span></span></pre></td></tr><tr><td scope="row"><pre>        [NSThread detachNewThreadSelector:@selector(LaunchThreadWithPort:)<span></span></pre></td></tr><tr><td scope="row"><pre>               toTarget:[MyWorkerClass class] withObject:myPort];<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>In order to set up a two-way communications channel between your threads, you might want to have the worker thread send its own local port to your main thread in a check-in message. Receiving the check-in message lets your main thread know that all went well in launching the second thread and also gives you a way to send further messages to that thread. </p><p><span class="content_text">Listing 5-13</span> shows the <code>handlePortMessage:</code> method for the primary thread. This method is called when data arrives on the thread's own local port. When a check-in message arrives, the method retrieves the port for the secondary thread directly from the port message and saves it for later use.</p><a name="//apple_ref/doc/uid/10000057i-CH16-SW8" title="Listing 5-13Handling Mach port messages"></a><p class="codesample"><strong>Listing 5-13&nbsp;&nbsp;</strong>Handling Mach port messages</p><div class="codesample"><table><tr><td scope="row"><pre>#define kCheckinMessage 100<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>// Handle responses from the worker thread.<span></span></pre></td></tr><tr><td scope="row"><pre>- (void)handlePortMessage:(NSPortMessage *)portMessage<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    unsigned int message = [portMessage msgid];<span></span></pre></td></tr><tr><td scope="row"><pre>    NSPort* distantPort = nil;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if (message == kCheckinMessage)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        // Get the worker thread’s communications port.<span></span></pre></td></tr><tr><td scope="row"><pre>        distantPort = [portMessage sendPort];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        // Retain and save the worker port for later use.<span></span></pre></td></tr><tr><td scope="row"><pre>        [self storeDistantPort:distantPort];<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    else<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        // Handle other messages.<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/10000057i-CH16-SW29" title="Implementing the Secondary Thread Code"></a><h5>Implementing the Secondary Thread Code</h5><p>For the secondary worker thread, you must configure the thread and use the specified port to communicate information back to the primary thread. </p><p><span class="content_text">Listing 5-14</span> shows the code for setting up the worker thread. After creating an autorelease pool for the thread, the method creates a worker object to drive the thread execution. The worker object’s <code>sendCheckinMessage:</code> method (shown in <span class="content_text"><a href="RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW10">Listing 5-15</a></span>) creates a local port for the worker thread and sends a check-in message back to the main thread.</p><a name="//apple_ref/doc/uid/10000057i-CH16-SW9" title="Listing 5-14Launching the worker thread using Mach ports"></a><p class="codesample"><strong>Listing 5-14&nbsp;&nbsp;</strong>Launching the worker thread using Mach ports</p><div class="codesample"><table><tr><td scope="row"><pre>+(void)LaunchThreadWithPort:(id)inData<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    NSAutoreleasePool*  pool = [[NSAutoreleasePool alloc] init];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Set up the connection between this thread and the main thread.<span></span></pre></td></tr><tr><td scope="row"><pre>    NSPort* distantPort = (NSPort*)inData;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    MyWorkerClass*  workerObj = [[self alloc] init];<span></span></pre></td></tr><tr><td scope="row"><pre>    [workerObj sendCheckinMessage:distantPort];<span></span></pre></td></tr><tr><td scope="row"><pre>    [distantPort release];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Let the run loop process things.<span></span></pre></td></tr><tr><td scope="row"><pre>    do<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        [[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode<span></span></pre></td></tr><tr><td scope="row"><pre>                            beforeDate:[NSDate distantFuture]];<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    while (![workerObj shouldExit]);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    [workerObj release];<span></span></pre></td></tr><tr><td scope="row"><pre>    [pool release];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>When using <code>NSMachPort</code>, local and remote threads can use the same port object for one-way communication between the threads. In other words, the local port object created by one thread becomes the remote port object for the other thread.</p><p><span class="content_text">Listing 5-15</span> shows the check-in routine of the secondary thread. This method sets up its own local port for future communication and then sends a check-in message back to the main thread. The method uses the port object received in the <code>LaunchThreadWithPort:</code> method as the target of the message. </p><a name="//apple_ref/doc/uid/10000057i-CH16-SW10" title="Listing 5-15Sending the check-in message using Mach ports"></a><p class="codesample"><a name="//apple_ref/doc/uid/TP40001479-139371" title="Listing 5-15Sending the check-in message using Mach ports"></a><strong>Listing 5-15&nbsp;&nbsp;</strong>Sending the check-in message using Mach ports</p><div class="codesample"><table><tr><td scope="row"><pre>// Worker thread check-in method<span></span></pre></td></tr><tr><td scope="row"><pre>- (void)sendCheckinMessage:(NSPort*)outPort<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    // Retain and save the remote port for future use.<span></span></pre></td></tr><tr><td scope="row"><pre>    [self setRemotePort:outPort];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Create and configure the worker thread port.<span></span></pre></td></tr><tr><td scope="row"><pre>    NSPort* myPort = [NSMachPort port];<span></span></pre></td></tr><tr><td scope="row"><pre>    [myPort setDelegate:self];<span></span></pre></td></tr><tr><td scope="row"><pre>    [[NSRunLoop currentRunLoop] addPort:myPort forMode:NSDefaultRunLoopMode];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Create the check-in message.<span></span></pre></td></tr><tr><td scope="row"><pre>    NSPortMessage* messageObj = [[NSPortMessage alloc] initWithSendPort:outPort<span></span></pre></td></tr><tr><td scope="row"><pre>                                         receivePort:myPort components:nil];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if (messageObj)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        // Finish configuring the message and send it immediately.<span></span></pre></td></tr><tr><td scope="row"><pre>        [messageObj setMsgid:kCheckinMessage];<span></span></pre></td></tr><tr><td scope="row"><pre>        [messageObj sendBeforeDate:[NSDate date]];<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/10000057i-CH16-SW30" title="Configuring an NSMessagePort Object"></a><h4>Configuring an NSMessagePort Object</h4><p>To establish a local connection with an <code>NSMessagePort</code> object, you cannot simply pass port objects between threads. Remote message ports must be acquired by name. Making this possible in Cocoa requires registering your local port with a specific name and then passing that name to the remote thread so that it can obtain an appropriate port object for communication. <span class="content_text">Listing 5-16</span> shows the port creation and registration process in cases where you want to use message ports. </p><a name="//apple_ref/doc/uid/10000057i-CH16-SW11" title="Listing 5-16Registering a message port"></a><p class="codesample"><strong>Listing 5-16&nbsp;&nbsp;</strong>Registering a message port</p><div class="codesample"><table><tr><td scope="row"><pre>NSPort* localPort = [[[NSMessagePort alloc] init] retain];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>// Configure the object and add it to the current run loop.<span></span></pre></td></tr><tr><td scope="row"><pre>[localPort setDelegate:self];<span></span></pre></td></tr><tr><td scope="row"><pre>[[NSRunLoop currentRunLoop] addPort:localPort forMode:NSDefaultRunLoopMode];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>// Register the port using a specific name. The name must be unique.<span></span></pre></td></tr><tr><td scope="row"><pre>NSString* localPortName = [NSString stringWithFormat:@"MyPortName"];<span></span></pre></td></tr><tr><td scope="row"><pre>[[NSMessagePortNameServer sharedInstance] registerPort:localPort<span></span></pre></td></tr><tr><td scope="row"><pre>                     name:localPortName];<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40001479-132173" title="Configuring a Port-Based Input Source in Core Foundation"></a><a name="//apple_ref/doc/uid/10000057i-CH16-132173-BAJHCHBJ" title="Configuring a Port-Based Input Source in Core Foundation"></a><h4>Configuring a Port-Based Input Source in Core Foundation</h4><p>This section shows how to set up a two-way communications channel between your application’s main thread and a worker thread using Core Foundation<a name="//apple_ref/doc/uid/10000057i-CH16-DontLinkElementID_15"></a>.</p><p><span class="content_text">Listing 5-17</span> shows the code called by the application’s main thread to launch the worker thread. The first thing the code does is set up a <code>CFMessagePort</code><a name="//apple_ref/doc/uid/10000057i-CH16-DontLinkElementID_16"></a> object to listen for messages from worker threads. The worker thread needs the name of the port to make the connection, so that string value is delivered to the entry point function of the worker thread. Port names should generally be unique within the current user context; otherwise, you might run into conflicts. </p><a name="//apple_ref/doc/uid/10000057i-CH16-139726-BAJBGHHB" title="Listing 5-17Attaching a Core Foundation message port to a new thread"></a><p class="codesample"><a name="//apple_ref/doc/uid/TP40001479-139726" title="Listing 5-17Attaching a Core Foundation message port to a new thread"></a><strong>Listing 5-17&nbsp;&nbsp;</strong>Attaching a Core Foundation message port to a new thread</p><div class="codesample"><table><tr><td scope="row"><pre>#define kThreadStackSize        (8 *4096)<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>OSStatus MySpawnThread()<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    // Create a local port for receiving responses.<span></span></pre></td></tr><tr><td scope="row"><pre>    CFStringRef myPortName;<span></span></pre></td></tr><tr><td scope="row"><pre>    CFMessagePortRef myPort;<span></span></pre></td></tr><tr><td scope="row"><pre>    CFRunLoopSourceRef rlSource;<span></span></pre></td></tr><tr><td scope="row"><pre>    CFMessagePortContext context = {0, NULL, NULL, NULL, NULL};<span></span></pre></td></tr><tr><td scope="row"><pre>    Boolean shouldFreeInfo;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Create a string with the port name.<span></span></pre></td></tr><tr><td scope="row"><pre>    myPortName = CFStringCreateWithFormat(NULL, NULL, CFSTR("com.myapp.MainThread"));<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Create the port.<span></span></pre></td></tr><tr><td scope="row"><pre>    myPort = CFMessagePortCreateLocal(NULL,<span></span></pre></td></tr><tr><td scope="row"><pre>                myPortName,<span></span></pre></td></tr><tr><td scope="row"><pre>                &amp;MainThreadResponseHandler,<span></span></pre></td></tr><tr><td scope="row"><pre>                &amp;context,<span></span></pre></td></tr><tr><td scope="row"><pre>                &amp;shouldFreeInfo);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if (myPort != NULL)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        // The port was successfully created.<span></span></pre></td></tr><tr><td scope="row"><pre>        // Now create a run loop source for it.<span></span></pre></td></tr><tr><td scope="row"><pre>        rlSource = CFMessagePortCreateRunLoopSource(NULL, myPort, 0);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        if (rlSource)<span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>            // Add the source to the current run loop.<span></span></pre></td></tr><tr><td scope="row"><pre>            CFRunLoopAddSource(CFRunLoopGetCurrent(), rlSource, kCFRunLoopDefaultMode);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>            // Once installed, these can be freed.<span></span></pre></td></tr><tr><td scope="row"><pre>            CFRelease(myPort);<span></span></pre></td></tr><tr><td scope="row"><pre>            CFRelease(rlSource);<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Create the thread and continue processing.<span></span></pre></td></tr><tr><td scope="row"><pre>    MPTaskID        taskID;<span></span></pre></td></tr><tr><td scope="row"><pre>    return(MPCreateTask(&amp;ServerThreadEntryPoint,<span></span></pre></td></tr><tr><td scope="row"><pre>                    (void*)myPortName,<span></span></pre></td></tr><tr><td scope="row"><pre>                    kThreadStackSize,<span></span></pre></td></tr><tr><td scope="row"><pre>                    NULL,<span></span></pre></td></tr><tr><td scope="row"><pre>                    NULL,<span></span></pre></td></tr><tr><td scope="row"><pre>                    NULL,<span></span></pre></td></tr><tr><td scope="row"><pre>                    0,<span></span></pre></td></tr><tr><td scope="row"><pre>                    &amp;taskID));<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>With the port installed and the thread launched, the main thread can continue its regular execution while it waits for the thread to check in. When the check-in message arrives, it is dispatched to the main thread’s <code>MainThreadResponseHandler</code> function, shown in <span class="content_text">Listing 5-18</span>. This function extracts the port name for the worker thread and creates a conduit for future communication. </p><a name="//apple_ref/doc/uid/10000057i-CH16-131591-BAJBGEIE" title="Listing 5-18Receiving the checkin message"></a><p class="codesample"><a name="//apple_ref/doc/uid/TP40001479-131591" title="Listing 5-18Receiving the checkin message"></a><strong>Listing 5-18&nbsp;&nbsp;</strong>Receiving the checkin message</p><div class="codesample"><table><tr><td scope="row"><pre>#define kCheckinMessage 100<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>// Main thread port message handler<span></span></pre></td></tr><tr><td scope="row"><pre>CFDataRef MainThreadResponseHandler(CFMessagePortRef local,<span></span></pre></td></tr><tr><td scope="row"><pre>                    SInt32 msgid,<span></span></pre></td></tr><tr><td scope="row"><pre>                    CFDataRef data,<span></span></pre></td></tr><tr><td scope="row"><pre>                    void* info)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    if (msgid == kCheckinMessage)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        CFMessagePortRef messagePort;<span></span></pre></td></tr><tr><td scope="row"><pre>        CFStringRef threadPortName;<span></span></pre></td></tr><tr><td scope="row"><pre>        CFIndex bufferLength = CFDataGetLength(data);<span></span></pre></td></tr><tr><td scope="row"><pre>        UInt8* buffer = CFAllocatorAllocate(NULL, bufferLength, 0);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        CFDataGetBytes(data, CFRangeMake(0, bufferLength), buffer);<span></span></pre></td></tr><tr><td scope="row"><pre>        threadPortName = CFStringCreateWithBytes (NULL, buffer, bufferLength, kCFStringEncodingASCII, FALSE);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        // You must obtain a remote message port by name.<span></span></pre></td></tr><tr><td scope="row"><pre>        messagePort = CFMessagePortCreateRemote(NULL, (CFStringRef)threadPortName);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        if (messagePort)<span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>            // Retain and save the thread’s comm port for future reference.<span></span></pre></td></tr><tr><td scope="row"><pre>            AddPortToListOfActiveThreads(messagePort);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>            // Since the port is retained by the previous function, release<span></span></pre></td></tr><tr><td scope="row"><pre>            // it here.<span></span></pre></td></tr><tr><td scope="row"><pre>            CFRelease(messagePort);<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        // Clean up.<span></span></pre></td></tr><tr><td scope="row"><pre>        CFRelease(threadPortName);<span></span></pre></td></tr><tr><td scope="row"><pre>        CFAllocatorDeallocate(NULL, buffer);<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    else<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        // Process other messages.<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    return NULL;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>With the main thread configured, the only thing remaining is for the newly created worker thread to create its own port and check in. <span class="content_text">Listing 5-19</span> shows the entry point function for the worker thread. The function extracts the main thread’s port name and uses it to create a remote connection back to the main thread. The function then creates a local port for itself, installs the port on the thread’s run loop, and sends a check-in message to the main thread that includes the local port name.</p><a name="//apple_ref/doc/uid/10000057i-CH16-131785-BAJDFHDB" title="Listing 5-19Setting up the thread structures"></a><p class="codesample"><a name="//apple_ref/doc/uid/TP40001479-131785" title="Listing 5-19Setting up the thread structures"></a><strong>Listing 5-19&nbsp;&nbsp;</strong>Setting up the thread structures</p><div class="codesample"><table><tr><td scope="row"><pre>OSStatus ServerThreadEntryPoint(void* param)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    // Create the remote port to the main thread.<span></span></pre></td></tr><tr><td scope="row"><pre>    CFMessagePortRef mainThreadPort;<span></span></pre></td></tr><tr><td scope="row"><pre>    CFStringRef portName = (CFStringRef)param;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    mainThreadPort = CFMessagePortCreateRemote(NULL, portName);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Free the string that was passed in param.<span></span></pre></td></tr><tr><td scope="row"><pre>    CFRelease(portName);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Create a port for the worker thread.<span></span></pre></td></tr><tr><td scope="row"><pre>    CFStringRef myPortName = CFStringCreateWithFormat(NULL, NULL, CFSTR("com.MyApp.Thread-%d"), MPCurrentTaskID());<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Store the port in this thread’s context info for later reference.<span></span></pre></td></tr><tr><td scope="row"><pre>    CFMessagePortContext context = {0, mainThreadPort, NULL, NULL, NULL};<span></span></pre></td></tr><tr><td scope="row"><pre>    Boolean shouldFreeInfo;<span></span></pre></td></tr><tr><td scope="row"><pre>    Boolean shouldAbort = TRUE;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    CFMessagePortRef myPort = CFMessagePortCreateLocal(NULL,<span></span></pre></td></tr><tr><td scope="row"><pre>                myPortName,<span></span></pre></td></tr><tr><td scope="row"><pre>                &amp;ProcessClientRequest,<span></span></pre></td></tr><tr><td scope="row"><pre>                &amp;context,<span></span></pre></td></tr><tr><td scope="row"><pre>                &amp;shouldFreeInfo);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if (shouldFreeInfo)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        // Couldn't create a local port, so kill the thread.<span></span></pre></td></tr><tr><td scope="row"><pre>        MPExit(0);<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    CFRunLoopSourceRef rlSource = CFMessagePortCreateRunLoopSource(NULL, myPort, 0);<span></span></pre></td></tr><tr><td scope="row"><pre>    if (!rlSource)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        // Couldn't create a local port, so kill the thread.<span></span></pre></td></tr><tr><td scope="row"><pre>        MPExit(0);<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Add the source to the current run loop.<span></span></pre></td></tr><tr><td scope="row"><pre>    CFRunLoopAddSource(CFRunLoopGetCurrent(), rlSource, kCFRunLoopDefaultMode);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Once installed, these can be freed.<span></span></pre></td></tr><tr><td scope="row"><pre>    CFRelease(myPort);<span></span></pre></td></tr><tr><td scope="row"><pre>    CFRelease(rlSource);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Package up the port name and send the check-in message.<span></span></pre></td></tr><tr><td scope="row"><pre>    CFDataRef returnData = nil;<span></span></pre></td></tr><tr><td scope="row"><pre>    CFDataRef outData;<span></span></pre></td></tr><tr><td scope="row"><pre>    CFIndex stringLength = CFStringGetLength(myPortName);<span></span></pre></td></tr><tr><td scope="row"><pre>    UInt8* buffer = CFAllocatorAllocate(NULL, stringLength, 0);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    CFStringGetBytes(myPortName,<span></span></pre></td></tr><tr><td scope="row"><pre>                CFRangeMake(0,stringLength),<span></span></pre></td></tr><tr><td scope="row"><pre>                kCFStringEncodingASCII,<span></span></pre></td></tr><tr><td scope="row"><pre>                0,<span></span></pre></td></tr><tr><td scope="row"><pre>                FALSE,<span></span></pre></td></tr><tr><td scope="row"><pre>                buffer,<span></span></pre></td></tr><tr><td scope="row"><pre>                stringLength,<span></span></pre></td></tr><tr><td scope="row"><pre>                NULL);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    outData = CFDataCreate(NULL, buffer, stringLength);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    CFMessagePortSendRequest(mainThreadPort, kCheckinMessage, outData, 0.1, 0.0, NULL, NULL);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Clean up thread data structures.<span></span></pre></td></tr><tr><td scope="row"><pre>    CFRelease(outData);<span></span></pre></td></tr><tr><td scope="row"><pre>    CFAllocatorDeallocate(NULL, buffer);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Enter the run loop.<span></span></pre></td></tr><tr><td scope="row"><pre>    CFRunLoopRun();<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>Once it enters its run loop, all future events sent to the thread’s port are handled by the <code>ProcessClientRequest</code> function. The implementation of that function depends on the type of work the thread does and is not shown here. </p>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../ThreadSafety/ThreadSafety.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../ThreadSafetySummary/ThreadSafetySummary.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2008 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2008-02-08<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html%3Fid%3D10000057i-4.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html%3Fid%3D10000057i-4.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html%3Fid%3D10000057i-4.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>