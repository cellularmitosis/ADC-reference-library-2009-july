<html><head><title>Mac OS X
 Manual Page For tack(1)</title>
<style type="text/css"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { font-size: 1px; background: #ffffff; color: #ffffff; } --></style>
<style type="text/css" media="print, aural, braille, embossed, projection, tty"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { display: none; } --></style>
</head><body bgcolor="white">
<a name="//apple_ref/doc/man/1/tack" title="Mac OS X
 Manual Page for tack(1)"><!-- headerDoc=man; indexgroup=Section 1; uid="//apple_ref/doc/man/1/tack"; name=tack(1) --></a>
<!--#include virtual="/includes/framesetheader"-->
<table width=600><tr><td scope="row">
<!-- begin breadcrumb insert request --><font face="Geneva,Helvetica,Arial" size="1">
 <a target="_top" href="http://developer.apple.com">ADC Home</a> <b>&gt;</b> <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> <b>&gt;</b> <a href="../../../../../reference/index.html#//apple_ref/doc/uid/TP30001281" target="_top">Reference</a> <b>&gt;</b> <!-- a href="" target="_top" -->Mac OS X<!-- /a --> <b>&gt;</b> <a href="../index.html#//apple_ref/doc/framework/manpages" target="_top">Mac OS X Man Pages</a></font>
<!-- end breadcrumb insert request -->
<p>&nbsp;</p>
</td></tr></table>
<!-- end of header -->
<table border="0"  cellpadding="2" cellspacing="2" width="630pt"><tr><td valign="top" height="12" colspan="5" scope="row">
<p style='text-align:justify;'>This document is a Mac OS X manual page.  Manual pages are a command-line technology
for providing documentation.  You can view these manual pages locally using the
<a href="man.1.html#//apple_ref/doc/man/1/man">man(1)</a> command.
These manual pages come from many different sources, and thus, have a variety of writing
styles.</p>
<p style='text-align:justify;'>For more information about the manual page format, see the manual page for 
<a href="../man5/manpages.5.html#//apple_ref/doc/man/5/manpages">manpages(5)</a>.</p>
</td></tr></table>
<hr />
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row"><pre class="manpages"><tt>
tack(1M)                                                                                            tack(1M)



<b>NAME</b>
       <b>tack</b> - <u>terminfo</u> action checker

<b>SYNOPSIS</b>
       <b>tack</b> [-itV] [term]

<b>DESCRIPTION</b>
       The <b>tack</b> program has three purposes: (1) to help you build a new terminfo entry describing an unknown
       terminal, (2) to test the correctness of an existing entry, and (3) to develop the correct  pad  tim-<font color="#ffffff" class="whiteout">ings&nbsp;timings</font>
       ings needed to ensure that screen updates don't fall behind the incoming data stream.

       <b>Tack</b>  presents  a  series of screen-painting and interactive tests in ways which are intended to make
       any mismatches between the terminfo entry and reality visually obvious.   <b>Tack</b>  also  provides  tools
       that can help in understanding how the terminal operates.

   <b>OPTIONS</b>
       <u>-i</u>     Usually  <b>tack</b> will send the reset and init strings to the terminal when the program starts up.
              The <u>-i</u> option will inhibit the terminal initialization.

       <u>-t</u>     Tell <b>tack</b> to override the terminfo settings for basic terminal functions.  When this option is
              set  <b>tack</b>  will  translate (cr) to \r, (cud1) to \n, (ind) to \n, (nel) to \r\n, (cub1) to \b,
              (bel) to \007, (ff) to \f and (ht) to \t.

       <u>-V</u>     Display the version information and exit.

       <u>term</u>   Terminfo terminal name to be tested.  If not present then the $TERM environment variable  will
              be used.

<b>OVERVIEW</b>
       Since  <b>tack</b>  is designed to test terminfo's it is not possible to rely on the correctness of the ter-<font color="#ffffff" class="whiteout">minfo&nbsp;terminfo</font>
       minfo data base.  Because of this the menuing system used with <b>tack</b> is vary primitive.  When  a  menu
       is printed it will scroll the entire screen.  To compensate for this verbose menu system <b>tack</b> permits
       menu selection type ahead.  If you already know what action you would like <b>tack</b> to perform  then  you
       can  enter that value immediately and avoid the menu display.  When in doubt the question mark (?) is
       a good character to type.  A carriage return will execute the default action.  These default  actions
       are designed to run all the standard tests.

       When  <b>tack</b>  first comes up it will display some basic information about the terminal.  Take some time
       to verify this information.  If it is wrong many of the subsequent tests will fail.  The most  impor-<font color="#ffffff" class="whiteout">tant&nbsp;important</font>
       tant  item  is the screen size.  If the screen size is wrong there is no point in proceeding.  (home)
       and (clear) are also critical to the success of subsequent tests.  The values of  (cr)  (ind)  (cub1)
       and  (ht)  may effect the tests if they are defined incorrectly.  If they are undefined <b>tack</b> will set
       them to reasonable defaults.  The last two entries on the display are  the  enquire  and  acknowledge
       strings.  These strings are taken from the user strings (u9) and (u8).

       By  now  you  must be wondering why the terminfo names are enclosed in parenthesis.  This has no pro-<font color="#ffffff" class="whiteout">found&nbsp;profound</font>
       found meaning other than it makes them stand out.  The <b>tack</b> program uses this convention any time  it
       displays  a  terminfo  name.  Remember <b>tack</b> is designed to rely on as little of the terminfo entry as
       possible.

<b>CREATING</b> <b>NEW</b> <b>ENTRIES</b>
       <b>Tack</b> has a number of tools that are designed to help gather information about the terminal.  Although
       these  functions  are  not dependent on terminal type, you may wish to execute <b>tack</b> with options <u>-it</u>.
       This will turn off initialization and default the standard entries.

       These tools may be reached from the main menu by selecting the 'tools' entry.

       <b>Echo</b> <b>tool</b>:  All data typed from the keyboard will be echoed back to the terminal.  Control characters
       are  not  translated  to  the up arrow format but are sent as control characters.  This allows you to
       test an escape sequence and see what it actually does.  You may also elect to <b>enable</b>  <b>hex</b>  <b>output</b>  <b>on</b>
       <b>echo</b>  <b>tool</b>  this will echo the characters in hexadecimal.  Once the test is running you may enter the
       'lines' or 'columns' keywords which will display a pattern that will help you determine  your  screen
       size.   A complete list of keywords will be displayed when the test starts.  Type 'help' to redisplay
       the list of available commands.

       <b>Reply</b> <b>tool</b>:  This tool acts much like the echo tool, but control characters that are  sent  from  the
       terminal  more  than  one  character after a carriage return will be expanded to the up arrow format.
       For example on a standard ANSI terminal you may type:

                 CR ESC [ c

       and the response will be echoed as something like:

                 ^[ [ ? 6 c

       <b>ANSI</b> <b>sgr</b> <b>display</b>:  This test assumes you have an ANSI terminal.  It goes through attribute numbers  0
       to  79, displaying each in turn and using that SGR number to write the text.  This shows you which of
       the SGR modes are actually implemented by the terminal.  Note:  some  terminals  (such  as  Tektronix
       color) use the private use characters to augment the functionality of the SGR command.  These private
       use characters may be interjected into the escape sequence by typing the character ( &lt;,  =,  &gt;,  ?  )
       after the original display has been shown.

       <b>ANSI</b> <b>status</b> <b>reports</b>:  This test queries the terminal in standard ANSI/VT-100 fashion.  The results of
       this test may help determine what options are supported by your terminal.

       <b>ANSI</b> <b>character</b> <b>sets</b>:  This test displays the character sets available on a ANSI/VT-100  style  termi-<font color="#ffffff" class="whiteout">nal.&nbsp;terminal.</font>
       nal.   Character  sets  on a real VT-100 terminal are usually defined with smacs=\E(0 and rmacs=\E(B.
       The first character after the escape defines the font bank.  The second character defines the charac-<font color="#ffffff" class="whiteout">ter&nbsp;character</font>
       ter  set.  This test allows you to view any of the possible combinations.  Private use character sets
       are defined by the digits.  Standard character sets are located in the alphabetic range.

<b>VERIFYING</b> <b>AN</b> <b>EXISTING</b> <b>ENTRY</b>
       You can verify the correctness of an entry with the `begin testing'  function.   This  entry  is  the
       default  action  and will be chosen if you hit carriage return (or enter).  This will bring up a sec-<font color="#ffffff" class="whiteout">ondary&nbsp;secondary</font>
       ondary menu that allows you to select more specific tests.

       The general philosophy of the program is, for each capability, to send an appropriate test pattern to
       the  terminal then send a description of what the user should expect.  Occasionally (as when checking
       function-key capabilities) the program will ask you to enter input for it to check.

       If the test fails then you have the option of dynamically changing the terminfo entry and  re-running
       the  test.   This  is done with the 'edit terminfo' menu item.  The edit submenu allows you to change
       the offending terminfo entry and immediately retest the capability.  The edit menu lets you do  other
       things  with  the  terminfo, such as; display the entire terminfo entry, display which caps have been
       tested and display which caps cannot be tested.  This menu also allows you to write the  newly  modi-<font color="#ffffff" class="whiteout">fied&nbsp;modified</font>
       fied  terminfo  to disc.  If you have made any modifications to the terminfo <b>tack</b> will ask you if you
       want to save the file to disc before it exits.  The filename will be the same as the  terminal  name.
       After  the  program  exits  you can run the <a href="tic.1m.html#//apple_ref/doc/man/1/tic">tic(1M)</a> compiler on the new terminfo to install it in the
       terminfo data base.


<b>CORRECTING</b> <b>PAD</b> <b>TIMINGS</b>
   <b>Theory</b> <b>of</b> <b>Overruns</b> <b>and</b> <b>Padding</b>
       Some terminals require significant amounts of time (that  is,  more  than  one  transmitted-character
       interval)  to do screen updates that change large portions of the screen, such as screen clears, line
       insertions, line deletions, and scrolls (including scrolls triggered by line feeds or a write to  the
       lowest, right-hand-most cell of the screen).

       If the computer continues to send characters to the terminal while one of these time-consuming opera-<font color="#ffffff" class="whiteout">tions&nbsp;operations</font>
       tions is going on, the screen may be garbled.  Since the length  of  a  character  transmission  time
       varies  inversely with transmission speed in cps, entries which function at lower speeds may break at
       higher speeds.

       Similar problems result if the host machine is simply sending characters at a sustained  rate  faster
       than the terminal can buffer and process them.  In either case, when the terminal cannot process them
       and can't tell the host to stop soon enough, it will just drop them.  The dropped characters could be
       text,  escape sequences or the escape character itself, causing some really strange-looking displays.
       This kind of glitch is called an <u>overrun</u>.

       In terminfo entries, you can attach a <b>pad</b> <b>time</b> to each string capability that is  a  number  of  mil-<font color="#ffffff" class="whiteout">liseconds&nbsp;milliseconds</font>
       liseconds  to  delay  after sending it.  This will give the terminal time to catch up and avoid over-<font color="#ffffff" class="whiteout">runs.&nbsp;overruns.</font>
       runs.

       If you are running a software terminal emulator, or you are on an X pseudo-tty, or your  terminal  is
       on  an RS-232C line which correctly handles RTS/CTS hardware flow control, then pads are not strictly
       necessary.  However, some display packages (such as <a href="../man3/ncurses.3x.html#//apple_ref/doc/man/3/ncurses">ncurses(3X)</a>) use the pad counts to calculate  the
       fastest  way  to  implement  certain functions.  For example: scrolling the screen may be faster than
       deleting the top line.

       One common way to avoid overruns is with XON/XOFF handshaking.  But  even  this  handshake  may  have
       problems  at  high  baud  rates.  This is a result of the way XON/XOFF works.  The terminal tells the
       host to stop with an XOFF.  When the host gets this character, it stops sending.  However, there is a
       small  amount of time between the stop request and the actual stop.  During this window, the terminal
       must continue to accept characters even though it has told the host to stop.  If the  terminal  sends
       the  stop  request  too late, then its internal buffer will overflow.  If it sends the stop character
       too early, then the terminal is not getting the most efficient use out of its internal buffers.  In a
       real  application at high baud rates, a terminal could get a dozen or more characters before the host
       gets around to suspending transmission.  Connecting the terminal over a network will make the problem
       much worse.

       (RTS/CTS  handshaking does not have this problem because the UARTs are signal-connected and the "stop
       flow" is done at the lowest level, without software intervention).


   <b>Timing</b> <b>your</b> <b>terminal</b>
       In order to get accurate timings from your terminal <b>tack</b> needs to know when the terminal has finished
       processing all the characters that were sent.  This requires a different type of handshaking than the
       XON/XOFF that is supported by most terminals.  <b>Tack</b> needs to send a request to the terminal and  wait
       for  its  reply.  Many terminals will respond with an ACK when they receive an ENQ.  This is the pre-<font color="#ffffff" class="whiteout">ferred&nbsp;preferred</font>
       ferred method since the sequence is short.  ANSI/VT-100 style terminals can mimic this handshake with
       the escape sequence that requests 'primary device attributes'.

          ESC [ c

       The terminal will respond with a sequence like:

          ESC [ ? 1 ; 0 c

       <b>Tack</b>  assumes  that  (u9)  is the enquire sequence and that (u8) is the acknowledge string.  A VT-100
       style terminal could set u9=\E[c and u8=\E[?1;0c.  Acknowledge strings fall into two categories.   1)
       Strings  with a unique terminating character and, 2) strings of fixed length.  The acknowledge string
       for the VT-100 is of the first type since it always ends with the letter 'c'.  Some Tektronics termi-<font color="#ffffff" class="whiteout">nals&nbsp;terminals</font>
       nals  have fixed length acknowledge strings.  <b>Tack</b> supports both types of strings by scanning for the
       terminating character until the length of the expected acknowledge string has arrived.   (u8)  should
       be set to some typical acknowledge that will be returned when (u9) is sent.

       <b>Tack</b>  will  test  this  sequence before running any of the pad tests or the function key tests.  <b>Tack</b>
       will ask you the following:

           Hit lower case g to start testing...

       After it sends this message it will send the enquire string.  It will then read characters  from  the
       terminal until it sees the letter g.


   <b>Testing</b> <b>and</b> <b>Repairing</b> <b>Pad</b> <b>Timings</b>
       The  pad  timings in distributed terminfo entries are often incorrect.  One major motivation for this
       program is to make it relatively easy to tune these timings.

       You can verify and edit the pad timings for a terminal with the `test string  capabilities'  function
       (this is also part of the `normal test sequence' function).

       The  key to determining pad times is to find out the effective baud rate of the terminal.  The effec-<font color="#ffffff" class="whiteout">tive&nbsp;effective</font>
       tive baud rate determines the number of characters per second that the terminal  can  accept  without
       either  handshaking  or  losing  data.  This rate is frequently less than the nominal cps rate on the
       RS-232 line.

       <b>Tack</b> uses the effective baud rate to judge the duration of the test and how much a particular  escape
       sequence will perturb the terminal.

       Each  pad test has two associated variables that can be tweaked to help verify the correctness of the
       pad timings.  One is the pad test length.  The other is the pad multiplier, which is used if the  pad
       prefix  includes  `*'.  In curses use, it is often the first parameter of the capability (if there is
       one).  For a capability like (dch) or (il) this will be the number of character  positions  or  lines
       affected, respectively.

       <b>Tack</b>  will run the pad tests and display the results to the terminal.  On capabilities that have mul-<font color="#ffffff" class="whiteout">tipliers&nbsp;multipliers</font>
       tipliers <b>tack</b> will not tell you if the pad needs the multiplier or not.  You must make this  decision
       yourself  by rerunning the test with a different multiplier.  If the padding changes in proportion to
       the multiplier than the multiplier is required.  If the multiplier has little or  no  effect  on  the
       suggested padding then the multiplier is not needed.  Some capabilities will take several runs to get
       a good feel for the correct values.  You may wish to make  the  test  longer  to  get  more  accurate
       results.   System load will also effect the results (a heavily loaded system will not stress the ter-<font color="#ffffff" class="whiteout">minal&nbsp;terminal</font>
       minal as much, possibly leading to pad timings that are too short).


<b>NOTE</b>
       The tests done at the beginning of the program are assumed to be correct later in the code.  In  par-<font color="#ffffff" class="whiteout">ticular,&nbsp;particular,</font>
       ticular, <b>tack</b> displays the number of lines and columns indicated in the terminfo entry as part of its
       initial output.  If these values are wrong a large number  of  tests  will  fail  or  give  incorrect
       results.

<b>FILES</b>
       tack.log    If logging is enabled then all characters written to the terminal will also be written to
                   the log file.  This gives you the ability to see how the tests were performed.  This fea-<font color="#ffffff" class="whiteout">ture&nbsp;feature</font>
                   ture is disabled by default.

       <u>term</u>        If you make changes to the terminfo entry <b>tack</b> will save the new terminfo to a file.  The
                   file will have the same name as the terminal name.

<b>SEE</b> <b>ALSO</b>
       <a href="../man5/terminfo.5.html#//apple_ref/doc/man/5/terminfo"><b>terminfo</b>(5)</a>, <a href="../man3/ncurses.3x.html#//apple_ref/doc/man/3/ncurses"><b>ncurses</b>(3X)</a>, <a href="tic.1m.html#//apple_ref/doc/man/1/tic"><b>tic</b>(1M)</a>, <a href="infocmp.1m.html#//apple_ref/doc/man/1/infocmp"><b>infocmp</b>(1M)</a>.  You should also have the documentation  supplied  by
       the terminal manufacturer.

<b>BUGS</b>
       If the screen size is incorrect, many of the tests will fail.

<b>AUTHOR</b>
       Concept,  design, and original implementation by Daniel Weaver &lt;danw@znyx.com&gt;.  Portions of the code
       and documentation are by Eric S. Raymond &lt;esr@snark.thyrsus.com&gt;.



                                                                                                    tack(1M)
</tt></pre>
</td></tr></table>
	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Darwin/Reference/ManPages/man1/tack.1.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Darwin/Reference/ManPages/man1/tack.1.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Darwin/Reference/ManPages/man1/tack.1.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

</body></html>
