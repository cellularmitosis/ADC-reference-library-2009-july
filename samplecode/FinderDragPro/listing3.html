<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>FinderDragPro - /FinderDragPro.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/Carbon/index.html">Carbon</a> &gt; <a href="../../samplecode/Carbon/idxInterapplicationCommunication-date.html">Interapplication Communication</a> &gt; <A HREF="javascript:location.replace('index.html');">FinderDragPro</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">FinderDragPro</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/FinderDragPro.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/FDPUtilities.c</option>
<option value="listing2.html">/FDPUtilities.h</option>
<option value="listing3.html">/FinderDragPro.c</option>
<option value="listing4.html">/FinderDragPro.h</option>
<option value="listing5.html">/FinderDragPro.r</option>
<option value="listing6.html">/GetIconSuiteFromFinder.c</option>
<option value="listing7.html">/GetIconSuiteFromFinder.h</option></select>
				</p>
				</form>
				<p><strong><a href="FinderDragPro.zip">Download Sample</a></strong> (&#147;FinderDragPro.zip&#148;, 54.3K)<BR>
<strong><a href="FinderDragPro.dmg">Download Sample</a></strong> (&#147;FinderDragPro.dmg&#148;, 117.0K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*  File:    FinderDragPro.c    Description:   Sample file illustrating drag and drop techniques for use        with file system objects.  This file illustrates how applications        can use drag and drop commands in a way compatible with current        and past versions of the Finder.                 This file is organized into the following sections:                COPYING FILES          routines used for copying files.  For promised file flavors, we copy          files to the destination directory.  routines in this section manage          file copy operations performed when providing promised files.        SENDING DRAGS          routines used for dragging files out of the main window.  This includes          code for both standard hfs flavors and promised hfs flavors.         RECEIVING DRAGS          routines for receiving drags dropped into the main window.  this implementation          only accepts drags containing one item that can be either a promised hfs flavor          or a standard hfs flavor.  Of interest here is code for handling promised hfs flavors          provided by Find File.        THE MAIN FINDER DRAG PRO WINDOW          routines for maintaining the main window.  These routines are responsible for          drawing the window's contents, and for handling clicks in the main window.        MENU HANDLING          routines for processing menu commands.  In this implementation, there are          only two valid menu commands:  one to quit the application and one to clear          the main window's display.        APPLE EVENT HANDLERS          apple event handlers used in the application.  Of interest here is the bogus Finder          event handler installed for compatibility with past versions of the Finder.        EVENT HANDLING          general event processing routines used in the application including calls to          WaitNextEvent and dispatching based on the event returned.        MAIN          the main routine including initialization code, the main loop, and termination code.  Author:    John Montbriand        Some techniques borrowed from Pete Gontier's original FinderDragPro.  Copyright:   Copyright: &copy; 1999 by Apple Computer, Inc.        all rights reserved.    Disclaimer:  You may incorporate this sample code into your applications without        restriction, though the sample code has been provided &quot;AS IS&quot; and the        responsibility for its operation is 100% yours.  However, what you are        not permitted to do is to redistribute the source as &quot;DSC Sample Code&quot;        after having made changes. If you're going to re-distribute the source,        we require that you make it clear in the source that the code was        descended from Apple Sample Code, but that you've made changes.    Change History (most recent first):  9/9/99 by John Montbriand*/#include &quot;FinderDragPro.h&quot;#include &quot;GetIconSuiteFromFinder.h&quot;#include &quot;FDPUtilities.h&quot;#include &lt;Fonts.h&gt;#include &lt;Dialogs.h&gt;#include &lt;Icons.h&gt;#include &lt;PLStringFuncs.h&gt;#include &lt;TextUtils.h&gt;#include &lt;Gestalt.h&gt;#include &lt;QDOffscreen.h&gt;#include &lt;Sound.h&gt;#include &lt;StdIO.h&gt;#include &lt;String.h&gt;#include &lt;StdArg.h&gt;#include &lt;Devices.h&gt;#include &lt;Folders.h&gt;#include &lt;Appearance.h&gt;#include &lt;Threads.h&gt;#ifndef __MWERKS__QDGlobals  qd; /* QuickDraw globals */#endif  /* application's globals */Boolean gRunning = true; /* true while the application is running, set to false to quit */Boolean gAppleEvents = false; /* true if the Apple event Manager is installed */Boolean gHasDragManager = false; /* true if the Drag Manager is installed */Boolean gCanTranslucentDrag = false; /* true if translucent dragging is available */Boolean gHasIconServices = false; /* true if icon services is available */Boolean gAppearance = false; /* true if the Appearance Manager is installed */Boolean gColorExists = false; /* true if Color QuickDraw is installed */Boolean gForground = true; /* true while FDP is the frontmost application */Boolean gHasThreads = true; /* true if the thread manager is defined */AEIdleUPP gAEIdleProc = NULL; /* idle proc called from AEInteractWithUser */  /* globals specific to the main window */DialogPtr gDialog = NULL; /* a pointer to the main dialog */Rect gIconBox; /* area in the window where the information about the current file is drawn */ Rect gIconImage; /* area inside of gIconBox where the icon is drawn */ControlHandle gPromiseControl; /* control for setting gDragMode to kUsePromiseHFS */ControlHandle gRegularControl; /* control for setting gDragMode to kUseRegularHFS */short gDragMode = kUseRegularHFS; /* determines the type of data we will provide for drags */PicHandle gSplashPict; /* splash image displayed in gIconBox when there is no file selected */UserItemUPP gFDPUserItemProc = NULL; /* UPP for the icon's user item.  This routine draws into gIconBox */DragReceiveHandlerUPP gMainReceiveHandler = NULL; /* receive handler for the main dialog */DragTrackingHandlerUPP gMainTrackingHandler = NULL; /* tracking handler for the main dialog */DragSendDataUPP gSendDataProc = NULL; /* send data proc for the main dialog -- only used for promise hfs flavors. */  /* file related variables */Boolean gFileInDisplay = false; /* true when gFileAlias contains an alias handle */AliasHandle gFileAlias; /* an alias to the last file dragged into the gIconBox */Boolean gFileUpToDate = false; /* true if we have an icon for the file */Handle gIconSuite; /* icon suite for displaying the file -- only used if gHasIconServices is false */IconRef gIconRef; /* an icon services reference to an icon for the file -- only used if gHasIconServices is true */  /* gTargetFile refers to the last known location of the file referred to by gFileAlias.  once    every 2 seconds or so this location is compared to the location actually referred to by    gFileAlias.  If they differ, both gTargetFile and the display are updated. */FSSpec gTargetFile; /* refers to the last known location of the file.  */OSType gType, gCreator; /* file type and creator for the file in the display */unsigned short gFlags; /* flags for the file in the display *//* COPYING FILES ------------------------------------------------ */  /* for promise hfs flavors, FDP returns a fsspec referring to the file  and then it completes the copy operation later after the drag and drop  command has been completed.  Most of the routines in this section are callbacks  called by the CopyFileCmd routine defined in FDPUtilities.h.  Normally, your  application would create a new file containing interesting data rather than  copying an existing one, but for the purposes of this example this is all  we do here.  */  /* copy command variables */DialogPtr gCopyProgressWindow = NULL;/* HitCopyAsWindow is called when DialogSelect indicates an item has been  hit in the copy progress window (gCopyProgressWindow).  The only item  we're interested in here is the 'Cancel' button.  */static void HitCopyAsWindow(DialogPtr theDialog, EventRecord *ev, short itemNo) {  if (itemNo == kCProCancelItem)    AbortCopyOperation();}/* CopyProgressProc is called periodically during the file copy.  It's main function  is to swap out our task and allow other operating system services to run; however,  if the copy operation takes longer than kCopyProgressTicksOffset and the copy operation  is less than 90% complete it will pull up the copy progress window showing the status  of the copy.   */static void CopyProgressProc(FSSpec *theFile, short message, long percentCompleted) {  static long gPercentDrawn = 0;  static unsigned long gCopyStart = 0;  switch (message) {      case kCopyStart:      gPercentDrawn = 0;      gCopyProgressWindow = NULL;      gCopyStart = TickCount();      break;          case kCopyRun:        /* check the status of the copy status window */      if (gCopyProgressWindow == NULL) {        unsigned long now;          /* has the copy been active longer than kCopyProgressTicksOffset          and the command is less than 90 % complete. */        now = TickCount();        if ((now - gCopyStart &gt; kCopyProgressTicksOffset) &amp;&amp; (percentCompleted &lt; 90)) {          Point wLocation = {25, 25};            /* display our progress window.  Locate it relative to the main window. */          ParamText(theFile-&gt;name, NULL, NULL, NULL);          gCopyProgressWindow = GetNewDialog((gAppearance ? kCopyProgressDialog : kPlainCopyProgressDialog), NULL, (WindowPtr) (-1));          SetPort(gDialog);          LocalToGlobal(&amp;wLocation);          MoveWindow(gCopyProgressWindow, wLocation.h, wLocation.v, true);          ShowWindow(gCopyProgressWindow);          DrawDialog(gCopyProgressWindow); /* draw it */          gPercentDrawn = 0;        }      } else if (gPercentDrawn != percentCompleted) {        short itemt;        Handle itemh;        Rect itemb;        GetDialogItem(gCopyProgressWindow, kCProIndicatorItem, &amp;itemt, &amp;itemh, &amp;itemb);        if (gAppearance) {          SetControlValue((ControlHandle) itemh, percentCompleted);        } else {          Str255 textbuf;          textbuf[0] = sprintf((char*) textbuf+1, &quot;%d%% Complete&quot;, percentCompleted);          SetDialogItemText(itemh, textbuf);        }        gPercentDrawn = percentCompleted;      }      break;            case kCopyEnd:      if (gCopyProgressWindow != NULL) DisposeDialog(gCopyProgressWindow);      break;    }}static void MyCopyErrorHandler(FSSpec *theFile, short errorCode) {  if (errorCode == kCannotCopyDirError)    ParamAlert(kCannotCopyDirAlert, theFile-&gt;name, NULL);  else if (errorCode != userCanceledErr) {    Str255 errNum;    NumToString(errorCode, errNum);    ParamAlert(kCopyFailedAlert, theFile-&gt;name, errNum);  }}/* SENDING DRAGS ------------------------------------------------ *//* MyDragSendDataProc is the send data procedure used for providing promised  flavors.  In this routine we begin the copy operation to create the promised  file by calling StartCopyCommand and return a FSSpec to the caller referring  to the new file. */static pascal OSErr MyDragSendDataProc(FlavorType flavorType, void *refcon, ItemReference itemRef, DragReference dragRef) {  OSErr err = noErr;  AEDesc dropLocDesc, targetDirDesc;  FSSpec theTarget, theSource, destinationDir;  long destinationDirID;  Str255 targetName;  CInfoPBRec cat;  Boolean wasChanged;  FInfo srcInfo, dstInfo;  Boolean destCreated;      /* set up locals */  AECreateDesc(typeNull, NULL, 0, NULL);  AECreateDesc(typeNull, NULL, 0, NULL);  destCreated = false;      /* get the drop location where */  err = GetDropLocation(dragRef, &amp;dropLocDesc);  if (err != noErr) goto bail;      /* attempt to convert the location record to a FSSpec.  By doing it this way    instead of looking at the descriptorType field,  we don't need to know what    type the location originally was or what coercion handlers are installed.  */  err = AECoerceDesc(&amp;dropLocDesc, typeFSS, &amp;targetDirDesc);  if (err != noErr) goto bail;  BlockMoveData(*targetDirDesc.dataHandle, &amp;destinationDir, sizeof(FSSpec));        /* establish the target directory */  cat.hFileInfo.ioNamePtr = destinationDir.name;  cat.hFileInfo.ioVRefNum = destinationDir.vRefNum;  cat.hFileInfo.ioDirID = destinationDir.parID;  cat.hFileInfo.ioFDirIndex = 0;  err = PBGetCatInfoSync(&amp;cat);  if (err != noErr) goto bail;  destinationDirID = cat.hFileInfo.ioDirID;      /* construct the target FSSpec, verify the name is free... */  err = GetAliasInfo(gFileAlias, asiAliasName, targetName);  if (err != noErr) goto bail;  err = FSMakeFSSpec(destinationDir.vRefNum, destinationDirID, targetName, &amp;theTarget);  if (err == noErr) { err = dupFNErr; goto bail; }  if (err != fnfErr) goto bail;        /* find the source file.. */  err = ResolveAliasQuietly(NULL, gFileAlias, &amp;theSource, &amp;wasChanged);  if (err != noErr) goto bail;    /* get the source file's finder info */  err = FSpGetFInfo(&amp;theSource, &amp;srcInfo);  if (err != noErr) goto bail;        /* create the destination file.  Unless the promised file is created in    the drag send proc, the Finder will not position the icon correctly.  */  err = FSpCreate(&amp;theTarget, srcInfo.fdCreator, srcInfo.fdType, smSystemScript);  if (err != noErr) goto bail;  destCreated = true;        /* set the destintation's flags */  err = FSpGetFInfo(&amp;theTarget, &amp;dstInfo);  if (err != noErr) goto bail;  dstInfo.fdFlags = (srcInfo.fdFlags &amp; (~kHasBeenInited));  err = FSpSetFInfo(&amp;theTarget, &amp;dstInfo);  if (err != noErr) goto bail;        /* begin the copy command.  Now that the file has been created, we defer the    remainder of the copy operation until after the drag.  CopyFileCmd copies the    resource fork and the data fork from a background thread.  */  err = CopyFileCmd(&amp;theSource, &amp;theTarget, CopyProgressProc, MyCopyErrorHandler);  if (err != noErr) goto bail;        /* return a reference to the new file to the caller */  err = SetDragItemFlavorData(dragRef, itemRef, flavorType, &amp;theTarget, sizeof(theTarget), 0);  if (err != noErr) goto bail;        /* clean up and leave */  AEDisposeDesc(&amp;targetDirDesc);  AEDisposeDesc(&amp;dropLocDesc);  return noErr;  bail:  if (destCreated) FSpDelete(&amp;theTarget);  AEDisposeDesc(&amp;targetDirDesc);  AEDisposeDesc(&amp;dropLocDesc);  return err;}/* DragOut performs a drag operation from the main window to  somewhere else.  if gDragMode is kUsePromiseHFS, then DragOut  performs a drag using a promised hfs flavor that triggers a copy  operation when successful.  If translucent dragging is supported, then  a translucent drag image of the file's icon is added to the drag. */static pascal OSErr DragOut(const EventRecord *event) {  DragReference dragRef;  Boolean dragRefExists;  Boolean hasDragImage;  GWorldPtr imageGWorld;  RgnHandle maskRgn, dragRgn, insetRgn;  Point offsetPt, globalOrigin;  OSErr err;  Rect imageRect;  HFSFlavor theFlavor;      /* set up locals */  dragRefExists = false;  hasDragImage = false;  imageGWorld = NULL;  maskRgn = NULL;  dragRgn = NULL;  insetRgn = NULL;    /* create a new dragreference */  err = NewDrag(&amp;dragRef);  if (err != noErr) goto bail;  dragRefExists = true;      /* convert the file alias to a HFSFlavor structure */  err = MakeHFSFlavorFromAlias(gFileAlias, &amp;theFlavor);  if (err != noErr) goto bail;      /* add our flavors to the drag */  if (gDragMode == kUsePromiseHFS) { /* if the option key is down work in promises */     PromiseHFSFlavor phfs;          /* add a send data proc */    err = SetDragSendProc(dragRef, gSendDataProc, NULL);    if (err != noErr) goto bail;      /* add the promise flavor first */    phfs.fileType = theFlavor.fileType;    phfs.fileCreator = theFlavor.fileCreator;    phfs.fdFlags = theFlavor.fdFlags;    phfs.promisedFlavor = kPromisedFlavor;    err = AddDragItemFlavor(dragRef, kFDPDragItemID, flavorTypePromiseHFS, &amp;phfs, sizeof(phfs), flavorNotSaved);    if (err != noErr) goto bail;      /* add the HFS flavor immediately after the promise */    err = AddDragItemFlavor(dragRef, kFDPDragItemID, kPromisedFlavor, NULL, 0, flavorNotSaved);    if (err != noErr) goto bail;  } else if (gDragMode == kUseRegularHFS) {      /* add a hfs flavor to the drag  */    err = AddDragItemFlavor(dragRef, kFDPDragItemID, flavorTypeHFS, &amp;theFlavor, sizeof(HFSFlavor), flavorNotSaved);    if (err != noErr) goto bail;  } else {    err = paramErr;    goto bail;  }    /* add a translucent image, if appropriate */  if (gCanTranslucentDrag) {    err = IconsToMaskedPixMap(&amp;gIconImage, gIconSuite, gIconRef, &amp;imageGWorld, &amp;maskRgn);    if (err == noErr) {      imageRect = gIconImage;      OffsetRect(&amp;imageRect, -imageRect.left, -imageRect.top);      SetPt(&amp;offsetPt, gIconImage.left, gIconImage.top);      LocalToGlobal(&amp;offsetPt);      err = SetDragImage(dragRef, GetGWorldPixMap(imageGWorld), maskRgn, offsetPt, kDragStandardTranslucency);      if (err != noErr) goto bail;    }  }      /* calculate an outline-style drag region */  if ((dragRgn = NewRgn()) == NULL) { err = memFullErr; goto bail; }  if (gHasIconServices)    err = IconRefToRgn(dragRgn, &amp;gIconImage, kAlignNone, kIconServicesNormalUsageFlag, gIconRef);  else err = IconSuiteToRgn(dragRgn, &amp;gIconImage, kAlignNone, gIconSuite);  if (err != noErr) goto bail;  if ((insetRgn = NewRgn()) == NULL) { err = memFullErr; goto bail; }  CopyRgn(dragRgn, insetRgn);  InsetRgn(insetRgn, 1, 1);  DiffRgn(dragRgn, insetRgn, dragRgn);  SetPt(&amp;globalOrigin, qd.thePort-&gt;portRect.left, qd.thePort-&gt;portRect.top);  LocalToGlobal(&amp;globalOrigin);  OffsetRgn(dragRgn, globalOrigin.h, globalOrigin.v);    /* perform the drag operation */  err = TrackDrag(dragRef, event, dragRgn);  if (err == userCanceledErr) err = noErr;  if (err != noErr) goto bail;    /* clean up and leave */  if (imageGWorld != NULL) DisposeGWorld(imageGWorld);  if (maskRgn != NULL) DisposeRgn(maskRgn);  DisposeRgn(dragRgn);  DisposeRgn(insetRgn);  DisposeDrag(dragRef);  return noErr;bail:  /* error recovery */  if (imageGWorld != NULL) DisposeGWorld(imageGWorld);  if (maskRgn != NULL) DisposeRgn(maskRgn);  if (dragRgn != NULL) DisposeRgn(dragRgn);  if (insetRgn != NULL) DisposeRgn(insetRgn);  if (dragRefExists) DisposeDrag(dragRef);  return err;}/* RECEIVING DRAGS ------------------------------------------------ *//* ApproveDragReference is called by the drag tracking handler to determine  if the contents of the drag can be handled by our receive handler.    This routine checks to see if there is only one item in the drag  and that item contains either one of two flavors: 'flavorTypeHFS'  or 'flavorTypePromiseHFS'.  If the option key was held down at  the beginning of the drag, then this routine only checks for  the 'flavorTypePromiseHFS' in the first drag item.  We accept one item and one item only.  Note that if a flavor can't be found, it's not really an  error; it only means the flavor wasn't there and we should  not accept the drag. Therefore, we translate 'badDragFlavorErr'  into a 'false' value for '*approved'. */static pascal OSErr ApproveDragReference(DragReference theDragRef, Boolean *approved) {  OSErr err;  UInt16 itemCount;  DragAttributes dragAttrs;  FlavorFlags flavorFlags;  ItemReference theItem;        /* we cannot drag to our own window */  if ((err = GetDragAttributes(theDragRef, &amp;dragAttrs)) != noErr) goto bail;  if ((dragAttrs &amp; kDragInsideSenderWindow) != 0) { err = userCanceledErr; goto bail; }      /* we only accept drags containing one item */  if ((err = CountDragItems(theDragRef, &amp;itemCount)) != noErr) goto bail;  if (itemCount != 1) { err = paramErr; goto bail; }        /* gather information about the drag &amp; a reference to item one. */  if ((err = GetDragItemReferenceNumber(theDragRef, 1, &amp;theItem)) != noErr) goto bail;        /* check for flavorTypeHFS */  err = GetFlavorFlags(theDragRef, theItem, flavorTypeHFS, &amp;flavorFlags);  if (err == noErr) {    *approved = true;    return noErr;  } else if (err != badDragFlavorErr)    goto bail;        /* check for flavorTypePromiseHFS */  err = GetFlavorFlags(theDragRef, theItem, flavorTypePromiseHFS, &amp;flavorFlags);  if (err == noErr) {    *approved = true;    return noErr;  } else if (err != badDragFlavorErr)    goto bail;        /* none of our flavors were found */  *approved = false;  return noErr;bail:    /* an error occured, clean up.  set result to false. */  *approved = false;  return err;}  /* these routines are used both in the receive handler and inside of the    tracking handler.  The following variables are shared between MyDragTrackingHandler    and MyDragReceiveHandler.  */static Boolean gApprovedDrag = false; /* set to true if the drag is approved */static Boolean gInIconBox = false; /* set true if the drag is inside our drop box *//* MyDragTrackingHandler is called for tracking the mouse while a drag is passing over our  window.  if the drag is approved, then the drop box will be hilitied appropriately  as the mouse passes over it.  */static pascal OSErr MyDragTrackingHandler(DragTrackingMessage message, WindowPtr theWindow, void *refCon, DragReference theDragRef) {    /* we're drawing into the image well if we hilite... */  switch (message) {      case kDragTrackingEnterWindow:      {  Point mouse;        gApprovedDrag = false;        if (theWindow == FrontWindow()) {          if (ApproveDragReference(theDragRef, &amp;gApprovedDrag) != noErr) break;          if ( ! gApprovedDrag ) break;          SetPort(theWindow);          GetMouse(&amp;mouse);          if (PtInRect(mouse, &amp;gIconBox)) {  /* if we're in the box, hilite... */            SetPort(theWindow);            gInIconBox = (ShowDragHiliteBox(theDragRef, &amp;gIconBox) == noErr);          }        }      }      break;    case kDragTrackingInWindow:      if (gApprovedDrag) {        Point mouse;        SetPort(theWindow);        GetMouse(&amp;mouse);        if (PtInRect(mouse, &amp;gIconBox)) {          if ( ! gInIconBox) {  /* if we're entering the box, hilite... */            SetPort(theWindow);            gInIconBox = (ShowDragHiliteBox(theDragRef, &amp;gIconBox) == noErr);          }        } else if (gInIconBox) {  /* if we're exiting the box, unhilite... */          HideDragHilite(theDragRef);          gInIconBox = false;        }      }      break;    case kDragTrackingLeaveWindow:      if (gApprovedDrag &amp;&amp; gInIconBox) {        HideDragHilite(theDragRef);      }      gApprovedDrag = gInIconBox = false;      break;  }  return noErr; // there's no point in confusing Drag Manager or its caller}/* SetDragAndDropDirectory sets the drop location for the drag reference  to the indicated directory.  This routine will be called from inside of the  drag receive handler when a promised hfs flavor about to be received.  The purpose  of the call to SetDropLocation is to tell the sending application where to put the  promised file or folder.  This routine sets up parameters referring to the  (vRefNum, dirID) directory and calls SetDropLocation. */static OSErr SetDragAndDropDirectory(DragReference theDragRef, short vRefNum, long dirID) {  Str255 name;  CInfoPBRec cat;  FSSpec spec;  AliasHandle theAlias;  AEDesc theDropLocation;  OSErr err;    /* set up locals */  theAlias = NULL;  AECreateDesc(typeNull, NULL, 0, NULL);    /* find out the folder's parent ID */  cat.hFileInfo.ioNamePtr = name;  cat.hFileInfo.ioVRefNum = vRefNum;  cat.hFileInfo.ioDirID = dirID;  cat.hFileInfo.ioFDirIndex = -1;  err = PBGetCatInfoSync(&amp;cat);  if (err != noErr) goto bail;    /* now convert it to a FSSpec record */  err = FSMakeFSSpec(vRefNum, cat.dirInfo.ioDrParID, name, &amp;spec);  if (err != noErr) goto bail;    /* convert the FSSpec to an alias */  err = NewAlias(NULL, &amp;spec, &amp;theAlias);  if (err != noErr) goto bail;    /* and make it into a descriptor record */  HLock((Handle) theAlias);  err = AECreateDesc(typeAlias,*theAlias, GetHandleSize((Handle) theAlias), &amp;theDropLocation);  if (err != noErr) goto bail;    /* set it as the drag's drop location */  err = SetDropLocation(theDragRef, &amp;theDropLocation);  if (err != noErr) goto bail;    /* we're done, clean up */  AEDisposeDesc(&amp;theDropLocation);  DisposeHandle((Handle) theAlias);  return noErr;bail:  AEDisposeDesc(&amp;theDropLocation);  if (theAlias != NULL) DisposeHandle((Handle) theAlias);  return err;}/* MyDragReceiveHandler is the receive handler for the main window.  It is called  when a file or folder (or a promised file or folder) is dropped into the drop  box in the main window.  Here, if the drag reference has been approved in the  track drag call, we handle three different cases:    1. standard hfs flavors,    2. promised flavors provided by find file,    3. promised flavors provided by other applications.    After receiving a file, the display is updated.  Any promised files are  placed on the desktop. */static pascal OSErr MyDragReceiveHandler(WindowPtr theWindow, void *refcon, DragReference theDragRef) {  ItemReference theItem;  HFSFlavor targetFile;  PromiseHFSFlavor targetPromise;  FSSpec targetSpec;  Size theSize;  OSErr err;      /* validate the drag.  Recall the receive handler will only be called after    the tracking handler has received a kDragTrackingInWindow event.  As a result,    the gApprovedDrag and gInIconBox will be defined when we arrive here.  Hence,    there is no need to spend extra time validating the drag at this point. */  if ( ! (gApprovedDrag &amp;&amp; gInIconBox) ) { err = userCanceledErr; goto bail; }      /* get the first item reference */  if ((err = GetDragItemReferenceNumber(theDragRef, 1, &amp;theItem)) != noErr) goto bail;        /* try to get a  HFSFlavor*/  theSize = sizeof(HFSFlavor);  err = GetFlavorData(theDragRef, theItem, flavorTypeHFS, &amp;targetFile, &amp;theSize, 0);  if (err == noErr) {    SetNewDisplay(&amp;targetFile);    return noErr;  } else if (err != badDragFlavorErr) goto bail;      /* try to get a  promised HFSFlavor*/  theSize = sizeof(PromiseHFSFlavor);  err = GetFlavorData(theDragRef, theItem, flavorTypePromiseHFS, &amp;targetPromise, &amp;theSize, 0);  if (err != noErr) goto bail;      /* check for a drop from find file */  if (targetPromise.promisedFlavor == kPromisedFlavorFindFile) {        /* from find file, no need to set the file location... */    theSize = sizeof(FSSpec);    err = GetFlavorData(theDragRef, theItem, targetPromise.promisedFlavor, &amp;targetSpec, &amp;theSize, 0);    if (err != noErr) goto bail;    } else {    short deskVol;    long deskDir;      /* we'll put promised files on the desktop */    err = FindFolder(kOnSystemDisk, kDesktopFolderType, kCreateFolder, &amp;deskVol, &amp;deskDir);    if (err != noErr) goto bail;      /* set the drag destination to the desktop */    err = SetDragAndDropDirectory(theDragRef, deskVol, deskDir);    if (err != noErr) goto bail;          /* get the promised file */    theSize = sizeof(FSSpec);    err = GetFlavorData(theDragRef, theItem, targetPromise.promisedFlavor, &amp;targetSpec, &amp;theSize, 0);    if (err != noErr) goto bail;          /* verify the promise structure, make sure it's valid.  */    err = ValidFSSpec(&amp;targetSpec);    if (err != noErr) goto bail;  }    /* display the located file*/  SetNewDisplay(&amp;targetFile);  return noErr;bail:  return err;}/* THE MAIN FINDER DRAG PRO WINDOW ------------------------------------------------ *//* SetNewDisplay is called to set the file or folder being displayed in the main window.  Here, structures are deallocated and an alias is saved referring to the file.   SetNewDisplay is called from the drag receive handler and since it is not  safe to call &quot;GetIconSuiteFromFinder()&quot; from inside of the drag receive handler  (it uses apple events), the flag gFileUpToDate is used to defer that operation  until the next time ValidateFDPWindowDisplay.  ValidateFDPWindowDisplay is  called from the main loop.  If targetFile is NULL, then the display is cleared. */void SetNewDisplay(HFSFlavor *targetFile) {    /* remove the old file */  if (gFileInDisplay) {    DisposeHandle((Handle) gFileAlias);    if (gFileUpToDate) {      if (gHasIconServices)        ReleaseIconRef(gIconRef);      else DisposeIconSuite(gIconSuite, true);      gFileUpToDate = false;    }    gFileInDisplay = false;  }    /* set the new file, if there is one */  if (targetFile != NULL) {    gType = targetFile-&gt;fileType;    gCreator = targetFile-&gt;fileCreator;    gFlags = targetFile-&gt;fdFlags;    gTargetFile = targetFile-&gt;fileSpec;    gFileInDisplay = (NewAliasMinimal(&amp;gTargetFile, &amp;gFileAlias) == noErr);  }    /* post an update for the window */  SetPort(gDialog);  InvalRect(&amp;gIconBox);}/* ValidateFDPWindowDisplay is called from the main loop, before update events,  and when the application is switching in.  It works together with SetNewDisplay.  SetNewDisplay is called from the drag receive handler where sometimes it is  unsafe to retrieve a file's icons.  Instead of gathering the icon information inside  of SetNewDisplay, SetNewDisplay sets the flag gFileUpToDate.  ValidateFDPWindowDisplay  watches gFileUpToDate.  When this flag is false and there is a new file to be displayed,  ValidateFDPWindowDisplay retrieves the icon and posts an update event for the window.  To minimize resolve alias calls, if the icons have been fetched, then the alias is only  verified at most once per second. */static OSErr ValidateFDPWindowDisplay(void) {  Boolean wasChanged;  OSErr err;  static unsigned long gLastValidCall = 0;  unsigned long now;    wasChanged = false;  if (gFileInDisplay) {    now = TickCount();    if ( ( ! gFileUpToDate) || (gLastValidCall == 0) || (now - gLastValidCall &gt;= 60)) {      gLastValidCall = now;      err = ResolveAliasQuietly(NULL, gFileAlias, &amp;gTargetFile, &amp;wasChanged);      if (err != noErr) goto bail;      if ( ! gFileUpToDate) {        if (gHasIconServices) {          SInt16 theLabel;          err = GetIconRefFromFile(&amp;gTargetFile, &amp;gIconRef, &amp;theLabel);        } else err = GetIconSuiteFromFinder(&amp;gTargetFile, &amp;gIconSuite);        if (err != noErr) goto bail;        gFileUpToDate = true;        wasChanged = true;      }    }  }  if (wasChanged) {    SetPort(gDialog);    InvalRect(&amp;gIconBox);  }  return noErr;bail:  SetNewDisplay(NULL);  return err;}/* MyFDPUserItem draws the image in the drop box in the window.  If the window  is not the active window, then the image is drawn grayed out.  If appearance  is in use, then the drop box is drawn as a generic well. */static pascal void MyFDPUserItem(WindowPtr theWindow, DialogItemIndex itemNo) {  Rect rdraw;  RGBColor sForground, sBackground;  RGBColor rgbWhite = {0xFFFF, 0xFFFF, 0xFFFF}, rgbBlack = {0, 0, 0}, rgbGray = {0x7FFF, 0x7FFF, 0x7FFF};    /* set up */  SetPort(theWindow);    /* set the colors we're using for drawing */  if (gColorExists) {    GetForeColor(&amp;sForground);    GetBackColor(&amp;sBackground);    RGBForeColor(&amp;rgbBlack);    RGBBackColor(&amp;rgbWhite);  }    /* draw the frame */  if (gAppearance) {    ThemeDrawState themeDrawState;    themeDrawState = (gForground &amp;&amp; (theWindow == FrontWindow())) ? kThemeStateActive : kThemeStateInactive;    DrawThemeGenericWell(&amp;gIconBox, themeDrawState,  true);  } else {    rdraw = gIconBox;    EraseRect(&amp;gIconBox);    InsetRect(&amp;rdraw, -1, -1);    FrameRect(&amp;rdraw);  }    /* draw the file information */  if (gFileInDisplay &amp;&amp; gFileUpToDate) {    OSErr err;    short baseLine;    long textLength;    char textbuf[256];    FontInfo fin;    Str255 name;      /* begin drawing */    TextFont(kFontIDGeneva); /* geneva */    TextSize(9);    GetFontInfo(&amp;fin);      /* draw the icon image */    if (gHasIconServices)      err = PlotIconRef(&amp;gIconImage, kAlignNone, kTransformNone, kIconServicesNormalUsageFlag, gIconRef);    else err = PlotIconSuite(&amp;gIconImage, kAlignNone, kTransformNone, gIconSuite);      /* draw the file name */    baseLine = gIconImage.bottom + fin.ascent;    memcpy(name, gTargetFile.name, gTargetFile.name[0] + 1);    TruncString(gIconBox.right - gIconBox.left - 4, name,  truncEnd);    MoveTo((gIconBox.left + gIconBox.right - StringWidth(name))/2, baseLine);    DrawString(name);      /* draw the location */    textLength = sprintf(textbuf, &quot;vRefNum %d, parID %d&quot;, gTargetFile.vRefNum, gTargetFile.parID);    baseLine += fin.ascent + fin.descent;    MoveTo((gIconBox.left + gIconBox.right - TextWidth(textbuf, 0, textLength))/2, baseLine);    DrawText(textbuf, 0, textLength);      /* draw the type and flags */    textLength = sprintf(textbuf, &quot;%.4s %.4s  0x%.4X&quot;, &amp;gType, &amp;gCreator, gFlags);    baseLine += fin.ascent + fin.descent;    MoveTo((gIconBox.left + gIconBox.right - TextWidth(textbuf, 0, textLength))/2, baseLine);    DrawText(textbuf, 0, textLength);      /* end drawing */    TextFont(systemFont); /* back to the system font */    TextSize(12);  } else {    Rect rPic;    rPic = (**gSplashPict).picFrame;    OffsetRect(&amp;rPic, -rPic.left, -rPic.top);    OffsetRect(&amp;rPic, (gIconBox.left + gIconBox.right - rPic.right)/2, (gIconBox.top + gIconBox.bottom - rPic.bottom)/2);    DrawPicture(gSplashPict, &amp;rPic);  }    /* gray the image if we're in the background */  if ( ! (gForground &amp;&amp; (theWindow == FrontWindow())) ) {    GrayOutBox(&amp;gIconBox);  }    /* restore previous colors */  if (gColorExists) {    RGBForeColor(&amp;sForground);    RGBBackColor(&amp;sBackground);  }}/* CreateFDPWindow creates the main finder drag pro window. It installs  tracking handlers and sets up the controls and user items in the window. */static pascal OSErr CreateFDPWindow(DialogPtr *theDialog) {  OSErr err;  Boolean installedTracker, installedReceiver;  short itemt;  Rect itemb;  Handle itemh;  DialogPtr dialog;      /* set up locals for recovery */  dialog = NULL;  installedTracker = installedReceiver = false;      /* create the dialog */  dialog = GetNewDialog(kFDPDialogResource, NULL, (WindowPtr) (-1));    if (dialog == NULL) { err = memFullErr; goto bail; }      /* grab and set up our dialog items */  GetDialogItem(dialog, kFDPUserItem, &amp;itemt, (Handle*) &amp;itemh, &amp;gIconBox);  SetDialogItem(dialog, kFDPUserItem, userItem, (Handle) gFDPUserItemProc, &amp;gIconBox);  GetDialogItem(dialog, kFDPpromiseItem, &amp;itemt, (Handle*) &amp;gPromiseControl, &amp;itemb);  GetDialogItem(dialog, kFDPhfsItem, &amp;itemt, (Handle*) &amp;gRegularControl, &amp;itemb);        /* set initial control values */  SetControlValue(gPromiseControl, (gDragMode == kUsePromiseHFS ? 1 : 0));  SetControlValue(gRegularControl, (gDragMode == kUseRegularHFS ? 1 : 0));    /* calculate the drawn icon's boundary */  SetRect(&amp;gIconImage, 0, 0, 32, 32);  OffsetRect(&amp;gIconImage, (gIconBox.right + gIconBox.left - 32) / 2, gIconBox.top + 16);    /* install the drag handlers */  err = InstallTrackingHandler(gMainTrackingHandler, dialog, NULL);  if (err != noErr) { err = memFullErr; goto bail; }  installedTracker = true;  err = InstallReceiveHandler(gMainReceiveHandler, dialog, NULL);  if (err != noErr) { err = memFullErr; goto bail; }  installedReceiver = true;    /* done, window complete */  *theDialog = dialog;  return noErr;bail:  if (installedReceiver)    RemoveReceiveHandler(gMainReceiveHandler, dialog);  if (installedTracker)    RemoveTrackingHandler(gMainTrackingHandler, dialog);  if (dialog != NULL) DisposeDialog(dialog);  return err;}/* DisposeFDPWindow disposes of any structures allocated for the    main finder drag pro window.  the call to SetNewDisplay with a  NULL parameter forces it to deallocate any icons and the  alias allocated for the item being displayed. */static void DisposeFDPWindow(DialogPtr theDialog) {  SetNewDisplay(NULL);  RemoveTrackingHandler(gMainTrackingHandler, theDialog);  RemoveReceiveHandler(gMainReceiveHandler, theDialog);  DisposeDialog(theDialog);}/* HitFDPWindow is called when the dialog manager's DialogSelect indicates  that an item in the main finder drag pro window has been hit.  Here,  either we begin a drag, or we adjust the promise/regular hfs controls */static void HitFDPWindow(DialogPtr theDialog, EventRecord *event, short itemNo) {  switch (itemNo) {    case kFDPUserItem:      if (gFileInDisplay) {        Point where;        Boolean isInSuite;        OSErr err, err2;          /* set up */        SetPort(theDialog);        where = event-&gt;where;        GlobalToLocal(&amp;where);          /* if the click is in the icon.... */        if (gHasIconServices)          isInSuite = PtInIconRef(&amp;where, &amp;gIconImage, kAlignNone, kIconServicesNormalUsageFlag,  gIconRef);        else isInSuite = PtInIconSuite(where, &amp;gIconImage, kAlignNone, gIconSuite);        if (isInSuite) {            /* draw the icon as 'selected' */          if (gHasIconServices)            err = PlotIconRef(&amp;gIconImage, kAlignNone, kTransformSelected, kIconServicesNormalUsageFlag, gIconRef);          else err = PlotIconSuite(&amp;gIconImage, kAlignNone, kTransformSelected, gIconSuite);          if (err == noErr) {              /* is it a drag command? */            if (WaitMouseMoved (event-&gt;where)) {                /* if it is, drag it */              err = DragOut(event);            }              /* restore the icon's original view */            if (gHasIconServices)              err2 = PlotIconRef(&amp;gIconImage, kAlignNone, kTransformNone, kIconServicesNormalUsageFlag, gIconRef);            else err2 = PlotIconSuite(&amp;gIconImage, kAlignNone, kTransformNone, gIconSuite);            if (err == noErr) err = err2;          }          if (err != noErr) {            Str255 errStr;            NumToString(err, errStr);            ParamAlert(kDragFailedAlert, errStr, NULL);          }        }      }      break;          case kFDPhfsItem: /* use regular hfs drags */      gDragMode = kUseRegularHFS;      SetControlValue(gPromiseControl, 0);      SetControlValue(gRegularControl, 1);      break;          case kFDPpromiseItem: /* use promised hfs drags */      gDragMode = kUsePromiseHFS;      SetControlValue(gPromiseControl, 1);      SetControlValue(gRegularControl, 0);      break;  }}/* MENU HANDLING ------------------------------------------------ *//* ResetMenus is called to reset the menus immediately before  either MenuSelect or MenuKey is called.  Here, we disable the  quit command during file copies. */static void ResetMenus(void) {  MenuHandle fileMenu;    /* get the file menu from the current menu list */  fileMenu = GetMenuHandle(mFile);    /* disable quit if we're in the middle of copying a file */  if (CopyFileInProgress())    DisableItem(fileMenu, iQuit);  else EnableItem(fileMenu, iQuit);}/* DoMenuCommand is called after either MenuSelect of MenuKey.  The  parameter rawMenuSelectResult is the result from one of these two routines.   DoMenuCommand parses this result into its two parts, and dispatches  the menu command as appropriate. */static void DoMenuCommand(long rawMenuSelectResult) {  short menu, item;    /* decode the MenuSelect result */  menu = (rawMenuSelectResult &gt;&gt; 16);  if (menu == 0) return;  item = (rawMenuSelectResult &amp; 0x0000FFFF);    /* dispatch on result */  switch (menu) {    case mApple:      if (item == iAbout) {          /* show the about box. */        ParamAlert(kAboutBoxAlert, NULL, NULL);      } else if (item &gt;= iFirstAppleItem) {        Str255 deskAccName;          /* open an apple menu item. */        GetMenuItemText(GetMenuHandle(mApple), item, deskAccName);        OpenDeskAcc(deskAccName);      }      break;    case mFile:      if (item == iQuit) gRunning = false; /* file.quit == quit */      break;    case mEdit:      if (item == iClear) SetNewDisplay(NULL); /* edit.clear == clear the display */      break;  }    /* unhilite the menu once we're done the command */  HiliteMenu(0);}/* APPLE EVENT HANDLERS ------------------------------------------------ *//* BogusFinderEventHandler is an event handler installed for compatibility reasons  as described below.  Not all finders behave in this way, but or universal compatibility,  applications wishing to drag and drop hfs flavors to the finder should add one of  these handlers to their code.  In cases where the finder does have this problem,  this routine will lie dormant and will not be used.  When a HFSFlavor item is provided to the Finder and the drop location is on a  different volume, the finder will attempt to copy the file to the new volume.  As  a part of the copy operation, the finder sends some apple events to the frontmost  application (assuming it's the finder) that are used to run the finder's copy progress  windows.  If our application happens to be frontmost, those events will be sent to  us which will cause the Finder to cancel.  By installing the handler, we avoid this problem  by ignoring the bogus events ourselves.,.... */static pascal OSErr BogusFinderEventHandler(const AppleEvent *theEvent, AppleEvent *theReply, long refcon) {  return noErr;}static OSErr GotReqParam(const AppleEvent *apple_event) {  DescType retType;  Size actSize;  OSErr err;  err = AEGetAttributePtr(apple_event, keyMissedKeywordAttr, typeWildCard, &amp;retType, NULL, 0, &amp;actSize);  if (err == errAEDescNotFound)    return noErr;  else if (err == noErr)    return errAEEventNotHandled;  else return err;}/* OpenApplication is an apple event handler called for 'open application' apple events. */static pascal OSErr OpenApplication(const AppleEvent *appleEvt, AppleEvent* reply, long refcon) {  OSErr err;  if ((err = GotReqParam(appleEvt)) != noErr) return err;  err = CreateFDPWindow(&amp;gDialog);  if (err != noErr) {    Str255 errStr;    NumToString(err, errStr);    ParamAlert(kOpenAppFailedAlert, errStr, NULL);  }  return noErr;}/* CloseApplication is an apple event handler called for 'close application' apple events. */static pascal OSErr CloseApplication(const AppleEvent *appleEvt, AppleEvent* reply, long refcon) {  OSErr err;  if ((err = GotReqParam(appleEvt)) != noErr) return err;  gRunning = false;  return noErr;}/* EVENT HANDLING ------------------------------------------------ *//* HandleNextEvent handles the event in the event record *ev dispatching  the event to appropriate routines.   */static void HandleNextEvent(EventRecord *ev) {  DialogPtr theDialog;  WindowPtr theWindow;  short itemNo;      /* dialog pre-processing */  if (((ev-&gt;what == keyDown) || (ev-&gt;what == autoKey)) &amp;&amp; ((ev-&gt;modifiers &amp; cmdKey) != 0)) {    ResetMenus();    DoMenuCommand(MenuKey((char) (ev-&gt;message &amp; charCodeMask)));  } else if (ev-&gt;what == osEvt) {    if ( (((ev-&gt;message &gt;&gt; 24) &amp; 0x0FF) == suspendResumeMessage) &amp;&amp; ((ev-&gt;message &amp; resumeFlag) != 0)) {        /* switching in */      ValidateFDPWindowDisplay();      gForground = true;    } else gForground = false;    if (gDialog != NULL) {      HiliteControl(gPromiseControl, (gForground ? 0 : 255));      HiliteControl(gRegularControl, (gForground ? 0 : 255));      DrawDialog(gDialog);    }  } else if (ev-&gt;what == updateEvt) {    if (gDialog == ((DialogPtr) ev-&gt;message))      ValidateFDPWindowDisplay();  } else if (ev-&gt;what == activateEvt) {    if (gDialog == ((DialogPtr) ev-&gt;message)) {      HiliteControl(gPromiseControl, ((gDialog == FrontWindow()) ? 0 : 255));      HiliteControl(gRegularControl, ((gDialog == FrontWindow()) ? 0 : 255));      DrawDialog(gDialog);    }  }    /* handle clicks in the dialog window */  if (IsDialogEvent(ev))    if (DialogSelect(ev, &amp;theDialog, &amp;itemNo)) {      if (theDialog == gDialog)        HitFDPWindow(theDialog, ev, itemNo);      else if (theDialog == gCopyProgressWindow)        HitCopyAsWindow(theDialog, ev, itemNo);    }    /* clicks and apple events... */  if (ev-&gt;what == kHighLevelEvent &amp;&amp; gAppleEvents) {    AEProcessAppleEvent(ev);  } else if (ev-&gt;what == nullEvent) {    ValidateFDPWindowDisplay(); /* revalidate once every two seconds */  } else if (ev-&gt;what == mouseDown)    switch (FindWindow(ev-&gt;where, &amp;theWindow)) {              /* menu bar clicks */      case inMenuBar:        ResetMenus();        DoMenuCommand(MenuSelect(ev-&gt;where));        break;                /* clicks in the close box, close the app */      case inGoAway:        if (TrackGoAway(theWindow, ev-&gt;where)) {          gRunning = false;        }        break;                /* allow window drags */      case inDrag:        if (theWindow == FrontWindow()) {          Rect boundsRect = { -32000, -32000, 32000, 32000};          DragWindow(theWindow, ev-&gt;where, &amp;boundsRect);        }        break;                /* desktop clicks, etc... */      case inSysWindow:        SystemClick(ev, theWindow);        break;    }}/* ProcessNextEvent calls WaitNextEvent to get the next event and then it passes  the event along to the HandleNextEvent routine.  sleepTime is passed to the  WaitNextEvent routine in the sleep parameter. */void ProcessNextEvent(long sleepTime) {  EventRecord ev;    /* get the next event */  if ( ! WaitNextEvent(everyEvent, &amp;ev,  sleepTime, NULL) )    ev.what = nullEvent;  HandleNextEvent(&amp;ev);}/* FDPIdleProcedure is the idle procedure called by AEInteractWithUser while we are waiting  for the application to be pulled into the forground.  It simply passes the event along  to HandleNextEvent */static pascal Boolean FDPIdleProcedure(EventRecord *theEvent, long *sleepTime, RgnHandle *mouseRgn) {  HandleNextEvent(theEvent);  return false;}/* ParamAlert is a general alert handling routine.  If Apple events exist, then it  calls AEInteractWithUser to ensure the application is in the forground, and then  it displays an alert after passing the s1 and s2 parameters to ParamText. */short ParamAlert(short alertID, StringPtr s1, StringPtr s2) {  if (gAppleEvents)    AEInteractWithUser(kNoTimeOut, NULL, gAEIdleProc);  ParamText(s1, s2, NULL, NULL);  return Alert(alertID, NULL);}/* MAIN ------------------------------------------------ */int main(void) {  OSErr err;  long response;        /* ***** set up the os ***** */    /* set up our app */  SetApplLimit(GetApplLimit());  MaxApplZone();  InitGraf(&amp;qd.thePort);  InitFonts();  InitWindows();  TEInit();  InitMenus();  InitDialogs(0);  FlushEvents(everyEvent, 0);  InitCursor();                /* ***** look at machine features ***** */    /* apple events??? */  if (Gestalt(gestaltAppleEventsAttr, &amp;response) != noErr) response = 0;  gAppleEvents = ((response &amp; (1&lt;&lt;gestaltAppleEventsPresent)) != 0);    /* check for the drag manager &amp; translucent feature??? */  if (Gestalt(gestaltDragMgrAttr, &amp;response) != noErr) response = 0;  gHasDragManager = ((response &amp; (1 &lt;&lt; gestaltDragMgrPresent)) != 0);  gCanTranslucentDrag = ((response &amp; (1 &lt;&lt; gestaltDragMgrHasImageSupport)) != 0);    /* icon services??? */  if (Gestalt(gestaltIconUtilitiesAttr, &amp;response) != noErr) response = 0;  gHasIconServices = ((response &amp; (1 &lt;&lt; gestaltIconUtilitiesHasIconServices)) != 0);    /* colour quickdraw */  if (Gestalt(gestaltQuickdrawVersion, &amp;response) != noErr) response = 0;  gColorExists = (response &gt;= gestalt8BitQD);    /* colour quickdraw */  if (Gestalt(gestaltThreadMgrAttr, &amp;response) != noErr) response = 0;  gHasThreads = ((response &amp; (1&lt;&lt;gestaltThreadMgrPresent)) != 0);    /* appearance */  if (Gestalt(gestaltAppearanceAttr, &amp;response) != noErr) response = 0;  if ((response &amp; (1&lt;&lt;gestaltAppearanceExists)) != 0) {    err = RegisterAppearanceClient();    if (err != noErr) goto bail;    gAppearance = true;  }            /* ***** abort if features we need aren't present ***** */  if ( ! gHasDragManager) { err = kNoDragMgrError; goto bail; }  if ( ! gHasThreads) { err = kNoThreadMgrError; goto bail; }            /* ***** install apple event handlers ***** */    /* install our Apple event handlers */  if (gAppleEvents) {    AEEventHandlerUPP aehandler;      /* the bogus finder event handler */    aehandler = NewAEEventHandlerProc(BogusFinderEventHandler);    if (aehandler == NULL) { err = memFullErr; goto bail; }    err = AEInstallEventHandler ('cwin','****', aehandler, 0, false);    if (err != noErr) goto bail;      /* standard apple events */    aehandler = NewAEEventHandlerProc(OpenApplication);    if (aehandler == NULL) { err = memFullErr; goto bail; }    err = AEInstallEventHandler(kCoreEventClass, kAEOpenApplication, aehandler, 0, false);    if (err != noErr) goto bail;    aehandler = NewAEEventHandlerProc(CloseApplication);    if (aehandler == NULL) { err = memFullErr; goto bail; }    err = AEInstallEventHandler(kCoreEventClass, kAEQuitApplication, aehandler, 0, false);    if (err != noErr) goto bail;  }    /* ***** initialize the application's globals ***** */    /* set up our routine descriptors */  gFDPUserItemProc = NewUserItemProc(MyFDPUserItem);  if (gFDPUserItemProc == NULL) { err = memFullErr; goto bail; }  gMainTrackingHandler = NewDragTrackingHandlerProc(MyDragTrackingHandler);  if (gMainTrackingHandler == NULL) { err = memFullErr; goto bail; }  gMainReceiveHandler = NewDragReceiveHandlerProc(MyDragReceiveHandler);  if (gMainReceiveHandler == NULL) { err = memFullErr; goto bail; }  gSendDataProc = NewDragSendDataProc(MyDragSendDataProc);  if (gSendDataProc == NULL) { err = memFullErr; goto bail; }  gAEIdleProc = NewAEIdleProc(FDPIdleProcedure);  if (gAEIdleProc == NULL) { err = memFullErr; goto bail; }        /* get other resources */  gSplashPict = GetPicture(kFDPSpashPictResource);  if (gSplashPict == NULL) { err = resNotFound; goto bail; }        /* ***** set up the menu bar ***** */  SetMenuBar(GetNewMBar(kFDPMenuBarResource));  DrawMenuBar();  AppendResMenu(GetMenuHandle(mApple), 'DRVR');    /* ***** run the app ***** */  while (gRunning) {    ProcessNextEvent(CopyFileInProgress() ? kCopySleepTime : kNormalSleepTime);    YieldToAnyThread();  }      /* ***** tear down ***** */bail:  switch (err) {    case userCanceledErr:    case noErr:      /* no alert here */      break;    case kNoDragMgrError:      ParamAlert(kNoDragManagerAlert, NULL, NULL);      break;    default:      {  Str255 errStr;        NumToString(err, errStr);        ParamAlert(kMainFailedAlert, errStr, NULL);      }      break;  }  if (gDialog != NULL) DisposeFDPWindow(gDialog);  if (gAppearance)    UnregisterAppearanceClient();  ExitToShell();  return 0;}</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/FinderDragPro/listing3.html%3Fid%3DDTS10000665-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/FinderDragPro/listing3.html%3Fid%3DDTS10000665-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/FinderDragPro/listing3.html%3Fid%3DDTS10000665-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>