<html><head><title>Enterprise Objects Framework Viewed Through Its Classes</title></head><body bgcolor="#ffffff"><!--start of banner --><!--#include virtual="/includes/framesetheader" --><!-- end of banner --><!--start of path --><font face="Geneva,Helvetica,Arial" size="1"><b>PATH<spacer type="horizontal" size="5">&nbsp;</b> <a href="../../../../../../index.html" target="_top">Documentation</a> <b>&gt;</b> <a href="../../../../../webobjects.html" target="_top">WebObjects 4.5</a> <b>&gt;</b>EOF Developer's Guide</font><br><br><!--end of path --> <a href="EOFClasses.html"><IMG SRC="ArrowUp.gif">Table of Contents</a> <a href="EOFClasses.html"><IMG SRC="ArrowLeft.gif">Previous Section</a> <a name="10223"><h1> Classes in a Command-Line Program</h1></a><a name="10224">A command-line program-one that doesn't have a graphical user interface-uses the most fundamental Enterprise Objects Framework classes (<a href="EOFClasses1.html#10233">Figure &#32;11</a>). The same classes are used in all the most typical types of applications, but other types add other classes for interacting with the user interface.<p></a><a name="10233"><p><img src="EOFClasses.gif"><p></a><a name="102"><p>Figure 11.	  Framework classes in a Command-Line Program<p></a><a name="10234">The next sections introduce these classes, following the flow of data from the database, through the access layer, to the control layer.<p></a><a name="10"><h2> The Access Layer</h2></a><a name="10237">The access layer is the part of the Framework that interacts with the database. Its role in a command-line program is much the same as it is in all other types: it fetches rows of data from a database, creates enterprise objects from the fetched data, and registers the enterprise objects with the control layer-the next layer up in an application's architecture. Later, when the control layer has changes to save, it directs the access layer to write those changes to the database.<p></a><a name="14844">The access layer is divided into three functional groupings:<p></a><ul><a name="14846"><p><li>	The <em>adaptor level</em> that interacts with a database in terms of server-specific client libraries, providing server-independent database access to the rest of the Framework.</a><a name="10242"><p><li>	The <em>database level</em> that creates full-fledged enterprise objects from database rows.</a><a name="10243"><p><li><em>Modeling classes</em> that furnish database login information and a &#32;database-to-objects mapping.</a></ul><a name="10247"><a href="EOFClasses1.html#10255">Figure &#32;12</a> shows how each grouping fits into the architecture of an application. The bottom row of classes (EOAdaptor, EOAdaptorContext, and EOAdaptorChannel) constitutes the adaptor level. The top row of &#32;classes in (EODatabase, EODatabaseContext, and EODatabaseChannel) constitutes the database level.<p></a><a name="10248">EOModel is one of the modeling classes. An EOModel object represents the whole database-to-objects mapping in entity-relationship terms, while other modeling classes correspond to components of that mapping. The adaptor level, database level, and modeling classes are described in greater detail in the following sections.<p></a><a name="10255"><p><img src="EOFClasses1.gif"><p></a><a name="1021"><p>Figure 12.	  The Access Layer<p></a><a name="10257"><h3> The Adaptor Level</h3></a><a name="10258">The adaptor level defines a server-independent interface for working with relational database systems. <a href="EOFClasses1.html#10268">Figure &#32;13</a> shows the adaptor level classes and the behaviors associated with each class.<p></a><a name="10265"><p><img src="EOFClasses2.gif"><p></a><a name="10268"><p>Figure 13.	  Adaptor Level<p></a><a name="10269">Server-specific subclasses encapsulate the behavior of database servers, thereby offering a uniform way of interacting with servers while still allowing applications to exploit their unique features. For example, the Framework provides the classes OracleAdaptor, OracleAdaptorContext, and OracleAdaptorChannel which implement the functionality specified in the adaptor level in terms of the Oracle client libraries. Together, the server-specific subclasses are referred to as an <em>adaptor</em>. For instance, the &#32;Oracle subclasses are collectively referred to as the Oracle adaptor.<p></a><a name="10270">The adaptor level deals with database rows packaged as NSDictionary objects. When an adaptor fetches from a relational database, it receives the raw data in whatever form the database client libraries provide. The adaptor then packages the data in dictionaries-one per database record. Each dictionary contains key-value pairs; the keys typically represents the name of a column, and the key's value corresponds to the data for the column in that particular row. Going the other way, the adaptor unpacks dictionaries into raw data that the server can accept whenever it needs to insert or update database rows.<p></a><a name="10272"><h3> The Database Level</h3></a><a name="17191">The database level creates enterprise objects from the dictionaries retrieved by the adaptor level. It's also where <em>snapshotting</em> is performed. Snapshotting is used by Enterprise Objects Framework to manage updates. For caching, For updating, when an object is fetched from the database, a snapshot is taken of its state. A snapshot-an NSDictionary object-is consulted when you perform an update to verify that the data in the row to be updated has not changed since you fetched the object. <p></a><a name="10279"><a href="EOFClasses1.html#10286">Figure &#32;14</a> shows the database level classes and the behaviors associated with each class. <p></a><a name="10285"><p><img src="EOFClasses3.gif"><p></a><a name="10286"><p>Figure 14.	  Database Level<p></a><a name="10288"><h3> Modeling Classes</h3></a><a name="10289">The correspondence between an enterprise object class and stored data &#32;is &#32;established and maintained in a <em>model</em>. A model defines, in <br>entity-relationship terms, the mapping between enterprise object classes &#32;and a database. <a href="EOFClasses1.html#10300">Figure &#32;15</a> shows the modeling classes.<p></a><a name="14"><p><img src="EOFClasses4.gif"><p></a><a name="10300"><p>Figure 15.	  Modeling Classes<p></a><a name="10301">Most of the modeling classes represent components of the database-to-object mapping. The following table summarize the role of those classes: <Table Border="3"><caption></caption><tr><th><a name="18165">Database Element</a></th><th><a name="18167">Model Object</a></th><th><a name="18169">Object Mapping</a></th></tr><tr><td scope="row"><a name="18171">Data Dictionary</a></td><td><a name="18173">EOModel</a></td><td><a name="18175">-</a></td></tr><tr><td scope="row"><a name="18177">Table</a></td><td><a name="18179">EOEntity</a></td><td><a name="18181">Enterprise object class</a></td></tr><tr><td scope="row"><a name="18183">Row</a></td><td><a name="18185">-</a></td><td><a name="18187">Enterprise object instance</a></td></tr><tr><td scope="row"><a name="18189">Column</a></td><td><a name="18191">EOAttribute</a></td><td><a name="18193">Enterprise object instance variable (class property)</a></td></tr><tr><td scope="row"><a name="18195">Referential Constraint</a></td><td><a name="18197">EORelationship</a></td><td><a name="18199">Reference to another object</a></td></tr></Table><Table><tr><td></Table><p></a><a name="10341">In addition to storing a mapping between the database schema and enterprise objects, an EOModel object stores information needed to connect to the database server. This connection information includes the name of the adaptor corresponding to your application's database server. An EOModel can also store information about a database's stored procedures (in EOStoredProcedure objects).<p></a><a name="10342">While a model can be generated programmatically at run time, the most common approach is to use the EOModeler application to create models and store them in files. The Framework knows how to initialize modeling objects from a model file. Simply by adding a model file to a project, you &#32;make the model's database-to-object mapping available to the Framework objects that need to reference it. All of the models available to an application are managed by an EOModelGroup object; see the EOModelGroup class specification in the <em>Enterprise Objects Framework Reference</em> for more information.<p></a><a name="10343">For a discussion of entity-relationship modeling and how it relates to Enterprise Objects Framework, see the Appendix <a href="ApA_ERMd.html#5070"> "Entity-Relationship Modeling" on page &#32;259</a>.<p></a><a name="11"><h2> The Control Layer</h2></a><a name="10345">In a command-line program, the control layer's responsibility is to manage a graph of enterprise objects, tracking changes to them and directing the access layer to commit those changes to the database when the program is ready to save. The control layer classes that perform these duties are EOObjectStoreCoordinator and EOEditingContext. An &#32;EOObjectStoreCoordinator object manages interactions with the &#32;access layer, while EOEditingContext objects manage graphs of &#32;enterprise objects and track changes to those objects.<p></a><a name="10346"><h3> Interacting with the Access Layer</h3></a><a name="10347">The control layer provides an infrastructure for managing enterprise objects that is independent of the storage mechanism being used. Put another way, you can use the control layer to interact with any external store: a relational database, a live data feed, or the file system, for example. To achieve this independence, the control layer defines an abstract class, EOObjectStore, whose subclasses represent "intelligent" sources and sinks of objects for EOEditingContexts. An object store is responsible for constructing and registering objects and for committing changes made in an editing context.<p></a><a name="10357">To allow applications to interact with more than one external store, the control layer provides two subclasses of EOObjectStore:<p></a><ul><a name="10358"><p><li><em>EOCooperatingObjectStore</em>, an abstract class that defines the basic API for object stores that work together to manage data from several distinct data repositories.</a><a name="10359"><p><li><em>EOObjectStoreCoordinator</em>, a concrete class whose instances manages the interactions between editing contexts and cooperating object stores.</a></ul><a name="10360">The access layer's EODatabaseContext is a concrete subclass of &#32;EOCooperatingObjectStore. Although different subclasses of EOObjectStore or EOCooperatingObjectStore can be defined for different types of external stores, most applications use an EOObjectStoreCoordinator and one or more EODatabaseContexts to &#32;access relational databases.<p></a><a name="10361"><h3> Object Graph Management and Change Tracking</h3></a><a name="10363">An <em>object graph</em> is a group of related enterprise objects that represents an internally consistent view of an external store-typically a database. In a running application, the object graph is the central repository for data and business logic. An EOEditingContext object, which represents a single "object space" or "document" in an application, manages this in-memory graph of enterprise objects. All objects fetched from an external store are registered in an editing context with a global identifier (an EOGlobalID object) to uniquely identify each object. The editing context is then responsible for watching for changes in its objects and recording snapshots of them for object-based undo. For more information on change tracking, see the EOEditingContext class specification and the EOObserving interface (or protocol) specification in the <em>Enterprise Objects Framework Reference</em>.<p></a><P> <a href="EOFClasses.html"><IMG SRC="ArrowUp.gif">Table of Contents</a> <a href="EOFClasses2.html"><IMG SRC="ArrowRight.gif">Next Section</a><P></body></html>