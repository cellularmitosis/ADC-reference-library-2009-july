<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>ColorTextureSample - /Source/QD3D_Support.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxGraphicsImaging-date.html">Graphics & Imaging</a> &gt; <A HREF="javascript:location.replace('index.html');">ColorTextureSample</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/GraphicsImaging/index.html" target="_blank">Reference Library > Graphics & Imaging</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">ColorTextureSample</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/Source/QD3D_Support.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/Source/3DMF.c</option>
<option value="listing2.html">/Source/Events.c</option>
<option value="listing3.html">/Source/Headers/3dmf.h</option>
<option value="listing4.html">/Source/Headers/main.h</option>
<option value="listing5.html">/Source/Headers/misc.h</option>
<option value="listing6.html">/Source/Headers/myevents.h</option>
<option value="listing7.html">/Source/Headers/MyGlobals.h</option>
<option value="listing8.html">/Source/Headers/mymenus.h</option>
<option value="listing9.html">/Source/Headers/mywindows.h</option>
<option value="listing10.html">/Source/Headers/objects.h</option>
<option value="listing11.html">/Source/Headers/process.h</option>
<option value="listing12.html">/Source/Headers/QD3D_Support.h</option>
<option value="listing13.html">/Source/Headers/Structs.h</option>
<option value="listing14.html">/Source/Main.c</option>
<option value="listing15.html">/Source/Menus.c</option>
<option value="listing16.html">/Source/Misc.c</option>
<option value="listing17.html">/Source/Objects.c</option>
<option value="listing18.html">/Source/Process.c</option>
<option value="listing19.html">/Source/QD3D_Support.c</option>
<option value="listing20.html">/Source/Windows.c</option></select>
				</p>
				</form>
				<p><strong><a href="ColorTextureSample.zip">Download Sample</a></strong> (&#147;ColorTextureSample.zip&#148;, 64.9K)<BR>
<strong><a href="ColorTextureSample.dmg">Download Sample</a></strong> (&#147;ColorTextureSample.dmg&#148;, 128.6K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/****************************//*     QD3D SUPPORT.C      *//* (c)1996 Pangea Software  *//* By Brian Greenstone      *//****************************//****************************//*    EXTERNALS             *//****************************/#include &lt;QD3D.h&gt;#include &lt;QD3DGroup.h&gt;#include &lt;QD3DLight.h&gt;#include &lt;QD3DPick.h&gt;#include &lt;QD3DTransform.h&gt;#include &lt;QD3DStorage.h&gt;#include &lt;QD3DMath.h&gt;#include &lt;QD3DErrors.h&gt;#include &lt;Rave.h&gt;#include &lt;timer.h&gt;#include &quot;myglobals.h&quot;#include &quot;misc.h&quot;#include &quot;qd3d_support.h&quot;#include &quot;mywindows.h&quot;extern  EventRecord      gTheEvent;extern  short        gHtab;extern  long  gTotalNumVertecies,gTotalNumFaces,gTotalMeshes;extern  WindowPtr      gModelWindow;/****************************//*    PROTOTYPES            *//****************************/static void CreateDrawContext(QD3DViewDefType *viewDefPtr);static void SetStyles(QD3DStyleDefType *styleDefPtr);static void CreateCamera(QD3DCameraDefType *cameraDefPtr);static void CreateLights(QD3DLightDefType *lightDefPtr);static void CreateView(QD3DSetupInputType *setupDefPtr);static void CreateTexturePixmap(PicHandle pict,unsigned long mapSizeX,               unsigned long mapSizeY, TQ3StoragePixmap *bMap);static void DrawPICTIntoPixmap(PicHandle pict,unsigned long mapSizeX,         unsigned long mapSizeY, TQ3StoragePixmap *bMap);static void GWorldToBMap(GWorldPtr pGWorld, TQ3StoragePixmap *bMap);static void TraverseDisplayGroupInfo(TQ3Object theGroup);static void ShowMeshInfo(TQ3Object theMesh);static void ShowAttributeInfo(TQ3AttributeSet theAttribute);static void ShowTriMeshInfo(TQ3Object theTriMesh);/****************************//*    CONSTANTS             *//****************************//*********************//*    VARIABLES      *//*********************/static TQ3CameraObject      gQD3D_CameraObject;static TQ3GroupObject      gQD3D_LightGroup;static TQ3ViewObject      gQD3D_ViewObject;static TQ3DrawContextObject    gQD3D_DrawContext;static TQ3RendererObject    gQD3D_RendererObject;static TQ3ShaderObject      gQD3D_ShaderObject;static  TQ3StyleObject      gQD3D_BackfacingStyle;static  TQ3StyleObject      gQD3D_FillStyle;static  TQ3StyleObject      gQD3D_InterpolationStyle;float  gFramesPerSecond = DEFAULT_FPS;        // this is used to maintain a constant timing velocity as frame rates differ//=======================================================================================================//=============================== VIEW WINDOW SETUP STUFF ===============================================//=======================================================================================================/************** SETUP QD3D WINDOW *******************/void QD3D_SetupWindow(QD3DSetupInputType *setupDefPtr, QD3DSetupOutputType *outputPtr){  CreateView(setupDefPtr);  Q3InteractiveRenderer_SetDoubleBufferBypass(gQD3D_RendererObject,kQ3True);    // let hardware go fast    CreateCamera(&amp;setupDefPtr-&gt;camera);                    // create new CAMERA object  CreateLights(&amp;setupDefPtr-&gt;lights);  SetStyles(&amp;setupDefPtr-&gt;styles);            /* DISPOSE OF EXTRA REFERENCES */          Q3Object_Dispose(gQD3D_RendererObject);        // (is contained w/in gQD3D_ViewObject)          /* PASS BACK INFO */          outputPtr-&gt;viewObject = gQD3D_ViewObject;  outputPtr-&gt;interpolationStyle = gQD3D_InterpolationStyle;  outputPtr-&gt;fillStyle = gQD3D_FillStyle;  outputPtr-&gt;backfacingStyle = gQD3D_BackfacingStyle;  outputPtr-&gt;shaderObject = gQD3D_ShaderObject;  outputPtr-&gt;cameraObject = gQD3D_CameraObject;  outputPtr-&gt;lightGroup = gQD3D_LightGroup;  outputPtr-&gt;drawContext = gQD3D_DrawContext;  outputPtr-&gt;window = setupDefPtr-&gt;view.displayWindow;    // remember which window  outputPtr-&gt;paneClip = setupDefPtr-&gt;view.paneClip;}/***************** QD3D_DisposeWindowSetup ***********************///// Disposes of all data created by QD3D_SetupWindow//void QD3D_DisposeWindowSetup(QD3DSetupOutputType *data){  Q3Object_Dispose(data-&gt;viewObject);  Q3Object_Dispose(data-&gt;interpolationStyle);  Q3Object_Dispose(data-&gt;backfacingStyle);  Q3Object_Dispose(data-&gt;fillStyle);  Q3Object_Dispose(data-&gt;cameraObject);  Q3Object_Dispose(data-&gt;lightGroup);  Q3Object_Dispose(data-&gt;drawContext);  Q3Object_Dispose(data-&gt;shaderObject);}/******************* CREATE GAME VIEW *************************/static void CreateView(QD3DSetupInputType *setupDefPtr){TQ3Status  myErr;unsigned long  hints;        /* CREATE NEW VIEW OBJECT */          gQD3D_ViewObject = Q3View_New();  if (gQD3D_ViewObject == nil)    DoFatalAlert(&quot;\pQ3View_New failed!&quot;);      /* CREATE &amp; SET DRAW CONTEXT */    CreateDrawContext(&amp;setupDefPtr-&gt;view);                 // init draw context    myErr = Q3View_SetDrawContext(gQD3D_ViewObject, gQD3D_DrawContext);      // assign context to view  if (myErr == kQ3Failure)    DoFatalAlert(&quot;\pQ3View_SetDrawContext Failed!&quot;);      /* CREATE &amp; SET RENDERER */  gQD3D_RendererObject = Q3Renderer_NewFromType(setupDefPtr-&gt;view.rendererType);  // create new RENDERER object  if (gQD3D_RendererObject == nil)  {    QD3D_ShowError(&quot;\pQ3Renderer_NewFromType Failed!&quot;, true);    CleanQuit();  }  myErr = Q3View_SetRenderer(gQD3D_ViewObject, gQD3D_RendererObject);        // assign renderer to view  if (myErr == kQ3Failure)    DoFatalAlert(&quot;\pQ3View_SetRenderer Failed!&quot;);    /* SET RENDERER FEATURES */      Q3InteractiveRenderer_GetRAVEContextHints(gQD3D_RendererObject, &amp;hints);  hints &amp;= ~kQAContext_NoZBuffer;         // Z buffer is on   hints &amp;= ~kQAContext_DeepZ;           // Z buffer is not deep, ergo it's shallow   hints |= kQAContext_NoDither;           // No Dither   Q3InteractiveRenderer_SetRAVEContextHints(gQD3D_RendererObject, hints);      Q3InteractiveRenderer_SetRAVETextureFilter(gQD3D_RendererObject,kQATextureFilter_Mid);  // fast texturing  Q3InteractiveRenderer_SetDoubleBufferBypass(gQD3D_RendererObject,kQ3True);}/**************** CREATE SKELETON DRAW CONTEXT *********************/static void CreateDrawContext(QD3DViewDefType *viewDefPtr){TQ3DrawContextData    drawContexData;TQ3MacDrawContextData  myMacDrawContextData;Rect          r;  r = viewDefPtr-&gt;displayWindow-&gt;portRect;      /* FILL IN DRAW CONTEXT DATA */  drawContexData.clearImageMethod = kQ3ClearMethodWithColor;        // how to clear  drawContexData.clearImageColor = viewDefPtr-&gt;clearColor;        // color to clear to  drawContexData.pane.min.x = r.left+viewDefPtr-&gt;paneClip.left;      // set bounds?  drawContexData.pane.max.x = r.right-viewDefPtr-&gt;paneClip.right;  drawContexData.pane.min.y = r.top+viewDefPtr-&gt;paneClip.top;  drawContexData.pane.max.y = r.bottom-viewDefPtr-&gt;paneClip.bottom;  drawContexData.paneState = kQ3True;                    // use bounds?  drawContexData.maskState = kQ3False;                  // no mask  drawContexData.doubleBufferState = kQ3True;                // double buffering  myMacDrawContextData.drawContextData = drawContexData;          // set MAC specifics  myMacDrawContextData.window = (CWindowPtr)viewDefPtr-&gt;displayWindow;  // assign window to draw to  myMacDrawContextData.library = kQ3Mac2DLibraryNone;            // use standard QD libraries (no GX crap!)  myMacDrawContextData.viewPort = nil;                  // (for GX only)  myMacDrawContextData.grafPort = (CWindowPtr)viewDefPtr-&gt;displayWindow;  // assign grafport      /* CREATE DRAW CONTEXT */  gQD3D_DrawContext = Q3MacDrawContext_New(&amp;myMacDrawContextData);  if (gQD3D_DrawContext == nil)    DoFatalAlert(&quot;\pQ3MacDrawContext_New Failed!&quot;);}/**************** SET STYLES ****************///// Creates style objects which define how the scene is to be rendered.// It also sets the shader object.//static void SetStyles(QD3DStyleDefType *styleDefPtr){        /* SET INTERPOLATION (FOR SHADING) */            gQD3D_InterpolationStyle = Q3InterpolationStyle_New(styleDefPtr-&gt;interpolation);  if (gQD3D_InterpolationStyle == nil)    DoFatalAlert(&quot;\pQ3InterpolationStyle_New Failed!&quot;);          /* SET BACKFACING */  gQD3D_BackfacingStyle = Q3BackfacingStyle_New(styleDefPtr-&gt;backfacing);  if (gQD3D_BackfacingStyle == nil )    DoFatalAlert(&quot;\pQ3BackfacingStyle_New Failed!&quot;);        /* SET POLYGON FILL STYLE */              gQD3D_FillStyle = Q3FillStyle_New(styleDefPtr-&gt;fill);  if ( gQD3D_FillStyle == nil )    DoFatalAlert(&quot;\p Q3FillStyle_New Failed!&quot;);          /* SET THE SHADER TO USE */  switch(styleDefPtr-&gt;illuminationType)  {    case  kQ3IlluminationTypePhong:        gQD3D_ShaderObject = Q3PhongIllumination_New();        if ( gQD3D_ShaderObject == nil )          DoFatalAlert(&quot;\p Q3PhongIllumination_New Failed!&quot;);        break;            case  kQ3IlluminationTypeLambert:        gQD3D_ShaderObject = Q3LambertIllumination_New();        if ( gQD3D_ShaderObject == nil )          DoFatalAlert(&quot;\p Q3LambertIllumination_New Failed!&quot;);        break;            case  kQ3IlluminationTypeNULL:        gQD3D_ShaderObject = Q3NULLIllumination_New();        if ( gQD3D_ShaderObject == nil )          DoFatalAlert(&quot;\p Q3NullIllumination_New Failed!&quot;);        break;  }  }/****************** CREATE CAMERA *********************/static void CreateCamera(QD3DCameraDefType *cameraDefPtr){TQ3CameraData          myCameraData;TQ3ViewAngleAspectCameraData  myViewAngleCameraData;TQ3Area              pane;TQ3Status            status;TQ3Status  myErr;  status = Q3DrawContext_GetPane(gQD3D_DrawContext,&amp;pane);        // get window pane info  if (status == kQ3Failure)    DoFatalAlert(&quot;\pQ3DrawContext_GetPane Failed!&quot;);        /* FILL IN CAMERA DATA */          myCameraData.placement.cameraLocation = cameraDefPtr-&gt;from;      // set camera coords  myCameraData.placement.pointOfInterest = cameraDefPtr-&gt;to;      // set target coords  myCameraData.placement.upVector = cameraDefPtr-&gt;up;          // set a vector that's &quot;up&quot;  myCameraData.range.hither = cameraDefPtr-&gt;hither;          // set frontmost Z dist  myCameraData.range.yon = cameraDefPtr-&gt;yon;              // set farthest Z dist  myCameraData.viewPort.origin.x = -1.0;                // set view origins?  myCameraData.viewPort.origin.y = 1.0;  myCameraData.viewPort.width = 2.0;  myCameraData.viewPort.height = 2.0;  myViewAngleCameraData.cameraData = myCameraData;  myViewAngleCameraData.fov = cameraDefPtr-&gt;fov;            // larger = more fisheyed  myViewAngleCameraData.aspectRatioXToY =        (pane.max.x-pane.min.x)/(pane.max.y-pane.min.y);  gQD3D_CameraObject = Q3ViewAngleAspectCamera_New(&amp;myViewAngleCameraData);   // create new camera  if (gQD3D_CameraObject == nil)    DoFatalAlert(&quot;\pQ3ViewAngleAspectCamera_New failed!&quot;);      myErr = Q3View_SetCamera(gQD3D_ViewObject, gQD3D_CameraObject);    // assign camera to view  if (myErr == kQ3Failure)    DoFatalAlert(&quot;\pQ3View_SetCamera Failed!&quot;);}/********************* CREATE LIGHTS ************************/static void CreateLights(QD3DLightDefType *lightDefPtr){TQ3GroupPosition    myGroupPosition;TQ3LightData      myLightData;TQ3DirectionalLightData  myDirectionalLightData;TQ3LightObject      myLight;short          i;TQ3Status  myErr;      /* CREATE NEW LIGHT GROUP */        gQD3D_LightGroup = Q3LightGroup_New();            // make new light group  if ( gQD3D_LightGroup == nil )    DoFatalAlert(&quot;\p Q3LightGroup_New Failed!&quot;);  myLightData.isOn = kQ3True;                  // light is ON        /************************/      /* CREATE AMBIENT LIGHT */      /************************/  if (lightDefPtr-&gt;ambientBrightness != 0)            // see if ambient exists  {    myLightData.color = lightDefPtr-&gt;ambientColor;        // set color of light    myLightData.brightness = lightDefPtr-&gt;ambientBrightness;  // set brightness value    myLight = Q3AmbientLight_New(&amp;myLightData);          // make it    if ( myLight == nil )      DoFatalAlert(&quot;\pQ3AmbientLight_New Failed!&quot;);    myGroupPosition = Q3Group_AddObject(gQD3D_LightGroup, myLight);  // add to group    if ( myGroupPosition == 0 )      DoFatalAlert(&quot;\p Q3Group_AddObject Failed!&quot;);    Q3Object_Dispose(myLight);                  // dispose of light  }      /**********************/      /* CREATE FILL LIGHTS */      /**********************/        for (i=0; i &lt; lightDefPtr-&gt;numFillLights; i++)  {        myLightData.color = lightDefPtr-&gt;fillColor[i];            // set color of light    myLightData.brightness = lightDefPtr-&gt;fillBrightness[i];      // set brightness    myDirectionalLightData.lightData = myLightData;            // refer to general light info    myDirectionalLightData.castsShadows = kQ3False;            // no shadows    myDirectionalLightData.direction =  lightDefPtr-&gt;fillDirection[i];  // set fill vector    myLight = Q3DirectionalLight_New(&amp;myDirectionalLightData);      // make it    if ( myLight == nil )      DoFatalAlert(&quot;\p Q3DirectionalLight_New Failed!&quot;);    myGroupPosition = Q3Group_AddObject(gQD3D_LightGroup, myLight);    // add to group    if ( myGroupPosition == 0 )      DoFatalAlert(&quot;\p Q3Group_AddObject Failed!&quot;);    Q3Object_Dispose(myLight);                      // dispose of light  }        /* ASSIGN LIGHT GROUP TO VIEW */        myErr = Q3View_SetLightGroup(gQD3D_ViewObject, gQD3D_LightGroup);    // assign light group to view  if (myErr == kQ3Failure)    DoFatalAlert(&quot;\pQ3View_SetLightGroup Failed!&quot;);    }/******************** QD3D CHANGE DRAW SIZE *********************///// Changes size of stuff to fit new window size.//void QD3D_ChangeDrawSize(QD3DSetupOutputType *setupInfo){Rect      r;TQ3Area      pane;TQ3ViewAngleAspectCameraData  cameraData;      /* CHANGE DRAW CONTEXT PANE SIZE */        r = setupInfo-&gt;window-&gt;portRect;              // get size of window  pane.min.x = r.left+setupInfo-&gt;paneClip.left;                    // set pane size  pane.max.x = r.right-setupInfo-&gt;paneClip.right;  pane.min.y = r.top+setupInfo-&gt;paneClip.top;  pane.max.y = r.bottom-setupInfo-&gt;paneClip.bottom;  Q3DrawContext_SetPane(setupInfo-&gt;drawContext,&amp;pane);    // update pane in draw context        /* CHANGE CAMERA ASPECT RATIO */          Q3ViewAngleAspectCamera_GetData(setupInfo-&gt;cameraObject,&amp;cameraData);      // get camera data  cameraData.aspectRatioXToY = (pane.max.x-pane.min.x)/(pane.max.y-pane.min.y);  // set new aspect ratio  Q3ViewAngleAspectCamera_SetData(setupInfo-&gt;cameraObject,&amp;cameraData);      // set new camera data}/******************* QD3D DRAW SCENE *********************/void QD3D_DrawScene(QD3DSetupOutputType *setupInfo, void (*drawRoutine)(QD3DSetupOutputType *)){TQ3Status        myStatus;TQ3ViewStatus      myViewStatus;      /* START RENDERING *///startTrace(&quot;test.tt6&quot;);  myStatus = Q3View_StartRendering(setupInfo-&gt;viewObject);        if ( myStatus == kQ3Failure )  {    DoFatalAlert(&quot;\p Q3View_StartRendering Failed!&quot;);  }        /***************/      /* RENDER LOOP */      /***************/  do  {        /* DRAW STYLES */            myStatus = Q3Style_Submit(setupInfo-&gt;interpolationStyle,setupInfo-&gt;viewObject);    if ( myStatus == kQ3Failure )      DoFatalAlert(&quot;\p Q3Style_Submit Failed!&quot;);          myStatus = Q3Style_Submit(setupInfo-&gt;backfacingStyle,setupInfo-&gt;viewObject);    if ( myStatus == kQ3Failure )      DoFatalAlert(&quot;\p Q3Style_Submit Failed!&quot;);          myStatus = Q3Style_Submit(setupInfo-&gt;fillStyle, setupInfo-&gt;viewObject);    if ( myStatus == kQ3Failure )      DoFatalAlert(&quot;\p Q3Style_Submit Failed!&quot;);    myStatus = Q3Shader_Submit(setupInfo-&gt;shaderObject, setupInfo-&gt;viewObject);    if ( myStatus == kQ3Failure )      DoFatalAlert(&quot;\p Q3Shader_Submit Failed!&quot;);      /* CALL INPUT DRAW FUNCTION */    drawRoutine(setupInfo);    myViewStatus = Q3View_EndRendering(setupInfo-&gt;viewObject);      } while ( myViewStatus == kQ3ViewStatusRetraverse );  //stopTrace();//CleanQuit();}//=======================================================================================================//=============================== MISC ==================================================================//=======================================================================================================/************** QD3D CALC FRAMES PER SECOND *****************/float  QD3D_CalcFramesPerSecond(void){UnsignedWide  wide;unsigned long  now;static  unsigned long then = 0;Str255      s;  Microseconds(&amp;wide);  now = wide.lo;  if (then != 0)  {    gFramesPerSecond = (float)1000000.0/(float)(now-then);    if (gFramesPerSecond &lt; DEFAULT_FPS)      // (avoid divide by 0's later)      gFramesPerSecond = DEFAULT_FPS;      if (gTheEvent.modifiers &amp; shiftKey)    {      SetPort(gModelWindow);      NumToString((long)(gFramesPerSecond+0.5),s);  // print # rounded up to nearest integer      MoveTo(29,12);      DrawString(s);      DrawString(&quot;\p  &quot;);    }  }  else    gFramesPerSecond = DEFAULT_FPS;      then = now;                // remember time      return(gFramesPerSecond);}//=======================================================================================================//=============================== CAMERA STUFF ==========================================================//=======================================================================================================/*************** QD3D_UpdateCameraFromTo ***************/void QD3D_UpdateCameraFromTo(QD3DSetupOutputType *setupInfo, TQ3Point3D *from, TQ3Point3D *to){TQ3Status  status;TQ3CameraPlacement  placement;      /* GET CURRENT CAMERA INFO */        status = Q3Camera_GetPlacement(setupInfo-&gt;cameraObject, &amp;placement);  if (status == kQ3Failure)    DoFatalAlert(&quot;\pQ3Camera_GetPlacement failed!&quot;);      /* SET CAMERA LOOK AT */        placement.pointOfInterest = *to;      /* SET CAMERA COORDS */        placement.cameraLocation = *from;        /* UPDATE CAMERA INFO */        status = Q3Camera_SetPlacement(setupInfo-&gt;cameraObject, &amp;placement);  if (status == kQ3Failure)    DoFatalAlert(&quot;\pQ3Camera_SetPlacement failed!&quot;);}/*************** QD3D_UpdateCameraFrom ***************/void QD3D_UpdateCameraFrom(QD3DSetupOutputType *setupInfo, TQ3Point3D *from){TQ3Status  status;TQ3CameraPlacement  placement;      /* GET CURRENT CAMERA INFO */        status = Q3Camera_GetPlacement(setupInfo-&gt;cameraObject, &amp;placement);  if (status == kQ3Failure)    DoFatalAlert(&quot;\pQ3Camera_GetPlacement failed!&quot;);      /* SET CAMERA COORDS */        placement.cameraLocation = *from;        /* UPDATE CAMERA INFO */        status = Q3Camera_SetPlacement(setupInfo-&gt;cameraObject, &amp;placement);  if (status == kQ3Failure)    DoFatalAlert(&quot;\pQ3Camera_SetPlacement failed!&quot;);}/*************** QD3D_MoveCameraFrom ***************/void QD3D_MoveCameraFrom(QD3DSetupOutputType *setupInfo, TQ3Vector3D *moveVector){TQ3Status  status;TQ3CameraPlacement  placement;      /* GET CURRENT CAMERA INFO */        status = Q3Camera_GetPlacement(setupInfo-&gt;cameraObject, &amp;placement);  if (status == kQ3Failure)    DoFatalAlert(&quot;\pQ3Camera_GetPlacement failed!&quot;);      /* SET CAMERA COORDS */        placement.cameraLocation.x += moveVector-&gt;x;  placement.cameraLocation.y += moveVector-&gt;y;  placement.cameraLocation.z += moveVector-&gt;z;        /* UPDATE CAMERA INFO */        status = Q3Camera_SetPlacement(setupInfo-&gt;cameraObject, &amp;placement);  if (status == kQ3Failure)    DoFatalAlert(&quot;\pQ3Camera_SetPlacement failed!&quot;);}//=======================================================================================================//=============================== MATHMATICAL STUFF =====================================================//=======================================================================================================/***************** QD3D:  CALC FACE NORMAL *********************///// Returns the normal vector off the face defined by 3 points.//void QD3D_CalcFaceNormal(TQ3Point3D *p1, TQ3Point3D *p2, TQ3Point3D *p3, TQ3Vector3D *normal){TQ3Vector3D  v1,v2;  v1.x = (p1-&gt;x - p3-&gt;x);  v1.y = (p1-&gt;y - p3-&gt;y);  v1.z = (p1-&gt;z - p3-&gt;z);  v2.x = (p2-&gt;x - p3-&gt;x);  v2.y = (p2-&gt;y - p3-&gt;y);  v2.z = (p2-&gt;z - p3-&gt;z);  Q3Vector3D_Cross(&amp;v1, &amp;v2, normal);        // cross product == vector perpendicular to 2 other vectors  Q3Vector3D_Normalize(normal,normal);}/**************** ANGLE BETWEEN VECTORS ******************///// OUTPUT: the angle in radians between 2 3D vectors//float  QD3D_AngleBetweenVectors3D(TQ3Vector3D *v1, TQ3Vector3D *v2){float  dot,angle;  Q3Vector3D_Normalize(v1,v1);  // make sure they're normalized  Q3Vector3D_Normalize(v2,v2);  dot = Q3Vector3D_Dot(v1,v2);  // the dot product is the cosine of the angle between the 2 vectors  angle = acos(dot);        // get arc-cosine to get the angle out of it  return(angle);}/**************** X ANGLE BETWEEN VECTORS 3D ******************///// OUTPUT: the x-axis angle in radians between 2 3D vectors//float  QD3D_XAngleBetweenVectors3D(TQ3Vector3D *v1, TQ3Vector3D *v2){float  dot,angle;  v1-&gt;x = v2-&gt;x;  Q3Vector3D_Normalize(v1,v1);  // make sure they're normalized  Q3Vector3D_Normalize(v2,v2);  dot = Q3Vector3D_Dot(v1,v2);  // the dot product is the cosine of the angle between the 2 vectors  angle = acos(dot);        // get arc-cosine to get the angle out of it  return(-angle);}//=======================================================================================================//=============================== LIGHTS STUFF ==========================================================//=======================================================================================================/********************* QD3D ADD POINT LIGHT ************************/TQ3GroupPosition QD3D_AddPointLight(QD3DSetupOutputType *setupInfo,TQ3Point3D *point, TQ3ColorRGB *color, float brightness){TQ3GroupPosition    myGroupPosition;TQ3LightData      myLightData;TQ3PointLightData    myPointLightData;TQ3LightObject      myLight;  myLightData.isOn = kQ3True;                      // light is ON    myLightData.color = *color;                      // set color of light  myLightData.brightness = brightness;                // set brightness  myPointLightData.lightData = myLightData;              // refer to general light info  myPointLightData.castsShadows = kQ3False;              // no shadows  myPointLightData.location = *point;                  // set coords    myPointLightData.attenuation =  kQ3AttenuationTypeInverseDistance;  // set attenuation  myLight = Q3PointLight_New(&amp;myPointLightData);        // make it  if ( myLight == nil )    DoFatalAlert(&quot;\p Q3DirectionalLight_New Failed!&quot;);  myGroupPosition = Q3Group_AddObject(setupInfo-&gt;lightGroup, myLight);    // add to light group  if ( myGroupPosition == 0 )    DoFatalAlert(&quot;\p Q3Group_AddObject Failed!&quot;);  Q3Object_Dispose(myLight);                      // dispose of light  return(myGroupPosition);}/****************** QD3D SET POINT LIGHT COORDS ********************/void QD3D_SetPointLightCoords(QD3DSetupOutputType *setupInfo, TQ3GroupPosition lightPosition, TQ3Point3D *point){TQ3PointLightData  pointLightData;TQ3LightObject    light;TQ3Status      status;  status = Q3Group_GetPositionObject(setupInfo-&gt;lightGroup, lightPosition, &amp;light);  // get point light object from light group  if (status == kQ3Failure)    DoFatalAlert(&quot;\pQ3Group_GetPositionObject Failed!&quot;);  status =  Q3PointLight_GetData(light, &amp;pointLightData);        // get light data  if (status == kQ3Failure)    DoFatalAlert(&quot;\pQ3PointLight_GetData Failed!&quot;);  pointLightData.location = *point;                  // set coords  status = Q3PointLight_SetData(light, &amp;pointLightData);        // update light data  if (status == kQ3Failure)    DoFatalAlert(&quot;\pQ3PointLight_SetData Failed!&quot;);}/****************** QD3D DELETE LIGHT ********************/void QD3D_DeleteLight(QD3DSetupOutputType *setupInfo, TQ3GroupPosition lightPosition){TQ3LightObject    light;  light = Q3Group_RemovePosition(setupInfo-&gt;lightGroup, lightPosition);  if (light == nil)    DoFatalAlert(&quot;\pQ3Group_RemovePosition Failed!&quot;);  Q3Object_Dispose(light);}//=======================================================================================================//=============================== TEXTURE MAP STUFF =====================================================//=======================================================================================================/************ QD3D CHANGE TEXTUREMAP ************///// INPUT:  textureShader = texture shader object to change//void QD3D_ChangeTextureMap(TQ3ShaderObject textureShader,long rezID){TQ3TextureObject  texture;TQ3StoragePixmap  pixmap;PicHandle      pict;      /* GET PIXMAP FROM SHADER */            Q3TextureShader_GetTexture(textureShader,&amp;texture);    // get texture object  Q3PixmapTexture_GetPixmap(texture, &amp;pixmap);      // get pixmap      /* LOAD NEW PICT */  pict = GetPicture(rezID);                // get picture from resource  if (pict == nil)    DoFatalAlert(&quot;\pUnable to load texture PICT resource&quot;);    /* DRAW PICT INTO PIXMAP */    DrawPICTIntoPixmap(pict, pixmap.width, pixmap.height, &amp;pixmap);  ReleaseResource((Handle)pict);    Q3Object_Dispose(texture);  Q3Object_Dispose(pixmap.image);  }/**************** QD3D GET TEXTURE MAP ***********************///// Loads a PICT resource and returns a shader object which is// based on the PICT converted to a texture map.//// INPUT: textureRezID = resource ID of texture PICT to get.//      myFSSpec != nil if want to load PICT from file instead//// OUTPUT: TQ3ShaderObject = shader object for texture map.//TQ3SurfaceShaderObject  QD3D_GetTextureMap(long  textureRezID, FSSpec *myFSSpec){PicHandle      picture;TQ3SurfaceShaderObject    shader;long        pictSize,headerSize;OSErr        iErr;short        fRefNum;char        pictHeader[PICT_HEADER_SIZE];  if (myFSSpec == nil)  {          /* LOAD PICT REZ */        picture = GetPicture (textureRezID);    if (picture == nil)      DoFatalAlert(&quot;\pUnable to load texture PICT resource&quot;);  }  else  {        /* LOAD PICT FROM FILE */      iErr = FSpOpenDF(myFSSpec,fsCurPerm,&amp;fRefNum);    if (iErr)      DoFatalAlert(&quot;\pError reading PICT file!&quot;);    if  (GetEOF(fRefNum,&amp;pictSize) != noErr)    // get size of file          DoFatalAlert(&quot;\pError reading PICT file!&quot;);            headerSize = PICT_HEADER_SIZE;          // check the header              if (FSRead(fRefNum,&amp;headerSize,pictHeader) != noErr)      DoFatalAlert(&quot;\pError reading PICT file!&quot;);    if ((pictSize -= PICT_HEADER_SIZE) &lt;= 0)      DoFatalAlert(&quot;\pError reading PICT file!&quot;);          if ((picture = (PicHandle)NewHandle(pictSize)) == NIL_POINTER)      DoFatalAlert(&quot;\pNot enough memory to read PICT file!&quot;);    HLock((Handle)picture);          if (FSRead(fRefNum,&amp;pictSize,*picture) != noErr)      DoFatalAlert(&quot;\pError reading PICT file!&quot;);          FSClose(fRefNum);      }      shader = QD3D_PICTToTexture(picture);      if (myFSSpec == nil)    ReleaseResource ((Handle) picture);  else    DisposeHandle((Handle)picture);  return(shader);  }/**************** QD3D PICT TO TEXTURE ***********************/////// INPUT: picture = handle to PICT.//// OUTPUT: TQ3ShaderObject = shader object for texture map.//TQ3SurfaceShaderObject  QD3D_PICTToTexture(PicHandle picture){TQ3StoragePixmap   pixmap;TQ3TextureObject  texture;TQ3SurfaceShaderObject    shader;      /* MAKE INTO STORAGE PIXMAP */    pixmap.image = nil;  CreateTexturePixmap (picture,        (**picture).picFrame.right  - (**picture).picFrame.left,        (**picture).picFrame.bottom - (**picture).picFrame.top,        &amp;pixmap);        /* MAKE NEW PIXMAP TEXTURE */        texture = Q3PixmapTexture_New (&amp;pixmap);  if (texture == nil)    DoFatalAlert(&quot;\pError calling Q3PixmapTexture_New!&quot;);      shader = Q3TextureShader_New (texture);  if (shader == nil)    DoFatalAlert(&quot;\pError calling Q3TextureShader_New!&quot;);  Q3Object_Dispose (texture);  Q3Object_Dispose (pixmap.image);      // disposes of extra reference to storage obj from CreateTexturePixmap  return(shader);  }/**************** QD3D GWORLD TO TEXTURE ***********************///// INPUT: picture = handle to PICT.//// OUTPUT: TQ3ShaderObject = shader object for texture map.//TQ3SurfaceShaderObject  QD3D_GWorldToTexture(GWorldPtr theGWorld){TQ3StoragePixmap       pixmap;TQ3TextureObject      texture;TQ3SurfaceShaderObject    shader;  GWorldToBMap(theGWorld,&amp;pixmap);      /* MAKE NEW PIXMAP TEXTURE */        texture = Q3PixmapTexture_New (&amp;pixmap);  if (texture == nil)    DoFatalAlert(&quot;\pError calling Q3PixmapTexture_New!&quot;);  shader = Q3TextureShader_New(texture);  if (shader == nil)    DoFatalAlert(&quot;\pError calling Q3TextureShader_New!&quot;);  Q3Object_Dispose (texture);  Q3Object_Dispose (pixmap.image);      // possible memory leak if dont call this?!?!  return(shader);  }/******************** CREATE TEXTURE PIXMAP ********************/static void CreateTexturePixmap(PicHandle pict,unsigned long mapSizeX,               unsigned long mapSizeY, TQ3StoragePixmap *bMap){  bMap-&gt;image = NULL;    if (mapSizeY &gt; 512)    mapSizeY = 512;  if (mapSizeX &gt; 512)    mapSizeX = 512;    DrawPICTIntoPixmap (pict, mapSizeX, mapSizeY, bMap);}/******************** DRAW PICT INTO PIXMAP ********************///// OUTPUT: bMap = new bitmap holding texture image//static void DrawPICTIntoPixmap(PicHandle pict,unsigned long width, unsigned long height, TQ3StoragePixmap *bMap){  #define  k80K    (80000)Rect           rectGW;GWorldPtr         pGWorld;PixMapHandle       hPixMap;OSErr          myErr;GDHandle        oldGD;GWorldPtr        oldGW;long          bytesNeeded;  GetGWorld(&amp;oldGW, &amp;oldGD);                    // save current port        /* CREATE A GWORLD TO DRAW INTO */  SetRect(&amp;rectGW, 0, 0, width, height);            // set dimensions  bytesNeeded = (width * height * 4) + k80K;  if (bytesNeeded &lt; MaxBlock())    myErr = NewGWorld(&amp;pGWorld, 32, &amp;rectGW, 0, 0, 0L);      // make gworld  else    myErr = -43;  if (myErr)    DoFatalAlert(&quot;\pError making texture GWorld!&quot;);    hPixMap = GetGWorldPixMap(pGWorld);              // calc addr &amp; rowbytes      /* DRAW PICTURE INTO GWORLD */        SetGWorld(pGWorld, nil);    LockPixels(hPixMap);  EraseRect(&amp;rectGW);  DrawPicture(pict, &amp;rectGW);      /* MAKE A PIXMAP FROM GWORLD */        GWorldToBMap(pGWorld,bMap);    SetGWorld (oldGW, oldGD);  UnlockPixels (hPixMap);  DisposeGWorld (pGWorld);}/******************** GWORLD TO BMAP ********************///// Creates a TQ3StoragePixmap from an existing GWorld//// NOTE: Assumes that GWorld is 32bit!!!!//// OUTPUT: bMap = new bitmap holding texture image//static void GWorldToBMap(GWorldPtr pGWorld, TQ3StoragePixmap *bMap){unsigned long       pictMapAddr;PixMapHandle       hPixMap;unsigned long       pictRowBytes;long          width, height;TQ3Status        status;    hPixMap = GetGWorldPixMap(pGWorld);                // calc addr &amp; rowbytes    if ((**hPixMap).pixelSize != 32)                  // verify bitdepth    DoFatalAlert(&quot;\pGworlds must be 32bit when converting to textures!&quot;);    pictMapAddr = (unsigned long )GetPixBaseAddr(hPixMap);  pictRowBytes = (unsigned long)(**hPixMap).rowBytes &amp; 0x3fff;  width = ((**hPixMap).bounds.right - (**hPixMap).bounds.left);  height = ((**hPixMap).bounds.bottom - (**hPixMap).bounds.top);        /* SET MORE PIXELMAP INFO */  if (bMap-&gt;image != NULL)  {    DoAlert(&quot;\pReplacing PixelMap : (remove this Alert if I want this&quot;);    status = Q3MemoryStorage_Set (bMap-&gt;image, (unsigned char *) pictMapAddr,               pictRowBytes * height);    if (status == kQ3Failure)      DoFatalAlert(&quot;\pQ3MemoryStorage_Set Failed!&quot;);  }  else  {    bMap-&gt;image = Q3MemoryStorage_New ((unsigned char *) pictMapAddr, pictRowBytes * height);    if (bMap-&gt;image == nil)      DoFatalAlert(&quot;\pQ3MemoryStorage_New Failed!&quot;);  }  bMap-&gt;width   = width;  bMap-&gt;height  = height;  bMap-&gt;rowBytes   = pictRowBytes;  bMap-&gt;pixelSize = 32;  bMap-&gt;pixelType  = kQ3PixelTypeRGB32;  bMap-&gt;bitOrder  = kQ3EndianBig;  bMap-&gt;byteOrder  = kQ3EndianBig;  }//=======================================================================================================//=============================== STYLE STUFF =====================================================//=======================================================================================================/****************** QD3D:  SET BACKFACE STYLE ***********************/void SetBackFaceStyle(QD3DSetupOutputType *setupInfo, TQ3BackfacingStyle style){TQ3Status status;TQ3BackfacingStyle  backfacingStyle;  status = Q3BackfacingStyle_Get(setupInfo-&gt;backfacingStyle, &amp;backfacingStyle);  if (status == kQ3Failure)    DoFatalAlert(&quot;\pQ3BackfacingStyle_Get Failed!&quot;);  if (style == backfacingStyle)              // see if already set to that    return;      status = Q3BackfacingStyle_Set(setupInfo-&gt;backfacingStyle, style);  if (status == kQ3Failure)    DoFatalAlert(&quot;\pQ3BackfacingStyle_Set Failed!&quot;);}/****************** QD3D:  SET FILL STYLE ***********************/void SetFillStyle(QD3DSetupOutputType *setupInfo, TQ3FillStyle style){TQ3Status     status;TQ3FillStyle  fillStyle;  status = Q3FillStyle_Get(setupInfo-&gt;fillStyle, &amp;fillStyle);  if (status == kQ3Failure)    DoFatalAlert(&quot;\pQ3FillStyle_Get Failed!&quot;);  if (style == fillStyle)              // see if already set to that    return;      status = Q3FillStyle_Set(setupInfo-&gt;fillStyle, style);  if (status == kQ3Failure)    DoFatalAlert(&quot;\pQ3FillStyle_Set Failed!&quot;);}//=======================================================================================================//=============================== INFO STUFF =====================================================//=======================================================================================================/********************** DISPLAY OBJECT INFO **************************///// NOTE: assumes that current grafport is already set to window we want to display info into//void QD3D_DisplayObjectInfo(TQ3Object myObject){TQ3ObjectType  oType;TQ3BackfacingStyle  backfacingStyle;  TextSize(9);  ForeColor(blackColor);  oType = Q3Object_GetType(myObject);  switch(oType)  {    case  kQ3ObjectTypeElement:        WriteString(&quot;\pElement: &quot;);        ForeColor(greenColor);        oType = Q3Object_GetLeafType(myObject);            // read kind of element        switch(oType)        {          case  kQ3ElementTypeAttribute:              WriteString(&quot;\p    Attribute&quot;);              DoCR();              break;        }        break;      case  kQ3ObjectTypePick:        WriteString(&quot;\pPick: &quot;);        ForeColor(greenColor);        oType = Q3Object_GetLeafType(myObject);            // read kind of pick        switch(oType)        {          case  kQ3PickTypeWindowPoint:              WriteString(&quot;\p    Window Point&quot;);              DoCR();              break;          case  kQ3PickTypeWindowRect:              WriteString(&quot;\p    Window Rect&quot;);              DoCR();              break;        }        break;      case  kQ3ObjectTypeShared://        WriteString(&quot;\pShared: &quot;);        ForeColor(greenColor);                oType = Q3Shared_GetType(myObject);              // get kind of shared                switch(oType)        {          case  kQ3SharedTypeShape:              WriteString(&quot;\pSHAPE: &quot;);              oType = Q3Shape_GetType(myObject);        // get kind of shape              switch(oType)              {                case  kQ3ShapeTypeGeometry:                    WriteString(&quot;\pGeometry: &quot;);                    oType = Q3Geometry_GetType(myObject);          // get geometry type                    switch(oType)                    {                      case  kQ3GeometryTypeBox:                          WriteString(&quot;\pBox&quot;);                                                break;                      case  kQ3GeometryTypeGeneralPolygon:                          WriteString(&quot;\pGeneral Polygon&quot;);                                                break;                      case  kQ3GeometryTypeLine:                          WriteString(&quot;\pLine&quot;);                                                break;                      case  kQ3GeometryTypeMarker:                          WriteString(&quot;\pMarker&quot;);                                                break;                      case  kQ3GeometryTypeMesh:                          WriteString(&quot;\pMesh&quot;);                          ShowMeshInfo(myObject);                                            break;                      case  kQ3GeometryTypeTriMesh:                          WriteString(&quot;\pTri-Mesh&quot;);                          ShowTriMeshInfo(myObject);                                            break;                      case  kQ3GeometryTypeNURBCurve:                          WriteString(&quot;\pNURB Curve&quot;);                                                break;                      case  kQ3GeometryTypeNURBPatch:                          WriteString(&quot;\pNURB Patch&quot;);                                                break;                      case  kQ3GeometryTypePoint:                          WriteString(&quot;\pPoint&quot;);                                                break;                      case  kQ3GeometryTypePolygon:                          WriteString(&quot;\pPolygon&quot;);                                                break;                      case  kQ3GeometryTypeTriangle:                          WriteString(&quot;\pTriangle&quot;);                                                break;                      case  kQ3GeometryTypeTriGrid:                          WriteString(&quot;\pTri-Grid&quot;);                                                break;                      default:                          WriteString(&quot;\pUnknown Geometry&quot;);                                                                }                    DoCR();                    break;                case  kQ3ShapeTypeShader:                    WriteString(&quot;\pShader: &quot;);                    oType = Q3Shader_GetType(myObject);        // get kind of shader                    switch(oType)                    {                      case  kQ3ShaderTypeSurface:                          WriteString(&quot;\pSurface&quot;);                                                break;                      case  kQ3ShaderTypeIllumination:                          WriteString(&quot;\pIllumination&quot;);                                                break;                    }                    DoCR();                    break;                case  kQ3ShapeTypeStyle:                    WriteString(&quot;\pStyle: &quot;);                    oType = Q3Style_GetType(myObject);        // get kind of style                    switch(oType)                    {                      case  kQ3StyleTypeBackfacing:                          WriteString(&quot;\pBackfacing-&quot;);                            Q3BackfacingStyle_Get(myObject, &amp;backfacingStyle);  // get state of backfacing                          switch(backfacingStyle)                          {                            case  kQ3BackfacingStyleBoth:                                WriteString(&quot;\pboth&quot;);                                break;                            case  kQ3BackfacingStyleFlip:                                WriteString(&quot;\pflip&quot;);                                break;                            case  kQ3BackfacingStyleRemove:                                WriteString(&quot;\premove&quot;);                                break;                                                    }                                            break;                      case  kQ3StyleTypeInterpolation:                          WriteString(&quot;\pInterpolation&quot;);                                                break;                      case  kQ3StyleTypeFill:                          WriteString(&quot;\pFill&quot;);                                                break;                      case  kQ3StyleTypePickID:                          WriteString(&quot;\pPick ID&quot;);                                                break;                      case  kQ3StyleTypeReceiveShadows:                          WriteString(&quot;\pReceive shadow&quot;);                                                break;                      case  kQ3StyleTypeHighlight:                          WriteString(&quot;\pHilight&quot;);                                                break;                      case  kQ3StyleTypeSubdivision:                          WriteString(&quot;\pSubdivision&quot;);                                                break;                      case  kQ3StyleTypeOrientation:                          WriteString(&quot;\pOrientation&quot;);                                                break;                      case  kQ3StyleTypePickParts:                          WriteString(&quot;\pPickParts&quot;);                                                break;                    }                    DoCR();                    break;                case  kQ3ShapeTypeTransform:                    WriteString(&quot;\pTransform&quot;);                    DoCR();                    break;                case  kQ3ShapeTypeLight:                    WriteString(&quot;\pLight&quot;);                    DoCR();                    break;                case  kQ3ShapeTypeCamera:                    WriteString(&quot;\pCamera&quot;);                    DoCR();                    break;                case  kQ3ShapeTypeGroup:                    WriteString(&quot;\pGroup: &quot;);                                          oType = Q3Group_GetType(myObject);        // get kind of group                    switch(oType)                    {                      case  kQ3GroupTypeDisplay:                          WriteString(&quot;\pDisplay&quot;);                          TraverseDisplayGroupInfo(myObject);    // recursive scan of group                                                break;                      case  kQ3GroupTypeLight:                          WriteString(&quot;\pLight&quot;);                                                break;                      case  kQ3GroupTypeInfo:                          WriteString(&quot;\pInfo&quot;);                                                break;                    }                    DoCR();                    break;                case  kQ3ShapeTypeUnknown:                    WriteString(&quot;\pUNKNOWN&quot;);                    DoCR();                    break;                case  kQ3SetTypeAttribute:                    WriteString(&quot;\pAttribute&quot;);                    ShowAttributeInfo(myObject);                    DoCR();                    break;                default:                    WriteString(&quot;\p(unImplemented or ERROR):&quot;);                    WriteChar((oType&amp;0xff000000)&gt;&gt;24);                    WriteChar((oType&amp;0xff0000)&gt;&gt;16);                    WriteChar((oType&amp;0xff00)&gt;&gt;8);                    WriteChar(oType&amp;0xff);                    DoCR();                    break;                                    }                        break;          case  kQ3SharedTypeRenderer:              WriteString(&quot;\p    RENDERER&quot;);              DoCR();              break;          case  kQ3SharedTypeSet:              WriteString(&quot;\p    SET&quot;);              DoCR();              break;          case  kQ3SharedTypeTexture:              WriteString(&quot;\p    TEXTURE&quot;);              DoCR();              break;          case  kQ3SharedTypeFile:              WriteString(&quot;\p    FILE&quot;);              DoCR();              break;          case  kQ3SharedTypeStorage:              WriteString(&quot;\p    STORAGE&quot;);              DoCR();              break;          case  kQ3SharedTypeShapePart:              WriteString(&quot;\p    SHAPE PART&quot;);              DoCR();              break;          case  kQ3SharedTypeControllerState:              WriteString(&quot;\p    CONTROLLER STATE&quot;);              DoCR();              break;          case  kQ3SharedTypeTracker:              WriteString(&quot;\p    TRACKER&quot;);              DoCR();              break;          case  kQ3SharedTypeViewHints:              WriteString(&quot;\p    VIEW HINTS&quot;);              DoCR();              break;                }        break;            case  kQ3ObjectTypeView:        WriteString(&quot;\pView&quot;);        DoCR();        break;  }}/****************** TRAVERSE DISPLAY GROUP INFO **********************/static void TraverseDisplayGroupInfo(TQ3Object theGroup){TQ3GroupPosition      position;      TQ3Object          object;        TQ3Status          status;          // a result codeunsigned long        numObjects;  status = Q3Group_CountObjects(theGroup, &amp;numObjects);                // get # objects in group  gHtab += 40;  DoCR();  ForeColor(blueColor);  WriteString(&quot;\p--------START GROUP----------&quot;);  DoCR();  if (numObjects &gt; 0)  {        status = Q3Group_GetFirstPosition(theGroup, &amp;position);                // get position of 1st object in group      do    {      status = Q3Group_GetPositionObject(theGroup, position, &amp;object);        // get ref to object from group      QD3D_DisplayObjectInfo(object);      Q3Object_Dispose(object);                            // zap reference      Q3Group_GetNextPosition(theGroup, &amp;position);                  // get next position    }while(position != nil);  }    ForeColor(blueColor);  WriteString(&quot;\p--------END GROUP -----------&quot;);  DoCR();  gHtab -= 40;}/******************** SHOW TRIMESH INFO **************************/static void ShowTriMeshInfo(TQ3Object theTriMesh){TQ3TriMeshData  triMeshData;TQ3Status      status;Str255        s;  status = Q3TriMesh_GetData(theTriMesh,&amp;triMeshData);  gHtab += 40;  DoCR();  WriteString(&quot;\p# Triangles = &quot;);  NumToString(triMeshData.numTriangles,s);  WriteString(s);  DoCR();  WriteString(&quot;\p# Points = &quot;);  NumToString(triMeshData.numPoints,s);  WriteString(s);  DoCR();  gHtab -= 40;    gTotalNumVertecies += triMeshData.numPoints;  gTotalNumFaces += triMeshData.numTriangles;  gTotalMeshes++;          Q3TriMesh_EmptyData(&amp;triMeshData);  }/****************** SHOW MESH INFO **********************/static void ShowMeshInfo(TQ3Object theMesh){TQ3Status      status;unsigned long    n,numFaces;Str255        s;TQ3MeshFace      meshFace;TQ3MeshIterator    iterator;TQ3AttributeSet    attributeSet;TQ3AttributeType  type;TQ3SurfaceShaderObject  surfaceShaderObject;TQ3SurfaceShaderObject  surfaceShaders[1000];short        numSurfaceShaders = 0,i;Boolean        isNew;RGBColor      color;TQ3TextureObject  texture;TQ3TextureObject  textures[1000];short        numTextures = 0;TQ3StoragePixmap  pixmap;TQ3StorageObject  pixmaps[1000];short        numPixmaps = 0;  GetForeColor(&amp;color);  ForeColor(magentaColor);  gHtab += 40;  DoCR();//  WriteString(&quot;\p--------------------- MESH -----------------------&quot;);//  DoCR();  status = Q3Mesh_GetNumVertices(theMesh, &amp;n);            // show # vertices  WriteString(&quot;\p# Vertices = &quot;);  NumToString(n,s);  WriteString(s);  DoCR();  status = Q3Mesh_GetNumFaces(theMesh, &amp;numFaces);          // show # faces  WriteString(&quot;\p# Faces = &quot;);  NumToString(numFaces,s);  WriteString(s);  DoCR();          /* INC GLOBAL COUNTERS */          gTotalNumVertecies += n;  gTotalNumFaces += numFaces;  gTotalMeshes++;                    /* SCAN FACES */          if (numFaces &gt; 0)  {    meshFace = Q3Mesh_FirstMeshFace(theMesh, &amp;iterator);      // get 1st face in mesh    do    {            /*****************/            /* CHECK ATTRIBS */            /*****************/                  status = Q3Mesh_GetFaceAttributeSet(theMesh, meshFace, &amp;attributeSet);    // get ref to attribs (if any)      if ((status == kQ3Success) &amp;&amp; (attributeSet != nil))      {        type = kQ3AttributeTypeNone;                      // get 1st attrib type        status = Q3AttributeSet_GetNextAttributeType(attributeSet, &amp;type);        if ((status == kQ3Success) &amp;&amp; (type != kQ3AttributeTypeNone))        {          do          {            switch(type)            {              case  kQ3AttributeTypeSurfaceShader:                  status = Q3AttributeSet_Get(attributeSet, type, &amp;surfaceShaderObject);    // get ref to surface shader object                  status = Q3TextureShader_GetTexture(surfaceShaderObject, &amp;texture);      // get ref to texture object                      status = Q3PixmapTexture_GetPixmap(texture, &amp;pixmap);            // get ref to pixmap object                                                      /* SEE IF SHADER IS UNIQUE */                                        isNew = true;                  for (i = 0; i &lt; numSurfaceShaders; i++)            // see if this surfaceShaderObject already accounted for                    if (surfaceShaderObject == surfaceShaders[i])                    {                      isNew = false;                      break;                    }                  if (isNew)                    surfaceShaders[numSurfaceShaders++] = surfaceShaderObject;                        /* SEE IF TEXTURE IS UNIQUE */                                        isNew = true;                  for (i = 0; i &lt; numTextures; i++)            // see if this texture already accounted for                    if (texture == textures[i])                    {                      isNew = false;                      break;                    }                  if (isNew)                    textures[numTextures++] = texture;                      /* SEE IF PIXMAP IMAGE IS UNIQUE */                                        isNew = true;                  for (i = 0; i &lt; numPixmaps; i++)            // see if this pixmap storage obj already accounted for                    if (pixmap.image == pixmaps[i])                    {                      isNew = false;                      break;                    }                  if (isNew)                    pixmaps[numPixmaps++] = pixmap.image;                      Q3Object_Dispose(surfaceShaderObject);            // dispose ref to shader                  Q3Object_Dispose(texture);                  // dispose ref to texture                  Q3Object_Dispose(pixmap.image);                // dispose ref to pixmap image (storage obj)                  break;                          }            status = Q3AttributeSet_GetNextAttributeType(attributeSet, &amp;type);  // get next attrib type            if (status != kQ3Success)              goto next_face;          }while(type != kQ3AttributeTypeNone);        }        Q3Object_Dispose(attributeSet);              // dispose ref to attribs      }next_face:        meshFace = Q3Mesh_NextMeshFace(&amp;iterator);          // get next face    }while(meshFace != nil);    WriteString(&quot;\p# Surface Shaders = &quot;);              // print # different shaders    NumToString(numSurfaceShaders,s);    WriteString(s);    DoCR();          /* SEE IF NEED TO TELL MORE ABOUT SURFACE SHADERS */              if (numSurfaceShaders &gt; 0)    {      WriteString(&quot;\p    # Textures = &quot;);                // print # different textures      NumToString(numTextures,s);      WriteString(s);      DoCR();        WriteString(&quot;\p        # Pixmaps = &quot;);              // print # different pixmaps      NumToString(numPixmaps,s);      WriteString(s);      DoCR();    }  }    //  DoCR();//  WriteString(&quot;\p+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++&quot;);//  DoCR();  gHtab -= 40;  RGBForeColor(&amp;color);}/****************** SHOW ATTRIBUTE INFO **********************/static void ShowAttributeInfo(TQ3AttributeSet theAttribute){TQ3Status      status;TQ3AttributeType  attribType;RGBColor      color;float        f;Str255        s;TQ3ColorRGB      c;  GetForeColor(&amp;color);  ForeColor(magentaColor);  gHtab += 40;  DoCR();//  WriteString(&quot;\p--------------- ATTRIB --------------------&quot;);//  DoCR();        /* GET 1ST ATTRIBUTE TYPE */          attribType = kQ3AttributeTypeNone;  status = Q3AttributeSet_GetNextAttributeType(theAttribute, &amp;attribType);        /* ITERATE THRU ALL ATTRIBS */          if ((status == kQ3Success) &amp;&amp; (attribType != kQ3AttributeTypeNone))  {    do    {      switch(attribType)      {        case  kQ3AttributeTypeSurfaceShader:            WriteString(&quot;\pSurface Shader&quot;);            DoCR();            break;                      case  kQ3AttributeTypeSurfaceUV:            WriteString(&quot;\pSurface UV&quot;);            DoCR();            break;          case  kQ3AttributeTypeShadingUV:            WriteString(&quot;\pShading UV&quot;);            DoCR();            break;          case  kQ3AttributeTypeNormal:            WriteString(&quot;\pNormal&quot;);            DoCR();            break;          case  kQ3AttributeTypeAmbientCoefficient:            WriteString(&quot;\pAmbient Coefficient: &quot;);            Q3AttributeSet_Get(theAttribute, attribType, &amp;f);                        FloatToString(f,s);            WriteString(s);            DoCR();            break;          case  kQ3AttributeTypeDiffuseColor:            WriteString(&quot;\pDiffuse Color: r=&quot;);            Q3AttributeSet_Get(theAttribute, attribType, &amp;c);                        FloatToString(c.r,s);            WriteString(s);            WriteString(&quot;\p g=&quot;);            FloatToString(c.g,s);            WriteString(s);            WriteString(&quot;\p b=&quot;);            FloatToString(c.b,s);            WriteString(s);            DoCR();            break;          case  kQ3AttributeTypeSpecularColor:            WriteString(&quot;\pSpecular Color: r=&quot;);            Q3AttributeSet_Get(theAttribute, attribType, &amp;c);                        FloatToString(c.r,s);            WriteString(s);            WriteString(&quot;\p g=&quot;);            FloatToString(c.g,s);            WriteString(s);            WriteString(&quot;\p b=&quot;);            FloatToString(c.b,s);            WriteString(s);            DoCR();            break;                      case  kQ3AttributeTypeSpecularControl:            WriteString(&quot;\pSpecular Control: &quot;);            Q3AttributeSet_Get(theAttribute, attribType, &amp;f);                        FloatToString(f,s);            WriteString(s);            DoCR();            break;                      case  kQ3AttributeTypeHighlightState:            WriteString(&quot;\pHighlight State&quot;);            DoCR();            break;                      case  kQ3AttributeTypeTransparencyColor:            WriteString(&quot;\pTransparency Color: r=&quot;);            Q3AttributeSet_Get(theAttribute, attribType, &amp;c);                        FloatToString(c.r,s);            WriteString(s);            WriteString(&quot;\p g=&quot;);            FloatToString(c.g,s);            WriteString(s);            WriteString(&quot;\p b=&quot;);            FloatToString(c.b,s);            WriteString(s);            DoCR();            break;                      case  kQ3AttributeTypeSurfaceTangent:            WriteString(&quot;\pSurface Tangent&quot;);            DoCR();            break;                                            }      status = Q3AttributeSet_GetNextAttributeType(theAttribute, &amp;attribType);  // get next attrib type      if (status != kQ3Success)        break;    }while(attribType != kQ3AttributeTypeNone);  }//  WriteString(&quot;\p++++++++++++++++++++ ATTRIB END +++++++++++++++++++++++++++++&quot;);//  DoCR();  gHtab -= 40;  RGBForeColor(&amp;color);}/**************** CALC SCALE TO MAKE FIT ***********************/float CalcScaleToMakeFit(QD3DSetupOutputType *setupInfo,TQ3Object theObject, float targetSize){TQ3BoundingSphere  boundingSphere;  Q3View_StartBoundingSphere(setupInfo-&gt;viewObject, kQ3ComputeBoundsApproximate);  do  {    Q3Object_Submit(theObject,setupInfo-&gt;viewObject);  }while(Q3View_EndBoundingSphere(setupInfo-&gt;viewObject, &amp;boundingSphere) == kQ3ViewStatusRetraverse);  return((targetSize/2)/boundingSphere.radius);}/******************** QD3D: REPLACE OBJECT IN GROUP **********************///// OUTPUT: new position in group//TQ3GroupPosition QD3D_ReplaceObjectInGroup(TQ3Object theGroup, TQ3GroupPosition position, TQ3Object newObj){      TQ3GroupPosition  newPos;TQ3Object      removedObj;  newPos = Q3Group_AddObjectBefore(theGroup, position, newObj);    // add newObj to group  if (newPos == nil)    DoFatalAlert(&quot;\pQ3Group_AddObjectBefore failed!&quot;);      removedObj = Q3Group_RemovePosition(theGroup, position);        // remove old from group  if (removedObj == nil)    DoFatalAlert(&quot;\pQ3Group_RemovePosition Failed!&quot;);  Q3Object_Dispose(removedObj);  return(newPos);}/*************** QD3D: CALC OBJECT BOUNDING BOX ************************/void QD3D_CalcObjectBoundingBox(QD3DSetupOutputType *setupInfo, TQ3Object theObject, TQ3BoundingBox  *boundingBox){  Q3View_StartBoundingBox(setupInfo-&gt;viewObject, kQ3ComputeBoundsExact);  do  {    Q3Object_Submit(theObject,setupInfo-&gt;viewObject);  }while(Q3View_EndBoundingBox(setupInfo-&gt;viewObject, boundingBox) == kQ3ViewStatusRetraverse);}/********************* QD3D: MAKE DUPLICATE ATTRIBUTE SET *********************///// This makes a copy of an attribute set, but does NOT duplicate any attached objects// such as surface shaders.  Q3Object_Duplicate appears to duplicate the attrib and all // included objects.//TQ3AttributeSet QD3D_MakeDuplicateAttributeSet(TQ3AttributeSet sourceSet){TQ3AttributeSet  newSet;  newSet = Q3AttributeSet_New();  Q3AttributeSet_Inherit(newSet, sourceSet, newSet);  return(newSet);}/**************** QD3D PIXMAP TO GWORLD ***********************///// OUTPUT: r = rect of gworld//GWorldPtr QD3D_PixmapToGWorld(TQ3StoragePixmap *pixmap, Rect *r){GWorldPtr    gworld;PixMapHandle  gworldPixmap;long      gworldRowBytes,x,y,pixmapRowbytes;Ptr        gworldPixelPtr;TQ3Status    status;unsigned long  size,sizeRead,*pix32Src,*pix32Dest;unsigned char  *buffer;unsigned short  *pix16Src,*pix16Dest;OSErr      iErr;      /* CREATE GWORLD TO DRAW INTO */    SetRect(r,0,0,pixmap-&gt;width,pixmap-&gt;height);  iErr = NewGWorld(&amp;gworld, pixmap-&gt;pixelSize, r, nil, nil, 0);  if (iErr)    DoFatalAlert(&quot;\pQD3D_PixmapToGWorld: NewGWorld failed!&quot;);  DoLockPixels(gworld);  gworldPixmap = GetGWorldPixMap(gworld);  gworldRowBytes = (**gworldPixmap).rowBytes &amp; 0x3fff;          // get GWorld's rowbytes  gworldPixelPtr = GetPixBaseAddr(gworldPixmap);              // get ptr to pixels    /* GET QD3D PIXMAP DATA INFO */  status = Q3Storage_GetSize(pixmap-&gt;image, &amp;size);            // get size of data  if (status == kQ3Failure)    DoFatalAlert(&quot;\pQD3D_PixmapToGWorld: Q3Storage_GetSize failed!&quot;);  buffer = (unsigned char *)AllocPtr(size);                // alloc buffer for pixel data  if (buffer == nil)    DoFatalAlert(&quot;\pQD3D_PixmapToGWorld: AllocPtr failed!&quot;);      status = Q3Storage_GetData(pixmap-&gt;image, 0, size, buffer, &amp;sizeRead);  // get pixel data  if (status == kQ3Failure)    DoFatalAlert(&quot;\pQD3D_PixmapToGWorld: Q3Storage_GetData failed!&quot;);  pixmapRowbytes = pixmap-&gt;rowBytes;        /* WRITE PIXMAP DATA INTO GWORLD */      //  if ((pixmap-&gt;bitOrder != kQ3EndianBig) || (pixmap-&gt;byteOrder != kQ3EndianBig))//    DoFatalAlert(&quot;\pQD3D_PixmapToGWorld: only kQ3EndianBig is supported!&quot;);        switch(pixmap-&gt;pixelSize)  {    case  32:        pixmap-&gt;pixelType = kQ3PixelTypeRGB32;            // (fix this for formZ)        pix32Src = (unsigned long *)buffer;              // get 32bit pointers        pix32Dest = (unsigned long *)gworldPixelPtr;        for (y = 0; y &lt;  pixmap-&gt;height; y++)        {          for (x = 0; x &lt; pixmap-&gt;width; x++)            pix32Dest[x] = pix32Src[x];                  pix32Dest += gworldRowBytes/4;              // next dest row          pix32Src += pixmapRowbytes/4;        }        break;    case  16:        pixmap-&gt;pixelType = kQ3PixelTypeRGB16;            // (fix this for formZ)        pix16Src = (unsigned short *)buffer;            // get 16bit pointers        pix16Dest = (unsigned short *)gworldPixelPtr;        for (y = 0; y &lt;  pixmap-&gt;height; y++)        {          for (x = 0; x &lt; pixmap-&gt;width; x++)            pix16Dest[x] = pix16Src[x];                  pix16Dest += gworldRowBytes/2;              // next dest row          pix16Src += pixmapRowbytes/2;        }        break;                    default:        DoFatalAlert(&quot;\pQD3D_PixmapToGWorld: Only 32/16 bit textures supported right now.&quot;);  }  DisposePtr((Ptr)buffer);                        return(gworld);  }/**************** QD3D MIPMAP TO GWORLD ***********************///// OUTPUT: r = rect of gworld//GWorldPtr QD3D_MipmapToGWorld(TQ3Mipmap *mipmap, Rect *r){GWorldPtr    gworld;PixMapHandle  gworldPixmap;long      gworldRowBytes,x,y,pixmapRowbytes;Ptr        gworldPixelPtr;TQ3Status    status;unsigned long  size,sizeRead,*pix32Src,*pix32Dest;unsigned char  *buffer;unsigned short  *pix16Src,*pix16Dest;OSErr      iErr;long      pixelSize;long      height,width;      /* CREATE GWORLD TO DRAW INTO */    switch(mipmap-&gt;pixelType)  {    case  kQ3PixelTypeRGB16:    case  kQ3PixelTypeARGB16:        pixelSize = 16;        break;            case  kQ3PixelTypeRGB32:    case  kQ3PixelTypeARGB32:        pixelSize = 32;        break;  }    height = mipmap-&gt;mipmaps[0].height;  width = mipmap-&gt;mipmaps[0].width;  SetRect(r,0,0,width,height);  iErr = NewGWorld(&amp;gworld,pixelSize, r, nil, nil, 0);  if (iErr)    DoFatalAlert(&quot;\pQD3D_MipmapToGWorld: NewGWorld failed!&quot;);  DoLockPixels(gworld);  gworldPixmap = GetGWorldPixMap(gworld);  gworldRowBytes = (**gworldPixmap).rowBytes &amp; 0x3fff;          // get GWorld's rowbytes  gworldPixelPtr = GetPixBaseAddr(gworldPixmap);              // get ptr to pixels    /* GET QD3D PIXMAP DATA INFO */  status = Q3Storage_GetSize(mipmap-&gt;image, &amp;size);            // get size of data  if (status == kQ3Failure)    DoFatalAlert(&quot;\pQD3D_MipmapToGWorld: Q3Storage_GetSize failed!&quot;);  buffer = (unsigned char *)AllocPtr(size);                // alloc buffer for pixel data  if (buffer == nil)    DoFatalAlert(&quot;\pQD3D_MipmapToGWorld: AllocPtr failed!&quot;);      status = Q3Storage_GetData(mipmap-&gt;image, 0, size, buffer, &amp;sizeRead);  // get pixel data  if (status == kQ3Failure)    DoFatalAlert(&quot;\pQD3D_MipmapToGWorld: Q3Storage_GetData failed!&quot;);  pixmapRowbytes = mipmap-&gt;mipmaps[0].rowBytes;        /* WRITE MIPMAP DATA INTO GWORLD */      //  if ((mipmap-&gt;bitOrder != kQ3EndianBig) || (mipmap-&gt;byteOrder != kQ3EndianBig))//    DoFatalAlert(&quot;\pQD3D_MipmapToGWorld: only kQ3EndianBig is supported!&quot;);        switch(pixelSize)  {    case  32:        pix32Src = (unsigned long *)buffer;              // get 32bit pointers        pix32Dest = (unsigned long *)gworldPixelPtr;        for (y = 0; y &lt;  height; y++)        {          for (x = 0; x &lt; width; x++)            pix32Dest[x] = pix32Src[x];                  pix32Dest += gworldRowBytes/4;              // next dest row          pix32Src += pixmapRowbytes/4;        }        break;    case  16:        pix16Src = (unsigned short *)buffer;            // get 16bit pointers        pix16Dest = (unsigned short *)gworldPixelPtr;        for (y = 0; y &lt;  height; y++)        {          for (x = 0; x &lt; width; x++)            pix16Dest[x] = pix16Src[x];                  pix16Dest += gworldRowBytes/2;              // next dest row          pix16Src += pixmapRowbytes/2;        }        break;                    default:        DoFatalAlert(&quot;\pQD3D_MipmapToGWorld: Only 32/16 bit textures supported right now.&quot;);  }  DisposePtr((Ptr)buffer);                        return(gworld);  }/******************* QD3D: SHOW ERROR *************************///// Returns true if Error, false if just a warning.//Boolean QD3D_ShowError(Str255 errString, Boolean showWarnings){TQ3Error  err;TQ3Warning  warning;Str255    numStr;    /* DO ERRORS */      err = Q3Error_Get(nil);  if (err != 0)  {    DoAlert(errString);    switch(err)    {      case  kQ3ErrorViewNotStarted:          DoFatalAlert(&quot;\pError:kQ3ErrorViewNotStarted&quot;);          break;                case  kQ3ErrorOutOfMemory:          DoFatalAlert(&quot;\pError:kQ3ErrorOutOfMemory&quot;);          break;                default:          ShowSystemErr(err);    }    return(true);  }      /* DO WARNINGS */  else  {    if (!showWarnings)      return(false);        DoAlert(errString);    warning = Q3Warning_Get(nil);    switch(warning)    {      case  kQ3WarningFunctionalityNotSupported:          DoAlert(&quot;\pWarning: kQ3WarningFunctionalityNotSupported&quot;);          break;                default:          NumToString(err, numStr);          DoAlert (numStr);    }    return(false);  }    }/************ QD3D: SHOW RECENT ERROR *******************/void QD3D_ShowRecentError(void){TQ3Error  q3Err;Str255    s;    q3Err = Q3Error_Get(nil);  if (q3Err == kQ3ErrorOutOfMemory)    QD3D_DoMemoryError();  else  if (q3Err == kQ3ErrorMacintoshError)    DoFatalAlert(&quot;\pkQ3ErrorMacintoshError&quot;);  else  if (q3Err != 0)  {    NumToString(q3Err,s);    DoFatalAlert(s);  }}/***************** QD3D: DO MEMORY ERROR **********************/void QD3D_DoMemoryError(void){  InitCursor();  NoteAlert(129,nil);  CleanQuit();}</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/ColorTextureSample/listing19.html%3Fid%3DDTS10000131-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/ColorTextureSample/listing19.html%3Fid%3DDTS10000131-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/ColorTextureSample/listing19.html%3Fid%3DDTS10000131-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>