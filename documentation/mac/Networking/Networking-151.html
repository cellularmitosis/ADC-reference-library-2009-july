<!-- Generated by Harlequin WebMaker 2.2.3 (23-Apr-1996)
LispWorks 3.2.2 -->
<HTML> <HEAD>
<TITLE>Writing a Responder ATP Application(IM:N)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING151></A>


<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="Networking-150.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Networking-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Networking-304.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt= "Book Index"></A> <A HREF="Networking-152.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="Networking-2.html"><B>Networking</B></A> / <BR><DD><A HREF="Networking-143.html"><B>Chapter 6 - AppleTalk Transaction Protocol (ATP)</B></A> / <A HREF="Networking-149.html"><B>Using ATP</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING151-0></A>
<H2>Writing a Responder ATP Application</H2>
 A<A NAME=MARKER-2-87></A> responder application receives incoming ATP requests, processes them, and sends a <A NAME=MARKER-2-33></A>response to the requester application. To write a responder application, you open a socket that you set up to listen for requests. When you receive a request, you process it <A NAME=MARKER-2-26></A>and send a response back to the requester application. The response can consist of a message reporting the outcome of the processing you performed or data resulting from the processing. <P>
 Before you can use ATP, you must first open the .MPP driver, which in turn opens the .ATP driver. Use the Device Manager's <CODE>OpenDriver</CODE> function to open the .MPP driver. Even if you suspect that the .MPP and the .ATP drivers are open, you should call the <CODE>OpenDriver</CODE> function for the .MPP driver to ensure that this is the case. Calling <CODE>OpenDrive</CODE>r for a driver that is already open will not produce harmful repercussions. See the chapter "Device Manager" in <I><A HREF="../Devices/Devices-2.html">Inside Macintosh: Devices</A></I> for information on the <CODE>OpenDriver</CODE> function. Do not close the .MPP driver when you are finished using ATP because other applications dependent on it or the .ATP driver require that it remain open. <P>
<A NAME=HEADING151-3></A>
<H3>Opening and <A NAME=MARKER-2-33></A>Setting Up a Socket to Receive Requests</H3>
 To open a socket to receive incoming requests, you use the following procedure:<P>
<OL>
<LI>To open the socket, call the <A NAME=MARKER-2-91></A><CODE>POpenATPSkt</CODE> function, providing it with values as follows: <P>
<UL>
<LI>To direct ATP to open a specific socket, provide the number of that socket as the value of the <CODE>atpSocket</CODE> parameter; to allow ATP to dynamically assign a socket, specify 0 as the value of this field. 
<LI>To <A NAME=MARKER-2-94></A>filter the sockets from which you will accept requests, set the internet socket address fields of the <CODE>addrBlock</CODE> parameter; to accept requests from any socket, <BR>set all three fields to 0. You can filter requests based on network, socket, or node numbers. For example, to accept requests from all sockets on the node whose ID <BR>is 112, you set the network and socket number fields of the address block record to 0 and the node ID field to 112. <P>
</UL>
<LI>To set up the socket to receive requests, <A NAME=MARKER-2-97></A>call the <CODE>PGetRequest</CODE> function, which listens for an incoming request on the socket you specify. You provide it with the parameter values as follows:<P>
<UL>
<LI>Allocate a buffer to store the incoming request; you pass <CODE>PGetRequest</CODE> a pointer to this buffer and the length of the buffer. Unless you know the exact size of the incoming request, allocate at least 578 bytes of nonrelocatable memory for this buffer to accommodate the maximum request packet size. Set the <CODE>reqPointer</CODE> parameter to point to the buffer, and set the <CODE>reqLength</CODE> parameter to the size in bytes of the buffer.
<LI>Set the <CODE>atpSocket</CODE> parameter to the number of the socket to be used to listen for the request; this is the socket you opened through the <CODE>POpenATPSkt</CODE> call. 
<LI>Set the <CODE>ioCompletion</CODE> parameter. In most cases, you should issue the <CODE>PGetRequest</CODE> call asynchronously so that your application can continue execution while <CODE>PGetRequest</CODE> listens for an incoming call; the <CODE>PGetRequest</CODE> function returns after it receives an incoming request or encounters an error condition. If you issue this call asynchronously, you must either specify a completion routine or set the <CODE>ioCompletion</CODE> parameter to <CODE>NIL</CODE>. If you use a completion routine, before it exits, your completion routine can call the <CODE>PGetRequest</CODE> function again to listen for the next incoming request. If you do not use a completion routine, you must poll the <CODE>ioResult</CODE> field for indication of an incoming request to determine when the function completes execution and whether an error condition or an incoming request caused the function to complete. For more information on calling a routine asynchronously, see the chapter "Introduction to AppleTalk" in this book. <P>
</UL>
<LI>Process the values that <CODE>PGetRequest</CODE> returns. The <CODE>PGetRequest</CODE> function returns the following values that may be of use to your application:<P>
<UL>
<LI>The request <A NAME=MARKER-2-121></A>transaction ID <CODE>reqTID</CODE> that ATP assigns to this request. If you intend to respond to the request, save this value because you will need to pass it to the <CODE>PSendResponse</CODE> function and the <CODE>PAddResponse</CODE> function to identify the request for which the response message is intended. For more information on the trans-<BR>action ID, see the discussion in the section <A HREF=Networking-145.html#MARKER-9-39>"The ATP Packet Format" beginning on page 6-5</A>. 
<LI>The <CODE>userData</CODE> parameter, <A NAME=MARKER-9-15></A>which contains any additional information that the requester application has sent. To make this parameter meaningful, both the requester and the responder applications should agree on the use of these additional data bytes that are separate from the request or response data sent <BR>in an ATP transaction.
<LI>The exactly-once bit (bit 5) of the <CODE>atpFlags</CODE> parameter, which is set if the request received is part of an exactly-once transaction. ATP uses this information internally to ensure that your responder application receives this request only once.<P>
</UL>
</OL>
 <A HREF=#MARKER-9-101>Listing 6-2 on page 6-17</A> shows how to open a socket and issue a call to the <CODE>PGetRequest</CODE> function to receive requests.<P>
<A NAME=HEADING151-17></A>
<H3><A NAME=MARKER-9-96></A>Responding to Requests</H3>
 After you process a request and create a response message, you call the <CODE><A NAME=MARKER-2-59></A>PSendResponse</CODE> function to send the response. ATP assembles the response packets into a message and returns them to the requester application. You can send the request through the same socket that you use to receive incoming requests, or you can specify a different socket to be used for this purpose. To use a different socket, you must first open the socket by calling <CODE>POpenATPSocket</CODE>. The code in <A HREF=#MARKER-9-101>Listing 6-2</A><B> </B>opens a new socket that it uses to <BR>send the response.<P>
<OL>
<LI>Create a buffer data structure to hold the response data that you want to send. <P>
<A NAME=MARKER-2-23></A>The buffer data structure (BDS) must be an array of up to eight elements. You can use the <CODE>BuildBDS</CODE> function to create the BDS. You pass <CODE>BuildBDS</CODE> a pointer to a buffer and the length of the buffer, and it creates up to eight elements depending on the size of the buffer that you supply. <CODE>BuildBDS</CODE> returns as its function result the number of elements that it creates; you pass this number and a pointer to the buffer data structure to the <CODE>PSendResponse</CODE> call. The memory that you allocate for the buffer must be nonrelocatable until the <CODE>PSendResponse</CODE> call completes execution. After <CODE>PSendResponse</CODE> returns, you should release this memory. 
<LI>To send the response, call the <CODE>PSendResponse</CODE> function. The response data cannot exceed 4624 bytes. If you need to send more information, you can follow the <CODE>PSendResponse</CODE> function with one or more calls to the <A NAME=MARKER-2-65></A><CODE>PAddResponse</CODE> function until you have sent a total of eight packets, including the packets that you sent <BR>when you called the <CODE>PSendResponse</CODE> function; each time you call the <CODE>PAddResponse</CODE> function, you can send one additional packet consisting of 578 bytes of data. <P>
<UL>
<LI>For the input address block (<CODE>addrBlock</CODE>) and transaction ID (<CODE>transID</CODE>) parameters to <CODE>PSendResponse</CODE>, use the address block (<CODE>addrBlock</CODE>) and <BR>request transaction ID (<CODE>reqTID</CODE>) parameter values that the <CODE>PGetRequest</CODE> <BR>function returned. 
<LI>Set the <CODE>numOfBuffs</CODE> field to the number of response packets that you are sending. If you are sending fewer packets than the requester expects to receive, you must set the end-of-message (<CODE>atpEOMvalue</CODE>) bit (bit 4) in the <CODE>atpFlags</CODE> field to indicate that the last packet is the final one in the response message. The bitmap returned by the <CODE>PGetRequest</CODE> function indicates the number of packets that the requester expects in response.
<LI>Set the <CODE>atpSocket</CODE> field to the number of the socket that you are using to send <BR>the response. <P>
</UL>
<LI>Call the <A NAME=MARKER-9-141></A><CODE>CloseATPSkt</CODE> function to close the socket that you opened to receive requests and respond to them after you are finished with this socket. You can use <BR>the socket to continue to listen for requests until your application completes execution, but you should explicitly close the socket before exiting the program. <P>
</OL>
 The code in <A HREF=#MARKER-9-101>Listing 6-2</A> first shows how to open a socket and issue a call to the <CODE>PGetRequest</CODE> function to receive requests. Then it shows how to prepare the <BR>response data and send it. <P>
<B>Listing 6-2  <A NAME=MARKER-9-101></A>Opening a socket to receive a request and sending response data</B><P>
<PRE>
CONST
   kMaxPacketSize = 578;            {maximum packet size you can receive}
   kMaxResponses = 8;               {maximum number of responses to expect}
   kRespBufSize = kMaxPacketSize * kMaxResponses;
                                    {your response buffer}
VAR
   err:              OSErr;
   NumOfBufs:        Integer;
   ref:              Integer;
   nBufs:            Integer;
   ReqBitMap:        BitMapType;
   thisBit:          LongInt;
   gAtpPBPtr:        ATPPBPtr;
   gSendRespPBPtr:   ATPPBPtr;
   gGetReqBufPtr:    Ptr;
   gSRespBuf:        Ptr;
   gSRespBdsPtr:     BDSPtr;
BEGIN
   gAtpPBPtr := ATPPBPtr(NewPtr(SizeOf(ATPParamBlock)));
   gSendRespPBPtr := ATPPBPtr(NewPtr(SizeOf(ATPParamBlock)));
   gGetReqBufPtr := NewPtr(kMaxPacketSize);
   gSRespBdsPtr := BDSPtr(NewPtr(SizeOf(BDSType)));
   gSRespBuf := NewPtr(kRespBufSize);

   err := OpenDriver('MPP',ref);
   if err &lt;&gt; noErr THEN DoErr(err);

WITH gAtpPBPtr^ DO
BEGIN
   atpSocket := 0;                  {dynamically allocate a socket}
   addrBlock.aNet := 0;             {accept requests from anyone}
   addrBlock.aNode := 0;
   addrBlock.aSocket := 0;
END;
err := POpenATPSkt(gAtpPBPtr,false);{socket is returned in }
                                    { gAtpPBPtr^.atpSocket}

IF err &lt;&gt; noErr THEN DoErr(err);
IF gAtpPBPtr^.ioResult &lt;&gt; noErr THEN DoErr(err);
WITH gAtpPBPtr^ DO
BEGIN
   reqLength := 0;                  {request data length will be returned }
                                    { to you here}
   reqPointer := gGetReqBufPtr;     {pointer to buffer for incoming request }
                                    { data}
END;
   err := PGetRequest(gAtpPBPtr,TRUE);{asynchronous PGetRequest}

   IF err &lt;&gt; noErr THEN DoErr(err);

   {Poll ioResult until the call completes.}
   WHILE gAtpPBPtr^.ioResult &gt; noErr DO
   BEGIN
      GoDoSomething;                {return control to user while you wait }
                                    { for PGetRequest to complete}
   END;
   IF gAtpPBPtr^.ioResult &lt;&gt; noErr THEN DoErr(err);

   MyProcessRequestReceived(gAtpPBPtr^.reqPointer,gAtpPBPtr^.reqLength)
                                    {user routine that looks at the request }
                                    { data received}

   {Walk through the bitmap and see how many response buffers you need.}
   NumOfBufs := 0;
   FOR thisBit := 0 to 7 DO
   BEGIN
      {Each bit that is set corresponds to a buffer.}
      if BitTst(@gAtpPBPtr^.bitMap,thisBit) = TRUE THEN
   BEGIN
      {Your routine to fill in the appropriate response data.}
      SetUpResponseData(gSRespBuf,thisBit);
      NumOfBufs := NumOfBufs + 1;
   END
END;

{Put your response data into the BDS structure.}
nBufs := BuildBDS(gSRespBuf,Ptr(gSRespBdsPtr),(NumOfBufs * kMaxPacketSize));





WITH gSendRespPBPtr^ DO
BEGIN
   atpSocket := gAtpPBPtr^.atpSocket;
   atpFlags := atpEOMvalue;         {indicate end of message}

{Send response to the machine that sent you the request.}
   addrBlock.aNet := gAtpPBPtr^.addrBlock.aNet;
   addrBlock.aNode := gAtpPBPtr^.addrBlock.aNode;
   addrBlock.aSocket := gAtpPBPtr^.addrBlock.aSocket;
   bdsPointer := Ptr(gSRespBdsPtr);
   numOfBuffs := NumOfBufs;         {send all of the responses back now}
   bdsSize := nBufs;                {indicate how many responses you are }
                                    { sending}
   transID := gAtpPBPtr^.transID;   {use transID returned from the }
                                    { PGetRequest function}
END;
err := PSendResponse(gSendRespPBPtr,FALSE);

IF err &lt;&gt; noErr THEN DoErr(err);

{Clean up after you are done.}
DisposePtr(Ptr(gAtpPBPtr));
DisposePtr(Ptr(gSendRespPBPtr));
DisposePtr(gGetReqBufPtr);
DisposePtr(Ptr(gSRespBdsPtr));
DisposePtr(gSRespBuf);
END.
</PRE>
</BLOCKQUOTE>
<HR>
<center>
<A HREF="Networking-150.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Networking-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Networking-304.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt= "Book Index"></A> <A HREF="Networking-152.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="Networking-3.html">&copy; Apple Computer, Inc.</A><br>7 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>  
