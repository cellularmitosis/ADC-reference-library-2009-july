<!-- Generated by Harlequin WebMaker 2.2.3 (23-Apr-1996)
LispWorks 3.2.2 -->
<HTML> <HEAD>
<TITLE>Using the Date, Time, and Measurement Utilities (IM: U)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING95></A>



<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="OSUtilities-94.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="OSUtilities-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="OSUtilities-222.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="OSUtilities-96.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="OSUtilities-2.html"><B>Operating System Utilities</B></A> / <BR><DD><A HREF="OSUtilities-93.html"><B>Chapter 4 - Date, Time, and Measurement Utilities</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING95-0></A>
<H1>Using the Date, Time, and Measurement Utilities</H1>
 This section describes how to <P>
<UL>
<LI>get the current date and time
<LI>set the current date and time
<LI>calculate days and dates mathematically
<LI>convert between date-time formats
<LI>convert to different calendar systems
<LI>read and store geographic location and time-zone data
<LI>determine which measurement system to use
<LI>determine the number of elapsed microseconds<P>
</UL>
<A NAME=HEADING95-10></A>
<H2><A NAME=MARKER-9-50></A><A NAME=MARKER-2-26></A><A NAME=MARKER-2-3></A><A NAME=MARKER-9-46></A><A NAME=MARKER-2-37></A>Getting the Current Date and Time</H2>
 The Date, Time, and Measurement Utilities provide<P>
<UL>
<LI>a function--<CODE>ReadDateTime</CODE>--that system software uses at system startup time to copy the current date-time information from the clock chip into low memory. This low-memory copy of the current date-time is accessible through the global variable <CODE>Time</CODE>. You application should never need to use this function.
<LI>two procedures --<CODE>GetDateTime</CODE> and <CODE>GetTime</CODE>--that allow you to access the current date-time information stored in the global variable <CODE>Time</CODE>.<P>
</UL>
 You can access the date-time information through a date-time record, representing the date and time, or you can access the date-time information through a standard date-time value, a 32-bit integer representing the number of seconds since midnight, January 1, 1904. <P>
 To obtain the current date-time information, you can use the <CODE>GetDateTime</CODE> and <CODE>GetTime</CODE> procedures. The <CODE>GetDateTime</CODE> procedure requires that you pass it a standard date-time value as a parameter. <A HREF=#MARKER-9-38>Listing 4-1</A> shows how you can get the current date-time information, expressed as a number of seconds. The application-defined procedure <CODE>MyCurrentDateTimeInt</CODE> returns in the long integer the number of seconds elapsed since midnight, January 1, 1904.<P>
<B>Listing 4-1  <A NAME=MARKER-9-38></A>Getting the current date and time with the <EM>GetDateTime</EM> procedure</B><P>
<PRE>
PROCEDURE MyCurrentDateTimeInt (VAR myStandardDateTime: LongInt);
BEGIN
   GetDateTime(myStandardDateTime);
END;
</PRE>
 The <CODE>GetTime</CODE> procedure requires that you pass it a date-time record as a parameter, and it fills in the fields of this record appropriately. <A HREF=#MARKER-9-39>Listing 4-2</A> shows how you can get the current date-time information, expressed as a date and time. The application-defined procedure <CODE>MyCurrentDateTimeRec</CODE> returns in the fields of the date-time record the current date and time.<P>
<B>Listing 4-2  <A NAME=MARKER-9-39></A>Getting the current date and time with the <EM>GetTime</EM> procedure</B><P>
<PRE>
PROCEDURE MyCurrentDateTimeRec (VAR myDateTime: DateTimeRec);
BEGIN
   GetTime(myDateTime);
END;
</PRE>
 If you need to access the date-time information through a long date-time value or a long date-time record, see <A HREF=#MARKER-9-52>"Converting Date-Time Formats" beginning on page 4-12</A> for more information about converting date-time formats.<A NAME=MARKER-9-105></A><A NAME=MARKER-2-91></A><A NAME=MARKER-9-78></A><A NAME=MARKER-2-43></A><P>
<A NAME=HEADING95-22></A>
<H2><A NAME=MARKER-2-44></A><A NAME=MARKER-2-45></A><A NAME=MARKER-9-46></A>Setting the Current Date and Time</H2>
 Your application can change the current date-time information stored in both the system global variable <CODE>Time</CODE> and in the clock chip by calling either the <CODE>SetDateTime</CODE> function or the <CODE>SetTime</CODE> procedure. The <CODE>SetDateTime</CODE> function requires a 32-bit integer as a parameter. The <CODE>SetTime</CODE> procedure requires a date-time record as a parameter. <P>
<DL>
<DT><B>Note</B>
<DD>If you are using formats other than a date-time value or a date-time record to access date-time information, you must first convert these formats into a standard date-time value or a date-time record before you can write the new date-time information to the clock chip. See <A HREF=#MARKER-9-52>"Converting Date-Time Formats" beginning on page 4-12</A> for more information about converting date-time formats.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
 <A HREF=#MARKER-9-47>Listing 4-3</A> shows an application-defined function that uses the <CODE>SetDateTime</CODE> function to change the current date and time to 5:50 A.M. on April 5, 1994.<P>
<B>Listing 4-3  <A NAME=MARKER-9-47></A>Changing the current date and time with the <EM>SetDateTime</EM> function</B><P>
<PRE>
FUNCTION MyChangeDateTimeInt: OSErr;
VAR
   myDateTimeInt: LongInt;
   myErr:         OSErr;
BEGIN
   myDateTimeInt := $A9C6AC88;
   myErr := SetDateTime(myDateTimeInt);
END;
</PRE>
 <A HREF=#MARKER-9-48>Listing 4-4</A> shows an application-defined procedure that uses the <CODE>SetTime</CODE> function to change the current date and time to 5:50 A.M. on April 5, 1994.<P>
<B>Listing 4-4  <A NAME=MARKER-9-48></A>Changing the current date and time with the <EM>SetTime</EM> function</B><P>
<PRE>
PROCEDURE MyChangeDateTimeRec;
VAR
   myDateTimeRec: DateTimeRec;
   myErr:         OSErr;
BEGIN
   WITH myDateTimeRec DO
   BEGIN
      year := 1994;
      month := 4;
      day := 5;
      hour := 5;
      minute := 50;
      second := 0;
      dayOfWeek := 3;
   END;
   SetTime(myDateTimeRec);
END;
</PRE>
<DL>
<DT><B>IMPORTANT</B>
<DD><A NAME=MARKER-2-49></A>Users can change the current date and time stored in both the system global variable <CODE>Time</CODE> and in the clock chip by using the General Controls control panel, Date &amp; Time control panel, or the Alarm Clock desk accessory. In general, your application should not directly change the current date-time information. If your application does need to modify the current date-time information, it should instruct the user how to change the date and time.<EM></EM><A NAME=MARKER-2-50></A><A NAME=MARKER-2-51></A>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
<A NAME=HEADING95-32></A>
<H2><A NAME=MARKER-9-52></A>Converting Date-Time Formats</H2>
 The Date, Time, and Measurement Utilities provide four routines--the <CODE>DateToSeconds</CODE>, <CODE>SecondsToDate</CODE>, <CODE>LongDateToSeconds</CODE>, and <CODE>LongSecondsToDate</CODE> procedures--that you can use to convert date-time formats. You can convert a date and time to a number of seconds and a number of seconds to a date and time. <P>
 Note that when you call one of these routines, system software uses the <CODE>DateToSeconds</CODE>, <CODE>SecondsToDate</CODE>, <CODE>LongDateToSeconds</CODE>, and <CODE>LongSecondsToDate</CODE> procedures provided by the current script system.<P>
<DL>
<DT><B>Note</B>
<DD>The routines that convert between time formats assume that each day contains 86,400 seconds. Occasionally (approximately once each two years) astronomers add a second to either June 31 or December 31 to compensate for imperfections in the earth's rotation. If you need to compute the exact number of seconds between two points in time, you might need to take these occasional additions into account. The routines that convert between formats are designed not to provide astronomical accuracy, but merely to convert data between one data structure and another.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
 If you use a standard date-time value or a date-time record to access date-time information, you can use the <CODE>SecondsToDate</CODE> procedure to convert a number of seconds to a date and time, and the <CODE>DateToSeconds</CODE> procedure to convert a date and time to a number of seconds. <A HREF=#MARKER-9-53>Listing 4-5</A> shows an application-defined procedure, <CODE>MyConvertSecondsAndDates</CODE>, that uses the <CODE>SecondsToDate</CODE> and <CODE>DateToSeconds</CODE> procedures to manipulate the date-time information. After calling the <CODE>GetDateTime</CODE> procedure, <CODE>MyConvertSecondsAndDates</CODE> calls the <CODE>SecondsToDate</CODE> procedure to convert the number of seconds (returned by the <CODE>GetDateTime</CODE> procedure) to a date and time. The <CODE>MyConvertSecondsAndDates</CODE> procedure manipulates the <CODE>year</CODE> field in the date-time record and then calls <CODE>DateToSeconds</CODE> to convert the date and time back into a number of seconds. The SetDateTime procedure writes the new date-time information to the clock chip. <P>
<B>Listing 4-5  <A NAME=MARKER-9-53></A>Manipulating date-time information</B><P>
<PRE>
PROCEDURE MyConvertSecondsAndDates;
VAR
   myDateTimeRec:       DateRec;
   mySeconds:           DateTime;
   myErr:               OSErr;
BEGIN
   GetDateTime(mySeconds);
   SecondsToDate(mySeconds, myDateTimeRec); 
   WITH myDateTimeRec DO
      year := year + 1;
   DateToSeconds (myDateTimeRec, mySeconds);
   myErr := SetDateTime(mySeconds);
END;
</PRE>
 If you access date-time information through a long date-time value or a long date-time record, you can use the <CODE>LongSecondsToDate</CODE> procedure to convert a number of seconds to a date and time and use the <CODE>LongDateToSeconds</CODE> procedure to convert a date and time to a number of seconds. <P>
 <A NAME=MARKER-2-54></A>If the type of data structure that you are using to access date-time information is insufficient, you can use a different date-time structure.<P>
<UL>
<LI>To access a number of seconds through a long date-time value instead of a standard date-time value, set the <CODE>lHigh</CODE> field of a long date-time conversion record (described on <A HREF=OSUtilities-99.html#MARKER-9-89>page 4-25</A>) to 0 and the <CODE>lLow</CODE> field to the total number of seconds since midnight, January 1, 1904. Then copy the value of the <CODE>c</CODE> field into a variable of type <CODE>LongDateTime</CODE>. 
<LI>To access a date and time through a long date-time record instead of a date-time record, set the <CODE>oldDate</CODE> field of the <CODE>LongDateRec</CODE> to the date-time record, and set the <CODE>eraAlt</CODE> field to 0, indicating that the date you have specified is A.D. <A NAME=MARKER-2-53></A>
<LI>To access a number of seconds through a standard date-time value instead of a long date-time value, truncate the long date-time value to just the low-order 32 bits. The year of the date being converted must fall within 1904 to 2040 of the Gregorian calendar.<BR><BR>This type of conversion is important when you work with a script system that uses a calendar system other than the Gregorian. Because you cannot write a long date-time value to the clock chip, you must first convert the long date-time value (if possible) to a standard date-time value. See <A HREF=#MARKER-9-63>"Working With Different Calendar Systems" beginning on page 4-16</A> for more information about calendar systems.
<LI>To access a date and time through a date-time record instead of a long date-time record, truncate the long date-time record so just the <CODE>year</CODE> through <CODE>dayOfWeek</CODE> fields are left. Once again, the year of the date being converted must fall within 1904 to 2040 of the Gregorian calendar. 
<LI>To access date-time information through a long date-time value instead of a date-time record, use the <CODE>DateToSeconds</CODE> procedure to convert the date and time to a number of seconds. Then set the <CODE>lHigh</CODE> field of a long date-time conversion record (described on <A HREF=OSUtilities-99.html#MARKER-9-89>page 4-25</A>) to 0 and the <CODE>lLow</CODE> field to the total number of seconds since midnight, January 1, 1904.
<LI>To access date-time information through a long date-time record (described on <A HREF=OSUtilities-100.html#MARKER-9-92>page 4-26</A>) instead of a standard date-time value, use the <CODE>SecondsToDate</CODE> procedure to translate the number of seconds to a date and time. Then set the <CODE>oldDate</CODE> field of the long date-time record to the date-time record, and set the <CODE>eraAlt</CODE> field to 0. 
<LI>To access date-time information through a date-time value instead of long date-time record, use the <CODE>LongDateToSeconds</CODE> procedure to translate the date and time to a number of seconds. Then truncate the long date-time value (returned by the <CODE>LongDateToSeconds</CODE> procedure) to just the low-order 32 bits. The year of the date being converted must fall within 1904 to 2040 in the Gregorian calendar. <P>
</UL>
 The Gregorian calendar is the default for converting to and from the long date-time forms. The current range allowed in conversion is roughly 30,000 B.C. to 30,000 A.D.<P>
 To present a date and time value as a date and time text string, you need to use Text Utilities routines, such as the <CODE>DateString</CODE>, <CODE>TimeString</CODE>, <CODE>StringToDate</CODE>, <CODE>StringToTime</CODE>, <CODE>LongDateString</CODE>, and <CODE>LongTimeString</CODE> routines. (Note that the date-string conversion routines do not append strings for A.D. or B.C.) For a complete description of these routines, see <I><A HREF="../Text/Text-2.html">Inside Macintosh: Text.</A></I> <P>
<A NAME=HEADING95-50></A>
<H2><A NAME=MARKER-9-117></A><A NAME=MARKER-2-87></A><A NAME=MARKER-9-58></A>Calculating Dates</H2>
 In the date-time record and long date-time record, any value in the <CODE>month</CODE>, <CODE>day</CODE>, <CODE>hour</CODE>, <CODE>minute</CODE>, or <CODE>second</CODE> field that exceeds the maximum value allowed for that field, will cause a wraparound to a future date and time when you modify the date-time format.<P>
<UL>
<LI>In the <CODE>month</CODE> field, values greater than 12 cause a wraparound to a future year and month.
<LI>In the <CODE>day</CODE> field, values greater than the number of days in a given month cause a wraparound to a future month and day.
<LI>In the <CODE>hour</CODE> field, values greater than 23 cause a wraparound to a future day and hour.
<LI>In the <CODE>minute</CODE> field, values greater than 59 cause a wraparound to a future hour and minute.
<LI>In the <CODE>seconds</CODE> field, values greater than 59 cause a wraparound to a future minute and seconds.<P>
</UL>
 You can use these wraparound facts to calculate and retrieve information about a specific date. For example, you can use a date-time record and the <CODE>DateToSeconds</CODE> and <CODE>SecondsToDate</CODE> procedures to calculate the 300th day of 1994. Set the <CODE>month</CODE> field of the date-time record to 1 and the <CODE>year</CODE> field to 1994. To find the 300th day of 1994, set the <CODE>day</CODE> field of the date-time record to 300. Initialize the rest of the fields in the record to values that do not exceed the maximum value allowed for that field. (Refer to the description of the date-time record on <A HREF=OSUtilities-98.html#MARKER-9-85>page 4-23</A> for a complete list of possible values).<P>
 To force a wrap-around, first convert the date and time (in this example, January 1, 1994) to the number of seconds elapsed since midnight, January 1, 1904 (by calling the <CODE>DateToSeconds</CODE> procedure). Once you have converted the date and time to a number of seconds, you convert the number of seconds back to a date and time (by calling the <CODE>SecondsToDate</CODE> procedure). The fields in the date-time record now contain the values that represent the 300th day of 1994. <A HREF=#MARKER-9-59>Listing 4-6</A> shows an application-defined procedure that calculates the 300th day of the Gregorian calendar year using a date-time record.<P>
<B>Listing 4-6  <A NAME=MARKER-9-59></A>Calculating the 300th day of the year</B><P>
<PRE>
PROCEDURE MyCalculate300Day;
VAR
   myDateTimeRec:    DateTimeRec;
   mySeconds:        LongInt;
BEGIN
   WITH myDateTimeRec DO
   BEGIN
      year := 1994;
      month := 1;
      day := 300;
      hour := 0;
      minute := 0;
      second := 0;
      dayOfWeek := 1;
   END; 
   DateToSeconds (myDateTimeRec, mySeconds);
   SecondsToDate (mySeconds, myDateTimeRec);
END;
</PRE>
 The <CODE>DateToSeconds</CODE> procedure converts the date and time to the number of seconds elapsed since midnight, January 1, 1904, and the <CODE>SecondsToDate</CODE> procedure converts the number of seconds back to a date and time. After the conversions, the values in the <CODE>year</CODE>, <CODE>month</CODE>, <CODE>day</CODE>, and <CODE>dayOfWeek</CODE> fields of the <CODE>myDateTimeRec</CODE> record represent the year, month, day of the month, and day of the week for the 300th day of 1994. If the values in the <CODE>hour</CODE>, <CODE>minute</CODE>, and <CODE>second</CODE> fields do not exceed the maximum value allowed for each field, the values remain the same after the conversions (in this example, the time is exactly 12:00 A.M.). <P>
 Similarly, you can use a long date-time record and the <CODE>LongDateToSeconds</CODE> and <CODE>LongSecondsToDate</CODE> procedures to compute the day of the week corresponding to a given date. <A HREF=#MARKER-9-60>Listing 4-7</A> shows an application-defined procedure that computes and retrieves the name of the day for July 4, 1776. Note that because the year is prior to 1904, it is necessary to use a long date-time record.<P>
<B>Listing 4-7  <A NAME=MARKER-9-60></A>Computing the day of the week</B><P>
<PRE>
PROCEDURE DoDayCalc;
VAR
   myLongDateRec: LongDateRec;
   myLongSeconds: LongDateTime;
   myDayOfWeek:   Integer;
BEGIN
   WITH myLongDateRec DO
   BEGIN
      era := 0;         /*initialize era field*/
      year := 1776;
      month := 7;
      day := 4;
      hour := 0;        /*initialize hour field*/
      minute := 0;      /*initialize minute field*/
      second := 0;      /*initialize second field*/
      dayOfWeek := 1;   /*initialize dayOfWeek field*/
      dayOfYear := 1;   /*initialize dayOfYear field*/
      weekOfYear := 1;  /*initialize weekOfYear field*/
      pm := 1;          /*initialize pm field*/
   END;
   LongDateToSeconds (myLongDateRec, myLongSeconds);
   LongSecondsToDate (myLongSeconds, myLongDateRec);
   myDayOfWeek := myLongDateRec.dayOfWeek;
END;
</PRE>
 The <CODE>LongDateToSeconds</CODE> procedure converts the date and time to the number of seconds, and the <CODE>LongSecondsToDate</CODE> procedure converts the number of seconds back to a date and time. After the conversions, the value in the <CODE>dayOfWeek</CODE> field of the <CODE>myLongDateRec</CODE> record represent the day of the week corresponding to July 4, 1776. If the values in the <CODE>hour</CODE>, <CODE>minute</CODE>, and <CODE>second</CODE> fields do not exceed the maximum value allowed for each field, the values remain the same after the conversions (in this example, the time is exactly 12:00 A.M.). The values in the <CODE>dayOfYear</CODE>, <CODE>weekOfYear</CODE>, and <CODE>pm</CODE> fields correspond to the date July 4, 1776 and the time 12:00 A.M.<A NAME=MARKER-2-61></A><A NAME=MARKER-2-202></A><P>
<A NAME=HEADING95-66></A>
<H2><A NAME=MARKER-9-63></A>Working With Different Calendar Systems</H2>
 The additional fields and wider ranges allowed by the long date-time record can help you to do calculations and conversions for different calendar systems. For example, the date January 1, 1993 in the Gregorian calendar year converts to 7 Rajab 1413 in the Arabic Civil Lunar Calendar (CLC) and 4 Tevet 5753 in the Jewish calendar; the years 1413 and 5753 are outside of the <CODE>year</CODE> field's range in the date-time record.<P>
<DL>
<DT><B>Note</B>
<DD><A NAME=MARKER-2-51></A><A NAME=MARKER-9-79></A>Depending on the country, the change from the Julian calendar to the Gregorian calendar occurred in different years. In western European countries, the change occurred in 1582; in Russia, the calendar changed in 1918. In these countries, dates before the calendar change should use the Julian calendar for conversion. (The Julian calendar differs from the Gregorian calendar by three days every four centuries.)<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
 <A NAME=MARKER-9-76></A>In addition, the beginning of the year for one calendar system falls on different dates in other calendar systems. <A HREF=#MARKER-9-5>Table 4-1</A> shows the equivalent dates for the first day of the calendar year in the Gregorian, Arabic CLC, and Jewish calendars.
<TABLE BORDER="0" CELLPADDING=3>
<CAPTION><A NAME=MARKER-9-5></A><B>Table 4-1 Equivalent dates in the Gregorian, Arabic CLC, and Jewish calendars</B></CAPTION>
<TH>Gregorian calendar<TH>Arabic CLC<TH>Jewish calendar<TR>
<TD>January 1, 1993<TD>7 Rajab 1413<TD>4 Tevet 5753<TR>
<TD>June 20, 1993<TD>1 Muharram 1414<TD>1 Tammuz 5753<TR>
<TD>September 16, 1993<TD>29 Rabi I 1414<TD>1 Tishri 5754</TABLE>
<P>
 Converting from one calendar system to another produces different values in the <CODE>dayOfYear</CODE> and <CODE>weekOfYear</CODE> fields of a long date-time record. For example, assuming all the data for the date 1 Muharram 1414 is correctly put into a long date-time record, the <CODE>dayOfYear</CODE> field value is 1, and the <CODE>weekOfYear</CODE> value is also 1. Converting this date to the Gregorian calendar results in June 20, 1993. The <CODE>dayOfYear</CODE> field value is then 171, and the <CODE>weekOfYear</CODE> value is 26. <A HREF=#MARKER-9-6>Table 4-2</A> shows these values.
<TABLE BORDER="0" CELLPADDING=3>
<CAPTION><A NAME=MARKER-9-6></A><B>Table 4-2 Values for the <EM>dayOfYear</EM> and <EM>weekOfYear</EM> fields for the date 1 Muharram 1414 and equivalent values in the Gregorian calendar</B></CAPTION>
<TH>LongDateRec field<TH>Arabic CLC<TH>Gregorian calendar<TR>
<TD><CODE>dayOfYear</CODE><TD>1<TD>171<TR>
<TD><CODE>weekOfYear</CODE><TD>1<TD>26</TABLE>
<P>
<DL>
<DT><B>Note</B>
<DD>Language-specific information, such as the name of the day, name of the month, and so on, are stored in the international resources. The international resources are provided by a script system, and the information in these resources varies according to the language associated with the script system.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
 <A HREF=#MARKER-9-4>Table 4-3</A> shows how some of the fields in the long date-time record are set to show the first day of the year 1414 in the Arabic CLC and the equivalent dates in the Gregorian and Jewish calendars. 
<TABLE BORDER="0" CELLPADDING=3>
<CAPTION><A NAME=MARKER-9-4></A><B>Table 4-3 Comparison of settings in fields of the long date-time record for Arabic CLC, Gregorian, and Jewish calendars</B></CAPTION>
<TH>Field of a long date-time record<TH>Arabic CLC calendar<TH>Gregorian calendar<TH>Jewish calendar<TR>
<TD><CODE>era</CODE><TD>0<TD>0<TD>0<TR>
<TD><CODE>year</CODE><TD>1413<TD>1993<TD>5753<TR>
<TD><CODE>month</CODE><TD>1<TD>6<TD>&nbsp;<TR>
<TD><CODE>day</CODE><TD>1<TD>21<TD>&nbsp;<TR>
<TD><CODE>...</CODE><TD>&nbsp;<TD>&nbsp;<TD>&nbsp;<TR>
<TD><CODE>dayOfWeek</CODE><TD>4<TD>2<TD>3<TR>
<TD><CODE>dayOfYear</CODE><TD>1<TD>172<TD>&nbsp;<TR>
<TD><CODE>weekOfYear</CODE><TD>1<TD>26<TD>&nbsp;</TABLE>
<P>
<DL>
<DT><B>Note</B>
<DD>The Arabic script system supports two lunar calendars: the astronomical lunar calendar (ALC) and the civil lunar calendar (CLC). The Macintosh user may choose either of the Arabic calendars or the Gregorian calendar by clicking buttons in the Arabic Calendar control panel.  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
<DD>The Hebrew script system supports the Jewish calendar besides the Gregorian calendar.  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
<DD>For more information on the different calendar systems supported by localized versions of the Macintosh system software, see <I>Guide to Macintosh Software Localization</I>.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
 For calendars that have more than seven day names and 12 month names (for example, the Jewish calendar sometimes has 13 months), you use the <CODE>'itl1'</CODE> resource, defined by the <CODE>Itl1ExtRec</CODE> data type. To get more information on the format of the <CODE>'itl1'</CODE> resource, see the appendix "International Resources" in <I><A HREF="../Text/Text-2.html">Inside Macintosh: Text</A></I>.<P>
<A NAME=HEADING95-77></A>
<H2><A NAME=MARKER-2-67></A><A NAME=MARKER-9-68></A>Handling Geographic Location and Time-Zone Data</H2>
 <A NAME=MARKER-2-29></A><A NAME=MARKER-2-70></A><A NAME=MARKER-2-71></A>Geographic locations and time zones can affect date and time information. For example, time-zone information can be used to derive the Greenwich mean time (GMT) at which a  document or mail message was created. With this information, when the document is received by an application or user in a different time zone, the creation date and time are correct. Otherwise, documents can appear to be created after they are read (for example, a user creates a message in Tokyo on Tuesday and sends it to San Francisco, where it is received and read on Monday). Geographic location information can also be used by applications that require it.<P>
 The geographic location and time-zone information for a particular Macintosh computers are stored in parameter RAM. You can work with this information through the <CODE>ReadLocation</CODE> and <CODE>WriteLocation</CODE> procedures. These procedures use the geographic location record (of date type <CODE>MachineLocation</CODE>) to help you read and store latitude, longitude, daylight saving time (DST), and GMT values. <P>
<PRE>
TYPE MachineLocation =              {geographic location record}
RECORD
   latitude:         Fract;         {latitude}
   longitude:        Fract;         {longitude}
   CASE Integer OF
   0:
      (dlsDelta:     SignedByte);   {daylight saving time}
   1:
      (gmtDelta:     LongInt);      {Greenwich mean time}
END;
</PRE>
 <A NAME=MARKER-2-72></A>The daylight savings time value is a signed byte value that you can use to specify the offset for the <CODE>hour</CODE> field--whether to add 1 hour, subtract 1 hour, or make no change at all.<P>
 The Greenwich mean time value is in seconds east of GMT. For example, San Francisco is at -28,800 seconds (8 hours * 3,600 seconds per hour) east of GMT. <P>
 If the geographic location record has never been set, all fields contain 0. <P>
 <A NAME=MARKER-2-73></A>Generally, latitude and longitude are measured in degrees. These values also can be thought of as fractions of a great circle. <P>
 Latitude and longitude information is stored in the geographic location record as values of type <CODE>Fract</CODE>. These values give accuracy to within 1 foot, which should be sufficient for most purposes. For example, the <CODE>Fract</CODE> value 1.0 equals 90 degrees; -1.0 equals -90 degrees; and -2.0 equals -180 degrees. <P>
 To store latitude and longitude values, you need to convert them first to the <CODE>Fixed</CODE> data type, then to the <CODE>Fract</CODE> data type. You can use the Operating System Utilities routines <CODE>Long2Fix</CODE> and <CODE>Fix2Fract</CODE> to accomplish this task. <A HREF=#MARKER-9-74>Listing 4-8</A> is an application-defined procedure that converts San Francisco's latitude and longitude to <CODE>Fract</CODE> values, then writes the <CODE>Fract</CODE> values to parameter RAM using the <CODE>WriteLocation</CODE> procedure. <P>
<B>Listing 4-8  <A NAME=MARKER-9-74></A>Converting latitude and longitude to <EM>Fract</EM> values</B><P>
<PRE>
PROCEDURE MyConvertLatLong;
VAR
   myLatitude, myLongitude:         LongInt;
   fixedLatitude, fixedLongitude:   Fixed;
   latFract, longFract:             Fract;
   myLocation:                      MachineLocation;
BEGIN
   myLatitude:= 37.48;                    {degrees latitude}
   myLongitude:= 122.24;                  {degrees longitude}
   {convert from long to fixed data type}
   fixedLatitude:= Long2Fix(myLatitude);
   fixedLongitude:= Long2Fix(myLongitude);

   {convert from fixed to Fract data type}
   latFract:= Fix2Frac(fixedLatitude);    
   longFract:= Fix2Frac(fixedLongitude);

   {write latitude and logitude to myLocation}
   myLocation.latitude:= latFract;
   myLocation.longitude:= longFract;

   {write latitude and longitude to parameter RAM}
   WriteLocation(myLocation);             

END;
</PRE>
 To read the latitude and longitude values from parameter RAM, you use the <CODE>ReadLocation</CODE> procedure. To convert these values to a degrees format, you need to convert the <CODE>Fract</CODE> values first to the <CODE>Fixed</CODE> data type, then to the <CODE>LongInt</CODE> data type. You can use the Mathematical and Logical Utilities routines <CODE>Fract2Fix</CODE> and <CODE>Fix2Long</CODE> to accomplish this task. (For more information on the <CODE>Fract</CODE> data type and the conversion routines <CODE>Long2Fix</CODE>, <CODE>Fix2Fract</CODE>, <CODE>Fract2Fix</CODE>, and <CODE>Fix2Long</CODE>, see the chapter "Mathematical and Logical Utilities" in this book.) <P>
 The <CODE>gmtDelta</CODE> field of the geographic location record is a 3-byte value contained in a long word, so you must take care to get and set it properly. <A HREF=#MARKER-9-75>Listing 4-9</A> shows an application-defined function for obtaining the value of <CODE>gmtDelta</CODE>. <P>
<B>Listing 4-9  <A NAME=MARKER-9-75></A>Getting <EM>gmtDelta</EM></B><P>
<PRE>
FUNCTION MyGetGmtDelta (myLocation: MachineLocation): LongInt;
VAR
   internalGmtDelta: LongInt;
BEGIN
   WITH myLocation DO 
   BEGIN
      internalGmtDelta := BitAnd(gmtDelta, $00FFFFFF);
      IF BitTst(internalGmtDelta, 23) THEN   
                                       {test sign extend bit}
         internalGmtDelta := BitOr(internalGmtDelta, $FF000000);
      MyGetGmtDelta := internalGmtDelta;
   END;
END;
</PRE>
 When writing <CODE>gmtDelta</CODE>, you should preserve the value of <CODE>dlsDelta</CODE>. <A HREF=#MARKER-9-76>Listing 4-10</A> shows an application-defined procedure that writes <CODE>gmtDelta</CODE> while preserving the value of <CODE>dlsDelta</CODE>.<P>
<B>Listing 4-10  Setting <EM>gmtDelta</EM><A NAME=MARKER-9-76></A></B><P>
<PRE>
PROCEDURE MySetGmtDelta (VAR myLocation: Location; 
                          myGmtDelta: LongInt);
VAR
   tempSignedByte: SignedByte;
BEGIN
   WITH myLocation DO 
   BEGIN
      tempSignedByte := dlsDelta;         {preserve dlsDelta}
      gmtDelta := myGmtDelta;             {write gmtDelta}
      dlsDelta := tempSignedByte;         {restore dlsDelta}
   END;
END;
</PRE>
 Note that you should mask off the top byte of the long word containing <CODE>gmtDelta</CODE> because it is reserved.<A NAME=MARKER-2-76></A><A NAME=MARKER-2-78></A><P>
<A NAME=HEADING95-97></A>
<H2><A NAME=MARKER-2-28></A>Determining the Measurement System</H2>
 To implement measuring devices in applications, such as rulers in a word processor or in drawing applications, you need to determine which measurement system your application should use. You can use the <CODE>IsMetric</CODE> function to determine if the measurement system needs to be the metric system or the English system. <A NAME=MARKER-2-80></A>The <CODE>IsMetric</CODE> function reads the numeric-format resource (resource type <CODE>'itl0'</CODE>) of the current script system to determine whether the user is using the metric system or the English system. <P>
 <A HREF=#MARKER-9-82>Listing 4-11</A> shows an application-defined procedure that uses the result of the <CODE>IsMetric</CODE> function to determine which application-defined ruler setup to use for a document window.<P>
<B>Listing 4-11  <A NAME=MARKER-9-82></A>Getting the current units of measurement</B><P>
<PRE>
PROCEDURE DoRuler (window: WindowPtr);
VAR
   myMeasure: BOOLEAN;           {response returned by IsMetric}
BEGIN
   myMeasure := IsMetric;
   IF myMeasure = TRUE THEN      {metric system is default}
      DoMetricRulerSetup         {set up metric system ruler}
   ELSE 
      DoEnglishRulerSetup;       {set up English system ruler}
END;
</PRE>
 If you want to use a measurement system different from that of the current script, you need to override the value of the <CODE>metricSys</CODE> field in the current numeric-format resource (resource type <CODE>'itl0'</CODE>). You can do this by using your own version of the numeric-format resource instead of the current script system's default international resources. See the chapter "Script Manager" in <I><A HREF="../Text/Text-2.html">Inside Macintosh: Text</A></I> for information on how to replace a script system's default international resources. <P>
<A NAME=HEADING95-103></A>
<H2>Determining the Number of Elapsed Microseconds</H2>
 Your application can use the <CODE>Microseconds</CODE> procedure to obtain the number of elapsed microseconds since system startup time. You can use the value returned by the <CODE>Microseconds</CODE> procedure to time an event. For example, <A HREF=#MARKER-9-82>Listing 4-11</A> shows an application-defined function MyEventTimer that computes and returns the time it takes to execute an application-defined procedure <CODE>DoMyEvent</CODE>. The application-defined function <CODE>MyCalulateElapsedTime</CODE> function uses the returned value of the <CODE>Microseconds</CODE> procedure to compute the time it takes to execute the <CODE>DoMyEvent</CODE> procedure.<P>
<B>Listing 4-12  <A NAME=MARKER-9-82></A>Timing an event using the <EM>Microseconds</EM> procedure</B><P>
<PRE>
FUNCTION MyEventTimer: UnsignedWide;
VAR
   myStartTime:UnsignedWide;
   myEndTime: UnsignedWide;
BEGIN
   Microseconds(&amp;myStartTime);
   DoMyEvent;
   Microseconds(&amp;myEndTime);
   MyEventTimer := MyComputeElapsedTime(&amp;myStartTime, &amp;myEndTime);
END;
</PRE>
 Because there is no compiler support for 64-bit integers, you must write an application-defined routine that calculates the elapsed time; you cannot obtain the elapsed time by subtracting the value in the <CODE>myStartTime</CODE> parameter from the value in the <CODE>myEndTime</CODE> parameter.<P>

</BLOCKQUOTE>
<HR>
<center>
<A HREF="OSUtilities-94.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="OSUtilities-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="OSUtilities-222.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="OSUtilities-96.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="OSUtilities-3.html">&copy; Apple Computer, Inc.</A><br>6 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>  
