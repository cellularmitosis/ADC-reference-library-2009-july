<html><head><title>What Is Enterprise Objects Framework?</title></head><body bgcolor="#ffffff"><!--start of banner --><!--#include virtual="/includes/framesetheader" --><!-- end of banner --><!--start of path --><font face="Geneva,Helvetica,Arial" size="1"><b>PATH<spacer type="horizontal" size="5">&nbsp;</b> <a href="../../../../../../index.html" target="_top">Documentation</a> <b>&gt;</b> <a href="../../../../../webobjects.html" target="_top">WebObjects 4.5</a> <b>&gt;</b>EOF Developer's Guide</font><br><br><!--end of path --> <a href="WhatsEOF.html"><IMG SRC="ArrowUp.gif">Table of Contents</a> <a href="WhatsEOF3.html"><IMG SRC="ArrowLeft.gif">Previous Section</a> <a name="6561"><h1> From Objects to Database</h1></a><a name="6414">After your program has accumulated changes to enterprise objects, it needs to push those changes back to the database. Enterprise Objects Framework manages this process, too, analyzing the objects for changes, generating corresponding database operations, and executing those operations to synchronize the database with in-memory enterprise objects. The Framework has mechanisms for ensuring that the integrity of your data is maintained between your application and the database:<p></a><ul><a name="7127"><li>Validation</a><a name="7092"><li>Referential integrity enforcement</a><a name="6303"><li>Automatic primary and foreign key generation</a><a name="7118"><li>Transaction management</a><a name="7119"><li>Locking</a></ul><a name="7130">Each of these is described in the following sections.<p></a><a name="11579"><h2> Validation</h2></a><a name="11580">A good part of your application's business logic is usually validation-for example, verifying that customers don't exceed their credit limits, that return dates don't come before their corresponding check out dates, and so on. In your enterprise object classes, you implement methods that check for invalid data, and the framework automatically invokes them before saving anything to the database.<p></a><a name="7134"><h2> Referential Integrity Enforcement</h2></a><a name="7164">Enterprise Objects Framework allows you to specify rules governing the &#32;relationships between objects. You can specify whether a to-one relationship is optional or mandatory. For example, you can require that all departments have a location (mandatory), but not require that every employee have a manager (optional).<p></a><a name="7173">You can also specify delete rules for relationships. For example, when you delete a department object, you can specify that:<p></a><ul><a name="7174"><li>All the employees in that department are also deleted (a cascading delete).</a><a name="7175"><li>All the employees in that department are updated to have no department (nullify).</a><a name="7176"><li>The department deletion is rejected if it has any employees (deny).</a></ul><a name="7179">For more information on Framework's referential integrity enforcement, see the chapter <a href="EOsI.html#14081"> "Designing Enterprise Objects"</a>. To learn how to define these rules in the EOModeler application, see the book <em>Enterprise Objects Framework Tools and Techniques</em>.<p></a><a name="7135"><h2> Automatic Primary and Foreign Key Generation</h2></a><a name="7191">With Enterprise Objects Framework, you don't have to maintain database artifacts such as database primary and foreign key values into your application. Database primary and foreign keys aren't usually meaningful parts of a business model; rather, they're attributes created in &#32;a relational database to express relationships between entities. For &#32;example, the primary key (MOVIE_ID) for a movie doesn't have &#32;any &#32;meaning to users. Users identify movies by their titles.<p></a><a name="7196">Enterprise Objects Framework keeps track of primary and foreign key &#32;data for you. You don't have to represent that information in your enterprise objects, and you don't have to worry about generating and propagating key values.<p></a><a name="7217">For information on eliminating database artifacts from your object model, see the chapter <a href="EOsI.html#14081"> "Designing Enterprise Objects"</a>. For &#32;information on how the Framework generates primary key values, see the chapter <a href="FAQ.html#7958"> "Answers to Common Design Questions"</a>. <p></a><a name="7136"><h2> Transaction Management</h2></a><a name="7227">For the most part, Enterprise Objects Framework handles transactions for you. You don't have to worry about beginning, committing, or rolling back transactions unless you want to fine-tune transaction management behavior. The Framework uses the native transaction management features of your database to group database operations that correspond to &#32;the changes that have been made to enterprise objects in memory. For &#32;more information, see the chapter <a href="BehindSc.html#8585"> "Behind the Scenes"</a>.<p></a><a name="7228">Additionally, the Framework provides a separate in-memory transaction management feature. You can create nested contexts in which a child context's changes are folded into the parent context only upon successful completion of an in-memory operation. For more information on nested contexts, see the chapter <a href="AppConfs.html#15898"> "Application Configurations"</a>.<p></a><a name="7137"><h2> Locking</h2></a><a name="7229">The Framework offers three types of locking:<p></a><ul><a name="7234"><p><li><em>Pessimistic</em>. With this strategy, Enterprise Objects Framework uses your database server's native locking mechanism to lock rows as they're fetched into your application. If you try to fetch an object that someone else has already fetched, the operation will fail because the corresponding database row is locked. This approach prevents update conflicts by never allowing two users to look at the same object at the same time.</a><a name="7235"><p><li><em>Optimistic</em>. With this strategy, update conflicts aren't detected until you try to save an object's changes to the database. At this point, the Framework checks the database row to see if it's changed since your object was fetched. If the row has been changed, it aborts the save operation.</a><a name="7291"><p>Enterprise Objects Framework determines that a database row has changed since its corresponding object was fetched using a technique called <em>snapshotting</em>. When the Framework fetches an object from the database, it records a <em>snapshot</em> of the state of the corresponding database row. When changes to an object are saved to the database, the snapshot is compared with the corresponding database row to ensure that the row data hasn't changed since the object was last fetched. For more information on snapshots, see &#32;the EODatabaseContext class specification in the <em>Enterprise &#32;Objects Framework Reference</em>.<p></a><a name="7236"><p><li><em>On-Demand</em>. This approach is a mixture of the pessimistic and optimistic strategies. With on-demand locking, you lock an object after you fetch it but before you attempt to modify it. When you try to get a lock on the object, it can fail for one of two reasons: the corresponding database row has changed since you fetched the object (optimistic locking), or because someone else already has a &#32;lock on the row (pessimistic locking).</a></ul><a name="7255">For more information on Enterprise Objects Framework's locking strategies, see the chapter <a href="BehindSc.html#8585"> "Behind the Scenes"</a>.<p></a><P> <a href="WhatsEOF.html"><IMG SRC="ArrowUp.gif">Table of Contents</a> <a href="WhatsEOF5.html"><IMG SRC="ArrowRight.gif">Next Section</a><P></body></html>