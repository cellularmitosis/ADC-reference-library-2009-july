<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>Play Video Sample - /RequestVideo.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxGraphicsImaging-date.html">Graphics & Imaging</a> &gt; <A HREF="javascript:location.replace('index.html');">Play Video Sample</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Not Recommended Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>The information in this document is <strong>Not Recommended</strong> and should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/GraphicsImaging/index.html" target="_blank">Reference Library > Graphics & Imaging</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">Play Video Sample</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/RequestVideo.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/PlayVideo.c</option>
<option value="listing2.html">/RequestVideo.c</option>
<option value="listing3.html">/RequestVideo.h</option>
<option value="listing4.html">/verbose debug code/PlayVideo.c</option>
<option value="listing5.html">/verbose debug code/RequestVideo.c</option></select>
				</p>
				</form>
				<p><strong><a href="Play_Video_Sample.zip">Download Sample</a></strong> (&#147;Play_Video_Sample.zip&#148;, 63.1K)<BR>
<strong><a href="Play_Video_Sample.dmg">Download Sample</a></strong> (&#147;Play_Video_Sample.dmg&#148;, 126.7K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*  File:    RequestVideo.c  Contains:  RequestVideo demonstrates the usage of the Display Manager introduced        with the PowerMacs and integrated into the system under System 7.5. With        the RequestVideo sample code library, developers will be able to explore        the Display Manager API by changing bit depth and screen resolution on        multisync displays on built-in, NuBus, and PCI based video. Display Manager 1.0        is built into the Systems included with the first PowerMacs up through System 7.5.        Display Manager 2.0 is included with the release of the new PCI based PowerMacs,        and will be included in post 7.5 System Software releases.           It is a good idea to reset the screen(s) to the original setting before exit        since the call to RVSetVideoAsScreenPrefs() may not do the right thing under        Display Manager 1.0 with certain video drivers.          For information on the use of this sample code, please the documentation in the Read Me file  Written by: Eric Anderson    Copyright:  Copyright &copy; 1995-1999 by Apple Computer, Inc., All Rights Reserved.        You may incorporate this Apple sample source code into your program(s) without        restriction. This Apple sample source code has been provided &quot;AS IS&quot; and the        responsibility for its operation is yours. You are not permitted to redistribute        this Apple sample source code as &quot;Apple sample source code&quot; after having made        changes. If you're going to re-distribute the source, we require that you make        it clear in the source that the code was descended from Apple sample source        code, but that you've made changes.  Change History (most recent first):        7/15/1999  Karl Groethe  Updated for Metrowerks Codewarror Pro 2.1        1/28/97    ewa        Updated source for Metrowerks CodeWarrior 11        6/27/96    dal        RVRequestVideoSetting() no longer requires Slot Manager DM 2.0 can be used.        6/27/96    dal        Added check for Display Library before making DM 2.0 calls.        5/31/95    ewa        Added RVGetCurrentVideoSetting and RVConfirmVideoRequest routines                      to make it easy to revert back to where you came from and to give                      the user a chance to confirm the new setting if the new mode was                      valid (ie: the card supports it) but not safe (the monitor may not).        5/24/95    ewa        Give the kAllValidModesBit requestFlags option for safe only or all                      valid resolution timings.          */#include &quot;RequestVideo.h&quot;// Internal includes#include &lt;Dialogs.h&gt;#include &lt;ROMDefs.h&gt;#include &lt;Devices.h&gt;#include &lt;Errors.h&gt;#include &lt;Gestalt.h&gt;#include &lt;Memory.h&gt;#include &lt;Palettes.h&gt;#include &lt;Slots.h&gt;#include &lt;Displays.h&gt;#include &lt;ConditionalMacros.h&gt;  //DL#include &lt;CodeFragments.h&gt;  //DL#if 0//#include &lt;StdIO.h&gt;//#include &lt;stdlib.h&gt;#else#define abs(x) ( ( (x) &lt; 0 ) ? -(x) : (x) )#endif//--------------------------------------------------------------//// Internal defines, structs, typedefs, and routine declarations////--------------------------------------------------------------#define    KMonoDev      0            // false (handy definitions for gdDevType settings)#define    kColorDev      1            // true#define    char_Enter      0x03          // for our filter proc#define    char_Return      0x0D          //#define    iRevertItem      1            // User buttons#define    iConfirmItem    2            //#define    kSecondsToConfirm  8            // seconds before confirm dialog is taken down#define    rConfirmSwtchAlrt  2735          // ID of alert dialogstruct DepthInfo {  VDSwitchInfoRec      depthSwitchInfo;      // This is the switch mode to choose this timing/depth  VPBlock          depthVPBlock;        // VPBlock (including size, depth and format)};typedef struct DepthInfo DepthInfo;struct ListIteratorDataRec {  VDTimingInfoRec      displayModeTimingInfo;    // Contains timing flags and such  unsigned long      depthBlockCount;      // How many depths available for a particular timing  DepthInfo        *depthBlocks;        // Array of DepthInfo};typedef struct ListIteratorDataRec ListIteratorDataRec;void GetRequestTheDM1Way (    VideoRequestRecPtr requestRecPtr,                GDHandle walkDevice);void GetRequestTheDM2Way (    VideoRequestRecPtr requestRecPtr,                GDHandle walkDevice,                DMDisplayModeListIteratorUPP myModeIteratorProc,                DMListIndexType theDisplayModeCount,                DMListType *theDisplayModeList);pascal void ModeListIterator (  void *userData,                DMListIndexType itemIndex,                DMDisplayModeListEntryPtr displaymodeInfo);Boolean FindBestMatch (      VideoRequestRecPtr requestRecPtr,                short bitDepth,                unsigned long horizontal,                unsigned long vertical);void GravitateMonitors (void);pascal Boolean ConfirmAlertFilter (DialogRef dlg, EventRecord *evt, short *itemHit);//--------------------------------------------------------------//// Implementation of sample code////--------------------------------------------------------------OSErr RVSetVideoRequest (VideoRequestRecPtr requestRecPtr){  GDHandle    aMonitor;  Boolean      displayMgrPresent;  unsigned long  displayMgrVersion;  OSErr      err;  Boolean      isColor;  long      value = 0;  Gestalt(gestaltDisplayMgrVers, (long*)&amp;displayMgrVersion);  Gestalt(gestaltDisplayMgrAttr,&amp;value);  displayMgrPresent=value&amp;(1&lt;&lt;gestaltDisplayMgrPresent);  if (displayMgrPresent)  {    if (requestRecPtr-&gt;displayMode &amp;&amp; requestRecPtr-&gt;depthMode)    {      if (requestRecPtr-&gt;availBitDepth == 1)  // Based on avail bit depth,         isColor = KMonoDev;          // set the device to a mono device, or      else isColor = kColorDev;        // set the device to a color device      SetDeviceAttribute(requestRecPtr-&gt;screenDevice,gdDevType,isColor);                // see how many monitors we have, aMonitor will be nil if we have only one.      aMonitor = DMGetFirstScreenDevice (dmOnlyActiveDisplays);      // get the first guy      aMonitor = DMGetNextScreenDevice ( aMonitor, dmOnlyActiveDisplays );  // get the next guy            if (nil == aMonitor || displayMgrVersion &gt;= 0x00020000)      {        // only call DMSetDisplayMode if we have one monitor or DM2.0 is installed        // since DM1.0 does not automatically gravitate monitors and our gravitate code        // is not implemented.        err = DMSetDisplayMode(  requestRecPtr-&gt;screenDevice,  // GDevice            requestRecPtr-&gt;displayMode,            // DM1.0 uses this            &amp;requestRecPtr-&gt;depthMode,            // DM1.0 uses this            (unsigned long) &amp;(requestRecPtr-&gt;switchInfo),  // DM2.0 uses this rather than displayMode/depthMode combo            nil);        if (noErr == err)        {          // Do the monitor gravitate here if we are using a version less than DM2.0          if (displayMgrVersion &lt; 0x00020000)            GravitateMonitors ();        }        else if (kDMDriverNotDisplayMgrAwareErr == err)        {          // DM not supported by driver, so all we can do is set the bit depth          err = SetDepth (requestRecPtr-&gt;screenDevice, requestRecPtr-&gt;depthMode, gdDevType, isColor);        }      }      else      {        // we have more than one monitor and DM1.0 is installed, so all we can do is set the bit depth        err = SetDepth (requestRecPtr-&gt;screenDevice, requestRecPtr-&gt;depthMode, gdDevType, isColor);      }            return (err);  // we did try to set the request    }  }  return (-1);  // return a generic error}// This extern should be removed once this function is formally defined in Displays.hextern pascal OSErr DMUseScreenPrefs(Boolean usePrefs, Handle displayState) THREEWORDINLINE(0x303C, 0x03EC, 0xABEB);OSErr RVSetVideoAsScreenPrefs (void){  Handle    displaystate;  Boolean    displayMgrPresent;  long    value = 0;  Gestalt(gestaltDisplayMgrAttr,&amp;value);  displayMgrPresent=value&amp;(1&lt;&lt;gestaltDisplayMgrPresent);  if (displayMgrPresent)  {    DMBeginConfigureDisplays (&amp;displaystate);  // Tell the world it is about to change    DMUseScreenPrefs (true, displaystate);    // Make the change    DMEndConfigureDisplays (displaystate);    // Tell the world the change is over        return (noErr);  // we (maybe) set the world back to a known setting  }  return (-1);  // return a generic error}OSErr RVGetCurrentVideoSetting (VideoRequestRecPtr requestRecPtr){  unsigned long    displayMgrVersion;  OSErr        error = paramErr;  CntrlParam      pBlock;  VDSwitchInfoRec    switchInfo;  AuxDCEHandle    theDCE;  VDSwitchInfoRec    videoMode;      requestRecPtr-&gt;availBitDepth      = 0;  // init to default - you can do it if it is important to you  requestRecPtr-&gt;availHorizontal      = 0;  requestRecPtr-&gt;availVertical      = 0;  requestRecPtr-&gt;availFlags        = 0;  requestRecPtr-&gt;displayMode        = -1;   requestRecPtr-&gt;depthMode        = -1;  requestRecPtr-&gt;switchInfo.csMode    = 0;  requestRecPtr-&gt;switchInfo.csData    = 0;  requestRecPtr-&gt;switchInfo.csPage    = 0;  requestRecPtr-&gt;switchInfo.csBaseAddr  = 0;  requestRecPtr-&gt;switchInfo.csReserved  = 0;    Gestalt(gestaltDisplayMgrVers, (long*)&amp;displayMgrVersion);  if (requestRecPtr-&gt;screenDevice)  {//DL -  must also make sure that Display Library is installed, otherwise//    calling DMGetDisplayMode() will branch to nil.//DL    if (displayMgrVersion &gt;= 0x00020000)#if GENERATINGCFM    if (displayMgrVersion &gt;= 0x00020000 &amp;&amp; (Ptr) DMGetDisplayMode != (Ptr) kUnresolvedCFragSymbolAddress)#else    if (displayMgrVersion &gt;= 0x00020000)#endif    {  // get the info the DM 2.0 way      error = DMGetDisplayMode(requestRecPtr-&gt;screenDevice, &amp;switchInfo);      if (noErr == error)      {        requestRecPtr-&gt;depthMode      = switchInfo.csMode;        requestRecPtr-&gt;displayMode      = switchInfo.csData;         requestRecPtr-&gt;switchInfo.csMode  = switchInfo.csMode;        requestRecPtr-&gt;switchInfo.csData  = switchInfo.csData;      }      return (error);  // we (maybe) set the world back to a known setting    }    else    {  // get the info the DM 1.0 way      videoMode.csMode = -1;    // init to bogus value      videoMode.csData = -1;    // init to bogus value            pBlock.ioNamePtr = nil;      pBlock.ioCRefNum = (*(requestRecPtr-&gt;screenDevice))-&gt;gdRefNum;      pBlock.csCode = cscGetCurMode;      *(Ptr *)&amp;pBlock.csParam[0] = (Ptr)&amp;videoMode;              error = PBStatusSync((ParmBlkPtr )&amp;pBlock);  // ask the driver first....since we trust it the most              if ( noErr == error &amp;&amp; ((-1 == videoMode.csMode) || (-1 == videoMode.csData)) )        error = statusErr;            if (noErr != error)  // if the driver has no clue fill it videoMode by hand as a last resort      {          theDCE = (AuxDCEHandle)GetDCtlEntry((*(requestRecPtr-&gt;screenDevice))-&gt;gdRefNum);                if( theDCE )        {          videoMode.csData = (unsigned char)(*theDCE)-&gt;dCtlSlotId;           videoMode.csMode = (*(requestRecPtr-&gt;screenDevice))-&gt;gdMode;          error = noErr;        }      }      if (noErr == error)  // Set our data      {        requestRecPtr-&gt;displayMode      = videoMode.csData;         requestRecPtr-&gt;depthMode      = videoMode.csMode;        requestRecPtr-&gt;switchInfo.csMode  = videoMode.csMode;        requestRecPtr-&gt;switchInfo.csData  = videoMode.csData;      }      return (error);  // we (maybe) set the world back to a known setting    }  }  return (-1);}pascal Boolean ConfirmAlertFilter(DialogRef theDialog, EventRecord *theEvent, short *itemHit){  char charCode;  Boolean enterORreturn;  Boolean returnValue = false;  WindowRef dialogWindow = GetDialogWindow(theDialog);  //DL  if (0 == GetWRefCon(dialogWindow))    SetWRefCon (dialogWindow,TickCount());  else  {    if (GetWRefCon(dialogWindow) + kSecondsToConfirm * 60 &lt; TickCount())    {      returnValue = true;      theEvent-&gt;what = nullEvent;      *itemHit = 1;    }    else    {      if (theEvent-&gt;what == keyDown)      {        charCode = (char)theEvent-&gt;message &amp; charCodeMask;        enterORreturn = (charCode == (char)char_Return) || (charCode == (char)char_Enter);        if (enterORreturn)        {          theEvent-&gt;what = nullEvent;          returnValue = true;          *itemHit = iRevertItem;          if (enterORreturn &amp;&amp; (0 != (theEvent-&gt;modifiers &amp; optionKey)))          {            *itemHit = iConfirmItem;          }        }      }    }  }  return (returnValue);}OSErr RVConfirmVideoRequest (VideoRequestRecPtr requestRecPtr){  short      alertReturn;    // Alert() return value  ModalFilterUPP  confirmFilterUPP;  // got to have us one of them new fangled UPP thingies    if (requestRecPtr-&gt;availFlags &amp; 1&lt;&lt;kModeValidNotSafeBit)  {  // new mode is valid but not safe, so ask user to confirm    SetCursor(&amp;qd.arrow);                    // have to show the arrow    confirmFilterUPP = NewModalFilterProc (ConfirmAlertFilter);  // create a new modal filter proc UPP    alertReturn = Alert(rConfirmSwtchAlrt, confirmFilterUPP);  // alert the user    DisposeRoutineDescriptor (confirmFilterUPP);        // of course there is no DisposeModalFilterProc...        if (alertReturn != iConfirmItem)      return (-1);              // tell the caller to switch back to a known setting    else return (noErr);            // all is well with the new setting, just leave it  }  return (noErr);                  // the mode was safe, so do nothing}OSErr RVRequestVideoSetting (VideoRequestRecPtr requestRecPtr){  Boolean              displayMgrPresent;  short              iCount = 0;          // just a counter of GDevices we have seen  DMDisplayModeListIteratorUPP  myModeIteratorProc = nil;  // for DM2.0 searches  SpBlock              spBlock;  Boolean              suppliedGDevice;    DisplayIDType          theDisplayID;        // for DM2.0 searches  DMListIndexType          theDisplayModeCount;    // for DM2.0 searches  DMListType            theDisplayModeList;      // for DM2.0 searches  long              value = 0;  GDHandle            walkDevice = nil;      // for everybody//DL START Check for the presence of DM 2.0 before calling DMNewDisplayModeList() and DMDisposeList().  OSErr              gestaltErr;  unsigned long          displayMgrVersion;  Boolean             hasDM2 = false;  Boolean             hasSlotMgr = false;    gestaltErr = Gestalt(gestaltDisplayMgrVers, (long*)&amp;displayMgrVersion);  if (  gestaltErr == noErr &amp;&amp;#if GENERATINGCFM      (Ptr) DMNewDisplayModeList != (Ptr) kUnresolvedCFragSymbolAddress &amp;&amp;      (Ptr) DMDisposeList != (Ptr) kUnresolvedCFragSymbolAddress &amp;&amp;#endif      displayMgrVersion &gt;= 0x00020000  )  {    hasDM2 = true;  }//DL END  Gestalt(gestaltDisplayMgrAttr,&amp;value);  displayMgrPresent=value&amp;(1&lt;&lt;gestaltDisplayMgrPresent);//DL  displayMgrPresent=displayMgrPresent &amp;&amp; (SVersion(&amp;spBlock)==noErr);  // need slot manager  hasSlotMgr = (SVersion(&amp;spBlock)==noErr);  //DL  displayMgrPresent=displayMgrPresent &amp;&amp; (hasDM2 || hasSlotMgr);  //DL - need slot manager only if using DM 1.0.  if (displayMgrPresent)  {    // init the needed data before we start    if (requestRecPtr-&gt;screenDevice)              // user wants a specifc device?    {      walkDevice = requestRecPtr-&gt;screenDevice;      suppliedGDevice = true;    }    else    {      walkDevice = DMGetFirstScreenDevice (dmOnlyActiveDisplays);      // for everybody      suppliedGDevice = false;    }        myModeIteratorProc = NewDMDisplayModeListIteratorProc(ModeListIterator);  // for DM2.0 searches      // Note that we are hosed if somebody changes the gdevice list behind our backs while we are iterating....    // ...now do the loop if we can start    if( walkDevice &amp;&amp; myModeIteratorProc) do // start the search    {      iCount++;    // GDevice we are looking at (just a counter)      if( noErr == DMGetDisplayIDByGDevice( walkDevice, &amp;theDisplayID, false ) )  // DM1.0 does not need this, but it fits in the loop      {        theDisplayModeCount = 0;  // for DM2.0 searches//DL        if (noErr == DMNewDisplayModeList(theDisplayID, 0, 0, &amp;theDisplayModeCount, &amp;theDisplayModeList) )        if (hasDM2 &amp;&amp; noErr == DMNewDisplayModeList(theDisplayID, 0, 0, &amp;theDisplayModeCount, &amp;theDisplayModeList) )        {          // search NuBus &amp; PCI the new kool way through Display Manager 2.0          GetRequestTheDM2Way (requestRecPtr, walkDevice, myModeIteratorProc, theDisplayModeCount, &amp;theDisplayModeList);          DMDisposeList(theDisplayModeList);  // now toss the lists for this gdevice and go on to the next one        }//DL        else        else if (hasSlotMgr)  //DL        {          // search NuBus only the old disgusting way through the slot manager          GetRequestTheDM1Way (requestRecPtr, walkDevice);        }      }    } while ( !suppliedGDevice &amp;&amp; nil != (walkDevice = DMGetNextScreenDevice ( walkDevice, dmOnlyActiveDisplays )) );  // go until no more gdevices    if( myModeIteratorProc )      DisposeRoutineDescriptor(myModeIteratorProc);    return (noErr);  // we were able to get the look for a match  }  return (-1);    // return a generic error}void GetRequestTheDM1Way (VideoRequestRecPtr requestRecPtr, GDHandle walkDevice){  AuxDCEHandle myAuxDCEHandle;  unsigned long  depthMode;  unsigned long  displayMode;  OSErr      error;  OSErr      errorEndOfTimings;  short      height;  short      jCount = 0;  Boolean      modeOk;  SpBlock      spAuxBlock;  SpBlock      spBlock;  unsigned long  switchFlags;  VPBlock      *vpData;  short      width;  myAuxDCEHandle = (AuxDCEHandle) GetDCtlEntry((**walkDevice).gdRefNum);    spBlock.spSlot = (**myAuxDCEHandle).dCtlSlot;  spBlock.spID = (**myAuxDCEHandle).dCtlSlotId;  spBlock.spExtDev = (**myAuxDCEHandle).dCtlExtDev;  spBlock.spHwDev = 0;                // we are going to get this pup  spBlock.spParamData = 1&lt;&lt;foneslot;          // this slot, enabled, and it better be here.  spBlock.spTBMask = 3;                // don't have constants for this yet  errorEndOfTimings = SGetSRsrc(&amp;spBlock);      // get the spDrvrHW so we know the ID of this puppy. This is important                            // since some video cards support more than one display, and the spDrvrHW                            // ID can, and will, be used to differentiate them.    if ( noErr == errorEndOfTimings )  {    // reinit the param block for the SGetTypeSRsrc loop, keep the spDrvrHW we just got    spBlock.spID = 0;                // start at zero,     spBlock.spTBMask = 2;              // 0b0010 - ignore DrvrSW - why ignore the SW side? Is it not important for video?    spBlock.spParamData = (1&lt;&lt;fall) + (1&lt;&lt;foneslot) + (1&lt;&lt;fnext);  // 0b0111 - this slot, enabled or disabled, so we even get 640x399 on Blackbird    spBlock.spCategory=catDisplay;    spBlock.spCType=typeVideo;    errorEndOfTimings = SGetTypeSRsrc(&amp;spBlock);  // but only on 7.0 systems, not a problem since we require DM1.0        // now, loop through all the timings for this GDevice    if ( noErr == errorEndOfTimings ) do    {      // now, loop through all possible depth modes for this timing mode      displayMode = (unsigned char)spBlock.spID;  // &quot;timing mode, ie:resource ref number&quot;      for (jCount = firstVidMode; jCount&lt;= sixthVidMode; jCount++)      {        depthMode = jCount;    // vid mode        error = DMCheckDisplayMode(walkDevice,displayMode,depthMode,&amp;switchFlags,0,&amp;modeOk);          // only if the mode is safe or we override it with the kAllValidModesBit request flag        if (  noErr == error &amp;&amp;            modeOk &amp;&amp;            (  switchFlags &amp; 1&lt;&lt;kNoSwitchConfirmBit ||              requestRecPtr-&gt;requestFlags &amp; 1&lt;&lt;kAllValidModesBit            )          )        {          // have a good displayMode/depthMode combo - now lets look inside          spAuxBlock = spBlock;        // don't ruin the iteration spBlock!!          spAuxBlock.spID = depthMode;    // vid mode          error=SFindStruct(&amp;spAuxBlock);    // get back a new spsPointer          if (noErr == error)          // keep going if no error\xC9          {            spAuxBlock.spID = 0x01;      // mVidParams request            error=SGetBlock (&amp;spAuxBlock);  // use the new spPointer and get back...a NewPtr'ed spResult            if (noErr == error)        // \xC9keep going if no error\xC9            {                // We have data! lets have a look              vpData = (VPBlock*)spAuxBlock.spResult;              height = vpData-&gt;vpBounds.bottom;  // left and top are usually zero              width = vpData-&gt;vpBounds.right;                            if (FindBestMatch (requestRecPtr, vpData-&gt;vpPixelSize, vpData-&gt;vpBounds.right, vpData-&gt;vpBounds.bottom))              {                requestRecPtr-&gt;screenDevice = walkDevice;                requestRecPtr-&gt;availBitDepth = vpData-&gt;vpPixelSize;                requestRecPtr-&gt;availHorizontal = vpData-&gt;vpBounds.right;                requestRecPtr-&gt;availVertical = vpData-&gt;vpBounds.bottom;                requestRecPtr-&gt;displayMode = displayMode;                requestRecPtr-&gt;depthMode = depthMode;                requestRecPtr-&gt;switchInfo.csMode = depthMode;        // fill in for completeness                requestRecPtr-&gt;switchInfo.csData = displayMode;                requestRecPtr-&gt;switchInfo.csPage = 0;                requestRecPtr-&gt;switchInfo.csBaseAddr = 0;                requestRecPtr-&gt;switchInfo.csReserved = 0;                if (switchFlags &amp; 1&lt;&lt;kNoSwitchConfirmBit)                  requestRecPtr-&gt;availFlags = 0;              // mode safe                else requestRecPtr-&gt;availFlags = 1&lt;&lt;kModeValidNotSafeBit;  // mode valid but not safe, requires user validation of mode switch              }              if (spAuxBlock.spResult) DisposePtr ((Ptr)spAuxBlock.spResult);  // toss this puppy when done            }          }        }      }      // go around again, looking for timing modes for this GDevice      spBlock.spTBMask = 2;    // ignore DrvrSW      spBlock.spParamData =  (1&lt;&lt;fall) + (1&lt;&lt;foneslot) + (1&lt;&lt;fnext);  // next resource, this slot, whether enabled or disabled      errorEndOfTimings = SGetTypeSRsrc(&amp;spBlock);  // and get the next timing mode    } while ( noErr == errorEndOfTimings );  // until the end of this GDevice  }}pascal void ModeListIterator(void *userData, DMListIndexType, DMDisplayModeListEntryPtr displaymodeInfo){  unsigned long      depthCount;  short          iCount;  ListIteratorDataRec    *myIterateData    = (ListIteratorDataRec*) userData;  DepthInfo        *myDepthInfo;    // set user data in a round about way  myIterateData-&gt;displayModeTimingInfo    = *displaymodeInfo-&gt;displayModeTimingInfo;    // now get the DMDepthInfo info into memory we own  depthCount = displaymodeInfo-&gt;displayModeDepthBlockInfo-&gt;depthBlockCount;  myDepthInfo = (DepthInfo*)NewPtrClear(depthCount * sizeof(DepthInfo));  // set the info for the caller  myIterateData-&gt;depthBlockCount = depthCount;  myIterateData-&gt;depthBlocks = myDepthInfo;  // and fill out all the entries  if (depthCount) for (iCount=0; iCount &lt; depthCount; iCount++)  {    myDepthInfo[iCount].depthSwitchInfo =       *displaymodeInfo-&gt;displayModeDepthBlockInfo-&gt;depthVPBlock[iCount].depthSwitchInfo;    myDepthInfo[iCount].depthVPBlock =       *displaymodeInfo-&gt;displayModeDepthBlockInfo-&gt;depthVPBlock[iCount].depthVPBlock;  }}void GetRequestTheDM2Way (  VideoRequestRecPtr requestRecPtr,              GDHandle walkDevice,              DMDisplayModeListIteratorUPP myModeIteratorProc,              DMListIndexType theDisplayModeCount,              DMListType *theDisplayModeList){  short          jCount;  short          kCount;  ListIteratorDataRec    searchData;  searchData.depthBlocks = nil;  // get the mode lists for this GDevice  for (jCount=0; jCount&lt;theDisplayModeCount; jCount++)    // get info on all the resolution timings  {    DMGetIndexedDisplayModeFromList(*theDisplayModeList, jCount, 0, myModeIteratorProc, &amp;searchData);        // for all the depths for this resolution timing (mode)...    if (searchData.depthBlockCount) for (kCount = 0; kCount &lt; searchData.depthBlockCount; kCount++)    {      // only if the mode is valid and is safe or we override it with the kAllValidModesBit request flag      if  (  searchData.displayModeTimingInfo.csTimingFlags &amp; 1&lt;&lt;kModeValid &amp;&amp;           (  searchData.displayModeTimingInfo.csTimingFlags &amp; 1&lt;&lt;kModeSafe ||            requestRecPtr-&gt;requestFlags &amp; 1&lt;&lt;kAllValidModesBit          )        )      {        if (FindBestMatch (  requestRecPtr,                  searchData.depthBlocks[kCount].depthVPBlock.vpPixelSize,                  searchData.depthBlocks[kCount].depthVPBlock.vpBounds.right,                  searchData.depthBlocks[kCount].depthVPBlock.vpBounds.bottom))        {          requestRecPtr-&gt;screenDevice = walkDevice;          requestRecPtr-&gt;availBitDepth = searchData.depthBlocks[kCount].depthVPBlock.vpPixelSize;          requestRecPtr-&gt;availHorizontal = searchData.depthBlocks[kCount].depthVPBlock.vpBounds.right;          requestRecPtr-&gt;availVertical = searchData.depthBlocks[kCount].depthVPBlock.vpBounds.bottom;                    // now set the important info for DM to set the display          requestRecPtr-&gt;depthMode = searchData.depthBlocks[kCount].depthSwitchInfo.csMode;          requestRecPtr-&gt;displayMode = searchData.depthBlocks[kCount].depthSwitchInfo.csData;          requestRecPtr-&gt;switchInfo = searchData.depthBlocks[kCount].depthSwitchInfo;          if (searchData.displayModeTimingInfo.csTimingFlags &amp; 1&lt;&lt;kModeSafe)            requestRecPtr-&gt;availFlags = 0;              // mode safe          else requestRecPtr-&gt;availFlags = 1&lt;&lt;kModeValidNotSafeBit;  // mode valid but not safe, requires user validation of mode switch          }      }    }      if (searchData.depthBlocks)    {      DisposePtr ((Ptr)searchData.depthBlocks);  // toss for this timing mode of this gdevice      searchData.depthBlocks = nil;        // init it just so we know    }  }}Boolean FindBestMatch (VideoRequestRecPtr requestRecPtr, short bitDepth, unsigned long horizontal, unsigned long vertical){  // ** do the big comparison **  // first time only if  (no mode yet) and  //            (bounds are greater/equal or kMaximizeRes not set) and  //            (depth is less/equal or kShallowDepth not set) and  //            (request match or kAbsoluteRequest not set)  if  (  nil == requestRecPtr-&gt;displayMode      &amp;&amp;      (  (horizontal &gt;= requestRecPtr-&gt;reqHorizontal &amp;&amp;        vertical &gt;= requestRecPtr-&gt;reqVertical)        ||                                    !(requestRecPtr-&gt;requestFlags &amp; 1&lt;&lt;kMaximizeResBit)        )      &amp;&amp;      (  bitDepth &lt;= requestRecPtr-&gt;reqBitDepth ||          !(requestRecPtr-&gt;requestFlags &amp; 1&lt;&lt;kShallowDepthBit)          )      &amp;&amp;      (  (horizontal == requestRecPtr-&gt;reqHorizontal &amp;&amp;          vertical == requestRecPtr-&gt;reqVertical &amp;&amp;        bitDepth == requestRecPtr-&gt;reqBitDepth)        ||        !(requestRecPtr-&gt;requestFlags &amp; 1&lt;&lt;kAbsoluteRequestBit)        )    )    {      // go ahead and set the new values      return (true);    }  else  // can we do better than last time?  {    // if  (kBitDepthPriority set and avail not equal req) and    //    ((depth is greater avail and depth is less/equal req) or kShallowDepth not set) and    //    (avail depth less reqested and new greater avail) or    //    (request match or kAbsoluteRequest not set)    if  (  (  requestRecPtr-&gt;requestFlags &amp; 1&lt;&lt;kBitDepthPriorityBit &amp;&amp;           requestRecPtr-&gt;availBitDepth != requestRecPtr-&gt;reqBitDepth        )        &amp;&amp;        (  (  bitDepth &gt; requestRecPtr-&gt;availBitDepth &amp;&amp;            bitDepth &lt;= requestRecPtr-&gt;reqBitDepth          )          ||          !(requestRecPtr-&gt;requestFlags &amp; 1&lt;&lt;kShallowDepthBit)          )        &amp;&amp;        (  requestRecPtr-&gt;availBitDepth &lt; requestRecPtr-&gt;reqBitDepth &amp;&amp;          bitDepth &gt; requestRecPtr-&gt;availBitDepth          )        &amp;&amp;        (  (horizontal == requestRecPtr-&gt;reqHorizontal &amp;&amp;            vertical == requestRecPtr-&gt;reqVertical &amp;&amp;          bitDepth == requestRecPtr-&gt;reqBitDepth)          ||          !(requestRecPtr-&gt;requestFlags &amp; 1&lt;&lt;kAbsoluteRequestBit)          )      )    {      // go ahead and set the new values      return (true);    }    else    {      // match resolution: minimize \xC6h &amp; \xC6v      if  (  abs((requestRecPtr-&gt;reqHorizontal - horizontal)) &lt;=          abs((requestRecPtr-&gt;reqHorizontal - requestRecPtr-&gt;availHorizontal)) &amp;&amp;          abs((requestRecPtr-&gt;reqVertical - vertical)) &lt;=          abs((requestRecPtr-&gt;reqVertical - requestRecPtr-&gt;availVertical))        )      {        // now we have a smaller or equal delta        //  if (h or v greater/equal to request or kMaximizeRes not set)         if (  (horizontal &gt;= requestRecPtr-&gt;reqHorizontal &amp;&amp;            vertical &gt;= requestRecPtr-&gt;reqVertical)            ||            !(requestRecPtr-&gt;requestFlags &amp; 1&lt;&lt;kMaximizeResBit)          )        {          // if  (depth is equal or kBitDepthPriority not set) and          //    (depth is less/equal or kShallowDepth not set) and          //    ([h or v not equal] or [avail depth less reqested and new greater avail] or depth equal avail) and          //    (request match or kAbsoluteRequest not set)          if  (  (  requestRecPtr-&gt;availBitDepth == bitDepth ||                      !(requestRecPtr-&gt;requestFlags &amp; 1&lt;&lt;kBitDepthPriorityBit)              )              &amp;&amp;              (  bitDepth &lt;= requestRecPtr-&gt;reqBitDepth ||                  !(requestRecPtr-&gt;requestFlags &amp; 1&lt;&lt;kShallowDepthBit)                  )              &amp;&amp;              (  (requestRecPtr-&gt;availHorizontal != horizontal ||                requestRecPtr-&gt;availVertical != vertical)                ||                (requestRecPtr-&gt;availBitDepth &lt; requestRecPtr-&gt;reqBitDepth &amp;&amp;                bitDepth &gt; requestRecPtr-&gt;availBitDepth)                ||                (bitDepth == requestRecPtr-&gt;reqBitDepth)              )              &amp;&amp;              (  (horizontal == requestRecPtr-&gt;reqHorizontal &amp;&amp;                  vertical == requestRecPtr-&gt;reqVertical &amp;&amp;                bitDepth == requestRecPtr-&gt;reqBitDepth)                ||                !(requestRecPtr-&gt;requestFlags &amp; 1&lt;&lt;kAbsoluteRequestBit)                )            )          {            // go ahead and set the new values            return (true);          }        }      }    }  }  return (false);}void GravitateMonitors (void){  // do the magic gravitation here}</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/Play_Video_Sample/listing2.html%3Fid%3DDTS10000437-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/Play_Video_Sample/listing2.html%3Fid%3DDTS10000437-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/Play_Video_Sample/listing2.html%3Fid%3DDTS10000437-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>