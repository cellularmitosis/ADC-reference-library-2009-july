<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>PlayTune - /src/PlayTune.java</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/Java/index.html">Java</a> &gt; <a href="../../samplecode/Java/idxQuickTime-date.html">QuickTime</a> &gt; <A HREF="javascript:location.replace('index.html');">PlayTune</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">PlayTune</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/src/PlayTune.java</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/src/PlayTune.java</option></select>
				</p>
				</form>
				<p><strong><a href="PlayTune.zip">Download Sample</a></strong> (&#147;PlayTune.zip&#148;, 78.2K)<BR>
<strong><a href="PlayTune.dmg">Download Sample</a></strong> (&#147;PlayTune.dmg&#148;, 140.4K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*

File: PlayTune.java

Abstract: Example usage of NoteChannels in QTJ

Version: 1.2

&copy; Copyright 2006 Apple Computer, Inc. All rights reserved.

IMPORTANT:  This Apple software is supplied to 
you by Apple Computer, Inc. (&quot;Apple&quot;) in 
consideration of your agreement to the following 
terms, and your use, installation, modification 
or redistribution of this Apple software 
constitutes acceptance of these terms.  If you do 
not agree with these terms, please do not use, 
install, modify or redistribute this Apple 
software.

In consideration of your agreement to abide by 
the following terms, and subject to these terms, 
Apple grants you a personal, non-exclusive 
license, under Apple's copyrights in this 
original Apple software (the &quot;Apple Software&quot;), 
to use, reproduce, modify and redistribute the 
Apple Software, with or without modifications, in 
source and/or binary forms; provided that if you 
redistribute the Apple Software in its entirety 
and without modifications, you must retain this 
notice and the following text and disclaimers in 
all such redistributions of the Apple Software. 
Neither the name, trademarks, service marks or 
logos of Apple Computer, Inc. may be used to 
endorse or promote products derived from the 
Apple Software without specific prior written 
permission from Apple.  Except as expressly 
stated in this notice, no other rights or 
licenses, express or implied, are granted by 
Apple herein, including but not limited to any 
patent rights that may be infringed by your 
derivative works or by other works in which the 
Apple Software may be incorporated.

The Apple Software is provided by Apple on an &quot;AS 
IS&quot; basis.  APPLE MAKES NO WARRANTIES, EXPRESS OR 
IMPLIED, INCLUDING WITHOUT LIMITATION THE IMPLIED 
WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY 
AND FITNESS FOR A PARTICULAR PURPOSE, REGARDING 
THE APPLE SOFTWARE OR ITS USE AND OPERATION ALONE 
OR IN COMBINATION WITH YOUR PRODUCTS.

IN NO EVENT SHALL APPLE BE LIABLE FOR ANY 
SPECIAL, INDIRECT, INCIDENTAL OR CONSEQUENTIAL 
DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS 
OF USE, DATA, OR PROFITS; OR BUSINESS 
INTERRUPTION) ARISING IN ANY WAY OUT OF THE USE, 
REPRODUCTION, MODIFICATION AND/OR DISTRIBUTION OF 
THE APPLE SOFTWARE, HOWEVER CAUSED AND WHETHER 
UNDER THEORY OF CONTRACT, TORT (INCLUDING 
NEGLIGENCE), STRICT LIABILITY OR OTHERWISE, EVEN 
IF APPLE HAS BEEN ADVISED OF THE POSSIBILITY OF 
SUCH DAMAGE.

*/

import java.awt.*;
import java.awt.event.*;
import java.io.*;

import quicktime.*;
import quicktime.app.view.*;
import quicktime.app.time.*;
import quicktime.io.*;
import quicktime.qd.*;
import quicktime.sound.*;
import quicktime.std.movies.*;
import quicktime.std.movies.media.*;
import quicktime.std.music.*;
import quicktime.std.*;
import quicktime.std.qtcomponents.*;

import quicktime.util.*;

// This is a sample of using the TunePlayer translated from the Develop 21 article on QTMusic
public class PlayTune extends Frame  implements StdQTConstants, SoundConstants {  
  public static void main (String args[])   {
    try { 
      QTSession.open();
      PlayTune app = new PlayTune(&quot;Play Tune&quot;);
      app.pack();
      app.show();
      app.toFront();
    } catch (Exception e) {
      e.printStackTrace();
      QTSession.close();
    }
  }

  TunePlayer      aTunePlayer;
  MusicData      aTune;
  AtomicInstrument myInstrument;
  NoteChannel    myNoteChannel;
  
  PlayTune (String title)  throws Exception {
    super (title);
  // Make up a tune player and set the note channels that will be used
  // the order of the NoteChannels in the array when the are added
  // to the TunePlayer is the part those channels take on
  // thus first element of NC array is the NoteChannel for the first part
      aTunePlayer = new TunePlayer();
    NoteChannel[] noteChanArray = new NoteChannel[2];
    myNoteChannel = noteChanArray[0] = new NoteChannel (1, 4);  //a piano with 4 voice polyphony
    
    File f = QTFactory.findAbsolutePath (&quot;sin440.aif&quot;);
    myInstrument = createAtomicInstrument (new QTFile (f));

    noteChanArray[1] = myInstrument.newNoteChannel (0); //new NoteChannel (41, 3);//a violin with 3 voice polyphony
    aTunePlayer.setNoteChannels (noteChanArray);
    
  // this is the tune itself
    aTune = testSequenceCreation();
  
  // create a button to start the tune playing
    Button playBtn = new Button (&quot;Play Tune&quot;);
    playBtn.addActionListener (new ActionListener () {
      public void actionPerformed (ActionEvent ae) {
        try {
          aTunePlayer.queue (aTune, 1.0F, 0, 0x7FFFFFFF, 0);
        } catch (QTException e) {
          e.printStackTrace();
        }
      }
    });
    
    add (playBtn, &quot;North&quot;);
    Button saveBtn = new Button (&quot;Save Tune&quot;);
    saveBtn.addActionListener (new ActionListener () {
      public void actionPerformed (ActionEvent ae) {
        makeMovie();
      }
    });
    add (saveBtn, &quot;Center&quot;);

    Button rebuildBtn = new Button (&quot;Rebuild Tune&quot;);
    rebuildBtn.addActionListener (new ActionListener () {
      public void actionPerformed (ActionEvent ae) {
        rebuildTune();
      }
    });
    add (rebuildBtn, &quot;South&quot;);

    addWindowListener(new WindowAdapter () {
      public void windowClosing (WindowEvent e) {
        QTSession.close();
        dispose();
      }

      public void windowClosed (WindowEvent e) { 
        System.exit(0);
      }
    });     

  }

  static final int 
        // why 600 -&gt; that is the scale of the media when we add it to the movie
      kNoteDuration = 240, // * in 600ths of a second
      kRestDuration = 300, // * in 600ths -- tempo will be 120 bpm
      
      // 21 music events plus 1 for end of sequence marker
      our_sequence_length = (22 * 4), // * bytes
        //why 9? - the tune we have has 9 rest's in it - the &quot;rest&quot; event essentially
        //sets up the grid and the duration
      our_sequence_duration = (9 * kRestDuration); // * 600ths
  
    // create a tune
  static MusicData testSequenceCreation () throws QTException {
    
    MusicData tune = new MusicData (our_sequence_length);
    
    tune.setMusicEvent (0, MusicData.stuffNoteEvent(1, 60, 100, kNoteDuration)); // * piano C
    tune.setMusicEvent (1, MusicData.stuffRestEvent(kRestDuration));
    tune.setMusicEvent (2, MusicData.stuffNoteEvent(2, 60, 100, kNoteDuration)); // * violin C
    tune.setMusicEvent (3, MusicData.stuffRestEvent(kRestDuration));
    tune.setMusicEvent (4, MusicData.stuffNoteEvent(1, 63, 100, kNoteDuration)); // * piano
    tune.setMusicEvent (5, MusicData.stuffRestEvent(kRestDuration));
    tune.setMusicEvent (6, MusicData.stuffNoteEvent(2, 64, 100, kNoteDuration)); // * violin
    tune.setMusicEvent (7, MusicData.stuffRestEvent(kRestDuration));
    // * Make the 5th and 6th notes much softer, just for fun.
    tune.setMusicEvent (8, MusicData.stuffNoteEvent(1, 67, 60, kNoteDuration)); // * piano
    tune.setMusicEvent (9, MusicData.stuffRestEvent(kRestDuration));
    tune.setMusicEvent (10, MusicData.stuffNoteEvent(2, 66, 60, kNoteDuration)); // * violin
    tune.setMusicEvent (11, MusicData.stuffRestEvent(kRestDuration));
    tune.setMusicEvent (12, MusicData.stuffNoteEvent(1, 72, 100, kNoteDuration)); // * piano
    tune.setMusicEvent (13, MusicData.stuffRestEvent(kRestDuration));
    tune.setMusicEvent (14, MusicData.stuffNoteEvent(2, 73, 100, kNoteDuration)); // * violin
    tune.setMusicEvent (15, MusicData.stuffRestEvent(kRestDuration));
    tune.setMusicEvent (16, MusicData.stuffNoteEvent(1, 60, 100, kNoteDuration)); // * piano
    tune.setMusicEvent (17, MusicData.stuffNoteEvent(1, 67, 100, kNoteDuration)); // * piano
    tune.setMusicEvent (18, MusicData.stuffNoteEvent( 2, 63, 100, kNoteDuration)); // * violin
    tune.setMusicEvent (19, MusicData.stuffNoteEvent(2, 72, 100, kNoteDuration)); // * violin
    tune.setMusicEvent (20, MusicData.stuffRestEvent(kRestDuration));
      // * end-of-sequence marker already in MusicData object
    //tune.setMusicEvent (21, MusicData.stuffMarkerEvent (0, 0));
    
    return tune;
  }

    //makes a TuneHeader up from the current state of the TunePlayer's note channels
  MusicData makeTuneHeaderFromTunePlayer () throws QTException {
  //  Make a MusicHeader with a note request and an atomic instrument
  //  The default constructor places the end marker event at the end of a MusicData allocated size
      
      //we need to find out how many 4byte values are required to fit our ai in
    int instSize = myInstrument.getSize() / 4;
    if (myInstrument.getSize() % 4 != 0)
      instSize++;
      //add 2 for the header and footer music events
    int aiEventLength = instSize + 2;
    
    int endMarkerSize = 4;
    
    MusicData musicHeader = new MusicData (MusicData.kNoteRequestHeaderEventLength * 4 + aiEventLength * 4 + endMarkerSize);

        // get its note request
      NoteRequest nr = myNoteChannel.getNoteRequest();
        // stuff the note request into the music header
    musicHeader.setNoteRequest (0, 1, nr);
        
      // 2 is the part number for the instrument
      // offset into music data past the first note request event
    musicHeader.setAtomicInstrument (MusicData.kNoteRequestHeaderEventLength, 2, myInstrument);
      
    return musicHeader;
  }

  void makeMovie () {
    try {
      FileDialog fd = new FileDialog (this, &quot;Save Movie As...&quot;, FileDialog.SAVE);
      fd.show();
      if(fd.getFile() == null)
        return;  //not saving at this time
      
      movieFile = new QTFile(fd.getDirectory() + fd.getFile());
      Movie theMovie = Movie.createMovieFile (movieFile,
                kMoviePlayer, 
                createMovieFileDeleteCurFile | createMovieFileDontCreateResFile);
      
      Track t = theMovie.newTrack (0, 0, 1.0F);
      MusicMedia musicMedia = new MusicMedia (t, 600);
      MusicDescription musicDesc = new MusicDescription ();
      
      // create the TuneHeader from the TunePlayer
      // then add it to the end of the MusicDescription
      musicDesc.setTuneHeader (makeTuneHeaderFromTunePlayer());
      
      // add the MD and the tune to the music media.
      musicMedia.beginEdits();  
      musicMedia.addSample (aTune, 0, aTune.getSize(), our_sequence_duration, musicDesc, 1, 0);
      musicMedia.endEdits();
      
      // insert the media into our track
      t.insertMedia (0, 0, our_sequence_duration, 1.0F);
      
      // save the movie to the created file
      OpenMovieFile outStream = OpenMovieFile.asWrite (movieFile); 
      theMovie.addResource (outStream, movieInDataForkResID, movieFile.getName());
      outStream.close();
      
      System.out.println (&quot;Finished&quot;);
    } catch (QTException e) {
      e.printStackTrace();
    }
  }
  
  QTFile movieFile;
    
    //rebuild the tune be reading in the previously saved instruments
  void rebuildTune () {
    try {
      if (movieFile == null) {
        System.out.println (&quot;Save Tune to Movie first&quot;);
        return;
      }
        
      Movie mov = Movie.fromFile (OpenMovieFile.asRead(movieFile));
      int numTracks = mov.getTrackCount();
      MusicMedia musicMedia = null;
      
      // add the audio media from each track
      for (int i = 1; i &lt;= numTracks; i++) {
        Track curTrack = mov.getIndTrack(i);
        Media trackMedia = Media.getTrackMedia(curTrack);
        if (trackMedia instanceof MusicMedia)
          musicMedia = (MusicMedia)trackMedia;
      }
      
      if (musicMedia == null)
        throw new QTException (&quot;Music Media not found&quot;);
      
      MusicDescription mdesc = musicMedia.getMusicDescription(1);
      System.out.println (mdesc);
      
      MusicData theMusicData = mdesc.getTuneHeader();
      System.out.println (theMusicData);
      
        //we know there are two instruments in the file we just created.
      NoteChannel[] noteChanArray = new NoteChannel[2];
    
        //we parse the tune header music data object.
        //pulling out any note requests and atomic instruments
        // we find in the header
      int currentEventIndex = 0;
      int i = 0;
        //to loop through the entire tune header 
        // we loop until the currentIndex is greater than the size (in bytes) of the 
        // music data / 4 (gives us the number of music events) - 1 (to ignore the end marker event)
      while (currentEventIndex &lt; theMusicData.getSize() / 4 - 1) {
        int eventHeader = theMusicData.getMusicEvent(currentEventIndex);
          System.out.print (&quot;event header:&quot; + Integer.toHexString(eventHeader));
        int eventLength =  MusicData.generalLength (eventHeader);
          System.out.print (&quot;,event length:&quot; + eventLength);
        int eventFooter = theMusicData.getMusicEvent (eventLength + currentEventIndex - 1);
          System.out.print (&quot;,event footer:&quot; + Integer.toHexString(eventFooter));
        int eventSubtype = MusicData.generalSubtype_Footer (eventFooter);
          System.out.print (&quot;,event subtype:&quot; + eventSubtype);
        System.out.println (&quot;&quot;);
          
          //based on the event sub type we have either
          //stored a note request or an atomic instrument
          // in the movie -&gt; so we read out from the music data the appropriate type
          // the note request/atomic inst. will start at the index of the general event + 1 
          // (to get past the general event header)
        switch (eventSubtype) {
          case kGeneralEventNoteRequest:
            NoteRequest nr = theMusicData.getNoteRequest (currentEventIndex + 1);
            System.out.println (nr);
            myNoteChannel = noteChanArray[i] = new NoteChannel (nr);
            break;
          case kGeneralEventAtomicInstrument:
            AtomicInstrument ai = theMusicData.getAtomicInstrument (currentEventIndex + 1);
            System.out.println (ai);
             noteChanArray[i] = myInstrument.newNoteChannel (0);
            break;
          default:
            break;  //skip this general event
        }
          //move our index to the next general event header
        currentEventIndex += eventLength;
        i++;
      }
      
      if (noteChanArray[0] == null || noteChanArray[1] == null)
        throw new QTException (&quot;Problem reading instruments&quot;);
        
        //swap the parts that the note channels play
        // originally we had the piano playing the first note
        // after rebuilding the sin wave will play the first note
      NoteChannel temp = noteChanArray[0];
      noteChanArray[0] = noteChanArray[1];
      noteChanArray[1] = temp;
      
      aTunePlayer.setNoteChannels (noteChanArray);
      
    } catch (QTException e) {
      e.printStackTrace();
    }
  }
      

  //////////
  //
  // createAtomicInstrument
  // Create a custom atomic instrument using the sampled sound data in the specified resource handle.
  //
  // A custom instrument is defined by a QTAtom structure containing appropriate atoms (hence the name
  // &quot;atomic&quot; instrument). See the QT3.0 book &quot;QuickTime Music Architecture&quot; for information about the
  // structure of an atomic instrument. Page 15 has a good picture of the required structure.
  //
  //////////

  static AtomicInstrument createAtomicInstrument (QTFile f) throws QTException, IOException {
      // some constants that are used
    final int kCustomInstAtomID = 11;
    final int 
        kMIDINoteValue_Lowest = 0,
        kMIDINoteValue_Highest = 127,
        kMIDINoteValue_A440 = 69;
    
    //////////
    //
    // get information about the sound; we'll use this later to construct a sample description atom
    //
    //////////
    SndInfo info = SndInfo.parseAIFFHeader (OpenFile.asRead (f));
    SoundComponentData mySndInfo = info.sndData;
/*
      //assume the AIFF sound data is uncompressed as
      //atomic instruments ONLY accept uncompressed sound
      // so this call and it's consequent usage is not required
    CompressionInfo myCompInfo = CompressionInfo.get (SoundConstants.notCompressed, 
                              mySndInfo.getFormat(), 
                              mySndInfo.getNumChannels(), 
                              mySndInfo.getSampleSize());
    System.out.println (myCompInfo);
*/    
    System.out.println (mySndInfo);
      
    //////////
    //
    // create an atom container with atoms that describe the custom instrument
    //
    //////////
    
    // create a new, empty atom container
    AtomicInstrument myInstrument = new AtomicInstrument();
    
    // insert a tone description atom, which contains a tone description structure
    ToneDescription myToneDesc = new ToneDescription ();
    myToneDesc.setSynthesizerType (kSoftSynthComponentSubType);
    myToneDesc.setInstrumentName (&quot;Sin 440&quot;);
    myToneDesc.setInstrumentNumber (1);//kInst_Custom
    myInstrument.insertChild (Atom.kParentIsContainer, kaiToneDescType, 1, 1, myToneDesc);
    
    // insert a note request atom, which contains a note request structure;
    // this atom is optional; if it's not present, QTMA assumes some reasonable values
    NoteRequestInfo myNoteInfo = new NoteRequestInfo ();
    myInstrument.insertChild (Atom.kParentIsContainer, kaiNoteRequestInfoType, 1, 1, myNoteInfo);

    // insert a knob list atom;
    // this atom is optional; if it's not present, QTMA assumes some reasonable values
    InstKnobList myKnobList = new InstKnobList ();
    myInstrument.insertChild (Atom.kParentIsContainer, kaiKnobListType, 1, 1, myKnobList);

    // insert a key range information atom; this is the parent of the sample description atom
     Atom myKeyRangeInfoAtom = myInstrument.insertChild (Atom.kParentIsContainer, kaiKeyRangeInfoType, 1, 1);
    
      if (myKeyRangeInfoAtom.getAtom() == 0)
        throw new QTException (&quot;Empty KeyRange Atom&quot;);

      //this is defined as a big-endian struct so QTJava automatically flips the fields
    InstSampleDesc  mySampleDesc = new InstSampleDesc ();
    
    mySampleDesc.setDataFormat (mySndInfo.getFormat());
    mySampleDesc.setNumChannels (mySndInfo.getNumChannels());
    mySampleDesc.setSampleSize (mySndInfo.getSampleSize());
    mySampleDesc.setSampleRate (mySndInfo.getSampleRate());

      // define the characteristics of the sampled sound  
    mySampleDesc.setSampleDataID (kCustomInstAtomID);
    mySampleDesc.setOffset (0);
    mySampleDesc.setNumSamples (mySndInfo.getSampleCount());
      
      //set looping characteristics
    mySampleDesc.setLoopType (kMusicLoopTypeNormal);
    mySampleDesc.setLoopStart (0);
    mySampleDesc.setLoopEnd (mySndInfo.getSampleCount());

      //set pitch characteristics
    mySampleDesc.setPitchNormal (kMIDINoteValue_A440);
    mySampleDesc.setPitchLow (kMIDINoteValue_Lowest);
    mySampleDesc.setPitchHigh (kMIDINoteValue_Highest);
      
      System.out.println (mySampleDesc);
      
      // insert the sample description atom
    myInstrument.insertChild (myKeyRangeInfoAtom, kaiSampleDescType, 1, 1, mySampleDesc);
    
    // insert a sample information atom; this is the parent of the sample data atom and must have
    // the same atom ID specified by the sampleDataID field of the instrument sample description 
    Atom mySampleInfoAtom = myInstrument.insertChild (Atom.kParentIsContainer, kaiSampleInfoType, kCustomInstAtomID, 0);

    if (mySampleInfoAtom.getAtom() == 0)
      throw new QTException (&quot;Sample Info Atom is 0&quot;);  

    // insert a sample data atom into the sample information atom; this atom contains the actual
    // sample data that defines the custom instrument; the format of the sample data is defined
    // by the corresponding sample description atom
        // was using myCompInfo.getBytesPerSample() but as this is not-compressed seems redundant
        //if worried about dealing with 12/18/20 bit sample sizes could do (getSampleSize() + 7) / 8 =&gt; will truncate to correct value
    int mySampleDataSize = mySndInfo.getSampleCount() * (mySndInfo.getSampleSize() / 8); 
      //read just the sample data into memory
      // it is sample data size and is found at the data offset location in the file
      // as returned by the ParseAIFF header call
      FileInputStream fis = new FileInputStream (f);
      byte[] ar = new byte [mySampleDataSize];      
      fis.skip (info.dataOffset);
      fis.read (ar, 0, mySampleDataSize);
      QTByteObject mySampleData = QTByteObject.fromArray (ar);
    myInstrument.insertChild (mySampleInfoAtom, kaiSampleDataType, 1, 0, mySampleData);
    
    // insert an instrument info atom; this is a parent atom
    Atom myInstInfoAtom = myInstrument.insertChild (Atom.kParentIsContainer, kaiInstInfoType, 1, 0);
    
    if (myInstInfoAtom.getAtom() == 0)
      throw new QTException (&quot;InstInfoAtom is 0&quot;);
      
    // insert a picture atom into the instrument info atom
    Pict myPictHandle = Pict.fromFile (QTFactory.findAbsolutePath (&quot;images/Ship01.pct&quot;));
    myInstrument.insertChild (myInstInfoAtom, kaiPictType, 1, 0, myPictHandle);

      //doesn't matter what format we have the strings in 
      // becase the insert child call for StringHandle will correctly insert just the string character's (bytes)
    StringHandle myWriter = new StringHandle (&quot;This space for rent!&quot;, StringHandle.kCStringFormat);
    StringHandle myRights = new StringHandle (&quot;Copyright 1998 by Apple Computer, Inc.&quot;, StringHandle.kCStringFormat);
    StringHandle myOthers = new StringHandle (&quot;Custom Atomic Instrument.&quot;, StringHandle.kCStringFormat);

    // insert a writer atom into the instrument info atom
    myInstrument.insertChild (myInstInfoAtom, kaiWriterType, 1, 0, myWriter);
    
    // insert a copyright atom into the instrument info atom
    myInstrument.insertChild (myInstInfoAtom, kaiCopyrightType, 1, 0, myRights);
    
    // insert an other info atom into the instrument info atom
    myInstrument.insertChild (myInstInfoAtom, kaiOtherStrType, 1, 0, myOthers);
      
    return myInstrument;
  }

// code not used in demo - here for your edification
  static MusicData testHeaderCreation () throws QTException {
      final int kNumberOfNoteRequestsInHeader = 2;

      // request for piano polyphony 4
    NoteRequest aRequest = new NoteRequest(1, 4);

      // request for violin polyphony 3
    NoteRequest anotherRequest = new NoteRequest(41, 3);
    anotherRequest.setPolyphony(3);

  //  Make a MusicHeader with 2 note requests
  //  The default constructor places the end marker event at the end of a MusicData allocated size
    MusicData musicHeader = new MusicData (4 + kNumberOfNoteRequestsInHeader * (MusicData.kNoteRequestHeaderEventLength * 4));

      // stick our request into it for first part
      musicHeader.setNoteRequest(0, 1, aRequest);
      // stick our request into it for second part
      musicHeader.setNoteRequest(MusicData.kNoteRequestHeaderEventLength, 2, anotherRequest);
      // end-of-sequence marker is already in the MusicData
    
    return musicHeader;
  }
}</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/PlayTune/listing1.html%3Fid%3DDTS10000976-2.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/PlayTune/listing1.html%3Fid%3DDTS10000976-2.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/PlayTune/listing1.html%3Fid%3DDTS10000976-2.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>