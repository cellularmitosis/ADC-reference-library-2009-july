<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>DropPrint USB - /TestPrinterClass.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxHardwareDrivers-date.html">Hardware & Drivers</a> &gt; <A HREF="javascript:location.replace('index.html');">DropPrint USB</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/HardwareDrivers/idxUSB-date.html" target="_blank">Hardware & Drivers > USB</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">DropPrint USB</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/TestPrinterClass.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/DropShell.c</option>
<option value="listing2.html">/DropShell.h</option>
<option value="listing3.html">/dropshell.r</option>
<option value="listing4.html">/DSAppleEvents.c</option>
<option value="listing5.html">/DSAppleEvents.h</option>
<option value="listing6.html">/DSGlobals.h</option>
<option value="listing7.html">/DSUserProcs.c</option>
<option value="listing8.html">/DSUserProcs.h</option>
<option value="listing9.html">/DSUtils.c</option>
<option value="listing10.html">/DSUtils.h</option>
<option value="listing11.html">/ListInDialog.c</option>
<option value="listing12.html">/ListInDialog.h</option>
<option value="listing13.html">/ListInDialog.r</option>
<option value="listing14.html">/Prefix.h</option>
<option value="listing15.html">/SafeNameRegistry.c</option>
<option value="listing16.html">/SafeNameRegistry.h</option>
<option value="listing17.html">/TestPrinterClass.c</option>
<option value="listing18.html">/TestPrinterClass.h</option></select>
				</p>
				</form>
				<p><strong><a href="DropPrint_USB.zip">Download Sample</a></strong> (&#147;DropPrint_USB.zip&#148;, 72.5K)<BR>
<strong><a href="DropPrint_USB.dmg">Download Sample</a></strong> (&#147;DropPrint_USB.dmg&#148;, 133.2K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">// File TestPrinterClass.c#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;types.h&gt;#include &lt;gestalt.h&gt;#include &lt;errors.h&gt;#ifndef __DIALOGS__#include &lt;Dialogs.h&gt;#endif#ifndef __EVENTS__#include &lt;Events.h&gt;#endif#ifndef __FILES__#include &lt;Files.h&gt;#endif#ifndef __DEVICES__#include &lt;Devices.h&gt;#endif#include &lt;textedit.h&gt;#ifndef __NUMBERFORMATTING__#include &lt;numberformatting.h&gt;#endif#include &quot;TestPrinterClass.h&quot;#include &quot;SafeNameRegistry.h&quot;enum {  kUSBNoErr          = 0,  kUSBNoTran          = 0,  kUSBNoDelay          = 0,  kUSBPending          = 1,              /* */                                /* USB assigned error numbers in range -6900 .. -6999 */  kUSBBaseError        = -7000,            /* */                                /* USB Services Errors */  kUSBInternalErr        = -6999,            /* Internal error */  kUSBUnknownDeviceErr    = -6998,            /*  device ref not recognised */  kUSBUnknownPipeErr      = -6997,            /*  Pipe ref not recognised */  kUSBTooManyPipesErr      = -6996,            /*  Too many pipes */  kUSBIncorrectTypeErr    = -6995,            /*  Incorrect type */  kUSBRqErr          = -6994,            /*  Request error */  kUSBUnknownRequestErr    = -6993,            /*  Unknown request */  kUSBTooManyTransactionsErr  = -6992,            /*  Too many transactions */  kUSBAlreadyOpenErr      = -6991,            /*  Already open */  kUSBNoDeviceErr        = -6990,            /*  No device */  kUSBDeviceErr        = -6989,            /*  Device error */  kUSBOutOfMemoryErr      = -6988,            /*  Out of memory */  kUSBNotFound        = -6987,            /*  Not found */  kUSBPBVersionError      = -6986,            /*  Wrong pbVersion */  kUSBPBLengthError      = -6985,            /*  pbLength too small */  kUSBCompletionError      = -6984,            /*  no completion routine specified */  kUSBFlagsError        = -6983,            /*  Flags not zeroed */  kUSBAbortedError      = -6982,            /*  Pipe aborted */  kUSBNoBandwidthError    = -6981,            /*  Not enough bandwidth available */  kUSBPipeIdleError      = -6980,            /*  Pipe is Idle, it will not accept transactions */  kUSBPipeStalledError    = -6979,            /*  Pipe has stalled, error needs to be cleared */  kUSBUnknownInterfaceErr    = -6978,            /*  Interface ref not recognised */                                /* */                                /* USB Manager Errors */  kUSBBadDispatchTable    = -6950,            /* Improper driver dispatch table */                                /* */                                /* Hardware Errors */                                /* Note pipe stalls are communication */                                /* errors. The affected pipe can not */                                /* be used until USBClearPipeStallByReference  */                                /* is used */                                /* kUSBEndpointStallErr is returned in */                                /* response to a stall handshake */                                /* from a device. The device has to be */                                /* cleared before a USBClearPipeStallByReference */                                /* can be used */  kUSBLinkErr          = -6916,  kUSBCRCErr          = -6915,            /*  Pipe stall, bad CRC */  kUSBBitstufErr        = -6914,            /*  Pipe stall, bitstuffing */  kUSBDataToggleErr      = -6913,            /*  Pipe stall, Bad data toggle */  kUSBEndpointStallErr    = -6912,            /*  Device didn't understand */  kUSBNotRespondingErr    = -6911,            /*  Pipe stall, No device, device hung */  kUSBPIDCheckErr        = -6910,            /*  Pipe stall, PID CRC error */  kUSBWrongPIDErr        = -6909,            /*  Pipe stall, Bad or wrong PID */  kUSBOverRunErr        = -6908,            /*  Packet too large or more data than buffer */  kUSBUnderRunErr        = -6907,            /*  Less data than buffer */  kUSBRes1Err          = -6906,  kUSBRes2Err          = -6905,  kUSBBufOvrRunErr      = -6904,            /*  Host hardware failure on data in, PCI busy? */  kUSBBufUnderRunErr      = -6903,            /*  Host hardware failure on data out, PCI busy? */  kUSBNotSent1Err        = -6902,            /*  Transaction not sent */  kUSBNotSent2Err        = -6901              /*  Transaction not sent */};#define SECONDS( n )      (n*60)#define PROGRAM        &quot;DropPrint*USB&quot;#define kStrPrinterClass  PROGRAM &quot;: &quot;enum {  kStatusDialog = 513};enum {  kStatusBarItem = 1};char        *outbuffer = NULL;IOParam      fsendblk;unsigned long  fUSBReference;char        *filename;DialogPtr    gStatusDlg;void    dump( char *p, long count );OSErr    sendfile( char *sourcefile, long buffersize );OSStatus OpenClassDriver( char *which_printer );void    showstatus( long current, long endfile );voiddump( char *p, long count ){  char  *q, *e, *f,      *d, line[64+32+1+1];  //2bytes per hex, 1 byte per char, 1 tab, 1 nul  short  nibble;  while ( count &gt; 0 )  {    q = p;                  // start of line    e = p + 32;                // proposed end of line    f = p + (count &gt; 32? 32: count);  // actual end of line    d = line;    //    //  standard hex dump    //    for ( ; count &gt; 0 &amp;&amp; p &lt; e; ++p, --count )    {      nibble = (*p &gt;&gt; 4) &amp; 0x0F;      *d++ = nibble + (nibble &gt; 9? 'A' - 10:'0');      nibble = *p &amp; 0x0F;      *d++ = nibble + (nibble &gt; 9? 'A' - 10:'0');    }    for ( ; p &lt; e; ++p )    {      *d++ = ' ';      *d++ = ' ';    }    *d++ = '\t';    //    //  ascii sidebar    //    for ( p = q; p &lt; f; ++p )      *d++ = *p &lt; ' ' || *p &gt;= 0x7F? '.': *p;    *d = '\0';    fprintf( stderr, &quot;%s\n&quot;, line );  }}OSStatusOpenClassDriver( char *which_printer ){  Str255      driverName;    // unit table driver name  OSStatus      err = -192;    // resNotFound  RegEntryID    self;  unsigned long  length;      fsendblk.ioRefNum = -1;          // preload our IOParms in engvars  fsendblk.ioResult = 0;  fsendblk.ioCompletion = 0L;  err = SafeRegistryEntryIDInit( &amp;self );  if ( err == noErr )  {      err = SafeRegistryCStrEntryLookup( nil, which_printer, &amp;self );    length = sizeof(driverName);    if ( err == noErr )      err = SafeRegistryPropertyGet( &amp;self, &quot;drvrOut&quot;, &amp;driverName, &amp;length );    if ( err == noErr )      err = OpenDriver( driverName, &amp;fsendblk.ioRefNum );    length = sizeof(fUSBReference);    if ( err == noErr )      err = SafeRegistryPropertyGet( &amp;self, &quot;privateData&quot;, &amp;fUSBReference, &amp;length );    SafeRegistryEntryIDDispose(&amp;self);  }  return err;}voidshowstatus( long current, long endfile ){  GrafPtr  oldport;  Rect    r;  Handle  h;  short    type;  long    width;  char    info[526];    GetPort( &amp;oldport );  SetPort( gStatusDlg );  GetDialogItem( gStatusDlg, kStatusBarItem, &amp;type, &amp;h, &amp;r );    // we have, width/ (r.right - r.left) == current/endfile  width = current *(r.right - r.left);  width /= endfile;    FrameRect( &amp;r );  InsetRect( &amp;r, 1, 1 );  sprintf( info, &quot;%ld of %ld&quot;, current, endfile );  TETextBox( info, strlen(info), &amp;r, teJustCenter );  r.right = width + r.left;  InvertRect( &amp;r );    SetPort( oldport );}OSErrsendfile( char *sourcefile, long buffersize ){  FILE         *fin = fopen( sourcefile, &quot;rb&quot; );  long        count;  EventRecord    e;  OSStatus      err;  long        eoffin;  // length of input file    gStatusDlg = GetNewDialog( kStatusDialog, nil, (WindowPtr)-1);  if ( !fin )    err = fnfErr;    // cant open file  else  {    fseek( fin, 0, 2 /*fsFromEnd*/ );    eoffin = ftell( fin );    fseek( fin, 0, 0 /*fsFromStart*/ );    do {      count = fread( outbuffer, sizeof(char), buffersize, fin );      if ( count &lt;= 0 )        break;    //  dump( outbuffer, count );      fsendblk.ioBuffer = outbuffer;      fsendblk.ioReqCount = count;      err = PBWriteAsync( (ParamBlockRec*) &amp;fsendblk );      if ( err != noErr )        break;      showstatus( ftell( fin ), eoffin );      // wait for i/o to complete      while ( fsendblk.ioResult == 1 )      {        WaitNextEvent( keyDownMask, &amp;e, 0, NULL );        if (e.what == keyDown &amp;&amp; e.modifiers &amp; cmdKey) {          if ( (e.message &amp; charCodeMask) == '.' )            break;        }      }      if ( fsendblk.ioResult != noErr )        break;      // if user canceled, exit the download      WaitNextEvent( keyDownMask, &amp;e, 0, NULL );            if (e.what == keyDown &amp;&amp; e.modifiers &amp; cmdKey) {        if ( (e.message &amp; charCodeMask) == '.' )          break;      }          } while ( count &gt; 0 );      DisposeDialog(gStatusDlg);    if ( err == noErr &amp;&amp; fsendblk.ioResult != noErr )      err = fsendblk.ioResult;    fclose( fin );  }    return err;}OSErrsendusb( char *printer_name, char *sourcefile, long blocksize, int repeat_count ){  OSStatus err = noErr;  outbuffer = (char *) malloc( blocksize );  memset( &amp;fsendblk, 0, sizeof(fsendblk) );    if ( !outbuffer )    err = iMemFullErr;  // memfull error  if ( err == noErr )    err = OpenClassDriver( printer_name );  if ( err == noErr )  {    for ( ; err == noErr &amp;&amp; repeat_count &gt; 0; --repeat_count )      err = sendfile( sourcefile, blocksize );    if ( err != noErr )      KillIO( fsendblk.ioRefNum );          if ( fsendblk.ioRefNum != -1 )      CloseDriver(fsendblk.ioRefNum);  }  if ( outbuffer )    free( outbuffer );    if ( err != noErr )  {    unsigned char *p;    int        slen;    switch ( err )    {        case  iMemFullErr:             p = &quot;\p&quot; PROGRAM &quot;Not enough memory. (Increase App heap, or use smaller block)&quot;; break;      case  kUSBInternalErr:          p = &quot;\p&quot; kStrPrinterClass &quot;Internal error&quot;; break;      case  kUSBUnknownDeviceErr:      p = &quot;\p&quot; kStrPrinterClass &quot;Unknown device&quot;; break;      case  kUSBUnknownPipeErr:         p = &quot;\p&quot; kStrPrinterClass &quot;Unknown pipe&quot;; break;      case  kUSBTooManyPipesErr:        p = &quot;\p&quot; kStrPrinterClass &quot;Too many pipes&quot;; break;      case  kUSBIncorrectTypeErr:      p = &quot;\p&quot; kStrPrinterClass &quot;Incorrect type&quot;; break;      case  kUSBRqErr:              p = &quot;\p&quot; kStrPrinterClass &quot;Request error&quot;; break;      case  kUSBUnknownRequestErr:      p = &quot;\p&quot; kStrPrinterClass &quot;Unknown request&quot;; break;      case  kUSBTooManyTransactionsErr:  p = &quot;\p&quot; kStrPrinterClass &quot;Too many transactions&quot;; break;      case  kUSBAlreadyOpenErr:        p = &quot;\p&quot; kStrPrinterClass &quot;Already open&quot;; break;      case  kUSBNoDeviceErr:          p = &quot;\p&quot; kStrPrinterClass &quot;No device&quot;; break;      case  kUSBDeviceErr:            p = &quot;\p&quot; kStrPrinterClass &quot;Device error&quot;; break;      case  kUSBOutOfMemoryErr:        p = &quot;\p&quot; kStrPrinterClass &quot;Out of memory&quot;; break;      case  kUSBNotFound:            p = &quot;\p&quot; kStrPrinterClass &quot;Not found&quot;; break;      case  kUSBLinkErr:            p = &quot;\p&quot; kStrPrinterClass &quot;Link Err&quot;; break;      case  kUSBCRCErr:              p = &quot;\p&quot; kStrPrinterClass &quot;Comms/Device err, bad CRC&quot;;  break;          case  kUSBBitstufErr:          p = &quot;\p&quot; kStrPrinterClass &quot;Comms/Device err, bitstuffing&quot;; break;          case  kUSBDataToggleErr:        p = &quot;\p&quot; kStrPrinterClass &quot;Comms/Device err, Bad data toggle&quot;; break;          case  kUSBEndpointStallErr:      p = &quot;\p&quot; kStrPrinterClass &quot;Device didn't understand&quot;; break;          case  kUSBNotRespondingErr:      p = &quot;\p&quot; kStrPrinterClass &quot;No device, device hung&quot;; break;          case  kUSBPIDCheckErr:          p = &quot;\p&quot; kStrPrinterClass &quot;Comms/Device err, PID CRC error&quot;; break;          case  kUSBWrongPIDErr:          p = &quot;\p&quot; kStrPrinterClass &quot;Comms/Device err, Bad or wrong PID&quot;; break;          case  kUSBOverRunErr:          p = &quot;\p&quot; kStrPrinterClass &quot;Packet too large or more data than buffer&quot;; break;          case  kUSBUnderRunErr:          p = &quot;\p&quot; kStrPrinterClass &quot;Less data than buffer&quot;; break;          case  kUSBRes1Err:            p = &quot;\p&quot; kStrPrinterClass &quot;kUSBRes1Err&quot;; break;          case  kUSBRes2Err:            p = &quot;\p&quot; kStrPrinterClass &quot;kUSBRes1Err&quot;; break;          case  kUSBBufOvrRunErr:          p = &quot;\p&quot; kStrPrinterClass &quot;Buffer over run error&quot;; break;          case  kUSBBufUnderRunErr:        p = &quot;\p&quot; kStrPrinterClass &quot;Buffer under run error&quot;; break;          case  kUSBNotSent1Err:          p = &quot;\p&quot; kStrPrinterClass &quot;Transaction not sent1&quot;; break;          case  kUSBNotSent2Err:          p = &quot;\p&quot; kStrPrinterClass &quot;Transaction not sent2&quot;; break;        default:        p = &quot;\p&quot; kStrPrinterClass &quot;Unknown error nnnnnnnn&quot;;        NumToString( err, p + *p - 8 );        slen = *(p + *p - 8);        *(p + *p - 8) = ' ';        *p += slen - 8;        break;    }        ParamText( p, nil, nil, nil );    StopAlert( 768, nil );    err = noErr;  }  return err;}/* eof */</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/DropPrint_USB/listing17.html%3Fid%3DDTS10000288-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/DropPrint_USB/listing17.html%3Fid%3DDTS10000288-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/DropPrint_USB/listing17.html%3Fid%3DDTS10000288-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>