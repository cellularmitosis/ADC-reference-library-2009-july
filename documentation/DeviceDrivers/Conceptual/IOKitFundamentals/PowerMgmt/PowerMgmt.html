<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>I/O Kit Fundamentals: Managing Power</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Managing Power"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP0000020" title="Managing Power"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../../HardwareDrivers/index.html#//apple_ref/doc/uid/TP30000440-TP40003576" target="_top">Hardware &amp; Drivers</a> &gt; <a href="../Introduction/Introduction.html#//apple_ref/doc/uid/TP0000011-CH204-TPXREF101">I/O Kit Fundamentals</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../DataMgmt/DataMgmt.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../DeviceRemoval/DeviceRemoval.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP0000020-BABCCBIJ" title="Managing Power"></a><h1>Managing Power</h1><p>The power-management functionality of the I/O Kit aims to minimize the power consumed by a computer system, behavior that is especially important for portable computers where battery life is a crucial feature. Power management also imposes an orderly sequence of actions, such as saving and restoring state, when a system (or a part of it) sleeps or wakes.<a name="//apple_ref/doc/uid/TP0000020-DontLinkElementID_863"></a><a name="//apple_ref/doc/uid/TP0000020-DontLinkElementID_864"></a></p><p>This chapter focuses on power management for in-kernel drivers that manage hardware. Read this chapter to learn about power management in Mac OS X and to find out what level of power-management support you need to provide and how to implement it. Although power management is a complex technology, the majority of in-kernel drivers need to implement only the most basic functionality to participate successfully in Mac OS X power management.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP0000020-DontLinkElementID_64" title="Note"></a><p><strong>Note:</strong>&nbsp;If you’re developing an application that accesses hardware, such as a user-space driver for a digital camera, scanner, webcam, or tape drive, you probably do not need to perform any power-management tasks. For more information on developing applications that behave as user-space drivers, including information on how to set up your application to receive power-event notifications, see <em><a href="../../AccessingHardware/index.html#//apple_ref/doc/uid/TP30000376" target="_top">Accessing Hardware From Applications</a></em>.</p></div><p>The precise set of power-management responsibilities your driver must fulfill depends on factors such as how much support your driver’s superclass provides, whether your device receives power from a system bus (such as PCI), and to what power events your driver needs to respond. </p><p>If you’re unfamiliar with power management in Mac OS X, you should begin by reading the following three sections:</p><ul class="ul"><li class="li"><p><span class="content_text"><a href="PowerMgmt.html#//apple_ref/doc/uid/TP0000020-SW4">“Power Events”</a></span> which explains what power events are and how they affect your device</p></li><li class="li"><p><span class="content_text"><a href="PowerMgmt.html#//apple_ref/doc/uid/TP0000020-SW5">“The Power Plane: A Hierarchy of Power Dependencies”</a></span> which describes how Mac OS X monitors the power relationships among devices, drivers, and other objects</p></li><li class="li"><p><span class="content_text"><a href="PowerMgmt.html#//apple_ref/doc/uid/TP0000020-TPXREF104">“Devices and Power States”</a></span> which defines devices and power states in power-management terms</p></li></ul><p>Then, all driver developers should read <span class="content_text"><a href="PowerMgmt.html#//apple_ref/doc/uid/TP0000020-SW2">“Deciding How to Implement Power Management in Your Driver”</a></span> to find out what to do next. After you decide what type of power management you need to implement, read <span class="content_text"><a href="PowerMgmt.html#//apple_ref/doc/uid/TP0000020-SW3">“Implementing Basic Power Management”</a></span> and, if appropriate, <span class="content_text"><a href="PowerMgmt.html#//apple_ref/doc/uid/TP0000020-SW6">“Implementing Advanced Power Management”</a></span></p><p></p><a name="//apple_ref/doc/uid/TP0000020-SW4" title="Power Events"></a><h2>Power Events</h2><p>Before you consider how to implement power management in your driver, you need to understand what power events are and how they can affect your device. In Mac OS X, power events are transitions to and from the following states:</p><ul class="ul"><li class="li"><p>Sleep</p></li><li class="li"><p>Wake</p></li><li class="li"><p>Shutdown or restart</p></li></ul><p>All drivers must respond to sleep events. Mac OS X defines different types of sleep, which can occur for different reasons. For example, <strong>system sleep</strong> occurs when the user chooses Sleep from the Apple menu or closes the lid of a laptop; <strong>idle sleep</strong> occurs when there has been no device or system activity during the interval the user selects in the Energy Saver preferences. To your driver, however, all sleep events appear identical. The important thing to understand about a sleep event is that your device may be powered off when the system sleeps, so your driver must be prepared to initialize the device when it is awakened.</p><p>All drivers must respond to a system wake event by powering on. Wake can occur when the user hits a key on the keyboard, presses the power button, or when the computer receives a network administrator wake-up packet. On wake, drivers should perform the appropriate restoration of device state.</p><p>Device drivers do not have to respond to shutdown and restart events. A driver can choose to get notification of an impending shutdown or restart using the technique described in <span class="content_text"><a href="PowerMgmt.html#//apple_ref/doc/uid/TP0000020-SW8">“Receiving Shutdown and Restart Notifications”</a></span> but it’s important to understand that no driver can prevent a shutdown event.</p><p>Another type of event is a device power-up request, which occurs when some object in the system requires an idle or powered-off device to be in a usable state. A device power-up request notification uses most of the same mechanisms as sleep and wake notifications. Although most drivers do not need to know about device power-up requests, some drivers might need to implement them and even make such requests themselves. For more information about this, see <span class="content_text"><a href="PowerMgmt.html#//apple_ref/doc/uid/TP0000020-SW11">“Initiating a Power-State Change”</a></span> </p><a name="//apple_ref/doc/uid/TP0000020-SW5" title="The Power Plane: A Hierarchy of Power Dependencies"></a><h2>The Power Plane: A Hierarchy of Power Dependencies</h2><p>Mac OS X tracks all power-managed devices in a tree-like structure, called the power plane<a name="//apple_ref/doc/uid/TP0000020-DontLinkElementID_865"></a>, that captures the power dependencies among devices. A device, usually a leaf object in the power plane, generally receives power from its ancestors and may provide power to its children. For example, because a PCI card depends for power on the PCI bus to which it’s attached, the PCI card is considered to be a <strong>power child</strong> of the PCI bus. Likewise, the PCI bus is considered to be the <strong>power parent</strong> of the devices attached to it.</p><p>The power plane is one of the planes of the I/O Registry. As described in <span class="content_text"><a href="../TheRegistry/TheRegistry.html#//apple_ref/doc/uid/TP0000014-TP9">“The I/O Registry”</a></span> the I/O Registry is a dynamic database of device and driver objects that expresses the various provider-client relationships among them. To view the power plane in a running system, open the I/O Registry Explorer application (located in <code>/Developer/Applications/Utilities</code>) and choose IOPower from the pop-up menu. You can also enter <a name="//apple_ref/doc/uid/TP0000020-DontLinkElementID_866"></a><code>ioreg -p IOPower</code> at the command line to see a representation of the current power plane. <span class="content_text">Figure 9-1</span> shows the power plane in a Power Mac G5 running Mac OS X v10.5.</p><br/><div><a name="//apple_ref/doc/uid/TP0000020-SW7" title="Figure 9-1The power plane shown in I/O Registry Explorer"></a><p><strong>Figure 9-1&nbsp;&nbsp;</strong>The power plane shown in I/O Registry Explorer</p><img src = "../art/powerplane.jpg" alt = "" ></div><br/><p>In <span class="content_text">Figure 9-1</span> you can see the root of the power plane, an object called <code>IOPMrootDomain</code>, and objects that represent devices and drivers. You can ignore the many <code>IOPowerConnection</code> objects, which represent power connections, because these objects are of interest only to internal power-management objects and processes.</p><a name="//apple_ref/doc/uid/TP0000020-TPXREF104" title="Devices and Power States"></a><h2>Devices and Power States</h2><a name="//apple_ref/doc/uid/TP0000020-DontLinkElementID_867"></a><a name="//apple_ref/doc/uid/TP0000020-DontLinkElementID_868"></a><p>The fundamental entity in power management is the device. From a power-management perspective, a device is a unit of hardware whose power consumption can be measured and controlled independently of system power. A device can also have some state that needs to be saved and restored across changes in power. In power-management terms, “device” is synonymous with the device-driver object that controls it.</p><p></p><p></p><p>A device must have at least two power states associated with it—off and on. A device may also have intermediate states that represent some level of power between full power and no power. These states are described in a power-state array you create in your driver. (You learn how to create this array and provide power-state information in step 3 in <span class="content_text"><a href="PowerMgmt.html#//apple_ref/doc/uid/TP0000020-SW3">“Implementing Basic Power Management”</a></span>) The power-management functionality of the I/O Kit uses these states to ensure that all drivers in the power plane receive the power they require. Each power state is defined by the device’s capabilities when in that state:</p><ul class="ul"><li class="li"><p>A device that is on uses maximum power and has complete functionality.</p></li><li class="li"><p>A device that is off uses no power and has no functionality.</p></li><li class="li"><p>A device can be in a reduced-power state in which it is still usable, but at a lower level of performance or functionality.</p></li><li class="li"><p>A device can be in an intermediate state in which it is not usable, but retains some configuration or state.</p></li></ul><p>The power-management functionality of the I/O Kit associates several attributes with each power state of a device. A device driver must set these attributes to ensure that accurate information about the device’s capabilities and requirements is available. </p><p>The power-state attributes provide the following information:</p><ul class="ul"><li class="li"><p>The capability of the device while in a given state</p></li><li class="li"><p>The device’s power requirements of its power parent</p></li><li class="li"><p>The power characteristics the device can provide to its power children</p></li><li class="li"><p>The version of the power-state structure the device uses to store its power-state information</p></li></ul><p></p><p></p><p></p><a name="//apple_ref/doc/uid/TP0000020-SW2" title="Deciding How to Implement Power Management in Your Driver"></a><h2>Deciding How to Implement Power Management in Your Driver</h2><p>To participate in Mac OS X power management, most in-kernel drivers need only ensure that their devices respond appropriately to system sleep and wake events. Some in-kernel drivers might need to perform other tasks, such as implementing an idle state or taking action at system shutdown, but these drivers are not typical. Reflecting this distinction, Mac OS X power management defines two types of drivers:</p><ul class="ul"><li class="li"><p>A <strong>passive</strong> driver implements basic power management to respond to system power events; it does not initiate any power-related actions for its device.</p></li><li class="li"><p>An <strong>active</strong> driver implements basic power management to respond to system power events, but it also implements advanced power management to perform tasks such as deciding when the device should become idle, changing the device’s power state, or processing prior to system shutdown.</p></li></ul><p>An example of a passive driver is the AppleSmartBatteryManager driver present in most Macintosh laptop computers. The AppleSmartBatteryManager driver provides battery-status information to the battery-status menu bar item; when the system is about to sleep, the driver simply stops polling the battery for status information. A good example of an active driver is the built-in audio chip driver, because it performs its own idleness determination to allow the audio hardware to power off when it is not in use. If there is no sound coming out of a laptop's or desktop's internal speakers, the audio hardware will drop into a low power mode until it is needed.</p><p>As you can imagine, a passive driver is much easier than an active driver to design and implement. Essentially, a passive driver implements one virtual method and makes between three and five calls to participate in power management. The responsibilities of an active driver, on the other hand, begin with those of a passive driver, but increase with each additional task the driver needs to perform.</p><p>Some I/O Kit families provide various levels of built-in power-management support to driver subclasses. For example, the Network family (<code>IONetworkingFamily</code>) performs some of the power-management initialization tasks for a subclass driver, leaving the driver to perform other device-specific power-management tasks.</p><p>Before you begin designing your driver’s power-management implementation, you should look up your I/O Kit family in <span class="content_text"><a href="../Families_Ref/Families_Ref.html#//apple_ref/doc/uid/TP0000021-BABCCBIJ">“I/O Kit Family Reference”</a></span> to find out if the family provides any power-management support or requires subclasses to perform different or additional tasks. Be aware, however, that any I/O Kit family that provides power-management functionality may still require you to implement some parts of it. The following I/O Kit families provide some type of power-management functionality:</p><ul class="ul"><li class="li"><p>Audio family (described in <span class="content_text"><a href="../Families_Ref/Families_Ref.html#//apple_ref/doc/uid/TP0000021-BABJHDJH">“Audio”</a></span>)</p></li><li class="li"><p>FireWire family (described in <span class="content_text"><a href="../Families_Ref/Families_Ref.html#//apple_ref/doc/uid/TP0000021-BABIAGJE">“FireWire”</a></span>)</p></li><li class="li"><p>Network family (described in <span class="content_text"><a href="../Families_Ref/Families_Ref.html#//apple_ref/doc/uid/TP0000021-BABFBCFG">“Network”</a></span>)</p></li><li class="li"><p>PC card family, which includes Express Card devices (described in <span class="content_text"><a href="../Families_Ref/Families_Ref.html#//apple_ref/doc/uid/TP0000021-BABIBHJB">“PC Card”</a></span>)</p></li><li class="li"><p>PCI family (described in <span class="content_text"><a href="../Families_Ref/Families_Ref.html#//apple_ref/doc/uid/TP0000021-BABBIFFH">“PCI and AGP”</a></span>)</p></li><li class="li"><p>SCSI Architecture Model family (described in <span class="content_text"><a href="../Families_Ref/Families_Ref.html#//apple_ref/doc/uid/TP0000021-BABECGBG">“SCSI Architecture Model”</a></span>)</p></li><li class="li"><p>USB family (described in <span class="content_text"><a href="../Families_Ref/Families_Ref.html#//apple_ref/doc/uid/TP0000021-BABJBGJA">“USB”</a></span>)</p></li></ul><p>Even if your driver is a subclass of an I/O Kit family that does not provide any power-management support, or if your driver is a direct subclass of <code>IOService</code>, it can still be a passive power-management participant as long as it only responds to system-initiated power events. If, on the other hand, your driver needs to determine when your device is idle or perform pre-shutdown tasks, you must implement advanced power management. </p><p>If you decide to develop a passive driver, you should read <span class="content_text"><a href="PowerMgmt.html#//apple_ref/doc/uid/TP0000020-SW3">“Implementing Basic Power Management”</a></span> to learn how to participate in power management and respond to sleep and wake events. You do not need to read any other sections in this chapter. </p><p>If your driver needs to be an active power manager, you should also read <span class="content_text"><a href="PowerMgmt.html#//apple_ref/doc/uid/TP0000020-SW3">“Implementing Basic Power Management”</a></span> Then you should read <span class="content_text"><a href="PowerMgmt.html#//apple_ref/doc/uid/TP0000020-SW6">“Implementing Advanced Power Management”</a></span> for guidance on implementing specific tasks.</p><a name="//apple_ref/doc/uid/TP0000020-SW3" title="Implementing Basic Power Management"></a><h2>Implementing Basic Power Management</h2><p>As defined in <span class="content_text"><a href="PowerMgmt.html#//apple_ref/doc/uid/TP0000020-SW2">“Deciding How to Implement Power Management in Your Driver”</a></span> a passive driver only responds to sleep and wake events; it does not initiate any power state–changing activity. Your passive driver must do the following things to handle sleep and wake: </p><ul class="ul"><li class="li"><p>Get attached into the power plane so you receive power-change notifications and to ensure that your device’s power dependencies are considered when it is told to sleep and wake.</p><p>Power dependencies affect the ordering of sleep and wake notifications. Specifically, your driver is told to sleep before its power parent is told to sleep, and your driver is told to wake after its power parent is told to wake.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP0000020-DontLinkElementID_65" title="Note"></a><p><strong>Note:</strong>&nbsp;It’s possible for a device to have more than one power parent, but it’s important to understand that, in this case, a specific ordering of power changes is not guaranteed. Specifically, your device is awakened after the first power parent wakes up, not after all power parents wake up. </p></div></li><li class="li"><p>Save hardware state to memory before system sleep and restore state during wake.</p><p>You are responsible for writing code to do this.</p></li><li class="li"><p>Prevent all hardware accesses while your device is preparing for sleep.</p><p>You can return an error to any I/O request you receive while your device is going to sleep or you can block all incoming threads using a gating mechanism, such as <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOCommandGate_h/Classes/IOCommandGate/index.html#//apple_ref/cpp/cl/IOCommandGate" target="_top">IOCommandGate</a></code>, on your work loop (see <span class="content_text"><a href="../HandlingEvents/HandlingEvents.html#//apple_ref/doc/uid/TP0000018-BAJFICDI">“Work Loops ”</a></span> to learn more about work loops). </p></li></ul><p>To participate in power management so that you receive notifications of power events, ensure your driver is correctly attached into the power plane, and handle power-state changes, you make a few calls and implement one virtual method. The <code><a href="../../../../Darwin/Reference/KernelIOKitFramework/IOService_h/Classes/IOService/index.html#//apple_ref/doc/class/IOService" target="_top">IOService</a></code> class provides all the methods described in this section. Follow the steps listed below to implement basic power management in your driver.</p><ol class="ol"><li class="li"><p>Initialize power management using <code><!--a-->PMinit<!--/a--></code>. The <code><!--a target="_top" -->PMinit<!--/a--></code> method allocates internal power-management data structures that allow internal processes to track your driver. </p><p>In your driver’s <code>start</code> routine, after the call to your superclass’s <code>start</code> method, make the following call:</p><div class="codesample"><table><tr><td scope="row"><pre>PMinit();<span></span></pre></td></tr></table></div></li><li class="li"><p>Get attached into the power plane using <code><!--a-->joinPMtree<!--/a--></code>. The <code><!--a target="_top" -->joinPMtree<!--/a--></code> method attaches the passed-in driver object into the power plane as a child of its provider.</p><p>In your driver’s <code>start</code> routine, after the call to <code><!--a-->PMinit<!--/a--></code> and before the call to <code><!--a-->registerPowerDriver<!--/a--></code> (shown in step 3), call <code><!--a-->joinPMtree<!--/a--></code> as shown below:</p><div class="codesample"><table><tr><td scope="row"><pre>provider->joinPMtree(this);<span></span></pre></td></tr></table></div></li><li class="li"><p>Provide information about your device’s power states and register your driver with power management.</p><ol class="ol"><li class="ol ol"><p>First, declare an array of two structures to contain information about your device’s off and on states. The first element in the array must contain the structure that describes the off state and the second element of the array must contain the structure that describes the on state. Typically, a driver switches its device to the off state in response to a sleep event and to the on state in response to a wake event, as described in <span class="content_text"><a href="PowerMgmt.html#//apple_ref/doc/uid/TP0000020-SW4">“Power Events”</a></span></p><p>In your driver’s <code>start</code> routine, after the call to <code><!--a-->joinPMtree<!--/a--></code>, fill in two <code>IOPMPowerState</code> structures, as shown below:</p><div class="codesample"><table><tr><td scope="row"><pre>// Declare an array of two IOPMPowerState structures (kMyNumberOfStates = 2).<span></span></pre></td></tr><tr><td scope="row"><pre>static IOPMPowerState myPowerStates[kMyNumberOfStates];<span></span></pre></td></tr><tr><td scope="row"><pre>// Zero-fill the structures.<span></span></pre></td></tr><tr><td scope="row"><pre>bzero (myPowerStates, sizeof(myPowerStates));<span></span></pre></td></tr><tr><td scope="row"><pre>// Fill in the information about your device's off state:<span></span></pre></td></tr><tr><td scope="row"><pre>myPowerStates[0].version = 1;<span></span></pre></td></tr><tr><td scope="row"><pre>myPowerStates[0].capabilityFlags = kIOPMPowerOff;<span></span></pre></td></tr><tr><td scope="row"><pre>myPowerStates[0].outputPowerCharacter = kIOPMPowerOff;<span></span></pre></td></tr><tr><td scope="row"><pre>myPowerStates[0].inputPowerRequirement = kIOPMPowerOff;<span></span></pre></td></tr><tr><td scope="row"><pre>// Fill in the information about your device's on state:<span></span></pre></td></tr><tr><td scope="row"><pre>myPowerStates[1].version = 1;<span></span></pre></td></tr><tr><td scope="row"><pre>myPowerStates[1].capabilityFlags = kIOPMPowerOn;<span></span></pre></td></tr><tr><td scope="row"><pre>myPowerStates[1].outputPowerCharacter = kIOPMPowerOn;<span></span></pre></td></tr><tr><td scope="row"><pre>myPowerStates[1].inputPowerRequirement = kIOPMPowerOn;<span></span></pre></td></tr></table></div><p>In some drivers, you might see this step implemented in code similar to the following:</p><div class="codesample"><table><tr><td scope="row"><pre>static IOPMPowerState myPowerStates[kMyNumberOfStates] = {<span></span></pre></td></tr><tr><td scope="row"><pre>   {1, kIOPMPowerOff, kIOPMPowerOff, kIOPMPowerOff, 0, 0, 0, 0, 0, 0, 0, 0},<span></span></pre></td></tr><tr><td scope="row"><pre>   {1, kIOPMPowerOn, kIOPMPowerOn, kIOPMPowerOn, 0, 0, 0, 0, 0, 0, 0, 0}<span></span></pre></td></tr><tr><td scope="row"><pre>};<span></span></pre></td></tr></table></div></li><li class="ol ol"><p>Then, still in your driver’s <code>start</code> routine, register your driver with power management using <code><!--a target="_top" -->registerPowerDriver<!--/a--></code>. The <code><!--a-->registerPowerDriver<!--/a--></code> method tells power management that the passed-in driver object can transition the device between the power states described in the passed-in array. After you fill in the <code>IOPMPowerState</code> structures, call <code><!--a-->registerPowerDriver<!--/a--></code> with your power-state array as shown below:</p><div class="codesample"><table><tr><td scope="row"><pre>registerPowerDriver (this, myPowerStates, kMyNumberOfStates);<span></span></pre></td></tr></table></div></li></ol></li><li class="li"><p>Handle power-state changes using <code><!--a target="_top" -->setPowerState<!--/a--></code>. While your driver is running, you perform tasks that handle sleep and wake event notifications in your implementation of the virtual <code>IOService</code> method <code><!--a-->setPowerState<!--/a--></code>. An example of how to do this is shown below:</p><p></p><div class="codesample"><table><tr><td scope="row"><pre>IOReturn MyIOServiceDriver::setPowerState ( unsigned long whichState, IOService * whatDevice )<span></span></pre></td></tr><tr><td scope="row"><pre>// Note that it is safe to ignore the whatDevice parameter.<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>   if ( 0 == whichState ) {<span></span></pre></td></tr><tr><td scope="row"><pre>      // Going to sleep. Perform state-saving tasks here.<span></span></pre></td></tr><tr><td scope="row"><pre>   } else {<span></span></pre></td></tr><tr><td scope="row"><pre>      // Waking up. Perform device initialization here.<span></span></pre></td></tr><tr><td scope="row"><pre>   }<span></span></pre></td></tr><tr><td scope="row"><pre>   if ( done )<span></span></pre></td></tr><tr><td scope="row"><pre>      return kIOPMAckImplied;<span></span></pre></td></tr><tr><td scope="row"><pre>   else<span></span></pre></td></tr><tr><td scope="row"><pre>      return (/* a number of microseconds that represents the maximum time required to prepare for the state change */);<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>If you return <code>kIOPMAckImplied</code>, you signal that you’ve completed the transition to the new power state. If you do not return <code>kIOPMAckImplied</code> and instead return the maximum amount of time it takes to prepare your device for the power-state change, you must be sure to call <code><!--a target="_top" -->acknowledgeSetPowerState<!--/a--></code> when you have finished the power-state transition. If you do not call <code><!--a-->acknowledgeSetPowerState<!--/a--></code> before the length of time you specify has elapsed, the system continues with its power-state change as if you had returned <code>kIOPMAckImplied</code> in the first place.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP0000020-DontLinkElementID_66" title="Note"></a><p><strong>Note:</strong>&nbsp;If you are developing a driver for Mac OS X v10.5 or later, you may perform all necessary processing to prepare for the state change in the <code><!--a-->setPowerState<!--/a--></code> method before you return <code>kIOPMAckImplied</code>. In other words, you do not have to return an estimate of how long the processing will take, perform the processing in another method, and call <code><!--a-->acknowledgeSetPowerState<!--/a--></code> when the processing is finished.</p></div></li><li class="li"><p>Unregister from power management when your driver unloads using <code><!--a target="_top" -->PMstop<!--/a--></code>. The <code><!--a-->PMstop<!--/a--></code> method handles all the necessary cleanup, including the removal of your driver from the power plane. Because <code><!--a-->PMstop<!--/a--></code> may put your hardware into its off state, be sure to complete all hardware accesses before you call it.</p><div class="importantbox"><a name="//apple_ref/doc/uid/TP0000020-DontLinkElementID_67" title="Important:"></a><p><strong>Important:</strong>&nbsp;This step is crucial. If you neglect to call <code><!--a-->PMstop<!--/a--></code>, you will probably cause a leak and you might cause a system panic the next time the computer wakes up.</p><p></p></div><p>In your driver’s <code>stop</code> routine, after you finish all calls that might access your hardware, call <code>PMstop</code> as shown below:</p><div class="codesample"><table><tr><td scope="row"><pre>PMstop();<span></span></pre></td></tr></table></div></li></ol><a name="//apple_ref/doc/uid/TP0000020-SW6" title="Implementing Advanced Power Management"></a><h2>Implementing Advanced Power Management</h2><p>This section delves deeper into the power-management functionality of the I/O Kit. The vast majority of driver developers do not need to understand the information in this section because basic power management (as described in <span class="content_text"><a href="PowerMgmt.html#//apple_ref/doc/uid/TP0000020-SW2">“Deciding How to Implement Power Management in Your Driver”</a></span>) is sufficient for most devices. If your device can be passively power managed, read <span class="content_text"><a href="PowerMgmt.html#//apple_ref/doc/uid/TP0000020-SW3">“Implementing Basic Power Management”</a></span> instead.</p><p>You should read this section if your driver needs to perform advanced power-management tasks, such as determining device idleness, taking action when the system is about to shutdown, or deciding to change the device’s power state. Of course, active drivers share some tasks with passive drivers, namely the initialization and tear-down of power management. Before you read about the tasks in this section, therefore, you should glance at the steps in <span class="content_text"><a href="PowerMgmt.html#//apple_ref/doc/uid/TP0000020-SW3">“Implementing Basic Power Management”</a></span> to learn how to initialize and terminate power management in your driver. Even if your driver must perform advanced power-management tasks, it still needs to call <code><!--a-->PMinit<!--/a--></code>, <code><!--a-->joinPMtree<!--/a--></code>, <code><!--a-->registerPowerDriver<!--/a--></code>, and <code><!--a-->PMstop<!--/a--></code> and implement <code><!--a-->setPowerState<!--/a--></code>, as shown in <span class="content_text">“Implementing Basic Power Management”</span></p><p>This section covers several tasks an active driver might need to perform. Although few active drivers will perform all the tasks, most will perform at least one. Each task is accompanied by a code snippet to help you implement it in your driver.</p><a name="//apple_ref/doc/uid/TP0000020-SW1" title="Defining and Using Multiple Power States"></a><h3>Defining and Using Multiple Power States</h3><p>As described in <span class="content_text"><a href="PowerMgmt.html#//apple_ref/doc/uid/TP0000020-TPXREF104">“Devices and Power States”</a></span> information about a device’s power states and capabilities must be available to I/O Kit power management. Although most devices have only the two required power states, off and on, some devices have additional states. As shown in step 3 of <span class="content_text"><a href="PowerMgmt.html#//apple_ref/doc/uid/TP0000020-SW3">“Implementing Basic Power Management”</a></span> you construct an array of <code>IOPMPowerState</code> structures, each of which contains information about the device’s capabilities in each power state.<span class="content_text">Table 9-1</span> describes the fields in the <code>IOPMPowerState</code> structure, which is defined in the <code>IOPM.h</code> header file.</p><a name="//apple_ref/doc/uid/TP0000020-BAJFECJJ" title="Table 9-1Fields and appropriate values in the IOPMPowerState structure"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 9-1&nbsp;&nbsp;</strong>Fields and appropriate values in the <code>IOPMPowerState</code> structure</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Field</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Description</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Value</p></th></tr><tr><td  scope="row"><p><code>version</code></p></td><td ><p>Version number of this structure.</p></td><td ><p>1</p></td></tr><tr><td  scope="row"><p><code>capabilityFlags</code></p></td><td ><p>The capability of the device in this state.</p></td><td ><p>An <code>IOPMPowerFlags</code> flag.</p></td></tr><tr><td  scope="row"><p><code>outputPowerCharacter</code></p></td><td ><p>The power supplied in this state.</p></td><td ><p>An <code>IOPMPowerFlags</code> flag.</p></td></tr><tr><td  scope="row"><p><code>inputPowerRequirement</code></p></td><td ><p>The input power required in this state.</p></td><td ><p>An <code>IOPMPowerFlags</code> flag.</p></td></tr><tr><td  scope="row"><p><code>staticPower</code></p></td><td ><p>Average power consumption (in milliwatts) of a device in this state.</p></td><td ><p>0</p></td></tr><tr><td  scope="row"><p><code>unbudgetedPower</code></p></td><td ><p>Additional power consumption (in milliwatts) from a separate power supply, such as a battery.</p></td><td ><p>0</p></td></tr><tr><td  scope="row"><p><code>powerToAttain</code></p></td><td ><p>The power consumed by a device (in milliwatts) in entering this state from the next lowest state.</p></td><td ><p>0</p></td></tr><tr><td  scope="row"><p><code>timeToAttain</code></p></td><td ><p>The time (in microseconds) required for a device to enter this state from the next lower state; in other words, the time required to program the hardware.</p></td><td ><p>0</p></td></tr><tr><td  scope="row"><p><code>settleUpTime</code></p></td><td ><p>The time (in microseconds) required to allow power to settle after entering this state from the next lower state.</p></td><td ><p>0</p></td></tr><tr><td  scope="row"><p><code>timeToLower</code></p></td><td ><p>The time (in microseconds) required for a device to enter the next lower state from this state; in other words, the time required to program the hardware.</p></td><td ><p>0</p></td></tr><tr><td  scope="row"><p><code>settleDownTime</code></p></td><td ><p>The time (in microseconds) required to allow power to settle after entering the next lower state from this state.</p></td><td ><p>0</p></td></tr><tr><td  scope="row"><p><code>powerDomainBudget</code></p></td><td ><p>The power (in milliwatts) that a power parent in this state is electronically able to deliver to its children.</p></td><td ><p>0</p></td></tr></table></div><p>As shown in <span class="content_text">Table 9-1</span> the values of some fields may be provided by an <code>IOPMPowerFlags</code> flag. <span class="content_text">Table 9-2</span> shows the <code>IOPMPowerFlags</code> flags you are likely to use.</p><p></p><a name="//apple_ref/doc/uid/TP0000020-BAJCIGDJ" title="Table 9-2Power flags that describe device capabilities"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 9-2&nbsp;&nbsp;</strong>Power flags that describe device capabilities</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Flag</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Description</p></th></tr><tr><td  scope="row"><p><code>kIOPMPowerOn</code></p></td><td ><p>The device is in the full-power state.</p></td></tr><tr><td  scope="row"><p><code>kIOPMDeviceUsable</code></p></td><td ><p>The clients of the device can use it in this state.</p></td></tr><tr><td  scope="row"><p><code>kIOPMMaxPerformance</code></p></td><td ><p>The device is capable of its highest performance in this state.</p></td></tr><tr><td  scope="row"><p><code>kIOPMAuxPowerOn</code></p></td><td ><p>The PCI auxiliary power supply is on (used only by devices in the PCI family).</p></td></tr></table></div><p>Power management has the following requirements for the array of <code>IOPMPowerState</code> structures you construct in your driver’s <code><!--a-->start<!--/a--></code> method:</p><ul class="spaceabove"><li class="li"><p>The <code>IOPMPowerState</code> structure describing your device’s off state must be the first element in the array.</p></li><li class="li"><p>The <code>IOPMPowerState</code> structure describing your device’s on (that is, full power) state must be the last element in the array.</p></li><li class="li"><p>You can define any number of intermediate power states, but the <code>IOPMPowerState</code> structures describing them must not be the first or last elements of the array.</p></li></ul><p>After you construct the power-state array to these specifications, <a name="//apple_ref/doc/uid/TP0000020-DontLinkElementID_869"></a>call <code>registerPowerDriver</code>, passing in a pointer to the array and the number of power states. <a name="//apple_ref/doc/uid/TP0000020-DontLinkElementID_870"></a> <span class="content_text">Listing 9-1</span> shows one way to do this. It also shows the driver creating a work loop and setting up a command gate to synchronize the power state-change code, which is described in <span class="content_text"><a href="PowerMgmt.html#//apple_ref/doc/uid/TP0000020-TPXREF111">“Changing the Power State of a Device”</a></span></p><a name="//apple_ref/doc/uid/TP0000020-BAJFAAAH" title="Listing 9-1Building the power-state array and registering the driver"></a><p class="codesample"><strong>Listing 9-1&nbsp;&nbsp;</strong>Building the power-state array and registering the driver</p><div class="codesample"><table><tr><td scope="row"><pre>enum {<span></span></pre></td></tr><tr><td scope="row"><pre>    kMyOffPowerState  = 0,<span></span></pre></td></tr><tr><td scope="row"><pre>    kMyIdlePowerState   = 1,<span></span></pre></td></tr><tr><td scope="row"><pre>    kMyOnPowerState = 2<span></span></pre></td></tr><tr><td scope="row"><pre>};<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>static IOPMPowerState myPowerStates[3] = {<span></span></pre></td></tr><tr><td scope="row"><pre>    {1, kMyOffPowerState, kMyOffPowerState, kMyOffPowerState, 0, 0, 0, 0, 0, 0, 0, 0},<span></span></pre></td></tr><tr><td scope="row"><pre>    {1,kIOPMPowerOn, kIOPMPowerOn, kIOPMPowerOn, 0, 0, 0, 0, 0, 0, 0, 0},<span></span></pre></td></tr><tr><td scope="row"><pre>    {1,kIOPMPowerOn, kIOPMPowerOn, kIOPMPowerOn, 0, 0, 0, 0, 0, 0, 0, 0}<span></span></pre></td></tr><tr><td scope="row"><pre>};<span></span></pre></td></tr><tr><td scope="row"><pre>bool PMExampleDriver::start(IOService * provider)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>   /*<span></span></pre></td></tr><tr><td scope="row"><pre>    * Create a work loop and set up synchronization<span></span></pre></td></tr><tr><td scope="row"><pre>    * using a command gate.<span></span></pre></td></tr><tr><td scope="row"><pre>    */<span></span></pre></td></tr><tr><td scope="row"><pre>    fWorkloop = IOWorkLoop::workLoop();<span></span></pre></td></tr><tr><td scope="row"><pre>    fGate = IOCommandGate::commandGate(this);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if (fGate &amp;&amp; fWorkloop) {<span></span></pre></td></tr><tr><td scope="row"><pre>        fWorkloop->addEventSource(fGate);<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>     * Initialize power management, join the power plane,<span></span></pre></td></tr><tr><td scope="row"><pre>     * and register with power management.<span></span></pre></td></tr><tr><td scope="row"><pre>     */<span></span></pre></td></tr><tr><td scope="row"><pre>    PMinit();<span></span></pre></td></tr><tr><td scope="row"><pre>    provider->joinPMtree(this);<span></span></pre></td></tr><tr><td scope="row"><pre>    registerPowerDriver(this, myPowerStates, 3);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP0000020-TPXREF111" title="Changing the Power State of a Device"></a><h3>Changing the Power State of a Device</h3><a name="//apple_ref/doc/uid/TP0000020-DontLinkElementID_871"></a><p>A driver is responsible for changing the power state of its device. Most power-state change requests come from power management when the system is about to sleep or wake. It’s also possible for an active driver to become aware of the need to change its device’s power state and initiate the request. The following sections describe both tasks.</p><a name="//apple_ref/doc/uid/TP0000020-SW10" title="Responding to a Power State&acirc;&#128;&#147;Change Request"></a><h4>Responding to a Power State–Change Request</h4><p>As with a passive driver, an active driver must override the <code>setPowerState</code> method and change the power state of its device when it is instructed to do so. The ordinal value passed in to <code><!--a-->setPowerState<!--/a--></code> is an index to the power-state array for the device.</p><p>If you’re developing a driver to run in versions of Mac OS X prior to v10.5, you must perform only the minimum processing required to change the power state of your device in your <code>setPowerState</code> method. Any additional processing must be performed outside of the <code>setPowerState</code> method and followed by a call to <code><!--a-->acknowledgeSetPowerState<!--/a--></code> when it is finished. This is described in step 4 of <span class="content_text"><a href="PowerMgmt.html#//apple_ref/doc/uid/TP0000020-SW3">“Implementing Basic Power Management”</a></span></p><p>If, on the other hand, your driver will run in Mac OS X v10.5 and later, you can perform all necessary processing in your <code>setPowerState</code> method before you return <code>kIOPMAckImplied</code>. It’s important to understand, however, that power management calls the <code><!--a-->setPowerState<!--/a--></code> method from a thread-call context. In other words, power management does not perform any automatic synchronization using your driver’s work loop. Therefore, it’s essential that you continue to use a command gate or other locking primitive to ensure that access to your device’s state is serialized.</p><p>As soon as your driver returns <code>kIOPMAckImplied</code> or calls <code><!--a-->acknowledgeSetPowerState<!--/a--></code> after additional processing, power management marks the power change as completed. Thus it’s important for all drivers, regardless of the version of Mac OS X they target, to avoid reporting a power change as complete until the power-state of the device has actually changed. It’s possible that other power changes depend on your hardware having completed its power change before you call <code><!--a-->acknowledgeSetPowerState<!--/a--></code>.</p><p></p><a name="//apple_ref/doc/uid/TP0000020-SW11" title="Initiating a Power-State Change"></a><h4>Initiating a Power-State Change</h4><p>An active driver might become aware of the need to change its device’s power state, either through mechanisms of its own or through some other object. The <code>IOService</code> class provides three methods that assist in this task:</p><ul class="spaceabove"><li class="li"><p><code><!--a-->makeUsable<!--/a--></code></p></li><li class="li"><p><code><!--a-->changePowerStateTo<!--/a--></code></p></li><li class="li"><p><code><!--a-->changePowerStateToPriv<!--/a--></code></p></li></ul><p></p><p>Any object in the driver stack, including a user client (described in <span class="content_text"><a href="../ArchitectOverview/ArchitectOverview.html#//apple_ref/doc/uid/TP0000013-TPXREF103">“The Device-Interface Mechanism ”</a></span>), can request that a dormant device be made active by calling the <code><!--a-->makeUsable<!--/a--></code> method on the device’s driver. The <code><!--a-->makeUsable<!--/a--></code> method is interpreted as a request to put the device in its highest power state.</p><p>An active driver typically calls the <code><!--a-->changePowerStateTo<!--/a--></code> method once in its <code><!--a-->start<!--/a--></code> method, to set an initial power state. Later, when it wants to change its device’s power state, an active driver calls the <code><!--a-->changePowerStateToPriv<!--/a--></code> method, passing in the desired power state. An active driver might do this to shut down parts of the hardware that are not currently being used. </p><div class="importantbox"><a name="//apple_ref/doc/uid/TP0000020-DontLinkElementID_68" title="Important:"></a><p><strong>Important:</strong>&nbsp;Even though the <code><!--a-->makeUsable<!--/a--></code>, <code><!--a-->changePowerStateTo<!--/a--></code>, and <code><!--a-->changePowerStateToPriv<!--/a--></code> methods are asynchronous and return immediately, you must block all hardware access until you receive the call to your <code><!--a-->setPowerState<!--/a--></code> method. Before your <code><!--a-->setPowerState<!--/a--></code> method is called, you cannot be certain that your device is in a usable state. Because of this, these functions should be called in a work-loop context.</p><p></p></div><p>Power management uses the states passed in to <code><!--a-->changePowerStateTo<!--/a--></code> and <code><!--a-->changePowerStateToPriv<!--/a--></code> to determine the device’s new power state. Specifically, power management selects as the new power state the highest value of the following three values:</p><ul class="simple"><li><p>The power state set by <code><!--a-->changePowerStateToPriv<!--/a--></code></p></li><li><p>The power state set by <code><!--a-->changePowerStateTo<!--/a--></code></p></li><li><p>The highest of all power states required by the driver’s power children</p></li></ul><p>The following code snippet shows how a driver can get the device’s current power state (using the <code><!--a-->getPowerState<!--/a--></code> method introduced in Mac OS X v10.5) and then request a power-state change with <code><!--a-->changePowerStateToPriv<!--/a--></code>.</p><div class="codesample"><table><tr><td scope="row"><pre>enum {<span></span></pre></td></tr><tr><td scope="row"><pre>    kMyOffState = 0,<span></span></pre></td></tr><tr><td scope="row"><pre>    kMyOnState = 1<span></span></pre></td></tr><tr><td scope="row"><pre>};<span></span></pre></td></tr><tr><td scope="row"><pre>/*<span></span></pre></td></tr><tr><td scope="row"><pre> * Make sure the hardware is in the ON state<span></span></pre></td></tr><tr><td scope="row"><pre> * before accessing it. If it's powered off, call changePowerStateToPriv<span></span></pre></td></tr><tr><td scope="row"><pre> * to put the device in the ON state.<span></span></pre></td></tr><tr><td scope="row"><pre> */<span></span></pre></td></tr><tr><td scope="row"><pre>if (getPowerState() == kMyOnState)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    /* Device is ON. OK to access hardware. */<span></span></pre></td></tr><tr><td scope="row"><pre>} else {<span></span></pre></td></tr><tr><td scope="row"><pre>    changePowerStateToPriv( kMyOnState );<span></span></pre></td></tr><tr><td scope="row"><pre>    /*<span></span></pre></td></tr><tr><td scope="row"><pre>     * Note: If your device has been powered off for a system sleep, you cannot<span></span></pre></td></tr><tr><td scope="row"><pre>     * try to adjust your power state upwards. You are locked in your OFF or<span></span></pre></td></tr><tr><td scope="row"><pre>     * low-power state until system power is restored on wake.<span></span></pre></td></tr><tr><td scope="row"><pre>     */<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    /*<span></span></pre></td></tr><tr><td scope="row"><pre>     * Although changePowerStateToPriv returns immediately,<span></span></pre></td></tr><tr><td scope="row"><pre>     * it is _NOT_ safe to touch the hardware yet. You must wait until you<span></span></pre></td></tr><tr><td scope="row"><pre>     * receive your setPowerState() call before you can safely modify<span></span></pre></td></tr><tr><td scope="row"><pre>     * the hardware.<span></span></pre></td></tr><tr><td scope="row"><pre>     */<span></span></pre></td></tr><tr><td scope="row"><pre>}<a name="//apple_ref/doc/uid/TP0000020-DontLinkElementID_872"></a><span></span></pre></td></tr></table></div>	<a name="//apple_ref/doc/uid/TP0000020-TPXREF108" title="Implementing Idleness Determination and Idle Power Saving"></a><h3>Implementing Idleness Determination and Idle Power Saving</h3><p>When a device is idle, it can be powered down to conserve system power, which is especially important for laptop computers running on battery power. You should implement idle power saving in your device if:</p><ul class="spaceabove"><li class="li"><p>Access to your device is intermittent, and the device is often left unused for minutes, hours, or days at a time.</p></li><li class="li"><p>Your device consumes a significant amount of power, and putting it in a low power state when possible results in substantial power savings.</p></li></ul><p>To implement idle power saving, you must determine when your device is idle and specify how long the period of idleness should last before your device powers off. You determine idleness by supplying device-access information to the <code>IOService</code> superclass, which uses this information, in conjunction with the idleness period you specify, to tell your device to power off at the appropriate time. The <code>IOService</code> class provides two methods an <a name="//apple_ref/doc/uid/TP0000020-DontLinkElementID_873"></a>active <a name="//apple_ref/doc/uid/TP0000020-DontLinkElementID_874"></a><a name="//apple_ref/doc/uid/TP0000020-DontLinkElementID_875"></a>driver uses to do this:</p><ul class="spaceabove"><li class="li"><p><code><!--a target="_top" -->activityTickle<!--/a--></code>. On your device’s access path, you call <code><!--a-->activityTickle<!--/a--></code> every time your driver or any other client (including an application) triggers a hardware access. This allows power management to confirm that your device is in a usable state and to track the most recent access times for your device.</p></li><li class="li"><p><code><!--a target="_top" -->setIdleTimerPeriod<!--/a--></code>. You call <code><!--a-->setIdleTimerPeriod<!--/a--></code> to specify the duration of a watchdog timer that tracks how long your device can be idle at full power before it should be powered down. By setting the duration of the idle period, you effectively start a countdown that begins after each device access.</p></li></ul><p>When the idle period expires without any device activity, power management calls your implementation of the <code><!--a-->setPowerState<!--/a--></code> method to lower your device’s power state. See <span class="content_text"><a href="PowerMgmt.html#//apple_ref/doc/uid/TP0000020-TPXREF111">“Changing the Power State of a Device”</a></span> for more information on how to implement this method. </p><p>Of course, you must respond to any device-access request you receive while your device is powered off by first setting your device to its full-power state. Because you call <code><!--a-->activityTickle<!--/a--></code> on your device’s access path, power management is immediately alerted to the fact that some entity is requesting access to a device that is currently powered off. When this happens, the <code>IOService</code> superclass automatically calls <code><!--a-->makeUsable<!--/a--></code> on your device, which ultimately results in a call to your implementation of the <code><!--a-->setPowerState<!--/a--></code> method.</p><div class="importantbox"><a name="//apple_ref/doc/uid/TP0000020-DontLinkElementID_69" title="Important:"></a><p><strong>Important:</strong>&nbsp;As described in <span class="content_text"><a href="PowerMgmt.html#//apple_ref/doc/uid/TP0000020-SW11">“Initiating a Power-State Change”</a></span> you must block all hardware accesses until your <code><!--a-->setPowerState<!--/a--></code> implementation is called, because you cannot be certain that your device is in a usable state until that time. The best way to do this is to use a work loop to serialize hardware access.</p><p></p></div><p>The following steps outline the process of idleness determination:</p><ol class="ol"><li class="li"><p>Specify how long your device should remain in a high-power state while idle. Typically, one minute is an appropriate interval.</p><p>Call <code><!--a-->setIdleTimerPeriod<!--/a--></code>, passing in the idle interval in seconds, as shown below:</p><div class="codesample"><table><tr><td scope="row"><pre>setIdleTimerPeriod ( 60 );<span></span></pre></td></tr></table></div></li><li class="li"><p>Inform power management every time an entity (including your driver) initiates a device access. </p><p>In your driver’s device-access path, call <code><!--a-->activityTickle<!--/a--></code>, as shown below:</p><div class="codesample"><table><tr><td scope="row"><pre>activityTickle ( kIOPMSuperclassPolicy1, myDevicePowerOn );<span></span></pre></td></tr></table></div><p>As shown above, the first parameter to <code><!--a-->activityTickle<!--/a--></code> is <code>kIOPMSuperclassPolicy1</code>, which indicates that the <code>IOService</code> superclass will track device activity and take action when the idle period expires. The second parameter specifies the power state required for this activity, typically the on state.</p></li><li class="li"><p>When the idle timer expires, the <code>IOService</code> superclass checks whether there has been any device activity since the last idle timer expiration. The superclass determines this by checking when <code><!--a-->activityTickle<!--/a--></code> ( <code>kIOPMSuperclassPolicy1</code> ) was last called.</p></li><li class="li"><p>If there has been device activity since the last timer expiration, the <code>IOService</code> superclass restarts the timer. If no device activity has occurred, the <code>IOService</code> superclass calls <code>setPowerState</code> on your driver to power down the device to the next lowest state.<a name="//apple_ref/doc/uid/TP0000020-DontLinkElementID_876"></a></p></li></ol><div class="notebox"><a name="//apple_ref/doc/uid/TP0000020-DontLinkElementID_70" title="Optional"></a><p><strong>Optional:</strong>&nbsp;A driver may implement variable idle timeout behaviors by overriding the <code>IOService</code> method <code><!--a target="_top" -->nextIdleTimeout<!--/a--></code>. To do this, your implementation of <code><!--a-->nextIdleTimeout<!--/a--></code> should return how many "seconds from now" the device should move into its next lowest power state.</p>For example, the Graphics family uses <code><!--a-->nextIdleTimeout<!--/a--></code> to dynamically adjust the display’s idle-sleep timeouts. If the user moves the mouse very soon after the display dims, the display driver remembers this and increases the timeout period, effectively waiting a longer time before it initiates the next several display-dim events.</p></div><p>After your device has been powered down to a lower state through this process, a new <code>activityTickle</code> invocation<a name="//apple_ref/doc/uid/TP0000020-DontLinkElementID_877"></a> causes power management to raise the device’s power to the level required for the activity. If the device is already in the correct state, the superclass simply returns <code>true</code> from the call to <code><!--a-->activityTickle<!--/a--></code> ( <code>kIOPMSuperclassPolicy1</code> ); otherwise, the superclass returns <code>false</code> and proceeds to make the device usable.<a name="//apple_ref/doc/uid/TP0000020-DontLinkElementID_878"></a><a name="//apple_ref/doc/uid/TP0000020-DontLinkElementID_879"></a></p><p>Although the return value of <code><!--a-->activityTickle<!--/a--></code> indicates whether the device is in a usable power state, it’s better to keep track of your device’s current power state in your driver than to rely on the <code><!--a-->activityTickle<!--/a--></code> return value for this information. This is because <code><!--a-->activityTickle<!--/a--></code> is not called on the power management work loop and a device’s power state might change before <code><!--a-->activityTickle<!--/a--></code> returns.</p><a name="//apple_ref/doc/uid/TP0000020-DontLinkElementID_8" title="Receiving Notification of Power-State Changes in Other Devices"></a><h3>Receiving Notification of Power-State Changes in Other Devices</h3><p>In some cases, your driver might need to be notified when another driver changes its device’s power state. I/O Kit power management brackets each change to the power state of a device with a pair of notifications. These notifications are delivered through invocations of the <code>IOService</code> virtual methods <code><!--a target="_top" -->powerStateWillChangeTo<!--/a--></code> and <code><!--a target="_top" -->powerStateDidChangeTo<!--/a--></code>. You can implement these methods to receive the notifications and prepare for the changes.</p><p>Your driver can register its interest in another driver, as long as the following is true:</p><ul class="spaceabove"><li class="li"><p>The driver in which your driver is interested must be attached into the power plane.</p></li><li class="li"><p>Your driver must be a C++ subclass of <code>IOService</code>, but it does not have to be attached into the power plane itself.</p></li></ul><p>To find out when another driver changes its device’s power state, follow these steps in your driver:</p><ol class="ol"><li class="li"><p>Call the <code>IOService</code> method <code><!--a target="_top" -->registerInterestedDriver<!--/a--></code>. This ensures that power management will notify your driver when it sends out power-change notifications.</p></li><li class="li"><p>Implement the virtual <code>IOService</code> method <code><!--a target="_top" -->powerStateWillChangeTo<!--/a--></code>. This method is called by the device’s driver when it is about to change the device’s power state.</p><p>If your driver is prepared for the change, it should return <code>kIOPMAckImplied</code>; if it needs more time to prepare, it should return an upper limit on the time required (in microseconds). </p><p>If your driver returns a number representing the maximum preparation time needed, it should call the <code>acknowledgePowerChange</code> method<a name="//apple_ref/doc/uid/TP0000020-DontLinkElementID_880"></a> when it is prepared. If it does not do this, and the time requested for preparation elapses, the other driver carries on as if your driver had acknowledged the change. This behavior prevents power-state changes from stalling because of failing drivers.</p><div class="importantbox"><a name="//apple_ref/doc/uid/TP0000020-DontLinkElementID_71" title="Important:"></a><p><strong>Important:</strong>&nbsp;The <code><!--a-->powerStateWillChangeTo<!--/a--></code> method is not the place to perform any tasks related to the actual changing of the power state. Such tasks should be performed in the <code><!--a-->setPowerState<!--/a--></code> method, which is described in <span class="content_text"><a href="PowerMgmt.html#//apple_ref/doc/uid/TP0000020-SW10">“Responding to a Power State–Change Request”</a></span></p><p></p></div></li><li class="li"><p>Implement the virtual <code>IOService</code> method <code><!--a target="_top" -->powerStateDidChangeTo<!--/a--></code>. This method is called by the device’s driver after the power-state changed is complete.</p><p>After the change to power occurs and the power has settled to its new level, power management broadcasts this fact to all interested objects via the <code>powerStateDidChangeTo</code> method. If a device is going to a reduced power state, interested drivers generally don’t need to do much with this notification. However, if the device is going to a higher power state, interested drivers would use this notification to prepare for the change by, for example, restoring state or programming a device.</p><p>In your implementation of <code><!--a-->powerStateDidChangeTo<!--/a--></code>, your driver can examine the <code>IOPMPowerFlags</code> bitfield (described in <span class="content_text"><a href="PowerMgmt.html#//apple_ref/doc/uid/TP0000020-BAJCIGDJ">Table 9-2</a></span>) passed in to make its determination; this bitfield is derived from the <code>capabilityFlags</code> field of the power-state array, which is described in <span class="content_text"><a href="PowerMgmt.html#//apple_ref/doc/uid/TP0000020-BAJFECJJ">Table 9-1</a></span> As with <code><!--a-->powerStateWillChangeTo<!--/a--></code>, your driver should return <code>kIOPMAckImplied</code> if it has prepared for the change. If it needs time to prepare, it should return the maximum time required (in microseconds); when your driver is finally ready for the change, it should call the <code>acknowledgePowerChange</code> method.</p><div class="importantbox"><a name="//apple_ref/doc/uid/TP0000020-DontLinkElementID_72" title="Important:"></a><p><strong>Important:</strong>&nbsp;The <code><!--a-->powerStateDidChangeTo<!--/a--></code> method is not the place to perform any tasks related to the actual changing of the power state. Such tasks should be performed in the <code><!--a-->setPowerState<!--/a--></code> method, which is described in <span class="content_text"><a href="PowerMgmt.html#//apple_ref/doc/uid/TP0000020-SW10">“Responding to a Power State–Change Request”</a></span></p><p></p></div></li></ol><p>When your driver is no longer interested in the power changes of other drivers, it should deregister itself to stop receiving notifications. To do this, call the <code>IOService</code> method <code><!--a target="_top" -->deRegisterInterestedDriver<!--/a--></code>, usually in your driver’s <code>stop</code> method.</p><a name="//apple_ref/doc/uid/TP0000020-SW8" title="Receiving Shutdown and Restart Notifications"></a><h3>Receiving Shutdown and Restart Notifications</h3><p>In a driver targeting Mac OS X v10.5 and later, you can implement the <code><!--a-->systemWillShutdown<!--/a--></code> method to receive notification of an impending shutdown or restart. It’s important to understand, however, that there is nothing your driver can do to prevent a shutdown, regardless of the notification it receives. Your driver is capable of delaying shutdown, but that is strongly discouraged because it can severely degrade the user’s experience.</p><p>Do not assume that your driver should implement <code><!--a-->systemWillShutdown<!--/a--></code> so that it can respond to shutdown and restart notifications by shutting down your hardware. At shutdown time, power is about to be removed from your device regardless of its current state. Similarly, if the system is restarting, your device will be reinitialized shortly and, again, its current state is not important. Most built-in device drivers in Mac OS X do not shut down their devices when the system is about to shutdown or restart and most third-party device drivers should do the same.</p><p>Although the majority of device drivers do not need to handle shutdown or restart in any way at all, there are two valid reasons for a driver to run at shutdown or restart time:</p><ul class="spaceabove"><li class="li"><p>The architecture requires the driver to execute code at shutdown time. For example, all drivers that perform DMA in an Intel-based Macintosh <em>must</em> stop active DMA before shutdown can complete.</p></li><li class="li"><p>The driver must run at shutdown or restart time to avoid negative user experience. For example, an audio driver might need to turn off its device’s amplifiers to avoid an audible “pop” when power is removed.</p></li></ul><div class="notebox"><a name="//apple_ref/doc/uid/TP0000020-DontLinkElementID_73" title="Note"></a><p><strong>Note:</strong>&nbsp;There are other places that you may run code on the shutdown path. For example, if your software has a user-space daemon that runs until shutdown, that daemon can catch <code>SIGTERM</code>, which the kernel sends to all processes at shutdown. In general, try to run your shutdown code as early as possible in the shutdown path.</p></div><p></p><p>The <code><!--a-->systemWillShutdown<!--/a--></code> method is called on all members of the power plane, in leaf-to-root order. A driver’s <code><!--a-->systemWillShutdown<!--/a--></code> method is invoked only after all its power children have completed their shutdown tasks. This ensures that a child object can handle its shutdown or restart tasks before its parent powers off. Note that it is not necessary to call your driver’s <code><!--a-->free<!--/a--></code> method when the system is about to restart or shutdown, because all drivers are unloaded and destroyed at this time.</p><p>When a driver receives the <code><!--a-->systemWillShutdown<!--/a--></code> call, it performs the necessary tasks to prepare for the shutdown or restart and then invokes its superclass’s implementation of the method. This is essential, because system shutdown will stall until all drivers have finished handling their <code><!--a-->systemWillShutdown<!--/a--></code> notifications. Other than postponing the call to <code><!--a-->super::systemWillShutdown<!--/a--></code> until an in-flight I/O request completes, you should do everything possible to avoid delaying shutdown. <span class="content_text">Listing 9-2</span> shows how to override <code><!--a-->systemWillShutdown<!--/a--></code> and receive notification of shutdown or restart.</p><a name="//apple_ref/doc/uid/TP0000020-SW12" title="Listing 9-2Getting notification of system shutdown or restart"></a><p class="codesample"><strong>Listing 9-2&nbsp;&nbsp;</strong>Getting notification of system shutdown or restart</p><div class="codesample"><table><tr><td scope="row"><pre>void MyExampleDriver::systemWillShutdown( IOOptionBits specifier )<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    if ( kIOMessageSystemWillPowerOff == specifier ) {<span></span></pre></td></tr><tr><td scope="row"><pre>        // System is shutting down; perform appropriate processing.<span></span></pre></td></tr><tr><td scope="row"><pre>    } else if ( kIOMessageSystemWillRestart == specifier ) {<span></span></pre></td></tr><tr><td scope="row"><pre>        // System is restarting; perform appropriate processing.<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    /*<span></span></pre></td></tr><tr><td scope="row"><pre>     * You must call your superclass's implementation of systemWillShutdown as<span></span></pre></td></tr><tr><td scope="row"><pre>     * soon as you're finished processing your shutdown or restart<span></span></pre></td></tr><tr><td scope="row"><pre>     * because the shutdown will not proceed until you do.<span></span></pre></td></tr><tr><td scope="row"><pre>     */<span></span></pre></td></tr><tr><td scope="row"><pre>    super::systemWillShutdown( specifier );<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div>	<a name="//apple_ref/doc/uid/TP0000020-DontLinkElementID_9" title="Keeping Power On for Future Device Attachment"></a><h3>Keeping Power On for Future Device Attachment</h3><p>To conserve power, a device whose children have all disappeared is usually considered idle and is told to power off. However, your device might need to stay powered on to allow new children to attach at any time. For example, a bus might need to remain powered on even when there are no devices attached to it, because a new device trying to attach can cause a crash by attempting to access hardware that’s turned off.</p><p>The <code>IOService</code> class provides a method that allows you to keep your device’s power on, even if all its power children have disappeared. The <code><!--a target="_top" -->clampPowerOn<!--/a--></code> method allows you to specify a length of time to keep the device in its highest power state. If you need to do this in your driver, call the <code><!--a-->clampPowerOn<!--/a--></code> method before the last power child disappears, as shown below:</p><div class="codesample"><table><tr><td scope="row"><pre>// timeToStayOn is a length of time in milliseconds.<span></span></pre></td></tr><tr><td scope="row"><pre>clampPowerOn ( timeToStayOn );<span></span></pre></td></tr></table></div>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../DataMgmt/DataMgmt.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../DeviceRemoval/DeviceRemoval.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2001, 2007 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2007-05-17<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/DeviceDrivers/Conceptual/IOKitFundamentals/PowerMgmt/PowerMgmt.html%3Fid%3DTP0000011-4.8&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/DeviceDrivers/Conceptual/IOKitFundamentals/PowerMgmt/PowerMgmt.html%3Fid%3DTP0000011-4.8&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/DeviceDrivers/Conceptual/IOKitFundamentals/PowerMgmt/PowerMgmt.html%3Fid%3DTP0000011-4.8&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>