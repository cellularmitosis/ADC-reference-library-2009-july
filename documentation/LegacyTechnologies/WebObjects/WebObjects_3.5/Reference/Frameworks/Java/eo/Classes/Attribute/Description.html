<html><head><title></title></head>
<body bgcolor="#ffffff">
 
 
<h1>
<FONT COLOR="#000066">
<a name="816">
 <a name="//apple_ref/java/cl/Attribute">Attribute</a>
</a>
</FONT>
</h1>
<p><B>Extends:</B><BR>  
next.util.NextObject

<p><B>Implements:</B><BR>
next.eo.<a href="../../Interfaces/PropertyListEncoding/Frameset.html#" target="_top">PropertyListEncoding</a>

<p><a name="829"></a>
<a name="description"></a>
<H2>Class Description
</H2>
An Attribute represents a column, field or property in a database, and associates an internal name with an external name or expression by which the property is known to the database. The property an Attribute represents may be a meaningful value, such as a salary or a name, or it may be an arbitrary value used for identification but with no real-world applicability (ID numbers and foreign keys for relationships fall into this category). An Attribute also maintains type information for binding values to the instance variables of objects.<p>
Attributes are also used to represent arguments for StoredProcedures.<p>
You usually define attributes in your model with the EOModeler application, which is documented in the <em>Enterprise Objects Framework Developer's Guide</em>. Your code probably won't need to programmatically interact with Attribute unless you're working at the adaptor level.<p>
An attribute may be simple, derived, or flattened. A simple attribute typically corresponds to a single column in the database, and may be read or updated directly from or to the database. A simple Attribute may also be set as read-only with its <a href="#3836"><code>setReadOnly</code></a> method. Read-only attributes of enterprise objects are never updated.<p>
A derived attribute doesn't necessarily correspond to a single database column in its entity's database table, and is usually based on some other attribute, which is modified in some way. For example, if an Employee entity has a simple monthly salary attribute, you can define a derived <code>annualSalary</code> attribute as "salary * 12". Derived attributes, since they don't correspond to actual values in the database, are read-only; it makes no sense to write a derived value.<p>
A flattened attribute of an entity is actually an attribute of some other entity that's fetched through a relationship with a database join. A flattened attribute's external definition is a data path ending in an attribute name. For example, if the Employee entity has the relationship <code>toAddress</code> and the Address entity has the attribute <code>street</code>, you can define <code>streetName</code> as an attribute of your Employee Entity by creating an Attribute for it with a definition of "toAddress.street".<p>
Like the other major modeling classes, Attribute provides a user dictionary for the application to store any auxiliary information it needs.<p>
<h3>
<a name="3890">
 Mapping from Database to Objects
</a>
</h3>
Every Attribute has an external type, which is the type used by the database to store its associated data, and a Java class used as the type for that data in the client application. The type used by the database is accessed with the <a href="#3806"><code>setExternalType</code></a> and <a href="#3362"><code>externalType</code></a> methods. The class type used by the application is accessed with the <a href="#3856"><code>setValueClassName</code></a> and <a href="#3522"><code>valueClassName</code></a> methods. You can map database types to a set of standard value classes, which includes:<p>
<ul><li>java.lang.String<br>
<li>java.lang.Number<br>
<li>next.util.DecimalNumber<br>
<li>next.util.ImmutableBytes<br>
<li>next.util.Date<br>
</ul>Database-specific adaptors automatically handle value conversions for these classes. You can also create your own custom value class, so long as you define a format that it uses to interpret data. For more information on using Attribute methods to work with custom data types, see the next section, "<a href="#3903">Working with Custom Data Types</a>."<p>
The handling of dates assumes by default that both the database server and the client application are running in the same, local, time zone. You can alter the server time zone with the <a href="#3846"><code>setServerTimeZone</code></a> method. If you alter the server time zone, the adaptor automatically converts dates as they pass into and out of the server.<p>
<h3>
<a name="3903">
 Working with Custom Data Types
</a>
</h3>
When you create a new model, EOModeler maps each attribute in your model to one of the primitive data types the adaptor knows how to manipulate: java.lang.String, next.util.ImmutableBytes, java.lang.Number, next.util.DecimalNumber, and next.util.Date. For example, suppose you have a <code>photo</code> attribute that's stored in the database as a LONG RAW. When you create a new model, this attribute is mapped to ImmutableBytes. However, ImmutableBytes is just an object wrapper for binary data-for instance, it doesn't have any methods for operating on images, which would limit what you'd be able to do with the image in your application. This is a case in which you'd probably choose to use a custom data type.<p>
For a custom data type to be usable in Enterprise Objects Framework, it must supply methods for importing and exporting itself as one of the primitive types so that it can be read from and written to the database. Specifically, to use a custom data type you need to do the following:<p>
<ul><li>Set the attribute's value class using the method <a href="#3856"><code>setValueClassName</code></a>. <p>
<li>Set the factory method that will be used to create instances of your class from raw data using the method <a href="#3861"><code>setValueFactoryMethodName</code></a>.<p>
<li>Set the type of the argument that should be passed to the factory method using the method <a href="#3811"><code>setFactoryMethodArgumentType</code></a>.<p>
<li>Set the conversion method that is used to convert your data into one of the primitive data types the adaptor can work with using the method <a href="#3786"><code>setAdaptorValueConversionMethodName</code></a>; this enables the data to be stored in the database.<p>
</ul>If an Attribute represents a binary column in the database, the factory method argument type can be either FactoryMethodArgumentIsNSData or FactoryMethodArgumentIsBytes, indicating that the method takes an ImmutableBytes object or raw bytes as an argument. If the Attribute represents a string or character column, the factory method argument type can be either FactoryMethodArgumentIsNSString or FactoryMethodArgumentIsBytes, indicating that the method takes a String object or raw bytes as an argument. These types apply when fetching custom values.<p>
Instead of setting the value class information programmatically, you can use the Attributes Inspector in EOModeler, which is more common. For more information, see the chapter "Advanced Modeling Techniques" in the <em>Enterprise Objects Framework Developer's Guide</em>.<p>
<h4>
<a name="7111">
 Fetching Custom Values
</a>
</h4>
Custom values are created during fetching in AdaptorChannel's <a href="../AdaptorChannel/Frameset.html#2634" target="_top"><code>fetchRow</code></a><code> </code>method. This method fetches data in the external (server) type and converts it to a value object, applying the custom value factory method (<a href="#3543"><code>valueFactoryMethod</code></a>) to convert a value into the custom class if necessary. Once the value is converted, the AdaptorChannel puts it into the dictionary for the row being fetched.<p>
<h4>
<a name="3926">
 Converting Custom Values
</a>
</h4>
Custom values are converted back to binary or character data in AdaptorChannel's <a href="../AdaptorChannel/Frameset.html#2624" target="_top"><code>evaluateExpression</code></a> method. For each value in the SQLExpression to be evaluated, the AdaptorChannel sends the appropriate Attribute an <a href="#3197"><code>adaptorValueByConvertingAttributeValue</code></a> message to convert it. If the value is any of the standard value classes, it's returned unchanged. If the value is of a custom class, though, it's converted by applying the conversion method (<a href="#3215"><code>adaptorValueConversionMethod</code></a>) specified in the Attribute.<p>
<h3>
<a name="3928">
 SQL Statement Formats
</a>
</h3>
In addition to mapping database values to object values, an Attribute can alter the way values are selected, inserted, and updated in the database by defining special format strings. These format strings allow a client application to extend its reach right down to the server for certain operations. For example, you might want to view an employee's salary on a yearly basis, without defining a derived attribute as in a previous example. In this case, you could set the <code>salary</code> attribute's SELECT statement format to "salary * 12" (with <a href="#3831"><code>setReadFormat</code></a>) and the INSERT and UPDATE statement formats to "salary / 12" (<a href="#3876"><code>setWriteFormat</code></a>). Thus, whenever your application retrieves values for the salary attribute they're multiplied by 12, and when it writes values back to the database they're divided by 12.<p>
Your application can use any legal SQL value expression in a format string, and can even access server-specific features such as functions and stored procedures (see <a href="../Entity/Frameset.html#816" target="_top">Entity</a>'s <a href="../Entity/Frameset.html#4544" target="_top"><code>setStoredProcedure</code></a> method description for more information). Accessing server-specific features can offer your application great flexibility in dealing with its server, but does limit its portability. You're responsible for ensuring that your SQL is well-formed and will be understood by the database server.<p>
Format strings for the <a href="#3831"><code>setReadFormat</code></a> and <a href="#3876"><code>setWriteFormat</code></a> methods should use "%P" as the substitution character for the value that is being formatted. "%@" will not work. For example:<p>
<blockquote><pre>myAttribute.setReadFormat("TO_UPPER(%P)");<br>myAttribute.setWriteFormat("TO_LOWER(%P)");
</pre></blockquote><p>Instead of setting the read and write formats programmatically, you can set them in EOModeler, which is more common. For more information, see the chapter "Using EOModeler" in the <em>Enterprise Objects Framework Developer's Guide</em>.<p>
<h3>
<a name="3934">
 Creating a Simple Attribute
</a>
</h3>
A simple attribute needs at least the following characteristics:<p>
<ul><li>A name unique within its entity<p>
<li>The name of a column in the database table for its entity (the Attribute's external name)<p>
<li>A declaration of the type of that column as defined by the database and adaptor (the Attribute's external type)<p>
<li>A declaration of the Java class used to represent values outside the context of an enterprise object<p>
<li>For Java value classes that require it, a subtype for such distinctions as between numeric types<p>
</ul>You also have to set whether the attribute is part of its entity's primary key, is a class property, or is used for locking. See the <a href="../Entity/Frameset.html#816" target="_top">Entity</a> class description for more information.<p>
<h3>
<a name="6697">
 Creating a Derived Attribute
</a>
</h3>
A derived attribute depends on another attribute, so you base it on a definition including that attribute's name rather than on an external name. Because a derived attribute isn't mapped directly to anything in the database, you shouldn't include it in the entity's set of primary key attributes or attributes used for locking.<p>
<h3>
<a name="3984">
 Creating a Flattened Attribute
</a>
</h3>
A flattened attribute depends on a relationship, so you base it on a definition including that relationship's name rather than on an external name. Because a flattened attribute doesn't correspond directly to anything in its entity's table, you don't have to specify an external name, and shouldn't include it in the entity's set of primary key attributes or attributes used for locking. <p>
Instead of flattening attributes in your model, a better approach is often to directly traverse the object graph through relationships. See the chapter "Using EOModeler" in the <em>Enterprise Objects Framework Developer's Guide</em> for a discussion on when to use flattened attributes.<p>
<HR WIDTH=50% ALIGN=LEFT>
<h2>Interfaces Implemented</h2>  


<dl>
<dt>next.eo.<a href="../../Interfaces/PropertyListEncoding/Frameset.html#" target="_top">PropertyListEncoding</a><dl><dl><dl><dl>
<dt><a href="../../Interfaces/PropertyListEncoding/Frameset.html#" target="_top">awakeWithPropertyList</a><dt><a href="../../Interfaces/PropertyListEncoding/Frameset.html#" target="_top">encodeIntoPropertyList</a></dl>
</dl></dl></dl></dl>
<a name="5450">
<HR WIDTH=50% ALIGN=LEFT>
<h2>Method Types
</h2>
</a><dl>
<dt>Constructors<dl><dl><dl><dl>
<dt><a href="#2584">Attribute</a></dl>
</dl></dl></dl><dt>Accessing the entity<dl><dl><dl><dl>
<dt><a href="#3357">entity</a><dt><a href="#3429">parent</a></dl>
</dl></dl></dl><dt>Accessing the name<dl><dl><dl><dl>
<dt><a href="#3816">setName</a><dt><a href="#3408">name</a><dt><a href="#3512">validateName</a><dt><a href="#3305">beautifyName</a></dl>
</dl></dl></dl><dt>Accessing date information<dl><dl><dl><dl>
<dt><a href="#3486">serverTimeZone</a><dt><a href="#3846">setServerTimeZone</a></dl>
</dl></dl></dl><dt>Accessing external definitions<dl><dl><dl><dl>
<dt><a href="#3796">setColumnName</a><dt><a href="#3310">columnName</a><dt><a href="#3801">setDefinition</a><dt><a href="#3315">definition</a><dt><a href="#3806">setExternalType</a><dt><a href="#3362">externalType</a></dl>
</dl></dl></dl><dt>Accessing value type information<dl><dl><dl><dl>
<dt><a href="#3856">setValueClassName</a><dt><a href="#3522">valueClassName</a><dt><a href="#3866">setValueType</a><dt><a href="#3558">valueType</a><dt><a href="#3791">setAllowsNull</a><dt><a href="#3272">allowsNull</a><dt><a href="#3826">setPrecision</a><dt><a href="#3465">precision</a><dt><a href="#3841">setScale</a><dt><a href="#3475">scale</a><dt><a href="#3871">setWidth</a><dt><a href="#3563">width</a></dl>
</dl></dl></dl><dt>Converting to adaptor value types<dl><dl><dl><dl>
<dt><a href="#3197">adaptorValueByConvertingAttributeValue</a><dt><a href="#3220">adaptorValueType</a></dl>
</dl></dl></dl><dt>Working with custom value types<dl><dl><dl><dl>
<dt><a href="#3861">setValueFactoryMethodName</a><dt><a href="#3543">valueFactoryMethod</a><dt><a href="#3548">valueFactoryMethodName</a><dt><a href="#3811">setFactoryMethodArgumentType</a><dt><a href="#3377">factoryMethodArgumentType</a><dt><a href="#3786">setAdaptorValueConversionMethodName</a><dt><a href="#3215">adaptorValueConversionMethod</a><dt><a href="#3234">adaptorValueConversionMethodName</a><dt><a href="#5701">archiveDataForObject</a></dl>
</dl></dl></dl><dt>Accessing attribute characteristics<dl><dl><dl><dl>
<dt><a href="#3836">setReadOnly</a><dt><a href="#3398">isReadOnly</a><dt><a href="#4292">isDerived</a><dt><a href="#3388">isFlattened</a></dl>
</dl></dl></dl><dt>Accessing SQL statement formats<dl><dl><dl><dl>
<dt><a href="#3831">setReadFormat</a><dt><a href="#3470">readFormat</a><dt><a href="#3876">setWriteFormat</a><dt><a href="#3573">writeFormat</a></dl>
</dl></dl></dl><dt>Accessing the user dictionary<dl><dl><dl><dl>
<dt><a href="#3851">setUserInfo</a><dt><a href="#3507">userInfo</a></dl>
</dl></dl></dl><dt>Working with stored procedures<dl><dl><dl><dl>
<dt><a href="#3821">setParameterDirection</a><dt><a href="#3419">parameterDirection</a><dt><a href="#3496">storedProcedure</a></dl>
</dl></dl></dl></dl>
<HR WIDTH=50% ALIGN=LEFT>
<a name="2600"></a>
<a name="cons"></a>
<h2>Constructors</h2>  


<a name="2584"></a>
<h3>
 Attribute
</h3>
public <code>Attribute</code>()

<P>public <code>Attribute</code>(next.util.ImmutableHashtable <em>propertyList</em>, java.lang.Object <em>owner</em>)

<P>Creates a new Attribute.<p>
If <em>propertyList</em> and <em>owner</em> are provided, the new Attribute is initialized from <em>propertyList</em>-a dictionary containing only property list data types (that is, next.util.ImmutableHashtables, java.lang.Strings, next.util.ImmutableVectors, and next.util.ImmutableBytes). This constructor is used by EOModeler when it reads in a Model from a file, for example. The <em>owner</em> argument should be the Attribute's Entity or StoredProcedure. Attributes created from a property list must receive an <a href="../../Interfaces/PropertyListEncoding/Frameset.html#" target="_top"><code>awakeWithPropertyList</code></a> message immediately after creation before they are fully functional, but the <code>awake...</code> message should be deferred until the all of the other objects in the model have also been created.<p>
<B>See also: </B>  
<a href="../../Interfaces/PropertyListEncoding/Frameset.html#" target="_top"><code>awakeWithPropertyList</code></a> (PropertyListEncoding), <a href="../../Interfaces/PropertyListEncoding/Frameset.html#" target="_top"><code>encodeIntoPropertyList</code></a> 
(PropertyListEncoding)
<p><HR WIDTH=50% ALIGN=LEFT>
<a name="5708"></a>
<a name="clm"></a>
<h2>Static Methods</h2>  


<a name="5701"></a>
<h3>
 <a name="//apple_ref/java/clm/Attribute/archiveDataForObject">archiveDataForObject</a>
</h3>
public static next.util.ImmutableBytes <code>archiveDataForObject</code>(next.util.NextObject <em>anObject</em>)

<P>Return <em>anObject</em>'s value as a next.util.ImmutableBytes object whose bytes can be stored in an external repository.<p>
<HR WIDTH=50% ALIGN=LEFT>
<a name="instm"></a>
<h2>Instance Methods</h2>  


<a name="3197"></a>
<h3>
 <a name="//apple_ref/java/instm/Attribute/adaptorValueByConvertingAttributeValue">adaptorValueByConvertingAttributeValue</a>
</h3>
public java.lang.Object <code>adaptorValueByConvertingAttributeValue</code>(java.lang.Object <em>anObject</em>)

<P>Ensures that <em>anObject</em> is either a java.lang.String, next.util.ImmutableBytes, java.lang.Number, or next.util.Date, converting it if necessary. If <em>anObject</em> needs to be converted, <a href="#3197"><code>adaptorValueByConvertingAttributeValue</code></a> uses the adaptor conversion method to convert <em>anObject</em> to one of these four types. If the attribute hasn't a specific adaptor conversion method, and the type to be fetched from the database is AdaptorBytesType, <a href="#5701"><code>archiveDataForObject</code></a> will be invoked to convert the attribute value.<p>
<B>See also: </B>  
<a href="#3215"><code>adaptorValueConversionMethod</code></a>, <a href="#3220"><code>adaptorValueType</code></a>
<p><hr WIDTH=25% ALIGN=LEFT>
<a name="3215"></a>
<h3> <a name="//apple_ref/java/instm/Attribute/adaptorValueConversionMethod">adaptorValueConversionMethod</a></h3>
public next.util.Selector <code>adaptorValueConversionMethod</code>()

<P>Returns the method used to convert a custom class into one of the primitive types that the adaptor knows how to manipulate: java.lang.String, next.util.ImmutableBytes, java.lang.Number, or next.util.Date. The return value of this method is derived from the attribute's adaptor value conversion method name. If that name doesn't map to a valid method in the Java run-time, <code>null</code> is returned.<p>
<B>See also: </B>  
<a href="#3197"><code>adaptorValueByConvertingAttributeValue</code></a>, <a href="#3234"><code>adaptorValueConversionMethodName</code></a>
<p><hr WIDTH=25% ALIGN=LEFT>
<a name="3234"></a>
<h3> <a name="//apple_ref/java/instm/Attribute/adaptorValueConversionMethodName">adaptorValueConversionMethodName</a></h3>
public java.lang.String <code>adaptorValueConversionMethodName</code>()

<P>Returns the name of the method used to convert a custom class into one of the primitive types that the adaptor knows how to manipulate: java.lang.String, next.util.ImmutableBytes, java.lang.Number, or next.util.Date.<p>
<B>See also: </B>  
<a href="#3197"><code>adaptorValueByConvertingAttributeValue</code></a>
<p><hr WIDTH=25% ALIGN=LEFT>
<a name="3220"></a>
<h3> <a name="//apple_ref/java/instm/Attribute/adaptorValueType">adaptorValueType</a></h3>
public int <code>adaptorValueType</code>()

<P>Returns an adaptor value type that indicates the data type that will be fetched from the database. Currently, this method returns one of the following values:<p>
<ul><li>AdaptorNumberType<br>
<li>AdaptorCharactersType<br>
<li>AdaptorBytesType<br>
<li>AdaptorDateType<br>
</ul><B>See also: </B>  
<a href="#3377"><code>factoryMethodArgumentType</code></a>
<p><hr WIDTH=25% ALIGN=LEFT>
<a name="3272"></a>
<h3> <a name="//apple_ref/java/instm/Attribute/allowsNull">allowsNull</a></h3>
public boolean <code>allowsNull</code>()

<P>Returns <code>true</code> to indicate that the attribute can have a <code>null</code> value, <code>false</code> otherwise. If the attribute maps directly to a column in the database, it also is used to determine whether the database column can have a NULL value.<p>
<B>See also: </B>  
<a href="#3791"><code>setAllowsNull</code></a>
<p><hr WIDTH=25% ALIGN=LEFT>
<a name="3305"></a>
<h3> <a name="//apple_ref/java/instm/Attribute/beautifyName">beautifyName</a></h3>
public void <code>beautifyName</code>()

<P>Makes the attribute name conform to a standard convention. Names that conform to this style are all lower-case except for the initial letter of each embedded word other than the first, which is upper case. Thus, "NAME" becomes "name", and "FIRST_NAME" becomes "firstName". This method is used in reverse-engineering a model.<p>
<B>See also: </B>  
<a href="../Entity/Frameset.html#4657" target="_top"><code>nameForExternalName</code></a> (Entity), <a href="#3512"><code>validateName</code></a>, <a href="../Model/Frameset.html#2301" target="_top"><code>beautifyNames</code></a> (Model)
<p><hr WIDTH=25% ALIGN=LEFT>
<a name="3310"></a>
<h3> <a name="//apple_ref/java/instm/Attribute/columnName">columnName</a></h3>
public java.lang.String <code>columnName</code>()

<P>Returns the name of the column in the database that corresponds to this attribute, or <code>null</code> if the attribute isn't simple (that is, if it's derived or flattened). An adaptor uses this name to identify the column corresponding to the attribute. Your application should never need to use this name. Note that <code>columnName</code> and <a href="#3315"><code>definition</code></a> are mutually exclusive; if one returns a value, the other returns <code>null</code>.<p>
<B>See also: </B>  
<a href="#3362"><code>externalType</code></a>
<p><hr WIDTH=25% ALIGN=LEFT>
<a name="3315"></a>
<h3> <a name="//apple_ref/java/instm/Attribute/definition">definition</a></h3>
public java.lang.String <code>definition</code>()

<P>Returns a derived or flattened attribute's definition, or <code>null</code> if the attribute is simple. An attribute's definition is either a value expression defining a derived attribute, such as "salary * 12", or a data path for a flattened attribute, such as "toAuthor.name". Note that <a href="#3310"><code>columnName</code></a> and <code>definition</code> are mutually exclusive; if one returns a value, the other returns <code>null</code>.<p>
<B>See also: </B>  
<a href="#3362"><code>externalType</code></a>, <a href="#3801"><code>setDefinition</code></a>
<p><hr WIDTH=25% ALIGN=LEFT>
<a name="3357"></a>
<h3> <a name="//apple_ref/java/instm/Attribute/entity">entity</a></h3>
public next.eo.Entity <code>entity</code>()

<P>Returns the entity that owns the attribute, or <code>null</code> if this attribute is acting as an argument for a stored procedure.<p>
<B>See also: </B>  
<a href="#3496"><code>storedProcedure</code></a>
<p><hr WIDTH=25% ALIGN=LEFT>
<a name="3362"></a>
<h3> <a name="//apple_ref/java/instm/Attribute/externalType">externalType</a></h3>
public java.lang.String <code>externalType</code>()

<P>Returns the attribute's type as understood by the database; for example, a Sybase "varchar" or an Oracle "NUMBER".<p>
<B>See also: </B>  
<a href="#3310"><code>columnName</code></a>, <a href="#3806"><code>setExternalType</code></a>
<p><hr WIDTH=25% ALIGN=LEFT>
<a name="3377"></a>
<h3> <a name="//apple_ref/java/instm/Attribute/factoryMethodArgumentType">factoryMethodArgumentType</a></h3>
public int <code>factoryMethodArgumentType</code>()

<P>Returns the type of argument that should be passed to the "factory method"-which is invoked by the attribute to create an attribute value for a custom class. This method returns one of the following values:<p>
<Table Border="3">
<caption></caption>
<tr><th colspan=2 rowspan=1><b>Return Value</b>
</th><th><b>Argument Type</b>
</th></tr>
<tr><td colspan=2 rowspan=1 scope="row">FactoryMethodArgumentIsNSData
</td><td>a next.util.ImmutableBytes
</td></tr>
<tr><td colspan=2 rowspan=1 scope="row">FactoryMethodArgumentIsNSString
</td><td>a java.lang.String
</td></tr>
<tr><td colspan=2 rowspan=1 scope="row">FactoryMethodArgumentIsBytes
</td><td>raw bytes
</td></tr>

</Table>

<Table>
<tr><td>
</Table>
<p>
<B>See also: </B>  
<a href="#3543"><code>valueFactoryMethod</code></a>, <a href="#3811"><code>setFactoryMethodArgumentType</code></a>
<p><hr WIDTH=25% ALIGN=LEFT>
<a name="4292"></a>
<h3> <a name="//apple_ref/java/instm/Attribute/isDerived">isDerived</a></h3>
public boolean <code>isDerived</code>()

<P>Returns <code>false</code> if the attribute corresponds exactly to one column in the table associated with its entity, and <code>true</code> if it doesn't. For example, an attribute with a definition of "otherAttributeName + 1" is derived.<p>
Note that flattened attributes are also considered as derived attributes.<p>
<B>See also: </B>  
<a href="#3388"><code>isFlattened</code></a>, <a href="#3315"><code>definition</code></a>
<p><hr WIDTH=25% ALIGN=LEFT>
<a name="3388"></a>
<h3> <a name="//apple_ref/java/instm/Attribute/isFlattened">isFlattened</a></h3>
public boolean <code>isFlattened</code>()

<P>Returns <code>true</code> if the attribute is flattened, <code>false</code> otherwise. A flattened attribute is one that's accessed through an entity's relationships but belongs to another entity.<p>
Note that flattened attributes are also considered to be derived attributes.<p>
<B>See also: </B>  
<a href="#4292"><code>isDerived</code></a>, <a href="#3315"><code>definition</code></a>
<p><hr WIDTH=25% ALIGN=LEFT>
<a name="3398"></a>
<h3> <a name="//apple_ref/java/instm/Attribute/isReadOnly">isReadOnly</a></h3>
public boolean <code>isReadOnly</code>()

<P>Returns <code>true</code> if the value of the attribute can't be modified, <code>false</code> if it can.<p>
<B>See also: </B>  
<a href="#3836"><code>setReadOnly</code></a>
<p><hr WIDTH=25% ALIGN=LEFT>
<a name="3408"></a>
<h3> <a name="//apple_ref/java/instm/Attribute/name">name</a></h3>
public java.lang.String <code>name</code>()

<P>Returns the attribute's name.<p>
<B>See also: </B>  
<a href="#3310"><code>columnName</code></a>, <a href="#3315"><code>definition</code></a>, <code><a href="#3816">setName</a>
</code><p><hr WIDTH=25% ALIGN=LEFT>
<a name="3419"></a>
<h3> <a name="//apple_ref/java/instm/Attribute/parameterDirection">parameterDirection</a></h3>
public int <code>parameterDirection</code>()

<P>Returns the parameter direction for attributes that are arguments to a stored procedure. This method returns one of the following values:<p>
<ul><li>Void<br>
<li>InParameter<br>
<li>OutParameter<br>
<li>InOutParameter<br>
</ul><B>See also: </B>  
<a href="#3496"><code>storedProcedure</code></a>, <a href="../Entity/Frameset.html#4554" target="_top"><code>storedProcedureForOperation</code></a> (Entity), <a href="#3821"><code>setParameterDirection</code></a>
<p><hr WIDTH=25% ALIGN=LEFT>
<a name="3429"></a>
<h3> <a name="//apple_ref/java/instm/Attribute/parent">parent</a></h3>
public java.lang.Object <code>parent</code>()

<P>Returns the attribute's parent, which is either an Entity or a StoredProcedure. Use this method when you need to find the model for an attribute.<p>
<hr WIDTH=25% ALIGN=LEFT>
<a name="3465"></a>
<h3> <a name="//apple_ref/java/instm/Attribute/precision">precision</a></h3>
public int <code>precision</code>()

<P>Returns the precision of the database representation for attributes with a value class of java.lang.Number or next.util.DecimalNumber.<p>
<B>See also: </B>  
<a href="#3475"><code>scale</code></a>
<p><hr WIDTH=25% ALIGN=LEFT>
<a name="3470"></a>
<h3> <a name="//apple_ref/java/instm/Attribute/readFormat">readFormat</a></h3>
public java.lang.String <code>readFormat</code>()

<P>Returns a format string of the appropriate type that can be used when building an expression that contains the value of the attribute.<p>
<B>See also: </B>  
<a href="#3831"><code>setReadFormat</code></a>, <a href="#3573"><code>writeFormat</code></a>
<p><hr WIDTH=25% ALIGN=LEFT>
<a name="3475"></a>
<h3> <a name="//apple_ref/java/instm/Attribute/scale">scale</a></h3>
public int <code>scale</code>()

<P>Returns the scale of the database representation for attributes with a value class of java.lang.Number or next.util.DecimalNumber. The returned value can be negative.<p>
<B>See also: </B>  
<a href="#3465"><code>precision</code></a>, <a href="#3841"><code>setScale</code></a>
<p><hr WIDTH=25% ALIGN=LEFT>
<a name="3486"></a>
<h3> <a name="//apple_ref/java/instm/Attribute/serverTimeZone">serverTimeZone</a></h3>
public next.util.TimeZone <code>serverTimeZone</code>()

<P>Returns the time zone assumed for next.util.Dates in the database server, or the local time zone if one hasn't been set. An AdaptorChannel automatically converts dates between the time zones used by the server and the client when fetching and saving values. Applies only to attributes that represent dates.<p>
<B>See also: </B>  
<a href="#3846"><code>setServerTimeZone</code></a>
<p><hr WIDTH=25% ALIGN=LEFT>
<a name="3786"></a>
<h3> <a name="//apple_ref/java/instm/Attribute/setAdaptorValueConversionMethodName">setAdaptorValueConversionMethodName</a></h3>
public void <code>setAdaptorValueConversionMethodName</code>(java.lang.String <em>aString</em>)

<P>Sets to <em>aString</em> the name of the method used to convert a custom class into one of the primitive types that the adaptor knows how to manipulate: java.lang.String, next.util.ImmutableBytes, java.lang.Number, or next.util.Date.<p>
<B>See also: </B>  
<a href="#3234"><code>adaptorValueConversionMethodName</code></a>
<p><hr WIDTH=25% ALIGN=LEFT>
<a name="3791"></a>
<h3> <a name="//apple_ref/java/instm/Attribute/setAllowsNull">setAllowsNull</a></h3>
public void <code>setAllowsNull</code>(boolean <em>aBoolean</em>)

<P>Sets according to <em>aBoolean</em> whether or not the attribute can have a <code>null</code> value. If the attribute maps directly to a column in the database, it also controls whether the database column can have a NULL value.<p>
<B>See also: </B>  
<a href="#3272"><code>allowsNull</code></a>
<p><hr WIDTH=25% ALIGN=LEFT>
<a name="3796"></a>
<h3> <a name="//apple_ref/java/instm/Attribute/setColumnName">setColumnName</a></h3>
public void <code>setColumnName</code>(java.lang.String <em>aString</em>)

<P>Sets to <em>aString</em> the name of the attribute used in communication with the database server. An adaptor uses this name to identify the column corresponding to the attribute; this name must match the name of a column in the database table corresponding to the attribute's entity.<p>
This method makes a derived or flattened attribute simple; the <a href="#3315"><code>definition</code></a> is removed and the column name takes its place for use with the server.<p>
<DT><B>Note:</B></DT>
<DD><code>setColumnName</code> and <a href="#3801"><code>setDefinition</code></a> are closely related. Only one can be set at any given time. 
Invoking either of these methods causes the other value to be set to <code>null</code>.
</DD><B>See also: </B>  
<a href="#3310"><code>columnName</code></a>
<p><hr WIDTH=25% ALIGN=LEFT>
<a name="3801"></a>
<h3> <a name="//apple_ref/java/instm/Attribute/setDefinition">setDefinition</a></h3>
public void <code>setDefinition</code>(java.lang.String <em>aString</em>)

<P>Sets to <em>aString</em> the attribute's definition as recognized by the database server. <em>aString</em> should be either a value expression defining a derived attribute, such as "salary * 12", or a data path for a flattened attribute, such as "toAuthor.name".<p>
Prior to invoking this method, the attribute's entity must have been set by adding the attribute to an entity. This method will not function correctly if the attribute's entity has not been set.<p>
This method converts a simple attribute into a derived or flattened attribute; the <a href="#3310"><code>columnName</code></a> is removed and the definition takes its place for use with the server.<p>
<DT><B>Note:</B></DT>
<DD><a href="#3796"><code>setColumnName</code></a> and <code>setDefinition</code> are closely related. Only one can be set at any given time. 
Invoking either of these methods causes the other value to be set to <code>null</code>.
</DD><B>See also: </B>  
<a href="#3315"><code>definition</code></a>
<p><hr WIDTH=25% ALIGN=LEFT>
<a name="3806"></a>
<h3> <a name="//apple_ref/java/instm/Attribute/setExternalType">setExternalType</a></h3>
public void <code>setExternalType</code>(java.lang.String <em>aString</em>)

<P>Sets to <em>aString</em> the type used for the attribute in the database adaptor; for example, a Sybase "varchar" or an Oracle7 "NUMBER". Each adaptor defines the set of types that can be supplied to <code>setExternalType</code>. The external type you specify for a given attribute must correspond to the type used in the database server.<p>
<B>See also: </B>  
<a href="#3801"><code>setDefinition</code></a>, <a href="#3362"><code>externalType</code></a>
<p><hr WIDTH=25% ALIGN=LEFT>
<a name="3811"></a>
<h3> <a name="//apple_ref/java/instm/Attribute/setFactoryMethodArgumentType">setFactoryMethodArgumentType</a></h3>
public void <code>setFactoryMethodArgumentType</code>(int <em>anInt</em>)

<P>Sets the type of argument that should be passed to the "factory method"-which is invoked by the receiver to create a value for a custom class. Factory methods can accept java.lang.Strings, next.util.ImmutableBytes, or raw bytes; specify an <em>anInt</em> as FactoryMethodArgumentIsNSString, FactoryMethodArgumentIsNSData, or FactoryMethodArgumentIsBytes as appropriate.<p>
<B>See also: </B>  
<a href="#3861"><code>setValueFactoryMethodName</code></a>, <a href="#3377"><code>factoryMethodArgumentType</code></a>
<p><hr WIDTH=25% ALIGN=LEFT>
<a name="3816"></a>
<h3> <a name="//apple_ref/java/instm/Attribute/setName">setName</a></h3>
public void <code>setName</code>(java.lang.String <em>aString</em>)

<P>Sets the attribute's name to <em>aString</em>. Throws an exception if <em>aString</em> is already in use by another attribute or relationship of the same entity, or if <em>aString</em> is not a valid attribute name.<p>
<B>See also: </B>  
<a href="#3512"><code>validateName</code></a>, <a href="#3408"><code>name</code></a>
<p><hr WIDTH=25% ALIGN=LEFT>
<a name="3821"></a>
<h3> <a name="//apple_ref/java/instm/Attribute/setParameterDirection">setParameterDirection</a></h3>
public void <code>setParameterDirection</code>(int <em>anInt</em>)

<P>Sets the parameter direction for attributes that are arguments to a stored procedure. <em>anInt</em> should be one of the following values:<p>
<ul><li>Void<br>
<li>InParameter<br>
<li>OutParameter<br>
<li>InOutParameter<br>
</ul><B>See also: </B>  
<a href="#3419"><code>parameterDirection</code></a>
<p><hr WIDTH=25% ALIGN=LEFT>
<a name="3826"></a>
<h3> <a name="//apple_ref/java/instm/Attribute/setPrecision">setPrecision</a></h3>
public void <code>setPrecision</code>(int <em>anInt</em>)

<P>Sets to <em>anInt</em> the precision of the database representation for attributes with a value class of java.lang.Number or next.util.DecimalNumber.<p>
<B>See also: </B>  
<a href="#3841"><code>setScale</code></a>, <a href="#3465"><code>precision</code></a>
<p><hr WIDTH=25% ALIGN=LEFT>
<a name="3831"></a>
<h3> <a name="//apple_ref/java/instm/Attribute/setReadFormat">setReadFormat</a></h3>
public void <code>setReadFormat</code>(java.lang.String <em>aString</em>)

<P>Sets the format string that's used to format the attribute's value for SELECT statements. In <em>aString</em>, %P is replaced by the attribute's external name. <p>
The read format string is used whenever the attribute is referenced in a select list or qualifier.<p>
<B>See also: </B>  
<a href="#3876"><code>setWriteFormat</code></a>, <a href="#3470"><code>readFormat</code></a>
<p><hr WIDTH=25% ALIGN=LEFT>
<a name="3836"></a>
<h3> <a name="//apple_ref/java/instm/Attribute/setReadOnly">setReadOnly</a></h3>
public void <code>setReadOnly</code>(boolean <em>aBoolean</em>)

<P>Sets whether the value of the attribute can be modified according to <em>aBoolean</em>. Throws an exception if <em>aBoolean</em> is <code>false</code> and the argument is derived but not flattened.<p>
<B>See also: </B>  
<a href="#4292"><code>isDerived</code></a>, <a href="#3388"><code>isFlattened</code></a>, <a href="#3398"><code>isReadOnly</code></a>
<p><hr WIDTH=25% ALIGN=LEFT>
<a name="3841"></a>
<h3> <a name="//apple_ref/java/instm/Attribute/setScale">setScale</a></h3>
public void <code>setScale</code>(int <em>anInt</em>)

<P>Sets to <em>anInt</em> the scale of the database representation for attributes with a value class of java.lang.Number or next.util.DecimalNumber. <em>anInt</em> can be negative.<p>
<B>See also: </B>  
<a href="#3826"><code>setPrecision</code></a>, <a href="#3475"><code>scale</code></a>
<p><hr WIDTH=25% ALIGN=LEFT>
<a name="3846"></a>
<h3> <a name="//apple_ref/java/instm/Attribute/setServerTimeZone">setServerTimeZone</a></h3>
public void <code>setServerTimeZone</code>(next.util.TimeZone <em>aTimeZone</em>)

<P>Sets to <em>aTimeZone</em> the time zone used for next.util.Dates in the database server. If <em>aTimeZone</em> is <code>null</code> then the local time zone is used. An AdaptorChannel automatically converts dates between the time zones used by the server and the client when fetching and saving values. Applies only to attributes that represent dates.<p>
<B>See also: </B>  
<a href="#3486"><code>serverTimeZone</code></a>
<p><hr WIDTH=25% ALIGN=LEFT>
<a name="3851"></a>
<h3> <a name="//apple_ref/java/instm/Attribute/setUserInfo">setUserInfo</a></h3>
public void <code>setUserInfo</code>(next.util.ImmutableHashtable <em>dictionary</em>)

<P>Sets to <em>dictionary</em> the dictionary of auxiliary data, which your application can use for whatever it needs. <em>dictionary</em> can only contain property list data types (that is, next.util.ImmutableHashtables, java.lang.Strings, next.util.ImmutableVectors, and next.util.ImmutableBytes).<p>
<B>See also: </B>  
<a href="#3507"><code>userInfo</code></a>
<p><hr WIDTH=25% ALIGN=LEFT>
<a name="3856"></a>
<h3> <a name="//apple_ref/java/instm/Attribute/setValueClassName">setValueClassName</a></h3>
public void <code>setValueClassName</code>(java.lang.String <em>aString</em>)

<P>Sets the class name for values of this attribute to <em>aString</em>. When an AdaptorChannel fetches data for the attribute, it's presented to the application as an instance of this class.<p>
The class need not exist in the run-time system when this message is sent, but it must exist when an adaptor channel performs a fetch; if the class isn't present the result depends on the adaptor. See your adaptor's documentation for information on how absent value classes are handled.<p>
<B>See also: </B>  
<a href="#3866"><code>setValueType</code></a>, <a href="#3522"><code>valueClassName</code></a>
<p><hr WIDTH=25% ALIGN=LEFT>
<a name="3861"></a>
<h3> <a name="//apple_ref/java/instm/Attribute/setValueFactoryMethodName">setValueFactoryMethodName</a></h3>
public void <code>setValueFactoryMethodName</code>(java.lang.String <em>aString</em>)

<P>Sets the "factory method"-which is invoked by the attribute to create an attribute value for a custom class-to <em>aString</em>. The factory method should be a static method returning an object of your custom value class. Use <a href="#3811"><code>setFactoryMethodArgumentType</code></a> to specify the type of argument that is to be passed to your factory method.<p>
<B>See also: </B>  
<a href="#3548"><code>valueFactoryMethodName</code></a>
<p><hr WIDTH=25% ALIGN=LEFT>
<a name="3866"></a>
<h3> <a name="//apple_ref/java/instm/Attribute/setValueType">setValueType</a></h3>
public void <code>setValueType</code>(java.lang.String <em>aString</em>)

<P>Sets to <em>aString</em> the conversion character (such as "i" or "d") for the data type a java.lang.Number attribute is converted to and from in your application. Value types are scalars such as <code>int</code>, <code>float</code>, and <code>double</code>. Each adaptor supports a different set of conversion characters for numeric types. However, in most (if not all) cases it's safe to supply a value of "i" (int) or "d" (double).<p>
<B>See also: </B>  
<a href="#3856"><code>setValueClassName</code></a>, <a href="#3558"><code>valueType</code></a>
<p><hr WIDTH=25% ALIGN=LEFT>
<a name="3871"></a>
<h3> <a name="//apple_ref/java/instm/Attribute/setWidth">setWidth</a></h3>
public void <code>setWidth</code>(int <em>anInt</em>)

<P>Sets to <em>anInt</em> the maximum amount of bytes the attribute's value may contain. Adaptors may use this information to allocate space for fetch buffers.<p>
<B>See also: </B>  
<a href="#3563"><code>width</code></a>
<p><hr WIDTH=25% ALIGN=LEFT>
<a name="3876"></a>
<h3> <a name="//apple_ref/java/instm/Attribute/setWriteFormat">setWriteFormat</a></h3>
public void <code>setWriteFormat</code>(java.lang.String <em>aString</em>)

<P>Sets the format string that's used to format the attribute's value for INSERT or UPDATE expressions. In <em>aString</em>, %P is replaced by the attribute's value. <p>
<B>See also: </B>  
<a href="#3831"><code>setReadFormat</code></a>, <a href="#3573"><code>writeFormat</code></a>
<p><hr WIDTH=25% ALIGN=LEFT>
<a name="3496"></a>
<h3> <a name="//apple_ref/java/instm/Attribute/storedProcedure">storedProcedure</a></h3>
public next.eo.StoredProcedure <code>storedProcedure</code>()

<P>Returns the stored procedure for which this attribute is an argument. If this attribute isn't an argument to a stored procedure but instead is owned by an entity, this method returns <code>null</code>.<p>
<B>See also: </B>  
<a href="#3357"><code>entity</code></a>
<p><hr WIDTH=25% ALIGN=LEFT>
<a name="3507"></a>
<h3> <a name="//apple_ref/java/instm/Attribute/userInfo">userInfo</a></h3>
public next.util.ImmutableHashtable <code>userInfo</code>()

<P>Returns a dictionary of user data. Your application can use this to store any auxiliary information it needs.<p>
<B>See also: </B>  
<a href="#3851"><code>setUserInfo</code></a>
<p><hr WIDTH=25% ALIGN=LEFT>
<a name="3512"></a>
<h3> <a name="//apple_ref/java/instm/Attribute/validateName">validateName</a></h3>
public java.lang.Throwable <code>validateName</code>(java.lang.String <em>aString</em>)

<P>Validates <em>aString</em> and returns <code>null</code> if it is a valid name, or an exception if it isn't. A name is invalid if it has zero length; starts with a character other than a letter, a number, or "@", "#", or "_"; or contains a character other than a letter, a number, "@", "#", "_", or "$". A name is also invalid if the receiver's Entity already has an attribute with the same name, or if the model has a stored procedure that has an argument with the same name.<p>
<a href="#3816"><code>setName</code></a> uses this method to validate its argument.<p>
<hr WIDTH=25% ALIGN=LEFT>
<a name="3522"></a>
<h3> <a name="//apple_ref/java/instm/Attribute/valueClassName">valueClassName</a></h3>
public java.lang.String <code>valueClassName</code>()

<P>Returns the name of the class for custom value types. When data is fetched for the attribute, it's presented to the application as an instance of this class. <p>
This class must be present in the run-time system when an AdaptorChannel fetches data for the attribute; if the class isn't present the result depends on the adaptor. See your adaptor's documentation for information on how absent value classes are handled.<p>
<B>See also: </B>  
<a href="#3558"><code>valueType</code></a>, <a href="#3856"><code>setValueClassName</code></a>
<p><hr WIDTH=25% ALIGN=LEFT>
<a name="3543"></a>
<h3> <a name="//apple_ref/java/instm/Attribute/valueFactoryMethod">valueFactoryMethod</a></h3>
public next.util.Selector <code>valueFactoryMethod</code>()

<P>Returns the factory method that's invoked by the attribute when creating an attribute value that's of a custom class. The value returned from this method is derived from the attribute's <a href="#3548"><code>valueFactoryMethodName</code></a>. If that name doesn't map to a valid method in the Java run-time, this method returns <code>null</code>.<p>
<hr WIDTH=25% ALIGN=LEFT>
<a name="3548"></a>
<h3> <a name="//apple_ref/java/instm/Attribute/valueFactoryMethodName">valueFactoryMethodName</a></h3>
public java.lang.String <code>valueFactoryMethodName</code>()

<P>Returns the name of the factory method that's used for creating a custom class value.<p>
<B>See also: </B>  
<a href="#3543"><code>valueFactoryMethod</code></a>, <a href="#3861"><code>setValueFactoryMethodName</code></a>
<p><hr WIDTH=25% ALIGN=LEFT>
<a name="3558"></a>
<h3> <a name="//apple_ref/java/instm/Attribute/valueType">valueType</a></h3>
public java.lang.String <code>valueType</code>()

<P>Returns the conversion character (such as "i" or "d") for the data type a java.lang.Number attribute is converted to and from in your application. Value types are scalars such as <code>int</code>, <code>float</code>, and <code>double</code>. <p>
<B>See also: </B>  
<a href="#3522"><code>valueClassName</code></a>, <a href="#3866"><code>setValueType</code></a>
<p><hr WIDTH=25% ALIGN=LEFT>
<a name="3563"></a>
<h3> <a name="//apple_ref/java/instm/Attribute/width">width</a></h3>
public int <code>width</code>()

<P>Returns the maximum length (in bytes) for values that are mapped to this attribute. Returns zero for numeric and date types.<p>
<B>See also: </B>  
<a href="#3871"><code>setWidth</code></a>
<p><hr WIDTH=25% ALIGN=LEFT>
<a name="3573"></a>
<h3> <a name="//apple_ref/java/instm/Attribute/writeFormat">writeFormat</a></h3>
public java.lang.String <code>writeFormat</code>()

<P>Returns the format string that's used to format the attribute's value for INSERT or UPDATE expressions. In the returned string, %P is replaced by the attribute's value.<p>
<B>See also: </B>  
<a href="#3470"><code>readFormat</code></a>, <a href="#3876"><code>setWriteFormat</code></a>
<p><hr WIDTH=25% ALIGN=LEFT>
<a name="2579"></a>
<h3> <a name="//apple_ref/java/instm/Attribute/"></a></h3>

 
 


<i>Copyright &#169; 1998, Apple Computer, Inc.   All rights
reserved.</i>

<!-- Last updated: 01/18/98 16:09:54 -->

</body>
</html>
