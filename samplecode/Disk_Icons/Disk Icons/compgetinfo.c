#include <Memory.h>#include <Types.h>#include <Menus.h>#include <Windows.h>#include <Dialogs.h>#include <Fonts.h>#include <Devices.h>#include <Printing.h>#include <Controls.h>#include <Errors.h>#include <Quickdraw.h>/*	this is the data structure pointed to in the result of the	disk driver call csCode=21 (get ICN#/comment).  This call	works on all devices.*/typedef struct TInfoBlk {	unsigned char	icon[128];		/* icon */	unsigned char	mask[128];		/* mask */	Str255			infoString;		/* info string (for get info) */} TInfoBlk,*TInfoPtr;void GetDiskInfo(short driverRefNum,short driveNum,TInfoPtr *dataBlk);void DrawInfo(TInfoPtr infoBlock);void GetAllInfo(void);void GetAllInfoYourWay(void);#ifdef powerc   QDGlobals	qd;#endifvoid main(void){	WindowPtr theWindow;	Rect wBounds;	InitGraf(&qd.thePort);    InitFonts();	InitWindows();	InitMenus();	TEInit();	InitDialogs(nil);	FlushEvents(everyEvent,0);	InitCursor();		SetRect(&wBounds,40,40,100,100);	theWindow = NewWindow (nil,&wBounds,(StringPtr)"\pIcons",true,documentProc,				(WindowPtr)(-1),true,0L);	SetPort(theWindow);	GetAllInfo();	DisposeWindow(theWindow);}/*	This routine traverses the currently mounted volumes	index using PBHGetVInfo().  The drive # and device	driver number for each volume is extracted from the	parameter block, and passed into GetDiskInfo() to	call the disk drivers.		Once the data has been retrieved, the icon is plotted*/void GetAllInfo(void){	HParamBlockRec vBlock;	/* volume parameter block used to traverse mounted vols */	OSErr err;	TInfoPtr dataBlk;		/* pointer used to point to result of csCode=21 call */		vBlock.volumeParam.ioNamePtr = nil;	vBlock.volumeParam.ioVRefNum = 0;	vBlock.volumeParam.ioVolIndex = 1;		do {		err = PBHGetVInfo (&vBlock,false);		vBlock.volumeParam.ioVolIndex++;		if (err==noErr) {			GetDiskInfo(vBlock.volumeParam.ioVDRefNum,						vBlock.volumeParam.ioVDrvInfo,&dataBlk);			if (dataBlk)				DrawInfo(dataBlk);		}	} while (err==noErr);}/*	GetDiskInfo() makes the call to the volume's driver to get the	volume icon and info string.  A pointer to this data is returned	by reference in dataBlk		This routine tries to call the disk's driver with csCode=22,	which attempts to get info on a specific physical volume.		If the csCode=22 call fails, I call csCode=21 to get the generalized	media icon.		Both calls are documented in IM V-470*/void GetDiskInfo(short driverRefNum,short driveNum,TInfoPtr *dataBlk){	ParamBlockRec pBlock;	OSErr err;		pBlock.cntrlParam.ioVRefNum = driveNum;	pBlock.cntrlParam.ioCRefNum = driverRefNum;	pBlock.cntrlParam.csCode = 22;		err = PBControl(&pBlock,false);	if (err==controlErr) {		pBlock.cntrlParam.ioVRefNum = driveNum;		pBlock.cntrlParam.ioCRefNum = driverRefNum;		pBlock.cntrlParam.csCode = 21;		err = PBControl(&pBlock,false);	}		if (err==noErr)		*dataBlk = (TInfoPtr) *(Ptr *)pBlock.cntrlParam.csParam; /* messy way to get the locn out */	else *dataBlk = nil;}/*	this routine uses CopyBits to draw the icon on the screen (ignoring the mask and	the info string).  Make sure you put up a window and call SetPort() first!*/void DrawInfo(TInfoPtr infoBlock){	BitMap iconMap;	Rect destRect;		iconMap.baseAddr = (Ptr)infoBlock;	iconMap.rowBytes = 4;	SetRect(&iconMap.bounds,0,0,32,32);	SetRect(&destRect,0,0,32,32);	OffsetRect(&destRect,10,10);	CopyBits(&iconMap,&qd.thePort->portBits,&iconMap.bounds,&destRect,			srcCopy,nil);	while (!Button());	while (Button());}