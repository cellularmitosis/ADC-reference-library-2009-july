<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>CocoaSpeechSynthesisExample - /SpeakingTextWindow.m</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/UserExperience/index.html">User Experience</a> &gt; <a href="../../samplecode/UserExperience/idxSpeechTechnologies-date.html">Speech Technologies</a> &gt; <A HREF="javascript:location.replace('index.html');">CocoaSpeechSynthesisExample</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">CocoaSpeechSynthesisExample</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/SpeakingTextWindow.m</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/CocoaSpeechSynthesisExample_main.m</option>
<option value="listing2.html">/ReadMe-CocoaSpeechExample.txt</option>
<option value="listing3.html">/SpeakingCharacterView.h</option>
<option value="listing4.html">/SpeakingCharacterView.m</option>
<option value="listing5.html">/SpeakingTextWindow.h</option>
<option value="listing6.html">/SpeakingTextWindow.m</option></select>
				</p>
				</form>
				<p><strong><a href="CocoaSpeechSynthesisExample.zip">Download Sample</a></strong> (&#147;CocoaSpeechSynthesisExample.zip&#148;, 196.0K)<BR>
<strong><a href="CocoaSpeechSynthesisExample.dmg">Download Sample</a></strong> (&#147;CocoaSpeechSynthesisExample.dmg&#148;, 223.6K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*

File: SpeakingTextWindow.m

Abstract: The main window hosting all the apps speech features.

Version: 1.4

Disclaimer: IMPORTANT:  This Apple software is supplied to you by Apple
Inc. (&quot;Apple&quot;) in consideration of your agreement to the
following terms, and your use, installation, modification or
redistribution of this Apple software constitutes acceptance of these
terms.  If you do not agree with these terms, please do not use,
install, modify or redistribute this Apple software.

In consideration of your agreement to abide by the following terms, and
subject to these terms, Apple grants you a personal, non-exclusive
license, under Apple's copyrights in this original Apple software (the
&quot;Apple Software&quot;), to use, reproduce, modify and redistribute the Apple
Software, with or without modifications, in source and/or binary forms;
provided that if you redistribute the Apple Software in its entirety and
without modifications, you must retain this notice and the following
text and disclaimers in all such redistributions of the Apple Software. 
Neither the name, trademarks, service marks or logos of Apple Inc.
may be used to endorse or promote products derived from the Apple
Software without specific prior written permission from Apple.  Except
as expressly stated in this notice, no other rights or licenses, express
or implied, are granted by Apple herein, including but not limited to
any patent rights that may be infringed by your derivative works or by
other works in which the Apple Software may be incorporated.

The Apple Software is provided by Apple on an &quot;AS IS&quot; basis.  APPLE
MAKES NO WARRANTIES, EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION
THE IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY AND FITNESS
FOR A PARTICULAR PURPOSE, REGARDING THE APPLE SOFTWARE OR ITS USE AND
OPERATION ALONE OR IN COMBINATION WITH YOUR PRODUCTS.

IN NO EVENT SHALL APPLE BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL
OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) ARISING IN ANY WAY OUT OF THE USE, REPRODUCTION,
MODIFICATION AND/OR DISTRIBUTION OF THE APPLE SOFTWARE, HOWEVER CAUSED
AND WHETHER UNDER THEORY OF CONTRACT, TORT (INCLUDING NEGLIGENCE),
STRICT LIABILITY OR OTHERWISE, EVEN IF APPLE HAS BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.

Copyright &copy; 2000-2007 Apple Inc. All Rights Reserved

*/

#import &quot;SpeakingTextWindow.h&quot;

//
// Constants
//
NSString *  kPlainTextDataTypeString  = @&quot;Plain Text&quot;;
NSString *  kDefaultWindowTextString  = @&quot;Welcome to Cocoa Speech Synthesis Example.  This application provides an example of using Apple's speech synthesis technology in a Cocoa-based application.&quot;;

NSString *  kWordCallbackParamPosition  = @&quot;ParamPosition&quot;;
NSString *  kWordCallbackParamLength  = @&quot;ParamLength&quot;;
NSString *  kErrorCallbackParamPosition = @&quot;ParamPosition&quot;;
NSString *  kErrorCallbackParamError  = @&quot;ParamError&quot;;

//
// Prototypes
//
static pascal void  OurErrorCallBackProc(SpeechChannel inSpeechChannel, long inRefCon, OSErr inError, long inBytePos);
static pascal void  OurTextDoneCallBackProc(SpeechChannel inSpeechChannel, long inRefCon, const void ** nextBuf, unsigned long * byteLen, long * controlFlags);
static pascal void  OurSpeechDoneCallBackProc(SpeechChannel inSpeechChannel, long inRefCon);
static pascal void  OurSyncCallBackProc(SpeechChannel inSpeechChannel, long inRefCon, OSType inSyncMessage);
static pascal void  OurPhonemeCallBackProc(SpeechChannel inSpeechChannel, long inRefCon, short inPhonemeOpcode);
static pascal void  OurWordCallBackProc(SpeechChannel inSpeechChannel, long inRefCon, long inWordPos, short inWordLen);
static UInt32    BCDNumToLong(UInt32 inBCDNum);
static NSString*  VersionNumToString(NumVersion inVersionNum);

//
// SpeechLibTestShellWindow object
//

@implementation SpeakingTextWindow

/*----------------------------------------------------------------------------------------
init

Set the default text of the window.
----------------------------------------------------------------------------------------*/
- (id)init
{
  if (self = [super init]) {
    
    // Set our default window text.
    [self setTextData:[NSData dataWithBytes:[kDefaultWindowTextString cString] length:[kDefaultWindowTextString cStringLength]]];
    [self setTextDataType:kPlainTextDataTypeString];
  }
  
  return self;
}

/*----------------------------------------------------------------------------------------
dealloc

Release any memory we allocated while the window was showing.
----------------------------------------------------------------------------------------*/
-(void)dealloc
{
  [fTextData release];
  [fTextDataType release];
  [super dealloc];
}

/*----------------------------------------------------------------------------------------
setTextData:

Set our text data variable and update text in window if showing.
----------------------------------------------------------------------------------------*/
- (void)setTextData:(NSData *)theData
{
  [theData retain];
  [fTextData release];
  fTextData = theData;
  
  // If the window is showing, update the text view. 
  if (fSpokenTextView) {
    
    if ([[self textDataType] isEqualToString:@&quot;RTF Document&quot;])
      [fSpokenTextView replaceCharactersInRange:NSMakeRange(0,[[fSpokenTextView string] length]) withRTF:[self textData]];
    else
      [fSpokenTextView replaceCharactersInRange:NSMakeRange(0,[[fSpokenTextView string] length]) withString:[NSString stringWithCString:[[self textData] bytes] length:[[self textData] length]]];
  }
}

/*----------------------------------------------------------------------------------------
textData

Returns autoreleased copy of text data.
----------------------------------------------------------------------------------------*/
- (NSData *)textData
{
  return [[fTextData copy] autorelease];
}

/*----------------------------------------------------------------------------------------
setTextDataType:

Set our text data type variable.
----------------------------------------------------------------------------------------*/
- (void)setTextDataType:(NSString *)theType
{
  [theType retain];
  [fTextDataType release];
  fTextDataType = theType;
}

/*----------------------------------------------------------------------------------------
textDataType

Returns autoreleased copy of text data.
----------------------------------------------------------------------------------------*/
- (NSString *)textDataType
{
  return [[fTextDataType copy] autorelease];
}

/*----------------------------------------------------------------------------------------
textDataType

Returns reference to character view for callbacks.
----------------------------------------------------------------------------------------*/
- (SpeakingCharacterView *)characterView
{
  return fCharacterView;
}

/*----------------------------------------------------------------------------------------
shouldDisplayWordCallbacks

Returns true if user has chosen to have words hightlight during synthesis.
----------------------------------------------------------------------------------------*/
- (BOOL)shouldDisplayWordCallbacks
{
  return [fHandleWordCallbacksCheckboxButton intValue];
}

/*----------------------------------------------------------------------------------------
shouldDisplayPhonemeCallbacks

Returns true if user has chosen to the character animate phonemes during synthesis.
----------------------------------------------------------------------------------------*/
- (BOOL)shouldDisplayPhonemeCallbacks
{
  return [fHandlePhonemeCallbacksCheckboxButton intValue];
}

/*----------------------------------------------------------------------------------------
shouldDisplayErrorCallbacks

Returns true if user has chosen to have an alert appear in response to an error callback.
----------------------------------------------------------------------------------------*/
- (BOOL)shouldDisplayErrorCallbacks
{
  return [fHandleErrorCallbacksCheckboxButton intValue];
}

/*----------------------------------------------------------------------------------------
shouldDisplaySyncCallbacks

Returns true if user has chosen to have an alert appear in response to an sync callback.
----------------------------------------------------------------------------------------*/
- (BOOL)shouldDisplaySyncCallbacks
{
  return [fHandleSyncCallbacksCheckboxButton intValue];
}

/*----------------------------------------------------------------------------------------
shouldDisplaySpeechDoneCallbacks

Returns true if user has chosen to have an alert appear when synthesis is finished.
----------------------------------------------------------------------------------------*/
- (BOOL)shouldDisplaySpeechDoneCallbacks
{
  return [fHandleSpeechDoneCallbacksCheckboxButton intValue];
}

/*----------------------------------------------------------------------------------------
shouldDisplayTextDoneCallbacks

Returns true if user has chosen to have an alert appear when text processing is finished.
----------------------------------------------------------------------------------------*/
- (BOOL)shouldDisplayTextDoneCallbacks
{
  return [fHandleTextDoneCallbacksCheckboxButton intValue];
}

/*----------------------------------------------------------------------------------------
awakeFromNib

This routine is call once right after our nib file is loaded.  We build our voices
pop-up menu, create a new speech channel and update our window using parameters from
the new speech channel.
----------------------------------------------------------------------------------------*/
- (void)awakeFromNib
{
  OSErr    theErr = noErr;
  
  //
  // Build the Voices pop-up menu
  //
  {
    short    numOfVoices;
    long    voiceIndex;
    BOOL    voiceFoundAndSelected = false;
    VoiceSpec  theVoiceSpec;
    
    // Delete the existing voices from the bottom of the menu.
    while([fVoicesPopUpButton numberOfItems] &gt; 2)
      [fVoicesPopUpButton removeItemAtIndex:2];
    
    // Ask TTS API for each available voicez
    theErr = CountVoices(&amp;numOfVoices);
    if (theErr != noErr)
      NSRunAlertPanel(@&quot;CountVoices&quot;, [NSString stringWithFormat:@&quot;Error #%d returned.&quot;, theErr], @&quot;Oh?&quot;, NULL, NULL);
    
    if (theErr == noErr) {
      for (voiceIndex = 1; voiceIndex &lt;= numOfVoices; voiceIndex++) {
        VoiceDescription  theVoiceDesc;
        theErr = GetIndVoice(voiceIndex, &amp;theVoiceSpec);
        if (theErr != noErr)
          NSRunAlertPanel(@&quot;GetIndVoice&quot;, [NSString stringWithFormat:@&quot;Error #%d returned.&quot;, theErr], @&quot;Oh?&quot;, NULL, NULL);
        if (theErr == noErr)
          theErr = GetVoiceDescription(&amp;theVoiceSpec, &amp;theVoiceDesc, sizeof(theVoiceDesc));
        if (theErr != noErr)
          NSRunAlertPanel(@&quot;GetVoiceDescription&quot;, [NSString stringWithFormat:@&quot;Error #%d returned.&quot;, theErr], @&quot;Oh?&quot;, NULL, NULL);
        
        if (theErr == noErr) {
          // Get voice name and add it to the menu list
          NSString  *theNameString = [[[NSString alloc]initWithCString:(char *) &amp;(theVoiceDesc.name[1]) length:theVoiceDesc.name[0]]autorelease];
          [fVoicesPopUpButton addItemWithTitle:theNameString];
          
          // Selected this item if it matches our default voice spec.
          if (theVoiceSpec.creator == fSelectedVoiceCreator &amp;&amp; theVoiceSpec.id == fSelectedVoiceID) {
            [fVoicesPopUpButton selectItemAtIndex:voiceIndex-1];
            voiceFoundAndSelected = true;
          }
          
        }
      }
      
      // User preference default if problems.
      if (! voiceFoundAndSelected &amp;&amp; numOfVoices &gt;= 1) {
        // Update our object fields with the first voice
        fSelectedVoiceCreator  = 0;
        fSelectedVoiceID    = 0;
        
        [fVoicesPopUpButton selectItemAtIndex:0];
      }
    }
    else {
      [fVoicesPopUpButton selectItemAtIndex:0];
    }
    
  }
  
  // Create Speech Channel configured with our desired options and callbacks
  [self createNewSpeechChannel:NULL];
  
  // Set editable default fields
  [self fillInEditableParameterFields];
  
  // Enable buttons appropriatelly
  [fStartStopButton setEnabled:true];
  [fPauseContinueButton setEnabled:false];
  [fSaveAsFileButton setEnabled:true];
  
  // Show API version number
  [fAPIVersionStaticField setStringValue:VersionNumToString(SpeechManagerVersion())];
  
  // Set starting expresison on animated character
  [self phonemeCallbacksButtonPressed:fHandlePhonemeCallbacksCheckboxButton];
  
}

/*----------------------------------------------------------------------------------------
updateSpeakingControlState

This routine is called when appropriate to update the Start/Stop Speaking, 
Pause/Continue Speaking buttons.
----------------------------------------------------------------------------------------*/
- (void)updateSpeakingControlState
{
  
  //
  // Update controls based on speaking state
  //
  [fSaveAsFileButton setEnabled:!fCurrentlySpeaking];
  [fPauseContinueButton setEnabled:fCurrentlySpeaking];
  [fStartStopButton setEnabled:!fCurrentlyPaused];
  
  if (fCurrentlySpeaking) {
    [fStartStopButton setTitle:NSLocalizedString(@&quot;Stop Speaking&quot;, @&quot;Stop Speaking&quot;)];
    [fPauseContinueButton setTitle:NSLocalizedString(@&quot;Pause Speaking&quot;, @&quot;Pause Speaking&quot;)];
  }
  else {
    [fStartStopButton setTitle:NSLocalizedString(@&quot;Start Speaking&quot;, @&quot;Start Speaking&quot;)];
    [fSpokenTextView setSelectedRange:fOrgSelectionRange];  // Set selection length to zero.
  }
  
  if (fCurrentlyPaused)
    [fPauseContinueButton setTitle:NSLocalizedString(@&quot;Continue Speaking&quot;, @&quot;Continue Speaking&quot;)];
  else
    [fPauseContinueButton setTitle:NSLocalizedString(@&quot;Pause Speaking&quot;, @&quot;Pause Speaking&quot;)];
  
  [self enableOptionsForSpeakingState:fCurrentlySpeaking];
  
  
  //
  // Update parameter fields.
  //
  Fixed  tempFixedValue = 0;
  
  GetSpeechInfo(fCurSpeechChannel, soRate, &amp;tempFixedValue);
  [fRateCurrentStaticField setDoubleValue:(tempFixedValue / 65536.0)];
  
  GetSpeechPitch(fCurSpeechChannel, &amp;tempFixedValue);
  [fPitchBaseCurrentStaticField setDoubleValue:(tempFixedValue / 65536.0)];
  
  GetSpeechInfo(fCurSpeechChannel, soPitchMod, &amp;tempFixedValue);
  [fPitchModCurrentStaticField setDoubleValue:(tempFixedValue / 65536.0)];
  
  GetSpeechInfo(fCurSpeechChannel, soVolume, &amp;tempFixedValue);
  [fVolumeCurrentStaticField setDoubleValue:(tempFixedValue / 65536.0)];
  
}

/*----------------------------------------------------------------------------------------
highlightWordWithParams:

Highlights the word currently being spoken based on text position and text length
provided in the word callback routine.
----------------------------------------------------------------------------------------*/
- (void)highlightWordWithParams:(NSDictionary *)params
{
  UInt32  selectionPosition = [[params objectForKey:kWordCallbackParamPosition] longValue] + fOffsetToSpokenText;
  UInt32  wordLength = [[params objectForKey:kWordCallbackParamLength] longValue];
  
  [fSpokenTextView scrollRangeToVisible:NSMakeRange(selectionPosition, wordLength)];
  [fSpokenTextView setSelectedRange:NSMakeRange(selectionPosition, wordLength)];
  [fSpokenTextView display];
}

/*----------------------------------------------------------------------------------------
displayErrorAlertWithParams:

Displays an alert describing a text processing error provided in the error callback.
----------------------------------------------------------------------------------------*/
- (void)displayErrorAlertWithParams:(NSDictionary *)params
{
  
  UInt32  errorPosition = [[params objectForKey:kErrorCallbackParamPosition] longValue] + fOffsetToSpokenText;
  UInt32  errorCode = [[params objectForKey:kErrorCallbackParamError] longValue];
  
  if (errorCode != fLastErrorCode) {
    OSErr  theErr = noErr;
    unsigned long alertButtonClicked;
    NSString*  theMessageStr = NULL;
    
    // Tell engine to pause while we display this dialog.
    theErr = PauseSpeechAt(fCurSpeechChannel, kImmediate);
    if (theErr != noErr)
      NSRunAlertPanel(@&quot;PauseSpeechAt&quot;, [NSString stringWithFormat:@&quot;Error #%d returned.&quot;, theErr], @&quot;Oh?&quot;, NULL, NULL);
    
    // Select offending character
    [fSpokenTextView setSelectedRange:NSMakeRange(errorPosition, 1)];
    [fSpokenTextView display];
    
    // Display error alert, and stop or continue based on user's desires
    theMessageStr = [NSString stringWithFormat:@&quot;Error #%d occurred at position %d in the text.&quot;, errorCode, errorPosition];
    alertButtonClicked = NSRunAlertPanel(@&quot;Text Processing Error&quot;, theMessageStr, @&quot;Stop&quot;, NULL, @&quot;Continue&quot;);
    if (alertButtonClicked == 1)
      [self startStopButtonPressed:fStartStopButton];
    else {
      theErr = ContinueSpeech(fCurSpeechChannel);
      if (theErr != noErr)
        NSRunAlertPanel(@&quot;ContinueSpeech&quot;, [NSString stringWithFormat:@&quot;Error #%d returned.&quot;, theErr], @&quot;Oh?&quot;, NULL, NULL);
    }
    
    fLastErrorCode = errorCode;
  }
  
}

/*----------------------------------------------------------------------------------------
displaySyncAlertWithMessage:

Displays an alert with information about a sync command in response to a sync callback.
----------------------------------------------------------------------------------------*/
- (void)displaySyncAlertWithMessage:(NSNumber *)messageNumber
{
  OSErr  theErr = noErr;
  unsigned long alertButtonClicked;
  NSString*  theMessageStr = NULL;
  
  // Tell engine to pause while we display this dialog.
  theErr = PauseSpeechAt(fCurSpeechChannel, kImmediate);
  if (theErr != noErr)
    NSRunAlertPanel(@&quot;PauseSpeechAt&quot;, [NSString stringWithFormat:@&quot;Error #%d returned.&quot;, theErr], @&quot;Oh?&quot;, NULL, NULL);
  
  // Display error alert, and stop or continue based on user's desires
  UInt32  theMessageValue = [messageNumber longValue];  
  theMessageStr = [NSString stringWithFormat:@&quot;Sync embedded command was discovered containing message %d ('%4s').&quot;, theMessageValue, &amp;theMessageValue];
  alertButtonClicked = NSRunAlertPanel(@&quot;Sync Callback&quot;, theMessageStr, @&quot;Stop&quot;, NULL, @&quot;Continue&quot;);
  if (alertButtonClicked == 1)
    [self startStopButtonPressed:fStartStopButton];
  else
  {
    theErr = ContinueSpeech(fCurSpeechChannel);
    if (theErr != noErr)
      NSRunAlertPanel(@&quot;ContinueSpeech&quot;, [NSString stringWithFormat:@&quot;Error #%d returned.&quot;, theErr], @&quot;Oh?&quot;, NULL, NULL);
  }
  
}

/*----------------------------------------------------------------------------------------
speechIsDone

Updates user interface and optionally displays an alert when generation of speech is
finish.
----------------------------------------------------------------------------------------*/
- (void)speechIsDone
{
  fCurrentlySpeaking = false;
  [self updateSpeakingControlState];
  [self enableCallbackControlsBasedOnSavingToFileFlag:false];
  
  if ([self shouldDisplaySpeechDoneCallbacks])
    NSRunAlertPanel(@&quot;Speech Done&quot;, @&quot;Generation of synthesized speech is finished.&quot;, @&quot;OK&quot;, NULL, NULL);
}

/*----------------------------------------------------------------------------------------
displayTextDoneAlert

Displays an alert in response to a text done callback.
----------------------------------------------------------------------------------------*/
- (void)displayTextDoneAlert
{
  OSErr  theErr = noErr;
  unsigned long alertButtonClicked;
  
  // Tell engine to pause while we display this dialog.
  theErr = PauseSpeechAt(fCurSpeechChannel, kImmediate);
  if (theErr != noErr)
    NSRunAlertPanel(@&quot;PauseSpeechAt&quot;, [NSString stringWithFormat:@&quot;Error #%d returned.&quot;, theErr], @&quot;Oh?&quot;, NULL, NULL);
  
  // Display error alert, and stop or continue based on user's desires
  alertButtonClicked = NSRunAlertPanel(@&quot;Text Done Callback&quot;, @&quot;Processing of the text has completed.&quot;, @&quot;Stop&quot;, NULL, @&quot;Continue&quot;);
  if (alertButtonClicked == 1)
    [self startStopButtonPressed:fStartStopButton];
  else
  {
    theErr = ContinueSpeech(fCurSpeechChannel);
    if (theErr != noErr)
      NSRunAlertPanel(@&quot;ContinueSpeech&quot;, [NSString stringWithFormat:@&quot;Error #%d returned.&quot;, theErr], @&quot;Oh?&quot;, NULL, NULL);
  }
}


/*----------------------------------------------------------------------------------------
startStopButtonPressed:

An action method called when the user clicks the &quot;Start Speaking&quot;/&quot;Stop Speaking&quot;
button.   We either start or stop speaking based on the current speaking state.
----------------------------------------------------------------------------------------*/
- (IBAction)startStopButtonPressed:(id)sender
{
  OSErr  theErr  = noErr;
  
  if (fCurrentlySpeaking) {
    
    long  whereToStop;
    
    // Grab where to stop at value from radio buttons
    if ([fAfterWordRadioButton intValue])
      whereToStop = kEndOfWord;
    else if ([fAfterSentenceRadioButton intValue])
      whereToStop = kEndOfSentence;
    else
      whereToStop = kImmediate;
    
    if (whereToStop == kImmediate) {
      // NOTE:  We could just call StopSpeechAt with kImmediate, but for test purposes
      //      we exercise the StopSpeech routine.
      theErr = StopSpeech(fCurSpeechChannel);
      if (theErr != noErr)
        NSRunAlertPanel(@&quot;StopSpeech&quot;, [NSString stringWithFormat:@&quot;Error #%d returned.&quot;, theErr], @&quot;Oh?&quot;, NULL, NULL);
    }
    else {
      theErr = StopSpeechAt(fCurSpeechChannel, whereToStop);
      if (theErr != noErr)
        NSRunAlertPanel(@&quot;StopSpeechAt&quot;, [NSString stringWithFormat:@&quot;Error #%d returned.&quot;, theErr], @&quot;Oh?&quot;, NULL, NULL);
    }
    
    fCurrentlySpeaking = false;
    [self updateSpeakingControlState];
  }
  else {
    [self startSpeakingTextViewToURL:NULL];
  }
  
}

/*----------------------------------------------------------------------------------------
saveAsButtonPressed:

An action method called when the user clicks the &quot;Save As File&quot; button.   We ask user
to specify where to save the file, then start speaking to this file.
----------------------------------------------------------------------------------------*/
- (IBAction)saveAsButtonPressed:(id)sender
{
  NSURL * selectedFileURL = NULL;
  
  NSSavePanel *  theSavePanel = [NSSavePanel new];
  [theSavePanel setPrompt:NSLocalizedString(@&quot;Save&quot;, @&quot;Save&quot;)];
  if (NSFileHandlingPanelOKButton == [theSavePanel runModalForDirectory:NULL file:@&quot;Synthesized Speech.aiff&quot;]) {
    selectedFileURL = [theSavePanel URL];
    [self startSpeakingTextViewToURL:selectedFileURL];
  }
  
  [theSavePanel autorelease];
}

/*----------------------------------------------------------------------------------------
startSpeakingTextViewToURL:

This method sets up the speech channel and begins the speech synthesis 
process, optionally speaking to a file instead playing through the speakers.
----------------------------------------------------------------------------------------*/
- (void)startSpeakingTextViewToURL:(NSURL *)url
{
  
  OSErr    theErr = noErr;
  NSString *  theViewText;
  
  // Grab the selection substring, or if no selection then grab entire text.
  fOrgSelectionRange = [fSpokenTextView selectedRange];
  
  if (fOrgSelectionRange.length == 0) {
    theViewText = [fSpokenTextView string];
    fOffsetToSpokenText = 0;
  }
  else {
    theViewText = [[fSpokenTextView string] substringWithRange:fOrgSelectionRange];
    fOffsetToSpokenText = fOrgSelectionRange.location;
  }
  
  // Setup our callbacks
  fSavingToFile =   (url != NULL);
  if (theErr == noErr) {
    theErr = SetSpeechInfo(fCurSpeechChannel, soErrorCallBack, fSavingToFile?NULL:OurErrorCallBackProc);
    if (theErr != noErr)
      NSRunAlertPanel(@&quot;SetSpeechInfo(soErrorCallBack)&quot;, [NSString stringWithFormat:@&quot;Error #%d returned.&quot;, theErr], @&quot;Oh?&quot;, NULL, NULL);
  }
  if (theErr == noErr) {
    theErr = SetSpeechInfo(fCurSpeechChannel, soPhonemeCallBack, fSavingToFile?NULL:OurPhonemeCallBackProc);
    if (theErr != noErr)
      NSRunAlertPanel(@&quot;SetSpeechInfo(soPhonemeCallBack)&quot;, [NSString stringWithFormat:@&quot;Error #%d returned.&quot;, theErr], @&quot;Oh?&quot;, NULL, NULL);
  }
  if (theErr == noErr) {
    theErr = SetSpeechInfo(fCurSpeechChannel, soSpeechDoneCallBack, OurSpeechDoneCallBackProc);
    if (theErr != noErr)
      NSRunAlertPanel(@&quot;SetSpeechInfo(soSpeechDoneCallBack)&quot;, [NSString stringWithFormat:@&quot;Error #%d returned.&quot;, theErr], @&quot;Oh?&quot;, NULL, NULL);
  }
  if (theErr == noErr) {
    theErr = SetSpeechInfo(fCurSpeechChannel, soSyncCallBack, fSavingToFile?NULL:OurSyncCallBackProc);
    if (theErr != noErr)
      NSRunAlertPanel(@&quot;SetSpeechInfo(soSyncCallBack)&quot;, [NSString stringWithFormat:@&quot;Error #%d returned.&quot;, theErr], @&quot;Oh?&quot;, NULL, NULL);
  }
  
  if (theErr == noErr) {
    theErr = SetSpeechInfo(fCurSpeechChannel, soTextDoneCallBack, fSavingToFile?NULL:OurTextDoneCallBackProc);
    if (theErr != noErr)
      NSRunAlertPanel(@&quot;SetSpeechInfo(soTextDoneCallBack)&quot;, [NSString stringWithFormat:@&quot;Error #%d returned.&quot;, theErr], @&quot;Oh?&quot;, NULL, NULL);
  }
  if (theErr == noErr) {
    theErr = SetSpeechInfo(fCurSpeechChannel, soWordCallBack, fSavingToFile?NULL:OurWordCallBackProc);
    if (theErr != noErr)
      NSRunAlertPanel(@&quot;SetSpeechInfo(soWordCallBack)&quot;, [NSString stringWithFormat:@&quot;Error #%d returned.&quot;, theErr], @&quot;Oh?&quot;, NULL, NULL);
  }
  
  // Set URL to save file to disk
  SetSpeechInfo(fCurSpeechChannel, 'opaf', url);  // Use selector constant soOutputToFileWithCFURL with 10.3 or later
  
  // Convert NSString to cString. 
  char * theTextToSpeak = (char *)[theViewText lossyCString];
  if (theTextToSpeak) {
    // We want the text view the active view.  Also saves any parameters currently being edited.
    [fWindow makeFirstResponder:fSpokenTextView];  
    
    OSErr  theErr = SpeakText(fCurSpeechChannel, theTextToSpeak, strlen(theTextToSpeak));
    if (theErr == noErr) {
      
      // Update our vars
      fLastErrorCode = 0;
      fLastSpeakingValue = false;
      fLastPausedValue = false;
      fCurrentlySpeaking = true;
      fCurrentlyPaused = false;
      [self updateSpeakingControlState];
    }
    else {
      NSRunAlertPanel(@&quot;SpeakText&quot;, [NSString stringWithFormat:@&quot;Error #%d returned.&quot;, theErr], @&quot;Oh?&quot;, NULL, NULL);
    }
  }
  
  [self enableCallbackControlsBasedOnSavingToFileFlag:fSavingToFile];
  
}

/*----------------------------------------------------------------------------------------
pauseContinueButtonPressed:

An action method called when the user clicks the &quot;Pause Speaking&quot;/&quot;Continue Speaking&quot;
button.   We either pause or continue speaking based on the current speaking state.
----------------------------------------------------------------------------------------*/
- (IBAction)pauseContinueButtonPressed:(id)sender
{
  OSErr  theErr  = noErr;
  
  if (fCurrentlyPaused) {
    
    // We want the text view the active view.  Also saves any parameters currently being edited.
    [fWindow makeFirstResponder:fSpokenTextView];  
    
    theErr = ContinueSpeech(fCurSpeechChannel);
    if (theErr != noErr)
      NSRunAlertPanel(@&quot;ContinueSpeech&quot;, [NSString stringWithFormat:@&quot;Error #%d returned.&quot;, theErr], @&quot;Oh?&quot;, NULL, NULL);
    
    fCurrentlyPaused = false;
    [self updateSpeakingControlState];
  }
  else {
    long  whereToPause;
    
    // Figure out where to stop from radio buttons
    if ([fAfterWordRadioButton intValue])
      whereToPause = kEndOfWord;
    else if ([fAfterSentenceRadioButton intValue])
      whereToPause = kEndOfSentence;
    else
      whereToPause = kImmediate;
    
    theErr = PauseSpeechAt(fCurSpeechChannel, whereToPause);
    if (theErr != noErr)
      NSRunAlertPanel(@&quot;PauseSpeechAt&quot;, [NSString stringWithFormat:@&quot;Error #%d returned.&quot;, theErr], @&quot;Oh?&quot;, NULL, NULL);
    
    fCurrentlyPaused = true;
    [self updateSpeakingControlState];
  }
}

/*----------------------------------------------------------------------------------------
voicePopupSelected:

An action method called when the user selects a new voice from the Voices pop-up
menu.  We ask the speech channel to use the selected voice.   If the current
speech channel cannot use the selected voice, we close and open new speech
channel with the selecte voice.
----------------------------------------------------------------------------------------*/
- (IBAction) voicePopupSelected:(id)sender
{
  OSErr  theErr    = noErr;
  VoiceSpec  theVoiceSpec;
  long    theSelectedMenuIndex = [sender indexOfSelectedItem];
  
  if (theSelectedMenuIndex == 0) {
    //
    // Use the default voice from preferences.
    //
    // Our only choice is to close and reopen the speech channel to get the default voice.
    fSelectedVoiceCreator = 0;
    theErr = [self createNewSpeechChannel:NULL];
  }
  else {
    // 
    // Use the voice the user selected.
    //
    theErr = GetIndVoice([sender indexOfSelectedItem] - 1, &amp;theVoiceSpec);
    if (theErr != noErr)
      NSRunAlertPanel(@&quot;GetIndVoice&quot;, [NSString stringWithFormat:@&quot;Error #%d returned.&quot;, theErr], @&quot;Oh?&quot;, NULL, NULL);
    
    if (theErr == noErr) {
      // Update our object fields with the selection
      fSelectedVoiceCreator  = theVoiceSpec.creator;
      fSelectedVoiceID    = theVoiceSpec.id;
      
      // Change the current voice.  If it needs another engine, then dispose the current channel and open another
      if (SetSpeechInfo(fCurSpeechChannel, soCurrentVoice, &amp;theVoiceSpec) == incompatibleVoice)
        theErr = [self createNewSpeechChannel:&amp;theVoiceSpec];
      
    }
  }
  
  // Set editable default fields
  if (fCurSpeechChannel)
    [self fillInEditableParameterFields];
  
}

/*----------------------------------------------------------------------------------------
charByCharCheckboxSelected:

An action method called when the user checks/unchecks the Character-By-Character
mode checkbox.  We tell the speech channel to use this setting.
----------------------------------------------------------------------------------------*/
- (IBAction)charByCharCheckboxSelected:(id)sender
{
  OSErr  theErr = noErr;
  
  OSType  theMode;
  if ([fCharByCharCheckboxButton intValue])
    theMode = modeLiteral;  
  else
    theMode = modeNormal;
  
  theErr = SetSpeechInfo(fCurSpeechChannel, soCharacterMode, &amp;theMode);
  if (theErr != noErr)
    NSRunAlertPanel(@&quot;SetSpeechInfo(soCharacterMode)&quot;, [NSString stringWithFormat:@&quot;Error #%d returned.&quot;, theErr], @&quot;Oh?&quot;, NULL, NULL);
}

/*----------------------------------------------------------------------------------------
digitByDigitCheckboxSelected:

An action method called when the user checks/unchecks the Digit-By-Digit
mode checkbox.  We tell the speech channel to use this setting.
----------------------------------------------------------------------------------------*/
- (IBAction)digitByDigitCheckboxSelected:(id)sender
{
  OSErr  theErr = noErr;
  
  OSType  theMode;
  if ([fDigitByDigitCheckboxButton intValue])
    theMode = modeLiteral;  
  else
    theMode = modeNormal;
  
  theErr = SetSpeechInfo(fCurSpeechChannel, soNumberMode, &amp;theMode);
  if (theErr != noErr)
    NSRunAlertPanel(@&quot;SetSpeechInfo(soNumberMode)&quot;, [NSString stringWithFormat:@&quot;Error #%d returned.&quot;, theErr], @&quot;Oh?&quot;, NULL, NULL);
}

/*----------------------------------------------------------------------------------------
digitByDigitCheckboxSelected:

An action method called when the user checks/unchecks the Phoneme input
mode checkbox.  We tell the speech channel to use this setting.
----------------------------------------------------------------------------------------*/
- (IBAction)phonemeModeCheckboxSelected:(id)sender
{
  OSErr  theErr = noErr;
  
  OSType  theMode;
  if ([fPhonemeModeCheckboxButton intValue])
    theMode = modePhonemes; 
  else
    theMode = modeText;
  
  theErr = SetSpeechInfo(fCurSpeechChannel, soInputMode, &amp;theMode);
  if (theErr != noErr)
    NSRunAlertPanel(@&quot;SetSpeechInfo(soInputMode)&quot;, [NSString stringWithFormat:@&quot;Error #%d returned.&quot;, theErr], @&quot;Oh?&quot;, NULL, NULL);
}

/*----------------------------------------------------------------------------------------
dumpPhonemesSelected:

An action method called when the user clicks the Dump Phonemes button.  We ask
the speech channel for a phoneme representation of the window text then save the
result to a text file at a location determined by the user.
----------------------------------------------------------------------------------------*/
- (IBAction)dumpPhonemesSelected:(id)sender
{
  NSSavePanel *panel = [NSSavePanel savePanel];
  
  if ([panel runModal]) {
    long  theNumOfPhonBytes  = 0;
    
    // Get and speech text
    char *  theTextToSpeak = (char *)[[fSpokenTextView string] lossyCString];
    if (theTextToSpeak) {
      
      Handle thePhonemeHandle = NewHandle(0);
      if (thePhonemeHandle) {
        
        OSErr  theErr = TextToPhonemes(fCurSpeechChannel, (Ptr)theTextToSpeak, (long)strlen(theTextToSpeak), thePhonemeHandle, (long *)&amp;theNumOfPhonBytes);
        if (theErr != noErr)
          NSRunAlertPanel(@&quot;TextToPhonemes&quot;, [NSString stringWithFormat:@&quot;Error #%d returned.&quot;, theErr], @&quot;Oh?&quot;, NULL, NULL);
        else {
          
          // Create NSData object with resulting handle and then write to disk.
          NSData *  thePhonemeText = [NSData dataWithBytesNoCopy:*thePhonemeHandle length:theNumOfPhonBytes freeWhenDone:false];
          if(! [thePhonemeText writeToURL:[panel URL] atomically:false])
            NSRunAlertPanel(@&quot;TextToPhonemes&quot;, @&quot;Phoneme file could not be written to disk&quot;, @&quot;Oh?&quot;, NULL, NULL);
        }
        
        DisposeHandle(thePhonemeHandle);
      }
      else 
        NSRunAlertPanel(@&quot;TextToPhonemes&quot;, @&quot;Could not allocate handle for phonemes&quot;, @&quot;Oh?&quot;, NULL, NULL);
      
    }
  }
  
}

/*----------------------------------------------------------------------------------------
useDictionarySelected:

An action method called when the user clicks the Use Dictionary button.
----------------------------------------------------------------------------------------*/
- (IBAction)useDictionarySelected:(id)sender
{
  // Open file.
  NSOpenPanel *panel = [NSOpenPanel openPanel];
  
  [panel setAllowsMultipleSelection:YES];
  if ([panel runModal]) {
    
    NSEnumerator *  fileURLsEnumerator = [[panel URLs]objectEnumerator];
    NSURL *      fileURL = NULL;
    while (fileURL = [fileURLsEnumerator nextObject]) {
      
      // Read dictionary file into NSData object.
      NSData *  speechSynthesisDictionaryData = [NSData dataWithContentsOfURL:fileURL];
      if (speechSynthesisDictionaryData) {
        
        // Allocate handle, then copy the data into the handle and pass it to UseDictionary.
        Handle  theFileDataHandle = NewHandle([speechSynthesisDictionaryData length]);
        if (theFileDataHandle) {
          
          memcpy(*theFileDataHandle, [speechSynthesisDictionaryData bytes], [speechSynthesisDictionaryData length]);
          
          OSErr theErr = UseDictionary(fCurSpeechChannel, theFileDataHandle);
          DisposeHandle(theFileDataHandle);
          
          if (theErr != noErr)
            NSRunAlertPanel(@&quot;UseDictionary&quot;, [NSString stringWithFormat:@&quot;Error #%d returned.&quot;, theErr], @&quot;Oh?&quot;, NULL, NULL);
        }
        else
          NSRunAlertPanel(@&quot;TextToPhonemes&quot;, @&quot;Could not allocate handle for dictionary&quot;, @&quot;Oh?&quot;, NULL, NULL);
        
      }
      else
        NSRunAlertPanel(@&quot;TextToPhonemes&quot;, [NSString stringWithFormat:@&quot;Error occurred reading %@.&quot;, [fileURL path]], @&quot;Oh?&quot;, NULL, NULL);
    }
  }
}

/*----------------------------------------------------------------------------------------
rateChanged:

An action method called when the user changes the rate field.  We tell the speech 
channel to use this setting.
----------------------------------------------------------------------------------------*/
- (IBAction)rateChanged:(id)sender
{
  OSErr  theErr = noErr;
  
  Fixed  theNewValue = [fRateDefaultEditableField doubleValue] * 65536.0;
  theErr = SetSpeechInfo(fCurSpeechChannel, soRate, &amp;theNewValue);
  
  if (theErr != noErr)
    NSRunAlertPanel(@&quot;SetSpeechInfo(soRate)&quot;, [NSString stringWithFormat:@&quot;Error #%d returned.&quot;, theErr], @&quot;Oh?&quot;, NULL, NULL);
  else
    [fRateCurrentStaticField setDoubleValue:[fRateDefaultEditableField doubleValue]];
}

/*----------------------------------------------------------------------------------------
pitchBaseChanged:

An action method called when the user changes the pitch base field.   We tell the speech 
channel to use this setting.
----------------------------------------------------------------------------------------*/
- (IBAction)pitchBaseChanged:(id)sender
{
  OSErr  theErr = noErr;
  
  Fixed  theNewValue = [fPitchBaseDefaultEditableField doubleValue] * 65536.0;
  theErr = SetSpeechPitch(fCurSpeechChannel, theNewValue);
  
  if (theErr != noErr)
    NSRunAlertPanel(@&quot;SetSpeechPitch&quot;, [NSString stringWithFormat:@&quot;Error #%d returned.&quot;, theErr], @&quot;Oh?&quot;, NULL, NULL);
  else
    [fPitchBaseCurrentStaticField setDoubleValue:[fPitchBaseDefaultEditableField doubleValue]];
}

/*----------------------------------------------------------------------------------------
pitchModChanged:

An action method called when the user changes the pitch modulation field.  We tell 
the speech channel to use this setting.
----------------------------------------------------------------------------------------*/
- (IBAction)pitchModChanged:(id)sender
{
  OSErr  theErr = noErr;
  
  Fixed  theNewValue = [fPitchModDefaultEditableField doubleValue] * 65536.0;
  theErr = SetSpeechInfo(fCurSpeechChannel, soPitchMod, &amp;theNewValue);
  
  if (theErr != noErr)
    NSRunAlertPanel(@&quot;SetSpeechInfo(soPitchMod)&quot;, [NSString stringWithFormat:@&quot;Error #%d returned.&quot;, theErr], @&quot;Oh?&quot;, NULL, NULL);
  else
    [fPitchModCurrentStaticField setDoubleValue:[fPitchModDefaultEditableField doubleValue]];
}

/*----------------------------------------------------------------------------------------
volumeChanged:

An action method called when the user changes the volume field.   We tell 
the speech channel to use this setting.
----------------------------------------------------------------------------------------*/
- (IBAction)volumeChanged:(id)sender
{
  OSErr  theErr = noErr;
  
  Fixed  theNewValue = [fVolumeDefaultEditableField doubleValue] * 65536.0;
  theErr = SetSpeechInfo(fCurSpeechChannel, soVolume, &amp;theNewValue);
  
  if (theErr != noErr)
    NSRunAlertPanel(@&quot;SetSpeechInfo(soVolume)&quot;, [NSString stringWithFormat:@&quot;Error #%d returned.&quot;, theErr], @&quot;Oh?&quot;, NULL, NULL);
  else
    [fVolumeCurrentStaticField setDoubleValue:[fVolumeDefaultEditableField doubleValue]];
}

/*----------------------------------------------------------------------------------------
resetSelected:

An action method called when the user clicks the Use Defaults button.  We tell 
the speech channel to use this the default settings.
----------------------------------------------------------------------------------------*/
- (IBAction)resetSelected:(id)sender
{
  OSErr  theErr = noErr;
  
  theErr = SetSpeechInfo(fCurSpeechChannel, soReset, NULL);
  
  [self fillInEditableParameterFields];
  
  if (theErr != noErr)
    NSRunAlertPanel(@&quot;SetSpeechInfo(soReset)&quot;, [NSString stringWithFormat:@&quot;Error #%d returned.&quot;, theErr], @&quot;Oh?&quot;, NULL, NULL);
}

- (IBAction)wordCallbacksButtonPressed:(id)sender
{
  if (! [fHandleWordCallbacksCheckboxButton intValue])
    [fSpokenTextView setSelectedRange:fOrgSelectionRange];
}

- (IBAction)phonemeCallbacksButtonPressed:(id)sender
{
  if ([fHandlePhonemeCallbacksCheckboxButton intValue])
    [fCharacterView setExpression:kCharacterExpressionIdentifierIdle];
  else
    [fCharacterView setExpression:kCharacterExpressionIdentifierSleep];
}

/*----------------------------------------------------------------------------------------
enableOptionsForSpeakingState:

Updates controls in the Option tab panel based on the passed speakingNow flag.
----------------------------------------------------------------------------------------*/
- (void)enableOptionsForSpeakingState:(BOOL)speakingNow
{
  [fVoicesPopUpButton setEnabled:!speakingNow];
  [fCharByCharCheckboxButton setEnabled:!speakingNow];
  [fDigitByDigitCheckboxButton setEnabled:!speakingNow];
  [fPhonemeModeCheckboxButton setEnabled:!speakingNow];
  [fDumpPhonemesButton setEnabled:!speakingNow];
  [fUseDictionaryButton setEnabled:!speakingNow];
}

/*----------------------------------------------------------------------------------------
enableCallbackControlsForSavingToFile:

Updates controls in the Callback tab panel based on the passed savingToFile flag.
----------------------------------------------------------------------------------------*/
- (void)enableCallbackControlsBasedOnSavingToFileFlag:(BOOL)savingToFile
{
  
  [fHandleWordCallbacksCheckboxButton setEnabled:!savingToFile];
  [fHandlePhonemeCallbacksCheckboxButton setEnabled:!savingToFile];
  [fHandleSyncCallbacksCheckboxButton setEnabled:!savingToFile];
  [fHandleErrorCallbacksCheckboxButton setEnabled:!savingToFile];
  [fHandleTextDoneCallbacksCheckboxButton setEnabled:!savingToFile];
  
  if (savingToFile || [fHandlePhonemeCallbacksCheckboxButton intValue] == 0)
    [fCharacterView setExpression:kCharacterExpressionIdentifierSleep];
  else
    [fCharacterView setExpression:kCharacterExpressionIdentifierIdle];
}

/*----------------------------------------------------------------------------------------
fillInEditableParameterFields

Updates &quot;Current&quot; fields in the Parameters tab panel based on the current state of the
speech channel.
----------------------------------------------------------------------------------------*/
- (void)fillInEditableParameterFields
{
  Fixed tempFixedValue = 0;
  
  GetSpeechInfo(fCurSpeechChannel, soRate, &amp;tempFixedValue);
  [fRateDefaultEditableField setDoubleValue:(tempFixedValue / 65536.0)];
  [fRateCurrentStaticField setDoubleValue:(tempFixedValue / 65536.0)];
  
  GetSpeechPitch(fCurSpeechChannel, &amp;tempFixedValue);
  [fPitchBaseDefaultEditableField setDoubleValue:(tempFixedValue / 65536.0)];
  [fPitchBaseCurrentStaticField setDoubleValue:(tempFixedValue / 65536.0)];
  
  GetSpeechInfo(fCurSpeechChannel, soPitchMod, &amp;tempFixedValue);
  [fPitchModDefaultEditableField setDoubleValue:(tempFixedValue / 65536.0)];
  [fPitchModCurrentStaticField setDoubleValue:(tempFixedValue / 65536.0)];
  
  GetSpeechInfo(fCurSpeechChannel, soVolume, &amp;tempFixedValue);
  [fVolumeDefaultEditableField setDoubleValue:(tempFixedValue / 65536.0)];
  [fVolumeCurrentStaticField setDoubleValue:(tempFixedValue / 65536.0)];
}

/*----------------------------------------------------------------------------------------
createNewSpeechChannel:

Create a new speech channel for the given voice spec.  A nil voice spec pointer
causes the speech channel to use the default voice.   Any existing speech channel
for this window is closed first.
----------------------------------------------------------------------------------------*/
- (OSErr)createNewSpeechChannel:(VoiceSpec *)voiceSpec
{
  OSErr  theErr = noErr;
  
  // Dispose of the current one, if present.
  if (fCurSpeechChannel) {
    theErr = DisposeSpeechChannel(fCurSpeechChannel);
    if (theErr != noErr)
      NSRunAlertPanel(@&quot;DisposeSpeechChannel&quot;, [NSString stringWithFormat:@&quot;Error #%d returned.&quot;, theErr], @&quot;Oh?&quot;, NULL, NULL);
    
    fCurSpeechChannel = NULL;
  }
  
  // Create a speech channel
  if (theErr == noErr) {
    theErr = NewSpeechChannel(voiceSpec, &amp;fCurSpeechChannel);
    if (theErr != noErr)
      NSRunAlertPanel(@&quot;NewSpeechChannel&quot;, [NSString stringWithFormat:@&quot;Error #%d returned.&quot;, theErr], @&quot;Oh?&quot;, NULL, NULL);
  }
  
  // Setup our refcon to the document controller object so we have access within our Speech callbacks
  if (theErr == noErr) {
    theErr = SetSpeechInfo(fCurSpeechChannel, soRefCon, (Ptr)self);
    if (theErr != noErr)
      NSRunAlertPanel(@&quot;SetSpeechInfo(soRefCon)&quot;, [NSString stringWithFormat:@&quot;Error #%d returned.&quot;, theErr], @&quot;Oh?&quot;, NULL, NULL);
  }
  
  return theErr;
}

/*----------------------------------------------------------------------------------------
windowNibName

Part of the NSDocument support.   Called by NSDocument to return the nib file name of 
the document.
----------------------------------------------------------------------------------------*/
- (NSString *)windowNibName {
  return @&quot;SpeakingTextWindow&quot;;
}

/*----------------------------------------------------------------------------------------
windowControllerDidLoadNib:

Part of the NSDocument support.   Called by NSDocument after the nib has been loaded 
to udpate window as appropriate.
----------------------------------------------------------------------------------------*/
- (void)windowControllerDidLoadNib:(NSWindowController *) aController{
  [super windowControllerDidLoadNib:aController];
  
  // Update the window text from data
  if ([[self textDataType] isEqualToString:@&quot;RTF Document&quot;])
    [fSpokenTextView replaceCharactersInRange:NSMakeRange(0,[[fSpokenTextView string] length]) withRTF:[self textData]];
  else
    [fSpokenTextView replaceCharactersInRange:NSMakeRange(0,[[fSpokenTextView string] length]) withString:[NSString stringWithCString:[[self textData] bytes] length:[[self textData] length]]];
}

/*----------------------------------------------------------------------------------------
dataRepresentationOfType:

Part of the NSDocument support.   Called by NSDocument to read data from file.
----------------------------------------------------------------------------------------*/
- (NSData *)dataRepresentationOfType:(NSString *)aType {
  
  // Write text to file.
  if ([aType isEqualToString:@&quot;RTF Document&quot;])
    [self setTextData:[fSpokenTextView RTFFromRange:NSMakeRange(0,[[fSpokenTextView string] length])]];
  else
    [self setTextData:[NSData dataWithBytes:[[fSpokenTextView string] cString] length:[[fSpokenTextView string] cStringLength]]];
  
  return [self textData];
}

/*----------------------------------------------------------------------------------------
loadDataRepresentation: ofType:

Part of the NSDocument support.   Called by NSDocument to write data to file.
----------------------------------------------------------------------------------------*/
- (BOOL)loadDataRepresentation:(NSData *)data ofType:(NSString *)aType {
  
  // Read the opened file.
  [self setTextData:data];
  [self setTextDataType:aType];
  
  return YES;
}


@end

//
// Callback routines
//

//
//      AN  IMPORTANT NOTE ABOUT CALLBACKS AND THREADS
//
// All speech synthesis callbacks, except for the Text Done callback, call their specified routine on a
// thread other than the main thread.  Performing certain actions directly from a speech synthesis callback
// routine may cause your program to crash without certain safe gaurds.   In this example, we use the NSThread 
// method performSelectorOnMainThread:withObject:waitUntilDone: to safely update the user interface and 
// interact with our objects using only the main thread.
//
// Depending on your needs you may be able to specify your Cocoa application is multiple threaded
// then preform actions directly from the speech synthesis callback routines.  To indicate your Cocoa
// application is mulitthreaded, call the following line before calling speech synthesis routines for 
// the first time:
//
//    [NSThread detachNewThreadSelector:@selector(self) toTarget:self withObject:nil];
// 


/*----------------------------------------------------------------------------------------
OurErrorCallBackProc

Called by speech channel when an error occurs during processing of text to speak.
----------------------------------------------------------------------------------------*/
pascal void OurErrorCallBackProc(SpeechChannel inSpeechChannel, long inRefCon, OSErr inError, long inBytePos)
{
  NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
  
  if ([(SpeakingTextWindow *)inRefCon shouldDisplayTextDoneCallbacks])
    [(SpeakingTextWindow *)inRefCon performSelectorOnMainThread:@selector(displayErrorAlertWithParams:) withObject:[NSDictionary dictionaryWithObjectsAndKeys:[NSNumber numberWithLong:inBytePos], kErrorCallbackParamPosition, [NSNumber numberWithLong:inError], kErrorCallbackParamError, NULL] waitUntilDone:false]; 
  
  [pool release];
}

/*----------------------------------------------------------------------------------------
OurTextDoneCallBackProc

Called by speech channel when all text has been processed.  Additional text can be 
passed back to continue processing.
----------------------------------------------------------------------------------------*/
pascal void OurTextDoneCallBackProc(SpeechChannel inSpeechChannel, long inRefCon, const void ** nextBuf, unsigned long * byteLen, long * controlFlags)
{
  NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
  
  *nextBuf = NULL;
  
  if ([(SpeakingTextWindow *)inRefCon shouldDisplayTextDoneCallbacks])
    [(SpeakingTextWindow *)inRefCon performSelectorOnMainThread:@selector(displayTextDoneAlert) withObject:NULL waitUntilDone:false]; 
  
  [pool release];
}

/*----------------------------------------------------------------------------------------
OurSpeechDoneCallBackProc

Called by speech channel when all speech has been generated.
----------------------------------------------------------------------------------------*/
pascal void OurSpeechDoneCallBackProc(SpeechChannel inSpeechChannel, long inRefCon)
{
  NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
  
  [(SpeakingTextWindow *)inRefCon performSelectorOnMainThread:@selector(speechIsDone) withObject:NULL waitUntilDone:false]; 
  
  [pool release];
}

/*----------------------------------------------------------------------------------------
OurSyncCallBackProc

Called by speech channel when it encouters a synchronization command within an
embedded speech comand in text being processed.
----------------------------------------------------------------------------------------*/
pascal void OurSyncCallBackProc(SpeechChannel inSpeechChannel, long inRefCon, OSType inSyncMessage)
{
  NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
  
  if ([(SpeakingTextWindow *)inRefCon shouldDisplaySyncCallbacks])
    [(SpeakingTextWindow *)inRefCon performSelectorOnMainThread:@selector(displaySyncAlertWithMessage:) withObject:[NSNumber numberWithLong:inSyncMessage] waitUntilDone:false]; 
  
  [pool release];
}

/*----------------------------------------------------------------------------------------
OurPhonemeCallBackProc

Called by speech channel every time a phoneme is about to be generated.   You might use
this to animate a speaking character.
----------------------------------------------------------------------------------------*/
pascal void OurPhonemeCallBackProc(SpeechChannel inSpeechChannel, long inRefCon, short inPhonemeOpcode)
{
  NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
  
  if ([(SpeakingTextWindow *)inRefCon shouldDisplayPhonemeCallbacks])
    [[(SpeakingTextWindow *)inRefCon characterView] performSelectorOnMainThread:@selector(setExpressionForPhoneme:) withObject:[NSNumber numberWithShort:inPhonemeOpcode] waitUntilDone:false];
  
  [pool release];
}

/*----------------------------------------------------------------------------------------
OurWordCallBackProc

Called by speech channel every time a word is about to be generated.  This program
uses this callback to highlight the currently spoken word.
----------------------------------------------------------------------------------------*/
pascal void OurWordCallBackProc(SpeechChannel inSpeechChannel, long inRefCon, long inWordPos, short inWordLen)
{
  NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
  
  if ([(SpeakingTextWindow *)inRefCon shouldDisplayWordCallbacks])
    [(SpeakingTextWindow *)inRefCon performSelectorOnMainThread:@selector(highlightWordWithParams:) withObject:[NSDictionary dictionaryWithObjectsAndKeys:[NSNumber numberWithLong:inWordPos], kWordCallbackParamPosition, [NSNumber numberWithLong:inWordLen], kWordCallbackParamLength, NULL] waitUntilDone:false]; 
  
  [pool release];
}


//
// Version display utility routines
//

/*----------------------------------------------------------------------------------------
BCDNumToLong:

Returns a BCD version of a given integer.
----------------------------------------------------------------------------------------*/
static UInt32  BCDNumToLong(UInt32 inBCDNum)
{
  UInt32    newValue = 0;
  UInt16  i;
  for(i = 0; i &lt; 8; i++) {
    if (i &gt; 0)
      newValue += i * 10 * (inBCDNum &amp; 0x0000000F);
    else
      newValue += inBCDNum &amp; 0x0000000F;
    
    inBCDNum &gt;&gt;= 4;
  }
  
  return newValue;
}

/*----------------------------------------------------------------------------------------
VersionNumToString

Passes back a string representation of a given version.   The version can be either a
2-byte BCD version stored in the loword of the passed in long integer, or a 4-byte
BCD version that includes the stage and release number.

For example:  0x000007501 becomes &quot;7.5.1&quot;, and 0x08012003 becomes &quot;8.0.1a3&quot;.
----------------------------------------------------------------------------------------*/
static NSString*  VersionNumToString(NumVersion  inVersionNum)
{
#define kMajorVersMask    0xFF000000
#define kMinorVersMask    0x00F00000
#define kBugFixVersMask    0x000F0000
#define kStageVersMask    0x0000FF00
#define kReleaseVersMask  0x000000FF
  
#define kMajorVersShift    24
#define kMinorVersShift    20
#define kBugFixVersShift  16
#define kStageVersShift    8
#define kReleaseVersShift  0
  
#define kDevel        0x20
#define kAlpha        0x40
#define kBeta        0x60
#define kFinal        0x80
  
  unsigned long  majorVersValue;
  unsigned long  minorVersValue;
  unsigned long  bufFixVersValue;
  unsigned long  stageVersValue;
  unsigned long  releaseVersValue;
  
  unsigned long pVersionNum = *((long*)&amp;inVersionNum);
  NSMutableString* theVersionStr  = [[NSMutableString new] autorelease];
  
  //  Handle standard version number format with build stage and release
  majorVersValue = (pVersionNum &amp; kMajorVersMask) &gt;&gt; kMajorVersShift;
  [theVersionStr appendFormat:@&quot;%d&quot;, BCDNumToLong(majorVersValue)];
  
  minorVersValue = (pVersionNum &amp; kMinorVersMask) &gt;&gt; kMinorVersShift;
  [theVersionStr appendString:@&quot;.&quot;];
  [theVersionStr appendFormat:@&quot;%d&quot;, minorVersValue];
  
  bufFixVersValue = (pVersionNum &amp; kBugFixVersMask) &gt;&gt; kBugFixVersShift;
  if (bufFixVersValue != 0) {
    [theVersionStr appendString:@&quot;.&quot;];
    [theVersionStr appendFormat:@&quot;%d&quot;, bufFixVersValue];
  }
  
  stageVersValue = (pVersionNum &amp; kStageVersMask) &gt;&gt; kStageVersShift;
  releaseVersValue = (pVersionNum &amp; kReleaseVersMask) &gt;&gt; kReleaseVersShift;
  
  if (releaseVersValue != 0) {
    
    switch (stageVersValue) {
      case kDevel:
        [theVersionStr appendString:@&quot;d&quot;];
        break;
      case kAlpha:
        [theVersionStr appendString:@&quot;a&quot;];
        break;
      case kBeta:
        [theVersionStr appendString:@&quot;b&quot;];
        break;
      case kFinal:
        [theVersionStr appendString:@&quot;f&quot;];
        break;
    }
    
  }
  
  [theVersionStr appendFormat:@&quot;%d&quot;, BCDNumToLong(releaseVersValue)];
  return theVersionStr;    
}


</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/CocoaSpeechSynthesisExample/listing6.html%3Fid%3DDTS10001089-1.1&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/CocoaSpeechSynthesisExample/listing6.html%3Fid%3DDTS10001089-1.1&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/CocoaSpeechSynthesisExample/listing6.html%3Fid%3DDTS10001089-1.1&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>