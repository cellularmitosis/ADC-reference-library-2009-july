<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>SuperSnapshot - /Snapshot.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxGraphicsImaging-date.html">Graphics & Imaging</a> &gt; <A HREF="javascript:location.replace('index.html');">SuperSnapshot</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/GraphicsImaging/index.html" target="_blank">Reference Library > Graphics & Imaging</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">SuperSnapshot</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/Snapshot.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/AEventStuff.c</option>
<option value="listing2.html">/Snapshot.c</option>
<option value="listing3.html">/Snapshot.h</option>
<option value="listing4.html">/Snapshot.r</option></select>
				</p>
				</form>
				<p><strong><a href="SuperSnapshot.zip">Download Sample</a></strong> (&#147;SuperSnapshot.zip&#148;, 133.2K)<BR>
<strong><a href="SuperSnapshot.dmg">Download Sample</a></strong> (&#147;SuperSnapshot.dmg&#148;, 204.6K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*  File:    Snapshot.c  Contains:  This application demonstrates how to quickly and            efficiently capture the main device's desktop into              a window.  The program basically reads the image               stored in the the main device's pixmap then copies              it to a custom pixmap.  The custom pixmap is de-              fined at the same depth of the main device and                 contains an identical copy of that device's color-              table.  This is done to provide the fastest                 performance possible when copying from an offscreen              to onscreen pixmap.  By making sure the pixel values            map to the exact same colors in both colortables,              copybits will do a direct transfer of bits without              wasting time remapping the colors.  Also the ctSeed              field for each colortable should be the same.  Finally,            since the main device's bounding rect is different              than that of the offscreen's, the copying performance            for the device to the offscreen is slightly affected            because of the scaling required.  However, the copying            performance for the offscreen to the window is the               best possible since the bounding rects for each are              identical.                      Written by: EL    Copyright:  Copyright &copy; 1991-1999 by Apple Computer, Inc., All Rights Reserved.        You may incorporate this Apple sample source code into your program(s) without        restriction. This Apple sample source code has been provided &quot;AS IS&quot; and the        responsibility for its operation is yours. You are not permitted to redistribute        this Apple sample source code as &quot;Apple sample source code&quot; after having made        changes. If you're going to re-distribute the source, we require that you make        it clear in the source that the code was descended from Apple sample source        code, but that you've made changes.  Change History (most recent first):        08/2000    JM        Major revisions made. In addition to being &quot;carbonized&quot;                      added: multiple windows, refreshing, saving, conditional                      menu bar for OS X and 9, Apple Event Quit support,                      updated about box....(bunch of extra things)        11/6/1999  GGS         Updated to work with modern (1999) Mac OS.                        Fixed a PixMap disposing bug.  Updated casts                      and headers.        7/14/1999  KG        Updated for Metrowerks Codewarror Pro 2.1        */#include &quot;Snapshot.h&quot;// Different picture scaling constantsconst int FULL_SIZE = 1;const float HALF_SIZE = 1.41; // square root of 2, roughlyconst int QUARTER_SIZE = 2;/* Global Variable Definitions */Rect        gBounds;            // System resolution, effectivelyBoolean        gDone = false;          // Application termination globalBoolean        gDoingTrick = false;      // &quot;Trick&quot; flagfloat        gScale = 2.0; // QUARTER_SIZE;      // Scaling the window, relative to resolution (default of 1/2 width and height)Rect        gMinWindowSize;          // The minimum window sizeconst unsigned char*    fileName =   &quot;\pDesktop Pic&quot;;  // Generic filenameconst unsigned char*    defaultName = &quot;\pSnapshot&quot;;    // Default Save File Nameunsigned long    resizingDelay = 0;int main(){    initMac();  setUp();    doNewSnapshot();  adjustMenus();  doEventLoop();  destroyAllWindows();}// Tests to see if we are running on Mac OS X.Boolean onOSX(){  long response;  OSErr  anErr = noErr;    anErr = Gestalt(gestaltSystemVersion, &amp;response);    return response &gt;= 0x01000 &amp;&amp; (anErr == noErr);}void destroyAllWindows(){  WindowPtr theWindow = FrontWindow();  while(FrontWindow() != NULL) {    disposeWindow(theWindow);    theWindow = FrontWindow();    }}void initMac(){  // the only &quot;init&quot; calls needed in carbon  InitCursor();  FlushEvents( 0, everyEvent );}void setUp(){  Handle  menuBar;  OSErr   anErr = noErr;  long  response;    // Carbon Porting guidelines say provide alternate menu bar/menu scheme for OS X  // This is just one way of doing a different menu for 9 and X, which is pretty static  if (onOSX())     menuBar = GetNewMBar(MENU_BAR_IDX);    //if we are running on X, need menu without a File-&gt;Quit  else    menuBar = GetNewMBar(MENU_BAR_ID);    //default menu bar      anErr = ResError();    if ( menuBar == nil || anErr != noErr )     ExitToShell();    SetMenuBar(menuBar);  DisposeHandle(menuBar);  DrawMenuBar();    // Install 'quit' event handler    // This &quot;handler&quot; is called when a user selects Application-&gt;Quit on OS X.  if ((Gestalt(gestaltAppleEventsAttr, &amp;response) == noErr)) {        anErr = AEInstallEventHandler(kCoreEventClass, kAEQuitApplication,               NewAEEventHandlerUPP(AEQuitHandler), 0, false);        if (anErr != noErr)            ExitToShell();  }}void doNewSnapshot(){  WindowPtr    newWindow = nil;  PixMapHandle  pixHandle = nil;  // Snapshots consist of a window and a PixMap, could have chosen  // to use only pictures instead, but the existing code dealt with  // PixMaps, so I kept the existing &quot;concept&quot;    pixHandle = createScreenPixMap();  newWindow = createWindow();  // Window's refCon is its handle to a PixMap  SetWRefCon(newWindow, (long)pixHandle);  drawImage( newWindow );  ShowWindow( newWindow );}WindowPtr createWindow(){  Rect   wBounds;  BitMap  bitMap;  int    top, left, width, height;  WindowPtr newWindow;    // Centering the window is a good thing....  GetQDGlobalsScreenBits(&amp;bitMap);  width = ((bitMap.bounds.right - bitMap.bounds.left) / gScale);  height = ((bitMap.bounds.bottom - bitMap.bounds.top) / gScale);  left = (((bitMap.bounds.right - bitMap.bounds.left) - width) / 2);  top = (((bitMap.bounds.bottom - bitMap.bounds.top) - height) / 2);    // if scale is same size or bigger than the screen  if (gScale &lt;= FULL_SIZE)    top = left = GetMBarHeight() * 3; //arbitrary position....    // Create a window to display the final offscreen image.   SetRect( &amp;wBounds, left, top, left + width, top + height );    newWindow = NewCWindow( 0L, &amp;wBounds, &quot;\pSuper Snapshot!&quot;, false, kWindowFullZoomGrowDocumentProc,              (WindowPtr)-1L, true, 0L );  // The refcon of the windows are going to be used to store the PixMapHandle  // from a screen capture.  0 means no associated PixMapHandle while non-zero  // means the value is a handle to a PixMap. A windows refcon should always be  // a value in this program  SetWRefCon(newWindow, 0L);  return newWindow;}void disposeWindow(WindowPtr dieWindow){  PixMapHandle pixHandle;    if (dieWindow == NULL || !IsValidWindowPtr(dieWindow))    return;    // Free up the baseAddr pointer field, the PixMap itself,  // and the window  pixHandle = (PixMapHandle)GetWRefCon(dieWindow);  if (pixHandle != nil) {    LockPixels(pixHandle);    DisposePtr((*pixHandle)-&gt;baseAddr);    DisposeCTable((*pixHandle)-&gt;pmTable);    // set the color table to nil since this was a &quot;custom&quot;    // pixmap, otherwise DisposePixMap will not deallocate the memory    (*pixHandle)-&gt;pmTable = nil;    UnlockPixels(pixHandle);    DisposePixMap(pixHandle);  }  DisposeWindow(dieWindow);}void calculateSystemBounds(){  BitMap  bitMap;    // Get the resolution of the screen, save it in a global Rectangle and   // use the info to calculate the min/max window size  GetQDGlobalsScreenBits(&amp;bitMap);  SetRect( &amp;gBounds, 0, 0, bitMap.bounds.right, bitMap.bounds.bottom);  SetRect(&amp;gMinWindowSize, bitMap.bounds.right / 4, bitMap.bounds.bottom / 4, bitMap.bounds.right, bitMap.bounds.bottom);}PixMapHandle createScreenPixMap(){  GDHandle  mainDevice;  CTabHandle  cTable;  short    depth;    Ptr      offBaseAddr;  /* Pointer to the off-screen pixel image */  short    bytesPerRow;  PixMapHandle  pixHandle = nil;    pixHandle = NewPixMap();    /* Get a handle to the main device. */  mainDevice = GetMainDevice();  /* Store its current pixel depth. */  depth = (**(**mainDevice).gdPMap).pixelSize;  /* Make an identical copy of its pixmap's colortable. */  cTable = (**(**mainDevice).gdPMap).pmTable;  (void) HandToHand( (Handle*)&amp;cTable );    // Get Resolution of screen  calculateSystemBounds();    // Fill in a few of the PixMap's fields...  // NewPixMap() is good for default initialization, simply modify  // the new PixMap  (*pixHandle)-&gt;pmTable = cTable;  (*pixHandle)-&gt;bounds = gBounds;  (*pixHandle)-&gt;pixelSize = depth;  bytesPerRow = ((gBounds.right - gBounds.left) * depth) / 8;  offBaseAddr = NewPtr((unsigned long) bytesPerRow * (gBounds.bottom - gBounds.top));  (*pixHandle)-&gt;baseAddr = offBaseAddr;        // Point to image  (*pixHandle)-&gt;rowBytes = bytesPerRow | 0x8000;  // MSB set for PixMap    LockPixels(pixHandle);  CopyBits( (BitMap *)*(**mainDevice).gdPMap, (BitMap *) *pixHandle,        &amp;(**(**mainDevice).gdPMap).bounds, &amp;(*pixHandle)-&gt;bounds, srcCopy, 0l );    UnlockPixels(pixHandle);    return pixHandle;}void drawImage(WindowPtr theWindow){  Rect tempRect1;  PixMapHandle  pixHandle = (PixMapHandle) GetWRefCon(theWindow);  GrafPtr      oldPort;    GetPort(&amp;oldPort);  SetPortWindowPort(theWindow);  if (theWindow == NULL || !IsValidWindowPtr(theWindow))    return;  if (pixHandle == NULL)    return;  else    LockPixels(pixHandle);  // Copy the offscreen image back onto the window.  CopyBits( (BitMap *) *pixHandle,    GetPortBitMapForCopyBits(GetWindowPort(theWindow)),    &amp;(*pixHandle)-&gt;bounds,    GetPortBounds(GetWindowPort(theWindow),&amp;tempRect1),    srcCopy, 0L);  UnlockPixels(pixHandle);  SetPort(oldPort);}void saveToPICTFile(WindowPtr theWindow){  PicHandle      picHandle;  OSErr        anErr = noErr;    NavReplyRecord      reply;    NavDialogOptions    dialogOptions;    FSSpec          documentFSSpec;    OSType              fileTypeToSave = 'PICT';    OSType              creatorType = 'ogle';    // PictureViewer    AEKeyword       theKeyword;    DescType        actualType;  Size            actualSize;  Rect        tempRect1;  PixMapHandle    pixHandle;    // This is a very basic NavServices file-saving example  // added logic for this program specifically    if (theWindow == NULL || !IsValidWindowPtr(theWindow))    return;    pixHandle = (PixMapHandle) GetWRefCon(theWindow);  LockPixels(pixHandle);    SetPortWindowPort(theWindow);    GetPortBounds(GetWindowPort(theWindow), &amp;tempRect1);  picHandle = OpenPicture(&amp;tempRect1);    CopyBits((BitMap*) *pixHandle, GetPortBitMapForCopyBits(GetWindowPort(theWindow)), &amp;(*pixHandle)-&gt;bounds,    &amp;tempRect1, srcCopy, 0L);     ClosePicture();    anErr = NavGetDefaultDialogOptions(&amp;dialogOptions);     dialogOptions.dialogOptionFlags |= kNavSelectDefaultLocation;        // Set default name for a saved snapshot    PLstrcpy(dialogOptions.savedFileName, defaultName);        anErr = NavPutFile( nil,               &amp;reply,               &amp;dialogOptions,               nil,                        fileTypeToSave,                         creatorType,                         nil );  if (anErr == noErr &amp;&amp; reply.validRecord) {    anErr = AEGetNthPtr(&amp;(reply.selection), 1, typeFSS,                                &amp;theKeyword, &amp;actualType,                                &amp;documentFSSpec, sizeof(documentFSSpec),                                &amp;actualSize );      if (anErr == noErr) {          writePictToFile(&amp;documentFSSpec, picHandle);        }        reply.translationNeeded = false;       anErr = NavCompleteSave(&amp;reply, kNavTranslateInPlace);           NavDisposeReply(&amp;reply);    }  KillPicture(picHandle);  UnlockPixels(pixHandle);}void writePictToFile(FSSpec *fspec, PicHandle picHandle){  OSErr         anErr = noErr;  long        inOutCount;    short        refNum;    OSType              fileTypeToSave = 'PICT';    OSType              creatorType = 'ogle';    // PictureViewer    int          count;    unsigned char     header[512];    // Pict files have to have 512 bytes of &quot;zero&quot; data at the front.  for (count = 0; count &lt; 512; count++)    header[count] = 0x00;  anErr = FSpCreate(fspec, creatorType, fileTypeToSave, smSystemScript);  if (anErr == dupFNErr) {    anErr = FSpDelete(fspec);  //delete file if already exists    anErr = FSpCreate(fspec, creatorType, fileTypeToSave, smSystemScript);  }          // write the file    FSpOpenDF(fspec, fsRdWrPerm, &amp;refNum );    inOutCount = 512;     anErr = FSWrite(refNum, &amp;inOutCount, header);    // write the header    if (anErr == noErr) {      inOutCount = GetHandleSize((Handle)picHandle);    anErr = FSWrite(refNum,&amp;inOutCount,*picHandle);     }    FSClose( refNum );}void doTrickEventLoop(){  EventRecord  anEvent;  WindowPtr  evtWind = NULL;    // Event loop while doing the &quot;full screen&quot; trick    while (!gDone) {    if (WaitNextEvent( everyEvent, &amp;anEvent, 2, nil )) {      if (anEvent.what == updateEvt) {        evtWind = (WindowPtr)anEvent.message;          SetPortWindowPort(evtWind);                  BeginUpdate(evtWind);        drawImage(evtWind);        EndUpdate(evtWind);      }      else if (anEvent.what == autoKey || anEvent.what == keyDown)        handleKeyPress(&amp;anEvent);      else if (anEvent.what == kHighLevelEvent)        AEProcessAppleEvent(&amp;anEvent);      }  }  gDone = false;}void doConfusion(){  GDHandle    mainDevice;  PicHandle    picHandle;  FSSpec      fspec;  PixMapHandle  pixHandle;  WindowPtr    theWindow;  float      oldScale = gScale;  OSErr      anErr = noErr;  AEDesc      desc;  Ptr        oldState = NULL;  WindowPtr    bigWindow;  RgnHandle    rgnHandle = NewRgn();  Rect      tempRect1;  gScale = 1;    mainDevice = GetMainDevice();    pixHandle = createScreenPixMap();  LockPixels(pixHandle);    if (!onOSX()) {    // used a window for debugging purposes    theWindow = createWindow();    SetPortWindowPort(theWindow);    SetWRefCon(theWindow, (long) pixHandle);    picHandle = OpenPicture(&amp;gBounds);    drawImage(theWindow);    ClosePicture();    //ShowWindow(theWindow);      // write pict to file    FSMakeFSSpec(0, 0, fileName, &amp;fspec);    writePictToFile(&amp;fspec, picHandle);      // set desktop pict :-)    anErr = OHMakeAliasDescFromFSSpec(&amp;fspec, &amp;desc);    if (anErr == noErr) {      SetDesktopPict(&amp;desc, 1);      AEDisposeDesc(&amp;desc);    }    KillPicture(picHandle);    DisposeWindow(theWindow);    gDone = true;  }  else {    // since OS X does not use the Appearance manager for the desktop background    // we will drop into full screen mode instead    gDoingTrick = true;    BeginFullScreen(&amp;oldState, nil, 0, 0, &amp;bigWindow, 0, fullScreenAllowEvents);    SetWRefCon(bigWindow, (long)pixHandle);    SetPortWindowPort(bigWindow);    CopyBits( (BitMap *) *pixHandle,      GetPortBitMapForCopyBits(GetWindowPort(bigWindow)),      &amp;(*pixHandle)-&gt;bounds,      GetPortBounds(GetWindowPort(bigWindow),&amp;tempRect1),      srcCopy, 0L);    QDFlushPortBuffer(GetWindowPort(bigWindow), GetPortVisibleRegion(GetWindowPort(bigWindow), rgnHandle));    doTrickEventLoop();    EndFullScreen(oldState, nil);    gDoingTrick = false;  }    // clean up  DisposePtr((*pixHandle)-&gt;baseAddr);  DisposeCTable((*pixHandle)-&gt;pmTable);  UnlockPixels(pixHandle);  DisposePixMap(pixHandle);  DisposeRgn(rgnHandle);  gScale = oldScale;}void adjustMenus(){  // Function simply recalculates menus based on app state  // Apps should do better menu handling, this is quick and dirty :-)    MenuHandle menuHandle = GetMenuHandle(SIZE_MENU);  int  counter;  for (counter = 1; counter &lt;= NUMBER_OF_SIZES; counter++)    CheckMenuItem(menuHandle, counter, false);    if (gScale == QUARTER_SIZE)    CheckMenuItem(menuHandle, SIZE_QUARTER_SCALE, true);  else if (gScale == HALF_SIZE)    CheckMenuItem(menuHandle, SIZE_HALF_SCALE, true);  else if (gScale == FULL_SIZE)    CheckMenuItem(menuHandle, SIZE_FULL_SCALE, true);  menuHandle = GetMenuHandle(onOSX() ? FILE_MENUX : FILE_MENU);    for (counter = 2; counter &lt;= NUMBER_OF_FILE_MENU_ITEMS; counter++)    FrontWindow() != NULL ? EnableMenuItem(menuHandle, counter) : DisableMenuItem(menuHandle, counter);}void resizeWindow(WindowPtr theWindow){  PixMapHandle pixHandle;  Rect  originalLoc, newLoc;  Boolean  wasCollapsed;  RgnHandle  rgnHandle = NewRgn();    // Resize the window....  if (theWindow == NULL || !IsValidWindowPtr(theWindow))    return;    wasCollapsed = IsWindowCollapsed(theWindow);    if (wasCollapsed) {    HideWindow(theWindow);    CollapseWindow(theWindow, false);  }    pixHandle = (PixMapHandle)GetWRefCon(theWindow);  GetWindowBounds(theWindow, kWindowContentRgn, &amp;originalLoc);    SetRect(   &amp;newLoc,         originalLoc.left, originalLoc.top,         gBounds.right / gScale + originalLoc.left,        gBounds.bottom / gScale + originalLoc.top);  SetWindowBounds(theWindow, kWindowContentRgn, &amp;newLoc);  drawImage(theWindow);  QDFlushPortBuffer(  GetWindowPort(theWindow),             GetPortVisibleRegion(GetWindowPort(theWindow), rgnHandle));    if (wasCollapsed) {    CollapseWindow(theWindow, wasCollapsed);    ShowWindow(theWindow);  }  DisposeRgn(rgnHandle);}void handleMenuSelection(long result){  int menuID, menuItem;  RgnHandle rgnHandle = NewRgn();  DialogPtr  theDialog = NULL;  short itemHit;  PixMapHandle  pixHandle;    menuID = HiWord(result);  menuItem = LoWord(result);  HiliteMenu(0);    // File Menu  if (menuID == FILE_MENU || menuID == FILE_MENUX) {    if (menuItem == FILE_SAVE)      saveToPICTFile(FrontWindow());    else if (menuItem == FILE_QUIT)      gDone = true;    else if (menuItem == FILE_CLOSE) {      if (gDoingTrick)        gDone = true;      else if (FrontWindow() != NULL)        disposeWindow(FrontWindow());    }    else if (menuItem == FILE_NEW) {      doNewSnapshot();    }    else if (menuItem == FILE_REFRESH) {      if (FrontWindow() == NULL) {        HiliteMenu(0);        return;      }      pixHandle = (PixMapHandle)GetWRefCon(FrontWindow());      DisposePtr((**pixHandle).baseAddr);      DisposePixMap(pixHandle);      pixHandle = createScreenPixMap();      SetWRefCon(FrontWindow(), (long)pixHandle);      drawImage(FrontWindow());      QDFlushPortBuffer(GetWindowPort(FrontWindow()), GetPortVisibleRegion(GetWindowPort(FrontWindow()), rgnHandle));    }  }  else if (menuID == ABOUT_MENU) {  //about menu handling    if (menuItem == ABOUT) {      theDialog = GetNewDialog ( ABOUTDLG, nil, (WindowPtr)-1 );          do {            ModalDialog ( nil, &amp;itemHit );          } while( itemHit != ok ) ;          DisposeDialog ( theDialog );    }  }  else if (menuID == SIZE_MENU) {    //size menu    switch (menuItem) {      case SIZE_QUARTER_SCALE:        gScale = QUARTER_SIZE;        break;      case SIZE_HALF_SCALE:        gScale = HALF_SIZE;        break;      case SIZE_FULL_SCALE:        gScale = FULL_SIZE;        break;    }    resizeWindow(FrontWindow());  }  else if (menuID == SPECIAL_MENU || menuID == SPECIAL_MENUX) { // &quot;special&quot; because depends on OS 9 or X    switch (menuItem) {      case SPECIAL_CONFUSING:        doConfusion();      break;    }  }  adjustMenus();  DisposeRgn(rgnHandle);}void handleKeyPress(EventRecord *event){  char  key;  key = event-&gt;message &amp; charCodeMask;    // just check to see if the command key is down, if so  // process it as menu selection  if ( event-&gt;modifiers &amp; cmdKey )    handleMenuSelection(MenuKey(key));}// Apple Event - &quot;Quit&quot; Handlerpascal OSErr AEQuitHandler(const AppleEvent *messagein, AppleEvent *reply, long refIn){  #pragma unused (messagein,refIn,reply)    // Do not call ExitToShell() in an AE Handler....    gDone = true;    return noErr;}void doDynamicResizing(WindowPtr theWindow){  Point  currentLoc;  Rect  windowBounds;  long  time;  int offsetX, offsetY;  int  windowWidth, windowHeight;  RgnHandle  rgnHandle = NewRgn();  EventRecord  anEvent;    // I could not find any code that would handle dynamic resizing using the &quot;classic&quot;  // or traditional event model....so I wrote my own implementation  GetWindowBounds(theWindow, kWindowStructureRgn, &amp;windowBounds);  GetMouse(&amp;currentLoc);  LocalToGlobal(&amp;currentLoc);    // calculate where mouse is in relation to edge of the window  offsetX = windowBounds.right - currentLoc.h;  offsetY = windowBounds.bottom - currentLoc.v;  time = TickCount();  while (Button()) {    GetMouse(&amp;currentLoc);    LocalToGlobal(&amp;currentLoc);    GetWindowBounds(theWindow, kWindowStructureRgn, &amp;windowBounds);    windowBounds.bottom = currentLoc.v + offsetX;    windowBounds.right = currentLoc.h + offsetY;    windowWidth = windowBounds.right - windowBounds.left;    windowHeight = windowBounds.bottom - windowBounds.top;        // Error check the window rectangle    if (windowWidth &lt; gMinWindowSize.left)      windowBounds.right = windowBounds.left + gMinWindowSize.left;    if (windowHeight &lt; gMinWindowSize.top)      windowBounds.bottom = windowBounds.top + gMinWindowSize.top;    SetWindowBounds(theWindow, kWindowStructureRgn, &amp;windowBounds);    // Draws every &quot;resizingDelay&quot; miliseconds, can easily change the interval    // I've set the interval to 0 for instantaneous drawing, but different apps may want to    // change the delay (maybe the drawing is quite complex....) or change it during execution    if (TickCount() - time &gt;= resizingDelay) {      drawImage(theWindow);      QDFlushPortBuffer(GetWindowPort(theWindow), GetPortVisibleRegion(GetWindowPort(theWindow), rgnHandle));      time = TickCount();    }    WaitNextEvent( everyEvent, &amp;anEvent, 0, nil );    processEvent(&amp;anEvent);    // User may have decided to quit or close the window    if (gDone || !IsValidWindowPtr(theWindow))      break;  }  DisposeRgn(rgnHandle);  // Update the window when all is done  PostEvent(updateEvt, (long)theWindow);}void processEvent(EventRecord *anEvent){  WindowPtr     evtWind;  short         clickArea;  Rect          screenRect;  RgnHandle    rgnHandle = NewRgn();  // Pretty standard event processing, save the couple checks for the  // &quot;trick&quot; flag being set  if (anEvent-&gt;what == mouseDown)  {    clickArea = FindWindow( anEvent-&gt;where, &amp;evtWind );            if (clickArea == inMenuBar)      handleMenuSelection(MenuSelect(anEvent-&gt;where));    else if (clickArea == inDrag)    {      GetRegionBounds(GetGrayRgn(), &amp;screenRect);      DragWindow( evtWind, anEvent-&gt;where, &amp;screenRect );    }    else if (clickArea == inContent)    {      if (evtWind != FrontWindow())        SelectWindow( evtWind );    }    else if (clickArea == inGoAway) {      if (TrackGoAway( evtWind , anEvent-&gt;where )) {        disposeWindow(evtWind);        adjustMenus();      }    }    else if (clickArea == inGrow) {      doDynamicResizing(evtWind);    }    else if (clickArea == inZoomIn || clickArea == inZoomOut) {      if (TrackBox (evtWind, anEvent-&gt;where, clickArea == inZoomOut ? inZoomOut : inZoomIn)) {        ZoomWindow (evtWind, clickArea == inZoomOut ? inZoomOut : inZoomIn, true);        drawImage(evtWind);        QDFlushPortBuffer(GetWindowPort(evtWind), GetPortVisibleRegion(GetWindowPort(evtWind), rgnHandle));      }    }  }  else if (anEvent-&gt;what == updateEvt)  {    evtWind = (WindowPtr)anEvent-&gt;message;      SetPortWindowPort(evtWind);            BeginUpdate(evtWind);    drawImage(evtWind);    EndUpdate(evtWind);  }  else if (anEvent-&gt;what == autoKey || anEvent-&gt;what == keyDown)    handleKeyPress(anEvent);  else if (anEvent-&gt;what == kHighLevelEvent)    AEProcessAppleEvent(anEvent);    DisposeRgn(rgnHandle);}void doEventLoop(){  EventRecord   anEvent;    while (!gDone)    if (WaitNextEvent( everyEvent, &amp;anEvent, 10, nil))      processEvent(&amp;anEvent);}</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/SuperSnapshot/listing2.html%3Fid%3DDTS10000171-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/SuperSnapshot/listing2.html%3Fid%3DDTS10000171-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/SuperSnapshot/listing2.html%3Fid%3DDTS10000171-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>