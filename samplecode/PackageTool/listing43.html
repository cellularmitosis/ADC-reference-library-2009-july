<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>PackageTool - /Sample Package/HTMLSample sources/HTMLSample.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxMacOS9Earlier-date.html">Mac OS 9 & Earlier</a> &gt; <A HREF="javascript:location.replace('index.html');">PackageTool</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/index.html" target="_blank">Reference Library</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">PackageTool</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/Sample Package/HTMLSample sources/HTMLSample.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/PackageTool.c</option>
<option value="listing2.html">/PackageTool.h</option>
<option value="listing3.html">/PackageTool.r</option>
<option value="listing4.html">/PackageUtils.c</option>
<option value="listing5.html">/PackageUtils.h</option>
<option value="listing6.html">/PackageWindow.c</option>
<option value="listing7.html">/PackageWindow.h</option>
<option value="listing8.html">/Sample Package/HTMLSample/HTMLSample Help/buttons.html</option>
<option value="listing9.html">/Sample Package/HTMLSample/HTMLSample Help/index.html</option>
<option value="listing10.html">/Sample Package/HTMLSample/HTMLSample Pages/docs/display.html</option>
<option value="listing11.html">/Sample Package/HTMLSample/HTMLSample Pages/docs/drawing.html</option>
<option value="listing12.html">/Sample Package/HTMLSample/HTMLSample Pages/docs/generalroutines.html</option>
<option value="listing13.html">/Sample Package/HTMLSample/HTMLSample Pages/docs/index.html</option>
<option value="listing14.html">/Sample Package/HTMLSample/HTMLSample Pages/docs/intro.html</option>
<option value="listing15.html">/Sample Package/HTMLSample/HTMLSample Pages/docs/types.html</option>
<option value="listing16.html">/Sample Package/HTMLSample/HTMLSample Pages/docs/userdefined.html</option>
<option value="listing17.html">/Sample Package/HTMLSample/HTMLSample Pages/docs/utilities.html</option>
<option value="listing18.html">/Sample Package/HTMLSample/HTMLSample Pages/error.html</option>
<option value="listing19.html">/Sample Package/HTMLSample/HTMLSample Pages/index.html</option>
<option value="listing20.html">/Sample Package/HTMLSample Package Guide/index.html</option>
<option value="listing21.html">/Sample Package/HTMLSample Package Guide/tn1188/tn1188.html</option>
<option value="listing22.html">/Sample Package/HTMLSample sources/AboutBox.c</option>
<option value="listing23.html">/Sample Package/HTMLSample sources/AboutBox.h</option>
<option value="listing24.html">/Sample Package/HTMLSample sources/CIconButtons.c</option>
<option value="listing25.html">/Sample Package/HTMLSample sources/CIconButtons.h</option>
<option value="listing26.html">/Sample Package/HTMLSample sources/CWDefines.h</option>
<option value="listing27.html">/Sample Package/HTMLSample sources/debugf.c</option>
<option value="listing28.html">/Sample Package/HTMLSample sources/debugf.h</option>
<option value="listing29.html">/Sample Package/HTMLSample sources/History.c</option>
<option value="listing30.html">/Sample Package/HTMLSample sources/History.h</option>
<option value="listing31.html">/Sample Package/HTMLSample sources/HTMLSample Help/buttons.html</option>
<option value="listing32.html">/Sample Package/HTMLSample sources/HTMLSample Help/index.html</option>
<option value="listing33.html">/Sample Package/HTMLSample sources/HTMLSample Pages/docs/display.html</option>
<option value="listing34.html">/Sample Package/HTMLSample sources/HTMLSample Pages/docs/drawing.html</option>
<option value="listing35.html">/Sample Package/HTMLSample sources/HTMLSample Pages/docs/generalroutines.html</option>
<option value="listing36.html">/Sample Package/HTMLSample sources/HTMLSample Pages/docs/index.html</option>
<option value="listing37.html">/Sample Package/HTMLSample sources/HTMLSample Pages/docs/intro.html</option>
<option value="listing38.html">/Sample Package/HTMLSample sources/HTMLSample Pages/docs/types.html</option>
<option value="listing39.html">/Sample Package/HTMLSample sources/HTMLSample Pages/docs/userdefined.html</option>
<option value="listing40.html">/Sample Package/HTMLSample sources/HTMLSample Pages/docs/utilities.html</option>
<option value="listing41.html">/Sample Package/HTMLSample sources/HTMLSample Pages/error.html</option>
<option value="listing42.html">/Sample Package/HTMLSample sources/HTMLSample Pages/index.html</option>
<option value="listing43.html">/Sample Package/HTMLSample sources/HTMLSample.c</option>
<option value="listing44.html">/Sample Package/HTMLSample sources/HTMLSample.h</option>
<option value="listing45.html">/Sample Package/HTMLSample sources/HTMLSample.r</option>
<option value="listing46.html">/Sample Package/HTMLSample sources/RenderingWindow.c</option>
<option value="listing47.html">/Sample Package/HTMLSample sources/RenderingWindow.h</option>
<option value="listing48.html">/Sample Package/HTMLSample sources/SampleUtils.c</option>
<option value="listing49.html">/Sample Package/HTMLSample sources/SampleUtils.h</option>
<option value="listing50.html">/SimplePrefs.c</option>
<option value="listing51.html">/SimplePrefs.h</option>
<option value="listing52.html">/Utilities.c</option>
<option value="listing53.html">/Utilities.h</option></select>
				</p>
				</form>
				<p><strong><a href="PackageTool.zip">Download Sample</a></strong> (&#147;PackageTool.zip&#148;, 631.7K)<BR>
<strong><a href="PackageTool.dmg">Download Sample</a></strong> (&#147;PackageTool.dmg&#148;, 919.8K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*  file HTMLSample.c    Description:  This file contains the main application program for the HTMLSample.  Routines in this file are responsible for handling events directed  at the application.    HTMLSample is an application illustrating how to use the new  HTMLRenderingLib services found in Mac OS 9. HTMLRenderingLib  is Apple's light-weight HTML rendering engine capable of  displaying HTML files.  by John Montbriand, 1999.  Copyright: &copy; 1999 by Apple Computer, Inc.  all rights reserved.    Disclaimer:  You may incorporate this sample code into your applications without  restriction, though the sample code has been provided &quot;AS IS&quot; and the  responsibility for its operation is 100% yours.  However, what you are  not permitted to do is to redistribute the source as &quot;DSC Sample Code&quot;  after having made changes. If you're going to re-distribute the source,  we require that you make it clear in the source that the code was  descended from Apple Sample Code, but that you've made changes.    Change History (most recent first):  10/16/99 created by John Montbriand*/#include &quot;HTMLSample.h&quot;#include &quot;debugf.h&quot;#include &lt;Menus.h&gt;#include &lt;Windows.h&gt;#include &lt;Dialogs.h&gt;#include &lt;Events.h&gt;#include &lt;Fonts.h&gt;#include &lt;SegLoad.h&gt;#include &lt;Resources.h&gt;#include &lt;Balloons.h&gt;#include &lt;Devices.h&gt;#include &lt;AppleEvents.h&gt;#include &lt;StdIO.h&gt;#include &lt;StdArg.h&gt;#include &lt;string.h&gt;#include &lt;ToolUtils.h&gt;#include &lt;Appearance.h&gt;#include &lt;Navigation.h&gt;#include &lt;Sound.h&gt;#include &lt;HTMLRendering.h&gt;#include &quot;RenderingWindow.h&quot;#include &quot;SampleUtils.h&quot;#include &quot;AboutBox.h&quot;  /* true while the app is running */Boolean gRunning = true;/* OpenOneFile is called for each file the application is asked to open  either by way of Apple event or from the file menu.  spec points to  a file specification record referring to the file to open.  The file will  be opened in a new window. */static OSErr OpenOneFile(FSSpec *spec) {  Handle urlHandle, errorPageLink;  WindowPtr rWindow;  Str255 errStr;  OSErr err;    /* initial state */  urlHandle = NULL;  rWindow = NULL;    /* allocate locals */  urlHandle = NewHandle(0);  if (urlHandle == NULL) { err = memFullErr; goto bail; }  errorPageLink = GetResource(kCStyleStringResourceType, kErrorPageURLString);  if (errorPageLink == NULL)  { err = resNotFound; goto bail; }    /* convert the fsspec to a url */  err = HRUtilGetURLFromFSSpec(spec, urlHandle);  if (err != noErr) goto bail;    /* open the window */  err = RWOpen(&amp;rWindow);  if (err != noErr) goto bail;    /* attempt to open the url */  MoveHHi(urlHandle);  HLock(urlHandle);  err = RWGotoURL(rWindow, *urlHandle, true);  HUnlock(urlHandle);    /* if that fails, try to show the error page */  if (err != noErr) {    MoveHHi(errorPageLink);    HLock(errorPageLink);    err = RWGotoAppRelLink(rWindow, *errorPageLink, true);    HUnlock(errorPageLink);    if (err != noErr) goto bail;  }    /* clean up and leave */  DisposeHandle(urlHandle);  return noErr;bail:    /* we display an alert here if there's an error. returning    an error from this routine will abort any open routine that    is going on--even if we're in the middle of a list of files. */  NumToString(err, errStr);  ParamAlert(kOpenFileErrorAlert, errStr, spec-&gt;name);  if (rWindow != NULL) RWCloseWindow(rWindow);  if (urlHandle != NULL) DisposeHandle(urlHandle);  return err;}/* IdentifyPackage identifies a Mac OS 9 package and returns a reference  to it's main file inside of mainPackageFile.  In Mac OS 9, packages are  the special folders that have their bundle bits set and contain an alias  at their topmost level referring to a file somewhere in the package. */static Boolean IdentifyPackage(FSSpec *target, FSSpec *mainPackageFile) {  CInfoPBRec cat;  OSErr err;  long pDir;  Str255 name;  FSSpec aliasFile;  Boolean targetIsFolder, wasAliased;    /* check the target's flags */  cat.dirInfo.ioNamePtr = target-&gt;name;  cat.dirInfo.ioVRefNum = target-&gt;vRefNum;  cat.dirInfo.ioFDirIndex = 0;  cat.dirInfo.ioDrDirID = target-&gt;parID;  err = PBGetCatInfoSync(&amp;cat);  if (err != noErr) return false;    /* if it's a folder and the bundle bit is set....*/  if (((cat.dirInfo.ioFlAttrib &amp; 16) != 0) &amp;&amp; ((cat.dirInfo.ioDrUsrWds.frFlags &amp; kHasBundle) != 0)) {      /* search for a top level alias file.  Here, we enumerate all of the      objects in the directory until we find a file with the alias flag set. */    pDir = cat.dirInfo.ioDrDirID;    cat.dirInfo.ioNamePtr = name;    cat.dirInfo.ioVRefNum = target-&gt;vRefNum;    cat.dirInfo.ioFDirIndex = 1;    cat.dirInfo.ioDrDirID = pDir;    while (PBGetCatInfoSync(&amp;cat) == noErr) {        /* if the thing we're looking at is not a directory and it's alias flag is set,        try to resolve it as an alias file. */      if (((cat.dirInfo.ioFlAttrib &amp; 16) == 0) &amp;&amp; ((cat.dirInfo.ioDrUsrWds.frFlags &amp; kIsAlias) != 0)) {        err = FSMakeFSSpec(target-&gt;vRefNum, pDir, name, &amp;aliasFile);        if (err != noErr) return false;        err = ResolveAliasFile(&amp;aliasFile, false, &amp;targetIsFolder, &amp;wasAliased);        if (err != noErr) return false;        if (mainPackageFile != NULL)          *mainPackageFile = aliasFile;        return true;      }        /* move on to the next file in the directory. */      cat.dirInfo.ioFDirIndex++;      cat.dirInfo.ioDrDirID = pDir;    }  }    /* we found nothing matching our criteria, so we    fail. */  return false;}/* OpenTheDocuments is called to open a list of documents provided by  either an open documents Apple event or one of the Navigation services  dialogs.  */static OSErr OpenTheDocuments(AEDescList *theDocuments) {  OSErr err;  long i, n;  FSSpec fileSpec, packageSpec;  AEKeyword keyWd;  DescType typeCd;  Size actSz;      /* open them */  err = AECountItems(theDocuments, &amp;n);  if (err != noErr) goto bail;    /* and then open each one */  for (i = 1 ; i &lt;= n; i++) {      /* get the i'th FSSpec record.  NOTE: implicity, we are calling      a coercion handler because this list actually contains alias records.       In particular, the coercion handler converts them from alias records      into FSSpec records. */    err = AEGetNthPtr(theDocuments, i, typeFSS, &amp;keyWd, &amp;typeCd,      (Ptr) &amp;fileSpec, sizeof(fileSpec), (actSz = sizeof(fileSpec), &amp;actSz));    if (err != noErr) goto bail;      /* if it's a package, we'll open it's main file, otherwise      we'll open the file itself */    if (IdentifyPackage(&amp;fileSpec, &amp;packageSpec))      err = OpenOneFile(&amp;packageSpec);    else err = OpenOneFile(&amp;fileSpec);    if (err != noErr) goto bail;  }  return noErr;bail:  return err;}/* MyNavFilterProc This is the filter function we provide for the Navigation services  dialogs.  We only allow files of type TEXT. */static pascal Boolean MyNavFilterProc( AEDesc* theItem, void* info, NavCallBackUserData callBackUD, NavFilterModes filterMode) {  NavFileOrFolderInfo* theInfo;  if ( theItem-&gt;descriptorType == typeFSS ) {    theInfo = (NavFileOrFolderInfo*) info;    if ( theInfo-&gt;isFolder ) return true;    if ( theInfo-&gt;fileAndFolder.fileInfo.finderInfo.fdType != 'TEXT' )      return false;  }  return true;}/* NavEventCallBack is the event handling call back we provide for Navigation  services.  It's presence is important so our windows will be updated appropriately  when the navigation window is resized or moved. */static pascal void NavEventCallBack( NavEventCallbackMessage callBackSelector,      NavCBRecPtr callBackParms, NavCallBackUserData callBackUD) {  if (callBackSelector == kNavCBEvent &amp;&amp; callBackParms-&gt;eventData.eventDataParms.event-&gt;what == updateEvt) {    HandleEvent(callBackParms-&gt;eventData.eventDataParms.event);  }}/* MyFileFilterProc is used by the older standard file calls.  We fall back to  standard file when navigation services is not present or unavailable.  In this  routine, we filter out all invisible files. */static pascal Boolean MyFileFilterProc(CInfoPBPtr pb) {    /* don't display invisible files */  return ((pb-&gt;hFileInfo.ioFlFndrInfo.fdFlags &amp; kIsInvisible) != 0);}/* SelectAndOpenFile is the inner workings of the Open... command  when it is chosen from the file menu.  Here, we use the navigation  services dialogs when they are available, but if they're not, then we  use the standard file ones. */static OSStatus SelectAndOpenFile(void) {  NavDialogOptions dialogOptions;  NavReplyRecord theReply;  NavEventUPP eventf;  NavObjectFilterUPP filterf;  FileFilterUPP stdFilterf;  Boolean hasreply;  OSStatus err;    /* set up locals */  eventf = NULL;  filterf = NULL;  stdFilterf = NULL;  hasreply = false;  BlockZero(&amp;theReply, 0);    /* if Navigation services is available, then we    use those calls. */  if (NavServicesAvailable()) {      /* allocate data */    filterf = NewNavObjectFilterUPP(MyNavFilterProc);    if (filterf == NULL) { err = memFullErr; goto bail; }    eventf = NewNavEventProc(NavEventCallBack);    if (eventf == NULL) { err = memFullErr; goto bail; }      /* set up dialog options */    err = NavGetDefaultDialogOptions(&amp;dialogOptions);    if (err != noErr) goto bail;      /* NOTE: by setting the kNavAllowMultipleFiles flag, we make it possible      for the user to select more than one file.  And, setting the kNavSupportPackages      flag allows us to open package documents. */    dialogOptions.dialogOptionFlags = (kNavDontAutoTranslate | kNavAllowMultipleFiles | kNavSupportPackages);    GetIndString(dialogOptions.message, kMainStringList, kNavMessageString);      /* pick one or more files */    err = NavChooseFile(NULL, &amp;theReply, &amp;dialogOptions, eventf,  NULL,  filterf,  NULL, NULL);    if (err != noErr) goto bail;    if (!theReply.validRecord) { err = userCanceledErr; goto bail; }    hasreply = true;      /* if we have a valid reply, then call our      open documents routine. */    err = OpenTheDocuments(&amp;theReply.selection);    if (err != noErr) goto bail;      /* clean up the structures we allocated */    NavDisposeReply(&amp;theReply);    DisposeNavEventUPP(eventf);    DisposeNavObjectFilterUPP(filterf);  }  return noErr;bail:  if (hasreply) NavDisposeReply(&amp;theReply);  if (eventf != NULL) DisposeNavEventUPP(eventf);  if (filterf != NULL) DisposeNavObjectFilterUPP(filterf);  return err;}/* ResetMenus is called immediately before all calls to  MenuSelect or MenuKey.  In this routine, we re-build  or enable the menus as appropriate depending on the  current environment */static void ResetMenus(void) {  WindowPtr target;  target = FrontWindow();    /* if the front most window is a rendering    window, then we let the window handle the    menu. */  if (IsARenderingWindow(target))    RWResetGotoMenu(target);  else {    MenuHandle goMenu;      /* otherwise, we clear the menu      and disable all of its commands. */    goMenu = GetMenuHandle(mGo);    DisableMenuItem(goMenu, iBack);    DisableMenuItem(goMenu, iForward);    DisableMenuItem(goMenu, iHome);    while (CountMenuItems(goMenu) &gt;= iGoSep)      DeleteMenuItem(goMenu, iGoSep);  }}/* DoMenuCommand is called in response to MenuKey  or MenuSelect.  Here, we dispatch the menu command  to its appropriate handler, or if it's a small action  we do it here. */static void DoMenuCommand(long rawMenuSelectResult) {  short menu, item;    /* decode the MenuSelect result */  menu = (rawMenuSelectResult &gt;&gt; 16);  if (menu == 0) return;  item = (rawMenuSelectResult &amp; 0x0000FFFF);    /* dispatch on result */  switch (menu) {      /* apple menu commands */    case mApple:      if (item == iAbout) {        WindowPtr aboutBox;        OSStatus err;          /* open the about box */        err = OpenAboutBox(&amp;aboutBox);        if (err != noErr) {          Str255 errStr;          NumToString(err, errStr);          ParamAlert(kNoAboutBoxErrorAlert, errStr, NULL);        }      }      break;              /* file menu commands */    case mFile:      if (item == iOpen) {        SelectAndOpenFile();      } else if (item == iQuit) {        if (CloseRenderingWindows() == noErr)          gRunning = false;      }      break;              /* selections in the Go menu are handled by        the frontmost rendering window. */    case mGo:      {  WindowPtr target;        target = FrontWindow();        if (IsARenderingWindow(target))          RWHandleGotoMenu(target, item);      }      break;  }    /* unhilite the menu bar */  HiliteMenu(0);}/* QuitAppleEventHandler is our quit Apple event handler.  this routine  is called when a quit Apple event is sent to our application.  Here,  we set the gRunning flag to false. NOTE:  it is not appropriate to  call ExitToShell here.  Instead, by setting the flag to false we  fall through the bottom of our main loop the next time we're called.   Here, if we are unable to close all of the rendering windows,  we return an error.  This will abort the shutdown process,  if that's why we were called.  */static pascal OSErr QuitAppleEventHandler(const AppleEvent *appleEvt, AppleEvent* reply, unsigned long refcon) {  if (CloseRenderingWindows() == noErr) {    gRunning = false;    return noErr;  } else return userCanceledErr;}/* OpenAppleEventHandler is called when our application receives  an 'open application' apple event.  Here, we put up a window  referring to the default page. */static pascal OSErr OpenAppleEventHandler(const AppleEvent *appleEvt, AppleEvent* reply, unsigned long refcon) {  WindowPtr rWin;  Handle urlHandle;  OSErr err;    /* creat a rendering window. */  err = RWOpen(&amp;rWin);  if (err != noErr) return err;    /* get the link to the default page from the resource    file. */  urlHandle = GetResource(kCStyleStringResourceType, kDefaultPageURLString);  if (urlHandle == NULL) return memFullErr;    /* lock down the resource and point the rendering    window at it. */  MoveHHi(urlHandle);  HLock(urlHandle);  RWGotoAppRelLink(rWin, *urlHandle, true);  HUnlock(urlHandle);    /* done */  return noErr;}/* ReOpenAppleEventHandler is called whenever the application receives  a re-open Apple event.  This will happen if the application is already  running and the user attempts to open it again by either double clicking  on its icon in the Finder or by selecting its icon and choosing Open in  the Finder's file menu. Here, if there is no window showing, then we  open a new one as we would if an open application event was received. */static pascal OSErr ReOpenAppleEventHandler(const AppleEvent *appleEvt, AppleEvent* reply, unsigned long refcon) {    if (FrontWindow() == NULL)    return OpenAppleEventHandler(appleEvt, reply, refcon);  else return noErr;    return noErr;}/* OpenDocumentsEventHandler is called whenever we receive an open documents  Apple event.  Here, we extract the list of documents from the event  and pass them along to our OpenTheDocuments routine. */static pascal OSErr OpenDocumentsEventHandler(const AppleEvent *appleEvt, AppleEvent* reply, unsigned long refcon) {  OSErr err;  AEDescList documents;      /* initial state */  AECreateDesc(typeNull, NULL, 0, &amp;documents);      /* get the open parameter */  err = AEGetParamDesc(appleEvt, keyDirectObject, typeAEList, &amp;documents);  if (err != noErr) goto bail;      /* open the documents */  err = OpenTheDocuments(&amp;documents);  if (err != noErr) goto bail;bail:  AEDisposeDesc(&amp;documents);  return err;}/* HandleMouseDown is called for mouse down events.  Processing of  mouse down events in the HTML rendering area of windows is   handled by the HTMLRenderinLib, but clicks in the controls and  other parts of the windows are handled here. */static void HandleMouseDown(EventRecord *ev) {  WindowPtr theWindow;  short partcode;  Rect r;  partcode = FindWindow(ev-&gt;where, &amp;theWindow);  switch (partcode) {      /* inside the window's content area */    case inContent:      if (theWindow != FrontWindow()) {          /* if it's not the frontmost window,          then make it the frontmost window. */        SelectWindow(theWindow);      } else {          /* otherwise, if it's a rendering window,          pass the click along to the window. */        Point where;        SetPortWindowPort(theWindow);        SetOrigin(0, 0);        where = ev-&gt;where;        GlobalToLocal(&amp;where);        if (IsARenderingWindow(theWindow))          RWHandleMouseDown(theWindow, where);      }      break;            /* menu bar clicks */    case inMenuBar:      ResetMenus();      DoMenuCommand(MenuSelect(ev-&gt;where));      break;            /* track clicks in the close box */    case inGoAway:      if (TrackGoAway(theWindow, ev-&gt;where)) {        if (IsARenderingWindow(theWindow))          RWCloseWindow(theWindow);        else if (IsAboutBox(theWindow))          AboutBoxCloseWindow(theWindow);      }      break;            /* allow window drags */    case inDrag:      {  Rect boundsRect = {0,0, 32000, 32000};        DragWindow(theWindow, ev-&gt;where, &amp;boundsRect);      }      break;            /* allow window drags */    case inGrow:      {  Rect sizerect;        long grow_result;        SetRect(&amp;sizerect, 300, 150, 32767, 32767);        grow_result = GrowWindow(theWindow, ev-&gt;where, &amp;sizerect);        if (grow_result != 0) {          SizeWindow(theWindow, LoWord(grow_result), HiWord(grow_result), true);          SetPortWindowPort(theWindow);          InvalWindowRect(theWindow, GetPortBounds(GetWindowPort(theWindow), &amp;r));          if (IsARenderingWindow(theWindow))            RWRecalculateSize(theWindow);        }      }      break;            /* zoom box clicks.  NOTE:  since the rendering window      always sets the standard rectangle to the 'best size' for      displaying the current HTML window, the inZoomOut partcode      will zoom the window to that size rather than the entire screen.*/    case inZoomIn:    case inZoomOut:      SetPortWindowPort(theWindow);      EraseRect(GetPortBounds(GetWindowPort(theWindow), &amp;r));      ZoomWindow(theWindow, partcode, true);      SetPortWindowPort(theWindow);      if (IsARenderingWindow(theWindow))        RWRecalculateSize(theWindow);      break;        }}/* HandleEvent is the main event handling routine for the  application.  ev points to an event record returned by  WaitNextEvent. */void HandleEvent(EventRecord *ev) {  WindowPtr target;    /* process menu key events */  if (((ev-&gt;what == keyDown) || (ev-&gt;what == autoKey)) &amp;&amp; ((ev-&gt;modifiers &amp; cmdKey) != 0)) {    ResetMenus();    DoMenuCommand(MenuKey((char) (ev-&gt;message &amp; charCodeMask)));    ev-&gt;what = nullEvent;  }      /* process HR events.  NOTE: this call handles most of the events    for the active HTML rendering object.  But, be careful it may set    the clip region and origin of that window to an unknown state. */  if (HRIsHREvent(ev))    ev-&gt;what = nullEvent;      /* process other event types */  switch (ev-&gt;what) {      /* the application may be switching in to the forground      or into the background.  Either way, we need to activate      the frontmost window accordingly. */    case osEvt:      target = FrontWindow();      if (IsARenderingWindow(target))        RWActivate(target, ((ev-&gt;message &amp; resumeFlag) != 0));      else if (IsAboutBox(target))        AboutBoxActivate(target, ((ev-&gt;message &amp; resumeFlag) != 0));      break;            /* for activate events we call the window's activate event      handler. */    case activateEvt:      target = (WindowPtr) ev-&gt;message;      if (IsARenderingWindow(target))        RWActivate(target, ((ev-&gt;modifiers&amp;1) != 0));      else if (IsAboutBox(target))        AboutBoxActivate(target, ((ev-&gt;modifiers&amp;1) != 0));      break;            /* for update events we call the window's update event      handler. if the window is of an unknown type, we ignore the      event. */    case updateEvt:      target = (WindowPtr) ev-&gt;message;      if (IsARenderingWindow(target))        RWUpdate(target);      else if (IsAboutBox(target))        AboutBoxUpdate(target);      else {        BeginUpdate(target);        EndUpdate(target);      }      break;              /* for mouse events we call the the HandleMouseDown routine      defined above. */    case mouseDown:      HandleMouseDown(ev);      break;          /* for key down events we call the window's key down event      handler. */    case keyDown:    case autoKey:      target = FrontWindow();      if (IsARenderingWindow(target))        RWKeyDown(target, (char) (ev-&gt;message &amp; charCodeMask));      break;          /* Apple events. */    case kHighLevelEvent:      AEProcessAppleEvent(ev);      break;  }}/* FDPIdleProcedure is the idle procedure called by AEInteractWithUser while we are waiting  for the application to be pulled into the forground.  It simply passes the event along  to HandleNextEvent */static pascal Boolean MyIdleInteractProc(EventRecord *theEvent, long *sleepTime, RgnHandle *mouseRgn) {  HandleEvent(theEvent);  return ( ! gRunning ); /* quit waiting if we're not running */}/* ParamAlert is a general alert handling routine.  If Apple events exist, then it  calls AEInteractWithUser to ensure the application is in the forground, and then  it displays an alert after passing the s1 and s2 parameters to ParamText. */short ParamAlert(short alertID, StringPtr s1, StringPtr s2) {  AEIdleUPP aeIdleProc;  OSStatus err;  aeIdleProc = NewAEIdleUPP(MyIdleInteractProc);  if (aeIdleProc == NULL) { err = memFullErr; goto bail; }  err = AEInteractWithUser(kNoTimeOut, NULL, aeIdleProc);  if (err != noErr) goto bail;  ParamText(s1, s2, NULL, NULL);  err = Alert(alertID, NULL);  DisposeAEIdleUPP(aeIdleProc);  return err;bail:  if (aeIdleProc != NULL) DisposeAEIdleUPP(aeIdleProc);  return err;}/* MyGrowZone is called by the Memory Manager whenever it  cannot fulfil a memory request.  Here, we try to get back  enough memory for the request by asking the HTML rendering  library to free up some cache space. */static pascal long MyGrowZone(Size cbNeeded) {  return HRFreeMemory(cbNeeded);}  /* the main program */int main(void) {  OSStatus err;  Str255 errStr;    InitCursor();        /* install our event handlers */  err = AEInstallEventHandler(kCoreEventClass, kAEOpenApplication, NewAEEventHandlerProc(OpenAppleEventHandler), 0, false);  if (err != noErr) goto bail;  err = AEInstallEventHandler(kCoreEventClass, 'rapp', NewAEEventHandlerProc(ReOpenAppleEventHandler), 0, false);  if (err != noErr) goto bail;  err = AEInstallEventHandler(kCoreEventClass, kAEOpenDocuments, NewAEEventHandlerProc(OpenDocumentsEventHandler), 0, false);  if (err != noErr) goto bail;  err = AEInstallEventHandler(kCoreEventClass, kAEQuitApplication, NewAEEventHandlerProc(QuitAppleEventHandler), 0, false);  if (err != noErr) goto bail;    /* set up the menu bar */  SetMenuBar(GetNewMBar(kMenuBarID));  DrawMenuBar();    /* set up the rendering library */  if ( ! HRHTMLRenderingLibAvailable() ) {    ParamAlert(kNoRenderingLibErrorAlert, NULL, NULL);    err = userCanceledErr;    goto bail;  }    /* install our memory manger grow zone    routine.  This will have to be done differently in    Mac OS X... */  SetGrowZone(NewGrowZoneUPP(MyGrowZone));    /* initialize the rendering windows library */  err = InitRenderingWindows();  if (err != noErr) goto bail;    /* run the app */  while (gRunning) {    EventRecord ev;          /* get the next event */    if ( ! WaitNextEvent(everyEvent, &amp;ev,  GetCaretTime(), NULL))      ev.what = nullEvent;            /* call our handler to deal with it. */    HandleEvent(&amp;ev);  }      /* close all of our windows. */  CloseRenderingWindows();  EnsureAboutBoxIsClosed();      /* unregister ourselves with the appearance manager. */  UnregisterAppearanceClient();  ExitToShell();  return 0;bail:  NumToString(err, errStr);  if (err != userCanceledErr)    ParamAlert(kOpenApplicationErrorAlert, errStr, NULL);  ExitToShell();  return 0;}</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/PackageTool/listing43.html%3Fid%3DDTS10000599-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/PackageTool/listing43.html%3Fid%3DDTS10000599-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/PackageTool/listing43.html%3Fid%3DDTS10000599-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>