<html>	<head>		<title>EODelayedObserverConcepts</title>	</head>	<BODY BGCOLOR="#FFFFFF">		<!-- start of header -->		<!--#include virtual="/includes/framesetheader" -->		<!-- end of header --><!-- start of path --><table cellspacing=0 border=0 width=600 valign="left"><tr><td scope="row"><font face="Geneva,Helvetica,Arial" size="1"><b>PATH<spacer type="horizontal" size="5">&nbsp;</b><a href="../../../../../index.html" target="_top">Documentation</a> <b>></b> <a href="../../../../webobjects.html" target="_top">WebObjects</a></font></td></tr></table><br><!-- end of path -->		<a href="../../EOControlTOC.html"><img src="../Art/up.gif" border="0" alt="Table of Contents"></a> <a name="EODelayedObserver"></a>		<h1><font color="#000066"><a name="//apple_ref/UNKNOWN_LANGUAGE/cl/EODelayedObserver.Concepts">EODelayedObserver.Concepts</a></font></h1>		<br>		<br>		<a name="CIJBIABH"></a>		<h2>Creating a Subclass of EODelayedObserver</h2>		<p>EODelayedObserver implements the basic objectWillChange method to simply enqueue the receiver on an EODelayedObserverQueue. Regardless of how many of these messages the receiver gets during the run loop, it receives a single subjectChanged message from the queue-at the end of the run loop. In this method the delayed observer can check for changes and take whatever action is necessary. Subclasses should record objects they're interested in and examine them in <b>subjectChanged</b>. An EOAssociation.(EOInterface) for example, examines each of the EODisplayGroups (EOInterface) it's bound to in order to find out what has changed. Another kind of subclass might record each changed object for later examination by overriding <b>objectWillChange</b>, but it must be sure to invoke <b>super</b>'s implementation when doing so.</p>		<p>The rest of EODelayedObserver's methods have meaningful, if static, default implementations. EODelayedObserverQueue sends change notifications according to the priority of each enqueued observer. EODelayedObserver's implementation of the priority method returns ObserverPriorityThird. Your subclass can override it to return a higher or lower priority, or to have a settable priority. The other method a subclass might override is observerQueue, which returns a default EODelayedObserverQueue normally shared by all EODelayedObservers. Because sharing a single queue keeps all EODelayedObserver's synchronized according to their priority, you should rarely override this method, doing so only if your subclass is involved in a completely independent system.</p>		<p>A final method, discardPendingNotification, need never be overridden by subclasses, but must be invoked when a delayed observer is done observing changes. This prevents observers from being sent change notifications after they've been finalized.</p>		<p>&copy; 2001 Apple Computer, Inc. (Last Published April 19, 2001)</p>		<br>		<a href="../../EOControlTOC.html"><img src="../Art/up.gif" border="0" alt="Table of Contents"></a> <!-- start of footer -->		<!--#include virtual="/includes/framesetfooter" -->		<!-- end of footer -->	</body></html>