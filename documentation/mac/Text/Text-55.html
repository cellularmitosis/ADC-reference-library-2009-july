<!-- Generated by Harlequin WebMaker 2.2.3 (23-Apr-1996)
LispWorks 3.2.2 -->
<HTML> <HEAD>
<TITLE>Customizing TextEdit(IM: Tx)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING55></A>



<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="Text-54.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Text-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Text-594.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="Text-56.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="Text-2.html"><B>Text</B></A> / <BR><DD><A HREF="Text-40.html"><B>Chapter 2 - TextEdit</B></A> / <A HREF="Text-49.html"><B>Using TextEdit</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING55-0></A>
<H2><A NAME=MARKER-9-293></A>Customizing TextEdit</H2>
 <A NAME=MARKER-2-328></A>This section describes how to customize TextEdit using the <CODE>TECustomHook</CODE> routine to replace the end-of-line, drawing, width-measuring, and hit test default hook routines.<P>
 It also describes the multi-purpose low-memory global variable <A NAME=MARKER-2-293></A><CODE>TEDoText</CODE> hook routine that displays, highlights, and hit-tests characters, and positions the pen to draw a caret. Finally, this section discusses how to customize word selection, automatic scrolling, and how to determine the length of a line of text in order to justify it. (For a brief discussion of hook fields and hook routines, see <A HREF=Text-48.html#MARKER-9-120>"Related Data Structures" on page 2-16</A>.)<P>
 The next four sections describe how to customize TextEdit using the <CODE><A NAME=MARKER-9-83></A>TECustomHook</CODE> procedure. Information about the use of <CODE>TECustomHook</CODE> that is common to all four sections is provided here.<P>
 You can <A NAME=MARKER-9-47></A>customize TextEdit's behavior by replacing any of the default hook <BR>routines with those of your own. You use the <A NAME=MARKER-2-203></A><CODE>TECustomHook</CODE> procedure to replace <BR>a routine installed in a hook field of the dispatch record (<CODE>TEDispatchRec</CODE>). Initially, each hook field of the dispatch record contains the address of the default hook routine that TextEdit uses.<P>
 The <CODE>TECustomHook</CODE> procedure returns the address of the default routine that it replaces so that your application-supplied routine can call the default routine, daisy-chaining it, if you want it to. For example, your routine can add additional functionality, then call the default routine instead of replicating all of its behavior. If you replace the address of a default hook routine with that of your own customized version, the next time you call <CODE>TECustomHook</CODE> for that hook field, <CODE>TECustomHook</CODE> will return the address of your routine. (For more information, see <A HREF=Text-122.html#MARKER-9-553>"TECustomHook" on page 2-105</A>.) To ensure future compatibility, use the TextEdit customization routines to modify hooks rather than write directly to these fields.<P>
 If you replace a default hook routine with a customized version that you write in a high-level language, such as Pascal or C, you need to provide assembly-language glue code that utilizes the registers for your high-level language routine. Refer to <A HREF=Text-122.html#MARKER-9-553>"TECustomHook" on page 2-105</A> for a description of the register contents on entry and return for each of the hook routines.<P>
 If you replace a default routine, take the following precautions:<P>
<UL>
<LI>Before placing the address of your routine in the TextEdit dispatch record, strip the addresses, using the Operating System Utilities <CODE>StripAddress</CODE> function, to guarantee that your application is 32-bit clean. For more information, see <I><A HREF="../OSUtilities/OSUtilities-2.html">Inside Macintosh: Operating System Utilities</A></I>.
<LI>Before replacing a TextEdit routine with a customized one, determine whether more than one script system is installed, and, if so, ensure that your customized routine accommodates all of the installed script systems. This avoids the problem of your customized routine producing results that are incompatible with the Script Manager.
<LI>When you use assembly language, note that all registers must be preserved except those specified as containing return values. Register A3 contains a pointer to the edit record and Register A4 contains a handle to it. You can obtain line start positions from the <CODE>lineStarts</CODE> array in the edit record. Register A5 is always valid. Refer to <CODE>TECustomHook</CODE> in the TextEdit Reference section for complete coverage of the register content requirements for all hook routines.<P>
</UL>
<A NAME=HEADING55-11></A>
<H3>Replacing the End-of-Line Routine<A NAME=MARKER-2-18></A></H3>
 You can replace the address of the default end-of-line hook routine with the address of your own routine that determines an end-of-line <A NAME=MARKER-2-106></A>character if you want the end-of-line to be defined by a character other than the carriage return.<P>
 The default routine compares a given character with $0D (a carriage return) to determine whether it is an end-of-line character, and returns with the appropriate status flags (either <CODE>TRUE</CODE> or <CODE>FALSE</CODE>) in the status register.<P>
<A NAME=HEADING55-14></A>
<H3>Replacing the Drawing Routine</H3>
 TextEdit calls the draw hook routine any time the <A NAME=MARKER-2-43></A>various components of a line are drawn. The appropriate font, face, and size characteristics have already been set into the current graphics port by the time this routine is called.<A NAME=MARKER-2-573></A><P>
 If your application uses an outline font, the default behavior of the Font Manager ensure's that glyphs fit within the font's ascent and descent. Glyphs that extend beyond the ascent or descent, such as certain accented fonts, are scaled down to fit<A NAME=MARKER-2-304></A>.<P>
 If your application has set the <CODE>preserveGlyph</CODE> parameter of the Font Manager's <CODE>SetPreserveGlyph</CODE> procedure to <CODE>TRUE</CODE> to preserve the original unscaled shape of the glyph, note that TextEdit sets it to <CODE>FALSE</CODE> before it calls the draw hook to perform any drawing. This is to guarantee that the glyphs whose bounding boxes exceed the font's ascent or descent are scaled down to prevent them from colliding with other glyphs on the lines above or below. TextEdit then restores the <CODE>preserveGlyph</CODE> parameter to its previous value before proceeding.<P>
<A NAME=HEADING55-18></A>
<H3><A NAME=MARKER-2-909></A>Replacing the Width-Measuring Routines</H3>
 A width measurement hook routine <A NAME=MARKER-2-234></A>measures portions<A NAME=MARKER-9-107></A> of a line of text, and TextEdit calls one each time the width of various components of a line is calculated. There are three width measurement hooks: the width measurement hook, the new width measurement hook, and the text width measurement hook. Default hook routines of the same name as the hook field are installed in each of these hooks.<P>
 The width measurement hook, which TextEdit used in the past, now exists to provide backward compatibility for applications that have replaced the default routine with a customized one. TextEdit uses the routine whose address is installed in this field only when both of the following conditions exist: when only the Roman script system is installed and the field contains the address of a customized routine.<P>
 In all other cases--when more than one script system is installed or when the width measurement hook has not been customized--TextEdit calls the routine whose address is installed in the new width measurement hook field to measure text.<P>
 <A HREF=#MARKER-9-308>Figure 2-14</A> shows a flow chart illustrating when the width measurement hook and the new width measurement hook routines are used.<P>
<B>Figure 2-14  <A NAME=MARKER-9-308></A>Determining when to use <CODE>WIDTHHook</CODE> and <CODE>nWIDTHHook</CODE></B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/TE_L-29.jpg">
 The new width measurement hook routine is called to measure text for both Roman and non-Roman script systems. If you replace this routine, make sure that your customized routine is script-aware.<P>
 The default action for the new width measurement hook routine is to call the QuickDraw Manager's <CODE><A NAME=MARKER-2-15></A>CharToPixel</CODE> function or <CODE>TextWidth</CODE> procedure to measure for non-Roman scripts. By default, the <CODE>TextWidthHook</CODE> field contains the address of the QuickDraw <CODE>TextWidth</CODE> function. You can use this hook to replace TextEdit's use of the <BR>QuickDraw <CODE>TextWidth</CODE> function with your own measuring routine. If you replace <BR>this hook routine with a customized version, when the routine whose address is installed in the new width measurement hook field makes a call to <CODE>TextWidth</CODE>, your customized routine is invoked.<A NAME=MARKER-9-751></A><P>
 To test for the availability of the width-measuring hooks, you can call the <CODE>Gestalt</CODE> function with the <CODE>gestaltTextEditVersion</CODE> selector. A result of <CODE>gestaltTE2</CODE> or greater returned in the <CODE>response</CODE> parameter indicates that the new width measurement hook is available, and a result of <CODE>gestaltTE5</CODE> or greater indicates that <CODE>TextWidthHook</CODE> is available<A NAME=MARKER-2-311></A>.<A NAME=MARKER-2-969></A><P>
<A NAME=HEADING55-28></A>
<H3><A NAME=MARKER-9-313></A><A NAME=MARKER-21-314></A><A NAME=MARKER-21-315></A>Replacing the Hit Test Routine</H3>
 TextEdit <A NAME=MARKER-9-84></A>calls the hit test hook routine to <A NAME=MARKER-9-237></A>determine the glyph position in a line, given the pixel width from the left edge of the view rectangle<A NAME=MARKER-2-109></A>. For versions of software earlier than 7.0, the default action is to call the <CODE>TextWidth</CODE> function to determine if the pixel width of the measured text is greater than the input width. If it is, then the hit test hook routine calls the QuickDraw <CODE>PixelToChar</CODE> function and returns. For system software version 7 and later, the default action is to call the QuickDraw <CODE>PixelToChar</CODE> function. In addition to the values defined by the register contents on entry, when TextEdit calls the <CODE>PixelToChar</CODE> function, it passes a value of <CODE>OnlyStyleRun</CODE> for the <CODE>styleRunPosition</CODE> parameter and scaling factors of 1/1 for the <CODE>numer</CODE> and <CODE>demon</CODE> parameters. See "Hit Test Hook Registers" on <A HREF=Text-122.html#MARKER-9-560>page 2-108</A>.<A NAME=MARKER-21-111></A> <A NAME=MARKER-2-817></A><P>
<A NAME=HEADING55-30></A>
<H3><A NAME=MARKER-2-383></A><A NAME=MARKER-9-322></A>Customizing Word Selection</H3>
 A word-selection break routine determines which word is highlighted when the user double-clicks in the text. It also determines where TextEdit breaks the text at the end of a line. You can use <CODE>TESetWordBreak</CODE> to replace the default routine, installed in the edit record's <CODE>wordBreak</CODE> field, that is used for word selection and <A NAME=MARKER-9-10></A>line breaking under certain circumstances. Whether or not TextEdit uses the word break hook routine installed in this field is determined by the algorithm implemented in the default <CODE>TEFindWord</CODE> routine, which is described below.<P>
 When you replace the <CODE>wordBreak</CODE> field hook routine, your customized word-selection break routine is used instead of the default one. The default routine breaks words at <BR>any character with an ASCII value of $20 or less (the space character or nonprinting control characters).<P>
 <A NAME=MARKER-2-301></A>Before non-Roman script systems were supported, TextEdit used the word-selection break routine referenced by the <CODE>wordBreak</CODE> field for all word selection and line breaking. However, in order to support both Roman and non-Roman script systems, TextEdit now uses the routine referenced by the low-memory global variable <CODE><A NAME=MARKER-2-911></A>TEFindWord</CODE>. The default <CODE>TEFindWord</CODE> hook routine determines which hook TextEdit should use for word selection and line breaking--the <CODE>wordBreak</CODE> hook or the Text Utilities <CODE>FindWordBreaks</CODE> procedure--based on what script systems are installed <BR>and some other factors. You can replace the <CODE>TEFindWord</CODE> hook routine with a customized version.<P>
 The <CODE>TEFindWord</CODE> hook routine is a higher level routine than <CODE>wordBreak</CODE>. Because of this, when you customize the <CODE>TEFindWord</CODE> hook you are completely changing how TextEdit handles word selection and line breaking. However, when you replace <CODE>wordBreak</CODE>, you are only impacting those aspects of word selection and line breaking that are normally handled by the <CODE>wordBreak</CODE> routine.<P>
 The <CODE>TEFindWord</CODE> hook routine gives your application more control over the breaking process and allows<A NAME=MARKER-2-142></A> you to write more efficient routines. However, unless you include explicit tests for scripts in your customized routine, the algorithms you provide may be incorrect for non-Roman scripts. If you replace <CODE>TEFindWord</CODE>, you should understand the behavior of the default routine.<P>
 Here's how the default <CODE>TEFindWord</CODE> routine works:<P>
<UL>
<LI>TextEdit initially determines whether a non-Roman script system is installed. If more than the Roman script system is installed, TextEdit always uses the Text Utilities <CODE>FindWordBreaks</CODE> procedure for line breaking and word selection.
<LI>When TextEdit determines that only the Roman script system is installed and the <CODE>TEFindWord</CODE> routine is being called for line breaking (not word selection), TextEdit calls the <CODE>wordBreak</CODE> hook.
<LI>If <CODE>TEFindWord</CODE> is called for word selection for system software with only the Roman script system installed, TextEdit checks to see if your application has placed the address of a customized word-selection breaks routine in the <CODE>wordBreak</CODE> field of the edit record. If so, TextEdit calls your word-selection breaks routine. Otherwise, if the <CODE>wordBreak</CODE> field contains the address of TextEdit's internal word-selection breaks routine, TextEdit uses the Text Utilities <CODE>FindWordBreaks</CODE> procedure to determine word-selection breaks.<P>
</UL>
 When TextEdit calls the Text Utilities <CODE>FindWordBreaks</CODE> procedure, it uses information in the edit record to provide the necessary parameters. TextEdit determines the current script boundaries from the Text Utilities <CODE>FindWordBreaks</CODE> procedure by using the font run information in the style record (of type <CODE>TEStyleRec</CODE>). TextEdit also determines the length of the script run and the offset within the script run from which to begin searching for a word boundary. TextEdit uses the value in the <CODE>clikStuff</CODE> field of the edit record to determine the leading edge flag for the <CODE>FindWordBreaks</CODE> procedure. You must use similar information to replace <CODE>TEFindWord</CODE> correctly for non-Roman scripts<A NAME=MARKER-2-413></A>.<A NAME=MARKER-2-970></A><P>
<A NAME=HEADING55-41></A>
<H3><A NAME=MARKER-9-329></A>Customizing Automatic Scrolling</H3>
 <A NAME=MARKER-2-542></A>Scroll bars associated with the text are not automatically scrolled with the text unless you replace the address of the default click loop <A NAME=MARKER-2-331></A><A NAME=MARKER-2-82></A>routine with that of a customized routine that updates the scroll bars. You can write your own click loop routine that includes code to update the sc<A NAME=MARKER-2-31></A>roll bars along with the text and install its address in the <CODE>clikLoop</CODE> field. To replace the default click loop routine with your customized version, you call the <A NAME=MARKER-9-105></A><CODE>TESetClickLoop</CODE> procedure.<P>
 You can write a routine that manages the scroll bars, then calls the default click loop routine, rather than replicating its behavior in your routine. However, if your routine scrolls the text and updates scroll bars, you should consider what the default click loop routine does. It adjusts the value in the <CODE>clickTime</CODE> field of the edit record to allow for slower scrolling.<P>
 When <A NAME=MARKER-2-529></A><CODE>TEClick</CODE> is called, the <CODE>clickTime</CODE> field contains the time when <CODE>TEClick</CODE> was last called. TextEdit sets the <CODE>clickTime</CODE> field with the current tick count on exit from the <CODE>TEClick</CODE> procedure and uses the new value at reentry the next time <CODE>TEClick</CODE> is called.<P>
 If you code a click loop routine in Pascal, it should have no parameters and it should return a Boolean value. You can declare a click loop routine named <CODE>MyClickLoop</CODE> <BR>like this:<P>
<PRE>
FUNCTION MyClickLoop: Boolean;
</PRE>
 The function should return <CODE>TRUE</CODE>. Returning <CODE>FALSE</CODE> from your click loop routine tells the <CODE>TEClick</CODE> procedure that the mouse button has been released, which aborts <CODE>TEClick</CODE>.<P>
<DL>
<DT><B>Installing a customized default click loop routine</B>
<DD>If you code a click loop routine in Pascal, then call the <CODE>TESetClickLoop</CODE> procedure to install the Pascal routine in the <CODE>clikLoop</CODE> field, <CODE>TESetClickLoop</CODE> installs a glue code routine in the <CODE>clikLoop</CODE> field because <CODE>clikLoop</CODE> expects a routine that uses assembly-language conventions. Because of this, you must always use <CODE>TESetClickLoop</CODE> to install a Pascal routine, while you must always directly install an assembly routine in the <CODE>clikLoop</CODE> field.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
 If you code a click loop routine in assembly, it should set register D0 to 1 and preserve register D2. Returning 0 in register D0 aborts <CODE>TEClick</CODE>.<P>
 You can write a routine that manages the scroll bars, then calls the default click loop routine, rather than replicating its behavior in you<A NAME=MARKER-9-72></A>r routine. If your customized routine calls the default click loop routine, it must use assembly-language calling convention.<A NAME=MARKER-2-294></A><A NAME=MARKER-2-830></A><P>
<A NAME=HEADING55-52></A>
<H3>Determining the Line Length</H3>
 This section describes how to determine the length of a line. You can use this information, for example, to justify a line of text; although TextEdit aligns text with the right or left margins, or centers it, it does not justify it.<P>
 To determine the length of a line, you use the information contained in the edit record's line starts array and <CODE>nLine</CODE>s field. The line starts array<A NAME=MARKER-2-73></A> is a variable-length field in the edit record that contains the byte offset for the first character of each line. This array has the following boundary conditions:<A NAME=MARKER-2-981></A><P>
<UL>
<LI>The first entry has index 0 and value 0.
<LI>The last entry in the array has index <CODE>nLines</CODE> and value <CODE>teLength</CODE> (therefore, there are <CODE>nLines</CODE> + 1 entries).
<LI>The beginning of the first line is given by <CODE>lineStarts</CODE>[0], and the beginning of the second line is given by <CODE>lineStarts</CODE>[1]; therefore, the length of the first line is given by <CODE>lineStarts</CODE>[1] - <CODE>lineStarts</CODE>[0].
<LI>The maximum number of entries is 16,000.<P>
</UL>
 For example, if you want to determine the length of the line <I>n</I> (where <I>n</I> = 0 for the first line), subtract its start location (contained in the array entry with index <I>n</I>) from its end location (contained in the array with index <I>n</I> + 1):<P>
<PRE>
lengthOfLineN := myTE^^.lineStarts[n+1] - myTE^^.lineStarts[n];
</PRE>
 The terminating condition for this measurement is when <I>n</I> is equal to <CODE>nLines</CODE> plus 1.<P>
<DL>
<DT><A NAME=MARKER-9-341></A><B>IMPORTANT</B>
<DD>Do not change the information contained in the <CODE>lineStarts</CODE> array.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
<A NAME=HEADING55-63></A>
<H3>Advanced Customization</H3>
 The low-memory global variable <CODE>TEDoText</CODE> <A NAME=MARKER-9-97></A>is a hook which contains the address of a multi-purpose text editing routine that advanced programmers may find useful. It lets you display, highlight, and hit-test characters, and position the pen to draw the caret. <A NAME=MARKER-21-98></A>Hit-testing is the process of determining where to place the <A NAME=MARKER-2-99></A>insertion point when the user clicks the mouse button; the point selected with the mouse is in the <CODE>SelPoint</CODE> field. The registers contain the following values.
<TABLE BORDER="0" CELLPADDING=3><TH colspan=2>Registers on entry<TH>&nbsp;<TH>&nbsp;<TH>&nbsp;<TH>&nbsp;<TR>
<TD>A3<TD colspan=4>Pointer to the locked edit record<TD>&nbsp;<TR>
<TD>D3<TD colspan=4>Position of the first character (word)<TD>&nbsp;<TR>
<TD>D4<TD colspan=5>Position of the last character; used as defined below (word)<TR>
<TD>D7<TD colspan=4>Selectors for TEDoText (word)<TD>&nbsp;<TR>
<TD>&nbsp;<TD>teFind<TD>EQU<TD><CODE>0</CODE><TD colspan=2>to hit-test the character specified in D3<TR>
<TD>&nbsp;<TD>teHighlight<TD>EQU<TD><CODE>1</CODE><TD colspan=2>to highlight the text range specified in D3 <BR>and D4<TR>
<TD>&nbsp;<TD>teDraw<TD>EQU<TD><CODE>-1</CODE><TD colspan=2>to display the range of text specified in D3 and D4<TR>
<TD>&nbsp;<TD>teCaret<TD>EQU<TD><CODE>-2</CODE><TD colspan=2>to draw the caret at the position specified <BR>in D3<TR>
<TD>&nbsp;<TD>teFind<TD>EQU<TD><CODE>0</CODE><TD colspan=2>to hit-test the character specified in D3</TABLE>

<TABLE BORDER="0" CELLPADDING=3><TH colspan=2>Registers on exit<TH>&nbsp;<TH>&nbsp;<TR>
<TD>A0<TD colspan=3>Pointer to current graphics port<TR>
<TD>D0<TD colspan=3>If hit-testing, byte offset where hit, or -1 for none (word)</TABLE>
<P>
<DL>
<DT><B>Note</B>
<DD>You need to use the value stored in the edit record <CODE>selPoint</CODE> field <BR>for hit-testing if you replace the routine pointed to by the global <BR>variable <CODE>TEDoText</CODE>. (The <A NAME=MARKER-2-58></A>assembly-language o<A NAME=MARKER-2-875></A>ffset for this field <BR>is named <CODE>teSelPoint</CODE>.)<EM></EM><A NAME=MARKER-2-908></A>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
</BLOCKQUOTE>
<HR>
<center>
<A HREF="Text-54.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Text-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Text-594.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="Text-56.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="Text-3.html">&copy; Apple Computer, Inc.</A><br>6 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>  
