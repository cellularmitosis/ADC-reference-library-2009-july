<!-- legacy work start -->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<!-- legacy work end -->


<!-- Generated by Harlequin WebMaker 2.2.3 (23-Apr-1996)

LispWorks 3.2.2 -->
<HTML> <HEAD>
<TITLE>Summary of the Speech Manager (IM: S)  (deprecated)</Title>

<!-- legacy work start -->
        <META NAME="Generator" CONTENT="manual">
        <META http-equiv="content-type" CONTENT="text/html;charset=utf-8">
        <META NAME = "Copyright" CONTENT="Copyright 2007 Apple Inc. All Rights Reserved.">
        <META NAME="IndexTitle" CONTENT="Inside Macintosh: Sound (Not Recommended)">
        <meta name="xcode-display" content="render">

        <LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css"> <!-- before submitting, globally replace ".." with "developer.apple.com" -->
        <script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
<!-- legacy work end -->

</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<A NAME=HEADING265></A>


<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="Sound-264.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Sound-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Sound-336.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="Sound-266.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="Sound-2.html"><B>Sound</B></A> / <BR><DD><A HREF="Sound-187.html"><B>Chapter 4 - Speech Manager</B></A></DL></FONT><P>
<HR>

<!-- legacy work start -->
<script type="text/javascript"> placeWatermark()</script>
<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
<i>Inside Macintosh: Sound</i> is deprecated as of Mac OS X v10.5. For new audio development in Mac OS X, use Core Audio. See the <a href="../../../referencelibrary/MusicAudio/" target="_top">Audio</a> page in the ADC Reference Library.</p></div></div></div>
<!-- legacy work end -->


<BLOCKQUOTE>
<A NAME=HEADING265-0></A>
<H1>Summary of the Speech Manager</H1>
<A NAME=HEADING265-1></A>
<H2>Pascal Summary</H2>
<A NAME=HEADING265-2></A>
<H3>Constants</H3>
<PRE>
CONST
   {Gestalt selector and response bits for speech attributes}
   gestaltSpeechAttr          = 'ttsc';   {speech attributes selector}
   gestaltSpeechMgrPresent    = 0;        {Speech Manager is present}
   gestaltSpeechHasPPCGlue    = 1;        {native glue for PowerPC present}
   
   {Operating System types}
   kTextToSpeechSynthType     = 'ttsc';   {synthesizer component type}
   kTextToSpeechVoiceType     = 'ttvd';   {voice resource type}
   kTextToSpeechVoiceFileType = 'ttvf';   {voice file type}
   kTextToSpeechVoiceBundleType
                              = 'ttvb';   {voice bundle file type}
   
   {masks for SpeakBuffer and text-done callback control flags}
   kNoEndingProsody        = 1;        {disable prosody at end of sentences}
   kNoSpeechInterrupt      = 2;        {do not interrupt current speech}
   kPreflightThenPause     = 4;        {compute speech without generating}
  
   {constants for StopSpeechAt and PauseSpeechAt}
   kImmediate              = 0;        {stop immediately}
   kEndOfWord              = 1;        {stop at end of word}
   kEndOfSentence          = 2;        {stop at end of sentence}
   
   {GetSpeechInfo and SetSpeechInfo selectors}
   soCharacterMode         = 'char';   {get or set character-processing mode}
   soCommandDelimiter      = 'dlim';   {set embedded command delimiters}
   soCurrentA5             = 'myA5';   {set A5 on callbacks}
   soCurrentVoice          = 'cvox';   {set speaking voice}
   soErrorCallBack         = 'ercb';   {set error callback}
   soErrors                = 'erro';   {get error information}
   soInputMode             = 'inpt';   {get or set text-processing mode}
   soNumberMode            = 'nmbr';   {get or set number-processing mode}
   soPhonemeCallBack       = 'phcb';   {set phoneme callback}
   soPhonemeSymbols        = 'phsy';   {get phoneme symbols and sample words}
   soPitchBase             = 'pbas';   {get or set baseline pitch}
   soPitchMod              = 'pmod';   {get or set pitch modulation}
   soRate                  = 'rate';   {get or set speech rate}
   soRecentSync            = 'sync';   {get most recent synchronization }
                                       { message information}
   soRefCon                = 'refc';   {set reference constant value}
   soReset                 = 'rset';   {set channel back to default state}
   soSpeechDoneCallBack    = 'sdcb';   {set speech-done callback}
   soStatus                = 'stat';   {get status of channel}
   soSyncCallBack          = 'sycb';   {set synchronization callback}
   soSynthExtension        = 'xtnd';   {get or set synthesizer-specific }
                                       { information}
   soSynthType             = 'vers';   {get synthesizer information}
   soTextDoneCallBack      = 'tdcb';   {set text-done callback}
   soVolume                = 'volm';   {get or set speech volume}
   soWordCallBack          = 'wdcb';   {set word callback}
   
   {input mode constants}
   modeText             = 'TEXT';
   modePhonemes         = 'PHON';
   {character and number mode constants}
   modeNormal           = 'NORM';
   modeLiteral          = 'LTRL';
   
   {GetVoiceInfo selectors}
   soVoiceDescription   = 'info';      {get basic voice information}
   soVoiceFile          = 'fref';      {get voice file reference information}
   
   {genders}
   kNeuter              = 0;
   kMale                = 1;
   kFemale              = 2;
</PRE>
<A NAME=HEADING265-12></A>
<H3>Data Structures</H3>
<A NAME=HEADING265-13></A>
<H4>Speech Channel Record</H4>
<PRE>
TYPE
   SpeechChannelRecord  = LongInt;                 {speech channel record}
   SpeechChannel        = ^SpeechChannelRecord;    {speech channel}
   SpeechChannelPtr     = ^SpeechChannel;          {speech channel pointer}
</PRE>
<A NAME=HEADING265-15></A>
<H4>Voice Specification Record</H4>
<PRE>
   VoiceSpec =
   RECORD
      creator:          OSType;        {ID of required synthesizer}
      id:               OSType;        {ID of voice on the synthesizer}
   END;
   VoiceSpecPtr = ^VoiceSpec;
</PRE>
<A NAME=HEADING265-17></A>
<H4>Voice Description Record</H4>
<PRE>
   VoiceDescription =
   RECORD
      length:           LongInt;       {size of record--set by application}
      voice:            VoiceSpec;     {voice synthesizer and ID info}
      version:          LongInt;       {version number of voice}
      name:             Str63;         {name of voice}
      comment:          Str255;        {text information about voice}
      gender:           Integer;       {neuter, male, or female}
      age:              Integer;       {approximate age in years}
      script:           Integer;       {script code of text voice can }
                                       { process}
      language:         Integer;       {language code of voice output}
      region:           Integer;       {region code of voice output}
      reserved1:        LongInt;       {always 0--reserved for future use}
      reserved2:        LongInt;       {always 0--reserved for future use}
      reserved3:        LongInt;       {always 0--reserved for future use}
      reserved4:        LongInt;       {always 0--reserved for future use}
   END;
   VoiceDescriptionPtr = ^VoiceDescription;
</PRE>
<A NAME=HEADING265-19></A>
<H4>Voice File Information Record</H4>
<PRE>
   VoiceFileInfo =
   RECORD
      fileSpec:         FSSpec;        {volume, dir, and name of file}
      resID:            Integer;       {resource ID of voice in the file}
   END;
   VoiceFileInfoPtr = ^VoiceFileInfo;
</PRE>
<A NAME=HEADING265-21></A>
<H4>Speech-Status Information Record</H4>
<PRE>
   SpeechStatusInfo =
   RECORD
      outputBusy:       Boolean;       {TRUE if audio is playing}
      outputPaused:     Boolean;       {TRUE if channel is paused}
      inputBytesLeft:   LongInt;       {bytes of text left to process}
      phonemeCode:      Integer;       {opcode for current phoneme}
   END;
   SpeechStatusInfoPtr = ^SpeechStatusInfo;
</PRE>
<A NAME=HEADING265-23></A>
<H4>Speech Error Information Record</H4>
<PRE>
   SpeechErrorInfo =
   RECORD
      count:            Integer;       {number of errors since last check}
      oldest:           OSErr;         {oldest unread error}
      oldPos:           LongInt;       {character position of oldest error}
      newest:           OSErr;         {most recent error}
      newPos:           LongInt;       {character position of newest error}
   END;
</PRE>
<A NAME=HEADING265-25></A>
<H4>Speech Version Information Record</H4>
<PRE>
   SpeechVersionInfo =
   RECORD
      synthType:        OSType;        {general synthesizer type}
      synthSubType:     OSType;        {specific synthesizer type}
      synthManufacturer:
                        OSType;        {synthesizer creator ID}
      synthFlags:       LongInt;       {synthesizer feature flags}
      synthVersion:     NumVersion;    {synthesizer version number}
   END;
   SpeechVersionInfoPtr = ^SpeechVersionInfo;
</PRE>
<A NAME=HEADING265-27></A>
<H4>Phoneme Information Record</H4>
<PRE>
   PhonemeInfo =
   RECORD
      opCode:           Integer;       {opcode for the phoneme}
      phStr:            Str15;         {corresponding character string}
      exampleStr:       Str31;         {word that shows use of phoneme}
      hiliteStart:      Integer;       {offset from beginning of word }
                                       { to beginning of phoneme sound}
      hiliteEnd:        Integer;       {offset from beginning of word }
                                       { to end of phoneme sound}
   END;
</PRE>
<A NAME=HEADING265-29></A>
<H4>Phoneme Descriptor Record</H4>
<PRE>
   PhonemeDescriptor =
   RECORD
      phonemeCount:     Integer;       {number of phonemes defined by }
                                       { current synthesizer}
                                       {list of phoneme information records}
      thePhonemes:      ARRAY[0..0] OF PhonemeInfo;
   END;
</PRE>
<A NAME=HEADING265-31></A>
<H4>Speech Extension Data Record</H4>
<PRE>
   SpeechXtndData =
   RECORD
      synthCreator:     OSType;        {synthesizer creator ID}
                                       {data used by synthesizer}
      synthData:        PACKED ARRAY[0..1] OF Char;
   END;
</PRE>
<A NAME=HEADING265-33></A>
<H4>Delimiter Information Record</H4>
<PRE>
   DelimiterInfo =
   RECORD
      startDelimiter:   PACKED ARRAY[0..1] OF Char;   {start delimiter}
      endDelimiter:     PACKED ARRAY[0..1] OF Char;   {end delimiter}
   END;
</PRE>
<A NAME=HEADING265-35></A>
<H3>Speech Manager Routines</H3>
<A NAME=HEADING265-36></A>
<H4>Starting, Stopping, and Pausing Speech</H4>
<PRE>
FUNCTION  SpeakString   (s: Str255): OSErr;
FUNCTION  SpeakText     (chan: SpeechChannel; textBuf: Ptr; 
                         byteLen:LongInt): OSErr;
FUNCTION  SpeakBuffer   (chan: SpeechChannel; textBuf: Ptr; 
                         byteLen:LongInt; controlFlags: LongInt): 
          OSErr;
FUNCTION  StopSpeech    (chan: SpeechChannel): OSErr;
FUNCTION  StopSpeechAt  (chan: SpeechChannel; whereToStop: LongInt): 
          OSErr;
FUNCTION  PauseSpeechAt (chan: SpeechChannel; whereToStop: LongInt): 
          OSErr;
FUNCTION  ContinueSpeech  (chan: SpeechChannel): OSErr;
</PRE>
<A NAME=HEADING265-44></A>
<H4>Obtaining Information About Voices</H4>
<PRE>
FUNCTION  MakeVoiceSpec (creator: OSType; id: OSType; 
                         voice:VoiceSpecPtr): OSErr;
FUNCTION  CountVoices   (VAR numVoices: Integer): OSErr;
FUNCTION  GetIndVoice   (index: Integer; voice: VoiceSpecPtr): OSErr;
FUNCTION  GetVoiceDescription
                        (voice: VoiceSpecPtr; info:VoiceDescriptionPtr; infoLength:LongInt)
                       : OSErr;
FUNCTION  GetVoiceInfo  (voice: VoiceSpecPtr; selector:OSType; 
                         voiceInfo:Ptr): OSErr;
</PRE>
<A NAME=HEADING265-51></A>
<H4>Managing Speech Channels</H4>
<PRE>
FUNCTION  NewSpeechChannel  
                        (voice: VoiceSpecPtr; VAR chan:SpeechChannel): 
          OSErr;
FUNCTION  DisposeSpeechChannel
                        (chan: SpeechChannel): OSErr;
</PRE>
<A NAME=HEADING265-55></A>
<H4>Obtaining Information About Speech</H4>
<PRE>
FUNCTION  SpeechManagerVersion
                       : NumVersion;
FUNCTION  SpeechBusy    
                       : Integer;
FUNCTION  SpeechBusySystemWide
                       : Integer;
</PRE>
<A NAME=HEADING265-61></A>
<H4>Changing Speech Attributes</H4>
<PRE>
FUNCTION  GetSpeechRate   (chan: SpeechChannel; VAR rate: Fixed): OSErr;
FUNCTION  SetSpeechRate   (chan: SpeechChannel; rate: Fixed): OSErr;
FUNCTION  GetSpeechPitch  (chan: SpeechChannel; VAR pitch: Fixed): OSErr;
FUNCTION  SetSpeechPitch  (chan: SpeechChannel; pitch: Fixed): OSErr;
FUNCTION  GetSpeechInfo   (chan: SpeechChannel; selector: OSType; 
                           speechInfo:Ptr): OSErr;
FUNCTION  SetSpeechInfo   (chan: SpeechChannel; selector: OSType; 
                           speechInfo:Ptr): OSErr;
</PRE>  
<A NAME=HEADING265-68></A>
<H4>Converting Text to Phonemes</H4>
<PRE>
FUNCTION  TextToPhonemes  (chan: SpeechChannel; textBuf:Ptr; 
                           textBytes:LongInt; phonemeBuf: Handle; 
                           VAR phonemeBytes: LongInt): OSErr;
</PRE>
<A NAME=HEADING265-70></A>
<H4>Installing a Pronunciation Dictionary</H4>
<PRE>
FUNCTION  UseDictionary   (chan: SpeechChannel; dictionary: Handle)
                         : OSErr;
</PRE>
<A NAME=HEADING265-72></A>
<H3>Application-Defined Routines</H3>
<PRE>
PROCEDURE MyTextDoneCallback
                            (chan: SpeechChannel; refCon: LongInt; VARnextBuf: Ptr; 
                             VAR byteLen: LongInt; VARcontrolFlags: LongInt);
PROCEDURE MySpeechDoneCallback
                            (chan: SpeechChannel; refCon: LongInt);
PROCEDURE MySynchronizationCallback
                            (chan: SpeechChannel; refCon: LongInt; syncMessage: OSType);
PROCEDURE MyErrorCallback   (chan: SpeechChannel; refCon: LongInt;
                             error: OSErr; bytePos: LongInt);
PROCEDURE MyPhonemeCallback
                            (chan: SpeechChannel; refCon: LongInt; phonemeOpcode: Integer);
PROCEDURE MyWordCallback    (chan: SpeechChannel; refCon: LongInt;
                             wordPos: LongInt; wordLen: Integer);
</PRE>
<A NAME=HEADING265-83></A>
<H2>C Summary</H2>
<A NAME=HEADING265-84></A>
<H3>Constants</H3>
<PRE>
/*Gestalt selector and response bits for speech attributes*/
#define gestaltSpeechAttr  'ttsc'   /*speech attributes selector*/
enum {
   gestaltSpeechMgrPresent    = 0   /*Speech Manager is present*/
   gestaltSpeechHasPPCGlue    = 1   /*native glue for PowerPC present*/
};
/*Operating System types*/
#define kTextToSpeechSynthType         'ttsc'   /*synthesizer component */
                                                /* type*/
#define kTextToSpeechVoiceType         'ttvd'   /*voice resource type*/
#define kTextToSpeechVoiceFileType     'ttvf'   /*voice file type*/
#define kTextToSpeechVoiceBundleType   'ttvb'   /*voice bundle file type*/
/*masks for SpeakBuffer and text-done callback control flags*/
enum {
   kNoEndingProsody        = 1,     /*disable prosody at end of sentences*/
   kNoSpeechInterrupt      = 2,     /*do not interrupt current speech*/
   kPreflightThenPause     = 4      /*compute speech without generating*/
};
/*constants for StopSpeechAt and PauseSpeechAt*/
enum {
   kImmediate        = 0,           /*stop immediately*/
   kEndOfWord        = 1,           /*stop at end of word*/
   kEndOfSentence    = 2            /*stop at end of sentence*/
};
/*GetSpeechInfo and SetSpeechInfo selectors*/
#define soCharacterMode       'char'   /*get or set character-processing */
                                       /* mode*/
#define soCommandDelimiter    'dlim'   /*set embedded command delimiters*/
#define soCurrentA5           'myA5'   /*set A5 on callbacks*/
#define soCurrentVoice        'cvox'   /*set speaking voice*/
#define soErrorCallBack       'ercb'   /*set error callback*/
#define soErrors              'erro'   /*get error information*/
#define soInputMode           'inpt'   /*get or set text-processing mode*/
#define soNumberMode          'nmbr'   /*get or set number-processing mode*/
#define soPhonemeCallBack     'phcb'   /*set phoneme callback*/
#define soPhonemeSymbols      'phsy'   /*get phoneme symbols and sample*/
                                       /* words*/
#define soPitchBase           'pbas'   /*get or set baseline pitch*/
#define soPitchMod            'pmod'   /*get or set pitch modulation*/
#define soRate                'rate'   /*get or set speech rate*/
#define soRecentSync          'sync'   /*get most recent synchronization */
                                       /* message information*/
#define soRefCon              'refc'   /*set reference constant value*/
#define soReset               'rset'   /*set channel back to default state*/
#define soSpeechDoneCallBack  'sdcb'   /*set speech-done callback*/
#define soStatus              'stat'   /*get status of channel*/
#define soSyncCallBack        'sycb'   /*set synchronization callback*/
#define soSynthExtension      'xtnd'   /*get or set synthesizer-specific */
                                       /* information*/
#define soSynthType           'vers'   /*get synthesizer information*/
#define soTextDoneCallBack    'tdcb'   /*set text-done callback*/
#define soVolume              'volm'   /*get or set speech volume*/
#define soWordCallBack        'wdcb'   /*set word callback*/
/*input mode constants*/
#define modeText        'TEXT'
#define modePhonemes    'PHON'
/*character and number mode constants*/
#define modeNormal      'NORM'
#define modeLiteral     'LTRL'
/*GetVoiceInfo selectors*/
enum {
   soVoiceDescription   = 'info',   /*get basic voice information*/
   soVoiceFile          = 'fref'    /*get voice file reference information*/
};
/*genders*/
enum {
   kNeuter = 0, 
   kMale, 
   kFemale
};
</PRE>
<A NAME=HEADING265-94></A>
<H3>Data Types</H3>
<A NAME=HEADING265-95></A>
<H4>Speech Channel Record</H4>
<PRE>
typedef struct SpeechChannelRecord {
   long data[1];                       /*used internally*/
} SpeechChannelRecord;
typedef SpeechChannelRecord *SpeechChannel;
</PRE>
<A NAME=HEADING265-98></A>
<H4>Voice Specification Record</H4>
<PRE>
typedef struct VoiceSpec {
   OSType      creator;             /*ID of required synthesizer*/
   OSType      id;                  /*ID of voice on the synthesizer*/
} VoiceSpec;
</PRE>
<A NAME=HEADING265-100></A>
<H4>Voice Description Record</H4>
<PRE>
typedef struct VoiceDescription {
   long        length;              /*size of structure--set by application*/
   VoiceSpec   voice;               /*voice synthesizer and ID info*/
   long        version;             /*version number of voice*/
   Str63       name;                /*name of voice*/
   Str255      comment;             /*text information about voice*/
   short       gender;              /*neuter, male, or female*/
   short       age;                 /*approximate age in years*/
   short       script;              /*script code of text voice can process*/
   short       language;            /*language code of voice output*/
   short       region;              /*region code of voice output*/
   long        reserved[4];         /*always 0--reserved for future use*/
} VoiceDescription;
</PRE>
<A NAME=HEADING265-102></A>
<H4>Voice File Information Record</H4>
<PRE>
typedef struct VoiceFileInfo {
   FSSpec      fileSpec;            /*volume, dir, and name of file*/
   short       resID;               /*resource ID of voice in the file*/
} VoiceFileInfo;
</PRE>
<A NAME=HEADING265-104></A>
<H4>Speech Status Information Record</H4>
<PRE>
typedef struct SpeechStatusInfo {
   Boolean     outputBusy;          /*TRUE if audio is playing*/
   Boolean     outputPaused;        /*TRUE if channel is paused*/
   long        inputBytesLeft;      /*bytes of text left to process*/
   short       phonemeCode;         /*opcode for current phoneme*/
} SpeechStatusInfo;
</PRE>
<A NAME=HEADING265-106></A>
<H4>Speech Error Information Record</H4>
<PRE>
typedef struct SpeechErrorInfo {
   short       count;               /*number of errors since last check*/
   OSErr       oldest;              /*oldest unread error*/
   long        oldPos;              /*character position of oldest error*/
   OSErr       newest;              /*most recent error*/
   long        newPos;              /*character position of newest error*/
} SpeechErrorInfo;
</PRE>
<A NAME=HEADING265-108></A>
<H4>Speech Version Information Record</H4>
<PRE>
typedef struct SpeechVersionInfo {
   OSType      synthType;           /*general synthesizer type*/
   OSType      synthSubType;        /*specific synthesizer type*/
   OSType      synthManufacturer;   /*synthesizer creator ID*/
   long        synthFlags;          /*synthesizer feature flags*/
   NumVersion  synthVersion;        /*synthesizer version number*/
} SpeechVersionInfo;
</PRE>
<A NAME=HEADING265-110></A>
<H4>Phoneme Information Record</H4>
<PRE>
typedef struct PhonemeInfo {
   short       opcode;              /*opcode for the phoneme*/
   Str15       phStr;               /*corresponding character string*/
   Str31       exampleStr;          /*word that shows use of phoneme*/
   short       hiliteStart;         /*offset from beginning of word */
                                    /* to beginning of phoneme sound*/
   short       hiliteEnd;           /*offset from beginning of word */
                                    /* to end of phoneme sound*/
} PhonemeInfo;
</PRE>
<A NAME=HEADING265-112></A>
<H4>Phoneme Descriptor Record</H4>
<PRE>
typedef struct PhonemeDescriptor {
   short          phonemeCount;     /*number of phonemes defined by */
                                    /* current synthesizer*/
   PhonemeInfo    thePhonemes[1];   /*list of phoneme information records*/
} PhonemeDescriptor;
</PRE>
<A NAME=HEADING265-114></A>
<H4>Speech Extension Data Record</H4>
<PRE>
typedef struct SpeechXtndData {
   OSType      synthCreator;        /*synthesizer creator ID*/
   Byte        synthData[2];        /*data used by synthesizer*/
} SpeechXtndData;
</PRE>
<A NAME=HEADING265-116></A>
<H4>Delimiter Information Record</H4>
<PRE>
typedef struct DelimiterInfo {
   Byte        startDelimiter[2];   /*start delimiter*/
   Byte        endDelimiter[2];     /*end delimiter*/
} DelimiterInfo;
</PRE>
<A NAME=HEADING265-118></A>
<H3>Speech Manager Routines</H3>
<A NAME=HEADING265-119></A>
<H4>Starting, Stopping, and Pausing Speech</H4>
<PRE>
pascal  OSErr SpeakString   (StringPtr s);
pascal  OSErr SpeakText     (SpeechChannel chan, Ptr textBuf, 
                             long textBytes);
pascal  OSErr SpeakBuffer   (SpeechChannel chan, Ptr textBuf, 
                             long textBytes, long controlFlags);
pascal  OSErr StopSpeech    (SpeechChannel chan);
pascal  OSErr StopSpeechAt  (SpeechChannel chan, long whereToStop);
pascal  OSErr PauseSpeechAt (SpeechChannel chan, long whereToPause);
pascal  OSErr ContinueSpeech
                            (SpeechChannel chan);
</PRE>
<A NAME=HEADING265-128></A>
<H4>Obtaining Information About Voices</H4>
<PRE>
pascal  OSErr MakeVoiceSpec (OSType creator, OSType id, VoiceSpec *voice);
pascal  OSErr CountVoices   (short *numVoices);
pascal  OSErr GetIndVoice   (short index, VoiceSpec *voice);
pascal  OSErr GetVoiceDescription
                            (VoiceSpec *voice, VoiceDescription *info,
                             long infoLength);
pascal  OSErr GetVoiceInfo  (VoiceSpec *voice, OSType selector, 
                             void *voiceInfo);
</PRE>
<A NAME=HEADING265-135></A>
<H4>Managing Speech Channels</H4>
<PRE>
pascal  OSErr NewSpeechChannel
                            (VoiceSpec *voice, SpeechChannel *chan);
pascal  OSErr DisposeSpeechChannel
                            (SpeechChannel chan);
</PRE>
<A NAME=HEADING265-140></A>
<H4>Obtaining Information About Speech</H4>
<PRE>
pascal  NumVersion SpeechManagerVersion
                            (void);
pascal  short SpeechBusy    (void);
pascal  short SpeechBusySystemWide
                            (void);
</PRE>
<A NAME=HEADING265-146></A>
<H4>Changing Speech Attributes</H4>
<PRE>
pascal  OSErr GetSpeechRate (SpeechChannel chan, Fixed *rate);
pascal  OSErr SetSpeechRate (SpeechChannel chan, Fixed rate);
pascal  OSErr GetSpeechPitch
                            (SpeechChannel chan, Fixed *pitch);
pascal  OSErr SetSpeechPitch
                            (SpeechChannel chan, Fixed pitch);
pascal  OSErr GetSpeechInfo (SpeechChannel chan, OSType selector, 
                             void *speechInfo);
pascal  OSErr SetSpeechInfo (SpeechChannel chan, OSType selector, 
                             void *speechInfo);
</PRE>
<A NAME=HEADING265-155></A>
<H4>Converting Text to Phonemes</H4>
<PRE>
pascal  OSErr TextToPhonemes
                            (SpeechChannel chan, Ptr textBuf, 
                             long textBytes, Handle phonemeBuf, 
                             long *phonemeBytes);
</PRE>
<A NAME=HEADING265-158></A>
<H4>Installing a Pronunciation Dictionary</H4>
<PRE>
pascal  OSErr UseDictionary (SpeechChannel chan, Handle dictionary);
</PRE>
<A NAME=HEADING265-160></A>
<H3>Application-Defined Routines</H3>
<PRE>
#pragma procname SpeechTextDone
typedef pascal void         (*SpeechTextDoneCBPtr) 
                            (SpeechChannel, long, Ptr *, long *, long *);
typedef SpeechTextDoneProcPtr SpeechTextDoneCBPtr;
#pragma procname SpeechDone
typedef pascal void         (*SpeechDoneCBPtr)
                            (SpeechChannel, long);
typedef SpeechDoneProcPtr SpeechDoneCBPtr;
#pragma procname SpeechSync
typedef pascal void         (*SpeechSyncCBPtr)
                            (SpeechChannel, long, OSType);
typedef SpeechSyncProcPtr SpeechSyncCBPtr;
#pragma procname SpeechError
typedef pascal void         (*SpeechErrorCBPtr)
                            (SpeechChannel, long, OSErr, long);
typedef SpeechErrorProcPtr SpeechErrorCBPtr;
#pragma procname SpeechPhoneme
typedef pascal void         (*SpeechPhonemeCBPtr)
                            (SpeechChannel, long, short);
typedef SpeechPhonemeProcPtr SpeechPhonemeCBPtr;
#pragma procname SpeechWord
typedef pascal void         (*SpeechWordCBPtr)
                            (SpeechChannel, long, long, short);
typedef SpeechWordProcPtr SpeechWordCBPtr;
</PRE>
<A NAME=HEADING265-179></A>
<H2>Assembly-Language Information</H2>
<A NAME=HEADING265-180></A>
<H3>Data Structures</H3>
<A NAME=HEADING265-181></A>
<H4>Voice Specification Data Structure
<TABLE BORDER="0" CELLPADDING=3><TD>0<TD>creator<TD>4 bytes<TD>ID of required synthesizer<TR>
<TD>4<TD>id<TD>4 bytes<TD>ID of voice on the synthesizer</TABLE>
</H4>
<A NAME=HEADING265-182></A>
<H4>Voice Description Data Structure
<TABLE BORDER="0" CELLPADDING=3><TD>0<TD>length<TD>long<TD>size of structure--set by application<TR>
<TD>4<TD>voice<TD>8 bytes<TD>voice specification record<TR>
<TD>12<TD>version<TD>long<TD>version number of voice<TR>
<TD>16<TD>name<TD>64 bytes<TD>name of voice; preceded by length byte<TR>
<TD>80<TD>comment<TD>256 bytes<TD>text information about voice; preceded by length byte<TR>
<TD>336<TD>gender<TD>short<TD>neuter (0), male (1), or female (2)<TR>
<TD>338<TD>age<TD>short<TD>approximate age in years<TR>
<TD>340<TD>script<TD>short<TD>script code of text voice can process<TR>
<TD>342<TD>language<TD>short<TD>language code of text voice can process<TR>
<TD>344<TD>region<TD>short<TD>region code of voice output<TR>
<TD>346<TD>reserved<TD>16 bytes<TD>always set to 0--reserved for future use</TABLE>
</H4>
<A NAME=HEADING265-183></A>
<H4>Voice File Information Data Structure
<TABLE BORDER="0" CELLPADDING=3><TD>0<TD>fileSpec<TD>70 bytes<TD>volume, directory, and name of file<TR>
<TD>70<TD>resID<TD>word<TD>resource ID of voice in the file</TABLE>
</H4>
<A NAME=HEADING265-184></A>
<H4>Speech Status Information Data Structure
<TABLE BORDER="0" CELLPADDING=3><TD>0<TD>outputBusy<TD>byte<TD>1 if audio is playing<TR>
<TD>1<TD>outputPaused<TD>byte<TD>1 if channel is paused<TR>
<TD>2<TD>inputBytesLeft<TD>long<TD>bytes of text left to process<TR>
<TD>6<TD>phonemeCode<TD>short<TD>opcode for current phoneme</TABLE>
</H4>
<A NAME=HEADING265-185></A>
<H4>Speech Error Information Data Structure
<TABLE BORDER="0" CELLPADDING=3><TD>0<TD>count<TD>word<TD>number of errors since last check<TR>
<TD>2<TD>oldest<TD>long<TD>oldest unread Operating System error<TR>
<TD>6<TD>oldPos<TD>long<TD>character position of oldest error<TR>
<TD>10<TD>newest<TD>long<TD>newest Operating System error<TR>
<TD>14<TD>newPos<TD>long<TD>character position of newest error</TABLE>
</H4>
<A NAME=HEADING265-186></A>
<H4>Speech Version Information Data Structure
<TABLE BORDER="0" CELLPADDING=3><TD>0<TD>synthType<TD>4 bytes<TD>always <CODE>'TTSC'</CODE><TR>
<TD>4<TD>synthSubType<TD>4 bytes<TD>synthesizer type<TR>
<TD>8<TD>synthManufacturer<TD>4 bytes<TD>synthesizer creator ID<TR>
<TD>12<TD>synthFlags<TD>long<TD>synthesizer feature flags<TR>
<TD>16<TD>synthVersion<TD>long<TD>synthesizer version number</TABLE>
</H4>
<A NAME=HEADING265-187></A>
<H4>Phoneme Information Data Structure
<TABLE BORDER="0" CELLPADDING=3><TD>0<TD>opcode<TD>word<TD>opcode for the phoneme<TR>
<TD>2<TD>phStr<TD>16 bytes<TD>corresponding character string; preceded by length byte<TR>
<TD>18<TD>exampleStr<TD>32 bytes<TD>word that shows use of phoneme<TR>
<TD>50<TD>hiliteStart<TD>word<TD>offset from beginning of word to beginning of phoneme sound<TR>
<TD>52<TD>hiliteEnd<TD>word<TD>offset from beginning of word to end of phoneme sound</TABLE>
</H4>
<A NAME=HEADING265-188></A>
<H4>Phoneme Descriptor Data Structure
<TABLE BORDER="0" CELLPADDING=3><TD>0<TD>phonemeCount<TD>word<TD>number of phonemes defined by current synthesizer<TR>
<TD>2<TD>thePhonemes<TD>variable<TD>list of phoneme information records</TABLE>
</H4>
<A NAME=HEADING265-189></A>
<H4>Speech Extension Data Structure
<TABLE BORDER="0" CELLPADDING=3><TD>0<TD>synthCreator<TD>4 bytes<TD>synthesizer creator ID<TR>
<TD>4<TD>synthData<TD>variable<TD>data used by synthesizer</TABLE>
</H4>
<A NAME=HEADING265-190></A>
<H4>Delimiter Information Data Structure
<TABLE BORDER="0" CELLPADDING=3><TD>0<TD>startDelimiter<TD>2 bytes<TD>start embedded command characters; defaults to "<CODE>[[</CODE>"<TR>
<TD>2<TD>endDelimiter<TD>2 bytes<TD>end embedded command characters; defaults to "<CODE>]]</CODE>"</TABLE>
</H4>
<A NAME=HEADING265-191></A>
<H3>Trap Macros</H3>
<A NAME=HEADING265-192></A>
<H4>Trap Macro Requiring Routine Selectors</H4>
 <CODE>_SoundDispatch
<TABLE BORDER="0" CELLPADDING=3><TH ALIGN=LEFT>Selector<TH>Routine<TR>
<TD>$0000000C<TD><CODE>SpeechManagerVersion</CODE><TR>
<TD>$003C000C<TD><CODE>SpeechBusy</CODE><TR>
<TD>$0040000C<TD><CODE>SpeechBusySystemWide</CODE><TR>
<TD>$0108000C<TD><CODE>CountVoices</CODE><TR>
<TD>$021C000C<TD><CODE>DisposeSpeechChannel</CODE><TR>
<TD>$0220000C<TD><CODE>SpeakString</CODE><TR>
<TD>$022C000C<TD><CODE>StopSpeech</CODE><TR>
<TD>$0238000C<TD><CODE>ContinueSpeech</CODE><TR>
<TD>$030C000C<TD><CODE>GetIndVoice</CODE><TR>
<TD>$0418000C<TD><CODE>NewSpeechChannel</CODE><TR>
<TD>$0430000C<TD><CODE>StopSpeechAt</CODE><TR>
<TD>$0434000C<TD><CODE>PauseSpeechAt</CODE><TR>
<TD>$0444000C<TD><CODE>SetSpeechRate</CODE><TR>
<TD>$0448000C<TD><CODE>GetSpeechRate</CODE><TR>
<TD>$044C000C<TD><CODE>SetSpeechPitch</CODE><TR>
<TD>$0450000C<TD><CODE>GetSpeechPitch</CODE><TR>
<TD>$0460000C<TD><CODE>UseDictionary</CODE><TR>
<TD>$0604000C<TD><CODE>MakeVoiceSpec</CODE><TR>
<TD>$0610000C<TD><CODE>GetVoiceDescription</CODE><TR>
<TD>$0614000C<TD><CODE>GetVoiceInfo</CODE><TR>
<TD>$0624000C<TD><CODE>SpeakText</CODE><TR>
<TD>$0654000C<TD><CODE>SetSpeechInfo</CODE><TR>
<TD>$0658000C<TD><CODE>GetSpeechInfo</CODE><TR>
<TD>$0828000C<TD><CODE>SpeakBuffer</CODE><TR>
<TD>$0A5C000C<TD><CODE>TextToPhonemes</CODE></TABLE>
</CODE><P>
<A NAME=HEADING265-194></A>
<H2>Result Codes
<TABLE BORDER="0" CELLPADDING=3><TD>noErr<TD>0<TD>No error<TR>
<TD>paramErr<TD>-50<TD>Parameter error<TR>
<TD>memFullErr<TD>-108<TD>Not enough memory to speak<TR>
<TD>nilHandleErr<TD>-109<TD>Handle argument is <CODE>NIL</CODE><TR>
<TD>siUnknownInfoType<TD>-231<TD>Feature not implemented on synthesizer<TR>
<TD>noSynthFound<TD>-240<TD>Could not find the specified speech synthesizer<TR>
<TD>synthOpenFailed<TD>-241<TD>Could not open another speech synthesizer channel<TR>
<TD>synthNotReady<TD>-242<TD>Speech synthesizer is still busy speaking<TR>
<TD>bufTooSmall<TD>-243<TD>Output buffer is too small to hold result<TR>
<TD>voiceNotFound<TD>-244<TD>Voice resource not found<TR>
<TD>incompatibleVoice<TD>-245<TD>Specified voice cannot be used with synthesizer<TR>
<TD>badDictFormat<TD>-246<TD>Pronunciation dictionary format error<TR>
<TD>badPhonemeText<TD>-247<TD>Raw phoneme text contains invalid characters<TR>
<TD>unimplMsg<TD>-248<TD>Unimplemented message<TR>
<TD>badVoiceID<TD>-250<TD>Specified voice has not been preloaded<TR>
<TD>badParmCount<TD>-252<TD>Incorrect number of embedded command arguments<TR>
<TD>invalidComponentID<TD>-3000<TD>Speech channel is uninitialized or bad</TABLE>
</H2>
 <A NAME=MARKER-2-257></A><P>
</BLOCKQUOTE><P>
</DL>
</B>
</BLOCKQUOTE>
<HR>
<center>
<A HREF="Sound-264.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Sound-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Sound-336.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="Sound-266.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="Sound-3.html">&copy; Apple Computer, Inc.</A><br>2 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>  
