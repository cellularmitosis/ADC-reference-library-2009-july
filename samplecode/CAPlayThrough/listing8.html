<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>CAPlayThrough - /CAPlayThrough.cpp</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/MusicAudio/index.html">Audio</a> &gt; <a href="../../samplecode/MusicAudio/idxCoreAudio-date.html">Core Audio</a> &gt; <A HREF="javascript:location.replace('index.html');">CAPlayThrough</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->


	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">CAPlayThrough</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/CAPlayThrough.cpp</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/AudioDevice.cpp</option>
<option value="listing2.html">/AudioDevice.h</option>
<option value="listing3.html">/AudioDeviceList.cpp</option>
<option value="listing4.html">/AudioDeviceList.h</option>
<option value="listing5.html">/AudioRingBuffer2.cpp</option>
<option value="listing6.html">/AudioRingBuffer2.h</option>
<option value="listing7.html">/CABitOperations.h</option>
<option value="listing8.html">/CAPlayThrough.cpp</option>
<option value="listing9.html">/CAPlayThrough.h</option>
<option value="listing10.html">/CAPlayThroughController.h</option>
<option value="listing11.html">/CAPlayThroughController.mm</option>
<option value="listing12.html">/main.m</option>
<option value="listing13.html">/ReadMe.txt</option></select>
				</p>
				</form>
				<p><strong><a href="CAPlayThrough.zip">Download Sample</a></strong> (&#147;CAPlayThrough.zip&#148;, 83.5K)<BR>
<strong><a href="CAPlayThrough.dmg">Download Sample</a></strong> (&#147;CAPlayThrough.dmg&#148;, 128.7K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*  Copyright &copy; 2007 Apple Inc. All Rights Reserved.
  
  Disclaimer: IMPORTANT:  This Apple software is supplied to you by 
      Apple Inc. (&quot;Apple&quot;) in consideration of your agreement to the
      following terms, and your use, installation, modification or
      redistribution of this Apple software constitutes acceptance of these
      terms.  If you do not agree with these terms, please do not use,
      install, modify or redistribute this Apple software.
      
      In consideration of your agreement to abide by the following terms, and
      subject to these terms, Apple grants you a personal, non-exclusive
      license, under Apple's copyrights in this original Apple software (the
      &quot;Apple Software&quot;), to use, reproduce, modify and redistribute the Apple
      Software, with or without modifications, in source and/or binary forms;
      provided that if you redistribute the Apple Software in its entirety and
      without modifications, you must retain this notice and the following
      text and disclaimers in all such redistributions of the Apple Software. 
      Neither the name, trademarks, service marks or logos of Apple Inc. 
      may be used to endorse or promote products derived from the Apple
      Software without specific prior written permission from Apple.  Except
      as expressly stated in this notice, no other rights or licenses, express
      or implied, are granted by Apple herein, including but not limited to
      any patent rights that may be infringed by your derivative works or by
      other works in which the Apple Software may be incorporated.
      
      The Apple Software is provided by Apple on an &quot;AS IS&quot; basis.  APPLE
      MAKES NO WARRANTIES, EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION
      THE IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY AND FITNESS
      FOR A PARTICULAR PURPOSE, REGARDING THE APPLE SOFTWARE OR ITS USE AND
      OPERATION ALONE OR IN COMBINATION WITH YOUR PRODUCTS.
      
      IN NO EVENT SHALL APPLE BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL
      OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
      SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
      INTERRUPTION) ARISING IN ANY WAY OUT OF THE USE, REPRODUCTION,
      MODIFICATION AND/OR DISTRIBUTION OF THE APPLE SOFTWARE, HOWEVER CAUSED
      AND WHETHER UNDER THEORY OF CONTRACT, TORT (INCLUDING NEGLIGENCE),
      STRICT LIABILITY OR OTHERWISE, EVEN IF APPLE HAS BEEN ADVISED OF THE
      POSSIBILITY OF SUCH DAMAGE.
*/
/*=============================================================================
  CAPlayThrough.cpp
 
=============================================================================*/

#include &quot;CAPlayThrough.h&quot;

#pragma mark -- CAPlayThrough

// we define the class here so that is is not accessible from any object aside from CAPlayThroughManager
class CAPlayThrough 
{
public:
  CAPlayThrough(AudioDeviceID input, AudioDeviceID output);
  ~CAPlayThrough();
  
  OSStatus  Init(AudioDeviceID input, AudioDeviceID output);
  void    Cleanup();
  OSStatus  Start();
  OSStatus  Stop();
  Boolean    IsRunning();
  OSStatus  SetInputDeviceAsCurrent(AudioDeviceID in);
  OSStatus  SetOutputDeviceAsCurrent(AudioDeviceID out);
  
  AudioDeviceID GetInputDeviceID()  { return mInputDevice.mID;  }
  AudioDeviceID GetOutputDeviceID()  { return mOutputDevice.mID; }
  

private:
  OSStatus SetupGraph(AudioDeviceID out);
  OSStatus MakeGraph();
  
  OSStatus SetupAUHAL(AudioDeviceID in);
  OSStatus EnableIO();
  OSStatus CallbackSetup();
  OSStatus SetupBuffers();
  
  void ComputeThruOffset();
  
  static OSStatus InputProc(void *inRefCon,
                AudioUnitRenderActionFlags *ioActionFlags,
                const AudioTimeStamp *inTimeStamp,
                UInt32        inBusNumber,
                UInt32        inNumberFrames,
                AudioBufferList *    ioData);
  
  static OSStatus OutputProc(void *inRefCon,
                 AudioUnitRenderActionFlags *ioActionFlags,
                 const AudioTimeStamp *inTimeStamp,
                 UInt32        inBusNumber,
                 UInt32        inNumberFrames,
                 AudioBufferList *  ioData);
                      
  AudioUnit mInputUnit;
  AudioBufferList *mInputBuffer;
  AudioDevice mInputDevice, mOutputDevice;
  AudioRingBuffer *mBuffer;
  
  //AudioUnits and Graph
  AUGraph mGraph;
  AUNode mVarispeedNode;
  AudioUnit mVarispeedUnit;
  AUNode mOutputNode;
  AudioUnit mOutputUnit;
  
  //Buffer sample info
  Float64 mFirstInputTime;
  Float64 mFirstOutputTime;
  Float64 mInToOutSampleOffset;
};


#pragma mark ---Public Methods---


#pragma mark ---CAPlayThrough Methods---
CAPlayThrough::CAPlayThrough(AudioDeviceID input, AudioDeviceID output):
mBuffer(NULL),
mFirstInputTime(-1),
mFirstOutputTime(-1),
mInToOutSampleOffset(0)
{
  OSStatus err = noErr;
  err =Init(input,output);
    if(err) {
    fprintf(stderr,&quot;CAPlayThrough ERROR: Cannot Init CAPlayThrough&quot;);
    exit(1);
  }
}

CAPlayThrough::~CAPlayThrough()
{   
  Cleanup();
}

OSStatus CAPlayThrough::Init(AudioDeviceID input, AudioDeviceID output)
{
    OSStatus err = noErr;
  //Note: You can interface to input and output devices with &quot;output&quot; audio units.
  //Please keep in mind that you are only allowed to have one output audio unit per graph (AUGraph).
  //As you will see, this sample code splits up the two output units.  The &quot;output&quot; unit that will
  //be used for device input will not be contained in a AUGraph, while the &quot;output&quot; unit that will 
  //interface the default output device will be in a graph.
  
  //Setup AUHAL for an input device
  err = SetupAUHAL(input);
  checkErr(err);
  
  //Setup Graph containing Varispeed Unit &amp; Default Output Unit
  err = SetupGraph(output);  
  checkErr(err);
  
  err = SetupBuffers();
  checkErr(err);
  
  // the varispeed unit should only be conected after the input and output formats have been set
  err = AUGraphConnectNodeInput(mGraph, mVarispeedNode, 0, mOutputNode, 0);
  checkErr(err);
  
  err = AUGraphInitialize(mGraph); 
  checkErr(err);
  
  //Add latency between the two devices
  ComputeThruOffset();
    
  return err;  
}

void CAPlayThrough::Cleanup()
{
  //clean up
  Stop();
                  
  delete mBuffer;
  mBuffer = 0;
  if(mInputBuffer){
    for(UInt32 i = 0; i&lt;mInputBuffer-&gt;mNumberBuffers; i++)
      free(mInputBuffer-&gt;mBuffers[i].mData);
    free(mInputBuffer);
    mInputBuffer = 0;
  }
  
  AudioUnitUninitialize(mInputUnit);
  AUGraphClose(mGraph);
  DisposeAUGraph(mGraph);
}

#pragma mark --- Operation---

OSStatus CAPlayThrough::Start()
{
  OSStatus err = noErr;
  if(!IsRunning()){    
    //Start pulling for audio data
    err = AudioOutputUnitStart(mInputUnit);
    checkErr(err);
    
    err = AUGraphStart(mGraph);
    checkErr(err);
    
    //reset sample times
    mFirstInputTime = -1;
    mFirstOutputTime = -1;
  }
  return err;  
}

OSStatus CAPlayThrough::Stop()
{
  OSStatus err = noErr;
  if(IsRunning()){
    //Stop the AUHAL
    err = AudioOutputUnitStop(mInputUnit);
    err = AUGraphStop(mGraph);
    mFirstInputTime = -1;
    mFirstOutputTime = -1;
  }
  return err;
}

Boolean CAPlayThrough::IsRunning()
{  
  OSStatus err = noErr;
  UInt32 auhalRunning = 0, size = 0;
  Boolean graphRunning;
  size = sizeof(auhalRunning);
  if(mInputUnit)
  {
    err = AudioUnitGetProperty(mInputUnit,
                kAudioOutputUnitProperty_IsRunning,
                kAudioUnitScope_Global,
                0, // input element
                &amp;auhalRunning,
                &amp;size);
  }
  
  if(mGraph)
    err = AUGraphIsRunning(mGraph,&amp;graphRunning);
  
  return (auhalRunning || graphRunning);  
}


OSStatus CAPlayThrough::SetOutputDeviceAsCurrent(AudioDeviceID out)
{
    UInt32 size = sizeof(AudioDeviceID);;
    OSStatus err = noErr;
  
  if(out == kAudioDeviceUnknown) //Retrieve the default output device
  {
    err = AudioHardwareGetProperty(kAudioHardwarePropertyDefaultOutputDevice,
                     &amp;size,  
                     &amp;out);
  }
  mOutputDevice.Init(out, false);
  checkErr(err);
  
  //Set the Current Device to the Default Output Unit.
    err = AudioUnitSetProperty(mOutputUnit,
                kAudioOutputUnitProperty_CurrentDevice, 
                kAudioUnitScope_Global, 
                0, 
                &amp;mOutputDevice.mID, 
                sizeof(mOutputDevice.mID));
              
  return err;
}

OSStatus CAPlayThrough::SetInputDeviceAsCurrent(AudioDeviceID in)
{
    UInt32 size = sizeof(AudioDeviceID);
    OSStatus err = noErr;
  
  if(in == kAudioDeviceUnknown) //get the default input device if device is unknown
  {  
    err = AudioHardwareGetProperty(kAudioHardwarePropertyDefaultInputDevice,
                     &amp;size,  
                     &amp;in);
    checkErr(err);
  }
  
  mInputDevice.Init(in, true);
  
  //Set the Current Device to the AUHAL.
  //this should be done only after IO has been enabled on the AUHAL.
    err = AudioUnitSetProperty(mInputUnit,
                kAudioOutputUnitProperty_CurrentDevice, 
                kAudioUnitScope_Global, 
                0, 
                &amp;mInputDevice.mID, 
                sizeof(mInputDevice.mID));
  checkErr(err);
  return err;
}

#pragma mark -
#pragma mark --Private methods---
OSStatus CAPlayThrough::SetupGraph(AudioDeviceID out)
{
  OSStatus err = noErr;
  AURenderCallbackStruct output;
  
  //Make a New Graph
    err = NewAUGraph(&amp;mGraph);  
  checkErr(err);

  //Open the Graph, AudioUnits are opened but not initialized    
    err = AUGraphOpen(mGraph);
  checkErr(err);
  
  err = MakeGraph();
  checkErr(err);
    
  err = SetOutputDeviceAsCurrent(out);
  checkErr(err);
  
  //Tell the output unit not to reset timestamps 
  //Otherwise sample rate changes will cause sync los
  UInt32 startAtZero = 0;
  err = AudioUnitSetProperty(mOutputUnit, 
                kAudioOutputUnitProperty_StartTimestampsAtZero, 
                kAudioUnitScope_Global,
                0,
                &amp;startAtZero, 
                sizeof(startAtZero));
  checkErr(err);
  
  output.inputProc = OutputProc;
  output.inputProcRefCon = this;
  
  err = AudioUnitSetProperty(mVarispeedUnit, 
                kAudioUnitProperty_SetRenderCallback, 
                kAudioUnitScope_Input,
                0,
                &amp;output, 
                sizeof(output));
  checkErr(err);    
  
  return err;
}

OSStatus CAPlayThrough::MakeGraph()
{
  OSStatus err = noErr;
  ComponentDescription varispeedDesc,outDesc;
  
  //Q:Why do we need a varispeed unit?
  //A:If the input device and the output device are running at different sample rates
  //we will need to move the data coming to the graph slower/faster to avoid a pitch change.
  varispeedDesc.componentType = kAudioUnitType_FormatConverter;
  varispeedDesc.componentSubType = kAudioUnitSubType_Varispeed;
  varispeedDesc.componentManufacturer = kAudioUnitManufacturer_Apple;
  varispeedDesc.componentFlags = 0;        
  varispeedDesc.componentFlagsMask = 0;     
  
  outDesc.componentType = kAudioUnitType_Output;
  outDesc.componentSubType = kAudioUnitSubType_DefaultOutput;
  outDesc.componentManufacturer = kAudioUnitManufacturer_Apple;
  outDesc.componentFlags = 0;
  outDesc.componentFlagsMask = 0;
  
  //////////////////////////
  ///MAKE NODES
  //This creates a node in the graph that is an AudioUnit, using
  //the supplied ComponentDescription to find and open that unit  
  err = AUGraphNewNode(mGraph, &amp;varispeedDesc, 0, NULL, &amp;mVarispeedNode);
  checkErr(err);
  err = AUGraphNewNode(mGraph, &amp;outDesc, 0, NULL, &amp;mOutputNode);
  checkErr(err);
  
  //Get Audio Units from AUGraph node
  err = AUGraphGetNodeInfo(mGraph, mVarispeedNode, NULL, NULL, NULL, &amp;mVarispeedUnit);   
  checkErr(err);
  err = AUGraphGetNodeInfo(mGraph, mOutputNode, NULL, NULL, NULL, &amp;mOutputUnit);   
  checkErr(err);
  
  // don't connect nodes until the varispeed unit has input and output formats set

  return err;
}

OSStatus CAPlayThrough::SetupAUHAL(AudioDeviceID in)
{
  OSStatus err = noErr;
  
  Component comp;
  ComponentDescription desc;
  
  //There are several different types of Audio Units.
  //Some audio units serve as Outputs, Mixers, or DSP
  //units. See AUComponent.h for listing
  desc.componentType = kAudioUnitType_Output;
  
  //Every Component has a subType, which will give a clearer picture
  //of what this components function will be.
  desc.componentSubType = kAudioUnitSubType_HALOutput;
  
  //all Audio Units in AUComponent.h must use 
  //&quot;kAudioUnitManufacturer_Apple&quot; as the Manufacturer
  desc.componentManufacturer = kAudioUnitManufacturer_Apple;
  desc.componentFlags = 0;
  desc.componentFlagsMask = 0;
  
  //Finds a component that meets the desc spec's
  comp = FindNextComponent(NULL, &amp;desc);
  if (comp == NULL) exit (-1);
  
  //gains access to the services provided by the component
  OpenAComponent(comp, &amp;mInputUnit);  

  //AUHAL needs to be initialized before anything is done to it
  err = AudioUnitInitialize(mInputUnit);
  checkErr(err);
  
  err = EnableIO();
  checkErr(err);
  
  err= SetInputDeviceAsCurrent(in);
  checkErr(err);
  
  err = CallbackSetup();
  checkErr(err);
  
  //Don't setup buffers until you know what the 
  //input and output device audio streams look like.

  err = AudioUnitInitialize(mInputUnit);

  return err;
}

OSStatus CAPlayThrough::EnableIO()
{  
  OSStatus err = noErr;
  UInt32 enableIO;
  
  ///////////////
  //ENABLE IO (INPUT)
  //You must enable the Audio Unit (AUHAL) for input and disable output 
  //BEFORE setting the AUHAL's current device.
  
  //Enable input on the AUHAL
  enableIO = 1;
  err =  AudioUnitSetProperty(mInputUnit,
                kAudioOutputUnitProperty_EnableIO,
                kAudioUnitScope_Input,
                1, // input element
                &amp;enableIO,
                sizeof(enableIO));
  checkErr(err);
  
  //disable Output on the AUHAL
  enableIO = 0;
  err = AudioUnitSetProperty(mInputUnit,
                kAudioOutputUnitProperty_EnableIO,
                kAudioUnitScope_Output,
                0,   //output element
                &amp;enableIO,
                sizeof(enableIO));
  return err;
}

OSStatus CAPlayThrough::CallbackSetup()
{
  OSStatus err = noErr;
    AURenderCallbackStruct input;
  
    input.inputProc = InputProc;
    input.inputProcRefCon = this;
  
  //Setup the input callback. 
  err = AudioUnitSetProperty(mInputUnit, 
                kAudioOutputUnitProperty_SetInputCallback, 
                kAudioUnitScope_Global,
                0,
                &amp;input, 
                sizeof(input));
  checkErr(err);
  return err;
}

//Allocate Audio Buffer List(s) to hold the data from input.
OSStatus CAPlayThrough::SetupBuffers()
{
  OSStatus err = noErr;
  UInt32 bufferSizeFrames,bufferSizeBytes,propsize;
  
  CAStreamBasicDescription asbd,asbd_dev1_in,asbd_dev2_out;      
  Float64 rate=0;
  
  //Get the size of the IO buffer(s)
  UInt32 propertySize = sizeof(bufferSizeFrames);
  err = AudioUnitGetProperty(mInputUnit, kAudioDevicePropertyBufferFrameSize, kAudioUnitScope_Global, 0, &amp;bufferSizeFrames, &amp;propertySize);
  bufferSizeBytes = bufferSizeFrames * sizeof(Float32);
    
  //Get the Stream Format (Output client side)
  propertySize = sizeof(asbd_dev1_in);
  err = AudioUnitGetProperty(mInputUnit, kAudioUnitProperty_StreamFormat, kAudioUnitScope_Input, 1, &amp;asbd_dev1_in, &amp;propertySize);
  //printf(&quot;=====Input DEVICE stream format\n&quot; );  
  //asbd_dev1_in.Print();
  
  //Get the Stream Format (client side)
  propertySize = sizeof(asbd);
  err = AudioUnitGetProperty(mInputUnit, kAudioUnitProperty_StreamFormat, kAudioUnitScope_Output, 1, &amp;asbd, &amp;propertySize);    
  //printf(&quot;=====current Input (Client) stream format\n&quot;);  
  //asbd.Print();  

  //Get the Stream Format (Output client side)
  propertySize = sizeof(asbd_dev2_out);
  err = AudioUnitGetProperty(mOutputUnit, kAudioUnitProperty_StreamFormat, kAudioUnitScope_Output, 0, &amp;asbd_dev2_out, &amp;propertySize);
  //printf(&quot;=====Output (Device) stream format\n&quot;);  
  //asbd_dev2_out.Print();
  
  //////////////////////////////////////
  //Set the format of all the AUs to the input/output devices channel count
  //For a simple case, you want to set this to the lower of count of the channels
  //in the input device vs output device
  //////////////////////////////////////
  asbd.mChannelsPerFrame =((asbd_dev1_in.mChannelsPerFrame &lt; asbd_dev2_out.mChannelsPerFrame) ?asbd_dev1_in.mChannelsPerFrame :asbd_dev2_out.mChannelsPerFrame) ;
  //printf(&quot;Info: Input Device channel count=%ld\t Input Device channel count=%ld\n&quot;,asbd_dev1_in.mChannelsPerFrame,asbd_dev2_out.mChannelsPerFrame);  
  //printf(&quot;Info: CAPlayThrough will use %ld channels\n&quot;,asbd.mChannelsPerFrame);  

  
  // We must get the sample rate of the input device and set it to the stream format of AUHAL
  propertySize = sizeof(Float64);
  AudioDeviceGetProperty(mInputDevice.mID, 0, 1, kAudioDevicePropertyNominalSampleRate, &amp;propertySize, &amp;rate);
  asbd.mSampleRate =rate;
  propertySize = sizeof(asbd);
  
  //Set the new formats to the AUs...
  err = AudioUnitSetProperty(mInputUnit, kAudioUnitProperty_StreamFormat, kAudioUnitScope_Output, 1, &amp;asbd, propertySize);
  checkErr(err);  
  err = AudioUnitSetProperty(mVarispeedUnit, kAudioUnitProperty_StreamFormat, kAudioUnitScope_Input, 0, &amp;asbd, propertySize);
  checkErr(err);
  
  //Set the correct sample rate for the output device, but keep the channel count the same
  propertySize = sizeof(Float64);
  AudioDeviceGetProperty(mOutputDevice.mID, 0, 0, kAudioDevicePropertyNominalSampleRate, &amp;propertySize, &amp;rate);
  asbd.mSampleRate =rate;
  propertySize = sizeof(asbd);
  //Set the new audio stream formats for the rest of the AUs...
  err = AudioUnitSetProperty(mVarispeedUnit, kAudioUnitProperty_StreamFormat, kAudioUnitScope_Output, 0, &amp;asbd, propertySize);
  checkErr(err);  
  err = AudioUnitSetProperty(mOutputUnit, kAudioUnitProperty_StreamFormat, kAudioUnitScope_Input, 0, &amp;asbd, propertySize);
  checkErr(err);

  //calculate number of buffers from channels
  propsize = offsetof(AudioBufferList, mBuffers[0]) + (sizeof(AudioBuffer) *asbd.mChannelsPerFrame);

  //malloc buffer lists
  mInputBuffer = (AudioBufferList *)malloc(propsize);
  mInputBuffer-&gt;mNumberBuffers = asbd.mChannelsPerFrame;
  
  //pre-malloc buffers for AudioBufferLists
  for(UInt32 i =0; i&lt; mInputBuffer-&gt;mNumberBuffers ; i++) {
    mInputBuffer-&gt;mBuffers[i].mNumberChannels = 1;
    mInputBuffer-&gt;mBuffers[i].mDataByteSize = bufferSizeBytes;
    mInputBuffer-&gt;mBuffers[i].mData = malloc(bufferSizeBytes);
  }
  
  //Alloc ring buffer that will hold data between the two audio devices
  mBuffer = new AudioRingBuffer();  
  mBuffer-&gt;Allocate(asbd.mChannelsPerFrame, asbd.mBytesPerFrame, bufferSizeFrames * 20);
  
    return err;
}

void  CAPlayThrough::ComputeThruOffset()
{
  //The initial latency will at least be the saftey offset's of the devices + the buffer sizes
  mInToOutSampleOffset = SInt32(mInputDevice.mSafetyOffset +  mInputDevice.mBufferSizeFrames +
            mOutputDevice.mSafetyOffset + mOutputDevice.mBufferSizeFrames);
}

#pragma mark -
#pragma mark -- IO Procs --
OSStatus CAPlayThrough::InputProc(void *inRefCon,
                  AudioUnitRenderActionFlags *ioActionFlags,
                  const AudioTimeStamp *inTimeStamp,
                  UInt32 inBusNumber,
                  UInt32 inNumberFrames,
                  AudioBufferList * ioData)
{
    OSStatus err = noErr;
  
  CAPlayThrough *This = (CAPlayThrough *)inRefCon;
  if (This-&gt;mFirstInputTime &lt; 0.)
    This-&gt;mFirstInputTime = inTimeStamp-&gt;mSampleTime;
    
  //Get the new audio data
  err = AudioUnitRender(This-&gt;mInputUnit,
             ioActionFlags,
             inTimeStamp, 
             inBusNumber,     
             inNumberFrames, //# of frames requested
             This-&gt;mInputBuffer);// Audio Buffer List to hold data
  checkErr(err);
    
  if(!err)
    err = This-&gt;mBuffer-&gt;Store(This-&gt;mInputBuffer, Float64(inNumberFrames), SInt64(inTimeStamp-&gt;mSampleTime));
  
  return err;
}

inline void MakeBufferSilent (AudioBufferList * ioData)
{
  for(UInt32 i=0; i&lt;ioData-&gt;mNumberBuffers;i++)
    memset(ioData-&gt;mBuffers[i].mData, 0, ioData-&gt;mBuffers[i].mDataByteSize);  
}

OSStatus CAPlayThrough::OutputProc(void *inRefCon,
                   AudioUnitRenderActionFlags *ioActionFlags,
                   const AudioTimeStamp *TimeStamp,
                   UInt32 inBusNumber,
                   UInt32 inNumberFrames,
                   AudioBufferList * ioData)
{
    OSStatus err = noErr;
  CAPlayThrough *This = (CAPlayThrough *)inRefCon;
  Float64 rate = 0.0;
  AudioTimeStamp inTS, outTS;

  if (This-&gt;mFirstInputTime &lt; 0.) {
    // input hasn't run yet -&gt; silence
    MakeBufferSilent (ioData);
    return noErr;
  }
  
  //use the varispeed playback rate to offset small discrepancies in sample rate
  //first find the rate scalars of the input and output devices
  err = AudioDeviceGetCurrentTime(This-&gt;mInputDevice.mID, &amp;inTS);
  // this callback may still be called a few times after the device has been stopped
  if (err)
  {
    MakeBufferSilent (ioData);
    return noErr;
  }
    
  err = AudioDeviceGetCurrentTime(This-&gt;mOutputDevice.mID, &amp;outTS);
  checkErr(err);
  
  rate = inTS.mRateScalar / outTS.mRateScalar;
  err = AudioUnitSetParameter(This-&gt;mVarispeedUnit,kVarispeedParam_PlaybackRate,kAudioUnitScope_Global,0, rate,0);
  checkErr(err);
  
  //get Delta between the devices and add it to the offset
  if (This-&gt;mFirstOutputTime &lt; 0.) {
    This-&gt;mFirstOutputTime = TimeStamp-&gt;mSampleTime;
    Float64 delta = (This-&gt;mFirstInputTime - This-&gt;mFirstOutputTime);
    This-&gt;ComputeThruOffset();   
    //changed: 3865519 11/10/04
    if (delta &lt; 0.0)
      This-&gt;mInToOutSampleOffset -= delta;
    else
      This-&gt;mInToOutSampleOffset = -delta + This-&gt;mInToOutSampleOffset;
          
    MakeBufferSilent (ioData);
    return noErr;
  }

  //copy the data from the buffers  
  err = This-&gt;mBuffer-&gt;Fetch(ioData,inNumberFrames, SInt64(TimeStamp-&gt;mSampleTime - This-&gt;mInToOutSampleOffset));  
  if(err != 0) // kAudioRingBufferError_WayBehind)
  {
    MakeBufferSilent (ioData);
    SInt64 bufferStartTime, bufferEndTime;
    This-&gt;mBuffer-&gt;GetTimeBounds(bufferStartTime, bufferEndTime);
    This-&gt;mInToOutSampleOffset = TimeStamp-&gt;mSampleTime - bufferStartTime;
  }

  return noErr;
}

#pragma mark -- Listeners --

OSStatus CAPlayThroughHost::StreamListener( AudioStreamID         inStream,
                      UInt32                  inChannel,
                      AudioDevicePropertyID   inPropertyID,
                      void*                   inClientData)
{  
  CAPlayThroughHost *This = (CAPlayThroughHost *)inClientData;
  This-&gt;ResetPlayThrough();  
  return noErr;    
}

#pragma mark -                  
#pragma mark -- CAPlayThroughHost Methods --

CAPlayThroughHost::CAPlayThroughHost(AudioDeviceID input, AudioDeviceID output):
  mPlayThrough(NULL)
{
  CreatePlayThrough(input, output);
}

CAPlayThroughHost::~CAPlayThroughHost()
{
  DeletePlayThrough();
}

void CAPlayThroughHost::CreatePlayThrough(AudioDeviceID input, AudioDeviceID output)
{
  mPlayThrough = new CAPlayThrough(input, output);
  AddDeviceListeners(input);
}

void CAPlayThroughHost::DeletePlayThrough()
{
  if(mPlayThrough)
  {
    mPlayThrough-&gt;Stop();
    RemoveDeviceListeners(mPlayThrough-&gt;GetInputDeviceID());
    delete mPlayThrough;
    mPlayThrough = NULL;
  }
}

void CAPlayThroughHost::ResetPlayThrough ()
{
  
  AudioDeviceID input = mPlayThrough-&gt;GetInputDeviceID();
  AudioDeviceID output = mPlayThrough-&gt;GetOutputDeviceID();

  DeletePlayThrough();
  CreatePlayThrough(input, output);
  mPlayThrough-&gt;Start();
}

bool CAPlayThroughHost::PlayThroughExists()
{
  return (mPlayThrough != NULL) ? true : false;
}

OSStatus  CAPlayThroughHost::Start()
{
  if (mPlayThrough) return mPlayThrough-&gt;Start();
  return noErr;
}

OSStatus  CAPlayThroughHost::Stop()
{
  if (mPlayThrough) return mPlayThrough-&gt;Stop();
  return noErr;
}

Boolean    CAPlayThroughHost::IsRunning()
{
  if (mPlayThrough) return mPlayThrough-&gt;IsRunning();
  return noErr;
}

void CAPlayThroughHost::AddDeviceListeners(AudioDeviceID input)
{
    // StreamListener is called whenever the sample rate changes (as well as other format characteristics of the device)
  UInt32 propSize;
  OSStatus err = AudioDeviceGetPropertyInfo(input, 0, true, kAudioDevicePropertyStreams, &amp;propSize, NULL);
  if(!err)
  {
    AudioStreamID *streams = (AudioStreamID*)malloc(propSize);  
    err = AudioDeviceGetProperty(input, 0, true, kAudioDevicePropertyStreams, &amp;propSize, streams);
    
    if(!err);
    {
      UInt32 numStreams = propSize / sizeof(AudioStreamID);
      for(UInt32 i=0; i &lt; numStreams; i++)
      {
        UInt32 isInput;
        propSize = sizeof(UInt32);
        err = AudioStreamGetProperty(streams[i], 0, kAudioStreamPropertyDirection, &amp;propSize, &amp;isInput);
        if(!err &amp;&amp; isInput);
          err = AudioStreamAddPropertyListener(streams[i], 0, kAudioStreamPropertyPhysicalFormat, StreamListener, this);
      }
    }
  }
}

void CAPlayThroughHost::RemoveDeviceListeners(AudioDeviceID input)
{
  UInt32 propSize;
  OSStatus err = AudioDeviceGetPropertyInfo(input, 0, true, kAudioDevicePropertyStreams, &amp;propSize, NULL);
  if(!err)
  {
    AudioStreamID *streams = (AudioStreamID*)malloc(propSize);  
    err = AudioDeviceGetProperty(input, 0, true, kAudioDevicePropertyStreams, &amp;propSize, streams);
    if(!err)
    {
      UInt32 numStreams = propSize / sizeof(AudioStreamID);
      for(UInt32 i=0; i &lt; numStreams; i++)
      {
        UInt32 isInput;
        propSize = sizeof(UInt32);
        err = AudioStreamGetProperty(streams[i], 0, kAudioStreamPropertyDirection, &amp;propSize, &amp;isInput);
        if(!err &amp;&amp; isInput)
          err = AudioStreamRemovePropertyListener(streams[i], 0, kAudioStreamPropertyPhysicalFormat, StreamListener);
      }
    }
  }
}
</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/CAPlayThrough/listing8.html%3Fid%3DDTS10004443-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/CAPlayThrough/listing8.html%3Fid%3DDTS10004443-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/CAPlayThrough/listing8.html%3Fid%3DDTS10004443-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>