<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"			"http://www.w3.org/TR/REC-html40/loose.dtd"><HTML><!-- Template 01-05-01 --><head><LINK REL="stylesheet" HREF="../../adcstyle.css" TYPE="text/css"><LINK REL="stylesheet" HREF="../../style.css" TYPE="text/css">   <title>Technical Note TN1122: Locking and Unlocking Handles</title>       <meta name="keywords" content="Mac OS 8 Memory Manager locking   HLock HUnlock unlocking handles">    <meta name="Description" content="Technical Note TN1122: This Technical Note s addressed todevelopers who manipulate Memory Manager handles, and inparticular those who lock and unlock them. It explains whyand when handles need to be locked and how and when to preservethe state of a handle to avoid erroneously unlocking it."><meta name="categories" content="Memory"><meta name="week-posted" content="Jan 26, 1998 - Feb 6, 1998"><LINK REL="stylesheet" HREF="../../css/adcstyle.css" TYPE="text/css"><script language="JavaScript" type="text/javascript" src="../../js/adc.js"></script></HEAD><BODY BGCOLOR="#FFFFFF"><a name="//apple_ref/doc/uid/DTS10002962" title="Locking and Unlocking Handles"></a><A NAME="top"></A><!-- begin_header_information --><!--#include virtual="/adcnavbar" --><p><a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../technicalnotes/index.html">Technical Notes</a> &gt; <a href="../../technicalnotes/Carbon/index.html">Carbon</a> &gt; <a href="../../technicalnotes/Carbon/idxProcessManagement-date.html">Process Management</a> &gt; </p><div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Not Recommended Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>The information in this document is <strong>Not Recommended</strong> and should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="../../referencelibrary/Carbon/idxProcessManagement-date.html" target="_blank">Carbon > Process Management</a></li>
	</ul>
</div>




</div></div></div><!-- end_header_information --><!-- bottom_of_header_marker_comment --><!-- top_of_titles_marker_comment --><CENTER><table width="600" cellpadding="0" cellspacing="0" border="0">
<tr><td align="left" scope="row">
<h1>
<div id="pagehead">Technical Note TN1122</div>
<div id="pageheadsub">Locking and Unlocking Handles</div>
</h1>
</td></tr></table></CENTER><!-- bottom_of_titles_marker_comment --><center><TABLE BORDER=0 CELLSPACING=1 WIDTH=600><TR><td align="left">          <!-- begin_header_box --><table width="600" cellpadding="0" cellspacing="0" border="0">    <tr>        <td width=300 valign="top" align=left scope="row">            <table border="0" width="300" cellpadding="0" cellspacing="0">			<tr>                        <td width=300 align=left> <img src="images/tnmenutop.gif" alt="" align="bottom" width=300 height=7></td>                </tr>                <tr bgcolor="#e6e6e6">                    <td background="images/tnmenubody.gif" width=300 align=left>                        <span id="menutitle">                            CONTENTS                             <br>                            <br>                        </span>                    </td>                </tr>                <tr bgcolor="#e6e6e6">                    <td background="images/tnmenubody.gif" width=300 align=left><!-- begin_toc --><P id = "menutext"><A HREF = "#intro">The Basics</A><BR><BR>                  <A HREF = "#problem">The Problem</A><BR><BR>                  <A HREF = "#solution">The         Solution</A></p>                  <p id = "menutext2"><A HREF = "#technique1">Technique #1</A><BR><BR>                  <A HREF = "#technique2">Technique         #2</A></p>         <P id = "menutext"><A HREF = "#exceptions">Exceptions</A></p>         <P id = "menutext2"><A HREF = "#nolock">Don't Lock the Handle</A><BR><BR>         	<A HREF = "#exclusive">Exclusive         Access</A></p>         <P id = "menutext"><A HREF = "#Summary">Summary</A><BR><BR><A HREF="#References">References</A><BR><BR>         <A HREF="#Changes">Change History</A><BR><BR>         <A HREF="#Downloads">Downloadables</A></p>                   <!-- end_toc -->                  </td>                </tr>                <tr>                    <td width=300 align=left scope="row">                        <img src="images/tnmenubottom.gif" alt="" width=300 height=16>                    </td>                </tr>            </table>        </td>        <td width=300 valign="top" align=left>            			<!-- begin_intro_text -->         <P id="introtext">This Technote is         addressed to developers who manipulate         <a href="../../documentation/mac/Memory/Memory-56.html#HEADING56-0">Memory         Manager</A> handles, and in particular those who lock and         unlock them. It explains why and when handles need to be         locked and how and when to preserve the state of a handle to         avoid erroneously unlocking it.</P>                  <P id="introtext">After the discovery of a subtle bug (in both Apple and         third-party code) having to do with the erroneous unlocking         of handles, DTS recently conducted an exhaustive search of         developer documentation for an unequivocal and complete         statement about proper methods for locking and unlocking         handles. Since no such documentation could be found, this         Technote now serves as that statement.</P><!-- end_intro_text --><!-- begin_date --><h3>&nbsp;Updated: [Apr 13 1998]</h3><!-- end_date -->        </td>    </tr></table> <!-- end_header_box --><BR><BR><hr width=500 align=center><BR><BR><!-- begin_content --><H2><A NAME="intro"></A>The Basics</H2><P>A handle refers to one kind of memory block created and maintainedby the<a href="../../documentation/mac/Memory/Memory-56.html#HEADING56-0">MemoryManager</A>. Because a handle is an indirect reference (namely, apointer to a pointer) to a block, the<a href="../../documentation/mac/Memory/Memory-56.html#HEADING56-0">MemoryManager</A> is free to move such blocks at certain well-definedtimes. The pointer to which a handle points is called a masterpointer. When a handle block moves, the<a href="../../documentation/mac/Memory/Memory-56.html#HEADING56-0">MemoryManager</A> changes the master pointer, not the handle. (For a moredetailed review, check the<a href="../../documentation/mac/Memory/Memory-11.html#HEADING11-0">HeapManagement</A> section of the<a href="../../documentation/mac/Memory/Memory-9.html">Introductionto Memory Management</A> chapter of<I><a href="../../documentation/mac/Memory/Memory-2.html">InsideMacintosh: Memory</A></I>).</P><P>There are times at which a handle needs to be locked. If a programneeds to pass a master pointer (or a pointer to bytes inside a handle block) to a routine which canmove memory (that is, a routine which calls the<a href="../../documentation/mac/Memory/Memory-56.html#HEADING56-0">MemoryManager</A>, directly or indirectly, in a way which might causememory to move), the handle must be locked.A simple example is the first parameter to<CODE><a href="../../documentation/mac/Memory/Memory-108.html">PtrAndHand</A></CODE>.A slightly more complex example is any call to<CODE><a href="../../documentation/mac/Toolbox/Toolbox-228.html#HEADING228-0">NewWindow</A></CODE>.Finally, a subtle example of a routine which moves memory is onewhose implementation does not move memory but whose mere invocationdoes. Calling a routine which resides in an unloaded segment resourcemay cause handle blocks to move when the segment loads. (For details,see the<a href="../../documentation/mac/Memory/Memory-11.html#HEADING11-10">LoadingCode Segments</A> section of the<a href="../../documentation/mac/Memory/Memory-9.html">Introductionto Memory Management</A> chapter of<I><a href="../../documentation/mac/Memory/Memory-2.html">InsideMacintosh: Memory</A></I> and the<a href="../../documentation/mac/Processes/Processes-135.html">SegmentManager</A> chapter of<I><a href="../../documentation/mac/Processes/Processes-2.html">InsideMacintosh: Processes</A></I>.)</P><P>Since leaving a handle locked indefinitely may prevent the<a href="../../documentation/mac/Memory/Memory-56.html#HEADING56-0">MemoryManager</A> from relocating other blocks optimally, it is desirableto unlock a handle when it is no longer necessary for the handle tobe locked. However, it's dangerous to unlock a handle withoutunderstanding all the implications, even in many simple cases. It'smore dangerous to unlock a handle your program does not own.</P><BR><P><A HREF="#top">Back to top</A></P><H2><A NAME="problem"></A>The Problem</H2><P>The problem is that the<a href="../../documentation/mac/Memory/Memory-56.html#HEADING56-0">MemoryManager</A> does not track the number of times a handle has beenlocked. A handle is either locked or unlocked. If a program locks ahandle twice and then unlocks it once, the handle is unlocked. Thismeans that non-trivial programs cannot simply balance lock and unlockoperations. Here's an example of how <B>not</B> to maintain a lock ona handle:</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>static pascal OSErr Unsafe_DoSomethingToHandle (Handle h){    OSErr err = noErr;&nbsp;    <a href="../../documentation/mac/Memory/Memory-88.html#HEADING88-0">HLock</A> (h);&nbsp;    if (!(err = <a href="../../documentation/mac/Memory/Memory-116.html#HEADING116-0">MemError</A> ( )))    {        err = DoSomethingToPointer (*h);&nbsp;        <a href="../../documentation/mac/Memory/Memory-89.html#HEADING89-0">HUnlock</A> (h); // Danger, Will Robinson!&nbsp;        if (!err)            err = <a href="../../documentation/mac/Memory/Memory-116.html#HEADING116-0">MemError</A> ( );    }&nbsp;    return err;}</pre></TD></TR></TABLE></CENTER><BR><BR><P>If the caller of <CODE>Unsafe_DoSomethingToHandle</CODE> haslocked the parameter handle and expects it to stay locked, theprogram is in for a nasty surprise. Even though the caller has lockedthe handle it passes to <CODE>Unsafe_DoSomethingToHandle</CODE>, thecall to<CODE><a href="../../documentation/mac/Memory/Memory-89.html#HEADING89-0">HUnlock</A></CODE>in <CODE>Unsafe_DoSomethingToHandle</CODE> will undo the lock.</P><P>There are, of course, cases which are more difficult to debug.Sometimes the software that needs the handle to stay locked is notthe direct caller, but another function the caller calls, or evenpart of the system. For an example of this last case, see<A HREF = "tn1118.html">Technote1118</A>,"<A HREF = "tn1118.html">UnlockingGDHandles Considered Harmful</A>".</P><BR><P><A HREF="#top">Back to top</A></P><H2><A NAME="solution"></A>The Solution</H2><P>The general solution is to make sure the handle state is preservedby the function (or code sequence within a function).</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>IMPORTANT:</B><BR>         		If you always preserve the handle state, you will always         be safe. There are times when preserving the handle state         may be unnecessary and sub-optimal. However, it's essential         to precisely understand if and why a given case is safe         before you choose not to preserve a handle's state. (More         about these exceptional cases later. If you are a defensive         programmer and would prefer to be in the habit of writing         safe code every time, feel free to ignore the exceptional         cases.)</P></TD></TR></TABLE></CENTER><BR><BR><P>The handle state is a collection of bit flags maintained for eachhandle by the<a href="../../documentation/mac/Memory/Memory-56.html#HEADING56-0">MemoryManager</A>. One of the state flags describes whether the handle islocked. Programs can obtain the state of a handle by calling<CODE><a href="../../documentation/mac/Memory/Memory-86.html#HEADING86-0">HGetState</A></CODE>.All of the techniques listed below use<CODE><a href="../../documentation/mac/Memory/Memory-86.html#HEADING86-0">HGetState</A></CODE>in some way.</P><P><A href="#top">Back to top</A></P><H3><A NAME="technique1"></A>Technique#1</H3><P>The simplest technique is to save the entire handle state, lockthe handle, and then restore the entire handle state. This means thatthe bit which represents whether the handle is locked has the samevalue before and after the code runs, so if the handle is lockedbefore the code runs, it stays locked, and if the handle is unlockedbefore the code runs, it stays unlocked. Here's a typical sequence ofcalls:</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>static pascal OSErr SafeOne_DoSomethingToHandle (Handle h){    OSErr err = noErr;&nbsp;    SInt8 hState = <a href="../../documentation/mac/Memory/Memory-86.html#HEADING86-0">HGetState</A> (h);&nbsp;    if (!(err = <a href="../../documentation/mac/Memory/Memory-116.html#HEADING116-0">MemError</A> ( )))    {        <a href="../../documentation/mac/Memory/Memory-88.html#HEADING88-0">HLock</A> (h);&nbsp;        if (!(err = <a href="../../documentation/mac/Memory/Memory-116.html#HEADING116-0">MemError</A> ( )))        {            err = DoSomethingToLockedHandle (h);&nbsp;            <a href="../../documentation/mac/Memory/Memory-87.html#HEADING87-0">HSetState</A> (h,hState);&nbsp;            if (!err)                err = <a href="../../documentation/mac/Memory/Memory-116.html#HEADING116-0">MemError</A> ( );        }    }&nbsp;    return err;}</pre></TD></TR></TABLE></CENTER><BR><BR><P>This technique is reasonably safe. The disadvantage is that itsaves and restores the <B>entire</B> handle state. If the function<CODE>DoSomethingToLockedHandle</CODE> changes any of the otherhandle state flags (for example, the flag which controls the handle'spurgeability), the call to<CODE><a href="../../documentation/mac/Memory/Memory-87.html#HEADING87-0">HSetState</A></CODE>will wipe out the change.</P><BR><P><A HREF="#top">Back to top</A></P><H3><A NAME="technique2"></A>Technique#2</H3><P>A slightly more complicated technique involves testing the handlestate to see if the handle is locked and then locking and unlockingit only if needed. Here's a typical sequence of calls:</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>enum { kHandleLockMask = 0x80 }; // absent from &lt;MacMemory.h&gt; 3.0.1&nbsp;static pascal OSErr SafeTwo_DoSomethingToHandle (Handle h){    OSErr err = noErr;&nbsp;    SInt8 hState = <a href="../../documentation/mac/Memory/Memory-86.html#HEADING86-0">HGetState</A> (h);&nbsp;    if (!(err = <a href="../../documentation/mac/Memory/Memory-116.html#HEADING116-0">MemError</A> ( )))    {        Boolean handleWasLocked =              (kHandleLockMask &amp; hState) ? true : false;&nbsp;        if (!handleWasLocked)        {            <a href="../../documentation/mac/Memory/Memory-88.html#HEADING88-0">HLock</A> (h);            err = <a href="../../documentation/mac/Memory/Memory-116.html#HEADING116-0">MemError</A> ( );        }&nbsp;        if (!err)        {            err = DoSomethingToLockedHandle (h);&nbsp;            if (!handleWasLocked)            {                <a href="../../documentation/mac/Memory/Memory-89.html#HEADING89-0">HUnlock</A> (h);&nbsp;                if (!err)                    err = <a href="../../documentation/mac/Memory/Memory-116.html#HEADING116-0">MemError</A> ( );            }        }    }&nbsp;    return err;}</pre></TD></TR></TABLE></CENTER><BR><BR><P>This sequence avoids the problem that a stale handle state mightbe restored following the call to<CODE>DoSomethingToLockedHandle</CODE>. The disadvantage here is therelative complexity. This is the kind of code that nobody likes tothink carefully about (well, perhaps nobody but DTS geeks), and ifyou must lock and unlock a lot of different handles, it's likely thatbugs will creep in somewhere.</P><P>One way to avoid this kind of risky tedium is to wrap the logic upin a C++ class whose constructor locks the handle (if necessary) andwhose destructor unlocks the handle (if necessary). This extra layerof wrapping on <A HREF = "#technique2">Technique #2</A> even relievesyou of having to write code for error-handling and exceptions, sincethe handle will be unlocked, if appropriate, whenever the lock objectfalls out of scope.</P><BR><P><A HREF="#top">Back to top</A></P><H2><A NAME="exceptions"></A>ExceptionalCases</H2><P>There are, of course, cases in which you can avoid saving andrestoring a handle's state. You may, during the optimization phase ofyour development, want to look for cases in which you can do this, toavoid code bloat and if you find you are making "too many" (whateverthat means for your program)<a href="../../documentation/mac/Memory/Memory-56.html#HEADING56-0">MemoryManager</A> calls in a tight loop. Be sure to measure before assumingyou must optimize. Also: be safe, then fast.</P><BR><P><A HREF="#top">Back to top</A></P><H3><A NAME="nolock"></A>Don't Lock theHandle</H3><P>Sometimes you can avoid saving the handle state by not locking ahandle. This seems like an obvious statement, but, many times, codelocks handles when it doesn't need to. Make sure you understand justwhen the<a href="../../documentation/mac/Memory/Memory-56.html#HEADING56-0">MemoryManager</A> can move relocatable blocks (perhaps implicitly via someother Manager which calls<a href="../../documentation/mac/Memory/Memory-56.html#HEADING56-0">MemoryManager</A>). For example, DTS commonly sees developer code whichlooks something like this:</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>static pascal OSErr UnnecessaryHandleLock (Handle h){    OSErr err = noErr;&nbsp;    SInt8 hState = <a href="../../documentation/mac/Memory/Memory-86.html#HEADING86-0">HGetState</A> (h);&nbsp;    if (!(err = <a href="../../documentation/mac/Memory/Memory-116.html#HEADING116-0">MemError</A> ( )))    {        <a href="../../documentation/mac/Memory/Memory-88.html#HEADING88-0">HLock</A> (h);&nbsp;        if (!(err = <a href="../../documentation/mac/Memory/Memory-116.html#HEADING116-0">MemError</A> ( )))        {            **h = 12; // we locked 'h' for <B>this</B>?&nbsp;            <a href="../../documentation/mac/Memory/Memory-87.html#HEADING87-0">HSetState</A> (h,hState);            err = <a href="../../documentation/mac/Memory/Memory-116.html#HEADING116-0">MemError</A> ( );        }    }&nbsp;    return err;}</pre></TD></TR></TABLE></CENTER><BR><BR><P>In addition to taking advantage of situations which don't requireyou to lock a handle, you can also deliberately go out of your way toavoid locking it. If you need to modify a small portion of a handleblock, you can copy the appropriate bytes into a variable, modify thevariable, and copy the variable back into place within the handle.For example:</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>static pascal OSErr AvoidHandleLock (Handle h){    OSErr err = noErr;&nbsp;    char c = **h;&nbsp;    err = DoSomethingToCharacter (&amp;c);&nbsp;    if (!err)        **h = c;&nbsp;    return err;}</pre></TD></TR></TABLE></CENTER><BR><BR><P><A NAME="top">Back to top</A></P><H3><A NAME="exclusive"></A>ExclusiveAccess</H3><P>If a well-defined part of your code has exclusive access to ahandle, that code can lock and unlock handles at will.</P><P>Perhaps you have a code module which is responsible for managingsome handle-based buffers which are "hidden" from the module'scallers inside an opaque data type. In this case, your code allocatedthe handles and is solely responsible for them throughout theirentire lifetime, thus your code can manipulate those handles any wayit likes.</P><P>Another example might be a function which needs to allocate atemporary buffer (and, to avoid the obvious memory leak, dispose thebuffer as the function exits). Since it's safe to pass a lockedhandle to<CODE><a href="../../documentation/mac/Memory/Memory-73.html#HEADING73-0">DisposeHandle</A></CODE>,even though<CODE><a href="../../documentation/mac/Memory/Memory-67.html#HEADING67-0">NewHandle</A></CODE>produces an unlocked handle, a code sequence like this one isperfectly acceptable:</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>static pascal OSErr SafeThree_DoSomethingToHandle (void){    OSErr err = noErr;&nbsp;    Handle h = <a href="../../documentation/mac/Memory/Memory-67.html#HEADING67-0">NewHandle</A> (12);&nbsp;    if (!h)        err = <a href="../../documentation/mac/Memory/Memory-116.html#HEADING116-0">MemError</A> ( );    else    {        <a href="../../documentation/mac/Memory/Memory-88.html#HEADING88-0">HLock</A> (h);        err = <a href="../../documentation/mac/Memory/Memory-116.html#HEADING116-0">MemError</A> ( );&nbsp;        if (!err)            err = DoSomethingToLockedHandle (h);&nbsp;        <a href="../../documentation/mac/Memory/Memory-73.html#HEADING73-0">DisposeHandle</A> (h);&nbsp;        if (!err)            err = <a href="../../documentation/mac/Memory/Memory-116.html#HEADING116-0">MemError</A> ( );    }&nbsp;    return err;}</pre></TD></TR></TABLE></CENTER><BR><BR><BR><P><A HREF="#top">Back to top</A></P><H2><A NAME="Summary"></A>Summary</H2><P>It's generally not safe to preserve a handle's lock state simplyby balancing calls to<a href="../../documentation/mac/Memory/Memory-88.html#HEADING88-0">HLock</A>and<a href="../../documentation/mac/Memory/Memory-89.html#HEADING89-0">HUnlock</A>.In most cases, you should instead preserve the handle state. In theremaining cases, you need to fully understand the implications of notpreserving the handle state. In fact, if safety is of utmostimportance to you, you can't go wrong by always using one of thehandle state preservation techniques illustrated in this Technote.</P><BR><P><A HREF="#top">Back to top</A></P><A NAME="References"></A><H2>References</H2><P>The   <a href="../../documentation/mac/Memory/Memory-56.html#HEADING56-0">Memory   Manager</A> chapter in   <I><a href="../../documentation/mac/Memory/Memory-2.html">Inside   Macintosh: Memory</A></i></p>      <p>The   <a href="../../documentation/mac/Processes/Processes-135.html">Segment   Manager</A> chapter of   <I><a href="../../documentation/mac/Processes/Processes-2.html">Inside   Macintosh: Processes</A></i></p><BR><P><A HREF="#top">Back to top</A></P><H3>Acknowledgements</H3><P>Major funding provided by the Handle State Preservation Society.</P><BR><P><A HREF="#top">Back to top</A></P><A NAME="Changes"></A><H2>Change history:</H2><TABLE BORDER=0 CELLPADDING=3 WIDTH=544>            <TR>               <td width=100 align=left>                  <P ALIGN=center>02/09/98</P>               </TD>               <td align="left">                  <P>Initial version.</P>               </TD>            </TR>            <TR>				<td width=100 align=left>                  <P ALIGN=center>02/13/98</P>               </TD>               <td align="left">                  <P>Clarified examples of system calls which         move memory.</P>               </TD>            </TR>     </TABLE><BR><P><A HREF="#top">Back to top</A></P>        <A NAME="Downloads"></A>         <br><h2>Downloadables</h2>        <center><TABLE BORDER=0 CELLPADDING=3 WIDTH="600">          <TR>             <td width=50 align=left>               <P ALIGN=center><img src="images/acrobatsmall.gif" align=middle alt="Acrobat" width=22 height=23></P>            </TD>            <td align="left">               <p>Acrobat version of this Note (68K).</P>            </TD>            <td width=60 align=left>               <p><A HREF="pdf/tn1122.pdf">Download</A></P>            </TD>          </TR>        </TABLE></center><BR><BR>        </td></tr></table></center><!-- end_content --><!-- begin_footer_information -->	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/technotes/tn/tn1122.html%3Fid%3DDTS10002962-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/technotes/tn/tn1122.html%3Fid%3DDTS10002962-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/technotes/tn/tn1122.html%3Fid%3DDTS10002962-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>
<!--#include virtual="/includes/footer"--><!-- end_footer_information --></BODY></HTML>