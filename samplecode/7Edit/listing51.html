<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>7Edit - /Source/SVDrag.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxMacOS9Earlier-date.html">Mac OS 9 & Earlier</a> &gt; <A HREF="javascript:location.replace('index.html');">7Edit</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/Carbon/idxInterapplicationCommunication-date.html" target="_blank">Carbon > Interapplication Communication</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">7Edit</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/Source/SVDrag.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/Source/DebugUtils.c</option>
<option value="listing2.html">/Source/DebugUtils.h</option>
<option value="listing3.html">/Source/Offscreen.c</option>
<option value="listing4.html">/Source/Offscreen.h</option>
<option value="listing5.html">/Source/SVAEAccessors.c</option>
<option value="listing6.html">/Source/SVAEAccessors.h</option>
<option value="listing7.html">/Source/SVAEClone.c</option>
<option value="listing8.html">/Source/SVAEClone.h</option>
<option value="listing9.html">/Source/SVAEClose.c</option>
<option value="listing10.html">/Source/SVAEClose.h</option>
<option value="listing11.html">/Source/SVAECoercions.c</option>
<option value="listing12.html">/Source/SVAECoercions.h</option>
<option value="listing13.html">/Source/SVAECompare.c</option>
<option value="listing14.html">/Source/SVAECompare.h</option>
<option value="listing15.html">/Source/SVAECopy.c</option>
<option value="listing16.html">/Source/SVAECopy.h</option>
<option value="listing17.html">/Source/SVAECountElements.c</option>
<option value="listing18.html">/Source/SVAECountElements.h</option>
<option value="listing19.html">/Source/SVAECreate.c</option>
<option value="listing20.html">/Source/SVAECreate.h</option>
<option value="listing21.html">/Source/SVAECut.c</option>
<option value="listing22.html">/Source/SVAECut.h</option>
<option value="listing23.html">/Source/SVAEDelete.c</option>
<option value="listing24.html">/Source/SVAEDelete.h</option>
<option value="listing25.html">/Source/SVAEGetData.c</option>
<option value="listing26.html">/Source/SVAEGetData.h</option>
<option value="listing27.html">/Source/SVAEGetDataSize.c</option>
<option value="listing28.html">/Source/SVAEGetDataSize.h</option>
<option value="listing29.html">/Source/SVAEMove.c</option>
<option value="listing30.html">/Source/SVAEMove.h</option>
<option value="listing31.html">/Source/SVAEObjectsExist.c</option>
<option value="listing32.html">/Source/SVAEObjectsExist.h</option>
<option value="listing33.html">/Source/SVAEPaste.c</option>
<option value="listing34.html">/Source/SVAEPaste.h</option>
<option value="listing35.html">/Source/SVAERecording.c</option>
<option value="listing36.html">/Source/SVAERecording.h</option>
<option value="listing37.html">/Source/SVAERevert.c</option>
<option value="listing38.html">/Source/SVAERevert.h</option>
<option value="listing39.html">/Source/SVAESave.c</option>
<option value="listing40.html">/Source/SVAESave.h</option>
<option value="listing41.html">/Source/SVAESelect.c</option>
<option value="listing42.html">/Source/SVAESelect.h</option>
<option value="listing43.html">/Source/SVAESetData.c</option>
<option value="listing44.html">/Source/SVAESetData.h</option>
<option value="listing45.html">/Source/SVAETextUtils.c</option>
<option value="listing46.html">/Source/SVAETextUtils.h</option>
<option value="listing47.html">/Source/SVAEWindowUtils.c</option>
<option value="listing48.html">/Source/SVAEWindowUtils.h</option>
<option value="listing49.html">/Source/SVAppleEvents.c</option>
<option value="listing50.html">/Source/SVAppleEvents.h</option>
<option value="listing51.html">/Source/SVDrag.c</option>
<option value="listing52.html">/Source/SVDrag.h</option>
<option value="listing53.html">/Source/SVEditAEUtils.c</option>
<option value="listing54.html">/Source/SVEditAEUtils.h</option>
<option value="listing55.html">/Source/SVEditFile.c</option>
<option value="listing56.html">/Source/SVEditFile.h</option>
<option value="listing57.html">/Source/SVEditGlobals.c</option>
<option value="listing58.html">/Source/SVEditGlobals.h</option>
<option value="listing59.html">/Source/SVEditMain.c</option>
<option value="listing60.html">/Source/SVEditMain.h</option>
<option value="listing61.html">/Source/SVEditPrinting.c</option>
<option value="listing62.html">/Source/SVEditPrinting.h</option>
<option value="listing63.html">/Source/SVEditUtils.c</option>
<option value="listing64.html">/Source/SVEditUtils.h</option>
<option value="listing65.html">/Source/SVEditWindow.c</option>
<option value="listing66.html">/Source/SVEditWindow.h</option>
<option value="listing67.html">/Source/SVToken.h</option></select>
				</p>
				</form>
				<p><strong><a href="7Edit.zip">Download Sample</a></strong> (&#147;7Edit.zip&#148;, 205.9K)<BR>
<strong><a href="7Edit.dmg">Download Sample</a></strong> (&#147;7Edit.dmg&#148;, 251.7K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*  File:    SVDrag.c  Contains:    Written by: Original version by Jon Lansdell and Nigel Humphreys.              3.1 updates by Greg Sutton.    Copyright:  Copyright &copy;1995-1999 by Apple Computer, Inc., All Rights Reserved.        You may incorporate this Apple sample source code into your program(s) without        restriction. This Apple sample source code has been provided &quot;AS IS&quot; and the        responsibility for its operation is yours. You are not permitted to redistribute        this Apple sample source code as &quot;Apple sample source code&quot; after having made        changes. If you're going to re-distribute the source, we require that you make        it clear in the source that the code was descended from Apple sample source        code, but that you've made changes.  Change History (most recent first):        7/19/1999  Karl Groethe  Updated for Metrowerks Codewarror Pro 2.1        */#include &quot;SVDrag.h&quot;#include &quot;SVEditWindow.h&quot;#include &quot;SVEditGlobals.h&quot;#include &quot;Offscreen.h&quot;#include &quot;DebugUtils.h&quot;#include &lt;Drag.h&gt;#include &lt;LowMem.h&gt;#include &lt;Errors.h&gt;#include &lt;Folders.h&gt;static short  gCaretOffset;    // Caret drawn during a drag#pragma segment Drag//// InitDragHandlers creates the UPPs for the Drag Manager // callback routines _if_ the Drag Manager is available.//OSErr InitDragHandlers ( void ){  OSErr  theErr = noErr;    if ( gHasDragManager )  {    gDragTrackingHandlerUPP = NewDragTrackingHandlerProc ( MyTrackingHandler );    gDragReceiveHandlerUPP = NewDragReceiveHandlerProc ( MyReceiveHandler );  }    return theErr;}//// InstallDragHandlers attaches the tracking and receive handlers to// one of the application's windows.//OSErr InstallDragHandlers ( WindowRef theWindow ){    OSErr   theErr = noErr;    if ( gHasDragManager )  {        theErr = InstallTrackingHandler ( gDragTrackingHandlerUPP, theWindow, nil );      if ( theErr == noErr )    {      theErr = InstallReceiveHandler ( gDragReceiveHandlerUPP, theWindow, nil );      if ( theErr )        (void) RemoveTrackingHandler ( gDragTrackingHandlerUPP, theWindow );    }      }    return theErr;}//// RemoveDragHandlers removes the tracking and receive handlers from// one of the application's windows (usually just prior to disposal).//void RemoveDragHandlers ( WindowRef theWindow ){  if ( gHasDragManager )  {        RemoveReceiveHandler ( gDragReceiveHandlerUPP, theWindow );    RemoveTrackingHandler ( gDragTrackingHandlerUPP, theWindow );      }    return;}Boolean IsDragInWindowContent ( DragReference theDrag, WindowRef theWindow ){  Point  localPt;    GetDragMouse ( theDrag, &amp;localPt, 0L );  GlobalToLocal ( &amp;localPt );      // Assumes theWindow is current port    return PtInWindow ( localPt, theWindow );}Boolean PtInWindow ( Point localPt, WindowRef theWindow ){  DPtr theDocument;    theDocument = DPtrFromWindowPtr ( theWindow );  return PtInDocument ( localPt, theDocument );}Boolean PtInDocument ( Point localPt, DPtr theDocument ){  return PtInRect ( localPt, &amp;(**(theDocument-&gt;theText)).viewRect );}Boolean CanAcceptDragItems ( DragReference theDrag ){  OSErr      theErr;  ItemReference  theRef;  Boolean      bCanAccept = false;  HFSFlavor     currHFSFlavor;  Size      flavorDataSize;  FlavorFlags    currFlavorFlags;        theErr = GetDragItemReferenceNumber ( theDrag, 1, &amp;theRef );  if ( theErr == noErr )  {    // use GetFlavorFlags to check on flavor existence of TEXT data.    theErr = GetFlavorFlags ( theDrag, theRef, 'TEXT', &amp;currFlavorFlags );    if ( theErr == noErr )      bCanAccept = true;    else    {      // check if the item is a file spec, and it contains TEXT      flavorDataSize = sizeof ( HFSFlavor );      theErr = GetFlavorData ( theDrag, theRef, flavorTypeHFS, &amp;currHFSFlavor,                      &amp;flavorDataSize, 0  );            if ( theErr == noErr &amp;&amp; currHFSFlavor.fileType == 'TEXT' )         bCanAccept = true;    }  }    return bCanAccept;}pascal OSErr MyTrackingHandler ( DragTrackingMessage theMessage, WindowPtr theWindow,                  void* handlerRefCon, DragReference theDrag ){#pragma unused(handlerRefCon)  static Boolean  bHasAcceptableDrag;  static Boolean  bHasHilitedWindow;  static Boolean  bShowCaret;    static long    caretMovedTime;  static short  lastOffset, insertPosition;    short      theOffset;  OSErr      theErr = noErr;  long      theTime = TickCount ( );  unsigned long  theAttributes;  RgnHandle    tempRgn;  DPtr      theDocument, hitDocument;      GetDragAttributes ( theDrag, &amp;theAttributes );  theDocument = DPtrFromWindowPtr ( theWindow );    switch ( theMessage )  {    case kDragTrackingEnterHandler:      // Any initialization for this window handler.      bHasAcceptableDrag = CanAcceptDragItems ( theDrag );            // Let the drag manager know if we can't accept this drag      if ( !bHasAcceptableDrag )        theErr = dragNotAcceptedErr;    break;          case kDragTrackingEnterWindow:             caretMovedTime = theTime;      gCaretOffset = lastOffset = -1;      bShowCaret = true;      bHasHilitedWindow = false;          break;        case kDragTrackingInWindow:      // Hiliting of the window during a drag is done      // here.  Do it only if we can accept these items      // and we're not in the source window.            if ( bHasAcceptableDrag )      {        // Check if the mouse is in a window's content region. Make an        // exception if the window has yet to leave the source window,        // since we don't want to hilite it in that stuation.        Boolean    bMouseInContent;        Point    theMouse;                bMouseInContent = false;        if ( theAttributes &amp; kDragHasLeftSenderWindow )          bMouseInContent = IsDragInWindowContent ( theDrag, theWindow );                // If the mouse is in a window and it isn't hilited...        if ( bMouseInContent &amp;&amp; !bHasHilitedWindow )        {          tempRgn = NewRgn ( );          RectRgn ( tempRgn, &amp;(**(theDocument-&gt;theText)).viewRect );                    // ...draw the hilight...          if ( ShowDragHilite ( theDrag, tempRgn, true ) == noErr )            // ... and remember it's now hilited            bHasHilitedWindow = true;                    DisposeRgn ( tempRgn );        }                        GetDragMouse ( theDrag, &amp;theMouse, 0L );        theOffset = HitTest ( theMouse, &amp;hitDocument );                if ( theDocument == hitDocument )        {                  // Do not allow tracking through the selection in the          // window that sourced the drag.          if ( theAttributes &amp; kDragInsideSenderWindow )            if ( IsOffsetInSelection ( theOffset, theDocument-&gt;theText ) )              theOffset = -1;                                          insertPosition = theOffset;                    //  Reset flashing counter if the offset has moved. This makes the          //  caret blink only after the caret has stopped moving long enough.          if ( theOffset != lastOffset )          {            caretMovedTime = theTime;            bShowCaret = true;          }          lastOffset = theOffset;                              //  Flash caret.          if ( theTime - caretMovedTime &gt; LMGetCaretTime ( ) )          {            bShowCaret = !bShowCaret;            caretMovedTime = theTime;          }                    if ( !bShowCaret )            theOffset = -1;                      //  If caret offset has changed, move caret on screen.          if (theOffset != gCaretOffset)          {            if (gCaretOffset != -1)              DrawCaret(gCaretOffset, theDocument-&gt;theText);                        if (theOffset != -1)              DrawCaret(theOffset, theDocument-&gt;theText);          }                    gCaretOffset = theOffset;        }        else        {          lastOffset = theOffset;          insertPosition = -1;        }      }    break;        case kDragTrackingLeaveWindow:      //  If the caret is on the screen, remove it.      if (gCaretOffset != -1)      {        DrawCaret(gCaretOffset, theDocument-&gt;theText);        gCaretOffset = -1;      }            // Remove any window hiliting here. If the mouse      // is not in the window and it's hilited...      if ( bHasHilitedWindow )        // ...erase the hilight...        if ( HideDragHilite ( theDrag ) == noErr )          // ...remember that nothing is hilited          bHasHilitedWindow = false;    break;        case kDragTrackingLeaveHandler:    break;        default:      theErr = paramErr;    break;  }    return theErr;}Boolean IsOffsetInSelection ( short theOffset, TEHandle theTE ){  return (theOffset &gt;= (*theTE)-&gt;selStart &amp;&amp; theOffset &lt;= (*theTE)-&gt;selEnd);}//// DragIsNotInSourceWindow returns true if the drag in progress// is not in the same window it originated in. This is called by// the tracking and receive handlers.//static Boolean DragIsNotInSourceWindow ( DragReference theDrag ){  DragAttributes currDragFlags;    GetDragAttributes ( theDrag, &amp;currDragFlags );  return !(currDragFlags &amp; kDragInsideSenderWindow);}//// DragReceiver is called by the drag manager whenever an// item is dropped on one of the application's windows.//pascal OSErr MyReceiveHandler ( WindowPtr theWindow, void* handlerRefCon,                   DragReference theDrag ){#pragma unused(handlerRefCon)  Boolean        bHaveData = false;  Boolean        bMove = false;  OSErr        theErr = noErr;      unsigned short    numItems;  int          i;  unsigned long    theAttributes;  ItemReference    theItem;  Size        textSize, styleSize;  DPtr        theDocument;    short        theOffset;  Point        thePoint = { 0, 0 };    Ptr          textData = nil;  StScrpHandle    styleHandle = nil;  TEHandle      tempTE = nil;  Rect        tempRect;      RgnHandle      tempRgn;  Rect        sourceRect, targetRect;  tWindowOffscreen*  theOffscreen = nil;          if ( !(CanAcceptDragItems ( theDrag ) &amp;&amp; IsDragInWindowContent ( theDrag, theWindow )) )    return dragNotAcceptedErr;    theDocument = DPtrFromWindowPtr ( theWindow );  GetDragAttributes ( theDrag, &amp;theAttributes );    // Get the location of the drop  theErr = GetDragMouse ( theDrag, &amp;thePoint, 0L );  if ( theErr ) goto CleanupAndBail;    GlobalToLocal ( &amp;thePoint );      // Assumes theWindow is current port  // Map the drop location to the text  theOffset = TEGetOffset ( thePoint, theDocument-&gt;theText );  // Don't allow a drop within the original selection  if ( theAttributes &amp; kDragInsideSenderWindow )    if ( IsOffsetInSelection ( theOffset, theDocument-&gt;theText ) )      return dragNotAcceptedErr;          // Is this drag copying or a moving the text?  bMove = IsDragMoving ( theDrag );    // First, gather all the text into a temp TE record, and then insert that into  // the doucment. This approach makes it easy to handle things like text selection.  SetRect ( &amp;tempRect, 0, 0, 0, 0 );  tempTE = TEStyleNew ( &amp;tempRect, &amp;tempRect );  theErr = MemError ( );  if ( tempTE == nil || theErr ) goto CleanupAndBail;    theErr = CountDragItems ( theDrag, &amp;numItems );  if ( theErr ) goto CleanupAndBail;    for ( i = 1; i &lt;= numItems; i++ )  {        theErr = GetDragItemReferenceNumber ( theDrag, i, &amp;theItem );    if ( theErr ) goto CleanupAndBail;        theErr = GetFlavorDataSize ( theDrag, theItem, 'TEXT', &amp;textSize );    if ( theErr ) goto CleanupAndBail;        textData = NewPtr ( textSize );    theErr = MemError ( );    if ( textData == nil || theErr ) goto CleanupAndBail;        theErr = GetFlavorData ( theDrag, theItem, 'TEXT', textData, &amp;textSize, 0L );    if ( theErr ) goto CleanupAndBail;            // Check for optional styl data for the TEXT.    styleHandle = 0L;    theErr = GetFlavorDataSize ( theDrag, theItem, 'styl', &amp;styleSize );    if ( !theErr )    {      styleHandle = (StScrpHandle) NewHandle ( styleSize );      theErr = MemError ( );      if ( styleHandle == nil || theErr ) goto CleanupAndBail;            HLock ( (Handle) styleHandle );      theErr = GetFlavorData ( theDrag, theItem, 'styl', *styleHandle, &amp;styleSize, 0L );      if ( theErr ) goto CleanupAndBail;      HUnlock ( (Handle) styleHandle );    }        // Insert this drag item's text into the tempTE.    TESetSelect ( 32767, 32767, tempTE );    TEStyleInsert ( textData, textSize, styleHandle, tempTE );        DisposePtr ( textData );    textData = nil;    if ( styleHandle )    {      DisposeHandle ( (Handle) styleHandle );      styleHandle = nil;    }      }      // Pull the TEXT and styl data out of the tempTE handle.  textData = NewPtr (textSize = (**tempTE).teLength );  theErr = MemError ( );  if ( textData == nil || theErr ) goto CleanupAndBail;    BlockMoveData ( *(*tempTE)-&gt;hText, textData, textSize );  TESetSelect ( 0, 32767, tempTE );  styleHandle = TEGetStyleScrapHandle (tempTE );  TEDispose ( tempTE );  tempTE = nil;      // Insert any text into the destination.  if ( textSize != 0 )  {        // Get rid of the hilite/caret before inserting    if ( theAttributes &amp; kDragHasLeftSenderWindow )      HideDragHilite ( theDrag );        if ( gCaretOffset != -1 )    {      DrawCaret ( gCaretOffset, theDocument-&gt;theText );      gCaretOffset = -1;    }        //  If the drag occurred completely within the same window and the window is not    //  frontmost, bring the window forward and update its contents before completing    //  the drag.    if ( (theAttributes &amp; kDragInsideSenderWindow) &amp;&amp; (theWindow != FrontWindow ( )) )    {      SelectWindow ( theWindow );      DoUpdate ( theWindow );      TEActivate ( theDocument-&gt;theText );    }        //  If the window is not active, must activate TE before inserting    //  text or the background hilite will not update correctly.    if ( !IsWindowHilited ( theWindow ) )      TEActivate ( theDocument-&gt;theText );        //  Draw everything into offscreen pixmap.    theOffscreen = DrawOffscreen ( theWindow );    if ( theOffscreen  )      (*theDocument-&gt;theText)-&gt;inPort = (GrafPtr) theOffscreen-&gt;offscreenWorld;        if ( bMove )    {      // Get the current hilite rgn for zooming (source)      tempRgn = NewRgn ( );      theErr = MemError ( );      if ( theErr )  goto CleanupAndBail;      GetSelectedTextRgn ( theDocument, tempRgn );      sourceRect = (*tempRgn)-&gt;rgnBBox;      LocalRectToGlobalRect ( &amp;sourceRect, theWindow );            // If this is a move operation, delete the old text.      DeleteTextSelection ( theDocument-&gt;theText, &amp;theOffset );    }        InsertTextAtOffset ( theOffset, textData, textSize, styleHandle, theDocument-&gt;theText );        // If the text is moving (not copying) within the same window, provide a ZoomRects    // from the source to the destination before revealing the reflowed text.        if ( bMove )    {      // Get the current hilite rgn for zooming (target)      GetSelectedTextRgn ( theDocument, tempRgn );      targetRect = (*tempRgn)-&gt;rgnBBox;      DisposeRgn ( tempRgn );      tempRgn = nil;      LocalRectToGlobalRect ( &amp;targetRect, theWindow );            ZoomRects ( &amp;sourceRect, &amp;targetRect, 12, kZoomDecelerate );    }  }    // Undo the TEActivate, if needed.  if ( !IsWindowHilited ( theWindow ) )    TEDeactivate ( theDocument-&gt;theText );    //  Show the offscreen bitmap.  if ( theOffscreen )  {    theOffscreen = DrawOnscreen ( theOffscreen );    (*theDocument-&gt;theText)-&gt;inPort = theWindow;  }    // Make the document dirty  theDocument-&gt;dirty = true;    CleanupAndBail:      // All of these will be nil if no error occurred  if ( textData )    DisposePtr ( textData );  if ( styleHandle )    DisposeHandle ( (Handle) styleHandle );  if ( tempTE )    TEDispose ( tempTE );  if ( tempRgn )    DisposeRgn ( tempRgn );    // Normally  nil since DrawOnscreen calls DisposeOffscreen  if ( theOffscreen )  {    DisposeOffscreen ( theOffscreen );    (*theDocument-&gt;theText)-&gt;inPort = theWindow;  }      return theErr;}void DeleteTextSelection ( TEHandle theTE, short* theInsertPosition ){  short selStart, selEnd;    selStart = (*theTE)-&gt;selStart;  selEnd = (*theTE)-&gt;selEnd;  if ( WhiteSpaceAtOffset ( selStart - 1, theTE ) &amp;&amp;      !WhiteSpaceAtOffset ( selStart, theTE ) &amp;&amp;      !WhiteSpaceAtOffset ( selEnd - 1, theTE ) &amp;&amp;       WhiteSpaceAtOffset ( selEnd, theTE ) )  {        if ( GetCharAtOffset ( selEnd, theTE ) == ' ' )      (*theTE)-&gt;selEnd++;  }    if ( *theInsertPosition &gt; selStart )    *theInsertPosition -= ((*theTE)-&gt;selEnd - (*theTE)-&gt;selStart);    TEDelete ( theTE );    return;}static Boolean IsDragMoving ( DragReference theDrag ){  DragAttributes  theAttributes;    GetDragAttributes ( theDrag, &amp;theAttributes );  return (theAttributes &amp; kDragInsideSenderWindow) &amp;&amp; !IsDragWithOptionKey ( theDrag );}static Boolean IsDragWithOptionKey ( DragReference theDrag ){  short  mouseDownModifiers, mouseUpModifiers;    GetDragModifiers ( theDrag, 0L, &amp;mouseDownModifiers, &amp;mouseUpModifiers );  return (mouseDownModifiers &amp; optionKey) | (mouseUpModifiers &amp; optionKey);}void OutlineRegion ( RgnHandle theRgn ){  RgnHandle tempRgn;    tempRgn = NewRgn ( );  CopyRgn ( theRgn, tempRgn );  InsetRgn ( tempRgn, 1, 1 );  DiffRgn ( theRgn, tempRgn, theRgn );  DisposeRgn ( tempRgn );    return;}OSErr DoWindowContentDrag ( WindowPtr theWindow, EventRecord* theEvent ){  OSErr      theErr = noErr;  DragReference  theDrag = (unsigned long) nil;  RgnHandle    dragRgn = nil;  Ptr        dataPtr = nil;  StScrpHandle  styleHandle = nil;  short      dataSize;    DPtr      theDocument;  Rect      dragBounds;  ItemReference  theItem;      // create a new drag  theErr = NewDrag ( &amp;theDrag );  if ( theErr ) goto CleanupAndBail;    // use the window ptr as item reference for the heck of it  theItem = (ItemReference) theWindow;    // add the data to the drag  theDocument = DPtrFromWindowPtr ( theWindow );  dataPtr = NewPtr ( 0L );  theErr = GetSelectedText ( theDocument, dataPtr, &amp;dataSize );  if ( theErr || dataSize == 0 )  goto CleanupAndBail;    theErr = AddDragItemFlavor ( theDrag, theItem, 'TEXT', dataPtr, dataSize, 0 );  if ( theErr )  goto CleanupAndBail;  DisposePtr ( dataPtr );  dataPtr = nil;      // Add style data  styleHandle = TEGetStyleScrapHandle ( theDocument-&gt;theText );  HLock ( (Handle) styleHandle );  AddDragItemFlavor ( theDrag, theItem, 'styl', (Ptr) *styleHandle, GetHandleSize ( (Handle) styleHandle ), 0 );  HUnlock ( (Handle) styleHandle );  DisposeHandle ( (Handle) styleHandle );  styleHandle = nil;      // generate the bounds and region for the drag using the window's  // content rectangle  dragBounds = (**((WindowPeek) theWindow)-&gt;contRgn).rgnBBox;  theErr = SetDragItemBounds(theDrag, theItem, &amp;dragBounds);  if ( theErr ) goto CleanupAndBail;    dragRgn = NewRgn ( );  GetSelectedTextRgn ( theDocument, dragRgn );  LocalRgnToGlobalRgn ( dragRgn, nil );  OutlineRegion ( dragRgn );    // do the drag and clean up  TrackDrag ( theDrag, theEvent, dragRgn );      if ( DragIsNotInSourceWindow ( theDrag ) )  {    AEDesc  dropLocation;        // Get the drop location    GetDropLocation ( theDrag, &amp;dropLocation );    if ( !IsDragWithOptionKey ( theDrag ) &amp;&amp; DropLocationIsFinderTrash ( &amp;dropLocation) )    {      // Delete the exact text. Don't call DeleteTextSelection      TEDelete ( theDocument-&gt;theText );      theDocument-&gt;dirty = true;    }        AEDisposeDesc ( &amp;dropLocation );  }    CleanupAndBail:    if ( theDrag )    DisposeDrag(theDrag);    if ( dragRgn )    DisposeRgn ( dragRgn );    // These should be nil  if ( dataPtr )    DisposePtr ( dataPtr );  if ( styleHandle )    DisposeHandle ( (Handle) styleHandle );      return theErr;}void LocalRgnToGlobalRgn ( RgnHandle theRgn, WindowRef theWindow ){  GrafPtr    savePort;  Point    localPt, globalPt;      if ( theWindow )  {    GetPort ( &amp;savePort );    SetPortWindowPort ( theWindow );  }    localPt = globalPt = *(Point*) &amp;(*theRgn)-&gt;rgnBBox;    // top left  LocalToGlobal ( &amp;globalPt );  SubPt ( localPt, &amp;globalPt );  OffsetRgn ( theRgn, globalPt.h, globalPt.v );    if ( theWindow )    SetPort ( savePort );      return;}void LocalRectToGlobalRect ( Rect* theRect, WindowRef theWindow ){  GrafPtr    savePort;  Point    localPt, globalPt;      if ( theWindow )  {    GetPort ( &amp;savePort );    SetPortWindowPort ( theWindow );  }    localPt = globalPt = *(Point*) theRect;    // top left  LocalToGlobal ( &amp;globalPt );  SubPt ( localPt, &amp;globalPt );  OffsetRect ( theRect, globalPt.h, globalPt.v );    if ( theWindow )    SetPort ( savePort );      return;}OSErr GetSelectedText ( DPtr theDocument, Ptr dataPtr, short* dataSize ){  OSErr theErr;  TEHandle teHandle = theDocument-&gt;theText;    *dataSize = (**(teHandle)).selEnd - (**(teHandle)).selStart;  if ( *dataSize )  {    SetPtrSize ( dataPtr, *dataSize );    theErr = MemError ( );    if ( theErr )      return theErr;    BlockMoveData ( *(**(teHandle)).hText + (**(teHandle)).selStart, dataPtr, *dataSize );  }    return noErr;}void GetSelectedTextRgn ( DPtr theDocument, RgnHandle dataRgn ){  TEGetHiliteRgn ( dataRgn, theDocument-&gt;theText );    return;}//// Does the user want to drag something? First, checks the click could// be a drag, then waits to see if the user starts to drag the text.// Boolean UserWantsToDrag ( WindowRef theWindow, Point globalPt ){  Point  localPt;    localPt = globalPt;  GlobalToLocal ( &amp;localPt );      // Assumes theWindow is current port  if ( PointInWindowSelection ( localPt, theWindow ) )    return WaitMouseMoved ( globalPt );      return false;}//// Returns true if the local point is in the window's current selection//Boolean PointInWindowSelection ( Point localPt, WindowRef theWindow ){  Boolean    bHit;  RgnHandle  tempRgn;  DPtr    theDocument;    theDocument = DPtrFromWindowPtr ( theWindow );  if ( !(PtInDocument ( localPt, theDocument )) )    return false;    tempRgn = NewRgn ( );  GetSelectedTextRgn ( theDocument, tempRgn );  bHit = PtInRgn ( localPt, tempRgn );  DisposeRgn ( tempRgn );    return bHit;}////  Given a point in global coordinates, HitTest returns a pointer to a//  document structure if the point is inside a document window on the screen.//  If the point is not inside a document window, HitTest return NULL in//  theDoc. If the point is in a doument window and also in the viewRect of//  the document's TextEdit field, HitTest also returns the offset into//  the text that corresponds to that point. If the point is not in the text,//  HitTest returns -1.//short HitTest(Point theLoc, DPtr* theDoc){  GrafPtr    savePort;  WindowPtr  theWindow;  short    offset;    *theDoc = 0L;  offset = -1;    if (FindWindow(theLoc, &amp;theWindow) == inContent)  {    if ( Ours ( theWindow ) )    {      *theDoc = DPtrFromWindowPtr ( theWindow );      GetPort ( &amp;savePort );      SetPort(theWindow);      GlobalToLocal(&amp;theLoc);      SetPort ( savePort );            if ((PtInRect(theLoc, &amp;(**((**theDoc).theText)).viewRect)) &amp;&amp;         (PtInRect(theLoc, &amp;(**((**theDoc).theText)).destRect))) {                offset = TEGetOffset(theLoc, (**theDoc).theText);        if ((TEIsFrontOfLine(offset, (**theDoc).theText)) &amp;&amp; (offset) &amp;&amp;                  ((*((**((**theDoc).theText)).hText))[offset - 1] != 0x0D) &amp;&amp;            (TEGetPoint(offset - 1, (**theDoc).theText).h &lt; theLoc.h)) {          offset--;        }      }    }  }  return(offset);}// TEIsFrontOfLine, given an offset and a TextEdit handle, returns true if// the given offset is at the beginning of a line start.short TEIsFrontOfLine ( short offset, TEHandle theTE ){  short    line = 0;  if ((**theTE).teLength == 0)    return(true);  if (offset &gt;= (**theTE).teLength)    return( (*((**theTE).hText))[(**theTE).teLength - 1] == 0x0d );  while ((**theTE).lineStarts[line] &lt; offset)    line++;  return( (**theTE).lineStarts[line] == offset );}// TEGetLine, given an offset and a TextEdit handle, returns the line number// of the line that contains the offset.short TEGetLine ( short offset, TEHandle theTE ){  short    line = 0;  if (offset &gt; (**theTE).teLength)    return((**theTE).nLines);  while ((**theTE).lineStarts[line] &lt; offset)    line++;    return(line);}////  DrawCaret draws a caret in a TextEdit field at the given offset. DrawCaret//  expects the port to be set to the port that the TextEdit field is in.//  DrawCaret inverts the image of the caret onto the screen.//void DrawCaret(short offset, TEHandle theTE){  Point    theLoc;  short    theLine, lineHeight;  // Get the coordinates and the line of the offset to draw the caret.  theLoc  = TEGetPoint(offset, theTE);  theLine = TEGetLine(offset, theTE);      // For some reason, TextEdit dosen't return the proper coordinates  // of the last offset in the field if the last character in the record  // is a carriage return. TEGetPoint returns a point that is one line  // higher than expected. The following code fixes this problem.  if ((offset == (**theTE).teLength) &amp;&amp;      (*((**theTE).hText))[(**theTE).teLength - 1] == 0x0D) {    theLoc.v += TEGetHeight(theLine, theLine, theTE);  }  // Always invert the caret when drawing.  PenMode(patXor);  //Get the height of the line that the offset points to.  lineHeight = TEGetHeight(theLine, theLine, theTE);  // Draw the appropriate caret image.  MoveTo(theLoc.h - 1, theLoc.v - 1);  Line(0, 1 - lineHeight);  PenNormal();}char GetCharAtOffset(short offset, TEHandle theTE){  if (offset &lt; 0)    return(0x0D);  return(((char *) *((**theTE).hText))[offset]);}Boolean WhiteSpace(char theChar){  return((theChar == ' ') || (theChar == 0x0D));}Boolean WhiteSpaceAtOffset(short offset, TEHandle theTE){  char    theChar;  if ((offset &lt; 0) || (offset &gt; (**theTE).teLength - 1))    return(true);  theChar = ((char *) *((**theTE).hText))[offset];  return((theChar == ' ') || (theChar == 0x0D));}void InsertTextAtOffset(short offset, char *theBuf, long size, StScrpHandle theStyl, TEHandle theTE){  if (size == 0)    return;  // If inserting at the end of a word and the selection does not begin with  // a space, insert a space before the insertion.  if (!WhiteSpaceAtOffset(offset - 1, theTE) &amp;&amp;     WhiteSpaceAtOffset(offset, theTE) &amp;&amp;    !WhiteSpace(theBuf[0])) {    TESetSelect(offset, offset, theTE);    TEKey(' ', theTE);    offset++;  }  //  If inserting at the beginning of a word and the selection does not end  //  with a space, insert a space after the insertion.  if ( WhiteSpaceAtOffset(offset - 1, theTE) &amp;&amp;    !WhiteSpaceAtOffset(offset, theTE) &amp;&amp;    !WhiteSpace(theBuf[size - 1])) {    TESetSelect(offset, offset, theTE);    TEKey(' ', theTE);  }    TESetSelect(offset, offset, theTE);  TEStyleInsert(theBuf, size, theStyl, theTE);  TESetSelect(offset, offset + size, theTE);    return;}//// DropLocationIsFinderTrash returns true if the given dropLocation// AEDesc is a descriptor of the Finder's Trash.//Boolean DropLocationIsFinderTrash ( AEDesc* dropLocation ){  OSErr      result;  AEDesc      dropSpec;  FSSpecPtr    theSpec;  CInfoPBRec    thePB;  short      trashVRefNum;  long      trashDirID;        //  Coerce the dropLocation descriptor to an FSSpec. If there's no dropLocation or  //  it can't be coerced into an FSSpec, then it couldn't have been the Trash.  if ( (dropLocation-&gt;descriptorType != typeNull) &amp;&amp;    (AECoerceDesc(dropLocation, typeFSS, &amp;dropSpec) == noErr))  {    HLock(dropSpec.dataHandle);    theSpec = (FSSpec *) *dropSpec.dataHandle;    //  Get the directory ID of the given dropLocation object.    thePB.dirInfo.ioCompletion = 0L;    thePB.dirInfo.ioNamePtr = (StringPtr) &amp;theSpec-&gt;name;    thePB.dirInfo.ioVRefNum = theSpec-&gt;vRefNum;    thePB.dirInfo.ioFDirIndex = 0;    thePB.dirInfo.ioDrDirID = theSpec-&gt;parID;        result = PBGetCatInfo(&amp;thePB, false);    HUnlock(dropSpec.dataHandle);    AEDisposeDesc(&amp;dropSpec);        if ( result )      return(false);    //  If the result is not a directory, it cannot be the Trash.    if (!(thePB.dirInfo.ioFlAttrib &amp; (1 &lt;&lt; 4)))      return(false);    //  Get information about the Trash folder.    FindFolder ( theSpec-&gt;vRefNum, kTrashFolderType, kCreateFolder, &amp;trashVRefNum, &amp;trashDirID);    //  If the directory ID of the dropLocation object is the same as the directory ID    //  returned by FindFolder, then the drop must have occurred into the Trash.    if ( thePB.dirInfo.ioDrDirID == trashDirID )      return true;  }      return false;}</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/7Edit/listing51.html%3Fid%3DDTS10000200-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/7Edit/listing51.html%3Fid%3DDTS10000200-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/7Edit/listing51.html%3Fid%3DDTS10000200-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>