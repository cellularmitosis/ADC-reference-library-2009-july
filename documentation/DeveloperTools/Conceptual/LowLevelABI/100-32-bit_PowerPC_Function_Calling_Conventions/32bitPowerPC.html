<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>Mac OS X ABI Function Call Guide: 32-bit PowerPC Function Calling Conventions</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="32-bit PowerPC Function Calling Conventions"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP40002438" title="32-bit PowerPC Function Calling Conventions"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../index.html#//apple_ref/doc/uid/TP30000440-TP30000436" target="_top">Tools</a> &gt; <a href="../../../CompilersDebuggers-date.html#//apple_ref/doc/uid/TP30000440-TP30000436-TP30001025" target="_top">Compiling &amp; Debugging</a> &gt; <a href="../index.html" target="_top">Mac OS X ABI Function Call Guide</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../000-Introduction/introduction.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../110-64-bit_PowerPC_Function_Calling_Conventions/64bitPowerPC.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>
        
        
        <a name="//apple_ref/doc/uid/TP40002438-SW20" title="32-bit PowerPC Function Calling Conventions"></a><hr /><H1>32-bit PowerPC Function Calling Conventions</H1><p>When functions (routines) call other functions (subroutines), they may need to pass arguments to the called functions. The called functions access those arguments as <strong>parameters</strong>. Conversely, some functions return a <strong>result</strong> or return value to their callers. Both arguments and results can be passed using the 32-bit PowerPC architecture registers or the runtime stack, depending on the data type of the values involved. For the successful and efficient passing of values between routines and subroutines, GCC follows strict rules when it generates a program’s object code.</p><p>This article describes the data types that can be used to manipulate the arguments and results of function calls, how routines pass arguments to the subroutines they call, and how functions pass results to their callers. It also lists the registers available in the 32-bit PowerPC architecture and whether their value is preserved after a function call.</p>
<!-- This template is being used for both PDF and HTML. -->

    
    <!-- TopicBook.pm uses this template for its miniTOCs, but needs a different title. -->
    <h4>Contents:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="32bitPowerPC.html#//apple_ref/doc/uid/TP40002438-SW21">Data Types and Data Alignment</a>
				
			<br/>
			
        
			
			
				<a href="32bitPowerPC.html#//apple_ref/doc/uid/TP40002438-SW17">Function Calls</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP40002438-SW21" title="Data Types and Data Alignment"></a><h2>Data Types and Data Alignment</h2><p>Using the correct data types for your variables and setting the appropriate <strong>data alignment</strong><a name="//apple_ref/doc/uid/TP40002438-DontLinkElementID_20"></a> for your data can maximize the performance and portability of your programs. Data alignment specifies how data is laid out in memory.</p><p><span class="content_text">Table 1</span> lists the ANSI C scalar<a name="//apple_ref/doc/uid/TP40002438-DontLinkElementID_21"></a> data types and their sizes and natural alignment<a name="//apple_ref/doc/uid/TP40002438-DontLinkElementID_22"></a> in this environment.</p><a name="//apple_ref/doc/uid/TP40002438-SW1" title="Table 1Size and natural alignment of the scalar data types"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 1&nbsp;&nbsp;</strong>Size and natural alignment of the scalar data types</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Data type</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Size and natural alignment (in bytes)</p></th></tr><tr><td  scope="row"><p><code>_Bool</code>, <code>bool</code></p></td><td ><p>4</p></td></tr><tr><td  scope="row"><p><code>unsigned char</code></p></td><td ><p>1</p></td></tr><tr><td  scope="row"><p><code>char</code>, <code>signed char</code></p></td><td ><p>1</p></td></tr><tr><td  scope="row"><p><code>unsigned short</code></p></td><td ><p>2</p></td></tr><tr><td  scope="row"><p><code>signed short</code></p></td><td ><p>2</p></td></tr><tr><td  scope="row"><p><code>unsigned int</code></p></td><td ><p>4</p></td></tr><tr><td  scope="row"><p><code>signed int</code></p></td><td ><p>4</p></td></tr><tr><td  scope="row"><p><code>unsigned long</code></p></td><td ><p>4</p></td></tr><tr><td  scope="row"><p><code>signed long</code></p></td><td ><p>4</p></td></tr><tr><td  scope="row"><p><code>unsigned long long</code></p></td><td ><p>8</p></td></tr><tr><td  scope="row"><p><code>signed long long</code></p></td><td ><p>8</p></td></tr><tr><td  scope="row"><p><code>float</code></p></td><td ><p>4</p></td></tr><tr><td  scope="row"><p><code>double</code></p></td><td ><p>8</p></td></tr><tr><td  scope="row"><p><code>long double</code></p></td><td ><p>16*</p></td></tr><tr><td  scope="row"><p>pointer</p></td><td ><p>4</p></td></tr></table></div><p>(*) In Mac OS X v10.4 and later and GCC 4.0 and later, the size of the <code>long double</code> extended precision data type is 16 bytes (it’s made up of two 8-byte doubles). In earlier versions of Mac OS X and GCC, <code>long double</code> is equivalent to <code>double</code>. You should not use the <code>long double</code><a name="//apple_ref/doc/uid/TP40002438-DontLinkElementID_23"></a> type when you use GCC 4.0 or later to develop or in programs targeted at Mac OS X versions earlier than 10.4.</p><p>These are some important details about the 32-bit PowerPC environment:</p><ul class="ul"><li class="li"><p>A byte<a name="//apple_ref/doc/uid/TP40002438-DontLinkElementID_24"></a> is 8 bits long.</p></li><li class="li"><p>A null pointer<a name="//apple_ref/doc/uid/TP40002438-DontLinkElementID_25"></a> has a value of 0.</p></li><li class="li"><p>This environment uses the big-endian byte ordering<a name="//apple_ref/doc/uid/TP40002438-DontLinkElementID_26"></a> scheme to store numeric and pointer data types. That is, the most significant bytes go first, followed by the least significant bytes.</p></li><li class="li"><p>This environment uses the two’s-complement binary representation<a name="//apple_ref/doc/uid/TP40002438-DontLinkElementID_27"></a> for signed integer data types.</p></li><li class="li"><p>Arithmetic<a name="//apple_ref/doc/uid/TP40002438-DontLinkElementID_28"></a> for the 64-bit integer data types must be synthesized by the compiler since the 32-bit PowerPC architecture does not implement 64-bit integer math operations.</p></li><li class="li"><p>The <code>float</code> and <code>double</code> data types conform to the IEEE-754 standard representation<a name="//apple_ref/doc/uid/TP40002438-DontLinkElementID_29"></a>. For the value range and precise format of floating-point data types, see <em>PowerPC Numerics</em> in Performance Documentation.</p></li></ul><p>This environment supports multiple data alignment modes. The alignment of data types falls into two categories:</p><ul class="ul"><li class="li"><p><strong>Natural alignment.</strong><a name="//apple_ref/doc/uid/TP40002438-DontLinkElementID_30"></a> The alignment of a data type when allocated in memory or assigned a memory address.</p><p>The natural alignment of a data type is its size. <span class="content_text"><a href="32bitPowerPC.html#//apple_ref/doc/uid/TP40002438-SW1">Table 1</a></span> shows the natural alignment of each data type supported by this environment.</p></li><li class="li"><p><strong>Embedding alignment.</strong><a name="//apple_ref/doc/uid/TP40002438-DontLinkElementID_31"></a> The alignment of a data type within a composite data structure.</p></li></ul><p>For example, the alignment of an <code>unsigned short</code> variable on the stack may differ from that of an <code>unsigned short</code> element embedded in a data structure.</p><p>The embedding alignment for data structures varies depending on the alignment mode selected. Generally, you can set the alignment mode using compiler options or <code>#pragma</code> statements. You should consider the compatibility and performance issues described later in this section when choosing a particular alignment mode.</p><p>These are the embedding alignment modes available in the 32-bit PowerPC environment:</p><ul class="ul"><li class="li"><p><strong>Power alignment mode<a name="//apple_ref/doc/uid/TP40002438-DontLinkElementID_32"></a></strong><a name="//apple_ref/doc/uid/TP40002438-DontLinkElementID_33"></a> is derived from the alignment rules used by the IBM XLC compiler for the AIX operating system. It is the default alignment mode for the PowerPC-architecture version of GCC used on AIX and Mac OS X. Because this mode is most likely to be compatible between PowerPC-architecture compilers from different vendors, it’s typically used with data structures that are shared<a name="//apple_ref/doc/uid/TP40002438-DontLinkElementID_34"></a> between different programs.</p><p>The rules for power alignment are:</p><ul class="nested"><li class="nested li"><p>The embedding alignment of the first element in a data structure is equal to the element’s natural alignment.</p></li><li class="nested li"><p>For subsequent elements with a natural alignment less than 4 bytes, the embedding alignment of each element is equal to its natural alignment.</p></li><li class="nested li"><p>For subsequent elements that have a natural alignment greater than 4 bytes, the embedding alignment is 4, unless the element is a <code>vector</code>.</p></li><li class="nested li"><p>The embedding alignment for <code>vector</code> elements is always 16 bytes.</p></li><li class="nested li"><p>The embedding alignment of a composite data type (array or data structure) is determined by the largest embedding alignment of its members.</p></li><li class="nested li"><p>The total size of a composite type is rounded up to a multiple of its embedding alignment, and is padded with null bytes.</p></li></ul><p>Because the natural alignment of the  <code>double</code> and <code>long long</code> data types is greater than 4 bytes, they may not be appropriately aligned in power alignment mode. Any misalignment impairs performance when such data members are accessed. When you use these data types for any element after the first element, the compiler pads<a name="//apple_ref/doc/uid/TP40002438-DontLinkElementID_35"></a> the structure to align the elements to the next multiple of their natural alignment.</p></li><li class="li"><p><strong>Mac68K alignment mode</strong><a name="//apple_ref/doc/uid/TP40002438-DontLinkElementID_36"></a> is usually used with legacy data structures inherited from Mac OS 9 and earlier systems. New code should not need to use this alignment mode except to preserve compatibility with older data structures.</p><p>The rules for Mac68K alignment are:</p><ul class="nested"><li class="nested li"><p>The embedding alignment of the <code>char</code> data type is 1 byte.</p></li><li class="nested li"><p>The embedding alignment of all other data types (except <code>vector</code>) is 2 bytes.</p></li><li class="nested li"><p>The embedding alignment for the <code>vector</code> data type is 16 bytes.</p></li><li class="nested li"><p>The total size of a composite data type is rounded up to a multiple of 2 bytes.</p></li></ul></li><li class="li"><p><strong>Natural alignment mode</strong><a name="//apple_ref/doc/uid/TP40002438-DontLinkElementID_37"></a> uses the natural alignment of each data type as its embedding alignment. Use this alignment mode to obtain the highest performance<a name="//apple_ref/doc/uid/TP40002438-DontLinkElementID_38"></a> when using the <code>double</code>, <code>long long</code>, and <code>long double</code> data types.</p></li><li class="li"><p><strong>Packed alignment mode</strong><a name="//apple_ref/doc/uid/TP40002438-DontLinkElementID_39"></a> contains no alignment padding between elements (the alignment for all data types is 1 byte). Use this alignment mode when you need a data structure to use as little<a name="//apple_ref/doc/uid/TP40002438-DontLinkElementID_40"></a> memory as possible. Note, however, that packed alignment can significantly lower the performance of your application.</p></li></ul><div class="notebox"><a name="//apple_ref/doc/uid/TP40002438-SW22" title="Note"></a><p><strong>Note:</strong>&nbsp;Data items passed as parameters in a function call have special alignment rules. See <span class="content_text"><a href="32bitPowerPC.html#//apple_ref/doc/uid/TP40002438-SW19">“Stack Structure”</a></span> for more information.</p></div><p><span class="content_text">Table 2</span><a name="//apple_ref/doc/uid/TP40002438-DontLinkElementID_41"></a> lists the alignment for structure fields of the fundamental data types and composite data types in the supported alignment modes.</p><a name="//apple_ref/doc/uid/TP40002438-SW2" title="Table 2Alignment for structure fields"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 2&nbsp;&nbsp;</strong>Alignment for structure fields</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Data type</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Power alignment</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Natural alignment</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Mac68K alignment</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Packed alignment</p></th></tr><tr><td  scope="row"><p><code>_Bool</code>, <code>bool</code></p></td><td ><p>4</p></td><td ><p>4</p></td><td ><p>2</p></td><td ><p>1</p></td></tr><tr><td  scope="row"><p><code>char</code></p></td><td ><p>1</p></td><td ><p>1</p></td><td ><p>1</p></td><td ><p>1</p></td></tr><tr><td  scope="row"><p><code>short</code></p></td><td ><p>2</p></td><td ><p>2</p></td><td ><p>2</p></td><td ><p>1</p></td></tr><tr><td  scope="row"><p><code>int</code></p></td><td ><p>4</p></td><td ><p>4</p></td><td ><p>2</p></td><td ><p>1</p></td></tr><tr><td  scope="row"><p><code>long</code></p></td><td ><p>4</p></td><td ><p>4</p></td><td ><p>2</p></td><td ><p>1</p></td></tr><tr><td  scope="row"><p><code>long long</code></p></td><td ><p>4 or 8</p></td><td ><p>8</p></td><td ><p>2</p></td><td ><p>1</p></td></tr><tr><td  scope="row"><p><code>float</code></p></td><td ><p>4</p></td><td ><p>4</p></td><td ><p>2</p></td><td ><p>1</p></td></tr><tr><td  scope="row"><p><code>double</code></p></td><td ><p>4 or 8</p></td><td ><p>8</p></td><td ><p>2</p></td><td ><p>1</p></td></tr><tr><td  scope="row"><p><code>long double</code></p></td><td ><p></p></td><td ><p></p></td><td ><p>2</p></td><td ><p>1</p></td></tr><tr><td  scope="row"><p><code>vector</code></p></td><td ><p>16</p></td><td ><p>16</p></td><td ><p>16</p></td><td ><p>1</p></td></tr><tr><td  scope="row"><p>Composite (data structure or array)</p></td><td ><p>4, 8, or 16</p></td><td ><p>1, 2, 4, 8, or 16</p></td><td ><p>2</p></td><td ><p>1</p></td></tr></table></div><p>With GCC you can control data-structure alignment by adding <code>#pragma<a name="//apple_ref/doc/uid/TP40002438-DontLinkElementID_42"></a></code> statements to your source code or by using command-line options. The power alignment mode is used if you do not specify otherwise.</p><p>To set the alignment mode, use the <code>gcc</code> flags <code>-malign-power</code>, <code>-malign-mac68k</code>, and <code>-malign-natural</code>. To use a specific alignment mode in a data structure, add this statement just before the data-structure declaration:</p><div class="codesample"><table><tr><td scope="row"><pre>#pragma option align=&lt;mode><span></span></pre></td></tr></table></div><p>Replace <code>&lt;mode></code> with <code>power</code>, <code>mac68k</code>, <code>natural</code>, or <code>packed</code>. To restore the previous alignment mode, use <code>reset</code> as the alignment mode in a <code>#pragma</code> statement:</p><div class="codesample"><table><tr><td scope="row"><pre>#pragma option align=reset<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40002438-DontLinkElementID_43"></a><a name="//apple_ref/doc/uid/TP40002438-SW17" title="Function Calls"></a><h2>Function Calls</h2><p>This section details the process of calling a function and passing arguments to it, and how functions return values to their callers.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40002438-SW23" title="Note"></a><p><strong>Note:</strong>&nbsp;These argument-passing conventions are part of the Apple standard for procedural programming interfaces. Object-oriented languages may use different rules for their own method calls. For example, the conventions for C++ virtual function calls may be different from those for C functions.</p></div><a name="//apple_ref/doc/uid/TP40002438-SW19" title="Stack Structure"></a><h3>Stack Structure</h3><a name="//apple_ref/doc/uid/TP40002438-DontLinkElementID_44"></a><p>This environment uses a stack that grows downward and contains linkage information, local variables, and a function’s parameter information, as shown in <span class="content_text">Figure 1</span>. (To help prevent the execution of malicious code on the stack, GCC protects the stack against execution.)</p><br/><div><a name="//apple_ref/doc/uid/TP40002438-SW3" title="Figure 1Stack layout"></a><p><strong>Figure 1&nbsp;&nbsp;</strong>Stack layout</p><img src = "../art/calling_stack.jpg" alt = "" ></div><br/><p>The <strong>stack pointer</strong> (SP)<a name="//apple_ref/doc/uid/TP40002438-DontLinkElementID_45"></a> points to the bottom of the stack. The stack has a fixed frame size, which is known at compile time.</p><p>The calling routine’s stack frame includes a <strong>parameter area</strong><a name="//apple_ref/doc/uid/TP40002438-DontLinkElementID_46"></a> and some linkage information. The parameter area has the arguments the caller passes to the called function or space for them, depending on the type of each argument and the availability of registers (see <span class="content_text"><a href="32bitPowerPC.html#//apple_ref/doc/uid/TP40002438-SW14">“Passing Arguments”</a></span> for details). Since the calling routine may call several functions, in the 32-bit PowerPC environment the parameter area is normally large enough to accommodate the largest argument list of all the functions the caller calls. It is the calling routine’s responsibility to set up the parameter area before each function call. The called function is responsible for accessing the arguments placed in the parameter area.</p><p>The first 32 bytes in the parameter area correspond to the general-purpose<a name="//apple_ref/doc/uid/TP40002438-DontLinkElementID_47"></a> registers GPR3 through GPR10. When data is placed in a general-purpose register and not duplicated in the parameter area, the corresponding section in the parameter area is reserved in case the called function needs to copy the value in the register to the stack. <span class="content_text">Table 3</span> shows the correspondence of parameter area locations to the general-purpose registers that can be used to pass arguments.</p><a name="//apple_ref/doc/uid/TP40002438-SW9" title="Table 3Parameter area to general-purpose register mapping"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 3&nbsp;&nbsp;</strong>Parameter area to general-purpose register mapping</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Stack frame location</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Register</p></th></tr><tr><td  scope="row"><p><code>SP+24</code></p></td><td ><p>GPR3</p></td></tr><tr><td  scope="row"><p><code>SP+28</code></p></td><td ><p>GPR4</p></td></tr><tr><td  scope="row"><p><code>SP+32</code></p></td><td ><p>GPR5</p></td></tr><tr><td  scope="row"><p><code>SP+36</code></p></td><td ><p>GPR6</p></td></tr><tr><td  scope="row"><p><code>SP+40</code></p></td><td ><p>GPR7</p></td></tr><tr><td  scope="row"><p><code>SP+44</code></p></td><td ><p>GPR8</p></td></tr><tr><td  scope="row"><p><code>SP+48</code></p></td><td ><p>GPR9</p></td></tr><tr><td  scope="row"><p><code>SP+52</code></p></td><td ><p>GPR10</p></td></tr></table></div><p>These are the alignment rules<a name="//apple_ref/doc/uid/TP40002438-DontLinkElementID_48"></a> followed when parameters are placed in the parameter area<a name="//apple_ref/doc/uid/TP40002438-DontLinkElementID_49"></a> or in GPR3 through GPR10:</p><ol class="ol"><li class="li"><p>All nonvector parameters are aligned on 4-byte boundaries.</p></li><li class="li"><p>Vector parameters are aligned on 16-byte boundaries.</p></li><li class="li"><p>Noncomposite parameters (that is, parameters that are not arrays or data structures) smaller than 4 bytes occupy the high-order bytes of their 4-byte area.</p></li><li class="li"><p>Composite parameters (arrays, structures, and unions) 1 or 2 bytes in size occupy the low-order bytes of their 4-byte area. They are preceded by padding to 4 bytes.</p><p>This rule is inconsistent with other 32-bit PowerPC binary interfaces. In AIX and Mac OS 9 (and earlier), padding bytes always follow the data structure even in the case of composite parameters smaller than 4 bytes.</p></li><li class="li"><p>Composite parameters 3 bytes or larger in size occupy the high-order bytes of their 4-byte area. They are followed by padding to make a multiple of 4 bytes, with the padding bytes being undefined.</p></li></ol><p>For example, consider the <code>foo</code><a name="//apple_ref/doc/uid/TP40002438-DontLinkElementID_50"></a> function, declared like this:</p><div class="codesample"><table><tr><td scope="row"><pre>void foo(SInt32 i1, float  f1, double d1, SInt16 s1, double d2,<span></span></pre></td></tr><tr><td scope="row"><pre>         UInt8  c1, UInt16 s2, float  f2, SInt32 i2);<span></span></pre></td></tr></table></div><p><span class="content_text">Table 4</span> shows how the function’s arguments are assigned locations in the parameter area. The assignment takes into account the 4-byte alignment required for each argument.</p><a name="//apple_ref/doc/uid/TP40002438-SW8" title="Table 4Parameter area layout for the foo call"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 4&nbsp;&nbsp;</strong>Parameter area layout for the <code>foo</code> call</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Parameter</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Type</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Location</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Data size and padding (in bytes)</p></th></tr><tr><td  scope="row"><p><code>i1</code></p></td><td ><p><code>SInt32</code></p></td><td ><p><code>SP+24</code></p></td><td ><p>4, 0</p></td></tr><tr><td  scope="row"><p><code>f1</code></p></td><td ><p><code>float</code></p></td><td ><p><code>SP+28</code></p></td><td ><p>4, 0</p></td></tr><tr><td  scope="row"><p><code>d1</code></p></td><td ><p><code>double</code></p></td><td ><p><code>SP+32</code></p></td><td ><p>8, 0</p></td></tr><tr><td  scope="row"><p><code>s1</code></p></td><td ><p><code>SInt16</code></p></td><td ><p><code>SP+40</code></p></td><td ><p>2, 2</p></td></tr><tr><td  scope="row"><p><code>d2</code></p></td><td ><p><code>double</code></p></td><td ><p><code>SP+44</code></p></td><td ><p>8, 0</p></td></tr><tr><td  scope="row"><p><code>c1</code></p></td><td ><p><code>UInt8</code></p></td><td ><p><code>SP+52</code></p></td><td ><p>1, 3</p></td></tr><tr><td  scope="row"><p><code>s2</code></p></td><td ><p><code>UInt16</code></p></td><td ><p><code>SP+56</code></p></td><td ><p>2, 2</p></td></tr><tr><td  scope="row"><p><code>f2</code></p></td><td ><p><code>float</code></p></td><td ><p><code>SP+60</code></p></td><td ><p>4, 0</p></td></tr><tr><td  scope="row"><p><code>i2</code></p></td><td ><p><code>SInt32</code></p></td><td ><p><code>SP+64</code></p></td><td ><p>4, 0</p></td></tr></table></div><p>The calling routine’s <strong>linkage area</strong><a name="//apple_ref/doc/uid/TP40002438-DontLinkElementID_51"></a> holds a number of values, some of which are saved by the calling routine and some by the called function. The elements within the linkage area are:</p><ul class="spaceabove"><li class="li"><p><strong>The link register (LR).</strong><a name="//apple_ref/doc/uid/TP40002438-DontLinkElementID_52"></a> Its value is saved at <code>8(SP)</code> by the called function if it chooses to do so. The link register holds the return address of the instruction that follows a branch and link instruction.</p></li><li class="li"><p><strong>The condition register (CR).<a name="//apple_ref/doc/uid/TP40002438-DontLinkElementID_53"></a></strong> Its value may be saved at <code>4(SP)</code> by the called function. The condition register holds the results of comparison operations. As with the link register, the called procedure is not required to save this value.</p></li><li class="li"><p><strong>The stack pointer (SP).</strong><a name="//apple_ref/doc/uid/TP40002438-DontLinkElementID_54"></a> Its value may be saved at <code>0(SP)</code> by the called function as part of its stack frame. <strong>Leaf functions</strong> are not required to save the the stack pointer. A leaf function is a function that does not call any other functions.</p></li></ul><div class="notebox"><a name="//apple_ref/doc/uid/TP40002438-SW24" title="Note"></a><p><strong>Note:</strong>&nbsp;The space in the linkage area from <code>12(SP)</code> to <code>23(SP)</code> is reserved.</p></div><p>The linkage area is at the top of the stack, adjacent to the stack pointer. This positioning is necessary so that the calling routine can find and restore the values stored there and also allow the called function to find the caller’s parameter area. This placement means that a routine cannot push and pop parameters from the stack once the stack frame is set up.</p><p>The stack frame also includes space for the called function’s local variables. However, some registers are also available for use by the called function; see <span class="content_text"><a href="32bitPowerPC.html#//apple_ref/doc/uid/TP40002438-SW18">“Register Preservation”</a></span> for details. If the subroutine contains more local variables than would fit in the registers, it uses additional space on the stack. The size of the local-variable area is determined at compile time. Once a stack frame is allocated, the size of the local-variable area does not change.</p><a name="//apple_ref/doc/uid/TP40002438-DontLinkElementID_55"></a><a name="//apple_ref/doc/uid/TP40002438-SW25" title="Prologs and Epilogs"></a><h3>Prologs and Epilogs</h3><a name="//apple_ref/doc/uid/TP40002438-DontLinkElementID_56"></a><a name="//apple_ref/doc/uid/TP40002438-DontLinkElementID_57"></a><p>The called function is responsible for allocating<a name="//apple_ref/doc/uid/TP40002438-DontLinkElementID_58"></a> its own stack frame, making sure to preserve 16-byte alignment in the stack. This operation is accomplished by a section of code called the <strong>prolog</strong>, which the compiler places before the body of the subroutine. After the body of the subroutine, the compiler places an <strong>epilog</strong> to restore the processor to the state it was prior to the subroutine call.</p><p>The compiler-generated prolog code does the following:</p><ol class="ol"><li class="li"><p>Decrements the stack pointer<a name="//apple_ref/doc/uid/TP40002438-DontLinkElementID_59"></a> to account for the new<a name="//apple_ref/doc/uid/TP40002438-DontLinkElementID_60"></a> stack frame and writes the previous value of the stack pointer to its own linkage area, which ensures the stack can be restored to its original state after returning from the call.</p><p>It is important that the decrement and update tasks happen atomically (for example, with <code>stwu</code>, <code>stwux</code>, <code>stdu</code>, or <code>stdux</code>) so that the stack pointer and back-link are in a consistent state. Otherwise, asynchronous signals or interrupts could corrupt the stack.</p></li><li class="li"><p>Saves all nonvolatile general-purpose<a name="//apple_ref/doc/uid/TP40002438-DontLinkElementID_61"></a> and floating-point<a name="//apple_ref/doc/uid/TP40002438-DontLinkElementID_62"></a> registers into the saved-registers area. Note that if the called function does not change a particular nonvolatile register, it does not save it.</p></li><li class="li"><p>Saves the link-register<a name="//apple_ref/doc/uid/TP40002438-DontLinkElementID_63"></a> and condition-register<a name="//apple_ref/doc/uid/TP40002438-DontLinkElementID_64"></a> values in the caller’s linkage area, if needed.</p></li></ol><p><span class="content_text">Listing 1</span> shows an example of a subroutine prolog. Notice that the order of these actions differs from the order previously described.</p><a name="//apple_ref/doc/uid/TP40002438-SW4" title="Listing 1Example prolog"></a><p class="codesample"><strong>Listing 1&nbsp;&nbsp;</strong>Example prolog</p><div class="codesample"><table><tr><td scope="row"><pre>linkageArea = 24                                           ; size in 32-bit PowerPC ABI<span></span></pre></td></tr><tr><td scope="row"><pre>params = 32                                                ; callee parameter area<span></span></pre></td></tr><tr><td scope="row"><pre>localVars = 0                                              ; callee local variables<span></span></pre></td></tr><tr><td scope="row"><pre>numGPRs = 0                                                ; volatile GPRs used by callee<span></span></pre></td></tr><tr><td scope="row"><pre>numFPRs = 0                                                ; volatile FPRs used by callee<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>spaceToSave = linkageArea + params + localVars + 4*numGPRs + 8*numFPRs<span></span></pre></td></tr><tr><td scope="row"><pre>spaceToSaveAligned = ((spaceToSave+15) &amp; (-16))            ; 16-byte-aligned stack<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>_functionName:                                             ; PROLOG<span></span></pre></td></tr><tr><td scope="row"><pre>    mflr        r0                                         ; extract return address<span></span></pre></td></tr><tr><td scope="row"><pre>    stw         r0, 8(SP)                                  ; save the return address<span></span></pre></td></tr><tr><td scope="row"><pre>    stwu        SP, -spaceToSaveAligned(SP)                ; skip over caller save area<span></span></pre></td></tr></table></div>	<p>At the end of the subroutine, the compiler-generated epilog does the following:</p><ol class="ol"><li class="li"><p>Restores the nonvolatile general-purpose<a name="//apple_ref/doc/uid/TP40002438-DontLinkElementID_65"></a> and floating-point<a name="//apple_ref/doc/uid/TP40002438-DontLinkElementID_66"></a> registers that were saved in the stack frame.</p><p>Nonvolatile registers are saved in the new stack frame before the stack pointer is updated only when they fit within the space beneath the stack pointer, where a new stack frame would normally be allocated, also known as the <strong>red zone</strong>. The red zone is by definition large enough to hold all nonvolatile general-purpose and floating-point registers  but not the nonvolatile vector registers. See <span class="content_text"><a href="32bitPowerPC.html#//apple_ref/doc/uid/TP40002438-SW6">“The Red Zone”</a></span> for details.</p></li><li class="li"><p>Restores the condition-register<a name="//apple_ref/doc/uid/TP40002438-DontLinkElementID_67"></a> and link-register<a name="//apple_ref/doc/uid/TP40002438-DontLinkElementID_68"></a> values that were stored in the linkage area.</p></li><li class="li"><p>Restores the stack pointer<a name="//apple_ref/doc/uid/TP40002438-DontLinkElementID_69"></a> to its previous value.</p></li><li class="li"><p>Returns control to the the calling routine using the address stored in the link register<a name="//apple_ref/doc/uid/TP40002438-DontLinkElementID_70"></a>.</p></li></ol><p><span class="content_text">Listing 2</span> shows an example epilog.</p><a name="//apple_ref/doc/uid/TP40002438-SW15" title="Listing 2Example epilog"></a><p class="codesample"><strong>Listing 2&nbsp;&nbsp;</strong>Example epilog</p><div class="codesample"><table><tr><td scope="row"><pre>                                                   ; EPILOG<span></span></pre></td></tr><tr><td scope="row"><pre>lwz            r0, spaceToSaveAligned + 8(SP)      ; get the return address<span></span></pre></td></tr><tr><td scope="row"><pre>mtlr           r0                                  ;    into the link register<span></span></pre></td></tr><tr><td scope="row"><pre>addi           SP, SP, spaceToSaveAligned          ; restore stack pointer<span></span></pre></td></tr><tr><td scope="row"><pre>blr                                                ;    and branch to the return address<span></span></pre></td></tr></table></div>	<p>The VRSAVE<a name="//apple_ref/doc/uid/TP40002438-DontLinkElementID_71"></a> register is used to specify which vector registers must be saved during a thread or process context switch.<span class="content_text">Listing 3</span> shows an example prolog that sets up VRSAVE so that vector registers V0 through V2 are saved. <span class="content_text">Listing 3</span> also includes the epilog that restores VRSAVE to its previous state.</p><a name="//apple_ref/doc/uid/TP40002438-SW16" title="Listing 3Example usage of the VRSAVE register"></a><p class="codesample"><strong>Listing 3&nbsp;&nbsp;</strong>Example usage of the VRSAVE register</p><div class="codesample"><table><tr><td scope="row"><pre>#define VRSAVE 256                           //  VRSAVE IS SPR# 256<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    _functionName:<span></span></pre></td></tr><tr><td scope="row"><pre>        mfspr    r2, VRSAVE                  ; get vector of live VRs<span></span></pre></td></tr><tr><td scope="row"><pre>        oris         r0, r2, 0xE000          ; set bits 0-2 since we use V0..V2<span></span></pre></td></tr><tr><td scope="row"><pre>        mtspr    VRSAVE, r0                  ; update live VR vector before using any VRs<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        ; Now, V0..V2 can be safely used.<span></span></pre></td></tr><tr><td scope="row"><pre>        ; Function body goes here.<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        mtspr    VRSAVE, r2                  ; restore VRSAVE<span></span></pre></td></tr><tr><td scope="row"><pre>        blr                                  ; return to caller<span></span></pre></td></tr></table></div>	<a name="//apple_ref/doc/uid/TP40002438-DontLinkElementID_72"></a><a name="//apple_ref/doc/uid/TP40002438-DontLinkElementID_73"></a><a name="//apple_ref/doc/uid/TP40002438-SW6" title="The Red Zone"></a><h3>The Red Zone</h3><a name="//apple_ref/doc/uid/TP40002438-DontLinkElementID_74"></a><p>The space beneath the stack pointer, where a new stack frame would normally be allocated by a subroutine, is called the <strong>red zone</strong>. The red zone, shown in <span class="content_text">Figure 2</span>, is considered part of the current stack frame. This area is not modified by asynchronous<a name="//apple_ref/doc/uid/TP40002438-DontLinkElementID_75"></a> pushes, such as signals<a name="//apple_ref/doc/uid/TP40002438-DontLinkElementID_76"></a> or interrupt<a name="//apple_ref/doc/uid/TP40002438-DontLinkElementID_77"></a> handlers. Therefore, the red zone may be used for any purpose as long as a new<a name="//apple_ref/doc/uid/TP40002438-DontLinkElementID_78"></a> stack frame does not need to be added to the stack. However, the contents of the red zone are assumed to be destroyed by any synchronous<a name="//apple_ref/doc/uid/TP40002438-DontLinkElementID_79"></a> call.</p><br/><div><a name="//apple_ref/doc/uid/TP40002438-SW5" title="Figure 2The red zone"></a><p><strong>Figure 2&nbsp;&nbsp;</strong>The red zone</p><img src = "../art/calling_redzone.jpg" alt = "" ></div><br/><p>For example, because a leaf function<a name="//apple_ref/doc/uid/TP40002438-DontLinkElementID_80"></a> does not call any other functions—and, therefore, does not allocate a parameter area on the stack—it can use the red zone. Furthermore, such a function does not need to use the stack to store local variables; it needs to save only the nonvolatile registers it uses for local variables. Since, by definition, no more than one leaf function is active at any time within a thread, there is no possibility of multiple leaf functions competing for the same red zone space.</p><p>A leaf function may or may not allocate a stack frame and decrement the stack pointer. When it doesn’t allocate a stack frame, a leaf function stores the link register and condition register values in the linkage area of the routine that calls it (if necessary) and stores the values of any nonvolatile registers it uses in the red zone. This streamlining means that a leaf function’s prolog and epilog do minimal work; they do not have to set up and take down a stack frame.</p><p>The size of the red zone is 224 bytes, which is enough space to store the values of nineteen 32-bit general-purpose registers and eighteen 64-bit floating-point registers, rounded up to the nearest 16-byte boundary. If a leaf function’s red zone usage would exceed the red zone size, it must set up a stack frame, just as functions that call other functions do.</p><a name="//apple_ref/doc/uid/TP40002438-DontLinkElementID_81"></a><a name="//apple_ref/doc/uid/TP40002438-SW14" title="Passing Arguments"></a><h3>Passing Arguments</h3><a name="//apple_ref/doc/uid/TP40002438-DontLinkElementID_82"></a><p>In the C language, functions can declare their parameters using one of three conventions:</p><ul class="spaceabove"><li class="li"><p>The types of all parameters is specified in the function’s prototype. For example:</p><div class="codesample"><table><tr><td scope="row"><pre>int foo(int, short);<span></span></pre></td></tr></table></div><p>In this case, the type of all the function’s parameters is known at compile time.</p></li><li class="li"><p>The function’s prototype declares some fixed parameters and some nonfixed parameters. The group of nonfixed parameters is also called a <strong>variable argument list</strong><a name="//apple_ref/doc/uid/TP40002438-DontLinkElementID_83"></a>. For example:</p><div class="codesample"><table><tr><td scope="row"><pre>int foo(int, ...);<span></span></pre></td></tr></table></div><p>In this case, the type of one of the function’s parameters in known at compile time. The type of the nonfixed parameters is not known.</p></li><li class="li"><p>The function has no prototype or uses a pre–ANSI C declaration. For example:</p><div class="codesample"><table><tr><td scope="row"><pre>int foo();<span></span></pre></td></tr></table></div><p>In this case, the type of all the function’s parameters is unknown at compile time.</p></li></ul><p>When the compiler generates the prolog for a function call, it uses the information from the function’s declaration to decide how arguments are passed to the function. When the compiler knows the type of a parameter, it passes it in the most efficient way possible. But when the type is unknown, it passes the parameter using the safest approach, which may involve placing data both in registers and in the parameter area. For called functions to access their parameters correctly, it’s important that they know when parameters are passed in the stack or in registers.</p><p>Arguments are passed in the stack, in registers, or both, depending on their types and the availability of registers. There are three types of registers: general purpose, floating point, and vector. General-purpose<a name="//apple_ref/doc/uid/TP40002438-DontLinkElementID_84"></a> registers (GPRs) are 32-bit registers that can manipulate integral values and pointers. Floating-point<a name="//apple_ref/doc/uid/TP40002438-DontLinkElementID_85"></a> registers (FPRs) are 64-bit registers that can manipulate single-precision and double-precision floating-point values. Vector<a name="//apple_ref/doc/uid/TP40002438-DontLinkElementID_86"></a> registers are 128-bit registers that can manipulate 4 through 16 chunks of data in parallel.</p><p>The registers that can be used to pass arguments to called functions are the general-purpose registers GPR3 through GPR10, the floating-point registers FPR1 through FPR13, and the vector registers V2 through V13 (see <span class="content_text"><a href="32bitPowerPC.html#//apple_ref/doc/uid/TP40002438-SW18">“Register Preservation”</a></span> for details). These registers are also known as <strong>parameter registers</strong>.</p><div class="importantbox"><a name="//apple_ref/doc/uid/TP40002438-DontLinkElementID_4" title="Important:"></a><p><strong>Important:</strong>&nbsp;Only the low 32 bits in each of the general-purpose<a name="//apple_ref/doc/uid/TP40002438-DontLinkElementID_87"></a> registers available on the 64-bit PowerPC architecture are used in this environment. That is, only the low 32 bits of nonvolatile registers are saved and restored. However, all 64 bits are saved across asynchronous<a name="//apple_ref/doc/uid/TP40002438-DontLinkElementID_88"></a> events, such as signals<a name="//apple_ref/doc/uid/TP40002438-DontLinkElementID_89"></a> and preemptions. Therefore, you can use the 64 bits in each register between function calls. You control this feature through the <code>gcc</code> options <code>-arch</code> and <code>-mcpu</code>.</p><p></p></div><p>Typically, the called routine obtains arguments from registers. However, the caller generates a parameter area<a name="//apple_ref/doc/uid/TP40002438-DontLinkElementID_90"></a> in the caller’s stack frame that is large enough to hold all the arguments passed to the called function, regardless of how many of the arguments are actually passed in registers. (You can think of the parameter area as a data structure that has space to hold all the arguments in a given call.) There are several reasons for these scheme:</p><ul class="spaceabove"><li class="li"><p>It provides the called function with space in the stack to store a register-based parameter if it wants to use one of the parameter registers for some other purpose. For example, the callee can use these space to pass arguments to a function it calls.</p></li><li class="li"><p>Functions with variable argument lists<a name="//apple_ref/doc/uid/TP40002438-DontLinkElementID_91"></a> must often access their parameters from RAM, not from registers. Such functions must reserve 32 bytes (8 registers) in the parameter area to hold the parameter values.</p></li></ul><p>To simplify debugging, GCC writes parameters from the parameter registers into the parameter area in the stack frame. This allows you to see all the parameters by looking only at the parameter area.</p><p>The compiler uses the following rules when passing arguments to subroutines:</p><ul class="spaceabove"><li class="li"><p>Parameters whose type is known at compile time are processed as follows:</p><ol class="ol"><li class="li"><p><a name="//apple_ref/doc/uid/TP40002438-DontLinkElementID_92"></a>Scalar, non–floating-point elements are placed in the general-purpose registers GPR3 through GPR10. As each register is used, the caller allocates the register’s corresponding section in the parameter area, as described in <span class="content_text"><a href="32bitPowerPC.html#//apple_ref/doc/uid/TP40002438-SW19">“Stack Structure.”</a></span> When general-purpose registers are exhausted, the caller places scalar, non–floating-point elements in the parameter area<a name="//apple_ref/doc/uid/TP40002438-DontLinkElementID_93"></a>.</p></li><li class="li"><p>The caller places floating-point parameters<a name="//apple_ref/doc/uid/TP40002438-DontLinkElementID_94"></a> in the floating-point registers FPR1 through FPR13. As each floating-point register is used, the caller skips one or more general-purpose registers, based on the size of the parameter. (For example, a <code>float</code> element causes one (4-byte) general-purpose register to be skipped. A <code>double</code> element causes two general-purpose registers to be skipped.) When floating-point registers are exhausted, the caller places floating-point elements in the parameter area<a name="//apple_ref/doc/uid/TP40002438-DontLinkElementID_95"></a>.</p></li><li class="li"><p>The caller places structures (<code>struct</code> elements<a name="//apple_ref/doc/uid/TP40002438-DontLinkElementID_96"></a>) with only one noncomposite member in general-purpose or floating-point registers, depending on whether the member is an integer or a floating-point value. For example, the caller places a structure comprised of a <code>float</code> member in a floating-point register, not a general-purpose register. When registers of the required type are exhausted, the caller places structures in the parameter area<a name="//apple_ref/doc/uid/TP40002438-DontLinkElementID_97"></a>.</p></li><li class="li"><p>The caller places <code>vector</code><a name="//apple_ref/doc/uid/TP40002438-DontLinkElementID_98"></a> parameters in vector registers V2 through V13. For procedures with a fixed number of parameters, the presence of vectors doesn’t affect the allocation of general-purpose registers and floating-point registers. The caller doesn’t allocate space for <code>vector</code> elements in the parameter area of its stack frame unless the number of <code>vector</code> elements exceeds the number of usable vector registers.</p></li><li class="li"><p>When the number of parameters exceeds the number of usable registers, the caller places the excess parameters in the parameter area<a name="//apple_ref/doc/uid/TP40002438-DontLinkElementID_99"></a>.</p></li></ol></li><li class="li"><p>Parameters whose type is not known at compile time (functions with variable-argument lists<a name="//apple_ref/doc/uid/TP40002438-DontLinkElementID_100"></a> or using pre–ANSI C<a name="//apple_ref/doc/uid/TP40002438-DontLinkElementID_101"></a> prototypes) are processed as follows:</p><ol class="ol"><li class="li"><p>The caller places nonvector elements both in general-purpose registers and in floating-point registers.</p><p>Because the compiler doesn’t know the type of the parameter, it cannot determine whether the argument should be passed in a general-purpose register or in a floating-point register. Therefore, callers place each argument in a floating-point register <em>and</em> the corresponding general-purpose registers based on the argument’s size.</p></li><li class="li"><p>The caller places <code>vector</code> elements in vector registers <em>and</em> general-purpose registers (each vector element requires four general-purpose registers. The caller also allocates space in the parameter area<a name="//apple_ref/doc/uid/TP40002438-DontLinkElementID_102"></a> that corresponds to the general-purpose registers used.</p></li></ol></li></ul><div class="importantbox"><a name="//apple_ref/doc/uid/TP40002438-DontLinkElementID_5" title="Important:"></a><p><strong>Important:</strong>&nbsp;<a name="//apple_ref/doc/uid/TP40002438-DontLinkElementID_103"></a>When the return type of the called function is a composite value (for example, <code>struct</code> or <code>union</code>), the caller passes a pointer in GPR3 as an implicit first parameter of the called function. Therefore, the functions’ declared parameters start at GPR4. The pointer points to a section of memory large enough to hold the return value. See <span class="content_text"><a href="32bitPowerPC.html#//apple_ref/doc/uid/TP40002438-SW13">“Returning Results”</a></span> for more information.</p><p></p></div><p>For example, consider the <code>foo</code> function, declared like this:</p><div class="codesample"><table><tr><td scope="row"><pre>void foo(SInt32 i1, float  f1, double d1, SInt16 s1, double d2,<span></span></pre></td></tr><tr><td scope="row"><pre>         UInt8  c1, UInt16 s2, float  f2, SInt32 i2);<span></span></pre></td></tr></table></div><p>The caller places each argument to <code>foo</code> in a general-purpose register, a floating-point register, or the parameter area, depending on the parameter’s data type and register availability. <span class="content_text">Table 5</span> describes this process.</p><a name="//apple_ref/doc/uid/TP40002438-SW11" title="Table 5Assigning parameters to registers and the parameter area"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 5&nbsp;&nbsp;</strong>Assigning parameters to registers and the parameter area</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Parameter</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Type</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Placed in</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Reason</p></th></tr><tr><td  scope="row"><p><code>i1</code></p></td><td ><p><code>SInt32</code></p></td><td ><p>GPR3</p></td><td ><p>Noncomposite, non–floating-point element.</p></td></tr><tr><td  scope="row"><p><code>f1</code></p></td><td ><p><code>float</code></p></td><td ><p>FPR1</p></td><td ><p>Floating-point element. GPR4 is skipped.</p></td></tr><tr><td  scope="row"><p><code>d1</code></p></td><td ><p><code>double</code></p></td><td ><p>FPR2</p></td><td ><p>Double-precision, floating-point element. GPR5 and GPR6 are skipped.</p></td></tr><tr><td  scope="row"><p><code>s1</code></p></td><td ><p><code>SInt16</code></p></td><td ><p>GPR7</p></td><td ><p>Noncomposite, non–floating-point element.</p></td></tr><tr><td  scope="row"><p><code>d2</code></p></td><td ><p><code>double</code></p></td><td ><p>FPR3</p></td><td ><p>Double-precision, floating-point element. GPR8 and GPR9 are skipped.</p></td></tr><tr><td  scope="row"><p><code>c1</code></p></td><td ><p><code>UInt8</code></p></td><td ><p>GPR10</p></td><td ><p>Noncomposite, non–floating-point element.</p></td></tr><tr><td  scope="row"><p><code>s2</code></p></td><td ><p><code>UInt16</code></p></td><td ><p><code>SP+56</code>, low half of word</p></td><td ><p>No general-purpose registers available.</p></td></tr><tr><td  scope="row"><p><code>f2</code></p></td><td ><p><code>float</code></p></td><td ><p>FPR4</p></td><td ><p>Floating-point element.</p></td></tr><tr><td  scope="row"><p><code>i2</code></p></td><td ><p><code>SInt32</code></p></td><td ><p><code>SP+60</code></p></td><td ><p>No general-purpose registers available.</p></td></tr></table></div><div class="notebox"><a name="//apple_ref/doc/uid/TP40002438-SW26" title="Note"></a><p><strong>Note:</strong>&nbsp;In this case, the caller doesn’t place any arguments that it places in general-purpose registers or floating-point registers in the parameter area.</p></div><p><span class="content_text">Figure 3</span> illustrates the assignment of the <code>foo</code> parameters to registers and the parameter area. Keep in mind that the only parameters placed in the parameter area are <code>s2</code> and <code>i2</code>.</p><br/><div><a name="//apple_ref/doc/uid/TP40002438-SW10" title="Figure 3Assignment of parameters to registers and the parameter area"></a><p><strong>Figure 3&nbsp;&nbsp;</strong>Assignment of parameters to registers and the parameter area</p><img src = "../art/calling_stparamarea.jpg" alt = "" ></div><br/><p>The called function can access the fixed parameters as usual. But it copies the general-purpose registers to the parameter area and accesses the values from there. <span class="content_text">Listing 4</span> shows a routine that accesses undefined parameters by walking through the stack.</p><a name="//apple_ref/doc/uid/TP40002438-SW12" title="Listing 4A variable-argument procedure"></a><p class="codesample"><strong>Listing 4&nbsp;&nbsp;</strong>A variable-argument procedure</p><div class="codesample"><table><tr><td scope="row"><pre>#include &lt;stdarg.h><span></span></pre></td></tr><tr><td scope="row"><pre>double dsum(int count, ...) {<span></span></pre></td></tr><tr><td scope="row"><pre>    double sum = 0.0;<span></span></pre></td></tr><tr><td scope="row"><pre>    double val;<span></span></pre></td></tr><tr><td scope="row"><pre>    va_list arg;<span></span></pre></td></tr><tr><td scope="row"><pre>    va_start(arg, count);<span></span></pre></td></tr><tr><td scope="row"><pre>    while (count > 0) {<span></span></pre></td></tr><tr><td scope="row"><pre>        val = va_arg(arg, double);<span></span></pre></td></tr><tr><td scope="row"><pre>        sum += val;<span></span></pre></td></tr><tr><td scope="row"><pre>        count--;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    va_end(arg);<span></span></pre></td></tr><tr><td scope="row"><pre>    return sum;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40002438-SW13" title="Returning Results"></a><h3>Returning Results</h3><a name="//apple_ref/doc/uid/TP40002438-DontLinkElementID_104"></a><p>The following list describes where a function’s return value is passed to the caller.</p><ul class="spaceabove"><li class="li"><p>Scalars smaller than 4 bytes (such as <code>char</code> and <code>short</code>) are placed in the low word of GPR3. The register’s high word is undefined.</p></li><li class="li"><p>Scalars 4 bytes in size (such as <code>long</code>, <code>int</code>, and pointers, including array pointers) are placed in GPR3.</p></li><li class="li"><p>Values of type <code>long long</code> are returned in the high word of GPR3 and the low word of GPR4.</p></li><li class="li"><p>Floating-point values are placed in FPR1.</p></li><li class="li"><p>Composite values (such as <code>struct</code> and <code>union</code>) and values larger than 4 bytes are placed at the location pointed to by GPR3. See <span class="content_text"><a href="32bitPowerPC.html#//apple_ref/doc/uid/TP40002438-SW14">“Passing Arguments”</a></span> for more information.</p></li></ul><a name="//apple_ref/doc/uid/TP40002438-DontLinkElementID_105"></a><a name="//apple_ref/doc/uid/TP40002438-DontLinkElementID_106"></a><a name="//apple_ref/doc/uid/TP40002438-SW18" title="Register Preservation"></a><h3>Register Preservation</h3><a name="//apple_ref/doc/uid/TP40002438-DontLinkElementID_107"></a><p><span class="content_text">Table 6</span> lists the 32-bit PowerPC architecture registers used in this environment and their volatility in function calls. Registers that must preserve their value after a function call are called <strong>nonvolatile</strong>.</p><a name="//apple_ref/doc/uid/TP40002438-SW7" title="Table 6Processor registers in the 32-bit PowerPC architecture"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 6&nbsp;&nbsp;</strong>Processor registers in the 32-bit PowerPC architecture</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Type</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Name</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Preserved</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Notes</p></th></tr><tr><td  scope="row"><p>General-purpose register</p></td><td ><p>GPR0</p></td><td ><p>No</p></td><td ><p></p></td></tr><tr><td  scope="row"><p></p></td><td ><p>GPR1</p></td><td ><p>Yes</p></td><td ><p>Used as the stack pointer to store parameters and other temporary data items.</p></td></tr><tr><td  scope="row"><p></p></td><td ><p>GPR2</p></td><td ><p>No</p></td><td ><p>Available for general use.</p></td></tr><tr><td  scope="row"><p></p></td><td ><p>GPR3</p></td><td ><p>No</p></td><td ><p>The caller passes parameter values to the called procedure in GPR3 through GPR10. The caller may also pass the address to storage where the callee places its return value in this register.</p></td></tr><tr><td  scope="row"><p></p></td><td ><p>GPR4–GPR10</p></td><td ><p>No</p></td><td ><p>Used by callers to pass parameter values to called functions (see notes for GPR3).</p></td></tr><tr><td  scope="row"><p></p></td><td ><p>GPR11</p></td><td ><p>Yes in nested functions. No in leaf functions.</p></td><td ><p>In nested functions, the caller passes its stack frame to the nested function in this register. In leaf functions, the register is available. For details on nested functions, see the GCC documentation. This register is also used by lazy stubs in dynamic code generation to point to the lazy pointer.</p></td></tr><tr><td  scope="row"><p></p></td><td ><p>GPR12</p></td><td ><p>No</p></td><td ><p>Set to the address of the branch target before an indirect call for dynamic code generation. This register is not set for a function that has been called directly; therefore, functions that may be called directly should not depend on this register being set up correctly. See <em><a href="../../MachOTopics/index.html#//apple_ref/doc/uid/TP40001519" target="_top">Mach-O Programming Topics</a></em> for more information.</p></td></tr><tr><td  scope="row"><p></p></td><td ><p>GPR13–GPR31</p></td><td ><p>Yes</p></td><td ><p></p></td></tr><tr><td  scope="row"><p>Floating-point register</p></td><td ><p>FPR0</p></td><td ><p>No</p></td><td ><p></p></td></tr><tr><td  scope="row"><p></p></td><td ><p>FPR1–FPR13</p></td><td ><p>No</p></td><td ><p>Used to pass floating-point parameters in function calls.</p></td></tr><tr><td  scope="row"><p></p></td><td ><p>FPR14–FPR31</p></td><td ><p>Yes</p></td><td ><p></p></td></tr><tr><td  scope="row"><p>Vector register</p></td><td ><p>V0–V19</p></td><td ><p>No</p></td><td ><p>The caller passes vector parameters in V2 to V13 during a function call.</p></td></tr><tr><td  scope="row"><p></p></td><td ><p>V20–V31</p></td><td ><p>Yes</p></td><td ><p></p></td></tr><tr><td  scope="row"><p>Special-purpose vector register</p></td><td ><p>VRSAVE</p></td><td ><p>Yes</p></td><td ><p>32-bit special-purpose register. Each bit in this register indicates whether the corresponding vector register must be saved during a thread or process context switch.</p></td></tr><tr><td  scope="row"><p>Link register</p></td><td ><p>LR</p></td><td ><p>No</p></td><td ><p>Stores the return address of the calling routine that called the current subroutine.</p></td></tr><tr><td  scope="row"><p>Count register</p></td><td ><p>CTR</p></td><td ><p>No</p></td><td ><p></p></td></tr><tr><td  scope="row"><p>Fixed-point exception register</p></td><td ><p>XER</p></td><td ><p>No</p></td><td ><p></p></td></tr><tr><td  scope="row"><p>Condition register fields</p></td><td ><p>CR0, CR1</p></td><td ><p>No</p></td><td ><p></p></td></tr><tr><td  scope="row"><p></p></td><td ><p>CR2–CR4</p></td><td ><p>Yes</p></td><td ><p></p></td></tr><tr><td  scope="row"><p></p></td><td ><p>CR5–CR7</p></td><td ><p>No</p></td><td ><p></p></td></tr></table></div><a name="//apple_ref/doc/uid/TP40002438-DontLinkElementID_108"></a>

        <br/><br/> 

        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../000-Introduction/introduction.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../110-64-bit_PowerPC_Function_Calling_Conventions/64bitPowerPC.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2009 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2009-02-04<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/DeveloperTools/Conceptual/LowLevelABI/100-32-bit_PowerPC_Function_Calling_Conventions/32bitPowerPC.html%3Fid%3DTP40002521-2.2&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/DeveloperTools/Conceptual/LowLevelABI/100-32-bit_PowerPC_Function_Calling_Conventions/32bitPowerPC.html%3Fid%3DTP40002521-2.2&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/DeveloperTools/Conceptual/LowLevelABI/100-32-bit_PowerPC_Function_Calling_Conventions/32bitPowerPC.html%3Fid%3DTP40002521-2.2&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>
