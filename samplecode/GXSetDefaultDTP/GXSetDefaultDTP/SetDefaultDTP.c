/********************************************************************************	SetDefaultDTP.c		This file handles the main event loop and dialog events for SetDefaultDTP.		©1995  Apple Computer, Inc.	All rights reserved.********************************************************************************/#include <GestaltEqu.h>#include <AppleEvents.h>#include "FSSetPrinter.h"#define kBaseResID			128#define kErrorALRTid		128#define kAboutALRTid		129#define kDialogResID		130#define kVisible			true#define kMoveToFront		(WindowPtr)-1L#define kSleep				60L#define kNilFilterProc		0L#define kGestaltMask		1L#define kOn					1#define kOff				0#define mApple				kBaseResID#define iAbout				1#define mFile				kBaseResID+1#define iQuit				1#define mEdit				kBaseResID+2#define iCut				1#define iCopy				2#define iPaste				3#define iClear				4#define iGetText			1#define iText				3#define kNoIdleProc			nil#define kNoFilterProc		nil#define kMaxTextSize		255/*************//*  Globals  *//*************/Boolean		gDone;DialogPtr	gDialogPtr;/***************//*  Functions  *//***************/void		ToolboxInit( void );void		MenuBarInit( void );void		AEInit( void );void		SetUpDLOG( void );void		EventLoop( void );void		DoEvent( EventRecord *eventPtr );void		DoDialogEvent( EventRecord *eventPtr );void		HandleMouseDown( EventRecord *eventPtr );void		HandleEditChoice( short item );void		HandleMenuChoice( long menuChoice );void		HandleAppleChoice( short item );void		HandleFileChoice( short item );void		DoError( Str255 errorString );void InstallDefaultOutline(DialogPtr dlog, short button);void FlashDlogItem( DialogPtr dlog, short itemNum );              typedef struct{	long			placeholder;	Rect			location;	unsigned char	itemType;	unsigned char	extraLength;} DITLitem;/******************************** main *********/void	main( void ){	ToolboxInit();	MenuBarInit();	AEInit();		SetUpDLOG();		EventLoop();}/****************** ToolboxInit *********************/void	ToolboxInit( void ){	InitGraf( &qd.thePort );	InitFonts();	InitWindows();	InitMenus();	TEInit();	InitDialogs( 0L );	InitCursor();}/****************** MenuBarInit ***********************/void	MenuBarInit( void ){	Handle			menuBar;	MenuHandle		menu;		menuBar = GetNewMBar( kBaseResID );		if ( menuBar == NULL )		DoError( "\pCouldn't load the MBAR resource..." );		SetMenuBar( menuBar );	menu = GetMHandle( mApple );	AddResMenu( menu, 'DRVR' );		DrawMenuBar();}/******************************** AEInit *********/void	AEInit( void ){	OSErr	err;	long	feature;		err = Gestalt( gestaltAppleEventsAttr, &feature );		if ( err != noErr )		DoError( "\pError returned by Gestalt!" );			if ( !( feature & ( kGestaltMask << gestaltAppleEventsPresent ) ) )		DoError( "\pThis configuration does not support Apple events..." );}/****************** SetUpDLOG ***********************/void	SetUpDLOG( void ){	gDialogPtr = GetNewDialog( kDialogResID, NULL, kMoveToFront );	if ( gDialogPtr == NULL )		DoError( "\pCouldn't load the DLOG resource..." );			InstallDefaultOutline(gDialogPtr,iGetText);		ShowWindow( gDialogPtr );	SetPort( gDialogPtr );		SelIText( gDialogPtr, iText, 0, 32767 );	TEFromScrap();}/******************************** EventLoop *********/void	EventLoop( void ){			EventRecord		event;		gDone = false;	while ( gDone == false )	{		if ( WaitNextEvent( everyEvent, &event, kSleep, NULL ) )			DoEvent( &event );					TEIdle( ((DialogPeek)gDialogPtr)->textH );	}}/************************************* DoEvent	 */void	DoEvent( EventRecord *eventPtr ){	if ( IsDialogEvent( eventPtr ) )	{		DoDialogEvent( eventPtr );	}	else if ( eventPtr->what == mouseDown )	{		HandleMouseDown( eventPtr );	}}/************************************* DoDialogEvent	 */void	DoDialogEvent( EventRecord *eventPtr ){	short		itemHit;	short		itemType;	Handle		itemHandle;	Rect		itemRect;	char		theChar;	DialogPtr	dialog;	Str255		theText;	long		menuAndItem;	Boolean		didEvent = false;	switch ( eventPtr->what )	{		case keyDown:		case autoKey:			theChar = eventPtr->message & charCodeMask;						if ( (eventPtr->modifiers & cmdKey) != 0 ) 			{				menuAndItem = MenuKey( theChar );								if ( HiWord( menuAndItem ) != 0 )				{					HandleMenuChoice( menuAndItem );					return;				}			}			else if (theChar == 0x0D || theChar == 0x03)	// return or enter			{				FlashDlogItem(gDialogPtr,iGetText);				GetDItem( gDialogPtr, iText, &itemType, &itemHandle, &itemRect );				GetIText( itemHandle, theText );				SendTestAE(theText);								SelIText( gDialogPtr, iText, 0, 32767 );				didEvent = true;			}			break;		case osEvt:			if (eventPtr->message & 0x01000000)				if (eventPtr->message & resumeFlag)	// resume event				{					TEFromScrap();				}				else	// suspend event				{					ZeroScrap();					TEToScrap();				}			break;	}		if (!didEvent)		if ( DialogSelect( eventPtr, &dialog, &itemHit ) )		{			switch ( itemHit )			{				case iGetText:					GetDItem( dialog, iText, &itemType, &itemHandle, &itemRect );					GetIText( itemHandle, theText );					SendTestAE(theText);										SelIText( dialog, iText, 0, 32767 );					break;			}		}}/************************************* HandleMouseDown */void	HandleMouseDown( EventRecord *eventPtr ){	WindowPtr		window;	short			thePart;	long			menuChoice;		thePart = FindWindow( eventPtr->where, &window );		switch ( thePart )	{		case inMenuBar:			menuChoice = MenuSelect( eventPtr->where );			HandleMenuChoice( menuChoice );			break;		case inSysWindow : 			SystemClick( eventPtr, window );			break;		case inContent:			SelectWindow( window );			break;		case inDrag : 			DragWindow( window, eventPtr->where, &qd.screenBits.bounds );			break;	}}/****************** HandleMenuChoice ***********************/void	HandleMenuChoice( long menuChoice ){	short	menu;	short	item;		if ( menuChoice != 0 )	{		menu = HiWord( menuChoice );		item = LoWord( menuChoice );				switch ( menu )		{			case mApple:				HandleAppleChoice( item );				break;			case mFile:				HandleFileChoice( item );				break;			case mEdit:				HandleEditChoice( item );				break;		}		HiliteMenu( 0 );	}}/****************** HandleAppleChoice ***********************/void	HandleAppleChoice( short item ){	MenuHandle	appleMenu;	Str255		accName;	short		accNumber;		switch ( item )	{		case iAbout:			NoteAlert( kAboutALRTid, NULL );			break;		default:			appleMenu = GetMHandle( mApple );			GetItem( appleMenu, item, accName );			accNumber = OpenDeskAcc( accName );			break;	}}/****************** HandleFileChoice ***********************/void	HandleFileChoice( short item ){	switch ( item )	{		case iQuit:			gDone = true;			break;	}}/****************** HandleEditChoice ***********************/void	HandleEditChoice( short item ){	switch ( item )	{		case iCut:			DialogCut(gDialogPtr);			break;		case iCopy:			DialogCopy(gDialogPtr);			break;		case iPaste:			DialogPaste(gDialogPtr);			break;		case iClear:			DialogDelete(gDialogPtr);			break;	}}/***************** DoError ********************/void	DoError( Str255 errorString ){	ParamText( errorString, "\p", "\p", "\p" );		StopAlert( kErrorALRTid, kNilFilterProc );		ExitToShell();}Boolean DialogItemEnabled(DialogPtr dlog, short item){	ControlHandle		buttonHandle = nil;	Rect				buttonBox;	short				type;	GetDItem(dlog, item, &type, (Handle*)&buttonHandle, &buttonBox);	return ((type & itemDisable) == false);} // DialogItemEnabled pascal void DrawDefaultProc(DialogPtr dlog, short item){	short				defaultButton;		//	// Don't call GetDItem if the default button # has a strange value	//	defaultButton = ((DialogPeek)dlog)->aDefItem;	if( defaultButton > 0 )	{		short				type;		Handle				userHandle;		Rect				outlineBox;		//		// Only draw the bold outline around the default button		// if it really is a button		//		GetDItem(dlog, defaultButton, &type, &userHandle, &outlineBox);		if( (type & (ctrlItem + btnCtrl)) == ctrlItem + btnCtrl )		{			PenState			saveState;			short				buttonOval;			GetPenState( &saveState );			InsetRect(&outlineBox,-4,-4);						//			// We want to draw the thick line with a normal			// pen pattern that is 3 pixels wide			//			PenNormal();			PenSize(3,3);			PenMode(srcCopy);						//			// If the button we are outlining is disabled,			// draw the outline with a gray pattern.			//			if( !DialogItemEnabled(dlog, defaultButton ) )			{				PenPat(&qd.gray);			}						//			// Calculate the curvature to use and draw the thick line			//			buttonOval = 2 + (outlineBox.bottom - outlineBox.top) / 2;			FrameRoundRect(&outlineBox,buttonOval,buttonOval);						SetPenState( &saveState );		}	}} // DrawDefaultProc short AddNewUserItem( DialogPtr dlog ){	DialogPeek		theDialog		= (DialogPeek)dlog;	short**			itemHandle		= (short**)theDialog->items;	short			nItems			= **itemHandle + 1;	short			newItem			= 0;	DITLitem*		ditlPtr;	Size			itemHandleSize;		itemHandleSize = GetHandleSize( (Handle)itemHandle );	SetHandleSize( (Handle)itemHandle, itemHandleSize + sizeof(DITLitem) );	if( MemError() == noErr )	{		ditlPtr = (DITLitem*) ( (*itemHandle) + (itemHandleSize / sizeof(short)) );				ditlPtr->placeholder = 0;		ditlPtr->itemType = userItem;		ditlPtr->extraLength = 0;				newItem = nItems + 1;		**itemHandle = newItem - 1;	}		return newItem;} // AddNewUserItem void InstallDefaultOutline(DialogPtr dlog, short button){	short			userItem;	short			type;	Handle			item;	Rect			box;	Rect			userBox;		((DialogPeek)dlog)->aDefItem = button;	userItem = AddNewUserItem( dlog );	if( userItem > 0 )	{		GetDItem(dlog, button, &type, &item, &box);		InsetRect(&box,-4,-4);		GetDItem(dlog, userItem, &type, &item, &userBox);#if USESROUTINEDESCRIPTORS		SetDItem(dlog,userItem,type,(Handle)&gDrawDefaultProcRD,&userBox);#else		SetDItem(dlog,userItem,type,(Handle)DrawDefaultProc,&userBox);#endif	}}void FlashDlogItem( DialogPtr dlog, short itemNum ){	Handle		itemHandle;	short		itemType;	Rect		iRect;	long		tock;		GetDItem(dlog,itemNum,&itemType,&itemHandle,&iRect);	HiliteControl((ControlHandle)itemHandle,1);	Draw1Control((ControlHandle)itemHandle);	tock = TickCount() + 10;	do {} while( tock > TickCount() );	HiliteControl((ControlHandle)itemHandle,0);	Draw1Control((ControlHandle)itemHandle);} // FlashDlogItem 