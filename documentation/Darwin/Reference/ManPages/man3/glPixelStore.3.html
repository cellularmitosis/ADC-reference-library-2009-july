<html><head><title>Mac OS X
 Manual Page For glPixelStore(3)</title>
<style type="text/css"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { font-size: 1px; background: #ffffff; color: #ffffff; } --></style>
<style type="text/css" media="print, aural, braille, embossed, projection, tty"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { display: none; } --></style>
</head><body bgcolor="white">
<a name="//apple_ref/doc/man/3/glPixelStore" title="Mac OS X
 Manual Page for glPixelStore(3)"><!-- headerDoc=man; indexgroup=Section 3; uid="//apple_ref/doc/man/3/glPixelStore"; name=glPixelStore(3) --></a>
<!--#include virtual="/includes/framesetheader"-->
<table width=600><tr><td scope="row">
<!-- begin breadcrumb insert request --><font face="Geneva,Helvetica,Arial" size="1">
 <a target="_top" href="http://developer.apple.com">ADC Home</a> <b>&gt;</b> <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> <b>&gt;</b> <a href="../../../../../reference/index.html#//apple_ref/doc/uid/TP30001281" target="_top">Reference</a> <b>&gt;</b> <!-- a href="" target="_top" -->Mac OS X<!-- /a --> <b>&gt;</b> <a href="../index.html#//apple_ref/doc/framework/manpages" target="_top">Mac OS X Man Pages</a></font>
<!-- end breadcrumb insert request -->
<p>&nbsp;</p>
</td></tr></table>
<!-- end of header -->
<table border="0"  cellpadding="2" cellspacing="2" width="630pt"><tr><td valign="top" height="12" colspan="5" scope="row">
<p style='text-align:justify;'>This document is a Mac OS X manual page.  Manual pages are a command-line technology
for providing documentation.  You can view these manual pages locally using the
<a href="../man1/man.1.html#//apple_ref/doc/man/1/man">man(1)</a> command.
These manual pages come from many different sources, and thus, have a variety of writing
styles.</p>
<p style='text-align:justify;'>For more information about the manual page format, see the manual page for 
<a href="../man5/manpages.5.html#//apple_ref/doc/man/5/manpages">manpages(5)</a>.</p>
</td></tr></table>
<hr />
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row"><pre class="manpages"><tt>
GLPIXELSTORE(3G)                                                                            GLPIXELSTORE(3G)



<b>NAME</b>
       <b>glPixelStoref,</b> <b>glPixelStorei</b> - set pixel storage modes


<b>C</b> <b>SPECIFICATION</b>
       void <b>glPixelStoref</b>( GLenum <u>pname</u>,
                           GLfloat <u>param</u> )
       void <b>glPixelStorei</b>( GLenum <u>pname</u>,
                           GLint <u>param</u> )


<b>PARAMETERS</b>
       <u>pname</u>  Specifies  the  symbolic  name  of  the parameter to be set.  Six values affect the packing of
              pixel   data   into   memory:   <b>GL_PACK_SWAP_BYTES</b>,   <b>GL_PACK_LSB_FIRST</b>,   <b>GL_PACK_ROW_LENGTH</b>,
              <b>GL_PACK_IMAGE_HEIGHT</b>,   <b>GL_PACK_SKIP_PIXELS</b>,   <b>GL_PACK_SKIP_ROWS</b>,   <b>GL_PACK_SKIP_IMAGES</b>,   and
              <b>GL_PACK_ALIGNMENT</b>.   Six  more   affect   the   unpacking   of   pixel   data   <u>from</u>   memory:
              <b>GL_UNPACK_SWAP_BYTES</b>,   <b>GL_UNPACK_LSB_FIRST</b>,   <b>GL_UNPACK_ROW_LENGTH</b>,   <b>GL_UNPACK_IMAGE_HEIGHT</b>,
              <b>GL_UNPACK_SKIP_PIXELS</b>, <b>GL_UNPACK_SKIP_ROWS</b>, <b>GL_UNPACK_SKIP_IMAGES</b>, and <b>GL_UNPACK_ALIGNMENT</b>.

       <u>param</u>  Specifies the value that <u>pname</u> is set to.

<b>DESCRIPTION</b>
       <b>glPixelStore</b> sets pixel storage modes that  affect  the  operation  of  subsequent  <b>glDrawPixels</b>  and
       <b>glReadPixels</b>  as  well  as  the unpacking of polygon stipple patterns (see <b>glPolygonStipple</b>), bitmaps
       (see <b>glBitmap</b>), texture patterns  (see  <b>glTexImage1D</b>,  <b>glTexImage2D</b>,  <b>glTexImage3D</b>,  <b>glTexSubImage1D</b>,
       <b>glTexSubImage2D</b>, <b>glTexSubImage3D</b>).  Additionally, if the <b>GL_ARB_imaging</b> extension is supported, pixel
       storage modes affect  convolution  filters  (see  <b>glConvolutionFilter1D</b>,  <b>glConvolutionFilter2D</b>,  and
       <b>glSeparableFilter2D</b>, color table (see <b>glColorTable</b>, and <b>glColorSubTable</b>, and unpacking histogram (See
       <b>glHistogram</b>), and minmax (See <b>glMinmax</b>) data.

       <u>pname</u> is a symbolic constant indicating the parameter to be set, and <u>param</u> is the new value.  Six  of
       the  twelve  storage parameters affect how pixel data is returned to client memory.  They are as fol-<font color="#ffffff" class="whiteout">lows:&nbsp;follows:</font>
       lows:

       <b>GL_PACK_SWAP_BYTES</b>
                 If true, byte ordering for multibyte color components, depth components, color indices,  or
                 stencil  indices  is reversed.  That is, if a four-byte component consists of bytes b0, b1,
                 b2, b2 it  is  stored  in  memory  as  b3,  b2,  b1,  b0  if  <b>GL_PACK_SWAP_BYTES</b>  is  true.
                 <b>GL_PACK_SWAP_BYTES</b>  has no effect on the memory order of components within a pixel, only on
                 the order of bytes within components or indices.  For example, the three  components  of  a
                 <b>GL_RGB</b>  pixel are always stored with red first, green second, and blue third, regardless of
                 the value of <b>GL_PACK_SWAP_BYTES</b>.

       <b>GL_PACK_LSB_FIRST</b>
                 If true, bits are ordered within a byte from least significant to most significant;  other-<font color="#ffffff" class="whiteout">wise,&nbsp;otherwise,</font>
                 wise,  the  first bit in each byte is the most significant one.  This parameter is signifi-<font color="#ffffff" class="whiteout">cant&nbsp;significant</font>
                 cant for bitmap data only.

       <b>GL_PACK_ROW_LENGTH</b>
                 If greater than 0, <b>GL_PACK_ROW_LENGTH</b> defines the number of pixels in a row.  If the  first
                 pixel  of  a row is placed at location p in memory, then the location of the first pixel of
                 the next row is obtained by skipping


                                            k = nl for s&gt;=a, (a/s)(snl/a) for s&lt;a

                 components or indices, where n is the number of components or indices in a pixel, l is  the
                 number  of  pixels in a row (<b>GL_PACK_ROW_LENGTH</b> if it is greater than 0, the width argument
                 to the pixel routine otherwise), a is the value of <b>GL_PACK_ALIGNMENT</b>, and s is the size, in
                 bytes, of a single component (if a &lt; s, then it is as if a = s).  In the case of 1-bit val-
                 ues, the location of the next row is obtained by skipping


                                                       k = 8a (nl/8a)


                 components or indices.

                 The word <u>component</u> in this description refers to the  nonindex  values  red,  green,  blue,
                 alpha, and depth.  Storage  <b>GL_RGB</b>, for example, has three components per pixel: first red,
                 then green, and finally blue.

       <b>GL_PACK_IMAGE_HEIGHT</b>
                 If greater than 0, <b>GL_PACK_IMAGE_HEIGHT</b> defines the number of pixels  in  an  image  three-<font color="#ffffff" class="whiteout">dimensional&nbsp;threedimensional</font>
                 dimensional  texture  volume.   Where  ``image''  is defined by all pixels sharing the same
                 third dimension index.  If the first pixel of a row is placed at location p in memory, then
                 the location of the first pixel of the next row is obtained by skipping


                                           k = nlh for s&gt;=a, (a/s)(snlh/a) for s&lt;a


                 components  or indices, where n is the number of components or indices in a pixel, l is the
                 number of pixels in a row (<b>GL_PACK_ROW_LENGTH</b> if it is greater than 0,  the width  argument
                 to  <b>glTexImage3d</b> otherwise), h is the number of rows in a pixel image (<b>GL_PACK_IMAGE_HEIGHT</b>
                 if it is greater than 0, the height arguemnt to the <b>glTexImage3D</b> routine otherwise),  a  is
                 the value of <b>GL_PACK_ALIGNMENT</b>, and s is the size, in bytes, of a single component (if  a &lt;
                 s, then it is as if a = s).

                 The word <u>component</u> in this description refers to the  nonindex  values  red,  green,  blue,
                 alpha, and depth.  Storage  <b>GL_RGB</b>, for example, has three components per pixel: first red,
                 then green, and finally blue.

       <b>GL_PACK_SKIP_PIXELS</b>, <b>GL_PACK_SKIP_ROWS</b>, and <b>GL_PACK_SKIP_IMAGES</b>
                 These values are provided as a convenience to the programmer; they provide no functionality
                 that  cannot be duplicated simply by incrementing the pointer passed to <b>glReadPixels</b>.  Set-
                 ting <b>GL_PACK_SKIP_PIXELS</b> to i is equivalent to incrementing the pointer by i  n  components
                 or  indices,  where  n  is  the  number  of  components  or indices in each pixel.  Setting
                 <b>GL_PACK_SKIP_ROWS</b> to j is equivalent to incrementing the  pointer  by  j  m  components  or
                 indices,  where  m  is the number of components or indices per row, as just computed in the
                 <b>GL_PACK_ROW_LENGTH</b> section.  Setting <b>GL_PACK_SKIP_IMAGES</b> to k is equivalent to incrementing
                 the  pointer  by k p, where p is the number of components or indices per image, as computed
                 in the <b>GL_PACK_IMAGE_HEIGHT</b> section.

       <b>GL_PACK_ALIGNMENT</b>
                 Specifies the alignment requirements for the start of each pixel row in memory.  The allow-<font color="#ffffff" class="whiteout">able&nbsp;allowable</font>
                 able values are 1 (byte-alignment), 2 (rows aligned to even-numbered bytes), 4 (word-align-<font color="#ffffff" class="whiteout">ment),&nbsp;(word-alignment),</font>
                 ment), and 8 (rows start on double-word boundaries).

       The other six of the twelve storage parameters affect how pixel data  is  read  from  client  memory.
       These   values   are   significant   for   <b>glDrawPixels</b>,  <b>glTexImage1D</b>,  <b>glTexImage2D</b>,  <b>glTexImage3D</b>,
       <b>glTexSubImage1D</b>, <b>glTexSubImage2D</b>, <b>glTexSubImage3D</b>, <b>glBitmap</b>, and <b>glPolygonStipple</b>.

       Additionally,  if  the  <b>GL_ARB_imaging</b>  extension  is   supported,   <b>glColorTable</b>,   <b>glColorSubTable</b>,
       <b>glConvolutionFilter1D</b>, <b>glConvolutionFilter2D</b>, and <b>glSeparableFilter2D</b>.  They are as follows:

       <b>GL_UNPACK_SWAP_BYTES</b>
              If  true,  byte  ordering  for multibyte color components, depth components, color indices, or
              stencil indices is reversed.  That is, if a four-byte component consists of bytes b0, b1,  b2,
              b3,   it   is  taken  from  memory  as  b3,  b2,  b1,  b0  if  <b>GL_UNPACK_SWAP_BYTES</b>  is  true.
              <b>GL_UNPACK_SWAP_BYTES</b> has no effect on the memory order of components within a pixel,  only  on
              the  order  of  bytes  within  components  or indices.  For example, the three components of a
              <b>GL_RGB</b>  pixel are always stored with red first, green second, and blue  third,  regardless  of
              the value of <b>GL_UNPACK_SWAP_BYTES</b>.

       <b>GL_UNPACK_LSB_FIRST</b>
              If true, bits are ordered within a byte from least significant to most significant; otherwise,
              the first bit in each byte is the most significant one.  This  is  relevant  only  for  bitmap
              data.

       <b>GL_UNPACK_ROW_LENGTH</b>
              If  greater  than 0, <b>GL_UNPACK_ROW_LENGTH</b> defines the number of pixels in a row.  If the first
              pixel of a row is placed at location p in memory, then the location of the first pixel of  the
              next row is obtained by skipping


                                          k = nl for s&gt;=a, (a/s)(snl/a) for s&lt;a


              components  or  indices,  where  n is the number of components or indices in a pixel, l is the
              number of pixels in a row (<b>GL_UNPACK_ROW_LENGTH</b> if it is greater than 0, the width argument to
              the  pixel  routine  otherwise),  a is the value of <b>GL_UNPACK_ALIGNMENT</b>, and s is the size, in
              bytes, of a single component (if  a &lt; s, then it is as if a = s).  In the case of  1-bit  val-
              ues, the location of the next row is obtained by skipping


                                                      k = 8a (nl/8a)


              components or indices.

              The  word <u>component</u> in this description refers to the nonindex values red, green, blue, alpha,
              and depth.  Storage  <b>GL_RGB</b>, for example, has three components  per  pixel:  first  red,  then
              green, and finally blue.

       <b>GL_UNPACK_IMAGE_HEIGHT</b>
              If greater than 0, <b>GL_UNPACK_IMAGE_HEIGHT</b> defines the number of pixels in an image of a three-<font color="#ffffff" class="whiteout">dimensional&nbsp;threedimensional</font>
              dimensional texture volume.  Where ``image'' is defined by all pixel sharing  the  same  third
              dimension  index.   If  the  first  pixel of a row is placed at location p in memory, then the
              location of the first pixel of the next row is obtained by skipping


                                         k = nlh for s&gt;=a, (a/s)(snlh/a) for s&lt;a


              components or indices, where n is the number of components or indices in a  pixel,  l  is  the
              number of pixels in a row (<b>GL_UNPACK_ROW_LENGTH</b> if it is greater than 0, the width argument to
              <b>glTexImage3D</b> otherwise), h is the number of rows in an image (<b>GL_UNPACK_IMAGE_HEIGHT</b> if it  is
              greater  than  0,  the  height  argument  to  <b>glTexImage3D</b>  otherwise),  a  is  the  value  of
              <b>GL_UNPACK_ALIGNMENT</b>, and s is the size, in bytes, of a single component (if  a &lt; s, then it is
              as if a = s).

              The  word <u>component</u> in this description refers to the nonindex values red, green, blue, alpha,
              and depth.  Storage  <b>GL_RGB</b>, for example, has three components  per  pixel:  first  red,  then
              green, and finally blue.

       <b>GL_UNPACK_SKIP_PIXELS</b> and <b>GL_UNPACK_SKIP_ROWS</b>
              These  values  are  provided as a convenience to the programmer; they provide no functionality
              that cannot be duplicated by incrementing the pointer passed  to  <b>glDrawPixels</b>,  <b>glTexImage1D</b>,
              <b>glTexImage2D</b>,   <b>glTexSubImage1D</b>,  <b>glTexSubImage2D</b>,  <b>glBitmap</b>,  or  <b>glPolygonStipple</b>.   Setting
              <b>GL_UNPACK_SKIP_PIXELS</b> to i is equivalent to incrementing the pointer  by  i  n  components  or
              indices,   where   n  is  the  number  of  components  or  indices  in  each  pixel.   Setting
              <b>GL_UNPACK_SKIP_ROWS</b> to j is equivalent to incrementing  the  pointer  by  j  k  components  or
              indices,  where  k  is  the  number  of components or indices per row, as just computed in the
              <b>GL_UNPACK_ROW_LENGTH</b> section.

       <b>GL_UNPACK_ALIGNMENT</b>
              Specifies the alignment requirements for the start of each pixel row in memory.  The allowable
              values  are  1  (byte-alignment), 2 (rows aligned to even-numbered bytes), 4 (word-alignment),
              and 8 (rows start on double-word boundaries).

       The following table gives the type, initial value, and range of valid values for each storage parame-
       ter that can be set with <b>glPixelStore</b>.


        pname                  Type    Initial Valid
                                        Value  Range
        GL_PACK_SWAP_BYTES     boolean false   true or false
        GL_PACK_LSB_FIRST      boolean false   true or false
        GL_PACK_ROW_LENGTH     integer 0       [0,inf]
        GL_PACK_IMAGE_HEIGHT   integer 0       [0,inf]
        GL_PACK_SKIP_ROWS      integer 0       [0,inf]
        GL_PACK_SKIP_PIXELS    integer 0       [0,inf]
        GL_PACK_SKIP_IMAGES    integer 0       [0,inf]
        GL_PACK_ALIGNMENT   <b>integer</b> <b>4</b>       <b>1,</b> <b>2,</b> <b>4,</b> <b>or</b> <b>8</b>

        <b>GL_UNPACK_SWAP_BYTES</b>   <b>boolean</b> <b>false</b>   <b>true</b> <b>or</b> <b>false</b>
        <b>GL_UNPACK_LSB_FIRST</b>    <b>boolean</b> <b>false</b>   <b>true</b> <b>or</b> <b>false</b>
        <b>GL_UNPACK_ROW_LENGTH</b>   <b>integer</b> <b>0</b>       <b>[0,inf]</b>
        <b>GL_UNPACK_IMAGE_HEIGHT</b> <b>integer</b> <b>0</b>       <b>[0,inf]</b>
        <b>GL_UNPACK_SKIP_ROWS</b>    <b>integer</b> <b>0</b>       <b>[0,inf]</b>
        <b>GL_UNPACK_SKIP_PIXELS</b>  <b>integer</b> <b>0</b>       <b>[0,inf]</b>
        <b>GL_UNPACK_SKIP_IMAGES</b>  <b>integer</b> <b>0</b>       <b>[0,inf]</b>
        <b>GL_UNPACK_ALIGNMENT</b>    <b>integer</b> <b>4</b>       <b>1,</b> <b>2,</b> <b>4,</b> <b>or</b> <b>8</b>


       <b>glPixelStoref</b>  <b>can</b>  <b>be</b> <b>used</b> <b>to</b> <b>set</b> <b>any</b> <b>pixel</b> <b>store</b> <b>parameter.</b>  <b>If</b> <b>the</b> <b>parameter</b> <b>type</b> <b>is</b> <b>boolean,</b> <b>then</b>
       <b>if</b> <u>param</u> <b>is</b> <b>0,</b> <b>the</b> <b>parameter</b> <b>is</b> <b>false;</b> <b>otherwise</b> <b>it</b> <b>is</b> <b>set</b> <b>to</b> <b>true.</b>   <b>If</b>  <u>pname</u>  <b>is</b>  <b>a</b>  <b>integer</b>  <b>type</b>
       <b>parameter,</b> <u>param</u> <b>is</b> <b>rounded</b> <b>to</b> <b>the</b> <b>nearest</b> <b>integer.</b>

       Likewise,  <b>glPixelStorei</b>  can also be used to set any of the pixel store parameters.  Boolean parame-<font color="#ffffff" class="whiteout">ters&nbsp;parameters</font>
       ters are set to false if <u>param</u> is 0 and true otherwise.

<b>NOTES</b>
       The pixel storage modes  in  effect  when  <b>glDrawPixels</b>,  <b>glReadPixels</b>,  <b>glTexImage1D</b>,  <b>glTexImage2D</b>,
       <b>glTexImage3D</b>,  <b>glTexSubImage1D</b>,  <b>glTexSubImage2D</b>,  <b>glTexSubImage3D</b>,  <b>glBitmap</b>, or <b>glPolygonStipple</b> is
       placed in a display list control the interpretation of memory data.  Likewise, if the  <b>GL_ARB_imaging</b>
       extension  is  supported,  the  pixel  storage  modes  in  effect when <b>glColorTable</b>, <b>glColorSubTable</b>,
       <b>glConvolutionFilter1D</b>, <b>glConvolutionFilter2D</b>, of <b>glSeparableFilter2D</b> is placed in a display list con-<font color="#ffffff" class="whiteout">trol&nbsp;control</font>
       trol  the  intrepretation  of  memory data.  The pixel storage modes in effect when a display list is
       executed are not significant.

       Pixel storage modes are client state and must be pushed and restored using
       <b>glPushClientAttrib</b> and <b>glPopClientAttrib</b>.

<b>ERRORS</b>
       <b>GL_INVALID_ENUM</b> is generated if <u>pname</u> is not an accepted value.

       <b>GL_INVALID_VALUE</b> is generated if a negative row length, pixel skip, or row skip value  is  specified,
       or if alignment is specified as other than 1, 2, 4, or 8.

       <b>GL_INVALID_OPERATION</b>  is  generated  if <b>glPixelStore</b> is executed between the execution of <b>glBegin</b> and
       the corresponding execution of <b>glEnd</b>.

<b>ASSOCIATED</b> <b>GETS</b>
       <b>glGet</b> with argument <b>GL_PACK_SWAP_BYTES</b>
       <b>glGet</b> with argument <b>GL_PACK_LSB_FIRST</b>
       <b>glGet</b> with argument <b>GL_PACK_ROW_LENGTH</b>
       <b>glGet</b> with argument <b>GL_PACK_IMAGE_HEIGHT</b>
       <b>glGet</b> with argument <b>GL_PACK_SKIP_ROWS</b>
       <b>glGet</b> with argument <b>GL_PACK_SKIP_PIXELS</b>
       <b>glGet</b> with argument <b>GL_PACK_SKIP_IMAGES</b>
       <b>glGet</b> with argument <b>GL_PACK_ALIGNMENT</b>
       <b>glGet</b> with argument <b>GL_UNPACK_SWAP_BYTES</b>
       <b>glGet</b> with argument <b>GL_UNPACK_LSB_FIRST</b>
       <b>glGet</b> with argument <b>GL_UNPACK_ROW_LENGTH</b>
       <b>glGet</b> with argument <b>GL_UNPACK_IMAGE_HEIGHT</b>
       <b>glGet</b> with argument <b>GL_UNPACK_SKIP_ROWS</b>
       <b>glGet</b> with argument <b>GL_UNPACK_SKIP_PIXELS</b>
       <b>glGet</b> with argument <b>GL_UNPACK_SKIP_IMAGES</b>
       <b>glGet</b> with argument <b>GL_UNPACK_ALIGNMENT</b>

<b>SEE</b> <b>ALSO</b>
       <a href="glBitmap.3.html#//apple_ref/doc/man/3/glBitmap"><b>glBitmap</b>(3G)</a>,    <a href="glColorTable.3.html#//apple_ref/doc/man/3/glColorTable"><b>glColorTable</b>(3G)</a>,     <a href="glColorSubTable.3.html#//apple_ref/doc/man/3/glColorSubTable"><b>glColorSubTable</b>(3G)</a>,     <a href="glConvolutionFilter1D.3.html#//apple_ref/doc/man/3/glConvolutionFilter1D"><b>glConvolutionFilter1D</b>(3G)</a>,     <a href="glConvolutionFilter2D.3.html#//apple_ref/doc/man/3/glConvolutionFilter2D"><b>glConvolutionFilter2D</b>(3G)</a>,
       <a href="glSeparableFilter2D.3.html#//apple_ref/doc/man/3/glSeparableFilter2D"><b>glSeparableFilter2D</b>(3G)</a>,  <a href="glDrawPixels.3.html#//apple_ref/doc/man/3/glDrawPixels"><b>glDrawPixels</b>(3G)</a>,  <a href="glHistogram.3.html#//apple_ref/doc/man/3/glHistogram"><b>glHistogram</b>(3G)</a>, <a href="glMinmax.3.html#//apple_ref/doc/man/3/glMinmax"><b>glMinmax</b>(3G)</a>, <a href="glPixelMap.3.html#//apple_ref/doc/man/3/glPixelMap"><b>glPixelMap</b>(3G)</a>, <a href="glPixelTransfer.3.html#//apple_ref/doc/man/3/glPixelTransfer"><b>glPixelTransfer</b>(3G)</a>, <a href="glPixelZoom.3.html#//apple_ref/doc/man/3/glPixelZoom"><b>glPixelZoom</b>(3G)</a>,
       <a href="glPolygonStipple.3.html#//apple_ref/doc/man/3/glPolygonStipple"><b>glPolygonStipple</b>(3G)</a>,  <a href="glPushClientAttrib.3.html#//apple_ref/doc/man/3/glPushClientAttrib"><b>glPushClientAttrib</b>(3G)</a>,  <a href="glReadPixels.3.html#//apple_ref/doc/man/3/glReadPixels"><b>glReadPixels</b>(3G)</a>,   <a href="glTexImage1D.3.html#//apple_ref/doc/man/3/glTexImage1D"><b>glTexImage1D</b>(3G)</a>,   <a href="glTexImage2D.3.html#//apple_ref/doc/man/3/glTexImage2D"><b>glTexImage2D</b>(3G)</a>,   <a href="glTexImage3D.3.html#//apple_ref/doc/man/3/glTexImage3D"><b>glTexImage3D</b>(3G)</a>,
       <a href="glTexSubImage1D.3.html#//apple_ref/doc/man/3/glTexSubImage1D"><b>glTexSubImage1D</b>(3G)</a>, <a href="glTexSubImage2D.3.html#//apple_ref/doc/man/3/glTexSubImage2D"><b>glTexSubImage2D</b>(3G)</a>, <a href="glTexSubImage3D.3.html#//apple_ref/doc/man/3/glTexSubImage3D"><b>glTexSubImage3D</b>(3G)</a>




                                                                                            GLPIXELSTORE(3G)
</tt></pre>
</td></tr></table>
	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Darwin/Reference/ManPages/man3/glPixelStore.3.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Darwin/Reference/ManPages/man3/glPixelStore.3.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Darwin/Reference/ManPages/man3/glPixelStore.3.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

</body></html>
