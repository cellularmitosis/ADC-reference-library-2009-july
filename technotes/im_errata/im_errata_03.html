<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"    "http://www.w3.org/TR/1998/REC-html40-19980424/loose.dtd"><HTML><head><LINK REL="stylesheet" HREF="../../adcstyle.css" TYPE="text/css"><LINK REL="stylesheet" HREF="../../style.css" TYPE="text/css"><title>Technical Note IMERRATA03: Inside Macintosh: Networking Errata</title><meta name="keywords" content="Macintosh OS 8 Inside Networking errata errors omissions socket listener"><meta name="Description" content="Technical Note IMERRATA03: This Technical Note discussesknown errors and omissions in Inside Macintosh: Networking.Corrections include the documentation of the complete socketlistener code sample."><meta name="categories" content="Networking and Inside Macintosh Errata"><meta name="week-posted" content="Aug 29, 1994 - Sep 2, 1994"><LINK REL="stylesheet" HREF="../../css/adcstyle.css" TYPE="text/css"><script language="JavaScript" type="text/javascript" src="../../js/adc.js"></script></HEAD><BODY BGCOLOR="#FFFFFF" TEXT="#000000"><a name="//apple_ref/doc/uid/DTS10002523" title="Inside Macintosh: Networking Errata"></a><a name="top"></a><!-- top_of_header_marker_comment --><!-- begin_header_information --><!--#include virtual="/adcnavbar" --><p><a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../technicalnotes/index.html">Technical Notes</a> &gt; <a href="../../technicalnotes/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../technicalnotes/LegacyTechnologies/idxNetworking-date.html">Networking</a> &gt; </p><div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/Networking/index.html" target="_blank">Reference Library > Networking</a></li>
	</ul>
</div>




</div></div></div><!-- end_header_information --><!-- bottom_of_header_marker_comment --><!-- top_of_titles_marker_comment --><CENTER><table width="600" cellpadding="0" cellspacing="0" border="0">
<tr><td align="left" scope="row">
<h1>
<div id="pagehead">Technical Note IMERRATA03</div>
<div id="pageheadsub">Inside Macintosh: Networking Errata</div>
</h1>
</td></tr></table></CENTER><!-- bottom_of_titles_marker_comment --><CENTER><TABLE BORDER=0 CELLSPACING=1 WIDTH=600><TR><td align="left"><!-- begin_header_box --><table width="600" cellpadding="0" cellspacing="0" border="0">    <tr>        <td width=300 valign="top" align=left scope="row">            <table border="0" width="300" cellpadding="0" cellspacing="0">			<tr>                        <td width=300 align=left> <img src="images/tnmenutop.gif" alt="" align="bottom" width=300 height=7></td>                </tr>                <tr bgcolor="#e6e6e6">                    <td background="images/tnmenubody.gif" width=300 align=left>                                         <span id="menutitle">                            CONTENTS                             <br>                            <br>                        </span>                    </td>                </tr>                <tr bgcolor="#e6e6e6">                    <td background="images/tnmenubody.gif" width=300 align=left>					<!-- begin_toc -->										<p id="menutext">	<A HREF="#Section1">Topics</a><BR><BR>	<A HREF="#Section2">Chapter 2 - About the AppleTalk Utilities</a><BR><BR>	<A HREF="#Section3">Chapter 6 - AppleTalk Transaction Protocol (ATP)</a><BR><BR>	<A HREF="#Section4">Chapter 7 - Datagram Delivery Protocol (DDP)</a><BR><BR>	<A HREF="#Section5">Chapter 11 - Summary of Ethernet, TokenRing, and FDDI</a><BR><BR>	<a href="#References">References</a><BR><BR>                  <A HREF="#Downloads">Downloadables</A></P>                   <!-- end_toc -->                  </td>                </tr>                <tr>                    <td width=300 align=left scope="row">                        <img src="images/tnmenubottom.gif" alt="" width=300 height=16>                    </td>                </tr>            </table>        </td>        <td width=300 valign="top" align=left><!-- begin_intro_text --><P id = "introtext">This Technical Note discusses known errors and omissions in <i>InsideMacintosh: Networking</i>.</p><!-- end_intro_text --><!-- begin_date --><h3 align=center>[Sep 01 1994]</h3><!-- end_date -->                </TD>             </TR>          </TABLE>          <!-- end_table_box --> <BR><BR>          <hr width=500 align=center>          <BR><BR>          <!-- begin_content --><a name="Section1"></a><h2>Topics</h2><ul><li>Clarification to the use of the <code>GetBridgeAddress</code> function. Sept 94</li><li>Corrected special considerations to the use of <code>PSetSelfSend</code>.</li><li>Socket Listener sample code correction/modification. Sept 94</li><li>"Corrected" <code>EParamMisc2</code> C interface declaration is incorrect, Chapter 11 Sept 94</li><li>ATP <code>transID</code> transaction ID field omitted Sept 94</li></ul><a name="Section2"></a> <P><A HREF="#top">Back to top</A></P><h2>Chapter 2 - About the AppleTalk Utilities</h2><h3>Clarification to the use of GetBridgeAddress</h3><p>Page 2-6, Getting the Address of Your Node or Your Local Router</p><p>The documentation states that "to get the node ID part of a local router'saddress, you can call the <code>GetBridgeAddress</code> function."   This statement is notcorrect.  Instead of returning the actual node ID of the router, the<code>GetBridgeAddress</code> function returns a non-zero function result if a router existson the network.  A function result of zero indicates that there is no router.To get the node ID of the router, use the <code>PGetAppleTalkInfo</code> function instead.</p><h3>Correction to the Description for PSetSelfSend</h3><p>Page 2-16, <code>PSetSelfSend</code> description.</p><p>The documentation states that "Sending packets between a multinode applicationand user node applications on the same machine is independent of the intranodedelivery feature.  A multinode is treated as a virtual node distinct from theuser node...".   These statements lead to the incorrect conclusion that onedoes not need to set the <code>SelfSend</code> capability to send packets between the usernode and the multinode.  To send packets between the user node and a multinode,use PSetSelfSend to turn on intranode delivery service.</p><a name="Section3"></a> <P><A HREF="#top">Back to top</A></P><h2>Chapter 6 - AppleTalk Transaction Protocol (ATP)</h2><h3>Transaction ID field transID omitted</h3><p>The<code> transID</code> field should be used in place of the <code>reqTID </code>fieldas shown in the following areas:</p><p>Page 6-15</p><p>"The request transaction ID <code>transID</code> that ATP assigns to this request.If you intend to respond to the request, save this value because you will need to pass it to the <code>PSendResponse</code> function and the <code>PAddResponse</code> function to identify the request for which the response message is intended..."</p><p>Page 6-16</p><p>"For the input address block (<code>addrBlock</code>) and transaction ID(<code>transID</code>) parameters to <code>PSendResponse</code>, use the address block(<code>addrBlock</code>) and request transaction ID (<code>transID</code>) parametervalues that the <code>PGetRequest</code> function returned."</p><p>Page 6-33</p><p><code>PGetRequest</code> parameter block and description should look as follows:</p><p>Parameter block</p><p>-&gt; <code>ioCompletion ProcPtr</code> A pointer to a completion routine.</p><p>&lt;- <code>ioResult OSErr</code> The function result.</p><p>&lt;- <code>userData LongInt</code> Four bytes of user data.</p><p>-&gt; <code>csCode</code>    Integer    Always <code>getRequest</code> for this function.</p><p>-&gt; <code>atpSocket</code> Byte The socket number.</p><p>&lt;- <code>atpFlags</code> Byte The control information.</p><p>&lt;- <code>addrBlock LongInt</code> The destination socket address.</p><p>&lt;-&gt; <code>reqLength</code> Word On input, the request buffer size. On return,the actual of the request received.    </p><p>-&gt; <code>reqPointer</code>    Ptr A pointer to the request buffer.</p><p>&lt;- <code>bitMap</code> Byte A bitmap.</p><p>&lt;- <code>transID</code> Word The transaction ID.</p><p>Field descriptions</p><p>transID The transaction ID of the request that <code>PGetRequest</code> hasreceived. ATP supplies this value.</p><p>"The <code>PGetRequest</code> function returns the transaction ID of the requestthat it receives in the <code>transID</code> field. You should save this value ifyou intend to respond to the request; this transaction ID is used as an inputparameter to the <code>PSendResponse</code> and <code>PAddResponse</code> functions. Todetermine that the request transaction ID specified in the <code>transID</code>field is valid, first check the <code>atpTIDValidvalue</code> bit (bit 1) of the<code>atpFlags</code> field. If this bit is set, the <code>transID</code> field valueis valid."</p><p>Page 6-37</p><p>Field descriptions</p><p>transID    The transaction ID of the request for which this response is meant.</p><p>Page 6-43</p><p>Field should be an Integer, not a Byte:</p><p>-&gt; <code>transID</code> Integer The transaction ID of the request with which the<code>PSendResponse</code> function to be canceled is associated.</p><p>Page 6-48</p><p>Add the <code>transID</code> field to the <code>GetRequestParm</code> parameter blockas follows:</p><p><code>GetRequestParm</code>:</p><p>(bitMap: Byte; {bitmap}</p><p>filler1: Byte;</p><p>transID: Integer);</p>                <p>Page 6-57</p><p>Add the <code>transID</code> field to the <code>GetRequest</code> Parameter Variant as follows:</p><p><code>GetRequest</code> Parameter Variant</p><p>22 <code>reqTID</code> word request transaction ID</p><p>26 <code>csCode</code> word command code; always getRequest</p><p>29 <code>atpFlags</code> byte control information</p><p>30 <code>addrBlock</code> long destination socket address</p><p>34 <code>reqLength</code> word request size in bytes</p><p>36 <code>reqPointer</code> long pointer to request data</p><p>44 <code>bitMap</code> byte current bitmap</p><p>46 <code>transID</code> word request transaction ID</p><a name="Section4"></a> <P><A HREF="#top">Back to top</A></P><h2>Chapter 7 - Datagram Delivery Protocol (DDP)</h2><h3>Listing 7-6 Socket Listener sample code correction/modification.</h3><p>Page 7-26 through 7-30, Receiving and processing a DDP packet</p><p>The sample code is provided to demonstrate a generic socket listener written in68000 Assembler.  The supplied code in this chapter does not correctly processa packet which is received with a checksum.  A BRA.S instruction bypasses theportion of code which checks the packet for a checksum.  In addition, the codefor processing the checksum was not included in this release of <i>InsideMacintosh: Networking</i>.  There is one other correction relating to the<code>GetNextBuffer</code> code.  Before calling <code>DeQueue</code>, we must check for a nil pointer as<code>DeQueue</code> in some releases of System Software does not do this for us.  Thefollowing is the complete socket listener code sample, including the<code>SL_DoChksum</code> code.  Corrections to the supplied code for the socket listener only are presented in bold typeface.</p><p>In addition, the code has been modified to compile as a code resource which canbe called using a Universal <code>ProcPtr</code> and executed in mixed mode, to facilitatecompilation as native Power Macintosh code.  The beginning of the code resourceis the socket listener entry point, which is a JMP instruction to the actuallistener code.  The initialization code for the listener is two bytes into thecode resource.  For an example use of this listener code, refer to the NetworkWatch (DMZ) v1.3 application which is available on the Developer CD (Tool ChestEdition), August 1994  or later.</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>    INCLUDE    'QuickEqu.a'    INCLUDE    'ToolEqu.a'    INCLUDE    'SysEqu.a'    INCLUDE    'ATalkEqu.a'    INCLUDE    'Traps.a'    INCLUDE    'SysErr.a';;; Record Types;;_________________________________________________________________________MyQHdr                RECORD    0qFlags                DS.W      1qHead                 DS.L      1qTail                 DS.L      1                      ENDRPacketBuffer          RECORD    0qLink                 DS.L      1qType                 DS.W      1buffer_Type           DS.W      1            ; DDP Typebuffer_NodeID         DS.W      1            ; Destination nodebuffer_Address        DS.L      1            ; Source address in AddrBlock formatbuffer_Hops           DS.W      1            ; Hop countbuffer_ActCount       DS.W      1            ; length of DDP datagrambuffer_CheckSum       DS.W      1            ; Chksum error returned here                                             ; (cksumErr or noErr)buffer_Ticks          DS.L      1            ; TickCount when handler calledbuffer_Data           DS.B      ddpMaxData   ; the DDP datagram                      ENDR</pre>	</TD></TR></TABLE></CENTER>                      <CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>THE_LISTENER    PROC    EXPORT    BRA.S       TheListener    BRA.S       SL_InitSktListener           ; branch to init code;_________________________________________________________________________;; Local Variables;;_________________________________________________________________________free_queue        DC.L    0      ; pointer to freeQ QHdr - init'd by InitSktListenerused_queue        DC.L    0      ; pointer to usedQ QHdr - init'd by InitSktListenercurrent_qelem     DC.L    0      ; pointer to current PacketBuffer record                                 ; initialized by InitSktListener, then                                 ; set by socket listener after every packet.                                 ; NIL if no buffer is available.;_________________________________________________________________________; Function SL_InitSktListener(freeQ, usedQ: QHdrPtr): OSErr;StackFrame     RECORD    {A6Link},DECR     ; build a stack frame recordResult1        DS.W      1                 ; function's result returned to callerParamBegin     EQU       *                 ; start parameters after this pointfreeQ          DS.L      1                 ; freeQ parameterusedQ          DS.L      1                 ; usedQ parameterParamSize      EQU       ParamBegin-*      ; size of all the passed parametersRetAddr        DS.L      1                 ; placeholder for return addressA6Link         DS.L      1                 ; placeholder for A6 linkLocalSize      EQU       *                 ; size of all the local variables               ENDRSL_InitSktListener:    WITH       StackFrame,MyQHdr           ; use these record types    LINK       A6,#LocalSize               ; allocate our local stack frame; copy queue header pointers into our local storage for use in the listener    LEA        used_queue,A0               ; copy usedQ into used_queue    MOVE.L     usedQ(A6),(A0)    LEA        free_queue,A0               ; copy freeQ into free_queue    MOVE.L     freeQ(A6),(A0); dequeue the first buffer record from freeQ and set current_qelem to it    MOVEA.L    freeQ(A6),A1                ; A1 = ^freeQ    LEA        current_qelem, A0           ; copy freeQ.qHead into                                           ; current_qelem    MOVE.L     qHead(A1),(A0)    MOVEA.L    qHead(A1),A0                ; A0 = freeQ.qHead    _Dequeue    MOVE.W     D0,Result1(A6)              ; Return status@1  UNLK       A6                          ; destroy the link    MOVEA.L    (SP)+,A0                    ; pull off the return address    ADDA.L     #ParamSize,SP               ; strip all of the caller's                                           ; parameters    JMP        (A0)                        ; return to the caller;_________________________________________________________________________;; SL_TheListner - process packets received at the designated socket;;    Input:;     D0 (byte) = packet's destination socket number;     D1 (word) = number of bytes left to read in packet;     A0 points to the bytes to checksum;     A1 points to the bytes to checksum;     A2 points to MPP's local variables;     A3 points to next free byte in Read Header Area;     A4 points to ReadPacket and ReadRest jump table;;    Return:;     D0 is modified;     D3 (word) = accumulated checksum;_________________________________________________________________________    IMPORT  SL_DoChksum    : codeTheListener:    WITH    PacketBuffer; get pointer to current PacketBufferGetBuffer:    LEA       current_qelem,A3          ; get the pointer to the PacketBuffer to use    MOVE.L    (A3),A3    MOVE.L    A3,D0                     ; if no PacketBuffer    BEQ.S     NoBuffer                  ; then ignore packet; read rest of packet into PacketBuffer.datagramData    MOVE.L    D1,D3                     ; read rest of packet    LEA       buffer_data(A3),A3        ; A3 = ^bufferData    JSR       2(A4)                     ; ReadRest    BEQ.S     ProcessPacket             ; If no error, continue    BRA       RcvRTS                    ; there was an error, so ignore packet; No buffer; ignore the packetNoBuffer      CLR D3                    ; Set to ignore packet (buffer size = 0)    JSR       2(A4)                     ; ReadRest    BRA       GetNextBuffer             ; We missed this packet, but maybe there                                        ; will be a buffer for the next packet...; Process the packet you just read in.; ReadRest has been called so registers A0-A3 and D0-D3 are free to use.; We'll use registers this way:PktBuff         EQU    A0        ; the current PacketBufferMPPLocals       EQU    A2        ; pointer to MPP's local variables (still set                                 ;  up from entry to socket listener)HopCount        EQU    D0        ; used to get the hop countDatagramLength  EQU    D1        ; used to determine the datagram lengthSourceNetAddr   EQU    D2        ; used to build the source network addressProcessPacket:    LEA        current_qelem,PktBuff          ; PktBuff = current_qelem    MOVE.L     (PktBuff),PktBuff; do everything that's common to both long and short DDP headers; first, clear buffer_Type and buffer_NodeID to ensure their high bytes are 0    CLR.W      buffer_Type(PktBuff)           ; clear buffer_Type    CLR.W      buffer_NodeID(PktBuff)         ; clear buffer_NodeID; clear SourceNetAddr to prepare to build network address    MOVEQ      #0,SourceNetAddr               ; build the network address in                                              ; SourceNetAddr; get the hop count    MOVE.W     toRHA+lapHdSz+ddpLength(MPPLocals),HopCount ; Get hop/length                                              ; field    ANDI.W     #DDPHopsMask,HopCount          ; Mask off the hop count bits    LSR.W      #2,HopCount                    ; shift hop count into low bits of                                              ; high byte    LSR.W      #8,HopCount                    ; shift hop count into low byte    MOVE.W     HopCount,buffer_Hops(PktBuff)  ; and move it into the                                              ; PacketBuffer; get the packet length (including the DDP header)    MOVE.W     toRHA+lapHdSz+ddpLength(MPPLocals),DatagramLength ; Get length field    ANDI.W     #ddpLenMask,DatagramLength     ; Mask off the hop count bits; now, find out if the DDP header is long or short    MOVE.B     toRHA+lapType(MPPLocals),D3    ; Get LAP type    CMPI.B     #shortDDP,D3                   ; is this a long or short DDP                                              ; header?    BEQ.S      IsShortHdr                     ; skip if short DDP header; it's a long DDP header    MOVE.B     toRHA+lapHdSz+ddpType(MPPLocals),buffer_Type+1(PktBuff); get DDP type    MOVE.B     toRHA+lapHdSz+ddpDstNode(MPPLocals),buffer_NodeID+1(PktBuff)                                              ; get destination node from LAP                                              ; header    MOVE.L     toRHA+lapHdSz+ddpSrcNet(MPPLocals),SourceNetAddr                                              ; source network in hi word                                              ; source node in lo byte    LSL.W      #8,SourceNetAddr               ; shift source node up to high                                              ; byte of low word                                              ; get source socket from DDP                                              ; header    MOVE.B     toRHA+lapHdSz+ddpSrcSkt(MPPLocals),SourceNetAddr    SUB.W      #ddpType+1,DatagramLength      ; DatagramLength = number of bytes                                              ; in datagram    ;BRA.S      MoveToBuffer &lt;Delete this statement&gt;; Determine if there is a checksum    TST.W      toRHA+lapHdSz+ddpChecksum(MPPLocals) ;Does packet have checksum?    BEQ.S      noChecksum; Calculate checksum over DDP header    MOVE.W     DatagramLength,-(SP)       ; save DatagramLength (D1)    CLR        D3                             ; set checksum to zero    MOVEQ      #ddphSzLong-ddpDstNet,D1       ; D1 = length of header part to                                              ; checksum pointer to dest network                                              ; number in DDP header    LEA        toRHA+lapHdSz+ddpDstNet(MPPLocals),A1    JSR        SL_DoChksum                    ; checksum of DDP header part                                              ; (D3 holds accumulated checksum); Calculate checksum over data portion (if any)    LEA        buffer_Data(PktBuff),A1     ; pointer to datagram    MOVE.W     (SP)+,DatagramLength        ; restore DatagramLength(D1)    MOVE.W     DatagramLength,-(SP)        ; save DatagramLength (D1)                                              ;  before calling SL_DoChksum    BEQ.S      TestChecksum                   ; don't checksum datagram if its                                              ; length = 0    JSR        SL_DoChksum                    ; checksum of DDP datagram part                                              ; (D3 holds accumulated checksum)TestChecksum:    MOVE.W     (SP)+,DatagramLength        ; restore DatagramLength(D1); Now make sure the checksum is OK.    TST.W      D3                             ; is the calculated value zero?    BNE.S      NotZero                        ; no -- go and use it    SUBQ.W     #1,D3                          ; it is 0; make it -1NotZero:    CMP.W      toRHA+lapHdSz+ddpChecksum(MPPLocals),D3    BNE.S      ChecksumErr                    ; Bad checksum    MOVE.W     #0,buffer_CheckSum(A0)         ; no errors    BRA.S      noChecksumChecksumErr:    MOVE.W     #ckSumErr,buffer_CheckSum(PktBuff) ; checksum errornoChecksum:    BRA.S      MoveToBuffer; it's a short DDP headerIsShortHdr:                                              ; get DDP type    MOVE.B     toRHA+lapHdSz+sddpType(MPPLocals),buffer_Type+1(PktBuff)                                              ; get destination node from LAP                                              ; header    MOVE.B     toRHA+lapDstAdr(MPPLocals),buffer_NodeID+1(PktBuff)                                              ; get source node from LAP header    MOVE.B     toRHA+lapSrcAdr(MPPLocals),SourceNetAddr    LSL.W      #8,SourceNetAddr               ; shift src node up to high byte                                              ; of low word                                              ; get source socket from short DDP                                              ;  header    MOVE.B     toRHA+lapHdSz+sddpSrcSkt(MPPLocals),SourceNetAddr                                              ; DatagramLength = number of bytes in                                              ; datagram    SUB.W      #sddpType+1,DatagramLengthMoveToBuffer:                                      ;move source network address into PacketBuffer    MOVE.L     SourceNetAddr,buffer_Address(PktBuff)                                      ; move datagram length into PacketBuffer    MOVE.W     DatagramLength,buffer_ActCount(PktBuff); Now that we're done with the PacketBuffer, enqueue it into the usedQ and get; another buffer from the freeQ for the next packet.    LEA        used_queue,A1                   ; A1 = ^used_queue    MOVE.L     (A1),A1                         ; A1 = used_queue (pointer to usedQ)    _Enqueue                                    ; put the PacketBuffer in the usedQGetNextBuffer:    LEA        free_queue,A1                   ; A1 = ^free_queue    MOVE.L     (A1),A1                         ; A1 = free_queue (pointer to freeQ)    LEA        current_qelem, A0               ; copy freeQ.qHead into current_qelem    MOVE.L     qHead(A1),(A0)    MOVEA.L    qHead(A1),A0                    ; A0 = freeQ.qHead    MOVE.L    A0,D0             ; check whether there is a queue element    BEQ.S     RcvRTS            ; branch if not - don't dequeue nil ptr.    _DequeueRcvRTS:    RTS                                        ; return to callerENDWITH    ENDP;_________________________________________________________________________;; SL_DoChksum - accumulate ongoing checksum (from Inside Macintosh);;    Input:;     D1 (word) = number of bytes to checksum;     D3 (word) = current checksum;     A1 points to the bytes to checksum;;    Return:;     D0 is modified;     D3 (word) = accumulated checksum;_________________________________________________________________________SL_DoChksum    PROC    CLR.W      D0                    ; Clear high byte    SUBQ.W     #1,D1                 ; Decrement count for DBRAChksumLoop:    MOVE.B     (A1)+,D0              ; read a byte into D0    ADD.W      D0,D3                 ; accumulate checksum    ROL.W      #1,D3                 ; rotate left one bit    DBRA       D1,ChksumLoop         ; loop if more bytes    RTS    ENDP    END</pre>	</TD></TR></TABLE></CENTER><h3>Listing 7-7 sample code has logic error</h3><p>Page 7-32, Testing for Available Packets</p><p>The sample code "Determining if the socket listener has processed a packet",incorrectly uses the following statement to check whether a packet wassuccessfully Dequeued:</p> <CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>IF (Dequeue(QElemPtr(bufPtr),  @usedQ) &lt;&gt; noErr) THEN</pre>	</TD></TR></TABLE></CENTER><p>The corrected statement is:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>IF (Dequeue(QElemPtr(bufPtr),  @usedQ) = noErr) THEN</pre>	</TD></TR></TABLE></CENTER><a name="Section5"></a> <P><A HREF="#top">Back to top</A></P><h2>Chapter 11 - Summary of Ethernet, TokenRing, and FDDI</h2><h3>"Corrected" EParamMisc2 C interface declaration is incorrect</h3><p>Page 11-46, A corrected definition for the <code>EParamMisc2</code> variable type is presented as:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>typedef struct {    EParamHeader    char     eMultiAddr[5];} EParamMisc2;</pre>	</TD></TR></TABLE></CENTER><p>This declaration is incorrect.  The <code>eMultiAddr</code> field is 6 bytes long.  The correct structure is defined as:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>typedef struct {    EParamHeader    char     eMultiAddr[6];} EParamMisc2;</pre>	</TD></TR></TABLE></CENTER><a name="References"></a> <P><A HREF="#top">Back to top</A></P><h2>References</h2><P><i>Inside Macintosh: Networking</i></p>         <P><A HREF="#top">Back to top</A></P>                  <P><A NAME=Downloads></A></P>                  <h2>Downloadables</h2>                  <TABLE BORDER=0 CELLPADDING=3 WIDTH="100%">            <TR>               <td width=50 align=left>                  <P ALIGN=center><img src="images/acrobatsmall.gif" width=22 height=23 align=middle alt="Acrobat gif"></P>               </TD>               <td align="left">                  <P>Acrobat version of this Note (48K)</P>               </TD>               <td width=60 align=left>                  <P><A HREF="pdf/im_errata_03.pdf">Download</A></P>               </TD>            </TR>                     </TABLE>         <BR>                  <P><A HREF="#top">Back to top</A></P></TD></TR></TABLE></CENTER><!-- end_content --><!-- begin_footer_information -->	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/technotes/im_errata/im_errata_03.html%3Fid%3DDTS10002523-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/technotes/im_errata/im_errata_03.html%3Fid%3DDTS10002523-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/technotes/im_errata/im_errata_03.html%3Fid%3DDTS10002523-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>
<!--#include virtual="/includes/footer"--><!-- end_footer_information --></BODY></HTML>