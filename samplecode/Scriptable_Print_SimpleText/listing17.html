<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>Scriptable Print SimpleText - /PICTFile.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxPrinting-date.html">Printing</a> &gt; <A HREF="javascript:location.replace('index.html');">Scriptable Print SimpleText</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/Printing/index.html" target="_blank">Reference Library > Printing</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">Scriptable Print SimpleText</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/PICTFile.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/AboutBox.c</option>
<option value="listing2.html">/AboutBox.h</option>
<option value="listing3.html">/AboutBox.r</option>
<option value="listing4.html">/aete.r</option>
<option value="listing5.html">/AGFile.h</option>
<option value="listing6.html">/Clipboard.c</option>
<option value="listing7.html">/Clipboard.h</option>
<option value="listing8.html">/Clipboard.r</option>
<option value="listing9.html">/CoercePrGeneral.h</option>
<option value="listing10.html">/ExtendPrintRecord.c</option>
<option value="listing11.html">/ExtendPrintRecord.h</option>
<option value="listing12.html">/Localize.r</option>
<option value="listing13.html">/MacIncludes.h</option>
<option value="listing14.html">/MovieFile.c</option>
<option value="listing15.html">/MovieFile.h</option>
<option value="listing16.html">/MovieFile.r</option>
<option value="listing17.html">/PICTFile.c</option>
<option value="listing18.html">/PICTFile.h</option>
<option value="listing19.html">/PICTFile.r</option>
<option value="listing20.html">/PrintAETypes.h</option>
<option value="listing21.html">/ScriptablePrinting.c</option>
<option value="listing22.html">/ScriptablePrinting.h</option>
<option value="listing23.html">/SimpleText.c</option>
<option value="listing24.html">/SimpleText.h</option>
<option value="listing25.html">/SimpleText.r</option>
<option value="listing26.html">/TextDrag.c</option>
<option value="listing27.html">/TextFile.a</option>
<option value="listing28.html">/TextFile.c</option>
<option value="listing29.html">/TextFile.h</option>
<option value="listing30.html">/TextFile.r</option>
<option value="listing31.html">/ThreeDMetafile.c</option>
<option value="listing32.html">/ThreeDMetafile.h</option>
<option value="listing33.html">/ThreeDMetafile.r</option></select>
				</p>
				</form>
				<p><strong><a href="Scriptable_Print_SimpleText.zip">Download Sample</a></strong> (&#147;Scriptable_Print_SimpleText.zip&#148;, 212.5K)<BR>
<strong><a href="Scriptable_Print_SimpleText.dmg">Download Sample</a></strong> (&#147;Scriptable_Print_SimpleText.dmg&#148;, 290.1K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/***  File:    PICTFile.c****  Contains:  PICT file for simple text application****  Version:  SimpleText 1.4 or later**** Copyright 1993-1999 Apple Computer. All rights reserved.****  You may incorporate this sample code into your applications without**  restriction, though the sample code has been provided &quot;AS IS&quot; and the**  responsibility for its operation is 100% yours.  However, what you are**  not permitted to do is to redistribute the source as &quot;DSC Sample Code&quot;**  after having made changes. If you're going to re-distribute the source,**  we require that you make it clear in the source that the code was**  descended from Apple Sample Code, but that you've made changes.*/#include &quot;MacIncludes.h&quot;#include &quot;PICTFile.h&quot;/* ------------------------------------------------------------------------------------  *//* GLOBALS ONLY USED BY THIS FILE *//* ------------------------------------------------------------------------------------  */#define kBufferSize  2048static short      gPictFileRefNum;static char        gPictureBuffer[kBufferSize];static long        gAmountInBuffer;static long        gFirstCharInBuffer;static QDProcsPtr       gSavedProcs;static QDProcs          gMyProcs;static CQDProcs         gMyColorProcs;// --------------------------------------------------------------------------------------------------------------// INTERNAL ROUTINES// --------------------------------------------------------------------------------------------------------------static pascal void GetPICTData(Ptr dataPtr,short byteCount)/*  replacement for the QuickDraw bottleneck routine*/{     OSErr            err = noErr;    long            longCount;    longCount = byteCount;    while ( (longCount &gt; 0) &amp;&amp; (err == noErr) )    {    if (gAmountInBuffer == 0)      {      gAmountInBuffer = kBufferSize;      gFirstCharInBuffer = 0;      err = FSRead(gPictFileRefNum,&amp;gAmountInBuffer,gPictureBuffer);      }    if (gAmountInBuffer &gt; 0)      {      long  amountToMove;            amountToMove = gAmountInBuffer;      if (amountToMove &gt; longCount)        amountToMove = longCount;              BlockMoveData(&amp;gPictureBuffer[gFirstCharInBuffer], dataPtr, amountToMove);      longCount -= amountToMove;      dataPtr += amountToMove;      gFirstCharInBuffer += amountToMove;      gAmountInBuffer -= amountToMove;      }          }  } // GetPICTData#if GENERATINGCFM  static RoutineDescriptor gGetPICTDataRD = BUILD_ROUTINE_DESCRIPTOR(uppQDGetPicProcInfo, GetPICTData);  static QDGetPicUPP gGetPICTData = &amp;gGetPICTDataRD;#else  static QDGetPicUPP gGetPICTData = NewQDGetPicProc(GetPICTData);#endif// --------------------------------------------------------------------------------------------------------------static OSErr  DiskPictureDraw( WindowDataPtr pData,   Boolean doDraw, Rect *pictureRect, Point *pOffset){  OSErr    anErr;  PicHandle  picHandle;  Point    offset;    if (pOffset)    offset = *pOffset;  else    {    offset.h = GetControlValue(pData-&gt;hScroll);    offset.v = GetControlValue(pData-&gt;vScroll);    }  picHandle = ((PICTDataPtr)pData)-&gt;cacheHandle;    if (picHandle)    {    if (doDraw)      {      Rect  destRect;            GetPICTRectangleAt72dpi(picHandle, &amp;destRect);      OffsetRect(&amp;destRect,                 -destRect.left +                   pData-&gt;contentRect.left -                  offset.h,                 -destRect.top +                   pData-&gt;contentRect.top -                  offset.v);      DrawPicture(picHandle, &amp;destRect);      }        if (pictureRect)      {      GetPICTRectangleAt72dpi(picHandle, pictureRect);      OffsetRect(pictureRect, -pictureRect-&gt;left, -pictureRect-&gt;top);      }          picHandle = nil;    anErr = noErr;    }  else    {    // make enough room for PICT header, including version    picHandle = (PicHandle) NewHandle(sizeof(Picture)  + sizeof(long)*8);    anErr = MemError();    nrequire(anErr, FailedNewHandle);        gPictFileRefNum = pData-&gt;dataRefNum;    anErr = SetFPos(gPictFileRefNum, fsFromStart, 512);    nrequire(anErr, FailedSetFPos);        gAmountInBuffer = kBufferSize;    gFirstCharInBuffer = 0;    anErr = FSRead(gPictFileRefNum, &amp;gAmountInBuffer, gPictureBuffer);    if (anErr == eofErr)      anErr = noErr;    if (gAmountInBuffer &lt; sizeof(Picture))      anErr = eofErr;    nrequire(anErr, FailedInitialRead);      // copy PICT header, including version    BlockMoveData(gPictureBuffer, *picHandle, sizeof(Picture) + sizeof(long)*8);    gFirstCharInBuffer += sizeof(Picture);    gAmountInBuffer -= sizeof(Picture);        if (doDraw)      {      Rect  destRect;            GetPICTRectangleAt72dpi(picHandle, &amp;destRect);      if (!gMachineInfo.haveQuickTime)        {        if (gMachineInfo.theEnvirons.hasColorQD)          {          if ((*qd.thePort).grafProcs)            BlockMoveData((*qd.thePort).grafProcs, &amp;gMyColorProcs, sizeof(gMyColorProcs));          else            SetStdCProcs(&amp;gMyColorProcs);          }        else          {          if ((*qd.thePort).grafProcs)            BlockMoveData((*qd.thePort).grafProcs, &amp;gMyProcs, sizeof(gMyProcs));          else            SetStdProcs(&amp;gMyProcs);          }                  gMyProcs.getPicProc = gGetPICTData;        gMyColorProcs.getPicProc = gGetPICTData;        gSavedProcs = (*qd.thePort).grafProcs;              if (gMachineInfo.theEnvirons.hasColorQD)          (*qd.thePort).grafProcs = (QDProcsPtr)&amp;gMyColorProcs;        else          (*qd.thePort).grafProcs = &amp;gMyProcs;        }              OffsetRect(&amp;destRect,                 -destRect.left +                   pData-&gt;contentRect.left -                  offset.h,                 -destRect.top +                   pData-&gt;contentRect.top -                  offset.v);                              if (!gMachineInfo.haveQuickTime)        {        DrawPicture(picHandle, &amp;destRect);        (*qd.thePort).grafProcs = gSavedProcs;        }      else        DrawPictureFile(gPictFileRefNum, &amp;destRect, nil);        }          if (pictureRect)      {      GetPICTRectangleAt72dpi(picHandle, pictureRect);      OffsetRect(pictureRect, -pictureRect-&gt;left, -pictureRect-&gt;top);      }    }  // FALL THROUGH EXCEPTION HANDLINGFailedInitialRead:FailedSetFPos:  DisposeHandle((Handle) picHandle);FailedNewHandle:    return(anErr);    } // DiskPictureDraw// --------------------------------------------------------------------------------------------------------------static OSErr GetSelectedPicture(WindowDataPtr pData, PicHandle *pResult){  OSErr    anErr;  PicHandle  scrapPict;  Rect    globRect;  GDHandle  theMaxDevice;  short    theDepth;  GDHandle  savedGDevice;  CGrafPtr  savedPort;  GWorldPtr  offscreenGWorld;  // save away current value for restores  GetGWorld(&amp;savedPort, &amp;savedGDevice);  // determine the best way in which to allocate stuff    SetRect(&amp;globRect, -32760, -32760, 32760, 32760);  theDepth = 1;  if (gMachineInfo.theEnvirons.hasColorQD)    {    theDepth = 8;    theMaxDevice = GetMaxDevice(&amp;globRect);    if (theMaxDevice != nil)      theDepth = (**(**theMaxDevice).gdPMap).pixelSize;    }    // allocate the GWorld in temp mem, or local if we run out  anErr = NewGWorld(&amp;offscreenGWorld, theDepth,             &amp;((PICTDataPtr)pData)-&gt;selectionRectangle,            nil, nil, useTempMem);  if (anErr != noErr)    anErr = NewGWorld(&amp;offscreenGWorld, theDepth,               &amp;((PICTDataPtr)pData)-&gt;selectionRectangle,              nil, nil, 0);  nrequire(anErr, FailedNewGWorld);  // blow open the visRgn, and clip to the selected area  RectRgn(offscreenGWorld-&gt;visRgn, &amp;globRect);  PortChanged((GrafPtr) offscreenGWorld);  SetGWorld(offscreenGWorld, nil);  EraseRect(&amp;offscreenGWorld-&gt;portRect);  ClipRect(&amp;((PICTDataPtr)pData)-&gt;selectionRectangle);    // Draw the picture into the offscreen  LockPixels( GetGWorldPixMap(offscreenGWorld));  {  Point  offset = {0,0};  anErr = DiskPictureDraw(pData, true, &amp;((PICTDataPtr)pData)-&gt;selectionRectangle, &amp;offset);  }  UnlockPixels( GetGWorldPixMap(offscreenGWorld));  nrequire(anErr, FailedDraw);  // CopyBits in place to grab the selection  scrapPict = OpenPicture(&amp;((PICTDataPtr)pData)-&gt;selectionRectangle);  LockPixels( GetGWorldPixMap(offscreenGWorld));  CopyBits(&amp;((GrafPtr)offscreenGWorld)-&gt;portBits, &amp;((GrafPtr)offscreenGWorld)-&gt;portBits,     &amp;((PICTDataPtr)pData)-&gt;selectionRectangle, &amp;((PICTDataPtr)pData)-&gt;selectionRectangle,    srcCopy, nil);  anErr = QDError();  UnlockPixels( GetGWorldPixMap(offscreenGWorld));  ClosePicture();  globRect = (**scrapPict).picFrame;  if ( (anErr == noErr) &amp;&amp; (EmptyRect(&amp;globRect)) )    anErr = memFullErr;      // done with our offscreen now  SetGWorld(savedPort, savedGDevice);  DisposeGWorld(offscreenGWorld);  if (anErr == noErr)    *pResult = scrapPict;    return(anErr);  // EXCEPTION HANDLINGFailedDraw:  DisposeGWorld(offscreenGWorld);  FailedNewGWorld:  SetGWorld(savedPort, savedGDevice);  return(anErr);  } // GetSelectedPicture// --------------------------------------------------------------------------------------------------------------static OSErr CopyGWorld(WindowDataPtr pData){  OSErr    anErr;  PicHandle  scrapPict;  anErr = GetSelectedPicture(pData, &amp;scrapPict);  if (anErr == noErr)    {    if (LoadScrap() == noErr)      {      ZeroScrap();      HLock((Handle) scrapPict);      anErr = PutScrap(GetHandleSize((Handle) scrapPict), 'PICT', (Ptr)*scrapPict);      KillPicture(scrapPict);      }    }    return(anErr);  } // CopyGWorld// --------------------------------------------------------------------------------------------------------------static pascal OSErr PICTSendDataProc(FlavorType theType, void *dragSendRefCon,                ItemReference theItem, DragReference theDrag)/* *  The ItemReference is the gxShape to be sent. The dragSendRefCon is ignored.*/{#pragma unused (dragSendRefCon)  OSErr  result = noErr;  switch (theType)     {    case 'PICT':      {        PicHandle   pict;      OSErr    anErr = GetSelectedPicture((WindowDataPtr)theItem, &amp;pict);        if (anErr == noErr)        {          HLock((Handle)pict);        result = SetDragItemFlavorData(theDrag, theItem, 'PICT', (Ptr)*pict, GetHandleSize((Handle)pict), 0);        KillPicture(pict);        }      }      break;          default:      result = badDragFlavorErr;      break;    }      return result;  } // PICTSendDataProc#if GENERATINGCFM  static RoutineDescriptor gPICTSendDataProcRD = BUILD_ROUTINE_DESCRIPTOR(uppDragSendDataProcInfo, PICTSendDataProc);  static DragSendDataUPP gPICTSendDataProc = &amp;gPICTSendDataProcRD;#else  static DragSendDataUPP gPICTSendDataProc = NewDragSendDataProc(PICTSendDataProc);#endif// --------------------------------------------------------------------------------------------------------------// OOP INTERFACE ROUTINES// --------------------------------------------------------------------------------------------------------------static OSErr  PICTUpdateWindow(WindowRef pWindow, WindowDataPtr pData){  OSErr    anErr;  RgnHandle  oldClip = NewRgn();    EraseRect(&amp;pData-&gt;contentRect);    GetClip(oldClip);  ClipRect(&amp;pData-&gt;contentRect);  anErr = DiskPictureDraw( pData, true, nil, nil);  SetClip(oldClip);  DisposeRgn(oldClip);    DrawSelection(pData, &amp;((PICTDataPtr)pData)-&gt;selectionRectangle, &amp;((PICTDataPtr)pData)-&gt;patternPhase, false);    DrawControls(pWindow);  DrawGrowIcon(pWindow);    return(anErr);  } // PICTUpdateWindow// --------------------------------------------------------------------------------------------------------------static OSErr  PICTGetDocumentRect(WindowRef pWindow, WindowDataPtr pData,       LongRect * documentRectangle, Boolean forGrow){#pragma unused (pWindow, forGrow)  RectToLongRect(&amp;((PICTDataPtr)pData)-&gt;pictureRectangle, documentRectangle);    return(noErr);  } // PICTGetDocumentRect// --------------------------------------------------------------------------------------------------------------static OSErr  PICTCloseWindow(WindowRef pWindow, WindowDataPtr pData){#pragma unused (pWindow)  DisposeHandle( (Handle) (((PICTDataPtr)pData)-&gt;cacheHandle));    return(noErr);  } // PICTCloseWindow// --------------------------------------------------------------------------------------------------------------static OSErr  PICTContentClick(WindowRef pWindow, WindowDataPtr pData, EventRecord *pEvent){  OSErr  anErr = noErr;  Rect  selectionRect = ((PICTDataPtr)pData)-&gt;selectionRectangle;  Point  clickPoint = pEvent-&gt;where;    GlobalToLocal(&amp;clickPoint);  OffsetRect(&amp;selectionRect, -GetControlValue(pData-&gt;hScroll), -GetControlValue(pData-&gt;vScroll));  if ( (gMachineInfo.haveDragMgr) &amp;&amp; (PtInRect(clickPoint, &amp;selectionRect)) )    {    DragAndDropArea(pWindow, pData, pEvent,               &amp;selectionRect);    }  else    {    anErr = SelectContents(pWindow, pData, pEvent,           &amp;((PICTDataPtr)pData)-&gt;selectionRectangle, &amp;((PICTDataPtr)pData)-&gt;pictureRectangle,           &amp;((PICTDataPtr)pData)-&gt;patternPhase);    }    return(anErr);  } // PICTContentClick// --------------------------------------------------------------------------------------------------------------static OSErr  PICTAdjustCursor(WindowRef pWindow, WindowDataPtr pData, Point * localMouse, Rect * globalRect){#pragma unused (pWindow, globalRect)  OSErr      anErr = noErr;  CursHandle    theCross;  Rect      selectionRect = ((PICTDataPtr)pData)-&gt;selectionRectangle;    OffsetRect(&amp;selectionRect, -GetControlValue(pData-&gt;hScroll), -GetControlValue(pData-&gt;vScroll));  if (!PtInRect(*localMouse, &amp;selectionRect) )    {    theCross = GetCursor(crossCursor);    if (theCross)      {      char  oldState;            oldState = HGetState((Handle) theCross);      HLock((Handle) theCross);      SetCursor(*theCross);      HSetState((Handle) theCross, oldState);      anErr = eActionAlreadyHandled;      }    }        return(anErr);  } // PICTAdjustCursor// --------------------------------------------------------------------------------------------------------------static OSErr  PICTDragAddFlavors(WindowRef pWindow, WindowDataPtr pData, DragReference theDragRef){#pragma unused (pWindow)  OSErr  anErr = noErr;    SetDragSendProc(theDragRef, gPICTSendDataProc, nil);  AddDragItemFlavor(theDragRef, (unsigned long)pData, 'PICT', nil, 0, 0);    return(anErr);  } // PICTDragAddFlavors// --------------------------------------------------------------------------------------------------------------static OSErr  PICTGetBalloon(WindowRef pWindow, WindowDataPtr pData,     Point *localMouse, short * returnedBalloonIndex, Rect *returnedRectangle){#pragma unused (pWindow, pData)  Rect  tempRect = ((PICTDataPtr)pData)-&gt;selectionRectangle;    // assume generic content  *returnedBalloonIndex = iHelpPictContent;    // see if we are within the selection  OffsetRect(&amp;tempRect, -GetControlValue(pData-&gt;hScroll), -GetControlValue(pData-&gt;vScroll) );  SectRect(&amp;tempRect, &amp;pData-&gt;contentRect, &amp;tempRect);    if (PtInRect(*localMouse, &amp;tempRect))    {    *returnedRectangle    = tempRect;    *returnedBalloonIndex   = iHelpPictSelection;    }      return(noErr);  } // PICTGetBalloon// --------------------------------------------------------------------------------------------------------------static OSErr  PICTPrintPage(WindowRef pWindow, WindowDataPtr pData,          Rect * pageRect, long *pageNum){#pragma unused (pWindow)  OSErr  anErr = noErr;  short  pagesWide, pagesHigh;  Rect  pictureRect = ((PICTDataPtr)pData)-&gt;pictureRectangle;  Point  offset;  Rect  localPageRect = *pageRect;    // calculate how many physical pages will be required to print this PICT  if (EqualRect(&amp;pictureRect, &amp;localPageRect))    pagesWide = pagesHigh = 1;  else    {    pagesWide = (pictureRect.right - pictureRect.left) / (localPageRect.right - localPageRect.left) + 1;    pagesHigh = (pictureRect.bottom - pictureRect.top) / (localPageRect.bottom - localPageRect.top) + 1;    }            // compute the offset in # of pages  offset.h = ((*pageNum - 1) % pagesWide);  offset.v = ((*pageNum - 1) / pagesWide);  // compute the pixel offset for this page  offset.h *= localPageRect.right - localPageRect.left;  offset.v *= localPageRect.bottom - localPageRect.top;    anErr = DiskPictureDraw( pData, true, &amp;localPageRect, &amp;offset);    // tell it to stop printing when we reach the end  if (*pageNum &gt;= (pagesWide*pagesHigh))    *pageNum = -1;    return(anErr);  } // PICTPrintPage// --------------------------------------------------------------------------------------------------------------static OSErr  PICTAdjustMenus(WindowRef pWindow, WindowDataPtr pData){#pragma unused (pWindow)  OSErr anErr = noErr;    if (!EmptyRect(&amp;((PICTDataPtr)pData)-&gt;selectionRectangle))    EnableCommand(cCopy);  if   (EqualRect(&amp;((PICTDataPtr)pData)-&gt;pictureRectangle, &amp;((PICTDataPtr)pData)-&gt;selectionRectangle))    ChangeCommandName(cSelectAll, kMiscStrings, iSelectNoneCommand);  else    ChangeCommandName(cSelectAll, kMiscStrings, iSelectAllCommand);  EnableCommand(cSelectAll);    return(anErr);  } // PICTAdjustMenus// --------------------------------------------------------------------------------------------------------------static OSErr  PICTCommand(WindowRef pWindow, WindowDataPtr pData, short commandID, long menuResult){#pragma unused (pWindow, menuResult)  OSErr  anErr = noErr;    switch (commandID)    {    case cCopy:      anErr = CopyGWorld(pData);      break;        case cSelectAll:      // erase the old selection      DrawSelection(pData, &amp;((PICTDataPtr)pData)-&gt;selectionRectangle, &amp;((PICTDataPtr)pData)-&gt;patternPhase, false);            if   (EqualRect(&amp;((PICTDataPtr)pData)-&gt;pictureRectangle, &amp;((PICTDataPtr)pData)-&gt;selectionRectangle))        {        ((PICTDataPtr)pData)-&gt;selectionRectangle.top = 0;        ((PICTDataPtr)pData)-&gt;selectionRectangle.left = 0;        ((PICTDataPtr)pData)-&gt;selectionRectangle.bottom = 0;        ((PICTDataPtr)pData)-&gt;selectionRectangle.right = 0;        }      else        {        ((PICTDataPtr)pData)-&gt;selectionRectangle = ((PICTDataPtr)pData)-&gt;pictureRectangle;        }              // draw the new selection      DrawSelection(pData, &amp;((PICTDataPtr)pData)-&gt;selectionRectangle, &amp;((PICTDataPtr)pData)-&gt;patternPhase, true);      break;    }    return(anErr);  } // PICTCommand// --------------------------------------------------------------------------------------------------------------static long PICTCalculateIdleTime(WindowRef pWindow, WindowDataPtr pData){#pragma unused (pWindow)  if (!EmptyRect( &amp;((PICTDataPtr)pData)-&gt;selectionRectangle))    return(0);  else    return(kMaxWaitTime);    } // PICTCalculateIdleTime// --------------------------------------------------------------------------------------------------------------static Boolean  PICTFilterEvent(WindowRef pWindow, WindowDataPtr pData, EventRecord *pEvent){  if   (    (!gMachineInfo.amInBackground) &amp;&amp;    (pEvent-&gt;what == nullEvent) &amp;&amp;    (pWindow == FrontWindow()) &amp;&amp;    (EmptyRgn( ((WindowPeek)pWindow)-&gt;updateRgn)) &amp;&amp;    (MOVESELECTION(pEvent-&gt;when) )    )    {    // erase the old    DrawSelection(pData, &amp;((PICTDataPtr)pData)-&gt;selectionRectangle, &amp;((PICTDataPtr)pData)-&gt;patternPhase, false);        // draw the new, moving onto the next pattern    DrawSelection(pData, &amp;((PICTDataPtr)pData)-&gt;selectionRectangle, &amp;((PICTDataPtr)pData)-&gt;patternPhase, true);    }      return(false);  } // PICTFilterEvent// --------------------------------------------------------------------------------------------------------------static OSErr  PICTMakeWindow(WindowRef pWindow, WindowDataPtr pData){#pragma unused (pWindow)  Size  availableRAM;  long  amountInFile;  OSErr  anErr = noErr;    pData-&gt;pUpdateWindow     = (UpdateWindowProc)    PICTUpdateWindow;  pData-&gt;pGetDocumentRect   = (GetDocumentRectProc)    PICTGetDocumentRect;  pData-&gt;pCloseWindow     = (CloseWindowProc)      PICTCloseWindow;  pData-&gt;pContentClick     = (ContentClickProc)    PICTContentClick;  pData-&gt;pAdjustCursor     = (AdjustCursorProc)    PICTAdjustCursor;  pData-&gt;pGetBalloon       = (GetBalloonProc)      PICTGetBalloon;  pData-&gt;pAdjustMenus     = (AdjustMenusProc)      PICTAdjustMenus;  pData-&gt;pPrintPage       = (PrintPageProc)      PICTPrintPage;  pData-&gt;pCommand         = (CommandProc)        PICTCommand;  pData-&gt;pFilterEvent       = (FilterEventProc)      PICTFilterEvent;  pData-&gt;pCalculateIdleTime  = (CalculateIdleTimeProc)  PICTCalculateIdleTime;  pData-&gt;pDragAddFlavors    = (DragAddFlavorsProc)    PICTDragAddFlavors;    pData-&gt;hasGrow        = true;  pData-&gt;hScrollAmount    = 10;  pData-&gt;vScrollAmount    = 10;    // Calculate amount of available RAM for cache  {  Size grow;  availableRAM = MaxMem(&amp;grow);  }    // Take half of it  availableRAM &gt;&gt;= 1;    // if too big, make it just big enough  GetEOF(pData-&gt;dataRefNum, &amp;amountInFile);  amountInFile -= 512;    if (amountInFile &lt; sizeof(Picture))    anErr = eErrorWhileDrawing;  else    {    if (availableRAM &gt; amountInFile)      {      Handle  theHandle = NewHandle(amountInFile);            if (theHandle)        {        SetFPos(pData-&gt;dataRefNum, fsFromStart, 512);        FSRead(pData-&gt;dataRefNum, &amp;amountInFile, *theHandle);                ((PICTDataPtr)pData)-&gt;cacheHandle = (PicHandle)theHandle;        }      }          // initialize the rectangle to be valid    {    Rect  pictureRect;    DiskPictureDraw( pData, false, &amp;((PICTDataPtr)pData)-&gt;pictureRectangle, nil);      pictureRect = ((PICTDataPtr)pData)-&gt;pictureRectangle;    if ((pData-&gt;contentRect.right &gt; pictureRect.right) &amp;&amp; (pictureRect.right &gt; 0))      pData-&gt;contentRect.right = pictureRect.right;    if ((pData-&gt;contentRect.bottom &gt; pictureRect.bottom) &amp;&amp; (pictureRect.bottom &gt; 0))      pData-&gt;contentRect.bottom = pictureRect.bottom;    }    }    return(anErr);  } // PICTMakeWindow// --------------------------------------------------------------------------------------------------------------OSErr  PICTPreflightWindow(PreflightPtr pPreflightData){  pPreflightData-&gt;wantHScroll      = true;  pPreflightData-&gt;wantVScroll      = true;    pPreflightData-&gt;continueWithOpen   = true;  pPreflightData-&gt;makeProcPtr     = PICTMakeWindow;    pPreflightData-&gt;storageSize = sizeof(PICTDataRecord);    return(noErr);  } // PICTPreflightWindow// --------------------------------------------------------------------------------------------------------------void PICTGetFileTypes(OSType * pFileTypes, OSType * pDocumentTypes, short * numTypes){  pFileTypes[*numTypes]     = 'PICT';  pDocumentTypes[*numTypes]   = kPICTWindow;  (*numTypes)++;  } // PICTGetFileTypes</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/Scriptable_Print_SimpleText/listing17.html%3Fid%3DDTS10000305-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/Scriptable_Print_SimpleText/listing17.html%3Fid%3DDTS10000305-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/Scriptable_Print_SimpleText/listing17.html%3Fid%3DDTS10000305-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>