<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>vImage Programming Guide: Performing Geometric Operations</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Performing Geometric Operations"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP30001001-CH206" title="Performing Geometric Operations"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../index.html#//apple_ref/doc/uid/TP30000440-TP30000430" target="_top">Performance</a> &gt; <a href="../../../GraphicsImaging-date.html#//apple_ref/doc/uid/TP30000440-TP30000430-TP30000450" target="_top">Graphics &amp; Imaging</a> &gt; <a href="../Introduction/Introduction.html#//apple_ref/doc/uid/TP30001001-CH201-TPXREF101">vImage Programming Guide</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../ConvolutionOperations/ConvolutionOperations.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../MorphologicalOperations/MorphologicalOperations.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP30001001-CH206-SW1" title="Performing Geometric Operations"></a><h1>Performing Geometric Operations</h1><p>Unlike convolutions, which enhance or filter images, geometric operations distort the geometry of images. Image rotation, scaling, and resizing are examples of geometric operations. They involve changing the shape of an image by modifying its geometric properties, such as the height, width, and the angles in its form.</p><p>Developers who are in search of efficient ways to alter the geometric properties of images in real time will find these vImage operations useful. In particular, vImage’s geometric operations are well suited for:</p><ul class="ul"><li class="li"><p>Applying arbitrary rotations to large images in real time</p></li><li class="li"><p>Changing the perspective of large images in real time</p></li><li class="li"><p>Scaling large images efficiently</p></li></ul><p>vImage’s geometry transforms usually look better than what you get from Quartz 2D or Core Image since vImage uses Lanczos resampling methods by default (rather than simpler approaches like linear interpolation). This makes vImage’s transforms less susceptible to Moire patterns and offer better image fidelity.</p><p>This chapter describes the various classes of geometric operations vImage offers, and explains how to use them. By reading this chapter you’ll:</p><ul class="ul"><li class="li"><p>See the types of effects geometric operations can produce</p></li><li class="li"><p>Learn how resampling works and why it can be necessary when performing geometric operations</p></li><li class="li"><p>Find out, through code samples, how to apply vImage geometric operations to images</p></li></ul>
<!-- This template is being used for both PDF and HTML. -->

    
    <h4>In this section:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="GeometricOperations.html#//apple_ref/doc/uid/TP30001001-CH206-SW13">Geometric Operations Overview</a>
				
			<br/>
			
        
			
			
				<a href="GeometricOperations.html#//apple_ref/doc/uid/TP30001001-CH206-SW16">Resampling</a>
				
			<br/>
			
        
			
			
				<a href="GeometricOperations.html#//apple_ref/doc/uid/TP30001001-CH206-SW23">Frequently Used Operations</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP30001001-CH206-SW13" title="Geometric Operations Overview"></a><h2>Geometric Operations Overview</h2><p>Although often simple conceptually, geometric operations (such as rotating an image by an arbitrary angle) can be computationally expensive. vImage provides both high-level and low-level functions for performing these operations efficiently. vImage offers several types of geometric operations, each meant to distort the geometry of the initial image in a different way. </p><p>Here are some of the geometric operations available in vImage:</p><ul class="ul"><li class="li"><p>Affine warp</p></li><li class="li"><p>Horizontal reflect</p></li><li class="li"><p>Vertical reflect</p></li><li class="li"><p>Horizontal shear</p></li><li class="li"><p>Vertical shear</p></li><li class="li"><p>Rotation</p></li><li class="li"><p>Scale</p></li></ul><p><span class="content_text">“Affine Warp”</span> shows one of the available scaling functions.</p><br/><div><a name="//apple_ref/doc/uid/TP30001001-CH206-SW9" title="Figure 3-1Scaling"></a><p><strong>Figure 3-1&nbsp;&nbsp;</strong>Scaling</p><img src = "../Art/scale.jpg" alt = "" ></div><br/><p>This function scales images in <code>ARGB8888</code> format:</p><div class="codesample"><table><tr><td scope="row"><pre>vImageScale_ARGB8888( inBuffer, outBuffer, NULL, flags );<span></span></pre></td></tr></table></div><p>The function scales the image by comparing the height and width of the original image (passed through the <code>inBuffer</code> parameter) and the height and width of the destination image (passed through the <code>outBuffer</code> parameter).</p><p>All of the geometric operations that vImage provides are examples of affine transformations. An affine transformation is the most general of linear transformations on an image. Under this transformation, all parallel lines in an image remain parallel. <span class="content_text">Figure 3-2</span> shows a basic affine transformation (notice how all parallelism is maintained).</p><br/><div><a name="//apple_ref/doc/uid/TP30001001-CH206-SW21" title="Figure 3-2An affine transformation"></a><p><strong>Figure 3-2&nbsp;&nbsp;</strong>An affine transformation</p><img src = "../Art/affine_example.jpg" alt = "" ></div><br/><p>Affine transformations work by mapping each pixel in the source image (based on its [<em>x</em>, <em>y</em>] coordinate location)  to a new location [<em>x’</em>, <em>y’</em>] in the destination image based on this simple arithmetic formula:</p><br/><div><a name="//apple_ref/doc/uid/TP30001001-CH206-SW22"></a><img src = "../Art/affine.jpg" alt = "image: ../Art/affine.jpg" ></div><br/><p>Affine transformations can also be described in terms of matrix arithmetic. The transformation is determined by an affine transform matrix</p><br/><div><img src = "../Art/matrix1.gif" alt = "image: ../Art/matrix1.gif" width="56" height="58"></div><br/><p>according to the formula</p><br/><div><img src = "../Art/matrix3.gif" alt = "image: ../Art/matrix3.gif" width="242" height="58"></div><br/><p><em>tx</em> and <em>ty</em> are each symbols for individual values. The additional component “1” on the right side is not part of the location of the source pixel; it is added here to represent the affine transformation as a matrix multiplication. In fact, it is customary to add an extra coordinate to the result vector and represent the affine transformation as</p><br/><div><img src = "../Art/matrix4.gif" alt = "image: ../Art/matrix4.gif" width="273" height="58"></div><br/><p>This makes it easier to calculate the inverse transformation, since the 3 x 3 matrix can be inverted.</p><p>The affine transformation can be decomposed into two less general transformations: a linear transformation followed by a translation (in both the <em>x</em> and <em>y</em> directions). The linear transformation is defined as</p><br/><div><img src = "../Art/matrix5.gif" alt = "image: ../Art/matrix5.gif" width="221" height="49"></div><br/><p>The translation simply adds <em>tx</em> to the x-coordinate, and <em>ty</em> to the y-coordinate.</p><p>The <code>vImage_AffineTransform</code> structure, which contains an affine transformation matrix, is the same as the <code>CGAffineTransform</code> data type. See <em><a href="../../../../GraphicsImaging/Reference/CGAffineTransform/index.html#//apple_ref/doc/uid/TP30000946" target="_top">CGAffineTransform Reference</a></em> for the functions used for creating and manipulating matrices.</p><p>Unlike convolutions, geometric operations distort the geometry of images. As a result, the number of pixels in the output image might differ from the number of pixels in the input image. Take, for example, the affine warp shown in <span class="content_text">Figure 3-3</span>.</p><br/><div><a name="//apple_ref/doc/uid/TP30001001-CH206-SW8" title="Figure 3-3Affine warp"></a><p><strong>Figure 3-3&nbsp;&nbsp;</strong>Affine warp</p><img src = "../Art/affine_warp.jpg" alt = "" ></div><br/><p>In this example it’s clear that area of the output image is different from the original image because the height, width, and angles have been changed. When an image processing function is unable to maintain a one-to-one mapping between each pixel in the source image and each pixel in the destination image, it must use something called a resampling filter to get the desired pixel values in the destination image. You will learn how vImage handles resampling filters in greater detail in the next section.</p><a name="//apple_ref/doc/uid/TP30001001-CH206-SW16" title="Resampling"></a><h2>Resampling</h2><p>Changing the dimensions of a digital image (as done in scaling and rotation) can potentially create unintended features to appear in the image. Many of these features occur when trying to evaluate pixels at fractional pixel locations. Most of the vImage geometric functions use a process known as <strong>resampling</strong> in order to avoid creating artifacts, such as interference patterns, in the destination image. vImage performs resampling using kernels, which combine data from a target pixel and other nearby pixels to calculate a value for the destination pixel. This is very similar to convolution.</p><p>However, in the geometric operations, the resampling kernel must itself be resampled during the process of pairing kernel values against the sampled pixel data. vImage must evaluate the kernel at fractional pixel locations (“in-between” pixels), in addition to integral pixel locations. Consequently, instead of using an M x N matrix for the kernel (as the convolution operations do), the operations use a kernel function that can be evaluated at both fractional and integral pixel locations. This resampling kernel function is called a <strong>resampling filter</strong>, or simply a filter.</p><p>For almost all geometric operations, vImage supplies a default resampling filter. The default resampling filters are implementations of the commonly used Lanczos resampling method. The Lanczos resampling method usually produces better-looking results than simpler approaches such as linear interpolation. However, the Lanczos method can produce ringing effects near regions of high frequency signals (such as line art). vImage provides two variations to choose from. If you do not set the <code>kvImageHighQualityResampling</code> flag for the call, vImage uses a <code>Lanczos3</code> filter. If you do set the flag, vImage uses a <code>Lanczos5</code> filter. A <code>Lanczos5</code> filter does higher-quality resampling than a <code>Lanczos3</code> filter but is slower to use.</p><p>The <code>Rotate</code> functions use resampling. The <code>Rotate90</code> functions do not.</p><p>The shear functions are a special case. They can use a default filter, but they also permit you to specify a custom filter of your own. You can use this feature when you need increased control over the operation.</p><a name="//apple_ref/doc/uid/TP30001001-CH206-SW2" title="Listing 3-1Creating a default resampling filter for a shear function"></a><p class="codesample"><strong>Listing 3-1&nbsp;&nbsp;</strong>Creating a default resampling filter for a shear function</p><div class="codesample"><table><tr><td scope="row"><pre>ResamplingFilter filter = vImageNewResamplingFilter( float scale, vImage_Flags kvImageNoFlags )<span></span></pre></td></tr></table></div><p>The procedure is different if you want to provide a custom resampling filter. Because the shear functions operate on a line-by-line basis, a resampling kernel used with a shear function is one-dimensional, a 1 x N matrix. Consequently, the resampling filter for a shear function can be modeled as a one-dimensional function <em>y = f(x)</em>. When using a custom filter, you must provide a routine that evaluates your function <em>f(x)</em> on an array of <em>x</em> values. At the same time you can, if desired, normalize the filter over the given array of <em>x</em> values. (This is the main reason your routine is required to evaluate your filter on an array of <em>x</em> values, rather than a single <em>x</em> value. It also improves performance.) To normalize the filter over an array of <em>x</em> values, you scale the filter values so that they add up to 1.0. If you do not do this, interference patterns may emerge in the resulting image.</p><a name="//apple_ref/doc/uid/TP30001001-CH206-SW18" title="Creating a Resampling Filter"></a><h3>Creating a Resampling Filter</h3><p>When you call a shear function, you must pass a parameter of type <code>ResamplingFilter</code>, regardless of whether you want to use a custom resampling filter or not.</p><p>If you want to use a default resampling filter, you create it by calling <code>vImageNewResamplingFilter</code> (as previously seen in <span class="content_text"><a href="GeometricOperations.html#//apple_ref/doc/uid/TP30001001-CH206-SW2">Listing 3-1</a></span>). This creates a new <code>ResamplingFilter</code> object that represents a default filter—a <code>Lanczos3</code> filter if you do not set the <code>kvImageHighQualityResampling</code> flag, or a <code>Lanczos5</code> filter if you do set that flag. You do not need to provide a filter function when you make this call.</p><p>The same <code>ResamplingFilter</code> object can be used in multiple shear function calls. However, the filter includes a scaling factor. If you want to use a different scaling factor, you must create a new filter.</p><p>When you are done using a <code>ResamplingFilter</code> object created by a call to <code>vImageNewResamplingFilter</code>, dispose of it by calling <code>vImageDestroyResamplingFilter</code>. Do not attempt to directly deallocate the object’s memory yourself.</p><p>If you want to create a <code>ResamplingFilter</code> object that represents your custom resampling filter, you create it by calling <code>vImageNewResamplingFilterForFunctionUsingBuffer</code>. You must pass a pointer to your custom filter function. <code>vImageNewResamplingFilterForFunctionUsingBuffer</code> creates the <code>ResamplingFilter</code> object in a buffer that you allocate directly. See <em><a href="../../../Reference/vImage_geometric/index.html#//apple_ref/doc/uid/TP40005490" target="_top">vImage Geometry Reference</a></em> for the details of usage. When you are done using the object, you must deallocate its memory yourself. Do not pass a <code>ResamplingFilter</code> object created by <code>vImageNewResamplingFilterForFunctionUsingBuffer</code> to <code>vImageDestroyResamplingFilter</code>.</p><p>To get the size of the buffer required for a custom <code>ResamplingFilter</code> object, call <code>vImageGetResamplingFilterSize</code>. Both the default <code>ResamplingFilter</code> and the custom <code>ResamplingFilter</code> objects include a scale factor that you provide. This scale factor is used to scale the transformed image in the shear operation.</p><a name="//apple_ref/doc/uid/TP30001001-CH206-SW19" title="A Sample Custom Resampling Filter"></a><h3>A Sample Custom Resampling Filter</h3><p><span class="content_text">Listing 3-2</span> shows how to declare and use a custom resampling filter function. The underlying filter function is <code>y = 1.0 – |x|</code>. The custom filter must evaluate that function on an array of <em>x</em> values. The filter may not be normalized over that range of <em>x</em> values. You can normalize it within the routine by dividing by the sum of the result values, as shown. This routine does not use <code>userData</code>.</p><a name="//apple_ref/doc/uid/TP30001001-CH206-SW5" title="Listing 3-2Using a custom filter function"></a><p class="codesample"><strong>Listing 3-2&nbsp;&nbsp;</strong>Using a custom filter function</p><div class="codesample"><table><tr><td scope="row"><pre>void MyLinearInterpolationFilterFunc(const float* xArray,<span></span></pre></td></tr><tr><td scope="row"><pre> float* yArray,<span></span></pre></td></tr><tr><td scope="row"><pre> int count,<span></span></pre></td></tr><tr><td scope="row"><pre> void* userData )<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    int i;<span></span></pre></td></tr><tr><td scope="row"><pre>    float sum = 0.0f;<span></span></pre></td></tr><tr><td scope="row"><pre>    //Calculate kernel values<span></span></pre></td></tr><tr><td scope="row"><pre>    for( i = 0; i &lt; count; i++ )<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        float unscaledResult = 1.0f - fabs( xArray[i] );    //LERP<span></span></pre></td></tr><tr><td scope="row"><pre>        yArray[i] = unscaledResult;<span></span></pre></td></tr><tr><td scope="row"><pre>        sum += unscaledResult;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    //Make sure the kernel values sum to 1.0. You can use some other  value here.<span></span></pre></td></tr><tr><td scope="row"><pre>    //Values other than 1.0 will cause the image to lighten or darken.<span></span></pre></td></tr><tr><td scope="row"><pre>    sum = 1.0f / sum;<span></span></pre></td></tr><tr><td scope="row"><pre>    for( i = 0; i &lt; count; i++ )<span></span></pre></td></tr><tr><td scope="row"><pre>        yArray[i] *= sum;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP30001001-CH206-SW23" title="Frequently Used Operations"></a><h2>Frequently Used Operations</h2><p>Rotations and scaling are the most common geometric operations, and vImage’s scaling and rotation functions are particularly suited for developers that need these scalings to look as clean as possible. Applications that manage photo layout (like iPhoto’s digital photo books) are perfect candidates for this. <span class="content_text">Listing 3-3</span> shows how to rotate an image that is in <code>ARGB8888</code> format.</p><a name="//apple_ref/doc/uid/TP30001001-CH206-SW3" title="Listing 3-3Rotating an image by a specified angle using vImageRotate_ARGB8888"></a><p class="codesample"><strong>Listing 3-3&nbsp;&nbsp;</strong>Rotating an image by a specified angle using vImageRotate_ARGB8888</p><div class="codesample"><table><tr><td scope="row"><pre>int MyRotateFilter(void *inData, unsigned int inRowBytes, void *outData, unsigned int outRowBytes, unsigned int height, unsigned int width, void *kernel, unsigned int kernel_height, unsigned int kernel_width, int colorChannel, vImage_Flags flags )<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    vImage_Buffer in = { inData, height, width, inRowBytes };<span></span></pre></td></tr><tr><td scope="row"><pre>    vImage_Buffer out = { outData, height, width, outRowBytes };<span></span></pre></td></tr><tr><td scope="row"><pre>    TransformInfo *info = kernel;<span></span></pre></td></tr><tr><td scope="row"><pre>    float angle = info->rotate * 2.0f * M_PI / 360.0f;<span></span></pre></td></tr><tr><td scope="row"><pre>    Pixel_8888 backColor;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    backColor[0] = UCHAR_MAX * info->a;<span></span></pre></td></tr><tr><td scope="row"><pre>    backColor[1] = UCHAR_MAX * info->r;<span></span></pre></td></tr><tr><td scope="row"><pre>    backColor[2] = UCHAR_MAX * info->g;<span></span></pre></td></tr><tr><td scope="row"><pre>    backColor[3] = UCHAR_MAX * info->b;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    return vImageRotate_ARGB8888( &amp;in, &amp;out, NULL, angle, backColor, flags );<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP30001001-CH206-SW4" title="Rotation"></a><h3>Rotation</h3><p>When performing rotation, vImage maps the center point of the source image to the center point of the destination image. No scaling is done. Depending on the relative sizes of the source image and destination image, parts of the source image may be clipped, and areas outside the source image may appear in the destination image. <span class="content_text">Figure 3-4</span> shows a photo of a bluejay that is rotated, but portions of the image appear clipped since they now reside outside the image buffer (these regions are colored with a caller-supplied background color).</p><br/><div><a name="//apple_ref/doc/uid/TP30001001-CH206-SW6" title="Figure 3-4Rotated image with clipping"></a><p><strong>Figure 3-4&nbsp;&nbsp;</strong>Rotated image with clipping</p><img src = "../Art/rotate.jpg" alt = "" ></div><br/><a name="//apple_ref/doc/uid/TP30001001-CH206-SW7" title="90 Degree Rotation"></a><h3>90 Degree Rotation</h3><p>This rotation operation rotates a source image by either 0, 90, 180, or 270 degrees (depending on a value you supply). vImage maps the center point of the source image to the center point of the destination image. No scaling or resampling is done. Depending on the relative sizes of the source image and destination image, parts of the source image may be clipped, and areas outside the source image (colored with a background color you supply) may appear in the destination image (as seen in <span class="content_text"><a href="GeometricOperations.html#//apple_ref/doc/uid/TP30001001-CH206-SW6">Figure 3-4</a></span>).</p><p>Because no resampling is done—instead, individual pixels are copied unchanged to new locations—this function places certain restrictions on the pixel heights and widths of the source and destination buffers, so that it can map the center of the source to the center of the destination precisely. The restrictions are these:</p><ul class="spaceabove"><li class="li"><p>If you are rotating an image 90 or 270 degrees, the height in pixels of the source image and the width of the destination image must both be even or both be odd; and the width of the source image and the height of the destination image must both be even or both be odd.</p></li><li class="li"><p>If you are rotating an image 0 or 180 degrees, the height in pixels of the source image and the destination image must both be even or both be odd; and the width of the source image and the destination image must both be even or both be odd.</p></li></ul><p>If your images do not meet these restrictions, you can use the general (higher-level) <code>Rotate</code> function instead.</p><a name="//apple_ref/doc/uid/TP30001001-CH206-SW10" title="Horizontal Reflections"></a><h3>Horizontal Reflections</h3><p>A horizontal reflection creates a mirror image of the input image by reflecting about the y-axis of the image. This can be thought of as placing an imaginary line from the top of the image to the bottom, and swapping each pixel on one side with the corresponding pixel on the other side. <span class="content_text">Figure 3-5</span> shows an example of a horizontal reflection operation.</p><br/><div><a name="//apple_ref/doc/uid/TP30001001-CH206-SW11" title="Figure 3-5Horizontal reflect"></a><p><strong>Figure 3-5&nbsp;&nbsp;</strong>Horizontal reflect</p><img src = "../Art/horiz_reflect.jpg" alt = "" ></div><br/><a name="//apple_ref/doc/uid/TP30001001-CH206-SW12" title="Vertical Reflections"></a><h3>Vertical Reflections</h3><p>A vertical reflection is identical to a horizontal reflect, except it reflects about the x-axis instead. <span class="content_text">Figure 3-6</span> shows an example of a vertical reflection operation.</p><br/><div><a name="//apple_ref/doc/uid/TP30001001-CH206-SW24" title="Figure 3-6Vertical reflect"></a><p><strong>Figure 3-6&nbsp;&nbsp;</strong>Vertical reflect</p><img src = "../Art/vert_reflect.jpg" alt = "" ></div><br/><a name="//apple_ref/doc/uid/TP30001001-CH206-SW25" title="Horizontal Shear"></a><h3>Horizontal Shear</h3><p>vImage’s horizontal shear function does shearing, translation, and scaling (in the horizontal dimension only) on a source image. The shear functions (and <code>Rotate90</code>) serve as the foundation upon which many of vImage’s other functions are implemented. In a simple horizontal shearing operation (no scaling or translation), a rectangular region of interest is mapped into a parallelogram whose top and bottom are parallel to the original rectangle, and whose sides are slanted at a particular slope. The height of the parallelogram is the same as the height of the original rectangle. </p><p>The operation starts at the bottom of the rectangle and shifts each row of pixels to the right by an amount proportional to that row’s distance from the bottom of the rectangle. The shift amount may be fractional for some rows, and so resampling must be done to assign appropriate pixel values without introducing interference patterns or other artifacts.</p><p>vImage allows you to specify the resampling filter. It can either be a default supplied by vImage—a Lanczos kernel—or a custom resampling filter you provide. In either case you pass a <code>ResamplingFilter</code> object to the horizontal shear function. The <code>ResamplingFilter</code> object you supply must contain the information necessary to calculate the resampling filter. It also contains a scale factor, which scales the transformed image in the horizontal direction. </p><p>In addition to simple shearing and scaling, the vImage horizontal shearing function allows you to specify a horizontal translation value, which shifts the transformed image to the left or the right in the destination buffer.</p><p>As the region of interest is sheared, translated, and scaled, source pixels from outside the region of interest (but inside the source image) may appear in the destination buffer. In fact, vImage shears, translates, and scales as much of the source image as it needs to in order to attempt to fill the destination buffer. In addition, areas from outside the source image may appear in the destination image. These are assigned colors using either the background color fill technique or the edge extend technique, depending on a flag setting.</p><p>The size (number of rows and number of columns) of the destination buffer is also used to determine the size of the region of interest in the source buffer. The origin of both the region of interest and the destination buffer are assumed to be in the lower-left corner. If there is no translation, then the lower-left corner of the region of interest (not necessarily of the source image, which may be different) is mapped to the lower-left corner of the destination image. (The <code>vImage_Buffer</code> data pointer points to the top-left corner of the image, as always.)</p><p><span class="content_text">Figure 3-7</span> shows the photo after a horizontal shear operation with no translation component.</p><br/><div><a name="//apple_ref/doc/uid/TP30001001-CH206-SW26" title="Figure 3-7Horizontal shear"></a><p><strong>Figure 3-7&nbsp;&nbsp;</strong>Horizontal shear</p><img src = "../Art/horiz_shear.jpg" alt = "" ></div><br/><a name="//apple_ref/doc/uid/TP30001001-CH206-SW27" title="Vertical Shear"></a><h3>Vertical Shear</h3><p>vImage’s vertical shear function does shearing, translation, and scaling (in the vertical dimension only) on a source image. In a simple vertical shearing operation (no scaling or translation), a rectangular region of interest is mapped into a parallelogram whose left and right edges are parallel to the original rectangle, and whose top and bottom edges are slanted at a particular slope. The width of the parallelogram is the same as the width of the original rectangle, and the height of the parallelogram (the height of any column) is the same as the height of the original rectangle.</p><p>The vertical shear starts at the left edge of the rectangle and shifts each row of pixels up by an amount proportional to that row’s distance from the bottom of the rectangle. The shift amount may be fractional for some rows, and so resampling must be done to assign appropriate pixel values without introducing interference patterns or other artifacts.</p><p>vImage allows you to specify the resampling filter. It can either be a default filter supplied by vImage—a Lanczos kernel—or a custom resampling filter supplied by the user. In either case you pass a <code>ResamplingFilter</code> object to the vertical shear function. The <code>ResamplingFilter</code> object you supply must contain the information necessary to calculate the resampling filter. It also contains a scale factor, which scales the transformed image in the vertical direction.</p><p>In addition to simple shearing and scaling, the vImage vertical shearing function allows you to specify a vertical translation value, which shifts the transformed image up or down in the destination buffer.</p><p>As the region of interest is sheared, translated, and scaled, source pixels from outside the region of interest (but inside the source image) may appear in the destination buffer. In fact, vImage shears, translates, and scales as much of the source image as it needs to in order to attempt to fill the destination buffer. In addition, areas from outside the source image may appear in the destination image. These outside areas are assigned colors using either the background color fill technique or the edge extend technique, depending on a flag setting.</p><p><span class="content_text">Figure 3-8</span> shows a picture after a vertical shear operation.</p><br/><div><a name="//apple_ref/doc/uid/TP30001001-CH206-SW28" title="Figure 3-8Vertical shear"></a><p><strong>Figure 3-8&nbsp;&nbsp;</strong>Vertical shear</p><img src = "../Art/vert_shear.jpg" alt = "" ></div><br/><a name="//apple_ref/doc/uid/TP30001001-CH206-SW14" title="Affine Warp"></a><h3>Affine Warp</h3><p>Using functions such as <code><a href="../../../Reference/vImage_geometric/Reference/reference.html#//apple_ref/c/func/vImageAffineWarp_ARGB8888" target="_top">vImageAffineWarp_ARGB8888</a></code> you can perform customized affine transformations that combine the effects of various rotations, shears, and reflections into a single function call. You do this by first constructing a <code><a href="../../../Reference/vImage_types/Reference/reference.html#//apple_ref/c/tdef/vImage_AffineTransformvImage_AffineTransform" target="_top">vImage_AffineTransform</a></code> data type which represents your affine transformation matrix. You can then pass this as a parameter (along with the rest of your image data) to the various affine warp functions vImage offers. </p>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../ConvolutionOperations/ConvolutionOperations.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../MorphologicalOperations/MorphologicalOperations.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2008 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2008-10-15<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Performance/Conceptual/vImage/GeometricOperations/GeometricOperations.html%3Fid%3DTP30001001-4.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Performance/Conceptual/vImage/GeometricOperations/GeometricOperations.html%3Fid%3DTP30001001-4.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Performance/Conceptual/vImage/GeometricOperations/GeometricOperations.html%3Fid%3DTP30001001-4.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>