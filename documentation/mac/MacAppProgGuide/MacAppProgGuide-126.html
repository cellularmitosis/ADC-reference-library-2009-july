<!-- Generated by Harlequin WebMaker 2.2.3 (30-Apr-1996)
Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->
<HTML> <HEAD>
<TITLE>Recipes--Failure Handling (MacApp PG)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING126></A>


<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="MacAppProgGuide-125.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="MacAppProgGuide-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="MacAppProgGuide-158.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="MacAppProgGuide-127.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="MacAppProgGuide-2.html"><B>Programmer's Guide to MacApp</B></A> / <A HREF="MacAppProgGuide-78.html"><B>Part 2 - Working With MacApp</B></A><BR><DD><A HREF="MacAppProgGuide-122.html"><B>Chapter 24 - Working With Memory and Failure Handling</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING126-0></A>
<H1><A NAME=MARKER-2-84></A>Recipes--Failure Handling</H1>
 The recipe and sample code in this section demonstrate how to avoid problems with register variables in failure-handling code.<P>
<A NAME=HEADING126-2></A>
<H2><A NAME=MARKER-9-85></A>Recipe--Avoiding Register Variables in Failure Handlers</H2>
 A C++ compiler may optimize code by storing local variables in registers. This practice can cause problems during failure handling because MacApp calls the C library routine <CODE><A NAME=MARKER-2-86></A>longjmp</CODE>, which restores registers to their values before the error occurred. A variable you wish to use in your recovery code may be set to a meaningless value when the previous value of its register is restored.<P>
 To ensure that a variable is not stored in a register, you use the MacApp macros <CODE><A NAME=MARKER-2-87></A>MAVolatile</CODE> and <CODE><A NAME=MARKER-2-88></A>MAVolatileInit</CODE>. These macros are introduced beginning on <A HREF=MacAppProgGuide-28.html#MARKER-9-91>page 58</A>. They can be used with variables of any type and are guaranteed to work on any compiler, even those that don't support the <CODE>volatile</CODE> keyword.<P>
 For <CODE>MAVolatile</CODE>, you supply a variable and a type, as in the following line:<P>
<PRE>
MAVolatile(long, raisinsPerBox);
</PRE>
 This guarantees that the variable raisinsPerBox will not be stored in a register.<P>
 For <CODE>MAVolatileInit</CODE>, you supply a type, a variable, and an initial value. The following code sample, from the <CODE><A NAME=MARKER-2-89></A>GetFilesList</CODE> method of MacApp's <CODE><A NAME=MARKER-2-90></A>TFilesCommand</CODE> class, uses <CODE>MAVolatileInit</CODE> for both of the lists created in the code block. It also demonstrates embedded failure handling with an iterator (described in <A HREF=MacAppProgGuide-28.html#MARKER-9-92>"Failure Handling Embedded in Objects," beginning on page 59</A>).<P>
<PRE>
MAVolatileInit(THandleList*, aHandleList, NULL);
MAVolatileInit(TList*, aFileList, NULL);
FailInfo outerFi;
Try(outerFi)
{
   aHandleList = new THandleList;
   aHandleList-&gt;IHandleList();
   
   FailInfo innerFi;
   Try(innerFi)
   {
      aFileList = NewList();
      .
      .
      .
      // Extra block to control scope of failure handler embedded in iterator.
      {
         CHandleIterator iter(aHandleList);
            for (Handle item = iter.FirstHandle(); iter.More(); 
                  item = iter.NextHandle())
         {
            MAVolatileInit(TFile*, aFile, NULL);
            aFile = gApplication-&gt;DoMakeFile(fIdentifier);
            FailInfo oneMoreFi;
            Try(oneMoreFi)
            {
               FailOSErr(...);
               .
               .
               .
               oneMoreFi.Success(); // No error, so remove handler.
            }
            else
            {
               // For a failure here, just free the file, if
               // necessary, then resignal to do any added cleanup.
               aFile = (TFile*)FreeIfObject(aFile);
               oneMoreFi.ReSignal();
            }
            aHandleList-&gt;Delete(item);// Delete item from the list.
            item = DisposeIfHandle(item);
         }
      }  // End extra block. Iterator's destructor calls success
         // for its failure handler.

      innerFi.Success();         // No error, so remove handler.
   }
   else                          // Recover.
   {
      // If we failed here, we may need to free both lists,
      // then resignal, in case there is any additional cleanup.
      if (aHandleList) 
         aHandleList-&gt;FreeList();
      if (aFileList) 
         aFileList-&gt;FreeList();
      innerFi.ReSignal();
   }
   outerFi.Success();            // No error, so remove handler.
}
else
{
   // If we couldn't create a handle list, just free the command,
   // then resignal, in case there is any additional cleanup.
   this-&gt;Free();
   outerFi.ReSignal();
}
</PRE>
 This code creates two lists within a failure-handling block. If an error occurs, the lists need to be freed. If the list variables were stored as register values, they could be corrupted when the failure handler restores the previous state of the registers--any attempt to use them in a recovery block could be disastrous. The <CODE>MAVolatileInit</CODE> macro eliminates this danger by preventing the list variables from being stored as register values.<P>
 A further complication is added by the user of an iterator. An iterator has an embedded failure handler that is installed by the iterator's constructor method and removed by its destructor method. By declaring the iterator inside its own code block in the middle of this method, we can control when the iterator goes out of scope and has its failure handler removed. As a result, we can guarantee that the iterator's failure handler isn't called for an error occurring outside the loop in which the iterator is used.<A NAME=MARKER-2-91></A><A NAME=MARKER-2-92></A><P>
 <P>
</BLOCKQUOTE>
<HR>
<center>
<A HREF="MacAppProgGuide-125.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="MacAppProgGuide-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="MacAppProgGuide-158.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="MacAppProgGuide-127.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="MacAppProgGuide-3.html">&copy; Apple Computer, Inc.</A><br>25 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>  
