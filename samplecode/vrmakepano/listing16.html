<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>vrmakepano - /MakePano.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/QuickTime/index.html">QuickTime</a> &gt; <a href="../../samplecode/QuickTime/idxVirtualReality-date.html">Virtual Reality</a> &gt; <A HREF="javascript:location.replace('index.html');">vrmakepano</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">vrmakepano</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/MakePano.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/Application Files/ComApplication.c</option>
<option value="listing2.html">/Application Files/ComApplication.h</option>
<option value="listing3.html">/Application Files/ComResource.h</option>
<option value="listing4.html">/Common Files/ComFramework.c</option>
<option value="listing5.html">/Common Files/ComFramework.h</option>
<option value="listing6.html">/Common Files/MacFramework.c</option>
<option value="listing7.html">/Common Files/MacFramework.h</option>
<option value="listing8.html">/Common Files/MacPrefix.h</option>
<option value="listing9.html">/Common Files/QTUtilities.c</option>
<option value="listing10.html">/Common Files/QTUtilities.h</option>
<option value="listing11.html">/Common Files/QTVRUtilities.c</option>
<option value="listing12.html">/Common Files/QTVRUtilities.h</option>
<option value="listing13.html">/Common Files/WinFramework.c</option>
<option value="listing14.html">/Common Files/WinFramework.h</option>
<option value="listing15.html">/Common Files/WinPrefix.h</option>
<option value="listing16.html">/MakePano.c</option>
<option value="listing17.html">/MakePano.h</option>
<option value="listing18.html">/VRMakePano.c</option>
<option value="listing19.html">/VRMakePano.h</option></select>
				</p>
				</form>
				<p><strong><a href="vrmakepano.zip">Download Sample</a></strong> (&#147;vrmakepano.zip&#148;, 200.6K)<BR>
<strong><a href="vrmakepano.dmg">Download Sample</a></strong> (&#147;vrmakepano.dmg&#148;, 288.3K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/******************************************************************************** *  File:    MakePano.c * *  Contains:  Code for creating a QuickTime VR panoramic movie from a panoramic image. * *  Written by:  Ken Turkowski *        Directly derived from VTMakeOPano.c by Tim Monroe. *        Based largely on MakeQTVRPanorama code by Ed Harp (and others?). *        Cubic projection code based on SampleMakeCubic.cp code by Ken Doyle. * *  Copyright:  &copy; 1996-1998 by Apple Computer, Inc., all rights reserved. * *  Change History (most recent first): * *     &lt;15&gt;     06/14/00  rtm    modified ImportVideoTrack as per Ken Doyle's changes in MakeCubicPPC *     &lt;14&gt;     03/23/00  rtm    added code to handle new cubic file format *     &lt;13&gt;     03/21/00  rtm    made changes to get things running under CarbonLib *     &lt;12&gt;     11/24/99  rtm    reworked file opening and saving to avoid using Standard File Package *                  on Macintosh (for Carbonization effort) *     &lt;11&gt;     02/01/99  rtm    reworked prompt and filename handling to remove &quot;\p&quot; sequences *     &lt;10&gt;     10/19/98  rtm    added check in CreatePanoTrack to make sure we were passed a *                  valid hot spot file spec (otherwise no panorama is created!); added *                  the default movie progress procedure *     &lt;9&gt;     09/30/98  rtm    tweaked call to AddMovieResource to create single-fork movies; *                  tweaked call to FlattenMovieData to enable FastStart option *     &lt;8&gt;     08/06/98  rtm    added VRPano_MakeHotSpotVers2x0 (based loosely on code from John Mott) *                  to support version 2.0 hot spot atoms; sketched out preliminary *                  support for 1.0 hot spots, but that's left as an exercise for the reader *     &lt;7&gt;     08/05/98  rtm    added support for hot spots image tracks (both version 1.0 and 2.0) *     &lt;6&gt;     08/26/98  rtm    added support for pan/tilt/field-of-view constraint atoms *     &lt;5&gt;     08/18/98  rtm    added support for version 1.0 panoramic movies *     &lt;4&gt;     08/16/98  rtm    final clean-up before initial release *     &lt;3&gt;     08/15/98  rtm    reworked the image file handling using QuickTime graphics importers; *                  added tile-display window for debugging purposes; *                  now we run fine under both MacOS and Windows. Ta da! *     &lt;2&gt;     01/14/98  rtm    further work; added Endian* macros; got working on MacOS *     &lt;1&gt;     01/12/98  rtm    first file from CMovieMaker.cp in MakeQTVRPanorama 2.0b * *  This file contains functions that convert a panoramic image into a QuickTime VR movie. The image *  can be a picture (of type 'PICT') or any other kind of image for which QuickTime has a graphics *  importer component. Here, we can create both version 1.0 and version 2.0 QTVR panoramic movies. *  We can also create hot spot image tracks and (for version 2.0 only) assemble the various hot spot *  atoms. * *  This file also contains a function that constructs a QuickTime VR movie that uses the new cubic *  projection. In the following notes, we'll call such movies &quot;cubic movies&quot; or &quot;cubic panoramas&quot;. * ******************************************************************************** * *  VERSION 2.0 FILE FORMAT * *  The definitive source of information about creating QTVR 2.0 panoramic movies is Chapter 3 of the *  book &quot;Virtual Reality Programming With QuickTime VR 2.0&quot;. (This information is also available *  online, at &lt;http://dev.info.apple.com/dev/techsupport/insidemac/qtvr/qtvrapi-2.html&gt;.) Here is *  a condensed version of the info in that chapter, as pertains to panoramas: * *  A panoramic movie is a QuickTime movie that contains at least three tracks: a QTVR track, a panorama *  track, and a panorama image track. In addition, a QuickTime VR movie must contain some special user data *  that specifies the QuickTime VR movie controller. A QuickTime VR movie can also contain other kinds of *  tracks, such as hot spot image tracks and even sound tracks. * *  A QuickTime VR movie contains a single &quot;QTVR track&quot;, which maintains a list of the nodes in the movie. *  Each individual sample in the QTVR track's media contains information about a single node, such as the *  node's type, ID, and name. Since we are creating a single-node movie here, our QTVR track will contain *  a single media sample.  * *  Every media sample in a QTVR track has the same sample description, whose type is QTVRSampleDescription. *  The data field of that sample description is a &quot;VR world&quot;, an atom container whose child atoms specify *  information about the nodes in the movie, such as the default node ID and the default imaging properties. *  We'll spend a good bit of time putting things into the VR world. * *  A panoramic movie also contains a single &quot;panorama track&quot;, which contains information specific to the *  panorama. A panorama track has a media sample for each media sample in the QTVR track. As a result, *  our panorama track will have one sample. The QTVRPanoSampleAtom structure defines the media sample data.  * *  The actual image data for a panoramic node is contained in a &quot;panorama image track&quot;. The individual *  frames in that track are the diced (and also perhaps compressed) tiles of the original panoramic image. *  There may also be a &quot;hot spot image track&quot; that contains the diced (and also perhaps compressed) tiles *  of the hot spot panoramic image. * *  So, our general strategy, given a panoramic image, is as follows (though perhaps not in the order listed): * *    (1) Create a movie containing a video track whose frames are the compressed tiles of the panoramic *          image. Call this movie the &quot;tile movie&quot;. Create a similar movie for the hot spot image. Call *      this movie the &quot;hot spot tile movie&quot;. *    (2) Create a new, empty movie. Call this movie the &quot;QTVR movie&quot;. *    (3) Create a QTVR track and its associated media. *    (4) Create a VR world atom container; this is stored in the sample description for the QTVR track. *    (5) Create a node information atom container for each node; this is stored as a media sample *          in the QTVR track. *    (6) Create a panorama track and add it to the movie. *    (7)  Create a panorama image track by copying the video track from the tile movie to the QTVR movie. *    (8)  Create a hot spot image track by copying the video track from the hot spot tile movie to the QTVR movie. *    (9) Set up track references from the QTVR track to the panorama track, and from the panorama track *          to the panorama image track and the hot spot image track. *    (A) Add a user data item that identifies the QTVR movie controller. *    (B) Flatten the QTVR movie into the final panoramic movie. * ******************************************************************************** * *  VERSION 1.0 FILE FORMAT * *  The definitive source of information about creating QTVR 1.0 panoramic movies is Technote 1035, *  &quot;QuickTime VR 1.0 Panorama Movie File Format&quot; released in March 1996, available online at the address *  &lt;http://devworld.apple.com/dev/technotes/tn/tn1035.html&gt;. Here is a condensed version of the info *  in that technote: * *  For version 1.0 panoramic movies, the file format is somewhat simpler. A single-node panoramic movie *  contains a &quot;scene track&quot; and a &quot;panorama track&quot;. The scene track is an inactive video track that contains *  the diced (and also perhaps compressed) tiles of the original panoramic image. A version 1.0 scene track *  is essentially a version 2.0 panorama image track. * *  A panoramic movie also contains a single &quot;panorama track&quot;, which contains information specific to the *  panorama. The panorama track in version 1.0 differs significantly from the panorama track in version 2.0, *  so don't let the names confuse you.  * *  A &quot;panorama track&quot; in version 1.0 contains one media sample for each node in the movie. Every media sample *  in a panorama track has the same sample description, whose type is PanoramaDescription. This structure *  contains information about how the panoramic image was diced, along with information about any hot spot *  and low-resolution scene tracks that might be contained in the movie file. * *  Each individual sample in the panorama track's media contains information about a single node, *  such as the node's default view angles, pan and zoom constraints, and hot spot information. *  Since we are creating a single-node movie here, our panorama track will contain a single media sample.  *  The data in a panorama track sample is organized as a sequence of &quot;atom data structures&quot;; each such *  structure begins with size and type fields, so you can easily read thru the atom data structures by *  starting at the beginning of the sample data and hopping over each structure. The atoms can appear in *  any order in the panorama track sample data. * *  -&gt; IMPORTANT: The &quot;atom data structures&quot; that comprise a panorama track sample are *not* QTAtoms, and the *  -&gt; panorama track sample itself is *not* a QTAtomContainer. The version 1.0 panorama file format predates *  -&gt; QuickTime 2.1, which introduced the atom data routines. As a result, you cannot use the atom data routines *  -&gt; to read or write version 1.0 panorama track samples. * *  A panorama track sample must contain a &quot;panorama header atom&quot;, whose structure is PanoSampleHeaderAtom. *  The sample may contain other atoms as well, such as a string table atom (which contains strings, such as *  node names) and a hot spot table atom (which lists all of the hot spots in a node). In this sample code, *  we add a hot spot image track to the VR movie, but we do not (yet) build a hot spot atom table; as a result, *  our panorama track sample will need to contain only a panorama header atom. * *  So, our general strategy, given a panoramic image, is as follows (though perhaps not in the order listed): * *    (1) Create a movie containing a video track whose frames are the compressed tiles of the panoramic *          image. Call this movie the &quot;tile movie&quot;. Create a similar movie for the hot spot image. Call *      this movie the &quot;hot spot tile movie&quot;. *    (2) Create a new, empty movie. Call this movie the &quot;QTVR movie&quot;. *    (3)  Create a scene track by copying the video track from the tile movie to the QTVR movie. *    (4)  Create a hot spot image track by copying the video track from the hot spot tile movie to the QTVR movie. *    (5) Create a panorama track and add it to the movie. *    (6)  Add a user data item that identifies the QTVR movie controller. *    (7) Flatten the QTVR movie into the final panoramic movie. * ******************************************************************************** * *  CUBIC PANORAMA FILE FORMAT * *  QuickTime VR version 5.0 introduces &quot;cubic panoramas&quot;, which store the panoramic image as 6 (or more) separate images that *  are (during playback) projected onto the sides of a cube (polyhedron). This allows the user to look straight up and straight *  down. The file format for cubic panoramas is identical with the Version 2.0 cylindrical file format, with these *  exceptions: * *  The image track (and any associated hot spot and preview tracks) must contain 6 samples/frames/faces *  (these can be subtiled, though tile based memory management may not be available initially). The first *  sample is the front cube face, the second is the right-hand cube face, and so on; sample 5 is the top of the cube *  and sample 6 is the bottom of the cube. You can change this default orientation with the 'cufa' descriptor. *  The frames are oriented horizontally (except for the top and bottom), not rotated as with cylindrical panoramas. * *  For cubic panoramas, some of the fields in the panorama sample atom should be assigned special values that allow *  the file to be displayed with the cylindrical engine if the cubic engine is not available. The cubic engine ignores *  those values, instead using values stored in the new &quot;cubic view atom&quot;. See the function CreatePanoTrack for *  the special values you should use. * * *  NOTES: * *  *** (1) *** *  This code is based largely on the existing MakeQTVRPanorama sample code written by Ed Harp (and others?). *  MakeQTVRPanorama is a full-featured application written in C++ using Metrowerks' PowerPlant, a Mac-only *  application framework. Here I've uncoupled the central portion of that code, contained in the file CMovieMaker.cp, *  and converted it into straight C. I have taken the liberty of reworking that code as necessary to make it run *  also on Windows platforms and to bring it into line with the other QuickTime code samples. So far the biggest *  changes involve using graphics importers instead of the original PICT-reading code and inserting all those *  Endian macros. * *  *** (2) *** *  All data in QTAtom structures must be in big-endian format. We use macros like EndianU32_NtoB to convert *  values into the proper format before inserting them into atoms. See CreateVRWorld for some examples. * ********************************************************************************//******************************************************************************** ******************************************************************************** ******************************************************************************** ***    compiler flags ******************************************************************************** ******************************************************************************** ********************************************************************************//* The following flag determines whether we show the uncompressed tiles in a window as they get processed; * I did this mainly for debugging purposes, but it's also a useful progress indicator.... */#define USE_TILE_DISPLAY_WINDOW      1#define USE_TEMP_MEM_FIRST/******************************************************************************** ******************************************************************************** ******************************************************************************** ***    header files ******************************************************************************** ******************************************************************************** ********************************************************************************/#include &lt;Endian.h&gt;#include &lt;QuickTimeVR.h&gt;#include &lt;QuickTimeVRFormat.h&gt;#include &lt;QuickTimeComponents.h&gt;#include &lt;FixMath.h&gt;#include &lt;Script.h&gt;#include &lt;Sound.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#if TARGET_OS_MAC#include &lt;fp.h&gt;#else#include &lt;math.h&gt;#endif#include &quot;MakePano.h&quot;#pragma mark #Constants/******************************************************************************** ******************************************************************************** ******************************************************************************** ***    Constants ******************************************************************************** ******************************************************************************** ********************************************************************************/enum {  QTVRFlattenerType = FOUR_CHAR_CODE('vrwe')  /* An oversight prevented this from going into QuickTimeVRFormat.h */};#define D_PI              3.1415926535898#define D_2PI              6.2831853071796#define D_PI_2              1.5707963267949#define D_DEGREES_PER_RADIAN      57.295779513082#define D_RADIANS_PER_DEGREE      0.017453292519943#define kQTVRStandardTimeScale      3600            /* time scale for QTVR panoramas */#define kDefaultNodeID          1              /* default node ID */#define kQTVRCylindricalVersion1    (long)1#define kQTVRCylindricalVersion2v    (long)2#define kQTVRCylindricalVersion2h    (long)3#define kQTVRCubicVersion1        (long)4#define kPanDescType          FOUR_CHAR_CODE('pano')#define kPanHeaderType          FOUR_CHAR_CODE('pHdr')#define kStringTableType        FOUR_CHAR_CODE('strT')#define kHotSpotTableType        FOUR_CHAR_CODE('pHot')#define kQTVRPanoTypeCube        FOUR_CHAR_CODE('cube')#define kQTVRCubicViewAtomType      FOUR_CHAR_CODE('cuvw')#define kQTVRCubicFaceDataAtomType    FOUR_CHAR_CODE('cufa')#define kCreateMovieFlags        (createMovieFileDeleteCurFile | createMovieFileDontCreateResFile)#pragma mark #Data Structures/******************************************************************************** ******************************************************************************** ******************************************************************************** ***    Data Structures ******************************************************************************** ******************************************************************************** ********************************************************************************//* version 1.0 data types */#pragma options align=mac68k/* panorama description: * this defines the structure of a sample description for a media sample in a panorama track */typedef struct PanoramaDescription {  long      size;            /* total size of PanoramaDescription */  long      type;            /* must be 'pano' */  long      reserved1;          /* must be zero */  long      reserved2;          /* must be zero */  short      majorVersion;        /* must be zero */  short      minorVersion;        /* must be zero */  long      sceneTrackID;        /* ID of video track that contains panoramic scene */  long      loResSceneTrackID;      /* ID of video track that contains lo res panoramic scene */  long      reserved3[6];        /* must be zero */  long      hotSpotTrackID;        /* ID of video track that contains hotspot image */  long      loResHotSpotTrackID;    /* ID of video track that contains lo res hotspot image */  long      reserved4[8];        /* must be zero */  Fixed      hPanStart;          /* horizontal pan range start angle (eg. 0) */  Fixed      hPanEnd;          /* horizontal pan range end angle (eg. 360) */  Fixed      vPanTop;          /* vertical pan range top angle(eg. 42.5) */  Fixed      vPanBottom;          /* vertical pan range bottom angle (eg. -42.5) */  Fixed      minimumZoom;        /* minimum zoom angle (eg. 5; use 0 for default)) */  Fixed      maximumZoom;        /* maximum zoom angle (eg. 65; use 0 for default) */  /* info for highest res version of scene track */  long      sceneSizeX;          /* pixel width of the panorama (eg. 768) */  long      sceneSizeY;          /* pixel height of the panorama (eg. 2496) */  long      numFrames;          /* number of diced frames (eg. 24) */  short      reserved5;          /* must be zero */  short      sceneNumFramesX;      /* diced frames wide (eg. 1) */  short      sceneNumFramesY;      /* diced frames high (eg. 24) */  short      sceneColorDepth;      /* bit depth of the scene track (eg. 32) */  /* info for highest res version of hotSpot track */  long      hotSpotSizeX;        /* pixel width of the hot spot panorama (eg. 768) */  long      hotSpotSizeY;        /* pixel height of the hot spot panorama (eg. 2496) */  short      reserved6;          /* must be zero */  short      hotSpotNumFramesX;      /* diced frames wide (eg. 1) */  short      hotSpotNumFramesY;      /* diced frames high (eg. 24) */  short      hotSpotColorDepth;      /* must be 8 */  } PanoramaDescription, *PanoramaDescriptionPtr, **PanoramaDescriptionHandle;/* panorama sample header atom: * this defines the structure of (part of) a media sample in a panorama track */typedef struct PanoSampleHeaderAtom {  long      size;  OSType      type;              /* must be 'pHdr' */  unsigned long  nodeID;            /* corresponds to a node ID in the idToTime table  */  Fixed      defHPan;          /* default horizontal pan angle when displaying this node */  Fixed      defVPan;          /* default vertical pan angle when displaying this node */  Fixed      defZoom;          /* default zoom angle when displaying this node */  Fixed      minHPan;          /* constraints for this node; use zero for default */  Fixed      minVPan;  Fixed      minZoom;  Fixed      maxHPan;  Fixed      maxVPan;  Fixed      maxZoom;  long      reserved1;          /* must be zero */  long      reserved2;          /* must be zero */  long      nameStrOffset;        /* offset into string table atom */  long      commentStrOffset;      /* offset into string table atom */} PanoSampleHeaderAtom, *PanoSampleHeaderAtomPtr, **PanoSampleHeaderAtomHandle;/* hot spot atom */typedef struct HotSpot {  unsigned short  hotSpotID;          /* the ID of this hot spot */  short      reserved1;          /* must be zero */  OSType      type;            /* the hot spot type (e.g. 'link',  'navg', etc) */  unsigned long  typeData;          /* for link and navg, the ID in the link  and navg table */  Fixed      viewHPan;          /* canonical view for this hot spot */  Fixed      viewVPan;  Fixed      viewZoom;  Rect      hotSpotRect;        /* bounding rectangle of the hot spot in  the panorama */  long      mouseOverCursorID;  long      mouseDownCursorID;  long      mouseUpCursorID;  long      reserved2;          /* must be 0 */  long      nameStrOffset;        /* offset into string table atom */  long      commentStrOffset;      /* offset into string table atom */} HotSpot, *HotSpotPtr, **HotSpotHandle;/* hot spot table atom */typedef struct HotSpotTableAtom {  long      size;  OSType      type;              /* must be 'pHot' */  short      pad;            /* must be 0 */  short      numHotSpots;  HotSpot      hotSpots[1];        /* list of hot spots */} HotSpotTableAtom, *HotSpotTableAtomPtr, **HotSpotTableAtomHandle;typedef struct StringTableAtom {  long      size;  OSType      type;            /* must be 'strT' */  char      bunchOstrings[1];      /* concatenated Pascal strings */} StringTableAtom, *StringTableAtomPtr, **StringTableAtomHandle;#pragma options align=resettypedef struct MyPanoTrackDescriptor {  long  versionToCreate;  long  imageTileWidth;  long  imageTileHeight;  long  imageRefTrackIndex;    long  hotSpotTileWidth;  long  hotSpotTileHeight;  long  hotSpotRefTrackIndex;    long  fastStartTileWidth;  long  fastStartTileHeight;  long  fastStartRefTrackIndex;} MyPanoTrackDescriptor;typedef struct FaceOrientation {  float x, y, z, theta;  } FaceOrientation;#pragma mark #Global Variables/******************************************************************************** ******************************************************************************** ******************************************************************************** ***    Global Variables ******************************************************************************** ******************************************************************************** ********************************************************************************/static FaceOrientation faceOrientation[6] = {/*  X    Y    Z    theta  */  0.0f,  1.0f,  0.0f,     0.0f,  /* Front (no rotation) */  0.0f,  1.0f,  0.0f,   -90.0f,  /* Right (rotate 90 degrees rightward about positive Y axis) */  0.0f,  1.0f,  0.0f,  -180.0f,  /* Back (rotate 180 degrees rightward about positive Y axis) */  0.0f,  1.0f,  0.0f,  -270.0f,  /* Left (rotate 90 degrees rightward about negative Y axis) */  1.0f,  0.0f,  0.0f,    90.0f,  /* Top (rotate 90 degrees upward about positive X axis) */  1.0f,  0.0f,  0.0f,   -90.0f    /* Bottom (rotate 90 degrees downward about positive X axis) */};/******************************************************************************** ******************************************************************************** ******************************************************************************** ***    Support Functions ******************************************************************************** ******************************************************************************** ********************************************************************************//******************************************************************************** * MyNewHandle ********************************************************************************/static HandleMyNewHandle(Size size){  OSErr err;  Handle h;    #ifdef USE_TEMP_MEM_FIRST    h = TempNewHandle(size, &amp;err);    if (err != noErr)      h = NewHandle(size);  #else /* USE_HEAP_MEM_FIRST */    h = NewHandle(size);    if (h == NULL)      h = TempNewHandle(size, &amp;err);  #endif /* USE_HEAP_MEM_FIRST */  return(h);}/******************************************************************************** * MyNewHandleClear ********************************************************************************/static HandleMyNewHandleClear(Size size){  OSErr err;  Handle h;    #ifdef USE_TEMP_MEM_FIRST    h = TempNewHandle(size, &amp;err);    if (err == noErr)      BlockZero(*h, size);    else      h = NewHandleClear(size);  #else /* USE_HEAP_MEM_FIRST */    h = NewHandleClear(size);    if (h == NULL) {      h = TempNewHandle(size, &amp;err);      if (err == noErr)        BlockZero(*h, size);    }  #endif /* USE_HEAP_MEM_FIRST */  return(h);}/******************************************************************************* * MakeTempFSSpec * *  Tack the given tmpSuffix onto the origSpec, resulting in the tmpSpec. *******************************************************************************/static voidMakeTempFSSpec(const FSSpec *origSpec, const char *tmpSuffix, FSSpec *tmpSpec){  long  sufSize, namSize;  char  *t;    *tmpSpec = *origSpec;  namSize  = tmpSpec-&gt;name[0];  sufSize  = strlen(tmpSuffix);  if (namSize &gt; (sizeof(StrFileName) - 1 - sufSize))    namSize = (sizeof(StrFileName) - 1 - sufSize);  tmpSpec-&gt;name[0] = namSize + sufSize;  t = (char*)(&amp;tmpSpec-&gt;name[namSize+1]);  while (sufSize--)    *t++ = *tmpSuffix++;}/******************************************************************************* * ClearFSSpec *******************************************************************************/static voidClearFSSpec(FSSpec *fsSpec){  fsSpec-&gt;vRefNum  = 0;  fsSpec-&gt;parID  = 0;  fsSpec-&gt;name[0]  = 0;}/******************************************************************************** * ConvertFloatToBigEndian * EndianF32_NtoB * *  Convert the specified floating-point number to big-endian format. ********************************************************************************/#if TARGET_RT_BIG_ENDIAN# define EndianF32_NtoB(f)      ((float)(f))#else /* TARGET_RT_LITTLE_ENDIAN */static floatEndianF32_NtoB(float f){  unsigned long fl;    *((float*)(&amp;fl)) = f;  fl = EndianU32_NtoB(fl);  f = *((float*)(&amp;fl));  return(f);}#endif /* TARGET_RT_LITTLE_ENDIAN *//******************************************************************************* * EndianF32NtoFixedB *******************************************************************************/static FixedEndianF32NtoFixedB(float f){  Fixed x;    x = roundtol(f * 65536.0);  x = EndianU32_NtoB(x);  return(x);}/******************************************************************************** * FocalLengthToFOV *    t = 2 atan((h-1)/(2f)) ********************************************************************************/static floatFocalLengthToFOV(float focalLength, long height){  return(2.0F * atan((height - 1) * 0.5F / focalLength));}/******************************************************************************** * PixelZoomToFOV ********************************************************************************/static floatPixelZoomToFOV(float srcFocalLength, long windowHeight, float pixelZoom){  return(FocalLengthToFOV(srcFocalLength * pixelZoom, windowHeight));}#pragma mark -/******************************************************************************* * AddCStringToAtomContainer *    Add a C string to the specified atom container; *    return (through theID) the ID of the new string atom. *******************************************************************************/static OSErrAddCStringToAtomContainer(QTAtomContainer theContainer, QTAtom theParent, const char *theString, QTAtomID *theID){  OSErr        err      = noErr;  QTAtom        myStringAtom;  UInt16        mySize;  QTVRStringAtomPtr  myStringAtomPtr;  unsigned short    stringLength;  *theID = 0;        /* initialize the returned atom ID */    if ((theContainer == NULL) || (theParent == 0))    return(paramErr);        stringLength = strlen(theString);  mySize = sizeof(QTVRStringAtom) - 4 + stringLength;  myStringAtomPtr = (QTVRStringAtomPtr)NewPtr(mySize);    if (myStringAtomPtr != NULL) {    myStringAtomPtr-&gt;stringUsage  = EndianU16_NtoB(1);    myStringAtomPtr-&gt;stringLength  = EndianU16_NtoB(stringLength);    BlockMoveData(theString, myStringAtomPtr-&gt;theString, stringLength);    err = QTInsertChild(theContainer, theParent, kQTVRStringAtomType, 0, 0, mySize, (Ptr)myStringAtomPtr, &amp;myStringAtom);    DisposePtr((Ptr)myStringAtomPtr);        if (err == noErr)      QTGetAtomTypeAndID(theContainer, myStringAtom, NULL, theID);  }    return(err);}/******************************************************************************* * SetQTControllerType * *  Set the controller type of the specified movie. * * This function adds an item to the movie's user data; * the updated user data is written to the movie file when the movie is next updated * (by calling AddMovieResource or UpdateMovieResource). * *******************************************************************************/static OSErrSetQTControllerType(Movie theMovie, OSType theType){  UserData  myUserData;  OSErr    err    = noErr;  /* make sure we've got a movie */  if (theMovie == NULL)    return(paramErr);      /* get the movie's user data list */  myUserData = GetMovieUserData(theMovie);  if (myUserData == NULL)    return(paramErr);    theType  = EndianU32_NtoB(theType);  err  = SetUserDataItem(myUserData, &amp;theType, sizeof(theType), kQTControllerType, 0);  return(err);}/******************************************************************************* * MakeQTVRHotSpot1x0 * *  Create a hot spot table atom with atoms for a single hot spot; also, if necessary, *  resize the string table handle theStringTable to contain a name and comment for the *  hot spot. * *  NOTE: This function builds hot spots that conform to version 1.0 of the QuickTime VR file format. *******************************************************************************/static HotSpotTableAtomHandleMakeQTVRHotSpot1x0(StringTableAtomHandle theStringTable){#pragma unused(theStringTable)  HotSpotTableAtomHandle  myHandle = NULL;    /* [left as an exercise for the reader] */    return(myHandle);}/******************************************************************************* * MakeQTVRHotSpot2x0 * *  Create the necessary atoms inside of theNodeInfo to configure the specified hot spot *  as a URL hot spot linked to the specified URL. * *  NOTE: This function builds hot spots that conform to version 2.0 of the QuickTime VR file format. *******************************************************************************/static OSErrMakeQTVRHotSpot2x0(  QTAtomContainer  theNodeInfo,  QTAtom      theHSParent,  char      *theURL,  char      *theHSName,  UInt32      theIndex){    QTAtom          myHSAtom;    QTVRHotSpotInfoAtom     myHSInfoAtom;    QTAtomID          myHSNameID;    OSErr          err    = noErr;  /*   * add a hot spot atom to the specified node info atom   *   * a hot spot atom contains two children:   * a hot spot information atom, which contains general info about the hot spot,   * and (for URL hot spots) a URL hot spot atom   */    /* the atom ID should be the same as the hot spot ID, which is an index in a 8-bit color table   */  err = QTInsertChild(theNodeInfo, theHSParent, kQTVRHotSpotAtomType, theIndex, 0, 0, NULL, &amp;myHSAtom);  if (err != noErr)    goto bail;    /*   * add a hot spot information atom   */    /* fill in the fields of the hot spot information atom data structure */  myHSInfoAtom.majorVersion  = EndianU16_NtoB(kQTVRMajorVersion);  myHSInfoAtom.minorVersion  = EndianU16_NtoB(kQTVRMinorVersion);  myHSInfoAtom.hotSpotType  = EndianU32_NtoB(kQTVRHotSpotURLType);  /* the published documentation says that the hot spot name is contained in a string atom   * that is a sibling of the hot spot atom (that is, a child of the hot spot parent atom);   * some other documents indicate that a string atom is always a sibling of the atom that   * contains the reference (in this case, a sibling of the hot spot information atom, and   * hence a child of the hot spot atom); I'd recommend coding to the latter....   */    /* add the hot spot name atom */  err = AddCStringToAtomContainer(theNodeInfo, myHSAtom, theHSName, &amp;myHSNameID);  if (err != noErr)    goto bail;    myHSInfoAtom.nameAtomID = EndianU32_NtoB(myHSNameID);    /* add the hot spot comment atom; 0 means that no comment atom exists */    myHSInfoAtom.commentAtomID = EndianU32_NtoB(0L);        /* set the custom cursor IDs; 0 means that no custom cursors exist */    myHSInfoAtom.cursorID[0] = 0;    myHSInfoAtom.cursorID[1] = 0;    myHSInfoAtom.cursorID[2] = 0;    /* set viewing hints */  myHSInfoAtom.bestPan  = EndianF32_NtoB(0.0);  myHSInfoAtom.bestTilt  = EndianF32_NtoB(0.0);  myHSInfoAtom.bestFOV  = EndianF32_NtoB(0.0);        myHSInfoAtom.bestViewCenter.x = 0.0;    myHSInfoAtom.bestViewCenter.y = 0.0;  /* set hot spot bounding rectangle; apparently unused */  myHSInfoAtom.hotSpotRect.top  = 0;  myHSInfoAtom.hotSpotRect.left  = 0;  myHSInfoAtom.hotSpotRect.bottom  = 0;  myHSInfoAtom.hotSpotRect.right  = 0;  myHSInfoAtom.flags    = 0L;  myHSInfoAtom.reserved1  = 0L;  myHSInfoAtom.reserved2  = 0L;    /* insert the hot spot information atom into the hot spot atom */  err = QTInsertChild(theNodeInfo, myHSAtom, kQTVRHotSpotInfoAtomType, 1, 0, sizeof(myHSInfoAtom), &amp;myHSInfoAtom, NULL);  if (err != noErr)    goto bail;      /*   * add a URL hot spot atom as a child of the hot spot atom   */    /* the atom data is the URL text   * (not a Pascal or C string, but just the characters themselves)   */  err = QTInsertChild(theNodeInfo, myHSAtom, kQTVRHotSpotURLType, 1, 0, strlen(theURL), theURL, NULL);bail:    return(err);}/******************************************************************************* * CountTrackSamples *******************************************************************************/static longCountTrackSamples(Track track){  long    numSamples;  TimeValue  currentTime, interestingTime;  OSErr    err;  err = GetMoviesStickyError();  interestingTime = 1;  currentTime = 0;  numSamples = -1; /* will iterate one more time than there is slices */  while (interestingTime != currentTime) {    currentTime = interestingTime;    ++numSamples;    GetTrackNextInterestingTime(track, nextTimeMediaSample, currentTime, 1, &amp;interestingTime, NULL);  }    if (err == noErr)    ClearMoviesStickyError();  /* Because the last GetTrackNextInterestingTime() goes beyond the end */  return(numSamples);}/******************************************************************************* * ImportFirstVideoTrackFromMovie * *  Copy a video track from one movie (the source) to another (the destination). * *  We assume that we want the first video track in theSrcMovie. *******************************************************************************/static OSErrImportFirstVideoTrackFromMovie(  Movie    srcMovie,        /* Transfer the first video track of this movie... */  Movie    dstMovie,        /* to this movie. */  TimeValue  dstSequenceDuration,  /* duration of the whole sequence */  long    numSamples,        /* the number of samples, or zero if the whole track is desired */  long    *pDstTrackWidth,    /* returned track width,  in integral units */  long    *pDstTrackHeight,    /* returned track height, in integral units */  Track    *pDstTrack        /* the track added to the dstMovie */){  Track            srcTrack    = NULL;  Media            srcMedia    = NULL;  Track            dstTrack    = NULL;  Media            dstMedia    = NULL;  Fixed            trackWidth, trackHeight;  OSType            mediaType;  SampleDescriptionHandle    sampleDesc    = (SampleDescriptionHandle)MyNewHandle(0);  Handle            sampleData    = MyNewHandle(0);  long            sampleDataSize;  TimeValue          srcMediaTime  = 0;  TimeValue          srcSampleDuration, dstSampleDuration;    ClearMoviesStickyError();    /* get the first video track in the source movie */  srcTrack = GetMovieIndTrackType(srcMovie, 1, VideoMediaType, movieTrackMediaType);  if (srcTrack == NULL)    return(paramErr);    /* get the track's media and dimensions */  srcMedia = GetTrackMedia(srcTrack);  GetTrackDimensions(srcTrack, &amp;trackWidth, &amp;trackHeight);    /* create a destination track */  dstTrack = NewMovieTrack(dstMovie, trackWidth, trackHeight, GetTrackVolume(srcTrack));  if (pDstTrackWidth  != NULL)    *pDstTrackWidth  = trackWidth  &gt;&gt; 16;  if (pDstTrackHeight != NULL)    *pDstTrackHeight = trackHeight &gt;&gt; 16;  if (pDstTrack       != NULL)    *pDstTrack       = dstTrack;  /* create a destination media */  GetMediaHandlerDescription(srcMedia, &amp;mediaType, NULL, NULL);  dstMedia = NewTrackMedia(dstTrack, mediaType, kQTVRStandardTimeScale, 0, 0);    /* determine the number of samples */  if (numSamples == 0)    numSamples = CountTrackSamples(srcTrack);  dstSampleDuration = dstSequenceDuration / numSamples;    /* extract samples one at a time */  BeginMediaEdits(dstMedia);  while (numSamples--) {    GetMediaSample(srcMedia, sampleData, 0, &amp;sampleDataSize, srcMediaTime, NULL, &amp;srcSampleDuration, sampleDesc, NULL, 1, NULL, NULL);    srcMediaTime += srcSampleDuration;    AddMediaSample(dstMedia, sampleData, 0, sampleDataSize, dstSampleDuration, sampleDesc, 1, 0, NULL);  }  EndMediaEdits(dstMedia);    InsertMediaIntoTrack(dstTrack, 0, 0, GetMediaDuration(dstMedia), 1L &lt;&lt; 16);  DisposeHandle((Handle)sampleDesc);  DisposeHandle(sampleData);  /* a panorama image track should always be disabled */  SetTrackEnabled(dstTrack, false);  return(GetMoviesStickyError());}/******************************************************************************* * ImportFirstVideoTrackFromFile *******************************************************************************/static OSErrImportFirstVideoTrackFromFile(  const FSSpec  *srcMovieSpec,      /* Transfer the first video track from this movie... */  Movie      dstMovie,        /* ... to this movie */  TimeValue    dstSequenceDuration,  /* Desired time duration of the sequence */  long      numSamples,        /* The number of samples, or zero if the whole track is desired */  long      *pDstFrameWidth,    /* Return the width  of the track frame */  long      *pDstFrameHeight,    /* Return the height of the track frame */  Track      *pDstTrack        /* Return the new track */){  Movie  srcMovie  = NULL;  short  srcRefNum  = 0;  short  srcResID  = 0;  OSErr  err;  err = OpenMovieFile(srcMovieSpec, &amp;srcRefNum, fsRdPerm);  if (err != noErr)    goto bail;    err = NewMovieFromFile(&amp;srcMovie, srcRefNum, &amp;srcResID, 0, 0, 0);  if (err != noErr)    goto bail;  SetMoviePlayHints(srcMovie, hintsHighQuality, hintsHighQuality);    err = ImportFirstVideoTrackFromMovie(srcMovie, dstMovie, dstSequenceDuration, numSamples,                    pDstFrameWidth, pDstFrameHeight, pDstTrack                  );bail:  if (srcMovie  != NULL)  DisposeMovie(srcMovie);  if (srcRefNum != 0)    CloseMovieFile(srcRefNum);    return(err);}/******************************************************************************* * VerifyPanoParameters *******************************************************************************/static voidVerifyPanoParameters(register MakeQTVRParams *qtvrParams, const MyPanoTrackDescriptor *panoDesc){  float circumference, axialHeight, focalLengthCircumferential, focalLengthAxial, maxFOV;  if (qtvrParams-&gt;trackDuration &lt;= 0)    qtvrParams-&gt;trackDuration      = 7200;  /* Set default pan range, if not set appropriately */  if (qtvrParams-&gt;maxPan == qtvrParams-&gt;minPan) {    qtvrParams-&gt;minPan          =   0.0f;  /* Default: 360 degree wrapping pano */    qtvrParams-&gt;maxPan          = 360.0f;    qtvrParams-&gt;wraps          = 1;  }  if ((panoDesc-&gt;versionToCreate == kQTVRCylindricalVersion2v) || (panoDesc-&gt;versionToCreate == kQTVRCylindricalVersion2h)) {  /* we're building a version 2.0 cylindrical panorama */    /* Check for valid parameters, and assign defaults. */    if (panoDesc-&gt;versionToCreate == kQTVRCylindricalVersion2h) {  /* non-rotated pano */      circumference          = panoDesc-&gt;imageTileWidth  * qtvrParams-&gt;tilesH; if (!qtvrParams-&gt;wraps) circumference--;      axialHeight            = panoDesc-&gt;imageTileHeight * qtvrParams-&gt;tilesV;    }    else {                        /* rotated pano */      circumference          = panoDesc-&gt;imageTileHeight * qtvrParams-&gt;tilesV; if (!qtvrParams-&gt;wraps) circumference--;      axialHeight            = panoDesc-&gt;imageTileWidth  * qtvrParams-&gt;tilesH;    }    focalLengthCircumferential      = circumference / (qtvrParams-&gt;maxPan - qtvrParams-&gt;minPan) * D_DEGREES_PER_RADIAN;    if (qtvrParams-&gt;maxTilt == qtvrParams-&gt;minTilt) {      focalLengthAxial        = focalLengthCircumferential;        /* Default: square pixels */      qtvrParams-&gt;maxTilt        = atan((axialHeight - 1) / (2.0f * focalLengthAxial)) * D_DEGREES_PER_RADIAN;      qtvrParams-&gt;minTilt        = -qtvrParams-&gt;maxTilt;    }    else {      focalLengthAxial        = (axialHeight - 1) / (tan(qtvrParams-&gt;maxTilt * D_RADIANS_PER_DEGREE) - tan(qtvrParams-&gt;minTilt * D_RADIANS_PER_DEGREE));    }    maxFOV = qtvrParams-&gt;maxTilt - qtvrParams-&gt;minTilt;    if ((qtvrParams-&gt;maxFieldOfView    &lt;= 0.0f) || (qtvrParams-&gt;maxFieldOfView &gt; maxFOV))      qtvrParams-&gt;maxFieldOfView    = maxFOV;    if (qtvrParams-&gt;minFieldOfView    &lt;= 0.0f)                      /* Set minimum to 2:1 pixel zoom */      qtvrParams-&gt;minFieldOfView    = PixelZoomToFOV(focalLengthAxial, qtvrParams-&gt;windowHeight, 2.0f) * D_DEGREES_PER_RADIAN;    if (qtvrParams-&gt;minFieldOfView    &gt; qtvrParams-&gt;maxFieldOfView)      qtvrParams-&gt;minFieldOfView    = qtvrParams-&gt;maxFieldOfView;    if (qtvrParams-&gt;defaultFieldOfView  == 0.0f)                    /* Set default to 1:1 pixel zoom */      qtvrParams-&gt;defaultFieldOfView  = PixelZoomToFOV(focalLengthAxial, qtvrParams-&gt;windowHeight, 1.0f) * D_DEGREES_PER_RADIAN;    if (qtvrParams-&gt;defaultFieldOfView  &gt; qtvrParams-&gt;maxFieldOfView)      qtvrParams-&gt;defaultFieldOfView  = qtvrParams-&gt;maxFieldOfView;    if (qtvrParams-&gt;defaultFieldOfView  &lt; qtvrParams-&gt;minFieldOfView)      qtvrParams-&gt;defaultFieldOfView  = qtvrParams-&gt;minFieldOfView;  }  else {  /* We're building a cubic panorama */      /* Check for valid parameters, and set to default if not */    if (qtvrParams-&gt;maxTilt == qtvrParams-&gt;minTilt) {    /* Default: peg at the poles */      qtvrParams-&gt;minTilt        = -90.0f;      qtvrParams-&gt;maxTilt        =  90.0f;    }    focalLengthAxial          = (panoDesc-&gt;imageTileHeight * qtvrParams-&gt;tilesV - 1) * 0.5f;  /* These are questionable for partial cubic panos */    maxFOV = qtvrParams-&gt;maxTilt - qtvrParams-&gt;minTilt;    if (maxFOV &gt; 170.1f)              /* 170.1 degrees (= 3 radians) limited by numerical precision in the computations */      maxFOV = 170.1f;    if (qtvrParams-&gt;maxFieldOfView &lt;= 0.0f) {      qtvrParams-&gt;maxFieldOfView      = maxFOV;      if (qtvrParams-&gt;maxFieldOfView &gt; 120.0)        qtvrParams-&gt;maxFieldOfView    = 120.0f;  /* 120 degrees is the default maximum FOV */    }    else if (qtvrParams-&gt;maxFieldOfView &gt; maxFOV)      qtvrParams-&gt;maxFieldOfView      = maxFOV;    if (qtvrParams-&gt;minFieldOfView &lt;= 0.0f)                    /* Set minimum to 2:1 pixel zoom */      qtvrParams-&gt;minFieldOfView      = PixelZoomToFOV(focalLengthAxial, qtvrParams-&gt;windowHeight, 2.0f) * D_DEGREES_PER_RADIAN;    if (qtvrParams-&gt;minFieldOfView &gt; qtvrParams-&gt;maxFieldOfView)      qtvrParams-&gt;minFieldOfView      = qtvrParams-&gt;maxFieldOfView;    if (qtvrParams-&gt;defaultFieldOfView &lt;= 0.0f)                  /* Set default to 1:1 pixel zoom */      qtvrParams-&gt;defaultFieldOfView    = PixelZoomToFOV(focalLengthAxial, qtvrParams-&gt;windowHeight, 1.0f) * D_DEGREES_PER_RADIAN;    if (qtvrParams-&gt;defaultFieldOfView &gt; qtvrParams-&gt;maxFieldOfView)      qtvrParams-&gt;defaultFieldOfView    = qtvrParams-&gt;maxFieldOfView;    if (qtvrParams-&gt;defaultFieldOfView &lt; qtvrParams-&gt;minFieldOfView)      qtvrParams-&gt;defaultFieldOfView    = qtvrParams-&gt;minFieldOfView;  }}/******************************************************************************* * SetCubicViewData *******************************************************************************/static voidSetCubicViewData(const MakeQTVRParams *qtvrParams, QTVRCubicViewAtom *cubicViewData){  cubicViewData-&gt;minPan        = EndianF32_NtoB(qtvrParams-&gt;minPan);  cubicViewData-&gt;maxPan        = EndianF32_NtoB(qtvrParams-&gt;maxPan);  cubicViewData-&gt;minTilt        = EndianF32_NtoB(qtvrParams-&gt;minTilt);  cubicViewData-&gt;maxTilt        = EndianF32_NtoB(qtvrParams-&gt;maxTilt);  cubicViewData-&gt;minFieldOfView    = EndianF32_NtoB(qtvrParams-&gt;minFieldOfView);  cubicViewData-&gt;maxFieldOfView    = EndianF32_NtoB(qtvrParams-&gt;maxFieldOfView);  cubicViewData-&gt;defaultPan      = EndianF32_NtoB(qtvrParams-&gt;defaultPan);  cubicViewData-&gt;defaultTilt      = EndianF32_NtoB(qtvrParams-&gt;defaultTilt);  cubicViewData-&gt;defaultFieldOfView  = EndianF32_NtoB(qtvrParams-&gt;defaultFieldOfView);}/******************************************************************************** * SetOneCubicFaceData * *  This assumes that the faces are equal subtiles of 6 cube faces. ********************************************************************************/static voidSetOneCubicFaceData(  QTVRCubicFaceData  *face,  float        x,      /* axis of rotation */  float        y,  float        z,    float        degrees,  /* rotation about axis */  long        tilesH,    /* the number of subdivisions to each face */  long        tilesV,  long        h,      /* The horizontal index of this sub-face */  long        v      /* The vertical   index of this sub-face */){  double halfAngle, norm, sqrtCotVFOV, s, c;    sqrtCotVFOV = sqrt((double)tilesV);  halfAngle = degrees * D_PI / 360.0;  norm = x*x + y*y + z*z;  if (norm != 0.0)    norm = 1.0 / sqrt(norm);  if (fabs(s = sin(halfAngle)) &lt; 1.0e-8)  s = 0.0;  /* Toss out numerically insignificant values ... */  if (fabs(c = cos(halfAngle)) &lt; 1.0e-8)  c = 0.0;  /* ... so the file format looks nice */  norm *= s * sqrtCotVFOV;  face-&gt;orientation[0]  = EndianF32_NtoB(c * sqrtCotVFOV);  face-&gt;orientation[1]  = EndianF32_NtoB(x * norm);  face-&gt;orientation[2]  = EndianF32_NtoB(y * norm);  face-&gt;orientation[3]  = EndianF32_NtoB(z * norm);    /* Center, normalized by the vertical dimension */  face-&gt;center[0]      = EndianF32_NtoB((2 * h - tilesH + 1) * (float)tilesV / (float)tilesH);  face-&gt;center[1]      = EndianF32_NtoB( 2 * v - tilesV + 1);  face-&gt;aspect      = EndianF32_NtoB(1.0f);  face-&gt;skew        = EndianF32_NtoB(0.0f);}/******************************************************************************* * SetCubicFaceData *******************************************************************************/static voidSetCubicFaceData(const MakeQTVRParams *qtvrParams, QTVRCubicFaceData* faceData){  long      i, j, k;  FaceOrientation *fo;    for (k = 0, fo = faceOrientation; k &lt; 6; k++, fo++)    for (j = 0; j &lt; qtvrParams-&gt;tilesV; j++)      for (i = 0; i &lt; qtvrParams-&gt;tilesH; i++, faceData++)        SetOneCubicFaceData(faceData, fo-&gt;x, fo-&gt;y, fo-&gt;z, fo-&gt;theta, qtvrParams-&gt;tilesH, qtvrParams-&gt;tilesV, i, j);}/******************************************************************************* * SetPanoSampleData *******************************************************************************/static voidSetPanoSampleData(  const MakeQTVRParams    *qtvrParams,  const MyPanoTrackDescriptor  *panoDescriptor,  QTVRPanoSampleAtom      *panoSampleData){  panoSampleData-&gt;majorVersion      = EndianU16_NtoB(kQTVRMajorVersion);  panoSampleData-&gt;minorVersion      = EndianU16_NtoB(kQTVRMinorVersion);  panoSampleData-&gt;imageRefTrackIndex    = EndianU32_NtoB(panoDescriptor-&gt;imageRefTrackIndex);  panoSampleData-&gt;hotSpotRefTrackIndex  = EndianU32_NtoB(panoDescriptor-&gt;hotSpotRefTrackIndex);  if ((panoDescriptor-&gt;versionToCreate == kQTVRCylindricalVersion2v) || (panoDescriptor-&gt;versionToCreate == kQTVRCylindricalVersion2h)) {  /* we're building a version 2.0 cylindrical panorama */    /* Set cylindrical parameters in Pano Sample Atom */    panoSampleData-&gt;minPan        = EndianF32_NtoB(qtvrParams-&gt;minPan);    panoSampleData-&gt;maxPan        = EndianF32_NtoB(qtvrParams-&gt;maxPan);    panoSampleData-&gt;minTilt        = EndianF32_NtoB(qtvrParams-&gt;minTilt);    panoSampleData-&gt;maxTilt        = EndianF32_NtoB(qtvrParams-&gt;maxTilt);    panoSampleData-&gt;minFieldOfView    = EndianF32_NtoB(qtvrParams-&gt;minFieldOfView);    panoSampleData-&gt;maxFieldOfView    = EndianF32_NtoB(qtvrParams-&gt;maxFieldOfView);    panoSampleData-&gt;defaultPan      = EndianF32_NtoB(qtvrParams-&gt;defaultPan);    panoSampleData-&gt;defaultTilt      = EndianF32_NtoB(qtvrParams-&gt;defaultTilt);    panoSampleData-&gt;defaultFieldOfView  = EndianF32_NtoB(qtvrParams-&gt;defaultFieldOfView);    panoSampleData-&gt;imageSizeX      = EndianU32_NtoB(panoDescriptor-&gt;imageTileWidth  * qtvrParams-&gt;tilesH);    panoSampleData-&gt;imageSizeY      = EndianU32_NtoB(panoDescriptor-&gt;imageTileHeight * qtvrParams-&gt;tilesV);    panoSampleData-&gt;imageNumFramesX    = EndianU16_NtoB(qtvrParams-&gt;tilesH);    panoSampleData-&gt;imageNumFramesY    = EndianU16_NtoB(qtvrParams-&gt;tilesV);        panoSampleData-&gt;hotSpotSizeX    = EndianU32_NtoB(panoDescriptor-&gt;hotSpotTileWidth  * qtvrParams-&gt;tilesH);    panoSampleData-&gt;hotSpotSizeY    = EndianU32_NtoB(panoDescriptor-&gt;hotSpotTileHeight * qtvrParams-&gt;tilesV);     panoSampleData-&gt;hotSpotNumFramesX  = EndianU16_NtoB(qtvrParams-&gt;tilesH);    panoSampleData-&gt;hotSpotNumFramesY  = EndianU16_NtoB(qtvrParams-&gt;tilesV);          if (panoDescriptor-&gt;versionToCreate == kQTVRCylindricalVersion2h) {      panoSampleData-&gt;panoType    = EndianU32_NtoB(kQTVRHorizontalCylinder);  /* non-rotated pano */      panoSampleData-&gt;flags      = EndianU32_NtoB((qtvrParams-&gt;wraps ? kQTVRPanoFlagAlwaysWrap : 0L) | kQTVRPanoFlagHorizontal); // include for compatibility with QT 4.0    }    else {      panoSampleData-&gt;panoType    = EndianU32_NtoB(kQTVRVerticalCylinder);  /* rotated pano */      panoSampleData-&gt;flags      = EndianU32_NtoB(qtvrParams-&gt;wraps ? kQTVRPanoFlagAlwaysWrap : 0L);    }    panoSampleData-&gt;reserved2      = EndianU32_NtoB(0L);  }  else {  /* We're building a cubic panorama: build backward-compatible pano sample data */    panoSampleData-&gt;minPan        = EndianF32_NtoB(qtvrParams-&gt;minPan);    panoSampleData-&gt;maxPan        = EndianF32_NtoB(qtvrParams-&gt;maxPan);    panoSampleData-&gt;minTilt        = EndianF32_NtoB(qtvrParams-&gt;minTilt        &lt; -45.0f ? -45.0f : qtvrParams-&gt;minTilt);    panoSampleData-&gt;maxTilt        = EndianF32_NtoB(qtvrParams-&gt;maxTilt        &gt;  45.0f ?  45.0f : qtvrParams-&gt;maxTilt);    panoSampleData-&gt;minFieldOfView    = EndianF32_NtoB(qtvrParams-&gt;minFieldOfView);    panoSampleData-&gt;maxFieldOfView    = EndianF32_NtoB(qtvrParams-&gt;maxFieldOfView &gt;  90.0f ?  90.0f : qtvrParams-&gt;maxFieldOfView);    panoSampleData-&gt;defaultPan      = EndianF32_NtoB(qtvrParams-&gt;defaultPan);    panoSampleData-&gt;defaultTilt      = EndianF32_NtoB(qtvrParams-&gt;defaultTilt);    panoSampleData-&gt;defaultFieldOfView  = EndianF32_NtoB(qtvrParams-&gt;defaultFieldOfView);    panoSampleData-&gt;imageSizeX      = EndianU32_NtoB(panoDescriptor-&gt;imageTileWidth  * qtvrParams-&gt;tilesH * 4);    panoSampleData-&gt;imageSizeY      = EndianU32_NtoB(panoDescriptor-&gt;imageTileHeight * qtvrParams-&gt;tilesV);    panoSampleData-&gt;imageNumFramesX    = EndianU16_NtoB(qtvrParams-&gt;tilesH * 4);    panoSampleData-&gt;imageNumFramesY    = EndianU16_NtoB(qtvrParams-&gt;tilesV);        panoSampleData-&gt;hotSpotSizeX    = EndianU32_NtoB(panoDescriptor-&gt;hotSpotTileWidth  * qtvrParams-&gt;tilesH * 4);    panoSampleData-&gt;hotSpotSizeY    = EndianU32_NtoB(panoDescriptor-&gt;hotSpotTileHeight * qtvrParams-&gt;tilesV);     panoSampleData-&gt;hotSpotNumFramesX  = EndianU16_NtoB(qtvrParams-&gt;tilesH * 4);    panoSampleData-&gt;hotSpotNumFramesY  = EndianU16_NtoB(qtvrParams-&gt;tilesV);          /* Set the horizontal flag so that pre-cubic QTVR engine can at least display the four sides of the cube */    panoSampleData-&gt;flags        = EndianU32_NtoB(kQTVRPanoFlagHorizontal);    panoSampleData-&gt;panoType      = EndianU32_NtoB(kQTVRCube);    panoSampleData-&gt;reserved2      = EndianU32_NtoB(0L);  }}/******************************************************************************** * TileGWorldsToNewTrack ********************************************************************************/static OSErrTileGWorldsToNewTrack(  long    numGWs,          /* the number of GWorlds */  GWorldPtr  *srcGWs,        /* Source GWorlds - in standard order */  long    overlapTiles,      /* Whether the tiles should overlap or not */  CodecType  tileCodec,  CodecQ    tileQuality,  long    tilesH,  long    tilesV,  long    tileDepth,  Movie    dstMovie,        /* to be tiled and added to this movie. */  TimeValue  dstSequenceDuration,  /* duration of the whole sequence */  long    *pDstTrackWidth,    /* returned track width,  in integral units */  long    *pDstTrackHeight,    /* returned track height, in integral units */  Track    *pDstTrack        /* the track added to the dstMovie */){  PixMapHandle        pm;  Rect            tileRect;  Track            tileTrack    = NULL;  Media            tileMedia    = NULL;  ImageDescriptionHandle    tileImageDesc  = NULL;  Handle            tileData    = NULL;  Ptr              tileDataPtr    = NULL;  long            tileFrameSize;  TimeValue          dstTileDuration  = dstSequenceDuration / (tilesH * tilesV);  OSErr            err        = noErr;  long            i, j, k;  #if USE_TILE_DISPLAY_WINDOW    WindowRef        tileWindow;  #endif /* USE_TILE_DISPLAY_WINDOW */    /* Determine tile size */  #if ACCESSOR_CALLS_ARE_FUNCTIONS    GetPortBounds(srcGWs[0], &amp;tileRect);  #else /* ACCESSOR_CALLS_ARE_FUNCTIONS */    tileRect = srcGWs[0]-&gt;portRect;  #endif /* ACCESSOR_CALLS_ARE_FUNCTIONS */  MacOffsetRect(&amp;tileRect, -tileRect.left, -tileRect.top);  if (overlapTiles) {    tileRect.right  += tilesH - 1;  /* Adjust for overlap at seams */    tileRect.bottom += tilesV - 1;  /* Adjust for overlap at seams */  }  if ((tileRect.right % tilesH != 0) || (tileRect.bottom % tilesV != 0)) {  /* Check for evenly divisible tiles */    err = paramErr;    /* Oops: tiles are not evenly divisible */    goto bail;  }  tileRect.right  /= tilesH;  tileRect.bottom /= tilesV;  if (pDstTrackWidth  != NULL)  *pDstTrackWidth  = tileRect.right;  if (pDstTrackHeight != NULL)  *pDstTrackHeight = tileRect.bottom;    /* Create tile view, if desired */  #if USE_TILE_DISPLAY_WINDOW    MacOffsetRect(&amp;tileRect, 20, 100);    tileWindow = NewCWindow(NULL, &amp;tileRect, &quot;\pUncompressed tiles&quot;, true, noGrowDocProc, (WindowPtr)-1L, true, 0);    MacOffsetRect(&amp;tileRect, -20, -100);  #endif /* USE_TILE_DISPLAY_WINDOW */    /* Create the tile movie track and media */  tileTrack = NewMovieTrack(dstMovie, (long)tileRect.right &lt;&lt; 16, (long)tileRect.bottom &lt;&lt; 16, kNoVolume);    tileMedia = NewTrackMedia(tileTrack, VideoMediaType, 600, NULL, 0);  if ((tileTrack == NULL) || (tileMedia == NULL))    goto bail;  if (pDstTrack != NULL)  *pDstTrack = tileTrack;    /*   * dice the picture into pieces, compress them, and add the compressed tiles as video samples to the movie   */  /* create an image description handle; this is resized and filled in below by FCompressImage */  tileImageDesc = (ImageDescriptionHandle)MyNewHandleClear(4);  if (tileImageDesc == NULL)    goto bail;  pm = GetGWorldPixMap(srcGWs[0]);  LockPixels(pm);  err = GetMaxCompressionSize(pm, &amp;tileRect, tileDepth, tileQuality, tileCodec, (CompressorComponent)anyCodec, &amp;tileFrameSize);  UnlockPixels(pm);  if (err != noErr)    goto bail;  tileData = MyNewHandle(tileFrameSize);  if (tileData == NULL)    goto bail;  HLock(tileData);  tileDataPtr = *tileData;  BeginMediaEdits(tileMedia);        /* tile, compress, and write tiles */  for (k = 0; k &lt; numGWs; k++) {    pm = GetGWorldPixMap(srcGWs[k]);    for (j = 0; j &lt; tilesV; j++) {      for (i = 0; i &lt; tilesH; i++) {        Rect r;        if (overlapTiles) {          r.left = i * (tileRect.right  - 1);          r.top  = j * (tileRect.bottom - 1);        }        else {          r.left = i * tileRect.right;          r.top  = j * tileRect.bottom;        }        r.right  = r.left + tileRect.right;        r.bottom = r.top  + tileRect.bottom;                LockPixels(pm);        /* Draw the picture into the window we've created */        #if USE_TILE_DISPLAY_WINDOW          if (tileWindow != NULL) {            GrafPtr savePort;            GetPort(&amp;savePort);          #if TARGET_API_MAC_CARBON            MacSetPort(GetWindowPort(tileWindow));            CopyBits((BitMap*)(*(pm)),(BitMap*)*GetPortPixMap(GetWindowPort(tileWindow)), &amp;(**(pm)).bounds, GetPortBounds(GetWindowPort(tileWindow), NULL), ditherCopy, NULL);          #else            MacSetPort(tileWindow);            CopyBits((BitMap*)(*(pm)),&amp;(tileWindow-&gt;portBits), &amp;(**(pm)).bounds, &amp;tileWindow-&gt;portRect, ditherCopy, NULL);          #endif            MacSetPort(savePort);          }        #endif /* USE_TILE_DISPLAY_WINDOW */        err = FCompressImage(pm, &amp;r, tileDepth, tileQuality, tileCodec, (CompressorComponent)anyCodec, NULL, 0, 0, NULL, NULL, tileImageDesc, tileDataPtr);        UnlockPixels(pm);        if (err != noErr)          goto bail;        err = AddMediaSample(tileMedia, tileData, 0, (**tileImageDesc).dataSize, dstTileDuration, (SampleDescriptionHandle)tileImageDesc, 1L, 0, NULL);        if (err != noErr)          goto bail;      }    }      }    HUnlock(tileData);    EndMediaEdits(tileMedia);      /* add the media to the track, at time 0 */  err = InsertMediaIntoTrack(tileTrack, 0, 0, GetMediaDuration(tileMedia), fixed1);  if (err != noErr)    goto bail;  /* a panorama image track should always be disabled */  SetTrackEnabled(tileTrack, false);  bail:  if (tileData      != NULL)  DisposeHandle(tileData);  if (tileImageDesc != NULL)  DisposeHandle((Handle)tileImageDesc);  #if USE_TILE_DISPLAY_WINDOW    if (tileWindow!= NULL)  DisposeWindow(tileWindow);  #endif /* USE_TILE_DISPLAY_WINDOW */  return(err);}/******************************************************************************* * TilePictsToNewTrack *******************************************************************************/static OSErrTilePictsToNewTrack(  long    numPicts,  FSSpec    **srcPictSpecs,  long    overlapTiles,      /* Whether the tiles should overlap or not */  CodecType  tileCodec,  CodecQ    tileQuality,  long    tilesH,  long    tilesV,  short    tileDepth,  Movie    dstMovie,        /* to be tiled and added to this movie. */  TimeValue  dstSequenceDuration,  /* duration of the whole sequence */  long    *pDstTrackWidth,    /* returned track width,  in integral units */  long    *pDstTrackHeight,    /* returned track height, in integral units */  Track    *pDstTrack        /* the track added to the dstMovie */){  GraphicsImportComponent    theImporter    = NULL;  Rect            pictRect, tileRect, drawRect;  long            tileWidth, tileHeight;  GWorldPtr          gw        = NULL;  PixMapHandle         pm        = NULL;  Track            tileTrack    = NULL;  Media            tileMedia    = NULL;  ImageDescriptionHandle    tileImageDesc  = NULL;  Handle            tileData    = NULL;  Ptr              tileDataPtr    = NULL;  long            tileFrameSize;  TimeValue          dstTileDuration  = dstSequenceDuration / (tilesH * tilesV);  OSErr            err        = noErr;  long            i, j, k;  FSSpec            fsSpec;  #if USE_TILE_DISPLAY_WINDOW    WindowRef        tileWindow;  #endif /* USE_TILE_DISPLAY_WINDOW */    if ((srcPictSpecs == NULL) || (srcPictSpecs[0] == NULL) || (srcPictSpecs[0][0].name[0] == 0)) {    err = paramErr;    goto bail;  }  /* Create a GWorld to draw the uncompressed tiles into */  fsSpec = srcPictSpecs[0][0];  err = GetGraphicsImporterForFile(&amp;fsSpec, &amp;theImporter);  if (err != noErr)    goto bail;  err = GraphicsImportGetBoundsRect(theImporter, &amp;pictRect);  if (err != noErr)    goto bail;  CloseComponent(theImporter);  theImporter = NULL;  tileWidth   = pictRect.right  - pictRect.left;  tileHeight  = pictRect.bottom - pictRect.top;  if (overlapTiles) {    tileWidth  += tilesH - 1;  /* Adjust for overlap at seams */    tileHeight += tilesV - 1;  /* Adjust for overlap at seams */  }  if ((tileWidth % tilesH != 0) || (tileHeight % tilesV != 0)) {  /* Check for evenly divisible tiles */    err = paramErr;    /* Oops: tiles are not evenly divisible */    goto bail;  }  tileWidth  /= tilesH;  tileHeight /= tilesV;  if (pDstTrackWidth  != NULL)  *pDstTrackWidth  = tileWidth;  if (pDstTrackHeight != NULL)  *pDstTrackHeight = tileHeight;  MacSetRect(&amp;tileRect, 0, 0, tileWidth, tileHeight);  err = NewGWorld(&amp;gw, tileDepth, &amp;tileRect, NULL, NULL, 0L);  if (err != noErr)    goto bail;    /* Debugging or progress window */  #if USE_TILE_DISPLAY_WINDOW    MacSetRect(&amp;tileRect, 0, 0, tileWidth, tileHeight);    MacOffsetRect(&amp;tileRect, 20, 100);    tileWindow = NewCWindow(NULL, &amp;tileRect, &quot;\pUncompressed tiles&quot;, true, noGrowDocProc, (WindowPtr)-1L, true, 0);    MacOffsetRect(&amp;tileRect, -20, -100);  #endif /* USE_TILE_DISPLAY_WINDOW */  tileTrack = NewMovieTrack(dstMovie, tileWidth &lt;&lt; 16, tileHeight &lt;&lt; 16, kNoVolume);    tileMedia = NewTrackMedia(tileTrack, VideoMediaType, 600, NULL, 0);  if ((tileTrack == NULL) || (tileMedia == NULL))    goto bail;  if (pDstTrack != NULL)  *pDstTrack = tileTrack;    /* Dice the picture into pieces, compress them, and add the compressed tiles as video samples to the movie */  tileImageDesc = (ImageDescriptionHandle)MyNewHandleClear(4); /* this is resized and filled in below by FCompressImage */  if (tileImageDesc == NULL)    goto bail;  pm = GetGWorldPixMap(gw);  LockPixels(pm);  err = GetMaxCompressionSize(pm, &amp;tileRect, tileDepth, tileQuality, tileCodec, (CompressorComponent)anyCodec, &amp;tileFrameSize);  UnlockPixels(pm);  if (err != noErr)    goto bail;  tileData = MyNewHandle(tileFrameSize);  if (tileData == NULL)    goto bail;  BeginMediaEdits(tileMedia);    for (k = 0; k &lt; numPicts; k++) {    fsSpec = srcPictSpecs[0][k];    err = GetGraphicsImporterForFile(&amp;fsSpec, &amp;theImporter);    if (err != noErr)      goto bail;    for (j = 0; j &lt; tilesV; j++) {      for (i = 0; i &lt; tilesH; i++) {        /* Offset to the proper subrect for this tile */        drawRect = pictRect;        if (overlapTiles)  MacOffsetRect(&amp;drawRect, -i * (tileWidth-1), -j * (tileHeight-1));         else        MacOffsetRect(&amp;drawRect, -i *  tileWidth,    -j *  tileHeight);                 /* Draw the picture into the window we've created */        #if USE_TILE_DISPLAY_WINDOW          if (tileWindow != NULL) {            GraphicsImportSetGWorld(theImporter, (CGrafPtr)tileWindow, NULL);            GraphicsImportSetBoundsRect(theImporter, &amp;drawRect);            GraphicsImportDraw(theImporter);          }        #endif /* USE_TILE_DISPLAY_WINDOW */        /* Draw the picture into the uncompressed tile GWorld */        GraphicsImportSetGWorld(theImporter, gw, NULL);        GraphicsImportSetBoundsRect(theImporter, &amp;drawRect);        GraphicsImportDraw(theImporter);                /* Compress the tile and add it tile to the movie */        HLock(tileData);        tileDataPtr = *tileData;        LockPixels(pm);        err = FCompressImage(pm, &amp;tileRect, tileDepth, tileQuality, tileCodec, (CompressorComponent)anyCodec,          NULL, 0, 0, NULL, NULL, tileImageDesc, tileDataPtr        );        UnlockPixels(pm);        if (err != noErr)          goto bail;        err = AddMediaSample(tileMedia, tileData, 0, (**tileImageDesc).dataSize, dstTileDuration,          (SampleDescriptionHandle)tileImageDesc, 1L, 0, NULL        );        if (err != noErr)          goto bail;      }    }    CloseComponent(theImporter);    theImporter = NULL;  }    EndMediaEdits(tileMedia);  DisposeHandle(tileData);  tileData = NULL;    /* add the media to the track, at time 0 */  err = InsertMediaIntoTrack(tileTrack, 0, 0, GetMediaDuration(tileMedia), fixed1);  if (err != noErr)    goto bail;  /* a panorama image track should always be disabled */  SetTrackEnabled(tileTrack, false);  bail:  if (theImporter   != NULL)  CloseComponent(theImporter);  if (gw            != NULL)  DisposeGWorld(gw);  if (tileData      != NULL)  DisposeHandle(tileData);  if (tileImageDesc != NULL)  DisposeHandle((Handle)tileImageDesc);  #if USE_TILE_DISPLAY_WINDOW    if (tileWindow!= NULL)  DisposeWindow(tileWindow);  #endif /* USE_TILE_DISPLAY_WINDOW */  return(err);}/******************************************************************************** * FlattenQTVRMovie ********************************************************************************/static OSErrFlattenQTVRMovie(Movie srcMovie, FSSpec *dstMovieSpec){  ComponentDescription desc;  Component flattener;  ComponentInstance qtvrExport = nil;  OSErr err;  desc.componentType      = MovieExportType;  desc.componentSubType    = MovieFileType;  desc.componentManufacturer  = QTVRFlattenerType;   flattener = FindNextComponent(NULL, &amp;desc);    /* Use the specialized QuickTimeVR flattener if it is available */  if (flattener &amp;&amp; ((qtvrExport = OpenComponent(flattener)) != NULL)) {    /* http://developer.apple.com/techpubs/quicktime/qtdevdocs/VR/tp_qt3ref_vrcre8mov.13.htm */    #if 0  /* setting a preview image - this code put here in case someone wants to do it - not tested */      Boolean yes = true;      QTAtomContainer exportData;      QTAtom parent;      err = QTNewAtomContainer(&amp;exportData);      err = QTInsertChild (exportData, kParentAtomIsContainer, QTVRFlattenerParentAtomType, 1, 0, 0, nil, &amp;parent);      err = QTInsertChild (exportData, parent, QTVRImportPreviewAtomType, 1, 0, sizeof (yes), &amp;yes, nil);      err = QTInsertChild (exportData, parent, QTVRImportSpecAtomType, 1, 0, sizeof (previewSpec), &amp;previewSpec, nil);      MovieExportSetSettingsFromAtomContainer (qtvrExport, exportData);      /* Overriding the compression settings */      ComponentInstance sc;      QTAtomContainer compressorData;      SCSpatialSettings ss;      sc = OpenDefaultComponent(StandardCompressionType,StandardCompressionSubType);      ss.codecType = kCinepakCodecType;      ss.codec = nil;      ss.depth = 0;      ss.spatialQuality = codecHighQuality      err = SCSetInfo(sc, scSpatialSettingsType, &amp;ss);      err = SCGetSettingsAsAtomContainer(sc, &amp;compressorData);      MovieExportSetSettingsFromAtomContainer (qtvrExport, compressorData);    #endif /* 0 */    err = MovieExportToFile(qtvrExport, dstMovieSpec, srcMovie, NULL, 0, 0);  }  else {  /* Use the generic movie flattener */    Movie dstMovie;    SetMovieProgressProc(srcMovie, (MovieProgressUPP)-1, 0L);    dstMovie = FlattenMovieData(srcMovie,      flattenDontInterleaveFlatten | flattenAddMovieToDataFork | flattenForceMovieResourceBeforeMovieData,      dstMovieSpec, FOUR_CHAR_CODE('TVOD'),      smSystemScript, createMovieFileDeleteCurFile | createMovieFileDontCreateResFile    );    if ((dstMovie == NULL) || ((err = GetMoviesError()) == fnOpnErr)) {      DeleteMovieFile(dstMovieSpec);  /* I don't know why, but sometimes this is necessary */      dstMovie = FlattenMovieData(srcMovie,        flattenDontInterleaveFlatten | flattenAddMovieToDataFork | flattenForceMovieResourceBeforeMovieData,        dstMovieSpec, FOUR_CHAR_CODE('TVOD'),        smSystemScript, createMovieFileDeleteCurFile | createMovieFileDontCreateResFile      );      if ((dstMovie == NULL) &amp;&amp; ((err = GetMoviesError()) == noErr))        err = writErr; /* Something is wrong */    }    if (dstMovie != NULL)      DisposeMovie(dstMovie);  }  return(err);}#pragma mark -/******************************************************************************** * CreateVRWorld * *  Create a VR world atom container and add the basic required atoms to it *  Also, create a node information atom container and add a node header atom to it. *  Return both atom containers. * *  The caller is responsible for disposing of the VR world and the node information atom *  (by calling QTDisposeAtomContainer). * *  This function assumes that the scene described by the VR world contains *  a single node whose type is specified by the theNodeType parameter. ********************************************************************************/static OSErrCreateVRWorld(  OSType          theNodeType,  const MakeQTVRParams  *qtvrParams,  QTAtomContainer      *theVRWorld,  QTAtomContainer      *theNodeInfo){  QTAtomContainer      myVRWorld      = NULL;  QTAtomContainer      myNodeInfo      = NULL;  QTVRWorldHeaderAtom    myVRWorldHeaderAtom;  QTAtom          myImagingParentAtom;  QTAtom          myNodeParentAtom;  QTAtom          myHSParentAtom;  QTAtom          myNodeAtom;  QTVRPanoImagingAtom    myPanoImagingAtom;  QTVRNodeLocationAtom  myNodeLocationAtom;  QTVRNodeHeaderAtom    myNodeHeaderAtom;  UInt32          myIndex;  OSErr          err          = noErr;  /* Create a VR world atom container */  err = QTNewAtomContainer(&amp;myVRWorld);  if (err != noErr)    goto bail;  /* Add a VR world header atom to the VR world */  myVRWorldHeaderAtom.majorVersion = EndianU16_NtoB(kQTVRMajorVersion);  myVRWorldHeaderAtom.minorVersion = EndianU16_NtoB(kQTVRMinorVersion);  /* Insert the scene name string, if we have one; if not, set nameAtomID to 0 */  if (qtvrParams-&gt;sceneName) {    QTAtomID      myID;        err = AddCStringToAtomContainer(myVRWorld, kParentAtomIsContainer, qtvrParams-&gt;sceneName, &amp;myID);    myVRWorldHeaderAtom.nameAtomID  = EndianU32_NtoB(myID);  } else {    myVRWorldHeaderAtom.nameAtomID  = EndianU32_NtoB(0L);  }    myVRWorldHeaderAtom.defaultNodeID  = EndianU32_NtoB(kDefaultNodeID);  myVRWorldHeaderAtom.vrWorldFlags  = EndianU32_NtoB(0L);  myVRWorldHeaderAtom.reserved1    = EndianU32_NtoB(0L);  myVRWorldHeaderAtom.reserved2    = EndianU32_NtoB(0L);  /* Add the atom to the atom container (the VR world) */  err = QTInsertChild(myVRWorld, kParentAtomIsContainer, kQTVRWorldHeaderAtomType, 1, 1, sizeof(QTVRWorldHeaderAtom), &amp;myVRWorldHeaderAtom, NULL);  if (err != noErr)    goto bail;      /* Add an imaging parent atom to the VR world and insert imaging atoms into it   *   * Imaging atoms describe the default imaging characteristics for the different types of nodes in the scene;   * currently, only the panorama imaging atoms are defined, so we'll include those (even in object movies)   */  err = QTInsertChild(myVRWorld, kParentAtomIsContainer, kQTVRImagingParentAtomType, 1, 1, 0, NULL, &amp;myImagingParentAtom);  if (err != noErr)    goto bail;      /* Fill in the fields of the panorama imaging atom structure */  myPanoImagingAtom.majorVersion    = EndianU16_NtoB(kQTVRMajorVersion);  myPanoImagingAtom.minorVersion    = EndianU16_NtoB(kQTVRMinorVersion);  myPanoImagingAtom.correction    = EndianU32_NtoB(kQTVRFullCorrection);  myPanoImagingAtom.imagingValidFlags  = EndianU32_NtoB(kQTVRValidCorrection | kQTVRValidQuality | kQTVRValidDirectDraw);  myPanoImagingAtom.reserved1      = EndianU32_NtoB(0L);  myPanoImagingAtom.reserved2      = EndianU32_NtoB(0L);  for (myIndex = 0; myIndex &lt; 6; myIndex++)    myPanoImagingAtom.imagingProperties[myIndex] = EndianU32_NtoB(0L);    /* Add a panorama imaging atom for kQTVRMotion state */  myPanoImagingAtom.quality    = EndianU32_NtoB(qtvrParams-&gt;dynamicQuality);  myPanoImagingAtom.directDraw  = EndianU32_NtoB(true);  myPanoImagingAtom.imagingMode  = EndianU32_NtoB(kQTVRMotion);  err = QTInsertChild(myVRWorld, myImagingParentAtom, kQTVRPanoImagingAtomType, 0, 0, sizeof(QTVRPanoImagingAtom), &amp;myPanoImagingAtom, NULL);  if (err != noErr)    goto bail;      /* Add a panorama imaging atom for kQTVRStatic state */  myPanoImagingAtom.quality    = EndianU32_NtoB(qtvrParams-&gt;staticQuality);  myPanoImagingAtom.directDraw  = EndianU32_NtoB(false);  myPanoImagingAtom.imagingMode  = EndianU32_NtoB(kQTVRStatic);  err = QTInsertChild(myVRWorld, myImagingParentAtom, kQTVRPanoImagingAtomType, 0, 0, sizeof(QTVRPanoImagingAtom), &amp;myPanoImagingAtom, NULL);  if (err != noErr)    goto bail;      /* Add a node parent atom to the VR world and insert node ID atoms into it */  err = QTInsertChild(myVRWorld, kParentAtomIsContainer, kQTVRNodeParentAtomType, 1, 1, 0, NULL, &amp;myNodeParentAtom);  if (err != noErr)    goto bail;      /* Add a node ID atom */  err = QTInsertChild(myVRWorld, myNodeParentAtom, kQTVRNodeIDAtomType, kDefaultNodeID, 0, 0, NULL, &amp;myNodeAtom);  if (err != noErr)    goto bail;    /* Add a single node location atom to the node ID atom */  myNodeLocationAtom.majorVersion    = EndianU16_NtoB(kQTVRMajorVersion);  myNodeLocationAtom.minorVersion    = EndianU16_NtoB(kQTVRMinorVersion);  myNodeLocationAtom.nodeType      = EndianU32_NtoB(theNodeType);  myNodeLocationAtom.locationFlags  = EndianU32_NtoB(kQTVRSameFile);  myNodeLocationAtom.locationData    = EndianU32_NtoB(0);  myNodeLocationAtom.reserved1    = EndianU32_NtoB(0);  myNodeLocationAtom.reserved2    = EndianU32_NtoB(0);    /* Insert the node location atom into the node ID atom */  err = QTInsertChild(myVRWorld, myNodeAtom, kQTVRNodeLocationAtomType, 1, 1, sizeof(QTVRNodeLocationAtom), &amp;myNodeLocationAtom, NULL);  if (err != noErr)    goto bail;    /*  Create a node information atom container and add a node header atom to it */    err = QTNewAtomContainer(&amp;myNodeInfo);  if (err != noErr)    goto bail;  myNodeHeaderAtom.majorVersion  = EndianU16_NtoB(kQTVRMajorVersion);  myNodeHeaderAtom.minorVersion  = EndianU16_NtoB(kQTVRMinorVersion);  myNodeHeaderAtom.nodeType    = EndianU32_NtoB(theNodeType);  myNodeHeaderAtom.nodeID      = EndianU32_NtoB(kDefaultNodeID);  myNodeHeaderAtom.commentAtomID  = EndianU32_NtoB(0L);  myNodeHeaderAtom.reserved1    = EndianU32_NtoB(0L);  myNodeHeaderAtom.reserved2    = EndianU32_NtoB(0L);    /* Insert the node name string into the node info atom container */  if (qtvrParams-&gt;nodeName) {    QTAtomID      myID;        err = AddCStringToAtomContainer(myNodeInfo, kParentAtomIsContainer, qtvrParams-&gt;nodeName, &amp;myID);    myNodeHeaderAtom.nameAtomID = EndianU32_NtoB(myID);  } else {    myNodeHeaderAtom.nameAtomID = EndianU32_NtoB(0L);  }    /* Insert the node header atom into the node info atom container */  err = QTInsertChild(myNodeInfo, kParentAtomIsContainer, kQTVRNodeHeaderAtomType, 1, 1, sizeof(QTVRNodeHeaderAtom), &amp;myNodeHeaderAtom, NULL);  if (err != noErr)    goto bail;    /*   * Add a hot spot parent atom to the node information atom container and insert hot spot atoms into it   */      /* Insert the hot spot parent atom into the node info atom container */  err = QTInsertChild(myNodeInfo, kParentAtomIsContainer, kQTVRHotSpotParentAtomType, 1, 1, 0, NULL, &amp;myHSParentAtom);  if (err != noErr)    goto bail;    #ifdef ADD_ALL_HOTSPOTS  /* The following loop adds all possible hot spot atoms to the hot spot parent atom;   * we do this because we don't know how many hot spots are in the hot spot image or   * what their color-table indices are; you will want to handle a real hot spot image   * differently, no doubt....   */      for (myIndex = 1; myIndex &lt; 255; myIndex++) {    char myHSName[100];    char myURL[] = &quot;http://www.apple.com&quot;;        sprintf(myHSName, &quot;Hot Spot Index %d&quot;, myIndex);    err = MakeQTVRHotSpot2x0(myNodeInfo, myHSParentAtom, myURL, myHSName, myIndex);    if (err != noErr)      goto bail;    }#endif /* ADD_ALL_HOTSPOTS */  bail:  /* return the atom containers that we've created and configured here */  *theVRWorld    = myVRWorld;  *theNodeInfo  = myNodeInfo;    return(err);}/******************************************************************************* * CreateQTVRTrack *******************************************************************************/static OSErrCreateQTVRTrack(const MakeQTVRParams *qtvrParams, TimeValue dstTrackDuration, Movie movie, Track *qtvrTrack){  Track              myQTVRTrack;  Media              myQTVRMedia;  QTAtomContainer          myVRWorld      = NULL;  QTAtomContainer          myNodeInfo      = NULL;  QTVRSampleDescriptionHandle    myQTVRDesc      = NULL;  long              mySize;  OSErr              err;  myQTVRTrack = NewMovieTrack(movie, qtvrParams-&gt;windowWidth &lt;&lt; 16, qtvrParams-&gt;windowHeight &lt;&lt; 16, kFullVolume);  myQTVRMedia = NewTrackMedia(myQTVRTrack, kQTVRQTVRType, kQTVRStandardTimeScale, NULL, 0);  if ((myQTVRTrack == NULL) || (myQTVRMedia == NULL)) {    err = GetMoviesError();    goto bail;  }    SetMovieTimeScale(movie, kQTVRStandardTimeScale);  /* create a VR world atom container and a node information atom container;   * remember that the VR world becomes part of the QTVR sample description,   * and the node information atom container becomes the media sample data   */  err = CreateVRWorld(kQTVRPanoramaType, qtvrParams, &amp;myVRWorld, &amp;myNodeInfo);  if ((err != noErr) || (myVRWorld == NULL) || (myNodeInfo == NULL))    goto bail;    /* create a QTVR sample description */  mySize = sizeof(QTVRSampleDescription) + GetHandleSize((Handle)myVRWorld) - sizeof(long);  myQTVRDesc = (QTVRSampleDescriptionHandle)MyNewHandleClear(mySize);  if (myQTVRDesc == NULL)    goto bail;      (**myQTVRDesc).descSize    = mySize;  (**myQTVRDesc).descType    = kQTVRQTVRType;  (**myQTVRDesc).reserved1  = 0;  (**myQTVRDesc).reserved2  = 0;  (**myQTVRDesc).dataRefIndex  = 0;  /* copy the VR world atom container into the data field of the QTVR sample description */  BlockMoveData(*((Handle)myVRWorld), &amp;((**myQTVRDesc).data), GetHandleSize((Handle)myVRWorld));    /* Create the media sample and add it to the QTVR track */  BeginMediaEdits(myQTVRMedia);  err = AddMediaSample(myQTVRMedia, (Handle)myNodeInfo, 0, GetHandleSize((Handle)myNodeInfo), dstTrackDuration, (SampleDescriptionHandle)myQTVRDesc, 1, 0, NULL);  if (err != noErr)    goto bail;  EndMediaEdits(myQTVRMedia);  err = InsertMediaIntoTrack(myQTVRTrack, 0, 0, dstTrackDuration, fixed1);  bail:  if (myQTVRDesc  != NULL)  DisposeHandle((Handle)myQTVRDesc);  if (myVRWorld   != NULL)  QTDisposeAtomContainer(myVRWorld);  if (myNodeInfo  != NULL)  QTDisposeAtomContainer(myNodeInfo);  *qtvrTrack = myQTVRTrack;  return(err);}/******************************************************************************* * CreatePanoMediaSample *******************************************************************************/static OSErrCreatePanoMediaSample(  const MakeQTVRParams    *qtvrParams,  const MyPanoTrackDescriptor  *panoDescriptor,  QTAtomContainer        *thePanoSample){  OSErr        err;  QTAtomContainer    panoSample;  QTVRPanoSampleAtom  myPanoSampleData;  /* Create a pano media sample container */  err = QTNewAtomContainer(&amp;panoSample);  if (err != noErr)    goto bail;    /* Insert the pano sample atom into the pano sample atom container */  SetPanoSampleData(qtvrParams, panoDescriptor, &amp;myPanoSampleData);  err = QTInsertChild(panoSample, kParentAtomIsContainer, kQTVRPanoSampleDataAtomType, 1, 1, sizeof(QTVRPanoSampleAtom), &amp;myPanoSampleData, NULL);  if (err != noErr)    goto bail;  /* Attach a fast start preview track, if applicable */  if (panoDescriptor-&gt;fastStartRefTrackIndex) {    QTVRTrackRefEntry trackRefEntry;    trackRefEntry.trackRefType    = kQTVRImageTrackRefType;    trackRefEntry.trackResolution = kQTVRPreviewTrackRes;    trackRefEntry.trackRefIndex   = panoDescriptor-&gt;fastStartRefTrackIndex;    err = QTInsertChild(panoSample, kParentAtomIsContainer,      kQTVRTrackRefArrayAtomType, 1, 1, sizeof(QTVRTrackRefEntry), &amp;trackRefEntry, nil);  }  /* Set the view and face orientation for cubic panoramas;   * this atom will be ignored in pre-cubic versions of QTVR   */  if (panoDescriptor-&gt;versionToCreate == kQTVRCubicVersion1) {    /* Specify the default and media-constrained view parameters */    QTVRCubicViewAtom     myCubicViewAtom;    SetCubicViewData(qtvrParams, &amp;myCubicViewAtom);    err = QTInsertChild(panoSample, kParentAtomIsContainer, kQTVRCubicViewAtomType, 1, 1, sizeof(QTVRCubicViewAtom), &amp;myCubicViewAtom, NULL);    if (err != noErr)      goto bail;    /* Specify the orientation of each face */    #define FORCE_CUBIC_FACE_DATA    #ifndef FORCE_CUBIC_FACE_DATA      if (qtvrParams-&gt;tilesH * qtvrParams-&gt;tilesV != 1)    /* We use the default if the faces are not subtiled */    #endif /* FORCE_CUBIC_FACE_DATA */    {      QTVRCubicFaceData  *cubicData;      cubicData = (QTVRCubicFaceData*)NewPtr(sizeof(QTVRCubicFaceData) * 6 * qtvrParams-&gt;tilesH * qtvrParams-&gt;tilesV);      SetCubicFaceData(qtvrParams, cubicData);      err = QTInsertChild(panoSample, kParentAtomIsContainer,        kQTVRCubicFaceDataAtomType, 1, 1, sizeof(QTVRCubicFaceData) * 6 * qtvrParams-&gt;tilesH * qtvrParams-&gt;tilesV, cubicData, nil      );      DisposePtr((Ptr)cubicData);      if (err != noErr)        goto bail;    }  }  /* add pan constraint, tilt constraint, and field-of-view constraint atoms here   * [left as an exercise for the reader; here's the basic idea:]   */  if (false) {    QTVRAngleRangeAtom    myPanRangeAtom;        myPanRangeAtom.minimumAngle = EndianF32_NtoB(  0.0);    myPanRangeAtom.maximumAngle = EndianF32_NtoB(270.0);        err = QTInsertChild(panoSample, kParentAtomIsContainer, kQTVRPanConstraintAtomType, 1, 1, sizeof(QTVRAngleRangeAtom), &amp;myPanRangeAtom, NULL);  }  bail:  *thePanoSample = (err == noErr) ? panoSample : NULL;  return(err);}/******************************************************************************* * InitMyPanoDesc * *  Create a (version 2.0) panorama track, appending the given video tracks. *******************************************************************************/static voidInitMyPanoDesc(MyPanoTrackDescriptor *myPanoDesc, long versionToCreate){  myPanoDesc-&gt;versionToCreate      = versionToCreate;  myPanoDesc-&gt;imageTileWidth      = 0;  myPanoDesc-&gt;imageTileHeight      = 0;  myPanoDesc-&gt;imageRefTrackIndex    = 0;  myPanoDesc-&gt;hotSpotTileWidth    = 0;  myPanoDesc-&gt;hotSpotTileHeight    = 0;  myPanoDesc-&gt;hotSpotRefTrackIndex  = 0;  myPanoDesc-&gt;fastStartTileWidth    = 0;  myPanoDesc-&gt;fastStartTileHeight    = 0;  myPanoDesc-&gt;fastStartRefTrackIndex  = 0;}/******************************************************************************* * CreatePanoTrackFromMovies * *  Create a (version 2.0) panorama track, appending the given video tracks. *******************************************************************************/static OSErrCreatePanoTrackFromMovies(  const FSSpec      *srcMovieSpec,  const FSSpec      *srcHSMovieSpec,  const FSSpec      *srcFSMovieSpec,  const MakeQTVRParams  *qtvrParams,  long          versionToCreate,  Movie          dstMovie,  Track          qtvrTrack,  Track          *thePanoTrack){  Track            panoTrack      = NULL;  Track            imageTrack      = NULL;  Track            hsImageTrack    = NULL;  Track            fsImageTrack    = NULL;  Media            panoMedia      = NULL;  SampleDescriptionHandle    sampleDesc      = NULL;  QTAtomContainer        myPanoSample    = NULL;  OSErr            err          = noErr;  MakeQTVRParams        myParams      = *qtvrParams;  MyPanoTrackDescriptor    myPanoDesc;  /* Initialize myPanoDesc */  InitMyPanoDesc(&amp;myPanoDesc, versionToCreate);  /* Create a new pano track and media */  panoTrack = NewMovieTrack(dstMovie, myParams.windowWidth&lt;&lt;16, myParams.windowHeight&lt;&lt;16, 0);  if (panoTrack == NULL) {    err = GetMoviesError();    goto bail;  }  panoMedia = NewTrackMedia(panoTrack, kQTVRPanoramaType, kQTVRStandardTimeScale, 0, 0);  if (panoMedia == NULL) {    err = GetMoviesError();    goto bail;  }    /* Create a fast start image track, if given; a reference to it is contained in the pano track */  if ((srcFSMovieSpec != NULL) &amp;&amp; (srcFSMovieSpec-&gt;name[0] != 0)) {    err = ImportFirstVideoTrackFromFile(srcFSMovieSpec, dstMovie, myParams.trackDuration, 0,      &amp;myPanoDesc.fastStartTileWidth, &amp;myPanoDesc.fastStartTileHeight, &amp;fsImageTrack    );    if (err != noErr)      goto bail;  }      /* Create a panorama image track; a reference to it is contained in the pano track */  err = ImportFirstVideoTrackFromFile(srcMovieSpec, dstMovie, myParams.trackDuration, 0,    &amp;myPanoDesc.imageTileWidth, &amp;myPanoDesc.imageTileHeight, &amp;imageTrack  );  if (err != noErr)    goto bail;    /* Create a hot spot image track, if given; a reference to it is contained in the pano track */  if ((srcHSMovieSpec != NULL) &amp;&amp; (srcHSMovieSpec-&gt;name[0] != 0)) {    err = ImportFirstVideoTrackFromFile(srcHSMovieSpec, dstMovie, myParams.trackDuration, 0,      &amp;myPanoDesc.hotSpotTileWidth, &amp;myPanoDesc.hotSpotTileHeight, &amp;hsImageTrack    );    if (err != noErr)      goto bail;  }      /* Create track references from QTVR track to panorama track,   * and from the panorama track to the panorama image track and the hot spot image track   */  if (panoTrack    != NULL)  AddTrackReference(qtvrTrack, panoTrack,    kQTVRPanoramaType,        NULL);  if (imageTrack   != NULL)  AddTrackReference(panoTrack, imageTrack,   kQTVRImageTrackRefType,   &amp;myPanoDesc.imageRefTrackIndex);  if (hsImageTrack != NULL)  AddTrackReference(panoTrack, hsImageTrack, kQTVRHotSpotTrackRefType, &amp;myPanoDesc.hotSpotRefTrackIndex);  if (fsImageTrack != NULL)  AddTrackReference(panoTrack, fsImageTrack, kQTVRImageTrackRefType,   &amp;myPanoDesc.fastStartRefTrackIndex);  /* Create a sample description; this contains no real info, but AddMediaSample requires it. */  sampleDesc = (SampleDescriptionHandle)MyNewHandleClear(sizeof(SampleDescription));  /* Check pano parameters */  VerifyPanoParameters(&amp;myParams, &amp;myPanoDesc);  /* Create panorama media sample and add it to the panorama track */  err = CreatePanoMediaSample(&amp;myParams, &amp;myPanoDesc, &amp;myPanoSample);  if (err != noErr)    goto bail;  BeginMediaEdits(panoMedia);  err = AddMediaSample(panoMedia, (Handle)myPanoSample, 0, GetHandleSize((Handle)myPanoSample), myParams.trackDuration, (SampleDescriptionHandle)sampleDesc, 1, 0, NULL);  if (err != noErr)    goto bail;  EndMediaEdits(panoMedia);  err = InsertMediaIntoTrack(panoTrack, 0, 0, myParams.trackDuration, fixed1);  QTDisposeAtomContainer(myPanoSample);  DisposeHandle((Handle)sampleDesc);  bail:  *thePanoTrack = panoTrack;  return(err);}/******************************************************************************* * CreatePanoTrackFromPicts * *  Create a (version 2.0) panorama track, appending the given Picts. *******************************************************************************/static OSErrCreatePanoTrackFromPicts(  long          numFaces,  FSSpec          **srcPictSpecs,    /* Source     images */  FSSpec          **srcHSPictSpecs,  /* Hot spot   images */  FSSpec          **srcFSPictSpecs,  /* Fast start images */  long          versionToCreate,  const MakeQTVRParams  *qtvrParams,  TimeValue        trackDuration,  Movie          dstMovie,  Track          qtvrTrack,  Track          *thePanoTrack){  Track            imageTrack      = NULL;  Track            hsImageTrack    = NULL;  Track            fsImageTrack    = NULL;  Track            panoTrack      = NULL;  Media            panoMedia      = NULL;  long            imageRefIndex    = 0;  long            hsRefIndex      = 0;  long            fsRefIndex      = 0;  SampleDescriptionHandle    sampleDesc      = NULL;  QTAtomContainer        myPanoSample    = NULL;  OSErr            err          = noErr;  long            overlapTiles    = (long)(versionToCreate == kQTVRCubicVersion1);  MakeQTVRParams        myParams      = *qtvrParams;  MyPanoTrackDescriptor    myPanoDesc;  /* Initialize myPanoDesc */  InitMyPanoDesc(&amp;myPanoDesc, versionToCreate);  /* Create a new pano track and media */  panoTrack = NewMovieTrack(dstMovie, myParams.windowWidth&lt;&lt;16, myParams.windowHeight&lt;&lt;16, 0);  if (panoTrack == NULL) {    err = GetMoviesError();    goto bail;  }  panoMedia = NewTrackMedia(panoTrack, kQTVRPanoramaType, kQTVRStandardTimeScale, 0, 0);  if (panoTrack == NULL) {    err = GetMoviesError();    goto bail;  }    /* Create a fast start image track, if given; a reference to it is contained in the pano track */  if ((srcFSPictSpecs != NULL) &amp;&amp; (srcFSPictSpecs[0][0].name[0] != 0)) {    err = TilePictsToNewTrack(numFaces, srcFSPictSpecs, overlapTiles, kJPEGCodecType, codecLowQuality,      myParams.tilesH, myParams.tilesV, 0, dstMovie, myParams.trackDuration,      &amp;myPanoDesc.fastStartTileWidth, &amp;myPanoDesc.fastStartTileHeight, &amp;fsImageTrack    );    if (err != noErr)      goto bail;  }      /* Create a panorama image track; a reference to it is contained in the pano track */  err = TilePictsToNewTrack(numFaces, srcPictSpecs, overlapTiles, myParams.tileCodec, myParams.tileQuality,    myParams.tilesH, myParams.tilesV, 0, dstMovie, myParams.trackDuration,    &amp;myPanoDesc.imageTileWidth, &amp;myPanoDesc.imageTileHeight, &amp;imageTrack  );  if (err != noErr)    goto bail;    /* Create a hot spot image track, if given; a reference to it is contained in the pano track */  if ((srcHSPictSpecs != NULL) &amp;&amp; (srcHSPictSpecs[0][0].name[0] != 0)) {    err = TilePictsToNewTrack(numFaces, srcHSPictSpecs, overlapTiles, kGraphicsCodecType, codecLosslessQuality,      myParams.tilesH, myParams.tilesV, 8, dstMovie, myParams.trackDuration,      &amp;myPanoDesc.hotSpotTileWidth, &amp;myPanoDesc.hotSpotTileHeight, &amp;hsImageTrack    );    if (err != noErr)      goto bail;  }        /* Create track references from QTVR track to panorama track,   * and from the panorama track to the panorama image track and the hot spot image track   */  if (panoTrack    != NULL)  AddTrackReference(qtvrTrack, panoTrack,    kQTVRPanoramaType,        NULL);  if (imageTrack   != NULL)  AddTrackReference(panoTrack, imageTrack,   kQTVRImageTrackRefType,   &amp;myPanoDesc.imageRefTrackIndex);  if (hsImageTrack != NULL)  AddTrackReference(panoTrack, hsImageTrack, kQTVRHotSpotTrackRefType, &amp;myPanoDesc.hotSpotRefTrackIndex);  if (fsImageTrack != NULL)  AddTrackReference(panoTrack, fsImageTrack, kQTVRImageTrackRefType,   &amp;myPanoDesc.fastStartRefTrackIndex);  /* Create a sample description; this contains no real info, but AddMediaSample requires it. */  sampleDesc = (SampleDescriptionHandle)MyNewHandleClear(sizeof(SampleDescription));  /* Check pano parameters */  VerifyPanoParameters(&amp;myParams, &amp;myPanoDesc);  /* Create panorama media sample and add it to the panorama track */  err = CreatePanoMediaSample(&amp;myParams, &amp;myPanoDesc, &amp;myPanoSample);  if (err != noErr)    goto bail;  BeginMediaEdits(panoMedia);  err = AddMediaSample(panoMedia, (Handle)myPanoSample, 0, GetHandleSize((Handle)myPanoSample), trackDuration, (SampleDescriptionHandle)sampleDesc, 1, 0, NULL);  if (err != noErr)    goto bail;  EndMediaEdits(panoMedia);  err = InsertMediaIntoTrack(panoTrack, 0, 0, trackDuration, fixed1);  bail:  if (myPanoSample != NULL)  QTDisposeAtomContainer(myPanoSample);  if (sampleDesc   != NULL)  DisposeHandle((Handle)sampleDesc);  *thePanoTrack = panoTrack;  return(err);}/******************************************************************************* * CreatePanoTrackFromGWorlds * *  Create a (version 2.0) panorama track, appending the given GWorlds. *******************************************************************************/static OSErrCreatePanoTrackFromGWorlds(  long          numFaces,  GWorldPtr        *panoGWs,  GWorldPtr        *hsGWs,  GWorldPtr        *fsGWs,  long          versionToCreate,  const MakeQTVRParams  *qtvrParams,  TimeValue        trackDuration,  Movie          dstMovie,  Track          qtvrTrack,  Track          *thePanoTrack){  Track            imageTrack      = NULL;  Track            hsImageTrack    = NULL;  Track            fsImageTrack    = NULL;  Track            panoTrack      = NULL;  Media            panoMedia      = NULL;  long            imageRefIndex    = 0;  long            hsRefIndex      = 0;  long            fsRefIndex      = 0;  SampleDescriptionHandle    sampleDesc      = NULL;  QTAtomContainer        myPanoSample    = NULL;  OSErr            err          = noErr;  long            overlapTiles    = (long)(versionToCreate == kQTVRCubicVersion1);  MakeQTVRParams        myParams      = *qtvrParams;  MyPanoTrackDescriptor    myPanoDesc;  /* Initialize myPanoDesc */  InitMyPanoDesc(&amp;myPanoDesc, versionToCreate);  /* Create a new pano track and media */  panoTrack = NewMovieTrack(dstMovie, myParams.windowWidth&lt;&lt;16, myParams.windowHeight&lt;&lt;16, 0);  if (panoTrack == NULL) {    err = GetMoviesError();    goto bail;  }  panoMedia = NewTrackMedia(panoTrack, kQTVRPanoramaType, kQTVRStandardTimeScale, 0, 0);  if (panoTrack == NULL) {    err = GetMoviesError();    goto bail;  }    /* Create a fast start image track, if given; a reference to it is contained in the pano track */  if ((fsGWs != NULL) &amp;&amp; (fsGWs[0] != NULL)) {    err = TileGWorldsToNewTrack(numFaces, fsGWs, overlapTiles, kJPEGCodecType, codecLowQuality,      myParams.tilesH, myParams.tilesV, 0, dstMovie, myParams.trackDuration,      &amp;myPanoDesc.fastStartTileWidth, &amp;myPanoDesc.fastStartTileHeight, &amp;fsImageTrack    );    if (err != noErr)      goto bail;  }      /* Create a panorama image track; a reference to it is contained in the pano track */  err = TileGWorldsToNewTrack(numFaces, panoGWs, overlapTiles, myParams.tileCodec, myParams.tileQuality,    myParams.tilesH, myParams.tilesV, 0, dstMovie, myParams.trackDuration,    &amp;myPanoDesc.imageTileWidth, &amp;myPanoDesc.imageTileHeight, &amp;imageTrack  );  if (err != noErr)    goto bail;    /* Create a hot spot image track, if given; a reference to it is contained in the pano track */  if ((hsGWs != NULL) &amp;&amp; (hsGWs[0] != NULL)) {    err = TileGWorldsToNewTrack(numFaces, hsGWs, overlapTiles, kGraphicsCodecType, codecLosslessQuality,      myParams.tilesH, myParams.tilesV, 8, dstMovie, myParams.trackDuration,      &amp;myPanoDesc.hotSpotTileWidth, &amp;myPanoDesc.hotSpotTileHeight, &amp;hsImageTrack    );    if (err != noErr)      goto bail;  }        /* Create track references from QTVR track to panorama track,   * and from the panorama track to the panorama image track and the hot spot image track   */  if (panoTrack    != NULL)  AddTrackReference(qtvrTrack, panoTrack,    kQTVRPanoramaType,        NULL);  if (imageTrack   != NULL)  AddTrackReference(panoTrack, imageTrack,   kQTVRImageTrackRefType,   &amp;myPanoDesc.imageRefTrackIndex);  if (hsImageTrack != NULL)  AddTrackReference(panoTrack, hsImageTrack, kQTVRHotSpotTrackRefType, &amp;myPanoDesc.hotSpotRefTrackIndex);  if (fsImageTrack != NULL)  AddTrackReference(panoTrack, fsImageTrack, kQTVRImageTrackRefType,   &amp;myPanoDesc.fastStartRefTrackIndex);  /* Create a sample description; this contains no real info, but AddMediaSample requires it. */  sampleDesc = (SampleDescriptionHandle)MyNewHandleClear(sizeof(SampleDescription));  /* Check pano parameters */  VerifyPanoParameters(&amp;myParams, &amp;myPanoDesc);  /* Create panorama media sample and add it to the panorama track */  err = CreatePanoMediaSample(&amp;myParams, &amp;myPanoDesc, &amp;myPanoSample);  if (err != noErr)    goto bail;  BeginMediaEdits(panoMedia);  err = AddMediaSample(panoMedia, (Handle)myPanoSample, 0, GetHandleSize((Handle)myPanoSample), trackDuration, (SampleDescriptionHandle)sampleDesc, 1, 0, NULL);  if (err != noErr)    goto bail;  EndMediaEdits(panoMedia);  err = InsertMediaIntoTrack(panoTrack, 0, 0, trackDuration, fixed1);  bail:  if (myPanoSample != NULL)  QTDisposeAtomContainer(myPanoSample);  if (sampleDesc   != NULL)  DisposeHandle((Handle)sampleDesc);  *thePanoTrack = panoTrack;  return(err);}#if 0/******************************************************************************* * CreateTileMovieFromPictFiles * *  Create a QuickTime movie containing tiles from the specified image files. *******************************************************************************/static OSErrCreateTileMovieFromPictFiles(  long    numPicts,  FSSpec    **srcPictSpecs,  CodecType  tileCodec,  CodecQ    tileQuality,  long    tilesH,  long    tilesV,  short    tileDepth,  FSSpec    *dstTileSpec){  GraphicsImportComponent    theImporter    = NULL;  Rect            pictRect, tileRect, drawRect;  long            tileWidth, tileHeight;  GWorldPtr          gw        = NULL;  PixMapHandle         pm        = NULL;  Movie            movie      = NULL;  short            myResRefNum    = -1;  short            myResID      = movieInDataForkResID;  Track            myTrack      = NULL;  Media            myMedia      = NULL;  ImageDescriptionHandle    myImageDesc    = NULL;  Handle            myData      = NULL;  Ptr              myDataPtr    = NULL;  long            myFrameSize;  TimeValue          dstTileDuration  = 300;  OSErr            err = noErr;  long            i, j, k;  FSSpec            fsSpec;  #if USE_TILE_DISPLAY_WINDOW    WindowRef        myWindow;  #endif /* USE_TILE_DISPLAY_WINDOW */    if ((srcPictSpecs == NULL) || (srcPictSpecs[0] == NULL) || (srcPictSpecs[0][0].name[0] == 0)) {    err = paramErr;    goto bail;  }  /* Create a GWorld to draw the uncompressed tiles into */  fsSpec = srcPictSpecs[0][0];  err = GetGraphicsImporterForFile(&amp;fsSpec, &amp;theImporter);  if (err != noErr)    goto bail;  err = GraphicsImportGetBoundsRect(theImporter, &amp;pictRect);  if (err != noErr)    goto bail;  CloseComponent(theImporter);  theImporter = NULL;  tileWidth   = (pictRect.right  - pictRect.left) / tilesH;  tileHeight  = (pictRect.bottom - pictRect.top ) / tilesV;  MacSetRect(&amp;tileRect, 0, 0, tileWidth, tileHeight);  err = NewGWorld(&amp;gw, tileDepth, &amp;tileRect, NULL, NULL, 0L);  if (err != noErr)    goto bail;    /* Debugging or progress window */  #if USE_TILE_DISPLAY_WINDOW    MacSetRect(&amp;tileRect, 0, 0, tileWidth, tileHeight);    MacOffsetRect(&amp;tileRect, 20, 100);    myWindow = NewCWindow(NULL, &amp;tileRect, &quot;\pUncompressed tiles&quot;, true, noGrowDocProc, (WindowPtr)-1L, true, 0);    MacOffsetRect(&amp;tileRect, -20, -100);  #endif /* USE_TILE_DISPLAY_WINDOW */  /* Create a new movie to contain the compressed tiles as video samples */  err = CreateMovieFile(dstTileSpec, FOUR_CHAR_CODE('TVOD'), smCurrentScript, kCreateMovieFlags, &amp;myResRefNum, &amp;movie);  if (err != noErr)    goto bail;  myTrack = NewMovieTrack(movie, tileWidth &lt;&lt; 16, tileHeight &lt;&lt; 16, kNoVolume);    myMedia = NewTrackMedia(myTrack, VideoMediaType, 600, NULL, 0);  if ((myTrack == NULL) || (myMedia == NULL))    goto bail;    /* Dice the picture into pieces, compress them, and add the compressed tiles as video samples to the movie */  myImageDesc = (ImageDescriptionHandle)MyNewHandleClear(4); /* this is resized and filled in below by FCompressImage */  if (myImageDesc == NULL)    goto bail;  pm = GetGWorldPixMap(gw);  LockPixels(pm);  err = GetMaxCompressionSize(pm, &amp;tileRect, tileDepth, tileQuality, tileCodec, (CompressorComponent)anyCodec, &amp;myFrameSize);  UnlockPixels(pm);  if (err != noErr)    goto bail;  myData = MyNewHandle(myFrameSize);  if (myData == NULL)    goto bail;  BeginMediaEdits(myMedia);    for (k = 0; k &lt; numPicts; k++) {    fsSpec = srcPictSpecs[0][k];    err = GetGraphicsImporterForFile(&amp;fsSpec, &amp;theImporter);    if (err != noErr)      goto bail;    for (j = 0; j &lt; tilesV; j++) {      for (i = 0; i &lt; tilesH; i++) {        /* Offset to the proper subrect for this tile */        drawRect = pictRect;        MacOffsetRect(&amp;drawRect, -i * tileWidth, -j * tileHeight);                 /* Draw the picture into the window we've created */        #if USE_TILE_DISPLAY_WINDOW          if (myWindow != NULL) {            GraphicsImportSetGWorld(theImporter, (CGrafPtr)myWindow, NULL);            GraphicsImportSetBoundsRect(theImporter, &amp;drawRect);            GraphicsImportDraw(theImporter);          }        #endif /* USE_TILE_DISPLAY_WINDOW */        /* Draw the picture into the uncompressed tile GWorld */        GraphicsImportSetGWorld(theImporter, gw, NULL);        GraphicsImportSetBoundsRect(theImporter, &amp;drawRect);        GraphicsImportDraw(theImporter);                /* Compress the tile and add it tile to the movie */        HLock(myData);        myDataPtr = *myData;        LockPixels(pm);        err = FCompressImage(pm, &amp;tileRect, tileDepth, tileQuality, tileCodec, (CompressorComponent)anyCodec,          NULL, 0, 0, NULL, NULL, myImageDesc, myDataPtr        );        UnlockPixels(pm);        if (err != noErr)          goto bail;        err = AddMediaSample(myMedia, myData, 0, (**myImageDesc).dataSize, dstTileDuration,          (SampleDescriptionHandle)myImageDesc, 1L, 0, NULL        );        if (err != noErr)          goto bail;      }    }    CloseComponent(theImporter);    theImporter = NULL;  }    EndMediaEdits(myMedia);  DisposeHandle(myData);  myData = NULL;    /* add the media to the track, at time 0 */  err = InsertMediaIntoTrack(myTrack, 0, 0, GetMediaDuration(myMedia), fixed1);  if (err != noErr)    goto bail;  /* add the movie resource */  err = AddMovieResource(movie, myResRefNum, &amp;myResID, NULL);  bail:  if (theImporter != NULL)  CloseComponent(theImporter);  if (gw          != NULL)  DisposeGWorld(gw);  if (myResRefNum != -1)    CloseMovieFile(myResRefNum);  if (myData      != NULL)  DisposeHandle(myData);  if (myImageDesc != NULL)  DisposeHandle((Handle)myImageDesc);  if (movie       != NULL)  DisposeMovie(movie);  #if USE_TILE_DISPLAY_WINDOW    if (myWindow!= NULL)  DisposeWindow(myWindow);  #endif /* USE_TILE_DISPLAY_WINDOW */  return(err);}/******************************************************************************* * CreateTileMovieFromOnePictFile * *  Create a QuickTime movie containing tiles from the specified image file. *******************************************************************************/static OSErrCreateTileMovieFromOnePictFile(  FSSpec      *srcPictSpec,  CodecType    tileCodec,  CodecQ      tileQuality,  long      tilesH,  long      tilesV,  short      tileDepth,  FSSpec      *dstTileSpec){  FSSpec  *specArray = srcPictSpec;  return(CreateTileMovieFromPictFiles(1, &amp;specArray, tileCodec, tileQuality, tilesH, tilesV, tileDepth, dstTileSpec));}#endif //0#pragma mark -#pragma mark ### Cylindrical API ####pragma mark -/******************************************************************************** ******************************************************************************** ******************************************************************************** ***    API ******************************************************************************** ******************************************************************************** ********************************************************************************//******************************************************************************* * VRMovieToQTVRCylPano1x0 * Create a single-node panoramic QTVR movie from the specified tile movie(s). * * NOTE: This function builds a movie that conforms to version 1.0 of the QuickTime VR file format. * * The newly-created movie contains references to the original tile movie, not the actual movie data. * We do this because we assume that the caller will flatten the movie into a third movie, which will * contain the movie data. Also, the interim file is much smaller than it would be if we copied the data, * thus saving time and disk space. *******************************************************************************/OSErrVRMovieToQTVRCylPano1x0(  MakeQTVRParams  *qtvrParams,  /* Parameters used to create the movie */  FSSpec      *srcTileSpec,  /* Cylindrical tile movie for the panoramic image */  FSSpec      *srcHSTileSpec,  /* Cylindrical tile movie for the hot spot image */  FSSpec      *dstMovieSpec  /* Destination movie */){  PanoramaDescriptionHandle  myPanoDesc      = NULL;  PanoSampleHeaderAtomHandle  myPanoHeader      = NULL;  HotSpotTableAtomHandle    myHotSpotTable    = NULL;  StringTableAtomHandle    myStringTable    = NULL;  short            myResRefNum      = -1;  short            myResID        = movieInDataForkResID;  short            myHSResRefNum    = -1;  short            myTilResRefNum    = -1;  short            myHSTilResRefNum  = -1;  Movie            myMovie        = NULL;  Movie            myTileMovie      = NULL;  Movie            myHSTileMovie    = NULL;  Track            myPanoTrack;  Media            myPanoMedia;  Track            myImageTrack;  Track            myHSImageTrack;  Fixed            myTheta;  UInt16            myIndex;  long            myTrackWidth, myTrackHeight;  ComponentResult        err          = noErr;    /*   * create a new movie   */  /* create a movie file for the destination movie */  err = CreateMovieFile(dstMovieSpec, FOUR_CHAR_CODE('TVOD'), smCurrentScript, kCreateMovieFlags, &amp;myResRefNum, &amp;myMovie);  if (err != noErr)    goto bail;  /*   * copy the video track from the tile movie to the new movie; this is the &quot;scene track&quot;   */  /* open the tile movie file */  err = ImportFirstVideoTrackFromFile(srcTileSpec, myMovie, qtvrParams-&gt;trackDuration, 0, &amp;myTrackWidth, &amp;myTrackHeight, &amp;myImageTrack);  if (err != noErr)    goto bail;    /*   * copy the hot spot image track from the tile movie to the new movie   */  if ((srcHSTileSpec != NULL) &amp;&amp; (srcHSTileSpec-&gt;name[0] != 0)) {    err = ImportFirstVideoTrackFromFile(srcHSTileSpec, myMovie, qtvrParams-&gt;trackDuration, 0, &amp;myTrackWidth, &amp;myTrackHeight, &amp;myHSImageTrack);    if (err != noErr)      goto bail;  }    /*   * create a panorama track and add it to the movie   */    /* create a panorama track and media */  myPanoTrack = NewMovieTrack(myMovie, qtvrParams-&gt;windowWidth &lt;&lt; 16, qtvrParams-&gt;windowHeight &lt;&lt; 16, 0);  myPanoMedia = NewTrackMedia(myPanoTrack, kQTVROldPanoType, kQTVRStandardTimeScale, NULL, 0);  if (((err = GetMoviesError()) != noErr) || (myPanoTrack == NULL) || (myPanoMedia == NULL))    goto bail;  /* create a panorama sample description */   myPanoDesc = (PanoramaDescriptionHandle)MyNewHandleClear(sizeof(PanoramaDescription));  if (myPanoDesc == NULL)    goto bail;  /* fill in the panorama sample description;   * all the data in this sample description that follows the first 4 long words must be in big-endian format;   * the first four long words are used by AddMediaSample and must therefore be in native-endian format   */  (**myPanoDesc).size          = sizeof(PanoramaDescription);  (**myPanoDesc).type          = kPanDescType;  (**myPanoDesc).reserved1      = 0L;  (**myPanoDesc).reserved2      = 0L;    (**myPanoDesc).majorVersion      = EndianU16_NtoB(0);  (**myPanoDesc).minorVersion      = EndianU16_NtoB(0);  (**myPanoDesc).sceneTrackID      = EndianU32_NtoB(GetTrackID(myImageTrack));  (**myPanoDesc).loResSceneTrackID  = EndianU32_NtoB(0L);    /* no lo-res video track */    for (myIndex = 1; myIndex &lt; 6; myIndex++) {    (**myPanoDesc).reserved3[myIndex] = EndianU32_NtoB(0L);    (**myPanoDesc).reserved4[myIndex] = EndianU32_NtoB(0L);  }    (**myPanoDesc).hotSpotTrackID    = EndianU32_NtoB(GetTrackID(myHSImageTrack));  (**myPanoDesc).loResHotSpotTrackID  = EndianU32_NtoB(0L);  /* no lo-res hot spot track */  myTheta = 180.0 * (atan((myTrackWidth * qtvrParams-&gt;tilesH) * D_PI / (myTrackHeight * qtvrParams-&gt;tilesV))) / D_PI * 65536.0;    (**myPanoDesc).hPanStart      = EndianF32NtoFixedB(qtvrParams-&gt;minPan);  (**myPanoDesc).hPanEnd        = EndianF32NtoFixedB(qtvrParams-&gt;maxPan);  (**myPanoDesc).vPanTop        = EndianF32NtoFixedB(qtvrParams-&gt;maxTilt);  (**myPanoDesc).vPanBottom      = EndianF32NtoFixedB(qtvrParams-&gt;minTilt);  (**myPanoDesc).minimumZoom      = EndianF32NtoFixedB(qtvrParams-&gt;minFieldOfView);  (**myPanoDesc).maximumZoom      = EndianF32NtoFixedB(qtvrParams-&gt;maxFieldOfView);    (**myPanoDesc).sceneSizeX      = EndianU32_NtoB((long)(myTrackWidth  * qtvrParams-&gt;tilesH));  (**myPanoDesc).sceneSizeY      = EndianU32_NtoB((long)(myTrackHeight * qtvrParams-&gt;tilesV));  (**myPanoDesc).numFrames      = EndianU32_NtoB((long)qtvrParams-&gt;tilesV);  (**myPanoDesc).sceneNumFramesX    = EndianU16_NtoB(qtvrParams-&gt;tilesH);  (**myPanoDesc).sceneNumFramesY    = EndianU16_NtoB(qtvrParams-&gt;tilesV);  (**myPanoDesc).sceneColorDepth    = EndianU16_NtoB(32);    (**myPanoDesc).hotSpotSizeX      = EndianU32_NtoB((long)(myTrackWidth  * qtvrParams-&gt;tilesH));  (**myPanoDesc).hotSpotSizeY      = EndianU32_NtoB((long)(myTrackHeight * qtvrParams-&gt;tilesV));  (**myPanoDesc).hotSpotNumFramesX  = EndianU16_NtoB(qtvrParams-&gt;tilesH);  (**myPanoDesc).hotSpotNumFramesY  = EndianU16_NtoB(qtvrParams-&gt;tilesV);  (**myPanoDesc).hotSpotColorDepth  = EndianU16_NtoB(8);  /* create a panorama header atom;   * the data in this atom (which is *not* a QTAtom) must be in big-endian format   */  myPanoHeader = (PanoSampleHeaderAtomHandle)MyNewHandleClear(sizeof(PanoSampleHeaderAtom));  if (myPanoHeader == NULL)    goto bail;      (**myPanoHeader).size        = EndianU32_NtoB(sizeof(PanoSampleHeaderAtom));  (**myPanoHeader).type        = EndianU32_NtoB(kPanHeaderType);  (**myPanoHeader).nodeID        = EndianU32_NtoB(0L);  /* set the default pan, tilt, and zoom */  (**myPanoHeader).defHPan      = EndianF32NtoFixedB(qtvrParams-&gt;defaultPan);  (**myPanoHeader).defVPan      = EndianF32NtoFixedB(qtvrParams-&gt;defaultTilt);  (**myPanoHeader).defZoom      = EndianF32NtoFixedB(qtvrParams-&gt;defaultFieldOfView);  /* set constraints for this node; use 0 for the default constraints */  (**myPanoHeader).minHPan      = EndianS32_NtoB(0L);  (**myPanoHeader).minVPan      = EndianS32_NtoB(0L);  (**myPanoHeader).maxHPan      = EndianS32_NtoB(0L);  (**myPanoHeader).maxVPan      = EndianS32_NtoB(0L);  (**myPanoHeader).maxZoom      = EndianS32_NtoB(0L);  (**myPanoHeader).nameStrOffset    = EndianU32_NtoB(0L);    /* no name or comment */  (**myPanoHeader).commentStrOffset  = EndianU32_NtoB(0L);  /* create a string table atom;   * the data in this atom (which is *not* a QTAtom) must be in big-endian format   */  myStringTable = (StringTableAtomHandle)MyNewHandleClear(sizeof(StringTableAtom));  if (myStringTable == NULL)    goto bail;      (**myStringTable).size        = EndianU32_NtoB(sizeof(StringTableAtom));  (**myStringTable).type        = EndianU32_NtoB(kStringTableType);  (**myStringTable).bunchOstrings[0]  = EndianU32_NtoB(0);  /* create a hot spot table atom and expand the string table atom to include the   * hot spot names and comments   */  myHotSpotTable = MakeQTVRHotSpot1x0(myStringTable);  /* append the hot spot table atom and the string table atom to the panorama header atom   * [left as an exercise for the reader]   */    /* Add the media sample to the panorama track */  BeginMediaEdits(myPanoMedia);  err = AddMediaSample(myPanoMedia, (Handle)myPanoHeader, 0, GetHandleSize((Handle)myPanoHeader), qtvrParams-&gt;trackDuration, (SampleDescriptionHandle)myPanoDesc, 1, 0, NULL);  if (err != noErr)    goto bail;  EndMediaEdits(myPanoMedia);  err = InsertMediaIntoTrack(myPanoTrack, 0, 0, qtvrParams-&gt;trackDuration, fixed1);    /* Add a user data item that identifies the QTVR movie controller */  err = SetQTControllerType(myMovie, kQTVROldPanoType);  if (err != noErr)    goto bail;      /* Add the movie resource to the panorama movie */  err = AddMovieResource(myMovie, myResRefNum, &amp;myResID, NULL);  bail:  if (myPanoDesc       != NULL)  DisposeHandle((Handle)myPanoDesc);    if (myPanoHeader     != NULL)  DisposeHandle((Handle)myPanoHeader);    if (myResRefNum      != -1)    CloseMovieFile(myResRefNum);    if (myHSResRefNum    != -1)    CloseMovieFile(myHSResRefNum);    if (myMovie          != NULL)  DisposeMovie(myMovie);      if (myTilResRefNum   != -1)    CloseMovieFile(myTilResRefNum);    if (myHSTilResRefNum != -1)    CloseMovieFile(myHSTilResRefNum);  if (myTileMovie      != NULL)  DisposeMovie(myTileMovie);  if (myHSTileMovie    != NULL)  DisposeMovie(myHSTileMovie);      return(err);}/******************************************************************************* * VRMovieToQTVRCylPano2 * Create a single-node panoramic QTVR movie from the specified tile movie(s). * * NOTE: This function builds a movie that conforms to version 2.0 of the QuickTime VR file format. * * The newly-created movie contains references to the original tile movie, not the actual movie data. * We do this because we assume that the caller will flatten the movie into a third movie, which will * contain the movie data. Also, the interim file is much smaller than it would be if we copied the data, * thus saving time and disk space. *******************************************************************************/static OSErrVRMovieToQTVRCylPano2(  MakeQTVRParams  *qtvrParams,  /* Parameters used to create the movie */  long      panoType,    /* Parameters used to create the movie */  FSSpec      *srcTileSpec,  /* Cylindrical tile movie for the panoramic image */  FSSpec      *srcHSTileSpec,  /* Cylindrical tile movie for the hot spot image */  FSSpec      *srcFSTileSpec,  /* Cylindrical tile movie for the fast start image */  FSSpec      *dstMovieSpec  /* Destination movie */){  short        myResRefNum      = -1;  Movie        tmpMovie      = NULL;  Track        myQTVRTrack;  Track        myPanoTrack;  ComponentResult    err          = noErr;  FSSpec        tmpSpec;    /* Create a movie file for the destination movie */  MakeTempFSSpec(dstMovieSpec, &quot;.MV~&quot;, &amp;tmpSpec);  err = CreateMovieFile(&amp;tmpSpec, FOUR_CHAR_CODE('TVOD'), smCurrentScript, kCreateMovieFlags, &amp;myResRefNum, &amp;tmpMovie);  if (err != noErr)    goto bail;  /* Create the QTVR movie track and media */  err = CreateQTVRTrack(qtvrParams, qtvrParams-&gt;trackDuration, tmpMovie, &amp;myQTVRTrack);  if (err != noErr)    goto bail;    /* Create panorama track and media, and add them to the movie */  err = CreatePanoTrackFromMovies(srcTileSpec, srcHSTileSpec, srcFSTileSpec,    qtvrParams, panoType, tmpMovie, myQTVRTrack,    &amp;myPanoTrack  );  if (err != noErr)    goto bail;      /* Add a user data item that identifies the QTVR movie controller */  err = SetQTControllerType(tmpMovie, kQTVRQTVRType);  if (err != noErr)    goto bail;      /* Create the final, flattened movie, from the temporary file into a new movie file;   * put the movie resource first so that FastStart is possible   */  err = FlattenQTVRMovie(tmpMovie, dstMovieSpec);  bail:  if (myResRefNum != -1)    CloseMovieFile(myResRefNum);  if (tmpMovie    != NULL)  DisposeMovie(tmpMovie);  DeleteMovieFile(&amp;tmpSpec);      return(err);}/******************************************************************************* * VRMovieToQTVRCylPano2v0 * Create a single-node panoramic QTVR movie from the specified tile movie(s). * * NOTE: This function builds a movie that conforms to version 2.0 of the QuickTime VR file format. * * The newly-created movie contains references to the original tile movie, not the actual movie data. * We do this because we assume that the caller will flatten the movie into a third movie, which will * contain the movie data. Also, the interim file is much smaller than it would be if we copied the data, * thus saving time and disk space. *******************************************************************************/OSErrVRMovieToQTVRCylPano2v0(  MakeQTVRParams  *qtvrParams,  /* Parameters used to create the movie */  FSSpec      *srcTileSpec,  /* Cylindrical tile movie for the panoramic image */  FSSpec      *srcHSTileSpec,  /* Cylindrical tile movie for the hot spot image */  FSSpec      *srcFSTileSpec,  /* Cylindrical tile movie for the fast start image */  FSSpec      *dstMovieSpec  /* Destination movie */){  return(VRMovieToQTVRCylPano2(qtvrParams, kQTVRCylindricalVersion2v, srcTileSpec, srcHSTileSpec, srcFSTileSpec, dstMovieSpec));}/******************************************************************************* * VRMovieToQTVRCylPano2h0 * *  Create a single-node QuickTime VR panoramic movie from the specified image file. *******************************************************************************/OSErrVRMovieToQTVRCylPano2h0(  MakeQTVRParams  *qtvrParams,  /* Parameters used to create the movie */  FSSpec      *srcTileSpec,  /* Cylindrical tile movie for the panoramic image */  FSSpec      *srcHSTileSpec,  /* Cylindrical tile movie for the hot spot image */  FSSpec      *srcFSTileSpec,  /* Cylindrical tile movie for the fast start image */  FSSpec      *dstMovieSpec  /* Destination movie */){  return(VRMovieToQTVRCylPano2(qtvrParams, kQTVRCylindricalVersion2h, srcTileSpec, srcHSTileSpec, srcFSTileSpec, dstMovieSpec));}/******************************************************************************* * VRPictToQTVRCylPano2 * *  Create a single-node QuickTime VR panoramic movie from the specified image file. *******************************************************************************/static OSErrVRPictToQTVRCylPano2(  MakeQTVRParams  *qtvrParams,    /* Parameters used to create the movie */  long      panoType,      /* Version 1, or version 2 (recommended) */  FSSpec      *srcPictSpec,    /* Source   image */  FSSpec      *srcHSPictSpec,    /* Hot spot image */  FSSpec      *srcFSPictSpec,    /* Fast start image */  FSSpec      *dstMovieSpec    /* Destination movie */){  short              myResRefNum      = -1;  Movie              tmpMovie      = NULL;  Track              myQTVRTrack;  Track              myPanoTrack;  ComponentResult          err          = noErr;  FSSpec              *srcH, *hsH, *fsH;  FSSpec              tmpSpec;    /* Create a movie file for the destination movie */  MakeTempFSSpec(dstMovieSpec, &quot;.MV~&quot;, &amp;tmpSpec);  err = CreateMovieFile(&amp;tmpSpec, FOUR_CHAR_CODE('TVOD'), smCurrentScript, kCreateMovieFlags, &amp;myResRefNum, &amp;tmpMovie);  if (err != noErr)    goto bail;  /* Create the QTVR movie track and media */  err = CreateQTVRTrack(qtvrParams, qtvrParams-&gt;trackDuration, tmpMovie, &amp;myQTVRTrack);  if (err != noErr)    goto bail;    /* Create panorama track and media, and add them to the movie */  srcH = srcPictSpec; hsH = srcHSPictSpec; fsH = srcFSPictSpec;  err = CreatePanoTrackFromPicts(1, &amp;srcH, (hsH ? &amp;hsH : NULL), (fsH ? &amp;fsH : NULL),    panoType, qtvrParams, qtvrParams-&gt;trackDuration, tmpMovie, myQTVRTrack,    &amp;myPanoTrack  );  if (err != noErr)    goto bail;      /* Add a user data item that identifies the QTVR movie controller */  err = SetQTControllerType(tmpMovie, kQTVRQTVRType);  if (err != noErr)    goto bail;      /* Create the final, flattened movie, from the temporary file into a new movie file;   * put the movie resource first so that FastStart is possible   */  err = FlattenQTVRMovie(tmpMovie, dstMovieSpec);  bail:  if (myResRefNum != -1)    CloseMovieFile(myResRefNum);  if (tmpMovie     != NULL)  DisposeMovie(tmpMovie);  DeleteMovieFile(&amp;tmpSpec);  return(err);}/******************************************************************************* * VRPictToQTVRCylPano2v0 *******************************************************************************/OSErrVRPictToQTVRCylPano2v0(  MakeQTVRParams  *qtvrParams,  /* Parameters used to create the movie */  FSSpec      *srcPictSpec,  /* Source   image, rotated 90 degrees counter-clockwise (classic orientation) */  FSSpec      *srcHSPictSpec,  /* Hot spot image, rotated 90 degrees counter-clockwise (classic orientation) */  FSSpec      *srcFSPictSpec,  /* Fast start image, rotated 90 degrees counter-clockwise (classic orientation) */  FSSpec      *dstMovieSpec  /* Destination movie */){  return(VRPictToQTVRCylPano2(qtvrParams, kQTVRCylindricalVersion2v, srcPictSpec, srcHSPictSpec, srcFSPictSpec, dstMovieSpec));}/******************************************************************************* * VRPictToQTVRCylPano2h0 *******************************************************************************/OSErrVRPictToQTVRCylPano2h0(  MakeQTVRParams  *qtvrParams,  /* Parameters used to create the movie */  FSSpec      *srcPictSpec,  /* Source   image, non-rotated (modern orientation) */  FSSpec      *srcHSPictSpec,  /* Hot spot image, non-rotated (modern orientation)) */  FSSpec      *srcFSPictSpec,  /* Fast start image, non-rotated (modern orientation)) */  FSSpec      *dstMovieSpec  /* Destination movie */){  return(VRPictToQTVRCylPano2(qtvrParams, kQTVRCylindricalVersion2h, srcPictSpec, srcHSPictSpec, srcFSPictSpec, dstMovieSpec));}/******************************************************************************* * VRGWorldToQTVRCylPano2 * *  Create a single-node QuickTime VR panoramic movie from the specified image file. *******************************************************************************/static OSErrVRGWorldToQTVRCylPano2(  MakeQTVRParams  *qtvrParams,    /* Parameters used to create the movie */  long      panoType,      /* Version 1, or version 2 (recommended) */  GWorldPtr    srcGW,        /* Source GWorld */  GWorldPtr    srcHSGW,      /* Source hot spot GWorld */  GWorldPtr    srcFSGW,      /* Source fast start GWorld */  FSSpec      *dstMovieSpec    /* Destination movie */){  short              myResRefNum      = -1;  Movie              tmpMovie      = NULL;  Track              myQTVRTrack;  Track              myPanoTrack;  ComponentResult          err;  GWorldPtr            srGW, hsGW, fsGW;  FSSpec              tmpSpec;    /* Create a movie file for the destination movie */  MakeTempFSSpec(dstMovieSpec, &quot;.MV~&quot;, &amp;tmpSpec);  err = CreateMovieFile(&amp;tmpSpec, FOUR_CHAR_CODE('TVOD'), smCurrentScript, kCreateMovieFlags, &amp;myResRefNum, &amp;tmpMovie);  if (err != noErr)    goto bail;  /* Create the QTVR movie track and media */  err = CreateQTVRTrack(qtvrParams, qtvrParams-&gt;trackDuration, tmpMovie, &amp;myQTVRTrack);  if (err != noErr)    goto bail;    /* Create panorama track and media, and add them to the movie */  srGW = srcGW; hsGW = srcHSGW; fsGW = srcFSGW;  err = CreatePanoTrackFromGWorlds(1, &amp;srcGW, (hsGW ? &amp;hsGW : NULL), (fsGW ? &amp;fsGW : NULL),    panoType, qtvrParams, qtvrParams-&gt;trackDuration, tmpMovie, myQTVRTrack,    &amp;myPanoTrack  );  if (err != noErr)    goto bail;      /* Add a user data item that identifies the QTVR movie controller */  err = SetQTControllerType(tmpMovie, kQTVRQTVRType);  if (err != noErr)    goto bail;      /* Create the final, flattened movie, from the temporary file into a new movie file;   * put the movie resource first so that FastStart is possible   */  err = FlattenQTVRMovie(tmpMovie, dstMovieSpec);  bail:  if (myResRefNum != -1)    CloseMovieFile(myResRefNum);  if (tmpMovie     != NULL)  DisposeMovie(tmpMovie);  DeleteMovieFile(&amp;tmpSpec);  return(err);}/******************************************************************************* * VRGWorldToQTVRCylPano2v0 *******************************************************************************/OSErrVRGWorldToQTVRCylPano2v0(  MakeQTVRParams  *qtvrParams,  /* Parameters used to create the movie */  GWorldPtr    srcGW,      /* Source GWorld, rotated 90 degrees counter-clockwise (classic orientation) */  GWorldPtr    srcHSGW,    /* Source hot spot GWorld, rotated 90 degrees counter-clockwise (classic orientation) */  GWorldPtr    srcFSGW,    /* Source fast start GWorld, rotated 90 degrees counter-clockwise (classic orientation) */  FSSpec      *dstMovieSpec  /* Destination movie */){  return(VRGWorldToQTVRCylPano2(qtvrParams, kQTVRCylindricalVersion2v, srcGW, srcHSGW, srcFSGW, dstMovieSpec));}/******************************************************************************* * VRGWorldToQTVRCylPano2h0 *******************************************************************************/OSErrVRGWorldToQTVRCylPano2h0(  MakeQTVRParams  *qtvrParams,  /* Parameters used to create the movie */  GWorldPtr    srcGW,      /* Source GWorld, non-rotated (modern orientation) */  GWorldPtr    srcHSGW,    /* Source hot spot GWorld, non-rotated (modern orientation) */  GWorldPtr    srcFSGW,    /* Source fast start GWorld, non-rotated (modern orientation) */  FSSpec      *dstMovieSpec  /* Destination movie */){  return(VRGWorldToQTVRCylPano2(qtvrParams, kQTVRCylindricalVersion2h, srcGW, srcHSGW, srcFSGW, dstMovieSpec));}#pragma mark -#pragma mark ### Cubic API ####pragma mark -/******************************************************************************* * VRMovieToQTVRCubicPano * *  Create a single-node cubic panoramic QTVR movie from the specified 6-frame movie. *******************************************************************************/OSErrVRMovieToQTVRCubicPano(  MakeQTVRParams  *qtvrParams,    /* Parameters used to create the movie */  FSSpec      *srcFramesSpec,    /* Source movie with the panorama faces */  FSSpec      *srcHSFramesSpec,  /* Source movie with the hot spot faces */  FSSpec      *srcFSFramesSpec,  /* Source movie with the fast start faces */  FSSpec      *dstMovieSpec    /* Destination movie */){  FSSpec        tmpSpec;  short        myResRefNum      = -1;  Movie        tmpMovie        = NULL;  Track        tmpQTVRTrack;  Track        tmpPanoTrack;  ComponentResult    err;    /* Create a temporary version of the panorama movie file,   * located in the same directory as the destination panorama movie file   */  MakeTempFSSpec(dstMovieSpec, &quot;.MV~&quot;, &amp;tmpSpec);  err = CreateMovieFile(&amp;tmpSpec, FOUR_CHAR_CODE('TVOD'), smCurrentScript, kCreateMovieFlags, &amp;myResRefNum, &amp;tmpMovie);  if (err != noErr)    goto bail;  /* Create the QTVR movie track and media */  err = CreateQTVRTrack(qtvrParams, qtvrParams-&gt;trackDuration, tmpMovie, &amp;tmpQTVRTrack);  if (err != noErr)    goto bail;    /* Create panorama track and media, and add them to the movie */  err = CreatePanoTrackFromMovies(srcFramesSpec, srcHSFramesSpec, srcFSFramesSpec,    qtvrParams, kQTVRCubicVersion1, tmpMovie, tmpQTVRTrack,    &amp;tmpPanoTrack  );  if (err != noErr)    goto bail;      /* Add a user data item that identifies the QTVR movie controller */  err = SetQTControllerType(tmpMovie, kQTVRQTVRType);  if (err != noErr)    goto bail;      /* Create the final, flattened movie, from the temporary file into a new movie file;   * put the movie resource first so that FastStart is possible   */  err = FlattenQTVRMovie(tmpMovie, dstMovieSpec);bail:  if (myResRefNum != -1)    CloseMovieFile(myResRefNum);  if (tmpMovie     != NULL)  DisposeMovie(tmpMovie);  DeleteMovieFile(&amp;tmpSpec);    return(err);}/******************************************************************************** * VRPictsToQTVRCubicPano * * This converts a set of 6 picture files to a cubic QuickTime VR panorama movie. * * This implements tiling of the faces, but the face dimensions must be appropriately divisible: *    (width  - tilesH + 1) / tilesH = integer *    (height - tilesV + 1) / tilesV = integer *  e.g. {dim=512,tiles=1}, {dim=511,tiles=2}, {dim=510,tiles=3} ********************************************************************************/OSErrVRPictsToQTVRCubicPano(  MakeQTVRParams  *qtvrParams,    /* Parameters used to create the movie */  FSSpec      **srcPictSpecs,    /* Source     images */  FSSpec      **srcHSPictSpecs,  /* Hot spot   images */  FSSpec      **srcFSPictSpecs,  /* Fast start images */  FSSpec      *dstMovieSpec    /* Destination movie */){  FSSpec            tmpSpec;  short            tmpRefNum      = -1;  Movie            tmpMovie      = NULL;  Track            qtvrTrack      = NULL;  Track            panoTrack      = NULL;  ComponentResult        err;    /* Create a temporary version of the panorama movie file,   * located in the same directory as the destination panorama movie file   */  MakeTempFSSpec(dstMovieSpec, &quot;.MV~&quot;, &amp;tmpSpec);  err = CreateMovieFile(&amp;tmpSpec, FOUR_CHAR_CODE('TVOD'), smCurrentScript, kCreateMovieFlags, &amp;tmpRefNum, &amp;tmpMovie);  if (err != noErr)    goto bail;  /* Create the QTVR movie track and media */  err = CreateQTVRTrack(qtvrParams, qtvrParams-&gt;trackDuration, tmpMovie, &amp;qtvrTrack);  if (err != noErr)    goto bail;    /*  Create panorama track and media, and add them to the movie */  err = CreatePanoTrackFromPicts(6, srcPictSpecs, srcHSPictSpecs, srcFSPictSpecs, kQTVRCubicVersion1,    qtvrParams, qtvrParams-&gt;trackDuration, tmpMovie, qtvrTrack, &amp;panoTrack  );  if (err != noErr)    goto bail;      /* Add a user data item that identifies the QTVR movie controller */  err = SetQTControllerType(tmpMovie, kQTVRQTVRType);  if (err != noErr)    goto bail;      /* Create the final, flattened movie, from the temporary file into a new movie file;   * put the movie resource first so that FastStart is possible   */  err = FlattenQTVRMovie(tmpMovie, dstMovieSpec);bail:  if (tmpRefNum != -1)  CloseMovieFile(tmpRefNum);  if (tmpMovie  != NULL)  DisposeMovie(tmpMovie);  DeleteMovieFile(&amp;tmpSpec);    return(err);}/******************************************************************************** * VRGWorldsToQTVRCubicPano * *  Given 6 GWorlds (and possible 6 hotspot GWorlds), create a cubic panorama movie. * *  This implements tiling of the faces, but the face dimensions must be appropriately divisible: *    (width  - tilesH + 1) / tilesH = integer *    (height - tilesV + 1) / tilesV = integer *  e.g. {dim=512,tiles=1}, {dim=511,tiles=2}, {dim=510,tiles=3} ********************************************************************************/OSErrVRGWorldsToQTVRCubicPano(  MakeQTVRParams  *qtvrParams,  /* Parameters used to create the movie */  GWorldPtr    *srcGWs,    /* 6 Source GWorlds - in standard order */  GWorldPtr    *srcHSGWs,    /* 6 Source hot spot GWorlds - in standard order */  GWorldPtr    *srcFSGWs,    /* 6 Source fast start GWorlds - in standard order */  FSSpec      *dstMovieSpec  /* Destination movie */){  FSSpec            tmpSpec;  short            tmpRefNum      = -1;  Movie            tmpMovie      = NULL;  Track            qtvrTrack      = NULL;  Track            panoTrack      = NULL;  ComponentResult        err;    /* Create a temporary version of the panorama movie file,   * located in the same directory as the destination panorama movie file   */  MakeTempFSSpec(dstMovieSpec, &quot;.MV~&quot;, &amp;tmpSpec);  err = CreateMovieFile(&amp;tmpSpec, FOUR_CHAR_CODE('TVOD'), smCurrentScript, kCreateMovieFlags, &amp;tmpRefNum, &amp;tmpMovie);  if (err != noErr)    goto bail;  /* Create the QTVR movie track and media */  err = CreateQTVRTrack(qtvrParams, qtvrParams-&gt;trackDuration, tmpMovie, &amp;qtvrTrack);  if (err != noErr)    goto bail;    /*  Create panorama track and media, and add them to the movie */  err = CreatePanoTrackFromGWorlds(6, srcGWs, srcHSGWs, srcFSGWs, kQTVRCubicVersion1,    qtvrParams, qtvrParams-&gt;trackDuration, tmpMovie, qtvrTrack, &amp;panoTrack  );  if (err != noErr)    goto bail;      /* Add a user data item that identifies the QTVR movie controller */  err = SetQTControllerType(tmpMovie, kQTVRQTVRType);  if (err != noErr)    goto bail;      /* Create the final, flattened movie, from the temporary file into a new movie file;   * put the movie resource first so that FastStart is possible   */  err = FlattenQTVRMovie(tmpMovie, dstMovieSpec);bail:  if (tmpRefNum != -1)  CloseMovieFile(tmpRefNum);  if (tmpMovie  != NULL)  DisposeMovie(tmpMovie);  DeleteMovieFile(&amp;tmpSpec);    return(err);}</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/vrmakepano/listing16.html%3Fid%3DDTS10001027-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/vrmakepano/listing16.html%3Fid%3DDTS10001027-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/vrmakepano/listing16.html%3Fid%3DDTS10001027-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>