<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>MoreOSL - /MoreDebugging/MoreBBLog.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/Carbon/index.html">Carbon</a> &gt; <a href="../../samplecode/Carbon/idxInterapplicationCommunication-date.html">Interapplication Communication</a> &gt; <A HREF="javascript:location.replace('index.html');">MoreOSL</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">MoreOSL</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/MoreDebugging/MoreBBLog.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/MIB_Carbon.h</option>
<option value="listing2.html">/MoreAppearance/MoreAppearance.cp</option>
<option value="listing3.html">/MoreAppearance/MoreAppearance.h</option>
<option value="listing4.html">/MoreAppleEvents/MoreAEObjects.c</option>
<option value="listing5.html">/MoreAppleEvents/MoreAEObjects.h</option>
<option value="listing6.html">/MoreAppleEvents/MoreAppleEvents.cp</option>
<option value="listing7.html">/MoreAppleEvents/MoreAppleEvents.h</option>
<option value="listing8.html">/MoreDebugging/MoreBBLog.c</option>
<option value="listing9.html">/MoreDebugging/MoreBBLog.h</option>
<option value="listing10.html">/MoreDialogs/MoreDialogs.cp</option>
<option value="listing11.html">/MoreDialogs/MoreDialogs.h</option>
<option value="listing12.html">/MoreMemory/MoreMemory.c</option>
<option value="listing13.html">/MoreMemory/MoreMemory.h</option>
<option value="listing14.html">/MoreNavigation/MoreNavigation.c</option>
<option value="listing15.html">/MoreNavigation/MoreNavigation.h</option>
<option value="listing16.html">/MoreOSL/MoreOSL.c</option>
<option value="listing17.html">/MoreOSL/MoreOSL.h</option>
<option value="listing18.html">/MoreOSL/MoreOSLHelpers.c</option>
<option value="listing19.html">/MoreOSL/MoreOSLHelpers.h</option>
<option value="listing20.html">/MoreOSL/MoreOSLStringCompare.c</option>
<option value="listing21.html">/MoreOSL/MoreOSLStringCompare.h</option>
<option value="listing22.html">/MoreOSL/MoreOSLTokens.c</option>
<option value="listing23.html">/MoreOSL/MoreOSLTokens.h</option>
<option value="listing24.html">/MoreOSL/ReadMe.html</option>
<option value="listing25.html">/MoreOSL/TestMoreOSL/TestMoreOSL.c</option>
<option value="listing26.html">/MoreOSL/TestMoreOSL/TestMoreOSLTerminology.h</option>
<option value="listing27.html">/MoreOSL/TestMoreOSL/TestMoreOSLTerminology.r</option>
<option value="listing28.html">/MoreProcesses/MoreProcesses.cp</option>
<option value="listing29.html">/MoreProcesses/MoreProcesses.h</option>
<option value="listing30.html">/MoreQuickDraw/MoreQuickDraw.cp</option>
<option value="listing31.html">/MoreQuickDraw/MoreQuickDraw.h</option>
<option value="listing32.html">/MoreResources/MoreResources.c</option>
<option value="listing33.html">/MoreResources/MoreResources.h</option>
<option value="listing34.html">/MoreSetup.h</option>
<option value="listing35.html">/MoreSetup.r</option>
<option value="listing36.html">/MoreTextUtils/MoreTextUtils.cp</option>
<option value="listing37.html">/MoreTextUtils/MoreTextUtils.h</option>
<option value="listing38.html">/MoreToolbox/MoreToolbox.cp</option>
<option value="listing39.html">/MoreToolbox/MoreToolbox.h</option>
<option value="listing40.html">/MoreWindows/MoreWindows.cp</option>
<option value="listing41.html">/MoreWindows/MoreWindows.h</option></select>
				</p>
				</form>
				<p><strong><a href="MoreOSL.zip">Download Sample</a></strong> (&#147;MoreOSL.zip&#148;, 211.7K)<BR>
<strong><a href="MoreOSL.dmg">Download Sample</a></strong> (&#147;MoreOSL.dmg&#148;, 285.5K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*  File:    MoreBBLog.c  Contains:  Module to log debug traces to BBEdit.  Written by:  Quinn  Copyright:  Copyright &copy; 2000 by Apple Computer, Inc., all rights reserved.        You may incorporate this Apple sample source code into your program(s) without        restriction. This Apple sample source code has been provided &quot;AS IS&quot; and the        responsibility for its operation is yours. You are not permitted to redistribute        this Apple sample source code as &quot;Apple sample source code&quot; after having made        changes. If you're going to re-distribute the source, we require that you make        it clear in the source that the code was descended from Apple sample source        code, but that you've made changes.  Change History (most recent first):         &lt;4&gt;     27/3/00    Quinn   Add some more coercions from basic types to text.  Don't assert                                    if we can't AESend to BBEdit because BBEdit isn't running.         &lt;3&gt;     20/3/00    Quinn   Added coercions from built-in types to typeText to make                                    descriptor logging more useful.  Changed BBLogDesc to bypass                                    Str255 limit.         &lt;2&gt;      3/9/00    gaw     API changes for MoreAppleEvents         &lt;1&gt;      6/3/00    Quinn   First checked in.*//////////////////////////////////////////////////////////////////// MoreIsBetter Setup#include &quot;MoreSetup.h&quot;// Mac OS Interfaces#include &lt;AERegistry.h&gt;#include &lt;PLStringFuncs.h&gt;#include &lt;TextUtils.h&gt;#include &lt;Aliases.h&gt;// MIB Prototypes#include &quot;MoreAppleEvents.h&quot;#include &quot;MoreMemory.h&quot;// Our Prototypes#include &quot;MoreBBLog.h&quot;/////////////////////////////////////////////////////////////////#if MORE_DEBUG  static AECoercePtrUPP gBasicToTextCoerceUPP;      // -&gt; BasicToTextCoerceProc    static pascal OSErr BasicToTextCoerceProc(DescType typeCode, const void *dataPtr, Size dataSize, DescType toType, SInt32 handlerRefCon, AEDesc *result)    // A coercion handler to convert some basic Apple event types    // to text.  I added these types on demand, as I noticed that my    // MoreOSL test program needed them.  {    #pragma unused(handlerRefCon)    OSStatus        err;    ccntTokenRecPtr tokenData;    AEDesc          tokenAsText;    Handle          resultH;    AliasHandle   aliasH;    Str63      tmpStr63;    Str255      tmpStr;    Str255      tmpStr2;    FSSpecPtr     fssP;        MoreAssertQ(toType == typeText);    MoreAssertQ(result != nil);        MoreAENullDesc(result);        switch (typeCode) {      case typeNull:      case typeCurrentContainer:      case typeObjectBeingExamined:        // You'd think that the following assert would be useful, but it fires all the time.        // MoreAssertQ(dataPtr == nil);        MoreAssertQ(dataSize == 0);        err = AECreateDesc(typeText, &amp;typeCode, sizeof(typeCode), result);        break;              case typeToken:        MoreAssertQ(dataSize == sizeof(ccntTokenRecord));        MoreAssertQ(dataPtr  != nil);                // The data for a token is a ccntTokenRecord.  We extract the data,        // then coerce the embedded descriptor to text, then add a header        // that identifies the token as a token.                MoreAENullDesc(&amp;tokenAsText);        resultH = nil;                tokenData = (ccntTokenRecPtr) dataPtr;        err = AECoerceDesc(&amp;tokenData-&gt;token, typeText, &amp;tokenAsText);        if (err == noErr) {          err = MoreAECopyDescriptorDataToHandle(&amp;tokenAsText, &amp;resultH);        }        if (err == noErr) {          // Add the string &quot;'toke-'&quot; to the front of the handle.          (void) Munger(resultH, 0, nil, 0, &quot;'toke'-&quot;, 7);          err = MemError();        }        if (err == noErr) {          HLock(resultH);          err = AECreateDesc(typeText, *resultH, GetHandleSize(resultH), result);        }                MoreAEDisposeDesc(&amp;tokenAsText);        if (resultH != nil) {          DisposeHandle(resultH);          MoreAssertQ(MemError() == noErr);        }        break;            case typeAbsoluteOrdinal:        MoreAssertQ(dataSize == sizeof(DescType));        err = AECreateDesc(typeText, dataPtr, sizeof(DescType), result);        break;            case typeAlias:        aliasH = nil;                err = PtrToHand(dataPtr, (Handle *) &amp;aliasH, dataSize);        if (err == noErr) {          err = GetAliasInfo(aliasH, asiAliasName, tmpStr63);        }        if (err == noErr) {          PLstrcpy(tmpStr, &quot;\palias(&quot;);          PLstrcat(tmpStr, tmpStr63);          PLstrcat(tmpStr, &quot;\p)&quot;);          err = AECreateDesc(typeText, &amp;tmpStr[1], tmpStr[0], result);        }                if (aliasH != nil) {          DisposeHandle( (Handle) aliasH );        }        break;      case typeFSS:        MoreAssertQ(dataPtr != nil);        MoreAssertQ(dataSize == sizeof(FSSpec));                fssP = (FSSpecPtr) dataPtr;        PLstrcpy(tmpStr, &quot;\pfss(&quot;);        PLstrcat(tmpStr, fssP-&gt;name);        PLstrcat(tmpStr, &quot;\p)&quot;);        err = AECreateDesc(typeText, &amp;tmpStr[1], tmpStr[0], result);        break;      case typeBoolean:        if ( *((Boolean *) dataPtr) ) {          err = AECreateDesc(typeText, &quot;true&quot;, 4, result);        } else {          err = AECreateDesc(typeText, &quot;false&quot;, 5, result);        }        break;      case typeTrue:        err = AECreateDesc(typeText, &quot;typeTrue&quot;, 8, result);        break;      case typeFalse:        err = AECreateDesc(typeText, &quot;typeFalse&quot;, 9, result);        break;              case typeQDPoint:        PLstrcpy(tmpStr, &quot;\pPoint(&quot;);        NumToString( ((PointPtr) dataPtr)-&gt;h, tmpStr2);        PLstrcat(tmpStr, tmpStr2);        PLstrcat(tmpStr, &quot;\p, &quot;);        NumToString( ((PointPtr) dataPtr)-&gt;v, tmpStr2);        PLstrcat(tmpStr, tmpStr2);        PLstrcat(tmpStr, &quot;\p)&quot;);        err = AECreateDesc(typeText, &amp;tmpStr[1], tmpStr[0], result);        break;              case typeQDRectangle:        PLstrcpy(tmpStr, &quot;\pRect(&quot;);        NumToString( ((RectPtr) dataPtr)-&gt;left, tmpStr2);        PLstrcat(tmpStr, tmpStr2);        PLstrcat(tmpStr, &quot;\p, &quot;);        NumToString( ((RectPtr) dataPtr)-&gt;top, tmpStr2);        PLstrcat(tmpStr, tmpStr2);        PLstrcat(tmpStr, &quot;\p, &quot;);        NumToString( ((RectPtr) dataPtr)-&gt;right, tmpStr2);        PLstrcat(tmpStr, tmpStr2);        PLstrcat(tmpStr, &quot;\p, &quot;);        NumToString( ((RectPtr) dataPtr)-&gt;bottom, tmpStr2);        PLstrcat(tmpStr, tmpStr2);        PLstrcat(tmpStr, &quot;\p)&quot;);        err = AECreateDesc(typeText, &amp;tmpStr[1], tmpStr[0], result);        break;      default:        MoreAssertQ(false);        err = errAECoercionFail;        break;    }        return err;  }  static AECoerceDescUPP gRecordToTextCoerceUPP;      // -&gt; RecordToTextCoerceProc    static pascal OSErr RecordToTextCoerceProc(const AEDesc *fromDesc, DescType toType, long handlerRefCon, AEDesc *toDesc)    // A coercion handler to convert lists, records, and other things    // coercible to records, to text.  {    #pragma unused(handlerRefCon)    OSStatus  err;    Handle    result;    AEDesc    fromDescAsRecord;    SInt32    itemIndex;    SInt32    itemCount;    AEKeyword thisKeyword;    AEDesc    thisElement;    AEDesc    thisElementAsText;    Size      textSize;    MoreAssertQ(fromDesc != nil);    MoreAssertQ(toType == typeText);    MoreAssertQ(toDesc   != nil);    MoreAENullDesc(toDesc);    MoreAENullDesc(&amp;fromDescAsRecord);        // Create a handle for the resulting text.        result = NewHandle(0);    err = MoreMemError(result);        // If the incoming data is a record or a list, we handle it natively    // so just duplicate it into the fromDescAsRecord.  OTOH, if the incoming    // data is something weird (an object specifier, say), use AECoerceDesc to     // coerce it to a record.        if (err == noErr) {      if (fromDesc-&gt;descriptorType == typeAERecord || fromDesc-&gt;descriptorType == typeAEList) {        err = AEDuplicateDesc(fromDesc, &amp;fromDescAsRecord);      } else {        err = AECoerceDesc(fromDesc, typeAERecord, &amp;fromDescAsRecord);      }    }        // Iterate through each element in the record/list, coercing the element    // to text and appending its text to the handle.        if (err == noErr) {      err = AECountItems(&amp;fromDescAsRecord, &amp;itemCount);    }    if (err == noErr) {      err = PtrAndHand(&quot;{&quot;, result, 1);      for (itemIndex = 1; itemIndex &lt;= itemCount; itemIndex++) {        MoreAENullDesc(&amp;thisElement);        MoreAENullDesc(&amp;thisElementAsText);        err = AEGetNthDesc(&amp;fromDescAsRecord, itemIndex, typeWildCard, &amp;thisKeyword, &amp;thisElement);        if (err == noErr) {          err = AECoerceDesc(&amp;thisElement, typeText, &amp;thisElementAsText);          // While writing this code, I spent lots of time figuring out          // exactly what type of data couldn't be coerced to text and then          // filling in that particular coercion.  The following assert          // helps detect these problems quickly.          MoreAssertQ(err != errAECoercionFail);        }                // If we're iteratintg through a record, the keyword is meaningful        // so add it to the output handle.                if (err == noErr &amp;&amp; fromDescAsRecord.descriptorType == typeAERecord) {          err = PtrAndHand(&quot;'&quot;, result, 1);          if (err == noErr) {            err = PtrAndHand(&amp;thisKeyword, result, sizeof(thisKeyword));          }          if (err == noErr) {            err = PtrAndHand(&quot;':&quot;, result, 2);          }        }                // Grow the handle to make room for the text for this element,        // then copy the text to the handle.                if (err == noErr) {          textSize = AEGetDescDataSize(&amp;thisElementAsText);          SetHandleSize(result, GetHandleSize(result) + textSize);          err = MemError();        }        if (err == noErr) {          HLock(result);          err = AEGetDescData(&amp;thisElementAsText, (*result) + GetHandleSize(result) - textSize, textSize);          HUnlock(result);        }                // If we're not the last element, add a separator.                if (err == noErr &amp;&amp; itemIndex &lt; itemCount) {          err = PtrAndHand(&quot;, &quot;, result, 2);        }                MoreAEDisposeDesc(&amp;thisElement);        MoreAEDisposeDesc(&amp;thisElementAsText);                if (err != noErr) {          break;        }      }    }    if (err == noErr) {      err = PtrAndHand(&quot;}&quot;, result, 1);    }        // Create a descriptor containing the data from the text handle.        if (err == noErr) {      HLock(result);      err = AECreateDesc(typeText, *result, GetHandleSize(result), toDesc);    }        // Clean up.        if (result != nil) {      DisposeHandle(result);      MoreAssertQ(MemError() == noErr);    }    MoreAEDisposeDesc(&amp;fromDescAsRecord);        return err;  }  static void InstallTextCoercionHandlers(void)    // This routine installs a bunch of coercion handles for    // coercing various common data types to text.  By adding these    // coercions, we increase the utility of the rest of MoreBBLog,     // which relies on being able to coerce various descriptors to text.  {    OSStatus junk;    // First install all the basic coercions.            gBasicToTextCoerceUPP = NewAECoercePtrUPP(BasicToTextCoerceProc);    MoreAssertQ(gBasicToTextCoerceUPP != nil);    junk = AEInstallCoercionHandler(typeNull, typeText, (AECoercionHandlerUPP) gBasicToTextCoerceUPP, 0, false, false);    MoreAssertQ(junk == noErr);    junk = AEInstallCoercionHandler(typeObjectBeingExamined, typeText, (AECoercionHandlerUPP) gBasicToTextCoerceUPP, 0, false, false);    MoreAssertQ(junk == noErr);    junk = AEInstallCoercionHandler(typeCurrentContainer, typeText, (AECoercionHandlerUPP) gBasicToTextCoerceUPP, 0, false, false);    MoreAssertQ(junk == noErr);    junk = AEInstallCoercionHandler(typeToken, typeText, (AECoercionHandlerUPP) gBasicToTextCoerceUPP, 0, false, false);    MoreAssertQ(junk == noErr);    junk = AEInstallCoercionHandler(typeAbsoluteOrdinal, typeText, (AECoercionHandlerUPP) gBasicToTextCoerceUPP, 0, false, false);    MoreAssertQ(junk == noErr);    junk = AEInstallCoercionHandler(typeAlias, typeText, (AECoercionHandlerUPP) gBasicToTextCoerceUPP, 0, false, false);    MoreAssertQ(junk == noErr);    junk = AEInstallCoercionHandler(typeFSS, typeText, (AECoercionHandlerUPP) gBasicToTextCoerceUPP, 0, false, false);    MoreAssertQ(junk == noErr);    junk = AEInstallCoercionHandler(typeBoolean, typeText, (AECoercionHandlerUPP) gBasicToTextCoerceUPP, 0, false, false);    MoreAssertQ(junk == noErr);    junk = AEInstallCoercionHandler(typeTrue, typeText, (AECoercionHandlerUPP) gBasicToTextCoerceUPP, 0, false, false);    MoreAssertQ(junk == noErr);    junk = AEInstallCoercionHandler(typeFalse, typeText, (AECoercionHandlerUPP) gBasicToTextCoerceUPP, 0, false, false);    MoreAssertQ(junk == noErr);    junk = AEInstallCoercionHandler(typeQDPoint, typeText, (AECoercionHandlerUPP) gBasicToTextCoerceUPP, 0, false, false);    MoreAssertQ(junk == noErr);    junk = AEInstallCoercionHandler(typeQDRectangle, typeText, (AECoercionHandlerUPP) gBasicToTextCoerceUPP, 0, false, false);    MoreAssertQ(junk == noErr);    // Then install the coercions for lists, records, and things coercible    // to records.        gRecordToTextCoerceUPP = NewAECoerceDescUPP(RecordToTextCoerceProc);    MoreAssertQ(gRecordToTextCoerceUPP != nil);    junk = AEInstallCoercionHandler(typeAERecord, typeText, (AECoercionHandlerUPP) gRecordToTextCoerceUPP, 0, true, false);    MoreAssertQ(junk == noErr);    junk = AEInstallCoercionHandler(typeAEList, typeText, (AECoercionHandlerUPP) gRecordToTextCoerceUPP, 0, true, false);    MoreAssertQ(junk == noErr);    junk = AEInstallCoercionHandler(typeAppleEvent, typeText, (AECoercionHandlerUPP) gRecordToTextCoerceUPP, 0, true, false);    MoreAssertQ(junk == noErr);    junk = AEInstallCoercionHandler(typeObjectSpecifier, typeText, (AECoercionHandlerUPP) gRecordToTextCoerceUPP, 0, true, false);    MoreAssertQ(junk == noErr);    junk = AEInstallCoercionHandler(typeRangeDescriptor, typeText, (AECoercionHandlerUPP) gRecordToTextCoerceUPP, 0, true, false);    MoreAssertQ(junk == noErr);    junk = AEInstallCoercionHandler(typeCompDescriptor, typeText, (AECoercionHandlerUPP) gRecordToTextCoerceUPP, 0, true, false);    MoreAssertQ(junk == noErr);    junk = AEInstallCoercionHandler(typeLogicalDescriptor, typeText, (AECoercionHandlerUPP) gRecordToTextCoerceUPP, 0, true, false);    MoreAssertQ(junk == noErr);  }  static const OSType kBBEditCreator = 'R*ch';  static UInt32  gIndent;    // records the number of levels of indent, as controlled by BBLogIndent etc  static Boolean gLogging;  // determines whether logging is enabled (true) or not (false)    extern pascal void BBLogStart(Boolean logging)    // See comment in header file.  {    OSStatus   err;    AppleEvent   theEvent;    AppleEvent   junkReply;    DescType   cDoc;    // Start up by installing our coercion handles.  This enables the rest    // of the routines to provide much nicer output.        InstallTextCoercionHandlers();        gIndent = 0;    gLogging = logging;    if (gLogging) {          // Send BBEdit an Apple event to make a new text window.  This      // will error if BBEdit is running, but the code to launch it      // is an unnecessary complication.  If you want to see logging,      // you have to have BBEdit running.            MoreAENullDesc(&amp;theEvent);      err = MoreAECreateAppleEventCreatorTarget(kAECoreSuite, kAECreateElement, kBBEditCreator, &amp;theEvent);      if (err == noErr) {        cDoc = cDocument;        err = AEPutParamPtr(&amp;theEvent, keyAEObjectClass, typeType, &amp;cDoc, sizeof(cDoc));      }      if (err == noErr) {        err = AESend(&amp;theEvent, &amp;junkReply, kAENoReply, kAENormalPriority, kAEDefaultTimeout, nil, nil);        if (err == connectionInvalid) {    // BBEdit not running          err = noErr;        }      }      MoreAEDisposeDesc(&amp;theEvent);      MoreAssertQ(err == noErr);    }  }    extern pascal void BBLogSetState(Boolean logging)    // See comment in header file.  {    gLogging = logging;  }      extern pascal void BBLogText(void *textPtr, Size textSize)    // See comment in header file.  {    OSStatus   err;    AppleEvent theEvent;    AppleEvent junkReply;    MoreAssertQ(textPtr != nil);    if (gLogging) {          // Send BBEdit an insert text ('Nsrt') event.  The text will go      // into the front window, which is typically the window we created      // during BBLogStart.            MoreAENullDesc(&amp;theEvent);      err = MoreAECreateAppleEventCreatorTarget(kBBEditCreator, 'Nsrt', kBBEditCreator, &amp;theEvent);      if (err == noErr) {        err = AEPutParamPtr(&amp;theEvent, keyDirectObject, typeText, textPtr, textSize);      }      if (err == noErr) {        err = AESend(&amp;theEvent, &amp;junkReply, kAENoReply, kAENormalPriority, kAEDefaultTimeout, nil, nil);        if (err == connectionInvalid) {    // BBEdit not running          err = noErr;        }      }      MoreAEDisposeDesc(&amp;theEvent);      MoreAssertQ(err == noErr);    }  }  static void BuildLineHeader(Str255 str)  {    UInt32 dateTime;    Str255 tmpStr;    static Str255 indentStr = &quot;\p                                                                                                  &quot;;        MoreAssertQ(str != nil);    GetDateTime(&amp;dateTime);    TimeString(dateTime, true, tmpStr, nil);    (void) PLstrcpy(str, tmpStr);    (void) PLstrcat(str, &quot;\p &quot;);    DateString(dateTime, shortDate, tmpStr, nil);    (void) PLstrcat(str, tmpStr);    (void) PLstrcat(str, &quot;\p - &quot;);    indentStr[0] = gIndent * 2;    (void) PLstrcat(str, indentStr);  }    extern pascal void BBLogLine(ConstStr255Param str)    // See comment in header file.  {    Str255 tmpStr;    MoreAssertQ(str != nil);    if (gLogging) {            // Add the date and time prefix, the appropriate indent, and the CR suffix.      BuildLineHeader(tmpStr);      (void) PLstrcat(tmpStr, str);      (void) PLstrcat(tmpStr, &quot;\p\r&quot;);      BBLogText(&amp;tmpStr[1], tmpStr[0]);    }  }    extern pascal void BBLogIndent(void)    // See comment in header file.  {    gIndent += 1;  }    extern pascal void BBLogOutdent(void)    // See comment in header file.  {    MoreAssertQ(gIndent &gt; 0);    gIndent -= 1;  }    extern pascal void BBLogOutdentWithErr(OSStatus errNum)    // See comment in header file.  {    Str255 tmpStr;    Str255 tmpStr2;        BBLogOutdent();    if (gLogging) {      if (errNum == noErr) {        (void) PLstrcpy(tmpStr, &quot;\perr=noErr&quot;);      } else {        (void) PLstrcpy(tmpStr, &quot;\perr=&quot;);        NumToString(errNum, tmpStr2);        (void) PLstrcat(tmpStr, tmpStr2);      }      BBLogLine(tmpStr);    }  }  extern pascal void BBLogAppleEvent(ConstStr255Param tag, const AppleEvent *theEvent)    // See comment in header file.  {    OSStatus     junk;    AEEventClass classID;    AEEventID    eventID;    DescType     junkType;    Size         junkSize;    Str255     tmpStr;    Str255     tmpStr2;        MoreAssertQ(tag      != nil);    MoreAssertQ(theEvent != nil);    if (gLogging) {          // Get the Apple event class and event IDs.            classID = '????';      junk = AEGetAttributePtr(theEvent, keyEventClassAttr, typeType, &amp;junkType, &amp;classID, sizeof(classID), &amp;junkSize);      MoreAssertQ(junk == noErr);      eventID = '????';      junk = AEGetAttributePtr(theEvent, keyEventIDAttr, typeType, &amp;junkType, &amp;eventID, sizeof(eventID), &amp;junkSize);      MoreAssertQ(junk == noErr);      // Create a log string out of those IDs.  Currently this      // is the only information about the event that we log;      // we might want to extend this in the future, with possibly      // the parameter list (or at least the direct object).            (void) PLstrcpy(tmpStr, tag);      (void) PLstrcat(tmpStr, &quot;\p='&quot;);      tmpStr2[0] = 4;      *((OSType *) &amp;tmpStr2[1]) = classID;      (void) PLstrcat(tmpStr, tmpStr2);      (void) PLstrcat(tmpStr, &quot;\p', '&quot;);      tmpStr2[0] = 4;      *((OSType *) &amp;tmpStr2[1]) = eventID;      (void) PLstrcat(tmpStr, tmpStr2);      (void) PLstrcat(tmpStr, &quot;\p'&quot;);      BBLogLine(tmpStr);    }  }    extern pascal void BBLogLong(ConstStr255Param tag,       SInt32 l)    // See comment in header file.  {    Str255 tmpStr;    Str255 tmpStr2;        MoreAssertQ(tag != nil);    if (gLogging) {      (void) PLstrcpy(tmpStr, tag);      (void) PLstrcat(tmpStr, &quot;\p=&quot;);      NumToString(l, tmpStr2);      (void) PLstrcat(tmpStr, tmpStr2);      BBLogLine(tmpStr);    }  }    extern pascal void BBLogDesc(ConstStr255Param tag,       const AEDesc *desc)    // See comment in header file.  {    OSStatus   err;    AEDesc     coercedDesc;    Str255    descStr;    Str255    tmpStr;    Handle    descText;        MoreAssertQ(tag  != nil);    MoreAssertQ(desc != nil);        if (gLogging) {      MoreAENullDesc(&amp;coercedDesc);      descText = nil;      // First try coercing the descriptor to text.      // If we succeed, then we use the resulting textual      // description of the descriptor.  If we fail,      // we just log the descriptor type and size            err = AECoerceDesc(desc, typeText, &amp;coercedDesc);      if (err == noErr) {        err = MoreAECopyDescriptorDataToHandle(&amp;coercedDesc, &amp;descText);                // If the original descriptor type was text, add        // some &quot; &quot; around the text.                if (err == noErr &amp;&amp; desc-&gt;descriptorType == typeText) {          (void) Munger(descText, 0, nil, 0, &quot;&quot;&quot;, 1);          err = MemError();                    if (err == noErr) {            err = PtrAndHand(&quot;&quot;&quot;, descText, 1);          }        }      } else {        tmpStr[0] = 4;        *((OSType *) &amp;tmpStr[1]) = desc-&gt;descriptorType;        (void) PLstrcpy(descStr, &quot;\p'&quot;);        (void) PLstrcat(descStr, tmpStr);        (void) PLstrcat(descStr, &quot;\p'&quot;);        if (desc-&gt;dataHandle != nil) {          (void) PLstrcat(descStr, &quot;\p, size=&quot;);          NumToString(AEGetDescDataSize(desc), tmpStr);          (void) PLstrcat(descStr, tmpStr);        }        err = PtrToHand(&amp;descStr[1], &amp;descText, descStr[0]);      }      // Now that descText is set up to contain the textual      // representation of desc, we just log it.  We also      // log the original type of the descriptor (in square      // brackets).            // First prepend the line header and the tag.      if (err == noErr) {        BuildLineHeader(tmpStr);        (void) PLstrcat(tmpStr, tag);        (void) PLstrcat(tmpStr, &quot;\p=&quot;);        (void) Munger(descText, 0, nil, 0, &amp;tmpStr[1], tmpStr[0]);        err = MemError();      }      // Then append the original descriptor type and the CR.            if (err == noErr) {        (void) PLstrcpy(tmpStr, &quot;\p [&quot;);        descStr[0] = 4;        *((OSType *) &amp;descStr[1]) = desc-&gt;descriptorType;        (void) PLstrcat(tmpStr, descStr);        (void) PLstrcat(tmpStr, &quot;\p]\x0d&quot;);                err = PtrAndHand(&amp;tmpStr[1], descText, tmpStr[0]);      }      // Finally, log the text.            if (err == noErr) {                HLock(descText);        BBLogText(*descText, GetHandleSize(descText));      }      // Clean up.            if (descText != nil) {        DisposeHandle(descText);        MoreAssertQ(MemError() == noErr);      }      MoreAEDisposeDesc(&amp;coercedDesc);    }  }    extern pascal void BBLogDescType(ConstStr255Param tag,   DescType theType)    // See comment in header file.  {    Str255 tmpStr;    Str255 tmpStr2;    MoreAssertQ(tag != nil);        if (gLogging) {      (void) PLstrcpy(tmpStr, tag);      (void) PLstrcat(tmpStr, &quot;\p='&quot;);      tmpStr2[0] = 4;      *((OSType *) &amp;tmpStr2[1]) = theType;      (void) PLstrcat(tmpStr, tmpStr2);      (void) PLstrcat(tmpStr, &quot;\p'&quot;);            BBLogLine(tmpStr);    }  }#endif // MORE_DEBUG</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/MoreOSL/listing8.html%3Fid%3DDTS10000670-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/MoreOSL/listing8.html%3Fid%3DDTS10000670-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/MoreOSL/listing8.html%3Fid%3DDTS10000670-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>