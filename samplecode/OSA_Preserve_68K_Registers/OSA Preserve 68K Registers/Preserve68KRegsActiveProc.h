#ifndef PRESERVE68KREGSACTIVEPROC#define PRESERVE68KREGSACTIVEPROC//------------------------------------------------------------------------------////	Macintosh Developer Technical Support////	Preserve68KRegsActiveProc PPC library////	File:	Preserve68KRegsActiveProc.h	-	C interface////	Copyright © 1996 Apple Computer, Inc.//	All rights reserved.////	Versions:	1.0		09/04/96	AB	Original design.//	Versions:	1.0.1	09/05/96	AB	Changed parameter from long to struct, to//										enable passing a refcon to the PPC function.//				1.1		11/06/96	AB	New version created for send function.//										Fixed a bug where we weren't properly returning the//										error value we got from the real send function.//										Changed name from PPCYieldFrom68KActive//										to Preserve68KRegsActiveProc.////	Components:	Preserve68KRegsActiveProc.h//				Preserve68KRegsActiveProc.xcoff////------------------------------------------------------------------------------//	//	purpose		To provide a 68K wrapper function, named Preserve68KRegsActiveProc, //				to be installed as an OSAActiveProc. The purpose of this function//				is to save and restore a group of emulated 68K registers around//				calls to a PowerPC function, which in turn calls YieldToAnyThread.////				This work-around is necessary because, at the current time, the //				PPC Thread Manager doesn't do anything with the emulated 68K registers,//				and without this work-around, the OSA AppleScript component get totally//				confused and blows-up.////------------------------------------------------------------------------------////	How do I use this library?////	You will need to add the file Preserve68KRegsActiveProc.xcoff to your project.//	Through some DTS Magic(TM), this library contains the 68K code for the//	Preserve68KRegsActiveProc function. This stub function saves the emulated //	68K registers, calls the real PPC active function (which contains the yield call)//	and then restores the emulated registers, passing through any error value//	returned by the real active function.////	Next, you must write your real active function (in PPC code) that contains a //	call to a Thread Manager yield function. See pg 10-95 of Inside Macintosh://	Interapplication Communication for information on writing an active function.////	You will need to declare a variable of type RefRec. Its address will be installed//	as the refCon value in your call to OSASetActiveProc. The RefRec structure will be//	used to pass the real refCon value and a UPP for the real active function to the //	Preserve68KRegsActiveProc function.////	When called, the Preserve68KRegsActiveProc function will then pass along the real//	refCon value from the RefRec structure, and call the real send function via the//	UPP passed in the procEntry field of the RefRec.////	The following snippet shows how to://	 *	create the UPP for the active function//	 *	initialize the RefRec variable's fields//	 *	install Preserve68KRegsActiveProc as the send function.////		OSAActiveUPP	myOSAActiveUPP;//		RefRec			myRefRec;//		//		myOSAActiveUPP = NewOSAActiveProc( myPPCActiveProcWithYield );//		myRefRec.procEntry = myOSAActiveUPP;//		myRefRec.refCon = nil;//		//		err = OSASetActiveProc( scriptingComponent, &Preserve68KRegsActiveProc, (long)&myRefRec);////------------------------------------------------------------------------------//  parameter type for variable passed in refCon field in the call to OSASetActiveProcstruct RefRec {	UniversalProcPtr	procEntry;	long				refCon;};typedef struct RefRec RefRec;//	entry point for the 68K emulated register preserving codeextern	RoutineDescriptor	Preserve68KRegsActiveProc;#endif// PRESERVE68KREGSACTIVEPROC