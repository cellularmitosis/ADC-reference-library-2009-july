<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>DroneZoneOld - /DZDrone.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxGraphicsImaging-date.html">Graphics & Imaging</a> &gt; <A HREF="javascript:location.replace('index.html');">DroneZoneOld</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/GraphicsImaging/index.html" target="_blank">Reference Library > Graphics & Imaging</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">DroneZoneOld</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/DZDrone.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/DZDisplay.c</option>
<option value="listing2.html">/DZDisplay.h</option>
<option value="listing3.html">/DZDrone.c</option>
<option value="listing4.html">/DZDrone.h</option>
<option value="listing5.html">/DZEvenMoreResources.r</option>
<option value="listing6.html">/DZEvents.c</option>
<option value="listing7.html">/DZEvents.h</option>
<option value="listing8.html">/DZGame.c</option>
<option value="listing9.html">/DZGame.h</option>
<option value="listing10.html">/DZInput.c</option>
<option value="listing11.html">/DZInput.h</option>
<option value="listing12.html">/DZISpPresets.r</option>
<option value="listing13.html">/DZKeyCap.h</option>
<option value="listing14.html">/DZMain.c</option>
<option value="listing15.html">/DZMain.h</option>
<option value="listing16.html">/DZMenu.c</option>
<option value="listing17.html">/DZMenu.h</option>
<option value="listing18.html">/DZMoreResources.r</option>
<option value="listing19.html">/DZPrefix.h</option>
<option value="listing20.html">/DZResource.h</option>
<option value="listing21.html">/DZSound.c</option>
<option value="listing22.html">/DZSound.h</option>
<option value="listing23.html">/DZSpace.c</option>
<option value="listing24.html">/DZSpace.h</option>
<option value="listing25.html">/DZThumbprint.h</option>
<option value="listing26.html">/DZUtils.c</option>
<option value="listing27.html">/DZUtils.h</option>
<option value="listing28.html">/DZVersion.r</option></select>
				</p>
				</form>
				<p><strong><a href="DroneZoneOld.zip">Download Sample</a></strong> (&#147;DroneZoneOld.zip&#148;, 189.3K)<BR>
<strong><a href="DroneZoneOld.dmg">Download Sample</a></strong> (&#147;DroneZoneOld.dmg&#148;, 543.0K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/* *  File:    DZDrone.c * *  Contents:  A drone object represents the position of an player or drone. * *  Copyright &copy; 1996 Apple Computer, Inc. */#include &lt;assert.h&gt;#include &lt;math.h&gt;#include &lt;stdlib.h&gt;#include &lt;Components.h&gt;#include &lt;Dialogs.h&gt;#include &lt;Events.h&gt;#include &lt;QuickDraw.h&gt;#include &lt;Resources.h&gt;#include &lt;Sound.h&gt;#include &lt;SoundComponents.h&gt;#include &lt;SoundInput.h&gt;#include &lt;ToolUtils.h&gt;#include &lt;Types.h&gt;#include &lt;QD3D.h&gt;#include &lt;QD3DCamera.h&gt;#include &lt;QD3DDrawContext.h&gt;#include &lt;QD3DGeometry.h&gt;#include &lt;QD3DMath.h&gt;#include &lt;QD3DPick.h&gt;#include &lt;QD3DSet.h&gt;#include &lt;QD3DShader.h&gt;#include &lt;QD3DStyle.h&gt;#include &lt;QD3DTransform.h&gt;#include &lt;QD3DView.h&gt;#include &quot;SoundSprocket.h&quot;#include &quot;DZDisplay.h&quot;#include &quot;DZDrone.h&quot;#include &quot;DZGame.h&quot;#include &quot;DZResource.h&quot;#include &quot;DZSound.h&quot;#include &quot;DZThumbprint.h&quot;#include &quot;DZUtils.h&quot;#ifndef  SELF_DRONE_HAS_FRICTION#define  SELF_DRONE_HAS_FRICTION  1#endif#define IS_SELF_DRONE(inDrone)    (inDrone-&gt;thumbprint == kThumbprint_SelfDrone)#define IS_AUTO_DRONE(inDrone)    (inDrone-&gt;thumbprint == kThumbprint_AutoDrone)#define IS_BULLET_DRONE(inDrone)  (inDrone-&gt;thumbprint == kThumbprint_BulletDrone)#define IS_DRONE(inDrone)      (IS_SELF_DRONE(inDrone) || IS_AUTO_DRONE(inDrone) || IS_BULLET_DRONE(inDrone))#define SELF_DRONE_INITIAL_SPEED  0.50  // In units per second#define SELF_DRONE_MAX_ACCEL    10.0    // In units per second per second#define SELF_DRONE_FRICTION      0.80   // as a percentage (1.00 would be no friction)#define AUTO_DRONE_LEAD        5.0    // Drone target leads by this distance (in units)#define AUTO_DRONE_ACCEL      2.0    // Drone acceleration (units per second per second)#define AUTO_DRONE_TURN_RATE    1.8    // In radians per second#define AUTO_DRONE_BURN_TIME    3.0    // In seconds#define AUTO_DRONE_REST_TIME    1.0    // In seconds#define AUTO_DRONE_EXPLOSION_TIME  3.0    // In seconds#define AUTO_DRONE_FADE_TIME    0.25  // Fraction of AUTO_DRONE_EXPLOSION_TIME for fade#define AUTO_DRONE_MIN_SCALE    0.2    // Initial scale for explosion#define AUTO_DRONE_IDLE_REF_DIST  2.0#define AUTO_DRONE_BURN_REF_DIST  5.0#define AUTO_DRONE_EXPL_REF_DIST  30.0#define BULLET_DRONE_OFFSET      0.2    // Offset from self to bullet initial position#define BULLET_DRONE_SPEED      50.0  // In units per second#define BULLET_DRONE_LIMIT      50.0  // Maximum length of a bullet#define HUD_SCALE          0.02  // Scale of HUD#define HUD_HEIGHT          0.5    // cos(angle) at which to consider out-of-planeenum {  kDroneDrawContextSize      = 5    // Used for picking};typedef enum TDroneOrder {          // In order of evaluation  kDroneOrder_Self,  kDroneOrder_Auto,  kDroneOrder_Bullet} TDroneOrder;typedef void (*TDroneMoveMethod)(  TDroneObject      inDrone);typedef void (*TDroneUpdateSoundMethod)(  TDroneObject      inDrone);typedef void (*TDroneSubmitMethod)(  TDroneObject      inDrone,  Boolean          inHUDVisible,  TQ3ViewObject      inView);typedef void (*TDronePickSubmitMethod)(  TDroneObject      inDrone,  TQ3ViewObject      inView);typedef void (*TDroneHitMethod)(  TDroneObject      inDrone);typedef enum TAutoSound {  kAutoSound_None,  kAutoSound_Idle,  kAutoSound_Burn,  kAutoSound_Explosion} TAutoSound;typedef enum TAutoMode {  kAutoMode_Idle,  kAutoMode_Burn,  kAutoMode_Rest,  kAutoMode_Explosion} TAutoMode;typedef struct TDroneData {  TThumbprint        thumbprint;      // For validation    TDroneMoveMethod    moveMethod;      // Method: Drone_Move  TDroneUpdateSoundMethod  updateSoundMethod;  // Method: Drone_UpdateSound  TDroneSubmitMethod    submitMethod;    // Method: Drone_Submit  TDronePickSubmitMethod  pickSubmitMethod;  // Method: Drone_PickSubmit  TDroneHitMethod      hitMethod;      // Method: Drone_Hit    TDroneObject      prev;        // The global list of drones  TDroneObject      next;  TDroneOrder        order;        // Sort key    Boolean          mark;        // Is this drone marked to die?    TQ3Point3D        position;      // Current position  TQ3Point3D        position1;      // Previous position    TQ3Vector3D        velocity;      // Change in position over time  TQ3Vector3D        velocity1;      // Previous velocity    TQ3Vector3D        acceleration;    // Change in velocity over time    TQ3Vector3D        direction;      // Forward    (model X axis)  TQ3Vector3D        up;          // Vertical    (model Y axis)  TQ3Vector3D        cross;        // Horizontal  (model Z axis)    TQ3Object        geometry;      // The shape of the drone    SndChannelPtr      autoSndChannel;    // Auto: Sound channel  SSpSourceReference    autoSource;      // Auto: 3D sound source  TAutoSound        autoSound;      // Auto: Sound currently playing  TDroneObject      autoInterest;    // Auto: Drone that we're looking at  TQ3Vector3D        autoVelocity;    // Auto: Drone velocity (instantaneous)  TAutoMode        autoMode;      // Auto: Current state  unsigned long      autoModeTimeout;  // Auto: When does mode expire?  float          autoDistance;    // Auto: Last distance from target  float          autoExplosion;    // Auto: 0=start; 1=end of explosion    TQ3Point3D        bulletOrigin;    // Bullet: Starting position of the bullet} TDroneData;static TDroneObject      gDroneList            = NULL;static TQ3Object      gDroneAutoGeometry        = NULL;static TQ3Object      gDroneAutoBurnGeometry      = NULL;static TQ3Object      gDroneAutoExplosionGeometry    = NULL;static TQ3AttributeSet    gDroneBulletColor        = NULL;static TQ3ShaderObject    gDroneNULLIllumination      = NULL;static TQ3ViewObject    gDroneView            = NULL;static TQ3DrawContextObject  gDroneDrawContext        = NULL;static TQ3CameraObject    gDroneCamera          = NULL;static TQ3PickObject    gDronePick            = NULL;static SndListHandle    gDroneAutoSndIdle        = NULL;static SndListHandle    gDroneAutoSndBurn        = NULL;static SndListHandle    gDroneAutoSndExplosion      = NULL;static long          gDroneAutoSndIdleOffset      = 0;static long          gDroneAutoSndBurnOffset      = 0;static long          gDroneAutoSndExplosionOffset  = 0;static TQ3GeometryObject  gDroneAutoMarkerEqual      = NULL;static TQ3GeometryObject  gDroneAutoMarkerAbove      = NULL;static TQ3GeometryObject  gDroneAutoMarkerBelow      = NULL;static unsigned char    gDroneAutoMarkerDataEqual[8] =                  {0x38, 0x44, 0x82, 0x92, 0x82, 0x44, 0x38, 0x00};static unsigned char    gDroneAutoMarkerDataAbove[8] =                  {0x38, 0x54, 0x92, 0xFE, 0x92, 0x54, 0x38, 0x00};static unsigned char    gDroneAutoMarkerDataBelow[8] =                  {0x38, 0x44, 0x82, 0xFE, 0x82, 0x44, 0x38, 0x00};static Boolean        gDroneAutoCheckFilterVersion  = true;static TDroneObject Drone_New(  TDroneOrder        inOrder);static void SelfDrone_Move(  TDroneObject      inDrone);static void AutoDrone_Move(  TDroneObject      inDrone);static void BulletDrone_Move(  TDroneObject      inDrone);static void AutoDrone_UpdateSound(  TDroneObject      inDrone);static void AutoDrone_Submit(  TDroneObject      inDrone,  Boolean          inHUDVisible,  TQ3ViewObject      inView);static void BulletDrone_Submit(  TDroneObject      inDrone,  Boolean          inHUDVisible,  TQ3ViewObject      inView);static void Drone_PickSubmit(  TDroneObject      inDrone,  TQ3ViewObject      inView);static void AutoDrone_PickSubmit(  TDroneObject      inDrone,  TQ3ViewObject      inView);static void Drone_Hit(  TDroneObject      inDrone);static void AutoDrone_Hit(  TDroneObject      inDrone);void Drone_GetMatrix(  TDroneObject      inDrone,  TQ3Matrix4x4*      outMatrix);/* ============================================================================= *    Drone_Init (external) * *  Initializes the drone stuff. * ========================================================================== */void Drone_Init(  void){  TQ3ColorRGB            color;  TQ3PixmapDrawContextData    pixmapDrawContextData;  TQ3ViewAngleAspectCameraData  viewAngleCameraData;  TQ3WindowPointPickData      windowPointPickData;  TQ3MarkerData          markerData;    // Set up the autopilot drone geometry  gDroneAutoGeometry = Get3DMFResource(k3DMFID_AutoDrone);  assert(gDroneAutoGeometry != NULL);    // Set up the autopilot drone burn geometry  gDroneAutoBurnGeometry = Get3DMFResource(k3DMFID_AutoDroneBurn);  assert(gDroneAutoBurnGeometry != NULL);    // Set up the autopilot drone explosion geometry  gDroneAutoExplosionGeometry = Get3DMFResource(k3DMFID_AutoDroneExplosion);  assert(gDroneAutoExplosionGeometry != NULL);    // Read in the autopilot drone sounds  gDroneAutoSndIdle = (SndListHandle) GetResource('snd ', kSndID_AutoIdle);  assert(gDroneAutoSndIdle != NULL);    gDroneAutoSndBurn = (SndListHandle) GetResource('snd ', kSndID_AutoBurn);  assert(gDroneAutoSndBurn != NULL);    gDroneAutoSndExplosion = (SndListHandle) GetResource('snd ', kSndID_AutoExplosion);  assert(gDroneAutoSndExplosion != NULL);    GetSoundHeaderOffset(gDroneAutoSndIdle,      &amp;gDroneAutoSndIdleOffset);  GetSoundHeaderOffset(gDroneAutoSndBurn,      &amp;gDroneAutoSndBurnOffset);  GetSoundHeaderOffset(gDroneAutoSndExplosion,  &amp;gDroneAutoSndExplosionOffset);    // Set up the bullet drone line color  gDroneBulletColor = Q3AttributeSet_New();  assert(gDroneBulletColor != NULL);    color.r = 1.0;  color.g = 0.8;  color.b = 0.1;    Q3AttributeSet_Add(gDroneBulletColor, kQ3AttributeTypeDiffuseColor, &amp;color);    // Create the bullet null illum shader  gDroneNULLIllumination = Q3NULLIllumination_New();  assert(gDroneNULLIllumination != NULL);    // Create the view that we use for bullet collision detection  gDroneView = Q3View_New();  assert(gDroneView != NULL);    // Create its draw context  pixmapDrawContextData.drawContextData.clearImageMethod    = kQ3ClearMethodWithColor;  pixmapDrawContextData.drawContextData.clearImageColor.a    = 1.0;  pixmapDrawContextData.drawContextData.clearImageColor.r    = 0.0;  pixmapDrawContextData.drawContextData.clearImageColor.g    = 0.0;  pixmapDrawContextData.drawContextData.clearImageColor.b    = 0.0;  pixmapDrawContextData.drawContextData.paneState        = kQ3False;  pixmapDrawContextData.drawContextData.maskState        = kQ3False;  pixmapDrawContextData.drawContextData.doubleBufferState    = kQ3False;  pixmapDrawContextData.pixmap.width              = kDroneDrawContextSize;  pixmapDrawContextData.pixmap.height              = kDroneDrawContextSize;  pixmapDrawContextData.pixmap.rowBytes            = pixmapDrawContextData.pixmap.width*4;  pixmapDrawContextData.pixmap.pixelSize            = 32;  pixmapDrawContextData.pixmap.pixelType            = kQ3PixelTypeRGB32;  pixmapDrawContextData.pixmap.bitOrder            = kQ3EndianBig;  pixmapDrawContextData.pixmap.byteOrder            = kQ3EndianBig;  pixmapDrawContextData.pixmap.image              = malloc(pixmapDrawContextData.pixmap.height*pixmapDrawContextData.pixmap.rowBytes);    gDroneDrawContext = Q3PixmapDrawContext_New(&amp;pixmapDrawContextData);  assert(gDroneDrawContext != NULL);    Q3View_SetDrawContext(gDroneView, gDroneDrawContext);    // Create its camera  viewAngleCameraData.cameraData.placement.cameraLocation.x  = 0.0;  viewAngleCameraData.cameraData.placement.cameraLocation.y  = 0.0;  viewAngleCameraData.cameraData.placement.cameraLocation.z  = 0.0;  viewAngleCameraData.cameraData.placement.pointOfInterest.x  = 1.0;  viewAngleCameraData.cameraData.placement.pointOfInterest.y  = 0.0;  viewAngleCameraData.cameraData.placement.pointOfInterest.z  = 0.0;  viewAngleCameraData.cameraData.placement.upVector.x      = 0.0;  viewAngleCameraData.cameraData.placement.upVector.y      = 1.0;  viewAngleCameraData.cameraData.placement.upVector.z      = 0.0;  viewAngleCameraData.cameraData.range.hither          = 0.1;  viewAngleCameraData.cameraData.range.yon          = BULLET_DRONE_LIMIT;  viewAngleCameraData.cameraData.viewPort.origin.x      = -1.0;  viewAngleCameraData.cameraData.viewPort.origin.y      = 1.0;  viewAngleCameraData.cameraData.viewPort.width        = 2.0;  viewAngleCameraData.cameraData.viewPort.height        = 2.0;  viewAngleCameraData.fov                    = 0.1;  viewAngleCameraData.aspectRatioXToY              = pixmapDrawContextData.pixmap.width/pixmapDrawContextData.pixmap.height;  gDroneCamera = Q3ViewAngleAspectCamera_New(&amp;viewAngleCameraData);  assert(gDroneCamera != NULL);    Q3View_SetCamera(gDroneView, gDroneCamera);    // Create the pick object  windowPointPickData.data.sort        = kQ3PickSortNearToFar;  windowPointPickData.data.mask        = kQ3PickDetailMaskPickID | kQ3PickDetailMaskDistance;  windowPointPickData.data.numHitsToReturn  = kQ3ReturnAllHits;  windowPointPickData.point.x          = 0.5*pixmapDrawContextData.pixmap.width;  windowPointPickData.point.y          = 0.5*pixmapDrawContextData.pixmap.height;  windowPointPickData.vertexTolerance      = 0.0;  windowPointPickData.edgeTolerance      = 0.0;    gDronePick = Q3WindowPointPick_New(&amp;windowPointPickData);  assert(gDronePick != NULL);    // Create the autodrone markers  markerData.location.x      = 0.0;  markerData.location.y      = 0.0;  markerData.location.z      = 0.0;  markerData.xOffset        = -3;  markerData.yOffset        = -3;  markerData.bitmap.width      = 8;  markerData.bitmap.height    = 8;  markerData.bitmap.rowBytes    = 1;  markerData.bitmap.bitOrder    = kQ3EndianBig;  markerData.markerAttributeSet  = Q3AttributeSet_New();    assert(markerData.markerAttributeSet != NULL);    color.r = 1.0;  color.g = 1.0;  color.b = 0.4;    Q3AttributeSet_Add(markerData.markerAttributeSet, kQ3AttributeTypeDiffuseColor, &amp;color);    markerData.bitmap.image = (unsigned char*) gDroneAutoMarkerDataEqual;  gDroneAutoMarkerEqual = Q3Marker_New(&amp;markerData);  assert(gDroneAutoMarkerEqual != NULL);    markerData.bitmap.image = (unsigned char*) gDroneAutoMarkerDataAbove;  gDroneAutoMarkerAbove = Q3Marker_New(&amp;markerData);  assert(gDroneAutoMarkerAbove != NULL);    markerData.bitmap.image = (unsigned char*) gDroneAutoMarkerDataBelow;  gDroneAutoMarkerBelow = Q3Marker_New(&amp;markerData);  assert(gDroneAutoMarkerBelow != NULL);    Q3Object_Dispose(markerData.markerAttributeSet);  markerData.markerAttributeSet = NULL;}/* ============================================================================= *    Drone_Exit (external) * *  Prepares for exit. * ========================================================================== */void Drone_Exit(  void){  while (gDroneList != NULL)  {    Drone_Dispose(gDroneList);  }    if (gDroneAutoGeometry != NULL)  {    Q3Object_Dispose(gDroneAutoGeometry);    gDroneAutoGeometry = NULL;  }    if (gDroneAutoBurnGeometry != NULL)  {    Q3Object_Dispose(gDroneAutoBurnGeometry);    gDroneAutoBurnGeometry = NULL;  }    if (gDroneAutoExplosionGeometry != NULL)  {    Q3Object_Dispose(gDroneAutoExplosionGeometry);    gDroneAutoExplosionGeometry = NULL;  }    if (gDroneAutoSndIdle != NULL)  {    ReleaseResource((Handle) gDroneAutoSndIdle);    gDroneAutoSndIdle = NULL;  }    if (gDroneAutoSndBurn != NULL)  {    ReleaseResource((Handle) gDroneAutoSndBurn);    gDroneAutoSndBurn = NULL;  }    if (gDroneAutoSndExplosion != NULL)  {    ReleaseResource((Handle) gDroneAutoSndExplosion);    gDroneAutoSndExplosion = NULL;  }    if (gDroneBulletColor != NULL)  {    Q3Object_Dispose(gDroneBulletColor);    gDroneBulletColor = NULL;  }    if (gDroneNULLIllumination != NULL)  {    Q3Object_Dispose(gDroneNULLIllumination);    gDroneNULLIllumination = NULL;  }    if (gDroneView != NULL)  {    Q3Object_Dispose(gDroneView);    gDroneView = NULL;  }    if (gDroneDrawContext != NULL)  {    Q3Object_Dispose(gDroneDrawContext);    gDroneDrawContext = NULL;  }    if (gDroneCamera != NULL)  {    Q3Object_Dispose(gDroneCamera);    gDroneCamera = NULL;  }    if (gDronePick != NULL)  {    Q3Object_Dispose(gDronePick);    gDronePick = NULL;  }    if (gDroneAutoMarkerEqual != NULL)  {    Q3Object_Dispose(gDroneAutoMarkerEqual);    gDroneAutoMarkerEqual = NULL;  }    if (gDroneAutoMarkerAbove != NULL)  {    Q3Object_Dispose(gDroneAutoMarkerAbove);    gDroneAutoMarkerAbove = NULL;  }    if (gDroneAutoMarkerBelow != NULL)  {    Q3Object_Dispose(gDroneAutoMarkerBelow);    gDroneAutoMarkerBelow = NULL;  }}/* ============================================================================= *    Drone_New (internal) * *  Creates a new drone. * ========================================================================== */TDroneObject Drone_New(  TDroneOrder      inOrder){  TDroneObject    drone;  TDroneObject    prev;  TDroneObject    next;    // Allocate the memory  drone = (TDroneObject) malloc(sizeof(TDroneData));  assert(drone != NULL);    drone-&gt;thumbprint = kThumbprint_Dead;  // until finished with it    // Find where to insert it  prev = NULL;  next = gDroneList;  while (next != NULL &amp;&amp; next-&gt;order &lt; inOrder)  {    prev = next;    next = next-&gt;next;  }    // Link it into the list  drone-&gt;prev = prev;  drone-&gt;next = next;    if (prev != NULL)  {    prev-&gt;next = drone;  }  else  {    gDroneList = drone;  }    if (next != NULL)  {    next-&gt;prev = drone;  }    // Fill in the defaults  drone-&gt;moveMethod      = NULL;  drone-&gt;updateSoundMethod  = NULL;  drone-&gt;submitMethod      = NULL;  drone-&gt;pickSubmitMethod    = NULL;  drone-&gt;hitMethod      = NULL;    drone-&gt;order        = inOrder;    drone-&gt;mark          = false;    drone-&gt;position.x      = 0.0;  drone-&gt;position.y      = 0.0;  drone-&gt;position.z      = 0.0;    drone-&gt;position1.x      = 0.0;  drone-&gt;position1.y      = 0.0;  drone-&gt;position1.z      = 0.0;    drone-&gt;velocity.x      = 0.0;  drone-&gt;velocity.y      = 0.0;  drone-&gt;velocity.z      = 0.0;    drone-&gt;velocity1.x      = 0.0;  drone-&gt;velocity1.y      = 0.0;  drone-&gt;velocity1.z      = 0.0;    drone-&gt;acceleration.x    = 0.0;  drone-&gt;acceleration.y    = 0.0;  drone-&gt;acceleration.z    = 0.0;    drone-&gt;direction.x      = 1.0;  drone-&gt;direction.y      = 0.0;  drone-&gt;direction.z      = 0.0;    drone-&gt;up.x          = 0.0;  drone-&gt;up.y          = 1.0;  drone-&gt;up.z          = 0.0;    drone-&gt;cross.x        = 0.0;  drone-&gt;cross.y        = 0.0;  drone-&gt;cross.z        = 1.0;    drone-&gt;geometry        = NULL;    drone-&gt;autoSndChannel    = NULL;  drone-&gt;autoSource      = NULL;  drone-&gt;autoSound      = kAutoSound_None;    drone-&gt;autoInterest      = NULL;    drone-&gt;autoVelocity.x    = 0.0;  drone-&gt;autoVelocity.y    = 0.0;  drone-&gt;autoVelocity.z    = 0.0;    drone-&gt;autoMode        = kAutoMode_Idle;  drone-&gt;autoModeTimeout    = 0;  drone-&gt;autoDistance      = 0.0;  drone-&gt;autoExplosion    = 0.0;    drone-&gt;bulletOrigin.x    = 0.0;  drone-&gt;bulletOrigin.y    = 0.0;  drone-&gt;bulletOrigin.z    = 0.0;    return drone;}/* ============================================================================= *    SelfDrone_New (external) * *  Creates a new drone whose movement pattern is defined by user controls. * ========================================================================== */TDroneObject SelfDrone_New(  void){  TDroneObject    drone;    // Create the basic drone  drone = Drone_New(kDroneOrder_Self);  assert(drone != NULL);    // Fill in the fields  drone-&gt;moveMethod    = SelfDrone_Move;    Q3Vector3D_Scale(&amp;drone-&gt;direction, SELF_DRONE_INITIAL_SPEED, &amp;drone-&gt;autoVelocity);    // Validate it  drone-&gt;thumbprint    = kThumbprint_SelfDrone;    return drone;}// **************************** GetSSpFilterVersion ****************************// Finds the manufacturer and version number of the SoundSprocket filter that// may be installed.  inManufacturer should be the manufacturer code specified// at the installation time, which may be zero to allow any manufacturer.// If no error is encountered, outManufacturer is set to the actual manufacturer// code and outMajorVersion and outMinorVersion are set to the component// specification level and manufacturer's implementation revision, respectively.static OSStatus GetSSpFilterVersion(  OSType          inManufacturer,  OSType*          outManufacturer,  UInt32*          outMajorVersion,  UInt32*          outMinorVersion){  OSStatus        err;  ComponentDescription  description;  Component        componentRef;  UInt32          vers;    // Set up the component description    description.componentType      = kSoundEffectsType;    description.componentSubType    = kSSpLocalizationSubType;    description.componentManufacturer  = inManufacturer;    description.componentFlags      = 0;            description.componentFlagsMask    = 0;        // Find a component matching the description  componentRef = FindNextComponent(nil, &amp;description);  if (componentRef == nil)  return couldntGetRequiredComponent;    // Get the component description (for the manufacturer code)  err = GetComponentInfo(componentRef, &amp;description, nil, nil, nil);  if (err != noErr)  return err;    // Get the version composite  vers = (UInt32) GetComponentVersion((ComponentInstance) componentRef);    // Return the results  *outManufacturer = description.componentManufacturer;  *outMajorVersion = HiWord(vers);  *outMinorVersion = LoWord(vers);    return noErr;}/* ============================================================================= *    AutoDrone_New (external) * *  Creates a new drone whose movement pattern is under automatic control. * ========================================================================== */TDroneObject AutoDrone_New(  TDroneObject      inDroneOfInterest){  OSStatus      err;  TDroneObject    drone;  TQ3Vector3D      orientation;  SoundComponentLink  link;  OSType        manufacturer;  UInt32        majorVersion;  UInt32        minorVersion;    assert(inDroneOfInterest != NULL &amp;&amp; IS_DRONE(inDroneOfInterest));    // Create the basic drone  drone = Drone_New(kDroneOrder_Auto);  assert(drone != NULL);    // Fill in the fields  drone-&gt;moveMethod    = AutoDrone_Move;  drone-&gt;updateSoundMethod = AutoDrone_UpdateSound;  drone-&gt;submitMethod    = AutoDrone_Submit;  drone-&gt;pickSubmitMethod  = AutoDrone_PickSubmit;  drone-&gt;hitMethod    = AutoDrone_Hit;    // Allocate the sound channel and set up for 3D localized sound  drone-&gt;autoSndChannel  = NULL;  SndNewChannel(&amp;drone-&gt;autoSndChannel, sampledSynth, initMono, NULL);  assert(drone-&gt;autoSndChannel != NULL);    SSpSource_New(&amp;drone-&gt;autoSource);  assert(drone-&gt;autoSource != NULL);    link.description.componentType      = kSoundEffectsType;  link.description.componentSubType    = kSSpLocalizationSubType;  link.description.componentManufacturer  = 0;  link.description.componentFlags      = 0;          link.description.componentFlagsMask    = 0;      link.mixerID              = nil;  link.linkID                = nil;    SndSetInfo(drone-&gt;autoSndChannel, siPreMixerSoundComponent, &amp;link);    // Verify that the right version filter was installed  if (gDroneAutoCheckFilterVersion)  {    err = GetSSpFilterVersion(        link.description.componentManufacturer,        &amp;manufacturer,        &amp;majorVersion,        &amp;minorVersion);        if (err != noErr)    {      // Filter must not be installed      // Note: A normal application would bail on 3D sound here      StopAlert(kAlrtID_FilterNotInstalled, NULL);    }    else    {      // The major version represents the component specification level      if (majorVersion &lt; 1)      {        //* if we couldn't handle some old version, we could bail here.                StopAlert(kAlrtID_FilterVersion, NULL);        // Note: A normal application would bail on 3D sound here        gSoundOn = false;      }      else      {        // The minor version specifies the manufacturer's implementation revision                //* could do something here is we needed to handle tweaks for specific        //* manufacturers or versions.      }    }        gDroneAutoCheckFilterVersion = false;  }  if (gSoundOn)  {    // The sound is loudest out the back of the model    Q3Vector3D_Set(&amp;orientation, -1.0, 0.0, 0.0);    SSpSource_SetOrientation(drone-&gt;autoSource, &amp;orientation);  }    drone-&gt;autoInterest    = inDroneOfInterest;  drone-&gt;geometry      = Q3Shared_GetReference(gDroneAutoGeometry);    drone-&gt;position.x    += Random()*0.0001 + AUTO_DRONE_LEAD;  drone-&gt;position.y    += Random()*0.0001;  drone-&gt;position.z    += Random()*0.0001;    drone-&gt;autoVelocity.x  += Random()*0.0001;  drone-&gt;autoVelocity.y  += Random()*0.0001;  drone-&gt;autoVelocity.z  += Random()*0.0001;    // Validate it  drone-&gt;thumbprint    = kThumbprint_AutoDrone;    return drone;}/* ============================================================================= *    BulletDrone_New (external) * *  Creates a new drone whose behavior is projectile. * ========================================================================== */TDroneObject BulletDrone_New(  const TQ3Point3D*    inPosition,  const TQ3Vector3D*    inDirection){  TDroneObject      drone;    assert(inPosition != NULL);  assert(inDirection != NULL);    // Create the basic drone  drone = Drone_New(kDroneOrder_Bullet);  assert(drone != NULL);    // Fill in the fields  drone-&gt;moveMethod    = BulletDrone_Move;  drone-&gt;submitMethod    = BulletDrone_Submit;    drone-&gt;position      = *inPosition;  drone-&gt;direction    = *inDirection;    drone-&gt;bulletOrigin    = *inPosition;    // Validate it  drone-&gt;thumbprint    = kThumbprint_BulletDrone;    return drone;}/* ============================================================================= *    Drone_Dispose (external) * *  Disposes of the drone. * ========================================================================== */void Drone_Dispose(  TDroneObject      inDrone){  assert(inDrone != NULL &amp;&amp; IS_DRONE(inDrone));    // Unlink it from the list  if (inDrone-&gt;prev != NULL)  {    inDrone-&gt;prev-&gt;next = inDrone-&gt;next;  }  else  {    gDroneList = inDrone-&gt;next;  }    if (inDrone-&gt;next != NULL)  {    inDrone-&gt;next-&gt;prev = inDrone-&gt;prev;  }    // Dispose stuff  if (inDrone-&gt;geometry != NULL)  {    Q3Object_Dispose(inDrone-&gt;geometry);    inDrone-&gt;geometry = NULL;  }    // Free the sound channel  //* This rightly belongs in AutoDrone_Dispose  if (inDrone-&gt;autoSource != NULL)  {    SSpSource_Dispose(inDrone-&gt;autoSource);    inDrone-&gt;autoSource = NULL;  }    if (inDrone-&gt;autoSndChannel != NULL)  {    SndDisposeChannel(inDrone-&gt;autoSndChannel, true);    inDrone-&gt;autoSndChannel = NULL;  }    // Dispose of the memory  inDrone-&gt;thumbprint = kThumbprint_Dead;  free(inDrone);}/* ============================================================================= *    Drone_Next (external) * *  If inDrone is NULL, then the head of the drone list is returned.  If inDrone *  is non-NULL, then the next drone in the list is returned.  If inDrone is the *  last drone, then NULL is returned. * ========================================================================== */TDroneObject Drone_Next(  TDroneObject      inDrone){  TDroneObject      result;    if (inDrone != NULL)  {    assert(IS_DRONE(inDrone));        result = inDrone-&gt;next;  }  else  {    result = gDroneList;  }    return result;}/* ============================================================================= *    Drone_Move (external) * *  Moves the drone forward one time step.  This may mark the drone for death. * ========================================================================== */void Drone_Move(  TDroneObject      inDrone){  assert(inDrone != NULL &amp;&amp; IS_DRONE(inDrone));    // Move the drone by its own rules  assert(inDrone-&gt;moveMethod != NULL);  (inDrone-&gt;moveMethod)(inDrone);    // Drone is still alive -- compute the velocity and acceleration  Q3Point3D_Subtract(&amp;inDrone-&gt;position, &amp;inDrone-&gt;position1, &amp;inDrone-&gt;velocity);  Q3Vector3D_Scale(&amp;inDrone-&gt;velocity, gGameFramesPerSecond, &amp;inDrone-&gt;velocity);  inDrone-&gt;position1 = inDrone-&gt;position;    Q3Vector3D_Subtract(&amp;inDrone-&gt;velocity, &amp;inDrone-&gt;velocity1, &amp;inDrone-&gt;acceleration);  Q3Vector3D_Scale(&amp;inDrone-&gt;acceleration, gGameFramesPerSecond, &amp;inDrone-&gt;acceleration);  inDrone-&gt;velocity1 = inDrone-&gt;velocity;    // Reorthogonalize the up and cross vectors  assert(fabs(Q3Vector3D_Length(&amp;inDrone-&gt;direction) - 1.0) &lt; 0.05);    Q3Vector3D_Cross(&amp;inDrone-&gt;direction, &amp;inDrone-&gt;up, &amp;inDrone-&gt;cross);  Q3Vector3D_Normalize(&amp;inDrone-&gt;cross, &amp;inDrone-&gt;cross);    Q3Vector3D_Cross(&amp;inDrone-&gt;cross, &amp;inDrone-&gt;direction, &amp;inDrone-&gt;up);}/* ============================================================================= *    AutoDrone_Move (internal) * *  Moves the drone forward one time step.  The autopilot drone has a constant *  thrust along its direction of orientation.  The direction is controlled to *  point just in front of the drone of interest. * ========================================================================== */void AutoDrone_Move(  TDroneObject      inDrone){  TQ3Vector3D        newDirection;  TQ3Vector3D        v1;  TQ3Vector3D        v2;  TQ3Point3D        target;  float          distance;  float          turnRate;  float          limit;  TAutoSound        newSound;  SndCommand        sndCommand;  long          base;  TQ3Matrix4x4      matrix;    assert(inDrone != NULL &amp;&amp; IS_AUTO_DRONE(inDrone));    // Figure out new direction  if (inDrone-&gt;autoMode == kAutoMode_Explosion)  {    // Point the explosion geometry at the camera    //* NOTE: For now, we assume that the camera is at the drone of interest    //* This is wrong for two reasons.  First, the camera could actually be    //* elsewhere.  Second, this assumes that the drone of interest moves    //* before this drone.    Q3Point3D_Subtract(        &amp;inDrone-&gt;autoInterest-&gt;position,        &amp;inDrone-&gt;position,        &amp;newDirection);        Q3Vector3D_Normalize(&amp;newDirection, &amp;inDrone-&gt;direction);  }  else  {    // Find a point in front of the drone of interest    assert(IS_DRONE(inDrone-&gt;autoInterest));        Q3Vector3D_Scale(&amp;inDrone-&gt;autoInterest-&gt;direction, AUTO_DRONE_LEAD, &amp;v1);    Q3Point3D_Vector3D_Add(&amp;inDrone-&gt;autoInterest-&gt;position, &amp;v1, &amp;target);        // Point toward the target    Q3Point3D_Subtract(&amp;target, &amp;inDrone-&gt;position, &amp;newDirection);    Q3Vector3D_Normalize(&amp;newDirection, &amp;newDirection);        // Limit the turn rate    turnRate = acosf(Q3Vector3D_Dot(&amp;inDrone-&gt;direction, &amp;newDirection));    limit = AUTO_DRONE_TURN_RATE*gGameInterval;    if (turnRate &gt; limit)    {      // Limit the turn      // Note: this should actually be spherical interpolation -- but linear is close enough      turnRate = limit/turnRate;      Q3Vector3D_Scale(&amp;inDrone-&gt;direction, 1.0-turnRate, &amp;v1);      Q3Vector3D_Scale(&amp;newDirection, turnRate, &amp;v2);      Q3Vector3D_Add(&amp;v1, &amp;v2, &amp;inDrone-&gt;direction);      Q3Vector3D_Normalize(&amp;inDrone-&gt;direction, &amp;inDrone-&gt;direction);    }    else    {      // It's OK to make the desired turn      inDrone-&gt;direction = newDirection;    }  }    // Figure out new position  switch (inDrone-&gt;autoMode)  {    case kAutoMode_Idle: // Start a burn if we are getting farther from the target      // Start burn if we are getting farther from the target      distance = Q3Point3D_Distance(&amp;inDrone-&gt;position, &amp;target);      if (inDrone-&gt;autoDistance &gt; distance)      {        // Getting closer to target -- don't change        inDrone-&gt;autoDistance = distance;      }      else      {        // Getting farther from target -- start a burn        inDrone-&gt;autoMode = kAutoMode_Burn;        inDrone-&gt;autoModeTimeout = TickCount() + (unsigned long) (AUTO_DRONE_BURN_TIME*60);      }    break;        case kAutoMode_Burn: // Accelerate toward the target      // Continue the burn?      if (TickCount() &lt;= inDrone-&gt;autoModeTimeout)      {        // Still burning -- change the velocity by accelerating toward the target        Q3Vector3D_Scale(&amp;inDrone-&gt;direction, gGameInterval*AUTO_DRONE_ACCEL, &amp;v1);        Q3Vector3D_Add(&amp;inDrone-&gt;autoVelocity, &amp;v1, &amp;inDrone-&gt;autoVelocity);      }      else      {        // Switch to rest mode        inDrone-&gt;autoMode = kAutoMode_Rest;        inDrone-&gt;autoModeTimeout = TickCount() + (unsigned long) (AUTO_DRONE_REST_TIME*60);      }    break;        case kAutoMode_Rest: // Don't use the engine for a while      // Continue the rest?      if (TickCount() &lt;= inDrone-&gt;autoModeTimeout)      {        // Still resting        // (do nothing)      }      else      {        // Switch to idle mode        inDrone-&gt;autoMode = kAutoMode_Idle;        inDrone-&gt;autoDistance = Q3Point3D_Distance(&amp;inDrone-&gt;position, &amp;target);      }    break;        case kAutoMode_Explosion: // Show the explosion for a while      // Continue the explosion?      inDrone-&gt;autoExplosion += gGameInterval/AUTO_DRONE_EXPLOSION_TIME;      if (inDrone-&gt;autoExplosion &lt;= 1.0)      {        // Still exploding        inDrone-&gt;autoVelocity.x =        inDrone-&gt;autoVelocity.y =        inDrone-&gt;autoVelocity.z = 0.0;      }      else      {        // Kill the drone        Drone_SetMark(inDrone, true);      }    break;        default:      assert(0);  }    // Move along the new velocity vector  Q3Vector3D_Scale(&amp;inDrone-&gt;autoVelocity, gGameInterval, &amp;v1);  Q3Point3D_Vector3D_Add(&amp;inDrone-&gt;position, &amp;v1, &amp;inDrone-&gt;position);    if (gSoundOn)  {    // Choose the next sound to play    switch (inDrone-&gt;autoMode)    {      case kAutoMode_Idle:      case kAutoMode_Rest:        newSound = kAutoSound_Idle;      break;            case kAutoMode_Burn:        newSound = kAutoSound_Burn;      break;            break;            case kAutoMode_Explosion:        newSound = kAutoSound_Explosion;      break;            default:        assert(0);    }        // Change the sound    if (inDrone-&gt;autoSound != newSound)    {      // Stop the old sound      if (inDrone-&gt;autoSound != kAutoSound_None)      {        sndCommand.cmd = quietCmd;        sndCommand.param1 = 0;        sndCommand.param2 = 0;        SndDoImmediate(inDrone-&gt;autoSndChannel, &amp;sndCommand);      }            inDrone-&gt;autoSound = newSound;            // Play the new sound      switch (inDrone-&gt;autoSound)      {        case kAutoSound_None:          base = 0;        break;                case kAutoSound_Idle:          base = (long) *gDroneAutoSndIdle + gDroneAutoSndIdleOffset;          SSpSource_SetAngularAttenuation(inDrone-&gt;autoSource, 0.0, 0.0);          SSpSource_SetReferenceDistance(inDrone-&gt;autoSource, AUTO_DRONE_IDLE_REF_DIST);        break;                case kAutoSound_Burn:          base = (long) *gDroneAutoSndBurn + gDroneAutoSndBurnOffset;          SSpSource_SetAngularAttenuation(inDrone-&gt;autoSource, 1.5, -12.0);          SSpSource_SetReferenceDistance(inDrone-&gt;autoSource, AUTO_DRONE_BURN_REF_DIST);        break;                case kAutoSound_Explosion:          base = (long) *gDroneAutoSndExplosion + gDroneAutoSndExplosionOffset;          SSpSource_SetAngularAttenuation(inDrone-&gt;autoSource, 0.0, 0.0);          SSpSource_SetReferenceDistance(inDrone-&gt;autoSource, AUTO_DRONE_EXPL_REF_DIST);        break;                default:          assert(0);      }            if (base != 0)      {        // Install the sound        sndCommand.cmd = soundCmd;        sndCommand.param1 = 0;        sndCommand.param2 = base;        SndDoImmediate(inDrone-&gt;autoSndChannel, &amp;sndCommand);                // Play it indefinitely        sndCommand.cmd = freqCmd;        sndCommand.param1 = 0;        sndCommand.param2 = 60;        SndDoImmediate(inDrone-&gt;autoSndChannel, &amp;sndCommand);      }    }        // Change the sound source location    Drone_GetMatrix(inDrone, &amp;matrix);    SSpSource_SetTransform(inDrone-&gt;autoSource, &amp;matrix);  }}/* ============================================================================= *    BulletDrone_Move (internal) * *  Moves the drone forward one time step. * ========================================================================== */void BulletDrone_Move(  TDroneObject      inDrone){  TQ3Vector3D        v;  float          prevDistance;  float          currDistance;  TQ3CameraPlacement    placement;  TDroneObject      target;  unsigned long      count;  unsigned long      index;    assert(inDrone != NULL &amp;&amp; IS_BULLET_DRONE(inDrone));    // Move the bullet  prevDistance = Q3Point3D_Distance(&amp;inDrone-&gt;position, &amp;inDrone-&gt;bulletOrigin);    Q3Vector3D_Scale(&amp;inDrone-&gt;direction, gGameInterval*BULLET_DRONE_SPEED, &amp;v);  Q3Point3D_Vector3D_Add(&amp;inDrone-&gt;position, &amp;v, &amp;inDrone-&gt;position);    currDistance = Q3Point3D_Distance(&amp;inDrone-&gt;position, &amp;inDrone-&gt;bulletOrigin);    // Time to expire?  if (currDistance &gt; BULLET_DRONE_LIMIT)  {    // Mark the drone to die    Drone_SetMark(inDrone, true);  }  else  {    // Set up for collision detection    placement.cameraLocation  = inDrone-&gt;bulletOrigin;    placement.upVector      = inDrone-&gt;up;        Q3Point3D_Vector3D_Add(&amp;inDrone-&gt;bulletOrigin, &amp;inDrone-&gt;direction, &amp;placement.pointOfInterest);        Q3Camera_SetPlacement(gDroneCamera, &amp;placement);        // Collision detection with all target drones    Q3View_StartPicking(gDroneView, gDronePick);    do    {      for (target = Drone_Next(NULL); target != NULL; target = Drone_Next(target))      {        // Submit the drone geometry, along with a PickID that is the object reference        Q3PickIDStyle_Submit((unsigned long) target, gDroneView);        Drone_PickSubmit(target, gDroneView);      }    }    while (Q3View_EndPicking(gDroneView) == kQ3ViewStatusRetraverse);        // Check the hit list    Q3Pick_GetNumHits(gDronePick, &amp;count);    for (index = 0; index &lt; count; index++)    {    UInt32  pickGood, maskGood;          Q3Pick_GetPickDetailData(gDronePick, index, kQ3PickDetailMaskPickID, &amp;pickGood);      Q3Pick_GetPickDetailData(gDronePick, index, kQ3PickDetailMaskDistance, &amp;maskGood);            if (pickGood &amp;&amp; maskGood)      {        Q3Pick_GetPickDetailData(gDronePick, index, kQ3PickDetailMaskPickID, &amp;target);                if (target != NULL &amp;&amp; IS_DRONE(target))        {          // Got a valid hit -- check its range          //* Should it be a bullet or a laser?//          if ((1 || prevDistance &lt;= hitData.distance) &amp;&amp; hitData.distance &lt;= currDistance)          if (true)          {            // Hit it!            Drone_Hit(target);                        // Kill the bullet            Drone_SetMark(inDrone, true);            break;          }        }      }      //      Q3Hit_EmptyData(&amp;hitData);    }        // Empty out the pick hits    Q3Pick_EmptyHitList(gDronePick);  }}/* ============================================================================= *    Drone_UpdateSound (external) * *  Updates localized sounds for this drone.  The default method does nothing. * ========================================================================== */void Drone_UpdateSound(  TDroneObject      inDrone){  assert(inDrone != NULL &amp;&amp; IS_DRONE(inDrone));    if (inDrone-&gt;updateSoundMethod != NULL)  {    (inDrone-&gt;updateSoundMethod)(inDrone);  }}/* ============================================================================= *    AutoDrone_UpdateSound (external) * *  Updates localized sounds for this autopilot drone. * ========================================================================== */void AutoDrone_UpdateSound(  TDroneObject      inDrone){  SSpLocalizationData        snd3DInfo;    assert(inDrone != NULL &amp;&amp; IS_AUTO_DRONE(inDrone));    if (gSoundOn)  {    SSpSource_CalcLocalization(inDrone-&gt;autoSource, Sound_GetListener(), &amp;snd3DInfo);        SndSetInfo(inDrone-&gt;autoSndChannel, siSSpLocalization, &amp;snd3DInfo);  }}/* ============================================================================= *    Drone_Submit (external) * *  Submits the drone for drawing. * ========================================================================== */void Drone_Submit(  TDroneObject      inDrone,  Boolean          inHUDVisible,  TQ3ViewObject      inView){  TQ3Matrix4x4      matrix;    assert(inDrone != NULL &amp;&amp; IS_DRONE(inDrone));    if (inDrone-&gt;submitMethod != NULL)  {    // Use the submit method    (inDrone-&gt;submitMethod)(inDrone, inHUDVisible, inView);  }  else if (inDrone-&gt;geometry != NULL)  {    // Submit the geometry    Drone_GetMatrix(inDrone, &amp;matrix);        Q3Push_Submit(inView);    Q3MatrixTransform_Submit(&amp;matrix, inView);    Q3Object_Submit(inDrone-&gt;geometry, inView);    Q3Pop_Submit(inView);  }}/* ============================================================================= *    AutoDrone_Submit (internal) * *  Submits the bullet drone for drawing. * ========================================================================== */void AutoDrone_Submit(  TDroneObject      inDrone,  Boolean          inHUDVisible,  TQ3ViewObject      inView){  TQ3Matrix4x4      matrix;  TQ3ColorRGB        transparency;  TQ3Point3D        position;  TQ3Vector3D        direction;  TQ3Vector3D        up;  TQ3Vector3D        right;  TQ3Vector3D        v;  TQ3Vector3D        v1;  TQ3Vector3D        v2;  float          height;  TQ3GeometryObject    marker;    assert(inDrone != NULL &amp;&amp; IS_AUTO_DRONE(inDrone));  assert(inView != NULL);    // Draw the drone  Q3Push_Submit(inView);    Drone_GetMatrix(inDrone, &amp;matrix);  Q3MatrixTransform_Submit(&amp;matrix, inView);    switch (inDrone-&gt;autoMode)  {    case kAutoMode_Burn:      Q3Object_Submit(gDroneAutoBurnGeometry, inView);      /* FALL THROUGH TO SUBMIT DRONE GEOMETRY */        case kAutoMode_Rest:    case kAutoMode_Idle:      Q3Object_Submit(inDrone-&gt;geometry, inView);    break;        case kAutoMode_Explosion:      // Grow the explosion      v.x = v.y = v.z = (1.0-AUTO_DRONE_MIN_SCALE)*inDrone-&gt;autoExplosion + AUTO_DRONE_MIN_SCALE;      Q3ScaleTransform_Submit(&amp;v, inView);            // Fade at the end      if (inDrone-&gt;autoExplosion &gt; (1.0-AUTO_DRONE_FADE_TIME))      {        transparency.r =        transparency.g =        transparency.b = (-1.0/AUTO_DRONE_FADE_TIME)*inDrone-&gt;autoExplosion + (1.0/AUTO_DRONE_FADE_TIME);                Q3Attribute_Submit(kQ3AttributeTypeTransparencyColor, &amp;transparency, inView);      }            // Submit the explosion geometry      Q3Object_Submit(gDroneAutoExplosionGeometry, inView);    break;        default:      assert(0);  }    Q3Pop_Submit(inView);    // Draw the HUD marker for the drone  if (inHUDVisible &amp;&amp; inDrone-&gt;autoMode != kAutoMode_Explosion)  {    Display_GetViewerPosition(&amp;position, &amp;direction, &amp;up);    Q3Vector3D_Cross(&amp;direction, &amp;up, &amp;right);        Q3Point3D_Subtract(&amp;inDrone-&gt;position, &amp;position, &amp;v);        Q3Vector3D_Scale(&amp;up,    HUD_SCALE*Q3Vector3D_Dot(&amp;direction, &amp;v), &amp;v1);    Q3Vector3D_Scale(&amp;right, HUD_SCALE*Q3Vector3D_Dot(&amp;right,     &amp;v), &amp;v2);        Q3Point3D_Vector3D_Add(&amp;position, &amp;direction, &amp;position);    Q3Point3D_Vector3D_Add(&amp;position, &amp;v1,        &amp;position);    Q3Point3D_Vector3D_Add(&amp;position, &amp;v2,        &amp;position);        Q3Vector3D_Normalize(&amp;v, &amp;v);    height = Q3Vector3D_Dot(&amp;up, &amp;v);    if (height &gt;= HUD_HEIGHT)    {      marker = gDroneAutoMarkerAbove;    }    else if (height &lt;= -HUD_HEIGHT)    {      marker = gDroneAutoMarkerBelow;    }    else    {      marker = gDroneAutoMarkerEqual;    }        Q3Marker_SetPosition(marker, &amp;position);    Q3Object_Submit(marker, inView);  }}/* ============================================================================= *    BulletDrone_Submit (internal) * *  Submits the bullet drone for drawing. * ========================================================================== */void BulletDrone_Submit(  TDroneObject      inDrone,  Boolean          inHUDVisible,  TQ3ViewObject      inView){  TQ3LineData        lineData;    assert(inDrone != NULL &amp;&amp; IS_BULLET_DRONE(inDrone));  assert(inView != NULL);    lineData.vertices[0].point      = inDrone-&gt;bulletOrigin;  lineData.vertices[0].attributeSet  = NULL;  lineData.vertices[1].point      = inDrone-&gt;position;  lineData.vertices[1].attributeSet  = NULL;  lineData.lineAttributeSet      = NULL;    Q3Push_Submit(inView);  Q3Object_Submit(gDroneNULLIllumination, inView);  Q3Object_Submit(gDroneBulletColor, inView);  Q3Line_Submit(&amp;lineData, inView);  Q3Pop_Submit(inView);}/* ============================================================================= *    Drone_PickSubmit (internal) * *  Submits the drone for picking against a bullet.  It forwards to the actual *  drone hit method, if any. * ========================================================================== */void Drone_PickSubmit(  TDroneObject      inDrone,  TQ3ViewObject      inView){  assert(inDrone != NULL &amp;&amp; IS_DRONE(inDrone));    if (inDrone-&gt;pickSubmitMethod != NULL)  {    (*inDrone-&gt;pickSubmitMethod)(inDrone, inView);  }}/* ============================================================================= *    AutoDrone_PickSubmit (internal) * *  Submits the autopilot drone for picking against a bullet. * ========================================================================== */void AutoDrone_PickSubmit(  TDroneObject      inDrone,  TQ3ViewObject      inView){  TQ3Matrix4x4      matrix;    assert(inDrone != NULL &amp;&amp; IS_AUTO_DRONE(inDrone));  assert(inView != NULL);    // Draw the drone  if (inDrone-&gt;autoMode != kAutoMode_Explosion)  {    Q3Push_Submit(inView);        Drone_GetMatrix(inDrone, &amp;matrix);    Q3MatrixTransform_Submit(&amp;matrix, inView);        Q3Object_Submit(gDroneAutoBurnGeometry, inView);        Q3Pop_Submit(inView);  }}/* ============================================================================= *    Drone_Hit (internal) * *  Called when this drone is hit.  It forwards to the actual drone hit method, *  if any. * ========================================================================== */void Drone_Hit(  TDroneObject      inDrone){  assert(inDrone != NULL &amp;&amp; IS_DRONE(inDrone));    if (inDrone-&gt;hitMethod != NULL)  {    (*inDrone-&gt;hitMethod)(inDrone);  }}/* ============================================================================= *    AutoDrone_Hit (internal) * *  Called when this autopilot drone is hit.  It puts the drone into *  explosion mode. * ========================================================================== */void AutoDrone_Hit(  TDroneObject      inDrone){  assert(inDrone != NULL &amp;&amp; IS_AUTO_DRONE(inDrone));    inDrone-&gt;autoMode = kAutoMode_Explosion;  inDrone-&gt;autoExplosion = 0.0;}/* ============================================================================= *    Drone_SetMark (external) * *  Changes the drone's mark to the given value.  The mark is used to indicate *  which drones should die. * ========================================================================== */void Drone_SetMark(  TDroneObject      inDrone,  Boolean          inMark){  assert(inDrone != NULL &amp;&amp; IS_DRONE(inDrone));    inDrone-&gt;mark = inMark;}/* ============================================================================= *    Drone_GetMark (external) * *  Returns the drone's mark. * ========================================================================== */Boolean Drone_GetMark(  TDroneObject      inDrone){  assert(inDrone != NULL &amp;&amp; IS_DRONE(inDrone));    return inDrone-&gt;mark;}/* ============================================================================= *    Drone_GetPosition (external) * *  Returns the current position in outPosition. * ========================================================================== */void Drone_GetPosition(  TDroneObject      inDrone,  TQ3Point3D*        outPosition){  assert(inDrone != NULL &amp;&amp; IS_DRONE(inDrone));  assert(outPosition != NULL);    *outPosition = inDrone-&gt;position;}/* ============================================================================= *    Drone_GetVelocity (external) * *  Returns the current velocity in outVelocity * ========================================================================== */void Drone_GetVelocity(  TDroneObject      inDrone,  TQ3Vector3D*      outVelocity){  assert(inDrone != NULL &amp;&amp; IS_DRONE(inDrone));  assert(outVelocity != NULL);    *outVelocity = inDrone-&gt;velocity;}/* ============================================================================= *    Drone_GetDirection (external) * *  Returns the current direction in outDirection. * ========================================================================== */void Drone_GetDirection(  TDroneObject      inDrone,  TQ3Vector3D*      outDirection){  assert(inDrone != NULL &amp;&amp; IS_DRONE(inDrone));  assert(outDirection != NULL);    *outDirection = inDrone-&gt;direction;}/* ============================================================================= *    Drone_GetUp (external) * *  Returns the current up vector in outUp. * ========================================================================== */void Drone_GetUp(  TDroneObject      inDrone,  TQ3Vector3D*      outUp){  assert(inDrone != NULL &amp;&amp; IS_DRONE(inDrone));  assert(outUp != NULL);    *outUp = inDrone-&gt;up;}/* ============================================================================= *    Drone_GetMatrix (external) * *  Returns the matrix that transforms to the drone position and orientation. * ========================================================================== */void Drone_GetMatrix(  TDroneObject      inDrone,  TQ3Matrix4x4*      outMatrix){  assert(inDrone != NULL &amp;&amp; IS_DRONE(inDrone));  assert(outMatrix != NULL);    outMatrix-&gt;value[0][0] = inDrone-&gt;direction.x;  outMatrix-&gt;value[0][1] = inDrone-&gt;direction.y;  outMatrix-&gt;value[0][2] = inDrone-&gt;direction.z;    outMatrix-&gt;value[1][0] = inDrone-&gt;up.x;  outMatrix-&gt;value[1][1] = inDrone-&gt;up.y;  outMatrix-&gt;value[1][2] = inDrone-&gt;up.z;    outMatrix-&gt;value[2][0] = inDrone-&gt;cross.x;  outMatrix-&gt;value[2][1] = inDrone-&gt;cross.y;  outMatrix-&gt;value[2][2] = inDrone-&gt;cross.z;    outMatrix-&gt;value[3][0] = inDrone-&gt;position.x;  outMatrix-&gt;value[3][1] = inDrone-&gt;position.y;  outMatrix-&gt;value[3][2] = inDrone-&gt;position.z;    outMatrix-&gt;value[0][3] = 0.0;  outMatrix-&gt;value[1][3] = 0.0;  outMatrix-&gt;value[2][3] = 0.0;  outMatrix-&gt;value[3][3] = 1.0;}/* ============================================================================= *    Drone_Fire (external) * *  Called each time the fire button is pressed. * ========================================================================== */void Drone_Fire(  TDroneObject      inDrone){  TQ3Vector3D        up;  TQ3Vector3D        cross;  TQ3Point3D        origin;    assert(inDrone != NULL &amp;&amp; IS_DRONE(inDrone));    // Find the offsets  Q3Vector3D_Scale(&amp;inDrone-&gt;up,    BULLET_DRONE_OFFSET, &amp;up);  Q3Vector3D_Scale(&amp;inDrone-&gt;cross,  BULLET_DRONE_OFFSET, &amp;cross);    // Fire one  Q3Point3D_Vector3D_Subtract(&amp;inDrone-&gt;position, &amp;up, &amp;origin);  Q3Point3D_Vector3D_Subtract(&amp;origin, &amp;cross, &amp;origin);  BulletDrone_New(&amp;origin, &amp;inDrone-&gt;direction);    // Fire two  Q3Point3D_Vector3D_Subtract(&amp;inDrone-&gt;position, &amp;up, &amp;origin);  Q3Point3D_Vector3D_Add(&amp;origin, &amp;cross, &amp;origin);  BulletDrone_New(&amp;origin, &amp;inDrone-&gt;direction);}/* ============================================================================= *    Drone_Silence (external) * *  Silences any drone sounds. * ========================================================================== */void Drone_Silence(  TDroneObject      inDrone){  SndCommand        sndCommand;    assert(inDrone != NULL &amp;&amp; IS_DRONE(inDrone));    //* We should really do this as AutoDrone_Silence, but whatever...    if (inDrone-&gt;autoSndChannel != NULL)  {    // Purge any pending commands    sndCommand.cmd = flushCmd;    sndCommand.param1 = 0;    sndCommand.param2 = 0;    SndDoImmediate(inDrone-&gt;autoSndChannel, &amp;sndCommand);          // Quiet the current sound    sndCommand.cmd = quietCmd;    sndCommand.param1 = 0;    sndCommand.param2 = 0;    SndDoImmediate(inDrone-&gt;autoSndChannel, &amp;sndCommand);  }}/* ============================================================================= *    SelfDrone_Move (internal) * *  Moves the drone forward one time step. * ========================================================================== */void SelfDrone_Move(  TDroneObject      inDrone){  TQ3Vector3D        v;    assert(inDrone != NULL &amp;&amp; IS_SELF_DRONE(inDrone));    // Move along the velocity vector  Q3Vector3D_Scale(&amp;inDrone-&gt;autoVelocity, gGameInterval, &amp;v);  Q3Point3D_Vector3D_Add(&amp;inDrone-&gt;position, &amp;v, &amp;inDrone-&gt;position);#if  SELF_DRONE_HAS_FRICTION  // automatically slow ship down if no thrust (like friction)  Q3Vector3D_Scale(&amp;inDrone-&gt;autoVelocity, SELF_DRONE_FRICTION, &amp;inDrone-&gt;autoVelocity);#endif}/* ============================================================================= *    SelfDrone_Thrust (external) * *  Increases the velocity of the drone. * ========================================================================== */void SelfDrone_Thrust(  TDroneObject      inDrone,  float          inThrust){  TQ3Vector3D        v;    assert(inDrone != NULL &amp;&amp; IS_SELF_DRONE(inDrone));    // change the velocity by accelerating inThrust amount  Q3Vector3D_Scale(&amp;inDrone-&gt;direction, inThrust*SELF_DRONE_MAX_ACCEL, &amp;v);  Q3Vector3D_Add(&amp;inDrone-&gt;autoVelocity, &amp;v, &amp;inDrone-&gt;autoVelocity);}/* ============================================================================= *    SelfDrone_DampVelocity (external) * *  Increases the velocity of the drone. * ========================================================================== */void SelfDrone_DampVelocity(  TDroneObject      inDrone,  float          inDampingPercentage){  assert(inDrone != NULL &amp;&amp; IS_SELF_DRONE(inDrone));    // automatically slow ship down if no thrust (like friction)  Q3Vector3D_Scale(&amp;inDrone-&gt;autoVelocity, inDampingPercentage, &amp;inDrone-&gt;autoVelocity);}/* ============================================================================= *    SelfDrone_AllStop (external) * *  Increases the velocity of the drone. * ========================================================================== */void SelfDrone_InstantStop(  TDroneObject      inDrone){  assert(inDrone != NULL &amp;&amp; IS_SELF_DRONE(inDrone));    // automatically slow ship down if no thrust (like friction)  Q3Vector3D_Scale(&amp;inDrone-&gt;autoVelocity, 0.0, &amp;inDrone-&gt;autoVelocity);}/* ============================================================================= *    SelfDrone_Pitch (external) * *  Changes the direction of the ship by the given angles, in radians. * ========================================================================== */void SelfDrone_Pitch(  TDroneObject      inDrone,  float          inPitchAngle){  TQ3Vector3D        v1;  TQ3Vector3D        v2;    assert(inDrone != NULL &amp;&amp; IS_SELF_DRONE(inDrone));    if (inPitchAngle != 0.0)  {    Q3Vector3D_Scale(&amp;inDrone-&gt;direction, cosf(inPitchAngle), &amp;v1);    Q3Vector3D_Scale(&amp;inDrone-&gt;up,        sinf(inPitchAngle), &amp;v2);    Q3Vector3D_Add(&amp;v1, &amp;v2, &amp;inDrone-&gt;direction);  }}/* ============================================================================= *    SelfDrone_Yaw (external) * *  Changes the direction of the ship by the given angles, in radians. * ========================================================================== */void SelfDrone_Yaw(  TDroneObject      inDrone,  float          inYawAngle){  TQ3Vector3D        v1;  TQ3Vector3D        v2;    assert(inDrone != NULL &amp;&amp; IS_SELF_DRONE(inDrone));    if (inYawAngle != 0.0)  {    Q3Vector3D_Scale(&amp;inDrone-&gt;direction, cosf(inYawAngle), &amp;v1);    Q3Vector3D_Scale(&amp;inDrone-&gt;cross,     sinf(inYawAngle), &amp;v2);    Q3Vector3D_Add(&amp;v1, &amp;v2, &amp;inDrone-&gt;direction);  }}/* ============================================================================= *    SelfDrone_Roll (external) * *  Changes the direction of the ship by the given angles, in radians. * ========================================================================== */void SelfDrone_Roll(  TDroneObject      inDrone,  float          inRollAngle){  TQ3Vector3D        v1;  TQ3Vector3D        v2;    assert(inDrone != NULL &amp;&amp; IS_SELF_DRONE(inDrone));    if (inRollAngle != 0.0)  {    Q3Vector3D_Scale(&amp;inDrone-&gt;up,     cosf(inRollAngle), &amp;v1);    Q3Vector3D_Scale(&amp;inDrone-&gt;cross,   sinf(inRollAngle), &amp;v2);    Q3Vector3D_Add(&amp;v1, &amp;v2, &amp;inDrone-&gt;up);  }}/*{  matrix = BuildRotationMatrix (angle, x, y, z)    up = Multiply (up, matrix);    normalize?}*/</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/DroneZoneOld/listing3.html%3Fid%3DDTS10000051-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/DroneZoneOld/listing3.html%3Fid%3DDTS10000051-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/DroneZoneOld/listing3.html%3Fid%3DDTS10000051-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>