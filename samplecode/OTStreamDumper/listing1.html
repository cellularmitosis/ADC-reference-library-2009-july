<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>OTStreamDumper - /OTStreamDumper.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxCarbon-date.html">Carbon</a> &gt; <A HREF="javascript:location.replace('index.html');">OTStreamDumper</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/Carbon/idxNetworking-date.html" target="_blank">Carbon > Networking</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">OTStreamDumper</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/OTStreamDumper.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/OTStreamDumper.c</option></select>
				</p>
				</form>
				<p><strong><a href="OTStreamDumper.zip">Download Sample</a></strong> (&#147;OTStreamDumper.zip&#148;, 12.2K)<BR>
<strong><a href="OTStreamDumper.dmg">Download Sample</a></strong> (&#147;OTStreamDumper.dmg&#148;, 71.8K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*  File:    OTStreamDumper.c  Contains:  Stream module to strlog all data going by.  Written by:  Quinn &quot;The Eskimo!&quot;  Copyright:  Copyright &copy; 2000 by Apple Computer, Inc., All Rights Reserved.  Disclaimer:  IMPORTANT:  This Apple software is supplied to you by Apple Computer, Inc.        (&quot;Apple&quot;) in consideration of your agreement to the following terms, and your        use, installation, modification or redistribution of this Apple software        constitutes acceptance of these terms.  If you do not agree with these terms,        please do not use, install, modify or redistribute this Apple software.        In consideration of your agreement to abide by the following terms, and subject        to these terms, Apple grants you a personal, non-exclusive license, under Apple's        copyrights in this original Apple software (the &quot;Apple Software&quot;), to use,        reproduce, modify and redistribute the Apple Software, with or without        modifications, in source and/or binary forms; provided that if you redistribute        the Apple Software in its entirety and without modifications, you must retain        this notice and the following text and disclaimers in all such redistributions of        the Apple Software.  Neither the name, trademarks, service marks or logos of        Apple Computer, Inc. may be used to endorse or promote products derived from the        Apple Software without specific prior written permission from Apple.  Except as        expressly stated in this notice, no other rights or licenses, express or implied,        are granted by Apple herein, including but not limited to any patent rights that        may be infringed by your derivative works or by other works in which the Apple        Software may be incorporated.        The Apple Software is provided by Apple on an &quot;AS IS&quot; basis.  APPLE MAKES NO        WARRANTIES, EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION THE IMPLIED        WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY AND FITNESS FOR A PARTICULAR        PURPOSE, REGARDING THE APPLE SOFTWARE OR ITS USE AND OPERATION ALONE OR IN        COMBINATION WITH YOUR PRODUCTS.        IN NO EVENT SHALL APPLE BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL OR        CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE        GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)        ARISING IN ANY WAY OUT OF THE USE, REPRODUCTION, MODIFICATION AND/OR DISTRIBUTION        OF THE APPLE SOFTWARE, HOWEVER CAUSED AND WHETHER UNDER THEORY OF CONTRACT, TORT        (INCLUDING NEGLIGENCE), STRICT LIABILITY OR OTHERWISE, EVEN IF APPLE HAS BEEN        ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  Change History (most recent first):*//////////////////////////////////////////////////////////////////// MIB Setup// Rather than include &quot;MoreSetup.h&quot; I just declare my assert routine // inline (see below).  This module is meant as a programming tool, not // for end user machines.// Mac OS Interfaces#include &lt;OpenTransportKernel.h&gt;/////////////////////////////////////////////////////////////////////static void MoreAssertQ(Boolean mustBeTrue){  if ( ! mustBeTrue ) {    DebugStr(&quot;\pMoreAssertQ: Assertion failure.&quot;);  }}/////////////////////////////////////////////////////////////////////#pragma mark ----- Data Structures -----enum {  kStreamDumpPerStreamDataMagic = 'StrD'};struct PerStreamData{  OSType         magic;        // must be kStreamDumpPerStreamDataMagic  UInt16        streamID;};typedef struct PerStreamData PerStreamData, *PerStreamDataPtr;static PerStreamDataPtr GetPerStreamData(queue_t* readOrWriteQ)  // Get the per-stream data for the given queue.  //  // Environment: any standard STREAMS entry point{  PerStreamDataPtr streamData;    streamData = (PerStreamDataPtr) readOrWriteQ-&gt;q_ptr;  MoreAssertQ(streamData != nil);  MoreAssertQ(streamData-&gt;magic == kStreamDumpPerStreamDataMagic);    return streamData;}static char* gStreamList = nil;static UInt16 gNextStreamID = 0;/////////////////////////////////////////////////////////////////////#pragma mark ----- Standard Entry Points -----static SInt32 StreamDumpOpen(queue_t* rdq, dev_t* dev, SInt32 flag, SInt32 sflag, cred_t* creds)  // This routine is called by STREAMS when a new stream is connected to  // our module.  //  // Environment: standard STREAMS entry point{  int         err;  PerStreamDataPtr   streamData;    err = noErr;  if ( rdq-&gt;q_ptr != nil ) {    goto done;  }  if ( (err == noErr) &amp;&amp; (sflag != MODOPEN) ) {    err = ENXIO;  }  if (err == noErr) {    err = mi_open_comm(&amp;gStreamList, sizeof(PerStreamData), rdq, dev, flag, sflag, creds);    if ( err == noErr ) {      // Note that we can't call GetPerStreamData because the magic is not set up yet.      streamData = (PerStreamDataPtr) rdq-&gt;q_ptr;            OTMemzero(streamData, sizeof(PerStreamData));            streamData-&gt;magic    = kStreamDumpPerStreamDataMagic;      streamData-&gt;streamID = OTAtomicAdd16(1, (SInt16 *) &amp;gNextStreamID);    }  }done:  return err;}static SInt32 StreamDumpClose(queue_t* rdq, SInt32 flags, cred_t* credP)  // This routine is called by STREAMS when a stream is being  // disconnected from our module (ie closed).  //  // Environment: standard STREAMS entry point{  #pragma unused(flags)  #pragma unused(credP)  (void) mi_close_comm(&amp;gStreamList, rdq);  return 0;}static Boolean IsReadQ(queue_t* q)  // Returns true if q is the read queue of a queue pair.{  return ( (q-&gt;q_flag &amp; QREADR) != 0 );}static void DumpCommon(queue_t* q, mblk_t* mp)  // Common code, called by both StreamDumpWritePut and   // StreamDumpReadPut, that logs the message via strlog.{  PerStreamDataPtr  streamData;  const char *    primStr;  const char *    qStr;  char         lineBuffer[256];  streamData = GetPerStreamData(q);    primStr = nil;  if ( mp-&gt;b_datap-&gt;db_type == M_DATA ) {    primStr = &quot;M_DATA&quot;;  } else if ( mp-&gt;b_datap-&gt;db_type == M_PROTO) {    switch ( ((T_primitives *) mp-&gt;b_rptr)-&gt;primType ) {      case T_UNITDATA_IND:        primStr = &quot;T_UNITDATA_IND&quot;;        break;      case T_UNITDATA_REQ:        primStr = &quot;T_UNITDATA_REQ&quot;;        break;      case T_DATA_IND:        primStr = &quot;T_DATA_IND&quot;;        break;      case T_DATA_REQ:        primStr = &quot;T_DATA_REQ&quot;;        break;      default:        // do nothing        break;    }    // Always move to the next mblk because if primType is not     // a data message then primStr is still nil and we never look at     // mp.        mp = mp-&gt;b_cont;  }  if (primStr != nil) {    if ( IsReadQ(q) ) {      qStr = &quot;Read&quot;;    } else {      qStr = &quot;Write&quot;;      q = RD(q);    }    // Log some basic info about the message.            (void) strlog(9993, streamData-&gt;streamID, kOTLvlInfoOnly, SL_TRACE | SL_NOTE, &quot;%s (%s)&quot;, primStr, qStr);        // Log the contents of each message block.        while (mp != nil) {      UInt32  mpSize;      UInt32  i;      UInt32  numPrintables;            mpSize = MBLK_SIZE(mp);      (void) strlog(9993, streamData-&gt;streamID, kOTLvlInfoOnly, SL_TRACE | SL_NOTE,                         &quot;%*m&quot;, mpSize, mp-&gt;b_rptr);            // If the message block's data is too big for our line buffer, don't       // even attempt to log it as ASCII.            if ( mpSize &lt; 256 ) {        BlockMoveData(mp-&gt;b_rptr, lineBuffer, mpSize);        lineBuffer[mpSize] = 0;      // terminate string will null        numPrintables = 0;        for (i = 0; i &lt; mpSize; i++) {          if ( lineBuffer[i] &gt;= 32 &amp;&amp; lineBuffer[i] &lt; 127 ) {            numPrintables += 1;          } else {            // Substitute '.' for non-printable characters.            // CR and LF are printable (for the purposes of deciding whether             // or not to print the ASCII at all).            if ( lineBuffer[i] == 13 || lineBuffer[i] == 10 ) {              numPrintables += 1;            }            lineBuffer[i] = '.';          }        }        if (numPrintables == mpSize) {          (void) strlog(9993, streamData-&gt;streamID, kOTLvlInfoOnly, SL_TRACE | SL_NOTE, &quot;&quot;%s&quot;&quot;, lineBuffer);        }      }      mp = mp-&gt;b_cont;    }  }}static SInt32 StreamDumpWritePut(queue_t* q, mblk_t* mp)  // This routine is called by STREAMS when it has a message for our  // module from upstream.  We call DumpCommon and then pass the   // along.  //  // Environment: standard STREAMS entry point{  DumpCommon(q, mp);  putnext(q, mp);    return 0;}static SInt32 StreamDumpReadPut(queue_t* q, mblk_t* mp)  // This routine is called by STREAMS when it has a message for our  // module from downstream.  We call DumpCommon and then pass the   // message along.  //  // Environment: standard STREAMS entry point{  DumpCommon(q, mp);  putnext(q, mp);  return 0;}/////////////////////////////////////////////////////////////////////#pragma mark ----- Static Declaration Structures -----static struct module_info gModuleInfo =  {  9993,            // Module Number, only useful for debugging  &quot;OTStreamDumper&quot;,      // Name of module  0,              // Minimum data size  INFPSZ,            // Maximum data size  16384,            // Hi water mark for queue  4096            // Lo water mark for queue};static struct qinit gReadInit = {  StreamDumpReadPut,      // Put routine for &quot;incoming&quot; data  nil,            // Service routine for &quot;incoming&quot; data  StreamDumpOpen,        // Our open routine  StreamDumpClose,       // Our close routine  nil,            // No admin routine  &amp;gModuleInfo        // Our module_info};static struct qinit gWriteInit ={  StreamDumpWritePut,      // Put routine for client data  nil,            // Service routine for client data  nil,            // open  field only used in read-side structure  nil,            // close field only used in read-side structure  nil,            // admin field only used in read-side structure  &amp;gModuleInfo        // Our module_info};static struct streamtab theStreamTab = {  &amp;gReadInit,          // Our read-side qinit structure  &amp;gWriteInit,        // Our write-side qinit structure  0,              // We are not a mux, so set this to nil  0              // We are not a mux, so set this to nil};/////////////////////////////////////////////////////////////////////#pragma mark ----- Macintosh-specific Static Structures -----static struct install_info theInstallInfo ={  &amp;theStreamTab,      // Stream Tab pointer  kOTModIsModule + kOTModUpperIsTPI + kOTModIsFilter,              // Tell OT that we are a driver, not a module               // TPI may not be right if we're pushed on a DLPI               // stream, but OT doesn't look at that flag anyway.  SQLVL_MODULE,      // Synchronization level, module level for the moment  0,            // Shared writer list buddy  0,            // Open Transport use - always set to 0  0            // Flag - always set to 0};// Prototypes for the exported routines below.extern Boolean InitStreamModule(void *portInfo);extern void TerminateStreamModule(void);extern install_info* GetOTInstallInfo();#pragma export list GetOTInstallInfo, InitStreamModule, TerminateStreamModule// Export entry pointextern Boolean InitStreamModule(void *portInfo)  // Initialises the module before the first stream is opened.  // Should return true if the module has started up correctly.  //  // Environment: Always called at SystemTask time.{    #pragma unused(portInfo)  // Drop into MacsBug so that we can set breakpoints if necessary.      #if MORE_DEBUG    DebugStr(&quot;\pOTStreamDumper: InitStreamModule&quot;);  #endif  return true;}extern void TerminateStreamModule(void)  // Shuts down the module after the last stream has been  // closed.  //  // Environment: Always called at SystemTask time.{}extern install_info* GetOTInstallInfo()  // Return pointer to install_info to STREAMS.{  return &amp;theInstallInfo;}</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/OTStreamDumper/listing1.html%3Fid%3DDTS10000254-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/OTStreamDumper/listing1.html%3Fid%3DDTS10000254-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/OTStreamDumper/listing1.html%3Fid%3DDTS10000254-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>