<html><head><title>Mac OS X
 Manual Page For zshtcpsys(1)</title>
<style type="text/css"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { font-size: 1px; background: #ffffff; color: #ffffff; } --></style>
<style type="text/css" media="print, aural, braille, embossed, projection, tty"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { display: none; } --></style>
</head><body bgcolor="white">
<a name="//apple_ref/doc/man/1/zshtcpsys" title="Mac OS X
 Manual Page for zshtcpsys(1)"><!-- headerDoc=man; indexgroup=Section 1; uid="//apple_ref/doc/man/1/zshtcpsys"; name=zshtcpsys(1) --></a>
<!--#include virtual="/includes/framesetheader"-->
<table width=600><tr><td scope="row">
<!-- begin breadcrumb insert request --><font face="Geneva,Helvetica,Arial" size="1">
 <a target="_top" href="http://developer.apple.com">ADC Home</a> <b>&gt;</b> <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> <b>&gt;</b> <a href="../../../../../reference/index.html#//apple_ref/doc/uid/TP30001281" target="_top">Reference</a> <b>&gt;</b> <!-- a href="" target="_top" -->Mac OS X<!-- /a --> <b>&gt;</b> <a href="../index.html#//apple_ref/doc/framework/manpages" target="_top">Mac OS X Man Pages</a></font>
<!-- end breadcrumb insert request -->
<p>&nbsp;</p>
</td></tr></table>
<!-- end of header -->
<table border="0"  cellpadding="2" cellspacing="2" width="630pt"><tr><td valign="top" height="12" colspan="5" scope="row">
<p style='text-align:justify;'>This document is a Mac OS X manual page.  Manual pages are a command-line technology
for providing documentation.  You can view these manual pages locally using the
<a href="man.1.html#//apple_ref/doc/man/1/man">man(1)</a> command.
These manual pages come from many different sources, and thus, have a variety of writing
styles.</p>
<p style='text-align:justify;'>For more information about the manual page format, see the manual page for 
<a href="../man5/manpages.5.html#//apple_ref/doc/man/5/manpages">manpages(5)</a>.</p>
</td></tr></table>
<hr />
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row"><pre class="manpages"><tt>
ZSHTCPSYS(1)                                                                                    ZSHTCPSYS(1)



<b>NAME</b>
       zshtcpsys - zsh tcp system

<b>DESCRIPTION</b>
       A  module  <b>zsh/net/tcp</b>  is provided to provide network I/O over TCP/IP from within the shell; see its
       description in <a href="zshmodules.1.html#//apple_ref/doc/man/1/zshmodules"><u>zshmodules</u>(1)</a> .  This manual page describes a function suite based on the module.   If
       the  module  is  installed,  the functions are usually installed at the same time, in which case they
       will be available for  autoloading  in  the  default  function  search  path.   In  addition  to  the
       <b>zsh/net/tcp</b>  module,  the  <b>zsh/zselect</b>  module is used to implement timeouts on read operations.  For
       troubleshooting tips, consult the corresponding advice for the <b>zftp</b> functions  described  in  <!-- a --><u>zshftp</u><!-- /a -->-<font color="#ffffff" class="whiteout">sys(1)&nbsp;zshftpsys(1)</font>
       <!-- a --><u>sys</u>(1)<!-- /a --> .

       There  are  functions  corresponding  to  the  basic I/O operations open, close, read and send, named
       <b>tcp_open</b> etc., as well as a function <b>tcp_expect</b> for pattern match analysis of  data  read  as  input.
       The  system  makes it easy to receive data from and send data to multiple named sessions at once.  In
       addition, it can be linked with the shell's line editor in such a way that input  data  is  automati-<font color="#ffffff" class="whiteout">cally&nbsp;automatically</font>
       cally  shown  at  the  terminal.  Other facilities available including logging, filtering and config-<font color="#ffffff" class="whiteout">urable&nbsp;configurable</font>
       urable output prompts.

       To use the system where it is available, it should be  enough  to  `<b>autoload</b>  <b>-U</b>  <b>tcp_open</b>'  and  run
       <b>tcp_open</b>  as  documented below to start a session.  The <b>tcp_open</b> function will autoload the remaining
       functions.



<b>TCP</b> <b>USER</b> <b>FUNCTIONS</b>
   <b>Basic</b> <b>I/O</b>
       <b>tcp_open</b> <b>[-qz]</b> <u>host</u> <u>port</u> <b>[</b> <u>sess</u> <b>]</b>
       <b>tcp_open</b> <b>[-qz]</b> <b>[</b> <b>-s</b> <u>sess</u> <b>|</b> <b>-l</b> <u>sess</u><b>,...</b> <b>]</b> <b>...</b>
       <b>tcp_open</b> <b>[-qz]</b> <b>[-a</b> <u>fd</u> <b>|</b> <b>-f</b> <u>fd</u> <b>]</b> <b>[</b> <u>sess</u> <b>]</b>
              Open a new session.  In the first and simplest form, open a TCP connection  to  host  <u>host</u>  at
              port <u>port</u>; numeric and symbolic forms are understood for both.

              If  <u>sess</u> is given, this becomes the name of the session which can be used to refer to multiple
              different TCP connections.  If <u>sess</u> is not given, the function  will  invent  a  numeric  name
              value (note this is <u>not</u> the same as the file descriptor to which the session is attached).  It
              is recommended that session names not include `funny' characters, where funny  characters  are
              not  well-defined  but certainly do not include alphanumerics or underscores, and certainly do
              include whitespace.

              In the second case, one or more sessions to be opened are given by  name.   A  single  session
              name  is  given  after <b>-s</b> and a comma-separated list after <b>-l</b>; both options may be repeated as
              many times as necessary.  The host and port are read from the file <b>.ztcp_sessions</b> in the  same
              directory  as the user's zsh initialisation files, i.e. usually the home directory, but <b>$ZDOT</b>-<font color="#ffffff" class="whiteout">DIR&nbsp;$ZDOTDIR</font>
              <b>DIR</b> if that is set.  The file consists of lines each giving a session name and the correspond-<font color="#ffffff" class="whiteout">ing&nbsp;corresponding</font>
              ing  host  and port, in that order (note the session name comes first, not last), separated by
              whitespace.

              The third form allows passive and fake TCP connections.  If the option <b>-a</b> is used,  its  argu-<font color="#ffffff" class="whiteout">ment&nbsp;argument</font>
              ment  is  a file descriptor open for listening for connections.  No function front-end is pro-<font color="#ffffff" class="whiteout">vided&nbsp;provided</font>
              vided to open such a file descriptor, but a call to `<b>ztcp</b> <b>-l</b> <u>port</u>' will create  one  with  the
              file  descriptor  stored in the parameter <b>$REPLY</b>.  The listening port can be closed with `<b>ztcp</b>
              <b>-c</b> <u>fd</u>'.  A call to `<b>tcp_open</b> <b>-a</b> <u>fd</u>' will block until a remote TCP connection is made  to  <u>port</u>
              on  the  local  machine.   At this point, a session is created in the usual way and is largely
              indistinguishable from an active connection created with one of the first two forms.

              If the option <b>-f</b> is used, its argument is a file descriptor which is used directly  as  if  it
              were a TCP session.  How well the remainder of the TCP function system copes with this depends
              on what actually underlies this file descriptor.  A regular file is likely to be  unusable;  a
              FIFO (pipe) of some sort will work better, but note that it is not a good idea for two differ-<font color="#ffffff" class="whiteout">ent&nbsp;different</font>
              ent sessions to attempt to read from the same FIFO at once.

              If the option <b>-q</b> is given with any of the three forms, <b>tcp_open</b> will not  print  informational
              messages, although it will in any case exit with an appropriate status.

              If  the  line editor (zle) is in use, which is typically the case if the shell is interactive,
              <b>tcp_open</b> installs a handler inside <b>zle</b> which will check for new data at the same  time  as  it
              checks  for  keyboard input.  This is convenient as the shell consumes no CPU time while wait-<font color="#ffffff" class="whiteout">ing;&nbsp;waiting;</font>
              ing; the test is performed by the operating system.  Giving the option <b>-z</b> to any of the  forms
              of <b>tcp_open</b> prevents the handler from being installed, so data must be read explicitly.  Note,
              however, this is not necessary for executing complete sets of send and read  commands  from  a
              function,  as zle is not active at this point.  Generally speaking, the handler is only active
              when the shell is waiting for input at a command prompt or in the <b>vared</b> builtin.   The  option
              has no effect if zle is not active; `<b>[[</b> <b>-o</b> <b>zle]]</b>' will test for this.

              The first session to be opened becomes the current session and subsequent calls to <b>tcp_open</b> do
              not change it.  The current session is stored in the parameter <b>$TCP_SESS</b>; see below  for  more
              detail about the parameters used by the system.

       <b>tcp_close</b> <b>[-qn]</b> <b>[</b> <b>-a</b> <b>|</b> <b>-l</b> <u>sess</u><b>,...</b> <b>|</b> <u>sess</u> <b>...</b> <b>]</b>
              Close  the named sessions, or the current session if none is given, or all open sessions if <b>-a</b>
              is given.  The options <b>-l</b> and <b>-s</b> are both handled for consistency with <b>tcp_open</b>, although  the
              latter is redundant.

              If  the  session  being closed is the current one, <b>$TCP_SESS</b> is unset, leaving no current ses-<font color="#ffffff" class="whiteout">sion,&nbsp;session,</font>
              sion, even if there are other sessions still open.

              If the session was opened with <b>tcp_open</b> <b>-f</b>, the file descriptor is closed so long as it is  in
              the  range  0  to  9 accessible directly from the command line.  If the option <b>-n</b> is given, no
              attempt will be made to close file descriptors in this case.  The <b>-n</b> option is  not  used  for
              genuine <b>ztcp</b> session; the file descriptors are always closed with the session.

              If the option <b>-q</b> is given, no informational messages will be printed.

       <b>tcp_read</b> <b>[-bdq]</b> <b>[</b> <b>-t</b> <u>TO</u> <b>]</b> <b>[</b> <b>-T</b> <u>TO</u> <b>]</b>
           <b>[</b> <b>-a</b> <b>|</b> <b>-u</b> <u>fd</u> <b>...</b> <b>|</b> <b>-l</b> <u>sess</u><b>,...</b> <b>|</b> <b>-s</b> <u>sess</u> <b>...]</b>
              Perform  a  read  operation  on the current session, or on a list of sessions if any are given
              with <b>-u</b>, <b>-l</b> or <b>-s</b>, or all open sessions if the option <b>-a</b> is given.  Any of the <b>-u</b>,  <b>-l</b>  or  <b>-s</b>
              options may be repeated or mixed together.  The <b>-u</b> option specifies a file descriptor directly
              (only those managed by this system are useful), the other two specify  sessions  as  described
              for <b>tcp_open</b> above.

              The  function  checks for new data available on all the sessions listed.  Unless the <b>-b</b> option
              is given, it will not block waiting for new data.  Any one line of data from any of the avail-<font color="#ffffff" class="whiteout">able&nbsp;available</font>
              able  sessions will be read, stored in the parameter <b>$TCP_LINE</b>, and displayed to standard out-<font color="#ffffff" class="whiteout">put&nbsp;output</font>
              put unless <b>$TCP_SILENT</b> contains a non-empty string.   When  printed  to  standard  output  the
              string  <b>$TCP_PROMPT</b> will be shown at the start of the line; the default form for this includes
              the name of the session being read.  See below for more information on these  parameters.   In
              this  mode,  <b>tcp_read</b>  can  be called repeatedly until it returns status 2 which indicates all
              pending input from all specified sessions has been handled.

              With the option <b>-b</b>, equivalent to an infinite timeout, the function will block until a line is
              available  to  read  from  one  of  the  specified  sessions.   However, only a single line is
              returned.

              The option <b>-d</b> indicates that all pending input should be drained.  In this case  <b>tcp_read</b>  may
              process  multiple  lines  in the manner given above; only the last is stored in <b>$TCP_LINE</b>, but
              the complete set is stored in the array <b>$tcp_lines</b>.  This is cleared at the start of each call
              to <b>tcp_read</b>.

              The  options  <b>-t</b> and <b>-T</b> specify a timeout in seconds, which may be a floating point number for
              increased accuracy.  With <b>-t</b> the timeout is applied before each line read.  With <b>-T</b>, the time-<font color="#ffffff" class="whiteout">out&nbsp;timeout</font>
              out  applies  to  the  overall  operation,  possibly including multiple read operations if the
              option <b>-d</b> is present; without this option, there is no distinction between <b>-t</b> and <b>-T</b>.

              The function does not print informational messages, but if the option <b>-q</b> is  given,  no  error
              message is printed for a non-existent session.

              A return status of 2 indicates a timeout or no data to read.  Any other non-zero return status
              indicates some error condition.

              See <b>tcp_log</b> for how to control where data is sent by <b>tcp_read</b>.

       <b>tcp_send</b> <b>[-cnq]</b> <b>[</b> <b>-s</b> <u>sess</u> <b>|</b> <b>-l</b> <u>sess</u><b>,...</b> <b>]</b> <u>data</u> <b>...</b>
       <b>tcp_send</b> <b>[-cnq]</b> <b>-a</b> <u>data</u> <b>...</b>
              Send the supplied data strings to all the specified sessions in turn.  The  underlying  opera-<font color="#ffffff" class="whiteout">tion&nbsp;operation</font>
              tion  differs  little from a `<b>print</b> <b>-r</b>' to the session's file descriptor, although it attempts
              to prevent the shell from dying owing to a <b>SIGPIPE</b> caused by an attempt to write to a  defunct
              session.

              The  option  <b>-c</b>  causes <b>tcp_send</b> to behave like <b>cat</b>.  It reads lines from standard input until
              end of input and sends them in turn to the specified <!-- a -->session(s)<!-- /a --> exactly as if they were  given
              as <u>data</u> arguments to individual <b>tcp_send</b> commands.

              The option <b>-n</b> prevents <b>tcp_send</b> from putting a newline at the end of the data strings.

              The remaining options all behave as for <b>tcp_read</b>.

              The  data arguments are not further processed once they have been passed to <b>tcp_send</b>; they are
              simply passed down to <b>print</b> <b>-r</b>.

              If the parameter <b>$TCP_OUTPUT</b> is a non-empty string and logging is enabled then the  data  sent
              to each session will be echoed to the log <!-- a -->file(s)<!-- /a --> with <b>$TCP_OUTPUT</b> in front where appropriate,
              much in the manner of <b>$TCP_PROMPT</b>.


   <b>Session</b> <b>Management</b>
       <b>tcp_alias</b> <b>[-q]</b> <u>alias</u><b>=</b><u>sess</u> <b>...</b>
       <b>tcp_alias</b> <b>[-q]</b> <b>[</b> <u>alias</u> <b>]</b> <b>...</b>
       <b>tcp_alias</b> <b>-d</b> <b>[-q]</b> <u>alias</u> <b>...</b>
              This function is not particularly well tested.

              The first form creates an alias for a session name; <u>alias</u> can then be used  to  refer  to  the
              existing session <u>sess</u>.  As many aliases may be listed as required.

              The second form lists any aliases specified, or all aliases if none.

              The third form deletes all the aliases listed.  The underlying sessions are not affected.

              The option <b>-q</b> suppresses an inconsistently chosen subset of error messages.

       <b>tcp_log</b> <b>[-asc]</b> <b>[</b> <b>-n</b> <b>|</b> <b>-N</b> <b>]</b> <b>[</b> <u>logfile</u> <b>]</b>
              With  an  argument  <u>logfile</u>,  all future input from <b>tcp_read</b> will be logged to the named file.
              Unless <b>-a</b> (append) is given, this file will first be truncated  or  created  empty.   With  no
              arguments, show the current status of logging.

              With the option <b>-s</b>, per-session logging is enabled.  Input from <b>tcp_read</b> is output to the file
              <u>logfile</u>.<u>sess</u>.  As the session is automatically discriminated by the filename, the contents are
              raw  (no  <b>$TCP_PROMPT</b>).   The option  <b>-a</b> applies as above.  Per-session logging and logging of
              all data in one file are not mutually exclusive.

              The option <b>-c</b> closes all logging, both complete and per-session logs.

              The options <b>-n</b> and <b>-N</b> respectively turn off or restore output of  data  read  by  <b>tcp_read</b>  to
              standard output; hence `<b>tcp_log</b> <b>-cn</b>' turns off all output by <b>tcp_read</b>.

              The   function  is  purely  a  convenient  front  end  to  setting  the  parameters  <b>$TCP_LOG</b>,
              <b>$TCP_LOG_SESS</b>, <b>$TCP_SILENT</b>, which are described below.

       <b>tcp_rename</b> <u>old</u> <u>new</u>
              Rename session <u>old</u> to session <u>new</u>.  The old name becomes invalid.

       <b>tcp_sess</b> <b>[</b> <u>sess</u> <b>[</b> <u>command</u>  <b>...</b> <b>]</b> <b>]</b>
              With no arguments, list all the open sessions and associated file  descriptors.   The  current
              session  is  marked  with  a  star.   For  use  in  functions, direct access to the parameters
              <b>$tcp_by_name</b>, <b>$tcp_by_fd</b> and <b>$TCP_SESS</b> is probably more convenient; see below.

              With a <u>sess</u> argument, set the current  session  to  <u>sess</u>.   This  is  equivalent  to  changing
              <b>$TCP_SESS</b> directly.

              With additional arguments, temporarily set the current session while executing the string <b>com</b>-<font color="#ffffff" class="whiteout">mand&nbsp;command</font>
              <b>mand</b> <b>...</b>.  The first argument is re-evaluated so as to expand aliases etc., but the  remaining
              arguments are passed through as the appear to <b>tcp_sess</b>.  The original session is restored when
              <b>tcp_sess</b> exits.


   <b>Advanced</b> <b>I/O</b>
       <b>tcp_command</b> <u>send-options</u> <b>...</b> <u>send-arguments</u> <b>...</b>
              This is a convenient front-end to <b>tcp_send</b>.  All arguments are passed to  <b>tcp_send</b>,  then  the
              function pauses waiting for data.  While data is arriving at least every <b>$TCP_TIMEOUT</b> (default
              0.3) seconds, data is handled and printed out according to the current settings.  Status 0  is
              always returned.

              This  is generally only useful for interactive use, to prevent the display becoming fragmented
              by output returned from the connection.  Within a programme or function it is generally better
              to handle reading data by a more explicit method.

       <b>tcp_expect</b> <b>[</b> <b>-q</b> <b>]</b> <b>[</b> <b>-p</b> <u>var</u> <b>]</b> <b>[</b> <b>-t</b>  <u>to</u> <b>|</b> <b>-T</b> <u>TO</u><b>]</b>
           <b>[</b> <b>-a</b> <b>|</b> <b>-s</b> <u>sess</u> <b>...</b> <b>|</b> <b>-l</b> <u>sess</u><b>,...</b> <b>]</b> <u>pattern</u> ...
              Wait  for  input matching any of the given <u>pattern</u>s from any of the specified sessions.  Input
              is ignored until an input line matches one of the given patterns; at this point status zero is
              returned,  the matching line is stored in <b>$TCP_LINE</b>, and the full set of lines read during the
              call to <b>tcp_expect</b> is stored in the array <b>$tcp_expect_lines</b>.

              Sessions are specified in the same way as <b>tcp_read</b>: the default is to use the current session,
              otherwise the sessions specified by <b>-a</b>, <b>-s</b>, or <b>-l</b> are used.

              Each  <u>pattern</u>  is a standard zsh extended-globbing pattern; note that it needs to be quoted to
              avoid it being expanded immediately by filename generation.  It must match the full  line,  so
              to  match  a  substring  there  must  be a `<b>*</b>' at the start and end.  The line matched against
              includes the <b>$TCP_PROMPT</b> added by <b>tcp_read</b>.  It is possible to include the globbing flags `<b>#b</b>'
              or  `<b>#m</b>'  in  the  patterns to make backreferences available in the parameters <b>$MATCH</b>, <b>$match</b>,
              etc., as described in the base zsh documentation on pattern matching.

              Unlike <b>tcp_read</b>, the default behaviour of  <b>tcp_expect</b>  is  to  block  indefinitely  until  the
              required  input  is  found.  This can be modified by specifying a timeout with <b>-t</b> or <b>-T</b>; these
              function as in <b>tcp_read</b>, specifying a per-read or overall timeout, respectively,  in  seconds,
              as an integer or floating-point number.  As <b>tcp_read</b>, the function returns status 2 if a time-<font color="#ffffff" class="whiteout">out&nbsp;timeout</font>
              out occurs.

              The function returns as soon as any one of the patterns given match.  If the caller  needs  to
              know  which  of the patterns matched, the option <b>-p</b> <u>var</u> can be used; on return, <b>$var</b> is set to
              the number of the pattern using ordinary zsh indexing, i.e. the first is 1, and so  on.   Note
              the  absence  of  a  `<b>$</b>'  in  front of <u>var</u>.  To avoid clashes, the parameter cannot begin with
              `<b>_expect</b>'.

              The option <b>-q</b> is passed directly down to <b>tcp_read</b>.

              As all input is done via <b>tcp_read</b>, all the usual rules about output of lines read apply.   One
              exception  is  that  the  parameter  <b>$tcp_lines</b> will only reflect the line actually matched by
              <b>tcp_expect</b>; use <b>$tcp_expect_lines</b> for the full set of lines read during the function call.

       <b>tcp_proxy</b>
              This is a simple-minded function to accept a TCP connection and execute  a  command  with  I/O
              redirected to the connection.  Extreme caution should be taken as there is no security whatso-<font color="#ffffff" class="whiteout">ever&nbsp;whatsoever</font>
              ever and this can leave your computer open to the world.  Ideally,  it  should  only  be  used
              behind a firewall.

              The first argument is a TCP port on which the function will listen.

              The remaining arguments give a command and its arguments to execute with standard input, stan-<font color="#ffffff" class="whiteout">dard&nbsp;standard</font>
              dard output and standard error redirected to the file descriptor on which the TCP session  has
              been  accepted.   If  no  command is given, a new zsh is started.  This gives everyone on your
              network direct access to your account, which in many cases will be a bad thing.

              The command is run in the background, so <b>tcp_proxy</b> can then accept new connections.   It  con-<font color="#ffffff" class="whiteout">tinues&nbsp;continues</font>
              tinues to accept new connections until interrupted.

       <b>tcp_spam</b> <b>[-ertv]</b> <b>[</b> <b>-a</b> <b>|</b> <b>-s</b>  <u>sess</u> <b>|</b> <b>-l</b> <u>sess</u><b>,...</b> <b>]</b> <u>cmd</u> <b>...</b>
              Execute  `<u>cmd</u> <b>...</b>' for each session in turn.  Note this executes the command and arguments; it
              does not send the command line as data unless the <b>-t</b> (transmit) option is given.

              The sessions may be selected explicitly with the standard <b>-a</b>, <b>-s</b> or <b>-l</b> options, or may be cho-<font color="#ffffff" class="whiteout">sen&nbsp;chosen</font>
              sen  implicitly.   If  none  of  the three options is given the rules are: first, if the array
              <b>$tcp_spam_list</b> is set, this is taken as the list  of  sessions,  otherwise  all  sessions  are
              taken.  Second, any sessions given in the array <b>$tcp_no_spam_list</b> are removed from the list of
              sessions.

              Normally, any sessions added by the `<b>-a</b>' flag or when all sessions are chosen  implicitly  are
              spammed in alphabetic order; sessions given by the <b>$tcp_spam_list</b> array or on the command line
              are spammed in the order given.  The <b>-r</b> flag reverses the order however it was arrived it.

              The <b>-v</b> flag specifies that a <b>$TCP_PROMPT</b> will be output before each session.  This  is  output
              after  any  modification to TCP_SESS by the user-defined <b>tcp_on_spam</b> function described below.
              (Obviously that function is able to generate its own output.)

              If the option <b>-e</b> is present, the line given as <u>cmd</u> <u>...</u> is executed using <b>eval</b>, otherwise it is
              executed without any further processing.

       <b>tcp_talk</b>
              This is a fairly simple-minded attempt to force input to the line editor to go straight to the
              default TCP_SESSION.

              An escape string, <b>$TCP_TALK_ESCAPE</b>, default `:', is used to allow access to normal shell oper-<font color="#ffffff" class="whiteout">ation.&nbsp;operation.</font>
              ation.  If it is on its own at the start of the line, or followed only by whitespace, the line
              editor returns to normal operation.  Otherwise, the string and any  following  whitespace  are
              skipped  and  the remainder of the line executed as shell input without any change of the line
              editor's operating mode.

              The current implementation is somewhat deficient in terms of use of the command history.   For
              this  reason, many users will prefer to use some form of alternative approach for sending data
              easily to the current session.  One simple approach is to alias some special  character  (such
              as `<b>%</b>') to `<b>tcp_command</b> <b>--</b>'.

       <b>tcp_wait</b>
              The  sole  argument  is  an integer or floating point number which gives the seconds to delay.
              The shell will do nothing for that period except wait for input on all TCP sessions by calling
              <b>tcp_read</b> <b>-a</b>.  This is similar to the interactive behaviour at the command prompt when zle han-<font color="#ffffff" class="whiteout">dlers&nbsp;handlers</font>
              dlers are installed.


   <b>`One-shot'</b> <b>file</b> <b>transfer</b>
       <b>tcp_point</b> <u>port</u>
       <b>tcp_shoot</b> <u>host</u> <u>port</u>
              This pair of functions provide a simple way to transfer a file between two  hosts  within  the
              shell.   Note,  however, that bulk data transfer is currently done using <b>cat</b>.  <b>tcp_point</b> reads
              any data arriving at <u>port</u> and sends it to standard output; <b>tcp_shoot</b> connects to <u>port</u> on  <u>host</u>
              and sends its standard input.  Any unused <u>port</u> may be used; the standard mechanism for picking
              a port is to think of a random four-digit number above 1024 until one works.

              To transfer a file from host <b>woodcock</b> to host <b>springes</b>, on <b>springes</b>:

                     <b>tcp_point</b> <b>8091</b> <b>&gt;output_file</b>

              and on <b>woodcock</b>:

                     <b>tcp_shoot</b> <b>springes</b> <b>8091</b> <b>&lt;input_file</b>

              As these two functions do not require <b>tcp_open</b> to set up a TCP connection first, they may need
              to be autoloaded separately.


<b>TCP</b> <b>USER\-DEFINED</b> <b>FUNCTIONS</b>
       Certain functions, if defined by the user, will be called by the function system in certain contexts.
       This facility depends on the module <b>zsh/parameter</b>, which is usually available in  interactive  shells
       as  the  completion system depends on it.  None of the functions need be defined; they simply provide
       convenient hooks when necessary.

       Typically, these are called after the requested action has been taken, so that the various parameters
       will reflect the new state.

       <b>tcp_on_alias</b> <u>alias</u> <u>fd</u>
              When  an  alias  is  defined, this function will be called with two arguments: the name of the
              alias, and the file descriptor of the corresponding session.

       <b>tcp_on_close</b> <u>sess</u> <u>fd</u>
              This is called with the name of a session being closed and the file  descriptor  which  corre-
              sponded to that session.  Both will be invalid by the time the function is called.

       <b>tcp_on_open</b> <u>sess</u> <u>fd</u>
              This  is called after a new session has been defined with the session name and file descriptor
              as arguments.

       <b>tcp_on_rename</b> <u>oldsess</u> <u>fd</u> <u>newsess</u>
              This is called after a session has been renamed with the three  arguments  old  session  name,
              file descriptor, new session name.

       <b>tcp_on_spam</b> <u>sess</u> <u>command</u> <b>...</b>
              This  is called once for each session spammed, just <u>before</u> a command is executed for a session
              by <b>tcp_spam</b>.  The arguments are the session name followed by the command list to be  executed.
              If <b>tcp_spam</b> was called with the option <b>-t</b>, the first command will be <b>tcp_send</b>.

              This  function  is  called  after  <b>$TCP_SESS</b>  is set to reflect the session to be spammed, but
              before any use of it is made.  Hence it is possible to alter the  value  of  <b>$TCP_SESS</b>  within
              this function.  For example, the session arguments to <b>tcp_spam</b> could include extra information
              to be stripped off and processed in <b>tcp_on_spam</b>.

              If the function sets the parameter <b>$REPLY</b> to `<b>done</b>', the command  line  is  not  executed;  in
              addition, no prompt is printed for the <b>-v</b> option to <b>tcp_spam</b>.

       <b>tcp_on_unalias</b> <u>alias</u> <u>fd</u>
              This is called with the name of an alias and the corresponding session's file descriptor after
              an alias has been deleted.


<b>TCP</b> <b>UTILITY</b> <b>FUNCTIONS</b>
       The following functions are used by the TCP function system but will rarely if ever need to be called
       directly.

       <b>tcp_fd_handler</b>
              This  is the function installed by <b>tcp_open</b> for handling input from within the line editor, if
              that is required.  It is in the format documented for the builtin `<b>zle</b> <b>-F</b>' in <a href="zshzle.1.html#//apple_ref/doc/man/1/zshzle"><u>zshzle</u>(1)</a> .

              While active, the function sets the parameter <b>TCP_HANDLER_ACTIVE</b> to 1.  This allows shell code
              called  internally  (for  example, by setting <b>tcp_on_read</b>) to tell if is being called when the
              shell is otherwise idle at the editor prompt.

       <b>tcp_output</b> <b>[</b> <b>-q</b> <b>]</b> <b>-P</b> <u>prompt</u> <b>-F</b> <u>fd</u> <b>-S</b> <u>sess</u>
              This function is used for both logging and handling output to  standard  output,  from  within
              <b>tcp_read</b> and (if <b>$TCP_OUTPUT</b> is set) <b>tcp_send</b>.

              The <u>prompt</u> to use is specified by <b>-P</b>; the default is the empty string.  It can contain:
              <b>%c</b>     Expands  to  1  if  the session is the current session, otherwise 0.  Used with ternary
                     expresions such as `<b>%(c.-.+)</b>' to output `<b>+</b>' for the current session and `<b>-</b>'  otherwise.

              <b>%f</b>     Replaced by the session's file descriptor.

              <b>%s</b>     Replaced by the session name.

              <b>%%</b>     Replaced by a single `<b>%</b>'.

              The option <b>-q</b> suppresses output to standard output, but not to any log files which are config-<font color="#ffffff" class="whiteout">ured.&nbsp;configured.</font>
              ured.

              The <b>-S</b> and <b>-F</b> options are used to pass in the session name and file  descriptor  for  possible
              replacement in the prompt.


<b>TCP</b> <b>USER</b> <b>PARAMETERS</b>
       Parameters  follow the usual convention that uppercase is used for scalars and integers, while lower-<font color="#ffffff" class="whiteout">case&nbsp;lowercase</font>
       case is used for normal and associative array.  It is always safe for user code to read these parame-<font color="#ffffff" class="whiteout">ters.&nbsp;parameters.</font>
       ters.   Some  parameters  may  also  be set; these are noted explicitly.  Others are included in this
       group as they are set by the function system for the user's benefit, i.e. setting them  is  typically
       not useful but is benign.

       It  is  often  also  useful  to  make  settable  parameters local to a function.  For example, `<b>local</b>
       <b>TCP_SILENT=1</b>' specifies that data read during the function call will not be printed to standard  out-<font color="#ffffff" class="whiteout">put,&nbsp;output,</font>
       put,  regardless of the setting outside the function.  Likewise, `<b>local</b> <b>TCP_SESS=</b><u>sess</u>' sets a session
       for the duration of a function, and `<b>local</b> <b>TCP_PROMPT=</b>' specifies that no prompt is  used  for  input
       during the function.

       <b>tcp_expect_lines</b>
              Array.   The  set  of  lines  read  during  the  last  call  to <b>tcp_expect</b>, including the last
              (<b>$TCP_LINE</b>).

       <b>tcp_filter</b>
              Array. May be set directly.  A set of extended globbing patterns which, if matched in <b>tcp_out</b>-<font color="#ffffff" class="whiteout">put,&nbsp;tcp_output,</font>
              <b>put</b>, will cause the line not to be printed to standard output.  The patterns should be defined
              as described for the arguments to <b>tcp_expect</b>.  Output of line to log files is not affected.

       <b>TCP_HANDLER_ACTIVE</b>
              Scalar.  Set to 1 within <b>tcp_fd_handler</b> to indicate to functions called recursively that  they
              have been called during an editor session.  Otherwise unset.

       <b>TCP_LINE</b>
              The last line read by <b>tcp_read</b>, and hence also <b>tcp_expect</b>.

       <b>TCP_LINE_FD</b>
              The  file  descriptor from which <b>$TCP_LINE</b> was read.  <b>${tcp_by_fd[$TCP_LINE_FD]}</b> will give the
              corresponding session name.

       <b>tcp_lines</b>
              Array. The set of lines read during the last call to <b>tcp_read</b>, including the last (<b>$TCP_LINE</b>).

       <b>TCP_LOG</b>
              May  be  set directly, although it is also controlled by <b>tcp_log</b>.  The name of a file to which
              output from all sessions will be sent.  The output is proceeded by the usual <b>$TCP_PROMPT</b>.   If
              it is not an absolute path name, it will follow the user's current directory.

       <b>TCP_LOG_SESS</b>
              May be set directly, although it is also controlled by <b>tcp_log</b>.  The prefix for a set of files
              to  which  output  from  each  session  separately  will  be  sent;  the  full   filename   is
              <b>${TCP_LOG_SESS}.</b><u>sess</u>.   Output to each file is raw; no prompt is added.  If it is not an abso-<font color="#ffffff" class="whiteout">lute&nbsp;absolute</font>
              lute path name, it will follow the user's current directory.

       <b>tcp_no_spam_list</b>
              Array.  May be set directly.  See <b>tcp_spam</b> for how this is used.

       <b>TCP_OUTPUT</b>
              May be set directly.  If a non-empty string, any data sent to a session by  <b>tcp_send</b>  will  be
              logged.  This parameter gives the prompt to be used in a file specified by <b>$TCP_LOG</b> but not in
              a file generated from <b>$TCP_LOG_SESS</b>.  The prompt string has the same format as <b>TCP_PROMPT</b>  and
              the same rules for its use apply.

       <b>TCP_PROMPT</b>
              May  be  set directly.  Used as the prefix for data read by <b>tcp_read</b> which is printed to stan-<font color="#ffffff" class="whiteout">dard&nbsp;standard</font>
              dard output or to the log file given by <b>$TCP_LOG</b>, if any.  Any `<b>%s</b>', `<b>%f</b>' or `<b>%%</b>' occurring in
              the string will be replaced by the name of the session, the session's underlying file descrip-<font color="#ffffff" class="whiteout">tor,&nbsp;descriptor,</font>
              tor, or a single `<b>%</b>', respectively.  The expression `<b>%c</b>' expands to 1  if  the  session  being
              read  is  the  current  session,  else  0;  this is most useful in ternary expressions such as
              `<b>%(c.-.+)</b>' which outputs `<b>+</b>' if the session is the current one, else `<b>-</b>'.

       <b>TCP_READ_DEBUG</b>
              May be set directly.  If this has non-zero length, <b>tcp_read</b> will give some limited diagnostics
              about data being read.

       <b>TCP_SECONDS_START</b>
              This value is created and initialised to zero by tcp_open.

              The  functions  <b>tcp_read</b> and <b>tcp_expect</b> use the shell's <b>SECONDS</b> parameter for their own timing
              purposes.  If that parameter is not of floating point type on entry to one of  the  functions,
              it  will  create  a  local  parameter  <b>SECONDS</b>  which  is floating point and set the parameter
              <b>TCP_SECONDS_START</b> to the previous value of <b>$SECONDS</b>.  If the  parameter  is  already  floating
              point, it is used without a local copy being created and <b>TCP_SECONDS_START</b> is not set.  As the
              global value is zero, the shell elapsed time is guaranteed to  be  the  sum  of  <b>$SECONDS</b>  and
              <b>$TCP_SECONDS_START</b>.

              This  can  be  avoided by setting <b>SECONDS</b> globally to a floating point value using `<b>typeset</b> <b>-F</b>
              <b>SECONDS</b>'; then the TCP functions will never make a local copy and never set  <b>TCP_SECONDS_START</b>
              to a non-zero value.

       <b>TCP_SESS</b>
              May  be  set  directly.  The current session; must refer to one of the sessions established by
              <b>tcp_open</b>.

       <b>TCP_SILENT</b>
              May be set directly, although it is also controlled by <b>tcp_log</b>.  If of non-zero  length,  data
              read  by <b>tcp_read</b> will not be written to standard output, though may still be written to a log
              file.

       <b>tcp_spam_list</b>
              Array.  May be set directly.  See the description of the function <b>tcp_spam</b>  for  how  this  is
              used.

       <b>TCP_TALK_ESCAPE</b>
              May be set directly.  See the description of the function <b>tcp_talk</b> for how this is used.

       <b>TCP_TIMEOUT</b>
              May be set directly.  Currently this is only used by the function <b>tcp_command</b>, see above.


<b>TCP</b> <b>USER\-DEFINED</b> <b>PARAMETERS</b>
       The  following parameters are not set by the function system, but have a special effect if set by the
       user.

       <b>tcp_on_read</b>
              This should be an associative array; if it is not, the behaviour is undefined.   Each  key  is
              the  name of a shell function or other command, and the corresponding value is a shell pattern
              (using <b>EXTENDED_GLOB</b>).  Every line read from  a  TCP  session  directly  or  indirectly  using
              <b>tcp_read</b>  (which  includes  lines read by <b>tcp_expect</b>) is compared against the pattern.  If the
              line matches, the command given in the key is called with two arguments: the name of the  ses-<font color="#ffffff" class="whiteout">sion&nbsp;session</font>
              sion from which the line was read, and the line itself.

              If  any  function  called  to handle a line returns a non-zero status, the line is not output.
              Thus a <b>tcp_on_read</b> handler containing only the instruction `<b>return</b> <b>1</b>' can be used to  suppress
              output  of  particular  lines  (see,  however,  <b>tcp_filter</b> above).  However, the line is still
              stored in <b>TCP_LINE</b> and <b>tcp_lines</b>; this occurs after all <b>tcp_on_read</b> processing.


<b>TCP</b> <b>UTILITY</b> <b>PARAMETERS</b>
       These parameters are controlled by the function system; they may be read  directly,  but  should  not
       usually be set by user code.

       <b>tcp_aliases</b>
              Associative  array.   The keys are the names of sessions established with <b>tcp_open</b>; each value
              is a space-separated list of aliases which refer to that session.

       <b>tcp_by_fd</b>
              Associative array.  The keys are session file descriptors; each value is the name of that ses-<font color="#ffffff" class="whiteout">sion.&nbsp;session.</font>
              sion.

       <b>tcp_by_name</b>
              Associative  array.   The  keys  are  the names of sessions; each value is the file descriptor
              associated with that session.


<b>TCP</b> <b>EXAMPLES</b>
       Here is a trivial example using a remote calculator.

       TO create a calculator server on port 7337 (see the <b>dc</b> manual page  for  quite  how  infuriating  the
       underlying command is):

              <b>tcp_proxy</b> <b>7337</b> <b>dc</b>

       To connect to this from the same host with a session also named `<b>dc</b>':

              <b>tcp_open</b> <b>localhost</b> <b>7337</b> <b>dc</b>

       To send a command to the remote session and wait a short while for output (assuming <b>dc</b> is the current
       session):

              <b>tcp_command</b> <b>2</b> <b>4</b> <b>+</b> <b>p</b>

       To close the session:

              <b>tcp_close</b>

       The <b>tcp_proxy</b> needs to be killed to be stopped.  Note this will  not  usually  kill  any  connections
       which have already been accepted, and also that the port is not immediately available for reuse.

       The  following  chunk  of code puts a list of sessions into an xterm header, with the current session
       followed by a star.

              <b>print</b> <b>-n</b> <b>"\033]2;TCP:"</b> <b>${(k)tcp_by_name:/$TCP_SESS/$TCP_SESS\*}</b> <b>"\a"</b>


<b>TCP</b> <b>BUGS</b>
       The function <b>tcp_read</b> uses the shell's normal <b>read</b> builtin.  As this reads a complete line  at  once,
       data arriving without a terminating newline can cause the function to block indefinitely.

       Though  the function suite works well for interactive use and for data arriving in small amounts, the
       performance when large amounts of data are being exchanged is likely to be extremely poor.



zsh 4.3.4                                      April 19, 2006                                   ZSHTCPSYS(1)
</tt></pre>
</td></tr></table>
	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Darwin/Reference/ManPages/man1/zshtcpsys.1.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Darwin/Reference/ManPages/man1/zshtcpsys.1.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Darwin/Reference/ManPages/man1/zshtcpsys.1.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

</body></html>
