<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>vImage Convolution Reference</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="vImage Convolution Reference"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP40005489-DontLinkChapterID_1" title="vImage Convolution Reference"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../../reference/index.html#//apple_ref/doc/uid/TP30001281" target="_top">Reference</a> &gt; <a href="../../../../../reference/Performance/index.html#//apple_ref/doc/uid/TP30001281-TP30000430" target="_top">Performance</a> &gt; <a href="../../../../../reference/Performance/idxGraphicsImaging-date.html#//apple_ref/doc/uid/TP30001281-TP30000430-TP30000450" target="_top">Graphics &amp; Imaging</a> &gt; <a href="../index.html" target="_top">vImage Convolution Reference</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <!-- Previous button --><span style="margin-left: 8px"><a href="../RevisionHistory.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP40005489-DontLinkChapterID_1-DontLinkElementID_10" title="vImage Convolution Reference"></a><h1>vImage Convolution Reference</h1><div class="spec_sheet_info_box"><table cellspacing="0" class="specbox"><tr><td scope="row"><strong><span style="white-space: nowrap;">Framework</span></strong></td><td><div style="margin-bottom:1px"><a href="../../vDSP_Reference_Collection/index.html#//apple_ref/doc/uid/TP40006226" target="_top">Accelerate</a>/vImage</div></td></tr><tr><td scope="row"><strong><span class="noWrap">Companion guide</span></strong></td><td><div style="margin-bottom:1px"><span class="content_text"><a href="../../../Conceptual/vImage/index.html#//apple_ref/doc/uid/TP30001001" target="_top">vImage Programming Guide</a></span><br/></div></td></tr><tr><td scope="row"><strong><span style="white-space: nowrap;">Declared in</span></strong></td><td><div style="margin-bottom:1px"><span class="content_text">Convolution.h</span><br/></div></td></tr></table></div><br/><a name="//apple_ref/doc/uid/TP40005489-CH1-DontLinkElementID_8" title="Overview"></a><h2>Overview</h2><p>Convolution functions implement various techniques for smoothing or sharpening an image by replacing a pixel with a weighted sum of itself and nearby pixels. Image convolution does not alter the size of an image. </p><p>Each convolution function requires that you pass it a convolution kernel, which determines how the values of neighboring pixels are used to compute the value of a destination pixel. A kernel is a packed array, without padding at the ends of the rows. The elements of the array must be of type <code>uint8_t</code> (for the Planar8 and ARGB8888 formats) or of type <code>float</code> (for the PlanarF and ARGBFFFF formats). The height and the width of the array must both be odd numbers.</p><p>For example, a 3 x 3 convolution kernel for a Planar8 image consist of nine 8-bit (1-byte) values, arranged consecutively. The first three values represent the first row of the kernel, the next three values the second row, and the last three values the third row.</p><p>Typically, you use normalized values for the convolution kernel. For floating-point formats, this means the sum of the elements of the kernel is 1.0. For integer formats, the sum of the elements of the kernel, divided by the given divisor, is 1. A non-normalized kernel either lightens or darkens the image.</p><p>For integer formats, the sum of any subset of elements of the kernel must be in the range –2<sup>24</sup> to 2<sup>24</sup> – 1, inclusive to prevent integer overflow. If your kernel does not meet this restriction, either use a floating-point format or scale the kernel to use smaller values.</p><p>A convolution function transforms a source image as follows:</p><ol class="ol"><li class="li"><p>Places the kernel over the image so that the center element of the kernel lies over the source pixel.</p></li><li class="li"><p>For floating-point formats, performs this calculation: </p><p></p><div class="item_figure"><img src = "../art/float_kernel.jpg" alt = "image: ../art/float_kernel.jpg" ></div><p>For integer formats, performs this calculation:</p><p></p><div class="item_figure"><img src = "../art/integer_kernel.jpg" alt = "image: ../art/integer_kernel.jpg" ></div></li><li class="li"><p>Assigns the result to the destination pixel.</p></li></ol><p>If the image is in a planar format, the convolution operation uses the single-channel values of the pixels directly. If the image is in an interleaved format, the convolution operation processes each channel (alpha, red, green, and blue) separately. In both the planar and interleaved format, the kernel itself is always planar.</p><p>When the pixel to be transformed is near the edge of the image—not merely the region of interest, but the entire image of which it is a part—the kernel may extend beyond the edge of the image, so that there are no existing pixels beneath some of the kernel elements. In these cases you must pass a flag that specifies a technique for the convolution function to use: <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageCopyInPlace" target="_top">kvImageCopyInPlace</a></code>, <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageBackgroundColorFill" target="_top">kvImageBackgroundColorFill</a></code>, <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageEdgeExtend" target="_top">kvImageEdgeExtend</a></code>, and <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageTruncateKernel" target="_top">kvImageTruncateKernel</a></code>. For a discussion of these options, see <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>.</p><a name="//apple_ref/doc/uid/TP40005489-DontLinkChapterID_1-DontLinkElementID_9" title="Functions by Task"></a><h2>Functions by Task</h2>
<a name="//apple_ref/doc/uid/TP40005489-CH210-SW1" title="Deconvolving"></a>
    
    <h3 class="tasks">Deconvolving</h3>
        
    <ul class="tooltip">
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImageRichardsonLucyDeConvolve_ARGBFFFF">vImageRichardsonLucyDeConvolve_ARGBFFFF</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Sharpens an ARGBFFFF image by undoing a previous convolution that blurred the image, such as diffraction effects in a camera lens.'/>
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImageRichardsonLucyDeConvolve_ARGB8888">vImageRichardsonLucyDeConvolve_ARGB8888</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Sharpens an ARGB8888 image by undoing a previous convolution that blurred the image, such as diffraction effects in a camera lens. '/>
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImageRichardsonLucyDeConvolve_PlanarF">vImageRichardsonLucyDeConvolve_PlanarF</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Sharpens a PlanarF image by undoing a previous convolution that blurred the image, such as diffraction effects in a camera lens. '/>
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImageRichardsonLucyDeConvolve_Planar8">vImageRichardsonLucyDeConvolve_Planar8</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Sharpens a Planar8 image by undoing a previous convolution that blurred the image, such as diffraction effects in a camera lens. '/>
            </span></li>
    </ul>


<a name="//apple_ref/doc/uid/TP40005489-CH210-DontLinkElementID_1" title="Convolving Without Bias"></a>
    
    <h3 class="tasks">Convolving Without Bias</h3>
        
    <ul class="tooltip">
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImageConvolve_ARGBFFFF">vImageConvolve_ARGBFFFF</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Convolves a region of interest within an ARGBFFFF source image by an M x N kernel.'/>
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImageConvolve_ARGB8888">vImageConvolve_ARGB8888</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Convolves a region of interest within a source image by an M x N kernel, then divides the pixel values by a divisor.'/>
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImageConvolve_PlanarF">vImageConvolve_PlanarF</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Convolves a region of interest within a source image by an M x N kernel.'/>
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImageConvolve_Planar8">vImageConvolve_Planar8</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Convolves a region of interest within a source image by an M x N kernel, then divides the pixel values by a divisor.'/>
            </span></li>
    </ul>


<a name="//apple_ref/doc/uid/TP40005489-CH210-DontLinkElementID_2" title="Convolving With a Bias"></a>
    
    <h3 class="tasks">Convolving With a Bias</h3>
        
    <ul class="tooltip">
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImageConvolveWithBias_ARGB8888">vImageConvolveWithBias_ARGB8888</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Convolves a region of interest within an ARGB8888 source image by an M x N kernel, then normalizes the pixel values.'/>
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImageConvolveWithBias_PlanarF">vImageConvolveWithBias_PlanarF</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Convolves a region of interest within a PlanarF source image by an M x N kernel.'/>
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImageConvolveWithBias_Planar8">vImageConvolveWithBias_Planar8</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Convolves a region of interest within a Planar8 source image by an M x N kernel, then normalizes the pixel values.'/>
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImageConvolveWithBias_ARGBFFFF">vImageConvolveWithBias_ARGBFFFF</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Convolves a region of interest within an ARGBFFFF source image by an M x N kernel.'/>
            </span></li>
    </ul>


<a name="//apple_ref/doc/uid/TP40005489-CH210-DontLinkElementID_4" title="Convolving With Multiple Kernels"></a>
    
    <h3 class="tasks">Convolving With Multiple Kernels</h3>
        
    <ul class="tooltip">
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImageConvolveMultiKernel_ARGBFFFF">vImageConvolveMultiKernel_ARGBFFFF</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Convolves each channel of a region of interest within an ARGBFFFF source image by one of the four M x N kernels.'/>
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImageConvolveMultiKernel_ARGB8888">vImageConvolveMultiKernel_ARGB8888</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Convolves each channel of a region of interest within an ARGB8888 source image by one of the four M x N kernels, then divides the pixel values by one of the four divisors.'/>
            </span></li>
    </ul>


<a name="//apple_ref/doc/uid/TP40005489-CH210-DontLinkElementID_7" title="Convolving With High-Speed Box and Tent Filters"></a>
    
    <h3 class="tasks">Convolving With High-Speed Box and Tent Filters</h3>
        
    <ul class="tooltip">
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImageBoxConvolve_Planar8">vImageBoxConvolve_Planar8</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Convolves a region of interest within a Planar8 source image by an implicit M x N kernel that has the effect of a box filter.'/>
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImageBoxConvolve_ARGB8888">vImageBoxConvolve_ARGB8888</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Convolves a region of interest within an ARGB8888 source image by an implicit M x N kernel that has the effect of a box filter.'/>
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImageTentConvolve_Planar8">vImageTentConvolve_Planar8</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Convolves a region of interest within a Planar8 source image by an implicit M x N kernel that has the effect of a tent filter.'/>
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImageTentConvolve_ARGB8888">vImageTentConvolve_ARGB8888</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Convolves a region of interest within an ARGB8888 source image by an implicit M x N kernel that has the effect of a tent filter.'/>
            </span></li>
    </ul>


<a name="//apple_ref/doc/uid/TP40005489-CH210-361487" title="Getting the Minimum Buffer Size"></a><a name="//apple_ref/doc/uid/TP40005489-CH210-TPXREF105" title="Getting the Minimum Buffer Size"></a>
    
    <h3 class="tasks">Getting the Minimum Buffer Size</h3>
        
    <ul class="tooltip">
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImageGetMinimumTempBufferSizeForConvolution">vImageGetMinimumTempBufferSizeForConvolution</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Returns the minimum size, in bytes, for the temporary buffer that the caller supplies to any of the convolution functions. &#032;(<font color="red">Deprecated.</font>&#032;Use the <code>kvImageGetTempBufferSize</code> flag with the appropriate convolution  function instead of calling this function.)'/>
            </span></li>
    </ul>

<a name="//apple_ref/doc/uid/TP40005489-CH210-222475" title="Functions"></a><a name="//apple_ref/doc/uid/TP40005489-CH210-BBCCEIDH" title="Functions"></a><h2><a name="//apple_ref/doc/uid/TP40005489-CH210-TPXREF102" title="Functions"></a>Functions</h2>                    <a name="//apple_ref/c/func/vImageBoxConvolve_ARGB8888" title="vImageBoxConvolve_ARGB8888"></a><a name="//apple_ref/doc/c_ref/vImageBoxConvolve_ARGB8888" title="vImageBoxConvolve_ARGB8888"></a><a name="//apple_ref/doc/uid/TP40005489-CH210-SW9" title="vImageBoxConvolve_ARGB8888"></a><a name="//apple_ref/doc/uid/TP40005489-CH210-DontLinkElementID_12"></a><h3 class="tight">vImageBoxConvolve_ARGB8888</h3> <p class="spaceabove">Convolves a region of interest within an ARGB8888 source image by an implicit M x N kernel that has the effect of a box filter.</p> <p class="spaceabove"><pre>
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Error" target="_top">vImage_Error</a> vImageBoxConvolve_ARGB8888 (
   const <!--a-->vImage_Buffer<!--/a--> *src,
   const <!--a-->vImage_Buffer<!--/a--> *dest,
   void *tempBuffer,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImagePixelCount" target="_top">vImagePixelCount</a> srcOffsetToROI_X,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImagePixelCount" target="_top">vImagePixelCount</a> srcOffsetToROI_Y,
   uint32_t kernel_height,
   uint32_t kernel_width,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/Pixel_8888" target="_top">Pixel_8888</a> backgroundColor,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags
);
</pre></p> <h5 class="tight">Parameters</h5><dl class="termdef"> <dt><em>src</em></dt> <dd><p>A pointer to a vImage buffer structure that contains data for the source image.</p></dd> <dt><em>dest</em></dt> <dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.  On return, the data buffer pointed to by this structure contains  the destination image data. When you no longer need the data buffer, you must deallocate the memory. The size (number of rows and number of columns) of the destination buffer also specifies the size of the region of interest in the source buffer.</p></dd> <dt><em>tempBuffer</em></dt> <dd><p>A pointer to a temporary buffer. If you pass <code>NULL</code>, the function allocates the buffer, then deallocates it before returning. Alternatively, you can allocate the buffer yourself, in which case you are responsible for deallocating it when you is no longer need it.</p><p>If you want to allocate the buffer yourself, see the Discussion for information on how to determine the minimum size that you must allocate.</p></dd> <dt><em>srcOffsetToROI_X</em></dt> <dd><p>The horizontal offset, in pixels, to the upper-left pixel of the region of interest within the source image.</p></dd> <dt><em>srcOffsetToROI_Y</em></dt> <dd><p>The vertical offset, in pixels, to the upper-left pixel of the region of interest within the source image.</p></dd> <dt><em>kernel_height</em></dt> <dd><p>The height of the kernel in pixels. This value must be odd.</p></dd> <dt><em>kernel_width</em></dt> <dd><p>The width of the kernel in pixels. This value must be odd.</p></dd> <dt><em>backgroundColor</em></dt> <dd><p>A background color. If you supply a color, you must also set the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageBackgroundColorFill" target="_top">kvImageBackgroundColorFill</a></code> flag, otherwise the function ignores the color.</p></dd> <dt><em>flags</em></dt> <dd><p>The options to use when performing the convolution operation. You must set exactly one of the following flags to specify how vImage handles pixel locations beyond the edge of the source image:  <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageCopyInPlace" target="_top">kvImageCopyInPlace</a></code>, <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageTruncateKernel" target="_top">kvImageTruncateKernel</a></code>, <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageBackgroundColorFill" target="_top">kvImageBackgroundColorFill</a></code>, or <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageEdgeExtend" target="_top">kvImageEdgeExtend</a></code>. </p><p>Set the <code>kvImageDoNotTile</code> flag if you plan to perform your own tiling or use multithreading.</p></dd></dl> <h5 class="tight">Return Value</h5><p><code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageNoError" target="_top">kvImageNoError</a></code>, otherwise it returns one of the error codes described in <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>.</p> <h5 class="tight">Discussion</h5><p>This function uses an implicit divisor and an implicit kernel of specified size instead of a kernel provided by the caller.</p><p>If you want to allocate the memory for the <code>tempBuffer</code> parameter yourself, call this function twice, as follows:</p><ol class="ol"><li class="li"><p>To determine the minimum size for the temporary buffer, the first time you call this function pass the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageGetTempBufferSize" target="_top">kvImageGetTempBufferSize</a></code> flag. Pass the same values for all other parameters that you intend to use in for the second call. The function returns the required minimum size, which should be a positive value. (A negative returned value indicates an error.) The <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageGetTempBufferSize" target="_top">kvImageGetTempBufferSize</a></code> flag prevents the function from performing any processing other than to determine the minimum buffer size.</p></li><li class="li"><p>After you allocate enough space for a buffer of the returned size, call the function a second time, passing a valid pointer in the <code>tempBuffer</code> parameter. This time, do not pass the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageGetTempBufferSize" target="_top">kvImageGetTempBufferSize</a></code> flag.</p></li></ol><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.4 and later.</li></ul><h5 class="tight">See Also</h5><ul class="availability"><li class="availability">  <code><a href="reference.html#//apple_ref/c/func/vImageConvolve_ARGB8888">vImageConvolve_ARGB8888</a></code></li><li class="availability">  <code><a href="reference.html#//apple_ref/c/func/vImageTentConvolve_ARGB8888">vImageTentConvolve_ARGB8888</a></code></li></ul><h5 class="tight">Declared In</h5><code>Convolution.h</code><a name="//apple_ref/c/func/vImageBoxConvolve_Planar8" title="vImageBoxConvolve_Planar8"></a><a name="//apple_ref/doc/c_ref/vImageBoxConvolve_Planar8" title="vImageBoxConvolve_Planar8"></a><a name="//apple_ref/doc/uid/TP40005489-CH210-SW8" title="vImageBoxConvolve_Planar8"></a><a name="//apple_ref/doc/uid/TP40005489-CH210-DontLinkElementID_13"></a><h3 class="tight">vImageBoxConvolve_Planar8</h3> <p class="spaceabove">Convolves a region of interest within a Planar8 source image by an implicit M x N kernel that has the effect of a box filter.</p> <p class="spaceabove"><pre>
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Error" target="_top">vImage_Error</a> vImageBoxConvolve_Planar8 (
   const <!--a-->vImage_Buffer<!--/a--> *src,
   const <!--a-->vImage_Buffer<!--/a--> *dest,
   void *tempBuffer,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImagePixelCount" target="_top">vImagePixelCount</a> srcOffsetToROI_X,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImagePixelCount" target="_top">vImagePixelCount</a> srcOffsetToROI_Y,
   uint32_t kernel_height,
   uint32_t kernel_width,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/Pixel_8" target="_top">Pixel_8</a> backgroundColor,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags
);
</pre></p> <h5 class="tight">Parameters</h5><dl class="termdef"> <dt><em>src</em></dt> <dd><p>A pointer to a vImage buffer structure that contains data for the source image.</p></dd> <dt><em>dest</em></dt> <dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.  On return, the data buffer pointed to by this structure contains  the destination image data. When you no longer need the data buffer, you must deallocate the memory. The size (number of rows and number of columns) of the destination buffer also specifies the size of the region of interest in the source buffer.</p></dd> <dt><em>tempBuffer</em></dt> <dd><p>A pointer to a temporary buffer. If you pass <code>NULL</code>, the function allocates the buffer, then deallocates it before returning. Alternatively, you can allocate the buffer yourself, in which case you are responsible for deallocating it when you is no longer need it.</p><p>If you want to allocate the buffer yourself, see the Discussion for information on how to determine the minimum size that you must allocate.</p></dd> <dt><em>srcOffsetToROI_X</em></dt> <dd><p>The horizontal offset, in pixels, to the upper-left pixel of the region of interest within the source image.</p></dd> <dt><em>srcOffsetToROI_Y</em></dt> <dd><p>The vertical offset, in pixels, to the upper-left pixel of the region of interest within the source image.</p></dd> <dt><em>kernel_height</em></dt> <dd><p>The height of the kernel in pixels. This value must be odd.</p></dd> <dt><em>kernel_width</em></dt> <dd><p>The width of the kernel in pixels. This value must be odd.</p></dd> <dt><em>backgroundColor</em></dt> <dd><p>A background color. If you supply a color, you must also set the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageBackgroundColorFill" target="_top">kvImageBackgroundColorFill</a></code> flag, otherwise the function ignores the color.</p></dd> <dt><em>flags</em></dt> <dd><p>The options to use when performing the convolution operation. You must set exactly one of the following flags to specify how vImage handles pixel locations beyond the edge of the source image:  <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageCopyInPlace" target="_top">kvImageCopyInPlace</a></code>, <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageTruncateKernel" target="_top">kvImageTruncateKernel</a></code>, <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageBackgroundColorFill" target="_top">kvImageBackgroundColorFill</a></code>, or <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageEdgeExtend" target="_top">kvImageEdgeExtend</a></code>. </p><p>Set the <code>kvImageDoNotTile</code> flag if you plan to perform your own tiling or use multithreading.</p></dd></dl> <h5 class="tight">Return Value</h5><p><code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageNoError" target="_top">kvImageNoError</a></code>, otherwise it returns one of the error codes described in <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>.</p> <h5 class="tight">Discussion</h5><p>This function uses an implicit divisor and an implicit kernel of specified size instead of a kernel provided by the caller.</p><p>If you want to allocate the memory for the <code>tempBuffer</code> parameter yourself, call this function twice, as follows:</p><ol class="ol"><li class="li"><p>To determine the minimum size for the temporary buffer, the first time you call this function pass the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageGetTempBufferSize" target="_top">kvImageGetTempBufferSize</a></code> flag. Pass the same values for all other parameters that you intend to use in for the second call. The function returns the required minimum size, which should be a positive value. (A negative returned value indicates an error.) The <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageGetTempBufferSize" target="_top">kvImageGetTempBufferSize</a></code> flag prevents the function from performing any processing other than to determine the minimum buffer size.</p></li><li class="li"><p>After you allocate enough space for a buffer of the returned size, call the function a second time, passing a valid pointer in the <code>tempBuffer</code> parameter. This time, do not pass the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageGetTempBufferSize" target="_top">kvImageGetTempBufferSize</a></code> flag.</p></li></ol><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.4 and later.</li></ul><h5 class="tight">See Also</h5><ul class="availability"><li class="availability">  <code><a href="reference.html#//apple_ref/c/func/vImageConvolve_Planar8">vImageConvolve_Planar8</a></code></li><li class="availability">  <code><a href="reference.html#//apple_ref/c/func/vImageTentConvolve_Planar8">vImageTentConvolve_Planar8</a></code></li></ul><h5 class="tight">Declared In</h5><code>Convolution.h</code><a name="//apple_ref/c/func/vImageConvolveMultiKernel_ARGB8888" title="vImageConvolveMultiKernel_ARGB8888"></a><a name="//apple_ref/doc/c_ref/vImageConvolveMultiKernel_ARGB8888" title="vImageConvolveMultiKernel_ARGB8888"></a><a name="//apple_ref/doc/uid/TP40005489-CH210-DontLinkElementID_6" title="vImageConvolveMultiKernel_ARGB8888"></a><a name="//apple_ref/doc/uid/TP40005489-CH210-DontLinkElementID_14"></a><h3 class="tight">vImageConvolveMultiKernel_ARGB8888</h3> <p class="spaceabove">Convolves each channel of a region of interest within an ARGB8888 source image by one of the four M x N kernels, then divides the pixel values by one of the four divisors.</p> <p class="spaceabove"><pre>
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Error" target="_top">vImage_Error</a> vImageConvolveMultiKernel_ARGB8888 (
   const <!--a-->vImage_Buffer<!--/a--> *src,
   const <!--a-->vImage_Buffer<!--/a--> *dest,
   void *tempBuffer,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImagePixelCount" target="_top">vImagePixelCount</a> srcOffsetToROI_X,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImagePixelCount" target="_top">vImagePixelCount</a> srcOffsetToROI_Y,
   const int16_t *kernels[4],
   uint32_t kernel_height,
   uint32_t kernel_width,
   const int32_t divisors[4],
   const int32_t biases[4],
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/Pixel_8888" target="_top">Pixel_8888</a> backgroundColor,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags
);
</pre></p> <h5 class="tight">Parameters</h5><dl class="termdef"> <dt><em>src</em></dt> <dd><p>A pointer to a vImage buffer structure that contains data for the source image.</p></dd> <dt><em>dest</em></dt> <dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.  On return, the data buffer pointed to by this structure contains  the destination image data. When you no longer need the data buffer, you must deallocate the memory. The size (number of rows and number of columns) of the destination buffer also specifies the size of the region of interest in the source buffer.</p></dd> <dt><em>tempBuffer</em></dt> <dd><p>A pointer to a temporary buffer. If you pass <code>NULL</code>, the function allocates the buffer, then deallocates it before returning. Alternatively, you can allocate the buffer yourself, in which case you are responsible for deallocating it when you is no longer need it.</p><p>If you want to allocate the buffer yourself, see the Discussion for information on how to determine the minimum size that you must allocate.</p></dd> <dt><em>srcOffsetToROI_X</em></dt> <dd><p>The horizontal offset, in pixels, to the upper-left pixel of the region of interest within the source image.</p></dd> <dt><em>srcOffsetToROI_Y</em></dt> <dd><p>The vertical offset, in pixels, to the upper-left pixel of the region of interest within the source image.</p></dd> <dt><em>kernels</em></dt> <dd><p>An array of pointers to the data for four kernels. The first kernel is for the alpha channel, the second for red, the third for green, and the fourth for blue. The data for each kernel is a packed array of integer values.</p></dd> <dt><em>kernel_height</em></dt> <dd><p>The height of the kernel in pixels. This value must be odd.</p></dd> <dt><em>kernel_width</em></dt> <dd><p>The width of the kernel in pixels. This value must be odd.</p></dd> <dt><em>divisors</em></dt> <dd><p>An array of values, for normalization purposes, to divide into the convolution results. Supply one value for each channel.</p></dd> <dt><em>biases</em></dt> <dd><p>An array of four values to be added to each element of the convolution result for one channel, before clipping. The first value is for the alpha channel, the second for red, the third for green, and the fourth for blue</p></dd> <dt><em>backgroundColor</em></dt> <dd><p>A background color. If you supply a color, you must also set the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageBackgroundColorFill" target="_top">kvImageBackgroundColorFill</a></code> flag, otherwise the function ignores the color.</p></dd> <dt><em>flags</em></dt> <dd><p>The options to use when performing the convolution operation. You must set exactly one of the following flags to specify how vImage handles pixel locations beyond the edge of the source image:  <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageCopyInPlace" target="_top">kvImageCopyInPlace</a></code>, <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageTruncateKernel" target="_top">kvImageTruncateKernel</a></code>, <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageBackgroundColorFill" target="_top">kvImageBackgroundColorFill</a></code>, or <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageEdgeExtend" target="_top">kvImageEdgeExtend</a></code>. </p><p>Set the <code>kvImageDoNotTile</code> flag if you plan to perform your own tiling or use multithreading.</p></dd></dl> <h5 class="tight">Return Value</h5><p><code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageNoError" target="_top">kvImageNoError</a></code>, otherwise it returns one of the error codes described in <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>.</p> <h5 class="tight">Discussion</h5><p>If you want to allocate the memory for the <code>tempBuffer</code> parameter yourself, call this function twice, as follows:</p><ol class="ol"><li class="li"><p>To determine the minimum size for the temporary buffer, the first time you call this function pass the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageGetTempBufferSize" target="_top">kvImageGetTempBufferSize</a></code> flag. Pass the same values for all other parameters that you intend to use in for the second call. The function returns the required minimum size, which should be a positive value. (A negative returned value indicates an error.) The <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageGetTempBufferSize" target="_top">kvImageGetTempBufferSize</a></code> flag prevents the function from performing any processing other than to determine the minimum buffer size.</p></li><li class="li"><p>After you allocate enough space for a buffer of the returned size, call the function a second time, passing a valid pointer in the <code>tempBuffer</code> parameter. This time, do not pass the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageGetTempBufferSize" target="_top">kvImageGetTempBufferSize</a></code> flag.</p></li></ol><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.4 and later.</li></ul><h5 class="tight">See Also</h5><ul class="availability"><li class="availability">  <code><a href="reference.html#//apple_ref/c/func/vImageConvolveWithBias_ARGB8888">vImageConvolveWithBias_ARGB8888</a></code></li></ul><h5 class="tight">Declared In</h5><code>Convolution.h</code><a name="//apple_ref/c/func/vImageConvolveMultiKernel_ARGBFFFF" title="vImageConvolveMultiKernel_ARGBFFFF"></a><a name="//apple_ref/doc/c_ref/vImageConvolveMultiKernel_ARGBFFFF" title="vImageConvolveMultiKernel_ARGBFFFF"></a><a name="//apple_ref/doc/uid/TP40005489-CH210-DontLinkElementID_5" title="vImageConvolveMultiKernel_ARGBFFFF"></a><a name="//apple_ref/doc/uid/TP40005489-CH210-DontLinkElementID_15"></a><h3 class="tight">vImageConvolveMultiKernel_ARGBFFFF</h3> <p class="spaceabove">Convolves each channel of a region of interest within an ARGBFFFF source image by one of the four M x N kernels.</p> <p class="spaceabove"><pre>
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Error" target="_top">vImage_Error</a> vImageConvolveMultiKernel_ARGBFFFF (
   const <!--a-->vImage_Buffer<!--/a--> *src,
   const <!--a-->vImage_Buffer<!--/a--> *dest,
   void *tempBuffer,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImagePixelCount" target="_top">vImagePixelCount</a> srcOffsetToROI_X,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImagePixelCount" target="_top">vImagePixelCount</a> srcOffsetToROI_Y,
   const float *kernels[4],
   uint32_t kernel_height,
   uint32_t kernel_width,
   const float biases[4],
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/Pixel_FFFF" target="_top">Pixel_FFFF</a> backgroundColor,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags
);
</pre></p> <h5 class="tight">Parameters</h5><dl class="termdef"> <dt><em>src</em></dt> <dd><p>A pointer to a vImage buffer structure that contains data for the source image.</p></dd> <dt><em>dest</em></dt> <dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.  On return, the data buffer pointed to by this structure contains  the destination image data. When you no longer need the data buffer, you must deallocate the memory. The size (number of rows and number of columns) of the destination buffer also specifies the size of the region of interest in the source buffer.</p></dd> <dt><em>tempBuffer</em></dt> <dd><p>A pointer to a temporary buffer. If you pass <code>NULL</code>, the function allocates the buffer, then deallocates it before returning. Alternatively, you can allocate the buffer yourself, in which case you are responsible for deallocating it when you is no longer need it.</p><p>If you want to allocate the buffer yourself, see the Discussion for information on how to determine the minimum size that you must allocate.</p></dd> <dt><em>srcOffsetToROI_X</em></dt> <dd><p>The horizontal offset, in pixels, to the upper-left pixel of the region of interest within the source image.</p></dd> <dt><em>srcOffsetToROI_Y</em></dt> <dd><p>The vertical offset, in pixels, to the upper-left pixel of the region of interest within the source image.</p></dd> <dt><em>kernels</em></dt> <dd><p>An array of pointers to the data for four kernels. The first kernel is for the alpha channel, the second for red, the third for green, and the fourth for blue. The data for each kernel is a packed array of floating-point values.</p></dd> <dt><em>kernel_height</em></dt> <dd><p>The height of the kernel in pixels. This value must be odd.</p></dd> <dt><em>kernel_width</em></dt> <dd><p>The width of the kernel in pixels. This value must be odd.</p></dd> <dt><em>biases</em></dt> <dd><p>An array of four values to be added to each element of the convolution result for one channel, before clipping. The first value is for the alpha channel, the second for red, the third for green, and the fourth for blue</p></dd> <dt><em>backgroundColor</em></dt> <dd><p>A background color. If you supply a color, you must also set the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageBackgroundColorFill" target="_top">kvImageBackgroundColorFill</a></code> flag, otherwise the function ignores the color.</p></dd> <dt><em>flags</em></dt> <dd><p>The options to use when performing the convolution operation. You must set exactly one of the following flags to specify how vImage handles pixel locations beyond the edge of the source image:  <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageCopyInPlace" target="_top">kvImageCopyInPlace</a></code>, <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageTruncateKernel" target="_top">kvImageTruncateKernel</a></code>, <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageBackgroundColorFill" target="_top">kvImageBackgroundColorFill</a></code>, or <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageEdgeExtend" target="_top">kvImageEdgeExtend</a></code>. </p><p>Set the <code>kvImageDoNotTile</code> flag if you plan to perform your own tiling or use multithreading.</p></dd></dl> <h5 class="tight">Return Value</h5><p><code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageNoError" target="_top">kvImageNoError</a></code>, otherwise it returns one of the error codes described in <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>.</p> <h5 class="tight">Discussion</h5><p>If you want to allocate the memory for the <code>tempBuffer</code> parameter yourself, call this function twice, as follows:</p><ol class="ol"><li class="li"><p>To determine the minimum size for the temporary buffer, the first time you call this function pass the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageGetTempBufferSize" target="_top">kvImageGetTempBufferSize</a></code> flag. Pass the same values for all other parameters that you intend to use in for the second call. The function returns the required minimum size, which should be a positive value. (A negative returned value indicates an error.) The <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageGetTempBufferSize" target="_top">kvImageGetTempBufferSize</a></code> flag prevents the function from performing any processing other than to determine the minimum buffer size.</p></li><li class="li"><p>After you allocate enough space for a buffer of the returned size, call the function a second time, passing a valid pointer in the <code>tempBuffer</code> parameter. This time, do not pass the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageGetTempBufferSize" target="_top">kvImageGetTempBufferSize</a></code> flag.</p></li></ol><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.4 and later.</li></ul><h5 class="tight">See Also</h5><ul class="availability"><li class="availability">  <code><a href="reference.html#//apple_ref/c/func/vImageConvolveWithBias_ARGBFFFF">vImageConvolveWithBias_ARGBFFFF</a></code></li></ul><h5 class="tight">Declared In</h5><code>Convolution.h</code><a name="//apple_ref/c/func/vImageConvolveWithBias_ARGB8888" title="vImageConvolveWithBias_ARGB8888"></a><a name="//apple_ref/doc/c_ref/vImageConvolveWithBias_ARGB8888" title="vImageConvolveWithBias_ARGB8888"></a><a name="//apple_ref/doc/uid/TP40005489-CH210-SW7" title="vImageConvolveWithBias_ARGB8888"></a><a name="//apple_ref/doc/uid/TP40005489-CH210-DontLinkElementID_16"></a><h3 class="tight">vImageConvolveWithBias_ARGB8888</h3> <p class="spaceabove">Convolves a region of interest within an ARGB8888 source image by an M x N kernel, then normalizes the pixel values.</p> <p class="spaceabove"><pre>
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Error" target="_top">vImage_Error</a> vImageConvolveWithBias_ARGB8888 (
   const <!--a-->vImage_Buffer<!--/a--> *src,
   const <!--a-->vImage_Buffer<!--/a--> *dest,
   void *tempBuffer,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImagePixelCount" target="_top">vImagePixelCount</a> srcOffsetToROI_X,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImagePixelCount" target="_top">vImagePixelCount</a> srcOffsetToROI_Y,
   const int16_t *kernel,
   uint32_t kernel_height,
   uint32_t kernel_width,
   int32_t divisor,
   int32_t bias,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/Pixel_8888" target="_top">Pixel_8888</a> backgroundColor,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags
);
</pre></p> <h5 class="tight">Parameters</h5><dl class="termdef"> <dt><em>src</em></dt> <dd><p>A pointer to a vImage buffer structure that contains data for the source image.</p></dd> <dt><em>dest</em></dt> <dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.  On return, the data buffer pointed to by this structure contains  the destination image data. When you no longer need the data buffer, you must deallocate the memory. The size (number of rows and number of columns) of the destination buffer also specifies the size of the region of interest in the source buffer.</p></dd> <dt><em>tempBuffer</em></dt> <dd><p>A pointer to a temporary buffer. If you pass <code>NULL</code>, the function allocates the buffer, then deallocates it before returning. Alternatively, you can allocate the buffer yourself, in which case you are responsible for deallocating it when you is no longer need it.</p><p>If you want to allocate the buffer yourself, see the Discussion for information on how to determine the minimum size that you must allocate.</p></dd> <dt><em>srcOffsetToROI_X</em></dt> <dd><p>The horizontal offset, in pixels, to the upper-left pixel of the region of interest within the source image.</p></dd> <dt><em>srcOffsetToROI_Y</em></dt> <dd><p>The vertical offset, in pixels, to the upper-left pixel of the region of interest within the source image.</p></dd> <dt><em>kernel</em></dt> <dd><p>A pointer to the convolution kernel data, which must be a packed array without any padding.</p></dd> <dt><em>kernel_height</em></dt> <dd><p>The height of the kernel in pixels. This value must be odd.</p></dd> <dt><em>kernel_width</em></dt> <dd><p>The width of the kernel in pixels. This value must be odd.</p></dd> <dt><em>divisor</em></dt> <dd><p>The value, for normalization purposes, to divide into the convolution results.</p></dd> <dt><em>bias</em></dt> <dd><p>The value to add  to each element in the convolution result, before applying the divisor or performing any clipping.</p></dd> <dt><em>backgroundColor</em></dt> <dd><p>A background color. If you supply a color, you must also set the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageBackgroundColorFill" target="_top">kvImageBackgroundColorFill</a></code> flag, otherwise the function ignores the color.</p></dd> <dt><em>flags</em></dt> <dd><p>The options to use when performing the convolution operation. You must set exactly one of the following flags to specify how vImage handles pixel locations beyond the edge of the source image:  <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageCopyInPlace" target="_top">kvImageCopyInPlace</a></code>, <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageTruncateKernel" target="_top">kvImageTruncateKernel</a></code>, <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageBackgroundColorFill" target="_top">kvImageBackgroundColorFill</a></code>, or <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageEdgeExtend" target="_top">kvImageEdgeExtend</a></code>. </p><p>Set the <code>kvImageDoNotTile</code> flag if you plan to perform your own tiling or use multithreading.</p></dd></dl> <h5 class="tight">Return Value</h5><p><code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageNoError" target="_top">kvImageNoError</a></code>, otherwise it returns one of the error codes described in <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>.</p> <h5 class="tight">Discussion</h5><p>If you want to allocate the memory for the <code>tempBuffer</code> parameter yourself, call this function twice, as follows:</p><ol class="ol"><li class="li"><p>To determine the minimum size for the temporary buffer, the first time you call this function pass the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageGetTempBufferSize" target="_top">kvImageGetTempBufferSize</a></code> flag. Pass the same values for all other parameters that you intend to use in for the second call. The function returns the required minimum size, which should be a positive value. (A negative returned value indicates an error.) The <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageGetTempBufferSize" target="_top">kvImageGetTempBufferSize</a></code> flag prevents the function from performing any processing other than to determine the minimum buffer size.</p></li><li class="li"><p>After you allocate enough space for a buffer of the returned size, call the function a second time, passing a valid pointer in the <code>tempBuffer</code> parameter. This time, do not pass the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageGetTempBufferSize" target="_top">kvImageGetTempBufferSize</a></code> flag.</p></li></ol><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.4 and later.</li></ul><h5 class="tight">See Also</h5><ul class="availability"><li class="availability">  <code><a href="reference.html#//apple_ref/c/func/vImageConvolve_ARGB8888">vImageConvolve_ARGB8888</a></code></li></ul><h5 class="tight">Declared In</h5><code>Convolution.h</code><a name="//apple_ref/c/func/vImageConvolveWithBias_ARGBFFFF" title="vImageConvolveWithBias_ARGBFFFF"></a><a name="//apple_ref/doc/c_ref/vImageConvolveWithBias_ARGBFFFF" title="vImageConvolveWithBias_ARGBFFFF"></a><a name="//apple_ref/doc/uid/TP40005489-CH210-SW6" title="vImageConvolveWithBias_ARGBFFFF"></a><a name="//apple_ref/doc/uid/TP40005489-CH210-DontLinkElementID_17"></a><h3 class="tight">vImageConvolveWithBias_ARGBFFFF</h3> <p class="spaceabove">Convolves a region of interest within an ARGBFFFF source image by an M x N kernel.</p> <p class="spaceabove"><pre>
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Error" target="_top">vImage_Error</a> vImageConvolveWithBias_ARGBFFFF (
   const <!--a-->vImage_Buffer<!--/a--> *src,
   const <!--a-->vImage_Buffer<!--/a--> *dest,
   void *tempBuffer,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImagePixelCount" target="_top">vImagePixelCount</a> srcOffsetToROI_X,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImagePixelCount" target="_top">vImagePixelCount</a> srcOffsetToROI_Y,
   const float *kernel,
   uint32_t kernel_height,
   uint32_t kernel_width,
   float bias,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/Pixel_FFFF" target="_top">Pixel_FFFF</a> backgroundColor,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags
);
</pre></p> <h5 class="tight">Parameters</h5><dl class="termdef"> <dt><em>src</em></dt> <dd><p>A pointer to a vImage buffer structure that contains data for the source image.</p></dd> <dt><em>dest</em></dt> <dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.  On return, the data buffer pointed to by this structure contains  the destination image data. When you no longer need the data buffer, you must deallocate the memory. The size (number of rows and number of columns) of the destination buffer also specifies the size of the region of interest in the source buffer.</p></dd> <dt><em>tempBuffer</em></dt> <dd><p>A pointer to a temporary buffer. If you pass <code>NULL</code>, the function allocates the buffer, then deallocates it before returning. Alternatively, you can allocate the buffer yourself, in which case you are responsible for deallocating it when you is no longer need it.</p><p>If you want to allocate the buffer yourself, see the Discussion for information on how to determine the minimum size that you must allocate.</p></dd> <dt><em>srcOffsetToROI_X</em></dt> <dd><p>The horizontal offset, in pixels, to the upper-left pixel of the region of interest within the source image.</p></dd> <dt><em>srcOffsetToROI_Y</em></dt> <dd><p>The vertical offset, in pixels, to the upper-left pixel of the region of interest within the source image.</p></dd> <dt><em>kernel</em></dt> <dd><p>A pointer to the convolution kernel data, which must be a packed array without any padding.</p></dd> <dt><em>kernel_height</em></dt> <dd><p>The height of the kernel in pixels. This value must be odd.</p></dd> <dt><em>kernel_width</em></dt> <dd><p>The width of the kernel in pixels. This value must be odd.</p></dd> <dt><em>bias</em></dt> <dd><p>The value to add  to each element in the convolution result, before performing any clipping.</p></dd> <dt><em>backgroundColor</em></dt> <dd><p>A background color. If you supply a color, you must also set the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageBackgroundColorFill" target="_top">kvImageBackgroundColorFill</a></code> flag, otherwise the function ignores the color.</p></dd> <dt><em>flags</em></dt> <dd><p>The options to use when performing the convolution operation. You must set exactly one of the following flags to specify how vImage handles pixel locations beyond the edge of the source image:  <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageCopyInPlace" target="_top">kvImageCopyInPlace</a></code>, <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageTruncateKernel" target="_top">kvImageTruncateKernel</a></code>, <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageBackgroundColorFill" target="_top">kvImageBackgroundColorFill</a></code>, or <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageEdgeExtend" target="_top">kvImageEdgeExtend</a></code>. </p><p>Set the <code>kvImageDoNotTile</code> flag if you plan to perform your own tiling or use multithreading.</p></dd></dl> <h5 class="tight">Return Value</h5><p><code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageNoError" target="_top">kvImageNoError</a></code>, otherwise it returns one of the error codes described in <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>.</p> <h5 class="tight">Discussion</h5><p>If you want to allocate the memory for the <code>tempBuffer</code> parameter yourself, call this function twice, as follows:</p><ol class="ol"><li class="li"><p>To determine the minimum size for the temporary buffer, the first time you call this function pass the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageGetTempBufferSize" target="_top">kvImageGetTempBufferSize</a></code> flag. Pass the same values for all other parameters that you intend to use in for the second call. The function returns the required minimum size, which should be a positive value. (A negative returned value indicates an error.) The <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageGetTempBufferSize" target="_top">kvImageGetTempBufferSize</a></code> flag prevents the function from performing any processing other than to determine the minimum buffer size.</p></li><li class="li"><p>After you allocate enough space for a buffer of the returned size, call the function a second time, passing a valid pointer in the <code>tempBuffer</code> parameter. This time, do not pass the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageGetTempBufferSize" target="_top">kvImageGetTempBufferSize</a></code> flag.</p></li></ol><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.4 and later.</li></ul><h5 class="tight">See Also</h5><ul class="availability"><li class="availability">  <code><a href="reference.html#//apple_ref/c/func/vImageConvolve_ARGBFFFF">vImageConvolve_ARGBFFFF</a></code></li></ul><h5 class="tight">Declared In</h5><code>Convolution.h</code><a name="//apple_ref/c/func/vImageConvolveWithBias_Planar8" title="vImageConvolveWithBias_Planar8"></a><a name="//apple_ref/doc/c_ref/vImageConvolveWithBias_Planar8" title="vImageConvolveWithBias_Planar8"></a><a name="//apple_ref/doc/uid/TP40005489-CH210-BBCJABID" title="vImageConvolveWithBias_Planar8"></a> <a name="//apple_ref/doc/uid/TP40005489-CH210-DontLinkElementID_18"></a><h3 class="tight">vImageConvolveWithBias_Planar8</h3> <p class="spaceabove">Convolves a region of interest within a Planar8 source image by an M x N kernel, then normalizes the pixel values.</p> <p class="spaceabove"><pre>
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Error" target="_top">vImage_Error</a> vImageConvolveWithBias_Planar8 (
   const <!--a-->vImage_Buffer<!--/a--> *src,
   const <!--a-->vImage_Buffer<!--/a--> *dest,
   void *tempBuffer,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImagePixelCount" target="_top">vImagePixelCount</a> srcOffsetToROI_X,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImagePixelCount" target="_top">vImagePixelCount</a> srcOffsetToROI_Y,
   const int16_t *kernel,
   uint32_t kernel_height,
   uint32_t kernel_width,
   int32_t divisor,
   int32_t bias,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/Pixel_8" target="_top">Pixel_8</a> backgroundColor,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags
);
</pre></p> <h5 class="tight">Parameters</h5><dl class="termdef"> <dt><em>src</em></dt> <dd><p>A pointer to a vImage buffer structure that contains data for the source image.</p></dd> <dt><em>dest</em></dt> <dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.  On return, the data buffer pointed to by this structure contains  the destination image data. When you no longer need the data buffer, you must deallocate the memory. The size (number of rows and number of columns) of the destination buffer also specifies the size of the region of interest in the source buffer.</p></dd> <dt><em>tempBuffer</em></dt> <dd><p>A pointer to a temporary buffer. If you pass <code>NULL</code>, the function allocates the buffer, then deallocates it before returning. Alternatively, you can allocate the buffer yourself, in which case you are responsible for deallocating it when you is no longer need it.</p><p>If you want to allocate the buffer yourself, see the Discussion for information on how to determine the minimum size that you must allocate.</p></dd> <dt><em>srcOffsetToROI_X</em></dt> <dd><p>The horizontal offset, in pixels, to the upper-left pixel of the region of interest within the source image.</p></dd> <dt><em>srcOffsetToROI_Y</em></dt> <dd><p>The vertical offset, in pixels, to the upper-left pixel of the region of interest within the source image.</p></dd> <dt><em>kernel</em></dt> <dd><p>A pointer to the convolution kernel data, which must be a packed array without any padding.</p></dd> <dt><em>kernel_height</em></dt> <dd><p>The height of the kernel in pixels. This value must be odd.</p></dd> <dt><em>kernel_width</em></dt> <dd><p>The width of the kernel in pixels. This value must be odd.</p></dd> <dt><em>divisor</em></dt> <dd><p>The value, for normalization purposes, to divide into the convolution results.</p></dd> <dt><em>bias</em></dt> <dd><p>The value to add  to each element in the convolution result, before applying the divisor or performing any clipping.</p></dd> <dt><em>backgroundColor</em></dt> <dd><p>A background color. If you supply a color, you must also set the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageBackgroundColorFill" target="_top">kvImageBackgroundColorFill</a></code> flag, otherwise the function ignores the color.</p></dd> <dt><em>flags</em></dt> <dd><p>The options to use when performing the convolution operation. You must set exactly one of the following flags to specify how vImage handles pixel locations beyond the edge of the source image:  <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageCopyInPlace" target="_top">kvImageCopyInPlace</a></code>, <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageTruncateKernel" target="_top">kvImageTruncateKernel</a></code>, <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageBackgroundColorFill" target="_top">kvImageBackgroundColorFill</a></code>, or <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageEdgeExtend" target="_top">kvImageEdgeExtend</a></code>. </p><p>Set the <code>kvImageDoNotTile</code> flag if you plan to perform your own tiling or use multithreading.</p></dd></dl> <h5 class="tight">Return Value</h5><p><code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageNoError" target="_top">kvImageNoError</a></code>, otherwise it returns one of the error codes described in <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>.</p> <h5 class="tight">Discussion</h5><p>If you want to allocate the memory for the <code>tempBuffer</code> parameter yourself, call this function twice, as follows:</p><ol class="ol"><li class="li"><p>To determine the minimum size for the temporary buffer, the first time you call this function pass the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageGetTempBufferSize" target="_top">kvImageGetTempBufferSize</a></code> flag. Pass the same values for all other parameters that you intend to use in for the second call. The function returns the required minimum size, which should be a positive value. (A negative returned value indicates an error.) The <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageGetTempBufferSize" target="_top">kvImageGetTempBufferSize</a></code> flag prevents the function from performing any processing other than to determine the minimum buffer size.</p></li><li class="li"><p>After you allocate enough space for a buffer of the returned size, call the function a second time, passing a valid pointer in the <code>tempBuffer</code> parameter. This time, do not pass the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageGetTempBufferSize" target="_top">kvImageGetTempBufferSize</a></code> flag.</p></li></ol><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.4 and later.</li></ul><h5 class="tight">See Also</h5><ul class="availability"><li class="availability">  <code><a href="reference.html#//apple_ref/c/func/vImageConvolve_Planar8">vImageConvolve_Planar8</a></code></li></ul><h5 class="tight">Declared In</h5><code>Convolution.h</code><a name="//apple_ref/c/func/vImageConvolveWithBias_PlanarF" title="vImageConvolveWithBias_PlanarF"></a><a name="//apple_ref/doc/c_ref/vImageConvolveWithBias_PlanarF" title="vImageConvolveWithBias_PlanarF"></a><a name="//apple_ref/doc/uid/TP40005489-CH210-DontLinkElementID_3" title="vImageConvolveWithBias_PlanarF"></a><a name="//apple_ref/doc/uid/TP40005489-CH210-DontLinkElementID_19"></a><h3 class="tight">vImageConvolveWithBias_PlanarF</h3> <p class="spaceabove">Convolves a region of interest within a PlanarF source image by an M x N kernel.</p> <p class="spaceabove"><pre>
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Error" target="_top">vImage_Error</a> vImageConvolveWithBias_PlanarF (
   const <!--a-->vImage_Buffer<!--/a--> *src,
   const <!--a-->vImage_Buffer<!--/a--> *dest,
   void *tempBuffer,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImagePixelCount" target="_top">vImagePixelCount</a> srcOffsetToROI_X,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImagePixelCount" target="_top">vImagePixelCount</a> srcOffsetToROI_Y,
   const float *kernel,
   uint32_t kernel_height,
   uint32_t kernel_width,
   float bias,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/Pixel_F" target="_top">Pixel_F</a> backgroundColor,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags
);
</pre></p> <h5 class="tight">Parameters</h5><dl class="termdef"> <dt><em>src</em></dt> <dd><p>A pointer to a vImage buffer structure that contains data for the source image.</p></dd> <dt><em>dest</em></dt> <dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.  On return, the data buffer pointed to by this structure contains  the destination image data. When you no longer need the data buffer, you must deallocate the memory. The size (number of rows and number of columns) of the destination buffer also specifies the size of the region of interest in the source buffer.</p></dd> <dt><em>tempBuffer</em></dt> <dd><p>A pointer to a temporary buffer. If you pass <code>NULL</code>, the function allocates the buffer, then deallocates it before returning. Alternatively, you can allocate the buffer yourself, in which case you are responsible for deallocating it when you is no longer need it.</p><p>If you want to allocate the buffer yourself, see the Discussion for information on how to determine the minimum size that you must allocate.</p></dd> <dt><em>srcOffsetToROI_X</em></dt> <dd><p>The horizontal offset, in pixels, to the upper-left pixel of the region of interest within the source image.</p></dd> <dt><em>srcOffsetToROI_Y</em></dt> <dd><p>The vertical offset, in pixels, to the upper-left pixel of the region of interest within the source image.</p></dd> <dt><em>kernel</em></dt> <dd><p>A pointer to the convolution kernel data, which must be a packed array without any padding.</p></dd> <dt><em>kernel_height</em></dt> <dd><p>The height of the kernel in pixels. This value must be odd.</p></dd> <dt><em>kernel_width</em></dt> <dd><p>The width of the kernel in pixels. This value must be odd.</p></dd> <dt><em>bias</em></dt> <dd><p>The value to add  to each element in the convolution result, before performing any clipping.</p></dd> <dt><em>backgroundColor</em></dt> <dd><p>A background color. If you supply a color, you must also set the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageBackgroundColorFill" target="_top">kvImageBackgroundColorFill</a></code> flag, otherwise the function ignores the color.</p></dd> <dt><em>flags</em></dt> <dd><p>The options to use when performing the convolution operation. You must set exactly one of the following flags to specify how vImage handles pixel locations beyond the edge of the source image:  <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageCopyInPlace" target="_top">kvImageCopyInPlace</a></code>, <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageTruncateKernel" target="_top">kvImageTruncateKernel</a></code>, <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageBackgroundColorFill" target="_top">kvImageBackgroundColorFill</a></code>, or <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageEdgeExtend" target="_top">kvImageEdgeExtend</a></code>. </p><p>Set the <code>kvImageDoNotTile</code> flag if you plan to perform your own tiling or use multithreading.</p></dd></dl> <h5 class="tight">Return Value</h5><p><code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageNoError" target="_top">kvImageNoError</a></code>, otherwise it returns one of the error codes described in <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>.</p> <h5 class="tight">Discussion</h5><p>If you want to allocate the memory for the <code>tempBuffer</code> parameter yourself, call this function twice, as follows:</p><ol class="ol"><li class="li"><p>To determine the minimum size for the temporary buffer, the first time you call this function pass the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageGetTempBufferSize" target="_top">kvImageGetTempBufferSize</a></code> flag. Pass the same values for all other parameters that you intend to use in for the second call. The function returns the required minimum size, which should be a positive value. (A negative returned value indicates an error.) The <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageGetTempBufferSize" target="_top">kvImageGetTempBufferSize</a></code> flag prevents the function from performing any processing other than to determine the minimum buffer size.</p></li><li class="li"><p>After you allocate enough space for a buffer of the returned size, call the function a second time, passing a valid pointer in the <code>tempBuffer</code> parameter. This time, do not pass the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageGetTempBufferSize" target="_top">kvImageGetTempBufferSize</a></code> flag.</p></li></ol><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.4 and later.</li></ul><h5 class="tight">See Also</h5><ul class="availability"><li class="availability">  <code><a href="reference.html#//apple_ref/c/func/vImageConvolve_PlanarF">vImageConvolve_PlanarF</a></code></li></ul><h5 class="tight">Declared In</h5><code>Convolution.h</code><a name="//apple_ref/c/func/vImageConvolve_ARGB8888" title="vImageConvolve_ARGB8888"></a><a name="//apple_ref/doc/c_ref/vImageConvolve_ARGB8888" title="vImageConvolve_ARGB8888"></a><a name="//apple_ref/doc/uid/TP40005489-CH210-vImageConvolve_ARGB8888" title="vImageConvolve_ARGB8888"></a><a name="//apple_ref/doc/uid/TP40005489-CH210-DontLinkElementID_20"></a><h3 class="tight">vImageConvolve_ARGB8888</h3> <p class="spaceabove">Convolves a region of interest within a source image by an M x N kernel, then divides the pixel values by a divisor.</p> <p class="spaceabove"><pre>
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Error" target="_top">vImage_Error</a> vImageConvolve_ARGB8888 (
   const <!--a-->vImage_Buffer<!--/a--> *src,
   const <!--a-->vImage_Buffer<!--/a--> *dest,
   void *tempBuffer,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImagePixelCount" target="_top">vImagePixelCount</a> srcOffsetToROI_X,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImagePixelCount" target="_top">vImagePixelCount</a> srcOffsetToROI_Y,
   const int16_t *kernel,
   uint32_t kernel_height,
   uint32_t kernel_width,
   int32_t divisor,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/Pixel_8888" target="_top">Pixel_8888</a> backgroundColor,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags
);
</pre></p> <h5 class="tight">Parameters</h5><dl class="termdef"> <dt><em>src</em></dt> <dd><p>A pointer to a vImage buffer structure that contains data for the source image.</p></dd> <dt><em>dest</em></dt> <dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.  On return, the data buffer pointed to by this structure contains  the destination image data. When you no longer need the data buffer, you must deallocate the memory. The size (number of rows and number of columns) of the destination buffer also specifies the size of the region of interest in the source buffer.</p></dd> <dt><em>tempBuffer</em></dt> <dd><p>A pointer to a temporary buffer. If you pass <code>NULL</code>, the function allocates the buffer, then deallocates it before returning. Alternatively, you can allocate the buffer yourself, in which case you are responsible for deallocating it when you is no longer need it.</p><p>If you want to allocate the buffer yourself, see the Discussion for information on how to determine the minimum size that you must allocate.</p></dd> <dt><em>srcOffsetToROI_X</em></dt> <dd><p>The horizontal offset, in pixels, to the upper-left pixel of the region of interest within the source image.</p></dd> <dt><em>srcOffsetToROI_Y</em></dt> <dd><p>The vertical offset, in pixels, to the upper-left pixel of the region of interest within the source image.</p></dd> <dt><em>kernel</em></dt> <dd><p>A pointer to the convolution kernel data, which must be a packed array without any padding.</p></dd> <dt><em>kernel_height</em></dt> <dd><p>The height of the kernel in pixels. This value must be odd.</p></dd> <dt><em>kernel_width</em></dt> <dd><p>The width of the kernel in pixels. This value must be odd.</p></dd> <dt><em>divisor</em></dt> <dd><p>A value to divide the results of the convolution by. This is commonly used for normalization.</p></dd> <dt><em>backgroundColor</em></dt> <dd><p>A background color. If you supply a color, you must also set the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageBackgroundColorFill" target="_top">kvImageBackgroundColorFill</a></code> flag, otherwise the function ignores the color.</p></dd> <dt><em>flags</em></dt> <dd><p>The options to use when performing the convolution operation. You must set exactly one of the following flags to specify how vImage handles pixel locations beyond the edge of the source image:  <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageCopyInPlace" target="_top">kvImageCopyInPlace</a></code>, <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageTruncateKernel" target="_top">kvImageTruncateKernel</a></code>, <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageBackgroundColorFill" target="_top">kvImageBackgroundColorFill</a></code>, or <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageEdgeExtend" target="_top">kvImageEdgeExtend</a></code>. </p><p>Set the <code>kvImageDoNotTile</code> flag if you plan to perform your own tiling or use multithreading.</p></dd></dl> <h5 class="tight">Return Value</h5><p><code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageNoError" target="_top">kvImageNoError</a></code>, otherwise it returns one of the error codes described in <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>.</p> <h5 class="tight">Discussion</h5><p>If you want to allocate the memory for the <code>tempBuffer</code> parameter yourself, call this function twice, as follows:</p><ol class="ol"><li class="li"><p>To determine the minimum size for the temporary buffer, the first time you call this function pass the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageGetTempBufferSize" target="_top">kvImageGetTempBufferSize</a></code> flag. Pass the same values for all other parameters that you intend to use in for the second call. The function returns the required minimum size, which should be a positive value. (A negative returned value indicates an error.) The <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageGetTempBufferSize" target="_top">kvImageGetTempBufferSize</a></code> flag prevents the function from performing any processing other than to determine the minimum buffer size.</p></li><li class="li"><p>After you allocate enough space for a buffer of the returned size, call the function a second time, passing a valid pointer in the <code>tempBuffer</code> parameter. This time, do not pass the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageGetTempBufferSize" target="_top">kvImageGetTempBufferSize</a></code> flag.</p></li></ol><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.3 and later.</li></ul><h5 class="tight">Declared In</h5><code>Convolution.h</code><a name="//apple_ref/c/func/vImageConvolve_ARGBFFFF" title="vImageConvolve_ARGBFFFF"></a><a name="//apple_ref/doc/c_ref/vImageConvolve_ARGBFFFF" title="vImageConvolve_ARGBFFFF"></a><a name="//apple_ref/doc/uid/TP40005489-CH210-vImageConvolve_ARGBFFFF" title="vImageConvolve_ARGBFFFF"></a><a name="//apple_ref/doc/uid/TP40005489-CH210-DontLinkElementID_21"></a><h3 class="tight">vImageConvolve_ARGBFFFF</h3> <p class="spaceabove">Convolves a region of interest within an ARGBFFFF source image by an M x N kernel.</p> <p class="spaceabove"><pre>
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Error" target="_top">vImage_Error</a> vImageConvolve_ARGBFFFF (
   const <!--a-->vImage_Buffer<!--/a--> *src,
   const <!--a-->vImage_Buffer<!--/a--> *dest,
   void *tempBuffer,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImagePixelCount" target="_top">vImagePixelCount</a> srcOffsetToROI_X,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImagePixelCount" target="_top">vImagePixelCount</a> srcOffsetToROI_Y,
   const float *kernel,
   uint32_t kernel_height,
   uint32_t kernel_width,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/Pixel_FFFF" target="_top">Pixel_FFFF</a> backgroundColor,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags
);
</pre></p> <h5 class="tight">Parameters</h5><dl class="termdef"> <dt><em>src</em></dt> <dd><p>A pointer to a vImage buffer structure that contains data for the source image.</p></dd> <dt><em>dest</em></dt> <dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.  On return, the data buffer pointed to by this structure contains  the destination image data. When you no longer need the data buffer, you must deallocate the memory. The size (number of rows and number of columns) of the destination buffer also specifies the size of the region of interest in the source buffer.</p></dd> <dt><em>tempBuffer</em></dt> <dd><p>A pointer to a temporary buffer. If you pass <code>NULL</code>, the function allocates the buffer, then deallocates it before returning. Alternatively, you can allocate the buffer yourself, in which case you are responsible for deallocating it when you is no longer need it.</p><p>If you want to allocate the buffer yourself, see the Discussion for information on how to determine the minimum size that you must allocate.</p></dd> <dt><em>srcOffsetToROI_X</em></dt> <dd><p>The horizontal offset, in pixels, to the upper-left pixel of the region of interest within the source image.  offsets to a point within the source image to define the upper left-hand point of the region of interest. </p></dd> <dt><em>srcOffsetToROI_Y</em></dt> <dd><p>The vertical offset, in pixels, to the upper-left pixel of the region of interest within the source image.</p></dd> <dt><em>kernel</em></dt> <dd><p>A pointer to the convolution kernel data, which must be a packed array without any padding.</p></dd> <dt><em>kernel_height</em></dt> <dd><p>The height of the kernel in pixels. This value must be odd.</p></dd> <dt><em>kernel_width</em></dt> <dd><p>The width of the kernel in pixels. This value must be odd.</p></dd> <dt><em>backgroundColor</em></dt> <dd><p>A background color. If you supply a color, you must also set the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageBackgroundColorFill" target="_top">kvImageBackgroundColorFill</a></code> flag, otherwise the function ignores the color.</p></dd> <dt><em>flags</em></dt> <dd><p>The options to use when performing the convolution operation. You must set exactly one of the following flags to specify how vImage handles pixel locations beyond the edge of the source image:  <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageCopyInPlace" target="_top">kvImageCopyInPlace</a></code>, <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageTruncateKernel" target="_top">kvImageTruncateKernel</a></code>, <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageBackgroundColorFill" target="_top">kvImageBackgroundColorFill</a></code>, or <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageEdgeExtend" target="_top">kvImageEdgeExtend</a></code>. </p><p>Set the <code>kvImageDoNotTile</code> flag if you plan to perform your own tiling or use multithreading.</p></dd></dl> <h5 class="tight">Return Value</h5><p><code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageNoError" target="_top">kvImageNoError</a></code>, otherwise it returns one of the error codes described in <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>.</p> <h5 class="tight">Discussion</h5><p>If you want to allocate the memory for the <code>tempBuffer</code> parameter yourself, call this function twice, as follows:</p><ol class="ol"><li class="li"><p>To determine the minimum size for the temporary buffer, the first time you call this function pass the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageGetTempBufferSize" target="_top">kvImageGetTempBufferSize</a></code> flag. Pass the same values for all other parameters that you intend to use in for the second call. The function returns the required minimum size, which should be a positive value. (A negative returned value indicates an error.) The <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageGetTempBufferSize" target="_top">kvImageGetTempBufferSize</a></code> flag prevents the function from performing any processing other than to determine the minimum buffer size.</p></li><li class="li"><p>After you allocate enough space for a buffer of the returned size, call the function a second time, passing a valid pointer in the <code>tempBuffer</code> parameter. This time, do not pass the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageGetTempBufferSize" target="_top">kvImageGetTempBufferSize</a></code> flag.</p></li></ol><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.3 and later.</li></ul><h5 class="tight">Declared In</h5><code>Convolution.h</code><a name="//apple_ref/c/func/vImageConvolve_Planar8" title="vImageConvolve_Planar8"></a><a name="//apple_ref/doc/c_ref/vImageConvolve_Planar8" title="vImageConvolve_Planar8"></a><a name="//apple_ref/doc/uid/TP40005489-CH210-vImageConvolve_Planar8" title="vImageConvolve_Planar8"></a><a name="//apple_ref/doc/uid/TP40005489-CH210-DontLinkElementID_22"></a><h3 class="tight">vImageConvolve_Planar8</h3> <p class="spaceabove">Convolves a region of interest within a source image by an M x N kernel, then divides the pixel values by a divisor.</p> <p class="spaceabove"><pre>
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Error" target="_top">vImage_Error</a> vImageConvolve_Planar8 (
   const <!--a-->vImage_Buffer<!--/a--> *src,
   const <!--a-->vImage_Buffer<!--/a--> *dest,
   void *tempBuffer,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImagePixelCount" target="_top">vImagePixelCount</a> srcOffsetToROI_X,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImagePixelCount" target="_top">vImagePixelCount</a> srcOffsetToROI_Y,
   const int16_t *kernel,
   uint32_t kernel_height,
   uint32_t kernel_width,
   int32_t divisor,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/Pixel_8" target="_top">Pixel_8</a> backgroundColor,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags
);
</pre></p> <h5 class="tight">Parameters</h5><dl class="termdef"> <dt><em>src</em></dt> <dd><p>A pointer to a vImage buffer structure that contains data for the source image.</p></dd> <dt><em>dest</em></dt> <dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.  On return, the data buffer pointed to by this structure contains  the destination image data. When you no longer need the data buffer, you must deallocate the memory. The size (number of rows and number of columns) of the destination buffer also specifies the size of the region of interest in the source buffer.</p></dd> <dt><em>tempBuffer</em></dt> <dd><p>A pointer to a temporary buffer. If you pass <code>NULL</code>, the function allocates the buffer, then deallocates it before returning. Alternatively, you can allocate the buffer yourself, in which case you are responsible for deallocating it when you is no longer need it.</p><p>If you want to allocate the buffer yourself, see the Discussion for information on how to determine the minimum size that you must allocate.</p></dd> <dt><em>srcOffsetToROI_X</em></dt> <dd><p>The horizontal offset, in pixels, to the upper-left pixel of the region of interest within the source image.</p></dd> <dt><em>srcOffsetToROI_Y</em></dt> <dd><p>The vertical offset, in pixels, to the upper-left pixel of the region of interest within the source image.</p></dd> <dt><em>kernel</em></dt> <dd><p>A pointer to the convolution kernel data, which must be a packed array without any padding.</p></dd> <dt><em>kernel_height</em></dt> <dd><p>The height of the kernel in pixels. This value must be odd.</p></dd> <dt><em>kernel_width</em></dt> <dd><p>The width of the kernel in pixels. This value must be odd.</p></dd> <dt><em>divisor</em></dt> <dd><p>A value to divide the results of the convolution with. This is commonly used for normalization.</p></dd> <dt><em>backgroundColor</em></dt> <dd><p>A background color. If you supply a color, you must also set the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageBackgroundColorFill" target="_top">kvImageBackgroundColorFill</a></code> flag, otherwise the function ignores the color.</p></dd> <dt><em>flags</em></dt> <dd><p>The options to use when performing the convolution operation. You must set exactly one of the following flags to specify how vImage handles pixel locations beyond the edge of the source image:  <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageCopyInPlace" target="_top">kvImageCopyInPlace</a></code>, <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageTruncateKernel" target="_top">kvImageTruncateKernel</a></code>, <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageBackgroundColorFill" target="_top">kvImageBackgroundColorFill</a></code>, or <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageEdgeExtend" target="_top">kvImageEdgeExtend</a></code>. </p><p>Set the <code>kvImageDoNotTile</code> flag if you plan to perform your own tiling or use multithreading.</p></dd></dl> <h5 class="tight">Return Value</h5><p><code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageNoError" target="_top">kvImageNoError</a></code>, otherwise it returns one of the error codes described in <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>.</p> <h5 class="tight">Discussion</h5><p>If you want to allocate the memory for the <code>tempBuffer</code> parameter yourself, call this function twice, as follows:</p><ol class="ol"><li class="li"><p>To determine the minimum size for the temporary buffer, the first time you call this function pass the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageGetTempBufferSize" target="_top">kvImageGetTempBufferSize</a></code> flag. Pass the same values for all other parameters that you intend to use in for the second call. The function returns the required minimum size, which should be a positive value. (A negative returned value indicates an error.) The <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageGetTempBufferSize" target="_top">kvImageGetTempBufferSize</a></code> flag prevents the function from performing any processing other than to determine the minimum buffer size.</p></li><li class="li"><p>After you allocate enough space for a buffer of the returned size, call the function a second time, passing a valid pointer in the <code>tempBuffer</code> parameter. This time, do not pass the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageGetTempBufferSize" target="_top">kvImageGetTempBufferSize</a></code> flag.</p></li></ol><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.3 and later.</li></ul><h5 class="tight">Declared In</h5><code>Convolution.h</code><a name="//apple_ref/c/func/vImageConvolve_PlanarF" title="vImageConvolve_PlanarF"></a><a name="//apple_ref/doc/c_ref/vImageConvolve_PlanarF" title="vImageConvolve_PlanarF"></a><a name="//apple_ref/doc/uid/TP40005489-CH210-vImageConvolve_PlanarF" title="vImageConvolve_PlanarF"></a><a name="//apple_ref/doc/uid/TP40005489-CH210-DontLinkElementID_23"></a><h3 class="tight">vImageConvolve_PlanarF</h3> <p class="spaceabove">Convolves a region of interest within a source image by an M x N kernel.</p> <p class="spaceabove"><pre>
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Error" target="_top">vImage_Error</a> vImageConvolve_PlanarF (
   const <!--a-->vImage_Buffer<!--/a--> *src,
   const <!--a-->vImage_Buffer<!--/a--> *dest,
   void *tempBuffer,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImagePixelCount" target="_top">vImagePixelCount</a> srcOffsetToROI_X,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImagePixelCount" target="_top">vImagePixelCount</a> srcOffsetToROI_Y,
   const float *kernel,
   uint32_t kernel_height,
   uint32_t kernel_width,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/Pixel_F" target="_top">Pixel_F</a> backgroundColor,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags
);
</pre></p> <h5 class="tight">Parameters</h5><dl class="termdef"> <dt><em>src</em></dt> <dd><p>A pointer to a vImage buffer structure that contains data for the source image.</p></dd> <dt><em>dest</em></dt> <dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.  On return, the data buffer pointed to by this structure contains  the destination image data. When you no longer need the data buffer, you must deallocate the memory. The size (number of rows and number of columns) of the destination buffer also specifies the size of the region of interest in the source buffer.</p></dd> <dt><em>tempBuffer</em></dt> <dd><p>A pointer to a temporary buffer. If you pass <code>NULL</code>, the function allocates the buffer, then deallocates it before returning. Alternatively, you can allocate the buffer yourself, in which case you are responsible for deallocating it when you is no longer need it.</p><p>If you want to allocate the buffer yourself, see the Discussion for information on how to determine the minimum size that you must allocate.</p></dd> <dt><em>srcOffsetToROI_X</em></dt> <dd><p>The horizontal offset, in pixels, to the upper-left pixel of the region of interest within the source image.</p></dd> <dt><em>srcOffsetToROI_Y</em></dt> <dd><p>The vertical offset, in pixels, to the upper-left pixel of the region of interest within the source image.</p></dd> <dt><em>kernel</em></dt> <dd><p>A pointer to the convolution kernel data, which must be a packed array without any padding.</p></dd> <dt><em>kernel_height</em></dt> <dd><p>The height of the kernel in pixels. This value must be odd.</p></dd> <dt><em>kernel_width</em></dt> <dd><p>The width of the kernel in pixels. This value must be odd.</p></dd> <dt><em>backgroundColor</em></dt> <dd><p>A background color. If you supply a color, you must also set the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageBackgroundColorFill" target="_top">kvImageBackgroundColorFill</a></code> flag, otherwise the function ignores the color.</p></dd> <dt><em>flags</em></dt> <dd><p>The options to use when performing the convolution operation. You must set exactly one of the following flags to specify how vImage handles pixel locations beyond the edge of the source image:  <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageCopyInPlace" target="_top">kvImageCopyInPlace</a></code>, <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageTruncateKernel" target="_top">kvImageTruncateKernel</a></code>, <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageBackgroundColorFill" target="_top">kvImageBackgroundColorFill</a></code>, or <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageEdgeExtend" target="_top">kvImageEdgeExtend</a></code>. </p><p>Set the <code>kvImageDoNotTile</code> flag if you plan to perform your own tiling or use multithreading.</p></dd></dl> <h5 class="tight">Return Value</h5><p><code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageNoError" target="_top">kvImageNoError</a></code>, otherwise it returns one of the error codes described in <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>.</p> <h5 class="tight">Discussion</h5><p>If you want to allocate the memory for the <code>tempBuffer</code> parameter yourself, call this function twice, as follows:</p><ol class="ol"><li class="li"><p>To determine the minimum size for the temporary buffer, the first time you call this function pass the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageGetTempBufferSize" target="_top">kvImageGetTempBufferSize</a></code> flag. Pass the same values for all other parameters that you intend to use in for the second call. The function returns the required minimum size, which should be a positive value. (A negative returned value indicates an error.) The <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageGetTempBufferSize" target="_top">kvImageGetTempBufferSize</a></code> flag prevents the function from performing any processing other than to determine the minimum buffer size.</p></li><li class="li"><p>After you allocate enough space for a buffer of the returned size, call the function a second time, passing a valid pointer in the <code>tempBuffer</code> parameter. This time, do not pass the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageGetTempBufferSize" target="_top">kvImageGetTempBufferSize</a></code> flag.</p></li></ol><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.3 and later.</li></ul><h5 class="tight">Declared In</h5><code>Convolution.h</code><a name="//apple_ref/c/func/vImageGetMinimumTempBufferSizeForConvolution" title="vImageGetMinimumTempBufferSizeForConvolution"></a><a name="//apple_ref/doc/c_ref/vImageGetMinimumTempBufferSizeForConvolution" title="vImageGetMinimumTempBufferSizeForConvolution"></a><a name="//apple_ref/doc/uid/TP40005489-CH210-vImageGetMinimumTempBufferSizeForConvolution" title="vImageGetMinimumTempBufferSizeForConvolution"></a><a name="//apple_ref/doc/uid/TP40005489-CH210-DontLinkElementID_24"></a><h3 class="tight">vImageGetMinimumTempBufferSizeForConvolution</h3> <p class="spaceabove">Returns the minimum size, in bytes, for the temporary buffer that the caller supplies to any of the convolution functions. &#032;(<strong>Deprecated.</strong>&#032;Use the <code>kvImageGetTempBufferSize</code> flag with the appropriate convolution  function instead of calling this function.)</p> <p class="spaceabove"><pre>
size_t vImageGetMinimumTempBufferSizeForConvolution (
   const <!--a-->vImage_Buffer<!--/a--> *src,
   const <!--a-->vImage_Buffer<!--/a--> *dest,
   uint32_t kernel_height,
   uint32_t kernel_width,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags,
   size_t bytesPerPixel
);
</pre></p> <h5 class="tight">Parameters</h5><dl class="termdef"> <dt><em>src</em></dt> <dd><p>A pointer to the vImage buffer structure that you plan to pass to the convolution function.</p></dd> <dt><em>dest</em></dt> <dd><p>A pointer to the vImage buffer structure that you plan to pass to the convolution function.</p></dd> <dt><em>kernel_height</em></dt> <dd><p>The height, in pixels, of the kernel that you plan to use in the convolution  function.</p></dd> <dt><em>kernel_width</em></dt> <dd><p>The width, in pixels, of the kernel that you plan to use in the convolution  function.</p></dd> <dt><em>flags</em></dt> <dd><p>The flags that  you plan to pass to the convolution  function.</p></dd> <dt><em>bytesPerPixel</em></dt> <dd><p>The number of bytes in a pixel. Make sure to pass the value appropriate for the format of the pixel.</p></dd></dl> <h5 class="tight">Return Value</h5> <p>The minimum size, in bytes, of the temporary buffer.</p> <h5 class="tight">Discussion</h5> <p>This function does not depend on the <em>data</em> or <em>rowBytes</em> fields of the <em>src</em> or <em>dest</em> parameters; it only uses the <em>height</em> and <em>width</em> fields from those parameters. If the size of the images you are processing stay the same, then the required size of the buffer also stays the same. More specifically, if, between two calls to <code><a href="reference.html#//apple_ref/doc/c_ref/vImageGetMinimumTempBufferSizeForConvolution">vImageGetMinimumTempBufferSizeForConvolution</a></code>, the <code>height</code> and <code>width</code> of the <em>src</em> and <em>dest</em> parameters do not increase, and the other parameters remain the same, then the result of the <code><a href="reference.html#//apple_ref/doc/c_ref/vImageGetMinimumTempBufferSizeForConvolution">vImageGetMinimumTempBufferSizeForConvolution</a></code> does not increase. This makes it easy to reuse the same temporary buffer when you are processing a number of images of the same size, as in tiling. </p><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.3 and later.</li><li class="availability">Deprecated in Mac OS X v10.4.</li></ul><h5 class="tight">Declared In</h5><code>Convolution.h</code><a name="//apple_ref/c/func/vImageRichardsonLucyDeConvolve_ARGB8888" title="vImageRichardsonLucyDeConvolve_ARGB8888"></a><a name="//apple_ref/doc/c_ref/vImageRichardsonLucyDeConvolve_ARGB8888" title="vImageRichardsonLucyDeConvolve_ARGB8888"></a><a name="//apple_ref/doc/uid/TP40005489-CH210-SW5" title="vImageRichardsonLucyDeConvolve_ARGB8888"></a><a name="//apple_ref/doc/uid/TP40005489-CH210-DontLinkElementID_25"></a><h3 class="tight">vImageRichardsonLucyDeConvolve_ARGB8888</h3> <p class="spaceabove">Sharpens an ARGB8888 image by undoing a previous convolution that blurred the image, such as diffraction effects in a camera lens. </p> <p class="spaceabove"><pre>
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Error" target="_top">vImage_Error</a> vImageRichardsonLucyDeConvolve_ARGB8888 (
   const <!--a-->vImage_Buffer<!--/a--> *src,
   const <!--a-->vImage_Buffer<!--/a--> *dest,
   void *tempBuffer,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImagePixelCount" target="_top">vImagePixelCount</a> srcOffsetToROI_X,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImagePixelCount" target="_top">vImagePixelCount</a> srcOffsetToROI_Y,
   const int16_t *kernel,
   const int16_t *kernel2,
   uint32_t kernel_height,
   uint32_t kernel_width,
   uint32_t kernel_height2,
   uint32_t kernel_width2,
   int32_t divisor,
   int32_t divisor2,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/Pixel_8888" target="_top">Pixel_8888</a> backgroundColor,
   uint32_t iterationCount,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags
);
</pre></p> <h5 class="tight">Parameters</h5><dl class="termdef"> <dt><em>src</em></dt> <dd><p>A pointer to a vImage buffer structure that contains data for the source image.</p></dd> <dt><em>dest</em></dt> <dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.  On return, the data buffer pointed to by this structure contains  the destination image data. When you no longer need the data buffer, you must deallocate the memory. The size (number of rows and number of columns) of the destination buffer also specifies the size of the region of interest in the source buffer.</p></dd> <dt><em>tempBuffer</em></dt> <dd><p>A pointer to a temporary buffer. If you pass <code>NULL</code>, the function allocates the buffer, then deallocates it before returning. Alternatively, you can allocate the buffer yourself, in which case you are responsible for deallocating it when you is no longer need it.</p><p>If you want to allocate the buffer yourself, see the Discussion for information on how to determine the minimum size that you must allocate.</p></dd> <dt><em>srcOffsetToROI_X</em></dt> <dd><p>The horizontal offset, in pixels, to the upper-left pixel of the region of interest within the source image.</p></dd> <dt><em>srcOffsetToROI_Y</em></dt> <dd><p>The vertical offset, in pixels, to the upper-left pixel of the region of interest within the source image.</p></dd> <dt><em>kernel</em></dt> <dd><p>A pointer to the deconvolution kernel data, which must be a packed array without any padding. The kernel expresses a blurring convolution or point-spread function.</p></dd> <dt><em>kernel2</em></dt> <dd><p>A pointer to the data of a second kernel, which must be a packed array without any padding. Supply this kernel only if the first kernel is asymmetrical; otherwise pass <code><!--a  -->NULL<!--/a--></code>.</p></dd> <dt><em>kernel_height</em></dt> <dd><p>The height of the first kernel in pixels. This value must be odd.</p></dd> <dt><em>kernel_width</em></dt> <dd><p>The width of the first kernel in pixels. This value must be odd.</p></dd> <dt><em>kernel_height2</em></dt> <dd><p>The height of the second kernel in pixels (ignored if <em>kernel2</em> is <code><!--a  -->NULL<!--/a--></code>). This value must be odd.</p></dd> <dt><em>kernel_width2</em></dt> <dd><p>The width of the second kernel in pixels (ignored if <em>kernel2</em> is <code><!--a  -->NULL<!--/a--></code>). This value must be odd.</p></dd> <dt><em>divisor</em></dt> <dd><p>The divisor to be used in convolutions with the first kernel.</p></dd> <dt><em>divisor2</em></dt> <dd><p>The divisor to be used in convolutions with the second kernel.</p></dd> <dt><em>backgroundColor</em></dt> <dd><p>A background color. If you supply a color, you must also set the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageBackgroundColorFill" target="_top">kvImageBackgroundColorFill</a></code> flag, otherwise the function ignores the color.</p></dd> <dt><em>iterationCount</em></dt> <dd><p>The number of times to iterate the deconvolution algorithm.</p></dd><dt><em>flags</em></dt><dd><p>The options to use when performing the deconvolution operation. You must set exactly one of the following flags to specify how vImage handles pixel locations beyond the edge of the source image:  <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageCopyInPlace" target="_top">kvImageCopyInPlace</a></code>, <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageTruncateKernel" target="_top">kvImageTruncateKernel</a></code>, <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageBackgroundColorFill" target="_top">kvImageBackgroundColorFill</a></code>, or <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageEdgeExtend" target="_top">kvImageEdgeExtend</a></code>. </p><p>Set the <code>kvImageDoNotTile</code> flag if you plan to perform your own tiling or use multithreading.</p></dd></dl> <h5 class="tight">Return Value</h5><p><code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageNoError" target="_top">kvImageNoError</a></code>, otherwise it returns one of the error codes described in <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>.</p> <h5 class="tight">Discussion</h5><p>This function performs a Richardson-Lucy deconvolution of a region of interest within a source image by an M x N kernel, performing a specified number of iterations and placing the result in a destination buffer. </p><p>If you want to allocate the memory for the <code>tempBuffer</code> parameter yourself, call this function twice, as follows:</p><ol class="ol"><li class="li"><p>To determine the minimum size for the temporary buffer, the first time you call this function pass the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageGetTempBufferSize" target="_top">kvImageGetTempBufferSize</a></code> flag. Pass the same values for all other parameters that you intend to use in for the second call. The function returns the required minimum size, which should be a positive value. (A negative returned value indicates an error.) The <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageGetTempBufferSize" target="_top">kvImageGetTempBufferSize</a></code> flag prevents the function from performing any processing other than to determine the minimum buffer size.</p></li><li class="li"><p>After you allocate enough space for a buffer of the returned size, call the function a second time, passing a valid pointer in the <code>tempBuffer</code> parameter. This time, do not pass the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageGetTempBufferSize" target="_top">kvImageGetTempBufferSize</a></code> flag.</p></li></ol><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.4 and later.</li></ul><h5 class="tight">See Also</h5><ul class="availability"><li class="availability">  <code><a href="reference.html#//apple_ref/c/func/vImageRichardsonLucyDeConvolve_Planar8">vImageRichardsonLucyDeConvolve_Planar8</a></code></li></ul><h5 class="tight">Declared In</h5><code>Convolution.h</code><a name="//apple_ref/c/func/vImageRichardsonLucyDeConvolve_ARGBFFFF" title="vImageRichardsonLucyDeConvolve_ARGBFFFF"></a><a name="//apple_ref/doc/c_ref/vImageRichardsonLucyDeConvolve_ARGBFFFF" title="vImageRichardsonLucyDeConvolve_ARGBFFFF"></a><a name="//apple_ref/doc/uid/TP40005489-CH210-SW4" title="vImageRichardsonLucyDeConvolve_ARGBFFFF"></a><a name="//apple_ref/doc/uid/TP40005489-CH210-DontLinkElementID_26"></a><h3 class="tight">vImageRichardsonLucyDeConvolve_ARGBFFFF</h3> <p class="spaceabove">Sharpens an ARGBFFFF image by undoing a previous convolution that blurred the image, such as diffraction effects in a camera lens.</p> <p class="spaceabove"><pre>
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Error" target="_top">vImage_Error</a> vImageRichardsonLucyDeConvolve_ARGBFFFF (
   const <!--a-->vImage_Buffer<!--/a--> *src,
   const <!--a-->vImage_Buffer<!--/a--> *dest,
   void *tempBuffer,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImagePixelCount" target="_top">vImagePixelCount</a> srcOffsetToROI_X,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImagePixelCount" target="_top">vImagePixelCount</a> srcOffsetToROI_Y,
   const float *kernel,
   const float *kernel2,
   uint32_t kernel_height,
   uint32_t kernel_width,
   uint32_t kernel_height2,
   uint32_t kernel_width2,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/Pixel_FFFF" target="_top">Pixel_FFFF</a> backgroundColor,
   uint32_t iterationCount,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags
);
</pre></p> <h5 class="tight">Parameters</h5><dl class="termdef"> <dt><em>src</em></dt> <dd><p>A pointer to a vImage buffer structure that contains data for the source image.</p></dd> <dt><em>dest</em></dt> <dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.  On return, the data buffer pointed to by this structure contains  the destination image data. When you no longer need the data buffer, you must deallocate the memory. The size (number of rows and number of columns) of the destination buffer also specifies the size of the region of interest in the source buffer.</p></dd> <dt><em>tempBuffer</em></dt> <dd><p>A pointer to a temporary buffer. If you pass <code>NULL</code>, the function allocates the buffer, then deallocates it before returning. Alternatively, you can allocate the buffer yourself, in which case you are responsible for deallocating it when you is no longer need it.</p><p>If you want to allocate the buffer yourself, see the Discussion for information on how to determine the minimum size that you must allocate.</p></dd> <dt><em>srcOffsetToROI_X</em></dt> <dd><p>The horizontal offset, in pixels, to the upper-left pixel of the region of interest within the source image.</p></dd> <dt><em>srcOffsetToROI_Y</em></dt> <dd><p>The vertical offset, in pixels, to the upper-left pixel of the region of interest within the source image.</p></dd> <dt><em>kernel</em></dt> <dd><p>A pointer to the deconvolution kernel data, which must be a packed array without any padding. The kernel expresses a blurring convolution or point-spread function.</p></dd> <dt><em>kernel2</em></dt> <dd><p>A pointer to the data of a second kernel, which must be a packed array without any padding. Supply this kernel only if the first kernel is asymmetrical; otherwise pass <code><!--a  -->NULL<!--/a--></code>.</p></dd> <dt><em>kernel_height</em></dt> <dd><p>The height of the first kernel in pixels. This value must be odd.</p></dd> <dt><em>kernel_width</em></dt> <dd><p>The width of the first kernel in pixels. This value must be odd.</p></dd> <dt><em>kernel_height2</em></dt> <dd><p>The height of the second kernel in pixels (ignored if <em>kernel2</em> is <code><!--a  -->NULL<!--/a--></code>). This value must be odd.</p></dd> <dt><em>kernel_width2</em></dt> <dd><p>The width of the second kernel in pixels (ignored if <em>kernel2</em> is <code><!--a  -->NULL<!--/a--></code>). This value must be odd.</p></dd> <dt><em>backgroundColor</em></dt> <dd><p>A background color. If you supply a color, you must also set the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageBackgroundColorFill" target="_top">kvImageBackgroundColorFill</a></code> flag, otherwise the function ignores the color.</p></dd> <dt><em>iterationCount</em></dt> <dd><p>The number of times to iterate the deconvolution algorithm.</p></dd><dt><em>flags</em></dt><dd><p>The options to use when performing the deconvolution operation. You must set exactly one of the following flags to specify how vImage handles pixel locations beyond the edge of the source image:  <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageCopyInPlace" target="_top">kvImageCopyInPlace</a></code>, <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageTruncateKernel" target="_top">kvImageTruncateKernel</a></code>, <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageBackgroundColorFill" target="_top">kvImageBackgroundColorFill</a></code>, or <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageEdgeExtend" target="_top">kvImageEdgeExtend</a></code>. </p><p>Set the <code>kvImageDoNotTile</code> flag if you plan to perform your own tiling or use multithreading.</p></dd></dl> <h5 class="tight">Return Value</h5><p><code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageNoError" target="_top">kvImageNoError</a></code>, otherwise it returns one of the error codes described in <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>.</p> <h5 class="tight">Discussion</h5><p>This function performs a Richardson-Lucy deconvolution of a region of interest within a source image by an M x N kernel, performing a specified number of iterations and placing the result in a destination buffer.</p><p>If you want to allocate the memory for the <code>tempBuffer</code> parameter yourself, call this function twice, as follows:</p><ol class="ol"><li class="li"><p>To determine the minimum size for the temporary buffer, the first time you call this function pass the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageGetTempBufferSize" target="_top">kvImageGetTempBufferSize</a></code> flag. Pass the same values for all other parameters that you intend to use in for the second call. The function returns the required minimum size, which should be a positive value. (A negative returned value indicates an error.) The <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageGetTempBufferSize" target="_top">kvImageGetTempBufferSize</a></code> flag prevents the function from performing any processing other than to determine the minimum buffer size.</p></li><li class="li"><p>After you allocate enough space for a buffer of the returned size, call the function a second time, passing a valid pointer in the <code>tempBuffer</code> parameter. This time, do not pass the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageGetTempBufferSize" target="_top">kvImageGetTempBufferSize</a></code> flag.</p></li></ol><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.4 and later.</li></ul><h5 class="tight">See Also</h5><ul class="availability"><li class="availability">  <code><a href="reference.html#//apple_ref/c/func/vImageRichardsonLucyDeConvolve_PlanarF">vImageRichardsonLucyDeConvolve_PlanarF</a></code></li></ul><h5 class="tight">Declared In</h5><code>Convolution.h</code><a name="//apple_ref/c/func/vImageRichardsonLucyDeConvolve_Planar8" title="vImageRichardsonLucyDeConvolve_Planar8"></a><a name="//apple_ref/doc/c_ref/vImageRichardsonLucyDeConvolve_Planar8" title="vImageRichardsonLucyDeConvolve_Planar8"></a><a name="//apple_ref/doc/uid/TP40005489-CH210-SW3" title="vImageRichardsonLucyDeConvolve_Planar8"></a><a name="//apple_ref/doc/uid/TP40005489-CH210-DontLinkElementID_27"></a><h3 class="tight">vImageRichardsonLucyDeConvolve_Planar8</h3> <p class="spaceabove">Sharpens a Planar8 image by undoing a previous convolution that blurred the image, such as diffraction effects in a camera lens. </p> <p class="spaceabove"><pre>
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Error" target="_top">vImage_Error</a> vImageRichardsonLucyDeConvolve_Planar8 (
   const <!--a-->vImage_Buffer<!--/a--> *src,
   const <!--a-->vImage_Buffer<!--/a--> *dest,
   void *tempBuffer,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImagePixelCount" target="_top">vImagePixelCount</a> srcOffsetToROI_X,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImagePixelCount" target="_top">vImagePixelCount</a> srcOffsetToROI_Y,
   const int16_t *kernel,
   const int16_t *kernel2,
   uint32_t kernel_height,
   uint32_t kernel_width,
   uint32_t kernel_height2,
   uint32_t kernel_width2,
   int32_t divisor,
   int32_t divisor2,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/Pixel_8" target="_top">Pixel_8</a> backgroundColor,
   uint32_t iterationCount,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags
);
</pre></p> <h5 class="tight">Parameters</h5><dl class="termdef"> <dt><em>src</em></dt> <dd><p>A pointer to a vImage buffer structure that contains data for the source image.</p></dd> <dt><em>dest</em></dt> <dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.  On return, the data buffer pointed to by this structure contains  the destination image data. When you no longer need the data buffer, you must deallocate the memory. The size (number of rows and number of columns) of the destination buffer also specifies the size of the region of interest in the source buffer.</p></dd> <dt><em>tempBuffer</em></dt> <dd><p>A pointer to a temporary buffer. If you pass <code>NULL</code>, the function allocates the buffer, then deallocates it before returning. Alternatively, you can allocate the buffer yourself, in which case you are responsible for deallocating it when you is no longer need it.</p><p>If you want to allocate the buffer yourself, see the Discussion for information on how to determine the minimum size that you must allocate.</p></dd> <dt><em>srcOffsetToROI_X</em></dt> <dd><p>The horizontal offset, in pixels, to the upper-left pixel of the region of interest within the source image.</p></dd> <dt><em>srcOffsetToROI_Y</em></dt> <dd><p>The vertical offset, in pixels, to the upper-left pixel of the region of interest within the source image.</p></dd> <dt><em>kernel</em></dt> <dd><p>A pointer to the deconvolution kernel data, which must be a packed array without any padding. The kernel expresses a blurring convolution or point-spread function.</p></dd> <dt><em>kernel2</em></dt> <dd><p>A pointer to the data of a second kernel, which must be a packed array without any padding. Supply this kernel only if the first kernel is asymmetrical; otherwise pass <code><!--a  -->NULL<!--/a--></code>.</p></dd> <dt><em>kernel_height</em></dt> <dd><p>The height of the first kernel in pixels. This value must be odd.</p></dd> <dt><em>kernel_width</em></dt> <dd><p>The width of the first kernel in pixels. This value must be odd.</p></dd> <dt><em>kernel_height2</em></dt> <dd><p>The height of the second kernel in pixels (ignored if <em>kernel2</em> is <code><!--a  -->NULL<!--/a--></code>). This value must be odd.</p></dd> <dt><em>kernel_width2</em></dt> <dd><p>The width of the second kernel in pixels (ignored if <em>kernel2</em> is <code><!--a  -->NULL<!--/a--></code>). This value must be odd.</p></dd> <dt><em>backgroundColor</em></dt> <dd><p>A background color. If you supply a color, you must also set the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageBackgroundColorFill" target="_top">kvImageBackgroundColorFill</a></code> flag, otherwise the function ignores the color.</p></dd> <dt><em>iterationCount</em></dt> <dd><p>The number of times to iterate the deconvolution algorithm.</p></dd><dt><em>flags</em></dt><dd><p>The options to use when performing the deconvolution operation. You must set exactly one of the following flags to specify how vImage handles pixel locations beyond the edge of the source image:  <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageCopyInPlace" target="_top">kvImageCopyInPlace</a></code>, <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageTruncateKernel" target="_top">kvImageTruncateKernel</a></code>, <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageBackgroundColorFill" target="_top">kvImageBackgroundColorFill</a></code>, or <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageEdgeExtend" target="_top">kvImageEdgeExtend</a></code>. </p><p>Set the <code>kvImageDoNotTile</code> flag if you plan to perform your own tiling or use multithreading.</p></dd></dl> <h5 class="tight">Return Value</h5><p><code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageNoError" target="_top">kvImageNoError</a></code>, otherwise it returns one of the error codes described in <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>.</p> <h5 class="tight">Discussion</h5><p>This function performs a Richardson-Lucy deconvolution of a region of interest within a source image by an M x N kernel, performing a specified number of iterations and placing the result in a destination buffer.</p><p>If you want to allocate the memory for the <code>tempBuffer</code> parameter yourself, call this function twice, as follows:</p><ol class="ol"><li class="li"><p>To determine the minimum size for the temporary buffer, the first time you call this function pass the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageGetTempBufferSize" target="_top">kvImageGetTempBufferSize</a></code> flag. Pass the same values for all other parameters that you intend to use in for the second call. The function returns the required minimum size, which should be a positive value. (A negative returned value indicates an error.) The <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageGetTempBufferSize" target="_top">kvImageGetTempBufferSize</a></code> flag prevents the function from performing any processing other than to determine the minimum buffer size.</p></li><li class="li"><p>After you allocate enough space for a buffer of the returned size, call the function a second time, passing a valid pointer in the <code>tempBuffer</code> parameter. This time, do not pass the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageGetTempBufferSize" target="_top">kvImageGetTempBufferSize</a></code> flag.</p></li></ol><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.4 and later.</li></ul><h5 class="tight">See Also</h5><ul class="availability"><li class="availability">  <code><a href="reference.html#//apple_ref/c/func/vImageRichardsonLucyDeConvolve_ARGB8888">vImageRichardsonLucyDeConvolve_ARGB8888</a></code></li></ul><h5 class="tight">Declared In</h5><code>Convolution.h</code><a name="//apple_ref/c/func/vImageRichardsonLucyDeConvolve_PlanarF" title="vImageRichardsonLucyDeConvolve_PlanarF"></a><a name="//apple_ref/doc/c_ref/vImageRichardsonLucyDeConvolve_PlanarF" title="vImageRichardsonLucyDeConvolve_PlanarF"></a><a name="//apple_ref/doc/uid/TP40005489-CH210-SW2" title="vImageRichardsonLucyDeConvolve_PlanarF"></a><a name="//apple_ref/doc/uid/TP40005489-CH210-DontLinkElementID_28"></a><h3 class="tight">vImageRichardsonLucyDeConvolve_PlanarF</h3> <p class="spaceabove">Sharpens a PlanarF image by undoing a previous convolution that blurred the image, such as diffraction effects in a camera lens. </p> <p class="spaceabove"><pre>
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Error" target="_top">vImage_Error</a> vImageRichardsonLucyDeConvolve_PlanarF (
   const <!--a-->vImage_Buffer<!--/a--> *src,
   const <!--a-->vImage_Buffer<!--/a--> *dest,
   void *tempBuffer,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImagePixelCount" target="_top">vImagePixelCount</a> srcOffsetToROI_X,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImagePixelCount" target="_top">vImagePixelCount</a> srcOffsetToROI_Y,
   const float *kernel,
   const float *kernel2,
   uint32_t kernel_height,
   uint32_t kernel_width,
   uint32_t kernel_height2,
   uint32_t kernel_width2,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/Pixel_F" target="_top">Pixel_F</a> backgroundColor,
   uint32_t iterationCount,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags
);
</pre></p> <h5 class="tight">Parameters</h5><dl class="termdef"> <dt><em>src</em></dt> <dd><p>A pointer to a vImage buffer structure that contains data for the source image.</p></dd> <dt><em>dest</em></dt> <dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.  On return, the data buffer pointed to by this structure contains  the destination image data. When you no longer need the data buffer, you must deallocate the memory. The size (number of rows and number of columns) of the destination buffer also specifies the size of the region of interest in the source buffer.</p></dd> <dt><em>tempBuffer</em></dt> <dd><p>A pointer to a temporary buffer. If you pass <code>NULL</code>, the function allocates the buffer, then deallocates it before returning. Alternatively, you can allocate the buffer yourself, in which case you are responsible for deallocating it when you is no longer need it.</p><p>If you want to allocate the buffer yourself, see the Discussion for information on how to determine the minimum size that you must allocate.</p></dd> <dt><em>srcOffsetToROI_X</em></dt> <dd><p>The horizontal offset, in pixels, to the upper-left pixel of the region of interest within the source image.</p></dd> <dt><em>srcOffsetToROI_Y</em></dt> <dd><p>The vertical offset, in pixels, to the upper-left pixel of the region of interest within the source image.</p></dd> <dt><em>kernel</em></dt> <dd><p>A pointer to the deconvolution kernel data, which must be a packed array without any padding. The kernel expresses a blurring convolution or point-spread function.</p></dd> <dt><em>kernel2</em></dt> <dd><p>A pointer to the data of a second kernel, which must be a packed array without any padding. Supply this kernel only if the first kernel is asymmetrical; otherwise pass <code><!--a  -->NULL<!--/a--></code>.</p></dd> <dt><em>kernel_height</em></dt> <dd><p>The height of the first kernel in pixels. This value must be odd.</p></dd> <dt><em>kernel_width</em></dt> <dd><p>The width of the first kernel in pixels. This value must be odd.</p></dd> <dt><em>kernel_height2</em></dt> <dd><p>The height of the second kernel in pixels (ignored if <em>kernel2</em> is <code><!--a  -->NULL<!--/a--></code>). This value must be odd.</p></dd> <dt><em>kernel_width2</em></dt> <dd><p>The width of the second kernel in pixels (ignored if <em>kernel2</em> is <code><!--a  -->NULL<!--/a--></code>). This value must be odd.</p></dd> <dt><em>backgroundColor</em></dt> <dd><p>A background color. If you supply a color, you must also set the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageBackgroundColorFill" target="_top">kvImageBackgroundColorFill</a></code> flag, otherwise the function ignores the color.</p></dd> <dt><em>iterationCount</em></dt> <dd><p>The number of times to iterate the deconvolution algorithm.</p></dd><dt><em>flags</em></dt><dd><p>The options to use when performing the deconvolution operation. You must set exactly one of the following flags to specify how vImage handles pixel locations beyond the edge of the source image:  <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageCopyInPlace" target="_top">kvImageCopyInPlace</a></code>, <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageTruncateKernel" target="_top">kvImageTruncateKernel</a></code>, <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageBackgroundColorFill" target="_top">kvImageBackgroundColorFill</a></code>, or <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageEdgeExtend" target="_top">kvImageEdgeExtend</a></code>. </p><p>Set the <code>kvImageDoNotTile</code> flag if you plan to perform your own tiling or use multithreading.</p></dd></dl> <h5 class="tight">Return Value</h5><p><code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageNoError" target="_top">kvImageNoError</a></code>, otherwise it returns one of the error codes described in <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>.</p> <h5 class="tight">Discussion</h5><p>The function performs a Richardson-Lucy deconvolution of a region of interest within a source image by an M x N kernel, performing a specified number of iterations and placing the result in a destination buffer.</p><p>If you want to allocate the memory for the <code>tempBuffer</code> parameter yourself, call this function twice, as follows:</p><ol class="ol"><li class="li"><p>To determine the minimum size for the temporary buffer, the first time you call this function pass the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageGetTempBufferSize" target="_top">kvImageGetTempBufferSize</a></code> flag. Pass the same values for all other parameters that you intend to use in for the second call. The function returns the required minimum size, which should be a positive value. (A negative returned value indicates an error.) The <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageGetTempBufferSize" target="_top">kvImageGetTempBufferSize</a></code> flag prevents the function from performing any processing other than to determine the minimum buffer size.</p></li><li class="li"><p>After you allocate enough space for a buffer of the returned size, call the function a second time, passing a valid pointer in the <code>tempBuffer</code> parameter. This time, do not pass the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageGetTempBufferSize" target="_top">kvImageGetTempBufferSize</a></code> flag.</p></li></ol><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.4 and later.</li></ul><h5 class="tight">See Also</h5><ul class="availability"><li class="availability">  <code><a href="reference.html#//apple_ref/c/func/vImageRichardsonLucyDeConvolve_ARGBFFFF">vImageRichardsonLucyDeConvolve_ARGBFFFF</a></code></li></ul><h5 class="tight">Declared In</h5><code>Convolution.h</code><a name="//apple_ref/c/func/vImageTentConvolve_ARGB8888" title="vImageTentConvolve_ARGB8888"></a><a name="//apple_ref/doc/c_ref/vImageTentConvolve_ARGB8888" title="vImageTentConvolve_ARGB8888"></a><a name="//apple_ref/doc/uid/TP40005489-CH210-SW10" title="vImageTentConvolve_ARGB8888"></a><a name="//apple_ref/doc/uid/TP40005489-CH210-DontLinkElementID_29"></a><h3 class="tight">vImageTentConvolve_ARGB8888</h3> <p class="spaceabove">Convolves a region of interest within an ARGB8888 source image by an implicit M x N kernel that has the effect of a tent filter.</p> <p class="spaceabove"><pre>
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Error" target="_top">vImage_Error</a> vImageTentConvolve_ARGB8888 (
   const <!--a-->vImage_Buffer<!--/a--> *src,
   const <!--a-->vImage_Buffer<!--/a--> *dest,
   void *tempBuffer,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImagePixelCount" target="_top">vImagePixelCount</a> srcOffsetToROI_X,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImagePixelCount" target="_top">vImagePixelCount</a> srcOffsetToROI_Y,
   uint32_t kernel_height,
   uint32_t kernel_width,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/Pixel_8888" target="_top">Pixel_8888</a> backgroundColor,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags
);
</pre></p> <h5 class="tight">Parameters</h5><dl class="termdef"> <dt><em>src</em></dt> <dd><p>A pointer to a vImage buffer structure that contains data for the source image.</p></dd> <dt><em>dest</em></dt> <dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.  On return, the data buffer pointed to by this structure contains  the destination image data. When you no longer need the data buffer, you must deallocate the memory. The size (number of rows and number of columns) of the destination buffer also specifies the size of the region of interest in the source buffer.</p></dd> <dt><em>tempBuffer</em></dt> <dd><p>A pointer to a temporary buffer. If you pass <code>NULL</code>, the function allocates the buffer, then deallocates it before returning. Alternatively, you can allocate the buffer yourself, in which case you are responsible for deallocating it when you is no longer need it.</p><p>If you want to allocate the buffer yourself, see the Discussion for information on how to determine the minimum size that you must allocate.</p></dd> <dt><em>srcOffsetToROI_X</em></dt> <dd><p>The horizontal offset, in pixels, to the upper-left pixel of the region of interest within the source image.</p></dd> <dt><em>srcOffsetToROI_Y</em></dt> <dd><p>The vertical offset, in pixels, to the upper-left pixel of the region of interest within the source image.</p></dd> <dt><em>kernel_height</em></dt> <dd><p>The height of the kernel in pixels. This value must be odd.</p></dd> <dt><em>kernel_width</em></dt> <dd><p>The width of the kernel in pixels. This value must be odd.</p></dd> <dt><em>backgroundColor</em></dt> <dd><p>A background color. If you supply a color, you must also set the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageBackgroundColorFill" target="_top">kvImageBackgroundColorFill</a></code> flag, otherwise the function ignores the color.</p></dd> <dt><em>flags</em></dt> <dd><p>The options to use when performing the convolution operation. You must set exactly one of the following flags to specify how vImage handles pixel locations beyond the edge of the source image:  <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageCopyInPlace" target="_top">kvImageCopyInPlace</a></code>, <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageTruncateKernel" target="_top">kvImageTruncateKernel</a></code>, <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageBackgroundColorFill" target="_top">kvImageBackgroundColorFill</a></code>, or <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageEdgeExtend" target="_top">kvImageEdgeExtend</a></code>. </p><p>Set the <code>kvImageDoNotTile</code> flag if you plan to perform your own tiling or use multithreading.</p></dd></dl> <h5 class="tight">Return Value</h5><p><code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageNoError" target="_top">kvImageNoError</a></code>, otherwise it returns one of the error codes described in <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>.</p> <h5 class="tight">Discussion</h5><p>This function uses an implicit divisor and an implicit kernel of specified size instead of a kernel provided by the caller.</p><p>If you want to allocate the memory for the <code>tempBuffer</code> parameter yourself, call this function twice, as follows:</p><ol class="ol"><li class="li"><p>To determine the minimum size for the temporary buffer, the first time you call this function pass the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageGetTempBufferSize" target="_top">kvImageGetTempBufferSize</a></code> flag. Pass the same values for all other parameters that you intend to use in for the second call. The function returns the required minimum size, which should be a positive value. (A negative returned value indicates an error.) The <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageGetTempBufferSize" target="_top">kvImageGetTempBufferSize</a></code> flag prevents the function from performing any processing other than to determine the minimum buffer size.</p></li><li class="li"><p>After you allocate enough space for a buffer of the returned size, call the function a second time, passing a valid pointer in the <code>tempBuffer</code> parameter. This time, do not pass the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageGetTempBufferSize" target="_top">kvImageGetTempBufferSize</a></code> flag.</p></li></ol><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.4 and later.</li></ul><h5 class="tight">See Also</h5><ul class="availability"><li class="availability">  <code><a href="reference.html#//apple_ref/c/func/vImageConvolve_ARGB8888">vImageConvolve_ARGB8888</a></code></li><li class="availability">  <code><a href="reference.html#//apple_ref/c/func/vImageBoxConvolve_ARGB8888">vImageBoxConvolve_ARGB8888</a></code></li></ul><h5 class="tight">Declared In</h5><code>Convolution.h</code><a name="//apple_ref/c/func/vImageTentConvolve_Planar8" title="vImageTentConvolve_Planar8"></a><a name="//apple_ref/doc/c_ref/vImageTentConvolve_Planar8" title="vImageTentConvolve_Planar8"></a><a name="//apple_ref/doc/uid/TP40005489-CH210-SW11" title="vImageTentConvolve_Planar8"></a><a name="//apple_ref/doc/uid/TP40005489-CH210-DontLinkElementID_30"></a><h3 class="tight">vImageTentConvolve_Planar8</h3> <p class="spaceabove">Convolves a region of interest within a Planar8 source image by an implicit M x N kernel that has the effect of a tent filter.</p> <p class="spaceabove"><pre>
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Error" target="_top">vImage_Error</a> vImageTentConvolve_Planar8 (
   const <!--a-->vImage_Buffer<!--/a--> *src,
   const <!--a-->vImage_Buffer<!--/a--> *dest,
   void *tempBuffer,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImagePixelCount" target="_top">vImagePixelCount</a> srcOffsetToROI_X,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImagePixelCount" target="_top">vImagePixelCount</a> srcOffsetToROI_Y,
   uint32_t kernel_height,
   uint32_t kernel_width,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/Pixel_8" target="_top">Pixel_8</a> backgroundColor,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags
);
</pre></p> <h5 class="tight">Parameters</h5><dl class="termdef"> <dt><em>src</em></dt> <dd><p>A pointer to a vImage buffer structure that contains data for the source image.</p></dd> <dt><em>dest</em></dt> <dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.  On return, the data buffer pointed to by this structure contains  the destination image data. When you no longer need the data buffer, you must deallocate the memory. . The size (number of rows and number of columns) of the destination buffer also specifies the size of the region of interest in the source buffer.</p></dd> <dt><em>tempBuffer</em></dt> <dd><p>A pointer to a temporary buffer. If you pass <code>NULL</code>, the function allocates the buffer, then deallocates it before returning. Alternatively, you can allocate the buffer yourself, in which case you are responsible for deallocating it when you is no longer need it.</p><p>If you want to allocate the buffer yourself, see the Discussion for information on how to determine the minimum size that you must allocate.</p></dd> <dt><em>srcOffsetToROI_X</em></dt> <dd><p>The horizontal offset, in pixels, to the upper-left pixel of the region of interest within the source image.</p></dd> <dt><em>srcOffsetToROI_Y</em></dt> <dd><p>The vertical offset, in pixels, to the upper-left pixel of the region of interest within the source image.</p></dd> <dt><em>kernel_height</em></dt> <dd><p>The height of the kernel in pixels. This value must be odd.</p></dd> <dt><em>kernel_width</em></dt> <dd><p>The width of the kernel in pixels. This value must be odd.</p></dd> <dt><em>backgroundColor</em></dt> <dd><p>A background color. If you supply a color, you must also set the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageBackgroundColorFill" target="_top">kvImageBackgroundColorFill</a></code> flag, otherwise the function ignores the color.</p></dd> <dt><em>flags</em></dt> <dd><p>The options to use when performing the convolution operation. You must set exactly one of the following flags to specify how vImage handles pixel locations beyond the edge of the source image:  <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageCopyInPlace" target="_top">kvImageCopyInPlace</a></code>, <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageTruncateKernel" target="_top">kvImageTruncateKernel</a></code>, <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageBackgroundColorFill" target="_top">kvImageBackgroundColorFill</a></code>, or <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageEdgeExtend" target="_top">kvImageEdgeExtend</a></code>. </p><p>Set the <code>kvImageDoNotTile</code> flag if you plan to perform your own tiling or use multithreading.</p></dd></dl> <h5 class="tight">Return Value</h5><p><code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageNoError" target="_top">kvImageNoError</a></code>, otherwise it returns one of the error codes described in <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>.</p> <h5 class="tight">Discussion</h5><p>This function uses an implicit divisor and an implicit kernel of specified size instead of a kernel provided by the caller.</p><p>If you want to allocate the memory for the <code>tempBuffer</code> parameter yourself, call this function twice, as follows:</p><ol class="ol"><li class="li"><p>To determine the minimum size for the temporary buffer, the first time you call this function pass the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageGetTempBufferSize" target="_top">kvImageGetTempBufferSize</a></code> flag. Pass the same values for all other parameters that you intend to use in for the second call. The function returns the required minimum size, which should be a positive value. (A negative returned value indicates an error.) The <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageGetTempBufferSize" target="_top">kvImageGetTempBufferSize</a></code> flag prevents the function from performing any processing other than to determine the minimum buffer size.</p></li><li class="li"><p>After you allocate enough space for a buffer of the returned size, call the function a second time, passing a valid pointer in the <code>tempBuffer</code> parameter. This time, do not pass the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageGetTempBufferSize" target="_top">kvImageGetTempBufferSize</a></code> flag.</p></li></ol><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.4 and later.</li></ul><h5 class="tight">See Also</h5><ul class="availability"><li class="availability">  <code><a href="reference.html#//apple_ref/c/func/vImageConvolve_Planar8">vImageConvolve_Planar8</a></code></li><li class="availability">  <code><a href="reference.html#//apple_ref/c/func/vImageBoxConvolve_Planar8">vImageBoxConvolve_Planar8</a></code></li></ul><h5 class="tight">Declared In</h5><code>Convolution.h</code>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <!-- Previous button --><span style="margin-left: 8px"><a href="../RevisionHistory.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2007 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2007-07-12<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Performance/Reference/vImage_convolution/Reference/reference.html%3Fid%3DTP40005489-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Performance/Reference/vImage_convolution/Reference/reference.html%3Fid%3DTP40005489-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Performance/Reference/vImage_convolution/Reference/reference.html%3Fid%3DTP40005489-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>