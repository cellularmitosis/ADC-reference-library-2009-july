#include <Types.h>#include <Files.h>#include <Resources.h>#include <StandardFile.h>#include <Printing.h>#include <TextUtils.h>#include "driverTypes.h"OSErr SelectOutputFile(FSSpec *fileSpec){	StandardFileReply	reply;	OSErr	theError;	StringHandle	prompt = GetString(defaultPromptID);	StringHandle	aStrHdl = GetString(defaultFileNameID);		///// The following typecasts are needed due to Radar ID#s	///// 1341495, 1341498 and 1341516. SC is not following	///// ¤A6.8 of The C Programming Language, Second Edition	///// -DaveP 4/16/96	HLock((Handle)aStrHdl);	HLock((Handle)prompt);	StandardPutFile(*prompt, *aStrHdl, &reply);	HUnlock((Handle)aStrHdl);	ReleaseResource((Handle)aStrHdl);	HUnlock((Handle)prompt);	ReleaseResource((Handle)prompt);	if (reply.sfGood) {		if (reply.sfReplacing) {			theError = FSpDelete(&(reply.sfFile));		} else {			theError = noErr;		}	} else theError = iPrAbort;		*fileSpec = reply.sfFile;	return theError;}OSErr OpenOutputFile(FSSpec *fileSpec, short *refnum, Boolean isResource){	OSType	theType, theCreator;	OSErr theError;		if (isResource) {		theType = 'rsrc';		theCreator = 'RSED';	} else {		theType = 'PICT';		theCreator = '????';	}	theError = FSpCreate(fileSpec, theCreator, theType, smSystemScript);	if (theError != noErr) {		DebugStr("\pCreate failed");		return theError;	}	if (isResource) {		short	saveResFile = CurResFile();//		DebugStr("\pOpening resource fork");		FSpCreateResFile(fileSpec, theCreator, theType, smSystemScript);		*refnum = FSpOpenResFile(fileSpec, fsRdWrPerm);		UseResFile(saveResFile);		if (*refnum == -1) theError = ResError();		else theError = noErr;	} else {//		DebugStr("\pOpening Data fork");		theError = FSpOpenDF(fileSpec, fsRdWrPerm, refnum);	}//	if (theError) DebugStr("\pOpen failed");	return theError;}OSErr CloseOutputFile(short refnum, Boolean isResource){	OSErr theError;		if (isResource) {		CloseResFile(refnum);		theError = ResError();	} else {		theError = FSClose(refnum);	}	return theError;}OSErr WritePictData(short refnum, Handle pictHandle, short pageNum, Boolean isResource){	OSErr	writeError;	if (isResource) {		short	savedResFile = CurResFile();				UseResFile(refnum);				AddResource(pictHandle,'PICT',pageNum,(unsigned char *)"");		WriteResource(pictHandle);		ReleaseResource(pictHandle);				UseResFile(savedResFile);	} else {		Ptr		gunkbytes;		long	theCount;		gunkbytes = NewPtrClear(512);		if (!gunkbytes) {			DebugStr("\pCouldn't allocate garbage header bytes!");			return(iMemFullErr);		}		theCount = 512;		writeError = FSWrite(refnum, &theCount, gunkbytes);		if (writeError != noErr) {			DebugStr("\pError writing file. Gack!");			return(writeError);		}		DisposePtr(gunkbytes);		theCount = GetHandleSize(pictHandle);		writeError = FSWrite(refnum, &theCount, *pictHandle);		if (writeError != noErr) {			DebugStr("\pError writing file. Gack!");			return(writeError);		}				DisposeHandle(pictHandle);	}	return(writeError);}OSErr WriteCLUTData(short refnum){#pragma unused(refnum)#ifdef SUPPORT_CLUTS	if (IsColorGrafPort((GrafPtr)pPrPort)) {		Handle	clutHandle;		Handle	tableHandle = (Handle) GetPmTable((CGrafPtr)pPrPort);		long	theCount = GetHandleSize(tableHandle);		clutHandle = NewHandleClear(theCount);		if (clutHandle) {			BlockMoveData(*tableHandle, *clutHandle, theCount);			AddResource(clutHandle, 'clut', printRecord->CurPage, dummyString);			WriteResource(clutHandle);		}	}#endif	return noErr;}