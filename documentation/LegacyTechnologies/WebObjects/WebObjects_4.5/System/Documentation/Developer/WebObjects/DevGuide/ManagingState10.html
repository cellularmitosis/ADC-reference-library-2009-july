<html><head><title>Managing State</title></head><body bgcolor="#ffffff"><!--start of banner --><!--#include virtual="/includes/framesetheader" --><!-- end of banner --><!--start of path --><font face="Geneva,Helvetica,Arial" size="1"><b>PATH<spacer type="horizontal" size="5">&nbsp;</b> <a href="../../../../../../index.html" target="_top">Documentation</a> <b>&gt;</b> <a href="../../../../../webobjects.html" target="_top">WebObjects 4.5</a> <b>&gt;</b>WebObjects Developer's Guide</font><br><br><!--end of path --> <hr> <a href="StateTOC.html"><IMG SRC="ArrowUp.gif">Table of Contents</a> <a href="ManagingState9.html"><IMG SRC="ArrowLeft.gif">Previous Section</a> <a name="5288"><h1> Storing State for Custom Objects</h1></a><a name="5290">When state is stored in the server, the objects that hold state are kept intact in memory between cycles of the request-response loop. In contrast, custom state storage mechanisms may ask objects to archive themselves (using classes and methods defined in the Foundation framework) before being put into storage. The objects that are part of the WebObjects and Foundation frameworks can archive themselves, so they require no effort on your part. But if your application has custom classes that need to store state, these classes must know how to archive and unarchive themselves. How you implement archiving for custom classes depends on whether your application accesses a database. If your application accesses a database, it uses the Enterprise Objects Framework and should use the EOEditingContext class to archive objects. If your application doesn't access a database, it should use the NSArchiver class to archive custom objects.<p></a><P> <a href="StateTOC.html"><IMG SRC="ArrowUp.gif">Table of Contents</a> <a href="ManagingState11.html"><IMG SRC="ArrowRight.gif">Next Section</a><P></body></html>