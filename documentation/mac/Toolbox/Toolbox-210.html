<!-- Generated by Harlequin WebMaker 2.2.3 (23-Apr-1996)
LispWorks 3.2.2 -->
<HTML> <HEAD>
<TITLE>Resizing a Window(IM:Tb)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING210></A>


<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="Toolbox-209.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Toolbox-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Toolbox-490.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="Toolbox-211.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="Toolbox-2.html"><B>Macintosh Toolbox Essentials</B></A> / <BR><DD><A HREF="Toolbox-188.html"><B>Chapter 4 - Window Manager</B></A> / <A HREF="Toolbox-201.html"><B>Using the Window Manager</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING210-0></A>
<H2><A NAME=MARKER-9-233></A>Resizing a Window</H2>
 <A NAME=MARKER-21-649></A>The size box, in the lower-right corner of a window's content region, allows the user to change a window's size.<P>
 <A NAME=MARKER-2-143></A>When the user positions the cursor in the size box and presses the mouse button, your application can call the Window Manager's <CODE>GrowWindow</CODE> function. This function displays a<B> grow image</B>--a gray outline of the window's frame and scroll bar areas, which expands or contracts as the user drags the size box. The grow image indicates where the window edges would be if the user released the mouse button at any <BR>given moment<A NAME=MARKER-2-211></A>.<P>
 To avoid unmanageably large or small windows, you supply lower and upper size limits when you call <CODE>GrowWindow</CODE>. The <CODE>sizeRect</CODE> parameter to <CODE>GrowWindow</CODE> specifies both the lower and upper size limits in a single structure of type <CODE>Rect</CODE>. The values in the <CODE>sizeRect</CODE> structure represent window dimensions, not screen coordinates:<P>
<UL>
<LI>You supply the minimum vertical measurement in <CODE>sizeRect.top</CODE>.
<LI>You supply the minimum horizontal measurement in <CODE>sizeRect.left</CODE>.
<LI>You supply the maximum vertical measurement in <CODE>sizeRect.bottom</CODE>.
<LI>You supply the maximum horizontal measurement in <CODE>sizeRect.right</CODE>.<P>
</UL>
 Most applications specify a minimum size big enough to include all parts of the structure area and the scroll bars. Because the user cannot move the cursor beyond the edges of the screen, you can safely set the maximum size to the largest possible rectangle.<P>
 When the user releases the mouse button, <CODE>GrowWindow</CODE> returns a long integer that describes the window's new height (in the high-order word) and width (in the low-order word). A value of 0 means that the window's size did not change. When <CODE>GrowWindow</CODE> returns any value other than 0, you call <CODE>SizeWindow</CODE> to resize the window.<P>
<DL>
<DT><B>Note</B>
<DD>Use the utility functions <CODE>HiWord</CODE> and <CODE>LoWord</CODE> to retrieve the high-order and low-order words, respectively.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
 When you change a window's size, you must erase and redraw the window's scroll bars.<P>
 <A HREF=#MARKER-9-237>Listing 4-13</A> illustrates the application-defined procedure <CODE>DoGrowWindow</CODE> for tracking mouse activity in the size box and resizing the window.<P>
<B>Listing 4-13  <A NAME=MARKER-9-237></A>Resizing a window</B><P>
<PRE>
PROCEDURE DoGrowWindow (thisWindow: windowPtr;
                         event: EventRecord);
VAR
   growSize:         LongInt;
   limitRect:        Rect;
   oldViewRect:      Rect;
   locUpdateRgn:     RgnHandle;
   theResult:        Boolean;
   myData:           MyDocRecHnd;
BEGIN
   {set up the limiting rectangle: kMinDocSize = 64 }
                                 { kMaxDocSize = 65535}
   SetRect(limitRect, kMinDocSize, kMinDocSize, kMaxDocSize,
            kMaxDocSize);
   {call Window Manager to let user drag size box}
   growSize := GrowWindow(thisWindow, event.where, limitRect);
   IF growSize &lt;&gt; 0 THEN         {if user changed size, }
   BEGIN                         { then resize window}
      myData := MyDocRecHnd(GetWRefCon(thisWindow));
      oldViewRect := myData^^.editRec^^.viewRect;
      locUpdateRgn := NewRgn;
      {save update region in local coordinates}
      MyGetLocalUpdateRgn(thisWindow, locUpdateRgn);
      {resize the window}
      SizeWindow(thisWindow, LoWord(growSize), HiWord(growSize),
                  TRUE);
      MyResizeWindow(thisWindow);
      {find intersection of old viewRect and new viewRect}
      theResult := SectRect(oldViewRect, 
                              myData^^.editRec^^.viewRect,
                              oldViewRect);
      {validate the intersection (don't update)}
      ValidRect(oldViewRect);
      {invalidate any prior update region}
      InvalRgn(locUpdateRgn);
      DisposeRgn(locUpdateRgn);
   END;
END;
</PRE>
 When the user presses the mouse button while the cursor is in the size box, the procedure that handles mouse-down events (<CODE>DoMouseDown</CODE>, shown on <A HREF=Toolbox-207.html#MARKER-9-200>page 4-39</A>) calls the application-defined <CODE>DoGrowWindow</CODE> procedure. The <CODE>DoGrowWindow</CODE> procedure <BR>calls the Window Manager function <CODE>GrowWindow</CODE>, which tracks mouse movement as long as the button is held down. If the user drags the size box before releasing the mouse button, <CODE>GrowWindow</CODE> returns a nonzero value, and <CODE>DoGrowWindow</CODE> prepares to resize the window. First <CODE>DoGrowWindow</CODE> saves the current view rectangle in the variable <CODE>oldViewRect</CODE>. It will use this information later, when redrawing the content region of the window in its new size. The <CODE>GrowWindow</CODE> procedure also saves the current update region, in local coordinates, in the region <CODE>LocUpdateRgn</CODE>, so that it can restore the update region after doing its own update-region maintenance. (This step is necessary only if an application allows user input to accumulate into the update region, drawing in response to update events instead of drawing into the window immediately.)<P>
 After saving the current view rectangle and the current update region, <CODE>DoGrowWindow</CODE> calls the Window Manager procedure <CODE>SizeWindow</CODE> to draw the window in its new <BR>size. The <CODE>DoGrowWindow</CODE> procedure then calls the application-defined procedure <CODE>MyResizeWindow</CODE>, which adjusts the window scroll bars and window contents to the new size. <A HREF=#MARKER-9-239>Listing 4-14</A> illustrates the application-defined <CODE>MyResizeWindow</CODE> procedure.<A NAME=MARKER-9-69></A><P>
 After calling <CODE>SizeWindow</CODE>, <CODE>DoGrowWindow</CODE> calculates the intersection of the old view rectangle and the new view rectangle. It uses this area to revalidate unchanged portions of the window (that is, to remove them from the update region), because the <CODE>MyResizeWindow</CODE> procedure invalidates the entire window (that is, places the entire window in the update region). This way, only the changed parts of the content area are redrawn when the application receives its next update event.<P>
<B>Listing 4-14  Adjusting scroll bars and content region when resizing a window<A NAME=MARKER-9-239></A></B><P>
<PRE>
PROCEDURE MyResizeWindow (window: WindowPtr);
BEGIN
   WITH window^ DO 
   BEGIN
      {adjust scroll bars and contents-- }
      { see the chapter "Control Manager" for implementation}
      MyAdjustScrollbars(window, TRUE);
      MyAdjustTE(window);
      {invalidate content region, forcing an update}
      InvalRect(portRect);
   END;
END; {MyResizeWindow}
</PRE>
 <A HREF=#MARKER-9-241>Listing 4-15</A> illustrates the application-defined procedure <CODE>MyGetLocalUpdateRgn</CODE>, which supplies a window's update region in local coordinates. The <CODE>MyGetLocalUpdateRgn</CODE> procedure uses the QuickDraw routines <CODE>CopyRgn</CODE> and <CODE>OffsetRgn</CODE>, documented in <I>Inside Macintosh: Imaging.</I><A NAME=MARKER-2-240></A><P>
<B>Listing 4-15  <A NAME=MARKER-9-241></A>Converting a window region to local coordinates</B><P>
<PRE>
PROCEDURE MyGetLocalUpdateRgn (window: WindowPtr; 
                              localRgn: RgnHandle);
BEGIN
   {save old update region}
   CopyRgn(WindowPeek(window)^.updateRgn, localRgn);
   WITH window^.portBits.bounds DO
      OffsetRgn(localRgn, left, top);  {convert to local coords}
END; {MyGetLocalUpdateRgn}
</PRE>
</BLOCKQUOTE>
<HR>
<center>
<A HREF="Toolbox-209.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Toolbox-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Toolbox-490.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="Toolbox-211.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="Toolbox-3.html">&copy; Apple Computer, Inc.</A><br>11 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>  
