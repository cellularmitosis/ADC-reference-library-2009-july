<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>GLCarbon1ContextPbuffer - /HID Support/HID_Queue_Utilities.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/GraphicsImaging/index.html">Graphics & Imaging</a> &gt; <a href="../../samplecode/GraphicsImaging/idxOpenGL-date.html">OpenGL</a> &gt; <A HREF="javascript:location.replace('index.html');">GLCarbon1ContextPbuffer</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">GLCarbon1ContextPbuffer</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/HID Support/HID_Queue_Utilities.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/camera.h</option>
<option value="listing2.html">/drawInfo.h</option>
<option value="listing3.html">/glCheck.c</option>
<option value="listing4.html">/glCheck.h</option>
<option value="listing5.html">/HID Support/HID_Config_Utilities.c</option>
<option value="listing6.html">/HID Support/HID_Config_Utilities.h</option>
<option value="listing7.html">/HID Support/HID_Error_Handler.c</option>
<option value="listing8.html">/HID Support/HID_Error_Handler.h</option>
<option value="listing9.html">/HID Support/HID_Name_Lookup.c</option>
<option value="listing10.html">/HID Support/HID_Name_Lookup.h</option>
<option value="listing11.html">/HID Support/HID_Queue_Utilities.c</option>
<option value="listing12.html">/HID Support/HID_Queue_Utilities.h</option>
<option value="listing13.html">/HID Support/HID_Utilities.c</option>
<option value="listing14.html">/HID Support/HID_Utilities.h</option>
<option value="listing15.html">/HID Support/HID_Utilities_External.h</option>
<option value="listing16.html">/HID Support/HID_Utilities_Internal.h</option>
<option value="listing17.html">/HID Support/HIDSupport.c</option>
<option value="listing18.html">/HID Support/HIDSupport.h</option>
<option value="listing19.html">/main.c</option>
<option value="listing20.html">/main.h</option>
<option value="listing21.html">/pbuffer.c</option>
<option value="listing22.html">/pbuffer.h</option>
<option value="listing23.html">/SurfaceGeometry.c</option>
<option value="listing24.html">/SurfaceGeometry.h</option>
<option value="listing25.html">/trackball.c</option>
<option value="listing26.html">/trackball.h</option></select>
				</p>
				</form>
				<p><strong><a href="GLCarbon1ContextPbuffer.zip">Download Sample</a></strong> (&#147;GLCarbon1ContextPbuffer.zip&#148;, 220.4K)<BR>
<strong><a href="GLCarbon1ContextPbuffer.dmg">Download Sample</a></strong> (&#147;GLCarbon1ContextPbuffer.dmg&#148;, 270.0K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*
 *  HID_Queue_Utilities.c
 *  HID Explorer
 *
 *  Created by ggs on Tue May 08 2001.
 
   Copyright:  Copyright &copy; 2001 Apple Computer, Inc., All Rights Reserved

  Disclaimer:  IMPORTANT:  This Apple software is supplied to you by Apple Computer, Inc.
      (&quot;Apple&quot;) in consideration of your agreement to the following terms, and your
      use, installation, modification or redistribution of this Apple software
      constitutes acceptance of these terms.  If you do not agree with these terms,
      please do not use, install, modify or redistribute this Apple software.

      In consideration of your agreement to abide by the following terms, and subject
      to these terms, Apple grants you a personal, non-exclusive license, under Apple's
      copyrights in this original Apple software (the &quot;Apple Software&quot;), to use,
      reproduce, modify and redistribute the Apple Software, with or without
      modifications, in source and/or binary forms; provided that if you redistribute
      the Apple Software in its entirety and without modifications, you must retain
      this notice and the following text and disclaimers in all such redistributions of
      the Apple Software.  Neither the name, trademarks, service marks or logos of
      Apple Computer, Inc. may be used to endorse or promote products derived from the
      Apple Software without specific prior written permission from Apple.  Except as
      expressly stated in this notice, no other rights or licenses, express or implied,
      are granted by Apple herein, including but not limited to any patent rights that
      may be infringed by your derivative works or by other works in which the Apple
      Software may be incorporated.

      The Apple Software is provided by Apple on an &quot;AS IS&quot; basis.  APPLE MAKES NO
      WARRANTIES, EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION THE IMPLIED
      WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY AND FITNESS FOR A PARTICULAR
      PURPOSE, REGARDING THE APPLE SOFTWARE OR ITS USE AND OPERATION ALONE OR IN
      COMBINATION WITH YOUR PRODUCTS.

      IN NO EVENT SHALL APPLE BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL OR
      CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
      GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
      ARISING IN ANY WAY OUT OF THE USE, REPRODUCTION, MODIFICATION AND/OR DISTRIBUTION
      OF THE APPLE SOFTWARE, HOWEVER CAUSED AND WHETHER UNDER THEORY OF CONTRACT, TORT
      (INCLUDING NEGLIGENCE), STRICT LIABILITY OR OTHERWISE, EVEN IF APPLE HAS BEEN
      ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

#include &quot;HID_Utilities_Internal.h&quot;
#include &quot;HID_Utilities_External.h&quot;

static IOReturn HIDCreateQueue (pRecDevice pDevice);
static unsigned char HIDIsDeviceQueueEmpty (pRecDevice pDevice);
static IOReturn HIDDisposeReleaseQueue (pRecDevice pDevice);

// ==================================
// private functions

// creates a queue for a device, creates and opens device interface if required

static IOReturn HIDCreateQueue (pRecDevice pDevice)
{
    IOReturn result = kIOReturnSuccess;
  if (NULL == pDevice-&gt;queue) // do we already have a queue
  {  
    if (NULL != pDevice-&gt;interface) 
    {
      pDevice-&gt;queue =(void *) (*(IOHIDDeviceInterface **) pDevice-&gt;interface)-&gt;allocQueue (pDevice-&gt;interface); // alloc queue
      if (pDevice-&gt;queue)
      {
        result = (*(IOHIDQueueInterface **) pDevice-&gt;queue)-&gt;create (pDevice-&gt;queue, 0, kDeviceQueueSize); // create actual queue
        if (kIOReturnSuccess != result)
          HIDReportErrorNum (&quot;Failed to create queue via create&quot;, result);
      }
      else
      {
        HIDReportError (&quot;Failed to alloc IOHIDQueueInterface ** via allocQueue&quot;);
        result = kIOReturnError; // synthesis error
      }
    }
    else
      HIDReportErrorNum (&quot;Device inteface does not exist for queue creation&quot;, result);
  }
    return result;
}

// ---------------------------------

// returns true if queue is empty false otherwise
// error if no device, empty if no queue

static unsigned char HIDIsDeviceQueueEmpty (pRecDevice pDevice)
{
    if (pDevice &amp;&amp; pDevice-&gt;queue) // need device and queue
    {
        pRecElement pElement = HIDGetFirstDeviceElement (pDevice, kHIDElementTypeIO);
        while (pElement)
        {
            if ((*(IOHIDQueueInterface **) pDevice-&gt;queue)-&gt;hasElement (pDevice-&gt;queue, pElement-&gt;cookie))
                return false;
            pElement = HIDGetNextDeviceElement (pElement, kHIDElementTypeIO);
        } 
    }
    else if (NULL == pDevice) // if no device (if just no queue then queue must be empty)
        HIDReportError (&quot;NULL device passed to DeviceQueueEmpty.&quot;);
    return true;   
}

// ---------------------------------

// disposes and releases queue, sets queue to NULL,.
// Note: will have no effect if device or queue do not exist

static IOReturn HIDDisposeReleaseQueue (pRecDevice pDevice)
{
    IOReturn result = kIOReturnSuccess;

    if ((NULL != pDevice) &amp;&amp; (NULL != pDevice-&gt;queue))
  {
    // stop queue
    result = (*(IOHIDQueueInterface **) pDevice-&gt;queue)-&gt;stop (pDevice-&gt;queue);
    if (kIOReturnSuccess != result)
      HIDReportErrorNum (&quot;Failed to stop queue.&quot;, result);
    // dispose of queue
    result = (*(IOHIDQueueInterface **) pDevice-&gt;queue)-&gt;dispose (pDevice-&gt;queue);
    if (kIOReturnSuccess != result)
      HIDReportErrorNum (&quot;Failed to dipose queue.&quot;, result);
    // release the queue
    result = (*(IOHIDQueueInterface **) pDevice-&gt;queue)-&gt;Release (pDevice-&gt;queue);
    if (kIOReturnSuccess != result)
      HIDReportErrorNum (&quot;Failed to release queue.&quot;, result);
      
    pDevice-&gt;queue = NULL;
  }
    return result;
}

// ==================================
// public functions

// Create and open an interface to device, required prior to extracting values or building queues
// Note: appliction now owns the device and must close and release it prior to exiting

IOReturn HIDCreateOpenDeviceInterface (io_object_t hidDevice, pRecDevice pDevice)
{
    IOReturn result = kIOReturnSuccess;
    HRESULT plugInResult = S_OK;
    SInt32 score = 0;
    IOCFPlugInInterface ** ppPlugInInterface = NULL;
  
  if (NULL == pDevice-&gt;interface)
  {
    result = IOCreatePlugInInterfaceForService (hidDevice, kIOHIDDeviceUserClientTypeID,
                          kIOCFPlugInInterfaceID, &amp;ppPlugInInterface, &amp;score);
    if (kIOReturnSuccess == result)
    {
      // Call a method of the intermediate plug-in to create the device interface
      plugInResult = (*ppPlugInInterface)-&gt;QueryInterface (ppPlugInInterface, 
                CFUUIDGetUUIDBytes (kIOHIDDeviceInterfaceID), (void *) &amp;(pDevice-&gt;interface));
      if (S_OK != plugInResult)
        HIDReportErrorNum (&quot;Couldn't query HID class device interface from plugInInterface&quot;, plugInResult);
      IODestroyPlugInInterface (ppPlugInInterface); // replace (*ppPlugInInterface)-&gt;Release (ppPlugInInterface)
    }
    else
      HIDReportErrorNum (&quot;Failed to create **plugInInterface via IOCreatePlugInInterfaceForService.&quot;, result);
  }
  if (NULL != pDevice-&gt;interface)
  {
    result = (*(IOHIDDeviceInterface **)pDevice-&gt;interface)-&gt;open (pDevice-&gt;interface, 0);
    if (kIOReturnSuccess != result)
      HIDReportErrorNum (&quot;Failed to open pDevice-&gt;interface via open.&quot;, result);
  }
    return result;
}

// ---------------------------------

// queues specific element, performing any device queue set up required
// queue is started and ready to return events on exit from this function

unsigned long  HIDQueueElement (pRecDevice pDevice, pRecElement pElement)
{
    IOReturn result = kIOReturnSuccess;

  // error checking
    if ((NULL == pDevice) || (NULL == pElement))
  {
    HIDReportError (&quot;Device or element does not exist, cannot queue element.&quot;);
        return kIOReturnBadArgument;
  }
    if (NULL == pDevice-&gt;interface) // must have interface
  {
        HIDReportError (&quot;Device does not have interface, cannot queue element.&quot;);
    return kIOReturnError;
  }
    if (NULL == pDevice-&gt;queue) // if no queue create queue
        result = HIDCreateQueue (pDevice);
    if ((kIOReturnSuccess != result) || (NULL == pDevice-&gt;queue))
  {
        HIDReportErrorNum (&quot;Could not queue element due to problem creating queue.&quot;, result);
    if (kIOReturnSuccess != result)
      return result;
    else
      return kIOReturnError;
  }

    // stop queue
    result = (*(IOHIDQueueInterface **) pDevice-&gt;queue)-&gt;stop (pDevice-&gt;queue);
    if (kIOReturnSuccess != result)
        HIDReportError (&quot;Failed to stop queue.&quot;);

    // queue element
    if (!(*(IOHIDQueueInterface **) pDevice-&gt;queue)-&gt;hasElement (pDevice-&gt;queue, pElement-&gt;cookie))
    {
        result = (*(IOHIDQueueInterface **) pDevice-&gt;queue)-&gt;addElement (pDevice-&gt;queue, pElement-&gt;cookie, 0);
        if (kIOReturnSuccess != result)
            HIDReportError (&quot;Failed to add element to queue via addElement.&quot;);
    }

    // restart queue
    result = (*(IOHIDQueueInterface **) pDevice-&gt;queue)-&gt;start (pDevice-&gt;queue);
    if (kIOReturnSuccess != result)
        HIDReportError (&quot;Failed to start queue.&quot;);

   return result;
}

// ---------------------------------

// adds all elements to queue, performing any device queue set up required
// queue is started and ready to return events on exit from this function

unsigned long  HIDQueueDevice (pRecDevice pDevice)
{
    IOReturn result = kIOReturnSuccess;
    pRecElement pElement;
    
  // error checking
    if (NULL == pDevice)
  {
    HIDReportError (&quot;Device does not exist, cannot queue device.&quot;);
        return kIOReturnBadArgument;
  }
    if (NULL == pDevice-&gt;interface) // must have interface
  {
        HIDReportError (&quot;Device does not have interface, cannot queue device.&quot;);
    return kIOReturnError;
  }
    if (NULL == pDevice-&gt;queue) // if no queue create queue
        result = HIDCreateQueue (pDevice);
    if ((kIOReturnSuccess != result) || (NULL == pDevice-&gt;queue))
  {
        HIDReportErrorNum (&quot;Could not queue device due to problem creating queue.&quot;, result);
    if (kIOReturnSuccess != result)
      return result;
    else
      return kIOReturnError;
  }

  // stop queue
  result = (*(IOHIDQueueInterface **) pDevice-&gt;queue)-&gt;stop (pDevice-&gt;queue);
  if (kIOReturnSuccess != result)
    HIDReportErrorNum (&quot;Failed to stop queue.&quot;, result);

  // queue element
  pElement = HIDGetFirstDeviceElement (pDevice, kHIDElementTypeIO);
  while (pElement)
  {
    if (!(*(IOHIDQueueInterface **) pDevice-&gt;queue)-&gt;hasElement (pDevice-&gt;queue, pElement-&gt;cookie))
    {
      result = (*(IOHIDQueueInterface **) pDevice-&gt;queue)-&gt;addElement (pDevice-&gt;queue, pElement-&gt;cookie, 0);
      if (kIOReturnSuccess != result)
        HIDReportErrorNum (&quot;Failed to add element to queue via addElement&quot;, result);
    }
    pElement = HIDGetNextDeviceElement (pElement, kHIDElementTypeIO);
  }    

  // start queue
  result = (*(IOHIDQueueInterface **) pDevice-&gt;queue)-&gt;start (pDevice-&gt;queue);
  if (kIOReturnSuccess != result)
    HIDReportErrorNum (&quot;Failed to start queue.&quot;, result);

    return result;
}

// ---------------------------------

// removes element for queue, if last element in queue will release queue and closes device interface

unsigned long  HIDDequeueElement (pRecDevice pDevice, pRecElement pElement)
{
    IOReturn result = kIOReturnSuccess;
    if (!pDevice || !pElement)
        result = kIOReturnBadArgument;
  else
  {
    if ((pDevice-&gt;interface) &amp;&amp; (pDevice-&gt;queue))
    {
      // stop queue
      result = (*(IOHIDQueueInterface **) pDevice-&gt;queue)-&gt;stop (pDevice-&gt;queue);
      if (kIOReturnSuccess != result)
        HIDReportErrorNum (&quot;Failed to stop queue.&quot;, result);
    
      if ((*(IOHIDQueueInterface **) pDevice-&gt;queue)-&gt;hasElement (pDevice-&gt;queue, pElement-&gt;cookie)) // if has element then remove
      {
        result = (*(IOHIDQueueInterface **) pDevice-&gt;queue)-&gt;removeElement (pDevice-&gt;queue, pElement-&gt;cookie);
        if (kIOReturnSuccess != result)
          HIDReportErrorNum (&quot;Failed to add element to queue via addElement&quot;, result);
      }
      
      if (HIDIsDeviceQueueEmpty (pDevice)) // release device queue and close interface if queue empty
      {
        result = HIDDisposeReleaseQueue (pDevice);
        if (kIOReturnSuccess != result)
          HIDReportErrorNum (&quot;Failed to dispose and release queue.&quot;, result);
      }
      else // not empty so restart queue
      {
        result = (*(IOHIDQueueInterface **) pDevice-&gt;queue)-&gt;start (pDevice-&gt;queue);
        if (kIOReturnSuccess != result)
          HIDReportErrorNum (&quot;Failed to start queue.&quot;, result);
      }
    }
    else
    {
      HIDReportError (&quot;No device inteface or queue.&quot;);
      return kIOReturnError;
    }
  }
    return result;
}

// ---------------------------------

// completely removes all elements from queue and releases queue and closes device interface
// does not release device interfaces, application must call ReleaseHIDDeviceList on exit

unsigned long  HIDDequeueDevice (pRecDevice pDevice)
{
    IOReturn result = kIOReturnSuccess;
    if (!pDevice)
        result = kIOReturnBadArgument;
  else
  {
    if ((pDevice-&gt;interface) &amp;&amp; (pDevice-&gt;queue))
    {
      // iterate through elements and if queued, remove
      pRecElement pElement = HIDGetFirstDeviceElement (pDevice, kHIDElementTypeIO);
      while (pElement)
      {
        if ((*(IOHIDQueueInterface **) pDevice-&gt;queue)-&gt;hasElement (pDevice-&gt;queue, pElement-&gt;cookie))
        {
          result = (*(IOHIDQueueInterface **) pDevice-&gt;queue)-&gt;removeElement (pDevice-&gt;queue, pElement-&gt;cookie);
          if (kIOReturnSuccess != result)
            HIDReportErrorNum (&quot;Failed to add element to queue via addElement&quot;, result);
        }
        pElement = HIDGetNextDeviceElement (pElement, kHIDElementTypeIO);
      }    
    }
    // ensure queue is disposed and released
    // interface will be closed and released on call to ReleaseHIDDeviceList
    result = HIDDisposeReleaseQueue (pDevice);
    if (kIOReturnSuccess != result)
      HIDReportErrorNum (&quot;Failed to dispose and release queue.&quot;, result);
  }
    return result;
}

// ---------------------------------

// releases all device queues for quit or rebuild (must be called)
// does not release device interfaces, application must call ReleaseHIDDeviceList on exit

IOReturn HIDReleaseAllDeviceQueues (void)
{
    IOReturn result = kIOReturnSuccess;
    pRecDevice pDevice = HIDGetFirstDevice ();
    while (pDevice)
    {
        result = HIDDequeueDevice (pDevice);
        if (kIOReturnSuccess != result)
            HIDReportErrorNum (&quot;Could not dequeue device.&quot;, result);
        pDevice = HIDGetNextDevice (pDevice);
    }
    return result;
}

// ---------------------------------

// Closes and releases interface to device, should be done prior to exting application
// Note: will have no affect if device or interface do not exist
// application will &quot;own&quot; the device if interface is not closed
// (device may have to be plug and re-plugged in different location to get it working again without a restart)

IOReturn HIDCloseReleaseInterface (pRecDevice pDevice)
{
  IOReturn result = kIOReturnSuccess;
  
  if ((NULL != pDevice) &amp;&amp; (NULL != pDevice-&gt;interface))
  {
    // close the interface
    result = (*(IOHIDDeviceInterface **) pDevice-&gt;interface)-&gt;close (pDevice-&gt;interface);
    if (kIOReturnNotOpen == result)
    {
      //  do nothing as device was not opened, thus can't be closed
    }
    else if (kIOReturnSuccess != result)
      HIDReportErrorNum (&quot;Failed to close IOHIDDeviceInterface.&quot;, result);
    //release the interface
    result = (*(IOHIDDeviceInterface **) pDevice-&gt;interface)-&gt;Release (pDevice-&gt;interface);
    if (kIOReturnSuccess != result)
      HIDReportErrorNum (&quot;Failed to release IOHIDDeviceInterface.&quot;, result);
    pDevice-&gt;interface = NULL;
  }  
  return result;
}      

// ---------------------------------

// Get the next event in the queue for a device
// elements or entire device should be queued prior to calling this with HIDQueueElement or HIDQueueDevice
// returns true if an event is avialable for the element and fills out *pHIDEvent structure, returns false otherwise
// Note: kIOReturnUnderrun returned from getNextEvent indicates an empty queue not an error condition
// Note: application should pass in a pointer to a IOHIDEventStruct cast to a void (for CFM compatibility)

unsigned char HIDGetEvent (pRecDevice pDevice, void * pHIDEvent)
{
    IOReturn result = kIOReturnSuccess;
    AbsoluteTime zeroTime = {0,0};
    if (pDevice)
  {
    if (pDevice-&gt;queue)
    {
      result = (*(IOHIDQueueInterface **) pDevice-&gt;queue)-&gt;getNextEvent (pDevice-&gt;queue, (IOHIDEventStruct *)pHIDEvent, zeroTime, 0);
      if (kIOReturnUnderrun == result)
        return false;  // no events in queue not an error per say
      else if (kIOReturnSuccess != result) // actual error versus just an empty queue
        HIDReportErrorNum (&quot;Could not get HID event via getNextEvent.&quot;, result);
      else
        return true;
    }
    else
      HIDReportError (&quot;Could not get HID event, queue does not exist.&quot;);
  }
  else
    HIDReportError (&quot;Could not get HID event, device does not exist.&quot;);
    return false; // did not get event
}

// ---------------------------------

// returns current value for element, polling element
// will return 0 on error conditions which should be accounted for by application

long HIDGetElementValue (pRecDevice pDevice, pRecElement pElement)
{
    IOReturn result = kIOReturnSuccess;
    IOHIDEventStruct hidEvent;
    hidEvent.value = 0;
    
    if (NULL != pDevice)
    {
        if (NULL != pElement)
        {
       if (NULL != pDevice-&gt;interface)
            {
                result = (*(IOHIDDeviceInterface **) pDevice-&gt;interface)-&gt;getElementValue (pDevice-&gt;interface, pElement-&gt;cookie, &amp;hidEvent);
                if (kIOReturnSuccess != result)
                        HIDReportErrorNum (&quot;Could not get HID element value via getElementValue.&quot;, result);
        // on 10.0.x this returns the incorrect result for negative ranges, so fix it!!!
        // this is not required on Mac OS X 10.1+
        if ((pElement-&gt;min &lt; 0) &amp;&amp; (hidEvent.value &gt; pElement-&gt;max)) // assume range problem
          hidEvent.value = hidEvent.value + pElement-&gt;min - pElement-&gt;max - 1;
      }
            else
                HIDReportError (&quot;Did not have interface for device prior to getting element value.&quot;);
        }
        else
            HIDReportError (&quot;Bad element passed to GetElementValue.&quot;);
    }
    else
        HIDReportError (&quot;Bad device passed to GetElementValue.&quot;);
    // record min and max for auto scale and auto ...
    if (hidEvent.value &lt; pElement-&gt;minReport)
        pElement-&gt;minReport = hidEvent.value; 
    if (hidEvent.value &gt; pElement-&gt;maxReport)
        pElement-&gt;maxReport = hidEvent.value; 

    return hidEvent.value;
}
</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/GLCarbon1ContextPbuffer/listing11.html%3Fid%3DDTS10003144-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/GLCarbon1ContextPbuffer/listing11.html%3Fid%3DDTS10003144-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/GLCarbon1ContextPbuffer/listing11.html%3Fid%3DDTS10003144-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>