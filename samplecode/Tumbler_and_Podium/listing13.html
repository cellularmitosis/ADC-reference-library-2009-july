<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>Tumbler and Podium - /TumblerSource/Tumbler_event.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxGraphicsImaging-date.html">Graphics & Imaging</a> &gt; <A HREF="javascript:location.replace('index.html');">Tumbler and Podium</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/GraphicsImaging/index.html" target="_blank">Reference Library > Graphics & Imaging</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">Tumbler and Podium</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/TumblerSource/Tumbler_event.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/TumblerSource/Tumbler_AEVT.c</option>
<option value="listing2.html">/TumblerSource/Tumbler_AEVT.h</option>
<option value="listing3.html">/TumblerSource/Tumbler_camera.c</option>
<option value="listing4.html">/TumblerSource/Tumbler_camera.h</option>
<option value="listing5.html">/TumblerSource/Tumbler_cursor.c</option>
<option value="listing6.html">/TumblerSource/Tumbler_cursor.h</option>
<option value="listing7.html">/TumblerSource/Tumbler_document.c</option>
<option value="listing8.html">/TumblerSource/Tumbler_document.h</option>
<option value="listing9.html">/TumblerSource/Tumbler_drag.c</option>
<option value="listing10.html">/TumblerSource/Tumbler_drag.h</option>
<option value="listing11.html">/TumblerSource/Tumbler_ErrorHandler.c</option>
<option value="listing12.html">/TumblerSource/Tumbler_ErrorHandler.h</option>
<option value="listing13.html">/TumblerSource/Tumbler_event.c</option>
<option value="listing14.html">/TumblerSource/Tumbler_event.h</option>
<option value="listing15.html">/TumblerSource/Tumbler_file.c</option>
<option value="listing16.html">/TumblerSource/Tumbler_file.h</option>
<option value="listing17.html">/TumblerSource/Tumbler_globals.h</option>
<option value="listing18.html">/TumblerSource/Tumbler_HideMenuBar.c</option>
<option value="listing19.html">/TumblerSource/Tumbler_HideMenuBar.h</option>
<option value="listing20.html">/TumblerSource/Tumbler_initialize.c</option>
<option value="listing21.html">/TumblerSource/Tumbler_initialize.h</option>
<option value="listing22.html">/TumblerSource/Tumbler_main.c</option>
<option value="listing23.html">/TumblerSource/Tumbler_main.h</option>
<option value="listing24.html">/TumblerSource/Tumbler_menus.c</option>
<option value="listing25.html">/TumblerSource/Tumbler_menus.h</option>
<option value="listing26.html">/TumblerSource/Tumbler_offscreen.c</option>
<option value="listing27.html">/TumblerSource/Tumbler_offscreen.h</option>
<option value="listing28.html">/TumblerSource/Tumbler_PICTImport.c</option>
<option value="listing29.html">/TumblerSource/Tumbler_PICTImport.h</option>
<option value="listing30.html">/TumblerSource/Tumbler_podium.c</option>
<option value="listing31.html">/TumblerSource/Tumbler_podium.h</option>
<option value="listing32.html">/TumblerSource/Tumbler_prototypes.h</option>
<option value="listing33.html">/TumblerSource/Tumbler_resources.h</option>
<option value="listing34.html">/TumblerSource/Tumbler_teutilities.c</option>
<option value="listing35.html">/TumblerSource/Tumbler_teutilities.h</option>
<option value="listing36.html">/TumblerSource/Tumbler_traps.c</option>
<option value="listing37.html">/TumblerSource/Tumbler_traps.h</option>
<option value="listing38.html">/TumblerSource/Tumbler_utility.c</option>
<option value="listing39.html">/TumblerSource/Tumbler_utility.h</option>
<option value="listing40.html">/TumblerSource/Tumbler_windows.c</option>
<option value="listing41.html">/TumblerSource/Tumbler_windows.h</option></select>
				</p>
				</form>
				<p><strong><a href="Tumbler_and_Podium.zip">Download Sample</a></strong> (&#147;Tumbler_and_Podium.zip&#148;, 1.07M)<BR>
<strong><a href="Tumbler_and_Podium.dmg">Download Sample</a></strong> (&#147;Tumbler_and_Podium.dmg&#148;, 1.15M)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">//    Tumbler)event.c////    Event handling routines.////    Author:    Nick Thompson &amp; Pablo Fernicola, with thanks to the QuickDraw 3D team//    Date:    Monday, Janurary 20, 1992////    Copyright &copy; 1992-95 Apple Computer, Inc., All Rights Reserved////  Modification History://    12/2/94    nick    ////  Debugging Aids :////  Turn this flag on to see where the current hilite region is.////    #define  _FLASH_HILITE_RGN_////#include &lt;Drag.h&gt;#include &quot;QD3D.h&quot;#include &quot;Tumbler_globals.h&quot;#include &quot;Tumbler_prototypes.h&quot;#include &quot;Tumbler_resources.h&quot;#include &quot;AppleEvents.h&quot;#include &quot;Events.h&quot;#include &quot;QD3DView.h&quot;#include &quot;QD3DDrawContext.h&quot;#include &quot;QD3DDrawContext.h&quot;#include &quot;QD3DPick.h&quot;#include &quot;QD3DTransform.h&quot;#include &quot;QD3DLight.h&quot;#include &quot;QD3DMath.h&quot;#include &quot;QD3DGeometry.h&quot;#define  SleepDuration    20    /* WaitNextEvent sleep constant    */#include &quot;Tumbler_event.h&quot;#include &quot;Tumbler_camera.h&quot;#include &quot;Tumbler_drag.h&quot;#include &quot;Tumbler_offscreen.h&quot;#include &quot;Tumbler_windows.h&quot;#include &quot;Tumbler_menus.h&quot;#include &quot;Tumbler_drag.h&quot;#include &quot;Tumbler_document.h&quot;#include &quot;Tumbler_cursor.h&quot;#ifdef PODIUM_APP  #include &quot;Tumbler_Podium.h&quot;#endifstatic void DoContentClick(WindowPtr theWindow, EventRecord *theEvent);static void DoBackgroundContentClick(WindowPtr theWindow, EventRecord *theEvent) ;static void DoMouseDown(EventRecord *theEvent);static void DoKey(char theChar);static void DoKeyDown(EventRecord *theEvent);static void DoActivate(EventRecord *theEvent);static void DoUpdate(EventRecord *theEvent);static void DoOSEvent(EventRecord *theEvent);static void DoHighLevelEvent(EventRecord *theEvent);static void DoEvent(EventRecord *theEvent);static void DoIdleHitTest(void);static void DoIdle(void);//-------------------------------------------------------------------------------------//  DoContentClick handles mouseDown events in the content region of a document window.////  (1)  If the mouseDown is on a draggable object (the document's hiliteRgn) and a//    successful drag occurs, no further processing is necessary.////  (2)  If the mouseDown is not on a draggable object and within the viewRect of the//    TextEdit field, call TEClick to handle the mouseDown.static void DoContentClick( WindowPtr theWindow, EventRecord *theEvent){  short      thePart;  Point      thePoint;  ControlHandle  theControl;  DocumentPtr    theDocument = GetDocumentFromWindow(theWindow);  GrafPtr      savedPort ;  if( theWindow == nil )    return ;  GetPort( &amp;savedPort) ;  SetPort( theWindow ) ;    thePoint = theEvent-&gt;where;  GlobalToLocal(&amp;thePoint);  if( theDocument-&gt;documentGroup ) {          // we can only do a drag if the option key is held down      if (theEvent-&gt;modifiers &amp; optionKey) {      RgnHandle  tempRgn = NewRgn();  // Nick this needs to be the BBox of the group            RectRgn(tempRgn, &amp;theWindow-&gt;portRect);      DoDragObjects(theDocument, theEvent, tempRgn ) ;            DisposeRgn(tempRgn);    } else {      Point   oldMouse;      Point   newMouse;      long   mouseChanged = 0;      long  dx, dy, x, y, oldX, oldY;      float  width, height;      float  xRot, yRot;                GetMouse(&amp;newMouse);    // get the mouse in local co-ordinates,                       // local to the  current GrafPort        oldX = newMouse.h;      oldY = newMouse.v;            width = theWindow-&gt;portRect.left - theWindow-&gt;portRect.right;      height = theWindow-&gt;portRect.bottom - theWindow-&gt;portRect.top;      while (WaitMouseUp()) {              GetMouse(&amp;newMouse);    // get the mouse in local co-ordinates,                       // local to the  current GrafPort        dx = oldY - newMouse.v;        dy = newMouse.h - oldX;                if ((dx != 0) || (dy != 0)) {          TQ3Matrix4x4    tempMatrix;                    xRot = ((float) dx * kQ3Pi) / width;          yRot = ((float) dy * kQ3Pi) / height;              if ((xRot != 0.0) || (yRot != 0.0)) {            Q3Matrix4x4_SetRotate_XYZ(&amp;tempMatrix, xRot, yRot, 0.0);            Q3Matrix4x4_Multiply(&amp;theDocument-&gt;modelRotation, &amp;tempMatrix, &amp;theDocument-&gt;modelRotation);            mouseChanged = 1;            DrawOffscreen(theDocument);          }        }        oldX = newMouse.h; oldY = newMouse.v;      }            if( mouseChanged ) {        theDocument-&gt;rotationDir.x = xRot;        theDocument-&gt;rotationDir.y = yRot;        DrawOffscreen(theDocument);                DoDrawGrowIcon(theDocument-&gt;theWindow);      }    }  }  SetPort( savedPort ) ;}////  DoBackgroundContentClick handles mouseDown events in the content region of a document window//  when the window is not frontmost. The following bullet items describe how this background//  mouseDown event is handled:////  (1)  If the mouseDown is not in a draggable object (not in the document's hiliteRgn) call//    SelectWindow to bring the window to the front as usual.////  (2)  If the mouseDown is in a draggable object and the mouse is released without//    dragging, call SelectWindow when the mouse is released.////  (3)  If the mouseDown is in a draggable object and a successful drag occurs, SelectWindow//    should only be called if the drop occurred in the same window (the DoDragObjects function//    calls SelectWindow in this case).//static void DoBackgroundContentClick(WindowPtr theWindow, EventRecord *theEvent){  short      thePart;  Point      thePoint;  ControlHandle  theControl;  DocumentPtr    theDocument ;  RgnHandle    tempRgn = NewRgn(); // Nick will fix later, needs to be the bbox of the group    if( theWindow == nil )    return ;  SetPort( theWindow );  theDocument = GetDocumentFromWindow(theWindow);  thePoint = theEvent-&gt;where;  GlobalToLocal(&amp;thePoint);  RectRgn(tempRgn, &amp;theWindow-&gt;portRect);    if (PtInRgn(thePoint, tempRgn)) {    if (! DoDragObjects(theDocument, theEvent, tempRgn)) {      SelectWindow(theDocument-&gt;theWindow);    }  } else {    SelectWindow(theDocument-&gt;theWindow);  }  DisposeRgn( tempRgn );}////  DoMouseDown is called to handle mouseDown events.//static void DoMouseDown(EventRecord *theEvent){  short    thePart;  WindowPtr  theWindow;  Rect    dragRect;  DocumentPtr theDocument;    thePart = FindWindow(theEvent-&gt;where, &amp;theWindow);  switch(thePart) {      case inMenuBar:      PrepareMenus();      DoMenuCommand(MenuSelect(theEvent-&gt;where));      break;          case inSysWindow:      SystemClick(theEvent, theWindow);      break;    case inContent:          if (theWindow == FrontWindow()) {#ifndef PODIUM_APP        DoContentClick(theWindow, theEvent);#else        Podium_DoContent( GetDocumentFromWindow(theWindow), theEvent ) ;#endif      } else {#ifndef PODIUM_APP        DoBackgroundContentClick(theWindow, theEvent);#else        Podium_DoBackgroundContent( GetDocumentFromWindow(theWindow), theEvent ) ;#endif      }      break;          case inDrag:      if (theWindow != FrontWindow())        SelectWindow(theWindow);      dragRect = qd.screenBits.bounds;      DragWindow(theWindow, theEvent-&gt;where, &amp;dragRect);      break;          case inGrow:            if ((theDocument = GetDocumentFromWindow(theWindow)) != nil) {        GrowDocumentWindow(theWindow, theEvent-&gt;where);      }      break;          case inGoAway:      if ((theDocument = GetDocumentFromWindow(theWindow)) != nil)        if (TrackGoAway(theWindow, theEvent-&gt;where)) {          (void)CloseDocument(theDocument);    // it's not important what the result is here        }      break;  }}////  DoKey is called each time a character is typed on the keyboard to//  be entered into a document window.//static void DoKey(char theChar){  WindowPtr    theWindow;  DocumentPtr theDocument;  if ((theWindow = FrontWindow()) != nil) {    if ((theDocument = GetDocumentFromWindow(theWindow)) != nil) {      // what d'ya want to do here?    }  }}////  DoKeyDown is called to handle keyDown or autoKey events.//static void DoKeyDown(EventRecord *theEvent){  char    theChar;  theChar = theEvent-&gt;message &amp; charCodeMask;  if (theEvent-&gt;modifiers &amp; cmdKey) {    PrepareMenus();    DoMenuCommand(MenuKey(theChar));  }}////  DoActivate is called in response to activate/deactivate events.//static void DoActivate(EventRecord *theEvent){  WindowPtr    theWindow;  DocumentPtr theDocument;  if ((theWindow = (WindowPtr) theEvent-&gt;message) != nil) {    if ((theDocument = GetDocumentFromWindow(theWindow)) != nil) {      DoActivateDocument(theDocument, (theEvent-&gt;modifiers &amp; activeFlag));    }  }}////  DoUpdate is called in response to update events.//static void DoUpdate(EventRecord *theEvent){  DocumentPtr theDocument;  if ( ((WindowPtr) theEvent-&gt;message) != nil)    UpdateWindow((WindowPtr) theEvent-&gt;message);}////  DoOSEvent is called in response to Operating System events.//static void DoOSEvent(EventRecord *theEvent){  DocumentPtr theDocument;  switch ((theEvent-&gt;message &gt;&gt; 24) &amp; 0x0FF) {    case suspendResumeMessage:      gInBackground = (theEvent-&gt;message &amp; resumeFlag) == 0;      if ((theDocument = GetDocumentFromWindow(FrontWindow())) != nil)        DoActivateDocument(theDocument, !gInBackground);      break;  }}static void DoHighLevelEvent(EventRecord *theEvent){  AEProcessAppleEvent(theEvent);}////  Each time WaitNextEvent returns an event to this application, DoEvent//  is called to handle the event.//static void DoEvent(EventRecord *theEvent){  WindowPtr    theWindow;  DocumentPtr theDocument;  if ((theWindow = FrontWindow()) != nil) {    if ((theDocument = GetDocumentFromWindow(theWindow)) != nil) {      gFrontDocument = theDocument;    }  }  switch(theEvent-&gt;what) {    case mouseDown:      DoMouseDown(theEvent);      break;    case mouseUp:      break;    case keyDown:    case autoKey:      DoKeyDown(theEvent);      break;    case activateEvt:      DoActivate(theEvent);      break;    case updateEvt:      DoUpdate(theEvent);      break;    case osEvt:      DoOSEvent(theEvent);      break;    case kHighLevelEvent:      DoHighLevelEvent(theEvent);      break;  }}////  DoIdle get called repetitively while the application is not doing//  anything.//static void DoIdleHitTest(void){  WindowPtr    theWindow;  DocumentPtr theDocument;  if ((theWindow = FrontWindow()) != nil) {    if ((theDocument = GetDocumentFromWindow(theWindow)) != nil) {      SetPort(theDocument-&gt;theWindow);      if( theDocument-&gt;documentGroup ) {        Point    screenPoint;        TQ3WindowPointPickData  withData;        unsigned long    numPicked;        TQ3PickObject    pickObject;                withData.data.sort       =  kQ3PickSortNone;        withData.data.numHitsToReturn=  1;        withData.data.mask       =  kQ3PickDetailMaskObject;                                GetMouse( &amp;screenPoint );        withData.point.x = screenPoint.h;        withData.point.y = screenPoint.v;              withData.vertexTolerance = withData.edgeTolerance = 3;// gone and sadly missed in b1c1, delete this line at b2c1!!//        withData.view = theDocument-&gt;theView;              pickObject = Q3WindowPointPick_New(&amp;withData);            Q3View_StartPicking(theDocument-&gt;theView, pickObject);        do {          Q3DisplayGroup_Submit(theDocument-&gt;documentGroup, theDocument-&gt;theView);        } while (Q3View_EndPicking(theDocument-&gt;theView) == kQ3ViewStatusRetraverse);                if (Q3Pick_GetNumHits(pickObject, &amp;numPicked) &amp;&amp; (numPicked != 0)) {          SetCursor(*GetCursor(plusCursor));        } else {          SetCursor(&amp;qd.arrow);        }                Q3Object_Dispose(pickObject);      }#ifdef _FLASH_HILITE_RGN_      {  long      dTime;        InvertRgn(theDocument-&gt;hiliteRgn);        Delay(10, &amp;dTime);        InvertRgn(theDocument-&gt;hiliteRgn);      }#endif    }  }}////  DoIdle get called repetitively while the application is not doing//  anything.//static void DoIdle(void){  WindowPtr    theWindow;  DocumentPtr theDocument;  if ((theWindow = FrontWindow()) != nil) {    if ((theDocument = GetDocumentFromWindow(theWindow)) != nil) {      Boolean  update = false;            SetPort(theDocument-&gt;theWindow);      if( theDocument-&gt;documentGroup &amp;&amp; theDocument-&gt;animateLights &amp;&amp; theDocument-&gt;light) {#if defined(ESCHER_VER_15) &amp;&amp; ESCHER_VER_15        float angle;        TQ3GroupPosition    lightPosition, position;        TQ3LightObject    theLight;        TQ3GroupObject    lightGroup;        TQ3Matrix4x4      matrix;        TQ3Point3D      location;        TQ3Object      ellipsoid;        TQ3Point3D      origin;                theDocument-&gt;light = kQ3True;                Q3View_GetLightGroup(theDocument-&gt;theView, &amp;lightGroup);        Q3Group_GetFirstPosition(lightGroup, &amp;lightPosition);                    /* First one is always on, skip */        Q3Group_GetNextPosition(lightGroup, &amp;lightPosition);        /* Adjust the transform for the Red sphere */        Q3RotateTransform_GetAngle(theDocument-&gt;lightXform1, &amp;angle);        angle += 0.8;        Q3RotateTransform_SetAngle(theDocument-&gt;lightXform1, angle);        Q3Transform_GetMatrix(theDocument-&gt;lightXform1, &amp;matrix);                /* Get the Red light */        Q3Group_GetPositionObject(lightGroup, lightPosition, &amp;theLight);        /* Get the Red sphere */        Q3Group_GetFirstPositionOfType(theDocument-&gt;light1,          kQ3ShapeTypeGeometry, &amp;position);              Q3Group_GetPositionObject(theDocument-&gt;light1, position, &amp;ellipsoid);        Q3Ellipsoid_GetOrigin( ellipsoid, &amp;origin);        Q3Point3D_Transform(&amp;origin, &amp;matrix, &amp;location);        Q3PointLight_SetLocation(theLight, &amp;location);        Q3Object_Dispose(theLight);                    Q3Object_Dispose(ellipsoid);                            /* Adjust the transform for the Green sphere */        Q3Group_GetNextPosition(lightGroup, &amp;lightPosition);        Q3RotateTransform_GetAngle(theDocument-&gt;lightXform2, &amp;angle);        angle += 0.5;        Q3RotateTransform_SetAngle(theDocument-&gt;lightXform2, angle);        Q3Transform_GetMatrix(theDocument-&gt;lightXform2, &amp;matrix);                    /* Get the Green light */        Q3Group_GetPositionObject(lightGroup, lightPosition, &amp;theLight);        /* Get the Green sphere */        Q3Group_GetFirstPositionOfType(theDocument-&gt;light2,          kQ3ShapeTypeGeometry, &amp;position);              Q3Group_GetPositionObject(theDocument-&gt;light2, position, &amp;ellipsoid);        Q3Ellipsoid_GetOrigin( ellipsoid, &amp;origin);        Q3Point3D_Transform(&amp;origin, &amp;matrix, &amp;location);        Q3PointLight_SetLocation(theLight, &amp;location);        Q3Object_Dispose(theLight);                    Q3Object_Dispose(ellipsoid);                                /* Adjust the transform for the Blue sphere */        Q3Group_GetNextPosition(lightGroup, &amp;lightPosition);        Q3RotateTransform_GetAngle(theDocument-&gt;lightXform3, &amp;angle);        angle += 0.3;        Q3RotateTransform_SetAngle(theDocument-&gt;lightXform3, angle);        Q3Transform_GetMatrix(theDocument-&gt;lightXform3, &amp;matrix);                    /* Get the Blue light */        Q3Group_GetPositionObject(lightGroup, lightPosition, &amp;theLight);        /* Get the Blue sphere */        Q3Group_GetFirstPositionOfType(theDocument-&gt;light3,          kQ3ShapeTypeGeometry, &amp;position);              Q3Group_GetPositionObject(theDocument-&gt;light3, position, &amp;ellipsoid);        Q3Ellipsoid_GetOrigin( ellipsoid, &amp;origin);        Q3Point3D_Transform(&amp;origin, &amp;matrix, &amp;location);        Q3PointLight_SetLocation(theLight, &amp;location);        Q3Object_Dispose(theLight);                    Q3Object_Dispose(ellipsoid);                    Q3Object_Dispose(lightGroup);        update = true;#endif      }      if( theDocument-&gt;documentGroup &amp;&amp; theDocument-&gt;animateModel) {        TQ3Matrix4x4  tmp;                if( theDocument-&gt;rotationDir.x == 0.0 &amp;&amp; theDocument-&gt;rotationDir.y == 0.0 ) {          Q3Matrix4x4_SetRotate_XYZ(&amp;tmp, 0.03, 0.08, 0.0);          Q3Matrix4x4_Multiply(&amp;theDocument-&gt;modelRotation, &amp;tmp, &amp;theDocument-&gt;modelRotation);        } else {          Q3Matrix4x4_SetRotate_XYZ(&amp;tmp, theDocument-&gt;rotationDir.x, theDocument-&gt;rotationDir.y, 0.0);          Q3Matrix4x4_Multiply(&amp;theDocument-&gt;modelRotation, &amp;tmp, &amp;theDocument-&gt;modelRotation);        }        update = true;      }      if( update ) {        DrawOffscreen(theDocument);        DrawOnscreen(theDocument);        DoDrawGrowIcon(theDocument-&gt;theWindow);      }    }  }}////  This is the main event loop of the program. It calls WaitNextEvent//  and dispatches the returned event until gQuit is true.//void EventLoop(void){  short      gotEvent;  EventRecord    theEvent;  RgnHandle    theMouseRgn;  Point      theLoc;  theMouseRgn = NewRgn();  do {      gotEvent = WaitNextEvent(everyEvent, &amp;theEvent, 0L, theMouseRgn);    if (gotEvent) {      DoEvent(&amp;theEvent);    } else {#ifndef PODIUM_APP      DoIdle();#else      Podium_DoIdle(&amp;theEvent) ;#endif    }  } while (! gQuit);  DisposeRgn(theMouseRgn);}</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/Tumbler_and_Podium/listing13.html%3Fid%3DDTS10000127-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/Tumbler_and_Podium/listing13.html%3Fid%3DDTS10000127-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/Tumbler_and_Podium/listing13.html%3Fid%3DDTS10000127-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>