<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html><head>
<!-- BEGIN META TAG INFO -->
<link rel="home" href="http://developer.apple.com/">
<link rel="find" href="http://developer.apple.com/search/">
<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
<script language="JavaScript" type="text/javascript" src="../../documentation/js/busnav.js"></script>
<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<!-- END META TAG INFO -->
<!-- BEGIN TITLE -->
<title>Technical Note TN2127: Kernel Authorization</title>
<!-- END TITLE -->
</head>
<!-- BEGIN BODY OPEN -->
<body bgcolor="#ffffff"><a name="//apple_ref/doc/uid/DTS10003591" title="Kernel Authorization"></a>
<!--END BODY OPEN -->
<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->
<a name="top"></a>
<!-- BEGIN LOGO AND SEARCH -->
<!--#include virtual="/includes/adcnavbar"-->
<!-- END LOGO AND SEARCH -->
<!-- START BREADCRUMB -->
<div id="breadcrumb"><table width="680" border="0" cellpadding="0" cellspacing="0"><tr>
<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
<td><img width="340" height="10" src="images/1dot.gif" alt=""></td></tr><tr valign="middle"><td align="left" colspan="2">
<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../technicalnotes/index.html">Technical Notes</a> &gt; <a href="../../technicalnotes/Darwin/index.html">Darwin</a> &gt; <a href="../../technicalnotes/Darwin/idxKernel-date.html">Kernel</a> &gt; 
</td></tr><tr><td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td></tr></table></div>
<!-- END BREADCRUMB -->

<!-- START MAIN CONTENT -->
<!-- START TITLE GRAPHIC AND INTRO-->
<table width="680" border="0" cellpadding="0" cellspacing="0"><tr align="left" valign="top">
<td><h1>
<div id="pagehead">Technical Note TN2127</div>
<div id="pageheadsub">Kernel Authorization</div>
</h1></td></tr></table>
<!-- END TITLE GRAPHIC AND INTRO -->
<!-- BEGIN WIDE COLUMN -->
<table width="680" border="0" cellpadding="0" cellspacing="0"><tr align="left" valign="top"><td align="left" width="680">
<!-- BEGIN CONTENTS -->
<table width="680" border="0" cellpadding="0" cellspacing="0"><tr align="left" valign="top"><td><p>Mac OS X 10.4 Tiger introduces a new kernel subsystem, Kernel Authorization or Kauth for short, for managing authorization within the kernel.  The Kauth subsystem exports a kernel programming interface (KPI) that allows third party kernel developers to authorize actions within the kernel, modify authorization decisions, and extend the kernel's authorization landscape.  It can also be used as a notification mechanism.</p><p>If you write code that interacts with the BSD portions of the Mac OS X kernel, you should read this technote to gain a passing familiarity with Kauth.  If you need to perform any of the tasks list above, you'll want to study this technote in depth.  Finally, if you're developing an anti-virus product for Mac OS X, you will need the information contained in this technote to implement &quot;on access&quot; and &quot;post modification&quot; file scanning.</p></td></tr><tr><td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br><img height="1" width="680" src="images/1dot_919699.gif" alt=""><br><img width="680" height="20" src="images/1dot.gif" alt=""></td></tr></table><table width="680" border="0" cellpadding="0" cellspacing="0"><tr align="left" valign="top"><td width="680"><ul><li><a href="#SECKAUTHFUND">Kauth Fundamentals</a></li><li><a href="#SECIMPLEMENTINGLISTENER">Implementing a Listener</a></li><li><a href="#SECREGISTERINGLISTENER">Registering a Listener</a></li><li><a href="#SECDEREGISTERINGLISTENER">Deregistering a Listener</a></li><li><a href="#SECREGISTERINGNEWSCOPE">Registering a New Scope</a></li><li><a href="#SECDEREGISTERSCOPE">Deregistering a Scope</a></li><li><a href="#SECAUTHORIZINGACTION">Authorizing an Action</a></li><li><a href="#SECBUILTINSCOPES">Built-In Scopes</a><ul><li><a href="#SECPROCESSSCOPE">Process Scope</a></li><li><a href="#SECGENERICSCOPE">Generic Scope</a></li><li><a href="#SECFILEOPSCOPE">File Operation Scope</a></li><li><a href="#SECVNODESCOPE">Vnode Scope</a><ul><li><a href="#SECVNODESCOPEGOTCHAS">Vnode Scope Gotchas</a></li></ul></li></ul></li><li><a href="#SECLISTENERGOTCHAS">Listener Gotchas</a><ul><li><a href="#SECCONTEXT">Context</a><ul><li><a href="#SECDEADLOCKS">Deadlock Avoidance</a><li><a href="#SECPERFORMANCE">Performance</a></li></ul></li></ul></li><li><a href="#SECKAUTHCOOKBOOK">Kauth Cookbook</a><ul><li><a href="#SECDENYDEBUG">Denying the Debugger</a></li><li><a href="#SECANTIVIRUS">Anti-Virus Scanner</a></li><li><a href="#SECNEWKERNELSUBSYSTEM">New Kernel Subsystem</a></li></ul></li><li><a href="#SECSAMPLECODE">KauthORama Sample Code</a></li><li><a href="#TNT_HISTORY_TAG">Document Revision History</a></li></ul></td></tr><tr><td colspan="3" scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br><img height="1" width="680" src="images/1dot_919699.gif" alt=""><br><img width="680" height="20" src="images/1dot.gif" alt=""></td></tr></table><A NAME="SECKAUTHFUND"></A><H2>Kauth Fundamentals</H2><p>The Kauth system is new in Mac OS X 10.4 Tiger.  It was implemented primarily to simplify the implementation of access control lists (ACLs), a major new feature of the Tiger kernel.  Because evaluating an ACL is a complex task, the code for doing this has been abstracted out of each file system plug-in and moved into the kernel proper.  Kauth does this in a general and flexible way.</p><p>While Kauth was originally designed to support ACLs, it is a general kernel authorization mechanism and can be used for a variety of other tasks.  One such use is as a simple notification mechanism for anti-virus developers (see <A HREF="#SECANTIVIRUS">Anti-Virus Scanner</A>).</p><p>To understand Kauth, you'll need to understand a number of core concepts.</p><ul><li><p><strong>scopes</strong> &mdash; A scope is an area of interest for authorization within the kernel.  For example, the scope <code>KAUTH_SCOPE_VNODE</code> is used for all authorization within the VFS layer.  Scopes allow you to register interest in some subset of kernel authorization decisions, without being involved in all authorization decisions.</p><p>Scopes are strings formatted using reverse DNS notation (for example, <code>KAUTH_SCOPE_VNODE</code> is <code>&quot;com.apple.kauth.vnode&quot;</code>), so you can define your own scope if you like.</p></li><li><p><strong>actions</strong> &mdash; An action is an operation within a scope.  For example, the VFS subsystem defines an action, <code>KAUTH_VNODE_READ_DATA</code>, which determines whether you're allowed to read data from a file system object.  Actions are specified by integer constants (the actual type is <code>kauth_action_t</code>) and each scope has its own action namespace.</p><p>The combination of a scope and an action defines an operation whose authorization can be checked.</p></li><li><p><strong>actors</strong> &mdash; An actor is an entity that's performing an operation.</p></li><li><p><strong>credentials</strong> &mdash; Credentials are the information that identifies an actor.  Credentials are specified by an opaque type, <code>kauth_cred_t</code>.  There are numerous accessor functions that let you operate on this type.  For example, <code>kauth_cred_getuid</code> returns the effective user ID (EUID) from the credentials.</p></li><li><p><strong>request</strong> &mdash; In the context of this document, an actor makes requests to perform an action within a particular scope.</p></li><li><p><strong>listener</strong> &mdash; A listener is a callback that makes an authorization decision for a request.  Fundamentally the listener authorizes the request based on the credentials of the actor.  The listener is free to use whatever scope- and action-dependent information necessary to make that decision.</p><p>There is a <strong>default listener</strong> for every built-in scope.  This listener implements the standard BSD authorization model for all actions within that scope.  In addition, you can register your own listeners for a scope.</p></li></ul><p><a href="#top">Back to Top</a>&nbsp;<a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p><A NAME="SECIMPLEMENTINGLISTENER"></A><H2>Implementing a Listener</H2><p>The prototype for a listener is shown in <A HREF="#LISTLISTENERPROTO">Listing 1</A>.</p><A NAME="LISTLISTENERPROTO"></A><p class="smalltext"><strong>Listing 1:</strong> Prototype for a listener</p><pre class="sourcecodebox">
static int MyListener(
    kauth_cred_t   credential,
    void *         idata,
    kauth_action_t action,
    uintptr_t      arg0,
    uintptr_t      arg1,
    uintptr_t      arg2,
    uintptr_t      arg3
);
</pre><p>The meaning of the first three arguments is the same for all scopes.</p><ul><li><p><code>credential</code> is a reference to the actor's credentials.</p><div class="notebox"><p><strong>IMPORTANT:</strong> When inspecting the credentials associated with a request, always use the accessor functions defined in &lt;sys/kauth.h&gt;.  Be especially careful when testing for group membership.  In Tiger a user can be in lots of groups (many more than the traditional limit of 16) and groups can be nested.  If you want to test whether a user is a member of a group, use <code>kauth_cred_ismember_gid</code>.</p></div></li><li><p><code>idata</code> is the cookie (or refCon) data you supplied when you registered the listener (see <A HREF="#SECREGISTERINGLISTENER">Registering a Listener</A>).</p></li><li><p><code>action</code> is the requested action (for example, <code>KAUTH_VNODE_READ_DATA</code>).</p></li></ul><p>The meaning of the remaining parameters is scope dependent.  I'll discuss these in detail in later sections.  However, in most cases these parameters give you extra information that allow you to make an authorization decision.  For example, for the VFS scope (<code>KAUTH_SCOPE_VNODE</code>), <code>arg1</code> is a reference to the vnode (of type <code>vnode_t</code>) that's being operated on.</p><p>A listener callback must return one of the following values.</p><ul><li><p><code>KAUTH_RESULT_DEFER</code> &mdash; This value indicates that the listener defers the decision about this request to the other listeners (and ultimately to the default listener).</p></li><li><p><code>KAUTH_RESULT_ALLOW</code> &mdash; This value indicates that, as far as this listener is concerned, the request is allowed.</p></li><li><p><code>KAUTH_RESULT_DENY</code> &mdash; This value indicates that the request should be denied.</p></li></ul><p>For a request to be allowed, at least one listener must return <code>KAUTH_RESULT_ALLOW</code> and no listeners can return <code>KAUTH_RESULT_DENY</code>.  This has a number of consequences.</p><ul><li><p>All listeners are called for all requests (because the last listener just might return <code>KAUTH_RESULT_DENY</code>).</p></li><li><p>Because a listener can't allow a request that's denied by any other listener, a non-default listener can only tighten security.</p></li></ul><p>When writing a listener, there are a number of important points that you need to keep in mind.  These are discussed in the detail in <A HREF="#SECLISTENERGOTCHAS">Listener Gotchas</A>.</p><p><a href="#top">Back to Top</a>&nbsp;<a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p><A NAME="SECREGISTERINGLISTENER"></A><H2>Registering a Listener</H2><p>You can register a listener for an existing scope using <code>kauth_listen_scope</code>.</p><p class="smalltext"><strong>Listing 2:</strong> kauth_listen_scope</p><pre class="sourcecodebox">
extern kauth_listener_t kauth_listen_scope(
    const char *           identifier,
    kauth_scope_callback_t callback,
    void *                 idata
);
</pre><p>The parameters are as follows:</p><ul><li><p><code>identifier</code> is the name of the scope.  The routine does not make a copy of the string pointed to by this parameter.  This is not a problem if you're passing a constant string; however, if you're calculating the string at runtime, you must make sure that the string persists until you dispose of the resulting <code>kauth_listener_t</code>.</p></li><li><p><code>callback</code> is the address of your listener callback function, with the prototype shown in <A HREF="#LISTLISTENERPROTO">Listing 1</A>.</p></li><li><p><code>idata</code> is the cookie (or refCon) for your listener callback.</p></li></ul><p>On error, the result is <code>NULL</code>.  On success, the result is a reference to the listener; you can use this to deregister your listener.</p><p>It is not an error to register a listener before the corresponding scope is registered.  The system will remember your listener and apply it once the scope appears.</p><p><a href="#top">Back to Top</a>&nbsp;<a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p><A NAME="SECDEREGISTERINGLISTENER"></A><H2>Deregistering a Listener</H2><p>You can deregister a listener using <code>kauth_unlisten_scope</code>.</p><p class="smalltext"><strong>Listing 3:</strong> kauth_unlisten_scope</p><pre class="sourcecodebox">
extern void  kauth_unlisten_scope(kauth_listener_t listener);
</pre><p>The parameters are as follows:</p><ul><li><p><code>listener</code> is a reference to the listener you got from <code>kauth_listen_scope</code>.</p></li></ul><div class="notebox"><p><strong>IMPORTANT:</strong> The return of <code>kauth_unlisten_scope</code> does not guarantee that all threads executing your listener have returned from your listener.  Once <code>kauth_unlisten_scope</code> returns, you must take steps to avoid destroying state that these threads rely on until they've completed executing your listener's code.  See <A HREF="#SECSAMPLECODE">KauthORama Sample Code</A> for an example of our recommended approach for this.</p></div><p><a href="#top">Back to Top</a>&nbsp;<a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p><A NAME="SECREGISTERINGNEWSCOPE"></A><H2>Registering a New Scope</H2><div class="notebox"><p><strong>IMPORTANT:</strong> You should only do this if you want to create your own custom scope.  In most cases third party developers should register a listener for an existing scope.</p></div><p>You can register a new scope using <code>kauth_register_scope</code>.</p><p class="smalltext"><strong>Listing 4:</strong> kauth_register_scope</p><pre class="sourcecodebox">
extern kauth_scope_t kauth_register_scope(
    const char *           identifier,
    kauth_scope_callback_t callback,
    void *                 idata
);
</pre><p>The parameters are as follows:</p><ul><li><p><code>identifier</code> is the name of the scope.  It is an error to register a scope that already exists.  The routine does not make a copy of the string pointed to by this parameter.  This is not a problem if you're passing a constant string; however, if you're calculating the string at runtime, you must make sure that the string persists at least until you dispose of the resulting <code>kauth_scope_t</code>.</p></li><li><p><code>callback</code> is the address of the listener callback function for this scope; this becomes the scope's default listener.  This parameter may be <code>NULL</code>, in which case a callback that always returns <code>KAUTH_RESULT_DEFER</code> is assumed.</p></li><li><p><code>idata</code> is the cookie (or refCon) for the listener callback.</p></li></ul><p>On error, the result is <code>NULL</code>.  On success, the result is a reference to the scope; you can use this to deregister your scope.</p><p><a href="#top">Back to Top</a>&nbsp;<a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p><A NAME="SECDEREGISTERSCOPE"></A><H2>Deregistering a Scope</H2><p>You can deregister a scope using <code>kauth_deregister_scope</code>:</p><p class="smalltext"><strong>Listing 5:</strong> kauth_deregister_scope</p><pre class="sourcecodebox">
extern void  kauth_deregister_scope(kauth_scope_t scope);
</pre><p>The parameters are as follows:</p><ul><li><p><code>scope</code> is a reference to the scope you got from <code>kauth_register_scope</code>.</p></li></ul><p>Any other (non-default) listeners registered on the scope will go dormant; they'll be reactivated if the scope is reregistered.</p><div class="notebox"><p><strong>IMPORTANT:</strong> The return of <code>kauth_deregister_scope</code> does not guarantee that all threads executing your listener have returned from your listener.  See the discussion associated with <code>kauth_unlisten_scope</code> (in <A HREF="#SECDEREGISTERINGLISTENER">Deregistering a Listener</A>) for details.</p></div><p><a href="#top">Back to Top</a>&nbsp;<a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p><A NAME="SECAUTHORIZINGACTION"></A><H2>Authorizing an Action</H2><p>You can make an authorization request using <code>kauth_authorize_action</code>.</p><p class="smalltext"><strong>Listing 6:</strong> kauth_authorize_action</p><pre class="sourcecodebox">
extern int kauth_authorize_action(
    kauth_scope_t  scope,
    kauth_cred_t   credential,
    kauth_action_t action,
    uintptr_t      arg0,
    uintptr_t      arg1,
    uintptr_t      arg2,
    uintptr_t      arg3
);
</pre><p>The parameters are as follows:</p><ul><li><p><code>scope</code> is a reference to the scope in which the action is defined.  You get this value from the result of <code>kauth_register_scope</code>.</p></li><li><p><code>credential</code> is a reference to the actor's credentials.  Normally you would either already have this information, or you'd call <code>kauth_cred_get</code> to get the credentials for the current thread.</p></li><li><p><code>action</code> is the requested action.</p></li><li><p><code>arg0</code> through <code>arg3</code> are passed unmodified to the listener callbacks.</p></li></ul><p>If your kernel extension supports plug-ins and those plug-ins call <code>kauth_authorize_action</code>, you must have a way for your plug-ins to discover the scope reference (<code>kauth_scope_t</code>).  The easiest way to do this is to export a wrapper function that's tailored to your specific requirements.</p><div class="notebox"><p><strong>IMPORTANT:</strong> The kernel already provides <code>kauth_authorize_action</code> wrappers for all of the scopes that it defines.  If you're authorizing within a kernel-defined scope you should call these wrappers rather than calling <code>kauth_authorize_action</code> directly.  These wrappers are described below, along with corresponding scopes.</p></div><p><a href="#top">Back to Top</a>&nbsp;<a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p><A NAME="SECBUILTINSCOPES"></A><H2>Built-In Scopes</H2><p>This section lists all of the scopes built in to the kernel in Mac OS X 10.4 Tiger.</p><A NAME="SECPROCESSSCOPE"></A><H3>Process Scope</H3><p>The process scope (<code>KAUTH_SCOPE_PROCESS</code>, which is <code>&quot;com.apple.kauth.process&quot;</code>) is the easiest to understand.  It defines just two actions.</p><ul><li><p><code>KAUTH_PROCESS_CANTRACE</code> &mdash;&nbsp;Authorizes whether the current process can trace the target process.  <code>arg0</code> (of type <code>proc_t</code>) is the process being traced.  <code>arg1</code> (of type <code>(int *)</code>) is a pointer to an an errno-style error code; if the listener denies the request, it must set this value to a non-zero value.</p></li><li><p><code>KAUTH_PROCESS_CANSIGNAL</code> &mdash;&nbsp;Authorizes whether the current process can signal the target process.  <code>arg0</code> (of type <code>proc_t</code>) is the process to be signalled.  <code>arg1</code> (of type <code>int</code>) is the signal that's being sent.</p><div class="notebox"><p><strong>IMPORTANT:</strong> This action is not implemented in Mac OS X 10.4 Tiger (r. <A HREF="rdar://problem/3931697">3931697</A>).</p></div></li></ul><p>The kernel also exports a <code>kauth_authorize_action</code> wrapper for this scope, namely <code>kauth_authorize_process</code>.</p><p class="smalltext"><strong>Listing 7:</strong> kauth_authorize_process</p><pre class="sourcecodebox">
extern int kauth_authorize_process(
    kauth_cred_t   credential,
    kauth_action_t action,
    proc_t         process,
    uintptr_t      arg1,
    uintptr_t      arg2,
    uintptr_t      arg3
);
</pre><p>This wrapper around <code>kauth_authorize_action</code> does two useful things:</p><ol><li><p>It supplies the appropriate scope parameter.</p></li><li><p>It eliminates the need to cast <code>process</code> (of type <code>proc_t</code>) to <code>arg0</code> (of type <code>uintptr_t</code>).</p></li></ol><p>Typically this is not useful for third party developers.</p><p><a href="#top">Back to Top</a>&nbsp;<a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p><A NAME="SECGENERICSCOPE"></A><H3>Generic Scope</H3><p>The generic scope (<code>KAUTH_SCOPE_GENERIC</code>, which is <code>&quot;com.apple.kauth.generic&quot;</code>) has a single action, <code>KAUTH_GENERIC_ISSUSER</code>, which the kernel requests to test whether an actor has superuser privileges.  None of the generic arguments (<code>arg0</code> through <code>arg3</code>) are significant.</p><div class="notebox"><p><strong>IMPORTANT:</strong> The kernel does not currently use this request for all superuser tests; in many cases the kernel continues to directly compare the credential's effective user ID to 0.</p></div><p>The kernel also exports a <code>kauth_authorize_action</code> wrapper for this scope, namely <code>kauth_authorize_generic</code>.</p><p class="smalltext"><strong>Listing 8:</strong> kauth_authorize_generic</p><pre class="sourcecodebox">
extern int kauth_authorize_generic(
    kauth_cred_t   credential,
    kauth_action_t action
);
</pre><p>Typically this is not useful for third party developers.</p><p><a href="#top">Back to Top</a>&nbsp;<a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p><A NAME="SECFILEOPSCOPE"></A><H3>File Operation Scope</H3><p>The file operation scope (<code>KAUTH_SCOPE_FILEOP</code>, which is <code>&quot;com.apple.kauth.fileop&quot;</code>) is different from other scopes in that it's not used to actually authorize an operation; rather, the system uses this scope to notify listeners of significant file system operations.  This can be used to implement an anti-virus scanning program, as described in <A HREF="#SECANTIVIRUS">Anti-Virus Scanner</A>.</p><p><code>KAUTH_SCOPE_FILEOP</code> defines the following actions.</p><ul><li><p><code>KAUTH_FILEOP_OPEN</code> &mdash;&nbsp;Notifies that a file system object (a file or directory) has been opened.  <code>arg0</code> (of type <code>vnode_t</code>) is a vnode reference.  <code>arg1</code> (of type <code>(const char *)</code>) is a pointer to the object's full path.</p></li><li><p><code>KAUTH_FILEOP_CLOSE</code> &mdash; Notifies that a file system object is about to be closed.  <code>arg0</code> (of type <code>vnode_t</code>) is a vnode reference.  <code>arg1</code> (of type <code>(const char *)</code>) is a pointer to the object's full path.  <code>arg2</code> (of type <code>int</code>) is a set of bit flags; the only flag currently defined is <code>KAUTH_FILEOP_CLOSE_MODIFIED</code>, which is set if a modified file is being closed.</p></li><li><p><code>KAUTH_FILEOP_RENAME</code> &mdash;&nbsp;Notifies that a file system object has been renamed.  <code>arg0</code> (of type <code>(const char *)</code>) is a pointer to the object's previous full path.  <code>arg1</code> (of type <code>(const char *)</code>) is a pointer to the object's new full path.</p></li><li><p><code>KAUTH_FILEOP_EXCHANGE</code> &mdash;&nbsp;Notifies that two files have been exchanged (via <A HREF="x-man-page://2/exchangedata">exchangedata</A>).  <code>arg0</code> (of type <code>(const char *)</code>) is a pointer to the first file's full path.  <code>arg1</code> (of type <code>(const char *)</code>) is a pointer to the second file's full path.</p></li><li><p><code>KAUTH_FILEOP_LINK</code> &mdash;&nbsp;Notifies that a new hard link has been added to a file (via the <A HREF="x-man-page://2/link">link</A> system call).  <code>arg0</code> (of type <code>(const char *)</code>) is a pointer to the full path of the original file.  <code>arg1</code> (of type <code>(const char *)</code>) is a pointer to the full path of the newly created link.</p></li><li><p><code>KAUTH_FILEOP_EXEC</code> &mdash;&nbsp;Notifies that a program has been executed (via the <A HREF="x-man-page://2/execve">execve</A> system call).  <code>arg0</code> (of type <code>vnode_t</code>) is a vnode reference of the program being executed (for Mach-O executables, this is the actual executable; for CFM applications, this will always reference <code>LaunchCFMApp</code>; for interpreted scripts, such as shell or perl scripts, this is the script, not the interpreter). <code>arg1</code> (of type <code>(const char *)</code>) is a pointer to the program file's full path.</p></li></ul><p>If you install a listener in this scope, it will be called to notify you of these events.  The kernel ignores the return value of your listener, although we recommend that you always return <code>KAUTH_RESULT_DEFER</code>.</p><div class="notebox"><p><strong>WARNING:</strong> If you install a listener in the this scope and handle the <code>KAUTH_FILEOP_RENAME</code>, <code>KAUTH_FILEOP_LINK</code>, or <code>KAUTH_FILEOP_EXEC</code> actions, you must test whether <code>arg0</code> and <code>arg1</code> are <code>NULL</code> before accessing them as strings.  Under certain circumstances (most notably, very early in the boot sequence and very late in the shutdown sequence), the kernel may pass you <code>NULL</code> for these arguments <A HREF="rdar://problem/4605516">(r. 4605516)</A>.  If you access such a pointer as a string, you will kernel panic.</p></div><p>The kernel also exports a <code>kauth_authorize_action</code> wrapper for this scope, namely <code>kauth_authorize_fileop</code>.</p><p class="smalltext"><strong>Listing 9:</strong> kauth_authorize_fileop</p><pre class="sourcecodebox">
extern int kauth_authorize_fileop(
    kauth_cred_t   credential,
    kauth_action_t action,
    uintptr_t      arg0,
    uintptr_t      arg1
);
</pre><p>Typically this is not useful for third party developers.</p><p><a href="#top">Back to Top</a>&nbsp;<a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p><A NAME="SECVNODESCOPE"></A><H3>Vnode Scope</H3><p>The vnode scope (<code>KAUTH_SCOPE_VNODE</code>, which is <code>&quot;com.apple.kauth.vnode&quot;</code>) is the most complex scope currently defined.  The first thing to note is that, within the vnode scope, actions are not enumerations but rather bitfields.  Thus, it's perfectly reasonable to combine actions by ORing them together.  For example, an action of <code>KAUTH_VNODE_READ_DATA</code> | <code>KAUTH_VNODE_EXECUTE</code> indicates that actor wishes to both read and execute the file.</p><p>To authorize an action within the vnode scope, you would call <code>vnode_authorize</code>.</p><p class="smalltext"><strong>Listing 10:</strong> vnode_authorize</p><pre class="sourcecodebox">
extern int vnode_authorize(
    vnode_t        vp,
    vnode_t        dvp,
    kauth_action_t action,
    vfs_context_t  context
);
</pre><p>The parameters are as follows:</p><ul><li><p><code>vp</code> is the vnode on which the action is being performed.</p></li><li><p><code>dvp</code> is the parent directory's vnode.  In many cases this is <code>NULL</code>, indicating that the parent is unknown or irrelevant.</p></li><li><p><code>action</code> is the operation being performed; this is discussed in detail below.</p></li><li><p><code>context</code> is the VFS context associated with the actor.  This is an opaque data structure that's intimately tied to the VFS implementation.  Most VFS entry points are passed this context.  In addition, there are numerous VFS context routines defined in &lt;sys/vnode.h&gt;.</p></li></ul><p><code>vnode_authorize</code> is a fairly simple wrapper around <code>kauth_authorize_action</code>.  It performs two useful functions:</p><ol><li><p>It assembles the correct scope listener arguments (<code>arg0</code> through <code>arg3</code>).  These are discussed below.</p></li><li><p>It ensures that the error code is correct.  Specifically, it translates the <code>EPERM</code> error returned by <code>kauth_authorize_action</code> into <code>EACCES</code> (which is the appropriate error for file system functions).  Also, if the listener denies a request and provides a specific error code (via <code>arg3</code>, see below), it returns that error.</p></li></ol><div class="notebox"><p><strong>IMPORTANT:</strong> It is relatively unusual for a VFS plug-in to call <code>vnode_authorize</code>.  In most cases the VFS layer has authorized all actions before calling your plug-in.  However, there are some circumstances where a VFS plug-in should call <code>vnode_authorize</code>.  For example, HFS [Plus]'s implementation of <A HREF="x-man-page://2/searchfs">searchfs</A> uses <code>vnode_authorize</code> to ensure that the caller has access to the file system objects that it's returning.</p></div><p>The scope listener arguments for the vnode scope are as follows:</p><ul><li><p><code>arg0</code>, of type <code>vfs_context_t</code>, is <code>context</code> &mdash; The VFS context, described above.</p></li><li><p><code>arg1</code>, of type <code>vnode_t</code>, is <code>vp</code> &mdash; The vnode itself.</p></li><li><p><code>arg2</code>, of type <code>vnode_t</code>, is <code>dvp</code> &mdash; The parent vnode, if available.  This may be <code>NULL</code>.</p></li><li><p><code>arg3</code>, of type <code>(int *)</code>, is <code>errPtr</code> &mdash; A pointer to an errno-style error.  If your callback denies the request, it can set this value to indicate the error to return to the client.  If you don't set this, the client gets <code>EACCES</code>.</p></li></ul><p>Within the vnode scope, the following standard actions are defined.</p><ul><li><p><code>KAUTH_VNODE_READ_DATA</code> (also <code>KAUTH_VNODE_LIST_DIRECTORY</code>) &mdash; If the vnode is a directory, authorizes the actor to enumerate the contents of that directory.  Otherwise, authorizes the actor to read the contents of a file.</p></li><li><p><code>KAUTH_VNODE_WRITE_DATA</code> (also <code>KAUTH_VNODE_ADD_FILE</code>) &mdash; If the vnode is a directory, authorizes the actor to add a file to that directory.  <code>vp</code> is the directory to which the file is being added; <code>dvp</code> is <code>NULL</code>.  Otherwise, authorizes the actor to write the contents of a file.</p></li><li><p><code>KAUTH_VNODE_EXECUTE</code> (also <code>KAUTH_VNODE_SEARCH</code>) &mdash; If the vnode is a directory, authorizes the actor to probe for the existence of an item within the directory as part of a path lookup.  Otherwise, authorizes the actor to execute the contents of a file.</p></li><li><p><code>KAUTH_VNODE_DELETE</code> &mdash; Authorizes the actor to delete an item from a directory.  <code>vp</code> is the item to be deleted and <code>dvp</code> is the directory it's being deleted from.</p></li><li><p><code>KAUTH_VNODE_APPEND_DATA</code> (also <code>KAUTH_VNODE_ADD_SUBDIRECTORY</code>) &mdash; If the vnode is a directory, authorizes the actor to add a directory to it.  Otherwise, this action is intended to authorize the actor to append data to the contents of a file; however, this aspect is not currently implemented.</p></li><li><p><code>KAUTH_VNODE_DELETE_CHILD</code> &mdash; When used in a directory's ACL, this permission controls whether the actor can delete an item from the directory.  That is, for the actor to be able to delete the item, they must have <code>KAUTH_VNODE_DELETE</code> permission on the item and <code>KAUTH_VNODE_DELETE_CHILD</code> permission on the item's parent directory.</p><p>A Kauth listener, however, rarely sees this action. When an actor deletes an item, the kernel just authorizes the <code>KAUTH_VNODE_DELETE</code> action on the item itself; it does not authorize a separate <code>KAUTH_VNODE_DELETE_CHILD</code> action on the parent directory.  Rather, the default listener for the vnode scope will check the <code>KAUTH_VNODE_DELETE_CHILD</code> permission on the parent directory directly, without another pass through Kauth.  This improves performance and avoids a potential race condition.</p><p>On the other hand, a <code>KAUTH_VNODE_DELETE_CHILD</code> action is generated in response to an <A HREF="x-man-page://2/access">access</A> system call with the <code>_RMFILE_OK</code> flag.</p></li><li><p><code>KAUTH_VNODE_READ_ATTRIBUTES</code> &mdash; Authorizes the actor to read standard attributes of the vnode (such as the time stamps).</p></li><li><p><code>KAUTH_VNODE_WRITE_ATTRIBUTES</code> &mdash; Authorizes the actor to change standard attributes of the vnode (such as the time stamps).</p></li><li><p><code>KAUTH_VNODE_READ_EXTATTRIBUTES</code> &mdash; Authorizes the actor to read extended attributes of the vnode (those accessed via <code>getxattr</code>, including the resource fork).</p></li><li><p><code>KAUTH_VNODE_WRITE_EXTATTRIBUTES</code> &mdash; Authorizes the actor to change (or add) extended attributes of the vnode (those accessed via <code>getxattr</code>, including the resource fork).</p></li><li><p><code>KAUTH_VNODE_READ_SECURITY</code> &mdash; Authorizes the actor to read the vnode's ACL.</p></li><li><p><code>KAUTH_VNODE_WRITE_SECURITY</code> &mdash; Authorizes the actor to change the vnode's ACL.</p></li><li><p><code>KAUTH_VNODE_TAKE_OWNERSHIP</code> &mdash; Authorizes the actor to change ownership of the vnode.</p></li><li><p><code>KAUTH_VNODE_SYNCHRONIZE</code> &mdash; This represents an ACL permission that is defined for compatibility with other platforms.  It is preserved but not tested by Mac OS X.  Hence, it is never used as a Kauth action.</p></li><li><p><code>KAUTH_VNODE_LINKTARGET</code> &mdash; Authorizes the actor to make a new hard link to the vnode.</p></li><li><p><code>KAUTH_VNODE_CHECKIMMUTABLE</code> &mdash; Authorizes the actor to modify the file (in the <code>SF_IMMUTABLE</code> sense; see <A HREF="x-man-page://2/chflags">chflags</A>).  This flag is set if other checks have already been made to check that the file can by modified, but the modification should still fail for immutable files.</p></li><li><p><code>KAUTH_VNODE_ACCESS</code> &mdash; This is a special flag.  If this flag is set the authorization request is advisory (for example, to satisfy an <A HREF="x-man-page://2/access">access</A> system call) rather than authoritative.  A listener can use this to avoid doing extra work in the advisory case.</p></li><li><p><code>KAUTH_VNODE_NOIMMUTABLE</code> &mdash; This is a special flag.  It is passed to the listener along with the <code>KAUTH_VNODE_WRITE_SECURITY</code> bit (and no others) to indicate that the actor wishes to change one or more of the immutable flags, and that the state of these flags should not be considered when authorizing the request.</p></li></ul><A NAME="SECVNODESCOPEGOTCHAS"></A><H4>Vnode Scope Gotchas</H4><p>Remember that actions within the vnode scope are a bitfield.  Thus a vnode scope listener can be called to authorize multiple actions simultaneously.</p><p>The vnode scope is <strong>extremely hot</strong>.  If your vnode scope listener is slow, it will significantly slow down all file system operations.  If you install a vnode scope listener, you should work to make it as efficient as possible.</p><p>When writing a vnode scope listener, be aware that not every file system operation will trigger an authorization request.  For example, if an actor successfully requests <code>KAUTH_VNODE_SEARCH</code> on a directory, the system may cache that result and grant future requests without invoking your listener for each one.</p><p>For more information about the pitfalls of writing a listener, see <A HREF="#SECLISTENERGOTCHAS">Listener Gotchas</A>.</p><p><a href="#top">Back to Top</a>&nbsp;<a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p><A NAME="SECLISTENERGOTCHAS"></A><H2>Listener Gotchas</H2><p>When writing a listener, there are a number of important points that you need to keep in mind.  These are discussed in the following sections.</p><A NAME="SECCONTEXT"></A><H3>Context</H3><p>In most cases your listener will be called by the user's thread.  That is, a user thread has made a system call, which caused it to enter the kernel to do the work, which has triggered a Kauth request.  So, it's possible to get information about the actor based on the current thread or process.  For example, you can call <code>proc_self</code> to get a reference to the current process and then extract useful information from that.</p><p>However, you should try to avoid doing this.  Rather, your listener should make its decision based on the actor's credentials (as passed to it in the <code>credentials</code> parameter) and, if you're listening in the <A HREF="#SECVNODESCOPE">vnode scope</A>, the VFS context.</p><p>There are two reasons for this recommendation.</p><ul><li><p>As far as the overall kernel design is concerned, it is cleaner for your listener to make decisions based on its input parameters, rather than on implicit parameters like the current thread.</p></li><li><p>In some cases, it's possible for a kernel operation to be executed by another thread on behalf of the user.  This sort of thing already happens for asynchronous I/O, where the kernel maintains a pool of async I/O threads that perform asynchronous file system requests.  On Mac OS X 10.4 Tiger these threads don't actually make authorization requests, but the long-term direction is clear.</p></li></ul><A NAME="SECDEADLOCKS"></A><H4>Deadlock Avoidance</H4><p>Your listener is called by the thread that's performing the operation, so it's possible to block the thread while you process the request.  However, this is a two-edged sword.  It allows your listener to pass the request to an external agent (a user space daemon, for example) and block waiting for the results.  However, doing so entails significant risk of deadlocking the system.</p><p>This problem most commonly crops up when writing a listener for the <A HREF="#SECVNODESCOPE">vnode</A> or <A HREF="#SECFILEOPSCOPE">file operation</A> scopes.  A typical example is:</p><ol><li><p>You install a listener for the <A HREF="#SECFILEOPSCOPE">file operation</A> scope.</p></li><li><p>A normal process opens a file.</p></li><li><p>Your listener is called with <code>KAUTH_FILEOP_OPEN</code>.  It passes the request to a user space daemon and waits for the result.</p></li><li><p>The user space daemon calls some system routine that RPCs to a system daemon.  For example, it might call <A HREF="x-man-page://3/getpwuid">getpwuid</A>, which is actually implemented inside <A HREF="x-man-page://8/lookupd">lookupd</A>.</p></li><li><p>The system daemon opens a file.</p></li><li><p>This causes the kernel to call your listener, and the cycle starts over again.</p></li></ol><p>This problem is much worse than it seems.  Specifically:</p><ul><li><p>System daemons call other system daemons.  For example, <code>lookupd</code> is dependent on <A HREF="x-man-page://8/DirectoryService">DirectoryService</A>, which may in turn be dependent on other daemons.</p></li><li><p>You can't just hard-code a list of possible system daemons because the dependency tree varies of from release-to-release; Apple can add new dependencies at any time.</p></li><li><p>It's impossible for your daemon to not depend on any system daemons.  Every time you touch pageable memory, you might trigger the allocation of a paging file, which depends on the <A HREF="x-man-page://8/dynamic_pager">dynamic_pager</A>.</p></li></ul><p>There are a variety of ways to avoid this deadlock.  The best is for your listener to avoid do any processing if the request comes from a thread running as root (that is, where <code>kauth_cred_getuid</code> for the actor's credentials returns 0).  As all critical system daemons will necessarily run as root, you break the deadlock at step 6 above.</p><div class="notebox"><p><strong>Note:</strong> The group resolution membership daemon, <A HREF="x-man-page://8/memberd">memberd</A>, faces a similar problem, and it avoids this problem in exactly this fashion; the system never invokes <code>memberd</code> if the thread is running as root.</p></div><p>However, this technique may not be appropriate in all cases.  For example, an <A HREF="#SECANTIVIRUS">anti-virus scanner</A> would particularly want to scan files being opened by a thread running with elevated privileges.  In this case the only correct solution is for the scanner to operate entirely within the kernel.</p><p><a href="#top">Back to Top</a>&nbsp;<a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p><A NAME="SECPERFORMANCE"></A><H4>Performance</H4><p>Some Kauth scopes are very hot.  That is, a typical system will make authorization requests in that scope frequently.  For example, a system copying files might make thousands of <A HREF="#SECVNODESCOPE">vnode scope</A> authorization requests per second.  If you register a listener for a scope, it can be called for every request.  If your listener is slow, it will significantly degrade system performance.</p><p>The two hot scopes on Mac OS X 10.4 Tiger are the <A HREF="#SECVNODESCOPE">vnode scope</A> and the <A HREF="#SECFILEOPSCOPE">file operation scope</A>.  If you install a listener for either of these scopes, be sure to measure the effect your listener has on overall system performance, and optimize your listener accordingly.</p><p><a href="#top">Back to Top</a>&nbsp;<a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p><A NAME="SECKAUTHCOOKBOOK"></A><H2>Kauth Cookbook</H2><p>This section describes how to use Kauth to implement some commonly requested features.</p><A NAME="SECDENYDEBUG"></A><H3>Denying the Debugger</H3><p>You can use Kauth to implement a kernel extension that prevents users attaching to processes with the debugger.  All you need to do is register a listener for the <code>KAUTH_SCOPE_PROCESS</code> scope and look for the <code>KAUTH_PROCESS_CANTRACE</code> action.  <A HREF="#LISTNODEBUG">Listing 11</A> shows an example listener that denies debugging for everyone except root.  You can use a similar technique to prevent the debugger attaching to specific processes.</p><A NAME="LISTNODEBUG"></A><p class="smalltext"><strong>Listing 11:</strong> Denying the debugger</p><pre class="sourcecodebox">
static int KauthDenyDebugListener(
    kauth_cred_t    credential,
    void *          idata,
    kauth_action_t  action,
    uintptr_t       arg0,
    uintptr_t       arg1,
    uintptr_t       arg2,
    uintptr_t       arg3
)
    // We register this listener for the KAUTH_SCOPE_PROCESS scope.
    // The system calls this listener whenever it needs to authorize
    // an action within that scope.  We look for
    // KAUTH_PROCESS_CANTRACE action and deny it if the requesting
    // user is not root.
{
    int     result;

    result = KAUTH_RESULT_DEFER;

    switch (action) {
        case KAUTH_PROCESS_CANTRACE:
            {
                proc_t  targetProc;
                int *   errPtr;

                targetProc = (proc_t) arg0;
                errPtr     = (int *)  arg1;

                if (kauth_cred_getuid(credential) != 0) {
                    printf(
                        &quot;Denied P_TRACE from %d to %d by %d.\n&quot;,
                        proc_selfpid(),
                        proc_pid(targetProc),
                        kauth_cred_getuid(credential)
                    );
                    *errPtr = EPERM;
                    result = KAUTH_RESULT_DENY;
                }
            }
            break;
        default:
            // do nothing
            break;
    }

    return result;
}
</pre><div class="notebox"><p><strong>Note:</strong> Kauth is not invoked when a program is started by the debugger.  You can detect this case using the technique shown in <A HREF="../../qa/qa2004/qa1361.html">Technical Q&amp;A QA1361, 'Detecting the Debugger'</A>.</p></div><p><a href="#top">Back to Top</a>&nbsp;<a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p><A NAME="SECANTIVIRUS"></A><H3>Anti-Virus Scanner</H3><p>Kauth allows you to implement an anti-virus program that supports both &quot;on access&quot; and &quot;post modification&quot; file scanning.  The latter is easy: all you need to do is register a listener for the <code>KAUTH_SCOPE_FILEOP</code> scope and watch for the <code>KAUTH_FILEOP_CLOSE</code> action.  If you see a modified file being closed, you can pass that file to your user space daemon for scanning.  As the scanning proceeds asynchronously in the background, there should be no problems with deadlock.</p><p>Implementing &quot;on access&quot; scanning is more challenging.  Your approach depends on whether you can always fix a file.  If that's the case, you can listen for <code>KAUTH_FILEOP_OPEN</code> (in the <code>KAUTH_SCOPE_FILEOP</code>) and scan the file immediately after it's been opened.  However, the result of your listener is always ignored, so there is no way to deny the actor access to that file.</p><p>If you can't always fix a file, and thus you may want to deny the actor access to the file, you must listen for the appropriate actions in the <code>KAUTH_SCOPE_VNODE</code> scope.  If you scan a file, detect that it's infected, and can't fix it, you should return <code>KAUTH_RESULT_DENY</code> to prevent the actor from using it.</p><p>The difficulty with both of these &quot;on access&quot; approaches is avoiding deadlock.  See <A HREF="#SECIMPLEMENTINGLISTENER">Implementing a Listener</A> for a detailed discussion of this problem.</p><p><a href="#top">Back to Top</a>&nbsp;<a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p><A NAME="SECNEWKERNELSUBSYSTEM"></A><H3>New Kernel Subsystem</H3><p>If you're implementing an entirely new kernel subsystem (for example, a sophisticated protocol stack), you may decide to implement your authorization using Kauth.  There are seven steps to this:</p><ol><li><p>Decide on a scope name.  You should use a reverse DNS-style name, as illustrated by the built-in scopes <A HREF="#SECBUILTINSCOPES">described in this document</A>.</p></li><li><p>Decide on a set of actions.  You can choose to use either an enumeration (as done by the <A HREF="#SECFILEOPSCOPE">file operations scope</A>) or a bitmask (as used by the <A HREF="#SECVNODESCOPE">vnode scope</A>).</p></li><li><p>For each action, you must decide what request-specific arguments (of type <code>arg0</code> through <code>arg3</code>) are appropriate for that action.  It's easiest if the arguments are the same for all of the actions within your scope, but that's not required.</p></li><li><p><A HREF="#SECIMPLEMENTINGLISTENER">Write a default listener</A> for your scope.  This listener should be able to make authorization decisions based on:</p><ul><li><p>the identity of the actor (as represented by the listener's <code>credentials</code> parameter)</p></li><li><p>the requested action</p></li><li><p>the request-specific arguments</p></li></ul><p>Your listener can extract information from the credentials using the accessor functions defined in &lt;sys/kauth.h&gt;.</p></li><li><p>Create your scope, and register your listener as the default listener, using <code>kauth_register_scope</code>.</p></li><li><p>Create a scope-specific wrapper function for <code>kauth_authorize_action</code> that:</p><ul><li><p>supplies a reference to the scope created in the previous step</p></li><li><p>casts your scope-specific arguments to the generic arguments (<code>arg0</code> through <code>arg3</code>) used by <code>kauth_authorize_action</code></p></li></ul></li><li><p>Call your scope-specific wrapper function to authorize specific actions at appropriate places in your kernel subsystem.</p></li></ol><p><a href="#top">Back to Top</a>&nbsp;<a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p><A NAME="SECSAMPLECODE"></A><H2>KauthORama Sample Code</H2><p><A HREF="../../samplecode/KauthORama/index.html">Sample Code Project 'KauthORama'</A> is a great tool for exploring Kauth.  It allows you to register a dummy listener for any scope.  The listener always returns <code>KAUTH_RESULT_DEFER</code>, and so has no effect on authorization decisions, but it prints a record of the authorization request.  Using this you can see how Kauth interacts with high-level operations, like listing directories or copying files.  The sample's read me file has instructions for doing this.</p><p><a href="#top">Back to Top</a>&nbsp;<a href="#top"><img src="images/arrow_linkup.gif" height="7" width="10" border="0" alt=""></a></p><A NAME="TNT_HISTORY_TAG"></A><H2>Document Revision History</H2><table cellspacing="0" class="graybox" width="680"><tr><th width="100">Date</th><th width="580">Notes</th></tr><tr><td scope="row">2007-01-16</td><td>Document a kernel bug that causes certain arguments to be NULL.</td></tr><tr><td scope="row">2006-03-21</td><td>Corrected problems with non-ASCII characters.</td></tr><tr><td scope="row">2005-06-03</td><td>Describes the kernel authorization (kauth) subsystem and its associated KPI.</td></tr></table><p><b>Posted:</b> 2007-01-16</p>
<!-- END CONTENTS -->
</td></tr></table>
<!-- END WIDE COLUMN -->
<!-- END MAIN CONTENT -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/technotes/tn2005/tn2127.html%3Fid%3DDTS10003591-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/technotes/tn2005/tn2127.html%3Fid%3DDTS10003591-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/technotes/tn2005/tn2127.html%3Fid%3DDTS10003591-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

<!-- START BOTTOM APPLE NAVIGATION -->
<!--#include virtual="/includes/footer"-->
<!-- END BOTTOM APPLE NAVIGATION -->
<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->
</body></html>