<!-- Generated by Harlequin WebMaker 2.2.3 (23-Apr-1996)
LispWorks 3.2.2 -->
<HTML> <HEAD>
<TITLE>Compatibility and Performance (IM: PS)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING16></A>



<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="PPCSoftware-15.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="PPCSoftware-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="PPCSoftware-86.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="PPCSoftware-17.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="PPCSoftware-2.html"><B>PowerPC System Software</B></A> / <BR><DD><A HREF="PPCSoftware-11.html"><B>Chapter 1 - Introduction to PowerPC System Software</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING16-0></A>
<H1>Compatibility and Performance</H1>
 In general, it's relatively easy to modify existing ANSI-compliant C or C++ source code that successfully compiles and runs on 680x0-based Macintosh computers so that it can be compiled and run on PowerPC processor-based Macintosh computers. Most of the intricate work required to make your application compatible with the new PowerPC run-time environment is performed automatically by your development system's compiler and linker and by the Code Fragment Manager. As you've seen, the changes you need to make in your application's source code are fairly straightforward. You need to make these changes:<A NAME=MARKER-2-420></A><P>
<UL>
<LI>Create routine descriptors for any routines whose addresses you pass to code of an unknown type.
<LI>Minimize any dependencies on system global variables by using the new set of accessor routines defined in the MPW interface files.<A NAME=MARKER-2-421></A><A NAME=MARKER-2-422></A>
<LI>Isolate and conditionalize any dependencies on specific features of the 680x0 A5 world or the 680x0 run-time environment.
<LI>Isolate and conditionalize any dependencies on information being passed in specific 680x0 registers.
<LI>Use 680x0 alignment for any data that is passed between environments, or declare your data structures so that their fields are aligned identically in both the 680x0 and PowerPC environments.<P>
</UL>
 This section discusses several additional topics that relate more generally to the compatibility and performance of your PowerPC application.<P>
<A NAME=HEADING16-8></A>
<H2><A NAME=MARKER-9-423></A>Patches</H2>
 <A NAME=MARKER-2-363></A><A NAME=MARKER-2-186></A>Some applications or other kinds of software patch the Operating System's trap dispatch tables to augment or replace the capabilities of certain system software routines. In general, however, there is much less need to patch the system software now than there previously was, and you should avoid doing so if at all possible. One very good reason to avoid unnecessary patching is that you can incur a substantial performance reduction if your patch causes a mode switch. For example, when a PowerPC application calls <BR>a system software routine that is implemented as PowerPC code, the dispatching to <BR>the PowerPC code occurs fairly quickly. However, if you patch the PowerPC code <BR>with 680x0 code, the Mixed Mode Manager needs to intervene to switch the execution environments both when entering and when exiting your patch code. This switching results in a considerable overhead (approximately 15 microseconds on a 60 MHz PowerPC processor per round-trip mode switch, the equivalent of about fifty 680x0 instructions).<A NAME=MARKER-10-4></A><A NAME=MARKER-2-427></A><P>
<DL>
<DT><B>Note</B>
<DD>The precise number of instructions or microseconds of overhead required to switch from one environment to the other and back is subject to change in future system software versions and on different hardware configurations. The important point to keep in mind is that switching modes is a reasonably expensive activity and you should avoid it whenever possible.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
 The same situation occurs if you use PowerPC code to patch a system software routine that is implemented as 680x0 code. Once again, a mode switch is required before entering your patch code and after exiting it.<P>
 <A NAME=MARKER-2-428></A><A NAME=MARKER-2-429></A>The ideal solution is simply to avoid patching the system software entirely. In the few cases in which you absolutely cannot avoid patching some system software routine, you can avoid the kind of mode switching just described by making sure to patch PowerPC code with a PowerPC patch and 680x0 code with a 680x0 patch. Because you cannot in general know what kind of code implements a particular system software routine, you should install a <B>fat patch,</B> which addresses both PowerPC and 680x0 versions of your code. To install a fat patch, you need to create a routine descriptor with two embedded routine records, one record describing the PowerPC routine and one record describing the 680x0 routine. Then you pass the address of that routine descriptor--that is, a universal procedure pointer--to an appropriate Trap Manager routine, which installs that universal procedure pointer into the trap dispatch table. When the patched routine is called, the Mixed Mode Manager inspects the routine descriptor addressed by the universal procedure pointer and selects the patch code that has the smallest impact on performance.<A NAME=MARKER-2-430></A><P>
<DL>
<DT><B>IMPORTANT</B>
<DD>To install patches, you can use one of the Trap Manager routines <CODE>SetToolTrapAddress</CODE>, <CODE>SetOSTrapAddress</CODE>, and <CODE>NSetTrapAddress</CODE>. You should not use the obsolete routine <CODE>SetTrapAddress</CODE>. See the chapter "Trap Manager" in <I><A HREF="../OSUtilities/OSUtilities-2.html">Inside Macintosh: Operating System Utilities</A></I> for a more complete description of the recommended way to patch system software routines. You should never manipulate the trap dispatch tables directly.<EM></EM><A NAME=MARKER-2-48></A><A NAME=MARKER-2-49></A>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
 Your patch code should, of course, make sure to call through to the code originally addressed by the entry in the trap dispatch table. You can retrieve that address by calling <CODE>GetToolTrapAddress</CODE>, <CODE>GetOSTrapAddress</CODE>, or <CODE>NGetTrapAddress</CODE> before you install <BR>your patch. In the 680x0 patch code, you can simply jump to that address. In the PowerPC patch code, you execute the original code by calling the Mixed Mode Manager routine <CODE>CallUniversalProc</CODE> (for Toolbox traps) or <CODE>CallOSTrapUniversalProc</CODE> (for Operating System traps).<A NAME=MARKER-2-190></A><P>
 The <CODE>CallOSTrapUniversalProc</CODE> function behaves just like the <CODE>CallUniversalProc</CODE> function except that it preserves additional 680x0 registers around the execution of <BR>the called procedure. In addition, you need to pass it a value specifying the trap word. Operating System traps expect a 2-byte parameter in register D1; this parameter represents the actual A-trap word used to call the routine. (Some traps use bits in the trap word to dispatch to different code.) Any Operating System trap patches you install should accept that parameter in register D1 and pass it through when calling the original trap code. <A HREF=#MARKER-9-435>Listing 1-14</A> shows how to patch the <CODE>NewPtr</CODE> function using PowerPC code.<A NAME=MARKER-2-434></A><P>
<B>Listing 1-14  <A NAME=MARKER-9-435></A>Patching an Operating System trap</B><P>
<PRE>
enum {      /*procedure information for NewPtr function*/
   kNewPtrProcInfo = kRegisterBased |
      RESULT_SIZE(kFourByteCode) |
      REGISTER_RESULT_LOCATION(kRegisterA0) |
      REGISTER_ROUTINE_PARAMETER(1, kRegisterD1, kTwoByteCode) |
      REGISTER_ROUTINE_PARAMETER(2, kRegisterD0, kFourByteCode)
};

pascal Ptr MyNewPtrPatch(unsigned short trapWord, Size byteCount)
{
   /*Your patch code goes here.*/

   return (long) CallOSTrapUniversalProc(gOriginalNewPtr,
                        kNewPtrProcInfo, trapWord, byteCount);
}
</PRE>
 Because <CODE>CallUniversalProc</CODE> and <CODE>CallOSTrapUniversalProc</CODE> are called as subroutines and return control to the calling code, all PowerPC patches are both <BR><B>head patches</B> and <B>tail patches</B> (that is, your patch has control both before and after <BR>the code originally pointed to by the trap dispatch table).<A NAME=MARKER-2-300></A><A NAME=MARKER-2-362></A><A NAME=MARKER-2-360></A><P>
 Notice that the address you call through to might be the address of someone else's patch. As a result, it's still possible for mode switches to occur, if at least one link in the patch daisy chain is not a fat patch. These mode switches are unavoidable.<P>
 Note also that the system software includes a small number of <B>split traps,</B> system software routines that are implemented with 680x0 code (usually in ROM) and as PowerPC code in an import library. Because the PowerPC code is contained directly <BR>in the import library, you cannot patch the PowerPC portion of a split trap. In general, however, only those routines are implemented as split traps that are not likely candi-<BR>dates for patching. For example, a number of very small utility routines like <CODE>AddPt</CODE> and <CODE>SetRect</CODE> are implemented as split traps.<A NAME=MARKER-2-354></A><A NAME=MARKER-2-355></A><P>
 The biggest restriction on patching is that you cannot patch any <B>selector-based traps</B> (system software routines that are dispatched through a selector code) with either pure PowerPC or fat patches. In the 680x0 environment, you can patch one or more selectors belonging to a dispatched trap and pass all others through to the original code. In the PowerPC environment, however, this is not possible. As a result, when patching with PowerPC code, you must patch all the routines selected by a single trap if you patch any of them. However, you cannot in general determine how many selectors are supported by a given selector-based trap. You cannot therefore safely patch selector-based traps in a way that is likely to remain compatible with future system software versions. For now, you should use 680x0 code if you need to patch selector-based traps.<A NAME=MARKER-2-356></A><A NAME=MARKER-2-358></A><A NAME=MARKER-2-180></A><A NAME=MARKER-2-444></A><A NAME=MARKER-2-445></A><A NAME=MARKER-2-446></A><A NAME=MARKER-2-361></A><P>
<A NAME=HEADING16-22></A>
<H2>The Memory Manager</H2>
 <A NAME=MARKER-2-448></A><A NAME=MARKER-10-376></A>As you've already learned, the Memory Manager has been rewritten for PowerPC processor-based Macintosh computers. The new Memory Manager, written in C and compiled into native PowerPC code, offers much better performance than the previous 680x0 assembly-language version, both because it runs in the native PowerPC environ-<BR>ment and because it uses substantially improved algorithms to manage heaps. In general, however, the application programming interface has not changed. As a result, you'll benefit from the new version completely transparently, whether your application runs under the 68LC040 Emulator or in the native PowerPC environment.<P>
 The Memory control panel (shown in <A HREF=#MARKER-9-453>Figure 1-17</A>) includes controls that allow the user to select whether applications and other software use the new Memory Manager or the original Memory Manager. By default, the new (or "Modern") Memory Manager is used.<A NAME=MARKER-0-450></A><A NAME=MARKER-2-384></A><A NAME=MARKER-2-452></A><P>
<B>Figure 1-17  <A NAME=MARKER-9-453></A>The Memory control panel for PowerPC processor-based Macintosh computers</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/PPCO-S-38.jpg">
 There are, however, several restrictions imposed by the new Memory Manager that might cause compatibility problems for your application. If you've followed the advice and warnings in the book <I><A HREF="../Memory/Memory-2.html">Inside Macintosh: Memory</A>,</I> your application should run without problems. However, the new Memory Manager is generally much less forgiving toward code that fails to heed those warnings. Here are some areas to watch out for.<P>
<UL>
<LI>Don't dispose of blocks more than once. When you dispose of a block, whether relocatable or nonrelocatable, the Memory Manager immediately takes control of that block. Any future attempt to operate on the block (even simply to dispose of it) is likely to cause problems. Note that it's possible to dispose of a block twice in rather subtle ways. For example, you might call <CODE>GetPicture</CODE> to display a picture stored in a resource and then inadvertently call <CODE>KillPicture</CODE> or <CODE>DisposeHandle</CODE> to remove it. This way of disposing of the block of memory leaves the <CODE>'PICT'</CODE> resource in the resource map. When your application quits, the resource is disposed of once again. (The proper way to dispose of a picture loaded from a resource is to call <CODE>ReleaseResource</CODE>.)<A NAME=MARKER-2-99></A><A NAME=MARKER-2-455></A><A NAME=MARKER-2-98></A><A NAME=MARKER-2-457></A><A NAME=MARKER-2-458></A><A NAME=MARKER-2-459></A><A NAME=MARKER-2-460></A>
<LI>Don't manipulate the Memory Manager's private data structures, including block headers for both relocatable and nonrelocatable blocks, zone headers, and any unused master pointers. The sizes and formats of some of these structures have changed.<A NAME=MARKER-2-461></A><A NAME=MARKER-2-462></A><A NAME=MARKER-2-463></A>
<LI>Don't access any system global variables maintained by the Memory Manager. Whenever possible, use the documented application programming interface (such <BR>as the <CODE>SetApplLimit</CODE> and <CODE>SetGrowZone</CODE> procedures) to avoid manipulating <BR>those variables.<A NAME=MARKER-2-464></A><A NAME=MARKER-2-466></A>
<LI>Don't modify free blocks of data or rely on the integrity of any data in free blocks. The new Memory Manager assumes control of all unallocated memory in your heap and may overwrite any information in free blocks.<A NAME=MARKER-2-467></A>
<LI>Don't close a resource file without first detaching any resources in that file that you want to continue using. To detach a resource, call the <CODE>DetachResource</CODE> procedure.<A NAME=MARKER-2-468></A><A NAME=MARKER-2-469></A><A NAME=MARKER-2-470></A>
<LI>Don't use fake handles or pointers. You should call Memory Manager routines <BR>only on blocks that were created by the Memory Manager itself. Remember that <BR>the Memory Manager is fundamentally a heap managing tool. You should not, <BR>for example, call <CODE>DisposePtr</CODE> on data in your stack or in your application global variable space.<A NAME=MARKER-2-471></A><A NAME=MARKER-2-472></A>
<LI>Don't call Memory Manager routines at interrupt time. Except for the <CODE>BlockMove</CODE> procedure, all Memory Manager routines either move memory or manipulate system global variables. These operations must not occur at interrupt time.<A NAME=MARKER-2-3></A><A NAME=MARKER-2-372></A><A NAME=MARKER-2-374></A>
<LI>Make sure to flush the instruction cache whenever necessary. Because it's much harder to treat data as executable code in the PowerPC environment, the new Memory Manager flushes the instruction cache only when it moves blocks around in memory.<A NAME=MARKER-2-373></A><A NAME=MARKER-2-477></A>
<LI>Don't make assumptions about the relative positions of the stack and heap in your application partition. You should adjust the size of the stack, if necessary, by calling <CODE>GetApplLimit</CODE> and <CODE>SetApplLimit</CODE>.<A NAME=MARKER-2-371></A><A NAME=MARKER-10-5></A><P>
</UL>
 To repeat, you shouldn't encounter any of these problems if you've used the routines and programming techniques documented in <I><A HREF="../Memory/Memory-2.html">Inside Macintosh: Memory</A>.<A NAME=MARKER-2-90></A></I><P>
<A NAME=HEADING16-38></A>
<H2>Performance Tuning</H2>
 <A NAME=MARKER-2-375></A>Once you've gotten your application or other software to execute correctly on a PowerPC processor-based Macintosh computer, you'll want to spend some time <BR>tuning it for maximum performance. Many factors affect the speed at which code executes, including<P>
<UL>
<LI>how often you cause mode switches from one environment to another
<LI>how you pass parameters to subroutines
<LI>whether you use compiler-specific optimizations<P>
</UL>
 The easiest way to increase the performance of your application is to use the compiler's optimization capabilities. It's not uncommon for compiler speed optimizations to improve your code's execution by as much as 50 percent. See the book <I>Macintosh on PowerPC C Compiler</I> for more information on compiler optimizations.<P>
 This section provides some preliminary discussion of the overhead associated with mode switches and parameter passing. In general, you'll need to combine the informa-<BR>tion presented here with empirical observations you obtain when using a performance-<BR>measurement tool, such as the Adaptive Sampling Profiler (ASP) built into the debugger. See the book <I>Macintosh Debugger Reference</I> for complete information about using the ASP.<P>
<A NAME=HEADING16-45></A>
<H3>Mode Switches</H3>
 <A NAME=MARKER-10-378></A>You've already learned (in <A HREF=#MARKER-9-423>"Patches" on page 1-66</A>) that it's important to avoid mode switches whenever possible. The Mixed Mode Manager requires the equivalent of approximately fifty 680x0 instructions to switch from one environment to another. <BR>As a result, you might want to minimize the number of times your code invokes a <BR>mode switch.<P>
 Some mode switches are entirely avoidable. For example, if you need to patch a system software routine, you can avoid at least some mode switching by installing a fat patch <BR>(a patch that includes both 680x0 and PowerPC versions of the patching code). Similarly, if your application calls any resource-based code (for example, dynamically loadable filters), you can create <B>fat resources</B>: code resources that include both 680x0 and PowerPC versions of the executable code. Once again, the Mixed Mode Manager will select the code that minimizes mode switching.<A NAME=MARKER-2-483></A><A NAME=MARKER-2-484></A><A NAME=MARKER-2-485></A><A NAME=MARKER-2-486></A><P>
 Some mode switches, however, are entirely unavoidable. Any time your PowerPC application calls a system software routine that has not yet been ported to use the native PowerPC instruction set, the Mixed Mode Manager must switch to the 680x0 environ-<BR>ment to execute the routine and then switch back to the PowerPC environment to allow your application to continue. This sometimes means that parts of your application might execute more slowly on a PowerPC processor-based Macintosh computer than on a 680x0-based Macintosh computer.<P>
 A good example of this behavior concerns calling Event Manager routines, which remain as 680x0 code in the first release of the system software for PowerPC processor-based Macintosh computers. Suppose that during a lengthy calculation your application calls <CODE>WaitNextEvent</CODE> or <CODE>EventAvail</CODE> to scan the event queue for a Command-period event (which typically indicates that the user wants to cancel the lengthy operation) and to give time to other applications. Each time you call the Event Manager, two mode switches occur (from your code to the emulated code and back). Moreover, because your code is native PowerPC code, it executes more quickly between Event Manager calls than it did in the 680x0 environment. The result is that your application is switching modes more often than it absolutely has to.<P>
 Although you cannot avoid the mode switches entirely when calling the Event Manager, you can lessen the overall impact of those switches on your application's performance by doing more work between successive Event Manager calls. One simple way to do this is to perform more than one iteration of a loop between calls to <CODE>WaitNextEvent</CODE>. Another simple way is to call <CODE>WaitNextEvent</CODE> only after a certain amount of time has elapsed. <A HREF=#MARKER-9-489>Listing 1-15</A> shows how you can rewrite a part of your main event loop to incorporate this feature.<A NAME=MARKER-2-487></A><A NAME=MARKER-2-95></A><P>
<B>Listing 1-15  <A NAME=MARKER-9-489></A>Waiting to call the <CODE>WaitNextEvent</CODE> function</B><P>
<PRE>
static unsigned long    gWNEDelay = 5;    /*adjust this value as needed*/

void MainEventLoop(void)
{
   EventRecord       myEvent;
   unsigned long     nextTimeToCheckForEvents = 0;
   
   while (!gDone) {
      if ((gWNEDelay == 0) || (TickCount() &gt; nextTimeToCheckForEvents)) {
         nextTimeToCheckForEvents = TickCount() + gWNEDelay;
         if (WaitNextEvent(everyEvent, &amp;myEvent, 
                                             MyGetSleep(), (RgnHandle) nil))
            HandleEvent(&amp;myEvent);
      }
      DoIdle();
   }
}
</PRE>
 As you can see, this code continues in the event loop only when a certain amount of time has elapsed. This method of adjusting the frequency of calls to WaitNextEvent works on any available Macintosh computer and doesn't require any conditional compilation.<A NAME=MARKER-10-108></A><A NAME=MARKER-2-491></A><A NAME=MARKER-2-492></A><P>
<A NAME=HEADING16-54></A>
<H3>Routine Parameters</H3>
 <A NAME=MARKER-2-400></A>You've already learned (in <A HREF=PPCSoftware-15.html#MARKER-9-315>"Parameter Passing" beginning on page 1-47</A>) that PowerPC compilers attempt to pass as many parameters as possible in the processor's registers, thereby minimizing the number of memory accesses that are required for a routine call. You can, however, help the compiler minimize memory accesses by following a few simple guidelines:<P>
<UL>
<LI>Use function prototypes. A compiler can generate more efficient code if you include prototypes for any functions that accept floating-point parameters. The compiler then knows to use the floating-point registers to store those parameters. If no function prototype is available for a function taking floating-point parameters, the compiler needs to pass the same information in both general-purpose and floating-point parameters. (For more information, see the description of PowerPC calling conventions beginning on <A HREF=PPCSoftware-15.html#MARKER-9-315>page 1-47</A>.)<A NAME=MARKER-2-494></A>
<LI>Put floating-point parameters at the end of the parameter list. A PowerPC compiler reserves space for floating-point parameters not only in the floating-point registers but also either in the general-purpose registers or in a stack frame. (This is necessary to support passing floating-point parameters to a function for which no prototype <BR>is available.) It's best to let any non-floating-point parameters use the available general-purpose register, so you should move floating-point parameters to the end of the routine's parameter list.<A NAME=MARKER-2-495></A><A NAME=MARKER-2-496></A>
<LI>Minimize the use of variable parameter lists. For many reasons, it's inefficient to <BR>use variable parameter lists in the PowerPC environment. Use them only when absolutely necessary.<A NAME=MARKER-2-497></A><A NAME=MARKER-2-498></A><P>
</UL>
<DL>
<DT><B>IMPORTANT</B>
<DD>These floating-point parameter-passing optimizations are highly dependent on specific features of the PowerPC run-time environment. You should implement these guidelines only in those parts of your code where maximum efficiency is necessary.<EM></EM><A NAME=MARKER-2-399></A><A NAME=MARKER-2-500></A>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
 <A NAME=MARKER-2-501></A><A NAME=MARKER-2-502></A><P>

</BLOCKQUOTE>
<HR>
<center>
<A HREF="PPCSoftware-15.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="PPCSoftware-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="PPCSoftware-86.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="PPCSoftware-17.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="PPCSoftware-3.html">&copy; Apple Computer, Inc.</A><br>3 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>  
