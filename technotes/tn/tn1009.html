<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><HTML><!-- Template 03-24-01 --><!--Includes revisions to code listings--><HEAD><LINK REL="stylesheet" HREF="../../adcstyle.css" TYPE="text/css"><LINK REL="stylesheet" HREF="../../style.css" TYPE="text/css"><title>Technical Note TN1009: On Multiple Inheritance &amp; HandleObjects</title>    <meta name="keywords" content="Mac OS 8 MPW C++ multiple inheritance handle objects vtables">    <meta name="Description" content="Technical Note TN1009: This Technical Note  provides a briefoverview of how multiple inheritance is implemented in MPWC++. Included is an explanation of HandleObjects, how theyare used, and the restrictions for use of a HandleObjectin a program."><meta name="categories" content="Platforms and Tools"><meta name="week-posted" content="Sep 25, 1995 - Oct 6, 1995"><LINK REL="stylesheet" HREF="../../css/adcstyle.css" TYPE="text/css"><script language="JavaScript" type="text/javascript" src="../../js/adc.js"></script></HEAD><BODY BGCOLOR="#FFFFFF"><a name="//apple_ref/doc/uid/DTS10002851" title="On Multiple Inheritance & HandleObjects"></a><A NAME="top"></A><!-- begin_header_information --><!--#include virtual="/adcnavbar" --><p><a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../technicalnotes/index.html">Technical Notes</a> &gt; <a href="../../technicalnotes/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../technicalnotes/LegacyTechnologies/idxTools-date.html">Tools</a> &gt; </p><div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="../../referencelibrary/Java/idxTools-date.html" target="_blank">Reference Library > Tools</a></li>
	</ul>
</div>




</div></div></div><!-- end_header_information --><!-- bottom_of_header_marker_comment --><!-- top_of_titles_marker_comment --><CENTER><table width="600" cellpadding="0" cellspacing="0" border="0">
<tr><td align="left" scope="row">
<h1>
<div id="pagehead">Technical Note TN1009</div>
<div id="pageheadsub">On Multiple Inheritance &amp; HandleObjects</div>
</h1>
</td></tr></table></CENTER><!-- bottom_of_titles_marker_comment --><CENTER><TABLE BORDER=0 CELLSPACING=1 WIDTH=600><TR><td align="left">         <!-- begin_header_box --><table width="600" cellpadding="0" cellspacing="0" border="0">    <tr>        <td width=300 valign="top" align=left scope="row">            <table border="0" width="300" cellpadding="0" cellspacing="0">			<tr>                        <td width=300 align=left> <img src="images/tnmenutop.gif" alt="" align="bottom" width=300 height=7></td>                </tr>                <tr bgcolor="#e6e6e6">                    <td background="images/tnmenubody.gif" width=300 align=left>                        <span id="menutitle">                            CONTENTS                             <BR>                            <BR>                        </span>                    </td>                </tr>                <tr bgcolor="#e6e6e6">                    <td background="images/tnmenubody.gif" width=300 align=left>					<!-- begin_toc --><p id="menutext"><A HREF = "#RTFToC1">About HandleObjects</a><br><br><A HREF = "#RTFToC2">Using HandleObjects</a><br><br><A HREF = "#RTFToC3">Managing Many Handles</a><br><br><A HREF = "#Summary">Summary</a><br><br> <A HREF="#References">References</A><br><br><A HREF="#Downloads">Downloadables</A></P>                   <!-- end_toc -->                  </td>                </tr>                 <tr>                    <td width=300 align=left scope="row">                        <img src="images/tnmenubottom.gif" alt="" width=300 height=16>                    </td>                </tr>            </table>        </td>        <td width=300 valign="top" align=left><!-- begin_intro_text --><P id = "introtext">This Technote answers a common question about MPW C++: Why doesn't <code>HandleObject</code> support multiple inheritance? To answer that question, this Note provides a brief overview of how multiple inheritance is implemented in MPW C++.</p><P id = "introtext">This Technote is addressed primarily to C++ developers who are concerned about memory fragmentation.</p><!-- end_intro_text --><!-- begin_date --><h3 align=center>&nbsp;[Oct 1 1995]</h3><!-- end_date -->                </TD>             </TR>          </TABLE>          <!-- end_table_box --> <BR><BR>          <hr width=500 align=center>          <BR><BR>                   <!-- begin_content --><a name="RTFToC1"></a><h2>About HandleObjects</h2><P>Beginning with Version 3.0, MacApp switched the focus of its object memory management from a handle-based system to a pointer-based system. This change substantially improved execution speed, specifically because pointer-based objects avoid compaction delays.</p><P>Accordingly, Apple recommends using <code>malloc</code> or the standard <code>operator new</code> for allocating small objects.</p><P>For large objects, handles have some significant advantages. For one thing, they minimize RAM usage by avoiding fragmentation. Also, some developers need to continue using handles in their existing code.</p><h3>Handles under Future Versions of Mac OS</h3><P>Plans for future versions of Mac OS call for handles to become lessimportant. An improved implementation of virtual memory (VM) will alleviate the effects of fragmentation for objects larger than the size of a VM page (4K bytes) while increasing the duration of heap compaction due to page-swapping between disk and RAM.</p><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>The items called "vtable" in this Technote are actually pointers to the vtable, which resides elsewhere in memory. The more recent reference <cite>The Annotated C++ Reference Manual</cite> uses the term "vptr".</P></TD></TR></TABLE></CENTER><BR><a name="RTFToC2"></a><h2>Using HandleObjects </h2><P>MPW C++ contains several extensions to standard C++ for supporting Macintosh programming. One such extension is the built-in class <code>HandleObject</code>. Objects of any class descended from <code>HandleObject</code> are allocated as handles in the heap. Your program may refer to one of these objects as if it were a simple pointer; the compiler takes care of the extra dereference required.</p><P>A <code>HandleObject</code> is useful in Macintosh programming for the same reason that a handle is useful. The use of handles helps prevent heap fragmentation, which is critical on Macintosh computers that use small amounts of memory. If you need to write an app that is small -- i.e., less than 100K -- you need to consider using <code>HandleObjects</code>.</p><P>The nature of <code>HandleObject</code> imposes some restrictions, however, on how you can use it in a program. These restrictions include:</p><ul><li>heap allocation</li><li>handle manipulation </li><li>multiple inheritance.</li></ul><h3>Heap Allocation</h3><P>Because each object is allocated as a handle, all objects must be allocated on the heap. ("Native" C++ objects can be allocated on the stack or in the static space as well.) Consequently, you always declare variables and parameters as pointers to an object of the class. For example:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>class TSample: public HandleObject {public:    ...    long  fData;};TSample  *aSampleObject; // LegalTSample anotherSample; // Results in a compile-time error</pre>	</TD></TR></TABLE></CENTER><P>The error message the compiler generates in this case is:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>Can't declare a handle/pascal object: anotherSample</pre>	</TD></TR></TABLE></CENTER><P>At first, this message might seem strange because the last two lines seem to both declare objects. Actually, the first declaration is of a pointer to an object, not of the object itself.</p><h3>Handle Manipulation</h3><P>The second restriction is that you must follow the usual rules for manipulating handles. In particular, you have to be careful about creating pointers to <code>HandleObject</code> data members, since the object might move if the heap is compacted. If you write:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>long *x = &amp; (aSampleObject -&gt; fData);</pre>	</TD></TR></TABLE></CENTER><P>then x becomes "stale," i.e., it has a valid address but doesn't point to where the programmer intends, if the object moves. The solution is to lock the object if there is a possibility that the heap may be compacted. Objects of <code>HandleObject</code> are allocated with a call to <code>NewHandle</code>, so you can use <code>HLock</code> and <code>HUnlock</code> (along with an appropriate type cast) to lock and unlock the object.</p><h3>Multiple Inheritance</h3><P>The third restriction is that you cannot use multiple inheritance with a <code>HandleObject</code>. The reason behind this restriction is not obvious. To understand the reason, you must look at the implementation of multiple inheritance.</p><h4>Implementing Multiple Inheritance</h4><P>To understand how multiple inheritance is implemented, one needs a simple example. Suppose you define two classes as follows:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>class TBaseA {public:    virtual void SetVarA(long newValue);            long fVarA;    ...};class TBaseB {public:    virtual void SetVarB(long newValue);            long fVarB;    ...};</pre>	</TD></TR></TABLE></CENTER><P>If you were to look at objects of these classes (see Figure 1), you would find that in each case the object storage would contain four bytes for the C++ virtual table (<code>vtable</code>) and four bytes for the data member. Any code that accesses the data members (for example, <code>TBaseB::SetVarB</code>) would do so using a fixed offset from the start of the object. (In the particular version of C++, this offset was 0; your offset may vary.) Figure 1 shows the layout of <code>TBaseA</code> and <code>TBaseB</code> objects.</p><CENTER><TABLE BORDER=0 ALIGN=CENTER CELLPADDING=0><TR><td width=200 valign=top align=left><img src="images/tn1009_003.gif" alt="" width=127 height=100></td><td width=200 valign=top align=left><img src="images/tn1009_004.gif" alt="" width=127 height=100> </td></tr></table></center><CENTER><P><B>Figure 1.</b> Layout of TBaseA and TBaseB objects</p></center><P>Now suppose you define another class:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>class TDerived: public TBaseA, public TBaseB {public:    virtual void SetDerivedVar(long newValue);            long fDerivedVar;    ...};</pre>	</TD></TR></TABLE></CENTER><P>In this case, an object of <code>TDerived</code> has the following layout, as shown in Figure 2:</p><CENTER><img src="images/tn1009_005.gif" alt="" width=148 height=208><br><P><b>Figure 2.</b> Layout of TDerived object</p></center><P>This is what you would expect. <code>TDerived</code> inherits from both <code>TBaseA</code> and <code>TBaseB</code>, and therefore objects of <code>TDerived</code> contain a part that is a <code>TBaseA</code> and a part that is a <code>TBaseB</code>. In addition, the virtual table <code>vtableDerived</code> includes the tables for both <code>TBaseA</code> and <code>TDerived</code>.</p><P><code>TDerived</code> also inherits the virtual member functions defined in <code>TBaseA</code> and <code>TBaseB</code>. Suppose you wanted to call <code>SetVarB</code>, using a <code>TDerived</code> object. The code for <code>SetVarB</code> expects to be passed a pointer to a <code>TBaseB</code> object (all member functions are passed a pointer to an appropriate object as an implicit parameter), and refers to <code>fVarB</code> by a fixed offset from that pointer. Therefore, to call <code>SetVarB</code> using a <code>TDerived</code> object, C++ passes a pointer to the middle of the object; specifically it passes a pointer to the part of the object that represents a <code>TBaseB</code>.</p><P>This gives you a very basic idea of how C++ implements multiple inheritance. For more details, read "Multiple Inheritance for C++" by Bjarne Stroustrup in <cite>Proceedings EUUG Spring 1987 Conference</cite>, Helsinki.</p><h4>Impact on HandleObjects</h4><P>Each member function of a <code>HandleObject</code> class expects to be passed a handle to the object, instead of a pointer; when multiple inheritance is used, the compiler sometimes has to pass a pointer to the middle of the object.</p><P>Pointers into the middle of an object, even though (and especially because) they are implicit in this case, nevertheless present the same problem as pointers to object data members (as described earlier). The object's handle could be moved during heap compaction, rendering the pointer "stale."</p><P>Designing a new implementation of multiple inheritance that is compatible with a <code>HandleObject</code>, as well as the rest of C++, is a big undertaking. For that reason, it is unlikely this restriction will disappear in the future. There are, however, two alternatives to consider:</p><h5>Ignore Fragmentation</h5><P>For the majority of today's machines and applications, the main reason to use <code>HandleObject</code> is for purposes of compatibility with code that expects handle objects. However, another valid reason is to reduce the chance of fragmentation that would result from using non-relocatable blocks.</p><P>But even in applications for which fragmentation would otherwise be a critical concern, memory allocation patterns may be very predictable; fragmentation is less of an issue when all allocated blocks are of similar sizes.</p><h5>Abandoning Multiple Inheritance</h5><P>The other alternative is to give up multiple inheritance. In most cases, this isn't as difficult as it sounds. The typical way you would do this is with a form of delegation. For example, you could rewrite the class <code>TDerived</code> as:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>class TSingleDerived: public TBaseA {public:    virtual void SetDerivedVar(long newValue);            void SetBaseB(long newValue);            long fDerivedVar;            TBaseB fBaseBPart;    ...};</pre>	</TD></TR></TABLE></CENTER><P>In this case <code>TSingleDerived</code> inherits only from <code>TBaseA</code>, but includes an object of <code>TBaseB</code> as an data member. It also implements the virtual member function <code>SetBaseB</code> to call the function by the same name in the <code>TBaseB</code> class. (In effect, <code>TSingleDerived</code> delegates part of its implementation to <code>TBaseB</code>.) </p><P>There are advantages and disadvantages to this approach. The advantage is that it requires only single inheritance, yet you can still reuse the implementation of <code>TBaseB</code>. The disadvantage is that <code>TSingleDerived</code> is not a sub-class of <code>TBaseB</code>, which means that an object of <code>TSingleDerived</code> cannot be used in a situation that requires a <code>TBaseB</code>. Also, <code>TSingleDerived</code> has to define a member function that corresponds to each function in <code>TBaseB</code>. (You can, however, define these functions as inline and non-virtual, which eliminates any run-time overhead.)</p><h4>Caveat</h4><p>You should realize that the multiple inheritance implementation described here costs some extra space, compared to a simpler implementation that does not support multiple inheritance (e.g., the implementation used for a <code>HandleObject</code>). Each <code>vtable</code> is twice as large, and each virtual member function takes about 24 bytes, compared to 14. This is true even if you do not take advantage of multiple inheritance. For this reason, MPW C++ also contains a built-in class called <code>SingleObject</code>, whose objects can be allocated in the same way as normal C++ objects, but which only supports single inheritance.</p><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>The third class built into MPW C++, <code>PascalObject</code>, uses Object Pascal's run-time implementation, which takes the least amount of space, but the most execution time.</P></TD></TR></TABLE></CENTER><BR><a name="RTFToC3"></a><h2>Managing Many Handles</h2><p>If you're writing large, high-end applications, you may need to manage thousands of objects. The Macintosh Memory Managers slow down when required to deal with so many handles. If you're dealing with many handles, here are some important points to keep in mind:</p><ul><li>Keep the objects locked except just after calling <code>WaitNextEvent</code>. Then, if some predetermined amount of time (perhaps one minute, for example) has elapsed since the user interacted with the application, unlock everything and compact the heap.</li><li>When you compact the heap, do it incrementally, i.e., do a little bit of compaction, then check to see if you have used up more than 50,000 microseconds in the process. When you have used up that much time, call <code>EventAvail</code> to check if there is now an event that needs processing. If such an event has arrived, return to your main event loop to process it.</li><li>Because the Modern Memory Manager's <code>CompactMem</code> routine really compacts the entire application heap even if you ask it to compact just a little bit of it, use <code>NewPtr</code> instead. Ask for a moderate-sized block (e.g. "<code>NewPtr(40000)</code>"), and check the time to see if you need to call <code>EventAvail</code>. Then ask for another block.</li><li>After compacting memory with <code>NewPtr</code>, dispose of the compaction pointers, and lock your handles. </li><li>When you can't allocate a pointer, you're done.</li></ul><P>This approach will cause purgeable handles to get purged, so if you don't want that to happen, create and manage a list of purgeable handles. Call <code>HNoPurge</code> on this list prior to a <code>NewPtr</code>-based compaction, then call <code>HPurge</code> on it after the compaction.</p><a name="Summary"></a><h2>Summary</h2><P>You cannot use a <code>HandleObject</code> with multiple inheritance because of the way multiple inheritance is implemented in MPW C++. Your alternatives are to give up one or the other: You can either use native C++ objects and let the objects fall where they may, or give up multiple inheritance and use a form of delegation.</p><A NAME="References"></a><H2>References</h2><p>MPW C++ Reference Manual</p><p>"Multiple Inheritance for C++," Bjarne Stroustrup, <cite>Proceedings EUUG Spring 1987 Conference</cite>, Helsinki.</p><p>Ellis, Margaret A. and Bjarne Stroustrup, <cite>The Annotated C++ Reference Manual</cite>, (a.k.a "<cite>ARM</cite>"), Addison-Wesley, 1990, ISBN 0-201-51459-1, pp.217-237</p><a name="Changes"></a><H2>Change History</h2><TABLE BORDER=0 CELLPADDING=3 WIDTH=544>            <TR>               <td width=100 align=left>                  <P ALIGN=center>01-August-1990</P>               </TD>               <td align="left">                  <P>Originally written.</P>               </TD>            </TR><TR>               <td width=100 align=left>                  <P ALIGN=center>01-July-1995</P>               </TD>               <td align="left">                  <P>Revised to include information on managing multiple handles.</P>               </TD>            </TR><TR>               <td width=100 align=left>                  <P ALIGN=center>01-October-1995</P>               </TD>               <td align="left">                  <P>Updated with new information, then retired.</P>               </TD>            </TR></table><BR><P><A HREF="#top">Back to top</A></P>                           <A NAME=Downloads></A>                  <H2>Downloadables</H2>                  <TABLE BORDER=0 CELLPADDING=3 WIDTH="100%">            <TR>               <td width=50 align=left>                  <P ALIGN=center><img src="images/acrobatsmall.gif" width=22 height=23 align=middle alt="Acrobat gif"></P>               </TD>               <td align="left">                  <P>Acrobat version of this Note (92K)</P>               </TD>               <td width=60 align=left>                  <P><A HREF="pdf/tn1009.pdf">Download</A></P>               </TD>            </TR>         </TABLE>         <BR><BR><P><A HREF="#top">Back to top</A></P></TD></TR></TABLE></CENTER><!-- end_content --><!-- begin_footer_information -->	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/technotes/tn/tn1009.html%3Fid%3DDTS10002851-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/technotes/tn/tn1009.html%3Fid%3DDTS10002851-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/technotes/tn/tn1009.html%3Fid%3DDTS10002851-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>
<!--#include virtual="/includes/footer"--><!-- end_footer_information --></BODY></HTML>