<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>File System Events Programming Guide: Using the File System Events API</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Using the File System Events API"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP40005289-CH4" title="Using the File System Events API"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../index.html#//apple_ref/doc/uid/TP30000440-TP30000422" target="_top">Darwin</a> &gt; <a href="../../../FileManagement-date.html#//apple_ref/doc/uid/TP30000440-TP30000422-TP30000448" target="_top">File Management</a> &gt; <a href="../Introduction/Introduction.html#//apple_ref/doc/uid/TP40005289-CH1-DontLinkElementID_15">File System Events Programming Guide</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../TechnologyOverview/TechnologyOverview.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../FileSystemEventSecurity/FileSystemEventSecurity.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP40005289-CH4-SW4" title="Using the File System Events API"></a><h1>Using the File System Events API</h1><p>The File System Events API consists of several distinct groups of functions. You can obtain general information about volumes and events by using functions that begin with <code>FSEvents</code>. You can create a new event stream, perform operations on the stream, and so on using functions that begin with <code>FSEventStream</code>.</p><p>The life cycle of a file system events stream is as follows:</p><ol class="ol"><li class="li"><p>The application creates a stream by calling <code><a href="../../../Reference/FSEvents_Ref/FSEvents/CompositePage.html#//apple_ref/c/func/FSEventStreamCreate" target="_top">FSEventStreamCreate</a></code> or <code><a href="../../../Reference/FSEvents_Ref/FSEvents/CompositePage.html#//apple_ref/c/func/FSEventStreamCreateRelativeToDevice" target="_top">FSEventStreamCreateRelativeToDevice</a></code>. The stream initially has a retain count of 1. If desired, you can increment this count by calling <code><a href="../../../Reference/FSEvents_Ref/FSEvents/CompositePage.html#//apple_ref/c/func/FSEventStreamRetain" target="_top">FSEventStreamRetain</a></code>.</p></li><li class="li"><p>The application schedules the stream on the run loop by calling <code><a href="../../../Reference/FSEvents_Ref/FSEvents/CompositePage.html#//apple_ref/c/func/FSEventStreamScheduleWithRunLoop" target="_top">FSEventStreamScheduleWithRunLoop</a></code>.</p></li><li class="li"><p>The application tells the file system events daemon to start sending events by calling <code><a href="../../../Reference/FSEvents_Ref/FSEvents/CompositePage.html#//apple_ref/c/func/FSEventStreamStart" target="_top">FSEventStreamStart</a></code>.</p></li><li class="li"><p>The application services events as they arrive. The API posts events by calling the callback function specified in step 1.</p></li><li class="li"><p>The application tells the daemon to stop sending events by calling <code><a href="../../../Reference/FSEvents_Ref/FSEvents/CompositePage.html#//apple_ref/c/func/FSEventStreamStop" target="_top">FSEventStreamStop</a></code>.</p></li><li class="li"><p>If the application needs to restart the stream, go to step 3.</p></li><li class="li"><p>The application unschedules the event from its run loop by calling <code><a href="../../../Reference/FSEvents_Ref/FSEvents/CompositePage.html#//apple_ref/c/func/FSEventStreamUnscheduleFromRunLoop" target="_top">FSEventStreamUnscheduleFromRunLoop</a></code>.</p></li><li class="li"><p>The application invalidates the stream by calling <code><a href="../../../Reference/FSEvents_Ref/FSEvents/CompositePage.html#//apple_ref/c/func/FSEventStreamInvalidate" target="_top">FSEventStreamInvalidate</a></code>.</p></li><li class="li"><p>The application releases its reference to the stream by calling <code><a href="../../../Reference/FSEvents_Ref/FSEvents/CompositePage.html#//apple_ref/c/func/FSEventStreamRelease" target="_top">FSEventStreamRelease</a></code>.</p></li></ol><p>These steps are explained in more detail in the sections that follow.</p>
<!-- This template is being used for both PDF and HTML. -->

    
    <h4>In this section:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="UsingtheFSEventsFramework.html#//apple_ref/doc/uid/TP40005289-CH4-DontLinkElementID_10">Adding Include Directives</a>
				
			<br/>
			
        
			
			
				<a href="UsingtheFSEventsFramework.html#//apple_ref/doc/uid/TP40005289-CH4-DontLinkElementID_11">Creating an Event Stream</a>
				
			<br/>
			
        
			
			
				<a href="UsingtheFSEventsFramework.html#//apple_ref/doc/uid/TP40005289-CH4-SW1">Handling Events</a>
				
			<br/>
			
        
			
			
				<a href="UsingtheFSEventsFramework.html#//apple_ref/doc/uid/TP40005289-CH4-DontLinkElementID_12">Using Persistent Events</a>
				
			<br/>
			
        
			
			
				<a href="UsingtheFSEventsFramework.html#//apple_ref/doc/uid/TP40005289-CH4-SW2">Building a Directory Hierarchy Snapshot</a>
				
			<br/>
			
        
			
			
				<a href="UsingtheFSEventsFramework.html#//apple_ref/doc/uid/TP40005289-CH4-DontLinkElementID_13">Cleaning Up</a>
				
			<br/>
			
        
			
			
				<a href="UsingtheFSEventsFramework.html#//apple_ref/doc/uid/TP40005289-CH4-SW3">Special Considerations for Per-Device Streams</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP40005289-CH4-DontLinkElementID_10" title="Adding Include Directives"></a><h2>Adding Include Directives</h2><p>Before you use the file system event stream API, you must include the Core Services framework as follows:</p><div class="codesample"><table><tr><td scope="row"><pre>#include &lt;CoreServices/CoreServices.h><span></span></pre></td></tr></table></div><p>When you compile, you must include the Core Services Framework by adding it to your target in Xcode or by adding the flag <code>-framework CoreServices</code> to your linker flags on the command line or in a Makefile.</p><a name="//apple_ref/doc/uid/TP40005289-CH4-DontLinkElementID_11" title="Creating an Event Stream"></a><h2>Creating an Event Stream</h2><p>The file system events API supports two types of event streams: per-disk event streams and a per-host event streams. Before you can create a stream, you must decide which type of stream to create: a per-host event stream or a per-disk event stream. You can create these streams by calling the functions <code><a href="../../../Reference/FSEvents_Ref/FSEvents/CompositePage.html#//apple_ref/c/func/FSEventStreamCreate" target="_top">FSEventStreamCreate</a></code> and <code><a href="../../../Reference/FSEvents_Ref/FSEvents/CompositePage.html#//apple_ref/c/func/FSEventStreamCreateRelativeToDevice" target="_top">FSEventStreamCreateRelativeToDevice</a></code>, respectively.</p><p>A per-host event stream consists of events whose IDs are increasing with respect to other events on that host. These IDs are guaranteed to be unique with one exception: if additional disks are added from another computer that was also running Mac OS X v10.5 or later, historical IDs may conflict between these volumes. Any new events will automatically start after the highest-numbered historical ID for any attached drive.</p><p>A per-disk event stream, by contrast, consists of events whose IDs are increasing with respect to previous events on that disk. It does not have any relationship with other events on other disks, and thus you must create a separate event stream for each physical device that you wish to monitor.</p><p>In general, if you are writing software that requires persistence, you should use per-disk streams to avoid any confusion due to ID conflicts. By contrast, per-host streams are most convenient if you are monitoring for changes in a directory or tree of directories during normal execution, such as watching a queue directory.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40005289-CH4-DontLinkElementID_17" title="Note"></a><p><strong>Note:</strong>&nbsp;Because disks can be modified by computers running earlier versions of Mac OS X (or potentially other operating systems), you should treat the events list as advisory rather than a definitive list of all changes to the volume. If a disk is modified by a computer running a previous version of Mac OS X, the historical log is discarded.</p>For example, backup software should still periodically perform a full sweep of any volume to ensure that no changes fall through the cracks.</p></div><p>If you are monitoring files on the root file system, either stream mechanism will behave similarly.</p><p>For example, the following snippet shows how to create an event stream:</p><div class="codesample"><table><tr><td scope="row"><pre>    /* Define variables and create a CFArray object containing<span></span></pre></td></tr><tr><td scope="row"><pre>       CFString objects containing paths to watch.<span></span></pre></td></tr><tr><td scope="row"><pre>     */<span></span></pre></td></tr><tr><td scope="row"><pre>    CFStringRef mypath = CFSTR("/path/to/scan");<span></span></pre></td></tr><tr><td scope="row"><pre>    CFArrayRef pathsToWatch = CFArrayCreate(NULL, (const void **)&amp;mypath, 1, NULL);<span></span></pre></td></tr><tr><td scope="row"><pre>    void *callbackInfo = NULL; // could put stream-specific data here.<span></span></pre></td></tr><tr><td scope="row"><pre>    FSEventStreamRef stream;<span></span></pre></td></tr><tr><td scope="row"><pre>    CFAbsoluteTime latency = 3.0; /* Latency in seconds */<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    /* Create the stream, passing in a callback, */<span></span></pre></td></tr><tr><td scope="row"><pre>    stream = FSEventStreamCreate(NULL,<span></span></pre></td></tr><tr><td scope="row"><pre>        &amp;myCallbackFunction,<span></span></pre></td></tr><tr><td scope="row"><pre>        callbackInfo,<span></span></pre></td></tr><tr><td scope="row"><pre>        pathsToWatch,<span></span></pre></td></tr><tr><td scope="row"><pre>        kFSEventStreamEventIdSinceNow, /* Or a previous event ID */<span></span></pre></td></tr><tr><td scope="row"><pre>        latency,<span></span></pre></td></tr><tr><td scope="row"><pre>        kFSEventStreamCreateFlagNone /* Flags explained in reference */<span></span></pre></td></tr><tr><td scope="row"><pre>    );<span></span></pre></td></tr></table></div><p>Once you have created an event stream, you must schedule it on your application’s run loop. To do this, call <code><!--a-->FSEventStreamScheduleWithRunLoop<!--/a--></code>, passing in the newly-created stream, a reference to your run loop, and a run loop mode. For more information about run loops, read <em><a href="../../../../CoreFoundation/Conceptual/CFRunLoops/index.html#//apple_ref/doc/uid/10000135i" target="_top">Run Loops</a></em>.</p><p>If you don’t already have a run loop, you will need to devote a thread to this task. After creating a thread using your API of choice, call <code><a href="../../../../CoreFoundation/Reference/CFRunLoopRef/Reference/reference.html#//apple_ref/c/func/CFRunLoopGetCurrent" target="_top">CFRunLoopGetCurrent</a></code> to allocate an initial run loop for that thread. Any future calls to <code><a href="../../../../CoreFoundation/Reference/CFRunLoopRef/Reference/reference.html#//apple_ref/c/func/CFRunLoopGetCurrent" target="_top">CFRunLoopGetCurrent</a></code> will return the same run loop.</p><p>For example, the following snippet shows how to schedule a stream, called <code>stream</code>, on the current thread’s run loop (not yet running):</p><div class="codesample"><table><tr><td scope="row"><pre>    FSEventStreamRef stream;<span></span></pre></td></tr><tr><td scope="row"><pre>    /* Create the stream before calling this. */<span></span></pre></td></tr><tr><td scope="row"><pre>    FSEventStreamScheduleWithRunLoop(stream, CFRunLoopGetCurrent(),         kCFRunLoopDefaultMode);<span></span></pre></td></tr></table></div><p>The final step in setting up an event stream is to call <code><!--a-->FSEventStreamStart<!--/a--></code>. This function tells the event stream to begin sending events. Its sole parameter is the event stream to start.</p><p>Once the event stream has been created and scheduled, if your run loop is not already running, you should start it by calling <code><a href="../../../../CoreFoundation/Reference/CFRunLoopRef/Reference/reference.html#//apple_ref/c/func/CFRunLoopRun" target="_top">CFRunLoopRun</a></code>.</p><a name="//apple_ref/doc/uid/TP40005289-CH4-SW1" title="Handling Events"></a><h2>Handling Events</h2><p>Your event handler callback must conform to the prototype for <code><a href="../../../Reference/FSEvents_Ref/FSEvents/CompositePage.html#//apple_ref/c/tdef/FSEventStreamCallback" target="_top">FSEventStreamCallback</a></code>. The parameters are described in the reference documentation for the <code>FSEventStreamCallback</code> data type.</p><p>Your event handler receives three lists: a list of paths, a list of identifiers, and a list of flags. In effect, these represent a list of events. The first event consists of the first entry taken from each of the arrays, and so on. Your handler must iterate through these lists, processing the events as needed.</p><p>For each event, you should scan the directory at the specified path, processing its contents as desired. Normally, you need to scan only the exact directory specified by the path. However, there are three situations in which this is not the case:</p><ul class="ul"><li class="li"><p>If an event in a directory occurs at about the same time as one or more events in a subdirectory of that directory, the events may be coalesced into a single event. In this case, you will receive an event with the <code><!--a target="_top" -->kFSEventStreamEventFlagMustScanSubDirs<!--/a--></code> flag set. When you receive such an event, you must recursively rescan the path listed in the event. The additional changes are not necessarily in an immediate child of the listed path.</p></li><li class="li"><p>If a communication error occurs between the kernel and the user-space daemon, you may receive an event with either the <code><!--a target="_top" -->kFSEventStreamEventFlagKernelDropped<!--/a--></code> or <code><!--a target="_top" -->kFSEventStreamEventFlagUserDropped<!--/a--></code> flag set. In either case, you must do a full scan of any directories that you are monitoring because there is no way to determine what may have changed.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40005289-CH4-DontLinkElementID_18" title="Note"></a><p><strong>Note:</strong>&nbsp;When an event is dropped, the <code><!--a target="_top" -->kFSEventStreamEventFlagMustScanSubDirs<!--/a--></code> flag is also set. Thus, it is not necessary to explicitly check for the dropped event flags when determining whether to perform a full rescan of a path. The dropped event flags are provided purely for informational purposes.</p></div></li><li class="li"><p>If the root directory that you are watching is deleted, moved, or renamed (or if any of its parent directories are moved or renamed), the directory may cease to exist. If you care about this, you should pass the flag <code><!--a target="_top" -->kFSEventStreamCreateFlagWatchRoot<!--/a--></code> when creating the stream. In this case, you will receive an event with the flag  <code><!--a target="_top" -->kFSEventStreamEventFlagRootChanged<!--/a--></code> and an event ID of zero (<code>0</code>). In this case, you must rescan the entire directory because it may not exist.</p><p>If you need to figure out where the directory moved, you should open the root directory with <code><a href="../../../Reference/ManPages/man1/open.1.html#//apple_ref/doc/man/1/open" target="_top">open(1)</a></code>, then pass <code>F_GETPATH</code> to <code><a href="../../../Reference/ManPages/man2/fcntl.2.html#//apple_ref/doc/man/2/fcntl" target="_top">fcntl(2)</a></code> to find its current path. See the manual page for <code><a href="../../../Reference/ManPages/man2/fcntl.2.html#//apple_ref/doc/man/2/fcntl" target="_top">fcntl(2)</a></code> for more information.</p></li><li class="li"><p>If the number of events approaches 2^64, the event identifier will wrap around. When this happens, you will receive an event with the flag <code><!--a target="_top" -->kFSEventStreamEventFlagEventIdsWrapped<!--/a--></code>. Fortunately, at least in the near term, this is unlikely to occur in practice, as 64 bits allows enough room for about one event per eraser-sized region on the Earth’s surface (including water) and would require about 2000 exabytes (2 million million gigabytes) of storage to hold them all. However, you should still check for this flag and take appropriate action if you receive it.</p></li></ul><p>As part of your handler, you may sometimes need to obtain a list of paths being watched by the current event stream. You can obtain that list by calling <code><a href="../../../Reference/FSEvents_Ref/FSEvents/CompositePage.html#//apple_ref/c/func/FSEventStreamCopyPathsBeingWatched" target="_top">FSEventStreamCopyPathsBeingWatched</a></code>.</p><p>Sometimes, you may wish to monitor where you are in the stream. You might, for example, choose to do less processing if your code is slipping significantly behind. You can find out the latest event included in the current batch of events by calling <code><a href="../../../Reference/FSEvents_Ref/FSEvents/CompositePage.html#//apple_ref/c/func/FSEventStreamGetLatestEventId" target="_top">FSEventStreamGetLatestEventId</a></code> (or by examining the last event in the list). You can then compare this with the value returned by <code><a href="../../../Reference/FSEvents_Ref/FSEvents/CompositePage.html#//apple_ref/c/func/FSEventsGetCurrentEventId" target="_top">FSEventsGetCurrentEventId</a></code>, which returns the highest numbered event in the system.</p><p>For example, the following code snippet shows a very simple handler.</p><div class="codesample"><table><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>void mycallback(<span></span></pre></td></tr><tr><td scope="row"><pre>    ConstFSEventStreamRef streamRef,<span></span></pre></td></tr><tr><td scope="row"><pre>    void *clientCallBackInfo,<span></span></pre></td></tr><tr><td scope="row"><pre>    size_t numEvents,<span></span></pre></td></tr><tr><td scope="row"><pre>    void *eventPaths,<span></span></pre></td></tr><tr><td scope="row"><pre>    const FSEventStreamEventFlags eventFlags[],<span></span></pre></td></tr><tr><td scope="row"><pre>    const FSEventStreamEventId eventIds[])<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    int i;<span></span></pre></td></tr><tr><td scope="row"><pre>    char **paths = eventPaths;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // printf("Callback called\n");<span></span></pre></td></tr><tr><td scope="row"><pre>    for (i=0; i&lt;numEvents; i++) {<span></span></pre></td></tr><tr><td scope="row"><pre>        int count;<span></span></pre></td></tr><tr><td scope="row"><pre>        /* flags are unsigned long, IDs are uint64_t */<span></span></pre></td></tr><tr><td scope="row"><pre>        printf("Change %llu in %s, flags %lu\n", eventIds[i], paths[i], eventFlags[i]);<span></span></pre></td></tr><tr><td scope="row"><pre>   }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><div class="notebox"><a name="//apple_ref/doc/uid/TP40005289-CH4-DontLinkElementID_19" title="Note"></a><p><strong>Note:</strong>&nbsp;If you passed the flag <code><!--a target="_top" -->kFSEventStreamCreateFlagUseCFTypes<!--/a--></code> when creating the stream, you should cast the <code>eventPaths</code> value to a <code><a href="../../../../CoreFoundation/Reference/CFArrayRef/Reference/reference.html#//apple_ref/c/tdef/CFArrayRef" target="_top">CFArrayRef</a></code> object.</p></div><a name="//apple_ref/doc/uid/TP40005289-CH4-DontLinkElementID_12" title="Using Persistent Events"></a><h2>Using Persistent Events</h2><p>One of the most powerful features of file system events is their persistence across reboots. This means that your application can easily find out what happened since a particular time or a particular event in the distant past. By doing so, you can find out what files have been modified even when your application is not running. This can greatly simplify tasks such as backing up modified files, checking for changed dependencies in multi-file projects, and so on.</p><p>To work with persistent events, your application should regularly store the last event ID that it processes. Then, when it needs to go back and see what files have changed, it only needs to look at events that occurred after the last known event. To obtain all events since a particular event in the past, you pass the event ID in the <code>sinceWhen</code> argument to <code><a href="../../../Reference/FSEvents_Ref/FSEvents/CompositePage.html#//apple_ref/c/func/FSEventStreamCreate" target="_top">FSEventStreamCreate</a></code> or <code><a href="../../../Reference/FSEvents_Ref/FSEvents/CompositePage.html#//apple_ref/c/func/FSEventStreamCreateRelativeToDevice" target="_top">FSEventStreamCreateRelativeToDevice</a></code>.]
[On a per-device basis, you can also easily use a timestamp to determine which events to include. To do this, you must first call <code><a href="../../../Reference/FSEvents_Ref/FSEvents/CompositePage.html#//apple_ref/c/func/FSEventsGetLastEventIdForDeviceBeforeTime" target="_top">FSEventsGetLastEventIdForDeviceBeforeTime</a></code> to obtain the last event ID <code>sinceWhen</code> argument to <code><a href="../../../Reference/FSEvents_Ref/FSEvents/CompositePage.html#//apple_ref/c/func/FSEventStreamCreateRelativeToDevice" target="_top">FSEventStreamCreateRelativeToDevice</a></code>.</p><p>On a per-device basis, you can also easily use a time stamp to determine which events to include. To do this, you must first call <code><a href="../../../Reference/FSEvents_Ref/FSEvents/CompositePage.html#//apple_ref/c/func/FSEventsGetLastEventIdForDeviceBeforeTime" target="_top">FSEventsGetLastEventIdForDeviceBeforeTime</a></code> to obtain the last event ID for that device prior to the specified time stamp. You then pass the resulting value to <code><a href="../../../Reference/FSEvents_Ref/FSEvents/CompositePage.html#//apple_ref/c/func/FSEventStreamCreateRelativeToDevice" target="_top">FSEventStreamCreateRelativeToDevice</a></code>. This is described further in <span class="content_text"><a href="UsingtheFSEventsFramework.html#//apple_ref/doc/uid/TP40005289-CH4-SW3">“Special Considerations for Per-Device Streams.”</a></span></p><p>When working with persistent events, a commonly-used technique is to combine file system event notifications with a cached “snapshot” of the metadata of files within the tree. This process is described further in <span class="content_text"><a href="UsingtheFSEventsFramework.html#//apple_ref/doc/uid/TP40005289-CH4-SW2">“Building a Directory Hierarchy Snapshot.”</a></span></p><a name="//apple_ref/doc/uid/TP40005289-CH4-SW2" title="Building a Directory Hierarchy Snapshot"></a><h2>Building a Directory Hierarchy Snapshot</h2><p>File system events tell you that something in a given directory changed. In some cases, this is sufficient—for example, if your application is a print or mail spooler, all it needs to know is that a file has been added to the directory.</p><p>In some cases, however, this is not enough, and you need to know precisely what changed within the directory. The simplest way to solve this problem is to take a snapshot directory hierarchy, storing your own copy of the state of the system at a given point in time. You might, for example, store a list of filenames and last modified dates, thus allowing you to determine which files have been modified since the last time you performed a backup.</p><p>You do this by iterating through the hierarchy and building up a data structure of your choice. As you cache this metadata, if you see changes during the caching process, you can reread the directory or directories that changed to obtain an updated snapshot. Once you have a cached tree of metadata that accurately reflects the current state of the hierarchy you are concerned with, you can then determine what file or files changed within a directory or hierarchy (after a file system event notification) by comparing the current directory state with your snapshot.</p><div class="importantbox"><a name="//apple_ref/doc/uid/TP40005289-CH4-DontLinkElementID_20" title="Important:"></a><p><strong>Important:</strong>&nbsp;To avoid missing changes, you must start monitoring the directory <em>before</em> you start scanning it. Because of the inherently non-deterministic latency in any notification mechanism on a multitasking operating system, it may not always be obvious whether the action that triggered an event occurred before or after a nested subdirectory was scanned. To guarantee that no changes are lost, it is best to always rescan any subdirectory that is modified during scanning rather than taking a time stamp for each subdirectory and trying to compare those time stamps with event time stamps.</p><p></p></div><p>Mac OS X provides a number of APIs that can make this easier. The <code><a href="../../../Reference/ManPages/man3/scandir.3.html#//apple_ref/doc/man/3/scandir" target="_top">scandir(3)</a></code> function returns an array of directory entries that you can quickly iterate through. This is somewhat easier than reading a directory manually with <code><a href="../../../Reference/ManPages/man3/opendir.3.html#//apple_ref/doc/man/3/opendir" target="_top">opendir(3)</a></code>, <code><a href="../../../Reference/ManPages/man3/readdir.3.html#//apple_ref/doc/man/3/readdir" target="_top">readdir(3)</a></code>, and so on, and is slightly more efficient since you will always iterate through the entire directory while caching anyway.</p><p>The binary tree functions <code><a href="../../../Reference/ManPages/man3/tsearch.3.html#//apple_ref/doc/man/3/tsearch" target="_top">tsearch(3)</a></code>,, <code><a href="../../../Reference/ManPages/man3/tfind.3.html#//apple_ref/doc/man/3/tfind" target="_top">tfind(3)</a></code>, <code><a href="../../../Reference/ManPages/man3/twalk.3.html#//apple_ref/doc/man/3/twalk" target="_top">twalk(3)</a></code>, and <code><a href="../../../Reference/ManPages/man3/tdelete.3.html#//apple_ref/doc/man/3/tdelete" target="_top">tdelete(3)</a></code> can simplify working with large search trees. In particular, binary trees are an easy way of quickly finding the cached file information from a particular directory. The following code snippet demonstrates the proper way to call these functions:</p><a name="//apple_ref/doc/uid/TP40005289-CH4-DontLinkElementID_21" title="Listing 2-1Using the tsearch, tfind, twalk, and tdelete API."></a><p class="codesample"><strong>Listing 2-1&nbsp;&nbsp;</strong>Using the tsearch, tfind, twalk, and tdelete API.</p><div class="codesample"><table><tr><td scope="row"><pre>#include &lt;unistd.h><span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;stdlib.h><span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;stdio.h><span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;dirent.h><span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;sys/stat.h><span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;string.h><span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;search.h><span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>int array[] = { 1, 17, 2432, 645, 2456, 1234, 6543, 214, 3, 45, 34 };<span></span></pre></td></tr><tr><td scope="row"><pre>void *dirtree;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>static int cmp(const void *a, const void *b) {<span></span></pre></td></tr><tr><td scope="row"><pre>    if (*(int *)a &lt; *(int *)b) return -1;<span></span></pre></td></tr><tr><td scope="row"><pre>    if (*(int *)a > *(int *)b) return 1;<span></span></pre></td></tr><tr><td scope="row"><pre>    return 0;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>void printtree(void);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/* Pass in a directory as an argument. */<span></span></pre></td></tr><tr><td scope="row"><pre>int main(int argc, char *argv[])<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    int i;<span></span></pre></td></tr><tr><td scope="row"><pre>    for (i=0; i&lt; sizeof(array) / sizeof(array[0]); i++) {<span></span></pre></td></tr><tr><td scope="row"><pre>        void *x = tsearch(&amp;array[i], &amp;dirtree, &amp;cmp);<span></span></pre></td></tr><tr><td scope="row"><pre>        printf("Inserted %p\n", x);<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    printtree();<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    void *deleted_node = tdelete(&amp;array[2], &amp;dirtree, &amp;cmp);<span></span></pre></td></tr><tr><td scope="row"><pre>    printf("Deleted node %p with value %d (parent node contains %d)\n",<span></span></pre></td></tr><tr><td scope="row"><pre>        deleted_node, array[2], **(int**)deleted_node);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    for (i=0; i&lt; sizeof(array) / sizeof(array[0]); i++) {<span></span></pre></td></tr><tr><td scope="row"><pre>        void *node = tfind(&amp;array[i], &amp;dirtree, &amp;cmp);<span></span></pre></td></tr><tr><td scope="row"><pre>        if (node) {<span></span></pre></td></tr><tr><td scope="row"><pre>            int **x = node;<span></span></pre></td></tr><tr><td scope="row"><pre>            printf("Found %d (%d) at %p\n", array[i], **x, node);<span></span></pre></td></tr><tr><td scope="row"><pre>        } else {<span></span></pre></td></tr><tr><td scope="row"><pre>            printf("Not found: %d\n", array[i]);<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    exit(0);<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>static void printme(const void *node, VISIT v, int k)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    const void *myvoid = *(void **)node;<span></span></pre></td></tr><tr><td scope="row"><pre>    const int *myint = (const int *)myvoid;<span></span></pre></td></tr><tr><td scope="row"><pre>    // printf("x\n");<span></span></pre></td></tr><tr><td scope="row"><pre>    if (v != postorder &amp;&amp; v != leaf) return;<span></span></pre></td></tr><tr><td scope="row"><pre>    printf("%d\n", *myint);<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>void printtree(void)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    twalk(dirtree, &amp;printme);<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>Two unusual design decisions in this API can make it tricky to use correctly if you haven’t used it before on other UNIX-based or UNIX-like operating systems:</p><ul class="ul"><li class="li"><p>The <code><a href="../../../Reference/ManPages/man3/tsearch.3.html#//apple_ref/doc/man/3/tsearch" target="_top">tsearch(3)</a></code> and <code><a href="../../../Reference/ManPages/man3/tdelete.3.html#//apple_ref/doc/man/3/tdelete" target="_top">tdelete(3)</a></code> functions take the address of the tree variable, not the tree variable itself. This is because they must modify the value stored in the tree variable when they create or delete the initial root node, respectively.</p><p>Even though <code><a href="../../../Reference/ManPages/man3/tfind.3.html#//apple_ref/doc/man/3/tfind" target="_top">tfind(3)</a></code> does not modify the value of the root, it still takes the address of the root as its parameter, not the root pointer itself. A common mistake is to pass in the <code>dirtree</code> pointer. In fact, you must pass in <code>&amp;dirtree</code> (the address of the <code>dirtree</code> pointer).</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40005289-CH4-DontLinkElementID_22" title="Note"></a><p><strong>Note:</strong>&nbsp;Despite the seeming consistency, the <code><a href="../../../Reference/ManPages/man3/twalk.3.html#//apple_ref/doc/man/3/twalk" target="_top">twalk(3)</a></code> function does <em>not</em> take the address of the root, so the ampersand is not needed, and indeed, will cause a crash if you use it.</p></div></li><li class="li"><p>The values passed to the callback by <code><a href="../../../Reference/ManPages/man3/twalk.3.html#//apple_ref/doc/man/3/twalk" target="_top">twalk(3)</a></code> and the values returned by <code><a href="../../../Reference/ManPages/man3/tfind.3.html#//apple_ref/doc/man/3/tfind" target="_top">tfind(3)</a></code> and <code><a href="../../../Reference/ManPages/man3/tsearch.3.html#//apple_ref/doc/man/3/tsearch" target="_top">tsearch(3)</a></code> are the address where the pointer to the data is stored, not the data value itself. Because this code passed in the address of an integer, it is necessary to dereference that value twice—once for the original <code>address-of</code> operator and once to dereference the pointer to that pointer that these functions return.</p><p>Unlike the other functions, however, the function <code><a href="../../../Reference/ManPages/man3/tdelete.3.html#//apple_ref/doc/man/3/tdelete" target="_top">tdelete(3)</a></code> does not return an address within the tree where the data is stored. This is because the data is no longer stored in the tree. Instead, it returns the <em>parent</em> node of the node that it deleted.</p></li></ul><p>The POSIX functions <code><a href="../../../Reference/ManPages/man2/stat.2.html#//apple_ref/doc/man/2/stat" target="_top">stat(2)</a></code> and <code><a href="../../../Reference/ManPages/man2/lstat.2.html#//apple_ref/doc/man/2/lstat" target="_top">lstat(2)</a></code> provide easy access to file metadata. These two functions differ in their treatment of symbolic links. The <code>lstat</code> function provides information about the link itself, while the <code>stat</code> function provides information about the file that the link points to. Generally speaking, when working with file system event notifications, you will probably want to use <code>lstat</code>, because changes to the underlying file will not result in a change notification for the directory containing the symbolic link to that file. However, if you are working with a controlled file structure in which symbolic links always point within your watched tree, you might have reason to use <code>stat</code>.</p><p>For an example of a tool that builds a directory snapshot, see the <em><a href="../../../../../samplecode/Watcher/index.html#//apple_ref/doc/uid/DTS10004054" target="_top">Watcher</a></em> sample code.</p><a name="//apple_ref/doc/uid/TP40005289-CH4-DontLinkElementID_13" title="Cleaning Up"></a><h2>Cleaning Up</h2><p>When you no longer need a file system event stream, you should always clean up the stream to avoid leaking memory and descriptors. Before cleaning up, however, you must first stop the run loop by calling <code><a href="../../../Reference/FSEvents_Ref/FSEvents/CompositePage.html#//apple_ref/c/func/FSEventStreamStop" target="_top">FSEventStreamStop</a></code>.</p><p>Next, you should call <code><a href="../../../Reference/FSEvents_Ref/FSEvents/CompositePage.html#//apple_ref/c/func/FSEventStreamInvalidate" target="_top">FSEventStreamInvalidate</a></code>. This function unschedules the stream from all run loops with a single call. If you need to unschedule it from only a single run loop, or if you need to move the event stream between two run loops, you should instead call <code><a href="../../../Reference/FSEvents_Ref/FSEvents/CompositePage.html#//apple_ref/c/func/FSEventStreamUnscheduleFromRunLoop" target="_top">FSEventStreamUnscheduleFromRunLoop</a></code>. You can then reschedule the event stream, if desired, by calling <code><a href="../../../Reference/FSEvents_Ref/FSEvents/CompositePage.html#//apple_ref/c/func/FSEventStreamScheduleWithRunLoop" target="_top">FSEventStreamScheduleWithRunLoop</a></code>.</p><p>Once you have invalidated the event stream, you can release it by calling <code><a href="../../../Reference/FSEvents_Ref/FSEvents/CompositePage.html#//apple_ref/c/func/FSEventStreamRelease" target="_top">FSEventStreamRelease</a></code>. When the retain count reaches zero, the stream will be freed.</p><p>There are three other cleanup-related functions that you should be aware of under certain circumstances. If your application needs to make certain that the file system has reached a steady state prior to cleaning up the stream, you may find it useful to flush the stream. You can do this with one of two functions: <code><a href="../../../Reference/FSEvents_Ref/FSEvents/CompositePage.html#//apple_ref/c/func/FSEventStreamFlushAsync" target="_top">FSEventStreamFlushAsync</a></code> and <code><a href="../../../Reference/FSEvents_Ref/FSEvents/CompositePage.html#//apple_ref/c/func/FSEventStreamFlushSync" target="_top">FSEventStreamFlushSync</a></code>.</p><p>When flushing events, the synchronous call will not return until all pending events are flushed. The asynchronous call will return immediately, and will return the event ID (of type <code><a href="../../../Reference/FSEvents_Ref/FSEvents/CompositePage.html#//apple_ref/c/tdef/FSEventStreamEventId" target="_top">FSEventStreamEventId</a></code>) of the last event pending. You can then use this value in your callback function to determine when the last event has been processed, if desired.</p><p>The final function related to cleaning up is <code><a href="../../../Reference/FSEvents_Ref/FSEvents/CompositePage.html#//apple_ref/c/func/FSEventsPurgeEventsForDeviceUpToEventId" target="_top">FSEventsPurgeEventsForDeviceUpToEventId</a></code>. This function can only be called by the root user because it destroys the historical record of events on a volume prior to a given event ID. As a general rule, you should never call this function because you cannot safely assume that your application is the only consumer of event data.</p><p>If you are writing a specialized application (an enterprise backup solution, for example), it may be appropriate to call this function to trim the event record to some reasonable size to prevent it from growing arbitrarily large. You should do this <em>only</em> if the administrator explicitly requests this behavior, however, and you should <em>always</em> ask for confirmation (either before performing the operation or before enabling any rule that would cause it to be performed at a later time).</p><a name="//apple_ref/doc/uid/TP40005289-CH4-SW3" title="Special Considerations for Per-Device Streams"></a><h2>Special Considerations for Per-Device Streams</h2><p>In addition to the considerations described in <span class="content_text"><a href="UsingtheFSEventsFramework.html#//apple_ref/doc/uid/TP40005289-CH4-SW1">“Handling Events,”</a></span> streams created with <code><a href="../../../Reference/FSEvents_Ref/FSEvents/CompositePage.html#//apple_ref/c/func/FSEventStreamCreateRelativeToDevice" target="_top">FSEventStreamCreateRelativeToDevice</a></code>, per-device streams have some special characteristics that you should be aware of:</p><ul class="ul"><li class="li"><p>All paths are relative to the root of the volume that you are monitoring, <em>not</em> relative to the system root. This applies to both the path used when creating the stream and to any path that your callback receives as part of an event.</p></li><li class="li"><p>Device IDs may not remain the same across reboots (particularly with removable devices). It is your responsibility to ensure that the volume you are looking at is the right one by comparing the UUID.</p></li></ul><p>In addition to the functions provided for systemwide streams, you can obtain the UUID for the device associated with a stream by calling <code><a href="../../../Reference/FSEvents_Ref/FSEvents/CompositePage.html#//apple_ref/c/func/FSEventStreamGetDeviceBeingWatched" target="_top">FSEventStreamGetDeviceBeingWatched</a></code>.</p><p>You can obtain the unique ID for a device by calling <code><a href="../../../Reference/FSEvents_Ref/FSEvents/CompositePage.html#//apple_ref/c/func/FSEventsCopyUUIDForDevice" target="_top">FSEventsCopyUUIDForDevice</a></code>. If this unique ID is different than the one obtained from a previous run, this can mean many things. It could mean that the user has two volumes with the same name, that the user has reformatted the volume with the same name, or that the event IDs have been purged for the volume. In any of these cases, any previous events for the volume do not apply to this particular volume, but they may still be valid for another volume.</p><p>If you find that the UUID for a volume matches what was stored on a previous run, but the event ID is lower than the last version you stored, this may mean that the user restored a volume from a backup, or it may mean that the IDs have wrapped around or have been purged. In either case, any stored events you may have for the device are invalid.</p><p>Finally, if you are using persistent events, you can also use the function <code><a href="../../../Reference/FSEvents_Ref/FSEvents/CompositePage.html#//apple_ref/c/func/FSEventsGetLastEventIdForDeviceBeforeTime" target="_top">FSEventsGetLastEventIdForDeviceBeforeTime</a></code> to find the last event prior to a time stamp. This event ID is persistent, and can be particularly useful for performing incremental backups.</p><p>The time format used is a <code><a href="../../../../CoreFoundation/Reference/CFTimeUtils/Reference/reference.html#//apple_ref/c/tdef/CFAbsoluteTime" target="_top">CFAbsoluteTime</a></code> value, which is measured in seconds since January 1, 2001. For other timestamp formats, you must convert them to this format as follows:</p><ul class="ul"><li class="li"><p>If you are writing a Cocoa application, you should use an <code><a href="../../../../Cocoa/Reference/Foundation/Classes/NSDate_Class/Reference/Reference.html#//apple_ref/occ/cl/NSDate" target="_top">NSDate</a></code> object to perform any conversions, then use <code><a href="../../../../CoreFoundation/Reference/CFDateRef/Reference/reference.html#//apple_ref/c/func/CFDateGetAbsoluteTime" target="_top">CFDateGetAbsoluteTime</a></code> to obtain the corresponding <code>CFAbsoluteTime</code> value. (You can transparently pass an <code><a href="../../../../Cocoa/Reference/Foundation/Classes/NSDate_Class/Reference/Reference.html#//apple_ref/occ/cl/NSDate" target="_top">NSDate</a></code> object as a <code><a href="../../../../CoreFoundation/Reference/CFDateRef/Reference/reference.html#//apple_ref/c/tdef/CFDateRef" target="_top">CFDateRef</a></code>.)</p></li><li class="li"><p>If you are starting with a POSIX timestamp in a non-Cocoa application, you should subtract <code><a href="../../../../CoreFoundation/Reference/CFTimeUtils/Reference/reference.html#//apple_ref/c/data/kCFAbsoluteTimeIntervalSince1970" target="_top">kCFAbsoluteTimeIntervalSince1970</a></code> from the value to convert to a <code>CFAbsoluteTime</code> value. Be sure to always use timestamps based on GMT.</p></li><li class="li"><p>If you are working with a legacy Carbon timestamp in a non-Cocoa application, you would subtract <code><a href="../../../../CoreFoundation/Reference/CFTimeUtils/Reference/reference.html#//apple_ref/c/data/kCFAbsoluteTimeIntervalSince1904" target="_top">kCFAbsoluteTimeIntervalSince1904</a></code>. Be sure to always use timestamps based on GMT.</p></li></ul><p>For more information about date and time types, you should read <em><a href="../../../../CoreFoundation/Conceptual/CFDatesAndTimes/index.html#//apple_ref/doc/uid/10000125i" target="_top">Dates and Times Programming Guide for Core Foundation</a></em>.</p>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../TechnologyOverview/TechnologyOverview.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../FileSystemEventSecurity/FileSystemEventSecurity.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2008 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2008-03-11<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Darwin/Conceptual/FSEvents_ProgGuide/UsingtheFSEventsFramework/UsingtheFSEventsFramework.html%3Fid%3DTP40005289-1.2&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Darwin/Conceptual/FSEvents_ProgGuide/UsingtheFSEventsFramework/UsingtheFSEventsFramework.html%3Fid%3DTP40005289-1.2&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Darwin/Conceptual/FSEvents_ProgGuide/UsingtheFSEventsFramework/UsingtheFSEventsFramework.html%3Fid%3DTP40005289-1.2&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>