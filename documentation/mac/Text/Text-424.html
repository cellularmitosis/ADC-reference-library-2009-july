<!-- Generated by Harlequin WebMaker 2.2.3 (23-Apr-1996)
LispWorks 3.2.2 -->
<HTML> <HEAD>
<TITLE>Making Calls(IM: Tx)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING424></A>



<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="Text-423.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Text-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Text-594.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="Text-425.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="Text-2.html"><B>Text</B></A> / <BR><DD><A HREF="Text-409.html"><B>Chapter 7 - Text Services Manager</B></A> / <A HREF="Text-421.html"><B>Using the Text Services Manager (for Text Service Components)</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING424-0></A>
<H2><A NAME=MARKER-9-211></A><A NAME=MARKER-2-397></A>Making Calls</H2>
 Your text service component needs to make two kinds of calls to the Text Services Manager: calls that cause the sending of an Apple event to a client application, and calls that request a floating window from the Text Services Manager.<P>
<A NAME=HEADING424-2></A>
<H3><A NAME=MARKER-2-302></A>Sending Apple Events to Client Applications</H3>
 <A NAME=MARKER-2-214></A>Apple events allow text service components to send information to and request specific services of client applications. It is the responsibility of the client application to install Apple event handlers for these Apple events. Using these events, the text service component controls the text services environment by requesting a variety of services from the client application.<P>
 Your text service component can send Apple events to request that a client application perform the following actions:<P>
<UL>
<LI>create or update text in an active input area
<LI>help you track cursor movements by converting global coordinates to the byte offset of characters in the active input area
<LI>help you position items on the screen by converting the byte offset of characters in the active input area to global coordinates
<LI>show or hide a floating input window<P>
</UL>
<DL>
<DT><B>Note</B>
<DD>Your text service component must always use the <CODE>kCurrentProcess</CODE> constant as the target address when it creates an Apple event to send to the Text Services Manager.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
 To send Apple events to a client application, your text service component calls the Text Services Manager <CODE>SendAEFromTSMComponent</CODE> function. The Text Services Manager then completes the Apple event and sends it to the application. For general information on constructing and sending Apple events, see the discussion of the Apple Event Manager in <I><A HREF="../IAC/IAC-2.html">Inside Macintosh: Interapplication Communication</A></I>.<P>
 <A NAME=MARKER-2-376></A><A HREF=#MARKER-9-216>Listing 7-11</A> shows an example of a text service component preparing and sending an Update Active Input Area Apple event. The component creates the Apple event and constructs the required parameters, including the text to be sent to the application. It also constructs the optional parameters that specify highlighting and update ranges in the text. It then calls <CODE>SendAEFromTSMComponent</CODE> to send the Apple event. In this listing, <CODE>globalHandle</CODE> is a handle to a data structure in which the text service component maintains all information about the text in the active input area.<P>
<B>Listing 7-11  <A NAME=MARKER-9-216></A>Constructing and sending an Update Active Input Area Apple event</B><P>
<PRE>
FUNCTION MyCreateUpdateInlineAreaAE(globalHandle: TglobalHandle)  
: OSErr;
VAR
   psnRecord:              ProcessSerialNumber;
   myErr:                  OSErr; 
   addrDescriptor:         AEAddressDesc;
   theAEvent:              AppleEvent;
   theReply:               AppleEvent;
   slRecord:               ScriptLanguageRecord;
   theRangeTableSize:      LongInt;
   theTextData:            Handle;
   theUpdateRangeTable:    TextRangeArray;
   theHiliteRangeTable:    TextRangeArray;
BEGIN
   {Apple event must go to the current process }
   psnRecord.highLongOfPSN := 0;
   psnRecord.lowLongOfPSN  := kCurrentProcess;
   myErr := AECreateDesc(typeProcessSerialNumber, @psnRecord, 
                           sizeof(psnRecord), addrDescriptor);
   IF myErr &lt;&gt; noErr THEN
   BEGIN
      MyCreateUpdateInlineAreaAE := myErr;
      Exit(MyCreateUpdateInlineAreaAE);
   END;
   {create the Apple event record}
   myErr := AECreateAppleEvent(kTextServiceClass, 
                              kUpdateActiveInputArea, 
                              addrDescriptor, 
                              kAutoGenerateReturnID, 
                              kAnyTransactionID, theAEvent);
   IF myErr &lt;&gt; noErr THEN
   BEGIN
      MyCreateUpdateInlineAreaAE := myErr;
      myErr := AEDisposeDesc(addrDescriptor);   {ignore the error}
      Exit(MyCreateUpdateInlineAreaAE);
   END;

   {construct the required parameter keyAEServerInstance-- }
   { globalHandle^^.fSelf = global containing component instance}
   myErr := AEPutParamPtr(theAEvent, keyAEServerInstance, 
                           typeComponentInstance, 
                           @globalHandle^^.fSelf, 
                           sizeof(ComponentInstance));
   IF myErr = noErr THEN
   BEGIN
      {construct required parameter keyAEScriptTag }
      { --Korean in this case}
      slRecord.fScript := smKorean;
      slRecord.fLanguage := langKorean;
      myErr := AEPutParamPtr(theAEvent, keyAEScriptTag, 
                              typeIntlWritingCode, 
                              @slRecord, sizeof(slRecord));
   END;
   IF myErr = noErr THEN
   BEGIN
      {construct required parameter keyAETheData. globalHandle }
      { is a handle to component's data structure describing }
      { all text in the active inline area}
      theTextData := globalHandle^^.fTextData;
      HLock(theTextData);
      myErr := AEPutParamPtr(theAEvent, keyAETheData, typeChar,
                           theTextData^, 
                           globalHandle^^.fTextDataLength);
      HUnlock(theTextData);
   END;
   IF myErr = noErr THEN
      {construct the required parameter keyAEFixLength}
      myErr := AEPutParamPtr(theAEvent, keyAEFixLength, 
                           typeInteger, 
                           @globalHandle^^.fFixedLength, 
                           sizeof(LongInt));

   IF myErr = noErr THEN
   BEGIN 
      {construct the optional parameter UpdateRangeTable}
      theUpdateRangeTable := globalHandle^^.fUpdateRangeTable;
      theRangeTableSize := sizeof(TextRangeArray) 
                           + theUpdateRangeTable.fNumOfRanges 
                           * sizeof(TextRange);
      myErr := AEPutParamPtr(theAEvent, keyAEFixLength, 
                           typeInteger, 
                           @theUpdateRangeTable, 
                           theRangeTableSize);  
   END;
   IF myErr = noErr THEN
   BEGIN
      {construct the optional parameter HiliteRangeTable}
      theHiliteRangeTable := globalHandle^^.fHiliteRangeTable;
      theRangeTableSize := sizeof(TextRangeArray) 
                           + theHiliteRangeTable.fNumOfRanges 
                           * sizeof(TextRange);
      myErr := AEPutParamPtr(theAEvent, keyAEFixLength, 
                           typeInteger, 
                           @theHiliteRangeTable, 
                           theRangeTableSize)
   END;
   IF myErr &lt;&gt; noErr THEN
   BEGIN
      MyCreateUpdateInlineAreaAE := myErr;
      myErr := AEDisposeDesc(theAEvent);     {ignore the errors}
      myErr := AEDisposeDesc(addrDescriptor);
      Exit(MyCreateUpdateInlineAreaAE);
   END;
   {send the Apple event}
   myErr := SendAEFromTSMComponent(theAEvent, theReply, 
                              kAEWaitReply + kAENeverInteract,
                              kAENormalPriority, 120, NIL, NIL);
   MyCreateUpdateInlineAreaAE := myErr;
   myErr := AEDisposeDesc(theAEvent);        {ignore the errors}
   myErr := AEDisposeDesc(addrDescriptor);
   myErr := AEDisposeDesc(theReply);
END; 
</PRE>
<A NAME=HEADING424-17></A>
<H3><A NAME=MARKER-2-217></A>Opening Floating Utility Windows</H3>
 <A NAME=MARKER-9-378></A>To open a floating utility window in front of the current client application, you use the <CODE>NewServiceWindow</CODE> function. If the call is successful, <CODE>NewServiceWindow</CODE> allocates a floating window in the floating window service layer, and returns a pointer to the window. See <A HREF=Text-414.html#MARKER-9-85>"Floating Input Windows" on page 7-13</A> and <A HREF=Text-414.html#MARKER-9-90>"Floating Utility Windows" on page 7-14</A> for a discussion of the Text Services Manager floating window service and the floating window service layer.<P>
 <A NAME=MARKER-2-219></A>Your text service component can open multiple floating windows. When your component receives an event, you must determine if the event belongs to one of your <A NAME=MARKER-2-379></A>text service floating windows. To get a pointer to the frontmost window in the floating window service layer, call the <CODE>GetFrontServiceWindow</CODE> function. To find <A NAME=MARKER-2-380></A>out which part of your floating window an event occurred in, call the <CODE>FindServiceWindow</CODE> function. Your text service component can close the floating window you originally allocated by using the <CODE>CloseServiceWindow</CODE> function.<A NAME=MARKER-2-674></A><P>
</BLOCKQUOTE>
<HR>
<center>
<A HREF="Text-423.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Text-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Text-594.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="Text-425.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="Text-3.html">&copy; Apple Computer, Inc.</A><br>6 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>  
