<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>Security Overview: Security Concepts</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Security Concepts"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP30000976-CH203" title="Security Concepts"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../index.html#//apple_ref/doc/uid/TP30000440-TP30000434" target="_top">Security</a> &gt; <a href="../Introduction/Introduction.html#//apple_ref/doc/uid/TP30000976-CH201-TPXREF101">Security Overview</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../Architecture/Architecture.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../Security_Services/Security_Services.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP30000976-CH203-TPXREF101" title="Security Concepts"></a><h1>Security Concepts</h1><p>This chapter introduces several concepts necessary to understanding the Mac OS X and iPhone OS security APIs. It does not explain any of these concepts in depth, provide programming algorithms, or give the mathematical foundations of cryptography. If you are already familiar with security concepts, you may skip this chapter. If you are already familiar with security concepts in general but would like to know more about how permissions are implemented in Mac OS X, see <span class="content_text"><a href="Concepts.html#//apple_ref/doc/uid/TP30000976-CH203-CHDJICAE">“Permissions.”</a></span></p><p>For references to more detailed sources of information on security concepts and on how to write secure applications, see <span class="content_text"><a href="../Introduction/Introduction.html#//apple_ref/doc/uid/TP30000976-CH201-CHDFAGBC">“See Also.”</a></span></p>
<!-- This template is being used for both PDF and HTML. -->

    
    <h4>In this section:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="Concepts.html#//apple_ref/doc/uid/TP30000976-CH203-TPXREF102">Aspects of Security</a>
				
			<br/>
			
        
			
			
				<a href="Concepts.html#//apple_ref/doc/uid/TP30000976-CH203-CHDJDEDH">Authentication, Identification, and Authorization</a>
				
			<br/>
			
        
			
			
				<a href="Concepts.html#//apple_ref/doc/uid/TP30000976-CH203-TPXREF106">Encryption and Decryption</a>
				
			<br/>
			
        
			
			
				<a href="Concepts.html#//apple_ref/doc/uid/TP30000976-CH203-TPXREF109">Encrypting Messages</a>
				
			<br/>
			
        
			
			
				<a href="Concepts.html#//apple_ref/doc/uid/TP30000976-CH203-CHDJGBCA">Digital Signatures</a>
				
			<br/>
			
        
			
			
				<a href="Concepts.html#//apple_ref/doc/uid/TP30000976-CH203-CHDBIGCE">Digital Certificates</a>
				
			<br/>
			
        
			
			
				<a href="Concepts.html#//apple_ref/doc/uid/TP30000976-CH203-CHDBGFDJ">Authentication and Identification Methods</a>
				
			<br/>
			
        
			
			
				<a href="Concepts.html#//apple_ref/doc/uid/TP30000976-CH203-CHDJICAE">Permissions</a>
				
			<br/>
			
        
			
			
				<a href="Concepts.html#//apple_ref/doc/uid/TP30000976-CH203-CHDJHDDB">Authorization</a>
				
			<br/>
			
        
			
			
				<a href="Concepts.html#//apple_ref/doc/uid/TP30000976-CH203-TPXREF127">Secure Storage</a>
				
			<br/>
			
        
			
			
				<a href="Concepts.html#//apple_ref/doc/uid/TP30000976-CH203-CHDDFACB">Secure Communication</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP30000976-CH203-TPXREF102" title="Aspects of Security"></a><h2>Aspects of Security</h2><p>The fundamental purpose of security is to control who has access to valuable property, whether physical or intellectual. This is the reason we have locks on the doors of our houses, why the military encrypts classified information, and why Mac OS X and iPhone OS enable users to require a password or PIN every time someone logs on to their computer, iPhone, or iPod Touch. </p><p>Security features on a personal computer can be classified into two general groups: those designed to protect programs and data on the computer from unauthorized access by users on the system (“local security<a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_58"></a><a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_59"></a>”); and those designed to protect the system, programs, and data from unauthorized access over a network or other transport medium, such as removable disks (“remote transport security<a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_60"></a><a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_61"></a>”). </p><p>When considering local security, you must be aware of whether access is being controlled by the operating system or by the application itself.</p><a name="//apple_ref/doc/uid/TP30000976-CH203-TPXREF103" title="Local Security"></a><h3>Local Security</h3><p>Local security<a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_62"></a><a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_63"></a> is important when a computer is being shared, such as in libraries or schools; or when an unauthorized person might get access to the computer, such as a computer kept in an open cubicle in a large office. Security features useful in such environments include the password protection offered by the Finder, encryption of data provided by FileVault, BSD access permissions, and access permissions added to applications through use of Authorization Services.</p><a name="//apple_ref/doc/uid/TP30000976-CH203-TPXREF104" title="Remote Transport Security"></a><h3>Remote Transport Security</h3><p>Remote transport security<a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_64"></a><a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_65"></a> is important to all users, and especially to users whose computers are connected to a LAN or to the Internet. Web browsers, for example, use secure transport protocols (<span class="content_text"><a href="Concepts.html#//apple_ref/doc/uid/TP30000976-CH203-CHDJAAJG">“Protocols for Secure Communication”</a></span>) to protect data from interception while in transit, digital signatures (<span class="content_text"><a href="Concepts.html#//apple_ref/doc/uid/TP30000976-CH203-CHDJGBCA">“Digital Signatures”</a></span>) to ensure data integrity, and digital certificates (<span class="content_text"><a href="Concepts.html#//apple_ref/doc/uid/TP30000976-CH203-CHDBIGCE">“Digital Certificates”</a></span>) to verify the identity of people or servers trying to get access to data. Many of the security APIs provided by Mac OS X and iPhone OS are useful in this regard, including the secure networking APIs (Secure Transport, CFNetwork, and URL Loading System), Keychain Services (used to store certificates, passwords, and encryption keys), and Certificate, Key, and Trust Services.</p><a name="//apple_ref/doc/uid/TP30000976-CH203-TPXREF105" title="System-Restricted or Self-Restricted Access"></a><h3>System-Restricted or Self-Restricted Access</h3><p><a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_66"></a><a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_67"></a><a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_68"></a><a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_69"></a>It is important to understand that certain forms of access permission are enforced by the operating system, whereas others are enforced by individual applications. BSD permissions (<span class="content_text"><a href="Concepts.html#//apple_ref/doc/uid/TP30000976-CH203-CHDCDCID">“BSD”</a></span>) control who can execute a program or open a file, and are built into the operating system. On the other hand, if you want finer-grained control over access, such as restricting certain operations to a subset of users, you must enforce these restrictions yourself. <a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_70"></a>Authorization Services provides functions you can use to implement such restrictions, and you can make the restrictions optional so that they operate only when your application is being used in an environment where they are necessary. For example, you might want to restrict access to some application preferences to administrators on a shared computer but not require a password when the computer is not shared. See <span class="content_text"><a href="http://developer.apple.com/technotes/tn2002/tn2095.html" target="_top">Authorization for Everyone, Technical Note TN2095</a></span>, for techniques and sample code for implementing self-restricted access permissions.</p><a name="//apple_ref/doc/uid/TP30000976-CH203-CHDJDEDH" title="Authentication, Identification, and Authorization"></a><h2>Authentication, Identification, and Authorization</h2><p><a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_71"></a><strong>Authentication</strong> is the process by which a person or other entity (such as a server) proves that it is who (or what) it says it is. Authentication is achieved through presenting something that you know, something that you have, some unique identifying feature, or some combination of these. A common example is the way you authenticate yourself in order to use a teller machine: you insert your ATM card (something you have) and enter your personal identification number (PIN, something you know). Unique identifying features include such things as fingerprints, retina patterns, and voice prints.</p><p>It is always desirable to authenticate the person or server with which you are dealing before transferring something valuable, such as information or money. Authentication, however, is time consuming and can inconvenience users. For example, once having shown your photo ID card to enter the Apple Worldwide Developer’s Conference, you would not want to get it out again every time you walked into one of the conference rooms. To make situations like this more convenient and efficient, many systems use some method of <a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_72"></a><strong>identification</strong>, which verifies that the person or entity is the same one you communicated with last time. The means of identification can be through the use of a ticket or token issued when authentication is done. For example, the conference badge you are given to wear during the Developer’s Conference identifies you as a legitimate attendee who was authenticated when you first came in.</p><p>In general, authentication or identification is not sufficient to gain access to information or code. For that, the entity requesting access must have <a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_73"></a><strong>authorization</strong>. Authorization requires first a determination that the authenticated entity has the appropriate <a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_74"></a><strong>permissions</strong>—that is, the right to the specific type of access (such as read, write, or execute) requested—and then the actual granting of that access. For example, the mere possession of a conference badge does not grant you the right to enter a restricted area, such as the speakers’ preparation room. You must have permission to enter this area (indicated, in this case, by the color of your badge), and you must be granted access by the guard at the door. </p><p>Authentication and identification methods available in Mac OS X are described in <span class="content_text"><a href="Concepts.html#//apple_ref/doc/uid/TP30000976-CH203-CHDBGFDJ">“Authentication and Identification Methods.”</a></span> Permissions in BSD and Mac OS X are described in <span class="content_text"><a href="Concepts.html#//apple_ref/doc/uid/TP30000976-CH203-CHDJICAE">“Permissions.”</a></span> Authorization is discussed in more detail in <span class="content_text"><a href="Concepts.html#//apple_ref/doc/uid/TP30000976-CH203-CHDJHDDB">“Authorization.”</a></span> Note that iPhone OS relies on the device’s PIN and the sandboxing (<span class="content_text"><a href="Concepts.html#//apple_ref/doc/uid/TP30000976-CH203-SW1">“Sandboxing and the Mandatory Acccess Control Framework”</a></span>) of applications to provide security—no authorization or authentication interface is provided for iPhone OS.</p><a name="//apple_ref/doc/uid/TP30000976-CH203-TPXREF106" title="Encryption and Decryption"></a><h2>Encryption and Decryption</h2><p>Most of the security APIs in Mac OS X and iPhone OS rely to some degree on encryption of text or data. For example, encryption is used in the creation of certificates and digital signatures, in secure storage of secrets in the keychain, and in secure transport of information. For the purposes of this book, <a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_75"></a><strong>encryption</strong> is defined as the transformation of data into a form in which it cannot be made sense of without the use of some <a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_76"></a><strong>key</strong>. Such transformed data is referred to as <a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_77"></a><strong>ciphertext</strong>. Use of a key to reverse this process and return the data to its original (or <a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_78"></a><strong>plaintext</strong>) form is called <a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_79"></a><strong>decryption</strong>. </p><p>Encryption can be anything from a simple process of substituting one character for another—in which case the key is the substitution rule—to a complex mathematical algorithm. For purposes of security, the more difficult it is to decrypt the ciphertext, the better. On the other hand, if the algorithm is too complex, takes too long to do, or requires keys that are too large to store easily, it becomes impractical for use in a personal computer. Therefore, some balance must be reached between <strong>strength</strong> of the <a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_80"></a>encryption (that is, how difficult it is for someone to discover the algorithm and the key) and ease of use. </p><p>For practical purposes, the encryption need only be strong enough to protect the data for the amount of time the data might be useful to a person with malicious intent. For example, if you need to keep your bid on a contract secret only until after the contract has been awarded, an encryption method that can be broken in a few weeks will suffice. If you are protecting your credit card number, you probably want an encryption method that cannot be broken for many years.</p><p>There are two main types of encryption in use in computer security, referred to as <em>symmetric key encryption</em> and <em>asymmetric key encryption</em>. A closely related process to encryption, in which the data is transformed using a key and a mathematical algorithm that cannot be reversed, is called <a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_81"></a><strong>cryptographic hashing</strong>. The remainder of this section discusses encryption keys, key exchange mechanisms (including the Diffie-Hellman key exchange used in some Mac OS X secure transport protocols), and cryptographic hash functions.</p><a name="//apple_ref/doc/uid/TP30000976-CH203-TPXREF107" title="Symmetric Keys"></a><h3>Symmetric Keys</h3><p><a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_82"></a><a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_83"></a><a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_84"></a><a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_85"></a><a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_86"></a><a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_87"></a><a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_88"></a><a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_89"></a><a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_90"></a><strong>Symmetric key</strong> cryptography (also called private key cryptography or secret key cryptography) is the classic use of keys that most people are familiar with: the same key is used to encrypt and decrypt the data. The classic, and most easily breakable, version of this is the Caesar cipher<a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_91"></a> (named for Julius Caesar), in which each letter in a message is replaced by a letter that is a fixed number of positions away in the alphabet (for example, “a” is replaced by “c”, “b” is replaced by “d”, and so forth). In this case, the key used to encrypt and decrypt the message is simply the number of positions in the alphabet to shift the letters. Modern symmetric key algorithms are much more sophisticated and much harder to break. However, they share the property of using the same key for encryption and decryption.</p><p>There are many different algorithms used for symmetric key cryptography, offering anything from minimal to nearly unbreakable security. Some of these algorithms offer strong security, easy implementation in code, and rapid encryption and decryption. Such algorithms are very useful for such purposes as encrypting files stored on a computer to protect them in case an unauthorized individual uses the computer. They are somewhat less useful for sending messages from one computer to another, because both ends of the communication channel must possess the key and must keep it secure. Distribution and secure storage of such keys can be difficult and can open security vulnerabilities. </p><p>In 1968, the USS <em>Pueblo</em><a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_92"></a>, a U.S. Navy intelligence ship, was captured by the North Koreans. At the time, every Navy ship carried symmetric keys for a variety of code machines at a variety of security levels. Each key was changed daily. Because there was no way to know how many of these keys had not been destroyed by the Pueblo’s crew and therefore were in the possession of North Korea, the Navy had to assume that all keys being carried by the Pueblo had been compromised. Every ship and shore station in the Pacific theater (that is, several thousand installations, including ships at sea) had to replace all of their keys by physically carrying code books and punched cards to each installation. </p><p>The Pueblo incident was an extreme case. However, it has something in common with the problem of providing secure communication for commerce over the Internet. In both cases, codes are used for sending secure messages, not between two locations, but between a server (the Internet server or the Navy’s communications center) and a large number of communicants (individual web users or ships and shore stations). The more end users that are involved in the secure communications, the greater the problems of distribution and protection of the secret symmetric keys.</p><p>Although secure techniques for exchanging or creating symmetric keys can overcome this problem to some extent (see, for example, <span class="content_text"><a href="Concepts.html#//apple_ref/doc/uid/TP30000976-CH203-CHDCCDIA">“Diffie-Hellman Key Exchange”</a></span>), a more practical solution for use in computer communications came about with the invention of practical algorithms for asymmetric key cryptography.</p><a name="//apple_ref/doc/uid/TP30000976-CH203-CHDFFFCC" title="Asymmetric Keys"></a><h3>Asymmetric Keys</h3><p>In <strong>asymmetric key cryptography</strong><a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_93"></a><a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_94"></a><a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_95"></a>, different keys are used for encrypting and decrypting a message. The asymmetric key algorithms that are most useful are those in which neither key can be deduced from the other. In that case, one key can be made public while the other is kept secure. There are some distinct advantages to this public-key–private-key arrangement, often referred to as <strong>public key cryptography</strong><a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_96"></a><a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_97"></a><a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_98"></a>: the necessity of distributing secret keys to large numbers of users is eliminated, and the algorithm can be used for authentication as well as for cryptography.</p><p>The first public key algorithm to become widely available was described by Ron Rivest, Adi Shamir, and Len Adleman in 1977, and is known as <a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_99"></a><a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_100"></a><strong>RSA encryption</strong> from their initials. Although other public key algorithms have been created since, RSA is still the most commonly used. The mathematics of the method are beyond the scope of this document, and are available on the Internet and in many books on cryptography. The algorithm is based on mathematical manipulation of two large prime numbers and their product. Its strength is believed to be related to the difficulty of factoring a very large number. With the current and foreseeable speed of modern digital computers, the selection of long-enough prime numbers in the generation of the RSA keys should make this algorithm secure indefinitely. However, this belief has not been proved mathematically, and either a fast factorization algorithm or an entirely different way of breaking RSA encryption might be possible. Also, if practical <strong>quantum computers</strong> are developed, factoring large numbers will no longer be an intractable problem.</p><p>Other public key algorithms, based on different mathematics of equivalent complexity to RSA, include ElGamal encryption and elliptic curve encryption. Their use is similar to RSA encryption (though the mathematics behind them differs), and they will not be discussed further in this document.</p><p>To see how public key algorithms address the problem of key distribution, assume that Alice wants to receive a secure communication from Bob. The procedure is illustrated in <span class="content_text">Figure 2-1</span>.</p><br/><div><a name="//apple_ref/doc/uid/TP30000976-CH203-CHDCEIHH" title="Figure 2-1Asymmetric key encryption"></a><p><strong>Figure 2-1&nbsp;&nbsp;</strong>Asymmetric key encryption</p><img src = "../art/asymmetric_keys.gif" alt = "Asymmetric key encryption" width="391" height="568"></div><br/><p>The secure message exchange illustrated in <span class="content_text"><a href="Concepts.html#//apple_ref/doc/uid/TP30000976-CH203-CHDCEIHH">Figure 2-1</a></span> has the following steps:</p><ol class="ol"><li class="li"><p>Alice uses one of the public key algorithms to generate a pair of encryption keys: a private key, which she keeps secret, and a public key. She also prepares a message to send to Bob.</p></li><li class="li"><p>Alice sends the public key to Bob, unencrypted. Because her private key cannot be deduced from the public key, doing so does not compromise her private key in any way.</p></li><li class="li"><p>Alice can now easily prove her identity to Bob (a process known as <em>authentication</em>). To do so, she encrypts her message (or any portion of the message) using her private key and sends it to Bob.</p></li><li class="li"><p>Bob decrypts the message with Alice’s public key. This proves the message must have come from Alice, as only she has the private key used to encrypt it.</p></li><li class="li"><p>Bob encrypts his message using Alice’s public key and sends it to Alice. The message is secure, because even if it is intercepted, no one but Alice has the private key needed to decrypt it.</p></li><li class="li"><p>Alice decrypts the message with her private key.</p></li></ol><p>Since encryption and authentication are subjects of great interest in national security and protecting corporate secrets, some extremely smart people are engaged both in creating secure systems and in trying to break them. Therefore, it should come as no surprise that actual secure communication and authentication procedures are considerably more complex than the one just described. For example, the authentication method of encrypting the message with your private key can be got around by a <a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_101"></a><strong>man-in-the-middle attack</strong>, where someone with malicious intent (usually referred to as Eve in books on cryptography) intercepts Alice’s original message and replaces it with their own, so that Bob is using not Alice’s public key, but Eve’s. Eve then intercepts each of Alice’s messages, decrypts it with Alice’s public key, alters it (if she wishes), and reencrypts it with her own private key. When Bob receives the message, he decrypts it with Eve’s public key, thinking that the key came from Alice.</p><p>Although this is a subject much too broad and technical to be covered in detail in this document, see <span class="content_text"><a href="Concepts.html#//apple_ref/doc/uid/TP30000976-CH203-CHDBIGCE">“Digital Certificates,”</a></span> <span class="content_text"><a href="Concepts.html#//apple_ref/doc/uid/TP30000976-CH203-CHDJGBCA">“Digital Signatures,”</a></span> and <span class="content_text"><a href="Concepts.html#//apple_ref/doc/uid/TP30000976-CH203-CHDBGFDJ">“Authentication and Identification Methods”</a></span> for a few of the approaches used to address these security problems.</p><a name="//apple_ref/doc/uid/TP30000976-CH203-CHDCCDIA" title="Diffie-Hellman Key Exchange"></a><h3>Diffie-Hellman Key Exchange</h3><p><a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_102"></a><a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_103"></a><a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_104"></a><a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_105"></a>The <strong>Diffie-Hellman key exchange</strong> protocol is a way for two ends of a communication session to generate symmetric private keys through the exchange of public keys. The two sides agree beforehand on the exact algorithm to use and certain parameters, such as the size of the keys. Then each side selects a random number as a private key and uses that number to generate a public key, according to the algorithm. The security of this algorithm depends in part on it being extremely difficult to derive or guess the private key from this public key. </p><p>The two sides exchange public keys and then each generates a session key using their own private key and the other side’s public key. The mathematics of the algorithm is such that, even though neither side knows the other side’s private key, both sides’ session keys are identical. A third party intercepting the public keys but lacking knowledge of either private key cannot generate a session key. Therefore, data encrypted with the session key is secure while in transit. </p><p>Although Diffie-Hellman key exchange provides strong protection against compromise of intercepted data, it provides no mechanism for ensuring that the entity on the other end of the connection is who you think it is. That is, this protocol is vulnerable to a man-in-the-middle attack. Therefore, it is sometimes used together with some other authentication method to ensure the integrity of the data.</p><p>Diffie-Hellman key exchange is supported by <a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_106"></a>Apple Filing Protocol (AFP) version 3.1 and later and by Apple’s <a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_107"></a>Secure Transport API. Because RSA encryption tends to be slower than symmetric key methods, Diffie-Hellman (and other systems where public keys are used to generate symmetric private keys) can be useful when a lot of encrypted data must be exchanged.</p><a name="//apple_ref/doc/uid/TP30000976-CH203-TPXREF108" title="Cryptographic Hash Functions"></a><h3>Cryptographic Hash Functions</h3><p>A <a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_108"></a><strong>cryptographic hash function</strong> takes any amount of data and applies an algorithm that transforms it into a fixed-size output value. For a cryptographic hash function to be useful, it has to be extremely difficult or impossible to reconstruct the original data from the hash value, and it must be extremely unlikely that the same output value could result from any other input data. </p><p>Sometimes it is more important to verify the integrity of data than to keep it secret. For example, if Alice sent a message to Bob instructing him to shred some records (legally, of course), it would be important to Bob to verify that the list of documents was accurate before proceeding with the shredding. Since the shredding is legal, however, there is no need to encrypt the message, a computationally expensive and time-consuming process. Instead, Alice could compute a hash of the message (called a <a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_109"></a><strong>message digest</strong>) and encrypt the digest with her private key. When Bob receives the message, he decrypts the message digest with Alice’s public key (thus verifying that the message is from Alice), and computes his own message digest from the message text. If the two digests match, then Bob knows the message has not been corrupted or tampered with. For more information on ensuring data integrity, see <span class="content_text"><a href="Concepts.html#//apple_ref/doc/uid/TP30000976-CH203-CHDJGBCA">“Digital Signatures”</a></span></p><p>Commonly used hash functions include MD5, from RSA Data Security, which hashes any amount of input data into a 128-bit output value, and SHA-1, developed and published by the U.S. Government, which produces a 160-bit hash value from any data up to 264 bits in length. </p><a name="//apple_ref/doc/uid/TP30000976-CH203-TPXREF109" title="Encrypting Messages"></a><h2>Encrypting Messages</h2><p>Either symmetric or asymmetric key methods can be used to encrypt messages. Whereas the iPhone OS Certificate, Key, and Trust Services API includes functions to encrypt and decrypt data, Mac OS X does not provide a high-level encryption API. In Mac OS X, you can call CSSM <a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_110"></a><a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_111"></a><a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_112"></a>Cryptographic Services Manager functions to encrypt data. See <span class="content_text"><a href="../Architecture/Architecture.html#//apple_ref/doc/uid/TP30000976-CH202-CHDHEEDC">“CDSA”</a></span> and <span class="content_text"><a href="../Architecture/Architecture.html#//apple_ref/doc/uid/TP30000976-CH202-CHDIFBEH">“CSSM Services”</a></span> for more information about CSSM. For examples of code using CSSM for common encryption tasks, see the <em><a href="../../../../../samplecode/CryptoSample/index.html#//apple_ref/doc/uid/DTS10001086" target="_top">CryptoSample</a></em> sample code.</p><p>Apple’s Mail application (and other email applications) can extract a public key from the signing certificate of any signed email and use it to encrypt messages sent to the owner of that key. See <span class="content_text"><a href="Concepts.html#//apple_ref/doc/uid/TP30000976-CH203-CHDJGBCA">“Digital Signatures”</a></span> for more information about digital signatures and Help for the Mail application for details on sending encrypted email.</p><p>If you use the Secure Transport or CFNetwork APIs to set up a secure communication session, all data sent over that communication link is encrypted. See <span class="content_text"><a href="Concepts.html#//apple_ref/doc/uid/TP30000976-CH203-CHDDFACB">“Secure Communication”</a></span> for more information.</p><a name="//apple_ref/doc/uid/TP30000976-CH203-CHDJGBCA" title="Digital Signatures"></a><h2>Digital Signatures</h2><p><a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_113"></a><strong>Digital signatures</strong><a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_114"></a> are a way to ensure the integrity of a message or other data using public key cryptography. Like traditional signatures written with ink on paper, they can be used to authenticate the identity of the signer of the data. However, digital signatures go beyond traditional signatures in that they can also ensure that the data itself has not been altered. This is like signing a check in such a way that if someone changes the amount of the sum written on the check, an “Invalid” stamp becomes visible on the face of the check.</p><p>To create a digital signature, the signer generates a message digest of the data and then uses a private key to encrypt the digest. The signature includes the encrypted digest and information about the signer’s digital certificate. The certificate is used to verify the signature; it includes the public key needed to decrypt the digest and the algorithm used to create the digest. To verify that the signed document has not been altered, the recipient uses the algorithm to create their own message digest and uses the public key to decrypt the digest in the signature. If the two digests are identical, then the message cannot have been altered and must have been sent by the owner of the public key. </p><p>To ensure that the person who provided the signature is not only the same person who provided the data but is also who they say they are, the certificate is also signed—in this case by the certification authority who issued the certificate. Digital certificates are described in <span class="content_text"><a href="Concepts.html#//apple_ref/doc/uid/TP30000976-CH203-CHDBIGCE">“Digital Certificates.”</a></span> Starting with Mac OS X v10.5, developers are encouraged to sign their applications. On execution, each application’s signature is checked for validity. Digital signatures are required on all applications for iPhone OS. See <span class="content_text"><a href="../Security_Services/Security_Services.html#//apple_ref/doc/uid/TP30000976-CH204-SW1">“Code Signing”</a></span> for more information on how code signing is used by Mac OS X and iPhone OS. </p><p><span class="content_text">Figure 2-2</span> illustrates the <a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_115"></a>creation of a digital signature. </p><br/><div><a name="//apple_ref/doc/uid/TP30000976-CH203-CHDFACFH" title="Figure 2-2Creating a digital signature"></a><p><strong>Figure 2-2&nbsp;&nbsp;</strong>Creating a digital signature</p><img src = "../art/signed_doc.gif" alt = "Creating a digital signature" width="452" height="418"></div><br/><p><span class="content_text">Figure 2-3</span> illustrates the verification<a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_116"></a> of a digital signature. The recipient gets the signer’s public key from the signer’s certificate and uses that to decrypt the digest. Then, using the algorithm indicated in the certificate, the recipient creates a new digest of the data and compares the new digest to the decrypted copy of the one delivered in the signature. If they match, then the received data must be identical to the original data created by the signer.</p><br/><div><a name="//apple_ref/doc/uid/TP30000976-CH203-CHDCHAJC" title="Figure 2-3Verifying a digital signature"></a><p><strong>Figure 2-3&nbsp;&nbsp;</strong>Verifying a digital signature</p><img src = "../art/verify_signature.gif" alt = "Verifying a digital signature" width="429" height="336"></div><br/><a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_117"></a><a name="//apple_ref/doc/uid/TP30000976-CH203-CHDBIGCE" title="Digital Certificates"></a><h2>Digital Certificates</h2><p>A <a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_118"></a><strong>digital certificate</strong> is a collection of data used to verify the identity of the holder or sender of the certificate. For example, an X.509 certificate <a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_119"></a>contains such information as: </p><ul class="ul"><li class="li"><p>Version</p></li><li class="li"><p>Serial number</p></li><li class="li"><p>Certificate issuer</p></li><li class="li"><p>Certificate holder</p></li><li class="li"><p>Validity period (the certificate is not valid before or after this period)</p></li><li class="li"><p>Attributes, known as <a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_120"></a><strong>certificate extensions</strong>, that contain additional information such as allowable uses for this certificate</p></li><li class="li"><p>Digital signature from the certification authority to ensure that the certificate has not been altered and to indicate the identity of the issuer</p></li><li class="li"><p>Public key of the owner of the certificate</p></li><li class="li"><p>Message digest algorithm used to create the signature</p></li></ul><p>The careful reader will have noticed that a digital signature indicates the certificate of the signer, and a certificate contains a digital signature, which indicates another certificate. In general, each certificate is <a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_121"></a>verified through the use of another certificate, creating a chain of certificates that ends with the <a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_122"></a><a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_123"></a><strong>root certificate</strong>. The issuer of a certificate is called a <a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_124"></a><a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_125"></a><strong>certification authority</strong> (CA<a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_126"></a>). The owner of the root certificate is the <a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_127"></a><strong>root certification authority</strong>. <span class="content_text">Figure 2-4</span> illustrates the anatomy of a digital certificate.</p><br/><div><a name="//apple_ref/doc/uid/TP30000976-CH203-CHDHJDGF" title="Figure 2-4Anatomy of a digital certificate"></a><p><strong>Figure 2-4&nbsp;&nbsp;</strong>Anatomy of a digital certificate</p><img src = "../art/certificate_anatomy.gif" alt = "Anatomy of a digital certificate" width="285" height="287"></div><br/><p>The root certificate is self-signed, meaning the signature of the root certificate was created by the root certification authority themselves. <span class="content_text">Figure 2-5</span> and <span class="content_text">Figure 2-6</span> illustrate how a chain of certificates is created and used. <span class="content_text">Figure 2-5</span> shows how the root certification authority creates its own certificate and then creates a certificate for a secondary certification authority.</p><br/><div><a name="//apple_ref/doc/uid/TP30000976-CH203-CHDFCAHC" title="Figure 2-5Creating the certificates for the root CA and a secondary CA"></a><p><strong>Figure 2-5&nbsp;&nbsp;</strong>Creating the certificates for the root CA and a secondary CA</p><img src = "../art/keys_in_cert_chain.gif" alt = "Creating the certificates for the root CA and a secondary CA" width="520" height="574"></div><br/><p><span class="content_text">Figure 2-6</span> shows how the secondary certification authority creates a certificate for an end user and how the end user uses it to sign a document.</p><br/><div><a name="//apple_ref/doc/uid/TP30000976-CH203-CHDJHHBB" title="Figure 2-6Creating the certificate for an end user and signing a document with it"></a><p><strong>Figure 2-6&nbsp;&nbsp;</strong>Creating the certificate for an end user and signing a document with it</p><img src = "../art/keys_in_cert_chain2.gif" alt = "Creating the certificate for an end user and signing a document with it" width="516" height="544"></div><br/><p>In <span class="content_text">Figure 2-6</span>, the creator of the document has signed the document. The signature indicates the certificate of the document’s creator (labeled “User” in the figure). The document’s creator signs the document with a private key, and the signing certificate contains the corresponding public<a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_128"></a> key, which can be used to decrypt the message digest to verify the signature <a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_129"></a>(see <span class="content_text"><a href="Concepts.html#//apple_ref/doc/uid/TP30000976-CH203-CHDJGBCA">“Digital Signatures.”</a></span> This certificate—together with the private and public keys—was provided by a certification authority<a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_130"></a><a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_131"></a> (CA). In order to verify the validity of the user’s certificate, the certificate is signed using the certificate of the CA. The certificate of the CA includes the public key needed to decrypt the message digest of the user’s certificate. Continuing the <a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_132"></a><a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_133"></a>certificate chain, the certificate of the CA is signed using the certificate of the authority who issued that certificate. The chain can go on through any number of intermediate certificates, but in <span class="content_text"><a href="Concepts.html#//apple_ref/doc/uid/TP30000976-CH203-CHDFCAHC">Figure 2-5</a></span> the issuer of the CA’s certificate is the root certification authority. Note that the certificate of the root CA, unlike the others, is “self signed.” That is, it does not refer to a further certification authority but is signed using the root CA’s own private key. </p><p>When a CA creates a certificate, it uses its <a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_134"></a>private key to encrypt the certificate’s message digest. The signature of every certificate the CA issues refers to its own signing certificate. The CA’s public key is in this certificate, and the application verifying the signature must extract this key to verify the certificate of the CA. So it continues, on down the certificate chain, to the certificate of the root CA. When a root CA issues a certificate, it, too, signs the certificate. However, this signing certificate was not issued by another CA; the chain stops here. Rather, the root CA issues its own signing certificate, as shown in <span class="content_text"><a href="Concepts.html#//apple_ref/doc/uid/TP30000976-CH203-CHDFCAHC">Figure 2-5</a></span>.</p><p>The certificate of the root CA can be verified by creating a digest and comparing it with one widely available. Typically, the root certificate and root CA’s public key are already stored in the application or on the computer that needs to verify the signature. </p><p>It’s possible to end a certificate chain with a trusted certificate that is not a root certificate. For example, a certificate can be certified as trusted by the user, or can be cross certified—that is, signed with more than one certificate chain. The general term for a certificate trusted to certify other certificates—including root certificates and others—is <strong>anchor certificate</strong>. Because most anchor certificates are root certificates, the two terms are often used interchangeably. </p><p>The confidence you can have in a given certificate depends on the confidence you have in the anchor certificate; for example, the trust you have in the certificate authorities and in their procedures for ensuring that subsequent certificate recipients in the certificate chain are fully authenticated. For this reason, it is always a good idea to examine the certificate that comes with a digital signature, even when the signature appears to be valid. In Mac OS X and iPhone OS, all certificates you receive are stored in your keychain. In Mac OS X, you can use the Keychain Access utility to view them.</p><p>Certain attributes of a digital certificate (known as <strong>certificate extensions</strong>) are said to establish a <a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_135"></a><strong>level of trust</strong> for a digital certificate. A <a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_136"></a><a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_137"></a><strong>trust policy</strong> is a set of rules that specify the appropriate uses for a certificate that has a specific level of trust. In other words, the level of trust for a certificate is used to answer the question “Should I trust this certificate for this action?”</p><p>For example, the AppleX509TP module (<span class="content_text"><a href="../Architecture/Architecture.html#//apple_ref/doc/uid/TP30000976-CH202-CHDEEDBE">“AppleX509TP Module”</a></span>) enforces a trust policy referred to as the S/MIME policy, which specifies that in order to be trusted to verify a digitally signed email, a certificate must contain an email address that matches the address of the sender of the email.<a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_138"></a></p><a name="//apple_ref/doc/uid/TP30000976-CH203-CHDBGFDJ" title="Authentication and Identification Methods"></a><h2>Authentication and Identification Methods</h2><a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_139"></a><p>This section describes some of the authentication and identification methods used in software in general and in Mac OS X in particular, but gives no implementation details or programming samples. </p><p>If you use Authorization Services, your application can take advantage of any authentication methods supported by Mac OS X, even if new methods are added after you write your code. See <span class="content_text"><a href="../Security_Services/Security_Services.html#//apple_ref/doc/uid/TP30000976-CH204-CHDEEDHC">“Authorization Services”</a></span> for more information on Mac OS X Authorization Services.</p><a name="//apple_ref/doc/uid/TP30000976-CH203-TPXREF110" title="Mac OS X"></a><h3>Mac OS X</h3><p>Mac OS X servers and clients can authenticate users by:</p><ul class="spaceabove"><li class="li"><p>Using the Kerberos Key Distribution Center (KDC), which is built into Mac OS X Server (see <span class="content_text"><a href="Concepts.html#//apple_ref/doc/uid/TP30000976-CH203-CHDGBCDF">“Kerberos”</a></span>)</p></li><li class="li"><p>Using a password stored securely in the Open Directory Password Server database</p></li><li class="li"><p>Using shadow hash authentication, in which cryptographic hashes for NT and LAN Manager authentication are stored in a local file that only the root user can access</p></li><li class="li"><p>Using an encrypted password stored directly in the user’s account</p></li><li class="li"><p>Using a non-Apple LDAP (Lightweight Directory Access Protocol) server</p></li></ul><a name="//apple_ref/doc/uid/TP30000976-CH203-TPXREF111" title="Shared Secret"></a><h3>Shared Secret</h3><p>Many authentication methods are based on <a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_140"></a><a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_141"></a>shared secrets, such as passwords. The security of <strong>shared secret authentication</strong> methods depends on the ability of both parties to keep the secret safe. If the secret is ever intercepted or is simple enough to be easily guessed, the method is not secure at all. The physicist Richard Feynman had a reputation as a safecracker when he worked at Los Alamos. However, in most instances he merely guessed the safe’s combination by using such numbers as the safe owner’s birthday or address. Similarly, if you select a password based on your middle name and then use the same password on all your accounts, none of the accounts will be secure.</p><p>On the other hand, carefully picked and guarded secrets can be extremely secure. Two examples of highly secure shared secret methods are one-time pads and time-based passwords.</p><a name="//apple_ref/doc/uid/TP30000976-CH203-TPXREF112" title="One-Time Pads"></a><h4>One-Time Pads</h4><p><a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_142"></a><a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_143"></a><strong>One-time pad authentication</strong> requires that both parties have an identical list of pairs of numbers, words, or symbols. The most secure lists are randomly generated. When one party (Alice) requests an interchange with the other (Bob), Bob sends Alice a challenge in the form of one of the items selected from the list. Alice must respond with the corresponding paired item (<span class="content_text">Figure 2-7</span>). Once a challenge has been used, it is crossed off the list and never used again. </p><br/><div><a name="//apple_ref/doc/uid/TP30000976-CH203-CHDEDFJA" title="Figure 2-7Authentication using one-time pads"></a><p><strong>Figure 2-7&nbsp;&nbsp;</strong>Authentication using one-time pads</p><img src = "../art/challenge_response.gif" alt = "Authentication using one-time pads" width="308" height="225"></div><br/><p>The one-time nature of one-time pad authentication makes it impossible for someone to guess the appropriate response to any one particular challenge by a brute force attack—that is, by responding to the challenge repeatedly with different answers until hitting the right answer. Similarly, it is impossible to guess what the next challenge should be. Assuming that the lists are truly randomly generated, the only way to break such a system is to know some portion of the contents of the list of pairs.</p><p>For this reason, once the one-time pad has been shared securely, it can be used over insecure communication channels. If someone snoops the communication, they can obtain that challenge-response pair. However, that information is of no use to them, since that particular challenge is never issued again.</p><p>The first problem with challenge-response pairs is that generating truly random lists is difficult with computers. Pseudorandom lists are much easier to obtain, and can (in principle at least) be duplicated, given the right algorithm and a good guess at the seed value. The second problem is that this method is useful only if every pair of correspondents has a unique set of lists. Otherwise, it is impossible to determine which holder of the list is authenticating. Finally, as with any shared secret method, the lists must be kept secret when they are shared and stored securely. If one of the lists is obtained by a third party, the method is compromised and the security breach might be undetectable.</p><a name="//apple_ref/doc/uid/TP30000976-CH203-TPXREF113" title="Time-Based Authentication"></a><h4>Time-Based Authentication</h4><p><a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_144"></a><a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_145"></a><strong>Time-based authentication</strong> is a shared secret method in which the secret is changed periodically in a way known only to the two parties involved. In one variant, both parties begin with the same small amount of seed numbers (as few as two or three) and use a mathematical function that calculates a new number from them. Every time interval (for example, once a minute), a new number is calculated from the previous two or three numbers and the oldest number is discarded. </p><p>As long as both parties keep their clocks synchronized and start with the same seed numbers, they can calculate the current authentication number. In order to guard against a third party intercepting enough numbers to calculate the series or authenticating themselves before the number expires, the numbers should be transmitted over a secure communication channel. To further increase security (for example, if the number-generating ID card is lost or stolen), the generated number is combined with a password or PIN known only to the two parties.</p><p>As with other shared secret methods, time-based authentication depends on the physical security of the shared secret, and each individual wishing to use the system must have a unique generated number and PIN.</p><a name="//apple_ref/doc/uid/TP30000976-CH203-CHDGBCDF" title="Kerberos"></a><h3>Kerberos</h3><a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_146"></a><p>In Greek mythology, Kerberos was the three-headed dog that guarded the gates of Hades. In computer security, Kerberos is an industry-standard protocol created by the Massachusetts Institute of Technology (MIT) to provide authentication over a network. <strong>Kerberos</strong> is a symmetric-key, server-based protocol and is used widely in Macintosh, Windows, and UNIX networks. Kerberos has been integrated into Mac OS X since Mac OS X v10.1. Kerberos is highly secure, and unlike some other shared secret, private-key methods, it can be used for one-to-many and many-to-many communications as well as one-to-one. Kerberos achieves this ability by storing all users’ passwords in a central location, the directory server. Mac OS X works with all common directory servers, including <a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_147"></a><strong>LDAP</strong> (Lightweight Directory Access Protocol) servers and Microsoft Windows <a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_148"></a>Active Directory servers. Mac OS X Server v10.3 and later includes an open-source LDAP server. Mac OS X Server v10.2 and later can host Kerberos authentication services (called a Kerberos <strong>Key Distribution Center</strong> (<strong>KDC</strong>)). Furthermore, a Mac OS X Server v10.3 or later installation that is configured to include a shared LDAP server automatically includes a Kerberos KDC. Mac OS X Server v10.3 and later uses Kerberos v5. Starting with Mac OS X v10.5, Kerberos client and server implementations are both included in the operating system, so any user’s computer can be configured as a KDC.</p><p>Although users’ passwords cannot be intercepted during authentication (because they are never sent over the network), it is very important to keep the machine containing the directory server in a secure location. All passwords and private encryption keys are stored in the directory server and are therefore vulnerable to attack if a malicious person gains access to the server. </p><p>Starting with Mac OS X v10.5, a user with a .Mac account can use Kerberos over the internet to access and control a computer remotely, a service known as Back To My Mac. This service uses public key cryptography to authenticate the two computers, which then follow standard Kerberos protocols, with one computer acting as the KDC and the other as the Kerberos client. The protocol that defines the use of public key cryptography for initial authentication in Kerberos is known as <strong>PKINIT</strong>. You use the open-source Generic Security Service Application Program Interface (<strong>GSS-API</strong>) to adapt your application to use Kerberos.</p><p><strong>Kerberos tickets</strong> are blocks of data used to identify a user who has been previously authenticated. Because Kerberos uses tickets (which are issued for a specific user, service, and period of time), it is possible to access additional kerberized services without requiring the user to reauthenticate (by reentering their password). This feature is called <strong>single signon</strong><a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_149"></a>. A <a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_150"></a><strong>kerberized service</strong> is one that has been configured to take Kerberos tickets. </p><p>For more information on Kerberos in Mac OS X, see <span class="content_text"><a href="http://developer.apple.com/opensource/kerberosintro.html" target="_top">http://developer.apple.com/opensource/kerberosintro.html</a></span>. For general information on Kerberos, see <span class="content_text"><a href="http://web.mit.edu/kerberos/" target="_blank">http://web.mit.edu/kerberos/</a></span>. For information on MIT’s Kerberos for Macintosh, see <span class="content_text"><a href="http://web.mit.edu/macdev/Development/MITKerberos/MITKerberosLib/Common/Documentation/KerberosFramework.html" target="_blank">http://web.mit.edu/macdev/Development/MITKerberos/MITKerberosLib/Common/Documentation/KerberosFramework.html</a></span>. Kerberos version 5 is defined in RFC 4120; PKINIT is defined in RFC 4556; and GSS-API is defined in RFC 2078.</p><p>As of Mac OS X v10.5, these Mac OS X services support Kerberos authentication: </p><ul class="spaceabove"><li class="li"><p>Apple Mail</p></li><li class="li"><p>Apple Filing Protocol (AFP server)</p></li><li class="li"><p>Apple FTP server</p></li><li class="li"><p>Telnet </p></li><li class="li"><p>SSH </p></li><li class="li"><p>NFS</p></li><li class="li"><p>SMB</p></li><li class="li"><p>CUPS</p></li><li class="li"><p>VNC</p></li><li class="li"><p>iCal</p></li><li class="li"><p>Xgrid</p></li><li class="li"><p>Macintosh Manager Client Logins</p></li></ul><p>See <em>Mac OS X Server Open Directory Administration</em> (at <span class="content_text"><a href="http://www.apple.com/server/documentation/" target="_blank">http://www.apple.com/server/documentation/</a></span>) to learn about the services that support Kerberos and to learn how to implement a Kerberos KDC on your Mac OS X server.</p><a name="//apple_ref/doc/uid/TP30000976-CH203-CHDIFGAJ" title="Kerberos Authentication Process"></a><h4>Kerberos Authentication Process</h4><p>There are several phases to <a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_151"></a><a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_152"></a>Kerberos authentication. In the first phase, the client obtains <strong>credentials</strong> (blocks of data that identify and authenticate an entity) to be used to request access to kerberized services. In the second phase, the client requests authentication for a specific service. In the final phase, the client presents those credentials to the service. <span class="content_text">Figure 2-8</span> and <span class="content_text"><a href="Concepts.html#//apple_ref/doc/uid/TP30000976-CH203-CHDEBJFD">Figure 2-9</a></span> illustrate this process. </p><p><span class="content_text">Figure 2-8</span> shows the first phase, in which the client, labeled Alice in the figure, requests credentials from the Kerberos KDC.</p><br/><div><a name="//apple_ref/doc/uid/TP30000976-CH203-CHDFCBIF" title="Figure 2-8Requesting credentials from the KDC"></a><p><strong>Figure 2-8&nbsp;&nbsp;</strong>Requesting credentials from the KDC</p><img src = "../art/kerberos_1.gif" alt = "Requesting credentials from the KDC" width="390" height="353"></div><br/><p>The steps are as follows:</p><ol class="ol"><li class="li"><p><a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_153"></a><a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_154"></a>Alice sends a request to the KDC<a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_155"></a> for credentials. The KDC prompts Alice for a user name and password (or other authentication information), checks the authentication information against the data in the directory server, and (assuming the authentication is valid) gets Alice’s private key from the directory server.</p></li><li class="li"><p>The KDC creates an encryption key (called a <strong>session key</strong><a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_156"></a>) for use by Alice the next time she wants to request service from a kerberized server and encrypts the key with Alice’s private key. It also creates an identification credential called a <a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_157"></a><a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_158"></a><strong>ticket-granting ticket</strong> (<strong>TGT</strong>), which contains a copy of the session key encrypted with the KDC’s private key (plus other information). The KDC sends both credentials to Alice. Alice decrypts the session key and stores it for later. She can’t decrypt the TGT or modify it, but saves it for later use as well. Both the session key and the TGT include timestamps and expiration times to limit the chances of their being intercepted and used by unauthorized persons.</p></li></ol><p>In the second phase, Alice uses the TGT to request identification credentials from the KDC in order to use a kerberized service, labeled Bob in the figure. Because Alice has a TGT, the KDC does not have to reauthenticate her, so Alice is not asked again for her password. In the third phase, Alice sends the credentials to Bob, and Bob sends authentication information to Alice. The second and third phases are illustrated in <span class="content_text">Figure 2-9</span>.</p><br/><div><a name="//apple_ref/doc/uid/TP30000976-CH203-CHDEBJFD" title="Figure 2-9Authenticating the client and server with a Kerberos ticket"></a><p><strong>Figure 2-9&nbsp;&nbsp;</strong>Authenticating the client and server with a Kerberos ticket</p><img src = "../art/kerberos_2.gif" alt = "Authenticating the client and server with a Kerberos ticket" width="447" height="382"></div><br/><p>The steps are as follows:</p><ol class="ol"><li class="li"><p>Alice sends to the KDC a request to open a session with Bob, together with the TGT that the KDC issued earlier. Because the TGT is encrypted with the KDC’s private key, it cannot have been altered, and the KDC accepts it as proof that Alice has been authenticated. </p></li><li class="li"><p>The KDC decrypts the TGT and extracts the session key it issued earlier to Alice. (Recall that when the KDC sent the session key to Alice earlier, it was encrypted with Alice’s private key, so only the KDC and Alice can know this session key.) The KDC then generates a random value, encrypts it with the session key, and sends it to Alice. It also creates a <a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_159"></a>ticket for Alice to send to Bob. This ticket contains a new session key, the same random value that was sent to Alice, and an indication that the request for a session came from Alice. This key is encrypted with Bob’s private key, so Alice (or an intruder) cannot read or modify it. The KDC sends the ticket to Alice.</p></li><li class="li"><p>Alice sends the ticket to Bob. Bob decrypts it with his private key. Because only the KDC and Bob know this key, Bob knows the ticket was issued by the KDC. Bob extracts the random value and the session key, and encrypts the random value with the session key.</p></li><li class="li"><p>Bob sends the encrypted value to Alice. Because Alice knows that only she and Bob have this session key, she knows that the credential must have come from Bob. She checks the value and compares it with the one she received earlier from the KDC. If they match, she knows the message was not interfered with, and she accepts that Bob has been authenticated by the KDC.</p></li></ol><p>Note that this procedure does not involve sending either Alice’s or Bob’s private key over the network. Both Alice and Bob are authenticated to each other, so Bob knows that Alice is a valid user and Alice knows that Bob is the server with which she intended to do business. All credentials are further protected with timestamps and expiration times. Kerberos has other security features as well; for details, see the MIT Kerberos website at <span class="content_text"><a href="http://web.mit.edu/kerberos/" target="_blank">http://web.mit.edu/kerberos/</a></span>.</p><a name="//apple_ref/doc/uid/TP30000976-CH203-CHDEBDEA" title="Kerberos and Authorization"></a><h4>Kerberos and Authorization</h4><p>Kerberos is an authentication protocol, not an <a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_160"></a><a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_161"></a>authorization protocol. That is, it verifies the identities of both the client and the server, but it does not include any information about whether the client has a right to use the services provided by the server. In terms of the preceding discussion, once Bob is satisfied that the request for services really came from Alice, it is up to Bob to determine whether to grant Alice access to those services. The ticket that Bob receives from Alice contains enough information about Alice to enable Bob to make that determination.</p><p>Starting with Kerberos version 5, Kerberos tickets provide a mechanism for the tamperproof transmission of authorization information. When the client requests a ticket, it includes information about itself in the request and can request that the KDC include additional authorization in the ticket. The KDC inserts this information into the authorization data field of the ticket and forwards it to the server. Kerberos does not define how this authorization information should be encoded; it provides only a secure mechanism for its transmission. It is up to the client and server to implement the authorization protocol.</p><a name="//apple_ref/doc/uid/TP30000976-CH203-TPXREF114" title="Single Signon"></a><h4>Single Signon</h4><p>Mac OS X uses Kerberos for <a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_162"></a><a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_163"></a>single signon authentication, which relieves users from entering a name and password separately for every kerberized service. With single signon, after a user enters a name and password in the login window, the user does not have to enter a name and password for Apple file service, mail service, or other services that use Kerberos authentication. In other words, Kerberos authenticates the user once, and thereafter uses tickets to <a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_164"></a>identify the user (see <span class="content_text"><a href="Concepts.html#//apple_ref/doc/uid/TP30000976-CH203-CHDJDEDH">“Authentication, Identification, and Authorization”</a></span>). </p><p>To take advantage of the single signon feature, services must be configured for Kerberos authentication and users and services must use the same Kerberos <a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_165"></a><a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_166"></a>KDC. For Mac OS X Server v10.3 and later, user accounts in an LDAP directory that have a password type of Open Directory use the server’s built-in KDC. These user accounts are automatically configured for Kerberos and single signon. The server’s kerberized services also use the server’s built-in KDC and are automatically configured for single signon. See <em>Mac OS X Server Open Directory Administration</em> (at <span class="content_text"><a href="http://www.apple.com/server/documentation/" target="_blank">http://www.apple.com/server/documentation/</a></span>) for details.</p><a name="//apple_ref/doc/uid/TP30000976-CH203-TPXREF115" title="Large Networks"></a><h4>Large Networks</h4><p>In <span class="content_text"><a href="Concepts.html#//apple_ref/doc/uid/TP30000976-CH203-CHDIFGAJ">“Kerberos Authentication Process,”</a></span> the Kerberos Key Distribution Center (KDC) is treated as a single entity. However, a KDC consists of two separate software processes: the <a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_167"></a><a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_168"></a><strong>ticket-granting server</strong> and the <a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_169"></a><a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_170"></a><strong>authentication server</strong>. The authentication server verifies a user’s identity by prompting the user for a name and password and asking the directory server for the user’s password. The authentication server then looks up the user’s private key, generates a session key, and creates the ticket-granting ticket (TGT), as shown in <span class="content_text"><a href="Concepts.html#//apple_ref/doc/uid/TP30000976-CH203-CHDFCBIF">Figure 2-8</a></span>. Thereafter, the user sends the TGT to the ticket-granting server whenever the services of a kerberized server are required, and the ticket-granting server issues the ticket, as shown in <span class="content_text"><a href="Concepts.html#//apple_ref/doc/uid/TP30000976-CH203-CHDEBJFD">Figure 2-9</a></span>.</p><p>Many networks are too large to efficiently store all the information about users and computers in a single directory server. Instead, a distributed model is used, where there are a number of directory servers, each serving a subset of the network. In Kerberos parlance, this subset is referred to as a <a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_171"></a><a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_172"></a><strong>realm</strong>. Each realm has its own ticket-granting server and authentication server. If a user needs a ticket for a service in a different realm, the authentication server issues a TGT and the user sends the TGT to the authentication server, as before. The authentication server then issues a ticket, not for the desired service but for the remote ticket-granting server for the realm that the service is in. The user then sends the ticket to the remote ticket-granting server to get the ticket for the actual service.</p><p>In fact, in a large network, the user might have to contact the remote ticket-granting server in a sequence of realms before finally getting the ticket for the desired service. When a ticket for the application service is finally issued, it contains an enumeration of all the realms consulted in the process of requesting the ticket. An application server that applies strict authorization rules is permitted to reject authentication that passes through realms that it does not trust.</p><p>Although limited cross-realm authentication was possible in Kerberos v4, the full implementation of this feature is new in Kerberos v5. <a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_173"></a></p><a name="//apple_ref/doc/uid/TP30000976-CH203-CHDEJBJB" title="Public Keys"></a><h3>Public Keys</h3><p>In <strong>public key cryptography</strong>, different keys are used for encryption and decryption. One, the <strong>private key</strong>, is kept secure. The <strong>public key</strong>, on the other hand, can be made publicly available without compromising the private key or the encryption method. In principle, <a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_174"></a><a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_175"></a><a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_176"></a>public key authentication works in much the same way as private key authentication, with one major difference: because public keys do not have to be kept secret, there is no need to encrypt them or send them over secure channels. The public key can be provided by a server, in a certificate, or through some other method. <span class="content_text">Figure 2-10</span> illustrates public key authentication using an authentication server.</p><br/><div><a name="//apple_ref/doc/uid/TP30000976-CH203-CHDHEJBB" title="Figure 2-10Public key authentication"></a><p><strong>Figure 2-10&nbsp;&nbsp;</strong>Public key authentication</p><img src = "../art/public_key_auth.gif" alt = "Public key authentication" width="483" height="377"></div><br/><p>The steps are as follows:</p><ol class="ol"><li class="li"><p>Alice sends Bob a request to talk.</p></li><li class="li"><p>Bob generates a random value and sends it to Alice as a challenge.</p></li><li class="li"><p>Bob requests Alice’s public key from the authentication server.</p></li><li class="li"><p>The authentication server sends the unencrypted public key to Bob.</p></li><li class="li"><p>Alice encrypts the random value with her private key and sends it to Bob. </p></li><li class="li"><p>Bob decrypts the value with Alice’s public key. </p></li><li class="li"><p>Bob compares the decrypted value with the original value to verify that they are identical. Alice has now authenticated herself to Bob.</p></li></ol><p>Bob can authenticate himself to Alice in exactly the same way.</p><p>Notice that there is no need for the authentication server to store any sensitive material: the public keys do not have to be stored securely, and the authentication server does not need to hold passwords because it never has to verify one. However, it is necessary to ensure that no one alters the public keys stored in the authentication server. Otherwise, Eve, for example, could substitute her public key for Alice’s and then could impersonate Alice. Actual implementations of server-based public key authentication systems, therefore, such as used by Novell Corporation’s NDS (Novell Directory Services), include additional security features.</p><p>Note, however, that it is not necessary to have an authentication server in order to use public key authentication. Digital certificates can take the place of a central distributor of public keys.<a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_177"></a><a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_178"></a></p><a name="//apple_ref/doc/uid/TP30000976-CH203-TPXREF116" title="Certificates"></a><h3>Certificates</h3><p><a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_179"></a><a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_180"></a>The problem of ensuring that a public key actually belongs to the entity you wish to authenticate can be addressed using digital certificates. Authentication using a digital certificate is illustrated in <span class="content_text">Figure 2-11</span>.</p><br/><div><a name="//apple_ref/doc/uid/TP30000976-CH203-CHDJHBGE" title="Figure 2-11Authentication with a digital certificate"></a><p><strong>Figure 2-11&nbsp;&nbsp;</strong>Authentication with a digital certificate</p><img src = "../art/certificate_auth.gif" alt = "Authentication with a digital certificate" width="481" height="263"></div><br/><p>The steps are as follows:</p><ol class="ol"><li class="li"><p>Alice sends Bob a request to talk.</p></li><li class="li"><p>Bob generates a random value and sends it to Alice as a challenge.</p></li><li class="li"><p>Alice encrypts the value with her private key and sends it to Bob. She also sends Bob her digital certificate containing her public key. </p></li><li class="li"><p>Bob verifies the digital certificate and uses the public key to decrypt the value.</p></li><li class="li"><p>Bob compares the decrypted value to the original value, verifying that it was truly Alice who sent him the certificate.</p></li></ol><p>In practice, Alice could digitally sign her response to Bob rather than separately encrypting the challenge. Certificates are described in more detail in <span class="content_text"><a href="Concepts.html#//apple_ref/doc/uid/TP30000976-CH203-CHDBIGCE">“Digital Certificates,”</a></span> and digital signatures are discussed in <span class="content_text"><a href="Concepts.html#//apple_ref/doc/uid/TP30000976-CH203-CHDJGBCA">“Digital Signatures.”</a></span><a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_181"></a></p><a name="//apple_ref/doc/uid/TP30000976-CH203-CHDJICAE" title="Permissions"></a><h2>Permissions</h2><p>An important aspect of security on a computer system is the granting or denying of <a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_182"></a><strong>permissions</strong> (sometimes called <strong>access rights</strong><a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_183"></a>). A permission is the ability to perform a specific operation such as to gain access to data or to execute code. Permissions can be granted at the level of directories (folders), subdirectories, files or applications, or specific data within files or functions within applications. </p><p>Permissions in Mac OS X are controlled at many levels, from the Mach and BSD components of the kernel, through higher levels of the operating system, and—for networked applications—through the networking protocols. For iPhone OS, see <span class="content_text"><a href="Concepts.html#//apple_ref/doc/uid/TP30000976-CH203-SW1">“Sandboxing and the Mandatory Acccess Control Framework.”</a></span></p><div class="importantbox"><a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_2" title="Important:"></a><p><strong>Important:</strong>&nbsp;The Mach and BSD access permissions are enforced by the operating system and therefore affect every process running in Mac OS X. In contrast, application-defined security policies must be enforced by those applications. The Mac OS X security APIs discussed in this document are available for that purpose.</p><p></p></div><p>This section introduces the basic features of permissions at all of these levels in Mac OS X.</p><a name="//apple_ref/doc/uid/TP30000976-CH203-CHDCACCI" title="Mach Port Rights"></a><h3>Mach Port Rights</h3><a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_184"></a><a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_185"></a><a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_186"></a><p>At the deepest level of Mac OS X system architecture, the basis for the operating system’s built-in security features is provided by the Mach and BSD components of the kernel. This section provides only a very brief and cursory introduction to Mach. For more information on Mach in Mac OS X and Mach programming, see <em><a href="../../../../Darwin/Conceptual/KernelProgramming/index.html#//apple_ref/doc/uid/TP30000905" target="_top">Kernel Programming Guide</a></em>.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP30000976-CH203-SW5" title="Note"></a><p><strong>Note:</strong>&nbsp; Apple does not support Mach functions for use by external developers and does not guarantee the binary compatibility from one operating system release to the next of code that calls Mach directly. Therefore, Apple recommends against the use of Mach functions by applications. You should use higher-level APIs whenever possible, and call BSD when a low-level interface is required.</p></div><p>Mach security is based on ports and port rights. A Mach <strong>port</strong> is an endpoint of a communication channel between a client who requests a service and a server that provides the service. Mach ports are unidirectional; a reply to a service request must use a second port.</p><p>A port has a set of associated port rights, which are owned by tasks. A <strong>port right</strong> specifies which task can use that port. Each port has one receive right, the owner of which can receive messages on that port. Each port also has one or more send rights; the owners of the send rights can send messages to the port. Rights can be transferred between tasks by being attached to a message.</p><p>A single task (or other Mach object, such as a thread or the computer itself) may have multiple ports that provide access to resources it supports. For example, a task might have a name port and a control port. Access to the control port allows the task to be manipulated. In contrast, access to the name port merely allows the client to obtain information about the task or perform other nonprivileged operations on it.</p><p>Each process has a port right namespace, which maps small integers known as <strong>port right names</strong> to their corresponding port rights. A port right name is meaningful only within that task’s port right namespace. A task can transfer a port right to another task by sending it the corresponding port right name. However, unless it sends the name correctly, the receiving task won’t be able use the right. The only way to transmit a port right between two tasks is by sending a Mach message and attaching the right name to that message using the correct syntax and message structure.</p><p>When you use Mach to create a task, Mach returns a port right name that references a send right for the port (the receive right for a task port is always owned by the kernel). You can send messages to this port to start and stop the task, kill the task, manipulate the task’s address space, and so forth. Therefore, whoever owns a send right for a task’s port effectively owns the task and can manipulate the task’s state without regard to BSD security policies or any higher-level security policies. In other words, an expert in Mach programming with local administrator access to a Mac OS X machine can bypass BSD and higher-level security features. Therefore, it is very important to use strong administrator passwords, keep them secure, and control physical security for any computer containing sensitive information.</p><a name="//apple_ref/doc/uid/TP30000976-CH203-CHDCDCID" title="BSD"></a><h3>BSD</h3><a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_187"></a><a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_188"></a><p>The BSD portion of the kernel is the key place within the Mac OS X operating system that enforces access to applications and files. BSD security policies are visible to users in the Finder, in the form of the Ownership and Permissions information in a file or folder’s Info dialog (<span class="content_text">Figure 2-12</span>).</p><br/><div><a name="//apple_ref/doc/uid/TP30000976-CH203-CHDCJCAB" title="Figure 2-12Ownership and Permissions information"></a><p><strong>Figure 2-12&nbsp;&nbsp;</strong>Ownership and Permissions information</p><img src = "../art/file_info.gif" alt = "Ownership and Permissions information" width="200" height="387"></div><br/><p>The most familiar aspect of BSD security is the <a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_189"></a><a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_190"></a>file system security policy, which controls access to files and folders (directories). BSD file permissions are described in many documents, including <em><a href="../../../../MacOSX/Conceptual/BPFileSystem/index.html#//apple_ref/doc/uid/10000185i" target="_top">File System Overview</a></em>. In addition to the file system security policy, BSD defines two other security policies used in special cases: the owner or root security policy, and the root EUID security policy. Each of these policies is described briefly in the following subsections.</p><p>The BSD security model is based on matching up attributes of an object (such as a file) with attributes of the process attempting to gain access to that object. For example, suppose a file has an owner ID of 1234 and the file permissions specify that the owner may have read and write access to that file. Suppose further that Alice has a user ID (UID) of 1234. When Alice attempts to read the file, BSD matches her UID with the file’s owner ID and grants Alice access to read the file. </p><p>Starting in Mac OS X v10.5, the kernel includes an implementation of the TrustedBSD Mandatory Access Control (MAC) framework. Mandatory access control—also known as “sandboxing”—is discussed in <span class="content_text"><a href="Concepts.html#//apple_ref/doc/uid/TP30000976-CH203-SW1">“Sandboxing and the Mandatory Acccess Control Framework.”</a></span></p><a name="//apple_ref/doc/uid/TP30000976-CH203-TPXREF117" title="File System Security Policy"></a><h4>File System Security Policy</h4><p><a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_191"></a><a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_192"></a>The file system security policy is used to control access to objects in the file system, such as volumes, directories, files, symbolic links, and devices. Each file system object has a user ID (the <strong>file UID</strong>, commonly referred to as the file’s owner), a group ID (the <strong>file GID</strong>, commonly referred to as the file’s group), and three sets of permission bits, known as owner, group, and other permissions. The first set of bits controls access to the object by the <strong>owner</strong> (any process whose effective UID is equal to the file UID), the second controls access by members of the group, and the third controls access by everyone else. Each bit set contains three bits: read, write, and execute (rwx for short). The effect of these bits differs for files and directories, as shown in <span class="content_text">Table 2-1</span>.</p><a name="//apple_ref/doc/uid/TP30000976-CH203-CJBJGFBF" title="Table 2-1File permission bits in BSD"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 2-1&nbsp;&nbsp;</strong>File permission bits in BSD</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Bit</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>File</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Directory</p></th></tr><tr><td  scope="row"><p>read</p></td><td ><p>Can open file for read</p></td><td ><p>Can list directory contents</p></td></tr><tr><td  scope="row"><p>write</p></td><td ><p>Can open file for write</p></td><td ><p>Can modify directory contents</p></td></tr><tr><td  scope="row"><p>execute</p></td><td ><p>Can treat file as a program to run</p></td><td ><p>Can search the directory</p></td></tr></table></div><p>Each process has three <a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_193"></a>user IDs: the <a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_194"></a>real user ID (RUID), <a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_195"></a>effective user ID (EUID), and <a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_196"></a>saved user ID (SUID). The <strong>RUID</strong> is always inherited from the user or process that executes the process. The <strong>EUID</strong> is normally the same as the RUID, but it can differ in special circumstances as described in <span class="content_text"><a href="Concepts.html#//apple_ref/doc/uid/TP30000976-CH203-CHDJDDJC">“Owner or Root Security Policy.”</a></span> In most cases, it is the EUID that BSD checks to determine permissions. The <strong>SUID</strong> is used by BSD to enable a privileged process to switch in and out of privileged mode. </p><p>Each process also has real and saved group IDs (RGID and SGID) and up to 16 effective group IDs (EGIDs), which work in a way analogous to the process’s user IDs. </p><p>For more details on these UIDs and GIDs, see <em>The Design and Implementation of the 4.4 BSD Operating System</em> by Marshall McKusick and others.)</p><p>Under the file system security policy, BSD determines the permissions applicable to a process accessing a file by comparing the process’s EUID and EGIDs with the UID and GID associated with the file. If the UIDs match, BSD grants the process the permissions specified for the owner. If the UIDs do not match, BSD checks whether the process is considered a member of the group identified by the file’s GID. If it is, then BSD grants the process the permissions specified for the group. If neither of these conditions is met, the process is granted the permissions specified for “other.” </p><a name="//apple_ref/doc/uid/TP30000976-CH203-CHDJDDJC" title="Owner or Root Security Policy"></a><h4>Owner or Root Security Policy</h4><p><a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_197"></a><a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_198"></a>The owner-or-root security policy is used to control execution of a few specific operations. Under this policy, a specific operation on an object can be performed by any process whose EUID is the same as the object’s owner or whose EUID is 0. The user with a UID of 0 is called the <a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_199"></a><a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_200"></a><strong>root user</strong> (also called the <em>superuser</em><a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_201"></a>) and a process running with an EUID of 0 is said to be running as<a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_202"></a><code>root</code>. </p><p>In addition to the r, w, and x bits, each file system object also has three ancillary permission bits: setuid, setgid, and sticky. Normally, when a process executes a program, the resulting process has both its RUID and EUID set to the EUID of the process that executed it. However, if the program’s setuid bit<a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_203"></a> is set, it runs with the EUID equal to the program’s file UID. Therefore, if the owner of a program is the root user, the program runs with an EUID of 0. The setgid bit<a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_204"></a> has a similar effect: the process runs with an EGID equal to the program file’s group UID. </p><p>The sticky bit<a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_205"></a> restricts the deletion of files in a directory so that only the owner of the file, the owner of the directory, or the root user can delete a file.</p><p>A user can change the permissions only on files owned by that user. Therefore, only the root user can set the setuid bit on a program owned by <code>root</code>. Because such a program runs with root privileges when executed by someone other than <code>root</code>, it can create a security vulnerability. Therefore, it is important to restrict the creation and use of such programs. </p><p>An example of where the owner-or-root security policy applies is the <code>chmod</code> system call, which is used to change the permissions of a file (including the setuid and setgid bits). Only the owner of the file or a process running as <code>root</code> can change a file’s permissions. </p><a name="//apple_ref/doc/uid/TP30000976-CH203-TPXREF118" title="Root EUID Security Policy"></a><h4>Root EUID Security Policy</h4><p><a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_206"></a><a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_207"></a>Under the root EUID security policy, an operation can be performed only by a process with an EUID of 0. Such operations are sometimes referred to as <a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_208"></a><strong>privileged operations</strong>. Some of the common situations where the root EUID security policy applies are:</p><ul class="spaceabove"><li class="li"><p>Changing the owner of a file system object</p></li><li class="li"><p>Binding TCP/IP sockets to low-numbered ports</p></li><li class="li"><p>Making changes to the network configuration</p></li><li class="li"><p>Certain I/O Kit operations</p></li><li class="li"><p>Getting the Mach host privileged special port</p></li></ul><a name="//apple_ref/doc/uid/TP30000976-CH203-SW2" title="Authorization Services and BSD Security Policies"></a><h4>Authorization Services and BSD Security Policies</h4><p>Because a process running with an EUID of 0 has many special privileges, such a process can be a target of malicious hackers. To minimize such risks, you should factor your application into privileged and nonprivileged processes. See <span class="content_text"><a href="../Security_Services/Security_Services.html#//apple_ref/doc/uid/TP30000976-CH204-CHDEEDHC">“Authorization Services”</a></span> for more information and for references that describe and illustrate this technique.<a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_209"></a><a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_210"></a></p><p>Processes can change their EUID and EGID by calling <code>setuid</code>, <code>setgid</code>, and related system calls. For example, a process can run as root temporarily and then switch to a less privileged EUID to minimize exposure to malicious attacks. This technique is complicated by the confusing semantics of the <code>setuid</code> call and by the fact that these calls operate somewhat differently on different implementations of UNIX (including different versions of Mac OS X). For a detailed discussion of the issues involved, see <em>Setuid Demystified</em> by Chen, Wagner, and Dean (Proceedings of the 11th USENIX Security Symposium, 2002), available at <span class="content_text"><a href="http://www.usenix.org/publications/library/proceedings/sec02/full_papers/chen/chen.pdf" target="_blank">http://www.usenix.org/publications/library/proceedings/sec02/full_papers/chen/chen.pdf</a></span>. For more information on the system calls, see the man pages for <code>setuid</code>, <code>setreuid</code>, and <code>setregid</code>. (The <code>setuid</code> man page includes information about <code>seteuid</code>, <code>setgid</code>, and <code>setegid</code> as well.)</p><a name="//apple_ref/doc/uid/TP30000976-CH203-SW1" title="Sandboxing and the Mandatory Acccess Control Framework"></a><h4>Sandboxing and the Mandatory Acccess Control Framework</h4><a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_211"></a><a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_212"></a><p><a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_213"></a><strong>Sandboxing</strong> provides fine-grained control of the ability of processes to access system resources. For example, you can prevent a process from connecting to any network, from writing any files, or from writing any files outside of specific directories. This feature limits the amount of damage that can be done by a malicious hacker that gains control of an application. For example, if an attacker takes control of an application that is sandboxed so that it can write files only to the folder <code>/var/tmp</code>, it is not possible for the hacked program to overwrite system files. </p><p>New processes inherit the sandbox restrictions of their parent.</p><p>In Mac OS X, sandboxing is provided by the Mac OS X Mandatory Access Control (MAC) framework, which is an implementation of the TrustedBSD MAC framework, documented in <span class="content_text"><a href="http://www.trustedbsd.org/mac.html" target="_blank">http://www.trustedbsd.org/mac.html</a></span>. </p><p>In iPhone OS, each application is put in a sandbox that restricts the application to using only its own files and preferences, and limits the system resources to which the application has access. For example, an application can call the public networking APIs to communicate over a network, but has no direct access to the communications or networking hardware.</p><p>It’s important to note that a sandbox does not protect an application from a direct attack. For example, if you accept input from the user, don’t validate it, and there is an exploitable buffer overflow in your input-handling code, an attacker might be able to cause your program to crash or even take control of the program so that it executes the attacker’s code. The sandbox limits the damage an attacker can cause, but cannot prevent attacks.</p><a name="//apple_ref/doc/uid/TP30000976-CH203-CHDJJGBF" title=" ACLs"></a><h3> ACLs</h3><a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_214"></a><a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_215"></a><a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_216"></a><p>Starting with Mac OS X v10.4, the Mach and BSD permissions policies are supplemented by support in the kernel for <strong>ACLs</strong> (access control lists), which are data structures that provide much more detailed control over permissions than does BSD. For example, ACLs allow the system administrator to specify that a specific user can delete a file but cannot write to it. ACLs also provide compatibility with Active Directory and with the SMB/CIFS networks used by the Windows operating system. For more information on ACL support in Mac OS X for different network file systems, see <span class="content_text"><a href="Concepts.html#//apple_ref/doc/uid/TP30000976-CH203-TPXREF122">“Network File Systems.”</a></span></p><p>An ACL consists of an ordered list of <strong>ACEs</strong><a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_217"></a><a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_218"></a> (access control entries), each of which associates a user or group with a set of permissions and specifies whether each permission is allowed or denied. ACEs also include attributes related to inheritance (see <span class="content_text"><a href="Concepts.html#//apple_ref/doc/uid/TP30000976-CH203-CHDGJEHB">“Inheritance of Permissions”</a></span>). </p><div class="notebox"><a name="//apple_ref/doc/uid/TP30000976-CH203-SW6" title="Note"></a><p><strong>Note:</strong>&nbsp;File system ACLs are not related to the ACLs used by keychains, as described in <em><a href="../../keychainServConcepts/index.html#//apple_ref/doc/uid/TP30000897" target="_top">Keychain Services Programming Guide</a></em>.</p></div><a name="//apple_ref/doc/uid/TP30000976-CH203-SW3" title="File System Access Control Policy"></a><h4>File System Access Control Policy</h4><p>You can use file system ACLs to implement more detailed and complex access control policies than are possible using only BSD permissions. They do so by using many more permission bits than the three used by BSD and by implementing both allow and deny associations for each permission for each user or group. <span class="content_text">Table 2-2</span> shows the permission bits used by ACLs. Compare these to the BSD permission bits shown in <span class="content_text"><a href="Concepts.html#//apple_ref/doc/uid/TP30000976-CH203-CJBJGFBF">Table 2-1</a></span>.</p><a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_219"></a><a name="//apple_ref/doc/uid/TP30000976-CH203-CHDCAJJE" title="Table 2-2File permission bits using ACLs  "></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 2-2&nbsp;&nbsp;</strong>File permission bits using ACLs  </caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Bit</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>File</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Directory</p></th></tr><tr><td  scope="row"><p>read</p></td><td ><p>Open file for read</p></td><td ><p>List directory contents</p></td></tr><tr><td  scope="row"><p>write</p></td><td ><p>Open file for write</p></td><td ><p>Add a file entry to the directory</p></td></tr><tr><td  scope="row"><p>execute</p></td><td ><p>Execute file</p></td><td ><p>Search through the directory</p></td></tr><tr><td  scope="row"><p>delete</p></td><td ><p>Delete file</p></td><td ><p>Delete directory</p></td></tr><tr><td  scope="row"><p>append</p></td><td ><p>Append to file</p></td><td ><p>Add subdirectory to directory</p></td></tr><tr><td  scope="row"><p>delete child</p></td><td ><p>—</p></td><td ><p>Remove a file or subdirectory entry from the directory</p></td></tr><tr><td  scope="row"><p>read attributes</p></td><td ><p>Read basic attributes</p></td><td ><p>Read basic attributes</p></td></tr><tr><td  scope="row"><p>write attributes</p></td><td ><p>Write basic attributes</p></td><td ><p>Write basic attributes</p></td></tr><tr><td  scope="row"><p>read extended</p></td><td ><p>Read extended (named) attributes</p></td><td ><p>Read extended (named) attributes</p></td></tr><tr><td  scope="row"><p>write extended</p></td><td ><p>Write extended (named) attributes</p></td><td ><p>Write extended (named) attributes</p></td></tr><tr><td  scope="row"><p>read permissions</p></td><td ><p>Read file permissions (ACL)</p></td><td ><p>Read directory permissions (ACL)</p></td></tr><tr><td  scope="row"><p>write permissions</p></td><td ><p>Write file permissions (ACL)</p></td><td ><p>Write directory permissions (ACL)</p></td></tr><tr><td  scope="row"><p>take ownership</p></td><td ><p>Take ownership</p></td><td ><p>Take ownership</p></td></tr></table></div><p>Notice that the right to change permissions is itself controlled by a permission.</p><a name="//apple_ref/doc/uid/TP30000976-CH203-SW4" title="ACLs and User IDs"></a><h4>ACLs and User IDs</h4><a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_220"></a><p>One of the main reasons for implementing ACLs in Mac OS X is to support network file systems such as SMB/CIFS (see <span class="content_text"><a href="Concepts.html#//apple_ref/doc/uid/TP30000976-CH203-TPXREF125">“SMB/CIFS”</a></span>). In order to be able to identify users and groups throughout the network, each file or directory must have universally unique identifiers (UUIDs<a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_221"></a>) in addition to the locally-unique UID and GID used by BSD. Each file or directory that has associated ACLs, therefore, has four associated identities, two to support BSD and two to support ACLs:</p><ul class="spaceabove"><li class="li"><p>user ID (UID)</p></li><li class="li"><p>group ID (GID)</p></li><li class="li"><p>owner UUID</p></li><li class="li"><p>group UUID</p></li></ul><p>Unlike BSD, which specifies three permissions for each file (one for the file’s owner, one for members of the file’s group, and one for everyone else), an ACL can specify different permissions for each ACE. Another contrast between ACLs and BSD is that, whereas in BSD the file owner must be an individual, in the ACL permission scheme the file owner can be either a user or a group. If a file is owned by a group, its GID (used by BSD) and group UUID are always coherent (that is, there is always a simple, 1:1 mapping between them). However, because BSD does not support the concept of a group as owner of a file, in this case the system assigns a special UID that identifies the file as owned by “not a user” and the owner UUID represents a group. If the file is owned by a single individual, its UID and owner UUID are coherent. </p><p>The owner of a file using an ACL has certain unrevokable permissions (read and write permissions) regardless of the contents of the ACL. If the file is owned by an individual, the group UUID associates a group with a file system object and affects the inheritance of certain ACEs (see <span class="content_text"><a href="Concepts.html#//apple_ref/doc/uid/TP30000976-CH203-CHDGJEHB">“Inheritance of Permissions”</a></span>) but does not confer any special permissions on the group.</p><a name="//apple_ref/doc/uid/TP30000976-CH203-CHDGGFHB" title="Evaluating Permissions"></a><h4>Evaluating Permissions</h4><a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_222"></a><p>Each ACE in an ACL either allows <a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_223"></a>or a denies <a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_224"></a>some set of permissions. It is very important to understand that a deny ACE is not the same as the absence of an allow ACE. Rather, the system evaluates the ACEs in sequence until either all requested permissions are allowed or any requested permission is denied. A request for authorization includes a credential (which identifies the requesting entity) and the permissions required for the operation. Mac OS X v10.4 and later evaluates permissions using the following algorithm (also, see <span class="content_text"><a href="Concepts.html#//apple_ref/doc/uid/TP30000976-CH203-CHDGJEHB">“Inheritance of Permissions”</a></span> for a discussion of inherited permissions):</p><ol class="ol"><li class="li"><p>If the requested permissions would change the object, and the file system is read-only or the object is marked as immutable, the operation is denied.</p></li><li class="li"><p>If the entity making the request is the root user, the operation is allowed.</p></li><li class="li"><p>If the entity making the request is the object’s owner, the requestor is given Read Permissions and Write Permissions access. If that is sufficient to satisfy the request, the operation is allowed. </p></li><li class="li"><p>If the object has an ACL, the ACEs in the ACL are scanned in order. (Those with deny associations are usually placed before those with allow associations.) Each ACE is evaluated according to the following criteria until either a required permission has been denied, all required permissions have been allowed, or the end of the ACL is reached:</p><ol class="ol"><li class="ol ol"><p>The ACE is checked for applicability. The ACE is not considered applicable if it does not refer to any of the requested permissions. In addition, the requesting entity must be the same as the entity named in the ACE, or the requestor must be a member of a group named in the ACE. (Groups may be nested and an external directory service may be used to resolve group membership.) Non-applicable ACEs are ignored.</p></li><li class="ol ol"><p>If the ACE denies any of the requested permissions, then the request is denied. (Note that Read Permissions and Write Permissions are granted to the object’s owner, regardless of whether allowed or denied by ACEs.)</p></li><li class="ol ol"><p>If the ACE allows any of the requested permissions, the system adds this permission to the list of granted permissions. If the granted permissions include all the requested permissions, the request is allowed and the process stops. If the list is not complete, the system goes on to check the next ACE.</p></li></ol></li><li class="li"><p>If the end of the ACL is reached without finding all of the required permissions, and if the object also has BSD permissions, then the system checks the unsatisfied permissions against the BSD permissions. If these are sufficient to grant all required permissions, the request is allowed. If the permission requested has no BSD equivalent (such as “take ownership”), then it is considered still outstanding and the request is denied. </p></li><li class="li"><p>If the file system object has no ACL, then permissions are evaluated according to the BSD security policies, as described in <span class="content_text"><a href="Concepts.html#//apple_ref/doc/uid/TP30000976-CH203-CHDCDCID">“BSD.”</a></span></p></li></ol><p>The credential of the requesting entity is equivalent to the effective UID (that is, the EUID) of the program attempting to open or execute a file. The EUID is normally the same as the UID of the user or process that executes the process., but it can differ in special circumstances (involving the setuid bit) as described in <span class="content_text"><a href="Concepts.html#//apple_ref/doc/uid/TP30000976-CH203-CHDJDDJC">“Owner or Root Security Policy.”</a></span> </p><a name="//apple_ref/doc/uid/TP30000976-CH203-CHDGJEHB" title="Inheritance of Permissions"></a><h4>Inheritance of Permissions</h4><a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_225"></a><a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_226"></a><p>BSD permissions are assigned only on a per-file basis, so that the permissions assigned to a directory do not affect the permissions of a new file or subdirectory created in that directory. Although you can apply the permissions of a directory to enclosed items, doing so is a one-time operation. Any newly created files or subdirectories are not affected—they are created with default permissions.</p><p>With ACLs, by contrast, newly created files and subdirectories can inherit permissions from their enclosing directory. Each ACE on a directory can contain any combination of the following inheritance flags:</p><ul class="spaceabove"><li class="li"><p>Inherited (this ACE was inherited).</p></li><li class="li"><p>File Inherit (this ACE should be inherited by files created within this directory.</p></li><li class="li"><p>Directory Inherit (this ACE should be inherited by directories created within this directory).</p></li><li class="li"><p>Inherit Only (this ACE should not be checked during authorization).</p></li><li class="li"><p>No Propagate Inherit (this ACE should be inherited only by direct children; that is, the ACE should lose any Directory Inherit or File Inherit bit when inherited).</p></li></ul><p>When it creates a new file, the kernel goes through the entire access control list of the parent directory and copies to the file’s ACL any ACEs that are marked for file inheritance. Similarly, when it creates a new subdirectory, the kernel copies to the subdirectory’s ACL any ACEs that are marked for directory inheritance.</p><p>If a file is copied and pasted into a directory, the kernel replicates the contents of the source file into a new file at the destination. Because it is creating a new file, the system checks the ACL of the parent directory and adds any inherited ACEs to whatever ACEs were in the original file. If a file is moved into a directory, on the other hand, the original file is not replicated and no ACEs are inherited. In this case, the parent directory’s ACEs are added to the moved file only if the administrator specifically propagates ACEs from the parent directory through contained files and subdirectories. Similarly, once a file has been created, changing the ACL of the parent directory does not affect the ACL of contained files and subdirectories unless the administrator specifically propagates the change.</p><p>In BSD, applying a directory’s permissions to enclosed files and subdirectories completely replaces the permissions of the enclosed objects. With ACLs, in contrast, inherited ACEs are added to other ACEs already on the file or directory.</p><p>The order in which ACEs are placed in an ACL—and therefore the order in which they are evaluated to determine permissions—is as follows:</p><ol class="ol"><li class="li"><p>Explicitly specified deny associations</p></li><li class="li"><p>Explicitly specified allow associations</p></li><li class="li"><p>Inherited associations, in the same order in which they appeared in the parent</p></li></ol><p>Therefore, any explicitly specified ACEs take precedence over all inherited ACEs. For more information on how ACEs are evaluated, see <span class="content_text"><a href="Concepts.html#//apple_ref/doc/uid/TP30000976-CH203-CHDGGFHB">“Evaluating Permissions.”</a></span></p><p>Because ACEs can be inherited, administrators can control the fine-grained permissions of files created in a directory by assigning inheritable ACEs to the directory. Doing so saves the work of assigning ACEs to each file individually. In addition, because ACEs can apply to groups of users, administrators can assign permissions to groups rather than having to specify permissions for each individual. Applying access security to directories and groups rather than to files and individuals saves administrator time and gives better file system performance in many circumstances. </p><p>For application programmers, it is important to note that the automatic inheritance of permissions from directories means that it is not necessary for an application to create an ACL for each new file it creates or to maintain inherited ACEs when a file is saved, because the kernel creates the ACL for the file using inherited ACEs. (Note that assignment and inheritance of BSD permissions are not affected by ACLs. If ACLs are not supported, the BSD permissions are used. For more information on the way permissions are evaluated when both ACLs and BSD permissions are set, see <span class="content_text"><a href="Concepts.html#//apple_ref/doc/uid/TP30000976-CH203-CHDGGFHB">“Evaluating Permissions.”</a></span>)</p><p>In Mac OS X Server v10.4, the server administrator can perform the following operations:</p><ul class="spaceabove"><li class="li"><p>Copy permissions from a parent directory to all files and directories below it in the hierarchy. This makes permissions uniform in the directory tree and should be used only for BSD permissions.</p></li><li class="li"><p>Propagate permissions from a parent directory to all files and directories below it in the hierarchy. In this case, explicitly specified ACEs are unchanged and ACEs inherited from them are unchanged. Files and subdirectories inherit ACEs as if they had been newly created in place under the directories that have explicitly specified ACEs, as illustrated in <span class="content_text">Figure 2-13</span>.</p></li><li class="li"><p>Apply inheritance from a parent directory to a specific directory or file.</p></li><li class="li"><p>Make inherited ACEs in directories explicit.</p></li><li class="li"><p>Remove all ACEs from directories and files.</p></li><li class="li"><p>Enable or disable ACLs on a volume.</p></li></ul><p>The server GUI cannot directly manipulate ACEs of files. There is no GUI in the Finder to set or change ACEs. ACEs can be read and set both on the server and client using the command-line tools <code>ls</code> and <code>chmod</code>.</p><br/><div><a name="//apple_ref/doc/uid/TP30000976-CH203-CHDHABAD" title="Figure 2-13Propagating permissions"></a><p><strong>Figure 2-13&nbsp;&nbsp;</strong>Propagating permissions</p><a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_227"></a><a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_228"></a><a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_229"></a><img src = "../art/server_permissions.gif" alt = "Propagating permissions" width="657" height="738"></div><br/><a name="//apple_ref/doc/uid/TP30000976-CH203-TPXREF119" title="Mac OS X"></a><h3>Mac OS X</h3><p>This section discusses how Mac OS X uses BSD permissions.</p><a name="//apple_ref/doc/uid/TP30000976-CH203-TPXREF57" title="The Root User"></a><h4>The Root User</h4><p>The <a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_230"></a><a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_231"></a><strong>root user</strong> owns many of the primary system processes and has unlimited access to the file system objects on the devices attached to the computer. For example, the root user can:</p><ul class="spaceabove"><li class="li"><p>Read, write, and execute any file</p></li><li class="li"><p>Copy, move, and rename any file or folder</p></li><li class="li"><p>Transfer ownership and reset permissions for any file</p></li></ul><p>A major difference between standard BSD permission semantics and the Mac OS X implementation is that in Mac OS X the root user is disabled after system installation. In most cases, it is not necessary for an administrator to run as <code>root</code> (see <span class="content_text"><a href="Concepts.html#//apple_ref/doc/uid/TP30000976-CH203-TPXREF121">“The Admin Group”</a></span>). You may also assume root power by using the <code>sudo</code> utility. Although the <code>sudo</code> utility does not require you to enable the root user, you can use it only from the Terminal application; that is, you must have physical access to the machine to use it. See the <code>sudo</code> man page for more information on its use.</p><p>The root user should not be enabled on user systems. If your application needs to perform operations as the root user, you must use Authorization Services. For more information, see <em><a href="../../../Reference/authorization_ref/index.html#//apple_ref/doc/uid/TP30000826" target="_top">Authorization Services C Reference</a></em> and <em><a href="../../authorization_concepts/index.html#//apple_ref/doc/uid/TP30000995" target="_top">Authorization Services Programming Guide</a></em> in Security Documentation.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP30000976-CH203-SW7" title="Note"></a><p><strong>Note:</strong>&nbsp; In almost all cases you can run as a member of the <a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_232"></a><a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_233"></a><code>admin</code> group or use <code>sudo</code> rather than enabling the root user. If you absolutely must enable the root user, run the NetInfo Manager utility and authenticate yourself as the local administrator. Then choose Enable Root User from the Security menu. This menu item is enabled only if you are a member of the local <code>admin</code> group—a group with special administrative privileges—and you have been previously authenticated in the local domain. Once you’ve enabled the root user, the password is blank, so you should give the root user a password by selecting Change Root Password from the Security menu. After you’ve completed the task requiring root access, you should relinquish root user privileges by choosing Disable Root User from the Security menu.</p></div><p>Whereas most user permissions apply across networks, often the concept of a root user does not. In most cases, the root user is mapped to <a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_234"></a><a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_235"></a><strong>nobody</strong>—a special user with very little access. This prevents the root user on one computer from becoming the root user on another computer.</p><a name="//apple_ref/doc/uid/TP30000976-CH203-TPXREF120" title="The Wheel Group"></a><h4>The Wheel Group</h4><p>There is a special group in BSD called the <a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_236"></a><a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_237"></a><strong>wheel group</strong>. Membership in the wheel group confers on users the ability to become the root user by using the <code>su</code> utility on the command line. Users who are not in the wheel group can’t become the root user, even if they have the correct password. In Mac OS X v 10.3 and later, the wheel group is not used. Its functions have been assumed by the <code>admin</code> group.</p><a name="//apple_ref/doc/uid/TP30000976-CH203-TPXREF121" title="The Admin Group"></a><h4>The Admin Group</h4><p>Mac OS X provides the <code>admin</code> group in place of the root user. A member of the <a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_238"></a><a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_239"></a><strong>admin group</strong> (referred to as an <strong>administrator</strong>) can perform almost all functions the root user can, and can do them using the Finder—that is, without resorting to the command line. The only thing the administrator is prevented from doing is directly adding, modifying, or deleting files in the system domain. An administrator can use special applications such as Installer or Software Update for this purpose, however.</p><p>The user who installs Mac OS X on a system becomes automatically the first administrator for the system. Thereafter, this user (or any other administrator) can use Accounts preferences to create accounts on the local system for new users and can grant administrative privileges to any user on the system. </p><a name="//apple_ref/doc/uid/TP30000976-CH203-TPXREF122" title="Network File Systems"></a><h3>Network File Systems</h3><a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_240"></a><p>This section discusses the use of permissions by network file server protocols. Mac OS X supports four network file server protocols:</p><ul class="spaceabove"><li class="li"><p><strong>AFP</strong>—Apple Filing Protocol<a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_241"></a>, the principal file-sharing protocol in Mac OS 9 systems, used by AppleShare servers and clients.</p></li><li class="li"><p><strong>NFS</strong>—Network File System<a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_242"></a>, the main file-sharing protocol used by UNIX systems.</p></li><li class="li"><p><strong>SMB/CIFS</strong>—Server Message Block<a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_243"></a>/Common Internet File System<a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_244"></a>, a file-sharing protocol used on Windows and UNIX systems</p></li><li class="li"><p><strong>WebDAV</strong>—Web-based Distributed Authoring and Versioning<a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_245"></a>, an extension of HTTP that allows collaborative file management on the web.</p></li></ul><a name="//apple_ref/doc/uid/TP30000976-CH203-TPXREF123" title="AFP"></a><h4>AFP</h4><a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_246"></a><p>If the AppleShare client and server both support AFP 3.0, the actual BSD permissions are transported over the connection. If the file or directory on the AFP server has an ACL, the ACL<a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_247"></a> is transported over the connection and the effective permissions<a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_248"></a> are displayed by the Finder. However, enforcement of permissions is done only on the server, not on the client. See <span class="content_text"><a href="Concepts.html#//apple_ref/doc/uid/TP30000976-CH203-CHDJJGBF">“ ACLs”</a></span> for more information on the Mac OS X implementation of ACLs.</p><p>If the connection is using AFP 2.x, you should be aware of the differences in how permissions work:</p><ul class="spaceabove"><li class="li"><p>BSD supports permissions on files, whereas AFP 2.x does not.</p></li><li class="li"><p>BSD implements a “best match” permissions policy: if you’re the owner, you get the owner permissions; if you’re not the owner but you’re in the file’s group, you get the group permissions; otherwise, you get the other permissions. AFP implements a cumulative permissions policy: your permissions are the union of the permissions you derive from the owner, group, and other permissions. For example, if a folder is writable by the group but not by the owner, AFP permissions let the owner modify the folder but BSD permissions do not.</p></li><li class="li"><p>BSD interprets the rwx bits for folders as shown in <span class="content_text"><a href="Concepts.html#//apple_ref/doc/uid/TP30000976-CH203-CJBJGFBF">Table 2-1</a></span>. AFP permissions define them as “See Files”, “See Folders”, and “Make Changes”. When dealing with an AppleShare 2.x server, the Mac OS X AppleShare client maps between these privilege models. A similar mapping applies when you connect to a Mac OS X server using an AppleShare 2.x client.</p></li><li class="li"><p>ACLs are not supported by AFP 2.x.</p></li></ul><p>AFP excludes a process having an EUID of 0 (that is, one running as <code>root</code>) from accessing any data over the network.</p><a name="//apple_ref/doc/uid/TP30000976-CH203-TPXREF124" title="NFS"></a><h4>NFS</h4><a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_249"></a><p>In general, NFS is not a secure protocol, because most NFS servers trust their clients. That is, if a client says that this file operation is done on behalf of user Bob, the server does the operation on behalf of user Bob. However, if you have root access on the client, you can pretend to be user Bob and access any of Bob’s files on the NFS server. To maintain some security, most NFS servers map the <a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_250"></a><a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_251"></a>root user to a special user, <code><a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_252"></a><a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_253"></a>nobody</code>, which owns no files or directories. For this reason, if your EUID is 0 you can, in general, access only those files on an NFS server that allow access to “other”. </p><a name="//apple_ref/doc/uid/TP30000976-CH203-TPXREF125" title="SMB/CIFS"></a><h4>SMB/CIFS</h4><a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_254"></a><p><strong>SMB</strong> is a networking protocol for file sharing commonly used on Windows networks. CIFS is often used as a synonym for SMB. <strong>Samba</strong> is software that implements an SMB/CIFS server on UNIX. Therefore, this file sharing protocol is variously referred to as SMB, CIFS, SMB/CIFS, Samba, and Windows file sharing.</p><p>Mac OS X v10.4 and later implements SMB/CIFS-compatible access control lists (ACLs). Although individual users cannot set or alter ACLs, server administrators can do so. (Administrators can use the SMB server command line to manipulate ACLs, but only if both the client and server are bound to the same Active Directory domain.) However, enforcement of permissions is done only on the server, not on the client. See <span class="content_text"><a href="Concepts.html#//apple_ref/doc/uid/TP30000976-CH203-CHDJJGBF">“ ACLs”</a></span> for more information on the Mac OS X implementation of ACLs.</p><p>For Mac OS X v10.3 and earlier, all of the SMB access controls in Mac OS X are implemented on the server, not the client. Consequently, when a Mac OS X user mounts an SMB file server, the volume, directory, or file mounted appears in the Finder to allow read, write, and execute access and to be owned by the user. However, when the user attempts to open a folder or file, the server evaluates the user’s access permissions and either allows access or prompts the user for a new user name and password before granting access.</p><p>For more information on SMB/CIFS permissions and to learn how to modify their behavior, see the man page for SMB (<code>man 5 smb.conf</code>).</p><a name="//apple_ref/doc/uid/TP30000976-CH203-TPXREF126" title="WebDAV"></a><h4>WebDAV</h4><p>The <strong>WebDAV</strong><a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_255"></a> protocol is an extension to the HTTP<a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_256"></a> protocol that allows users to write and edit web content remotely; that is, over a network connection. The Mac OS X WebDAV file system uses WebDAV and HTTP requests to access resources on a WebDAV-enabled HTTP server as files and directories.</p><p>The WebDAV protocol does not support users and groups. Furthermore, a WebDAV client cannot determine access permissions for files and directories on a WebDAV server before attempting to access them. Therefore, the WebDAV file system in Mac OS X sets the user and group IDs to <code>unknown</code> for all files and directories and the permissions default to <code>read</code>, <code>write</code>, and <code>execute</code> for everyone: user, group, and other.</p><p>When the WebDAV file system sends a request to a WebDAV-enabled HTTP server, the server determines whether authorization is required. If no authorization is required, the server accepts the request. If authorization is required, the server checks for authentication credentials (such as a user name and password) and, if they are present and correct, the server authorizes the client and allows access. If authorization is required and no credentials were sent or the credentials are not correct, the server rejects the request with a challenge for authentication. If the user cannot supply the correct credentials, the WebDAV file system refuses access.</p><p>For more information on the protocols used by the WebDAV file system, see the following documents:</p><ul class="spaceabove"><li class="li"><p><em>Hypertext Transfer Protocol—HTTP/1.1</em><span class="content_text"><a href="http://www.ietf.org/rfc/rfc2616.txt" target="_blank">http://www.ietf.org/rfc/rfc2616.txt</a></span></p></li><li class="li"><p><em>HTTP Authentication: Basic and Digest Access Authentication</em><span class="content_text"><a href="http://www.ietf.org/rfc/rfc2617.txt?number=2617" target="_blank">http://www.ietf.org/rfc/rfc2617.txt</a></span></p></li><li class="li"><p><em>HTTP Extensions for Distributed Authoring—WEBDAV</em><span class="content_text"><a href="http://www.ietf.org/rfc/rfc2518.txt?number=2518" target="_blank">http://www.ietf.org/rfc/rfc2518.txt</a></span><a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_257"></a><a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_258"></a></p></li></ul><a name="//apple_ref/doc/uid/TP30000976-CH203-CHDJHDDB" title="Authorization"></a><h2>Authorization</h2><a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_259"></a><a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_260"></a><p>Mac OS X uses authorization to control access to files and programs. The iPhone OS uses sandboxing for this purpose (see <span class="content_text"><a href="Concepts.html#//apple_ref/doc/uid/TP30000976-CH203-SW1">“Sandboxing and the Mandatory Acccess Control Framework”</a></span>). Before a user or service on Mac OS X can execute a program or gain access to data, it must be authorized to do so. Authorization is normally a three-step process:</p><ol class="ol"><li class="li"><p>Authenticate a user or service (see <span class="content_text"><a href="Concepts.html#//apple_ref/doc/uid/TP30000976-CH203-CHDBGFDJ">“Authentication and Identification Methods”</a></span>).</p></li><li class="li"><p>Determine the user’s or service’s permissions (see <span class="content_text"><a href="Concepts.html#//apple_ref/doc/uid/TP30000976-CH203-CHDJICAE">“Permissions”</a></span>).</p></li><li class="li"><p>Decide whether to give the user or service access to the data or allow them to execute the program.</p></li></ol><p>The first step, authentication, may be omitted in special circumstances, such as when a user is using a ticket (see <span class="content_text"><a href="Concepts.html#//apple_ref/doc/uid/TP30000976-CH203-CHDEBDEA">“Kerberos and Authorization.”</a></span>)</p><p>Authentication and determination of permissions are facilitated by Authorization Services (see <span class="content_text"><a href="../Security_Services/Security_Services.html#//apple_ref/doc/uid/TP30000976-CH204-CHDEEDHC">“Authorization Services”</a></span>). Each individual process, whether the Finder or your application, must then make its own determination of whether to allow access to the data or code it controls. The BSD permissions structure provides a basic level of access permission. You can implement more sophisticated or fine-grained access permissions based on user access lists or security policies of your own design. For example, you can let any user run your application but allow only users who are members of the <code>admin</code> group to change application preferences. </p><p>Authorization Services can be used to implement such security policies. For details, see <em><a href="../../../Reference/authorization_ref/index.html#//apple_ref/doc/uid/TP30000826" target="_top">Authorization Services C Reference</a></em> and <em><a href="../../authorization_concepts/index.html#//apple_ref/doc/uid/TP30000995" target="_top">Authorization Services Programming Guide</a></em> in Security Documentation.<a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_261"></a></p><a name="//apple_ref/doc/uid/TP30000976-CH203-TPXREF127" title="Secure Storage"></a><h2>Secure Storage</h2><a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_262"></a><p><strong>Secure storage</strong> is the protection of data through either access permissions or encryption. Access permissions can prevent users who are not computer experts from gaining access to data but cannot prevent someone who is capable of bypassing the operating system from reading data off the disk or out of memory. Therefore, highly sensitive data must be stored in an encrypted form.</p><p>Mac OS X and iPhone OS provide an API, called <a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_263"></a><strong>Keychain Services</strong>, for securely storing small amounts of data, such as passwords or other short text strings. Mac OS X includes a utility that allows users to store and read the data in the keychain, called Keychain Access. In Mac OS X v10.3 and later, users can encrypt their entire Home folder by using FileVault, available through Security preferences. In Mac OS X, there is no high-level API for general encryption or for encryption of files or directories. You must use the CSSM API to perform such operations. For examples of code using <a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_264"></a>CSSM for common encryption tasks, see the <em><a href="../../../../../samplecode/CryptoSample/index.html#//apple_ref/doc/uid/DTS10001086" target="_top">CryptoSample</a></em> sample code. In iPhone OS, the Certificate, Key, and Trust Services API includes functions for encrypting and decrypting blocks of data. </p><p>In iPhone OS, backups of data to the user’s computer are stored in plaintext, with the exception of passwords and other secrets on the keychain, which remain encrypted in the backup. It is therefore important to use the keychain to store passwords and other data (such as cookies) that are used to access secure web sites, as otherwise this data might be compromised if an unauthorized person gains access to the backup data.</p><a name="//apple_ref/doc/uid/TP30000976-CH203-CHDDFACB" title="Secure Communication"></a><h2>Secure Communication</h2><a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_265"></a><a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_266"></a><p>One important aspect of computer security is the secure communication of data over a network. Although you can devise your own security protocols and use low-level APIs such as BSD sockets and CSSM to implement them, it is usually much more convenient to use standard protocols and higher-level APIs when they are available. Mac OS X uses the SSL and TLS protocols and provides the Secure Transport, CFNetwork, and URL Loading System APIs for secure communication. The CFNetwork API is available on iPhone OS as well.</p><a name="//apple_ref/doc/uid/TP30000976-CH203-CHDJAAJG" title="Protocols for Secure Communication"></a><h3>Protocols for Secure Communication</h3><a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_267"></a><p><a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_268"></a><a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_269"></a><a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_270"></a><strong>SSL</strong> and <strong>TLS</strong> are versions of a security protocol that provides secure communication over a network. They are commonly used over TCP/IP connections such as the Internet. They use certificate-based authentication (<span class="content_text"><a href="Concepts.html#//apple_ref/doc/uid/TP30000976-CH203-CHDBIGCE">“Digital Certificates”</a></span>) to ensure that you are communicating with a valid server, they validate data to prevent tampering, and they can use public-key cryptography (<span class="content_text"><a href="Concepts.html#//apple_ref/doc/uid/TP30000976-CH203-CHDFFFCC">“Asymmetric Keys”</a></span>) to guard against eavesdropping or message forgery. SSL is built into all major browsers and web servers (the most recent versions also include TLS). Whenever you use a secure website—for example, to send your credit card number to a vendor over the Internet—and see a protocol identifier of <code><a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_271"></a>https</code> rather than <code>http</code> at the beginning of the URL, you are using SSL or TLS for communication. </p><p>Although the TLS protocol is not interoperable with SSL, the Mac OS X and iPhone OS implementation of these protocols, <a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_272"></a><a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_273"></a>Secure Transport, switches to SSL 3.0 if it cannot negotiate a TLS session with the other end of the connection. </p><p>Secure Transport uses certificate management and cryptography services provided by CDSA (<span class="content_text"><a href="../Architecture/Architecture.html#//apple_ref/doc/uid/TP30000976-CH202-CHDHEEDC">“CDSA”</a></span>). Secure Transport has no transport-layer dependencies; it can be used with BSD sockets, Open Transport, or any other transport-layer protocol available. </p><p>For more information on the SSL standard, see <span class="content_text"><a href="http://wp.netscape.com/eng/ssl3/" target="_blank">http://wp.netscape.com/eng/ssl3/</a></span> and for the TLS standard, see <span class="content_text"><a href="http://www.ietf.org/html.charters/tls-charter.html" target="_blank">http://www.ietf.org/html.charters/tls-charter.html</a></span>. </p><a name="//apple_ref/doc/uid/TP30000976-CH203-TPXREF128" title="Secure Communication APIs"></a><h3>Secure Communication APIs</h3><p>There are three secure communication APIs in Mac OS X: Secure Transport, CFNetwork, and URL Loading System. The CFNetwork API is also available on iPhone OS.</p><p><a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_274"></a><a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_275"></a><strong>Secure Transport</strong> is the Mac OS X implementation of <a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_276"></a>SSL and <a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_277"></a><a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_278"></a>TLS. Applications are responsible for setting up the network connection and must provide callback functions that Secure Transport calls to perform I/O operations over the network. For more information about the capabilities and use of Secure Transport, see <span class="content_text"><a href="../Security_Services/Security_Services.html#//apple_ref/doc/uid/TP30000976-CH204-CHDHDIBB">“Secure Transport.”</a></span> For complete documentation of the Secure Transport API, see <em><a href="../../../Reference/secureTransportRef/index.html#//apple_ref/doc/uid/TP30000155" target="_top">Secure Transport Reference</a></em> in Security Documentation.</p><p><a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_279"></a><a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_280"></a><strong>CFNetwork</strong> is a high-level C API that makes it easy to create, send, and receive serialized HTTP messages. Because CFNetwork is built on top of Secure Transport, you can encrypt the data stream using any of a variety of SSL or TLS protocol versions. </p><p>For more information about CFNetwork, see <span class="content_text"><a href="../Security_Services/Security_Services.html#//apple_ref/doc/uid/TP30000976-CH204-CHDFGEIH">“CFNetwork.”</a></span></p><p><a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_281"></a><a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_282"></a><strong>URL Loading System</strong> is a higher-level Mac OS X API built on CFNetwork. Rather than creating and maintaining a connection or a data stream, URL Loading System allows you to access the contents of a specific URL, including a secure <code>https://</code> URL. See <span class="content_text"><a href="../Security_Services/Security_Services.html#//apple_ref/doc/uid/TP30000976-CH204-TPXREF103">“URL Loading System.”</a></span><a name="//apple_ref/doc/uid/TP30000976-CH203-DontLinkElementID_283"></a></p>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../Architecture/Architecture.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../Security_Services/Security_Services.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2003, 2008 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2008-10-15<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Security/Conceptual/Security_Overview/Concepts/Concepts.html%3Fid%3DTP30000976-3.1&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Security/Conceptual/Security_Overview/Concepts/Concepts.html%3Fid%3DTP30000976-3.1&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Security/Conceptual/Security_Overview/Concepts/Concepts.html%3Fid%3DTP30000976-3.1&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>