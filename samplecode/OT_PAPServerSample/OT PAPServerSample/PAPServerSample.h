/*	File:		PAPServerSample.h	Contains:	headers, defines for the PAPServerSample.c file	Written by: Rich Kubota		Copyright:	Copyright © 1993-1999 by Apple Computer, Inc., All Rights Reserved.				You may incorporate this Apple sample source code into your program(s) without				restriction. This Apple sample source code has been provided "AS IS" and the				responsibility for its operation is yours. You are not permitted to redistribute				this Apple sample source code as "Apple sample source code" after having made				changes. If you're going to re-distribute the source, we require that you make				it clear in the source that the code was descended from Apple sample source				code, but that you've made changes.	Change History (most recent first):				7/22/1999	Karl Groethe	Updated for Metrowerks Codewarror Pro 2.1				*/#ifndef __PAPSERVERSAMPLE__#define __PAPSERVERSAMPLE__#ifndef __CONDITIONALMACROS__#include <ConditionalMacros.h>#endif#ifdef __cplusplusextern "C" {#endif#if PRAGMA_ALIGN_SUPPORTED#pragma options align=mac68k#endif#if PRAGMA_IMPORT_SUPPORTED#pragma import on#endif#include <stdio.h>#include <Types.h>#include <Memory.h>#include <Resources.h>#include <Events.h>#include "OpenTransport.h"		// open transport files	#include "OpenTptAppleTalk.h"	#define SHOW_DEBUG_FLOW		1	// enable display of DebugStr showing program flow#if SHOW_DEBUG_FLOW#define	DO_DEBUG_LOG		0	// enable a debug log at the beginning#endif// defines for the STR# resource#define kServerStrID	1000	// STR# resource ID for the PAP Server Sample strings#define kOTVersion111	0x01118000#define kOTVersion120	0x01208000enum {	kServerNBPStrID	= 1,	kIdleStrID,	kBusyStrID};#define kZeroQLen		0#define kDynamicSocket	0#define kATPType		3#define TIMEOUT			25 		// seconds#define kMaxHandoffEPs	5		// maximum number of handoff endpoints supported by this sample#define kDITop			0x0050		/* kTopLeft - for positioning the Disk											   Initialization dialogs. */#define kDILeft			0x0070#define kNumBuffers		25		// initial number of packet buffers to allocate#define kUserByteSize	4#define	kPAPDataSize	32768	// if we can, collect 16K of data at a time		// defines for gFlags bits#define OTActiveFlag		0#define	dumpPktsFlag		1#define BufsInitdFlag		4#define InBackGndFlag		5#define BuffsHeldFlag		6#define CheckOptFlag		7#define StatusBusyFlag		8#define StatusIdleFlag		9// flags macros for setting, testing and clearing the gFlag bits#define SetOTActiveFlag(flags)		((flags) |= 1 << OTActiveFlag)#define ClrOTActiveFlag(flags)		((flags) &= (-1 ^ (1 << OTActiveFlag)))#define TstOTActiveFlag(flags)		(((flags) & (1 << OTActiveFlag)) != 0)#define SetdumpPktsFlag(flags)		((flags) |= 1 << dumpPktsFlag)#define ClrdumpPktsFlag(flags)		((flags) &= (-1 ^ (1 << dumpPktsFlag)))#define TstdumpPktsFlag(flags)		(((flags) & (1 << dumpPktsFlag)) != 0)#define SetBufsInitdFlag(flags)		((flags) |= 1 << BufsInitdFlag)#define ClrBufsInitdFlag(flags)		((flags) &= (-1 ^ (1 << BufsInitdFlag)))#define TstBufsInitdFlag(flags)		(((flags) & (1 << BufsInitdFlag)) != 0)#define SetInBackGndFlag(flags)		((flags) |= 1 << InBackGndFlag)#define ClrInBackGndFlag(flags)		((flags) &= (-1 ^ (1 << InBackGndFlag)))#define TstInBackGndFlag(flags)		(((flags) & (1 << InBackGndFlag)) != 0)#define SetBuffsHeldFlag(flags)		((flags) |= 1 << BuffsHeldFlag)#define ClrBuffsHeldFlag(flags)		((flags) &= (-1 ^ (1 << BuffsHeldFlag)))#define TstBuffsHeldFlag(flags)		(((flags) & (1 << BuffsHeldFlag)) != 0)#define SetCheckOptFlag(flags)		((flags) |= 1 << CheckOptFlag)#define ClrCheckOptFlag(flags)		((flags) &= (-1 ^ (1 << CheckOptFlag)))#define TstCheckOptFlag(flags)		(((flags) & (1 << CheckOptFlag)) != 0)#define SetStatusBusyFlag(flags)	((flags) |= 1 << StatusBusyFlag)#define ClrStatusBusyFlag(flags)	((flags) &= (-1 ^ (1 << StatusBusyFlag)))#define TstStatusBusyFlag(flags)	(((flags) & (1 << StatusBusyFlag)) != 0)#define SetStatusIdleFlag(flags)	((flags) |= 1 << StatusIdleFlag)#define ClrStatusIdleFlag(flags)	((flags) &= (-1 ^ (1 << StatusIdleFlag)))#define TstStatusIdleFlag(flags)	(((flags) & (1 << StatusIdleFlag)) != 0)// defines for the semaphore bits#define kInListenLoop		0		// this bit used with OTAtomicSetBit to control re-entrancy into the DoListenAccept procedure#define kInRcvDataFlag		1		// used with OTAtomic calls to check whether in DoReceive call// defines for flags bits#define EPActiveFlag		0		// indicates that the endpoint is active#define EPBoundFlag			1		// indicates the endpoint is bound#define EPListenFlag		2		// indicates that the endpoint has processed a listen request#define EPBusyFlag			3		// used with handoff endpoint to indicate it has accepted 									// a handoff endpoint#define ListenerSavedFlag	4		// a listener has been identified and saved locally#define PassconFlag			6		// the passive connection has completed#define EOMOnFlag			7		// EOM option enabled#define ListenPendFlag		10#define AcceptPendFlag		11#define	TempFileFlag		12		// indicates that a temp file has been opened for data to this endpoint#define InPSQueryFlag		13		// indicates that the endpoint is currently processing a PS query#define HasDataFlag			14		// indicates that there is more to read for this endpoint#define OrdDisconFlag		15		// indicates that the server received an orderly discon event// flags macros for setting, testing and clearing the flag bits#define SetEPActiveFlag(flags)		((flags) |= 1 << EPActiveFlag)#define ClrEPActiveFlag(flags)		((flags) &= (-1 ^ (1 << EPActiveFlag)))#define TstEPActiveFlag(flags)		(((flags) & (1 << EPActiveFlag)) != 0)#define SetEPBoundFlag(flags)		((flags) |= 1 << EPBoundFlag)#define ClrEPBoundFlag(flags)		((flags) &= (-1 ^ (1 << EPBoundFlag)))#define TstEPBoundFlag(flags)		(((flags) & (1 << EPBoundFlag)) != 0)#define SetEPListenFlag(flags)		((flags) |= 1 << EPListenFlag)#define ClrEPListenFlag(flags)		((flags) &= (-1 ^ (1 << EPListenFlag)))#define TstEPListenFlag(flags)		(((flags) & (1 << EPListenFlag)) != 0)#define SetEPBusyFlag(flags)		((flags) |= 1 << EPBusyFlag)#define ClrEPBusyFlag(flags)		((flags) &= (-1 ^ (1 << EPBusyFlag)))#define TstEPBusyFlag(flags)		(((flags) & (1 << EPBusyFlag)) != 0)#define SetListenerSavedFlag(flags)	((flags) |= 1 << ListenerSavedFlag)#define ClrListenerSavedFlag(flags)	((flags) &= (-1 ^ (1 << ListenerSavedFlag)))#define TstListenerSavedFlag(flags)	(((flags) & (1 << ListenerSavedFlag)) != 0)#define SetPassconFlag(flags)		((flags) |= 1 << PassconFlag)#define ClrPassconFlag(flags)		((flags) &= (-1 ^ (1 << PassconFlag)))#define TstPassconFlag(flags)		(((flags) & (1 << PassconFlag)) != 0)#define SetEOMOnFlag(flags)			((flags) |= 1 << EOMOnFlag)#define ClrEOMOnFlag(flags)			((flags) &= (-1 ^ (1 << EOMOnFlag)))#define TstEOMOnFlag(flags)			(((flags) & (1 << EOMOnFlag)) != 0)#define SetListenPendFlag(flags)	((flags) |= 1 << ListenPendFlag)#define ClrListenPendFlag(flags)	((flags) &= (-1 ^ (1 << ListenPendFlag)))#define TstListenPendFlag(flags)	(((flags) & (1 << ListenPendFlag)) != 0)#define SetAcceptPendFlag(flags)	((flags) |= 1 << AcceptPendFlag)#define ClrAcceptPendFlag(flags)	((flags) &= (-1 ^ (1 << AcceptPendFlag)))#define TstAcceptPendFlag(flags)	(((flags) & (1 << AcceptPendFlag)) != 0)#define SetTempFileFlag(flags)		((flags) |= 1 << TempFileFlag)#define ClrTempFileFlag(flags)		((flags) &= (-1 ^ (1 << TempFileFlag)))#define TstTempFileFlag(flags)		(((flags) & (1 << TempFileFlag)) != 0)#define SetInPSQueryFlag(flags)		((flags) |= 1 << InPSQueryFlag)#define ClrInPSQueryFlag(flags)		((flags) &= (-1 ^ (1 << InPSQueryFlag)))#define TstInPSQueryFlag(flags)		(((flags) & (1 << InPSQueryFlag)) != 0)#define SetHasDataFlag(flags)		((flags) |= 1 << HasDataFlag)#define ClrHasDataFlag(flags)		((flags) &= (-1 ^ (1 << HasDataFlag)))#define TstHasDataFlag(flags)		(((flags) & (1 << HasDataFlag)) != 0)#define SetOrdDisconFlag(flags)		((flags) |= 1 << OrdDisconFlag)#define ClrOrdDisconFlag(flags)		((flags) &= (-1 ^ (1 << OrdDisconFlag)))#define TstOrdDisconFlag(flags)		(((flags) & (1 << OrdDisconFlag)) != 0)enum {	kLookingForEndStr = 1,	kLookingForQueryStr,	kLookingForDefaultResponse,	kLookingForEOFStr};enum {	kSetBusyStr = 1,	kSetIdleStr,	kAcceptOption,	kDeclineOption,	kQuitTest};	/********************************************************************************* Structures********************************************************************************/typedef struct MyEndpointRef MyEndpointRef;typedef struct {		OTLink		fLink;						// first field standard for OTLink list		OTFlags		flags;		MyEndpointRef *theEp;					// save the endpoint ref associated with the endpoint		UInt32		lastPos;					// last scanned position in the buffer		UInt32		numBytes;					// numBytes in this packet		OTTimeStamp	timeStamp;					// timestamp of this packet		UInt8		data[kPAPDataSize];			// data bytes of packet} PacketBuffer;typedef PacketBuffer *PacketPtr;struct MyEndpointRef{	EndpointRef		ep;	UInt32			flags;	OTLIFO			*usedQ;					// ptr to incoming packet queue for this connection	PacketPtr		prevPtr;				// used while processing a postscript											// query where we have to save the previous packet											// in order to complete processing of queries.	OTTimeStamp		timeDataIn;				// timestamp of first incoming packet	OTTimeStamp 	timeDataEnd;			// timestamp of last incoming packet	OTTimeStamp		timerDog;				// timestamp of most recent packet	UInt32			numBytesIn;				// number of bytes received for a connection	UInt16			psState;				// state while processing a postscript query	short			fRefNum;				// file ref num of temp file associated											//	with this endpoint	UInt8			semaphore;	UInt8			dummy;};// Prototypesextern void DoValueBreak(long value, const char* message);#if PRAGMA_IMPORT_SUPPORTED#pragma import off#endif#if PRAGMA_ALIGN_SUPPORTED#pragma options align=reset#endif#ifdef __cplusplus}#endif#endif /* __PAPSERVERSAMPLE__ */