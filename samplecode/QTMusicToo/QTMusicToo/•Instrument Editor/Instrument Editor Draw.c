/* * file: Instrument Editor Draw.c * * started 10 June 1992 * david van brink * *//*--------------------------	Inclusions--------------------------*/#include "BigEasy2.h"#include "BigEasyGrafish.h"#include "IE PrintUtilities.h"#include "Instrument Editor.h"/*--------------------------	Prototytpes--------------------------*/#define 	kKnobAffectsOthers 16static void DrawSlidersDoc(TDoc *d);static void GetSliderClip(TDoc *d,Rect *r);static pascal void ScrollAction(ControlHandle cH, short part);static void DoStatLine(short line,short face,StringPtr s);static void PinPoint(Rect *r,Point *p);void GoSliderBack(void);static TDoc *gTheDoc;/*--------------------------	Cow--------------------------*/void DrawDoc(short n)/* * Draws the window. */	{	TDoc *d;	Rect r;	d = &gDoc[n - kFirstDocWindow];	GoBW();	r = qd.thePort->portRect;	r.bottom = kHeaderHeight;	EraseRect(&r);	MoveTo(0,kHeaderHeight-3);	Line(r.right,0);	MoveTo(0,kHeaderHeight-1);	Line(r.right,0);	TextFont(3);	TextSize(9);	TextFace(bold);	MoveTo(3,kHeaderHeight - 6);	DrawChar('Ò');	DrawString(d->sd.name);	DrawChar('Ó');	TextFace(0);	DrawString("\p, ");	PrintPlural(d->sd.instrumentCount + (d->sd.flags & kSynthesizerGMSuperset ? 128 : 0),			"\pNo","\pROM Instrument","\ps", "\p, ");	PrintPlural(d->sd.modifiableInstrumentCount, "\pNo","\pUser Instrument","\ps", "\p, ");	PrintPlural(d->sd.voiceCount, "\pNo","\pVoice","\ps", "\p");	GoBW();	r = gBigRect;	r.right = kSliderzoneLeft;	r.top = kHeaderHeight;	RGBFore(48000,48000,48000);	RGBBack(48000,48000,48000);	PaintRect(&r);	GoBW();	MoveTo(kSliderzoneLeft-1,kHeaderHeight);	Line(0,10000);	r = d->statBounds;	InsetRect(&r,-1,-1);	FrameRect(&r);	MoveTo(r.right,r.top + 2);	LineTo(r.right,r.bottom);	LineTo(r.left + 2,r.bottom);	DrawKeyboard(&d->kd);	DrawStats(d);	DrawControls(d->w);	r = (**d->listH).rView;	r.right += 15;	InsetRect(&r,-1,-1);	FrameRect(&r);	TextFont(3);	TextSize(9);	TextFace(0);	EraseRect(&(**d->listH).rView);	if(d->listH)		LUpdate(qd.thePort->visRgn,d->listH);	GoBW();	MoveTo(r.right,r.top+2);	LineTo(r.right,r.bottom);	LineTo(r.left+2,r.bottom);	SetupSliderClipDoc(d);	DrawSlidersDoc(d);	DoneSliderClipDoc(d);	MoveTo(kSliderzoneLeft-1,kHeaderHeight);	Line(0,10000);	}void DoStatLine(short line,short face,StringPtr s)	{	MoveTo(kStatLeft + 4,kStatTop + line * kTextAllowance);	TextFace(face);	if(s)		DrawString(s);		}void DrawStats(TDoc *d)	{	Rect r;	ClipRect(&d->statBounds);	TextFont(3);	TextSize(9);	TextFace(0);	GoBW();	EraseRect(&d->statBounds);	DoStatLine(1,0,"\pInstrument:");	DoStatLine(2,bold,"\p   ");	DrawString(d->instrumentName);	DoStatLine(3,0,nil);	PrintPlural(d->globalKnobCount,			"\pNo","\pGlobal Knob","\ps", "\p");	DoStatLine(4,0,nil);	PrintPlural(d->instrumentKnobCount,			"\pNo","\pInstrument Knob","\ps", "\p");	ClipRect(&gBigRect);	}void GoSliderBack(void)	{	RGBBack(62535,49000,65535);	}void DrawSlidersDoc(TDoc *d)	{	Rect r;	GoSliderBack();	r = d->visibleSliderBounds;	OffsetRect(&r,-r.left,-r.top);	EraseRect(&gBigRect);	GoBW();	DrawEasyControlList(d->ecl);	}void ResizeDoc(short n, Point *oldSize, Point *newSize, short modifiers)	{	TDoc *d;	d = &gDoc[n - kFirstDocWindow];	GoBW();	SizeWindow(qd.thePort,newSize->h,newSize->v,true);	FixForSize(d);	}void FixForSize(TDoc *d)	{	Rect r;	long x;	Point wSize;	GoBW();	wSize.h = d->w->portRect.right;	wSize.v = d->w->portRect.bottom;	r = (**d->listH).rView;	r.right = kInstrumentListRight - 16;	x = (d->w->portRect.bottom - kDocMargin - r.top) / kInstrumentListCellHeight;	if(x <= 0)		x = 1;	r.bottom = kInstrumentListCellHeight * x + r.top;	TextFont(3);	TextSize(9);	TextFace(0);	LSize(r.right - r.left,r.bottom - r.top,d->listH);	LDoDraw(true,d->listH);	r.top = kInstrumentListTop;	r.right = kSliderzoneLeft;	r.left = 0;	r.bottom = 10000;	InvalRect(&r);	GoBW();	HideControl(d->horizontalScroller);	HideControl(d->verticalScroller);	r = d->w->portRect;	r.left += kSliderzoneLeft - 1;	r.right -= 14;	r.top = r.bottom - 15;	r.bottom += 1;	ValidRect(&r);	MoveControl(d->horizontalScroller,r.left,r.top);	SizeControl(d->horizontalScroller,r.right - r.left,r.bottom - r.top);	r = d->w->portRect;	r.left = r.right - 15;	r.top += kHeaderHeight - 1;	r.bottom -= 14;	r.right += 1;	ValidRect(&r);	MoveControl(d->verticalScroller,r.left,r.top);	SizeControl(d->verticalScroller,r.right - r.left,r.bottom - r.top);	GetSliderClip(d,&d->visibleSliderBounds);	InvalRect(&d->visibleSliderBounds);	x = d->virtualSliderBounds.right			- d->visibleSliderBounds.right + d->visibleSliderBounds.left;	if(x < 0)		{		x = 0;		d->lastH = 0;		}	SetCtlMax(d->horizontalScroller,x);	d->lastH = GetCtlValue(d->horizontalScroller);	x = d->virtualSliderBounds.bottom			- d->visibleSliderBounds.bottom + d->visibleSliderBounds.top;	if(x < 0)		{		x = 0;		d->lastV = 0;		}	SetCtlMax(d->verticalScroller,x);	d->lastV = GetCtlValue(d->verticalScroller);	ShowControl(d->horizontalScroller);	ShowControl(d->verticalScroller);	}void PinPoint(Rect *r,Point *p)	{	if(p->h < r->left)		p->h = r->left;	if(p->h > r->right)		p->h = r->right;	if(p->v < r->top)		p->v = r->top;	if(p->v > r->bottom)		p->v = r->bottom;	}void ClickDoc(short n,Point p,short mods)/* * Come here for a click in the window. */	{	ControlClickResult ccr;	TDoc *d;	ComponentResult result;	Point lastP;	ControlHandle cH;	short part;	Rect r;	d = &gDoc[n - kFirstDocWindow];	gTheDoc = d;	TextFont(3);	TextSize(9);	TextFace(0);	GoBW();	r = (**d->listH).rView;	r.right += 16;	if(PtInRect(p,&r))		{		Boolean doubleClick;		doubleClick = LClick(p,mods,d->listH);		if(doubleClick)			{			Cell c;			c = LLastClick(d->listH);			SetInstrumentForDoc(d,d->instrument[c.v]);			}		FixUpMenus(d);		goto goHome;		}	if(p.v < kHeaderHeight)		{		MusicPlayNote(d->ci,d->part,p.h,0x64);		while(StillDown());		MusicPlayNote(d->ci,d->part,p.h,0);		goto goHome;		}	part = FindControl(p,d->w,&cH);	if(cH)		{		if(part == inThumb)			{			TrackControl(cH,p,nil);			NewScrollDoc(d,true,nil);			}		else			TrackControl(cH,p,ScrollAction);		goto goHome;		}	if(PtInRect(p,&d->visibleSliderBounds) && !(mods & optionKey))		{		Point p2;		TextFont(3);		TextSize(9);		SetupSliderClipDoc(d);		p2.h = p.h - d->visibleSliderBounds.left + d->lastH;		p2.v = p.v - d->visibleSliderBounds.top + d->lastV;		ClickEasyControlList(d->ecl,p2,&ccr,mods);			if(ccr.tracked)			{			if(d->whichList == mInstrumentKnobs)				{				result = MusicSetPartKnob(d->ci,d->part,ccr.id + 1,ccr.value);				if ( (*d->ikdList)[ccr.id].flags & kKnobAffectsOthers )					UpdateSliderKnobs(d);				}			else if(d->whichList == mControllers)				result = MusicSetController(d->ci,d->part,ccr.id,ccr.value);			else				{				result = MusicSetKnob(d->ci,ccr.id + 1,ccr.value);				if ( (*d->gkdList)[ccr.id].flags & kKnobAffectsOthers )					UpdateSliderKnobs(d);				}			DoneSliderClipDoc(d);			FlashResult(result);			}		DoneSliderClipDoc(d);		if(ccr.tracked)			goto goHome;		}	if(PtInRect(p,&d->kd.r))		{		short pitch,lastPitch;		lastPitch = -1;		while(StillDown())			{			pitch = GetKeyboardKey(&d->kd,p);			GetMouse(&p);			if(pitch != lastPitch)				{				MusicPlayNote(d->ci,d->part,lastPitch,0);				if(pitch >= 0)					MusicPlayNote(d->ci,d->part,pitch,0x64);				PaintKeyboardKey(&d->kd,lastPitch,0);				PaintKeyboardKey(&d->kd,pitch,255);				lastPitch = pitch;				}			PaintKeyboardVector(&d->kd,d->keyVel);			}		PaintKeyboardKey(&d->kd,lastPitch,0);		MusicPlayNote(d->ci,d->part,lastPitch,0);		goto goHome;		}	/* Default: Drag controller area */	if(PtInRect(p,&d->visibleSliderBounds))		{		Point p2,lastP2;		RgnHandle rH,scrollRgn,updateRgn;		Rect clipR,movingR,r;		short x,y;		GoCursor(128);		rH = NewRgn();		scrollRgn = NewRgn();		updateRgn = NewRgn();		OpenRgn();		movingR = clipR = r = d->visibleSliderBounds;		InsetRect(&r,2,2);		FrameRect(&r);		InsetRect(&r,2,2);		FrameRect(&r);		CloseRgn(rH);		p2 = lastP2 = p;		ClipRect(&clipR);		InvertRgn(rH);		ClipRect(&gBigRect);		x = GetCtlValue(d->horizontalScroller);		y = GetCtlValue(d->verticalScroller);		r.left = p2.h - (GetControlMaximum(d->horizontalScroller) - x);		r.right = p2.h + (x - GetControlMinimum(d->horizontalScroller));		r.top = p2.v - (GetControlMaximum(d->verticalScroller) - y);		r.bottom = p2.v + (y - GetControlMinimum(d->verticalScroller));		GoSliderBack();		do			{			GetMouse(&p2);			PinPoint(&r,&p2);			if(p2.h != lastP2.h || p2.v != lastP2.v)				{				short dh,dv;				Rect swollenMovingR;				ClipRect(&clipR);				dh = p2.h - lastP2.h;				dv = p2.v - lastP2.v;				swollenMovingR = movingR;				if(dh > 0)					swollenMovingR.right += dh;				else					swollenMovingR.left += dh;				if(dv > 0)					swollenMovingR.bottom += dv;				else					swollenMovingR.top += dv;				InvertRgn(rH);				OffsetRgn(rH,dh,dv);				ScrollRect(&swollenMovingR,dh,dv,scrollRgn);				UnionRgn(updateRgn,scrollRgn,updateRgn);				InvertRgn(rH);				ClipRect(&gBigRect);				OffsetRect(&movingR,dh,dv);				SectRect(&movingR,&clipR,&movingR);				lastP2 = p2;				SetCtlValue(d->horizontalScroller,x + p.h - p2.h);				SetCtlValue(d->verticalScroller,y + p.v - p2.v);				}			} while(StillDown());		GoBW();		ClipRect(&clipR);		InvertRgn(rH);		ClipRect(&gBigRect);		DisposeRgn(rH);		DisposeRgn(scrollRgn);		GoArrow();		NewScrollDoc(d,false,updateRgn);		DisposeRgn(updateRgn);		}goHome:;	}#define kSmallBump 66#define kLargeBump (kSliderWidth+kDocMargin)pascal void ScrollAction(ControlHandle cH, short part)	{	long oldValue,bump;	oldValue = GetCtlValue(cH);	switch(part)		{		case inUpButton:			bump = -kSmallBump;			break;		case inDownButton:			bump = kSmallBump;			break;		case inPageUp:			bump = - kLargeBump;			break;		case inPageDown:			bump = kLargeBump;			break;		default:			bump = 0;		}	SetCtlValue(cH,bump+oldValue);	NewScrollDoc(gTheDoc,true,nil);	}void NewScrollDoc(TDoc *d,Boolean doScroll,RgnHandle updateRgn)/* * Check for scroller movement, and * redraw the scrollable area if necessary. */	{	long newH, newV;	newH = GetCtlValue(d->horizontalScroller);	newV = GetCtlValue(d->verticalScroller);	if(newH != d->lastH || newV != d->lastV)		{		RgnHandle rH1,rH2;		Rect r;		rH1 = NewRgn();		rH2 = NewRgn();		r = d->visibleSliderBounds;		GoBW();		RGBBack(62535,49000,65535);		if(doScroll)			ScrollRect(&r,-newH + d->lastH,-newV + d->lastV,rH1);		else if(updateRgn)			CopyRgn(updateRgn,rH1);					d->lastH = newH;		d->lastV = newV;		OffsetRgn(rH1,- d->visibleSliderBounds.left + newH,				- d->visibleSliderBounds.top + newV);		SetupSliderClipDoc(d);		GetClip(rH2);		SectRgn(rH1,rH2,rH1);		SetClip(rH1);		DrawSlidersDoc(d);		DoneSliderClipDoc(d);		DisposeRgn(rH1);		DisposeRgn(rH2);		}	}void GetSliderClip(TDoc *d,Rect *r)	{	*r = d->w->portRect;	r->top += kHeaderHeight;	r->left += kSliderzoneLeft;	r->right -= 15;	r->bottom -= 15;	}void SetupSliderClipDoc(TDoc *d)	{	Rect sliderRect;	short x,y;	sliderRect = d->visibleSliderBounds;	GoBW();	x = d->lastH - sliderRect.left;	y = d->lastV - sliderRect.top;	SetOrigin(x,y);	OffsetRect(&sliderRect,x,y);	ClipRect(&sliderRect);	}void DoneSliderClipDoc(TDoc *d)	{	SetOrigin(0,0);	ClipRect(&gBigRect);	}