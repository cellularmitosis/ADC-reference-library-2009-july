<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>vImage Morphology Reference</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="vImage Morphology Reference"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP40005492-DontLinkChapterID_1" title="vImage Morphology Reference"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../../reference/index.html#//apple_ref/doc/uid/TP30001281" target="_top">Reference</a> &gt; <a href="../../../../../reference/Performance/index.html#//apple_ref/doc/uid/TP30001281-TP30000430" target="_top">Performance</a> &gt; <a href="../../../../../reference/Performance/idxGraphicsImaging-date.html#//apple_ref/doc/uid/TP30001281-TP30000430-TP30000450" target="_top">Graphics &amp; Imaging</a> &gt; <a href="../index.html" target="_top">vImage Morphology Reference</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <!-- Previous button --><span style="margin-left: 8px"><a href="../revhx.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP40005492-DontLinkChapterID_1-DontLinkElementID_7" title="vImage Morphology Reference"></a><h1>vImage Morphology Reference</h1><div class="spec_sheet_info_box"><table cellspacing="0" class="specbox"><tr><td scope="row"><strong><span style="white-space: nowrap;">Framework</span></strong></td><td><div style="margin-bottom:1px"><a href="../../vDSP_Reference_Collection/index.html#//apple_ref/doc/uid/TP40006226" target="_top">Accelerate</a>/vImage</div></td></tr><tr><td scope="row"><strong><span class="noWrap">Companion guide</span></strong></td><td><div style="margin-bottom:1px"><span class="content_text"><a href="../../../Conceptual/vImage/index.html#//apple_ref/doc/uid/TP30001001" target="_top">vImage Programming Guide</a></span><br/></div></td></tr><tr><td scope="row"><strong><span style="white-space: nowrap;">Declared in</span></strong></td><td><div style="margin-bottom:1px"><span class="content_text">Morphology.h</span><br/></div></td></tr></table></div><br/><a name="//apple_ref/doc/uid/TP40005492-CH1-DontLinkElementID_5" title="Overview"></a><h2>Overview</h2><p>Morphological functions change the shape of an object by performing dilatation, erosion, maximum, and minimum operations. Dilation expands objects. Erosion contracts them. Maximum is a special case of dilation, while minimum is a special case of erosion. The precise nature of the expanding or shrinking is determined by a kernel (also known as a <em>structure element</em>) provided by the caller. The number of rows and number of columns  of the image does not change after applying a morphological operation.</p><p>You can use morphological functions on grayscale images, where the source image is planar (single-channel) or on full-color images. The kernel itself is always planar.</p><p>vImage applies morphological operations to an <strong>object</strong>, which is not the same as the entire image. An object is either comprised of the brightest pixels in an image or the darkest pixels in the image, where brightness is defined relative to the particular image. When you define bright pixels as the object, dark pixels become the background. In this case dilation expands objects with erosion contracts them. When you define dark pixels as the object, bright pixels become the background. In this case, dilation contracts objects and erosion expands them.</p><p>Each morphological function requires that you pass it a convolution kernel that determines how the values of neighboring pixels are used to compute the value of a destination pixel. A kernel is a packed array, without padding at the ends of the rows. The elements of the array must be of type <code>uint8_t</code> (for the Planar8 and ARGB8888 formats) or of type <code>float</code> (for the PlanarF and ARGBFFFF formats). The height and the width of the array must both be odd numbers.</p><p>For example, a 3 x 3 convolution kernel for a Planar8 image consists of nine 8-bit (1-byte) values, arranged consecutively. The first three values represent the first row of the kernel, the next three values the second row, and the last three values the third row.</p><p>Morphology functions perform clipping to prevent overflow for the Planar8 and ARGB8888 formats. Saturated clipping maps all intensity levels above 255, to 255, all intensity levels below 0, to 0, and leaves intensity levels between 0 and 255, inclusive, unchanged.</p><p>When the pixel to be transformed is near the edge of the image—not merely the region of interest, but the entire image of which it is a part—the kernel may extend beyond the edge of the image, so that there are no existing pixels beneath some of the kernel  elements. In this case the morphology functions only make use of that part of the kernel which overlaps the source buffer. The other kernel elements are ignored.</p><a name="//apple_ref/doc/uid/TP40005492-DontLinkChapterID_1-DontLinkElementID_6" title="Functions by Task"></a><h2>Functions by Task</h2>
<a name="//apple_ref/doc/uid/TP40005492-CH210-DontLinkElementID_1" title="Dilating an Object"></a>
    
    <h3 class="tasks">Dilating an Object</h3>
        
    <ul class="tooltip">
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImageDilate_ARGBFFFF">vImageDilate_ARGBFFFF</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Dilates a region of interest within an ARGBFFFF source image using an M x N kernel.'/>
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImageDilate_ARGB8888">vImageDilate_ARGB8888</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Dilates a region of interest within an ARGB8888 source image using an M x N kernel. '/>
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImageDilate_PlanarF">vImageDilate_PlanarF</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Dilates a region of interest within a PlanarF source image using an M x N kernel. '/>
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImageDilate_Planar8">vImageDilate_Planar8</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Dilates a region of interest within a Planar8 source image using an M x N kernel. '/>
            </span></li>
    </ul>


<a name="//apple_ref/doc/uid/TP40005492-CH210-DontLinkElementID_2" title="Eroding an Object"></a>
    
    <h3 class="tasks">Eroding an Object</h3>
        
    <ul class="tooltip">
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImageErode_ARGBFFFF">vImageErode_ARGBFFFF</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Erodes a region of interest within an ARGBFFFF  source image using an M x N kernel. '/>
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImageErode_ARGB8888">vImageErode_ARGB8888</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Erodes a region of interest within an ARGB8888 source image using an M x N kernel. '/>
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImageErode_PlanarF">vImageErode_PlanarF</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Erodes a region of interest within a PlanarF source image using an M x N kernel. '/>
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImageErode_Planar8">vImageErode_Planar8</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Erodes a region of interest within a Planar8 source image using an M x N kernel. '/>
            </span></li>
    </ul>


<a name="//apple_ref/doc/uid/TP40005492-CH210-DontLinkElementID_3" title="Maximizing an Object"></a>
    
    <h3 class="tasks">Maximizing an Object</h3>
        
    <ul class="tooltip">
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImageMax_ARGBFFFF">vImageMax_ARGBFFFF</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Maximizes a region of interest within an ARGBFFFF source image using an M x N kernel. '/>
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImageMax_ARGB8888">vImageMax_ARGB8888</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Maximizes a region of interest within an ARGB8888 source image using an M x N kernel.  '/>
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImageMax_PlanarF">vImageMax_PlanarF</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Maximizes with a region of interest within a PlanarF source image using an M x N kernel.'/>
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImageMax_Planar8">vImageMax_Planar8</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Maximizes  a region of interest within a Planar8 source image using an M x N kernel. '/>
            </span></li>
    </ul>


<a name="//apple_ref/doc/uid/TP40005492-CH210-DontLinkElementID_4" title="Minimizing an Object"></a>
    
    <h3 class="tasks">Minimizing an Object</h3>
        
    <ul class="tooltip">
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImageMin_ARGBFFFF">vImageMin_ARGBFFFF</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Minimizes a region of interest within an ARGBFFFF source image using an M x N kernel.  '/>
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImageMin_ARGB8888">vImageMin_ARGB8888</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Minimizes a region of interest within an ARGB8888 source image using an M x N kernel.  '/>
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImageMin_PlanarF">vImageMin_PlanarF</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Minimizes a region of interest within a PlanarF source image using an M x N kernel. '/>
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImageMin_Planar8">vImageMin_Planar8</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Minimizes a region of interest within a Planar8 source image using an M x N kernel. '/>
            </span></li>
    </ul>


<a name="//apple_ref/doc/uid/TP40005492-CH210-281689" title="Getting the Buffer Size"></a><a name="//apple_ref/doc/uid/TP40005492-CH210-TPXREF107" title="Getting the Buffer Size"></a>
    
    <h3 class="tasks">Getting the Buffer Size</h3>
        
    <ul class="tooltip">
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/vImageGetMinimumTempBufferSizeForMinMax">vImageGetMinimumTempBufferSizeForMinMax</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Returns the minimum size, in bytes, for the temporary buffer that the caller supplies to any of the Min or Max morphological functions.&#032;(<font color="red">Deprecated.</font>&#032;Use the <code>kvImageGetTempBufferSize</code> flag with the appropriate morphological function instead of calling this function.)'/>
            </span></li>
    </ul>

<a name="//apple_ref/doc/uid/TP40005492-CH210-222475" title="Functions"></a><a name="//apple_ref/doc/uid/TP40005492-CH210-BBCCEIDH" title="Functions"></a><h2><a name="//apple_ref/doc/uid/TP40005492-CH210-TPXREF102" title="Functions"></a>Functions</h2>                  <a name="//apple_ref/c/func/vImageDilate_ARGB8888" title="vImageDilate_ARGB8888"></a><a name="//apple_ref/doc/c_ref/vImageDilate_ARGB8888" title="vImageDilate_ARGB8888"></a><a name="//apple_ref/doc/uid/TP40005492-CH210-vImageDilate_ARGB8888" title="vImageDilate_ARGB8888"></a><a name="//apple_ref/doc/uid/TP40005492-CH210-DontLinkElementID_9"></a><h3 class="tight">vImageDilate_ARGB8888</h3> <p class="spaceabove">Dilates a region of interest within an ARGB8888 source image using an M x N kernel. </p> <p class="spaceabove"><pre>
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Error" target="_top">vImage_Error</a> vImageDilate_ARGB8888 (
   const <!--a-->vImage_Buffer<!--/a--> *src,
   const <!--a-->vImage_Buffer<!--/a--> *dest,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImagePixelCount" target="_top">vImagePixelCount</a> srcOffsetToROI_X,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImagePixelCount" target="_top">vImagePixelCount</a> srcOffsetToROI_Y,
   const unsigned char *kernel,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImagePixelCount" target="_top">vImagePixelCount</a> kernel_height,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImagePixelCount" target="_top">vImagePixelCount</a> kernel_width,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags
);
</pre></p> <h5 class="tight">Parameters</h5><dl class="termdef"> <dt><em>src</em></dt> <dd><p>A pointer to a vImage buffer structure that contains data for the source image.</p></dd> <dt><em>dest</em></dt> <dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.  On return, the data buffer pointed to by this structure contains  the destination image data. When you no longer need the data buffer, you must deallocate the memory.</p><p>The size (number of rows and number of columns) of the destination buffer also specifies the size of the region of interest in the source buffer.</p></dd> <dt><em>srcOffsetToROI_X</em></dt> <dd><p>The horizontal offset, in pixels, to the upper-left pixel of the region of interest within the source image.</p></dd> <dt><em>srcOffsetToROI_Y</em></dt> <dd><p>The vertical offset, in pixels, to the upper-left pixel of the region of interest within the source image.</p></dd> <dt><em>kernel</em></dt> <dd><p>A pointer to the kernel data, which must be a packed array without any padding. The function uses the same kernel for all channels.</p></dd> <dt><em>kernel_height</em></dt> <dd><p>The height of the kernel in pixels. This value must be odd.</p></dd> <dt><em>kernel_width</em></dt> <dd><p>The width of the kernel in pixels. This value must be odd.</p></dd> <dt><em>flags</em></dt> <dd><p>The options to use when performing the morphological operation. Set the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageDoNotTile" target="_top">kvImageDoNotTile</a></code> flag if you plan to perform your own tiling or use multithreading. Set the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageLeaveAlphaUnchanged" target="_top">kvImageLeaveAlphaUnchanged</a></code> flag to specify that the alpha channel should be copied to the destination image unchanged.</p></dd></dl> <h5 class="tight">Return Value</h5><p><code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageNoError" target="_top">kvImageNoError</a></code>, otherwise it returns one of the error codes described in <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>.</p><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.3 and later.</li></ul><h5 class="tight">Declared In</h5><code>Morphology.h</code><a name="//apple_ref/c/func/vImageDilate_ARGBFFFF" title="vImageDilate_ARGBFFFF"></a><a name="//apple_ref/doc/c_ref/vImageDilate_ARGBFFFF" title="vImageDilate_ARGBFFFF"></a><a name="//apple_ref/doc/uid/TP40005492-CH210-vImageDilate_ARGBFFFF" title="vImageDilate_ARGBFFFF"></a><a name="//apple_ref/doc/uid/TP40005492-CH210-DontLinkElementID_10"></a><h3 class="tight">vImageDilate_ARGBFFFF</h3> <p class="spaceabove">Dilates a region of interest within an ARGBFFFF source image using an M x N kernel.</p> <p class="spaceabove"><pre>
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Error" target="_top">vImage_Error</a> vImageDilate_ARGBFFFF (
   const <!--a-->vImage_Buffer<!--/a--> *src,
   const <!--a-->vImage_Buffer<!--/a--> *dest,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImagePixelCount" target="_top">vImagePixelCount</a> srcOffsetToROI_X,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImagePixelCount" target="_top">vImagePixelCount</a> srcOffsetToROI_Y,
   const float *kernel,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImagePixelCount" target="_top">vImagePixelCount</a> kernel_height,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImagePixelCount" target="_top">vImagePixelCount</a> kernel_width,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags
);
</pre></p> <h5 class="tight">Parameters</h5><dl class="termdef"> <dt><em>src</em></dt> <dd><p>A pointer to a vImage buffer structure that contains data for the source image.</p></dd> <dt><em>dest</em></dt> <dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.  On return, the data buffer pointed to by this structure contains  the destination image data. When you no longer need the data buffer, you must deallocate the memory.</p><p>The size (number of rows and number of columns) of the destination buffer also specifies the size of the region of interest in the source buffer.</p></dd> <dt><em>srcOffsetToROI_X</em></dt> <dd><p>The horizontal offset, in pixels, to the upper-left pixel of the region of interest within the source image.</p></dd> <dt><em>srcOffsetToROI_Y</em></dt> <dd><p>The vertical offset, in pixels, to the upper-left pixel of the region of interest within the source image.</p></dd> <dt><em>kernel</em></dt> <dd><p>A pointer to the kernel data, which must be a packed array without any padding.</p></dd> <dt><em>kernel_height</em></dt> <dd><p>The height of the kernel in pixels. This value must be odd.</p></dd> <dt><em>kernel_width</em></dt> <dd><p>The width of the kernel in pixels. This value must be odd.</p></dd> <dt><em>flags</em></dt> <dd><p>The options to use when performing the morphological operation. Set the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageDoNotTile" target="_top">kvImageDoNotTile</a></code> flag if you plan to perform your own tiling or use multithreading. Set the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageLeaveAlphaUnchanged" target="_top">kvImageLeaveAlphaUnchanged</a></code> flag to specify that the alpha channel should be copied to the destination image unchanged.</p></dd></dl> <h5 class="tight">Return Value</h5> <p><code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageNoError" target="_top">kvImageNoError</a></code>, otherwise it returns one of the error codes described in <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>.</p> <h5 class="tight">Discussion</h5> <p>This function uses the same kernel is for all channels. In addition to supplying space for the destination image, the <code>dest</code> parameter also specifies the size of the region of interest in within the source image. The region of interest has the same height and width (in pixels) as the destination buffer pointed to by dest.</p><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.3 and later.</li></ul><h5 class="tight">Declared In</h5><code>Morphology.h</code><a name="//apple_ref/c/func/vImageDilate_Planar8" title="vImageDilate_Planar8"></a><a name="//apple_ref/doc/c_ref/vImageDilate_Planar8" title="vImageDilate_Planar8"></a><a name="//apple_ref/doc/uid/TP40005492-CH210-vImageDilate_Planar8" title="vImageDilate_Planar8"></a><a name="//apple_ref/doc/uid/TP40005492-CH210-DontLinkElementID_11"></a><h3 class="tight">vImageDilate_Planar8</h3> <p class="spaceabove">Dilates a region of interest within a Planar8 source image using an M x N kernel. </p> <p class="spaceabove"><pre>
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Error" target="_top">vImage_Error</a> vImageDilate_Planar8 (
   const <!--a-->vImage_Buffer<!--/a--> *src,
   const <!--a-->vImage_Buffer<!--/a--> *dest,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImagePixelCount" target="_top">vImagePixelCount</a> srcOffsetToROI_X,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImagePixelCount" target="_top">vImagePixelCount</a> srcOffsetToROI_Y,
   const unsigned char *kernel,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImagePixelCount" target="_top">vImagePixelCount</a> kernel_height,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImagePixelCount" target="_top">vImagePixelCount</a> kernel_width,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags
);
</pre></p> <h5 class="tight">Parameters</h5><dl class="termdef"> <dt><em>src</em></dt> <dd><p>A pointer to a vImage buffer structure that contains data for the source image.</p></dd> <dt><em>dest</em></dt> <dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.  On return, the data buffer pointed to by this structure contains  the destination image data. When you no longer need the data buffer, you must deallocate the memory.</p><p>The size (number of rows and number of columns) of the destination buffer also specifies the size of the region of interest in the source buffer.</p></dd> <dt><em>srcOffsetToROI_X</em></dt> <dd><p>The horizontal offset, in pixels, to the upper-left pixel of the region of interest within the source image.</p></dd> <dt><em>srcOffsetToROI_Y</em></dt> <dd><p>The vertical offset, in pixels, to the upper-left pixel of the region of interest within the source image.</p></dd> <dt><em>kernel</em></dt> <dd><p>A pointer to the kernel data, which must be a packed array without any padding.</p></dd> <dt><em>kernel_height</em></dt> <dd><p>The height of the kernel in pixels. This value must be odd.</p></dd> <dt><em>kernel_width</em></dt> <dd><p>The width of the kernel in pixels. This value must be odd.</p></dd> <dt><em>flags</em></dt> <dd><p>The options to use when performing the morphological operation. Set the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageDoNotTile" target="_top">kvImageDoNotTile</a></code> flag if you plan to perform your own tiling or use multithreading. Set the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageLeaveAlphaUnchanged" target="_top">kvImageLeaveAlphaUnchanged</a></code> flag to specify that the alpha channel should be copied to the destination image unchanged.</p></dd></dl> <h5 class="tight">Return Value</h5><p><code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageNoError" target="_top">kvImageNoError</a></code>, otherwise it returns one of the error codes described in <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>.</p><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.3 and later.</li></ul><h5 class="tight">Declared In</h5><code>Morphology.h</code><a name="//apple_ref/c/func/vImageDilate_PlanarF" title="vImageDilate_PlanarF"></a><a name="//apple_ref/doc/c_ref/vImageDilate_PlanarF" title="vImageDilate_PlanarF"></a><a name="//apple_ref/doc/uid/TP40005492-CH210-vImageDilate_PlanarF" title="vImageDilate_PlanarF"></a><a name="//apple_ref/doc/uid/TP40005492-CH210-DontLinkElementID_12"></a><h3 class="tight">vImageDilate_PlanarF</h3> <p class="spaceabove">Dilates a region of interest within a PlanarF source image using an M x N kernel. </p> <p class="spaceabove"><pre>
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Error" target="_top">vImage_Error</a> vImageDilate_PlanarF (
   const <!--a-->vImage_Buffer<!--/a--> *src,
   const <!--a-->vImage_Buffer<!--/a--> *dest,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImagePixelCount" target="_top">vImagePixelCount</a> srcOffsetToROI_X,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImagePixelCount" target="_top">vImagePixelCount</a> srcOffsetToROI_Y,
   const float *kernel,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImagePixelCount" target="_top">vImagePixelCount</a> kernel_height,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImagePixelCount" target="_top">vImagePixelCount</a> kernel_width,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags
);
</pre></p> <h5 class="tight">Parameters</h5><dl class="termdef"> <dt><em>src</em></dt> <dd><p>A pointer to a vImage buffer structure that contains data for the source image.</p></dd> <dt><em>dest</em></dt> <dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.  On return, the data buffer pointed to by this structure contains  the destination image data. When you no longer need the data buffer, you must deallocate the memory.</p><p>The size (number of rows and number of columns) of the destination buffer also specifies the size of the region of interest in the source buffer.</p></dd> <dt><em>srcOffsetToROI_X</em></dt> <dd><p>The horizontal offset, in pixels, to the upper-left pixel of the region of interest within the source image.</p></dd> <dt><em>srcOffsetToROI_Y</em></dt> <dd><p>The vertical offset, in pixels, to the upper-left pixel of the region of interest within the source image.</p></dd> <dt><em>kernel</em></dt> <dd><p>A pointer to the kernel data, which must be a packed array without any padding.</p></dd> <dt><em>kernel_height</em></dt> <dd><p>The height of the kernel in pixels. This value must be odd.</p></dd> <dt><em>kernel_width</em></dt> <dd><p>The width of the kernel in pixels. This value must be odd.</p></dd> <dt><em>flags</em></dt> <dd><p>The options to use when performing the morphological operation. Set the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageDoNotTile" target="_top">kvImageDoNotTile</a></code> flag if you plan to perform your own tiling or use multithreading. Set the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageLeaveAlphaUnchanged" target="_top">kvImageLeaveAlphaUnchanged</a></code> flag to specify that the alpha channel should be copied to the destination image unchanged.</p></dd></dl> <h5 class="tight">Return Value</h5><p><code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageNoError" target="_top">kvImageNoError</a></code>, otherwise it returns one of the error codes described in <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>.</p><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.3 and later.</li></ul><h5 class="tight">Declared In</h5><code>Morphology.h</code><a name="//apple_ref/c/func/vImageErode_ARGB8888" title="vImageErode_ARGB8888"></a><a name="//apple_ref/doc/c_ref/vImageErode_ARGB8888" title="vImageErode_ARGB8888"></a><a name="//apple_ref/doc/uid/TP40005492-CH210-vImageErode_ARGB8888" title="vImageErode_ARGB8888"></a><a name="//apple_ref/doc/uid/TP40005492-CH210-DontLinkElementID_13"></a><h3 class="tight">vImageErode_ARGB8888</h3> <p class="spaceabove">Erodes a region of interest within an ARGB8888 source image using an M x N kernel. </p> <p class="spaceabove"><pre>
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Error" target="_top">vImage_Error</a> vImageErode_ARGB8888 (
   const <!--a-->vImage_Buffer<!--/a--> *src,
   const <!--a-->vImage_Buffer<!--/a--> *dest,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImagePixelCount" target="_top">vImagePixelCount</a> srcOffsetToROI_X,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImagePixelCount" target="_top">vImagePixelCount</a> srcOffsetToROI_Y,
   const unsigned char *kernel,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImagePixelCount" target="_top">vImagePixelCount</a> kernel_height,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImagePixelCount" target="_top">vImagePixelCount</a> kernel_width,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags
);
</pre></p> <h5 class="tight">Parameters</h5><dl class="termdef"> <dt><em>src</em></dt> <dd><p>A pointer to a vImage buffer structure that contains data for the source image.</p></dd> <dt><em>dest</em></dt> <dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.  On return, the data buffer pointed to by this structure contains  the destination image data. When you no longer need the data buffer, you must deallocate the memory.</p><p>The size (number of rows and number of columns) of the destination buffer also specifies the size of the region of interest in the source buffer.</p></dd> <dt><em>srcOffsetToROI_X</em></dt> <dd><p>The horizontal offset, in pixels, to the upper-left pixel of the region of interest within the source image.</p></dd> <dt><em>srcOffsetToROI_Y</em></dt> <dd><p>The vertical offset, in pixels, to the upper-left pixel of the region of interest within the source image.</p></dd> <dt><em>kernel</em></dt> <dd><p>A pointer to the kernel data, which must be a packed array without any padding.  The function uses the same kernel for all channels.</p></dd> <dt><em>kernel_height</em></dt> <dd><p>The height of the kernel in pixels. This value must be odd.</p></dd> <dt><em>kernel_width</em></dt> <dd><p>The width of the kernel in pixels. This value must be odd.</p></dd> <dt><em>flags</em></dt> <dd><p>The options to use when performing the morphological operation. Set the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageDoNotTile" target="_top">kvImageDoNotTile</a></code> flag if you plan to perform your own tiling or use multithreading. Set the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageLeaveAlphaUnchanged" target="_top">kvImageLeaveAlphaUnchanged</a></code> flag to specify that the alpha channel should be copied to the destination image unchanged.</p></dd></dl> <h5 class="tight">Return Value</h5><p><code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageNoError" target="_top">kvImageNoError</a></code>, otherwise it returns one of the error codes described in <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>.</p><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.3 and later.</li></ul><h5 class="tight">Declared In</h5><code>Morphology.h</code><a name="//apple_ref/c/func/vImageErode_ARGBFFFF" title="vImageErode_ARGBFFFF"></a><a name="//apple_ref/doc/c_ref/vImageErode_ARGBFFFF" title="vImageErode_ARGBFFFF"></a><a name="//apple_ref/doc/uid/TP40005492-CH210-vImageErode_ARGBFFFF" title="vImageErode_ARGBFFFF"></a><a name="//apple_ref/doc/uid/TP40005492-CH210-DontLinkElementID_14"></a><h3 class="tight">vImageErode_ARGBFFFF</h3> <p class="spaceabove">Erodes a region of interest within an ARGBFFFF  source image using an M x N kernel. </p> <p class="spaceabove"><pre>
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Error" target="_top">vImage_Error</a> vImageErode_ARGBFFFF (
   const <!--a-->vImage_Buffer<!--/a--> *src,
   const <!--a-->vImage_Buffer<!--/a--> *dest,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImagePixelCount" target="_top">vImagePixelCount</a> srcOffsetToROI_X,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImagePixelCount" target="_top">vImagePixelCount</a> srcOffsetToROI_Y,
   const float *kernel,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImagePixelCount" target="_top">vImagePixelCount</a> kernel_height,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImagePixelCount" target="_top">vImagePixelCount</a> kernel_width,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags
);
</pre></p> <h5 class="tight">Parameters</h5><dl class="termdef"> <dt><em>src</em></dt> <dd><p>A pointer to a vImage buffer structure that contains data for the source image.</p></dd> <dt><em>dest</em></dt> <dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.  On return, the data buffer pointed to by this structure contains  the destination image data. When you no longer need the data buffer, you must deallocate the memory.</p><p>The size (number of rows and number of columns) of the destination buffer also specifies the size of the region of interest in the source buffer.</p></dd> <dt><em>srcOffsetToROI_X</em></dt> <dd><p>The horizontal offset, in pixels, to the upper-left pixel of the region of interest within the source image.</p></dd> <dt><em>srcOffsetToROI_Y</em></dt> <dd><p>The vertical offset, in pixels, to the upper-left pixel of the region of interest within the source image.</p></dd> <dt><em>kernel</em></dt> <dd><p>A pointer to the kernel data, which must be a packed array without any padding.  The function uses the same kernel for all channels.</p></dd> <dt><em>kernel_height</em></dt> <dd><p>The height of the kernel in pixels. This value must be odd.</p></dd> <dt><em>kernel_width</em></dt> <dd><p>The width of the kernel in pixels. This value must be odd.</p></dd> <dt><em>flags</em></dt> <dd><p>The options to use when performing the morphological operation. Set the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageDoNotTile" target="_top">kvImageDoNotTile</a></code> flag if you plan to perform your own tiling or use multithreading. Set the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageLeaveAlphaUnchanged" target="_top">kvImageLeaveAlphaUnchanged</a></code> flag to specify that the alpha channel should be copied to the destination image unchanged.</p></dd></dl> <h5 class="tight">Return Value</h5><p><code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageNoError" target="_top">kvImageNoError</a></code>, otherwise it returns one of the error codes described in <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>.</p><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.3 and later.</li></ul><h5 class="tight">Declared In</h5><code>Morphology.h</code><a name="//apple_ref/c/func/vImageErode_Planar8" title="vImageErode_Planar8"></a><a name="//apple_ref/doc/c_ref/vImageErode_Planar8" title="vImageErode_Planar8"></a><a name="//apple_ref/doc/uid/TP40005492-CH210-vImageErode_Planar8" title="vImageErode_Planar8"></a><a name="//apple_ref/doc/uid/TP40005492-CH210-DontLinkElementID_15"></a><h3 class="tight">vImageErode_Planar8</h3> <p class="spaceabove">Erodes a region of interest within a Planar8 source image using an M x N kernel. </p> <p class="spaceabove"><pre>
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Error" target="_top">vImage_Error</a> vImageErode_Planar8 (
   const <!--a-->vImage_Buffer<!--/a--> *src,
   const <!--a-->vImage_Buffer<!--/a--> *dest,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImagePixelCount" target="_top">vImagePixelCount</a> srcOffsetToROI_X,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImagePixelCount" target="_top">vImagePixelCount</a> srcOffsetToROI_Y,
   const unsigned char *kernel,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImagePixelCount" target="_top">vImagePixelCount</a> kernel_height,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImagePixelCount" target="_top">vImagePixelCount</a> kernel_width,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags
);
</pre></p> <h5 class="tight">Parameters</h5><dl class="termdef"> <dt><em>src</em></dt> <dd><p>A pointer to a vImage buffer structure that contains data for the source image.</p></dd> <dt><em>dest</em></dt> <dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.  On return, the data buffer pointed to by this structure contains  the destination image data. When you no longer need the data buffer, you must deallocate the memory.</p><p>The size (number of rows and number of columns) of the destination buffer also specifies the size of the region of interest in the source buffer.</p></dd> <dt><em>srcOffsetToROI_X</em></dt> <dd><p>The horizontal offset, in pixels, to the upper-left pixel of the region of interest within the source image.</p></dd> <dt><em>srcOffsetToROI_Y</em></dt> <dd><p>The vertical offset, in pixels, to the upper-left pixel of the region of interest within the source image.</p></dd> <dt><em>kernel</em></dt> <dd><p>A pointer to the kernel data, which must be a packed array without any padding.</p></dd> <dt><em>kernel_height</em></dt> <dd><p>The height of the kernel in pixels. This value must be odd.</p></dd> <dt><em>kernel_width</em></dt> <dd><p>The width of the kernel in pixels. This value must be odd.</p></dd> <dt><em>flags</em></dt> <dd><p>The options to use when performing the morphological operation. Set the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageDoNotTile" target="_top">kvImageDoNotTile</a></code> flag if you plan to perform your own tiling or use multithreading. Set the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageLeaveAlphaUnchanged" target="_top">kvImageLeaveAlphaUnchanged</a></code> flag to specify that the alpha channel should be copied to the destination image unchanged.</p></dd></dl> <h5 class="tight">Return Value</h5><p><code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageNoError" target="_top">kvImageNoError</a></code>, otherwise it returns one of the error codes described in <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>.</p><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.3 and later.</li></ul><h5 class="tight">Declared In</h5><code>Morphology.h</code><a name="//apple_ref/c/func/vImageErode_PlanarF" title="vImageErode_PlanarF"></a><a name="//apple_ref/doc/c_ref/vImageErode_PlanarF" title="vImageErode_PlanarF"></a><a name="//apple_ref/doc/uid/TP40005492-CH210-vImageErode_PlanarF" title="vImageErode_PlanarF"></a><a name="//apple_ref/doc/uid/TP40005492-CH210-DontLinkElementID_16"></a><h3 class="tight">vImageErode_PlanarF</h3> <p class="spaceabove">Erodes a region of interest within a PlanarF source image using an M x N kernel. </p> <p class="spaceabove"><pre>
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Error" target="_top">vImage_Error</a> vImageErode_PlanarF (
   const <!--a-->vImage_Buffer<!--/a--> *src,
   const <!--a-->vImage_Buffer<!--/a--> *dest,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImagePixelCount" target="_top">vImagePixelCount</a> srcOffsetToROI_X,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImagePixelCount" target="_top">vImagePixelCount</a> srcOffsetToROI_Y,
   const float *kernel,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImagePixelCount" target="_top">vImagePixelCount</a> kernel_height,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImagePixelCount" target="_top">vImagePixelCount</a> kernel_width,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags
);
</pre></p> <h5 class="tight">Parameters</h5><dl class="termdef"> <dt><em>src</em></dt> <dd><p>A pointer to a vImage buffer structure that contains data for the source image.</p></dd> <dt><em>dest</em></dt> <dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.  On return, the data buffer pointed to by this structure contains  the destination image data. When you no longer need the data buffer, you must deallocate the memory.</p><p>The size (number of rows and number of columns) of the destination buffer also specifies the size of the region of interest in the source buffer.</p></dd> <dt><em>srcOffsetToROI_X</em></dt> <dd><p>The horizontal offset, in pixels, to the upper-left pixel of the region of interest within the source image.</p></dd> <dt><em>srcOffsetToROI_Y</em></dt> <dd><p>The vertical offset, in pixels, to the upper-left pixel of the region of interest within the source image.</p></dd> <dt><em>kernel</em></dt> <dd><p>A pointer to the kernel data, which must be a packed array without any padding.</p></dd> <dt><em>kernel_height</em></dt> <dd><p>The height of the kernel in pixels. This value must be odd.</p></dd> <dt><em>kernel_width</em></dt> <dd><p>The width of the kernel in pixels. This value must be odd.</p></dd> <dt><em>flags</em></dt> <dd><p>The options to use when performing the morphological operation. Set the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageDoNotTile" target="_top">kvImageDoNotTile</a></code> flag if you plan to perform your own tiling or use multithreading. Set the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageLeaveAlphaUnchanged" target="_top">kvImageLeaveAlphaUnchanged</a></code> flag to specify that the alpha channel should be copied to the destination image unchanged.</p></dd></dl> <h5 class="tight">Return Value</h5><p><code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageNoError" target="_top">kvImageNoError</a></code>, otherwise it returns one of the error codes described in <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>.</p><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.3 and later.</li></ul><h5 class="tight">Declared In</h5><code>Morphology.h</code><a name="//apple_ref/c/func/vImageGetMinimumTempBufferSizeForMinMax" title="vImageGetMinimumTempBufferSizeForMinMax"></a><a name="//apple_ref/doc/c_ref/vImageGetMinimumTempBufferSizeForMinMax" title="vImageGetMinimumTempBufferSizeForMinMax"></a><a name="//apple_ref/doc/uid/TP40005492-CH210-vImageGetMinimumTempBufferSizeForMinMax" title="vImageGetMinimumTempBufferSizeForMinMax"></a><a name="//apple_ref/doc/uid/TP40005492-CH210-DontLinkElementID_17"></a><h3 class="tight">vImageGetMinimumTempBufferSizeForMinMax</h3> <p class="spaceabove">Returns the minimum size, in bytes, for the temporary buffer that the caller supplies to any of the Min or Max morphological functions.&#032;(<strong>Deprecated.</strong>&#032;Use the <code>kvImageGetTempBufferSize</code> flag with the appropriate morphological function instead of calling this function.)</p> <p class="spaceabove"><pre>
size_t vImageGetMinimumTempBufferSizeForMinMax (
   const <!--a-->vImage_Buffer<!--/a--> *src,
   const <!--a-->vImage_Buffer<!--/a--> *dest,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImagePixelCount" target="_top">vImagePixelCount</a> kernel_height,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImagePixelCount" target="_top">vImagePixelCount</a> kernel_width,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags,
   size_t bytesPerPixel
);
</pre></p> <h5 class="tight">Parameters</h5><dl class="termdef"> <dt><em>src</em></dt> <dd><p>A pointer to the vImage buffer structure that you plan to pass to the Min or Max function.</p></dd> <dt><em>dest</em></dt> <dd><p>A pointer to the vImage buffer structure that you plan to pass to the Min or Max function.</p></dd> <dt><em>kernel_height</em></dt> <dd><p>The height, in pixels, of the kernel that you plan to pass to the Min or Max function.</p></dd> <dt><em>kernel_width</em></dt> <dd><p>The width, in pixels, of the kernel that you plan to pass to the Min or Max function.</p></dd> <dt><em>flags</em></dt> <dd><p>The flags that you plan to pass to the Min or Max function.</p></dd> <dt><em>pixelBytes</em></dt><dd><p>The number of bytes in a pixel. Make sure to pass the value appropriate for the format of the pixel.</p></dd></dl> <h5 class="tight">Return Value</h5> <p>The minimum size, in bytes, of the temporary buffer.</p> <h5 class="tight">Discussion</h5><p>This function uses the <em>height</em> and <em>width</em> fields from the <em>src</em> or <em>dest</em> parameters; it does not use the <em>data</em> or <em>rowBytes</em> fields. If the size of the images you are processing remain the same, then the required size of the buffer also remains the same. More specifically, if, between two calls to <code><a href="reference.html#//apple_ref/doc/c_ref/vImageGetMinimumTempBufferSizeForMinMax">vImageGetMinimumTempBufferSizeForMinMax</a></code>, the <code>height</code> and <code>width</code> of the <em>src</em> and <em>dest</em> parameters do not increase, and the other parameters remain the same, then the result of the <code><a href="reference.html#//apple_ref/doc/c_ref/vImageGetMinimumTempBufferSizeForMinMax">vImageGetMinimumTempBufferSizeForMinMax</a></code> does not increase. This makes it easy to reuse the same temporary buffer when you process a number of images of the same size, as you would when tiling.</p><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.3 and later.</li><li class="availability">Deprecated in Mac OS X v10.4.</li></ul><h5 class="tight">Declared In</h5><code>Morphology.h</code><a name="//apple_ref/c/func/vImageMax_ARGB8888" title="vImageMax_ARGB8888"></a><a name="//apple_ref/doc/c_ref/vImageMax_ARGB8888" title="vImageMax_ARGB8888"></a><a name="//apple_ref/doc/uid/TP40005492-CH210-vImageMax_ARGB8888" title="vImageMax_ARGB8888"></a><a name="//apple_ref/doc/uid/TP40005492-CH210-DontLinkElementID_18"></a><h3 class="tight">vImageMax_ARGB8888</h3> <p class="spaceabove">Maximizes a region of interest within an ARGB8888 source image using an M x N kernel.  </p> <p class="spaceabove"><pre>
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Error" target="_top">vImage_Error</a> vImageMax_ARGB8888 (
   const <!--a-->vImage_Buffer<!--/a--> *src,
   const <!--a-->vImage_Buffer<!--/a--> *dest,
   void *tempBuffer,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImagePixelCount" target="_top">vImagePixelCount</a> srcOffsetToROI_X,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImagePixelCount" target="_top">vImagePixelCount</a> srcOffsetToROI_Y,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImagePixelCount" target="_top">vImagePixelCount</a> kernel_height,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImagePixelCount" target="_top">vImagePixelCount</a> kernel_width,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags
);
</pre></p> <h5 class="tight">Parameters</h5><dl class="termdef"> <dt><em>src</em></dt> <dd><p>A pointer to a vImage buffer structure that contains data for the source image.</p></dd> <dt><em>dest</em></dt> <dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.  On return, the data buffer pointed to by this structure contains  the destination image data. When you no longer need the data buffer, you must deallocate the memory.</p><p>The size (number of rows and number of columns) of the destination buffer also specifies the size of the region of interest in the source buffer.</p></dd> <dt><em>tempBuffer</em></dt> <dd><p>A pointer to a temporary buffer. If you pass <code>NULL</code>, the function allocates the buffer, then deallocates it before returning. Alternatively, you can allocate the buffer yourself, in which case you are responsible for deallocating it when you is no longer need it.</p><p>If you want to allocate the buffer yourself, see the Discussion for information on how to determine the minimum size that you must allocate.</p></dd> <dt><em>srcOffsetToROI_X</em></dt> <dd><p>The horizontal offset, in pixels, to the upper-left pixel of the region of interest within the source image.</p></dd> <dt><em>srcOffsetToROI_Y</em></dt> <dd><p>The vertical offset, in pixels, to the upper-left pixel of the region of interest within the source image.</p></dd> <dt><em>kernel_height</em></dt> <dd><p>The height of the kernel in pixels. This value must be odd.</p></dd> <dt><em>kernel_width</em></dt> <dd><p>The width of the kernel in pixels. This value must be odd.</p></dd> <dt><em>flags</em></dt> <dd><p>The options to use when performing the morphological operation. Set the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageDoNotTile" target="_top">kvImageDoNotTile</a></code> flag if you plan to perform your own tiling or use multithreading. Set the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageLeaveAlphaUnchanged" target="_top">kvImageLeaveAlphaUnchanged</a></code> flag to specify that the alpha channel should be copied to the destination image unchanged. Set the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageGetTempBufferSize" target="_top">kvImageGetTempBufferSize</a></code> flag if you want to determine the minimum size to allocate for the <code>tempBuffer</code> parameter.</p></dd></dl> <h5 class="tight">Return Value</h5><p><code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageNoError" target="_top">kvImageNoError</a></code>, otherwise it returns one of the error codes described in <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>.</p> <h5 class="tight">Discussion</h5> <p>If you want to allocate the memory for the <code>tempBuffer</code> parameter yourself, call this function twice, as follows:</p><ol class="ol"><li class="li"><p>To determine the minimum size for the temporary buffer, the first time you call this function pass the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageGetTempBufferSize" target="_top">kvImageGetTempBufferSize</a></code> flag. Pass the same values for all other parameters that you intend to use in for the second call. The function returns the required minimum size, which should be a positive value. (A negative returned value indicates an error.) The <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageGetTempBufferSize" target="_top">kvImageGetTempBufferSize</a></code> flag prevents the function from performing any processing other than to determine the minimum buffer size.</p></li><li class="li"><p>After you allocate enough space for a buffer of the returned size, call the function a second time, passing a valid pointer in the <code>tempBuffer</code> parameter. This time, do not pass the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageGetTempBufferSize" target="_top">kvImageGetTempBufferSize</a></code> flag.</p></li></ol><p>The morphological operation Max is a special case of the dilation operation. In the Max operation, all the elements of the kernel have the same value. The actual value does not matter; only the size of the kernel is significant. vImage optimizes this special case, so the Max function is considerably faster than the Dilate function called with a uniform kernel.</p><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.3 and later.</li></ul><h5 class="tight">Declared In</h5><code>Morphology.h</code><a name="//apple_ref/c/func/vImageMax_ARGBFFFF" title="vImageMax_ARGBFFFF"></a><a name="//apple_ref/doc/c_ref/vImageMax_ARGBFFFF" title="vImageMax_ARGBFFFF"></a><a name="//apple_ref/doc/uid/TP40005492-CH210-vImageMax_ARGBFFFF" title="vImageMax_ARGBFFFF"></a><a name="//apple_ref/doc/uid/TP40005492-CH210-DontLinkElementID_19"></a><h3 class="tight">vImageMax_ARGBFFFF</h3> <p class="spaceabove">Maximizes a region of interest within an ARGBFFFF source image using an M x N kernel. </p> <p class="spaceabove"><pre>
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Error" target="_top">vImage_Error</a> vImageMax_ARGBFFFF (
   const <!--a-->vImage_Buffer<!--/a--> *src,
   const <!--a-->vImage_Buffer<!--/a--> *dest,
   void *tempBuffer,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImagePixelCount" target="_top">vImagePixelCount</a> srcOffsetToROI_X,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImagePixelCount" target="_top">vImagePixelCount</a> srcOffsetToROI_Y,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImagePixelCount" target="_top">vImagePixelCount</a> kernel_height,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImagePixelCount" target="_top">vImagePixelCount</a> kernel_width,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags
);
</pre></p> <h5 class="tight">Parameters</h5><dl class="termdef"> <dt><em>src</em></dt> <dd><p>A pointer to a vImage buffer structure that contains data for the source image.</p></dd> <dt><em>dest</em></dt> <dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.  On return, the data buffer pointed to by this structure contains  the destination image data. When you no longer need the data buffer, you must deallocate the memory.</p><p>The size (number of rows and number of columns) of the destination buffer also specifies the size of the region of interest in the source buffer.</p></dd> <dt><em>tempBuffer</em></dt> <dd><p>A pointer to a temporary buffer. If you pass <code>NULL</code>, the function allocates the buffer, then deallocates it before returning. Alternatively, you can allocate the buffer yourself, in which case you are responsible for deallocating it when you is no longer need it.</p><p>If you want to allocate the buffer yourself, see the Discussion for information on how to determine the minimum size that you must allocate.</p></dd> <dt><em>srcOffsetToROI_X</em></dt> <dd><p>The horizontal offset, in pixels, to the upper-left pixel of the region of interest within the source image.</p></dd> <dt><em>srcOffsetToROI_Y</em></dt> <dd><p>The vertical offset, in pixels, to the upper-left pixel of the region of interest within the source image.</p></dd> <dt><em>kernel_height</em></dt> <dd><p>The height of the kernel in pixels. This value must be odd.</p></dd> <dt><em>kernel_width</em></dt> <dd><p>The width of the kernel in pixels. This value must be odd.</p></dd> <dt><em>flags</em></dt> <dd><p>The options to use when performing the morphological operation. Set the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageDoNotTile" target="_top">kvImageDoNotTile</a></code> flag if you plan to perform your own tiling or use multithreading. Set the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageLeaveAlphaUnchanged" target="_top">kvImageLeaveAlphaUnchanged</a></code> flag to specify that the alpha channel should be copied to the destination image unchanged.</p></dd></dl> <h5 class="tight">Return Value</h5><p><code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageNoError" target="_top">kvImageNoError</a></code>, otherwise it returns one of the error codes described in <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>.</p> <h5 class="tight">Discussion</h5><p>If you want to allocate the memory for the <code>tempBuffer</code> parameter yourself, call this function twice, as follows:</p><ol class="ol"><li class="li"><p>To determine the minimum size for the temporary buffer, the first time you call this function pass the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageGetTempBufferSize" target="_top">kvImageGetTempBufferSize</a></code> flag. Pass the same values for all other parameters that you intend to use in for the second call. The function returns the required minimum size, which should be a positive value. (A negative returned value indicates an error.) The <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageGetTempBufferSize" target="_top">kvImageGetTempBufferSize</a></code> flag prevents the function from performing any processing other than to determine the minimum buffer size.</p></li><li class="li"><p>After you allocate enough space for a buffer of the returned size, call the function a second time, passing a valid pointer in the <code>tempBuffer</code> parameter. This time, do not pass the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageGetTempBufferSize" target="_top">kvImageGetTempBufferSize</a></code> flag.</p></li></ol> <p>The morphological operation Max is a special case of the dilation operation. In the Max operation, all the elements of the kernel have the same value. The actual value does not matter; only the size of the kernel is significant. vImage optimizes this special case, so the Max function is considerably faster than the Dilate function called with a uniform kernel.</p><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.3 and later.</li></ul><h5 class="tight">Declared In</h5><code>Morphology.h</code><a name="//apple_ref/c/func/vImageMax_Planar8" title="vImageMax_Planar8"></a><a name="//apple_ref/doc/c_ref/vImageMax_Planar8" title="vImageMax_Planar8"></a><a name="//apple_ref/doc/uid/TP40005492-CH210-vImageMax_Planar8" title="vImageMax_Planar8"></a><a name="//apple_ref/doc/uid/TP40005492-CH210-DontLinkElementID_20"></a><h3 class="tight">vImageMax_Planar8</h3> <p class="spaceabove">Maximizes  a region of interest within a Planar8 source image using an M x N kernel. </p> <p class="spaceabove"><pre>
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Error" target="_top">vImage_Error</a> vImageMax_Planar8 (
   const <!--a-->vImage_Buffer<!--/a--> *src,
   const <!--a-->vImage_Buffer<!--/a--> *dest,
   void *tempBuffer,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImagePixelCount" target="_top">vImagePixelCount</a> srcOffsetToROI_X,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImagePixelCount" target="_top">vImagePixelCount</a> srcOffsetToROI_Y,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImagePixelCount" target="_top">vImagePixelCount</a> kernel_height,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImagePixelCount" target="_top">vImagePixelCount</a> kernel_width,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags
);
</pre></p> <h5 class="tight">Parameters</h5><dl class="termdef"> <dt><em>src</em></dt> <dd><p>A pointer to a vImage buffer structure that contains data for the source image.</p></dd> <dt><em>dest</em></dt> <dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.  On return, the data buffer pointed to by this structure contains  the destination image data. When you no longer need the data buffer, you must deallocate the memory.</p><p>The size (number of rows and number of columns) of the destination buffer also specifies the size of the region of interest in the source buffer.</p></dd> <dt><em>tempBuffer</em></dt> <dd><p>A pointer to a temporary buffer. If you pass <code>NULL</code>, the function allocates the buffer, then deallocates it before returning. Alternatively, you can allocate the buffer yourself, in which case you are responsible for deallocating it when you is no longer need it.</p><p>If you want to allocate the buffer yourself, see the Discussion for information on how to determine the minimum size that you must allocate.</p></dd> <dt><em>srcOffsetToROI_X</em></dt> <dd><p>The horizontal offset, in pixels, to the upper-left pixel of the region of interest within the source image.</p></dd> <dt><em>srcOffsetToROI_Y</em></dt> <dd><p>The vertical offset, in pixels, to the upper-left pixel of the region of interest within the source image.</p></dd> <dt><em>kernel_height</em></dt> <dd><p>The height of the kernel in pixels. This value must be odd.</p></dd> <dt><em>kernel_width</em></dt> <dd><p>The width of the kernel in pixels. This value must be odd.</p></dd> <dt><em>flags</em></dt> <dd><p>The options to use when performing the morphological operation. Set the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageDoNotTile" target="_top">kvImageDoNotTile</a></code> flag if you plan to perform your own tiling or use multithreading. Set the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageLeaveAlphaUnchanged" target="_top">kvImageLeaveAlphaUnchanged</a></code> flag to specify that the alpha channel should be copied to the destination image unchanged.</p></dd></dl> <h5 class="tight">Return Value</h5><p><code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageNoError" target="_top">kvImageNoError</a></code>, otherwise it returns one of the error codes described in <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>.</p> <h5 class="tight">Discussion</h5><p>If you want to allocate the memory for the <code>tempBuffer</code> parameter yourself, call this function twice, as follows:</p><ol class="ol"><li class="li"><p>To determine the minimum size for the temporary buffer, the first time you call this function pass the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageGetTempBufferSize" target="_top">kvImageGetTempBufferSize</a></code> flag. Pass the same values for all other parameters that you intend to use in for the second call. The function returns the required minimum size, which should be a positive value. (A negative returned value indicates an error.) The <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageGetTempBufferSize" target="_top">kvImageGetTempBufferSize</a></code> flag prevents the function from performing any processing other than to determine the minimum buffer size.</p></li><li class="li"><p>After you allocate enough space for a buffer of the returned size, call the function a second time, passing a valid pointer in the <code>tempBuffer</code> parameter. This time, do not pass the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageGetTempBufferSize" target="_top">kvImageGetTempBufferSize</a></code> flag.</p></li></ol><p>The morphological operation Max is a special case of the dilation operation. In the Max operation, all the elements of the kernel have the same value. The actual value does not matter; only the size of the kernel is significant. vImage optimizes this special case, so the Max function is considerably faster than the Dilate function called with a uniform kernel.</p><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.3 and later.</li></ul><h5 class="tight">Declared In</h5><code>Morphology.h</code><a name="//apple_ref/c/func/vImageMax_PlanarF" title="vImageMax_PlanarF"></a><a name="//apple_ref/doc/c_ref/vImageMax_PlanarF" title="vImageMax_PlanarF"></a><a name="//apple_ref/doc/uid/TP40005492-CH210-vImageMax_PlanarF" title="vImageMax_PlanarF"></a><a name="//apple_ref/doc/uid/TP40005492-CH210-DontLinkElementID_21"></a><h3 class="tight">vImageMax_PlanarF</h3> <p class="spaceabove">Maximizes with a region of interest within a PlanarF source image using an M x N kernel.</p> <p class="spaceabove"><pre>
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Error" target="_top">vImage_Error</a> vImageMax_PlanarF (
   const <!--a-->vImage_Buffer<!--/a--> *src,
   const <!--a-->vImage_Buffer<!--/a--> *dest,
   void *tempBuffer,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImagePixelCount" target="_top">vImagePixelCount</a> srcOffsetToROI_X,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImagePixelCount" target="_top">vImagePixelCount</a> srcOffsetToROI_Y,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImagePixelCount" target="_top">vImagePixelCount</a> kernel_height,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImagePixelCount" target="_top">vImagePixelCount</a> kernel_width,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags
);
</pre></p> <h5 class="tight">Parameters</h5><dl class="termdef"> <dt><em>src</em></dt> <dd><p>A pointer to a vImage buffer structure that contains data for the source image.</p></dd> <dt><em>dest</em></dt> <dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.  On return, the data buffer pointed to by this structure contains  the destination image data. When you no longer need the data buffer, you must deallocate the memory.</p><p>The size (number of rows and number of columns) of the destination buffer also specifies the size of the region of interest in the source buffer.</p></dd> <dt><em>tempBuffer</em></dt> <dd><p>A pointer to a temporary buffer. If you pass <code>NULL</code>, the function allocates the buffer, then deallocates it before returning. Alternatively, you can allocate the buffer yourself, in which case you are responsible for deallocating it when you is no longer need it.</p><p>If you want to allocate the buffer yourself, see the Discussion for information on how to determine the minimum size that you must allocate.</p></dd> <dt><em>srcOffsetToROI_X</em></dt> <dd><p>The horizontal offset, in pixels, to the upper-left pixel of the region of interest within the source image.</p></dd> <dt><em>srcOffsetToROI_Y</em></dt> <dd><p>The vertical offset, in pixels, to the upper-left pixel of the region of interest within the source image.</p></dd> <dt><em>kernel_height</em></dt> <dd><p>The height of the kernel in pixels. This value must be odd.</p></dd> <dt><em>kernel_width</em></dt> <dd><p>The width of the kernel in pixels. This value must be odd.</p></dd> <dt><em>flags</em></dt> <dd><p>The options to use when performing the morphological operation. Set the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageDoNotTile" target="_top">kvImageDoNotTile</a></code> flag if you plan to perform your own tiling or use multithreading. Set the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageLeaveAlphaUnchanged" target="_top">kvImageLeaveAlphaUnchanged</a></code> flag to specify that the alpha channel should be copied to the destination image unchanged.</p></dd></dl> <h5 class="tight">Return Value</h5><p><code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageNoError" target="_top">kvImageNoError</a></code>, otherwise it returns one of the error codes described in <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>.</p> <h5 class="tight">Discussion</h5><p>If you want to allocate the memory for the <code>tempBuffer</code> parameter yourself, call this function twice, as follows:</p><ol class="ol"><li class="li"><p>To determine the minimum size for the temporary buffer, the first time you call this function pass the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageGetTempBufferSize" target="_top">kvImageGetTempBufferSize</a></code> flag. Pass the same values for all other parameters that you intend to use in for the second call. The function returns the required minimum size, which should be a positive value. (A negative returned value indicates an error.) The <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageGetTempBufferSize" target="_top">kvImageGetTempBufferSize</a></code> flag prevents the function from performing any processing other than to determine the minimum buffer size.</p></li><li class="li"><p>After you allocate enough space for a buffer of the returned size, call the function a second time, passing a valid pointer in the <code>tempBuffer</code> parameter. This time, do not pass the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageGetTempBufferSize" target="_top">kvImageGetTempBufferSize</a></code> flag.</p></li></ol><p>The morphological operation Max is a special case of the dilation operation. In the Max operation, all the elements of the kernel have the same value. The actual value does not matter; only the size of the kernel is significant. vImage optimizes this special case, so the Max function is considerably faster than the Dilate function called with a uniform kernel.</p><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.3 and later.</li></ul><h5 class="tight">Declared In</h5><code>Morphology.h</code><a name="//apple_ref/c/func/vImageMin_ARGB8888" title="vImageMin_ARGB8888"></a><a name="//apple_ref/doc/c_ref/vImageMin_ARGB8888" title="vImageMin_ARGB8888"></a><a name="//apple_ref/doc/uid/TP40005492-CH210-vImageMin_ARGB8888" title="vImageMin_ARGB8888"></a><a name="//apple_ref/doc/uid/TP40005492-CH210-DontLinkElementID_22"></a><h3 class="tight">vImageMin_ARGB8888</h3> <p class="spaceabove">Minimizes a region of interest within an ARGB8888 source image using an M x N kernel.  </p> <p class="spaceabove"><pre>
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Error" target="_top">vImage_Error</a> vImageMin_ARGB8888 (
   const <!--a-->vImage_Buffer<!--/a--> *src,
   const <!--a-->vImage_Buffer<!--/a--> *dest,
   void *tempBuffer,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImagePixelCount" target="_top">vImagePixelCount</a> srcOffsetToROI_X,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImagePixelCount" target="_top">vImagePixelCount</a> srcOffsetToROI_Y,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImagePixelCount" target="_top">vImagePixelCount</a> kernel_height,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImagePixelCount" target="_top">vImagePixelCount</a> kernel_width,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags
);
</pre></p> <h5 class="tight">Parameters</h5><dl class="termdef"> <dt><em>src</em></dt> <dd><p>A pointer to a vImage buffer structure that contains data for the source image.</p></dd> <dt><em>dest</em></dt> <dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.  On return, the data buffer pointed to by this structure contains  the destination image data. When you no longer need the data buffer, you must deallocate the memory.</p><p>The size (number of rows and number of columns) of the destination buffer also specifies the size of the region of interest in the source buffer.</p></dd> <dt><em>tempBuffer</em></dt> <dd><p>A pointer to a temporary buffer. If you pass <code>NULL</code>, the function allocates the buffer, then deallocates it before returning. Alternatively, you can allocate the buffer yourself, in which case you are responsible for deallocating it when you is no longer need it.</p><p>If you want to allocate the buffer yourself, see the Discussion for information on how to determine the minimum size that you must allocate.</p></dd> <dt><em>srcOffsetToROI_X</em></dt> <dd><p>The horizontal offset, in pixels, to the upper-left pixel of the region of interest within the source image.</p></dd> <dt><em>srcOffsetToROI_Y</em></dt> <dd><p>The vertical offset, in pixels, to the upper-left pixel of the region of interest within the source image.</p></dd> <dt><em>kernel_height</em></dt> <dd><p>The height of the kernel in pixels. This value must be odd.</p></dd> <dt><em>kernel_width</em></dt> <dd><p>The width of the kernel in pixels. This value must be odd.</p></dd> <dt><em>flags</em></dt> <dd><p>The options to use when performing the morphological operation. Set the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageDoNotTile" target="_top">kvImageDoNotTile</a></code> flag if you plan to perform your own tiling or use multithreading. Set the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageLeaveAlphaUnchanged" target="_top">kvImageLeaveAlphaUnchanged</a></code> flag to specify that the alpha channel should be copied to the destination image unchanged.</p></dd></dl> <h5 class="tight">Return Value</h5><p><code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageNoError" target="_top">kvImageNoError</a></code>, otherwise it returns one of the error codes described in <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>.</p> <h5 class="tight">Discussion</h5><p>If you want to allocate the memory for the <code>tempBuffer</code> parameter yourself, call this function twice, as follows:</p><ol class="ol"><li class="li"><p>To determine the minimum size for the temporary buffer, the first time you call this function pass the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageGetTempBufferSize" target="_top">kvImageGetTempBufferSize</a></code> flag. Pass the same values for all other parameters that you intend to use in for the second call. The function returns the required minimum size, which should be a positive value. (A negative returned value indicates an error.) The <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageGetTempBufferSize" target="_top">kvImageGetTempBufferSize</a></code> flag prevents the function from performing any processing other than to determine the minimum buffer size.</p></li><li class="li"><p>After you allocate enough space for a buffer of the returned size, call the function a second time, passing a valid pointer in the <code>tempBuffer</code> parameter. This time, do not pass the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageGetTempBufferSize" target="_top">kvImageGetTempBufferSize</a></code> flag.</p></li></ol><p>The morphological operation Min is a special case of the erosion operation. In the Min operation, all the elements of the kernel have the same value. The actual value does not matter; only the size of the kernel is significant. vImage optimizes this special case, so the Min function is considerably faster than the Erode function called with a uniform kernel.</p><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.3 and later.</li></ul><h5 class="tight">Declared In</h5><code>Morphology.h</code><a name="//apple_ref/c/func/vImageMin_ARGBFFFF" title="vImageMin_ARGBFFFF"></a><a name="//apple_ref/doc/c_ref/vImageMin_ARGBFFFF" title="vImageMin_ARGBFFFF"></a><a name="//apple_ref/doc/uid/TP40005492-CH210-vImageMin_ARGBFFFF" title="vImageMin_ARGBFFFF"></a><a name="//apple_ref/doc/uid/TP40005492-CH210-DontLinkElementID_23"></a><h3 class="tight">vImageMin_ARGBFFFF</h3> <p class="spaceabove">Minimizes a region of interest within an ARGBFFFF source image using an M x N kernel.  </p> <p class="spaceabove"><pre>
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Error" target="_top">vImage_Error</a> vImageMin_ARGBFFFF (
   const <!--a-->vImage_Buffer<!--/a--> *src,
   const <!--a-->vImage_Buffer<!--/a--> *dest,
   void *tempBuffer,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImagePixelCount" target="_top">vImagePixelCount</a> srcOffsetToROI_X,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImagePixelCount" target="_top">vImagePixelCount</a> srcOffsetToROI_Y,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImagePixelCount" target="_top">vImagePixelCount</a> kernel_height,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImagePixelCount" target="_top">vImagePixelCount</a> kernel_width,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags
);
</pre></p> <h5 class="tight">Parameters</h5><dl class="termdef"> <dt><em>src</em></dt> <dd><p>A pointer to a vImage buffer structure that contains data for the source image.</p></dd> <dt><em>dest</em></dt> <dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.  On return, the data buffer pointed to by this structure contains  the destination image data. When you no longer need the data buffer, you must deallocate the memory.</p><p>The size (number of rows and number of columns) of the destination buffer also specifies the size of the region of interest in the source buffer.</p></dd> <dt><em>tempBuffer</em></dt> <dd><p>A pointer to a temporary buffer. If you pass <code>NULL</code>, the function allocates the buffer, then deallocates it before returning. Alternatively, you can allocate the buffer yourself, in which case you are responsible for deallocating it when you is no longer need it.</p><p>If you want to allocate the buffer yourself, see the Discussion for information on how to determine the minimum size that you must allocate.</p></dd> <dt><em>srcOffsetToROI_X</em></dt> <dd><p>The horizontal offset, in pixels, to the upper-left pixel of the region of interest within the source image.</p></dd> <dt><em>srcOffsetToROI_Y</em></dt> <dd><p>The vertical offset, in pixels, to the upper-left pixel of the region of interest within the source image.</p></dd> <dt><em>kernel_height</em></dt> <dd><p>The height of the kernel in pixels. This value must be odd.</p></dd> <dt><em>kernel_width</em></dt> <dd><p>The width of the kernel in pixels. This value must be odd.</p></dd> <dt><em>flags</em></dt> <dd><p>The options to use when performing the morphological operation. Set the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageDoNotTile" target="_top">kvImageDoNotTile</a></code> flag if you plan to perform your own tiling or use multithreading. Set the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageLeaveAlphaUnchanged" target="_top">kvImageLeaveAlphaUnchanged</a></code> flag to specify that the alpha channel should be copied to the destination image unchanged.</p></dd></dl> <h5 class="tight">Return Value</h5><p><code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageNoError" target="_top">kvImageNoError</a></code>, otherwise it returns one of the error codes described in <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>.</p> <h5 class="tight">Discussion</h5><p>If you want to allocate the memory for the <code>tempBuffer</code> parameter yourself, call this function twice, as follows:</p><ol class="ol"><li class="li"><p>To determine the minimum size for the temporary buffer, the first time you call this function pass the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageGetTempBufferSize" target="_top">kvImageGetTempBufferSize</a></code> flag. Pass the same values for all other parameters that you intend to use in for the second call. The function returns the required minimum size, which should be a positive value. (A negative returned value indicates an error.) The <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageGetTempBufferSize" target="_top">kvImageGetTempBufferSize</a></code> flag prevents the function from performing any processing other than to determine the minimum buffer size.</p></li><li class="li"><p>After you allocate enough space for a buffer of the returned size, call the function a second time, passing a valid pointer in the <code>tempBuffer</code> parameter. This time, do not pass the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageGetTempBufferSize" target="_top">kvImageGetTempBufferSize</a></code> flag.</p></li></ol> <p>The morphological operation Min is a special case of the erosion operation. In the Min operation, all the elements of the kernel have the same value. The actual value does not matter; only the size of the kernel is significant. vImage optimizes this special case, so the Min function is considerably faster than the Erode function called with a uniform kernel.</p><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.3 and later.</li></ul><h5 class="tight">Declared In</h5><code>Morphology.h</code><a name="//apple_ref/c/func/vImageMin_Planar8" title="vImageMin_Planar8"></a><a name="//apple_ref/doc/c_ref/vImageMin_Planar8" title="vImageMin_Planar8"></a><a name="//apple_ref/doc/uid/TP40005492-CH210-vImageMin_Planar8" title="vImageMin_Planar8"></a><a name="//apple_ref/doc/uid/TP40005492-CH210-DontLinkElementID_24"></a><h3 class="tight">vImageMin_Planar8</h3> <p class="spaceabove">Minimizes a region of interest within a Planar8 source image using an M x N kernel. </p> <p class="spaceabove"><pre>
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Error" target="_top">vImage_Error</a> vImageMin_Planar8 (
   const <!--a-->vImage_Buffer<!--/a--> *src,
   const <!--a-->vImage_Buffer<!--/a--> *dest,
   void *tempBuffer,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImagePixelCount" target="_top">vImagePixelCount</a> srcOffsetToROI_X,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImagePixelCount" target="_top">vImagePixelCount</a> srcOffsetToROI_Y,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImagePixelCount" target="_top">vImagePixelCount</a> kernel_height,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImagePixelCount" target="_top">vImagePixelCount</a> kernel_width,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags
);
</pre></p> <h5 class="tight">Parameters</h5><dl class="termdef"> <dt><em>src</em></dt> <dd><p>A pointer to a vImage buffer structure that contains data for the source image.</p></dd> <dt><em>dest</em></dt> <dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.  On return, the data buffer pointed to by this structure contains  the destination image data. When you no longer need the data buffer, you must deallocate the memory.</p><p>The size (number of rows and number of columns) of the destination buffer also specifies the size of the region of interest in the source buffer.</p></dd> <dt><em>tempBuffer</em></dt> <dd><p>A pointer to a temporary buffer. If you pass <code>NULL</code>, the function allocates the buffer, then deallocates it before returning. Alternatively, you can allocate the buffer yourself, in which case you are responsible for deallocating it when you is no longer need it.</p><p>If you want to allocate the buffer yourself, see the Discussion for information on how to determine the minimum size that you must allocate.</p></dd> <dt><em>srcOffsetToROI_X</em></dt> <dd><p>The horizontal offset, in pixels, to the upper-left pixel of the region of interest within the source image.</p></dd> <dt><em>srcOffsetToROI_Y</em></dt> <dd><p>The vertical offset, in pixels, to the upper-left pixel of the region of interest within the source image.</p></dd> <dt><em>kernel_height</em></dt> <dd><p>The height of the kernel in pixels. This value must be odd.</p></dd> <dt><em>kernel_width</em></dt> <dd><p>The width of the kernel in pixels. This value must be odd.</p></dd> <dt><em>flags</em></dt> <dd><p>The options to use when performing the morphological operation. Set the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageDoNotTile" target="_top">kvImageDoNotTile</a></code> flag if you plan to perform your own tiling or use multithreading. Set the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageLeaveAlphaUnchanged" target="_top">kvImageLeaveAlphaUnchanged</a></code> flag to specify that the alpha channel should be copied to the destination image unchanged.</p></dd></dl> <h5 class="tight">Return Value</h5><p><code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageNoError" target="_top">kvImageNoError</a></code>, otherwise it returns one of the error codes described in <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>.</p> <h5 class="tight">Discussion</h5><p>If you want to allocate the memory for the <code>tempBuffer</code> parameter yourself, call this function twice, as follows:</p><ol class="ol"><li class="li"><p>To determine the minimum size for the temporary buffer, the first time you call this function pass the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageGetTempBufferSize" target="_top">kvImageGetTempBufferSize</a></code> flag. Pass the same values for all other parameters that you intend to use in for the second call. The function returns the required minimum size, which should be a positive value. (A negative returned value indicates an error.) The <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageGetTempBufferSize" target="_top">kvImageGetTempBufferSize</a></code> flag prevents the function from performing any processing other than to determine the minimum buffer size.</p></li><li class="li"><p>After you allocate enough space for a buffer of the returned size, call the function a second time, passing a valid pointer in the <code>tempBuffer</code> parameter. This time, do not pass the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageGetTempBufferSize" target="_top">kvImageGetTempBufferSize</a></code> flag.</p></li></ol><p>The morphological operation Min is a special case of the erosion operation. In the Min operation, all the elements of the kernel have the same value. The actual value does not matter; only the size of the kernel is significant. vImage optimizes this special case, so the Min function is considerably faster than the Erode function called with a uniform kernel.</p><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.3 and later.</li></ul><h5 class="tight">Declared In</h5><code>Morphology.h</code><a name="//apple_ref/c/func/vImageMin_PlanarF" title="vImageMin_PlanarF"></a><a name="//apple_ref/doc/c_ref/vImageMin_PlanarF" title="vImageMin_PlanarF"></a><a name="//apple_ref/doc/uid/TP40005492-CH210-vImageMin_PlanarF" title="vImageMin_PlanarF"></a><a name="//apple_ref/doc/uid/TP40005492-CH210-DontLinkElementID_25"></a><h3 class="tight">vImageMin_PlanarF</h3> <p class="spaceabove">Minimizes a region of interest within a PlanarF source image using an M x N kernel. </p> <p class="spaceabove"><pre>
<a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Error" target="_top">vImage_Error</a> vImageMin_PlanarF (
   const <!--a-->vImage_Buffer<!--/a--> *src,
   const <!--a-->vImage_Buffer<!--/a--> *dest,
   void *tempBuffer,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImagePixelCount" target="_top">vImagePixelCount</a> srcOffsetToROI_X,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImagePixelCount" target="_top">vImagePixelCount</a> srcOffsetToROI_Y,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImagePixelCount" target="_top">vImagePixelCount</a> kernel_height,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImagePixelCount" target="_top">vImagePixelCount</a> kernel_width,
   <a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/vImage_Flags" target="_top">vImage_Flags</a> flags
);
</pre></p> <h5 class="tight">Parameters</h5><dl class="termdef"> <dt><em>src</em></dt> <dd><p>A pointer to a vImage buffer structure that contains data for the source image.</p></dd> <dt><em>dest</em></dt> <dd><p>A pointer to a vImage buffer data structure. You are responsible for filling out the <code>height</code>, <code>width</code>, and <code>rowBytes</code> fields of this structure, and for allocating a data buffer of the appropriate size.  On return, the data buffer pointed to by this structure contains  the destination image data. When you no longer need the data buffer, you must deallocate the memory.</p><p>The size (number of rows and number of columns) of the destination buffer also specifies the size of the region of interest in the source buffer.</p></dd> <dt><em>tempBuffer</em></dt> <dd><p>A pointer to a temporary buffer. If you pass <code>NULL</code>, the function allocates the buffer, then deallocates it before returning. Alternatively, you can allocate the buffer yourself, in which case you are responsible for deallocating it when you is no longer need it.</p><p>If you want to allocate the buffer yourself, see the Discussion for information on how to determine the minimum size that you must allocate.</p></dd> <dt><em>srcOffsetToROI_X</em></dt> <dd><p>The horizontal offset, in pixels, to the upper-left pixel of the region of interest within the source image.</p></dd> <dt><em>srcOffsetToROI_Y</em></dt> <dd><p>The vertical offset, in pixels, to the upper-left pixel of the region of interest within the source image.</p></dd> <dt><em>kernel_height</em></dt> <dd><p>The height of the kernel in pixels. This value must be odd.</p></dd> <dt><em>kernel_width</em></dt> <dd><p>The width of the kernel in pixels. This value must be odd.</p></dd> <dt><em>flags</em></dt> <dd><p>The options to use when performing the morphological operation. Set the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageDoNotTile" target="_top">kvImageDoNotTile</a></code> flag if you plan to perform your own tiling or use multithreading. Set the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageLeaveAlphaUnchanged" target="_top">kvImageLeaveAlphaUnchanged</a></code> flag to specify that the alpha channel should be copied to the destination image unchanged.</p></dd></dl> <h5 class="tight">Return Value</h5><p><code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageNoError" target="_top">kvImageNoError</a></code>, otherwise it returns one of the error codes described in <em><a href="../../vImage_types/index.html#//apple_ref/doc/uid/TP40005495" target="_top">vImage Data Types and Constants Reference</a></em>.</p> <h5 class="tight">Discussion</h5><p>If you want to allocate the memory for the <code>tempBuffer</code> parameter yourself, call this function twice, as follows:</p><ol class="ol"><li class="li"><p>To determine the minimum size for the temporary buffer, the first time you call this function pass the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageGetTempBufferSize" target="_top">kvImageGetTempBufferSize</a></code> flag. Pass the same values for all other parameters that you intend to use in for the second call. The function returns the required minimum size, which should be a positive value. (A negative returned value indicates an error.) The <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageGetTempBufferSize" target="_top">kvImageGetTempBufferSize</a></code> flag prevents the function from performing any processing other than to determine the minimum buffer size.</p></li><li class="li"><p>After you allocate enough space for a buffer of the returned size, call the function a second time, passing a valid pointer in the <code>tempBuffer</code> parameter. This time, do not pass the <code><a href="../../vImage_types/Reference/reference.html#//apple_ref/doc/c_ref/kvImageGetTempBufferSize" target="_top">kvImageGetTempBufferSize</a></code> flag.</p></li></ol><p>The morphological operation Min is a special case of the erosion operation. In the Min operation, all the elements of the kernel have the same value. The actual value does not matter; only the size of the kernel is significant. vImage optimizes this special case, so the Min function is considerably faster than the Erode function called with a uniform kernel.</p><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.3 and later.</li></ul><h5 class="tight">Declared In</h5><code>Morphology.h</code>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <!-- Previous button --><span style="margin-left: 8px"><a href="../revhx.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2007 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2007-07-12<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Performance/Reference/vImage_morphological/Reference/reference.html%3Fid%3DTP40005492-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Performance/Reference/vImage_morphological/Reference/reference.html%3Fid%3DTP40005492-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Performance/Reference/vImage_morphological/Reference/reference.html%3Fid%3DTP40005492-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>