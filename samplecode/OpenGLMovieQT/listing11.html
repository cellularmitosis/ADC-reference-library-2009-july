<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>OpenGLMovieQT - /Carbon SetupGL/Carbon_SetupGL.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxQuickTime-date.html">QuickTime</a> &gt; <A HREF="javascript:location.replace('index.html');">OpenGLMovieQT</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/QuickTime/idxGraphicsImaging-date.html" target="_blank">QuickTime > Graphics & Imaging</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">OpenGLMovieQT</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/Carbon SetupGL/Carbon_SetupGL.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/Carbon Include.h</option>
<option value="listing2.html">/Carbon Resource.r</option>
<option value="listing3.html">/Carbon SetupGL/aglString/aglString.c</option>
<option value="listing4.html">/Carbon SetupGL/aglString/aglString.h</option>
<option value="listing5.html">/Carbon SetupGL/Carbon_Error_Handler.c</option>
<option value="listing6.html">/Carbon SetupGL/Carbon_Error_Handler.h</option>
<option value="listing7.html">/Carbon SetupGL/Carbon_Include.h</option>
<option value="listing8.html">/Carbon SetupGL/Carbon_Resource.r</option>
<option value="listing9.html">/Carbon SetupGL/Carbon_SetupDSp.c</option>
<option value="listing10.html">/Carbon SetupGL/Carbon_SetupDSp.h</option>
<option value="listing11.html">/Carbon SetupGL/Carbon_SetupGL.c</option>
<option value="listing12.html">/Carbon SetupGL/Carbon_SetupGL.h</option>
<option value="listing13.html">/Carbon SetupGL/Carbon_SetupGL_Test.c</option>
<option value="listing14.html">/OpenGL Movie Controls.c</option>
<option value="listing15.html">/OpenGL Movie Main.c</option>
<option value="listing16.html">/OpenGL Movie.c</option>
<option value="listing17.html">/OpenGLMovie.h</option></select>
				</p>
				</form>
				<p><strong><a href="OpenGLMovieQT.zip">Download Sample</a></strong> (&#147;OpenGLMovieQT.zip&#148;, 139.4K)<BR>
<strong><a href="OpenGLMovieQT.dmg">Download Sample</a></strong> (&#147;OpenGLMovieQT.dmg&#148;, 197.4K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*
  File:    Carbon SetupGL.c

  Contains:  Functions to enable building and destorying a GL full screen or windowed context

  Written by:  Geoff Stahl (ggs)

  Copyright:  Copyright &copy; 1999 Apple Computer, Inc., All Rights Reserved

  Change History (most recent first):

         &lt;4&gt;     8/23/01    ggs     Fixed texture sharing and added number of bug fixes
         &lt;3&gt;     4/20/01    ggs     Added support for texture sharing by sharing all contexts by default
         &lt;2&gt;     3/26/01    ggs     Add DSp version check and other items for full screen on X
         &lt;1&gt;     1/19/01    ggs     Initial re-add
         &lt;7&gt;     3/22/00    ggs     remove extranious prototype
         &lt;6&gt;     3/21/00    ggs     Added windowed mode and clean up various implementation details
         &lt;5&gt;     1/26/00    ggs     Add fade code back in, ensure NULL pointer/context/drawable
                                    checks are in, add Preflight
         &lt;4&gt;     1/24/00    ggs     Added glFinish to shutdown code
         &lt;3&gt;     1/24/00    ggs     update to latest, better rendrere info handling for 3dfx, better
                                    checks on pause and resume, added frin devce numer and gdhandle
                                    from point
          &lt;2.7&gt;   11/28/99    ggs     Split out DSp and error handling.  Added texture memory
                                    considerations, assume VRAM is required if other than zero
         &lt;2.6&gt;   11/14/99    ggs     Fix source server copy
         &lt;2.5&gt;   11/13/99    ggs     fixed default pixel depth (0) condition that was causing failures
         &lt;2.4&gt;   11/13/99    ggs     added custom fade code
         &lt;2.3&gt;   11/13/99    ggs     Reset for Quake 3 use
         &lt;2.2&gt;   11/12/99    ggs     re-add
         &lt;2.1&gt;   11/12/99    ggs     added support for frequency retrieval, fixed display number
                                    output to be correct if display number input was -1
         &lt;2&gt;    11/12/99    ggs     1.0 functionality
         &lt;1&gt;    11/11/99    ggs     Initial Add

  Disclaimer:  You may incorporate this sample code into your applications without
        restriction, though the sample code has been provided &quot;AS IS&quot; and the
        responsibility for its operation is 100% yours.  However, what you are
        not permitted to do is to redistribute the source as &quot;DSC Sample Code&quot;
        after having made changes. If you're going to re-distribute the source,
        we require that you make it clear in the source that the code was
        descended from Apple Sample Code, but that you've made changes.
*/

// system includes ----------------------------------------------------------

#ifdef __APPLE_CC__
    #include &lt;Carbon/Carbon.h&gt;
#else
    #include &lt;Gestalt.h&gt;
    #include &lt;sound.h&gt;
#endif

// project includes ---------------------------------------------------------

#include &quot;Carbon_Error_Handler.h&quot;
#include &quot;Carbon_SetupDSp.h&quot;
#include &quot;Carbon_SetupGL.h&quot;


// globals (internal/private) -----------------------------------------------

const RGBColor  rgbBlack  = { 0x0000, 0x0000, 0x0000 };

const short kWindowType = kWindowDocumentProc;

// prototypes (internal/private) --------------------------------------------

static Boolean CheckRenderer (GDHandle hGD, long *VRAM, long *textureRAM, GLint*  , Boolean fAccelMust);
static Boolean CheckAllDeviceRenderers (long* pVRAM, long* pTextureRAM, GLint* pDepthSizeSupport, Boolean fAccelMust);
static Boolean CheckWindowExtents (GDHandle hGD, short width, short height);
static void DumpCurrent (AGLDrawable* paglDraw, AGLContext* paglContext, DSpContextReference* pdspContext, pstructGLInfo pcontextInfo);

static OSStatus BuildGLContext (AGLDrawable* paglDraw, AGLContext* paglContext, DSpContextReference* pdspContext, GDHandle hGD, 
                pstructGLInfo pcontextInfo, AGLContext aglShareContext);
static OSStatus BuildDrawable (AGLDrawable* paglDraw, GDHandle hGD, pstructGLInfo pcontextInfo);
static OSStatus BuildGLonDevice (AGLDrawable* paglDraw, AGLContext* paglContext, DSpContextReference* pdspContext, 
                GDHandle hGD, pstructGLInfo pcontextInfo, AGLContext aglShareContext);
static OSStatus BuildGLonWindow (WindowPtr pWindow, AGLContext* paglContext, pstructGLWindowInfo pcontextInfo, AGLContext aglShareContext);
                

// functions (internal/private) ---------------------------------------------

// CheckRenderer

// looks at renderer attributes it has at least the VRAM is accelerated

// Inputs:   hGD: GDHandle to device to look at
//      pVRAM: pointer to VRAM in bytes required; out is actual VRAM if a renderer was found, otherwise it is the input parameter
//      pTextureRAM:  pointer to texture RAM in bytes required; out is same (implementation assume VRAM returned by card is total so we add texture and VRAM)
//      fAccelMust: do we check for acceleration

// Returns: true if renderer for the requested device complies, false otherwise

static Boolean CheckRenderer (GDHandle hGD, long* pVRAM, long* pTextureRAM, GLint* pDepthSizeSupport, Boolean fAccelMust)
{
  AGLRendererInfo info, head_info;
  GLint inum;
  GLint dAccel = 0;
  GLint dVRAM = 0, dMaxVRAM = 0;
  Boolean canAccel = false, found = false;
  head_info = aglQueryRendererInfo(&amp;hGD, 1);
  aglReportError ();
  if(!head_info)
  {
    ReportError (&quot;aglQueryRendererInfo error&quot;);
    return false;
  }
  else
  {
    info = head_info;
    inum = 0;
    // see if we have an accelerated renderer, if so ignore non-accelerated ones
    // this prevents returning info on software renderer when actually we'll get the hardware one
    while (info)
    {  
      aglDescribeRenderer(info, AGL_ACCELERATED, &amp;dAccel);
      aglReportError ();
      if (dAccel)
        canAccel = true;
      info = aglNextRendererInfo(info);
      aglReportError ();
      inum++;
    }
      
    info = head_info;
    inum = 0;
    while (info)
    {
      aglDescribeRenderer (info, AGL_ACCELERATED, &amp;dAccel);
      aglReportError ();
      // if we can accel then we will choose the accelerated renderer 
      // how about compliant renderers???
      if ((canAccel &amp;&amp; dAccel) || (!canAccel &amp;&amp; (!fAccelMust || dAccel)))
      {
        aglDescribeRenderer (info, AGL_VIDEO_MEMORY, &amp;dVRAM);  // we assume that VRAM returned is total thus add texture and VRAM required
        aglReportError ();
        if (dVRAM &gt;= (*pVRAM + *pTextureRAM))
        {
          if (dVRAM &gt;= dMaxVRAM) // find card with max VRAM
          {
            aglDescribeRenderer (info, AGL_DEPTH_MODES, pDepthSizeSupport);  // which depth buffer modes are supported
            aglReportError ();
            dMaxVRAM = dVRAM; // store max
            found = true;
          }
        }
      }
      info = aglNextRendererInfo(info);
      aglReportError ();
      inum++;
    }
  }
  aglDestroyRendererInfo(head_info);
  if (found) // if we found a card that has enough VRAM and meets the accel criteria
  {
    *pVRAM = dMaxVRAM; // return VRAM
    return true;
  }
  // VRAM will remain to same as it did when sent in
  return false;
}

//-----------------------------------------------------------------------------------------------------------------------

// CheckAllDeviceRenderers 

// looks at renderer attributes and each device must have at least one renderer that fits the profile

// Inputs:   pVRAM: pointer to VRAM in bytes required; out is actual min VRAM of all renderers found, otherwise it is the input parameter
//      pTextureRAM:  pointer to texture RAM in bytes required; out is same (implementation assume VRAM returned by card is total so we add texture and VRAM)
//      fAccelMust: do we check fro acceleration

// Returns: true if any renderer for on each device complies (not necessarily the same renderer), false otherwise

static Boolean CheckAllDeviceRenderers (long* pVRAM, long* pTextureRAM, GLint* pDepthSizeSupport, Boolean fAccelMust)
{
  AGLRendererInfo info, head_info;
  GLint inum;
  GLint dAccel = 0;
  GLint dVRAM = 0, dMaxVRAM = 0;
  Boolean canAccel = false, found = false, goodCheck = true; // can the renderer accelerate, did we find a valid renderer for the device, are we still successfully on all the devices looked at
  long MinVRAM = 0x8FFFFFFF; // max long
  GDHandle hGD = GetDeviceList (); // get the first screen
  while (hGD &amp;&amp; goodCheck)
  {
    head_info = aglQueryRendererInfo(&amp;hGD, 1);
    aglReportError ();
    if(!head_info)
    {
      ReportError (&quot;aglQueryRendererInfo error&quot;);
      return false;
    }
    else
    {
      info = head_info;
      inum = 0;
      // see if we have an accelerated renderer, if so ignore non-accelerated ones
      // this prevents returning info on software renderer when actually we'll get the hardware one
      while (info)
      {
                aglDescribeRenderer(info, AGL_ACCELERATED, &amp;dAccel);
        aglReportError ();
        if (dAccel)
          canAccel = true;
        info = aglNextRendererInfo(info);
        aglReportError ();
        inum++;
      }
        
      info = head_info;
      inum = 0;
      while (info)
      {  
        aglDescribeRenderer(info, AGL_ACCELERATED, &amp;dAccel);
        aglReportError ();
        // if we can accel then we will choose the accelerated renderer 
        // how about compliant renderers???
        if ((canAccel &amp;&amp; dAccel) || (!canAccel &amp;&amp; (!fAccelMust || dAccel)))
        {
                    aglDescribeRenderer(info, AGL_VIDEO_MEMORY, &amp;dVRAM);  // we assume that VRAM returned is total thus add texture and VRAM required
          aglReportError ();
          if (dVRAM &gt;= (*pVRAM + *pTextureRAM))
          {
            if (dVRAM &gt;= dMaxVRAM) // find card with max VRAM
            {
              aglDescribeRenderer(info, AGL_DEPTH_MODES, pDepthSizeSupport);  // which depth buffer modes are supported
              aglReportError ();
              dMaxVRAM = dVRAM; // store max
              found = true;
            }
          }
        }
        info = aglNextRendererInfo(info);
        aglReportError ();
        inum++;
      }
    }
    aglDestroyRendererInfo(head_info);
    if (found) // if we found a card that has enough VRAM and meets the accel criteria
    {
      if (MinVRAM &gt; dMaxVRAM)
        MinVRAM = dMaxVRAM; // return VRAM
      
    }
    else
      goodCheck = false; // one device failed thus entire requirement fails
    hGD = GetNextDevice (hGD); // get next device
  } // while
  if (goodCheck) // we check all devices and each was good
  {
    *pVRAM = MinVRAM; // return VRAM
    return true;
  }
  return false; //at least one device failed to have mins
}

//-----------------------------------------------------------------------------------------------------------------------

// CheckWindowExtents

// checks to see window fits on screen completely

// Inputs:   hGD: GDHandle to device to look at
//      width/height: requested width and height of window

// Returns: true if window and borders fit, false otherwise

static Boolean CheckWindowExtents (GDHandle hGD, short width, short height)
{
  Rect strucRect, rectWin = {0, 0, 1, 1};
  short deviceHeight = (short) ((**hGD).gdRect.bottom - (**hGD).gdRect.top - GetMBarHeight ());  
  short deviceWidth = (short) ((**hGD).gdRect.right - (**hGD).gdRect.left);
  short windowWidthExtra, windowHeightExtra;
  // build window (not visible)
  WindowPtr pWindow = NewCWindow (NULL, &amp;rectWin, &quot;\p&quot;, true, kWindowType, (WindowPtr)-1, 0, 0);
  
#if !TARGET_API_MAC_CARBON
  strucRect = (**(((WindowPeek)pWindow)-&gt;strucRgn)).rgnBBox;
#else
  GetWindowBounds (pWindow, kWindowStructureRgn, &amp;strucRect);
#endif
  windowWidthExtra = (short) ((strucRect.right - strucRect.left) - 1);
  windowHeightExtra = (short) ((strucRect.bottom - strucRect.top) - 1);
  DisposeWindow (pWindow);
  if ((width + windowWidthExtra &lt;= deviceWidth) &amp;&amp;
    (height + windowHeightExtra &lt;= deviceHeight))
    return true;
  return false;
}

// --------------------------------------------------------------------------

// DumpCurrent

// Kills currently allocated context
// does not care about being pretty (assumes display is likely faded)

// Inputs:   paglDraw, paglContext, pdspContext: things to be destroyed

void DumpCurrent (AGLDrawable* paglDraw, AGLContext* paglContext, DSpContextReference* pdspContext, pstructGLInfo pcontextInfo)
{
  if (*pdspContext)
    DSpReportError (DSpContext_CustomFadeGammaOut (NULL, NULL, fadeTicks));

  if (*paglContext)
  {
    aglSetCurrentContext (NULL);
    aglReportError ();
    aglSetDrawable (*paglContext, NULL);
    aglReportError ();
    aglDestroyContext (*paglContext);
    aglReportError ();
    *paglContext = NULL;
  }
  
  if (pcontextInfo-&gt;fmt)
  {
    aglDestroyPixelFormat (pcontextInfo-&gt;fmt); // pixel format is no longer needed
    aglReportError ();
  }
  pcontextInfo-&gt;fmt = 0;

  if (*paglDraw &amp;&amp; !(pcontextInfo-&gt;fFullscreen &amp;&amp; CheckMacOSX ())) // do not destory a window on DSp if in Mac OS X
                                   // since there is no window built in X
#if TARGET_API_MAC_CARBON
    DisposeWindow (GetWindowFromPort (*paglDraw));
#else
    DisposeWindow ((WindowPtr) *paglDraw);
#endif
  *paglDraw = NULL;
  DestroyDSpContext (pdspContext); // fades in, safe to call at all times
}

#pragma mark -
// --------------------------------------------------------------------------

// BuildGLContext

// Builds OpenGL context

// Inputs:   hGD: GDHandle to device to look at
//      pcontextInfo: request and requirements for cotext and drawable

// Outputs: paglContext as allocated
//      pcontextInfo:  allocated parameters

// if fail to allocate: paglContext will be NULL
// if error: will return error paglContext will be NULL

static OSStatus BuildGLContext (AGLDrawable* paglDraw, AGLContext* paglContext, DSpContextReference* pdspContext,
                GDHandle hGD, pstructGLInfo pcontextInfo, AGLContext aglShareContext)
{
  OSStatus err = noErr;
  NumVersion versionDSp = GetDSpVersion ();

  if ((Ptr) kUnresolvedCFragSymbolAddress == (Ptr) aglChoosePixelFormat) // check for existance of OpenGL
  {
    ReportError (&quot;OpenGL not installed&quot;);
    return noErr;
  }  
  
  // DSp has problems on Mac OS X with DSp version less than 1.99 so use agl full screen
  if ((pcontextInfo-&gt;fFullscreen) &amp;&amp; (CheckMacOSX ()) &amp;&amp; ((versionDSp.majorRev == 0x01) &amp;&amp; (versionDSp.minorAndBugRev &lt; 0x99))) // need to set pixel format for full screen
  {
    short i = 0;
    while (pcontextInfo-&gt;aglAttributes[i++] != AGL_NONE) {}
    i--; // point to AGL_NONE
    pcontextInfo-&gt;aglAttributes [i++] = AGL_FULLSCREEN;
    pcontextInfo-&gt;aglAttributes [i++] = AGL_PIXEL_SIZE;
    pcontextInfo-&gt;aglAttributes [i++] = (SInt32) pcontextInfo-&gt;pixelDepth;
    pcontextInfo-&gt;aglAttributes [i++] = AGL_NONE;
  }

  pcontextInfo-&gt;fmt = aglChoosePixelFormat (&amp;hGD, 1, pcontextInfo-&gt;aglAttributes); // get an appropriate pixel format
  aglReportError ();
  if (NULL == pcontextInfo-&gt;fmt) 
  {
    ReportError(&quot;Could not find valid pixel format&quot;);
    return noErr;
  }

  // using a default method of sharing all the contexts enables texture sharing across these contexts by default
  *paglContext = aglCreateContext (pcontextInfo-&gt;fmt, aglShareContext);        // Create an AGL context
   if (AGL_BAD_MATCH == aglGetError())
    *paglContext = aglCreateContext (pcontextInfo-&gt;fmt, 0); // unable to sahre context, create without sharing
  aglReportError ();
  if (NULL == *paglContext) 
  {
    ReportError (&quot;Could not create context&quot;);
    return paramErr;
  }
  if (aglShareContext == NULL)
    aglShareContext = *paglContext;
  
  // set our drawable
  
  // DSp has problems on Mac OS X use DSp only when version is not less than 1.99
  if ((pcontextInfo-&gt;fFullscreen) &amp;&amp; (CheckMacOSX ()) &amp;&amp; !((versionDSp.majorRev == 0x01) &amp;&amp; (versionDSp.minorAndBugRev &lt; 0x99))) // fullscreen X late DSp
  {
    // use DSp's front buffer on Mac OS X
    *paglDraw = GetDSpDrawable (*pdspContext);
    // there is a problem in Mac OS X GM CoreGraphics that may not size the port pixmap correctly
    // this will check the vertical sizes and offset if required to fix the problem
    // this will not center ports that are smaller then a particular resolution
    {
      short deltaV, deltaH;
      Rect portBounds;
#if TARGET_API_MAC_CARBON
      PixMapHandle hPix = GetPortPixMap (*paglDraw);
      Rect pixBounds = (**hPix).bounds;
      GetPortBounds (*paglDraw, &amp;portBounds);
#else
      PixMapHandle hPix = (*paglDraw)-&gt;portPixMap;
      Rect pixBounds = (**hPix).bounds;
      portBounds = (*paglDraw)-&gt;portRect;
#endif
      deltaV = (short) ((portBounds.bottom - portBounds.top) - (pixBounds.bottom - pixBounds.top) +
               (portBounds.bottom - portBounds.top - pcontextInfo-&gt;height) / 2);
      deltaH = (short) (-(portBounds.right - portBounds.left - pcontextInfo-&gt;width) / 2);
      if (deltaV || deltaH)
      {
        GrafPtr pPortSave;
        GetPort (&amp;pPortSave);
        SetPort ((GrafPtr)*paglDraw);
        // set origin to account for CG offset and if requested drawable smaller than screen rez
        SetOrigin (deltaH, deltaV);
        SetPort (pPortSave);
      }
    }
    if (!aglSetDrawable (*paglContext, *paglDraw))      // attach the CGrafPtr to the context
      return aglReportError ();
  }
  // DSp has problems on Mac OS X with DSp version less than 1.99 so use agl full screen
  else if ((pcontextInfo-&gt;fFullscreen) &amp;&amp; (CheckMacOSX ()) &amp;&amp; ((versionDSp.majorRev == 0x01) &amp;&amp; (versionDSp.minorAndBugRev &lt; 0x99))) // fulscreen X early DSp
  {
    // use aglFullScreen
    short display = 0;
    if (!aglSetFullScreen (*paglContext, pcontextInfo-&gt;width, pcontextInfo-&gt;height, 60, display)) // attach fulls screen device to the context
    {
      ReportError (&quot;SetFullScreen failed&quot;);
      aglReportError ();
      return paramErr;
    }
  }
  else // not Mac OS X fullscreen:  this is for three cases 1) Mac OS 9 windowed 2) Mac OS X windowed 3) Mac OS 9 fullscreen (as you need to build a window on top of DSp for GL to work correctly
  {
    // build window as late as possible
    err = BuildDrawable (paglDraw, hGD, pcontextInfo);
    if (err != noErr)
    {
      ReportError (&quot;Could not build drawable&quot;);
      return err;
    }
    if (!aglSetDrawable (*paglContext, *paglDraw))      // attach the CGrafPtr to the context
      return aglReportError ();
  }
  if(!aglSetCurrentContext (*paglContext))          // make the context the current context
    return aglReportError ();
  
  return err;
}

// --------------------------------------------------------------------------

// BuildDrawable

// Builds window to be used as drawable

// Inputs:   hGD: GDHandle to device to look at
//      pcontextInfo: request and requirements for cotext and drawable

// Outputs: paglDraw as allocated
//      pcontextInfo:  allocated parameters

// if fail to allocate: paglDraw will be NULL
// if error: will return error paglDraw will be NULL

static OSStatus BuildDrawable (AGLDrawable* paglDraw, GDHandle hGD, pstructGLInfo pcontextInfo)
{
  Rect rectWin;
  RGBColor rgbSave;
  GrafPtr pGrafSave;
  OSStatus err = noErr;
  
  // center window in our context's gdevice
  rectWin.top  = (short) ((**hGD).gdRect.top + ((**hGD).gdRect.bottom - (**hGD).gdRect.top) / 2); // v center
  rectWin.top  -= pcontextInfo-&gt;height / 2;
  rectWin.left  = (short) ((**hGD).gdRect.left + ((**hGD).gdRect.right - (**hGD).gdRect.left) / 2);  // h center
  rectWin.left  -= pcontextInfo-&gt;width / 2;
  rectWin.right = (short) (rectWin.left + pcontextInfo-&gt;width);
  rectWin.bottom = (short) (rectWin.top + pcontextInfo-&gt;height);
  

#if TARGET_API_MAC_CARBON
  if (pcontextInfo-&gt;fFullscreen)
    *paglDraw = GetWindowPort (NewCWindow (NULL, &amp;rectWin, &quot;\p&quot;, 0, plainDBox, (WindowPtr)-1, 0, 0));
  else
    *paglDraw = GetWindowPort (NewCWindow (NULL, &amp;rectWin, &quot;\p&quot;, 0, kWindowType, (WindowPtr)-1, 0, 0));
    ShowWindow (GetWindowFromPort (*paglDraw));
#else
  if (pcontextInfo-&gt;fFullscreen)
    *paglDraw = (AGLDrawable) NewCWindow (NULL, &amp;rectWin, &quot;\p&quot;, 0, plainDBox, (WindowPtr)-1, 0, 0);
  else
    *paglDraw = (AGLDrawable) NewCWindow (NULL, &amp;rectWin, &quot;\p&quot;, 0, kWindowType, (WindowPtr)-1, 0, 0);
    ShowWindow ((WindowPtr) *paglDraw);
#endif
  GetPort (&amp;pGrafSave);
  SetPort ((GrafPtr)*paglDraw);
  GetForeColor (&amp;rgbSave);
  RGBForeColor (&amp;rgbBlack);
#if TARGET_API_MAC_CARBON
  GetWindowBounds (GetWindowFromPort (*paglDraw), kWindowContentRgn, &amp;rectWin);
#else
  rectWin = ((GrafPtr) *paglDraw)-&gt;portRect;
#endif
  PaintRect (&amp;rectWin);
  RGBForeColor (&amp;rgbSave); // ensure color is reset for proper blitting
  SetPort (pGrafSave);
  return err;
}

// --------------------------------------------------------------------------

// BuildGLonDevice

// Takes device single device and tries to build on it

// Inputs:   hGD: GDHandle to device to look at
//      *pcontextInfo: request and requirements for cotext and drawable

// Outputs: *paglDraw, *paglContext and *pdspContext as allocated
//      *pcontextInfo:  allocated parameters

// if fail to allocate: paglDraw, paglContext and pdspContext will be NULL
// if error: will return error and paglDraw, paglContext and pdspContext will be NULL
// Note: *paglDraw and *pdspContext can be null is aglFullScreen is used

static OSStatus BuildGLonDevice (AGLDrawable* paglDraw, AGLContext* paglContext, DSpContextReference* pdspContext, 
                   GDHandle hGD, pstructGLInfo pcontextInfo, AGLContext aglShareContext)
{
  GLint depthSizeSupport;
  OSStatus err = noErr;
  Boolean fCheckRenderer = false;
  NumVersion versionDSp = GetDSpVersion ();

  if (pcontextInfo-&gt;fFullscreen)
  {
    // if we are in 16 or 32 bit mode already, we can check the renderer now (we will double check later)
    if (16 &lt;= (**(**hGD).gdPMap).pixelSize)
    {
      // check for VRAM and accelerated
      if (!CheckRenderer (hGD, &amp;(pcontextInfo-&gt;VRAM), &amp;(pcontextInfo-&gt;textureRAM), &amp;depthSizeSupport, pcontextInfo-&gt;fAcceleratedMust))
      {
        ReportError (&quot;Renderer check failed&quot;);
        return err;
      }
      else
        fCheckRenderer = true;
    }

    // only for  Mac OS 9 or less and greater than Mac OS X 10.0.2
    // DSp has problems on Mac OS X with DSp version less than 1.99 (10.0.2 or less)
    if ((!CheckMacOSX ()) || ((versionDSp.majorRev &gt; 0x01) || ((versionDSp.majorRev == 0x01) &amp;&amp; (versionDSp.minorAndBugRev &gt;= 0x99))))  // DSp should be supported in version after 1.98
    {
      err = BuildDSpContext (pdspContext, hGD, depthSizeSupport, pcontextInfo);
      // we are now faded
      if ((err != noErr) || (*pdspContext == NULL))
      {
        if (err != noErr)
          ReportErrorNum (&quot;BuildDSpContext failed with error:&quot;, err);
        else
          ReportError (&quot;Could not build DrawSprocket context&quot;);
        if (*pdspContext)
          DSpReportError (DSpContext_CustomFadeGammaIn (NULL, NULL, fadeTicks));
        return err;
      }
    }
    // else we are using aglFullScreen and no DSp work is required
  }
  else
  {
    if (pcontextInfo-&gt;pixelDepth == 0)  // default
    {
      pcontextInfo-&gt;pixelDepth = (**(**hGD).gdPMap).pixelSize;
      if (16 &gt; pcontextInfo-&gt;pixelDepth)
        pcontextInfo-&gt;pixelDepth = 16;
    }
    if (pcontextInfo-&gt;fDepthMust &amp;&amp; (pcontextInfo-&gt;pixelDepth != (**(**hGD).gdPMap).pixelSize))  // device depth must match and does not
    {
      ReportError (&quot;Pixel Depth does not match device in windowed mode.&quot;);
      if (*pdspContext)
        DSpReportError (DSpContext_CustomFadeGammaIn (NULL, NULL, fadeTicks));
      return err;
    }
    // copy back the curretn depth
    pcontextInfo-&gt;pixelDepth = (**(**hGD).gdPMap).pixelSize;
    if (!CheckWindowExtents (hGD, pcontextInfo-&gt;width, pcontextInfo-&gt;height))
    {
      ReportError (&quot;Window will not fit on device in windowed mode.&quot;);
      if (*pdspContext)
        DSpReportError (DSpContext_CustomFadeGammaIn (NULL, NULL, fadeTicks));
      return err;
    }
  }
  
  // if we have not already checked the renderer, check for VRAM and accelerated
  if (!fCheckRenderer)
    if (!CheckRenderer (hGD, &amp;(pcontextInfo-&gt;VRAM), &amp;(pcontextInfo-&gt;textureRAM), &amp;depthSizeSupport, pcontextInfo-&gt;fAcceleratedMust))
    {
      ReportError (&quot;Renderer check failed&quot;);
      if (*pdspContext)
        DSpReportError (DSpContext_CustomFadeGammaIn (NULL, NULL, fadeTicks));
      return err;
    }
  
  // do agl
  // need to send device #'s through this
  err = BuildGLContext (paglDraw, paglContext, pdspContext, hGD, pcontextInfo, aglShareContext);
    
  // DSp has problems on Mac OS X with DSp version less than 1.99
  if ((!CheckMacOSX ()) || ((versionDSp.majorRev &gt; 0x01) || ((versionDSp.majorRev == 0x01) &amp;&amp; (versionDSp.minorAndBugRev &gt;= 0x99))))// DSp should be supported in version after 1.98
  {
    if (*pdspContext)
      DSpReportError (DSpContext_CustomFadeGammaIn (NULL, NULL, fadeTicks));
  }
  return err;
}


// --------------------------------------------------------------------------

// BuildGLonDrawable

// Takes a drawable and tries to build on it

// Inputs:   aglDraw: a valid AGLDrawable
//      *pcontextInfo: request and requirements for cotext and drawable

// Outputs: *paglContext as allocated
//      *pcontextInfo:  allocated parameters

// if fail to allocate: paglContext will be NULL
// if error: will return error and paglContext will be NULL

static OSStatus BuildGLonWindow (WindowPtr pWindow, AGLContext* paglContext, pstructGLWindowInfo pcontextInfo, AGLContext aglShareContext)
{
  GDHandle hGD = NULL;
  GrafPtr cgrafSave = NULL;
  short numDevices;
  GLint depthSizeSupport;
  OSStatus err = noErr;
  
  if (!pWindow || !pcontextInfo)
  {
    ReportError (&quot;NULL parameter passed to BuildGLonDrawable.&quot;);
    return paramErr;
  }
  
  GetPort (&amp;cgrafSave);
  SetPortWindowPort(pWindow);

  // check renderere VRAM and acceleration
  numDevices = FindGDHandleFromWindow (pWindow, &amp;hGD);
  if (!pcontextInfo-&gt;fDraggable)   // if numDevices &gt; 1 then we will only be using the software renderer otherwise check only window device
  {
    if ((numDevices &gt; 1) || (numDevices == 0)) // this window spans mulitple devices thus will be software only
    {
      // software renderer
      // infinite VRAM, infinite textureRAM, not accelerated
      if (pcontextInfo-&gt;fAcceleratedMust)
      {
        ReportError (&quot;Unable to accelerate window that spans multiple devices&quot;);
        return err;
      }
    }
    else // not draggable on single device
    {
      if (!CheckRenderer (hGD, &amp;(pcontextInfo-&gt;VRAM), &amp;(pcontextInfo-&gt;textureRAM), &amp;depthSizeSupport, pcontextInfo-&gt;fAcceleratedMust))
      {
        ReportError (&quot;Renderer check failed&quot;);
        return err;
      }
    }
  }
  // else draggable so must check all for support (each device should have at least one renderer that meets the requirements)
  else if (!CheckAllDeviceRenderers (&amp;(pcontextInfo-&gt;VRAM), &amp;(pcontextInfo-&gt;textureRAM), &amp;depthSizeSupport, pcontextInfo-&gt;fAcceleratedMust))
  {
    ReportError (&quot;Renderer check failed&quot;);
    return err;
  }
  
  // do agl
  if ((Ptr) kUnresolvedCFragSymbolAddress == (Ptr) aglChoosePixelFormat) // check for existance of OpenGL
  {
    ReportError (&quot;OpenGL not installed&quot;);
    return NULL;
  }  
  // we successfully passed the renderer check

  if ((!pcontextInfo-&gt;fDraggable &amp;&amp; (numDevices == 1)))  // not draggable on a single device
    pcontextInfo-&gt;fmt = aglChoosePixelFormat (&amp;hGD, 1, pcontextInfo-&gt;aglAttributes); // get an appropriate pixel format
  else
    pcontextInfo-&gt;fmt = aglChoosePixelFormat (NULL, 0, pcontextInfo-&gt;aglAttributes); // get an appropriate pixel format
  aglReportError ();
  if (NULL == pcontextInfo-&gt;fmt) 
  {
    ReportError(&quot;Could not find valid pixel format&quot;);
    return NULL;
  }

  *paglContext = aglCreateContext (pcontextInfo-&gt;fmt, aglShareContext); // Create an AGL context
  if (AGL_BAD_MATCH == aglGetError())
    *paglContext = aglCreateContext (pcontextInfo-&gt;fmt, 0); // unable to sahre context, create without sharing
  aglReportError ();
  if (NULL == *paglContext) 
  {
    ReportError (&quot;Could not create context&quot;);
    return NULL;
  }
  
  if (!aglSetDrawable (*paglContext, GetWindowPort (pWindow))) // attach the CGrafPtr to the context
    return aglReportError ();
  
  if(!aglSetCurrentContext (*paglContext)) // make the context the current context
    return aglReportError ();

  SetPort (cgrafSave);

  return err;
}

#pragma mark -

// functions (public) -------------------------------------------------------

// CheckMacOSX

// Runtime check to see if we are running on Mac OS X

// Inputs:  None

// Returns: 0 if &lt; Mac OS X or version number of Mac OS X (10.0 for GM)

UInt32 CheckMacOSX (void)
{
  UInt32 response;
    
  if ((Gestalt(gestaltSystemVersion, (SInt32 *) &amp;response) == noErr) &amp;&amp; (response &gt;= 0x01000))
    return response;
  else
    return 0;
}

// --------------------------------------------------------------------------

// PreflightGL

// Checks for presense of OpenGL and DSp (if required)
// Inputs: checkFullscreen: true if one wants to run fullscreen (which requires DrwSprocket currently)
// Ouputs: true if OpenGL is installed (and DrawSprocket if checkFullscreen is true

Boolean PreflightGL (Boolean checkFullscreen)
{
  if ((Ptr) kUnresolvedCFragSymbolAddress == (Ptr) aglChoosePixelFormat) // check for existance of OpenGL
    return false;
  if (checkFullscreen &amp;&amp; ((Ptr) kUnresolvedCFragSymbolAddress == (Ptr) DSpStartup)) // check for existance of DSp
    return false;
  return true;
}

// --------------------------------------------------------------------------

// BuildGL

// Takes device and geometry request and tries to build best context and drawable
// if device does not work will walk down devices looking for first one that satisfies requirments

// Inputs:   *pnumDevice: 0 any device, # attempt that device first, then any device
//      *pcontextInfo: request and requirements for cotext and drawable

// Outputs: *paglDraw, *paglContext and *pdspContext as allocated
//      *pnumDevice to device number in list that was used 
//      *pcontextInfo:  allocated parameters

// if fail to allocate: paglDraw, paglContext and pdspContext will be NULL
// if error: will return error and paglDraw, paglContext and pdspContext will be NULL

OSStatus BuildGL (AGLDrawable* paglDraw, AGLContext* paglContext, DSpContextReference* pdspContext, 
          short* pnumDevice, pstructGLInfo pcontextInfo, AGLContext aglShareContext)
{
  OSStatus err = noErr;
  GDHandle hGD = NULL;
  structGLInfo contextInfoSave;
  
  // clear
  *paglDraw = NULL;
  *paglContext = 0;
  *pdspContext = 0;
  contextInfoSave = *pcontextInfo; // save info to reset on failures
  
  // if we are full screen and not on Mac OS X (which will use aglFullScreen)
  if (pcontextInfo-&gt;fFullscreen)
  {
    NumVersion versionDSp = GetDSpVersion ();
    // DSp has problems on Mac OS X with DSp version less than 1.99
    if ((!CheckMacOSX ()) || ((versionDSp.majorRev &gt; 0x01) || ((versionDSp.majorRev == 0x01) &amp;&amp; (versionDSp.minorAndBugRev &gt;= 0x99))))// DSp should be supported in version after 1.98
    {
      err = StartDSp ();
      if (gDSpStarted)
        gNeedFade = true;
      else
        return err;
    }
  }
  
  
  //find main device
  if (*pnumDevice == -1)
  {
    GDHandle hDevice; // check number of screens
    hGD = GetMainDevice ();
    if (NULL != hGD)
    {
      err = BuildGLonDevice (paglDraw, paglContext, pdspContext, hGD, pcontextInfo, aglShareContext);
      // find device number
      *pnumDevice = 0;
      hDevice = DMGetFirstScreenDevice (true);
      do
      {
        if (hDevice == hGD)
          break;
        hDevice = DMGetNextScreenDevice (hDevice, true);
        (*pnumDevice)++;
      }
      while (hDevice);
      if (!hDevice)
        ReportError (&quot;main device match not found&quot;);
    }
    else
      ReportError (&quot;Cannot get main device&quot;);
  }

  if ((err != noErr) || (*paglContext == 0))
  {
    err = noErr;
    DumpCurrent (paglDraw, paglContext, pdspContext, pcontextInfo); // dump what ever partial solution we might have
    *pcontextInfo = contextInfoSave; // restore info
    //find target device and check this first is one exists
    if (*pnumDevice)
    {
      short i;
      hGD = DMGetFirstScreenDevice (true);
      for (i = 0; i &lt; *pnumDevice; i++)
      {
        GDHandle hGDNext = DMGetNextScreenDevice (hGD, true);
        if (NULL == hGDNext) // ensure we did not run out of devices
          break; // if no more devices drop out
        else
          hGD = hGDNext; // otherwise continue
      }
      *pnumDevice = i; // record device we actually got
      err = BuildGLonDevice (paglDraw, paglContext, pdspContext, hGD, pcontextInfo, aglShareContext);
    }
  }
  
  // while we have not allocated a context or there were errors
  if ((err != noErr) || (*paglContext == 0))
  {
    err = noErr;
    DumpCurrent (paglDraw, paglContext, pdspContext, pcontextInfo); // dump what ever partial solution we might have
    *pcontextInfo = contextInfoSave; // restore info
    // now look through the devices in order
    hGD = DMGetFirstScreenDevice (true);  
    *pnumDevice = -1;
    do 
    {
      (*pnumDevice)++;
      err = BuildGLonDevice (paglDraw, paglContext, pdspContext, hGD, pcontextInfo, aglShareContext);
      if ((err != noErr) || (*paglDraw == NULL) || (*paglContext == 0))  // reset hGD only if we are not done
      {
        hGD = DMGetNextScreenDevice (hGD, true);
        DumpCurrent (paglDraw, paglContext, pdspContext, pcontextInfo); // dump what ever partial solution we might have
        *pcontextInfo = contextInfoSave; // restore info
      }
    }
    while (((err != noErr) || (*paglContext == 0)) &amp;&amp; hGD);
  }
  return err;
}

// --------------------------------------------------------------------------

// DestroyGL

// Destroys drawable and context
// Ouputs: *paglDraw, *paglContext and *pdspContext should be 0 on exit

OSStatus DestroyGL (AGLDrawable* paglDraw, AGLContext* paglContext, DSpContextReference* pdspContext, pstructGLInfo pcontextInfo)
{
  if ((!paglContext) || (!*paglContext))
    return paramErr; // not a valid context
  glFinish ();
  DumpCurrent (paglDraw, paglContext, pdspContext, pcontextInfo);
  ShutdownDSp (); // safe to call anytime
  return noErr;
}

//-----------------------------------------------------------------------------------------------------------------------

// BuildGLFromWindow

// Takes window in the form of an AGLDrawable and geometry request and tries to build best context

// Inputs:   aglDraw: a valid AGLDrawable (i.e., a WindowPtr)
//      *pcontextInfo: request and requirements for cotext and drawable

// Outputs: *paglContext as allocated
//      *pcontextInfo:  allocated parameters

// if fail to allocate: paglContext will be NULL
// if error: will return error and paglContext will be NULL

OSStatus BuildGLFromWindow (WindowPtr pWindow, AGLContext* paglContext, pstructGLWindowInfo pcontextInfo, AGLContext aglShareContext)
{
  if (!pWindow)
    return paramErr;
  return BuildGLonWindow (pWindow, paglContext, pcontextInfo, aglShareContext);
}

// --------------------------------------------------------------------------

// DestroyGLFromWindow

// Destroys context that waas allocated with BuildGLFromWindow
// Ouputs: *paglContext should be NULL on exit

OSStatus DestroyGLFromWindow (AGLContext* paglContext, pstructGLWindowInfo pcontextInfo)
{
  OSStatus err;
  
  if ((!paglContext) || (!*paglContext))
    return paramErr; // not a valid context
  glFinish ();
  aglSetCurrentContext (NULL);
  err = aglReportError ();
  aglSetDrawable (*paglContext, NULL);
  err = aglReportError ();
  aglDestroyContext (*paglContext);
  err = aglReportError ();
  *paglContext = NULL;

  if (pcontextInfo-&gt;fmt)
  {
    aglDestroyPixelFormat (pcontextInfo-&gt;fmt); // pixel format is no longer valid
    err = aglReportError ();
  }
  pcontextInfo-&gt;fmt = 0;
  
  return err;
}

//-----------------------------------------------------------------------------------------------------------------------

// SuspendFullScreenGL

// Special suspend function to ensure the the GL window is hidden

// needs to be reviewed

OSStatus SuspendFullScreenGL (AGLDrawable aglDraw, AGLContext aglContext)
{
  if (aglDraw &amp;&amp; aglContext) // will only have a drawable
  {
    glFinish (); // must do this to ensure the queue is complete
    aglSetCurrentContext (NULL);
#if TARGET_API_MAC_CARBON
    HideWindow (GetWindowFromPort (aglDraw));
#else
    HideWindow ((WindowPtr) aglDraw);
#endif
    return aglReportError ();
  }
  return noErr;
}

//-----------------------------------------------------------------------------------------------------------------------

// ResumeFullScreenGL

// Needs a special resume function to ensure the the GL window is shown

// needs to be reviewed

OSStatus ResumeFullScreenGL (AGLDrawable aglDraw, AGLContext aglContext)
{
  if (aglDraw &amp;&amp; aglContext)
  {
#if TARGET_API_MAC_CARBON
    ShowWindow (GetWindowFromPort (aglDraw));
#else
    ShowWindow ((WindowPtr) aglDraw);
#endif
    aglSetCurrentContext (aglContext);
    aglUpdateContext (aglContext);
    return aglReportError ();
  }
  return paramErr;
}

//-----------------------------------------------------------------------------------------------------------------------

// PauseGL

// Pauses gl to allow toolbox drawing

OSStatus PauseGL (AGLContext aglContext)
{
  if (aglContext)
  {
    glFinish (); // must do this to ensure the queue is complete
    aglSetCurrentContext (NULL);
    return aglReportError ();
  }
  return paramErr;
}

//-----------------------------------------------------------------------------------------------------------------------

// ResumeGL

// resumes gl to allow gl drawing

OSStatus ResumeGL (AGLContext aglContext)
{
  if (aglContext)
  {
    aglSetCurrentContext (aglContext);
    aglUpdateContext (aglContext);
    return aglReportError ();
  }
  return paramErr;
}

// --------------------------------------------------------------------------

// FindGDHandleFromRect

// Inputs:  a global Rect

// Outputs:  the GDHandle that that Rect is mostly on

// returns the number of devices that the Rect touches
short FindGDHandleFromRect (Rect * pRect, GDHandle * phgdOnThisDevice)
{
  Rect rectSect;
  long greatestArea, sectArea;
  short numDevices = 0;
  GDHandle hgdNthDevice;
  
  if (!phgdOnThisDevice)
    return NULL;
    
  *phgdOnThisDevice = NULL;
  
  hgdNthDevice = GetDeviceList ();
  greatestArea = 0;
  // check window against all gdRects in gDevice list and remember 
  //  which gdRect contains largest area of window}
  while (hgdNthDevice)
  {
    if (TestDeviceAttribute (hgdNthDevice, screenDevice))
      if (TestDeviceAttribute (hgdNthDevice, screenActive))
      {
        // The SectRect routine calculates the intersection 
        //  of the window rectangle and this gDevice 
        //  rectangle and returns TRUE if the rectangles intersect, 
        //  FALSE if they don't.
        SectRect (pRect, &amp;(**hgdNthDevice).gdRect, &amp;rectSect);
        // determine which screen holds greatest window area
        //  first, calculate area of rectangle on current device
        sectArea = (long) (rectSect.right - rectSect.left) * (rectSect.bottom - rectSect.top);
        if (sectArea &gt; 0)
          numDevices++;
        if (sectArea &gt; greatestArea)
        {
          greatestArea = sectArea; // set greatest area so far
          *phgdOnThisDevice = hgdNthDevice; // set zoom device
        }
        hgdNthDevice = GetNextDevice(hgdNthDevice);
      }
  }
  return numDevices;
}

// --------------------------------------------------------------------------

// GetWindowDevice

// Inputs:  a valid WindowPtr

// Outputs:  the GDHandle that that window is mostly on

// returns the number of devices that the windows content touches

short FindGDHandleFromWindow (WindowPtr pWindow, GDHandle * phgdOnThisDevice)
{
  GrafPtr pgpSave;
  Rect rectWind, rectSect;
  long greatestArea, sectArea;
  short numDevices = 0;
  GDHandle hgdNthDevice;
  
  if (!pWindow || !phgdOnThisDevice)
    return NULL;
    
  *phgdOnThisDevice = NULL;
  
  GetPort (&amp;pgpSave);
  SetPortWindowPort (pWindow);
  

#if TARGET_API_MAC_CARBON
  GetWindowPortBounds (pWindow, &amp;rectWind);
#else
  rectWind = pWindow-&gt;portRect;
#endif // TARGET_API_MAC_CARBON
  LocalToGlobal ((Point*)&amp; rectWind.top);  // convert to global coordinates
  LocalToGlobal ((Point*)&amp; rectWind.bottom);
  hgdNthDevice = GetDeviceList ();
  greatestArea = 0;
  // check window against all gdRects in gDevice list and remember 
  //  which gdRect contains largest area of window}
  while (hgdNthDevice)
  {
    if (TestDeviceAttribute (hgdNthDevice, screenDevice))
      if (TestDeviceAttribute (hgdNthDevice, screenActive))
      {
        // The SectRect routine calculates the intersection 
        //  of the window rectangle and this gDevice 
        //  rectangle and returns TRUE if the rectangles intersect, 
        //  FALSE if they don't.
        SectRect (&amp;rectWind, &amp;(**hgdNthDevice).gdRect, &amp;rectSect);
        // determine which screen holds greatest window area
        //  first, calculate area of rectangle on current device
        sectArea = (long) (rectSect.right - rectSect.left) * (rectSect.bottom - rectSect.top);
        if (sectArea &gt; 0)
          numDevices++;
        if (sectArea &gt; greatestArea)
        {
          greatestArea = sectArea; // set greatest area so far
          *phgdOnThisDevice = hgdNthDevice; // set zoom device
        }
        hgdNthDevice = GetNextDevice(hgdNthDevice);
      }
  }
  
  SetPort (pgpSave);
  return numDevices;
}

//-----------------------------------------------------------------------------------------------------------------------

// FindDeviceNumFromRect

// returns the number of the device that the point is on (i.e., where it is in the search order)
// just a ultility to find the number of the device from a point

short FindDeviceNumFromRect (Rect * pRect)
{
  short displayNum = 0;
  GDHandle hgdNthDevice, hgdFoundDevice;
  
  FindGDHandleFromRect (pRect, &amp;hgdFoundDevice);
  
  hgdNthDevice = DMGetFirstScreenDevice (true);
  while (hgdNthDevice)
  {
    if (hgdFoundDevice == hgdNthDevice)
      break;
    hgdNthDevice = DMGetNextScreenDevice(hgdNthDevice, true);
    displayNum++;
  }   // of WHILE

  return displayNum;
}</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/OpenGLMovieQT/listing11.html%3Fid%3DDTS10000847-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/OpenGLMovieQT/listing11.html%3Fid%3DDTS10000847-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/OpenGLMovieQT/listing11.html%3Fid%3DDTS10000847-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>