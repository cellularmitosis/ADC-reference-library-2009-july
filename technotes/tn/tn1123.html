<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"			"http://www.w3.org/TR/REC-html40/loose.dtd"><HTML><!-- Template 01-05-01 --><head><LINK REL="stylesheet" HREF="../../adcstyle.css" TYPE="text/css"><LINK REL="stylesheet" HREF="../../style.css" TYPE="text/css">   <title>Technical Note TN1123: Start Manager Extension Table Mechanism</title>    <meta name="keywords" content="Mac OS 8 Start Manager Extension Table monitor control ExtensionElement">    <meta name="Description" content="Technical Note TN1123: This Technical Note describes howthe Start Manager was changed in Mac OS 8.1, and shows howa program can monitor or take control of the system extensionloading process. Included is a discussion of Extension TableManager, which focuses on such things as Constants, DataTypes, Routines, and Result Codes."><meta name="categories" content="Runtime Architecture, Operating System and System Releases"><meta name="week-posted" content="Mar 30, 1998 - Apr 3, 1998"><LINK REL="stylesheet" HREF="../../css/adcstyle.css" TYPE="text/css"><script language="JavaScript" type="text/javascript" src="../../js/adc.js"></script></HEAD><BODY BGCOLOR="#FFFFFF"><a name="//apple_ref/doc/uid/DTS10002963" title="Start Manager Extension Table Mechanism"></a><A NAME="top"></A><!-- begin_header_information --><!--#include virtual="/adcnavbar" --><p><a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../technicalnotes/index.html">Technical Notes</a> &gt; <a href="../../technicalnotes/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../technicalnotes/LegacyTechnologies/idxCarbon-date.html">Carbon</a> &gt; </p><div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/Carbon/idxRuntimeArchitecture-date.html" target="_blank">Carbon > Runtime Architecture</a></li>
	</ul>
</div>




</div></div></div><!-- end_header_information --><!-- bottom_of_header_marker_comment --><!-- top_of_titles_marker_comment --><CENTER><table width="600" cellpadding="0" cellspacing="0" border="0">
<tr><td align="left" scope="row">
<h1>
<div id="pagehead">Technical Note TN1123</div>
<div id="pageheadsub">Start Manager Extension Table Mechanism</div>
</h1>
</td></tr></table></CENTER><!-- bottom_of_titles_marker_comment --><center><TABLE BORDER=0 CELLSPACING=1 WIDTH=600><TR><td align="left">          <!-- begin_header_box --><table width="600" cellpadding="0" cellspacing="0" border="0">    <tr>        <td width=300 valign="top" align=left scope="row">            <table border="0" width="300" cellpadding="0" cellspacing="0">			<tr>                        <td width=300 align=left> <img src="images/tnmenutop.gif" alt="" align="bottom" width=300 height=7></td>                </tr>                <tr bgcolor="#e6e6e6">                    <td background="images/tnmenubody.gif" width=300 align=left>                        <span id="menutitle">                            CONTENTS                             <br>                            <br>                        </span>                    </td>                </tr>                <tr bgcolor="#e6e6e6">                    <td background="images/tnmenubody.gif" width=300 align=left><!-- begin_toc --><P id = "menutext">            <A HREF = "#Introduction">Introduction</A><BR><BR>            <A HREF = "#MonitoringExtensionLoading">Monitoring            System Extension Loading and Execution</A><BR><BR>            <A HREF = "#ControlingExtensionLoading">Controlling            System Extension Loading and Execution</A><BR><BR>            <A HREF = "#ExtensionTableManagerReference">Extension            Table Manager Reference</A><BR><BR>            <A HREF = "#ExtensionTable">Summary of            the Extension Table Manager</A><BR><BR>			<A HREF="#Downloads">Downloadables</A></p>                   <!-- end_toc -->                  </td>                </tr>                <tr>                    <td width=300 align=left scope="row">                        <img src="images/tnmenubottom.gif" alt="" width=300 height=16>                    </td>                </tr>            </table>        </td>        <td width=300 valign="top" align=left>            			<!-- begin_intro_text --><P id ="introtext">The Start Manager wasrevised in Mac OS 8.1 to add a mechanism for monitoring andcontrolling the loading of system extensions during systemstartup.</P><P id ="introtext">This Technote describes how the Start Manager was changed, andshows how a program can monitor or take control of the systemextension loading process.</P><!-- end_intro_text --><!-- begin_date --><h3>&nbsp;Updated: [Apr 15 1998]</h3><!-- end_date -->        </td>    </tr></table> <!-- end_header_box --><BR><BR><hr width=500 align=center><BR><BR><!-- begin_content --><H2><A NAME=Introduction></A>Introduction</H2><P>Prior to Mac OS 8.1, system extensions were loaded and executedfrom three folders in order: the Extensions folder, Control Panelsfolder, and the System Folder. The system extensions in each folderwere loaded and executed in the order they were found on the disk. Onan HFS volume (also known as Mac OS Standard) item names are storedusing ASCII characters. Items are stored in the catalog file in<CODE>RelString</CODE> order, i.e., in the order the names would bein if sorted by the <CODE>RelString</CODE> function. Because of this,the File Manager's <CODE>GetFInfo</CODE> routine returns files in<CODE>RelString</CODE> order.</P><P>With the introduction of Mac OS 8.1, a new bootable disk format,HFS Plus (also known as Mac OS Extended), was introduced. On HFS Plusvolumes item names are stored using Unicode, rather than ASCIIcharacters. Items are stored in the catalog file in a different orderthan they would be on an HFS volume. Details on the sorting order forHFS Plus volumes can be found in the HFS Plus Volume Formatdocumentation.</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>         Applications should never rely on the order in which files         are stored on a volume. Each volume format is free to sort         item in any order, or to not sort items at all.</P></TD></TR></TABLE></CENTER><BR><BR><P>On systems using the Roman script system, files on HFS Plusvolumes are returned by <CODE>GetFInfo</CODE> in a similar, but not exactly thesame, order as <CODE>RelString</CODE>. However, on systems running non-Romanscript systems, <CODE>GetFInfo</CODE> may return files in a radically differentorder.</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>         Apple has always maintained that system extensions cannot         depend on a particular load order; however, many system         extensions do require specific loading orders.</P></TD></TR></TABLE></CENTER><BR><BR><P>To prevent problems for our users, and to ensure that systemextensions load and execute in the same order regardless of thevolume format and script system used, the system extension mechanismwas revised to be table driven. The Start Manager builds a singletable of system extensions, sorted using <CODE>RelString</CODE>, fromthe system extensions found in each folder. Then, each systemextension is loaded and executed, in order, from the table. Theresult is that system extensions are loaded and executed in the sameorder regardless of which type of volume the system is booting fromand what script system the system is running.</P><P>The Start Manager was revised to allow other programs access tothe system extension loading mechanism. Programs can either monitoror control the system extension loading and execution process.</P><P><A NAME="Monitor and Control"></A></P><H3>Monitor and Control</H3><P>A program can install an <CODE>ExtensionNotificationProc</CODE> tomonitor the system extension loading process. Each<CODE>ExtensionNotificationProc</CODE> is called before the firstsystem extension is loaded and executed, both before and after eachsystem extension is loaded and executed, and after the last systemextension is loaded and executed. When called, an extensionnotification routine can perform some action such as drawing an icon,playing a sound, displaying the system extension's name, or savingthe system extension's name in a file to help debug system extensioncrashes or document system extension loading order. An<CODE>ExtensionNotificationProc</CODE> cannot change the order thatsystem extensions load and execute. Any number of<CODE>ExtensionNotificationProcs</CODE> can be installed.</P><P>A program can install an <CODE>ExtensionTableHandlerProc</CODE> tocontrol the system extension loading process. The<CODE>ExtensionTableHandlerProc</CODE> is called before the firstsystem extension is loaded and executed, both before and after eachsystem extension is loaded and executed, and after the last systemextension is loaded and executed. Unlike an<CODE>ExtensionNotificationProc</CODE>, the<CODE>ExtensionTableHandlerProc</CODE> owns the extension table andhas complete control over the order that system extensions load andexecute. A program that installs an<CODE>ExtensionTableHandlerProc</CODE> can also prevent some systemextensions from loading and load system extensions from other thanthe default folders. Only one <CODE>ExtensionTableHandlerProc</CODE>can be installed.</P><P>If no <CODE>ExtensionTableHandlerProc</CODE> is installed, theStart Manager uses its own default extension table handler. Thisdefault extension table handler mimics the behavior of the FileManager under previous versions of Mac OS (i.e., if the contents of afolder used to build the extension table changes, then the extensiontable is rebuilt and execution is resumed where it would have if theStart Manager were calling <CODE>GetFInfo</CODE>).</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>         An <CODE>ExtensionNotificationProc</CODE> or         <CODE>ExtensionTableHandlerProc</CODE> can be installed at         any point in the startup process and will begin receiving         messages from that point forward. An <CODE>ExtensionTableHandlerProc</CODE>         can control the loading and execution of system extensions that have not         already been installed.</P></TD></TR></TABLE></CENTER><BR><BR><P><A NAME="The Extension Table"></A></P><H3>The Extension Table</H3><P>The extension table is a relocatable block in the system heapcontaining an <CODE>ExtensionTable</CODE> structure. An<CODE>ExtensionTable</CODE> consists of an<CODE>ExtensionTableHeader</CODE> followed by an array of<CODE>ExtensionElement</CODE>s. The <CODE>ExtensionTableHeader</CODE>contains the version field which indicates the version of both the<CODE>ExtensionTable</CODE> and the <CODE>ExtensionElement</CODE>records, an index into the <CODE>ExtensionElement</CODE>s whichindicates which system extension is currently loading and executing,the size of an <CODE>ExtensionElement</CODE>, and the number of<CODE>ExtensionElement</CODE>s in the table. Each<CODE>ExtensionElement</CODE> in the <CODE>ExtensionTable</CODE>contains information used to identify which system extensions will beloaded and executed by the Start Manager.</P><P>Each installed <CODE>ExtensionNotificationProc</CODE> will bepassed a copy of the <CODE>ExtensionElement</CODE> for the systemextension which is currently being loaded and executed.</P><P>The <CODE>ExtensionTableHandlerProc</CODE> controlling the systemextension loading process will be passed the<CODE>ExtensionTable</CODE> each time it is called. This handler cancontrol the loading of system extensions by modifying the<CODE>ExtensionTable</CODE>.</P><P><A NAME="The Boot Process"></A></P><H3>The Boot Process</H3><P>The Start Manager installs the APIs for installing and removing<CODE>ExtensionTableHandlerProc</CODE> and<CODE>ExtensionNotificationProc</CODE>s early in the boot process(after MacsBug has loaded but before MacsBug<CODE>dcmdSecondaryINIT</CODE> time).</P><P>Before system extensions are to be loaded and executed, the StartManager creates an extension table.</P><P>Before the first system extension is loaded and executed, the<CODE>ExtensionTableHandlerProc</CODE> and each<CODE>ExtensionNotificationProc</CODE> will be called with the<CODE>extNotificationBeforeFirst</CODE> message indicating that thesystem extension loading process is about to begin. The<CODE>ExtensionTableHandlerProc</CODE> is always called with the<CODE>extNotificationBeforeFirst</CODE> message before any<CODE>ExtensionNotificationProc</CODE>.</P><P>The Start Manager then loads and executes each system extension inorder from the extension table. Before each system extension isloaded and executed, the <CODE>ExtensionTableHandlerProc</CODE> andall <CODE>ExtensionNotificationProc</CODE>s are called with the<CODE>extNotificationBeforeCurrent</CODE> message. After each systemextension is loaded and executed, all<CODE>ExtensionNotificationProc</CODE>s and the<CODE>ExtensionTableHandlerProc</CODE> are called with the<CODE>extNotificationAfterCurrent</CODE> message. The<CODE>ExtensionTableHandlerProc</CODE> is always called with the<CODE>extNotificationBeforeCurrent</CODE> message before any<CODE>ExtensionNotificationProc</CODE>s, and the<CODE>ExtensionTableHandlerProc</CODE> is always called with the<CODE>extNotificationAfterCurrent</CODE> message after any<CODE>ExtensionNotificationProc</CODE>s.</P><P>After all system extensions have been loaded all<CODE>ExtensionNotificationProc</CODE>s and the<CODE>ExtensionTableHandlerProc</CODE> are called with theextNotificationAfterLast message indicating that the system extensionloading process is complete. The<CODE>ExtensionTableHandlerProc</CODE> is always called with the<CODE>extNotificationAfterLast</CODE> message after the last<CODE>ExtensionNotificationProc</CODE>.</P><P>In all cases, the relative order in which<CODE>ExtensionNotificationProc</CODE>s are called is notdefined.</P><H2><A NAME="MonitoringExtensionLoading"></A>MonitoringSystem Extension Loading</H2><P>An INIT, or a program executed before system extensions areloaded, can monitor the system extension loading process by calling<CODE>InstallExtensionNotificationProc</CODE> to install an<CODE>ExtensionNotificationProc</CODE>. Once installed, this handlerwill be called:</P><UL>   <LI>Before the first system extension is loaded and executed (if   installed before the system extension load and execute   process).</LI>      <LI>Before each system extension is loaded and executed.</LI>      <LI>After each system extension has been loaded and executed.</LI>      <LI>After the last system extension has been loaded and   executed.</LI></UL><P>An <CODE>ExtensionNotificationProc</CODE> receives an<CODE>ExtensionElementPtr</CODE> which points to a copy of the<CODE>ExtensionElement</CODE> for the system extension currentlybeing loaded.</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>         The data in the <CODE>ExtensionElement</CODE> is read-only.         While you can change it, you'll only be changing a copy of         the <CODE>ExtensionElement</CODE>. Any changes will be         discarded when the <CODE>ExtensionNotificationProc</CODE>         returns.</P></TD></TR></TABLE></CENTER><BR><BR><P>There can be any number of <CODE>ExtensionNotificationProc</CODE>sinstalled.</P><hr width=500 align=center><H2><A NAME="ControlingExtensionLoading"></A>ControllingSystem Extension Loading</H2><P>An INIT, or a program executed before system extensions areloaded, can take control of the system extension loading process bycalling <CODE>InstallExtensionTableHandlerProc</CODE> to install a<CODE>ExtensionTableHandlerProc</CODE>.<CODE>InstallExtensionTableHandlerProc</CODE> returns the default<CODE>ExtensionTable</CODE> created by the Start Manager.</P><P>There can only be one <CODE>ExtensionTableHandlerProc</CODE>installed.</P><P>While it is installed, the <CODE>ExtensionTableHandlerProc</CODE>is responsible for all changes to the <CODE>ExtensionTable</CODE>,except for incrementing <CODE>extElementIndex</CODE> field betweensystem extensions. After an <CODE>ExtensionTableHandlerProc</CODE> isinstalled, the system's default extension table handler no longermanages the <CODE>ExtensionTable</CODE>.</P><P>Once installed, the <CODE>ExtensionTableHandlerProc</CODE> will becalled:</P><UL>   <LI>Before the first system extension is loaded and executed (if   installed before the system extension load and execute   process).</LI>      <LI>Before each system extension is loaded and executed.</LI>      <LI>After each system extension has been loaded and executed.</LI>      <LI>After the last system extension has been loaded and   executed.</LI></UL><P>Unlike <CODE>ExtensionNotificationProcs</CODE>, the<CODE>ExtensionTableHandlerProc</CODE> receives a handle to the<CODE>ExtensionTable</CODE> used by the Start Manager -- not acopy.</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>         Once an installed <CODE>ExtensionTableHandlerProc</CODE>         modifies the <CODE>ExtensionTable,</CODE> or the contents of         the folders controlled in the <CODE>ExtensionTable</CODE>         are changed, the handler cannot be removed. Calling         <CODE>RemoveExtensionTableHandlerProc</CODE> after these         changes will return a         <CODE>paramErr</CODE>         error.</P></TD></TR></TABLE></CENTER><BR><BR><P>The <CODE>extElementIndex</CODE> field in the<CODE>ExtensionTable</CODE> is always incremented to the next<CODE>ExtensionElement</CODE> immediately after the<CODE>ExtensionTableHandlerProc</CODE> is called with the<CODE>extNotificationAfterCurrent</CODE> message.</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>IMPORTANT:</B><BR>         When controlling the loading of system extensions, the only         safe time to change which <CODE>ExtensionElement</CODE> is         at         <CODE>ExtensionTable.extElements[extElementIndex]</CODE>         is when your <CODE>ExtensionTableHandlerProc</CODE> is         called with the <CODE>extNotificationAfterCurrent</CODE>         message. You may change the <CODE>ExtensionTable</CODE> or         the <CODE>extElementIndex</CODE> at other times, but you         must ensure that the <CODE>ExtensionElement</CODE> at         <CODE>ExtensionTable.extElements[extElementIndex]</CODE>         stays the same.</P></TD></TR></TABLE></CENTER><BR><BR><hr width=500 align=center><H2><A NAME="ExtensionTableManagerReference"></A>ExtensionTable Manager Reference</H2><P>This section discusses the techniques you can use to monitor orcontrol the system extension loading and execution process.</P><P><A NAME="ExtensionTableVersion(gestalt)"></A></P><H3>Extension Table Version(<CODE>Gestalt</CODE>)</H3><P>You should call <CODE>Gestalt</CODE>with the <CODE>gestaltExtensionTableVersion</CODE> selector todetermine the version of <CODE>ExtensionTable</CODE> currentlyinstalled before installing any handlers for the extension tablemechanism.</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>enum {    gestaltExtensionTableVersion = FOUR_CHAR_CODE('etbl') /* ExtensionTable version */};</pre></TD></TR></TABLE></CENTER><BR><BR><P>The current (Mac OS 8.1) <CODE>ExtensionTable</CODE> version is1.0.0.</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>enum {    kExtensionTableVersion = 0x00000100  /* current ExtensionTable version (1.0.0) */};</pre></TD></TR></TABLE></CENTER><BR><BR><P>If <CODE>gestaltExtensionTableVersion</CODE> is not defined, itindicates that there is no extension table mechanism present and thatthe associated extension table routines will be undefined.</P><P>When the major version number of<CODE>kExtensionTableVersion</CODE> and the value returned by<CODE>gestaltExtensionTableVersion</CODE> are different, it indicatesthat the extension table mechanism has radically changed and codethat doesn't know about the new major version must not attempt to usethe extension table mechanism.</P><P>Changes to the minor version number of<CODE>kExtensionTableVersion</CODE> indicate that the definition ofthe ExtensionElement structure has been extended, but the fieldsdefined for previous minor versions of<CODE>kExtensionTableVersion</CODE> have not changed.</P><P><A NAME="Extension Table Structure"></A></P><H3>ExtensionTable Structure</H3><P>An <CODE>ExtensionTable</CODE> is an<CODE>ExtensionTableHeader</CODE> followed by an array of<CODE>ExtensionElements</CODE>. This structure is built by theextension table mechanism when it scans for system extensions to beloaded and executed at boot time.</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>struct ExtensionTable {    ExtensionTableHeader     extTableHeader; /* the ExtensionTableHeader */    ExtensionElement         extElements[1]; /* one element for each extension to load */};typedef struct ExtensionTable    ExtensionTable;typedef        ExtensionTable    * ExtensionTablePtr;typedef        ExtensionTablePtr * ExtensionTableHandle;</pre></TD></TR></TABLE></CENTER><BR><BR><P>An <CODE>ExtensionTableHandle</CODE> containing the current<CODE>ExtensionTable</CODE> will be passed as a parameter to theinstalled <CODE>ExtensionTableHandlerProc</CODE> when it iscalled.</P><P><A NAME="ExtensionTableHeader Structure"></A></P><H3>ExtensionTableHeader Structure</H3><P>An <CODE>ExtensionTable</CODE> begins with an<CODE>ExtensionTableHeader</CODE>.</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>struct ExtensionTableHeader {    UInt32    extTableHeaderSize;    UInt32    extTableVersion;    UInt32    extElementIndex;    UInt32    extElementSize;    UInt32    extElementCount;};typedef struct ExtensionTableHeader ExtensionTableHeader;</pre></TD></TR></TABLE></CENTER><BR><BR><TABLE BORDER=0>   <TR>      <td valign=top width=143 height=36 align=left>         <P><CODE>extTableHeaderSize</CODE></P>      </TD>      <td valign=top width=355 height=36 align=left>         <P>The size of <CODE>ExtensionTableHeader</CODE>. Equal to         <CODE>offsetof(ExtensionTable,extElements[0])</CODE></P>      </TD>   </TR>   <TR>      <td valign=top width=143 height=36 align=left>         <P><CODE>extTableVersion</CODE></P>      </TD>      <td valign=top width=355 height=36 align=left>         <P>The current <CODE>ExtensionTable</CODE> version. The same         as the value returned by         <CODE>gestaltExtensionTableVersion</CODE> Gestalt         selector</P>      </TD>   </TR>   <TR>      <td valign=top width=143 height=36 align=left>         <P><CODE>extElementIndex</CODE></P>      </TD>      <td valign=top width=355 height=36 align=left>         <P>The current index into         <CODE>ExtensionElement[]</CODE> (zero-based).         Incremented by the Start Manager after each system extension         is loaded and executed</P>      </TD>   </TR>   <TR>      <td valign=top width=143 height=36 align=left>         <P><CODE>extElementSize</CODE></P>      </TD>      <td valign=top width=355 height=36 align=left>         <P>The size of the <CODE>ExtensionElement</CODE>s in this         version of the <CODE>ExtensionTable</CODE></P>      </TD>   </TR>   <TR>      <td valign=top width=143 height=12 align=left>         <P><CODE>extElementCount</CODE></P>      </TD>      <td valign=top width=355 height=12 align=left>         <P>The number of <CODE>ExtensionElement</CODE> records in         the <CODE>ExtensionTable</CODE></P></TD></TR></TABLE><P>The <CODE>ExtensionTableHandlerProc</CODE> should check the minorversion of the <CODE>extTableVersion</CODE> field. If it has changedsince the <CODE>ExtensionTableHandlerProc</CODE> was written, itindicates that the value of <CODE>extElementSize</CODE> will belarger. If the <CODE>ExtensionTableHandlerProc</CODE> is only movingand deleting elements in the table it could continue to run. However,if it wants to create new elements, it should remove itself because itwill not know how to create the new fields in the<CODE>ExtensionElement</CODE>s.</P><P>This structure is used internally by the Start Manager, and ispassed to the installed <CODE>ExtensionTableHandlerProc</CODE> eachtime it is called.</P><P><A NAME="Extension Element Structure"></A></P><H3>ExtensionElement Structure</H3><P>The <CODE>ExtensionElement</CODE> structure is used to holdinformation about each system extension that the Start Manager willload and execute.</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>struct ExtensionElement {    Str31               fileName;         /* The file name */    long                parentDirID;      /* the file's parent directory ID */      /* everything after ioNamePtr in the HParamBlockRec.fileParam variant */    short               ioVRefNum;        /* always the real volume reference number*/                                          /* (not a drive, default, or working dirID) */    short               ioFRefNum;    SInt8               ioFVersNum;    SInt8               filler1;    short               ioFDirIndex;      /* always 0 in table */    SInt8               ioFlAttrib;    SInt8               ioFlVersNum;    FInfo               ioFlFndrInfo;    long                ioDirID;    unsigned short      ioFlStBlk;    long                ioFlLgLen;    long                ioFlPyLen;    unsigned short      ioFlRStBlk;    long                ioFlRLgLen;    long                ioFlRPyLen;    unsigned long       ioFlCrDat;    unsigned long       ioFlMdDat;};typedef struct ExtensionElement         ExtensionElement;typedef ExtensionElement *              ExtensionElementPtr;</pre></TD></TR></TABLE></CENTER><BR><BR><P>The first two elements identify the individual file, while therest of the elements are copied directly from the<CODE>fileParam</CODE> variant of the<CODE>HParamBlockRec</CODE>.</P><P>An <CODE>ExtensionElement</CODE> is created for each systemextension found by the Start Manager in the Extensions folder,Control Panels folder, and System Folder. These<CODE>ExtensionElements</CODE> are collected into a<CODE>ExtensionTable</CODE>.</P><P>An <CODE>ExtensionElementPtr</CODE> is passed as a parameter toeach installed <CODE>ExtensionNotificationProc</CODE> when it iscalled. The <CODE>ExtensionElement</CODE> it points to will contain acopy of the <CODE>ExtensionElement</CODE> for the system extensionthat is currently being loaded and executed.</P><P><A NAME="ExtensionNotification Message"></A></P><H3>Extension Notification MessageCodes</H3><P>When an <CODE>ExtensionNotificationProc</CODE> or<CODE>ExtensionTableHandlerProc</CODE> is called, it will be passed amessage parameter containing one of the following values.</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>enum {    extNotificationBeforeFirst   = 0, /* Before any system extensions have loaded */    extNotificationAfterLast     = 1, /* After all system extensions have loaded */    extNotificationBeforeCurrent = 2, /* Before system extension at */                                      /* extElementIndex is loaded */    extNotificationAfterCurrent  = 3  /* After system extension at */                                      /* extElementIndex is loaded */};</pre></TD></TR></TABLE></CENTER><BR><BR><P><A NAME=ExtensionNotificationProc></A></P><H3>ExtensionNotificationProc</H3><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>pascal void MyExtensionNotificationProc( UInt32 message, void *reserved,                                         ExtensionElementPtr extElement );</pre></TD></TR></TABLE></CENTER><BR><BR><TABLE BORDER=0>      <TR>         <td width=104 align=left>            <P><CODE>message</CODE></P>         </TD>         <td width=56 align=left>            <P>input</P>         </TD>         <td width=321 align=left>            <P>One of the 4 defined <CODE>ExtensionNotification</CODE> message            codes</P>         </TD>      </TR>      <TR>         <td width=104 align=left>            <P><CODE>reserved</CODE></P>         </TD>         <td width=56 align=left>            <P></P>         </TD>         <td width=321 align=left>            <P>Reserved for future use</P>         </TD>      </TR>      <TR>         <td width=104 align=left>            <P><CODE>extElement</CODE></P>         </TD>         <td width=56 align=left>            <P>input</P>         </TD>         <td width=321 align=left>            <P>Copy of the <CODE>ExtensionElement</CODE> for the system extension            currently being loaded and executed</P>         </TD>      </TR>   </TABLE><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>            <CODE>extElement</CODE> is not valid for the            <CODE>extNotificationBeforeFirst</CODE> and            <CODE>extNotificationAfterLast</CODE> messages.</P></TD></TR></TABLE></CENTER><BR><BR><P>An <CODE>ExtensionNotificationProc</CODE> receives an<CODE>ExtensionElementPtr</CODE> which points to a copy of the<CODE>ExtensionElement</CODE> for the system extension currentlybeing loaded.</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>         The data in the <CODE>ExtensionElement</CODE> is read-only.         While you can change it, you'll only be changing a copy of         the <CODE>ExtensionElement</CODE>. Any changes will be         discarded when the <CODE>ExtensionNotificationProc</CODE>         returns.</P></TD></TR></TABLE></CENTER><BR><BR><P>There can be any number of <CODE>ExtensionNotificationProcs</CODE>installed.</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>         An <CODE>ExtensionNotificationProc</CODE> cannot call         <CODE>RemoveExtensionNotificationProc</CODE>. If there is a         need for an <CODE>ExtensionNotificationProc</CODE> to         remove itself, the removal must be deferred by, for example,         installing a Notification Manager task and using the         notification task to remove the         <CODE>ExtensionNotificationProc</CODE>.</P></TD></TR></TABLE></CENTER><BR><BR><P><A NAME=TableHandlerProc></A></P><H3>ExtensionTableHandlerProc</H3><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>pascal void MyExtensionTableHandlerProc( UInt32 message, void *reserved,                                         ExtensionTableHandle extTableHandle );</pre></TD></TR></TABLE></CENTER><BR><BR><TABLE BORDER=0>      <TR>         <td width=56 align=left>            <P><CODE>message</CODE></P>         </TD>         <td width=56 align=left>            <P>input</P>         </TD>         <td width=200 align=left>            <P>One of the 4 defined <CODE>ExtensionNotification</CODE> message            codes</P>         </TD>      </TR>      <TR>         <td width=56 align=left>            <P><CODE>reserved</CODE></P>         </TD>         <td width=56 align=left>            <P></P>         </TD>         <td width=200 align=left>            <P>Reserved for future use</P>         </TD>      </TR>      <TR>         <td width=56 align=left>            <P><CODE>extTableHandle</CODE></P>         </TD>         <td width=56 align=left>            <P>input</P>         </TD>         <td width=200 align=left>            <P><CODE>ExtensionTableHandle</CODE> containing all            system extensions to be loaded</P>         </TD>      </TR>   </TABLE><P>An <CODE>ExtensionTableHandlerProc</CODE> receives a handle to the<CODE>ExtensionTable</CODE> created at startup by the Start Manager.When an <CODE>ExtensionTableHandlerProc</CODE> is installed, thesystem's default handler no longer manages the<CODE>ExtensionTable</CODE>. While it is installed, the<CODE>ExtensionTableHandlerProc</CODE> is responsible for all changes to the<CODE>ExtensionTable</CODE>, except for incrementing<CODE>extElementIndex</CODE> between system extensions.</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>         If the <CODE>ExtensionTable</CODE> or the contents of the         folders included in the <CODE>ExtensionTable</CODE> are         changed after installing an         <CODE>ExtensionTableHandlerProc</CODE>,         <CODE>RemoveExtensionTableHandlerProc</CODE> cannot be         called.</P></TD></TR></TABLE></CENTER><BR><BR><P>The <CODE>extElementIndex</CODE> field is always incremented topoint to the next system extension to be loaded immediately after the<CODE>ExtensionTableHandlerProc</CODE> is called with the<CODE>extNotificationAfterCurrent</CODE> message.</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>IMPORTANT:</B><BR>         When controlling the loading of system extensions, the only         safe time to change which <CODE>ExtensionElement</CODE> is         at         <CODE>ExtensionTable.extElements[extElementIndex]</CODE>         is when your <CODE>ExtensionTableHandlerProc</CODE> is         called with the <CODE>extNotificationAfterCurrent</CODE>         message. You may change the <CODE>ExtensionTable</CODE> or         the <CODE>extElementIndex</CODE> at other times, but you         must ensure that the <CODE>ExtensionElement</CODE> at         <CODE>ExtensionTable.extElements[extElementIndex]</CODE>         stays the same.</P></TD></TR></TABLE></CENTER><BR><BR><P>The installed <CODE>ExtensionTableHandlerProc</CODE> is always thefirst handler called with <CODE>extNotificationBeforeFirst</CODE> and<CODE>extNotificationBeforeCurrent</CODE> messages and the lasthandler called with <CODE>extNotificationAfterLast</CODE> and<CODE>extNotificationAfterCurrent</CODE> messages.</P><P>There can only be one <CODE>ExtensionTableHandlerProc</CODE>installed.</P><A NAME=InstallExtensionNotificationPro></A><H3>InstallExtensionNotificationProc</H3><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>OSErr InstallExtensionNotificationProc( ExtensionNotificationUPP extNotificationProc )</pre></TD></TR></TABLE></CENTER><BR><BR><P>Parameters:</P><TABLE BORDER=0>      <TR>         <td width=139 align=left>            <P><CODE>extNotificationProc</CODE></P>         </TD>         <td width=56 align=left>            <P>input</P>         </TD>         <td width=246 align=left>            <P>The <CODE>ExtensionNotificationUPP</CODE> to            install</P>         </TD>      </TR>   </TABLE><P>Results:</P><TABLE BORDER=0 WIDTH="99%">      <TR>         <td width=81 align=left>            <P><CODE>noErr</CODE></P>         </TD>         <td width=31 align=left>            <P ALIGN=right>0</P>         </TD>         <td width=200 align=left>            <P>The <CODE>ExtensionNotificationUPP</CODE> was            installed</P>         </TD>      </TR>      <TR>         <td width=81 align=left>            <P><CODE>paramErr</CODE></P>         </TD>         <td width=31 align=left>            <P ALIGN=right>-50</P>         </TD>         <td width=200 align=left>            <P>This <CODE>ExtensionNotificationUPP</CODE> has already            been installed</P>         </TD>      </TR>      <TR>         <td width=81 align=left>            <P><CODE>memFullErr</CODE></P>         </TD>         <td width=31 align=left>            <P ALIGN=right>-108</P>         </TD>         <td width=200 align=left>            <P>Not enough memory to install the            <CODE>ExtensionNotificationUPP</CODE></P>         </TD>      </TR>   </TABLE><P>Installs an <CODE>ExtensionNotificationUPP</CODE>.</P><P>Multiple <CODE>ExtensionNotificationProcs</CODE> may beinstalled.</P><P><A NAME=RemoveExtensionNotificationProc></A></P><H3>RemoveExtensionNotificationProc</H3><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>OSErr RemoveExtensionNotificationProc (ExtensionNotificationUPP                                       extNotificationProc)</pre></TD></TR></TABLE></CENTER><BR><BR><P>Parameters:</P><TABLE BORDER=0 WIDTH="99%">      <TR>         <td width=139 align=left>            <P><CODE>extNotificationProc</CODE></P>         </TD>         <td width=56 align=left>            <P>input</P>         </TD>         <td width=246 align=left>            <P>The <CODE>ExtensionNotificationUPP</CODE> to            remove</P>         </TD>      </TR>   </TABLE><P>Results:</P><TABLE BORDER=0 WIDTH="99%">      <TR>         <td width=81 align=left>            <P><CODE>noErr</CODE></P>         </TD>         <td width=31 align=left>            <P ALIGN=right>0</P>         </TD>         <td width=330 align=left>            <P>The <CODE>ExtensionNotificationUPP</CODE> was            installed</P>         </TD>      </TR>      <TR>         <td valign=top width=81 align=left>            <P><CODE>paramErr</CODE></P>         </TD>         <td valign=top width=31 align=left>            <P ALIGN=right>-50</P>         </TD>         <td valign=top width=200 align=left>            <P>This <CODE>ExtensionNotificationUPP</CODE> was not            found, or <CODE>RemoveExtensionNotificationProc</CODE>            was called from within a            <CODE>ExtensionNotificationProc</CODE></P>         </TD>      </TR>   </TABLE><P>Removes an <CODE>ExtensionNotificationUPP</CODE>.</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>         <CODE>ExtensionNotificationProcs</CODE> cannot call         <CODE>RemoveExtensionNotificationProc</CODE>.</P></TD></TR></TABLE></CENTER><BR><BR><P><A NAME=InstallExtensionTableHandlerPro></A></P><H3>InstallExtensionTableHandlerProc</H3><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>OSErr InstallExtensionTableHandlerProc( ExtensionTableHandlerUPP extMgrProc,                                        ExtensionTableHandle * extTable)</pre></TD></TR></TABLE></CENTER><BR><BR><P>Parameters:</P><TABLE BORDER=0 WIDTH="99%">      <TR>         <td width=100 align=left>            <P><CODE>extMgrProc</CODE></P>         </TD>         <td width=40 align=left>            <P>input</P>         </TD>         <td width=246 align=left>            <P>The <CODE>ExtensionTableHandlerUPP</CODE> to            install</P>         </TD>      </TR>      <TR>         <td valign=top width=100 align=left>            <P><CODE>extTable</CODE></P>         </TD>         <td valign=top width=40 align=left>            <P>input</P>         </TD>         <td width=246 align=left>            <P>A pointer to an <CODE>ExtensionTableHandle</CODE>            where <CODE>InstallExtensionTableHandlerProc</CODE> will            return the current <CODE>ExtensionTableHandle</CODE>. You            don't own the handle itself and must not dispose of it,            but you can change the <CODE>extElementIndex</CODE>. the            <CODE>extElementCount</CODE>, and the            <CODE>ExtensionElements</CODE> in the table.</P>         </TD>      </TR>   </TABLE><P>Results:</P><TABLE BORDER=0 WIDTH="99%">      <TR>         <td width=81 align=left>            <P><CODE>noErr</CODE></P>         </TD>         <td width=31 align=left>            <P ALIGN=right><CODE>0</CODE></P>         </TD>         <td width=200 align=left>            <P>The <CODE>ExtensionTableHandlerUPP</CODE> was            installed</P>         </TD>      </TR>      <TR>         <td valign=top width=81 align=left>            <P><CODE>paramErr</CODE></P>         </TD>         <td valign=top width=31 align=left>            <P ALIGN=right><CODE>-50</CODE></P>         </TD>         <td width=200 align=left>            <P>Another <CODE>ExtensionTableHandlerUPP</CODE> has            already been installed</P>         </TD>      </TR>      <TR>         <td width=81 align=left>            <P><CODE>memFullErr</CODE></P>         </TD>         <td width=31 align=left>            <P ALIGN=right><CODE>-108</CODE></P>         </TD>         <td width=200 align=left>            <P>Not enough memory to install the            <CODE>ExtensionTableHandlerUPP</CODE></P>         </TD>      </TR>   </TABLE><P>Installs an <CODE>ExtensionTableHandlerUPP</CODE>.</P><P>There can only be one <CODE>ExtensionTableHandlerProc</CODE>installed.</P><P><A NAME=RemoveExtensionTableHandlerProc></A></P><H3>RemoveExtensionTableHandlerProc</H3><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>OSErr RemoveExtensionTableHandlerProc( ExtensionTableHandlerUPP extMgrProc )</pre></TD></TR></TABLE></CENTER><BR><BR><P>Parameters:</P><TABLE BORDER=0 WIDTH="99%">      <TR>         <td width=56 align=left>            <P><CODE>extMgrProc</CODE></P>         </TD>         <td width=56 align=left>            <P>input</P>         </TD>         <td width=200 align=left>            <P>The <CODE>ExtensionTableHandlerUPP</CODE> to            remove</P>         </TD>      </TR>   </TABLE><P>Results:</P><TABLE BORDER=0 WIDTH="99%">      <TR>         <td width=56 align=left>            <P><CODE>noErr</CODE></P>         </TD>         <td width=31 align=left>            <P ALIGN=right>0</P>         </TD>         <td width=200 align=left>            <P>The <CODE>ExtensionTableHandlerUPP</CODE> was            removed</P>         </TD>      </TR>      <TR>         <td valign=top width=56 align=left>            <P><CODE>paramErr</CODE></P>         </TD>         <td valign=top width=31 align=left>            <P ALIGN=right>-50</P>         </TD>         <td width=200 align=left>            <P>This <CODE>ExtensionTableHandlerUPP</CODE> was not            installed,<BR> or the <CODE>ExtensionTable</CODE> no longer            matches<BR> the original <CODE>ExtensionTable</CODE>.</P>         </TD>      </TR>   </TABLE><P>Remove an <CODE>ExtensionTableHandlerUPP</CODE>. Control is passedback to the default handler.</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>         If the <CODE>ExtensionTable</CODE> or the contents of the         folders included in the <CODE>ExtensionTable</CODE> are         changed after installing an         <CODE>ExtensionTableHandlerProc</CODE>,         <CODE>RemoveExtensionTableHandlerProc</CODE> cannot be         called.</P></TD></TR></TABLE></CENTER><BR><BR><H2><A NAME="ExtensionTable"></A>Summaryof the Extension Table Manager</H2><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>         All definitions in this section are available in Universal         Interfaces 3.1.</P></TD></TR></TABLE></CENTER><BR><BR><A NAME=Constants></A><H3>Constants</H3><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>enum {    gestaltExtensionTableVersion = FOUR_CHAR_CODE('etbl')  /* ExtensionTable version */};enum {    kExtensionTableVersion      = 0x00000100  /* current ExtensionTable version (1.0.0) */};/* ExtensionNotification message codes */enum {    extNotificationBeforeFirst  = 0,  /* Before any system extensions have loaded */    extNotificationAfterLast    = 1,  /* After all system extensions have loaded */    extNotificationBeforeCurrent = 2, /* Before system extension at */                                      /* extElementIndex is loaded */    extNotificationAfterCurrent = 3   /* After system extension at */                                      /* extElementIndex is loaded */};</pre></TD></TR></TABLE></CENTER><BR><BR><A NAME="Data Types"></A><H3>Data Types</H3><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>struct ExtensionElement {    Str31               fileName;          /* The file name */    long                parentDirID;       /* the file's parent directory ID */                                           /* and everything after ioNamePtr */                                           /* in the HParamBlockRec.fileParam variant */    short               ioVRefNum;         /* always the real volume reference number */                                           /* (not a drive, default, or working dirID) */    short               ioFRefNum;    SInt8               ioFVersNum;    SInt8               filler1;    short               ioFDirIndex;       /* always 0 in table */    SInt8               ioFlAttrib;    SInt8               ioFlVersNum;    FInfo               ioFlFndrInfo;    long                ioDirID;    unsigned short      ioFlStBlk;    long                ioFlLgLen;    long                ioFlPyLen;    unsigned short      ioFlRStBlk;    long                ioFlRLgLen;    long                ioFlRPyLen;    unsigned long       ioFlCrDat;    unsigned long       ioFlMdDat;};typedef struct ExtensionElement         ExtensionElement;typedef ExtensionElement *              ExtensionElementPtr;struct ExtensionTableHeader {    UInt32    extTableHeaderSize;    /* size of ExtensionTable header ( equal to */                                     /* offsetof(ExtensionTable, extElements[0])) */    UInt32    extTableVersion;       /* current ExtensionTable version (same as */                                     /* returned by gestaltExtensionTableVersion) */    UInt32    extElementIndex;       /* current index into ExtensionElement records */                                     /* (zero-based) */    UInt32    extElementSize;        /* size of ExtensionElement */    UInt32    extElementCount;       /* number of ExtensionElement records */                                     /* in table (1-based) */};typedef struct ExtensionTableHeader     ExtensionTableHeader;struct ExtensionTable {    ExtensionTableHeader   extTableHeader;          /* the ExtensionTableHeader */    ExtensionElement       extElements[1];  /* 1 element per system ext. to load */};typedef struct ExtensionTable           ExtensionTable;typedef ExtensionTable *                ExtensionTablePtr;typedef ExtensionTablePtr *             ExtensionTableHandle;</pre></TD></TR></TABLE></CENTER><BR><BR><A NAME=Routines></A><H3>Routines</H3><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>OSErr   InstallExtensionNotificationProc( ExtensionNotificationUPP  extNotificationProc)OSErr   RemoveExtensionNotificationProc( ExtensionNotificationUPP  extNotificationProc)OSErr   InstallExtensionTableHandlerProc( ExtensionTableHandlerUPP  extMgrProc,                                          ExtensionTableHandle *    extTable)OSErr   RemoveExtensionTableHandlerProc( ExtensionTableHandlerUPP  extMgrProc )</pre></TD></TR></TABLE></CENTER><BR><BR><A NAME="Result Codes"></A><H3>Result Codes</H3><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>noErr          0   The ExtensionNotificationUPP was removed.paramErr     -50   An error in the parameters prevented the                   normal execution of the routine.memFullErr  -108   Not enough memory to install the                   ExtensionTableHandlerUPP.</pre></TD></TR></TABLE></CENTER><BR><BR><BR><P><A HREF="#top">Back to top</A></P>        <A NAME="Downloads"></A>         <br><h2>Downloadables</h2>        <center><TABLE BORDER=0 CELLPADDING=3 WIDTH="600">          <TR>             <td width=50 align=left>               <P ALIGN=center><img src="images/acrobatsmall.gif" align=middle alt="Acrobat" width=22 height=23></P>            </TD>            <td align="left">               <p>Acrobat version of this Note (72K).</P>            </TD>            <td width=60 align=left>               <p><A HREF="pdf/tn1123.pdf">Download</A></P>            </TD>          </TR>        </TABLE></center><BR><BR>                  <BR><P><A HREF="#top">Back to top</A></P></TD></TR></TABLE></CENTER><!-- end_content --><!-- begin_footer_information -->	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/technotes/tn/tn1123.html%3Fid%3DDTS10002963-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/technotes/tn/tn1123.html%3Fid%3DDTS10002963-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/technotes/tn/tn1123.html%3Fid%3DDTS10002963-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>
<!--#include virtual="/includes/footer"--><!-- end_footer_information --></BODY></HTML>