<!-- Generated by Harlequin WebMaker 2.2.3 (23-Apr-1996)
LispWorks 3.2.2 -->
<HTML> <HEAD>
<TITLE>Preparing for a Session(IM:IC)</TITLE>
</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000" ="A" NAME="HEADING430"></A>



<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="IAC-429.html"><IMG ALIGN="BOTTOM" SRC="prev.gif" BORDER="none" HSPACE="20" ALT="Previous"></A> <A HREF="IAC-2.html"><IMG ALIGN="BOTTOM" SRC="content.gif" BORDER="none" HSPACE="20" ALT="Book Contents"></A> <A HREF="IAC-529.html"><IMG ALIGN="BOTTOM" SRC="index.gif" BORDER="none" HSPACE="20" ALT="Book Index"></A> <A HREF="IAC-431.html"><IMG ALIGN="BOTTOM" SRC="next.gif" BORDER="none" HSPACE="20" ALT="Next"></A> </CENTER><P>
<FONT SIZE="-1"><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="IAC-2.html"><B>Interapplication Communication</B></A> / <BR><DD><A HREF="IAC-423.html"><B>Chapter 11 - Program-to-Program Communications Toolbox</B></A> / <A HREF="IAC-427.html"><B>Using the PPC Toolbox</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME="HEADING430-0"></A>
<H2><A NAME="MARKER-21-103"></A>Preparing for a Session</H2>
 To communicate, you can open a port for your application and make it available to receive session requests, to initiate sessions, or both. Applications that are able to receive session requests can choose to accept or reject incoming session requests. <P>
 Before an application can accept and establish a session with another application, the PPC Toolbox authenticates the initiating user (unless guest access is enabled or the applications are located on the same computer). Once a session begins, the two applications can exchange data with each other. <P>
<A NAME="HEADING430-3"></A>
<H3><A NAME="MARKER-9-104"></A>Initiating a PPC Session<A NAME="MARKER-21-130"></A><A NAME="MARKER-21-106"></A></H3>
 Once you have established the name and the location of the port that you want to communicate with, you can initiate a session. You can use either the <CODE>StartSecureSession</CODE> function or the <CODE>PPCStart</CODE> function to initiate a session. The <CODE>StartSecureSession</CODE> function displays several dialog boxes to identify each user who requests a session. You may prefer to use the <CODE>PPCStart</CODE> function for low-level code such as that used for drivers, which typically do not provide a user interface. You may also prefer to use <CODE>PPCStart</CODE> when the application you are initiating a session with does not require authentication. The <CODE>IPCListPorts</CODE> and <CODE>PPCBrowser</CODE> functions return information about whether a particular port requires authentication.<A NAME="MARKER-21-126"></A><P>
<DL>
<DT><B>Note</B>
<DD>Do not call the <CODE>StartSecureSession</CODE> function from an application that is running in the background, because the function displays several dialog boxes on the user's screen.<EM></EM>  <IMG ALIGN="BOTTOM" SRC="graphics/diamond.gif">
</DL>
 The <CODE>StartSecureSession</CODE> function provides authentication services to identify each user who requests a session. This function combines the processes of prompting for user name and password and initiating a session into one synchronous procedure call. If authentication fails, the PPC Toolbox rejects the incoming session request.<A NAME="MARKER-2-134"></A><A NAME="MARKER-2-135"></A><P>
<PRE>
err := StartSecureSession (pb, userName, useDefault, allowGuest, 
                           guestSelected, prompt);
</PRE>
 Set the <CODE>useDefault</CODE> parameter to <CODE>TRUE</CODE> if you want the <CODE>StartSecureSession</CODE> function to use the default user identity (described later in this section). If the default user identity cannot be authenticated, the <CODE>StartSecureSession</CODE> function displays a dialog box to allow a user to log on. <A HREF="#MARKER-9-110">Figure 11-14</A> shows the user identity dialog box.<P>
<B>Figure 11-14  <A NAME="MARKER-9-110"></A><A NAME="MARKER-21-111"></A>The user identity dialog box<A NAME="MARKER-2-112"></A></B><P>
<IMG ALIGN="BOTTOM" SRC="graphics/PPC-S-14.GIF"><P>
 The <CODE>prompt</CODE> parameter of the <CODE>StartSecureSession</CODE> function allows you to specify a line of text that the dialog box can display. The <CODE>allowGuest</CODE> parameter specifies whether to enable the Guest radio button. If a port requires authentication, you should set this parameter to <CODE>FALSE</CODE>.<P>
 The <CODE>userName</CODE> parameter specifies the name of the user who is attempting to initiate a session. If the user name is not specified, the user identity dialog box appears on the user's screen with the owner name provided from the Sharing Setup control panel. <P>
 If the user enters an invalid password, the <CODE>StartSecureSession</CODE> function displays the dialog box shown in <A HREF="#MARKER-9-114">Figure 11-15</A>.<A NAME="MARKER-2-136"></A><P>
<B>Figure 11-15  <A NAME="MARKER-9-114"></A><A NAME="MARKER-21-115"></A>The incorrect password dialog box</B><P>
<IMG ALIGN="BOTTOM" SRC="graphics/PPC-S-15.GIF"><P>
 After the user clicks OK, the user identity dialog box reappears in the foreground so that the user can enter the password again.<P>
 If the user's name is invalid, the <CODE>StartSecureSession</CODE> function displays the dialog box shown in <A HREF="#MARKER-9-117">Figure 11-16</A>.<A NAME="MARKER-2-173"></A><P>
<B>Figure 11-16  <A NAME="MARKER-9-117"></A><A NAME="MARKER-21-118"></A>The invalid user name dialog box</B><P>
<IMG ALIGN="BOTTOM" SRC="graphics/PPC-S-16.GIF"><P>
 After the user clicks OK, the user identity dialog box reappears so that the user can enter a new user name.<P>
 The <CODE>StartSecureSession</CODE> function remains in this loop until a secure session is initiated or the user clicks Cancel in the user identity dialog box. If a secure session is initiated, <CODE>StartSecureSession</CODE> returns the user reference number in the corresponding field in the <CODE>PPCStart</CODE> parameter block. The user reference number represents the user name and password. A user reference number of 0 indicates that a session has been initiated with guest access. See <A HREF="IAC-426.html#MARKER-9-16">"Setting Up Authenticated Sessions" beginning on page 11-6</A> for more information.<A NAME="MARKER-2-93"></A><P>
 Before your application quits, you need to invalidate all user reference numbers obtained with the <CODE>StartSecureSession</CODE> function except for the default user reference number and the guest reference number (0). See <A HREF="IAC-433.html#MARKER-9-198">"Invalidating Users" on page 11-44</A> for detailed information.<P>
 <A HREF="#MARKER-9-121">Listing 11-6</A> illustrates how to use the <CODE>StartSecureSession</CODE> function to establish an authenticated session. This listing shows only one session, although your application may conduct multiple sessions at one time.<A NAME="MARKER-2-120"></A><P>
<B>Listing 11-6  <A NAME="MARKER-9-121"></A><A NAME="MARKER-21-122"></A>Using the <CODE>StartSecureSession</CODE> function to establish a session</B><P>
<PRE>
FUNCTION MyStartSecureSession(thePortInfoPtr: PortInfoPtr; 
                              theLocationNamePtr: LocationNamePtr; 
                              thePortRefNum: PPCPortRefNum; 
                              VAR theSessRefNum: PPCSessRefNum; 
                              VAR theUserRefNum: LongInt; 
                              VAR theRejectInfo: LongInt; 
                              VAR userName: Str32; 
                              VAR guestSelected: Boolean): OSErr;
VAR
   thePPCStartPBRec: PPCStartPBRec;
   useDefault:       Boolean;
   allowGuest:       Boolean;
   err:              OSErr;
BEGIN
   WITH thePPCStartPBRec DO
   BEGIN
      ioCompletion := NIL;
      portRefNum := thePortRefNum;     {from the PPCOpen function}
      serviceType := ppcServiceRealTime;
      resFlag := 0;
      portName := @thePortInfoPtr^.name;  {from the PPCBrowser}
      locationName := theLocationNamePtr; {from the PPCBrowser}
      userData := 0;    {application-specific data that the }
                        { PPCInform function sees}
   END;
   {try to connect with default user identity}
   useDefault := TRUE;
   {highlight the Guest button appropriately}
   allowGuest := NOT thePortInfoPtr^.authRequired;
   err := StartSecureSession(@thePPCStartPBRec, userName, 
                             useDefault, allowGuest,
                             guestSelected, stringPtr(NIL)^);
   IF err = noErr THEN
   BEGIN
      theSessRefNum := thePPCStartPBRec.sessRefNum;
      theUserRefNum := thePPCStartPBRec.userRefNum;
   END
   ELSE
      IF err = userRejectErr THEN
         {return rejectInfo from the PPCReject function}
         theRejectInfo := thePPCStartPBRec.rejectInfo;
   MyStartSecureSession := err;
END;
</PRE>
 For low-level code such as that used for drivers (which typically do not provide a user interface), you can use the <CODE>PPCStart</CODE> function instead of the <CODE>StartSecureSession</CODE> function to initiate a session. You can also use the <CODE>IPCListPorts</CODE> function (instead of displaying the program linking dialog box) to obtain a list of ports.<A NAME="MARKER-2-324"></A><P>
 If the <CODE>authRequired</CODE> field of the port information record contains <CODE>FALSE</CODE>, the port allows guest access. If the <CODE>authRequired</CODE> field of the port information record contains <CODE>TRUE</CODE>, use the <CODE>PPCStart</CODE> function and the user reference number obtained previously from the <CODE>StartSecureSession</CODE> function to reestablish an authenticated session.<P>
 You can also attempt to log on as the default user using the <CODE>GetDefaultUser</CODE> function to obtain the default user reference number and the default user name. The default user name is established after the owner starts up the computer.<A NAME="MARKER-2-94"></A><P>
<PRE>
err := GetDefaultUser (userRef, userName);
</PRE>
 The <CODE>userRef</CODE> parameter is a reference number that represents the user name and password of the default user. The <CODE>userName</CODE> parameter contains the owner name that is specified in the Sharing Setup control panel.<P>
 The <CODE>GetDefaultUser</CODE> function returns an error when the default user identity does not exist (no name is specified in the Sharing Setup control panel) or the user is not currently logged on.<P>
 <A HREF="#MARKER-9-125">Listing 11-7</A> illustrates how you use the <CODE>PPCStart</CODE> function to initiate a session. The <CODE>PPCStart</CODE> function uses the port information record and the location name record to attempt to open a session with the selected PPC port.<P>
<B>Listing 11-7  <A NAME="MARKER-9-125"></A><A NAME="MARKER-21-126"></A>Initiating a session using the <CODE>PPCStart</CODE> function</B><P>
<PRE>
FUNCTION MyPPCStart(thePortInfoPtr: PortInfoPtr; 
                     theLocationNamePtr: LocationNamePtr; 
                     thePortRefNum: PPCPortRefNum; 
                     VAR theSessRefNum: PPCSessRefNum; 
                     VAR theUserRefNum: LongInt; 
                     VAR theRejectInfo: LongInt): OSErr;
VAR
   thePPCStartPBRec: PPCStartPBRec;
   userName:         Str32;
   err:              OSErr;
BEGIN
   WITH thePPCStartPBRec DO
   BEGIN
      ioCompletion := NIL; 
      portRefNum := thePortRefNum;     {from the PPCOpen function}
      serviceType := ppcServiceRealTime;
      resFlag := 0;
      portName := @thePortInfoPtr^.name;  {destination port}
      locationName := theLocationNamePtr; {destination location}
      userData := 0;    {application-specific data for PPCInform}
   END;
   err := GetDefaultUser(thePPCStartPBRec.userRefNum, userName);
   IF err &lt;&gt; noErr THEN
      thePPCStartPBRec.userRefNum := 0;
   IF thePortInfoPtr^.authRequired AND 
      (thePPCStartPBRec.userRefNum = 0) THEN
      {port selected doesn't allow guests &amp; you don't have a }
      { default user ref number so you can't log on to this port}
      err := authFailErr
   ELSE  {attempt to log on}
      err := PPCStart(@thePPCStartPBRec, FALSE);
   IF err = noErr THEN
   BEGIN
      theSessRefNum := thePPCStartPBRec.sessRefNum;
      theUserRefNum := thePPCStartPBRec.userRefNum;
   END
   ELSE
      IF err = userRejectErr THEN
         {return rejectInfo from the PPCReject function}
         theRejectInfo := thePPCStartPBRec.rejectInfo;
   MyPPCStart := err;
END;
</PRE>
 The port to which you wish to connect must have an outstanding <CODE>PPCInform</CODE> function to successfully start a session. You cannot initiate a session with a port that is not able to receive session requests. <P>
 If the port is open, has an outstanding <CODE>PPCInform</CODE> function posted, and accepts your session request, the <CODE>PPCStart</CODE> function returns a <CODE>noErr</CODE> result code and a valid session reference number. This session reference number is used to identify the session during the exchange of data.<A NAME="MARKER-6-174"></A><A NAME="MARKER-2-128"></A><P>
<A NAME="HEADING430-37"></A>
<H3>Receiving Session Requests<A NAME="MARKER-21-129"></A></H3>
 Your application can open as many ports as it requires as long as each port name is unique within a particular computer. A single port can support a number of communication sessions. To allow a port to receive session requests, use the <CODE>PPCInform</CODE> function. (Note that you must open a port to obtain a port reference number before calling the <CODE>PPCInform</CODE> function.) A port may have any number of outstanding <CODE>PPCInform</CODE> requests.<A NAME="MARKER-2-130"></A><A NAME="MARKER-9-163"></A><P>
 <A HREF="#MARKER-9-132">Listing 11-8</A> illustrates how you use the <CODE>PPCInform</CODE> function to allow a port to receive session requests. In this listing, the parameter <CODE>thePPCParamBlockPtr</CODE> points to a PPC parameter block record allocated by the application. The <CODE>portRefNum</CODE>, <CODE>autoAccept</CODE>, <CODE>portName</CODE>, <CODE>locationName</CODE>, <CODE>userName</CODE>, and <CODE>ioCompletion</CODE> parameters of the PPC parameter block record must be supplied. If you want to automatically accept all incoming session requests, you can set the <CODE>autoAccept</CODE> field in the <CODE>PPCInform</CODE> parameter block. <P>
<B>Listing 11-8  <A NAME="MARKER-9-132"></A><A NAME="MARKER-21-133"></A>Using the <CODE>PPCInform</CODE> function to enable a port to receive sessions</B><P>
<PRE>
FUNCTION MyPPCInform(thePPCParamBlockPtr: PPCParamBlockPtr; 
                     thePPCPortPtr: PPCPortPtr;
                     theLocationNamePtr: LocationNamePtr; 
                     theUserNamePtr: stringPtr; 
                     thePortRefNum: PPCPortRefNum): OSErr;
BEGIN
   WITH thePPCParamBlockPtr^.informParam DO
   BEGIN
      ioCompletion := @MyInformCompProc;
      portRefNum := thePortRefNum;  {from the PPCOpen function}
      autoAccept := FALSE;          {the completion routine }
                                    { handles accepting or }
                                    { rejecting requests}
      portName := thePPCPortPtr;
      locationName := theLocationNamePtr;
      userName := theUserNamePtr;
   END;
   MyPPCInform := PPCInform(PPCInformPBPtr(thePPCParamBlockPtr),
                              TRUE);   {asynchronous}
END;
</PRE>
 A PPC parameter block record is used instead of a <CODE>PPCInform</CODE> parameter block record so that the same parameter block can be reused to make other PPC Toolbox calls from the <CODE>PPCInform</CODE> completion routine. The parameter block and the records it points to cannot be deallocated until all calls that use the parameter block and records have completed.<A NAME="MARKER-2-134"></A><P>
 You should make the call to <CODE>PPCInform</CODE> asynchronously. For each function that you use asynchronously, you should provide a completion routine. The completion routine gets called at interrupt time when the <CODE>PPCInform</CODE> function completes.<P>
 <A HREF="#MARKER-9-135">Listing 11-9</A> illustrates a completion routine for a <CODE>PPCInform</CODE> function. You can use the data passed into your <CODE>PPCInform</CODE> completion routine (user name, user data, port name, and location name) to determine whether to accept or reject the session request.<P>
<B>Listing 11-9  <A NAME="MARKER-9-135"></A><A NAME="MARKER-21-136"></A>Completion routine for a <CODE>PPCInform</CODE> function<A NAME="MARKER-2-230"></A><A NAME="MARKER-2-138"></A></B><P>
<PRE>
PROCEDURE MyInformCompProc(pb: PPCParamBlockPtr);
BEGIN
   IF pb^.informParam.ioResult = noErr THEN
   BEGIN
      {decide if this session should be accepted or rejected by }
      { looking at data supplied by the session requester}
      IF pb^.informParam.userData &lt;&gt; -1 THEN
         DoPPCAccept(pb)
      ELSE
         DoPPCReject(pb);
   END
   ELSE
      {use a global to tell the application that }
      { PPCParamBlockRec and the records it points to }
      { can be deallocated}
      gPBInUse := FALSE;
END;
</PRE>
 When the <CODE>PPCInform</CODE> function completes, the <CODE>MyInformCompProc</CODE> procedure determines whether to accept or reject the incoming session request. It does this by calling <CODE>PPCAccept</CODE> or <CODE>PPCReject</CODE>, as described in the next section.<A NAME="MARKER-2-210"></A><P>
<A NAME="HEADING430-48"></A>
<H3><A NAME="MARKER-9-140"></A><A NAME="MARKER-21-141"></A>Accepting or Rejecting Session Requests</H3>
 Use the <CODE>PPCAccept</CODE> function or the <CODE>PPCReject</CODE> function to accept or reject an incoming session request.<A NAME="MARKER-2-142"></A><A NAME="MARKER-2-143"></A><P>
<DL>
<DT><B>WARNING</B>
<DD>If the <CODE>PPCInform</CODE> function (with the <CODE>autoAccept</CODE> parameter set to <CODE>FALSE</CODE>) returns a <CODE>noErr</CODE> result code, you must call either the <CODE>PPCAccept</CODE> function or the <CODE>PPCReject</CODE> function. The computer trying to initiate a session (using the <CODE>StartSecureSession</CODE> function or the <CODE>PPCStart</CODE> function) waits (hangs) until the session attempt is either accepted or rejected, or until an error occurs.<EM></EM>  <IMG ALIGN="BOTTOM" SRC="graphics/triangle.gif">
</DL>
 <A HREF="#MARKER-9-145">Listing 11-10</A> illustrates how you use the <CODE>PPCAccept</CODE> function to accept a session request. This listing reuses the parameter block used in the <CODE>PPCInform</CODE> function, so the <CODE>sessRefNum</CODE> field already contains the session reference number needed by the <CODE>PPCAccept</CODE> function.<A NAME="MARKER-2-221"></A><P>
<B>Listing 11-10  <A NAME="MARKER-9-145"></A><A NAME="MARKER-21-146"></A>Accepting a session request using the <CODE>PPCAccept</CODE> function</B><P>
<PRE>
PROCEDURE DoPPCAccept(pb: PPCParamBlockPtr);
VAR
   err:  OSErr;
BEGIN {accept the session}
   pb^.acceptParam.ioCompletion := @MyAcceptCompProc;
   {the sessRefNum field is set by the PPCInform function}
   err := PPCAccept(@pb^.acceptParam, TRUE); {asynchronous}
END;
</PRE>
 For each function that you use asynchronously, you should provide a completion routine. <A HREF="#MARKER-9-150">Listing 11-11</A> illustrates a completion routine for a <CODE>PPCAccept</CODE> function. This procedure gets called at interrupt time when the <CODE>PPCAccept</CODE> function completes. If there are no errors, it sets the global variable <CODE>gSessionOpen</CODE> to <CODE>TRUE</CODE>. The global variable <CODE>gPBInUse</CODE> is set to <CODE>FALSE</CODE> to inform the application that the parameter block and the records it points to are no longer in use.<A NAME="MARKER-21-145"></A><A NAME="MARKER-2-327"></A><P>
 <A NAME="MARKER-21-149"></A>You can use the session reference number in subsequent <CODE>PPCWrite</CODE>, <CODE>PPCRead</CODE>, and <CODE>PPCEnd</CODE> functions once a session is accepted.<P>
<B>Listing 11-11  <A NAME="MARKER-9-150"></A>Completion routine for a <CODE>PPCAccept</CODE> function</B><P>
<PRE>
PROCEDURE MyAcceptCompProc(pb: PPCParamBlockPtr);
BEGIN
   IF pb^.acceptParam.ioResult = noErr THEN
      {accept completed so the session is completely open}
      gSessionOpen := TRUE;
   {use a global to tell the application that PPCParamBlockRec }
   { and the records it points to can be deallocated}
   gPBInUse := FALSE;
END;
</PRE>
 Use the <CODE>PPCReject</CODE> function to reject an incoming session request. <A HREF="#MARKER-9-155">Listing 11-12</A> illustrates how you use the <CODE>PPCReject</CODE> function to reject a session request. <P>
 This listing reuses the parameter block used in the <CODE>PPCInform</CODE> function, so the <CODE>sessRefNum</CODE> field already contains the session reference number needed by the <CODE>PPCReject</CODE> function.<A NAME="MARKER-2-151"></A><A NAME="MARKER-2-167"></A><A NAME="MARKER-21-340"></A><A NAME="MARKER-2-154"></A><P>
<B>Listing 11-12  <A NAME="MARKER-9-155"></A><A NAME="MARKER-21-156"></A>Rejecting a session request using the <CODE>PPCReject</CODE> function</B><P>
<PRE>
PROCEDURE DoPPCReject(pb: PPCParamBlockPtr);
VAR
   err:  OSErr;
BEGIN {reject the session}
   WITH pb^.rejectParam DO
   BEGIN
      ioCompletion := @MyRejectCompProc;
      {the sessRefNum field is set by the PPCInform function}
      rejectInfo := -1;
   END;
   err := PPCReject(@pb^.rejectParam, TRUE); {asynchronous}
END;
</PRE>
 <A HREF="#MARKER-9-158">Listing 11-13</A> illustrates a completion routine for a <CODE>PPCReject</CODE> function. This procedure is called at interrupt time when the <CODE>PPCReject</CODE> function completes. In this example, the global variable <CODE>gPBInUse</CODE> is set to <CODE>FALSE</CODE> to inform the application that the parameter block and the records it points to are no longer in use.<A NAME="MARKER-2-146"></A><P>
<B>Listing 11-13  <A NAME="MARKER-9-158"></A><A NAME="MARKER-21-159"></A>Completion routine for a <CODE>PPCReject</CODE> function</B><P>
<PRE>
PROCEDURE MyRejectCompProc(pb: PPCParamBlockPtr);
BEGIN
   {use a global to tell the application that PPCParamBlockRec }
   { and the records it points to can be deallocated}
   gPBInUse := FALSE;
END;
</PRE>
</BLOCKQUOTE>
<HR>
<CENTER>
<A HREF="IAC-429.html"><IMG ALIGN="BOTTOM" SRC="prev.gif" BORDER="none" HSPACE="20" ALT="Previous"></A> <A HREF="IAC-2.html"><IMG ALIGN="BOTTOM" SRC="content.gif" BORDER="none" HSPACE="20" ALT="Book Contents"></A> <A HREF="IAC-529.html"><IMG ALIGN="BOTTOM" SRC="index.gif" BORDER="none" HSPACE="20" ALT="Book Index"></A> <A HREF="IAC-431.html"><IMG ALIGN="BOTTOM" SRC="next.gif" BORDER="none" HSPACE="20" ALT="Next"></A> </CENTER><P>
<CENTER><FONT SIZE="-1"><A HREF="IAC-3.html">&copy; Apple Computer, Inc.</A><BR>7 JUL 1996</CENTER></FONT><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>  
