<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>PostScript Output Filters - /SampleFilter/SampleFilterOutput.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxPrinting-date.html">Printing</a> &gt; <A HREF="javascript:location.replace('index.html');">PostScript Output Filters</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/Printing/index.html" target="_blank">Reference Library > Printing</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">PostScript Output Filters</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/SampleFilter/SampleFilterOutput.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/Headers and Stub Libraries/Hints.h</option>
<option value="listing2.html">/Headers and Stub Libraries/PrintingPlugins.h</option>
<option value="listing3.html">/Headers and Stub Libraries/PrintingPlugins.r</option>
<option value="listing4.html">/Headers and Stub Libraries/PSLogFolder.h</option>
<option value="listing5.html">/Headers and Stub Libraries/PSOutputFilters.h</option>
<option value="listing6.html">/Headers and Stub Libraries/PSOutputFilters.r</option>
<option value="listing7.html">/Headers and Stub Libraries/PSSectionInfo.h</option>
<option value="listing8.html">/Headers and Stub Libraries/PSStreams.h</option>
<option value="listing9.html">/SampleFilter/Debug.h</option>
<option value="listing10.html">/SampleFilter/DebugMisc.h</option>
<option value="listing11.html">/SampleFilter/LibraryStuff/Hints.h</option>
<option value="listing12.html">/SampleFilter/LibraryStuff/PrintingPlugins.h</option>
<option value="listing13.html">/SampleFilter/LibraryStuff/PrintingPlugins.r</option>
<option value="listing14.html">/SampleFilter/LibraryStuff/PSOutputFilters.h</option>
<option value="listing15.html">/SampleFilter/LibraryStuff/PSOutputFilters.r</option>
<option value="listing16.html">/SampleFilter/LibraryStuff/PSSectionInfo.h</option>
<option value="listing17.html">/SampleFilter/LibraryStuff/PSStreams.h</option>
<option value="listing18.html">/SampleFilter/Macros.h</option>
<option value="listing19.html">/SampleFilter/NoDebug.h</option>
<option value="listing20.html">/SampleFilter/SampleFilter.r</option>
<option value="listing21.html">/SampleFilter/SampleFilterHints.h</option>
<option value="listing22.html">/SampleFilter/SampleFilterMain.c</option>
<option value="listing23.html">/SampleFilter/SampleFilterMain.h</option>
<option value="listing24.html">/SampleFilter/SampleFilterOutput.c</option>
<option value="listing25.html">/SampleFilter/SampleFilterPanel.c</option>
<option value="listing26.html">/SampleFilter/SampleFilterPanel.h</option>
<option value="listing27.html">/SampleFilter/SampleFilterResources.h</option>
<option value="listing28.html">/SampleFilter/Version.h</option>
<option value="listing29.html">/SectionReport/Debug.h</option>
<option value="listing30.html">/SectionReport/LibraryStuff/Hints.h</option>
<option value="listing31.html">/SectionReport/LibraryStuff/PrintingPlugins.h</option>
<option value="listing32.html">/SectionReport/LibraryStuff/PrintingPlugins.r</option>
<option value="listing33.html">/SectionReport/LibraryStuff/PSLogFolder.h</option>
<option value="listing34.html">/SectionReport/LibraryStuff/PSOutputFilters.h</option>
<option value="listing35.html">/SectionReport/LibraryStuff/PSOutputFilters.r</option>
<option value="listing36.html">/SectionReport/LibraryStuff/PSSectionInfo.h</option>
<option value="listing37.html">/SectionReport/NoDebug.h</option>
<option value="listing38.html">/SectionReport/SectionReport.c</option>
<option value="listing39.html">/SectionReport/SectionReport.r</option>
<option value="listing40.html">/SectionReport/Version.h</option></select>
				</p>
				</form>
				<p><strong><a href="PostScript_Output_Filters.zip">Download Sample</a></strong> (&#147;PostScript_Output_Filters.zip&#148;, 229.2K)<BR>
<strong><a href="PostScript_Output_Filters.dmg">Download Sample</a></strong> (&#147;PostScript_Output_Filters.dmg&#148;, 297.8K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/***  File:      SampleFilterOutput.c****  Description:  The filter output routines for the SampleFilter  ****  Version:    1.0****  Copyright 1999 Apple Computer. All rights reserved.****  You may incorporate this sample code into your applications without**  restriction, though the sample code has been provided &quot;AS IS&quot; and the**  responsibility for its operation is 100% yours.  However, what you are**  not permitted to do is to redistribute the source as &quot;ABC Sample Code&quot;**  after having made changes. If you're going to re-distribute the source,**  we require that you make it clear in the source that the code was**  descended from Apple Sample Code, but that you've made changes.***//*************************  This is a sample PostScript Output Filter for LaserWriter 8.7.    This demonstrates:    1) how to obtain data from the collection passed from the print dialog  2) how to insert data into the output stream BEFORE a given subsection  3) how to insert data into the output stream AFTER a given subsection  4) how to remove data for a given subsection  5) how to replace data for a given subsection  6) how to detect a given page*/#include &quot;PSOutputFilters.h&quot;#include &quot;PSSectionInfo.h&quot;#include &quot;DebugMisc.h&quot;#include &quot;Macros.h&quot;#include &quot;SampleFilterHints.h&quot;#include &quot;Hints.h&quot;#include &quot;PSStreams.h&quot;      // for our formatted stream writes#include &lt;stdio.h&gt;#include &lt;string.h&gt;    /*** Private Macros ***//*   These defines are here to flag usage of these routines by a filter. A filter should not use  these formatting routines because they do not handle the position data on the stream  in a manner that works for a filter's output.  */#define  psOutFormatPosition        ERROR-DONTUSE#define  psOutFormatPositionInfo      ERROR-DONTUSE#define psOutBlockPositionInfo      ERROR-DONTUSE/*  A macro to write a Pascal string to a filter with a given position.*/#define WritePStringToFilter(thefilter, string, position)  psWriteNextFilter((thefilter), &amp;((string)[1]), (string)[0], (position))/*   An error to return from our psOutputFilterPreFlight routine if we don't want our  filter to run.*/ enum{  noNeedToRunFilterErr = -1};/*** Private Variable Types ***//*  Our output execution time filter data.*/typedef struct FilterData{  SInt32      lastFilteredMsgId;      // the last messageID our filter saw        PSSubsection   lastSubsection;        // the last subsection our filter saw  Collection     jobhints;          // the collection containing the complete job collection  SInt32       currentPageNumber;      // the current page number being processed  PagesCommentMode pagesCommentMode;      // the comment mode specified by the UI  Boolean     doCustomHeaders;      // did the UI specify that we add our custom header comment  Boolean     notSkippingData;      // indicates whether or not to skip output of data  Str255       forText;          // replacement text for the %%For comment}FilterData;/*** Private Prototypes ***/static OSStatus getOurCollection(Collection hints, CollectionTag tag, SInt32 id, Collection *subCollection);static OSStatus handleFiltering(PSOutputFilterRef filter, FilterData *filterDataP, const void *data, long nBytes, const PSPosition *pos);static OSStatus checkForOurHints(Collection hints, FilterData *myDataP);/*** Global Data ***/static const Byte psCommentAfterPageSetup[] = &quot;\p% text just after Page Setup\r&quot;;static const Byte psCustomHeaderComment[] = &quot;\p%RBI_SampleComment: (Filtered by the Sample Filter)\r&quot;;/*** Code ***/OSStatus psOutputFilterPreFlight(PSOutputFilterRef filter, Collection jobInfo, Handle papaH, void **refconP)/*  This routine is called by PrintingLib to see if the filter wants to be  included in the filter chain for the current job. If we determine during this  preflight that we either don't want to run or get some kind of error  that prevents us from running, we return an error here and we won't be  called during the generation of PostScript output and our psOutputFilterPostflight  routine won't be called either.    In the normal case we allocate our filter private data for this print job and configure ourselves and  return noErr.*/{  OSStatus err = noErr;  FilterData *filterDataP;  Unused(filter);  Unused(papaH);  filterDataP = (FilterData *)NewPtrClear(sizeof(FilterData));    // this initializes all our data to 0  if(filterDataP){    filterDataP-&gt;notSkippingData = true;              // initialize so that we are not skipping data    filterDataP-&gt;jobhints = jobInfo;                // save the job collection for later reference        // check for our filter specific hints and configure ourselves accordingly    err = checkForOurHints(jobInfo, filterDataP);    if(err &amp;&amp; filterDataP){      // do NOT dispose of the hints collection we've got stored on filterDataP...we don't own it             // if we got an error then clean up properly since our postflight routine won't be called      DisposePtr((Ptr)filterDataP);      filterDataP = NULL;      }  }else    err = MemError();    *refconP = err ? NULL : filterDataP;      return err;  }OSStatus psOutputFilterPostFlight(PSOutputFilterRef filter, void *refcon)/*    PrintingLib calls this routine when our filter is being removed from   the filter output chain. At this point we need to clean up.  Here we deallocate the memory we've allocated during our execution.*/{  OSStatus err = noErr;  FilterData *filterDataP = (FilterData *)refcon;  Unused(filter);    // we should only be called here if we actually have data!  ckAssert(filterDataP != NULL);  if(filterDataP){    // do NOT dispose of the hints collection we've got stored on filterDataP...we don't own it     DisposePtr((Ptr)filterDataP);  }    return err;}OSStatus psOutputFilterWrite(PSOutputFilterRef filter, void *refcon, const void *data, long nBytes, const PSPosition *posP)/*  Filter the PostScript data being sent through us.*/{  OSStatus err = noErr;  FilterData *filterDataP = (FilterData *)refcon;    ckAssert(filterDataP != NULL);    // only examine the data if the caller is not flushing the output stream  if(nBytes != FLUSHWRITE){    /*  We need only look at new message IDs. If the message id associated with posP passed to us is the      same as the last one we saw, then we have already done our processing for that posP and      we don't need to do any new examination of the data.     */    if (filterDataP-&gt;lastFilteredMsgId != posP-&gt;id) {      // update our notion of the last id we saw      filterDataP-&gt;lastFilteredMsgId = posP-&gt;id;      err = handleFiltering(filter, filterDataP, data, nBytes, posP);    }else{      if(filterDataP-&gt;notSkippingData)        err = psWriteNextFilter(filter, data, nBytes, posP);    }    // record the PSSubsection we are seeing now    filterDataP-&gt;lastSubsection = posP-&gt;subsection;  }else{    // if the caller is flushing the output stream then we always write to the next filter and return any error    err = psWriteNextFilter(filter, data, nBytes, posP);  }    return err;}static OSStatus handleFiltering(PSOutputFilterRef filter, FilterData *filterDataP, const void *data,                   long nBytes, const PSPosition *posP){  OSStatus err = noErr;  /*      This filter only filters output during the main job, not the coverpage or query job so we      check the section before deciding whether to try and filter.  */  if(posP-&gt;section == kSectJob){    PSPosition myPosition;        /************       Before considering any data for the current subsection, we must first generate any data      we want to insert immediately AFTER the end of the last previously seen subsection.            This is handled in this manner so that we are certain that all of the data (of the      subsection we want to insert immediately after) has already been completely emitted.      */    switch(filterDataP-&gt;lastSubsection){      case kSubBeginPageSetup:        // We are just after %%BeginPageSetup and we potentially want to        // generate our data, depending on our pages mode        if(          (filterDataP-&gt;currentPageNumber == 1 &amp;&amp; filterDataP-&gt;pagesCommentMode == kPagesFirst) ||           filterDataP-&gt;pagesCommentMode == kPagesAll        ){          /*               We are going to write our new data. In order to do so we need to             have a PSPosition structure that is filled in with our data.            We call psFilterSetPSPosition to fill in myPosition as we specify.            We're filling in the section field with the current section, the subsection            field to kSubAnon since our data is anonymous and the info field to NULL.             The psFilterSetPSPosition properly sets the id portion of the PSPosition            for a filter write.          */          err = psFilterSetPSPosition(filter, &amp;myPosition, posP-&gt;section, kSubAnon, NULL);          if(!err)err = WritePStringToFilter(filter, psCommentAfterPageSetup, &amp;myPosition);        }                  break;      // case statements for any additional subsections that we want to       // insert data AFTER should be here      default:        break;        }    /*       Now that we have inserted any data after the last subsection, we can now insert any data       that we want to write BEFORE the current subsection is written. Here we also process      the subsection that is currently being written.        */    if(!err){      switch(posP-&gt;subsection){        case kSubPage:          /*            This subsection corresponds to a %%Page: comment. When it is written, there is normally            an 'info' structure that points to a DSCPage structure. If so, we'll pick up the            ordinal value of the current page number so we know what page is currently            being generated          */          ckAssert(posP-&gt;info != NULL);          if(posP-&gt;info != NULL){            filterDataP-&gt;currentPageNumber = ((DSCPage *)posP-&gt;info)-&gt;ordinal;          }          /*            If we see this subsection, we should make sure that we no longer             are skipping the write of any data.          */          filterDataP-&gt;notSkippingData = true;          break;                case kSubEndComments:          /*             We are about to write %%EndComments so we should check            whether we want to write our custom header comments and            if so, then we need to emit them before we write the            existing data.                    */          if(filterDataP-&gt;doCustomHeaders){            /*                 We call psFilterSetPSPosition to fill in myPosition as we specify.              We're filling in the section field with the current section, the subsection              field to kSubAnon since our data is anonymous and the info field to NULL.               The psFilterSetPSPosition properly sets the id portion of the PSPosition              for a filter write.            */            err = psFilterSetPSPosition(filter, &amp;myPosition, posP-&gt;section, kSubAnon, NULL);            if(!err)              err = WritePStringToFilter(filter, psCustomHeaderComment, &amp;myPosition);          }          /*            If we see this subsection, we should make sure that we no longer             are skipping the write of any data.          */           filterDataP-&gt;notSkippingData = true;          break;        // we are going to replace the %%For comment with the user supplied text         case kSubFor:           if(!err){            /*                 As an example, we are going to take advantage of the way that psOutFormat               can format data. To do this we need a stream that can write to a filter               and then make a StreamInfoData structure from it.            */            PSStream outFilterStream;                        /*  Open the stream. psOpenFilterOutputStream makes sure that writes to               this stream will generate calls  to psWriteNextFilter with the filter               reference passed here.            */            err = psOpenFilterOutputStream(&amp;outFilterStream, filter);            if(!err){              OSStatus tempErr;              StreamInfoData comm;              /*   Now make the StreamInfoData since we need to do that formatted writes using psOutFormat                              One important note is that it is crucial that the job hints that we pass to this routine                properly reflect the output channel characteristics so that psOutFormat correctly formats                the output for the channel. Once the channel query has been performed, the hints collection                properly indicates the channel characteristics and we can go ahead and make our call.                            */              err = psSetupStreamInfoData(&amp;comm, &amp;outFilterStream, filterDataP-&gt;jobhints);              if(!err){                /*   we must set the position on the stream represented by comm so that we get a position                  properly set up for filter writes. Note that we *MUST* do this, RATHER than use                  the formatting routines psOutFormatPosition, psOutFormatPositionInfo,                  or psOutBlockPositionInfo.                                    We set the section field to the section of the position passed to us and set the                  subsection to kSubFor and the info field is a Str255 of the text we are writing.                */                PSStream *theStreamP = psGetStreamFromStreamInfoData(comm);                err = psFilterSetPSPosition(filter, &amp;theStreamP-&gt;u.ps.pos,                           posP-&gt;section, kSubFor, filterDataP-&gt;forText);                if(!err){                  /*                      Our format string uses the ^S format since we want to ensure that the string                    data is always formatted for the printable ASCII character set regardless of the                    output channel characteristics.                                        For more information on psOutFormat and the use of streams and doing                    formatted writes see:                    Technote 1171: LaserWriter 8.6: How to Write a Converter Plug-in for                     the Download Manager,                     http://devworld.apple.com/technotes/tn/tn1171.html#AppendixA                  */                  err = psOutFormat(comm, &quot;\p%%For: (^S)\r&quot;, filterDataP-&gt;forText);                }                              tempErr = psDisposeStreamInfoData(&amp;comm);                if(!err)err = tempErr;              }              tempErr = psCloseFilterOutputStream(&amp;outFilterStream);              if(!err)err = tempErr;            }          }          /*   Make sure we skip any additional data until we see the next subsection.                      */           filterDataP-&gt;notSkippingData = false;           break;        /*            We are going to completely omit the %%Routing comment so we set notSkippingData          accordingly. This will skip all output until we see a new messageID        */         case kSubRouting:           filterDataP-&gt;notSkippingData = false;           break;                /*          For all other subsections we are going to no longer skip writing any data        */        default:           filterDataP-&gt;notSkippingData = true;          break;                }    }  }    // write the data passed to us if we are not skipping data  if(!err &amp;&amp; filterDataP-&gt;notSkippingData)    err = psWriteNextFilter(filter, data, nBytes, posP);    return err;}static OSStatus checkForOurHints(Collection hints, FilterData *myDataP){/*  This routine looks for our filter's private collection in the 'hints'  collection and configures itself based on the collection items it  finds in our private collection.*/  OSStatus err = noErr;  Collection plugInHints;    // initialize to our defaults data  myDataP-&gt;doCustomHeaders = kHintCustomHeaderDef;  myDataP-&gt;forText[0] = 0;  myDataP-&gt;pagesCommentMode = kHintPagesCommentDef;    // first get our private collection based on our signature  err = getOurCollection(hints, kHintPlugInCollTag, kSampleFilterSignature, &amp;plugInHints);  if(!err){    ckAssert(plugInHints != NULL);    // our private collection should not be NULL    /*      Look for our configuration data. If any piece of it does not exist then we treat      it as if the default value is specified and there is no error.    */    if(!err) {      long actualSize = sizeof(Str255);      err = GetCollectionItem(plugInHints, kHintTextTag, kHintTextId, &amp;actualSize, myDataP-&gt;forText);      if(err == collectionItemNotFoundErr){        myDataP-&gt;forText[0] = 0;        err = noErr;      }    }    if(!err) {      long actualSize = sizeof(kHintCustomHeaderVar);      err = GetCollectionItem(plugInHints, kHintCustomHeaderTag, kHintCustomHeaderId,                             &amp;actualSize, &amp;myDataP-&gt;doCustomHeaders);      if(err == collectionItemNotFoundErr){        myDataP-&gt;doCustomHeaders = kHintCustomHeaderDef;        err = noErr;      }    }    if(!err) {      long actualSize = sizeof(kHintPagesCommentVar);      err = GetCollectionItem(plugInHints, kHintPagesCommentTag, kHintPagesCommentId,                             &amp;actualSize, &amp;myDataP-&gt;pagesCommentMode);      if(err == collectionItemNotFoundErr){        myDataP-&gt;pagesCommentMode = kHintPagesCommentDef;        err = noErr;      }    }    DisposeCollection(plugInHints);  }else{    if(err == collectionItemNotFoundErr){      // if we don't find our private collection we'll go ahead and run with our defaults      err = noErr;    }  }    // we'll map any error here into our &quot;do not run filter error&quot;. This isn't strictly  // necessary...any error returned from psOutputFilterPreFlight is sufficient  if(err)        err = noNeedToRunFilterErr;    return err;}static OSStatus getOurCollection(Collection hints, CollectionTag tag, SInt32 id, Collection *subCollection)/*    getOurCollection assumes that the entry in the collection 'hints' with tag 'tag'   and id 'id' contains a flattened collection. This routine gets that flattened   collection, unflattens it, and returns the new  collection in *'subCollection'. If an error occurs then *'subCollection' is  set to NULL and a non-zero error value is returned.*/{  Collection newCollection = NULL;  Handle flatCollectionH = NULL;  OSStatus err = noErr;    flatCollectionH = NewHandle(0);  if (flatCollectionH != NULL) {    err = GetCollectionItemHdl(hints, tag, id, flatCollectionH);    if (!err){      newCollection = NewCollection();      if (newCollection != NULL) {        err = UnflattenCollectionFromHdl(newCollection, flatCollectionH);      } else {        err = MemError();      }    }    DisposeHandle(flatCollectionH);  } else {    err = MemError();  }    /*  If we had an error then get rid of the collection we    were trying to make.  */  if (err) {    if (newCollection != NULL) {      DisposeCollection(newCollection);      newCollection = NULL;        }  }    /*  Pass back the new collection. It will be NULL if    there was an error.  */  *subCollection = newCollection;      return err;}</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/PostScript_Output_Filters/listing24.html%3Fid%3DDTS10000297-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/PostScript_Output_Filters/listing24.html%3Fid%3DDTS10000297-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/PostScript_Output_Filters/listing24.html%3Fid%3DDTS10000297-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>