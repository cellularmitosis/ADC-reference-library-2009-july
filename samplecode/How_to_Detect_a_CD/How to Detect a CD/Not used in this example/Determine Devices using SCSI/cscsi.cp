#include		"CSCSI.h"CSCSIOp::CSCSIOp( void ){	haveInfo = 0;	timeout = 60L;}CSCSIOp::~CSCSIOp( void ){}void	CSCSIOp::keep( short what ){	haveInfo = what;}void	CSCSIOp::setID( short ID ){	targetID = ID;	haveInfo |= USE_ID;}void	CSCSIOp::setCDB( short len, Byte * cdbPtr ){	short	i;	cdbLen = len;	for ( i = 0; i < len; i++ )			cdb[i] = *cdbPtr++;	haveInfo |= USE_CDB;}void	CSCSIOp::set6( Byte a, Byte b, Byte c, Byte d, Byte e, Byte f ){	cdbLen = 6;	cdb[0] = a; cdb[1] = b; cdb[2] = c; cdb[3] = d; cdb[4] = e; cdb[5] = f;	haveInfo |= USE_CDB;}void	CSCSIOp::set10( Byte a, Byte b, Byte c, Byte d, Byte e, Byte f,								Byte g, Byte h, Byte i, Byte j ){	cdbLen = 10;	cdb[0] = a; cdb[1] = b; cdb[2] = c; cdb[3] = d; cdb[4] = e; cdb[5] = f;	cdb[6] = g; cdb[7] = h; cdb[8] = i; cdb[9] = j;	haveInfo |= USE_CDB;}void	CSCSIOp::set12( Byte a, Byte b, Byte c, Byte d, Byte e, Byte f,								Byte g, Byte h, Byte i, Byte j, Byte k, Byte l ){	cdbLen = 12;	cdb[0] = a; cdb[1] = b; cdb[2] = c; cdb[3] = d; cdb[4] = e; cdb[5] = f;	cdb[6] = g; cdb[7] = h; cdb[8] = i; cdb[9] = j; cdb[10] = k; cdb[11] = l;	haveInfo |= USE_CDB;}void	CSCSIOp::setLen( long len ){	dataLen = len;	haveInfo |= USE_LEN;}void	CSCSIOp::setBuf( void * buf ){	dataPtr = (Byte *)buf;	haveInfo |= USE_BUF;}void	CSCSIOp::setDir( XferDir direction ){	dir = direction;	haveInfo |= USE_DIR;}short	CSCSIOp::execute( void ){	SCSIInstr	xfer[3];	short		info = haveInfo;		haveInfo = 0;		if ( info & USE_DIR )	{		if ( dir == noData )		{			if ( (info & CAN_NO_DATA) != CAN_NO_DATA )			{					return err = SCSI_NEED_INFO;			}		}		else if ( (info & CAN_DATA) != CAN_DATA )		{			return err = SCSI_NEED_INFO;		}	}	else			return err = SCSI_NEED_INFO;				if ( dir != noData )	{		//		// SCSIManager seems to update scParam1 on scInc only if the scInc did		// not fail.  Thus, if we need to know the exact data count, we need		// to use a loop, doing on scInc for each byte.		//		// If the dataLen is not a multiple of 0x200, we assume the user needs		// to know the exact amount, and so we loop.  If the dataLen is a multiple		// of 0x200, we assume it is a read or write to a blocked device, and the		// user wants efficiency more than an exact byte count.		//		if ( dataLen & 0x1ff )		{			xfer[0].scOpcode = scInc;			xfer[0].scParam1 = (unsigned long)dataPtr;			xfer[0].scParam2 = 1;			xfer[1].scOpcode = scLoop;			xfer[1].scParam1 = -10;			xfer[1].scParam2 = dataLen;			xfer[2].scOpcode = scStop;		}		else		{			xfer[0].scOpcode = scInc;			xfer[0].scParam1 = (unsigned long)dataPtr;			xfer[0].scParam2 = dataLen;			xfer[1].scOpcode = scStop;		}	}		moved = 0;		err = SCSIGet();	if ( err )		return err;				err = SCSISelect( targetID );	if ( err )		return err;				err = SCSICmd( (Ptr)cdb, cdbLen );	if ( err )	{		SCSIComplete( &status, &message, 60L );		return err;	}		if ( dir == dataIn )		err = SCSIRead( (Ptr)xfer );	else if ( dir == dataOut )		err = SCSIWrite( (Ptr)xfer );				moved = xfer[0].scParam1 - (unsigned long)dataPtr;		if ( err && err != scPhaseErr )	{		SCSIComplete( &status, &message, 60L );		return err;	}		err = SCSIComplete( &status, &message, timeout );		return err;}short	CSCSIOp::getStatus( void ){	return status;}short	CSCSIOp::getMessage( void ){	return message;}void	CSCSIOp::setTimeout( long newTime ){	timeout = newTime;}OSErr	CSCSIOp::getErr( void ){	return err;}long	CSCSIOp::getMoved( void ){	return moved;}