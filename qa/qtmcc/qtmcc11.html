<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"			"http://www.w3.org/TR/REC-html40/loose.dtd"><html><HEAD><LINK REL="stylesheet" HREF="../../adcstyle.css" TYPE="text/css"><LINK REL="stylesheet" HREF="../../style.css" TYPE="text/css"><title>Technical Q&amp;A QTMCC11: Decompressing IMA WAVE files</title><meta name="keywords" content="Mac OS 8 QuickTime Decompressing IMA WAVE files"><meta name="Description" content="Technical Q&amp;A QTMCC11: Q&amp;A details, with sample code, howyou would use the QuickTime IMA sound decompressor componentsthat come with QuickTime 3.0 with the Sound Manager's APIso that you can decompress and play Window's Microsoft ADPCM-compressedWAVE files."><meta name="categories" content="QuickTime Components"><meta name="week-posted" content="Oct 19, 1998 - Oct 23, 1998"><LINK REL="stylesheet" HREF="../../css/adcstyle.css" TYPE="text/css"><script language="JavaScript" type="text/javascript" src="../../js/adc.js"></script></HEAD><BODY BGCOLOR="#FFFFFF" TEXT="#000000"><a name="//apple_ref/doc/uid/DTS10001954" title="Decompressing IMA WAVE files"></a> <!-- white background --><!-- top_of_header_marker_comment --><!-- begin_header_information --><!--#include virtual="/adcnavbar" --><p><a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../technicalqas/index.html">Technical Q&As</a> &gt; <a href="../../technicalqas/QuickTime/index.html">QuickTime</a> &gt; <a href="../../technicalqas/QuickTime/idxImportExport-date.html">Import & Export</a> &gt; </p><!-- end_header_information --><!-- bottom_of_header_marker_comment --><!-- top_of_titles_marker_comment --><CENTER><table width="600" cellpadding="0" cellspacing="0" border="0">
<tr><td align="left" scope="row">
<h1>
<div id="pagehead">Technical Q&amp;A QTMCC11</div>
<div id="pageheadsub">Decompressing IMA WAVE files</div>
</h1>
</td></tr></table></CENTER><!-- bottom_of_titles_marker_comment --><CENTER>			<!-- -->						<!-- Document Body --><table cellspacing="0" cellpadding="0" border="0" WIDTH="600"><tr><td align="left" scope="row"><hr width=500 align=center><p id=p2>Q: I want to decompress and play Window's Microsoft ADPCM-compressed WAVE files on the Mac, but I want to use the Sound Manager, not QuickTime. Is this possible?</p><p id=p4>A: Yes, this is possible, for the most part. However,you must still use QuickTime, at least partially, unless you want towrite your own sound decompressor component to handle the ADPCMsounds. You won't need to use the QuickTime API to play the sound:you will use the Sound Manager's API, but you will still need to ensure that QuickTime 3.0 or later is installed.</p><p id=p4>This Q&amp;A details how you would use the QuickTime IMA sounddecompressor components that come with QuickTime 3.0 (along with theSound Manager's APIs) so that you can decompress and play the soundyourself.</p><p id=p4>QuickTime supplies two sound decompressor components: one forMicrosoft ADPCM compressed WAVE files, and one for Intel IMA-DVIcompressed WAVE files, whose signatures are<CODE>kMicrosoftADPCMFormat</CODE> and<CODE>kDVIIntelIMAFormat</CODE>, respectively.</p><p id=p4>However, playing a IMA-compressed WAVE file via the Sound Manageris not as simple as merely specifying one of these sounddecompressors. Due to the file format variances allowed in IMA-compressed WAVE files, the decompressor component has to beconfigured so that it can correctly decompress the sound.</p><p id=p4>You configure the decompressor component by reading the <CODE>'fmt'</CODE> chunk out of the WAVE file and passing it, as a QuickTimeatom, to the appropriate decompressor component. You do not need todo any endian conversion on the <CODE>'fmt '</CODE> chunk before youplace it in the atom, because the IMA decompressor components expectthe data to be in little endian format, exactly as it comes out ofthe WAVE file.</p><p id=p4>Once the atom has been constructed, send it to the decompressorcomponent via <CODE>SoundConverterSetInfo</CODE> with the<CODE>siDecompressionParams</CODE> selector.</p><p id=p4>Once this has been done, you can use the Sound Manager's<CODE>SoundConvert</CODE> routines to decompress the sound into abuffer so that you can play the uncompressed sound (because youcannot directly play the compressed sound), or do anything else tothe uncompressed sound that you want to.</p><TABLE BORDER=1>   <TR>      <td bgcolor="#FFFFCC" width=500 align=left>         <P>Note: Make sure that you make your buffers of compressed         data large enough; 8K is a good starting point, but you may         need to make it larger to handle every possible WAVE. If the         buffer is not large enough, the call to         <CODE>SoundConverterGetBufferSizes</CODE> will fail with an         the error code <CODE>notEnoughBufferSpace</CODE> (-207). If         you get this error you should increase the size of the         buffer and call <CODE>SoundConverterGetBufferSizes</CODE>         again, repeating the process until it does not return an         error (or returns an error other than         <CODE>notEnoughBufferSpace</CODE>).</P>      </TD>   </TR></TABLE><BR><TABLE>	<TR>	<td width=500 align=left>	<P>Here is sample code showing how to create the atom and pass it tothe decompressor component. You will need to supply your own code toparse the WAVE file's header and extract the <CODE>'fmt '</CODE>chunk.</P>	</TD>	</TR></TABLE><BR><TABLE BORDER=0 CELLPADDING=1> <TR>		<td bgcolor="#CCCC99" align=left>                    <pre>typedef struct adpcmcoef_tag {    short   iCoef1;    short   iCoef2;} ADPCMCOEFSET;typedef struct waveformat_extended_tag {    short       wFormatTag;         /* format type */    short       nChannels;          /* number of channels (i.e. mono, stereo...) */    long        nSamplesPerSec;     /* sample rate */    long        nAvgBytesPerSec;    /* for buffer estimation */    short       nBlockAlign;        /* block size of data */    short       wBitsPerSample;     /* Number of bits per sample of mono data */    short       cbSize;             /* The count in bytes of the extra size */} WAVEFORMATEX;typedef struct adpcmwaveformat_tag {    WAVEFORMATEX    wfx;    short           wSamplesPerBlock;    short           wNumCoef;    ADPCMCOEFSET    aCoef[32];} ADPCMWAVEFORMAT;typedef struct {    long            atomSize;           // how big this structure is (big endian)    long            atomType;           // atom type - always kMicrosoftADPCMFormat                                        // (big endian)                                        // everything below here is little endian -                                        // right out of the wave header    ADPCMWAVEFORMAT adpcm;} AtomMSADPCMWaveFormatEx;typedef struct {    AudioFormatAtom             formatData;    AtomMSADPCMWaveFormatEx     endianData;    AudioTerminatorAtom         terminatorData;} AudioCompressionAtom, *AudioCompressionAtomPtr, **AudioCompressionAtomHandle;OSErr ASoundGetWAVEHeader (...) {    ...    case FormatID:        format = EndianU16_LtoN (WAVETemplate-&gt;fmt.wFormatTag);        switch (format) {            case 2:     // MS ADPCM            case 17:    // IMA ADPCM                BlockMoveData (&amp;(WAVETemplate-&gt;fmt.wFormatTag), formatChunk,                EndianU32_LtoN (WAVETemplate-&gt;fmt.ckSize));        ...        }    ...}OSErr DecompressWave (...) {    AudioCompressionAtom    decomAtom;    if (err == noErr) {        // Parse the WAVE file and get the 'fmt ' atom.        err = ASoundGetWAVEHeader (&amp;theSoundInfo, &amp;length,        (fmtChunk*)&amp;(decomAtom.endianData.adpcm));    }    if (err == noErr) {        // Figure out which type of ADPCM file we have.        switch (EndianU16_LtoN (decomAtom.endianData.adpcm.wfx.wFormatTag)) {            case 0x0002:                waveFormat = kMicrosoftADPCMFormat;                break;            case 0x0011:                waveFormat = kDVIIntelIMAFormat;                break;            default:                err = badFormat;        }    }    if (err == noErr) {        inputFormat.flags = 0;        inputFormat.format = waveFormat;        inputFormat.numChannels = EndianU16_LtoN          (decomAtom.endianData.adpcm.wfx.nChannels);        inputFormat.sampleSize = EndianU16_LtoN          (decomAtom.endianData.adpcm.wfx.wBitsPerSample);        inputFormat.sampleRate = (EndianU32_LtoN          (decomAtom.endianData.adpcm.wfx.nSamplesPerSec)) &lt;&lt; 16;        inputFormat.sampleCount = 0;        inputFormat.buffer = nil;        inputFormat.reserved = 0;        outputFormat.flags = 0;        outputFormat.format = kSoundNotCompressed;        outputFormat.numChannels = EndianU16_LtoN          (decomAtom.endianData.adpcm.wfx.nChannels);        outputFormat.sampleSize = 16;        outputFormat.sampleRate = (EndianU32_LtoN          (decomAtom.endianData.adpcm.wfx.nSamplesPerSec)) &lt;&lt; 16;        outputFormat.sampleCount = 0;        outputFormat.buffer = nil;        outputFormat.reserved = 0;        err = SoundConverterOpen (&amp;inputFormat, &amp;outputFormat, &amp;sc);    }    if (err == noErr) {        // Make atom to send to ADPCM decompressor so it knows how to        // decompress the data.        decomAtom.formatData.size = sizeof (AudioFormatAtom);        decomAtom.formatData.atomType = kAudioFormatAtomType;        decomAtom.formatData.format = waveFormat;        decomAtom.endianData.atomSize = sizeof (AtomMSADPCMWaveFormatEx);        decomAtom.endianData.atomType = waveFormat;        decomAtom.terminatorData.size = sizeof (AudioTerminatorAtom);        decomAtom.terminatorData.atomType = kAudioTerminatorAtomType;        err = SoundConverterSetInfo (sc, siDecompressionParams, &amp;decomAtom);    }    if (err == noErr) {        targetBytes = 4096;        do {            targetBytes *= 2;            err = SoundConverterGetBufferSizes              (sc, targetBytes, &amp;inputFrames, &amp;inputBytes, &amp;outputBytes);        } while (err == notEnoughBufferSpace &amp;&amp; targetBytes &lt; (MaxBlock () / 4));    }}</pre> </TD> </TR> </TABLE><BR><P>From this point on, use standard sound conversion code to uncompress the sound.</P><!-- begin_date --><H4 ALIGN=center>[Oct 19 1998]</H4><!-- end_date --></td></tr></table></CENTER><!-- begin_footer_information -->	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/qa/qtmcc/qtmcc11.html%3Fid%3DDTS10001954-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/qa/qtmcc/qtmcc11.html%3Fid%3DDTS10001954-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/qa/qtmcc/qtmcc11.html%3Fid%3DDTS10001954-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>
<!--#include virtual="/includes/footer"--><!-- end_footer_information --></BODY></HTML>