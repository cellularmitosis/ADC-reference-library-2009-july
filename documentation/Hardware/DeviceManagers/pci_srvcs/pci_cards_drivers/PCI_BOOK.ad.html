<HTML><HEAD><META NAME="GENERATOR" CONTENT="Adobe FrameMaker 5.5/HTML Export Filter"><script language="JavaScript" src="frametest.js"></script><TITLE> Native Driver Differences</TITLE></HEAD><BODY BGCOLOR="#ffffff"><DIV><a name="top"></a><!-- start of banner --><!--#include virtual="/includes/framesetheader" --><!-- end of banner --><!-- start of path --><font face="Geneva,Helvetica,Arial" size="1"><b><br>PATH<spacer type="horizontal" size="5">&nbsp;</b><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Documentation</a> &gt; <!-- a href="" target="_top" -->Hardware<!-- /a -->  <b>&gt; </b><a href="../../devicemgrs.html" target="_top">Device Managers and Drivers</a> <b>&gt; </b><a href="../pci_srvcs.html" target="_top">PCI Card Services</a> <b>&gt; </b>Designing PCI Cards and Drivers for Power Macintosh Computers</font><br><br><!-- end of path --><A HREF="PCI_BOOK.a6.html"><img src="images/up.gif" border="0" width="36" height="16"></A><nobr>&nbsp;</nobr><A HREF="PCI_BOOK.ac.html"><img src="images/previous.gif" border="0" width="66" height="16"></A><nobr>&nbsp;</nobr><A HREF="PCI_BOOK.ae.html"><img src="images/next.gif" border="0" width="49" height="16"></A><!-- insert Show/Hide frames --><a href="javascript:testFrame()"><script><!--document.write(frameLink);//--></script><!-- end Show/Hide frames --></A><HR></DIV><H1 CLASS="H2.Heading2"><A NAME="pgfId=3373"> </A>Native Driver Differences</H1><P CLASS="T1.Text1"><A NAME="pgfId=3376"> </A>For detailed information about constructing native device drivers, see <A HREF="PCI_BOOK.b6.html#13253" CLASS="XRef">Writing a Generic Device Driver</A> later in this chapter. If you are already familiar with writing 68K <A NAME="marker=3378"> </A>device drivers, the following are highlights of the principal differences:</P><UL><LI CLASS="B1.Bullet1"><A NAME="pgfId=3379"> </A>A native driver receives its parameters through the single <TT CLASS="cv">DoDriverIO</TT> entry point, subject to the calling conventions specified by the PowerPC run-time architecture. If a <TT CLASS="cv">DoDriverIo</TT> routine is written in C, the correct behavior is guaranteed. This is a fundamental change from the way 68K drivers received parameters.</LI><LI CLASS="B1.Bullet1"><A NAME="pgfId=3381"> </A>A native driver doesn't have access to its driver control entry <A NAME="marker=3380"> </A>(DCE) in the unit table.</LI><LI CLASS="B1.Bullet1"><A NAME="pgfId=3382"> </A><TT CLASS="cv">ImmediateIOCommandKind</TT> is passed in the <TT CLASS="cv">ioKind</TT> parameter to specify that a request must be executed immediately. If so, the driver must process the request completely and the result of the process must be reflected in the return value from the driver. <TT CLASS="cv">kInitializeCommand</TT>, <TT CLASS="cv">kFinalizeCommand</TT>, <TT CLASS="cv">kOpenCommand</TT>, <TT CLASS="cv">kCloseCommand</TT>, <TT CLASS="cv">kKillIOCommand</TT>, <TT CLASS="cv">kReplaceCommand</TT>, and <TT CLASS="cv">kSupersededCommand</TT> calls are always immediate.</LI><LI CLASS="B1.Bullet1"><A NAME="pgfId=3383"> </A>If the <TT CLASS="cv">ioKind</TT> parameter is either <TT CLASS="cv">SynchronousIOCommandKind</TT> or <TT CLASS="cv">AsynchronousIOCommandKind</TT>, the return value from the driver is ignored. The driver must call <TT CLASS="cv">IOCommandIsComplete</TT> at some future time. </LI><LI CLASS="B1.Bullet1"><A NAME="pgfId=3384"> </A>The <TT CLASS="cv">Initialize</TT> and <TT CLASS="cv">Finalize</TT> commands are sent to the driver as its first and last commands. <TT CLASS="cv">Initialize</TT> gives the driver information it needs to start up. <TT CLASS="cv">Finalize</TT> informs the driver that the system needs to unload it.</LI><LI CLASS="B1.Bullet1"><A NAME="pgfId=3385"> </A>Drivers now receive all <TT CLASS="cv">OpenDriver</TT> and <TT CLASS="cv">CloseDriver</TT> calls, which connect the driver independently of initialization and finalization. In the past, the first (and only) <TT CLASS="cv">OpenDriver</TT> and <TT CLASS="cv">CloseDriver</TT> calls were used as the initialization and finalization mechanism. </LI><LI CLASS="B1.Bullet1"><A NAME="pgfId=3386"> </A>All native drivers must accept and respond to all command codes. The <TT CLASS="cv">Read_Enable</TT>, <TT CLASS="cv">Write_Enable</TT>, <TT CLASS="cv">Control_Enable</TT>, and <TT CLASS="cv">Status_Enable</TT> bits in the DCE are ignored. Native drivers must keep track of I/O permissions for each instance of multiple open actions and return error codes if the permissions are violated.</LI><LI CLASS="B1.Bullet1"><A NAME="pgfId=3387"> </A>The Device Manager processes zero-length reads and writes on behalf of the 68K driver. Native drivers must accept zero-length read and write commands and respond to them in an intelligent way without crashing.</LI><LI CLASS="B1.Bullet1"><A NAME="pgfId=3389"> </A><TT CLASS="cv">KillIO</TT><A NAME="marker=3388"> </A> is no longer a control call; it is now its own command. For backward compatibility, the Device Manager converts <TT CLASS="cv">KillIO</TT> traps into <TT CLASS="cv">KillIO</TT> commands. It passes the old <TT CLASS="cv">csKillcode</TT> control call (<TT CLASS="cv">csCode</TT> = 1) without acting on it.</LI><LI CLASS="B1.Bullet1"><A NAME="pgfId=3391"> </A>The <A NAME="marker=3390"> </A>Code Fragment Manager sends CFM initialization and termination calls to a driver when the driver is loaded and unloaded. The CFM initialization routine, if present, will run prior to the driver being initialized by the Device Manager. It is possible that the driver will be loaded and its CFM initialization routine run even though it is never opened and, therefore, never closed. It is important that any processing done by a CFM initialization routine be undone by the CFM termination routine. The Device Manager may load a number of drivers looking for the best candidate for a particular device. Only the best driver is opened and remains loaded. All other CFM connections are closed, causing the CFM termination routine to run.</LI><LI CLASS="B1.Bullet1"><A NAME="pgfId=3393"> </A>Native drivers never jump to the <A NAME="marker=3392"> </A><TT CLASS="cv">IODone</TT> routine. To finish processing an I/O request, a generic native driver must call <TT CLASS="cv">IOCommandIsComplete</TT> to notify the Device Manager that a given request has been completed.</LI><LI CLASS="B1.Bullet1"><A NAME="pgfId=3395"> </A>To determine the kind of request or kind of command, the <A NAME="marker=3394"> </A><TT CLASS="cv">ioTrap</TT> field of the old Device Manager parameter block has been replaced with routine parameters called <TT CLASS="cv">theCode</TT> and <TT CLASS="cv">theKind</TT>. Native drivers do not need to read or modify this field. </LI><LI CLASS="B1.Bullet1"><A NAME="pgfId=3396"> </A>A native driver must be reentrant to the extent that during any call from the driver to <TT CLASS="cv">IOCommandIsComplete</TT> the driver may be reentered with another request. 68K device drivers would typically JMP to to <TT CLASS="cv">IODone</TT> and therefore technically never be re-entered. </LI><LI CLASS="B1.Bullet1"><A NAME="pgfId=3398"> </A>A native device driver does not have any sort of <A NAME="marker=3397"> </A>header. It must however, export a data symbol called <TT CLASS="cv">TheDriverDescription</TT>. A driver uses this data structure to give header-like information to the Device Manager. The Device Manager uses the information in <TT CLASS="cv">TheDriverDescription</TT> to set the <TT CLASS="cv">dCtlFlags</TT> field in the driver's DCE. </LI><LI CLASS="B1.Bullet1"><A NAME="pgfId=3399"> </A>Native drivers should never look at or modify directly the <TT CLASS="cv">iodesrbl</TT> field of the Device Manager parameter block. (what's that field?)</LI><LI CLASS="B1.Bullet1"><A NAME="pgfId=3400"> </A>A native device driver cannot make use of the <TT CLASS="cv">dCtlEMask</TT> and <TT CLASS="cv">dCtlMenu</TT> fields of its DCE.</LI><LI CLASS="B1.Bullet1"><A NAME="pgfId=3401"> </A>If you set the <TT CLASS="cv">ioBuffer</TT> field in an I/O parameter block to <TT CLASS="cv">NULL</TT>, the Device Manager will not pass the buffer to a native driver (but it will not return an error either).</LI><LI CLASS="B1.Bullet1"><A NAME="pgfId=3403"> </A>Native drivers cannot be used for creating <A NAME="marker=3402"> </A>desk accessories.</LI></UL><DIV><blockquote><p CLASS="ImportantHead"><b><A NAME="pgfId=16589"> </A>IMPORTANT</b></p><P CLASS="I.Important"><A NAME="pgfId=3404"> </A>Native drivers may use only those services provided by the Driver Services Library or family libraries. The Driver Services Library is described in Chapter <A HREF="PCI_BOOK.140.html#12320" CLASS="XRef">11</A>. </P></blockquote></DIV><HR>&#169 1999 Apple Computer, Inc. &#150 (Last Updated 26 March 99)<P><A HREF="PCI_BOOK.a6.html"><img src="images/up.gif" border="0" width="36" height="16"></A><nobr>&nbsp;</nobr><A HREF="PCI_BOOK.ac.html"><img src="images/previous.gif" border="0" width="66" height="16"></A><nobr>&nbsp;</nobr><A HREF="PCI_BOOK.ae.html"><img src="images/next.gif" border="0" width="49" height="16"></A><!-- insert Show/Hide frames --><a href="javascript:testFrame()"><script><!--document.write(frameLink);//--></script><!-- end Show/Hide frames --></A><!-- start of footer --><!--#include virtual="/includes/framesetfooter" --><!-- end of footer --></body></HTML>