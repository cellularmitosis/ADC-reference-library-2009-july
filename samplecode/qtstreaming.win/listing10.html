<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>qtstreaming.win - /ComponentVideoRTP/RTPMPComponentVideo/Sources/RTPMPComponentVideo.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/QuickTime/index.html">QuickTime</a> &gt; <a href="../../samplecode/QuickTime/idxStreaming-date.html">Streaming</a> &gt; <A HREF="javascript:location.replace('index.html');">qtstreaming.win</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">qtstreaming.win</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/ComponentVideoRTP/RTPMPComponentVideo/Sources/RTPMPComponentVideo.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/ComponentVideoRTP/RTPMPComponentVideo/Headers/ComponentVideoPayload.h</option>
<option value="listing2.html">/ComponentVideoRTP/RTPMPComponentVideo/Headers/ComponentVideoRTP.h</option>
<option value="listing3.html">/ComponentVideoRTP/RTPMPComponentVideo/Headers/ComponentVideoRTPResources.h</option>
<option value="listing4.html">/ComponentVideoRTP/RTPMPComponentVideo/Headers/RTPDefines.h</option>
<option value="listing5.html">/ComponentVideoRTP/RTPMPComponentVideo/Headers/RTPMPComponentVideo.h</option>
<option value="listing6.html">/ComponentVideoRTP/RTPMPComponentVideo/Headers/RTPMPComponentVideoDispatch.h</option>
<option value="listing7.html">/ComponentVideoRTP/RTPMPComponentVideo/Headers/RTPMPComponentVideoResources.h</option>
<option value="listing8.html">/ComponentVideoRTP/RTPMPComponentVideo/Sources/ComponentThing.r</option>
<option value="listing9.html">/ComponentVideoRTP/RTPMPComponentVideo/Sources/ComponentVideoPayload.c</option>
<option value="listing10.html">/ComponentVideoRTP/RTPMPComponentVideo/Sources/RTPMPComponentVideo.c</option>
<option value="listing11.html">/ComponentVideoRTP/RTPMPComponentVideo/Sources/RTPMPComponentVideo.r</option>
<option value="listing12.html">/ComponentVideoRTP/RTPRssmComponentVideo/Headers/ComponentVideoPayload.h</option>
<option value="listing13.html">/ComponentVideoRTP/RTPRssmComponentVideo/Headers/ComponentVideoRTP.h</option>
<option value="listing14.html">/ComponentVideoRTP/RTPRssmComponentVideo/Headers/ComponentVideoRTPResources.h</option>
<option value="listing15.html">/ComponentVideoRTP/RTPRssmComponentVideo/Headers/RTPDefines.h</option>
<option value="listing16.html">/ComponentVideoRTP/RTPRssmComponentVideo/Headers/RTPRssmComponentVideo.h</option>
<option value="listing17.html">/ComponentVideoRTP/RTPRssmComponentVideo/Headers/RTPRssmComponentVideoDispatch.h</option>
<option value="listing18.html">/ComponentVideoRTP/RTPRssmComponentVideo/Headers/RTPRssmComponentVidResources.h</option>
<option value="listing19.html">/ComponentVideoRTP/RTPRssmComponentVideo/Sources/ComponentThing.r</option>
<option value="listing20.html">/ComponentVideoRTP/RTPRssmComponentVideo/Sources/ComponentVideoPayload.c</option>
<option value="listing21.html">/ComponentVideoRTP/RTPRssmComponentVideo/Sources/RTPRssmComponentVideo.c</option>
<option value="listing22.html">/ComponentVideoRTP/RTPRssmComponentVideo/Sources/RTPRssmComponentVideo.r</option>
<option value="listing23.html">/IMAAudioRTP/RTPMPIMAAudio/Headers/IMAAudioPayload.h</option>
<option value="listing24.html">/IMAAudioRTP/RTPMPIMAAudio/Headers/IMAAudioQueue.h</option>
<option value="listing25.html">/IMAAudioRTP/RTPMPIMAAudio/Headers/IMAAudioRTP.h</option>
<option value="listing26.html">/IMAAudioRTP/RTPMPIMAAudio/Headers/IMAAudioRTPResources.h</option>
<option value="listing27.html">/IMAAudioRTP/RTPMPIMAAudio/Headers/RTPDefines.h</option>
<option value="listing28.html">/IMAAudioRTP/RTPMPIMAAudio/Headers/RTPMPIMAAudio.h</option>
<option value="listing29.html">/IMAAudioRTP/RTPMPIMAAudio/Headers/RTPMPIMAAudioDispatch.h</option>
<option value="listing30.html">/IMAAudioRTP/RTPMPIMAAudio/Headers/RTPMPIMAAudioResources.h</option>
<option value="listing31.html">/IMAAudioRTP/RTPMPIMAAudio/Headers/TCycle.h</option>
<option value="listing32.html">/IMAAudioRTP/RTPMPIMAAudio/Headers/TQueue.h</option>
<option value="listing33.html">/IMAAudioRTP/RTPMPIMAAudio/Sources/ComponentThing.r</option>
<option value="listing34.html">/IMAAudioRTP/RTPMPIMAAudio/Sources/IMAAudioPayload.c</option>
<option value="listing35.html">/IMAAudioRTP/RTPMPIMAAudio/Sources/IMAAudioQueue.c</option>
<option value="listing36.html">/IMAAudioRTP/RTPMPIMAAudio/Sources/RTPMPIMAAudio.c</option>
<option value="listing37.html">/IMAAudioRTP/RTPMPIMAAudio/Sources/RTPMPIMAAudio.r</option>
<option value="listing38.html">/IMAAudioRTP/RTPMPIMAAudio/Sources/TCycle.c</option>
<option value="listing39.html">/IMAAudioRTP/RTPMPIMAAudio/Sources/TQueue.c</option>
<option value="listing40.html">/IMAAudioRTP/RTPRssmIMAAudio/Headers/IMAAudioPayload.h</option>
<option value="listing41.html">/IMAAudioRTP/RTPRssmIMAAudio/Headers/IMAAudioRTP.h</option>
<option value="listing42.html">/IMAAudioRTP/RTPRssmIMAAudio/Headers/IMAAudioRTPResources.h</option>
<option value="listing43.html">/IMAAudioRTP/RTPRssmIMAAudio/Headers/RTPDefines.h</option>
<option value="listing44.html">/IMAAudioRTP/RTPRssmIMAAudio/Headers/RTPRssmIMAAudio.h</option>
<option value="listing45.html">/IMAAudioRTP/RTPRssmIMAAudio/Headers/RTPRssmIMAAudioDispatch.h</option>
<option value="listing46.html">/IMAAudioRTP/RTPRssmIMAAudio/Headers/RTPRssmIMAAudioResources.h</option>
<option value="listing47.html">/IMAAudioRTP/RTPRssmIMAAudio/Sources/ComponentThing.r</option>
<option value="listing48.html">/IMAAudioRTP/RTPRssmIMAAudio/Sources/IMAAudioPayload.c</option>
<option value="listing49.html">/IMAAudioRTP/RTPRssmIMAAudio/Sources/RTPRssmIMAAudio.c</option>
<option value="listing50.html">/IMAAudioRTP/RTPRssmIMAAudio/Sources/RTPRssmIMAAudio.r</option>
<option value="listing51.html">/Readme.txt</option></select>
				</p>
				</form>
				<p><strong><a href="qtstreaming.win.zip">Download Sample</a></strong> (&#147;qtstreaming.win.zip&#148;, 323.7K)<BR>
<strong><a href="qtstreaming.win.dmg">Download Sample</a></strong> (&#147;qtstreaming.win.dmg&#148;, 629.7K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*
  File:    RTPMPComponentVideo.c

  Contains:  Definition of Component Video RTPMediaPacketizer

  Copyright:  &copy; 1997-1999 by Apple Computer, Inc., all rights reserved.
  
  
  
  OVERVIEW
  
  QuickTime Streaming software uses an RTPMediaPacketizer to encapsulate
  sample data in network packets.  When preparing to packetize sample data,
  Streaming software first determines a packetizer's capabilities and
  operational parameters.  If the packetizer is suitable, the Streaming
  software provides the packetizer with an RTPPacketBuilder.  The packetizer
  uses the RTPPacketBuilder to construct network packets from sample data.
  The Streaming software specifies what sample data to packetize by calling
  the packetizer's RTPMPSetSampleData() implementation.
  
  This packetizer implements the following interface and delegates all other
  calls to a base RTPMediaPacketizer defined by QuickTime Streaming.
    
    
    STANDARD COMPONENT INTERFACE
    ----------------------------
    
    CallComponentOpen()        Allocate and initialize storage for
                    instance variables.
    
    CallComponentClose()      Reverse the effects of
                    CallComponentOpen().
    
    CallComponentVersion()      Return the instance's version.
    
    CallComponentTarget()      Update the instance's inheritance graph.
    
    
    
    RTP MEDIA PACKETIZER INTERFACE
    ------------------------------
    
    RTPMPInitialize()        Prepare to packetize sample data.
    
    RTPMPPreflightMedia()      Determine whether the packetizer can
                    packetize the described data.
    
    RTPMPSetSampleData()      Use the instance's RTPPacketBuilder to
                    packetize sample data.
    
    RTPMPFlush()          Finish any packetization in progress.
    
    RTPMPReset()          Abort any packetization in progress.
    
    RTPMPGetInfo()          Return the requested information.
    
    RTPMPSetTimeScale()
    
    RTPMPGetTimeScale()
    
    RTPMPSetTimeBase()
    
    RTPMPGetTimeBase()
    
    RTPMPHasCharacteristic()
    
    RTPMPSetPacketBuilder()
    
    RTPMPGetPacketBuilder()
    
    RTPMPSetMediaType()
    
    RTPMPGetMediaType()
    
    RTPMPSetMaxPacketSize()
    
    RTPMPGetMaxPacketSize()
    
    RTPMPSetMaxPacketDuration()
    
    RTPMPGetMaxPacketDuration()    
*/



/* ---------------------------------------------------------------------------
 *    H E A D E R S
 * ---------------------------------------------------------------------------
 */

#include &quot;RTPMPComponentVideo.h&quot;
#include &quot;RTPMPComponentVideoResources.h&quot;



/* ---------------------------------------------------------------------------
 *    R T P    M E D I A    P A C K E T I Z E R    P R O T O T Y P E S
 * ---------------------------------------------------------------------------
 *
 *  QTStreamingComponents.k.h uses these macros to declare prototypes for
 *  the RTPMediaPacketizer calls defined in this file.
 *
 */

#define RTPMP_BASENAME()        RTPMPComponentVideo_
#define RTPMP_GLOBALS()          RTPMPComponentVideoInstanceData **

#include &lt;QTStreamingComponents.k.h&gt;



/* ---------------------------------------------------------------------------
 *    C O M P O N E N T    D I S P A T C H    H E L P E R
 * ---------------------------------------------------------------------------
 *
 *  ComponentDispatchHelper.c uses these macros to define a dispatcher and to
 *  declare prototypes for the core component calls defined in this file.  For
 *  Mac OS, it defines the routine descriptor that serves as the component
 *  entry point.  The name of the routine descriptor is the macro expansion of
 *    
 *    CALLCOMPONENT_BASENAME()##ComponentDispatchRD
 *  
 *  The name of the dispatcher is the macro expansion of
 *  
 *    CALLCOMPONENT_BASENAME()##ComponentDispatch
 *
 */

#define CALLCOMPONENT_BASENAME()    RTPMP_BASENAME()
#define CALLCOMPONENT_GLOBALS()      RTPMP_GLOBALS() storage
#define COMPONENT_DISPATCH_FILE      &quot;RTPMPComponentVideoDispatch.h&quot;
#define COMPONENT_C_DISPATCHER      1
#define COMPONENT_UPP_SELECT_ROOT()    RTPMP
#define GET_DELEGATE_COMPONENT()    ( ( **storage ).itsBase )

#include &lt;ComponentDispatchHelper.c&gt;



#pragma mark *        INTERNAL IMPLEMENTATION
#pragma mark -
/* ---------------------------------------------------------------------------
 *    I N T E R N A L    I M P L E M E N T A T I O N
 * ---------------------------------------------------------------------------
 */

enum
{
  __kNoLimit            = 0xFFFFFFFF,
  __kNoFlags            = 0,
  __kDefaultPacketDurationLimit  = __kNoLimit,
  __kPayloadDataSizeMask      = 0xFFFFFFFC,
  __kTypicalMTUSize        = 1500,      /* Ethernet */
  __kTypicalNetworkHeaderSize    = 20,      /* IP, no options */
  __kTypicalTransportHeaderSize  = 8,      /* UDP */
  __kTypicalRTPHeaderSize      = 12,      /* no CSRCs, no extension */
  __kDefaultPacketSizeLimit    =
    __kTypicalMTUSize - __kTypicalNetworkHeaderSize - __kTypicalTransportHeaderSize -
    __kTypicalRTPHeaderSize
};



/* ---------------------------------------------------------------------------
 *    __UpdateDataSizes()
 * ---------------------------------------------------------------------------
 *
 *  Update data sizes the instance uses to construct network packets.
 *
 */

static
void
__UpdateDataSizes(
  RTPMPComponentVideoInstanceData **  inGlobals )
{
  UInt16  theWidth;
  UInt16  theHeight;
  
  
  theWidth = ComponentVideoPayloadWidth( &amp;( **inGlobals ).itsPayloadHeader );
  theHeight = ComponentVideoPayloadHeight( &amp;( **inGlobals ).itsPayloadHeader );
  
  
  /*  YUV 4:2:2 encoding uses four octets to represent a pair of pixels.
     The number of octets in a frame is therefore
     
       padded-width x height x 2 octets
     
     where padded-width is the row width in pixels padded to an
     even number. */
  
  ( **inGlobals ).itsFrameDataSize =
    ( ( ( theWidth + 1 ) &amp; ( ~1L ) ) * theHeight ) &lt;&lt; 1;
  
  
  /*  This packetizer sends an integral number of sample packets in
    each network packet.  Since YUV 4:2:2 encodes samples in four-octet
    sample packets, the amount of data sent in a network packet will be
    a multiple of four octets.  Most network packets will carry a fixed
    header and enough sample data to fill the network packet as closely
    as possible to the network packet size limit. */
  
  ( **inGlobals ).itsPayloadDataSize =
    ( ( **inGlobals ).itsPacketSizeLimit -
      sizeof( ( **inGlobals ).itsPayloadHeader.itsFixedHeader ) ) &amp;
    __kPayloadDataSizeMask;
  
  
  /*  Whatever data would be left over after dividing a frame into
    maximal-length network packets must fit into the first packet along
    with a fixed header and a payload description.   If the leftover
    data won't fit, adjust the size of the other network packets. */
  
  while(
    ( ( ( **inGlobals ).itsFrameDataSize % ( **inGlobals ).itsPayloadDataSize ) +
      sizeof( ( **inGlobals ).itsPayloadHeader ) &gt;
    ( **inGlobals ).itsPacketSizeLimit ) )
  {
    ( **inGlobals ).itsPayloadDataSize -= 4;
  }
}



/* ---------------------------------------------------------------------------
 *    __UpdateSampleDescription()
 * ---------------------------------------------------------------------------
 *
 *  Determine whether the SampleDescription of incoming sample data has
 *  changed and update instance variables accordingly.
 *
 */

static
ComponentResult
__UpdateSampleDescription(
  RTPMPComponentVideoInstanceData **  inGlobals,
  const RTPMPSampleDataParams *    inSampleData )
{
  ComponentResult      theError = noErr;
  SInt32          theFlags;
  ImageDescriptionHandle  theDescription;
  
  
  /*  Check the SampleDescription if it is the first description or if the cached
    sample description seed doesn't match the current seed. */
  
  if(
    !ComponentVideoPayloadHasDescription( &amp;( **inGlobals ).itsPayloadHeader )  ||
    ( **inGlobals ).itsSampleDescriptionSeed != inSampleData-&gt;sampleDescSeed )
  {
    theDescription =
      REINTERPRET_CAST( ImageDescriptionHandle )( inSampleData-&gt;sampleDescription );
    
    
    /* Only update if the differences in the new SampleDescription are pertinent. */
    
    if(
      ComponentVideoPayloadWidth( &amp;( **inGlobals ).itsPayloadHeader ) !=
        ( **theDescription ).width  ||
      ComponentVideoPayloadHeight( &amp;( **inGlobals ).itsPayloadHeader ) !=
        ( **theDescription ).height )
    {
      /*  If the RTPMPSetSampleData() implementation queues data, then any
        queued sample data, which uses the obsolete SampleDescription, must
        be flushed before updating to the new SampleDescription. */
      
      theError = RTPMPFlush( ( **inGlobals ).itsFinalDerivation, 0, &amp;theFlags );
      
      if( !theError )
      {
        /*  Update the payload description that the packetizer includes in
          some network packets. */
        
        ComponentVideoPayloadSetDescription(
          &amp;( **inGlobals ).itsPayloadHeader, ( **theDescription ).width,
          ( **theDescription ).height );
        
        
        /*  Update data sizes the packetizer uses to construct network
          packets. */
        
        __UpdateDataSizes( inGlobals );
      }
    }
    
    
    /*  Update the cached sample description seed to indicate that the
      packetizer state is now consistent with the new SampleDescription. */
    
    if( !theError )
      ( **inGlobals ).itsSampleDescriptionSeed = inSampleData-&gt;sampleDescSeed;
  }
  
  return( theError );
}



/* ---------------------------------------------------------------------------
 *    __PacketizeSampleData()
 * ---------------------------------------------------------------------------
 *
 *  Construct network packets from the specified sample data.
 *
 */

static
ComponentResult
__PacketizeSampleData(
  RTPMPComponentVideoInstanceData **  inGlobals,
  const RTPMPSampleDataParams *    inSampleData )
{
  ComponentResult      theError;
  RTPPacketGroupRef    thePacketGroup;
  UInt32          theDataOffset;
  RTPPacketRef      thePacket;
  UInt32          theDataSize;
  ComponentVideoPayload  theHeader;
  UInt32          theHeaderSize;
  
  
  /* This packetizer sends all the data for one frame in a single packet group. */
  
  theError =
    RTPPBBeginPacketGroup(
      ( **inGlobals ).itsPacketBuilder, __kNoFlags, inSampleData-&gt;timeStamp,
      &amp;thePacketGroup );
  
  if( !theError )
  {
    /*  Most network packets for the frame will be uniformly sized, with a
      fixed header and a fixed amount of sample data.  The first network
      packet will include whatever data is left over (taken from the
      start of the sample data, not the end), as well as a fixed header
      and a payload description. */
    
    theDataOffset = 0;
    theDataSize = ( **inGlobals ).itsFrameDataSize % ( **inGlobals ).itsPayloadDataSize;
    
    theHeader = ( **inGlobals ).itsPayloadHeader;
    theHeaderSize = sizeof( theHeader );
    
    
    /*  Construct network packets until the sample data for this frame is exhausted. */
    
    while( theDataOffset &lt; ( **inGlobals ).itsFrameDataSize  &amp;&amp;  !theError )
    {
      theError =
        RTPPBBeginPacket(
          ( **inGlobals ).itsPacketBuilder, __kNoFlags, thePacketGroup,
          ( **inGlobals ).itsPacketSizeLimit, &amp;thePacket );
      
      if( !theError )
      {
        /*  The header (with optional payload description) is added to the
          network packet as literal data.  The data is written directly
          to the network packet.  If the RTPPacketBuilder is storing
          network packet data to disk, it must store a copy of literal data. */
        
        theError =
          RTPPBAddPacketLiteralData(
            ( **inGlobals ).itsPacketBuilder, __kNoFlags, thePacketGroup,
            thePacket, REINTERPRET_CAST( UInt8 * )( &amp;theHeader ),
            theHeaderSize, NULL );
        
        if( !theError )
        {
          /*  The RTPPacketBuilder provides a routine specifically for adding
            sample data.  For stored movies, the RTPPacketBuilder need not
            store a copy of sample data, since the data is already stored
            in the movie. */
          
          theError =
            RTPPBAddPacketSampleData(
              ( **inGlobals ).itsPacketBuilder, __kNoFlags, thePacketGroup,
              thePacket, CONST_CAST( RTPMPSampleDataParams * )( inSampleData ),
              theDataOffset, theDataSize, NULL );
          
          if( !theError )
          {
            /*  The packetizer sets the RTP/AVP marker bit in the last network
              packet of a frame.  The QuickTime Streaming base RTPReassembler
              can better assist in reassembling the payload data if this bit
              is used to mark the end of a packet group.
              
              Most payloads have no duration, except for the last payload,
              which absorbs the duration for the entire frame. */
            
            if( theDataOffset + theDataSize &lt; ( **inGlobals ).itsFrameDataSize )
            {
              theError =
                RTPPBEndPacket(
                  ( **inGlobals ).itsPacketBuilder, __kNoFlags,
                  thePacketGroup, thePacket, 0 /* inTimeOffset */,
                  0 /* inDuration */ );
            }
            
            else
            {
              theError =
                RTPPBEndPacket(
                  ( **inGlobals ).itsPacketBuilder, kRTPPBSetMarkerFlag,
                  thePacketGroup, thePacket, 0 /* inTimeOffset */,
                  inSampleData-&gt;duration );
            }
          }
        }
      }
      
      
      /*  For this packetizer, packets after the first network packet of a frame
        are uniformly sized and have no payload description. */
      
      if( theDataOffset )
      {
        theDataOffset += theDataSize;
      }
      
      else
      {
        theDataOffset += theDataSize;
        theDataSize = ( **inGlobals ).itsPayloadDataSize;
        theHeaderSize = sizeof( theHeader.itsFixedHeader );
        
        ComponentVideoPayloadSetDescription( &amp;theHeader, 0, 0 );
      }
      
      
      /*  Update the Offset field of the header to indicate the next block
        of sample data. */
      
      ComponentVideoPayloadSetOffset( &amp;theHeader, theDataOffset );
    }
    
    
    if( theError )
    {
      RTPPBEndPacketGroup(
        ( **inGlobals ).itsPacketBuilder, kRTPPBDontSendFlag, thePacketGroup );
    }
    
    else
    {
      /*  For this packetizer, every group contains only sync samples.  That
        means the sample data for the group can be decoded independently of
        any previous sample data.  When randomly accessing stored movies,
        a streaming server can look for sync samples. */
      
      theError =
        RTPPBEndPacketGroup(
          ( **inGlobals ).itsPacketBuilder, kRTPPBSyncSampleFlag, thePacketGroup );
    }
  }
  
  return( theError );
}



#pragma mark -
#pragma mark *        STANDARD COMPONENT INTERFACE
#pragma mark -
/* ---------------------------------------------------------------------------
 *    S T A N D A R D    C O M P O N E N T    I N T E R F A C E
 * ---------------------------------------------------------------------------
 */

/* ---------------------------------------------------------------------------
 *    + CallComponentOpen() implementation
 * ---------------------------------------------------------------------------
 *
 *  Allocate and initialize storage for instance variables.  When a packetizer
 *  is opened, it is not always called to packetize data, so this function
 *  doesn't perform any allocations or time-consuming operations that are
 *  needed only for packetizing sample data.  The RTPMPInitialize()
 *  implementation performs such operations.
 *
 */

EXTERN_API( ComponentResult )
RTPMPComponentVideo_Open(
  RTPMPComponentVideoInstanceData **  inGlobals,
  ComponentInstance          self )
{
  ComponentResult    theResult = noErr;
  RTPMediaPacketizer  theBase;
  
  
  inGlobals =
    REINTERPRET_CAST( RTPMPComponentVideoInstanceData ** )(
      NewHandleClear( sizeof( **inGlobals ) ) );
  
  if( inGlobals )
  {
    ( **inGlobals ).itself = self;
    ( **inGlobals ).itsFinalDerivation = self;
    ( **inGlobals ).itsInitialized = false;
    
    SetComponentInstanceStorage( self, REINTERPRET_CAST( Handle )( inGlobals ) );
    
    theResult =
      OpenADefaultComponent(
        kRTPMediaPacketizerType, kRTPBaseMediaPacketizerType, &amp;theBase );
    
    if( theResult == noErr )
    {
      ( **inGlobals ).itsBase = theBase;
      theResult = CallComponentTarget( ( **inGlobals ).itsBase, self );
    }
  }
  
  else
  {
    theResult = MemError();
    
    if( theResult == noErr )
      theResult = memFullErr;
  }
  
  return( theResult );
}



/* ---------------------------------------------------------------------------
 *    + CallComponentClose() implementation
 * ---------------------------------------------------------------------------
 *
 *  Reverse the effects of the CallComponentOpen() implementation.
 *
 */

EXTERN_API( ComponentResult )
RTPMPComponentVideo_Close(
  RTPMPComponentVideoInstanceData **  inGlobals,
  ComponentInstance          self )
{
#pragma unused( self )
  
  if( inGlobals )
  {
    if( ( **inGlobals ).itsBase )
      CloseComponent( ( **inGlobals ).itsBase );
    
    DisposeHandle( REINTERPRET_CAST( Handle )( inGlobals ) );
  }
  
  return( noErr );
}



/* ---------------------------------------------------------------------------
 *    + CallComponentVersion() implementation
 * ---------------------------------------------------------------------------
 *
 *  Return the instance's version.
 *
 */

EXTERN_API( ComponentResult )
RTPMPComponentVideo_Version(
  RTPMPComponentVideoInstanceData **  inGlobals )
{
#pragma unused( inGlobals )
  
  return( kComponentVersion );
}



/* ---------------------------------------------------------------------------
 *    + CallComponentTarget() implementation
 * ---------------------------------------------------------------------------
 *
 *  Update the instance's inheritance graph with a new most-derived instance.
 *
 */

EXTERN_API( ComponentResult )
RTPMPComponentVideo_Target(
  RTPMPComponentVideoInstanceData **  inGlobals,
  ComponentInstance          target )
{
  ComponentResult    theResult;
  
  
  if( ( **inGlobals ).itsBase )
    theResult = ComponentSetTarget( ( **inGlobals ).itsBase, target );
  else
    theResult = noErr;
  
  if( theResult == noErr )
    ( **inGlobals ).itsFinalDerivation = target;
  
  return( theResult );
}



#pragma mark -
#pragma mark *        RTP MEDIA PACKETIZER INTERFACE
#pragma mark -
/* ---------------------------------------------------------------------------
 *    R T P    M E D I A    P A C K E T I Z E R    I N T E R F A C E
 * ---------------------------------------------------------------------------
 */

/* ---------------------------------------------------------------------------
 *    + RTPMPInitialize() implementation
 * ---------------------------------------------------------------------------
 *
 *  Prepare to packetize sample data.  This implementation initializes
 *  instance variables that represent the packetization state.
 *
 */

EXTERN_API( ComponentResult )
RTPMPComponentVideo_Initialize(
  RTPMPComponentVideoInstanceData **  inGlobals,
  SInt32                inFlags )
{
  ComponentResult    theResult;
  
  
  if( CallComponentCanDo( ( **inGlobals ).itsBase, kRTPMPInitializeSelect ) )
    theResult = RTPMPInitialize( ( **inGlobals ).itsBase, inFlags );
  else
    theResult = noErr;
  
  if( theResult == noErr )
  {
    ( **inGlobals ).itsPacketBuilder = NULL;
    ( **inGlobals ).itsPacketSizeLimit = __kDefaultPacketSizeLimit;
    ( **inGlobals ).itsPacketDurationLimit = __kDefaultPacketDurationLimit;
    
    ComponentVideoPayloadInitialize( &amp;( **inGlobals ).itsPayloadHeader, 0, 0 );
    
    ( **inGlobals ).itsInitialized = true;
  }
  
  return( theResult );
}



/* ---------------------------------------------------------------------------
 *    + RTPMPPreflightMedia() implementation
 * ---------------------------------------------------------------------------
 *
 *  Determine whether the packetizer can packetize data described by the
 *  given SampleDescription.  This implementation verifies that the sample
 *  data is in Component Video format, and that the image has positive width
 *  and height.
 *
 */

EXTERN_API( ComponentResult )
RTPMPComponentVideo_PreflightMedia(
  RTPMPComponentVideoInstanceData **  inGlobals,
  OSType                inMediaType,
  SampleDescriptionHandle        inSampleDescription )
{
#pragma unused( inGlobals )
  
  ComponentResult      theResult;
  ImageDescriptionHandle  theDescription;
  
  
  theDescription = REINTERPRET_CAST( ImageDescriptionHandle )( inSampleDescription );
  
  if(
    inMediaType != VideoMediaType  ||
    ( **theDescription ).cType != kComponentVideoDataFormat )
  {
    theResult = qtsUnsupportedDataTypeErr;
  }
  
  else if( ( **theDescription ).width &lt;= 0  ||  ( **theDescription ).height &lt;= 0 )
  {
    theResult = qtsUnsupportedFeatureErr;
  }
  
  else
  {
    theResult = noErr;
  }
  
  return( theResult );
}



/* ---------------------------------------------------------------------------
 *    + RTPMPSetSampleData() implementation
 * ---------------------------------------------------------------------------
 *
 *  Use the instance's RTPPacketBuilder to packetize the sample data described
 *  by the RTPMPSampleDataParams parameter.  The sample time of the data in
 *  successive calls is non-decreasing.  In the case of Component Video, this
 *  function is called with parameters describing one frame of data at a time.
 *  
 *  The RTPMPSampleDataParams structure includes a SampleDescription.  This
 *  implementation calls __UpdateSampleDescription() to detect when the
 *  SampleDescription changes and to make any updates necessary to accomodate
 *  the new SampleDescription.
 *
 *  The function then calls __PacketizeSampleData() to divide the data into
 *  network packets using the instance's RTPPacketBuilder.
 *
 */

EXTERN_API( ComponentResult )
RTPMPComponentVideo_SetSampleData(
  RTPMPComponentVideoInstanceData **  inGlobals,
  const RTPMPSampleDataParams *    inSampleData,
  SInt32 *              outFlags )
{
  ComponentResult        theError = noErr;
  
  
  /* Ignore requests that have no data */
  
  if( inSampleData-&gt;dataLength )
  {
    theError = __UpdateSampleDescription( inGlobals, inSampleData );
    
    if( !theError )
      theError = __PacketizeSampleData( inGlobals, inSampleData );
  }
  
  *outFlags = 0;
  
  return( theError );
}



/* ---------------------------------------------------------------------------
 *    + RTPMPFlush() implementation
 * ---------------------------------------------------------------------------
 *
 *  Finish any packetization in progress.  This packetizer doesn't defer any
 *  packetization, so its RTPMPFlush() implementation just gives its base a
 *  chance to flush.
 *
 */

EXTERN_API( ComponentResult )
RTPMPComponentVideo_Flush(
  RTPMPComponentVideoInstanceData **  inGlobals,
  SInt32        inFlags,
  SInt32 *      outFlags )
{
  ComponentResult    theResult;
  
  
  if( CallComponentCanDo( ( **inGlobals ).itsBase, kRTPMPFlushSelect ) )
  {
    theResult = RTPMPFlush( ( **inGlobals ).itsBase, inFlags, outFlags );
  }
  
  else
  {
    theResult = noErr;
    *outFlags = 0;
  }
  
  return( theResult );
}



/* ---------------------------------------------------------------------------
 *    + RTPMPReset() implementation
 * ---------------------------------------------------------------------------
 *
 *  Abort any packetization in progress and prepare to packetize a new data
 *  stream.  This implementation reinitializes its packetization state and
 *  resets its base.
 *
 */

EXTERN_API( ComponentResult )
RTPMPComponentVideo_Reset(
  RTPMPComponentVideoInstanceData **  inGlobals,
  SInt32                inFlags )
{
  ComponentResult    theResult;
  
  
  ComponentVideoPayloadInitialize( &amp;( **inGlobals ).itsPayloadHeader, 0, 0 );
  
  if( CallComponentCanDo( ( **inGlobals ).itsBase, kRTPMPResetSelect ) )
    theResult = RTPMPReset( ( **inGlobals ).itsBase, inFlags );
  else
    theResult = noErr;
  
  return( theResult );
}



/* ---------------------------------------------------------------------------
 *    + RTPMPGetInfo() implementation
 * ---------------------------------------------------------------------------
 *
 *  Return the information indicated by the selector.  This implemenation
 *  computes a result for the following selectors and delegates all others to
 *  its base.
 *
 *
 *    kRTPMPPayloadTypeInfo  ioParams points to an RTPMPPayloadTypeParams
 *                structure.  This implementation fills in this
 *                structure to indicate it uses a dynamic AVP
 *                payload type.  It copies its payload encoding
 *                name to a buffer described by this structure.
 *
 *    kRTPMPRTPTimeScaleInfo  ioParams points to a TimeScale where the
 *                implementation returns the clock rate, in
 *                Hertz, to be used for RTP timestamps.
 *
 *    kRTPMPMinPayloadSize  ioParams points to a UInt32 where the
 *                implementation returns the number of octets
 *                needed for the fixed header and payload
 *                description used by this packetizer.
 *
 *    kRTPMPPayloadNameInfo  ioParams points to a Str255 where the
 *                implementation returns a human-readable name
 *                for the payload encoding used by this
 *                packetizer.
 *
 */

EXTERN_API( ComponentResult )
RTPMPComponentVideo_GetInfo(
  RTPMPComponentVideoInstanceData **  inGlobals,
  OSType                inSelector,
  void *                ioParams )
{
  ComponentResult        theError = noErr;
  RTPMPPayloadTypeParams *  thePayloadInfo;
  Str255            theEncodingName;
  
  
  switch( inSelector )
  {
    case kRTPMPPayloadTypeInfo:
      thePayloadInfo = STATIC_CAST( RTPMPPayloadTypeParams * )( ioParams );
      thePayloadInfo-&gt;flags = kRTPPayloadTypeDynamicFlag;
      thePayloadInfo-&gt;payloadNumber = kRTPPayload_Unknown;
      
      theError =
        GetComponentIndString(
          REINTERPRET_CAST( Component )( ( **inGlobals ).itself ),
          theEncodingName, kRTPMPComponentVideoStringListResource,
          kRTPMPComponentVideoProtocolEncodingString );
      
      if( !theError )
      {
        if( thePayloadInfo-&gt;nameLength &lt; ( theEncodingName[ 0 ] + 1 ) )
        {
          theError = paramErr;
        }
        
        else
        {
          BlockMoveData(
            &amp;theEncodingName[ 1 ], thePayloadInfo-&gt;payloadName,
            theEncodingName[ 0 ] );
          
          thePayloadInfo-&gt;payloadName[ theEncodingName[ 0 ] ] = '\0';
        }
        
        thePayloadInfo-&gt;nameLength = theEncodingName[ 0 ] + 1;
      }
    break;
    
    
    case kRTPMPRTPTimeScaleInfo:
      *STATIC_CAST( TimeScale * )( ioParams ) = kComponentVideoRTPTimeScale;
    break;
    
    
    case kRTPMPMinPayloadSize:
      *STATIC_CAST( UInt32 * )( ioParams ) = sizeof( ComponentVideoPayload );
    break;
    
    
    case kRTPMPPayloadNameInfo:
      theError =
        GetComponentIndString(
          REINTERPRET_CAST( Component )( ( **inGlobals ).itself ),
          STATIC_CAST( StringPtr )( ioParams ),
          kRTPMPComponentVideoStringListResource,
          kRTPMPComponentVideoHIEncodingString );
    break;
    
    
    case kRTPMPRequiredSampleDescriptionInfo:
    case kRTPMPMinPacketDuration:
    case kRTPMPSuggestedRepeatPktCountInfo:
    case kRTPMPSuggestedRepeatPktSpacingInfo:
    case kRTPMPMaxPartialSampleSizeInfo:
    case kRTPMPPreferredBufferDelayInfo:
    default:
      theError =
        RTPMPGetInfo( ( **inGlobals ).itsBase, inSelector, ioParams );
    break;
  }
  
  return( theError );
}



/* ---------------------------------------------------------------------------
 *    + RTPMPSetTimeScale() implementation
 * ---------------------------------------------------------------------------
 */

EXTERN_API( ComponentResult )
RTPMPComponentVideo_SetTimeScale(
  RTPMPComponentVideoInstanceData **  inGlobals,
  TimeScale              inTimeScale )
{
  ( **inGlobals ).itsMediaTimeScale = inTimeScale;
  
  return( noErr );
}



/* ---------------------------------------------------------------------------
 *    + RTPMPGetTimeScale() implementation
 * ---------------------------------------------------------------------------
 */

EXTERN_API( ComponentResult )
RTPMPComponentVideo_GetTimeScale(
  RTPMPComponentVideoInstanceData **  inGlobals,
  TimeScale *              outTimeScale )
{
  *outTimeScale = ( **inGlobals ).itsMediaTimeScale;
  
  return( noErr );
}



/* ---------------------------------------------------------------------------
 *    + RTPMPSetTimeBase() implementation
 * ---------------------------------------------------------------------------
 */

EXTERN_API( ComponentResult )
RTPMPComponentVideo_SetTimeBase(
  RTPMPComponentVideoInstanceData **  inGlobals,
  TimeBase              inTimeBase )
{
  ( **inGlobals ).itsMediaTimeBase = inTimeBase;
  
  return( noErr );
}



/* ---------------------------------------------------------------------------
 *    + RTPMPGetTimeBase() implementation
 * ---------------------------------------------------------------------------
 */

EXTERN_API( ComponentResult )
RTPMPComponentVideo_GetTimeBase(
  RTPMPComponentVideoInstanceData **  inGlobals,
  TimeBase *              outTimeBase )
{
  *outTimeBase = ( **inGlobals ).itsMediaTimeBase;
  
  return( noErr );
}



/* ---------------------------------------------------------------------------
 *    + RTPMPHasCharacteristic() implementation
 * ---------------------------------------------------------------------------
 */

EXTERN_API( ComponentResult )
RTPMPComponentVideo_HasCharacteristic(
  RTPMPComponentVideoInstanceData **  inGlobals,
  OSType                inSelector,
  Boolean *              outHasIt )
{
  ComponentResult    theResult = noErr;
  
  
  switch( inSelector )
  {
    case kRTPMPNoSampleDataRequiredCharacteristic:
      *outHasIt = true;
    break;
    
    
    case kRTPMPPartialSamplesRequiredCharacteristic:
    case kRTPMPHasUserSettingsDialogCharacteristic:
    case kRTPMPPrefersReliableTransportCharacteristic:
    case kRTPMPRequiresOutOfBandDimensionsCharacteristic:
      *outHasIt = false;
    break;
    
    
    default:
      theResult =
        RTPMPHasCharacteristic( ( **inGlobals ).itsBase, inSelector, outHasIt );
    break;
  }
  
  return( theResult );
}



/* ---------------------------------------------------------------------------
 *    + RTPMPSetPacketBuilder() implementation
 * ---------------------------------------------------------------------------
 */

EXTERN_API( ComponentResult )
RTPMPComponentVideo_SetPacketBuilder(
  RTPMPComponentVideoInstanceData **  inGlobals,
  ComponentInstance          inPacketBuilder )
{
  ComponentResult    theError;
  SInt32        theFlags;
  
  
  if( ( **inGlobals ).itsInitialized  &amp;&amp;  ( **inGlobals ).itsPacketBuilder )
    theError = RTPMPFlush( ( **inGlobals ).itsFinalDerivation, 0, &amp;theFlags );
  else
    theError = noErr;
  
  if( !theError )
    ( **inGlobals ).itsPacketBuilder = inPacketBuilder;
  
  return( theError );
}



/* ---------------------------------------------------------------------------
 *    + RTPMPGetPacketBuilder() implementation
 * ---------------------------------------------------------------------------
 */

EXTERN_API( ComponentResult )
RTPMPComponentVideo_GetPacketBuilder(
  RTPMPComponentVideoInstanceData **  inGlobals,
  ComponentInstance *          outPacketBuilder )
{
  *outPacketBuilder = ( **inGlobals ).itsPacketBuilder;
  
  return( noErr );
}



/* ---------------------------------------------------------------------------
 *    + RTPMPSetMediaType() implementation
 * ---------------------------------------------------------------------------
 */

EXTERN_API( ComponentResult )
RTPMPComponentVideo_SetMediaType(
  RTPMPComponentVideoInstanceData **  inGlobals,
  OSType                inMediaType )
{
#pragma unused( inGlobals )
  ComponentResult    theResult;
  
  
  if( inMediaType == VideoMediaType )
    theResult = noErr;
  else
    theResult = qtsBadDataErr;
  
  return( theResult );
}



/* ---------------------------------------------------------------------------
 *    + RTPMPGetMediaType() implementation
 * ---------------------------------------------------------------------------
 */

EXTERN_API( ComponentResult )
RTPMPComponentVideo_GetMediaType(
  RTPMPComponentVideoInstanceData **  inGlobals,
  OSType *              outMediaType )
{
#pragma unused(inGlobals)

  *outMediaType = VideoMediaType;
  
  return( noErr );
}



/* ---------------------------------------------------------------------------
 *    + RTPMPSetMaxPacketSize() implementation
 * ---------------------------------------------------------------------------
 */

EXTERN_API( ComponentResult )
RTPMPComponentVideo_SetMaxPacketSize(
  RTPMPComponentVideoInstanceData **  inGlobals,
  UInt32                inMaxPacketSize )
{
  ( **inGlobals ).itsPacketSizeLimit = inMaxPacketSize;
  
  __UpdateDataSizes( inGlobals );
  
  return( noErr );
}



/* ---------------------------------------------------------------------------
 *    + RTPMPGetMaxPacketSize() implementation
 * ---------------------------------------------------------------------------
 */

EXTERN_API( ComponentResult )
RTPMPComponentVideo_GetMaxPacketSize(
  RTPMPComponentVideoInstanceData **  inGlobals,
  UInt32 *              outMaxPacketSize )
{
  *outMaxPacketSize = ( **inGlobals ).itsPacketSizeLimit;
  
  return( noErr );
}



/* ---------------------------------------------------------------------------
 *    + RTPMPSetMaxPacketDuration() implementation
 * ---------------------------------------------------------------------------
 */

EXTERN_API( ComponentResult )
RTPMPComponentVideo_SetMaxPacketDuration(
  RTPMPComponentVideoInstanceData **  inGlobals,
  UInt32                inMaxPacketDuration )
{
  ( **inGlobals ).itsPacketDurationLimit = inMaxPacketDuration;
  
  return( noErr );
}



/* ---------------------------------------------------------------------------
 *    + RTPMPGetMaxPacketDuration() implementation
 * ---------------------------------------------------------------------------
 */

EXTERN_API( ComponentResult )
RTPMPComponentVideo_GetMaxPacketDuration(
  RTPMPComponentVideoInstanceData **  inGlobals,
  UInt32 *              outMaxPacketDuration )
{
  *outMaxPacketDuration = ( **inGlobals ).itsPacketDurationLimit;
  
  return( noErr );
}
</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/qtstreaming.win/listing10.html%3Fid%3DDTS10001052-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/qtstreaming.win/listing10.html%3Fid%3DDTS10001052-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/qtstreaming.win/listing10.html%3Fid%3DDTS10001052-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>