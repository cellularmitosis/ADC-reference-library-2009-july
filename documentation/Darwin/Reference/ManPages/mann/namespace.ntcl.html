<html><head><title>Mac OS X
 Manual Page For namespace(ntcl)</title>
<style type="text/css"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { font-size: 1px; background: #ffffff; color: #ffffff; } --></style>
<style type="text/css" media="print, aural, braille, embossed, projection, tty"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { display: none; } --></style>
</head><body bgcolor="white">
<a name="//apple_ref/doc/man/ntcl/namespace" title="Mac OS X
 Manual Page for namespace(ntcl)"><a name="//apple_ref/doc/man/n/namespace" title="Mac OS X
 Manual Page for namespace(ntcl)"><!-- headerDoc=man; indexgroup=Section ntcl; uid="//apple_ref/doc/man/ntcl/namespace"; name=namespace(ntcl) --></a>
<!--#include virtual="/includes/framesetheader"-->
<table width=600><tr><td scope="row">
<!-- begin breadcrumb insert request --><font face="Geneva,Helvetica,Arial" size="1">
 <a target="_top" href="http://developer.apple.com">ADC Home</a> <b>&gt;</b> <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> <b>&gt;</b> <a href="../../../../../reference/index.html#//apple_ref/doc/uid/TP30001281" target="_top">Reference</a> <b>&gt;</b> <!-- a href="" target="_top" -->Mac OS X<!-- /a --> <b>&gt;</b> <a href="../index.html#//apple_ref/doc/framework/manpages" target="_top">Mac OS X Man Pages</a></font>
<!-- end breadcrumb insert request -->
<p>&nbsp;</p>
</td></tr></table>
<!-- end of header -->
<table border="0"  cellpadding="2" cellspacing="2" width="630pt"><tr><td valign="top" height="12" colspan="5" scope="row">
<p style='text-align:justify;'>This document is a Mac OS X manual page.  Manual pages are a command-line technology
for providing documentation.  You can view these manual pages locally using the
<a href="../man1/man.1.html#//apple_ref/doc/man/1/man">man(1)</a> command.
These manual pages come from many different sources, and thus, have a variety of writing
styles.</p>
<p style='text-align:justify;'>For more information about the manual page format, see the manual page for 
<a href="../man5/manpages.5.html#//apple_ref/doc/man/5/manpages">manpages(5)</a>.</p>
</td></tr></table>
<hr />
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row"><pre class="manpages"><tt>
namespace(n)                                Tcl Built-In Commands                               namespace(n)



____________________________________________________________________________________________________________

<b>NAME</b>
       namespace - create and manipulate contexts for commands and variables

<b>SYNOPSIS</b>
       <b>namespace</b> ?<u>option</u>? ?<u>arg</u> <u>...</u>?
____________________________________________________________________________________________________________


<b>DESCRIPTION</b>
       The  <b>namespace</b>  command lets you create, access, and destroy separate contexts for commands and vari-<font color="#ffffff" class="whiteout">ables.&nbsp;variables.</font>
       ables.  See the section <b>WHAT</b> <b>IS</b> <b>A</b> <b>NAMESPACE?</b> below for a brief overview  of  namespaces.   The  legal
       <u>option</u>'s are listed below.  Note that you can abbreviate the <u>option</u>'s.

       <b>namespace</b> <b>children</b> ?<u>namespace</u>? ?<u>pattern</u>?
              Returns  a  list of all child namespaces that belong to the namespace <u>namespace</u>.  If <u>namespace</u>
              is not specified, then the children are returned for  the  current  namespace.   This  command
              returns  fully-qualified  names,  which start with <b>::</b>.  If the optional <u>pattern</u> is given, then
              this command returns only the names that match the glob-style  pattern.   The  actual  pattern
              used  is  determined as follows: a pattern that starts with <b>::</b> is used directly, otherwise the
              namespace <u>namespace</u> (or the fully-qualified name of the current namespace) is  prepended  onto
              the the pattern.

       <b>namespace</b> <b>code</b> <u>script</u>
              Captures the current namespace context for later execution of the script <u>script</u>.  It returns a
              new script in which <u>script</u> has been wrapped in a <b>namespace</b> <b>inscope</b> command.   The  new  script
              has  two  important  properties.   First,  it can be evaluated in any namespace and will cause
              <u>script</u> to be evaluated in the current namespace (the one where the <b>namespace</b> <b>code</b> command  was
              invoked).   Second, additional arguments can be appended to the resulting script and they will
              be passed to <u>script</u> as additional arguments.  For example,  suppose  the  command  <b>set</b>  <b>script</b>
              <b>[namespace</b>  <b>code</b>  <b>{foo</b>  <b>bar}]</b>  is invoked in namespace <b>::a::b</b>.  Then <b>eval</b> <b>"$script</b> <b>x</b> <b>y"</b> can be
              executed in any namespace (assuming the value of <b>script</b> has been passed in properly) and  will
              have  the  same  effect as the command <b>::namespace</b> <b>eval</b> <b>::a::b</b> <b>{foo</b> <b>bar</b> <b>x</b> <b>y}</b>.  This command is
              needed because extensions like Tk normally execute callback scripts in the  global  namespace.
              A  scoped  command captures a command together with its namespace context in a way that allows
              it to be executed properly later.  See the section <b>SCOPED</b> <b>VALUES</b> for some examples of how this
              is used to create callback scripts.

       <b>namespace</b> <b>current</b>
              Returns  the  fully-qualified  name  for the current namespace.  The actual name of the global
              namespace is ``'' (i.e., an empty string), but this command returns <b>::</b> for the  global  names-<font color="#ffffff" class="whiteout">pace&nbsp;namespace</font>
              pace as a convenience to programmers.

       <b>namespace</b> <b>delete</b> ?<u>namespace</u> <u>namespace</u> <u>...</u>?
              Each  namespace  <u>namespace</u> is deleted and all variables, procedures, and child namespaces con-<font color="#ffffff" class="whiteout">tained&nbsp;contained</font>
              tained in the namespace are deleted.  If a procedure is currently executing inside the  names-<font color="#ffffff" class="whiteout">pace,&nbsp;namespace,</font>
              pace,  the namespace will be kept alive until the procedure returns; however, the namespace is
              marked to prevent other code from looking it up by name.  If a namespace doesn't  exist,  this
              command returns an error.  If no namespace names are given, this command does nothing.

       <b>namespace</b> <b>eval</b> <u>namespace</u> <u>arg</u> ?<u>arg</u> <u>...</u>?
              Activates a namespace called <u>namespace</u> and evaluates some code in that context.  If the names-<font color="#ffffff" class="whiteout">pace&nbsp;namespace</font>
              pace does not already exist, it is created.  If more than one <u>arg</u> argument is  specified,  the
              arguments  are  concatenated together with a space between each one in the same fashion as the
              <b>eval</b> command, and the result is evaluated.

              If <u>namespace</u> has leading namespace qualifiers and any leading namespaces do  not  exist,  they
              are automatically created.

       <b>namespace</b> <b>exists</b> <u>namespace</u>
              Returns <b>1</b> if <u>namespace</u> is a valid namespace in the current context, returns <b>0</b> otherwise.

       <b>namespace</b> <b>export</b> ?-<b>clear</b>? ?<u>pattern</u> <u>pattern</u> <u>...</u>?
              Specifies  which commands are exported from a namespace.  The exported commands are those that
              can be later imported into another namespace using a <b>namespace</b> <b>import</b> command.  Both  commands
              defined in a namespace and commands the namespace has previously imported can be exported by a
              namespace.  The commands do not have to be defined at the time the <b>namespace</b> <b>export</b> command is
              executed.   Each <u>pattern</u> may contain glob-style special characters, but it may not include any
              namespace qualifiers.  That is, the pattern can only specify commands in the current  (export-<font color="#ffffff" class="whiteout">ing)&nbsp;(exporting)</font>
              ing)  namespace.   Each  <u>pattern</u> is appended onto the namespace's list of export patterns.  If
              the -<b>clear</b> flag is given, the namespace's export pattern list is reset  to  empty  before  any
              <u>pattern</u>  arguments  are  appended.   If no <u>pattern</u>s are given and the -<b>clear</b> flag isn't given,
              this command returns the namespace's current export list.

       <b>namespace</b> <b>forget</b> ?<u>pattern</u> <u>pattern</u> <u>...</u>?
              Removes previously imported commands from a namespace.  Each <u>pattern</u> is a simple or  qualified
              name  such  as <b>x</b>, <b>foo::x</b> or <b>a::b::p*</b>.  Qualified names contain <b>::</b>s and qualify a name with the
              name of one or more namespaces.  Each <u>qualified</u> <u>pattern</u> is  qualified  with  the  name  of  an
              exporting  namespace and may have glob-style special characters in the command name at the end
              of the qualified name.  Glob characters may not appear in a namespace name.  For  each  <u>simple</u>
              <u>pattern</u> this command deletes the matching commands of the current namespace that were imported
              from a different namespace.  For <u>qualified</u> <u>patterns</u>, this command  first  finds  the  matching
              exported  commands.   It then checks whether any of those commands were previously imported by
              the current namespace.  If so, this command deletes the corresponding imported  commands.   In
              effect, this un-does the action of a <b>namespace</b> <b>import</b> command.

       <b>namespace</b> <b>import</b> ?<b>-force</b>? ?<u>pattern</u> <u>pattern</u> <u>...</u>?
              Imports  commands  into  a  namespace.  Each <u>pattern</u> is a qualified name like <b>foo::x</b> or <b>a::p*</b>.
              That is, it includes the name of an exporting namespace and may have glob-style special  char-<font color="#ffffff" class="whiteout">acters&nbsp;characters</font>
              acters  in  the command name at the end of the qualified name.  Glob characters may not appear
              in a namespace name.  All the commands that match a <u>pattern</u> string  and  which  are  currently
              exported  from their namespace are added to the current namespace.  This is done by creating a
              new command in the current namespace that points to  the  exported  command  in  its  original
              namespace;  when  the  new  imported command is called, it invokes the exported command.  This
              command normally returns an error if an imported command conflicts with an  existing  command.
              However,  if the -<b>force</b> option is given, imported commands will silently replace existing com-<font color="#ffffff" class="whiteout">mands.&nbsp;commands.</font>
              mands.  The <b>namespace</b> <b>import</b> command has snapshot semantics: that is, only requested  commands
              that  are  currently defined in the exporting namespace are imported.  In other words, you can
              import only the commands that are in a namespace at the time when the <b>namespace</b> <b>import</b> command
              is  executed.   If another command is defined and exported in this namespace later on, it will
              not be imported.

       <b>namespace</b> <b>inscope</b> <u>namespace</u> <u>script</u> ?<u>arg</u> <u>...</u>?
              Executes a script in the context of the specified <u>namespace</u>.  This command is not expected  to
              be  used  directly  by programmers; calls to it are generated implicitly when applications use
              <b>namespace</b> <b>code</b> commands to create callback scripts that the applications then  register  with,
              e.g.,  Tk  widgets.   The  <b>namespace</b>  <b>inscope</b>  command is much like the <b>namespace</b> <b>eval</b> command
              except that the <u>namespace</u> must already exist, and <b>namespace</b> <b>inscope</b> appends additional <u>arg</u>s as
              proper list elements.
              <b>namespace</b> <b>inscope</b> <b>::foo</b> <b>$script</b> <b>$x</b> <b>$y</b> <b>$z</b> is equivalent to <b>namespace</b> <b>eval</b> <b>::foo</b> <b>[concat</b> <b>$script</b>
              <b>[list</b> <b>$x</b> <b>$y</b> <b>$z]]</b> thus additional arguments will not undergo a second round of substitution, as
              is the case with <b>namespace</b> <b>eval</b>.

       <b>namespace</b> <b>origin</b> <u>command</u>
              Returns the fully-qualified name of the original command to which the imported command <u>command</u>
              refers.  When a command is imported into a namespace, a new command is created in that  names-<font color="#ffffff" class="whiteout">pace&nbsp;namespace</font>
              pace  that  points to the actual command in the exporting namespace.  If a command is imported
              into a sequence of namespaces <u>a,</u> <u>b,...,n</u> where each successive namespace just imports the com-<font color="#ffffff" class="whiteout">mand&nbsp;command</font>
              mand  from the previous namespace, this command returns the fully-qualified name of the origi-<font color="#ffffff" class="whiteout">nal&nbsp;original</font>
              nal command in the first namespace, <u>a</u>.  If <u>command</u> does not refer to an imported command,  the
              command's own fully-qualified name is returned.

       <b>namespace</b> <b>parent</b> ?<u>namespace</u>?
              Returns  the  fully-qualified name of the parent namespace for namespace <u>namespace</u>.  If <u>names</u>-<font color="#ffffff" class="whiteout">pace&nbsp;namespace</font>
              <u>pace</u> is not specified, the fully-qualified name of the current namespace's parent is returned.

       <b>namespace</b> <b>qualifiers</b> <u>string</u>
              Returns any leading namespace qualifiers for <u>string</u>.  Qualifiers are namespace names separated
              by <b>::</b>s.  For the <u>string</u> <b>::foo::bar::x</b>, this command returns <b>::foo::bar</b>, and for <b>::</b> it  returns
              an  empty string.  This command is the complement of the <b>namespace</b> <b>tail</b> command.  Note that it
              does not check whether the namespace names are, in fact, the names of currently defined names-<font color="#ffffff" class="whiteout">paces.&nbsp;namespaces.</font>
              paces.

       <b>namespace</b> <b>tail</b> <u>string</u>
              Returns the simple name at the end of a qualified string.  Qualifiers are namespace names sep-<font color="#ffffff" class="whiteout">arated&nbsp;separated</font>
              arated by <b>::</b>s.  For the <u>string</u> <b>::foo::bar::x</b>, this command returns <b>x</b>, and for <b>::</b> it returns an
              empty  string.   This  command is the complement of the <b>namespace</b> <b>qualifiers</b> command.  It does
              not check whether the namespace names are, in fact, the names of currently defined namespaces.

       <b>namespace</b> <b>which</b> ?-<b>command</b>? ?-<b>variable</b>? <u>name</u>
              Looks up <u>name</u> as either a command or variable and returns its fully-qualified name.  For exam-<font color="#ffffff" class="whiteout">ple,&nbsp;example,</font>
              ple, if <u>name</u> does not exist in the current namespace but does exist in the  global  namespace,
              this  command returns a fully-qualified name in the global namespace.  If the command or vari-<font color="#ffffff" class="whiteout">able&nbsp;variable</font>
              able does not exist, this command returns an empty string.  If the variable has  been  created
              but  not  defined,  such as with the <b>variable</b> command or through a <b>trace</b> on the variable, this
              command will return the fully-qualified name of the variable.  If no flag is  given,  <u>name</u>  is
              treated  as  a  command name.  See the section <b>NAME</b> <b>RESOLUTION</b> below for an explanation of the
              rules regarding name resolution.


<b>WHAT</b> <b>IS</b> <b>A</b> <b>NAMESPACE?</b>
       A namespace is a collection of commands and variables.  It encapsulates the commands and variables to
       ensure that they won't interfere with the commands and variables of other namespaces.  Tcl has always
       had one such collection, which we refer to as the <u>global</u> <u>namespace</u>.  The global namespace  holds  all
       global variables and commands.  The <b>namespace</b> <b>eval</b> command lets you create new namespaces.  For exam-<font color="#ffffff" class="whiteout">ple,&nbsp;example,</font>
       ple,
              <b>namespace</b> <b>eval</b> <b>Counter</b> <b>{</b>
                  <b>namespace</b> <b>export</b> <b>bump</b>
                  <b>variable</b> <b>num</b> <b>0</b>

                  <b>proc</b> <b>bump</b> <b>{}</b> <b>{</b>
                      <b>variable</b> <b>num</b>
                      <b>incr</b> <b>num</b>
                  <b>}</b>
              <b>}</b>
       creates a new namespace containing the variable <b>num</b> and the procedure <b>bump</b>.  The commands  and  vari-<font color="#ffffff" class="whiteout">ables&nbsp;variables</font>
       ables in this namespace are separate from other commands and variables in the same program.  If there
       is a command named <b>bump</b> in the global namespace, for example, it will be different from  the  command
       <b>bump</b> in the <b>Counter</b> namespace.

       Namespace  variables  resemble  global  variables  in Tcl.  They exist outside of the procedures in a
       namespace but can be accessed in a procedure via the <b>variable</b> command, as shown in the example above.

       Namespaces  are dynamic.  You can add and delete commands and variables at any time, so you can build
       up the contents of a namespace over time using a series of <b>namespace</b> <b>eval</b> commands.  For example, the
       following series of commands has the same effect as the namespace definition shown above:
              <b>namespace</b> <b>eval</b> <b>Counter</b> <b>{</b>
                  <b>variable</b> <b>num</b> <b>0</b>
                  <b>proc</b> <b>bump</b> <b>{}</b> <b>{</b>
                      <b>variable</b> <b>num</b>
                      <b>return</b> <b>[incr</b> <b>num]</b>
                  <b>}</b>
              <b>}</b>
              <b>namespace</b> <b>eval</b> <b>Counter</b> <b>{</b>
                  <b>proc</b> <b>test</b> <b>{args}</b> <b>{</b>
                      <b>return</b> <b>$args</b>
                  <b>}</b>
              <b>}</b>
              <b>namespace</b> <b>eval</b> <b>Counter</b> <b>{</b>
                  <b>rename</b> <b>test</b> <b>""</b>
              <b>}</b>
       Note that the <b>test</b> procedure is added to the <b>Counter</b> namespace, and later removed via the <b>rename</b> com-<font color="#ffffff" class="whiteout">mand.&nbsp;command.</font>
       mand.

       Namespaces can have other namespaces within them, so they nest hierarchically.  A nested namespace is
       encapsulated inside its parent namespace and can not interfere with other namespaces.


<b>QUALIFIED</b> <b>NAMES</b>
       Each  namespace  has  a  textual  name such as <b>history</b> or <b>::safe::interp</b>.  Since namespaces may nest,
       qualified names are used to refer to commands,  variables,  and  child  namespaces  contained  inside
       namespaces.  Qualified names are similar to the hierarchical path names for Unix files or Tk widgets,
       except that <b>::</b> is used as the separator instead of <b>/</b> or <b>.</b>.  The topmost or global namespace  has  the
       name   ``''  (i.e.,  an  empty  string),  although  <b>::</b>  is  a  synonym.   As  an  example,  the  name
       <b>::safe::interp::create</b> refers to the command <b>create</b> in the namespace <b>interp</b> that is  a  child  of  of
       namespace <b>::safe</b>, which in turn is a child of the global namespace <b>::</b>.

       If  you want to access commands and variables from another namespace, you must use some extra syntax.
       Names must be qualified by the namespace that contains them.  From the  global  namespace,  we  might
       access the <b>Counter</b> procedures like this:
              <b>Counter::bump</b> <b>5</b>
              <b>Counter::Reset</b>
       We could access the current count like this:
              <b>puts</b> <b>"count</b> <b>=</b> <b>$Counter::num"</b>
       When  one namespace contains another, you may need more than one qualifier to reach its elements.  If
       we had a namespace <b>Foo</b> that contained the namespace <b>Counter</b>, you could invoke its <b>bump</b> procedure from
       the global namespace like this:
              <b>Foo::Counter::bump</b> <b>3</b>

       You  can  also use qualified names when you create and rename commands.  For example, you could add a
       procedure to the <b>Foo</b> namespace like this:
              <b>proc</b> <b>Foo::Test</b> <b>{args}</b> <b>{return</b> <b>$args}</b>
       And you could move the same procedure to another namespace like this:
              <b>rename</b> <b>Foo::Test</b> <b>Bar::Test</b>

       There are a few remaining points about  qualified  names  that  we  should  cover.   Namespaces  have
       nonempty  names  except  for the global namespace.  <b>::</b> is disallowed in simple command, variable, and
       namespace names except as a namespace separator.  Extra <b>:</b>s in a qualified name are ignored; that  is,
       two  or  more <b>:</b>s are treated as a namespace separator.  A trailing <b>::</b> in a qualified variable or com-<font color="#ffffff" class="whiteout">mand&nbsp;command</font>
       mand name refers to the variable or command named {}.  However, a trailing <b>::</b> in a  qualified  names-<font color="#ffffff" class="whiteout">pace&nbsp;namespace</font>
       pace name is ignored.


<b>NAME</b> <b>RESOLUTION</b>
       In  general,  all  Tcl  commands  that take variable and command names support qualified names.  This
       means you can give qualified names to such commands as <b>set</b>, <b>proc</b>, <b>rename</b>, and <b>interp</b> <b>alias</b>.   If  you
       provide  a fully-qualified name that starts with a <b>::</b>, there is no question about what command, vari-<font color="#ffffff" class="whiteout">able,&nbsp;variable,</font>
       able, or namespace you mean.  However, if the name does not start with a <b>::</b> (i.e., is <u>relative</u>),  Tcl
       follows  a  fixed  rule  for looking it up: Command and variable names are always resolved by looking
       first in the current namespace, and then in the global namespace.   Namespace  names,  on  the  other
       hand, are always resolved by looking in only the current namespace.

       In the following example,
              <b>set</b> <b>traceLevel</b> <b>0</b>
              <b>namespace</b> <b>eval</b> <b>Debug</b> <b>{</b>
                  <b>printTrace</b> <b>$traceLevel</b>
              <b>}</b>
       Tcl  looks  for  <b>traceLevel</b> in the namespace <b>Debug</b> and then in the global namespace.  It looks up the
       command <b>printTrace</b> in the same way.  If a variable or command name is not found  in  either  context,
       the name is undefined.  To make this point absolutely clear, consider the following example:
              <b>set</b> <b>traceLevel</b> <b>0</b>
              <b>namespace</b> <b>eval</b> <b>Foo</b> <b>{</b>
                  <b>variable</b> <b>traceLevel</b> <b>3</b>

                  <b>namespace</b> <b>eval</b> <b>Debug</b> <b>{</b>
                      <b>printTrace</b> <b>$traceLevel</b>
                  <b>}</b>
              <b>}</b>
       Here  Tcl  looks  for <b>traceLevel</b> first in the namespace <b>Foo::Debug</b>.  Since it is not found there, Tcl
       then looks for it in the global namespace.  The variable <b>Foo::traceLevel</b> is completely ignored during
       the name resolution process.

       You can use the <b>namespace</b> <b>which</b> command to clear up any question about name resolution.  For example,
       the command:
              <b>namespace</b> <b>eval</b> <b>Foo::Debug</b> <b>{namespace</b> <b>which</b> <b>-variable</b> <b>traceLevel}</b>
       returns <b>::traceLevel</b>.  On the other hand, the command,
              <b>namespace</b> <b>eval</b> <b>Foo</b> <b>{namespace</b> <b>which</b> <b>-variable</b> <b>traceLevel}</b>
       returns <b>::Foo::traceLevel</b>.

       As mentioned above, namespace names are looked up differently than the names of  variables  and  com-<font color="#ffffff" class="whiteout">mands.&nbsp;commands.</font>
       mands.   Namespace names are always resolved in the current namespace.  This means, for example, that
       a <b>namespace</b> <b>eval</b> command that creates a new namespace always creates a child of the current namespace
       unless the new namespace name begins with a <b>::</b>.

       Tcl has no access control to limit what variables, commands, or namespaces you can reference.  If you
       provide a qualified name that resolves to an element by the  name  resolution  rule  above,  you  can
       access the element.

       You can access a namespace variable from a procedure in the same namespace by using the <b>variable</b> com-<font color="#ffffff" class="whiteout">mand.&nbsp;command.</font>
       mand.  Much like the <b>global</b> command, this creates a local link to the namespace variable.  If  neces-<font color="#ffffff" class="whiteout">sary,&nbsp;necessary,</font>
       sary, it also creates the variable in the current namespace and initializes it.  Note that the <b>global</b>
       command only creates links to variables in the global namespace.  It is not necessary to use a  <b>vari</b>-<font color="#ffffff" class="whiteout">able&nbsp;variable</font>
       <b>able</b> command if you always refer to the namespace variable using an appropriate qualified name.


<b>IMPORTING</b> <b>COMMANDS</b>
       Namespaces  are often used to represent libraries.  Some library commands are used so frequently that
       it is a nuisance to type their qualified names.  For example, suppose that all of the commands  in  a
       package  like BLT are contained in a namespace called <b>Blt</b>.  Then you might access these commands like
       this:
              <b>Blt::graph</b> <b>.g</b> <b>-background</b> <b>red</b>
              <b>Blt::table</b> <b>.</b> <b>.g</b> <b>0,0</b>
       If you use the <b>graph</b> and <b>table</b> commands frequently, you may want to access  them  without  the  <b>Blt::</b>
       prefix.  You can do this by importing the commands into the current namespace, like this:
              <b>namespace</b> <b>import</b> <b>Blt::*</b>
       This adds all exported commands from the <b>Blt</b> namespace into the current namespace context, so you can
       write code like this:
              <b>graph</b> <b>.g</b> <b>-background</b> <b>red</b>
              <b>table</b> <b>.</b> <b>.g</b> <b>0,0</b>
       The <b>namespace</b> <b>import</b> command only imports commands from a namespace that that namespace exported with
       a <b>namespace</b> <b>export</b> command.

       Importing  <u>every</u>  command from a namespace is generally a bad idea since you don't know what you will
       get.  It is better to import just the specific commands you need.  For example, the command
              <b>namespace</b> <b>import</b> <b>Blt::graph</b> <b>Blt::table</b>
       imports only the <b>graph</b> and <b>table</b> commands into the current context.

       If you try to import a command that already exists, you will get an error.  This  prevents  you  from
       importing  the  same command from two different packages.  But from time to time (perhaps when debug-<font color="#ffffff" class="whiteout">ging),&nbsp;debugging),</font>
       ging), you may want to get around this restriction.  You may want to  reissue  the  <b>namespace</b>  <b>import</b>
       command  to  pick  up  new commands that have appeared in a namespace.  In that case, you can use the
       <b>-force</b> option, and existing commands will be silently overwritten:
              <b>namespace</b> <b>import</b> <b>-force</b> <b>Blt::graph</b> <b>Blt::table</b>
       If for some reason, you want to stop using the imported commands, you can remove them with an  <b>names</b>-<font color="#ffffff" class="whiteout">pace&nbsp;namespace</font>
       <b>pace</b> <b>forget</b> command, like this:
              <b>namespace</b> <b>forget</b> <b>Blt::*</b>
       This  searches the current namespace for any commands imported from <b>Blt</b>.  If it finds any, it removes
       them.  Otherwise, it does nothing.  After this, the <b>Blt</b> commands must be accessed with the <b>Blt::</b> pre-<font color="#ffffff" class="whiteout">fix.&nbsp;prefix.</font>
       fix.

       When you delete a command from the exporting namespace like this:
              <b>rename</b> <b>Blt::graph</b> <b>""</b>
       the command is automatically removed from all namespaces that import it.


<b>EXPORTING</b> <b>COMMANDS</b>
       You can export commands from a namespace like this:
              <b>namespace</b> <b>eval</b> <b>Counter</b> <b>{</b>
                  <b>namespace</b> <b>export</b> <b>bump</b> <b>reset</b>
                  <b>variable</b> <b>Num</b> <b>0</b>
                  <b>variable</b> <b>Max</b> <b>100</b>

                  <b>proc</b> <b>bump</b> <b>{{by</b> <b>1}}</b> <b>{</b>
                      <b>variable</b> <b>Num</b>
                      <b>incr</b> <b>Num</b> <b>$by</b>
                      <b>Check</b>
                      <b>return</b> <b>$Num</b>
                  <b>}</b>
                  <b>proc</b> <b>reset</b> <b>{}</b> <b>{</b>
                      <b>variable</b> <b>Num</b>
                      <b>set</b> <b>Num</b> <b>0</b>
                  <b>}</b>
                  <b>proc</b> <b>Check</b> <b>{}</b> <b>{</b>
                      <b>variable</b> <b>Num</b>
                      <b>variable</b> <b>Max</b>
                      <b>if</b> <b>{$Num</b> <b>&gt;</b> <b>$Max}</b> <b>{</b>
                          <b>error</b> <b>"too</b> <b>high!"</b>
                      <b>}</b>
                  <b>}</b>
              <b>}</b>
       The  procedures  <b>bump</b>  and  <b>reset</b> are exported, so they are included when you import from the <b>Counter</b>
       namespace, like this:
              <b>namespace</b> <b>import</b> <b>Counter::*</b>
       However, the <b>Check</b> procedure is not exported, so it is ignored by the import operation.

       The <b>namespace</b> <b>import</b> command only imports commands that were declared as exported by their namespace.
       The  <b>namespace</b>  <b>export</b>  command  specifies  what  commands may be imported by other namespaces.  If a
       <b>namespace</b> <b>import</b> command specifies a command that is not exported, the command is not imported.


<b>SEE</b> <b>ALSO</b>
       <a href="variable.ntcl.html#//apple_ref/doc/man/n/variable">variable(n)</a>


<b>KEYWORDS</b>
       exported, internal, variable



Tcl                                                  8.0                                        namespace(n)
</tt></pre>
</td></tr></table>
	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Darwin/Reference/ManPages/mann/namespace.ntcl.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Darwin/Reference/ManPages/mann/namespace.ntcl.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Darwin/Reference/ManPages/mann/namespace.ntcl.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

</body></html>
