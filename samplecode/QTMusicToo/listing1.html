<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>QTMusicToo - /BigEasy/BigEasy2.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/QuickTime/index.html">QuickTime</a> &gt; <a href="../../samplecode/QuickTime/idxMusicAudio-date.html">Audio</a> &gt; <A HREF="javascript:location.replace('index.html');">QTMusicToo</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Not Recommended Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>The information in this document is <strong>Not Recommended</strong> and should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/QuickTime/idxMusicAudio-date.html" target="_blank">QuickTime > Audio</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">QTMusicToo</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/BigEasy/BigEasy2.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/BigEasy/BigEasy2.c</option>
<option value="listing2.html">/BigEasy/BigEasy2.h</option>
<option value="listing3.html">/BigEasy/BigEasyControls.c</option>
<option value="listing4.html">/BigEasy/BigEasyControls.h</option>
<option value="listing5.html">/BigEasy/BigEasyDialogs.c</option>
<option value="listing6.html">/BigEasy/BigEasyDialogs.h</option>
<option value="listing7.html">/BigEasy/BigEasyGestalt.c</option>
<option value="listing8.html">/BigEasy/BigEasyGestalt.h</option>
<option value="listing9.html">/BigEasy/BigEasyGrafish.c</option>
<option value="listing10.html">/BigEasy/BigEasyGrafish.h</option>
<option value="listing11.html">/BigEasy/BigEasyPPC.c</option>
<option value="listing12.html">/BigEasy/BigEasyPPC.h</option>
<option value="listing13.html">/BigEasy/BigEasyStandardControls.c</option>
<option value="listing14.html">/BigEasy/BigEasyStandardControls.h</option>
<option value="listing15.html">/BigEasy/BigEasyTextish.c</option>
<option value="listing16.html">/BigEasy/BigEasyTextish.h</option>
<option value="listing17.html">/BigEasy/BigEasyUtils.c</option>
<option value="listing18.html">/BigEasy/BigEasyUtils.h</option>
<option value="listing19.html">/BigEasy/IconUtilsPriv.h</option>
<option value="listing20.html">/BigEasy/NWindows.c</option>
<option value="listing21.html">/BigEasy/OneWindow.c</option>
<option value="listing22.html">/•Instrument Editor/All The MIDI Components.h</option>
<option value="listing23.html">/•Instrument Editor/IE KeyboardDiagram.c</option>
<option value="listing24.html">/•Instrument Editor/IE KeyboardDiagram.h</option>
<option value="listing25.html">/•Instrument Editor/IE PrintUtilities.c</option>
<option value="listing26.html">/•Instrument Editor/IE PrintUtilities.h</option>
<option value="listing27.html">/•Instrument Editor/Instrument Editor Controls.c</option>
<option value="listing28.html">/•Instrument Editor/Instrument Editor Controls.h</option>
<option value="listing29.html">/•Instrument Editor/Instrument Editor Draw.c</option>
<option value="listing30.html">/•Instrument Editor/Instrument Editor Filing.c</option>
<option value="listing31.html">/•Instrument Editor/Instrument Editor Filing.h</option>
<option value="listing32.html">/•Instrument Editor/Instrument Editor Menus.c</option>
<option value="listing33.html">/•Instrument Editor/Instrument Editor Menus.h</option>
<option value="listing34.html">/•Instrument Editor/Instrument Editor.c</option>
<option value="listing35.html">/•Instrument Editor/Instrument Editor.h</option>
<option value="listing36.html">/•Instrument Editor/Instrument Editor.r</option>
<option value="listing37.html">/•Instrument Editor/Instrument Tests.c</option>
<option value="listing38.html">/•Instrument Editor/More IE Routines.c</option>
<option value="listing39.html">/•Instrument Editor/More IE Routines.h</option>
<option value="listing40.html">/•Instrument Picker Test/InstrumentPickerTest.c</option>
<option value="listing41.html">/•QTMusic Sample Keyboards/EasyKeyboardDiagram.c</option>
<option value="listing42.html">/•QTMusic Sample Keyboards/EasyKeyboardDiagram.h</option>
<option value="listing43.html">/•QTMusic Sample Keyboards/EasyKeyboardDiagram.r</option>
<option value="listing44.html">/•QTMusic Sample Keyboards/QTMusic Sample Keyboards.c</option>
<option value="listing45.html">/•QTMusic Sample Keyboards/QTMusic Sample Keyboards.r</option>
<option value="listing46.html">/•QTMusic Sample Sequencer/Event Priority Queue.c</option>
<option value="listing47.html">/•QTMusic Sample Sequencer/Event Priority Queue.h</option>
<option value="listing48.html">/•QTMusic Sample Sequencer/Sequencer Test Movies.c</option>
<option value="listing49.html">/•QTMusic Sample Sequencer/Sequencer Test Movies.h</option>
<option value="listing50.html">/•QTMusic Sample Sequencer/SequencerTest Filing.c</option>
<option value="listing51.html">/•QTMusic Sample Sequencer/SequencerTest Filing.h</option>
<option value="listing52.html">/•QTMusic Sample Sequencer/SequencerTest Movies.h</option>
<option value="listing53.html">/•QTMusic Sample Sequencer/SequencerTest Realtime.c</option>
<option value="listing54.html">/•QTMusic Sample Sequencer/SequencerTest Realtime.h</option>
<option value="listing55.html">/•QTMusic Sample Sequencer/SequencerTest.c</option>
<option value="listing56.html">/•QTMusic Sample Sequencer/SequencerTest.h</option></select>
				</p>
				</form>
				<p><strong><a href="QTMusicToo.zip">Download Sample</a></strong> (&#147;QTMusicToo.zip&#148;, 115.5K)<BR>
<strong><a href="QTMusicToo.dmg">Download Sample</a></strong> (&#147;QTMusicToo.dmg&#148;, 173.6K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*  File:    BigEasy2.c  Copyright:  &copy; 1990-1992, 1994 by Apple Computer, Inc., all rights reserved.    This file is used in these builds: Warhol  Change History (most recent first):    &lt;41+&gt;   22-9-94  dvb  universal headers      &lt;41&gt;   22-9-94  dvb        &lt;40+&gt;   17-8-94  dvb    allocate gx job when pagesetup, no sooner, coz its slow.    &lt;40&gt;   17-8-94  dvb    GX Printing    &lt;39&gt;    9-8-94  dvb        &lt;38&gt;   27-7-94  dvb    installquititem    &lt;37+&gt;   5/27/94  dvb    InstallQuitItem    &lt;37&gt;   5/27/94  dvb    .    &lt;35&gt;    1/7/93  dvb    Compile under mpw.    &lt;34&gt;    1/6/93  dvb    Built in window-copy command.    &lt;33&gt;   4/23/92  dvb    Test checkout from new project    &lt;32&gt;   4/13/92  dvb    Pass activate/deactivates to back windows.    &lt;31&gt;   3/22/92  dvb    QuitApp message.    &lt;30&gt;   1/20/92  dvb    Cool new features. Much easier appleevents.    &lt;29&gt;  12/19/91  JB    removing think 4.0 code    &lt;28&gt;  10/14/91  JB    added #ifdef to create old window ports for debugging    &lt;27&gt;   9/18/91  PH    support silly disk inserted events    &lt;26&gt;   8/12/91  MD    support for timing profiler nastiness    &lt;25&gt;    7/3/91  PH    qd. is bad under old think    &lt;24&gt;   6/28/91  dvb    Make it work with/without MacHeaders in LSC5.    &lt;23&gt;    6/4/91  PH    compilin'    &lt;22&gt;    6/3/91  dvb    Just hackin.    &lt;21&gt;   5/28/91  JB    Added prototypes for BigEasy Proc Ptrs    &lt;20&gt;   5/27/91  PH    to compile again...    &lt;19&gt;   5/25/91  JB    OLD_THINK_C &amp;&amp; TOOLBOX_LINKED    &lt;18&gt;   5/23/91  PH    changes for THINK 5    &lt;17&gt;   5/22/91  PH    new style prototypes    &lt;16&gt;    5/6/91  PH    nifty line after about...    &lt;15&gt;    5/5/91  dvb    Latest features, and App-Events for document open.         &lt;14&gt;   4/25/91  JB    Changing to new THINK C interface files    &lt;13&gt;   4/19/91  PH    i like content clicks    &lt;12&gt;   4/19/91  dvb    Add WindowEventProc    &lt;11&gt;   3/29/91  PH    minor activate fix    &lt;10&gt;   3/29/91  dvb    Repair deactivate vs closewindow conflict, roll in latest cool                  features.     &lt;9&gt;    3/9/91  dvb    Adjust to work with or without (LSC) mac headers     &lt;8&gt;    3/7/91  JB    Adjusting for using MacHeaders     &lt;7&gt;    3/1/91  dvb    Trivial new functions     &lt;6&gt;   2/24/91  dvb    Various cool new calls     &lt;5&gt;   2/18/91  dvb    Miscellaneous Updates     &lt;4&gt;    1/9/91  JB    Increasing ItemsPerMenu &amp; #Menus     &lt;3&gt;  11/21/90  JB    Changes for INIT &amp; mpw compatability     &lt;2&gt;  11/17/90  dvb    Pass on unused command-keys to document windows    &lt;1&gt;  11/17/90  dvb    New again after 1st CD pressing! Yay!  To Do:*//* file: BigEasy2.c  *  * Started 30 June 1988, more or less.  *  * A set of routines to allow the quick development  * of simple Macintosh applications.  * :)  */#define BigEasy2#include &lt;QuickDraw.h&gt;#include &lt;Gestalt.h&gt;#include &lt;Events.h&gt;#include &lt;AppleEvents.h&gt;#include &lt;Resources.h&gt;#include &lt;Menus.h&gt;#include &lt;ToolUtils.h&gt;#include &lt;Menus.h&gt;#include &lt;Windows.h&gt;#include &lt;Dialogs.h&gt;#include &lt;Memory.h&gt;#include &lt;devices.h&gt;#include &lt;Fonts.h&gt;#include &lt;Scrap.h&gt;#include &lt;SegLoad.h&gt;//#undef BigEasyGXPrinting#ifdef BigEasyGXPrinting  #include &lt;PrintingManager.h&gt;  #include &lt;Graphics Toolbox.h&gt;  #include &lt;Graphics Routines.h&gt;#endif/* #define THINK_C_PROFILE /* */#if defined(TIMING_PROFILE) || defined(STACK_KILLER)  #include &quot;stack killer.h&quot;#endif#include &quot;BigEasy2.h&quot;#ifdef BigEasyGXPrinting  #define WantsGX 1#else  #define WantsGX 0#endif/*----------------  Limits----------------*/#define kMMax 10      /* Number of menus in menubar */#define kMIMax 50      /* Number of items per menu */#define kMenuNameMax 32    /* Length of a menu title */#define kStagLimX 97#define kStagLimY 37/*----------------  Constants----------------*/#define  kOSEvent            app4Evt  /* event used by MultiFinder */#define  kSuspendResumeMessage      1    /* high byte of suspend/resume event message */#define  kResumeMask          1    /* bit of message field for resume vs. suspend */#define kWinPosType 'bewP'#define trapExitToShell 0xA9F4/*----------------  Major BigEasy2 Structures----------------*/typedef struct TEasyWindow  {  Boolean wUsed;  long iNum;  long flags;  Boolean wGrowable;  beUpdateProcPtr wUpdateProc;  beClickProcPtr wClickProc;  beKeyProcPtr wKeyProc;  beGoAwayProcPtr wGoAwayProc;  beWNumCallProcPtr wZoomProc;  beActivateProcPtr wActivateProc;  beDeactivateProcPtr wDeactivateProc;  beIdleProcPtr wIdleProc;  beResizeProcPtr wResizeProc;  beGrowWindowProcPtr wGrowWindowProc;  beMoveWindowProcPtr wMoveWindowProc;  beEventProcPtr wEventProc;  WindowPtr wWindow;#ifdef BigEasyGXPrinting  gxJob job;#endif  } TEasyWindow;typedef struct  {  short ref;  char mark;  char enable;  char cmdEquiv;  beMenuProcPtr proc;  } TEasyMenuItem;/*----------------  Globals----------------*/static short gIdleSeed;static Rect gResizeLim = {50,50,1000,1000};static TEasyWindow **gEasyWindowListH;      /* Handle to array of window objects  */static TEasyWindow *gEasyWindowList;      /* Pointer to array of window objects  */static short gEasyWindowListSize;        /* Number of window objects allocated  *//*** Menus ***/static MenuHandle gMenuHandleList[kMMax];    /* MenuHandles indexed by MenuID's     */static short gMenuLength[kMMax];static char gMenuName[kMMax][kMenuNameMax];static TEasyMenuItem gMenu[kMMax][kMIMax];static short gMenuCount;            /* How many menus defined */static short gCurrentMenu;            /* the one to add to */static MenuHandle gMenuEdit;          /* Which one is the edit menu? *//*** Phantom Menu ***/static MenuHandle phantomMenuH = 0;/*** About ***/static beAboutProcPtr gAboutProc;static char gAboutS0[256];/*** Application Edit Commands ***/static beWNumCallProcPtr gAppUndoProc,gAppCutProc,gAppCopyProc,gAppPasteProc,gAppClearProc;static beMenuProcPtr gAppPageSetupProc=0,gAppPrintProc=0;/*** Global Status ***/static beOpenAppProcPtr gMasterOpenAppProc;static beOpenDocProcPtr gMasterOpenDocProc;static beQuitAppProcPtr gMasterQuitAppProc;static beAboutProcPtr gMasterIdleProc;static short gStagX,gStagY;static WindowPtr gLastFrontIdle;static short gLastFrontWindowNumber;static short gSleep;static short gCoolDragState;static Point gCoolDragPoint;static short gCoolDragWindowNumber;static TEasyWindow *gCoolDragEW;static Boolean gInvalidMenuBar;static void *gOldExitToShell;PicHandle GetWindowPICT(TEasyWindow *thisEasyWindow);/*----------------  Prototypes----------------*/static void InitToolbox(void);static void CheckMenubar(void);static void EventLoop(void);static void InitBigEasy(void);static void ExitBigEasy(void);static void InstallMyExitToShell(void);static pascal void MyExitToShell(void);static void GetGrowRect(WindowPtr,Rect*);static void EnoughEasyWindows(short);static void FrontDAEdits(void);static TEasyWindow *GoodWNum(short);static Boolean CoolBigEasyCmdKeys(short key);static void DoMyAbout(void);static void BEUndo(short);static void BECopy(short);static void BECut(short);static void BEPaste(short);static void BEClear(short);static void BENull(void);void BEPageSetup(short n, short menuItem, short menuRef);void BEPrint(short n, short menuItem, short menuRef);static void MenuClick(Point p);static void DeleteIndexedMenuItem(short menu,short item);static Boolean DoKeyPress(long k);static void MenuPoint(long theclick);static void StartMenus(void);static short ScanWindowList(WindowPtr w);static void DoMouseClick(EventRecord *event);static void MyDrawGrowIcon(WindowPtr w);static pascal OSErr BigEasyOpenAppThang(AppleEvent *theEvent, AppleEvent *reply,long refCon);static pascal OSErr BigEasyOpenDocThang(AppleEvent *theEvent, AppleEvent *reply,long refCon);static pascal OSErr BigEasyQuitAppThang(AppleEvent *theEvent, AppleEvent *reply,long refCon);static OSErr MissedAEParameters (AppleEvent *message);Boolean ActivateWindow(WindowPtr w, Boolean activate);#ifdef BigEasyGXPrintingvoid MakeSureWeHaveJob(TEasyWindow *thisWindow);#endifvoid main(void);/*----------------  Some useful routines----------------*/void InitToolbox(void)  {  InitGraf(&amp;qd.thePort);  InitFonts();  FlushEvents(0xffff,0);  InitWindows();  InitMenus();  InitDialogs(0);  TEInit();  InitCursor();  }void GetGrowRect(WindowPtr w,Rect *r)  {  register Rect *gr;  gr = r;  *gr = w-&gt;portRect;  gr-&gt;left = gr-&gt;right - 15;  gr-&gt;top = gr-&gt;bottom - 15;  }void GoWatch(void)  {  SetCursor(*(Cursor**)GetCursor(4));  }void GoArrow(void)  {  SetCursor(&amp;qd.arrow);  }void GoCursor(short c)/*  * Attempt to set to cursor ID c,  * but skip it if not there.  */  {  register Cursor **cur;  cur = (Cursor **)GetCursor(c);  if(cur)    SetCursor(*cur);  }static void EnoughEasyWindows(short n)/*  * If there are less than n window objects in the list,  * grow the handle appropriately.  */  {  short i;  n++;  if(gEasyWindowListSize &lt; n)    {    HUnlock((Handle)gEasyWindowListH);    SetHandleSize((Handle)gEasyWindowListH,sizeof(TEasyWindow) * (long)n);    HLock((Handle)gEasyWindowListH);    gEasyWindowList = *gEasyWindowListH;    for(i = gEasyWindowListSize; i &lt; n; i++)      gEasyWindowList[i].wUsed = 0;    gEasyWindowListSize = n;    }  }static TEasyWindow *GoodWNum(short n)/*  * return true if n is the number of an  * existing, used window.  */  {  register TEasyWindow *thisWindow;  if(n&lt;0 || n&gt;=gEasyWindowListSize)    return 0;  thisWindow = &amp;gEasyWindowList[n];  if(thisWindow-&gt;wUsed)    return thisWindow;  else    return 0;  }static void FrontDAEdits(void)/* * Check the front window. If it's a DA, * enable all edit menu options. */  {  WindowRecord *w;  w = (WindowRecord*)FrontWindow();  if(w-&gt;windowKind &lt; 0)                  /* Any click in a DA window: */    EnDisEdits(1,1,1,1,1);                /* enable edit menu. */  }void DoMyAbout(void)  {  DialogPtr d;  Handle h;  short hit;  if(gAboutProc)    (*gAboutProc)();  else    {    h = GetResource('DLOG',1962);              /* does it exist? */    if( (ResError()==0) &amp;&amp; (h!=nil) )      {      ParamText((StringPtr)gAboutS0,0,0,0);      d = GetNewDialog(1962,0,(WindowPtr)-1);      ModalDialog(nil,&amp;hit);      DisposDialog(d);      }    }  }void SetMasterIdle(r)  beAboutProcPtr r;  {  gMasterIdleProc = r;  }void SetWindowResizeProc(short n,beResizeProcPtr resizeProc)/*  * Sets the procedure which gets called when the window is resized  */  {  TEasyWindow *thisWindow;  thisWindow = GoodWNum(n);  if(thisWindow)    thisWindow-&gt;wResizeProc = resizeProc;  }void SetWindowGrowWindowProc(short n,beGrowWindowProcPtr growWindowProc)/*  * Sets the procedure which gets called when the window grows.  *   Allows alternate to GrowWindow.  */  {  TEasyWindow *thisWindow;  thisWindow = GoodWNum(n);  if(thisWindow)    thisWindow-&gt;wGrowWindowProc = growWindowProc;  }void SetWindowMoveProc(short n,beMoveWindowProcPtr moveWindowProc)  {  TEasyWindow *thisWindow;  thisWindow = GoodWNum(n);  if(thisWindow)    thisWindow-&gt;wMoveWindowProc = moveWindowProc;  }void SetWindowZoomProc(short n,beWNumCallProcPtr zoomProc)  {  register TEasyWindow *thisWindow;  thisWindow = GoodWNum(n);  if(thisWindow)    thisWindow-&gt;wZoomProc = zoomProc;  }void SetWindowEventProc(short n,beEventProcPtr eventProc)  {  register TEasyWindow *thisWindow;  thisWindow = GoodWNum(n);  if(thisWindow)    thisWindow-&gt;wEventProc = eventProc;  }long GetWindowFlags(short n)  {  TEasyWindow *thisWindow;  if(!(thisWindow = GoodWNum(n)))    return 0;  return thisWindow-&gt;flags;  }void SetWindowFlags(short n,long flags)  {  TEasyWindow *thisWindow;  if(!(thisWindow = GoodWNum(n)))    return;  thisWindow-&gt;flags = flags;  }void SetAbout(StringPtr progName,StringPtr s0,beAboutProcPtr aboutProc)/* * Sets the program's name in the about box, and * sets the second string as ParamText 0 (^0) * for the about dialog, 1962. */  {  short i;    SetItem(gMenuHandleList[1],1,(StringPtr)progName);  for(i=0; i&lt;256; i++)    gAboutS0[i] = *s0++;  gAboutProc = aboutProc;  } /*----------------  Error Handling----------------*/void InstallMyExitToShell(void)/*  * Add my HatStrap call to  * the classic routine, &quot;ExitToShell&quot;  */  {  gOldExitToShell =  (void *) NGetTrapAddress(trapExitToShell, ToolTrap);  NSetTrapAddress((UniversalProcPtr) MyExitToShell, trapExitToShell, ToolTrap);  }pascal void MyExitToShell(void)/*  * My exit routine, which does  * all the good cleanup.  */  {  Hatstrap();  NSetTrapAddress((UniversalProcPtr) gOldExitToShell, trapExitToShell, ToolTrap);  ExitToShell();  }  void FailNil(long x)/*  * If x is zero, post an error  * alert and quit the program.  */  {  if(!x)    {    Alert(200,nil);    Debugger();    ExitToShell();    }  }void FailOSErr(long x)/*  * If x isn't zero, post an error  * alert and quit the program.  */  {  if(x)    {    Debugger();    Alert(200,nil);    ExitToShell();    }  }/*----------------  Some inherent methods----------------*/void BEUndo(short n)  {  if(!SystemEdit(0) &amp;&amp; gAppUndoProc)    (*gAppUndoProc)(n);  }void BECut(short n)  {  if(!SystemEdit(2) &amp;&amp; gAppCutProc)    (*gAppCutProc)(n);  }PicHandle GetWindowPICT(TEasyWindow *tew)  {  Rect visBounds;  beUpdateProcPtr fp;  PicHandle picH;  SetPort(tew-&gt;wWindow);  /* Set port to window  */  visBounds = qd.thePort-&gt;portRect;  InsetRect(&amp;visBounds,-1,-1);  ForeColor(blackColor);  BackColor(whiteColor);  PenSize(1,1);  picH = OpenPicture(&amp;visBounds);  ClipRect(&amp;visBounds);  FrameRect(&amp;visBounds);  fp = tew-&gt;wUpdateProc;  if(fp)    (*fp)(tew-&gt;iNum);              /* Call drawing proc  */  SetOrigin(0,0);  ClosePicture();  ClipRect(&amp;gBigRect);  return picH;  }void BECopy(short n)  {  TEasyWindow *thisEasyWindow;  if(!SystemEdit(3))    {    thisEasyWindow = GoodWNum(n);    if(thisEasyWindow-&gt;flags &amp; wCopyDraw)      /*       *        */      {      PicHandle picH;      picH = GetWindowPICT(thisEasyWindow);      HLock((Handle)picH);      ZeroScrap();      PutScrap(GetHandleSize((Handle)picH),'PICT',(Ptr)*picH);      KillPicture(picH);      }    else if(gAppCopyProc)      (*gAppCopyProc)(n);    }  }void BEPaste(short n)  {  if(!SystemEdit(4) &amp;&amp; gAppPasteProc)    (*gAppPasteProc)(n);  }void BEClear(short n)  {  if(!SystemEdit(5) &amp;&amp; gAppClearProc)    (*gAppClearProc)(n);  }void BENull(void){}void BEPageSetup(short n, short menuItem, short menuRef)  {  OSErr err;  long oldMenus;#ifdef BigEasyGXPrinting  TEasyWindow *tew;  gxDialogResult result;  gxEditMenuRecord editMenuRec;  tew = GoodWNum(n);  if(tew-&gt;flags &amp; wPrintDraw)    {    oldMenus = DisableAllMenus();      editMenuRec.editMenuID = 0;    editMenuRec.cutItem = 0;     editMenuRec.copyItem = 0;    editMenuRec.pasteItem = 0;    editMenuRec.clearItem = 0;    editMenuRec.undoItem = 0;        MakeSureWeHaveJob(tew);    result = GXJobDefaultFormatDialog(tew-&gt;job,&amp;editMenuRec);    err = GXGetJobError(tew-&gt;job);      EnableAllMenus(oldMenus);    }  else#endif    {    if(gAppPageSetupProc)      (*gAppPageSetupProc)(n,menuItem,menuRef);    }  }void BEPrint(short n, short menuItem, short menuRef)  {  OSErr err;  PicHandle picH;  Rect pictR,centeredR,pageR;  Point p;  Str255 s;  long oldMenus;#ifdef BigEasyGXPrinting  TEasyWindow *tew;  gxFormat format;  gxTranslationStatistic stats;  gxRectangle pageSize,paperSize;  gxDialogResult result;  gxEditMenuRecord editMenuRec;  gxShape sh;  tew = GoodWNum(n);  if(tew-&gt;flags &amp; wPrintDraw)    {    oldMenus = DisableAllMenus();      editMenuRec.editMenuID = 0;    editMenuRec.cutItem = 0;     editMenuRec.copyItem = 0;    editMenuRec.pasteItem = 0;    editMenuRec.clearItem = 0;    editMenuRec.undoItem = 0;        MakeSureWeHaveJob(tew);    result = GXJobPrintDialog(tew-&gt;job,&amp;editMenuRec);    err = GXGetJobError(tew-&gt;job);      picH = GetWindowPICT(tew);      pictR = (**picH).picFrame;    p.h = p.v = 0;    /*      * Center the image in the page rectangle      */    format = GXGetJobFormat(tew-&gt;job,1);    GXGetFormatDimensions(format,&amp;pageSize,&amp;paperSize);    pageR.top = pageSize.top &gt;&gt; 16;    pageR.bottom = pageSize.bottom &gt;&gt; 16;    pageR.left = pageSize.left &gt;&gt; 16;    pageR.right = pageSize.right &gt;&gt; 16;    centeredR = pictR;    OffsetRect(&amp;centeredR,        (pageR.left + pageR.right - pictR.left - pictR.right + 1) &gt;&gt; 1,        (pageR.top + pageR.bottom - pictR.top - pictR.bottom + 1) &gt;&gt; 1);      sh = GXConvertPICTToShape(picH, gxDefaultOptionsTranslation, &amp;pictR, &amp;centeredR, p, nil, &amp;stats);      GetWTitle(tew-&gt;wWindow,s);      GXStartJob(tew-&gt;job,s,0);    err = GXGetJobError(tew-&gt;job);    GXPrintPage(tew-&gt;job,1,nil,sh);    err = GXGetJobError(tew-&gt;job);    GXFinishJob(tew-&gt;job);    err = GXGetJobError(tew-&gt;job);    GXDisposeShape(sh);      EnableAllMenus(oldMenus);    }#endif    {    if(gAppPageSetupProc)      (*gAppPageSetupProc)(n,menuItem,menuRef);    }  }/*----------------  Menu Action Routines----------------*/Boolean DoKeyPress(long k)  {  register long thePoint;  register Boolean didIt;  thePoint = MenuKey((char)k);  didIt = (thePoint&gt;&gt;16) != 0;  if(didIt)    MenuPoint(thePoint);  return didIt;  }  void MenuClick(Point p)  {  KeyMap   theKeys;  Boolean  putBack = false;  short  oldID;    if (phantomMenuH) {  GetKeys(theKeys);        if ((theKeys[1]&amp;4) == 0) {      putBack = true;      oldID = (**phantomMenuH).menuID;      DeleteMenu( oldID );      }    }  MenuPoint(MenuSelect(p));  if (putBack)    {    InsertMenu(phantomMenuH,oldID);    }  }void MenuPoint(long theclick)  {  register short mID,mItem;  char DAname[30];  short wNum;  TEasyWindow *thisWindow;  register beMenuProcPtr aProc;  register TEasyMenuItem *emi;  mID = theclick&gt;&gt;16;  mItem = theclick &amp; 0xffff;  if(mID == 0) return;  if(mID == 1)              /* Apple menu */    {    if(mItem == 1)            /* Its either the about box */      DoMyAbout();    else        {                  /* Or a DA */      GetItem(gMenuHandleList[1],mItem,(StringPtr)DAname);      OpenDeskAcc((StringPtr)DAname);      }    }  else    {    wNum = gLastFrontWindowNumber;    thisWindow = GoodWNum(wNum);    if(thisWindow)                  /* if one of our window in front, setport  */      SetPort(thisWindow-&gt;wWindow);    emi = &amp;gMenu[mID][0];    aProc = emi-&gt;proc;    if(aProc)                    /* call the menu's routine, if any    */      (*aProc)(wNum,mItem,gMenu[mID][mItem].ref);    emi = &amp;gMenu[mID][mItem];    aProc = emi-&gt;proc;    if(aProc)                    /* call the item's routine, if any    */      (*aProc)(wNum,mItem,emi-&gt;ref);    }  HiliteMenu(0);  }char dAbout[] = &quot;\pAbout &quot;;void StartMenus(void)/* * Start with just an About box, and some DA's. */  {  char aboutS[255];  MenuHandle applemenu;  BlockMove(&amp;dAbout[0],aboutS,dAbout[0]+1);      /* &quot;About&quot; */  BlockMove((StringPtr )0x910 + 1,aboutS + aboutS[0] + 1, *(StringPtr )0x910); /* ProgName */  aboutS[0] += *((StringPtr )0x910);  aboutS[aboutS[0] + 1] = '\xC9';  aboutS[0]++;  applemenu = NewMenu(1,(StringPtr)&quot;\p &quot;);        /* Apple menu: ID 1          */  AppendMenu(applemenu,(StringPtr)aboutS);  AppendMenu(applemenu,(StringPtr)&quot;\p(-&quot;);  AddResMenu(applemenu,'DRVR');  InsertMenu(applemenu,0);  DrawMenuBar();  gMenuHandleList[1] = applemenu;  gMenu[1][0].enable = true;  gMenuCount = 1;            /* Next menu added will be ID 2    */  gCurrentMenu = 1;  gMenuLength[1] = 0;          /* No items, really, in Apple menu    */  }MenuHandle InstallMenu(StringPtr s,beMenuProcPtr action,short ref)/* * Start a new menu with name s */  {  register TEasyMenuItem *emi;  register MenuHandle mh;  gMenuCount++;                /* new menu            */  gCurrentMenu = gMenuCount;  if(*s &gt; kMenuNameMax-1)    *s = kMenuNameMax-1;  gMenuLength[gCurrentMenu] = 0;  mh = NewMenu(gCurrentMenu,(StringPtr)s);  gMenuHandleList[gCurrentMenu] = mh;  InsertMenu(mh,0);  emi = &amp;gMenu[gCurrentMenu][0];  emi-&gt;enable = ref &gt;= 0;  if(!emi-&gt;enable)    {    DisableItem(mh,0);    ref =- ref;    }  emi-&gt;proc = action;  emi-&gt;ref = ref;  gInvalidMenuBar = true;          /* redraw soon */  BlockMove(s,gMenuName[gCurrentMenu],*s+1);  return mh;  }static Str255 dQuitString = &quot;\pQuit &quot;;#define kQuitLength 5static Str15 dQuitCmdKey = &quot;\p/Q&quot;;void InstallQuitItem(beMenuProcPtr action,short ref)  {  short i,j;  StringPtr w;  i = kQuitLength;  w = (StringPtr)0x910;  j = *w++;  while(j--)    dQuitString[++i] = *w++;  w = dQuitCmdKey;  j = *w++;  while(j--)    dQuitString[++i] = *w++;  dQuitString[0] = i;  InstallMenuItem(dQuitString,action,ref);  }void InstallMenuItem(StringPtr s,beMenuProcPtr action,short ref)/* * Add an item to the last menu, and associate a routine with it. */  {  register MenuHandle mh;  register TEasyMenuItem *emi;  register short item;  mh = gMenuHandleList[gCurrentMenu];  gMenuLength[gCurrentMenu]++;  item = gMenuLength[gCurrentMenu];  emi = &amp;gMenu[gCurrentMenu][item];  if (ref &lt; 0)    {    DisableItem(mh,item);    ref =- ref;    emi-&gt;enable = 0;    }  else    emi-&gt;enable = 1;  AppendMenu(mh,(StringPtr)s);  emi-&gt;proc = action;  emi-&gt;ref = ref;  emi-&gt;mark = 0;  if(*(s+*s-1) == '/')    emi-&gt;cmdEquiv = *(s+*s);  else    emi-&gt;cmdEquiv = 0;  }void RemoveMenuItem(short ref)/* * Remove all menu items with * refcon ref. */  {  short menu;  short item;  for(menu = 1; menu &lt;= gMenuCount; menu++)    for(item = gMenuLength[menu]; item &gt; 0; item--)      {      if(gMenu[menu][item].ref == ref)        DeleteIndexedMenuItem(menu,item);      }  }void DeleteIndexedMenuItem(short menu,short item)  {  StringPtr oldStrings;  MenuHandle mh;  short i;  short itemCount;  register TEasyMenuItem *emi;  register StringPtr w;  itemCount = gMenuLength[menu];  mh = gMenuHandleList[menu];  oldStrings = (StringPtr)NewPtrClear(256 * (itemCount));  FailNil((long)oldStrings);  for(i = 1; i&lt;=itemCount; i++)    GetItem(mh,i,(StringPtr)&amp;oldStrings[(i-1)*256]);  DeleteMenu(menu);  DisposeMenu(mh);  mh = NewMenu(menu,(StringPtr)gMenuName[menu]);  emi = &amp;gMenu[menu][1];  w = oldStrings;  for(i = 1; i&lt;=itemCount; i++)    {    if(i != item)      {      if(emi-&gt;cmdEquiv)        {        *(w+*w+1) = '/';        *(w+*w+2) = emi-&gt;cmdEquiv;        *w = *w + 2;        }      AppendMenu(mh,(StringPtr)w);      }    emi++;    w += 256;    }  emi = &amp;gMenu[menu][item];  for(i = item; i&lt;itemCount; i++)    {    *emi = *(emi+1);    emi++;    }  gMenuLength[menu]--;  itemCount--;  emi = &amp;gMenu[menu][1];  for(i = 1; i&lt;=itemCount; i++)    {    if(!emi-&gt;enable)      DisableItem(mh,i);    if(emi-&gt;mark)      SetItemMark(mh,i,emi-&gt;mark);    emi++;    }  InsertMenu(mh,menu+1);  DisposPtr((Ptr)oldStrings);  }void InstallEditMenu(beWNumCallProcPtr Xundo,    beWNumCallProcPtr Xcut,    beWNumCallProcPtr Xcopy,    beWNumCallProcPtr Xpaste,    beWNumCallProcPtr Xclear)  /*   * Start an edit menu, and put the first six things in.   */  {  gAppUndoProc = Xundo;  gAppCutProc = Xcut;  gAppCopyProc = Xcopy;  gAppPasteProc = Xpaste;  gAppClearProc = Xclear;  InstallMenu(&quot;\pEdit&quot;,nil,0);  InstallMenuItem(&quot;\px/Z&quot;,(beMenuProcPtr)BEUndo,-mUndo);      /* barfs because it is static */  InstallMenuItem(&quot;\p(-&quot;,(beMenuProcPtr)BENull,0);  InstallMenuItem(&quot;\px/X&quot;,(beMenuProcPtr)BECut,-mCut);  InstallMenuItem(&quot;\px/C&quot;,(beMenuProcPtr)BECopy,-mCopy);  InstallMenuItem(&quot;\px/V&quot;,(beMenuProcPtr)BEPaste,-mPaste);  InstallMenuItem(&quot;\px/B&quot;,(beMenuProcPtr)BEClear,-mClear);  gMenuEdit = gMenuHandleList[gCurrentMenu];  EnDisEdits(-1,-1,-1,-1,-1);  }void InstallPrintItems(beMenuProcPtr pageSetup,beMenuProcPtr print)  {  gAppPageSetupProc = pageSetup;  gAppPrintProc = print;  InstallMenuItem(&quot;\pPage Setup\xC9/&sup1;&quot;,(beMenuProcPtr)BEPageSetup,-mPageSetup);  InstallMenuItem(&quot;\pPrint\xC9/P&quot;,(beMenuProcPtr)BEPrint,-mPrint);  }void SetMenuItem(short ref,char enable,char isMarked,char mark,StringPtr s)/*  * Set all items with the reference number to the  * enable/disable state, with mark, and name s.  * pass enable + to enable, - to disable, and  * zero to leave alone.  */  {  short m,i;  MenuHandle mh;  register TEasyMenuItem *emi;  for(m=1; m&lt;=gMenuCount; m++)    {    mh = gMenuHandleList[m];    for(i=gMenuLength[m]; i&gt;=0; i--)      {      emi = &amp;gMenu[m][i];      if(emi-&gt;ref == ref)        {        if(enable)          {          if(!i)            gInvalidMenuBar = true;          if(enable &gt; 0)            {            emi-&gt;enable = 1;            EnableItem(mh,i);            }          else            {            emi-&gt;enable = 0;            DisableItem(mh,i);            }          }        if(i &gt; 0)          /* these only apply to items */          {          if(isMarked)            if(isMarked &gt; 0)              {              emi-&gt;mark = mark;              SetItemMark(mh,i,mark);              //CheckItem(mh,i,true);              }            else              {              emi-&gt;mark = 0;              SetItemMark(mh,i,0);              }          if(s)            SetItem(mh,i,(StringPtr)s);          }        }      }    }  }void EnDisEdits(short Eundo,short Ecut,short Ecopy,short Epaste,short Eclear)/* * For each edit menu entry, * -1=disable, 1=enable, 0=leave alone. */  {  SetMenuItem(mUndo,Eundo,false,0,&quot;\pUndo&quot;);  SetMenuItem(mCut,Ecut,false,0,&quot;\pCut&quot;);  SetMenuItem(mCopy,Ecopy,false,0,&quot;\pCopy&quot;);  SetMenuItem(mPaste,Epaste,false,0,&quot;\pPaste&quot;);  SetMenuItem(mClear,Eclear,false,0,&quot;\pClear&quot;);  }MenuHandle SetCurrentMenu(short ref)/* * Set which menu will take * future &quot;InstallMenuItem&quot;s. */  {  register short i;  for(i = 0; i&lt;gMenuCount; i++)    {    if(gMenu[i][0].ref == ref)      {      gCurrentMenu = i;      return gMenuHandleList[i];      }    }  return 0;  }long DisableAllMenus(void)/* * Disable all menus, as for a modal dialog, * and return a long with the masks of which should get reenabled. */  {  long result;  long mask;  TEasyMenuItem *emi;  short i;  result = 0;  mask = 1;  for(i = 0; i&lt;kMMax; i++)    {    emi = &amp;gMenu[i][0];    if(emi-&gt;enable)      {      DisableItem(gMenuHandleList[i],0);      result |= mask;      }    mask &lt;&lt;= 1;    }  DrawMenuBar();  return result;  }void EnableAllMenus(long saveMenus)/* * Enable menus according to the mask returned by DisableAllMenus(). */  {  long mask;  short i;  mask = 1;  for(i = 0; i&lt;kMMax; i++)    {    if(saveMenus &amp; mask)      EnableItem(gMenuHandleList[i],0);    mask &lt;&lt;= 1;    }  DrawMenuBar();  }short ScanWindowList(WindowPtr w)/*  * return a window number from a WindowPeek,  * or -1 if no known window.  */  {  short i;  TEasyWindow *wo;  wo= &amp;gEasyWindowList[0];  for(i=0; i&lt;gEasyWindowListSize; i++)    {    if (wo-&gt;wUsed &amp;&amp; (wo-&gt;wWindow==w))      return i;    wo++;    }  return -1;  }/*----------------  Mouse Action Routines----------------*/void DoMouseClick(EventRecord *event)  {  WindowPtr w;  short part;  register short wNum;  register TEasyWindow *thisEasyWindow;  Point p;  Rect r;  Boolean tookEvent;  p = event-&gt;where;  part = FindWindow (p, &amp;w);  wNum = ScanWindowList(w);  thisEasyWindow = GoodWNum(wNum);  switch (part)    {    case inDesk:      break;    case inMenuBar:      MenuClick(p);      break;        case inSysWindow:      SystemClick(event,w);      break;        case inContent:    contentClick:      if (w != FrontWindow())        /* If clicked on a non-front window, */        SelectWindow(w);              /* bring it to the front. */      else if(thisEasyWindow)              /* Click on front window: give click */        {                    /* to window's click routine. */        SetPort(w);        GlobalToLocal(&amp;p);        ClipRect(&amp;gBigRect);        SetOrigin(0,0);        if(thisEasyWindow &amp;&amp; thisEasyWindow-&gt;wEventProc)          (*thisEasyWindow-&gt;wEventProc)(wNum,event,&amp;tookEvent);        else          tookEvent = false;        if(!tookEvent)          {          register beClickProcPtr fp;          fp = thisEasyWindow-&gt;wClickProc;          if(fp)            (*fp)(wNum,p,                event-&gt;modifiers);          }        }      break;    case inDrag:      if(((thisEasyWindow-&gt;flags &amp; wCoolDrag)!=0)          ^ ((event-&gt;modifiers &amp; optionKey)!=0))        {        gCoolDragPoint = event-&gt;where;        gCoolDragState = 1;        gCoolDragEW = thisEasyWindow;        gCoolDragWindowNumber = wNum;        if(!(event-&gt;modifiers &amp; 256))          SelectWindow(w);        }      else        if(Button())                /* for quick title-bar clicks */          {          beMoveWindowProcPtr fp;          DragWindow(w,event-&gt;where,&amp;gBigRect);          fp = thisEasyWindow-&gt;wMoveWindowProc;          if(fp)            (fp)(wNum);                    }        else          SelectWindow(w);      break;    case inGrow:      if(thisEasyWindow &amp;&amp; (thisEasyWindow-&gt;flags &amp; wGrowable))        {        long oldSize,newSize;        beGrowWindowProcPtr fp;        beResizeProcPtr rsfp;                SetPort(w);        GetGrowRect(w,&amp;r);        InvalRect(&amp;r);        fp = thisEasyWindow-&gt;wGrowWindowProc;        if(fp)          (*fp)(&amp;newSize,wNum,w,event-&gt;where,&amp;gResizeLim);        else          newSize = GrowWindow(w,event-&gt;where,&amp;gResizeLim);        if(newSize)          {          rsfp = thisEasyWindow-&gt;wResizeProc;          if(rsfp)            {            oldSize = ((long)(w-&gt;portRect.bottom-w-&gt;portRect.top)&lt;&lt;16) |                (w-&gt;portRect.right-w-&gt;portRect.left);            (*rsfp)(wNum,(Point *)&amp;oldSize,(Point *)&amp;newSize,event-&gt;modifiers);            }          else            SizeWindow(w,newSize&amp;0xffff,newSize&gt;&gt;16,1);          GetGrowRect(w,&amp;r);          InvalRect(&amp;r);          }        }      else        goto contentClick;      break;    case inGoAway:      if(thisEasyWindow)        if (TrackGoAway(w,event-&gt;where))          {          beGoAwayProcPtr fp;                    fp = thisEasyWindow-&gt;wGoAwayProc;          if(fp)            (*fp)(wNum);          }      break;    /*     * The following way to handle zoom only     * applies to zooming to 1 state.  This does     * not handle zooming in and out between 2     * states.  Check IM IV.     */    case inZoomIn:  /* zoomBox */    case inZoomOut:      if(thisEasyWindow)        {        if (TrackBox(w,event-&gt;where,part))          {          beWNumCallProcPtr fp;                    fp = thisEasyWindow-&gt;wZoomProc;          if(fp)            (*fp)(wNum);          }        }      break;    }  }/*----------------  Window Action Routines----------------*/WindowPtr InstallWindow(short iNum,StringPtr iTitle,Rect *iRect,short iType,short iFlags,    beUpdateProcPtr iUpdate,beClickProcPtr iClick,beKeyProcPtr iKey,beGoAwayProcPtr iGoAway,    beActivateProcPtr iActivate,beDeactivateProcPtr iDeactivate,beIdleProcPtr iIdle)/* * Add a window to BigEasy's list. If the window is * already up somewhere, bring it to the front and * visualize it. */  {  TEasyWindow *thisWindow;  Rect stagRect,**oldPos;  Boolean isVisible;  RgnHandle rh;  KeyMap km;  Boolean opt;  GetKeys(km);  opt =km[58/8] &amp;  (1&lt;&lt; (58%8) );  isVisible = iNum&gt;0;  if(!isVisible)    iNum = -iNum;  EnoughEasyWindows(iNum);      /* Make sure there's space for new one    */  thisWindow = &amp;gEasyWindowList[iNum];  if (thisWindow-&gt;wUsed)        /* something already assigned to this window? */    {    Show(iNum);    goto goHome;    }  oldPos = (Rect **)Get1Resource(kWinPosType,iNum);  /* attempt to find saved window position    */  stagRect = *iRect;  if(oldPos &amp;&amp; !opt)                  /* (option key &quot;forgets&quot; old window */    OffsetRect(&amp;stagRect,        (**oldPos).left - stagRect.left,(**oldPos).top - stagRect.top);    {    Rect lilRect;    lilRect.top = stagRect.top - 10;    lilRect.left = stagRect.left + 4;    lilRect.bottom = lilRect.top + 1;    lilRect.right = lilRect.left + 1;    rh = NewRgn();    RectRgn(rh,&amp;lilRect);    SectRgn(rh,*(RgnHandle *)0x9EE,rh);    if(EmptyRgn(rh) &amp;&amp; gWindowsInView)      OffsetRect(&amp;stagRect,50 - iRect-&gt;left,80 - iRect-&gt;top);    if(gStaggerWindows)      {      gStagX = (gStagX + gStagStepX)%kStagLimX;      gStagY = (gStagY + gStagStepY)%kStagLimY;      OffsetRect(&amp;stagRect,gStagX,gStagY);      }    DisposeRgn(rh);    }  thisWindow-&gt;wUsed = 1;  if(gHasColor)    thisWindow-&gt;wWindow = NewCWindow(0,&amp;stagRect,(StringPtr)iTitle,isVisible,        ((iFlags &amp; wZoomable) != 0) ? zoomDocProc : iType,        (WindowPtr)-1,iGoAway!=0,0);  else    thisWindow-&gt;wWindow = NewWindow(0,&amp;stagRect,(StringPtr)iTitle,isVisible,        ((iFlags &amp; wZoomable) != 0) ? zoomDocProc : iType,        (WindowPtr)-1,iGoAway!=0,0);  SetPort(thisWindow-&gt;wWindow);  thisWindow-&gt;flags = iFlags;  thisWindow-&gt;iNum = iNum &lt; 0 ? -iNum : iNum;  thisWindow-&gt;wUpdateProc = iUpdate;  thisWindow-&gt;wClickProc = iClick;  thisWindow-&gt;wKeyProc = iKey;  thisWindow-&gt;wGoAwayProc = iGoAway;  thisWindow-&gt;wZoomProc = nil;  thisWindow-&gt;wActivateProc = iActivate;  thisWindow-&gt;wDeactivateProc = iDeactivate;  thisWindow-&gt;wIdleProc = iIdle;  thisWindow-&gt;wResizeProc = nil;  thisWindow-&gt;wGrowWindowProc = nil;  thisWindow-&gt;wMoveWindowProc = nil;  thisWindow-&gt;wEventProc = nil;#ifdef BigEasyGXPrinting  thisWindow-&gt;job = nil;#endifgoHome:  return thisWindow-&gt;wWindow;  }#ifdef BigEasyGXPrintingvoid MakeSureWeHaveJob(TEasyWindow *thisWindow)  {  if(!thisWindow-&gt;job)    if((thisWindow-&gt;flags &amp; wPrintDraw) &amp;&amp; gHasGX)      {      GoWatch();      GXNewJob(&amp;thisWindow-&gt;job);      GoArrow();      }  }#endifvoid UninstallWindow(short iNum)  {  register TEasyWindow *thisWindow;  register beDeactivateProcPtr fp;  gCoolDragState = 0;          /* just in case we were dragging the dissappeared window */  if(!(thisWindow = GoodWNum(iNum)))    return;  SetPort(thisWindow-&gt;wWindow);  fp = thisWindow-&gt;wDeactivateProc;  if(fp)    (*fp)(iNum);  CloseWindow(thisWindow-&gt;wWindow);  EnDisEdits(-1,-1,-1,-1,-1);#ifdef BigEasyGXPrinting  if((thisWindow-&gt;flags &amp; wPrintDraw) &amp;&amp; gHasGX)    GXDisposeJob(thisWindow-&gt;job);#endif  thisWindow-&gt;wUsed = 0;  }void Show(short iNum)  {  register TEasyWindow *thisWindow;  thisWindow = GoodWNum(iNum);  if(thisWindow)    {    if(!((WindowPeek)(thisWindow-&gt;wWindow))-&gt;visible)  /* If so, just show it, and bring it to the front. */      ShowWindow(thisWindow-&gt;wWindow);    SelectWindow(thisWindow-&gt;wWindow);    }  }void Hide(short iNum)/*  * Just do HideWindow to the  * specified window number.  */  {  register TEasyWindow *thisWindow;  gCoolDragState = 0;                  /* It might have been this window */  thisWindow = GoodWNum(iNum);  if(thisWindow)    HideWindow(thisWindow-&gt;wWindow);  }  void GetWindowRect(short n,Rect *r)/*  * return the window's current rectangle  * in global co\x9Ardinate space.  */  {  TEasyWindow *thisWindow;  WindowPtr g;  if(!(thisWindow = GoodWNum(n)))    return;  if(thisWindow-&gt;wUsed)    {    g = thisWindow-&gt;wWindow;    SetPort(g);    *r = g-&gt;portRect;    LocalToGlobal((Point *)r);    LocalToGlobal((Point *)( (char*)r + 4));    }  }    WindowPtr GetWindowPtr(short n)/*  * return the windowptr for  * the specified window number  */  {  TEasyWindow *thisWindow;  WindowPtr g;  if(!(thisWindow = GoodWNum(n)))    g = 0;  else    g = thisWindow-&gt;wWindow;  return g;  }Boolean GetWindowVisible(short n)/*  * return true if the window exists,  * and is visible, or false if its invisible  * or doesn't exist.  */  {  register WindowPtr g;  g = GetWindowPtr(n);  if(g)    return ((WindowPeek)g)-&gt;visible;  else    return false;  }void SaveWindowPosition(short n)/*  * Save the position of window number n,  * or all windows if n = -1;  */  {  Rect **rH;  register Rect *r;  register short i;  register short n1,n2;  TEasyWindow *thisWindow;  rH = (Rect **)NewHandleClear(sizeof(Rect));  FailNil((long)rH);  HLock((Handle)rH);  r = *rH;  if(n &lt; 0)    {    n1 = 0;    n2 = gEasyWindowListSize-1;    }  else    n1 = n2 = n;  for(i = n1; i&lt;=n2; i++)    {    thisWindow = GoodWNum(i);    if(thisWindow &amp;&amp; thisWindow-&gt;wUsed)      {      GetWindowRect(i,r);      if( !((WindowPeek)(thisWindow-&gt;wWindow))-&gt;visible )        SwapShort(r-&gt;left,r-&gt;right);      Replace1Resource((Handle)rH,kWinPosType,i);      }    }  DisposHandle( (Handle)rH );  }void ForgetWindowPosition(short n)/*  * Forget the saved window position n,  * or all windows if n&lt;0.  */  {  register short i;  register short n1,n2;  register TEasyWindow *thisWindow;  if(n &lt; 0)    {    n1 = 0;    n2 = gEasyWindowListSize-1;    }  else    n1 = n2 = n;  for(i = n1; i&lt;=n2; i++)    {    thisWindow = GoodWNum(i);    if(thisWindow &amp;&amp; thisWindow-&gt;wUsed)      Replace1Resource(0,kWinPosType,i);    }  }void Replace1Resource(Handle h,long type,short id)/*  * This is AddResource with a  * RmveResource if necessary.  * Pass h==nil to delete the resource.  */  {  Handle old;  /*   * A lame hack to prevent writing resources   * to a lightspeed project file.   */  if( *(StringPtr)(0x910 + (*(StringPtr)0x910)) == '&sup1;')    {    /* do nothing */    }  else    {    old = Get1Resource(type,id);    if(old)      RemoveResource(old);    if(h)      {      AddResource(h,type,id,(StringPtr)&quot;\p&quot;);      WriteResource(h);      DetachResource(h);      }    }  }void CheckMenubar(void)  {  if(gInvalidMenuBar)    {    DrawMenuBar();    gInvalidMenuBar = false;    }  }/*----------------  Event Routines----------------*/Boolean HandleUpdateEvent(EventRecord *er)/* * Update the appropriate window, if we know who it is. */  {  Boolean result;  short wNum;  TEasyWindow *thisEasyWindow;  WindowPtr w;  GrafPtr oldPort;  GetPort(&amp;oldPort);  result = false;  if(er-&gt;what != updateEvt)    {    result = false;    goto goHome;    }  w = (WindowPtr)er-&gt;message;  wNum = ScanWindowList(w);          /* other than null or click, scan list    */  thisEasyWindow = GoodWNum(wNum);      /* and get record          */  if(thisEasyWindow)    {    Rect visBounds;    beUpdateProcPtr fp;    SetPort(w);    BeginUpdate(w);      result = true;    visBounds = (**w-&gt;visRgn).rgnBBox;    fp = thisEasyWindow-&gt;wUpdateProc;    if(fp)      {      SetPort(thisEasyWindow-&gt;wWindow);          /* Set port to window  */      (*fp)(wNum);      /* Call drawing proc    */      }    SetOrigin(0,0);    if (thisEasyWindow-&gt;flags &amp; wGrowable)      /* Draw growbox, if...  */      MyDrawGrowIcon(w);    ClipRect(&amp;gBigRect);    DrawControls(w);    EndUpdate(w);    }  else    result = false;goHome:  SetPort(oldPort);  return result;  }Boolean ActivateWindow(WindowPtr w, Boolean activate)  {  Boolean result;  short wNum;  TEasyWindow *thisEasyWindow;  GrafPtr oldPort;  GetPort(&amp;oldPort);  wNum = ScanWindowList(w);          /* other than null or click, scan list    */  thisEasyWindow = GoodWNum(wNum);      /* and get record          */  if(!thisEasyWindow)    {    result = false;    goto goHome;    }  result = true;  FrontDAEdits();  if(thisEasyWindow)    {    SetPort(thisEasyWindow-&gt;wWindow);    if(activate)      {      beActivateProcPtr fp;      short copyItem,printItems;      if(thisEasyWindow-&gt;flags &amp; wCopyDraw)        copyItem = 1;      else        copyItem = -1;      EnDisEdits(-1,-1,copyItem,-1,-1);      if(((thisEasyWindow-&gt;flags &amp; wPrintDraw) &amp;&amp; gHasGX)          || (gAppPageSetupProc &amp;&amp; gAppPrintProc) )        printItems = 1;      else        printItems = -1;      SetMenuItem(mPageSetup,printItems,0,0,nil);      SetMenuItem(mPrint,printItems,0,0,nil);      fp = thisEasyWindow-&gt;wActivateProc;      if(fp)        (*fp)(wNum);      }    else      {      beDeactivateProcPtr fp;                  EnDisEdits(-1,-1,-1,-1,-1);      SetMenuItem(mPageSetup,-1,0,0,nil);      SetMenuItem(mPrint,-1,0,0,nil);      fp = thisEasyWindow-&gt;wDeactivateProc;      if(fp)        (*fp)(wNum);      }    InitCursor();    if (thisEasyWindow-&gt;flags &amp; wGrowable)      /* Draw growbox, if...  */      MyDrawGrowIcon(w);    }goHome:  SetPort(oldPort);  return result;  }Boolean HandleActivateEvent(EventRecord *er)/* * Handle it, if we can find out who it is. */  {  Boolean result;  result = true;  switch(er-&gt;what)    {    case activateEvt:      ActivateWindow((WindowPtr)er-&gt;message,er-&gt;modifiers &amp; 1);      break;        case kOSEvent:      switch ((unsigned long) er-&gt;message &gt;&gt; 24)  /*  high byte of message  */        {         case kSuspendResumeMessage:          ActivateWindow(FrontWindow(),er-&gt;modifiers &amp; 1);          break;        default:          result = false;          break;        }      break;    default:      result = false;      break;    }goHome:  return result;  }void EventLoop(void)  {  EventRecord er;  short i;  register short wNum;  WindowPtr w;  register TEasyWindow *thisEasyWindow;  Boolean tookKey,tookEvent;  CheckMenubar();  WaitNextEvent(0xffff,&amp;er,gSleep,nil);    {    gLastModifiers = er.modifiers;    gLastEventTime = er.when;    if(er.what &gt; 5 &amp;&amp; er.what &lt; 12)          /* update event or higher: in message  */      w = (WindowPtr)er.message;    else      w = FrontWindow();              /* else, use FrontW          */    if(er.what &gt; 1)      {      wNum = ScanWindowList(w);          /* other than null or click, scan list    */      thisEasyWindow = GoodWNum(wNum);      /* and get record          */      }    else      thisEasyWindow = 0;    SetPort(w);    if(thisEasyWindow &amp;&amp; thisEasyWindow-&gt;wEventProc)      (*thisEasyWindow-&gt;wEventProc)(wNum,&amp;er,&amp;tookEvent);    else      tookEvent = 0;    if(!tookEvent)      switch (er.what)        {        case 0:  /* null event */          break;          case mouseDown:          FrontDAEdits();          DoMouseClick(&amp;er);          break;          case keyDown:        case autoKey:          FrontDAEdits();            tookKey = false;          if( (!gMenuNeedsCmdKey) || (er.modifiers &amp; 256) )            tookKey = DoKeyPress(er.message);            if(!tookKey &amp;&amp; ((!gMenuNeedsCmdKey) || (er.modifiers &amp; 256)) )            tookKey = CoolBigEasyCmdKeys(er.message &amp; 0xFF);            if(!tookKey)            if(thisEasyWindow)              {              beKeyProcPtr fp;                            fp = thisEasyWindow-&gt;wKeyProc;              if(fp)                {                SetPort(thisEasyWindow-&gt;wWindow);        /* Set port to window  */                (*fp)(wNum,      /* Call key proc    */                    (short)(er.message&amp;0xff),      /* with the key */                    (short)((er.message&gt;&gt;8)&amp;0xff),    /* the key code */                    er.modifiers);            /* and the modifiers */                }              }          break;          case updateEvt:          HandleUpdateEvent(&amp;er);          break;          case activateEvt:          HandleActivateEvent(&amp;er);          break;          case kOSEvent:          switch ((unsigned long) er.message &gt;&gt; 24)  /*  high byte of message  */            {             case kSuspendResumeMessage:              if(thisEasyWindow)          /* just like activate event... */                {                ActivateWindow(FrontWindow(),                    er.message &amp; kResumeMask);                }            break;            }          break;          case kHighLevelEvent:          AEProcessAppleEvent(&amp;er);          break;        case diskEvt:          if (er.message &amp; 0xffff0000) {            Point where = {100,100};          //  DIBadMount(where, er.message);          }          break;          default:          /*Debugger();/**/          ;        }    }  /*    * See if we're doing a fake cool drag-window    */  if(gCoolDragState)    {    Point p,q;    SetPort(gCoolDragEW-&gt;wWindow);    GetMouse(&amp;p);    LocalToGlobal(&amp;p);    if( (p.v!=gCoolDragPoint.v) || (p.h!=gCoolDragPoint.h) )      {      q.h = gCoolDragEW-&gt;wWindow-&gt;portRect.left;      q.v = gCoolDragEW-&gt;wWindow-&gt;portRect.top;      LocalToGlobal(&amp;q);      MoveWindow(gCoolDragEW-&gt;wWindow,          q.h+p.h-gCoolDragPoint.h,          q.v+p.v-gCoolDragPoint.v,0);      gCoolDragPoint = p;        {        beMoveWindowProcPtr fp;        fp = gCoolDragEW-&gt;wMoveWindowProc;        if(fp)          (fp)(gCoolDragWindowNumber);                  }      }    if(!Button())      gCoolDragState = 0;    }  SystemTask();  w = FrontWindow();  if ( w == gLastFrontIdle)          /* Minor optimization, wins if the same    */    wNum = gLastFrontWindowNumber;    /* window is frontmost for a while.      */  else    {    wNum = ScanWindowList(w);    gLastFrontIdle = w;    gLastFrontWindowNumber = wNum;    }  if(er.what != mouseDown &amp;&amp; er.what != activateEvt &amp;&amp; !gQuitApp)  /* anything but a mousedown or [de]activate */    {    gIdleSeed ++;    if(gIdleSeed &amp; 1)  /* every other chance... */      for(i = 1; i&lt;gEasyWindowListSize; i++)        {        if(gEasyWindowList[i].wUsed &amp;&amp; gEasyWindowList[i].wIdleProc)          {          SetPort(gEasyWindowList[i].wWindow);          (*gEasyWindowList[i].wIdleProc)              ((short)i,(Boolean)(w == gEasyWindowList[i].wWindow));          }        }    }  if (gMasterIdleProc &amp;&amp; !gQuitApp)    (*gMasterIdleProc)();  }Boolean CoolBigEasyCmdKeys(short key)  {  WindowRecord *w;  switch(key)    {    /*     * Rotate active window     */    case 9:    /* &lt;tab&gt; */      w = *(WindowRecord **)0x9D6;    /* windowlist */      if(w)        {        while (w-&gt;nextWindow)          w = w-&gt;nextWindow;        SelectWindow((WindowPtr)w);        }      break;    default:      return false;    }  return true;  }void IdleWindow(short n)/* * Idle window number n, or * -1 to idle all windows. */    {  register short i;  short lo,hi;  WindowPtr w;  register TEasyWindow *ew;  GrafPtr oldPort;  GetPort(&amp;oldPort);  if(n&lt;0)    {    lo = 1;    hi = gEasyWindowListSize;    }  else    {    lo = n;    hi = n + 1;    }  w = FrontWindow();  ew = &amp;gEasyWindowList[lo];  for(i = lo; i &lt; hi; i++)    {    if(ew-&gt;wUsed &amp;&amp; ew-&gt;wIdleProc)      {      SetPort(ew-&gt;wWindow);      (*ew-&gt;wIdleProc)((short)i,ew-&gt;wWindow == w);      }    ew++;    }  SetPort(oldPort);  SystemTask();  }  void MyDrawGrowIcon(WindowPtr w)  {  Rect r;  SetPort(w);  GetGrowRect(w,&amp;r);  ClipRect(&amp;r);  DrawGrowIcon(w);  ClipRect(&amp;gBigRect);  }void SetMasterOpenAppProc(beOpenAppProcPtr openAppProc)  {  gMasterOpenAppProc = openAppProc;  if(gHasAppleEvents)    AEInstallEventHandler(kCoreEventClass, kAEOpenApplication,        (AEEventHandlerUPP)BigEasyOpenAppThang, 0, false);  }void SetMasterOpenDocProc(beOpenDocProcPtr openDocProc)  {  gMasterOpenDocProc = openDocProc;  if(gHasAppleEvents)    AEInstallEventHandler(kCoreEventClass, kAEOpenDocuments,        (AEEventHandlerUPP)BigEasyOpenDocThang, 0, false);  }void SetMasterQuitAppProc(beQuitAppProcPtr quitAppProc)  {  gMasterQuitAppProc = quitAppProc;  }pascal OSErr BigEasyOpenAppThang(AppleEvent *theEvent, AppleEvent *reply,long refCon)  {  #pragma unused (reply,refCon,theEvent)  return noErr;  }pascal OSErr BigEasyOpenDocThang(AppleEvent *message, AppleEvent *reply,long refCon)  {  FSSpec fSpec;  AEDescList docList;  long index, itemsInList;  Size actualSize;  AEKeyword keywd;  DescType typeCode;  OSErr thisError;  #pragma unused (reply,refCon)  thisError = AEGetParamDesc(message, keyDirectObject, typeAEList, &amp;docList);  if(thisError)    goto goHome;  thisError = MissedAEParameters(message);  if(thisError)    goto goHome;  thisError = AECountItems(&amp;docList, &amp;itemsInList);  if(thisError)    goto goHome;  for (index = 1; index &lt;= itemsInList; index++)    {    thisError = AEGetNthPtr(&amp;docList, index, typeFSS, &amp;keywd, &amp;typeCode,          (Ptr)&amp;fSpec, sizeof(FSSpec), &amp;actualSize);    if(thisError)      goto goHome;    if(gMasterOpenDocProc)      (*gMasterOpenDocProc)(&amp;fSpec);    }  thisError = AEDisposeDesc(&amp;docList);goHome:  return thisError;  }pascal OSErr BigEasyQuitAppThang(AppleEvent *theEvent, AppleEvent *reply,long refCon)  {  OSErr thisError;  #pragma unused (reply,refCon)  thisError = MissedAEParameters(theEvent);  if (!thisError)    {    ++ gQuitApp;      if(gMasterQuitAppProc)      (*gMasterQuitAppProc)();    }  return thisError;  }OSErr MissedAEParameters (AppleEvent *message)  {  DescType typeCode;  Size actualSize;  OSErr err;  err = AEGetAttributePtr(message, keyMissedKeywordAttr, typeWildCard,      &amp;typeCode, nil, 0L, &amp;actualSize);  if (err == errAEDescNotFound)    return(noErr);  return(err = noErr ? errAEEventNotHandled : err);  }void InitBigEasy(void)  {  long result;  InstallMyExitToShell();  gMasterOpenAppProc = nil;  gMasterOpenDocProc = nil;  gMasterIdleProc = nil;  gAboutProc = nil;  gQuitApp = false;  gMenuNeedsCmdKey = true;  gStaggerWindows = true;  gWindowsInView = true;  gSleep = 0;  gInvalidMenuBar = false;  gStagStepX = 7;  gStagStepY = 7;  SetRect(&amp;gBigRect,-16000,-16000,16000,16000);  gEasyWindowListH = (TEasyWindow**)NewHandleClear(sizeof(TEasyWindow));  HLock((Handle)gEasyWindowListH);  gEasyWindowList = *gEasyWindowListH;  gEasyWindowList[0].wUsed = 0;  gEasyWindowListSize = 1;  gLastFrontIdle = (WindowPtr) 0;  gLastFrontWindowNumber = -1;  gCoolDragState = 0;/* * 7.0 Feature stuff */  gSystemVersion = (Gestalt('sysv', &amp;result)) ? 0 : result;  gHasAppleEvents = (Gestalt(gestaltAppleEventsAttr, &amp;result) ? false : result != 0);  gHasColor = (Gestalt('qdrw',&amp;result)) ?      false : (result &amp; (1&lt;&lt;gestaltHasDeepGWorlds)) != 0;  /*   * The quit-app message, if available.   */  gMasterQuitAppProc = nil;  if(gHasAppleEvents)    AEInstallEventHandler(kCoreEventClass, kAEQuitApplication,        (AEEventHandlerUPP)BigEasyQuitAppThang, 0, false);/* * GX Feature stuff */#ifdef BigEasyGXPrinting  gHasGX = WantsGX      &amp;&amp; ( (Gestalt(gestaltGXVersion,&amp;result)) ? false : true );  if(gHasGX)    {    GXEnterGraphics();    GXInitPrinting();    }#else  gHasGX = false;#endif  }static void ExitBigEasy(void)  {#ifdef BigEasyGXPrinting  if(gHasGX)    {    GXExitGraphics();    GXExitPrinting();    }#endif  }void main(void)  {#if 0#ifdef THINK_C_PROFILE  freopen(&quot;profile output&quot;,&quot;w+&quot;,stdout);  InitProfile(1000,50);#endif THINK_C_PROFILE  #endif  MaxApplZone();  MoreMasters();  MoreMasters();  InitToolbox();  StartMenus();  InitBigEasy();  Bootstrap();    #if THINK_C &gt;= 5    #if defined(STACK_KILLER) || defined(TIMING_PROFILE)      prepStackKiller();    /** slime from HELL **/      #ifdef TIMING_PROFILE        InitTimingProfile(150);  /* call depth */      #endif TIMING_PROFILE    #endif  #endif  while (!gQuitApp)    EventLoop();  FlushEvents(0xffff,0);  #ifdef TIMING_PROFILE    DumpProfile(0, 0, &quot;\ptiming stats&quot;);  #endif  ExitBigEasy();  ExitToShell();  }</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/QTMusicToo/listing1.html%3Fid%3DDTS10000915-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/QTMusicToo/listing1.html%3Fid%3DDTS10000915-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/QTMusicToo/listing1.html%3Fid%3DDTS10000915-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>