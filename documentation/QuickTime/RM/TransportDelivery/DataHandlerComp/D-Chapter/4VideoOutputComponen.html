<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>QuickTime Transport and Delivery Guide: Video Output Components</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Video Output Components"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP40000861-VideoOutputComponents" title="Video Output Components"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440-TP30000433" target="_top">QuickTime</a> &gt; <a href="../../../../TransportDelivery-date.html#//apple_ref/doc/uid/TP30000440-TP30000433-TP30000580" target="_top">Transport &amp; Delivery</a> &gt; <a href="../A-Intro/1Introduction.html#//apple_ref/doc/uid/TP40000861-IntroductiontoQuickTimeTransportandDeliveryGuide-DontLinkElementID_54">QuickTime Transport and Delivery Guide</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../C-Chapter/3UsingDataHandlerCom.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../E-Chapter/5UsingVideoOutputCom.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP40000861-VideoOutputComponents-SW1" title="Video Output Components"></a>
<h1>Video Output Components</h1>

<p>This section describes what video output components are, and what they do.</p>
<p>QuickTime video output, which most often comes from QuickTime movies, can be displayed in windows that appear on a computer&#8217;s desktop. Because these windows are created and managed by the computer&#8217;s operating system, software that presents QuickTime video can use the operating system&#8217;s video display services to specify which display (when there is more than one video display) and window to use for video output.</p>
<p>There are, however, many video output devices that are not recognized by operating systems. To display QuickTime video on these devices, your software can use video output components. The components, which are normally developed by the manufacturers of video output devices, provide a standard interface for video output to a device.</p>



<!-- This template is being used for both PDF and HTML. -->

    
    <h4>In this section:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="4VideoOutputComponen.html#//apple_ref/doc/uid/TP40000861-VideoOutputComponents-DontLinkElementID_21">How Video Output Components Process Video Data</a>
				
			<br/>
			
        
			
			
				<a href="4VideoOutputComponen.html#//apple_ref/doc/uid/TP40000861-VideoOutputComponents-DontLinkElementID_23">Transfer Codecs</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP40000861-VideoOutputComponents-DontLinkElementID_21" title="How Video Output Components Process Video Data"></a>
<h2><a name="//apple_ref/doc/uid/TP40000861-VideoOutputComponents-HowVideoOutputComponentsProcessVideoData" title="How Video Output Components Process Video Data"></a>How Video Output Components Process Video Data</h2>
<p>A video output component receives QuickTime video data and delivers data to a video output device for display. If the incoming data is in a format that the video output device can display directly, the video output component can simply send the data to the video output device. If the incoming data cannot be displayed directly, the video output component must use a transfer codec or decompressor component to convert the data to a format that the video output device can display.</p>
<p>If a video output device cannot directly display 32-bit RGB data or data in one of the other supported QuickTime pixel formats, the developers of the device are strongly encouraged to provide a transfer codec that accepts data in one of the supported QuickTime pixel formats (preferably 32-bit RGB) and converts it to data that can be displayed on the device. When this transfer codec is available, any QuickTime video can be displayed on the video output device: the Image Compression Manager can convert any QuickTime images to a supported QuickTime pixel format and then invoke the transfer codec to display the result.</p>
<p>If any special decompressors, such as a transfer codec, are needed for a video output device, the decompressors are included in the definitions of the component&#8217;s display modes, as described in <span class="content_text"><a href="4VideoOutputComponen.html#//apple_ref/doc/uid/TP40000861-VideoOutputComponents-DisplayModes">Display Modes</a></span>. How hardware developers can develop a transfer codec for their device is described in <span class="content_text"><a href="4VideoOutputComponen.html#//apple_ref/doc/uid/TP40000861-VideoOutputComponents-CreatingaTransferCodecforaVideoOutputComponent">Creating a Transfer Codec for a Video Output Component</a></span>.</p>
<p>Some video output devices do not accept pixels as input. For example, there are devices that display JPEG data directly. For these devices, a video output component can send the appropriate data directly, or it can invoke a compressor component to convert data in a pixel format to the appropriate data.</p>
<a name="//apple_ref/doc/uid/TP40000861-VideoOutputComponents-DontLinkElementID_22" title="Display Modes"></a>
<h3><a name="//apple_ref/doc/uid/TP40000861-VideoOutputComponents-DisplayModes" title="Display Modes"></a>Display Modes</h3>
<p>A video output device has one or more display modes. The characteristics of each mode determine how video is displayed. When any software displays video on a video output device, it must select which of the device&#8217;s display modes to use.</p>
<p>The characteristics of a display mode include</p>
<ul class="spaceabove">
<li class="li"><p>the height of the displayed image, in pixels</p></li>
<li class="li"><p>the width of the displayed image, in pixels</p></li>
<li class="li"><p>the horizontal resolution of the display, in pixels per inch</p></li>
<li class="li"><p>the vertical resolution of the display, in pixels per inch</p></li>
<li class="li"><p>the refresh rate of the display, in Hertz</p></li>
<li class="li"><p>the pixel type of the display</p></li>
<li class="li"><p>a text description of the display mode</p></li>
</ul>
<p>The characteristics can also include a list of decompressor components required for the mode that are provided specifically for the video output device. If a video output device cannot directly display any of the pixel formats supported by QuickTime, the vendor of the device must provide one or more special decompressors to convert supported pixel formats to a format the device can display. If a video output device can display one or more of the pixel formats supported by QuickTime, the Image Compression Manager can use standard decompressors that are included with QuickTime, and the list of special decompressor components can be empty.</p>
<p>These characteristics, returned by the <code><a href="../../../../Reference/QTRef_VideoComponents/Reference/reference.html#//apple_ref/c/func/QTVideoOutputGetDisplayModeList" target="_top">QTVideoOutputGetDisplayModeList</a></code> function, are stored in a QT atom container. For a description of this QT atom container, see <span class="content_text"><a href="../F-Chapter/6FunctionsUsedToCont.html#//apple_ref/doc/uid/TP40000861-FunctionsUsedToControlVideoOutputComponents-DisplayModeQTAtomContainer">Display Mode QT Atom Container</a></span>.</p>


<a name="//apple_ref/doc/uid/TP40000861-VideoOutputComponents-DontLinkElementID_23" title="Transfer Codecs"></a>
<h2><a name="//apple_ref/doc/uid/TP40000861-VideoOutputComponents-TransferCodecs" title="Transfer Codecs"></a>Transfer Codecs</h2>
<p>If you are the manufacturer of a video output device, you need to provide a video output component for your device as described in <span class="content_text"><a href="../G-Chapter/7CreatingVideoOutput.html#//apple_ref/doc/uid/TP40000861-CreatingVideoOutputComponents-SW1">Creating Video Output Components</a></span>. In addition, if your video output device cannot display a pixel format defined by QuickTime, you should include a special decompressor, known as a transfer codec, that converts one of the supported QuickTime pixel formats (preferably 32-bit RGB) to data that the device can display. When this transfer codec is available, the QuickTime Image Compression Manager automatically uses it together with its built-in decompressors. This, in turn, lets applications or other software draw any QuickTime video directly to the video output component&#8217;s graphics world.</p>
<p>This section gives an overview of developing this transfer codec. Bear in mind that a transfer codec is a specialized image decompressor component, and should be based on the Base Image Decompressor.</p>
<a name="//apple_ref/doc/uid/TP40000861-VideoOutputComponents-DontLinkElementID_24" title="Overview  of Transfer Codecs"></a>
<h3><a name="//apple_ref/doc/uid/TP40000861-VideoOutputComponents-OverviewofTransferCodecs" title="Overview  of Transfer Codecs"></a>Overview  of Transfer Codecs</h3>
<p>QuickTime 2.5 contained new support for developers of codecs to accelerate certain image decompression operations. These features will most likely be used by developers of video hardware boards that provide special acceleration features, such as arbitrary scaling or color space conversion.</p>
<p>Prior to QuickTime 2.5, if a codec could not decompress an image directly to the screen, the ICM would prepare an offscreen buffer for the codec, then use the None codec to transfer the image from the offscreen buffer to the screen. With QuickTime 2.5, if a codec cannot decompress directly to the screen it has the option of specifying that it can decompress to one or more types of non-RGB pixel spaces, specified as an <code>OSType</code> (e.g., <code>'yuvs'</code>). The ICM then attempts to find a decompressor component of that type (a transfer codec) that can transfer the image to the screen. Since the ICM does not define non-RGB pixel types, the transfer codec must support additional calls to set up the offscreen. If a transfer codec cannot be found that supports the specified non-RGB pixel types, the ICM uses the None codec with an RGB offscreen buffer.</p>
<p>The real speed benefit comes from the fact that since the transfer codec defines the offscreen buffer, it can place the buffer in on-board memory, or even point to an overlay plane so that the offscreen image really is on the screen. In this case, the additional step of transferring the bits from offscreen memory on to the screen is avoided.</p>

<a name="//apple_ref/doc/uid/TP40000861-VideoOutputComponents-DontLinkElementID_25" title="Creating a Transfer Codec for a Video Output Component"></a>
<h3><a name="//apple_ref/doc/uid/TP40000861-VideoOutputComponents-CreatingaTransferCodecforaVideoOutputComponent" title="Creating a Transfer Codec for a Video Output Component"></a>Creating a Transfer Codec for a Video Output Component</h3>
<p>For an image decompressor component to indicate that it can decompress to non-RGB pixel types, it should, in the <code><a href="../../../../Reference/QTRef_ImageCodec/Reference/reference.html#//apple_ref/c/func/ImageCodecPreDecompress" target="_top">ImageCodecPreDecompress</a></code> call, fill in the <code>wantedDestinationPixelTypes</code> field with a handle to a zero-terminated list of pixel types that it can decompress to. The ICM immediately makes a copy of the handle. Cinepak, for example, returns a 12-byte handle containing <code>yuvs</code>, <code>yuvu</code>, and $00000000. Since <code><a href="../../../../Reference/QTRef_ImageCodec/Reference/reference.html#//apple_ref/c/func/ImageCodecPreDecompress" target="_top">ImageCodecPreDecompress</a></code> can be called often, it is suggested that codecs allocate this handle when their component is opened and simply fill in the <code>wantedDestinationPixelTypes</code> field with this handle during <code><a href="../../../../Reference/QTRef_ImageCodec/Reference/reference.html#//apple_ref/c/func/ImageCodecPreDecompress" target="_top">ImageCodecPreDecompress</a></code>. Components that use this method should be sure to dispose the handle at close.</p>
<p>Apple&#8217;s Cinepak decompressor supports decompressing to <code>'yuvs'</code> and <code>'yuvu'</code> pixel types. Type <code>'yuvs'</code> is a YUV format with u and <code>v</code> components signed (center point at $00), while <code>'yuvu'</code> has the u and <code>v</code> component centered at $80.</p>
<p>As an example, suppose XYZ Co. had a video board that had a YUV overlay plane capable of doing arbitrary scaling. The overlay plane takes data in the same format as Cinepak&#8217;s <code>'yuvs'</code> format. In this case, XYZ would make a component of type <code>'imdc'</code> and subtype <code>'yuvs'</code>.</p>
<p>The <code><a href="../../../../Reference/QTRef_ImageCodec/Reference/reference.html#//apple_ref/c/func/ImageCodecPreDecompress" target="_top">ImageCodecPreDecompress</a></code> call would set the <code>codecCanScale</code>, <code>codecHasVolatileBuffer</code>, and <code>codecImageBufferIsOnScreen</code> bits in the <code>capabilities</code>.flags field. The <code>codecImageBufferIsOnScreen</code> bit is necessary to inform the ICM that the codec is a direct screen transfer codec. A direct screen transfer codec is one that sets up an offscreen buffer that is actually onscreen (such as an overlay plane). Not setting this bit correctly can cause unpredictable results.</p>
<p>The real work of the codec takes place in the <code><a href="../../../../Reference/QTRef_ImageCodec/Reference/reference.html#//apple_ref/c/func/ImageCodecNewImageBufferMemory" target="_top">ImageCodecNewImageBufferMemory</a></code> call. This is where the codec is instructed to prepare the non-RGB pixel buffer. The codec must fill in the <code>baseAddr</code> and <code>rowBytes</code> fields of the <code>dstPixMap</code> structure in the<code></code> <code><!--a target="_top" -->CodecDecompressParams<!--/a--></code>. The ICM then passes these values to the original codec (e.g., Cinepak) to decompress into.</p>
<p>The codec must also implement<code></code> <code><a href="../../../../Reference/QTRef_ImageCodec/Reference/reference.html#//apple_ref/c/func/ImageCodecDisposeMemory" target="_top">ImageCodecDisposeMemory</a></code> to balance <code><a href="../../../../Reference/QTRef_ImageCodec/Reference/reference.html#//apple_ref/c/func/ImageCodecNewImageBufferMemory" target="_top">ImageCodecNewImageBufferMemory</a></code>.</p>
<p>Since Cinepak then decompresses into the card&#8217;s overlay plane, <code><a href="../../../../Reference/QTRef_ImageCodec/Reference/reference.html#//apple_ref/c/func/ImageCodecBandDecompress" target="_top">ImageCodecBandDecompress</a></code> needs to do nothing aside from calling <code><a href="../../../../Reference/QTRef_CompDecomp/Reference/reference.html#//apple_ref/c/func/ICMDecompressComplete" target="_top">ICMDecompressComplete</a></code>.</p>

<div class="codesample"><table><tr><td scope="row"><pre>pascal ComponentResult ImageCodecPreDecompress( Handle storage,<span></span></pre></td></tr><tr><td scope="row"><pre>&#xA0;&#xA0;&#xA0;&#xA0;CodecDecompressParams *p)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>&#xA0;&#xA0;&#xA0;&#xA0;CodecCapabilities *capabilities = p-&#62;capabilities; // only allow 16 bpp<span></span></pre></td></tr><tr><td scope="row"><pre>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;// source<span></span></pre></td></tr><tr><td scope="row"><pre>&#xA0;&#xA0;&#xA0;&#xA0;if ((**p-&#62;imageDescription).depth != 16)<span></span></pre></td></tr><tr><td scope="row"><pre>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;return codecConditionErr; /* we only support 16 bits per pixel dest */<span></span></pre></td></tr><tr><td scope="row"><pre>&#xA0;&#xA0;&#xA0;&#xA0;if (p-&#62;dstPixMap.pixelSize != 16)<span></span></pre></td></tr><tr><td scope="row"><pre>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;return codecConditionErr;<span></span></pre></td></tr><tr><td scope="row"><pre>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<span></span></pre></td></tr><tr><td scope="row"><pre>&#xA0;&#160;&#160;&#160;capabilities-&#62;wantedPixelSize = p-&#62;dstPixMap.pixelSize;<span></span></pre></td></tr><tr><td scope="row"><pre>&#xA0;&#160;&#160;&#160;capabilities-&#62;bandInc = capabilities-&#62;bandMin =<span></span></pre></td></tr><tr><td scope="row"><pre>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;(*p-&#62;imageDescription)-&#62;height;<span></span></pre></td></tr><tr><td scope="row"><pre>&#xA0;&#160;&#160;&#160;capabilities-&#62;extendWidth = 0;<span></span></pre></td></tr><tr><td scope="row"><pre>&#xA0;&#xA0;&#xA0;&#xA0;capabilities-&#62;extendHeight = 0;<span></span></pre></td></tr><tr><td scope="row"><pre>&#xA0;&#160;&#160;&#160;capabilities-&#62;flags = codecCanScale | codecImageBufferIsOnScreen | &#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;codecHasVolatileBuffer;<span></span></pre></td></tr><tr><td scope="row"><pre>&#xA0;&#160;&#160;&#160;return noErr;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre>&#xA0;<span></span></pre></td></tr><tr><td scope="row"><pre>pascal ComponentResult ImageCodecBandDecompress(Handle storage,<span></span></pre></td></tr><tr><td scope="row"><pre>&#xA0;&#xA0;&#xA0;&#xA0;CodecDecompressParams *p)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>&#xA0;&#xA0;&#xA0;&#xA0;ICMDecompressComplete(p-&#62;sequenceID, noErr, codecCompletionSource |<span></span></pre></td></tr><tr><td scope="row"><pre>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;codecCompletionDest, &#38;p-&#62;completionProcRecord);<span></span></pre></td></tr><tr><td scope="row"><pre>&#xA0;&#160;&#160;&#160;return noErr;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre>&#xA0;<span></span></pre></td></tr><tr><td scope="row"><pre>pascal ComponentResult ImageCodecNewImageBufferMemory(Handle storage,<span></span></pre></td></tr><tr><td scope="row"><pre>&#xA0;&#xA0;&#xA0;&#xA0;CodecDecompressParams *p, long flags,<span></span></pre></td></tr><tr><td scope="row"><pre>&#xA0;&#xA0;&#xA0;&#xA0;ICMMemoryDisposedUPP memoryGoneProc,&#160;void *refCon)<span></span></pre></td></tr><tr><td scope="row"><pre>{ &#160;&#160;<span></span></pre></td></tr><tr><td scope="row"><pre>&#xA0;&#xA0;&#xA0;&#xA0;OSErr err = noErr;<span></span></pre></td></tr><tr><td scope="row"><pre>&#xA0;&#xA0;&#xA0;&#xA0;long offsetH, offsetV;<span></span></pre></td></tr><tr><td scope="row"><pre>&#xA0;&#xA0;&#xA0;&#xA0;Ptr baseAddr;<span></span></pre></td></tr><tr><td scope="row"><pre>&#xA0;&#xA0;&#xA0;&#xA0;long rowBytes;<span></span></pre></td></tr><tr><td scope="row"><pre>&#xA0;&#xA0;&#xA0;&#xA0;<span></span></pre></td></tr><tr><td scope="row"><pre>&#xA0;&#160;&#160;&#160;// call predecompress to check to make sure we can handle<span></span></pre></td></tr><tr><td scope="row"><pre>&#xA0;&#xA0;&#xA0;&#xA0;// this destination<span></span></pre></td></tr><tr><td scope="row"><pre>&#xA0;&#xA0;&#xA0;&#xA0;err = ImageCodecPreDecompress(storage, p);<span></span></pre></td></tr><tr><td scope="row"><pre>&#xA0;&#xA0;&#xA0;&#xA0;if (err) goto bail;<span></span></pre></td></tr><tr><td scope="row"><pre>&#xA0;&#xA0;&#xA0;&#xA0;<span></span></pre></td></tr><tr><td scope="row"><pre>&#xA0;&#160;&#160;&#160;// set video board registers with the scale<span></span></pre></td></tr><tr><td scope="row"><pre>&#xA0;&#xA0;&#xA0;&#xA0;XYZVideoSetScale(p-&#62;matrix);<span></span></pre></td></tr><tr><td scope="row"><pre>&#xA0;&#xA0;&#xA0;&#xA0;<span></span></pre></td></tr><tr><td scope="row"><pre>&#xA0;&#160;&#160;&#160;// calculate a base address to write to<span></span></pre></td></tr><tr><td scope="row"><pre>&#xA0;&#xA0;&#xA0;&#xA0;offsetH = (p-&#62;dstRect.left - p-&#62;dstPixMap.bounds.left);<span></span></pre></td></tr><tr><td scope="row"><pre>&#xA0;&#xA0;&#xA0;&#xA0;offsetV = (p-&#62;dstRect.top - p-&#62;dstPixMap.bounds.top);<span></span></pre></td></tr><tr><td scope="row"><pre>&#xA0;&#xA0;&#xA0;&#xA0;XYZVideoGetBaseAddress(p-&#62;dstPixMap, offsetH, offsetV,<span></span></pre></td></tr><tr><td scope="row"><pre>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#38;baseAddr, &#38;rowBytes);<span></span></pre></td></tr><tr><td scope="row"><pre>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;<span></span></pre></td></tr><tr><td scope="row"><pre>&#xA0;&#160;&#160;&#160;p-&#62;dstPixMap.baseAddr = baseAddr;<span></span></pre></td></tr><tr><td scope="row"><pre>&#xA0;&#xA0;&#xA0;&#xA0;p-&#62;dstPixMap.rowBytes = rowBytes;<span></span></pre></td></tr><tr><td scope="row"><pre>&#xA0;&#xA0;&#xA0;&#xA0;p-&#62;capabilities-&#62;flags = codecImageBufferIsOnScreen;<span></span></pre></td></tr><tr><td scope="row"><pre>&#xA0;&#xA0;&#xA0;&#xA0;<span></span></pre></td></tr><tr><td scope="row"><pre>&#xA0;&#xA0;&#xA0;&#xA0;bail:<span></span></pre></td></tr><tr><td scope="row"><pre>&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;return err;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>pascal ComponentResult ImageCodecDisposeMemory(Handle storage, Ptr data)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>&#xA0;&#xA0;&#xA0;&#xA0;return noErr;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div>

<p>Some video hardware boards that use an overlay plane require that the image area on screen be flooded with a particular RGB value or alpha-channel in order to have the overlay buffer show through at that location. Codecs that require this support should set the <code>screenFloodMethod</code> and <code>screenFloodValue</code> fields of the <code><!--a target="_top" -->CodecDecompressParams<!--/a--></code> record during <code><a href="../../../../Reference/QTRef_ImageCodec/Reference/reference.html#//apple_ref/c/func/ImageCodecPreDecompress" target="_top">ImageCodecPreDecompress</a></code>. The ICM then manages the flooding of the screen buffer. This method is more reliable than having the codec attempt to flood the screen itself, and will ensure compatibility with future versions of QuickTime.</p>





        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../C-Chapter/3UsingDataHandlerCom.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../E-Chapter/5UsingVideoOutputCom.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2005, 2006 Apple Computer, Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2006-01-10<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/QuickTime/RM/TransportDelivery/DataHandlerComp/D-Chapter/4VideoOutputComponen.html%3Fid%3DTP40000861-3.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/QuickTime/RM/TransportDelivery/DataHandlerComp/D-Chapter/4VideoOutputComponen.html%3Fid%3DTP40000861-3.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/QuickTime/RM/TransportDelivery/DataHandlerComp/D-Chapter/4VideoOutputComponen.html%3Fid%3DTP40000861-3.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>