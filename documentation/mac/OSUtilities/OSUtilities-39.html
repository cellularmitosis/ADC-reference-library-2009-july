<!-- Generated by Harlequin WebMaker 2.2.3 (23-Apr-1996)
LispWorks 3.2.2 -->
<HTML> <HEAD>
<TITLE>About the Mathematical and Logical Utilities (IM: U)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING39></A>



<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="OSUtilities-38.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="OSUtilities-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="OSUtilities-222.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="OSUtilities-40.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="OSUtilities-2.html"><B>Operating System Utilities</B></A> / <BR><DD><A HREF="OSUtilities-38.html"><B>Chapter 3 - Mathematical and Logical Utilities</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING39-0></A>
<H1>About the Mathematical and Logical Utilities</H1>
 This section begins by introducing the building blocks of memory and then discusses some low-level routines the Mathematical and Logical Utilities provide, such as routines that compress data and generate pseudorandom numbers. Finally, the section concludes by introducing two fixed-point data types the Operating System supports.<P>
<A NAME=HEADING39-2></A>
<H2>Bits, Bytes, Words, and Long Words</H2>
 This section describes the fundamental memory units used in all computer systems and discusses some of the operations that you can perform on them using the Mathematical and Logical Utilities. If you already know what bits, bytes, words, and long words are, you can skip this section.<P>
 A <B>bit</B> is the atomic memory unit. Each bit can be set to one of two values. Often these values are called 0 and 1. A bit is said to be cleared when its value is 0 and set when its value is 1.<A NAME=MARKER-2-4></A><P>
 Eight bits form a single <B>byte.</B> The first bit in a byte is bit number 7, and the last bit is bit number 0. Bit number 7 is called the <B>most significant bit</B> or the <B>high-order bit,</B> and bit number 0 is the <B>least significant bit</B> or the <B>low-order bit.</B> A byte can thus store 2<EM>8</EM>, or 256, different possible values. In Pascal, a byte is thus defined like this:<A NAME=MARKER-2-27></A><A NAME=MARKER-2-178></A><A NAME=MARKER-9-54></A><A NAME=MARKER-2-77></A><P>
<PRE>
TYPE
   Byte = 0..255;
</PRE>
 <A HREF=#MARKER-9-19>Figure 3-1</A> illustrates a byte set to the base-10 value 109.<P>
<B>Figure 3-1  <A NAME=MARKER-9-19></A>A byte set to 109 ($6D)</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/MLU-L-01.jpg"><P>
 The base-10 value 109 is equivalent to the binary value 01101101. This sequence of binary digits exactly corresponds to the status of each bit in the byte illustrated in <A HREF=#MARKER-9-19>Figure 3-1</A>. A byte value is typically represented by two hexadecimal digits. The value in <A HREF=#MARKER-9-19>Figure 3-1</A>, for example, is equivalent to $6D.<P>
 Sometimes it is useful to quickly convert between hexadecimal and binary number formats during debugging when examining the values of individual bits in a byte. <BR><A HREF=#MARKER-9-10>Table 3-1</A> provides an easy way to do this on a digit-by-digit basis.<P>
<B>Table 3-1  <A NAME=MARKER-9-10></A><B>Table 3-1 Converting hexadecimal digits to binary values</B>
<TABLE BORDER="0" CELLPADDING=3><TH ALIGN=LEFT>Hexadecimal<TH>Binary<TR>
<TD>$0<TD>0000<TR>
<TD>$1<TD>0001<TR>
<TD>$2<TD>0010<TR>
<TD>$3<TD>0011<TR>
<TD>$4<TD>0100<TR>
<TD>$5<TD>0101<TR>
<TD>$6<TD>0110<TR>
<TD>$7<TD>0111<TR>
<TD>$8<TD>1000<TR>
<TD>$9<TD>1001<TR>
<TD>$A<TD>1010<TR>
<TD>$B<TD>1011<TR>
<TD>$C<TD>1100<TR>
<TD>$D<TD>1101<TR>
<TD>$E<TD>1110<TR>
<TD>$F<TD>1111</TABLE>
<A NAME=MARKER-2-117></A></B><P>
 For example, the hexadecimal value $A8 is equivalent to the binary value 10101000 because the hexadecimal digit $A is equivalent to 1010 and the digit $8 is equivalent to 1000. You can use <A HREF=#MARKER-9-10>Table 3-1</A> to convert numbers in both directions.<P>
 While you can always think of a byte as a particular value from $00 to $FF, sometimes that value is irrelevant. For example, an application might use a byte simply as a way to store eight flag bits; in this case, the application cares about only individual bits within the byte and not the value of the byte as a whole. Also, bytes are often used to store signed values, in which case a byte can be considered equivalent to values from -$80 to +$7F. If you use a low-level debugger like MacsBug to examine individual bytes in memory, you should also be aware that different compilers might use bytes in different ways.<A NAME=MARKER-9-22></A><P>
 Two bytes form a <B>word.</B> A word is thus a 16-bit quantity and can be used to store 2<EM>16</EM> (or 65,536) possible values. A <B>word boundary</B> is the memory location that divides two words. The first byte in a word is known as the high-order byte, and the second byte is known as the low-order byte. A pointer to a word points to the high-order byte. <BR><A HREF=#MARKER-9-14>Figure 3-2</A> illustrates a word.<A NAME=MARKER-9-12></A><P>
<B>Figure 3-2  <A NAME=MARKER-9-14></A>A word set to $3AD4</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/MLU-L-02.jpg"><P>
 In <A HREF=#MARKER-9-14>Figure 3-2</A>, the high-order byte is set to $3A. The low-order byte is set to $D4. The word thus has the value $3AD4. <P>
 Two words form a <B>long word.</B> A long word is thus a 32-bit quantity and can be used to store 2<EM>32</EM> (or 4,294,967,296) values. A <B>long-word boundary</B> is the memory location that divides two long words. A long word consists of a high-order word and a low-order word, as illustrated in <A HREF=#MARKER-9-15>Figure 3-3</A>.<P>
<B>Figure 3-3  <A NAME=MARKER-9-15></A>A long word set to $C24DAF2F</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/MLU-L-03.jpg"><P>
 In <A HREF=#MARKER-9-15>Figure 3-3</A>, the high-order word is set to $C24D. The low-order word is set to $AF2F. The long word thus has the value $C24DAF2F. <P>
 Variables of type <CODE>Integer</CODE> are signed words, and variables of type <CODE>LongInt</CODE> are signed long words. On current versions of the Operating System, a memory address is stored using all 32 bits of a long word.<P>
 Typically, Macintosh compilers align all values on word boundaries (and in some cases on long-word boundaries). This means that when you declare a variable of type <CODE>Byte</CODE> in Pascal, the compiler is in fact likely to allocate 2 bytes of memory to store the byte; the extra byte is called a <B>pad byte.</B> In this case, when you attempt to test bits in a byte you have allocated, the compiler might test the corresponding bit in the wrong byte.<P>
 In Pascal, there are two easy ways to avoid this problem. One is to aggregate variables of type <CODE>Boolean</CODE> and of type <CODE>Byte</CODE> in a packed record. In this case, as long as the packed record's size is a number of bytes that is a multiple of 4, no pad bytes are added. The second technique is, for variables in which you wish to test individual bits, to allocate 2 or 4 bytes for the variable (using a variable of type <CODE>Integer</CODE> or <CODE>LongInt</CODE>, respectively). <P>
<A NAME=HEADING39-26></A>
<H2>Bit Manipulation and Logical Operations</H2>
 The Mathematical and Logical Utilities provide a number of routines that provide bit-level and byte-level control over memory, as described in <A HREF=OSUtilities-40.html#MARKER-9-55>"Performing Low-Level Manipulation of Memory" beginning on page 3-14</A>. Given a pointer and offset, these routines can manipulate any specific bit in a stream of bits.<P>
 The <CODE>BitTst</CODE>, <CODE>BitSet</CODE>, and <CODE>BitClr</CODE> routines allow you to test and clear individual bits within a byte. These functions are introduced in <A HREF=OSUtilities-40.html#MARKER-9-56>"Testing and Manipulating Bits" on page 3-14</A>.<P>
<DL>
<DT><B>Note</B>
<DD>The <CODE>BitTst</CODE>, <CODE>BitSet</CODE>, and <CODE>BitClr</CODE> routines use a bit-numbering scheme that is opposite that of the MC680x0 microprocessor. This reversed bit-numbering scheme is described in the next section.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
 The <CODE>BitAnd</CODE>, <CODE>BitOr</CODE>, <CODE>BitXor</CODE>, and <CODE>BitNot</CODE> functions allow you to perform logical operations on long words, and the <CODE>BitShift</CODE> function allows you to shift the bits in a long word to the right or to the left. These functions are introduced in <A HREF=OSUtilities-40.html#MARKER-9-64>"Performing Logical Operations on Long Words" on page 3-16</A>.<P>
 You might also need to extract one of a long word's words. The <CODE>HiWord</CODE> and <CODE>LoWord</CODE> functions allow you to do this and are described in <A HREF=OSUtilities-40.html#MARKER-9-81>"Extracting a Word From a Long Word" on page 3-18</A>. Finally, you might need to set a group of bytes' values directly. The <CODE>StuffHex</CODE> procedure enables you to hardcode hexadecimal values to bytes anywhere in memory and is described in <A HREF=OSUtilities-40.html#MARKER-9-85>"Hardcoding Byte Values" on page 3-19</A>.<P>
<A NAME=HEADING39-32></A>
<H2><A NAME=MARKER-2-16></A><A NAME=MARKER-9-17></A><A NAME=MARKER-2-18></A>Reversed Bit-Numbering</H2>
 Three of the routines described in this chapter (the <CODE>BitTst</CODE>, <CODE>BitSet</CODE>, and <CODE>BitClr</CODE> routines) use a bit-numbering scheme that is opposite from that of the bit-numbering scheme used by the MC680x0 microprocessor. <P>
 The <CODE>BitTst</CODE>, <CODE>BitSet</CODE>, and <CODE>BitClr</CODE> routines count the bit numbers from left to right. That is, the most significant bit has the bit number 0. The MC680x0 bit number notation counts the bit numbers from right to left. (That is, the most significant bit has the biggest bit number.) <A HREF=#MARKER-9-19>Figure 3-1</A> illustrates these bit-numbering schemes.<P>
<B>Figure 3-4  <A NAME=MARKER-9-19></A>Bit-numbering schemes</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/MLU-L-06.jpg"><P>
 When using routines other than the <CODE>BitTst</CODE>, <CODE>BitSet</CODE>, and <CODE>BitClr</CODE> routines or if you are an assembly-language programmer, you should use the MC680x0 bit-numbering scheme.<P>
 To convert from MC680x0 bit notation to the scheme described in this section, subtract the MC680x0 bit number from the highest bit number. For example, to clear bit number 3 in a byte, you must clear bit number 4 (7-3 = 4).<A NAME=MARKER-2-20></A><A NAME=MARKER-9-19></A><P>
<A NAME=HEADING39-39></A>
<H2><A NAME=MARKER-9-22></A>Data Compression<A NAME=MARKER-2-97></A><A NAME=MARKER-2-101></A></H2>
 <A NAME=MARKER-2-294></A>The Mathematical and Logical Utilities include two procedures, <CODE>PackBits</CODE> and <CODE>UnpackBits</CODE>, that allow you to provide rudimentary data compression and decompression, respectively. The procedures are not powerful enough to provide effective compression for applications that primarily concern themselves with data compression. Also, if you are compressing sound, image, or video data, the Sound Manager (described in <I><A HREF="../Sound/Sound-2.html">Inside Macintosh: Sound</A></I>) and the Image Compression Manager (described in <I><A HREF="../../QuickTime/QuickTime.html">Inside Macintosh: QuickTime</A></I>) provide far more effective compression algorithms.<P>
 You can use the <CODE>PackBits</CODE> and <CODE>UnpackBits</CODE> procedures to conserve memory both in RAM and on disk. However, because decompressing data is time consuming, typically you compress data using the <CODE>PackBits</CODE> procedure before saving a file or resource to disk and decompress data using the <CODE>UnpackBits</CODE> procedure after reading the data back from disk. Because the time required for compression and decompression using <CODE>PackBits</CODE> and <CODE>UnpackBits</CODE> is usually trivial compared to the time it takes to access a typical hard disk, the routines provide a simple, low-overhead way for an application to minimize the size of its data files.<P>
 The <CODE>PackBits</CODE> procedure is effective when an uncompressed buffer of data is likely to have many consecutive bytes containing the same value. For example, some applications use data structures that include fields that the application reserves for future use. These fields are typically all set to 0. The <CODE>PackBits</CODE> procedure senses that there is a long string of consecutive bytes containing the same value and compresses the string of bytes by using 1 byte to indicate that the subsequent compressed byte represents a number of consecutive uncompressed bytes. <A NAME=MARKER-2-98></A><P>
 <CODE>PackBits</CODE> was originally intended as an easy way to compress black-and-white image data, such as MacPaint documents. However, because each pixel of a color picture is typically represented by multiple bytes of data, <CODE>PackBits</CODE> is unlikely to provide effective compression for such pictures.<A NAME=MARKER-2-100></A><P>
 If there is no reason to think that your data format might contain long strings of consecutive bytes, then the <CODE>PackBits</CODE> procedure is probably not useful and might even increase the size of your files. The <CODE>PackBits</CODE> procedure packs data 127 bytes at a time. If within the 127 bytes there is no series of 3 consecutive bytes containing the same value, then there are no gains to be made from compression. In this case, the <CODE>PackBits</CODE> procedure must use an initial byte to specify that the 127 subsequent bytes contain uncompressed data. You can compute the worst-case performance of <CODE>PackBits</CODE> (that is, the maximum number of output bytes) by using the following formula:<P>
<PRE>
maxDstBytes := srcBytes + (srcBytes+126) DIV 127;
</PRE>
 where <CODE>maxDstBytes</CODE> stands for the maximum number of destination bytes and <CODE>srcBytes</CODE> stands for the number of bytes in the uncompressed source data.<P>
 You can, if desired, pack a buffer of data, and then pack the packed buffer again. However, packing data twice not only is slower than packing data once, but also is likely to result in a larger output buffer than just packing data once. If your application does pack data twice, it should unpack the data twice.<P>
<DL>
<DT><B>Note</B>
<DD>In current versions of system software, you can request that <CODE>PackBits</CODE> pack up to 32,767 bytes. The <CODE>PackBits</CODE> procedure then processes the input buffer in 127-byte chunks. In versions of system software prior to version 6.0.2, however, you should pass to <CODE>PackBits</CODE> only buffers up to 127 bytes in length.<EM></EM><A NAME=MARKER-9-132></A><A NAME=MARKER-2-29></A>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
<A NAME=HEADING39-49></A>
<H2>Pseudorandom Number Generation<A NAME=MARKER-2-30></A><A NAME=MARKER-2-31></A></H2>
 Because digital computers continuously execute instructions, it is impossible for a computer to select a truly random number. To force the computer to output a number, the programmer must create an algorithm, but because algorithms always execute in the same way, the numbers an algorithm produces cannot be truly random. Random numbers are often necessary in software applications, however. For example, an entertainment software application might need to ensure that the user is not faced with the exact same game every time. Or a spreadsheet application might offer a randomization function for business users attempting to simulate various possible scenarios.<P>
 To get around the impossibility of producing truly random numbers, computer scientists rely on pseudorandom number generation algorithms. These are complex numeric algorithms used to produce a series of numbers. All such series eventually repeat, but typically not until the pseudorandom number generation algorithm has been executed millions or even billions of times. Because the series is generated by an algorithm, it is possible to discern a pattern; given the first few numbers of a series, a clever user might be able to guess the next number. Typically, however, these algorithms are complicated enough to make the numbers appear random, at least to the casual observer.<P>
 Of course, because pseudorandom number generation algorithms are algorithms, they produce the same series of numbers every time. However, you can seed the pseudorandom number generator to force it to start somewhere in the middle of the series. By seeding the generator to a constantly changing variable when your application starts up, your application can produce different results each time. The value typically used to seed the pseudo-random number generator is the current date and time. Of course, time isn't random--it moves forward at a constant linear rate--but in the absence of a stopped system clock, the user will never launch your application at the same time twice, so you can be confident that your application will produce different results each time it is executed.<P>
 The Macintosh Operating System's pseudorandom number generation algorithm is accessible through the <CODE>Random</CODE> function. The <CODE>Random</CODE> function returns a pseudorandom integer from -32767 to 32767. The value that the <CODE>Random</CODE> function produces depends on the <CODE>randSeed</CODE> global variable. The <CODE>Random</CODE> function changes <CODE>randSeed</CODE> while generating a pseudorandom number, thus enabling a subsequent call to <CODE>Random</CODE> to produce the next number in the series. You only need to seed the global variable once, at the start of your program. <A NAME=MARKER-2-27></A><P>
 The pseudorandom number generation algorithm is designed so that as the number of times <CODE>Random</CODE> is executed approaches infinity, the percentage difference in the number of times any two integers in the range -32767 to 32767 are produced approaches 0. Thus, the pseudorandom number generator is said to produce pseudo-random numbers that are uniformly distributed in the range -32767 to 32767.<A NAME=MARKER-6-12></A><P>
 This chapter does not describe the algorithm that <CODE>Random</CODE> uses to generate pseudorandom numbers. While the algorithm is sufficiently complex for most applications, applications that perform mathematical or statistical analysis might require a better pseudo-random number generator. Consult the computer science literature for information on sophisticated pseudorandom number generation algorithms.<A NAME=MARKER-2-34></A><P>
<A NAME=HEADING39-56></A>
<H2><A NAME=MARKER-2-35></A><A NAME=MARKER-9-36></A>Fixed-Point Data Types<A NAME=MARKER-9-6></A></H2>
 The Operating System supports two fixed-point data types, that is, numeric types that consist of integral and fractional components. Depending on the type of information you are representing with a fixed-point data type, these might be better suited for your needs than the types <CODE>Integer</CODE>, <CODE>LongInt</CODE>, and the many floating-point types supported by the Standard Apple Numerics Environment.<P>
 A variable of type <CODE>Fixed</CODE> is defined like this:<P>
<PRE>
TYPE
   Fixed = LongInt;
</PRE>
 A variable of type <CODE>Fixed</CODE> is a 32-bit signed quantity containing an integer part in the high-order word and a fractional part in the low-order word. <A HREF=#MARKER-9-38>Figure 3-5</A> illustrates the format for <CODE>Fixed</CODE>.<P>
<B>Figure 3-5  <A NAME=MARKER-9-38></A>The <CODE>Fixed</CODE> data type</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/MLU-L-04.jpg"><P>
 The high-order word consists of the integral component of the fixed-point number, and the low-order word consists of the fractional component of the fixed-point number. Each bit, other than the most significant bit, represents a power of 2, as indicated in <A HREF=#MARKER-9-38>Figure 3-5</A>.<P>
 Negative numbers of type <CODE>Fixed</CODE> are the two's complement; that is, the negative numbers are formed by treating the fixed-point number as a long integer, inverting each bit, and adding 1 to the least significant bit.<P>
 The <CODE>Fract</CODE> data type is useful for allowing accurate representation of small numbers, that is, numbers between -2 and 2. It is defined just like <CODE>Fixed</CODE>:<P>
<PRE>
TYPE
   Fract = LongInt;
</PRE>
 <A HREF=#MARKER-9-39>Figure 3-6</A> illustrates the format for <CODE>Fract</CODE>.<P>
<B>Figure 3-6  <A NAME=MARKER-9-39></A>The <CODE>Fract</CODE> data type</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/MLU-L-05.jpg"><P>
 Like a <CODE>Fixed</CODE> number, a <CODE>Fract</CODE> number is a 32-bit quantity, but its implicit binary point is to the right of bit 30 of the number; that is, a <CODE>Fract</CODE> number has 2 integer bits and 30 fraction bits. As with the type <CODE>Fixed</CODE>, a number is negated by taking its two's complement. Thus, <CODE>Fract</CODE> values range between -2 and 2 - (2<EM>-30</EM>), inclusive.<A NAME=MARKER-2-14></A><P>
 All routines that operate on fixed-point numbers handle boundary cases uniformly. Results are rounded by adding half a unit in magnitude in the last place of the stored precision and then chopping toward zero. Overflows are set to the maximum representable value with the correct sign ($80000000 for negative results and $7FFFFFFF for positive results). Division by zero results in $8000000 if the numerator is negative and $7FFFFFFF otherwise; thus, the special case 0/0 yields $7FFFFFFF.<A NAME=MARKER-2-134></A><A NAME=MARKER-2-136></A><A NAME=MARKER-2-137></A><A NAME=MARKER-2-44></A><A NAME=MARKER-2-45></A><P>
<A NAME=HEADING39-72></A>
<H2><A NAME=MARKER-2-46></A>Angle-Slope Conversion<A NAME=MARKER-2-99></A></H2>
 The Mathematical and Logical Utilities provide two functions for applications that need to draw lines at particular angles. For example, a mathematical plotting application might need to draw a 30-degree line. <A NAME=MARKER-2-48></A>The <CODE>SlopeFromAngle</CODE> and <CODE>AngleFromSlope</CODE> functions provide simple conversion between slope and angle values. Slopes and angles are defined in such a way as to be convenient to a computer programmer rather than correspond to the conventional mathematical interpretation.<P>
<DL>
<DT><B>Note</B>
<DD>You should not rely on the <CODE>SlopeFromAngle</CODE> and <CODE>AngleFromSlope</CODE> functions to produce values that will allow you to draw lines at a precise angle on the screen. The functions do not take into account the size of pixels on a screen. If pixels on a screen are not perfect squares, a 30-degree angle might appear to be a different angle to the user. <EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
 Since QuickDraw and other computer imaging schemes typically invert the y-axis (making positive down and negative up), the angle-slope conversion routines use this convention as well. Angles are measured clockwise relative to the negative y-axis (that is, relative to 12 o'clock), and are taken <CODE>MOD</CODE> 180, so that a 270-degree angle is considered to be equivalent to a 90-degree angle. <A NAME=MARKER-2-141></A><P>
 Slopes are defined as Dx/Dy, the horizontal change divided by the vertical change for any two points on a line with the slope. Note that mathematicians typically measure slopes Dy/Dx. The convention of angle-slope conversion is convenient for applications that plot a number of lines in a graph one horizontal line at a time. <A NAME=MARKER-2-106></A><P>
 <A HREF=#MARKER-9-51>Figure 3-7</A> shows some equivalencies between angle and slope values for the angle-slope conversion routines.<P>
<B>Figure 3-7  <BR>
<A NAME=MARKER-9-51></A>Some slope and line equivalencies using the conventions of the angle-slope conversion routines</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/MLU-L-07.jpg"><P>
 The <CODE>AngleFromSlope</CODE> function is useful primarily only when speed is more important than accuracy because the function might return an angle off by as much as 1 degree from the actual angle. The function returns values between 1 and 180 (inclusive), and thus never returns an angle value between 0 and 1 degrees. If your application is likely to need precise differentiation in angles, you should probably develop alternative routines to handle angle-slope conversions. <A NAME=MARKER-2-52></A><P>
 <CODE>SlopeFromAngle(0)</CODE> is 0, and <CODE>AngleFromSlope(0)</CODE> is 180. For all <CODE>x</CODE> except for 0, however, <CODE>AngleFromSlope(SlopeFromAngle(x)) = x</CODE> is true. But the reverse, <CODE>SlopeFromAngle(AngleFromSlope(x)) = x</CODE> is not necessarily true.<A NAME=MARKER-2-104></A><A NAME=MARKER-2-54></A><P>

</BLOCKQUOTE>
<HR>
<center>
<A HREF="OSUtilities-38.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="OSUtilities-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="OSUtilities-222.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="OSUtilities-40.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="OSUtilities-3.html">&copy; Apple Computer, Inc.</A><br>6 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>  
