<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>OpenGL Screensaver - /Source/glCheck.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/GraphicsImaging/index.html">Graphics & Imaging</a> &gt; <a href="../../samplecode/GraphicsImaging/idxOpenGL-date.html">OpenGL</a> &gt; <A HREF="javascript:location.replace('index.html');">OpenGL Screensaver</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">OpenGL Screensaver</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/Source/glCheck.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/Headers/BasicOpenGLView.h</option>
<option value="listing2.html">/Headers/drawInfo.h</option>
<option value="listing3.html">/Headers/glCheck.h</option>
<option value="listing4.html">/Headers/OpenGLScreensaverView.h</option>
<option value="listing5.html">/Headers/StringTexture.h</option>
<option value="listing6.html">/Headers/trackball.h</option>
<option value="listing7.html">/main.m</option>
<option value="listing8.html">/OpenGL Screensaver.saver/Contents/Resources/ReadMe.txt</option>
<option value="listing9.html">/ReadMe.txt</option>
<option value="listing10.html">/Source/BasicOpenGLView.m</option>
<option value="listing11.html">/Source/drawInfo.m</option>
<option value="listing12.html">/Source/glCheck.c</option>
<option value="listing13.html">/Source/OpenGLScreensaverView.m</option>
<option value="listing14.html">/Source/StringTexture.m</option>
<option value="listing15.html">/Source/trackball.c</option></select>
				</p>
				</form>
				<p><strong><a href="OpenGL_Screensaver.zip">Download Sample</a></strong> (&#147;OpenGL_Screensaver.zip&#148;, 143.0K)<BR>
<strong><a href="OpenGL_Screensaver.dmg">Download Sample</a></strong> (&#147;OpenGL_Screensaver.dmg&#148;, 206.4K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*
 *  glCheck.c
 *  Carbon OpenGL
 *
 *  Created by ggs on Fri Jan 24 2003.

  Copyright:  Copyright ï¿½ 2003 Apple Computer, Inc., All Rights Reserved

  Disclaimer:  IMPORTANT:  This Apple software is supplied to you by Apple Computer, Inc.
      (&quot;Apple&quot;) in consideration of your agreement to the following terms, and your
      use, installation, modification or redistribution of this Apple software
      constitutes acceptance of these terms.  If you do not agree with these terms,
      please do not use, install, modify or redistribute this Apple software.

      In consideration of your agreement to abide by the following terms, and subject
      to these terms, Apple grants you a personal, non-exclusive license, under Apple&rsquo;s
      copyrights in this original Apple software (the &quot;Apple Software&quot;), to use,
      reproduce, modify and redistribute the Apple Software, with or without
      modifications, in source and/or binary forms; provided that if you redistribute
      the Apple Software in its entirety and without modifications, you must retain
      this notice and the following text and disclaimers in all such redistributions of
      the Apple Software.  Neither the name, trademarks, service marks or logos of
      Apple Computer, Inc. may be used to endorse or promote products derived from the
      Apple Software without specific prior written permission from Apple.  Except as
      expressly stated in this notice, no other rights or licenses, express or implied,
      are granted by Apple herein, including but not limited to any patent rights that
      may be infringed by your derivative works or by other works in which the Apple
      Software may be incorporated.

      The Apple Software is provided by Apple on an &quot;AS IS&quot; basis.  APPLE MAKES NO
      WARRANTIES, EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION THE IMPLIED
      WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY AND FITNESS FOR A PARTICULAR
      PURPOSE, REGARDING THE APPLE SOFTWARE OR ITS USE AND OPERATION ALONE OR IN
      COMBINATION WITH YOUR PRODUCTS.

      IN NO EVENT SHALL APPLE BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL OR
      CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
      GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
      ARISING IN ANY WAY OUT OF THE USE, REPRODUCTION, MODIFICATION AND/OR DISTRIBUTION
      OF THE APPLE SOFTWARE, HOWEVER CAUSED AND WHETHER UNDER THEORY OF CONTRACT, TORT
      (INCLUDING NEGLIGENCE), STRICT LIABILITY OR OTHERWISE, EVEN IF APPLE HAS BEEN
      ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */
 
 // see glcheck.h for more explanation on the use of CheckOpenGLCaps and it's associated data

 
#include &quot;glCheck.h&quot;

#include &lt;OpenGL/OpenGL.h&gt;
#include &lt;AGL/agl.h&gt;
#include &lt;OpenGL/gl.h&gt;
#include &lt;OpenGL/glu.h&gt;
#include &lt;OpenGL/glext.h&gt;

#include &lt;string.h&gt;

// -------------------------

// local CF dictionary routines

static long _getDictLong (CFDictionaryRef refDict, CFStringRef key)
{
  long int_value;
  CFNumberRef num_value = (CFNumberRef)CFDictionaryGetValue(refDict, key);
  if (!num_value) // if can't get a number for the dictionary
    return -1;  // fail
  // or if cant convert it
  if (!CFNumberGetValue(num_value, kCFNumberLongType, &amp;int_value)) 
    return -1; // fail
  return int_value; // otherwise return the long value
}

static double _getDictDouble (CFDictionaryRef refDict, CFStringRef key)
{
  double double_value;
  CFNumberRef num_value = (CFNumberRef)CFDictionaryGetValue(refDict, key);
  if (!num_value) // if can't get a number for the dictionary
    return -1;  // fail
  // or if cant convert it
  if (!CFNumberGetValue(num_value, kCFNumberDoubleType, &amp;double_value)) 
    return -1; // fail
  return double_value; // otherwise return the long value
}

// -------------------------

// this does a reasonable check to see if things have changed without being 
// too heavy weight; returns 1 if changed 0 if not
// checks num displays, displayID, displayMask, each display geometry and 
// renderer VRAM and ID

unsigned char HaveOpenGLCapsChanged (GLCaps aDisplayCaps[], 
                                     CGDisplayCount dspyCnt)
{
  CGDisplayCount maxDisplays = 32;
  CGDirectDisplayID activeDspys[32];
  CGDisplayErr error;
  short i;
  CGDisplayCount newDspyCnt = 0;
  
  if (NULL == aDisplayCaps) return 1;

  error = CGGetActiveDisplayList(maxDisplays, activeDspys, &amp;newDspyCnt);
  // if error getting list mark as changed
  if (error) return 1; 
  // if number of displays not equal
  if (dspyCnt != newDspyCnt) return 1;
  
  for (i = 0; i &lt; dspyCnt; i++) {
    // get device ids
    if (aDisplayCaps[i].cgDisplayID != activeDspys[i]) return 1;
    if (aDisplayCaps[i].cglDisplayMask !=  
        CGDisplayIDToOpenGLDisplayMask(activeDspys[i])) return 1;
 
    // get current geometry
    {
      CGRect displayRect = CGDisplayBounds (activeDspys[i]);
      // get mode dictionary
      CFDictionaryRef dispMode = CGDisplayCurrentMode (activeDspys[i]);
      // check for all geometry matches 
      if (aDisplayCaps[i].deviceWidth != (long) displayRect.size.width)
        return 1;   
      if (aDisplayCaps[i].deviceHeight != (long) displayRect.size.height) 
        return 1;   
      if (aDisplayCaps[i].deviceOriginX != (long) displayRect.origin.x) 
        return 1;   
      if (aDisplayCaps[i].deviceOriginY != (long) displayRect.origin.y) 
        return 1;   
      if (aDisplayCaps[i].deviceDepth != 
                 (short) _getDictLong (dispMode,  kCGDisplayBitsPerPixel)) 
        return 1;    
      if (aDisplayCaps[i].deviceRefresh != 
          (short)(_getDictDouble (dispMode, kCGDisplayRefreshRate) + 0.5)) 
        return 1; // round to GLint
    }

    // get renderer info based on gDevice
    {
      CGLRendererInfoObj info;
      long j, numRenderers = 0, rv = 0;
      CGLError err = 0;
      long deviceVRAM; // video memory in bytes
      unsigned long rendererID; // renderer ID
      
      err = CGLQueryRendererInfo (aDisplayCaps[i].cglDisplayMask, 
                                  &amp;info, &amp;numRenderers);
      if(0 == err) {
        CGLDescribeRenderer (info, 0, kCGLRPRendererCount, &amp;numRenderers);
        for (j = 0; j &lt; numRenderers; j++) {
          // find accelerated renderer (assume only one)
          CGLDescribeRenderer (info, j, kCGLRPAccelerated, &amp;rv); 
          if (true == rv) { // if accelerated
            // what is the renderer ID
            CGLDescribeRenderer (info, j, kCGLRPRendererID, &amp;rendererID); 
            if (rendererID != aDisplayCaps[i].rendererID) // check match
              return 1;
            // what is the VRAM
            CGLDescribeRenderer (info, j, kCGLRPVideoMemory, &amp;deviceVRAM); 
            if (deviceVRAM != aDisplayCaps[i].deviceVRAM) // check match
              return 1;
            break; // done
          }
        }
      }
      CGLDestroyRendererInfo (info);
    }
  }
  return 0;
}

// -------------------------

// This will walk all active displays and gather information about their
// hardware renderer 

// An array length (maxDisplays) and array of GLCaps are passed in. Up to
// maxDisplays of the array are filled in with the displays meeting the
// specified criteria.  The actual number of displays filled in is returned
// in dspyCnt.  Calling this function with maxDisplays of 0 will just
// return the number of displays in dspyCnt.

// Developers should note this is NOT an exhaustive list of all the
// capabilities one could query, nor a required set of capabilities,
// feel free to add or subtract queries as you find helpful for your 
// application/use.

// one note on mirrored displays... if the display configuration is 
// changed it is possible (and likely) that the current active display
// in a mirrored configuration (as identified by the OpenGL Display Mask)
// will change if the mirrored display is removed.  
// This is due to the preference of selection the external display as 
// the active display.  This may affect full screen apps which should 
// always detect display configuration changes and respond accordingly.

void CheckOpenGLCaps (CGDisplayCount maxDspys, 
                      GLCaps dCaps[], 
                      CGDisplayCount * dCnt)
{
  CGLContextObj curr_ctx = 0;
  CGDirectDisplayID dspys[32];
  CGDisplayErr err;
  short i;
  short size = sizeof (GLCaps);
  
  // no devices
  *dCnt = 0;
  
  if (maxDspys == 0) { // find number of displays
    *dCnt = 0;
    err = CGGetActiveDisplayList (32, dspys, dCnt);
    if (err) // err getting list
      *dCnt = 0; // 0 displays since can't correctly find any
    // zero list to ensure the routines are used correctly
    memset (dspys, 0, sizeof (CGDirectDisplayID) * *dCnt);
    return; // return dCnt
  }
  if (NULL == dCaps) return;

  err = CGGetActiveDisplayList(maxDspys, dspys, dCnt);
  if (err) return; // err getting list
  if (0 == *dCnt) return; // no displays
  
  memset (dCaps, 0, size * *dCnt); // zero memory
  
  for (i = 0; i &lt; *dCnt; i++) {
    // get device ids
    dCaps[i].cgDisplayID = dspys[i];
    dCaps[i].cglDisplayMask = CGDisplayIDToOpenGLDisplayMask(dspys[i]);
    
    { // get current geometry
      CGRect displayRect = CGDisplayBounds (dspys[i]);
      // get mode dictionary
      CFDictionaryRef dispMode = CGDisplayCurrentMode (dspys[i]); 
      dCaps[i].deviceWidth = (long) displayRect.size.width;   
      dCaps[i].deviceHeight = (long) displayRect.size.height;   
      dCaps[i].deviceOriginX = (long) displayRect.origin.x;   
      dCaps[i].deviceOriginY = (long) displayRect.origin.y;   
      dCaps[i].deviceDepth = (short) _getDictLong (dispMode,  
                                              kCGDisplayBitsPerPixel);    
      dCaps[i].deviceRefresh = (short) (_getDictDouble (dispMode,
                                        kCGDisplayRefreshRate) + 0.5); 
    }

    { // find gDevice device by bounds
      GDHandle hGD;
      for (hGD = GetDeviceList (); hGD; hGD = GetNextDevice (hGD))
      {
        if (!TestDeviceAttribute (hGD, screenDevice) ||
            !TestDeviceAttribute (hGD, screenActive))
          continue;
  
        // if postion and sizes match
        if (((*hGD)-&gt;gdRect.top == dCaps[i].deviceOriginY) &amp;&amp;
          ((*hGD)-&gt;gdRect.left == dCaps[i].deviceOriginX) &amp;&amp;
          (((*hGD)-&gt;gdRect.bottom - (*hGD)-&gt;gdRect.top) ==
                                                  dCaps[i].deviceHeight) &amp;&amp;
          (((*hGD)-&gt;gdRect.right - (*hGD)-&gt;gdRect.left) ==
                                                  dCaps[i].deviceWidth)) {
          dCaps[i].hGDevice = hGD;
          break;
        }
      }
      if (dCaps[i].hGDevice == NULL)
        return; // err
      if (noErr != DMGetDisplayIDByGDevice (dCaps[i].hGDevice,
                                            &amp;dCaps[i].displayID, false))
        dCaps[i].displayID = 0; // err getting display ID
    }
    
    
    { // get renderer info based on gDevice
      CGLRendererInfoObj info;
      long j, numRenderers = 0, rv = 0;
      CGLError err = 0;
      
      err = CGLQueryRendererInfo (dCaps[i].cglDisplayMask, 
                                  &amp;info, 
                                  &amp;numRenderers);
      if(0 == err) {
        CGLDescribeRenderer (info, 0, kCGLRPRendererCount, &amp;numRenderers);
        for (j = 0; j &lt; numRenderers; j++) {
          // find accelerated renderer (assume only one)
          CGLDescribeRenderer (info, j, kCGLRPAccelerated, &amp;rv); 
          if (true == rv) { // if accelerated
            // what is the renderer ID
            CGLDescribeRenderer (info, j, kCGLRPRendererID,
                                 &amp;dCaps[i].rendererID);
            // can we do full screen?
            CGLDescribeRenderer (info, j, kCGLRPFullScreen, &amp;rv); 
            dCaps[i].fullScreenCapable = (bool) rv;
            // what is the VRAM?
            CGLDescribeRenderer (info, j, kCGLRPVideoMemory,
                                 &amp;dCaps[i].deviceVRAM);
            // what is the current texture memory? 
            CGLDescribeRenderer (info, j, kCGLRPTextureMemory,
                                 &amp;dCaps[i].deviceTextureRAM);
            break; // done
          }
        }
      }
      CGLDestroyRendererInfo (info);
    }

    { // build context and context specific info
      CGLPixelFormatAttribute attribs[] = { kCGLPFADisplayMask,
                                            dCaps[i].cglDisplayMask, 
                                            NULL };
      CGLPixelFormatObj pixelFormat = NULL;
      long numPixelFormats = 0;
      CGLContextObj cglContext;
      
      curr_ctx = CGLGetCurrentContext (); // get current CGL context
      CGLChoosePixelFormat (attribs, &amp;pixelFormat, &amp;numPixelFormats);
      if (pixelFormat) {
        CGLCreateContext(pixelFormat, NULL, &amp;cglContext);
        CGLDestroyPixelFormat (pixelFormat);
        CGLSetCurrentContext (cglContext);
        if (cglContext) {
          const GLubyte * strExt;
          const GLubyte * strRend;
          const GLubyte * strVers;
          const GLubyte * strVend;

          // get renderer strings
          strRend = glGetString (GL_RENDERER);
          strncpy (dCaps[i].strRendererName, strRend, 255);
          strVend = glGetString (GL_VENDOR);
          strncpy (dCaps[i].strRendererVendor, strVend, 255);
          strVers = glGetString (GL_VERSION);
          strncpy (dCaps[i].strRendererVersion, strVers, 255);
          { // get BCD version
            short j = 0;
            short shiftVal = 8;
            while (((strVers[j] &lt;= '9') &amp;&amp; (strVers[j] &gt;= '0')) ||
                                            (strVers[j] == '.')) { 
            // get only basic version info (until first non-digit or non-.)
              if ((strVers[j] &lt;= '9') &amp;&amp; (strVers[j] &gt;= '0')) {
                dCaps[i].glVersion += (strVers[j] - '0') &lt;&lt; shiftVal;
                shiftVal -= 4;
              }
              j++;
            }
          }
          strExt = glGetString (GL_EXTENSIONS);

          // get caps
          glGetIntegerv (GL_MAX_TEXTURE_UNITS, 
                         &amp;dCaps[i].textureUnits);
          glGetIntegerv (GL_MAX_TEXTURE_SIZE,
                         &amp;dCaps[i].maxTextureSize); 
          glGetIntegerv (GL_MAX_3D_TEXTURE_SIZE, 
                         &amp;dCaps[i].max3DTextureSize);
          glGetIntegerv (GL_MAX_CUBE_MAP_TEXTURE_SIZE, 
                         &amp;dCaps[i].maxCubeMapTextureSize);

          // get functionality info
          dCaps[i].fSpecularVector = 
            gluCheckExtension (&quot;GL_APPLE_specular_vector&quot;, strExt);
          dCaps[i].fTransformHint = 
            gluCheckExtension (&quot;GL_APPLE_transform_hint&quot;, strExt);
          dCaps[i].fPackedPixels = 
            gluCheckExtension (&quot;GL_APPLE_packed_pixels&quot;, strExt) || 
            gluCheckExtension (&quot;GL_APPLE_packed_pixel&quot;, strExt)  || 
            (dCaps[i].glVersion &gt;= 0x0120);
          dCaps[i].fClientStorage = 
            gluCheckExtension (&quot;GL_APPLE_client_storage&quot;, strExt);
          dCaps[i].fYCbCr = 
            gluCheckExtension (&quot;GL_APPLE_ycbcr_422&quot;, strExt);
          dCaps[i].fTextureRange = 
            gluCheckExtension (&quot;GL_APPLE_texture_range&quot;, strExt);
          dCaps[i].fFence = 
            gluCheckExtension (&quot;GL_APPLE_fence&quot;, strExt);
          dCaps[i].fVAR = 
            gluCheckExtension (&quot;GL_APPLE_vertex_array_range&quot;, strExt);
          dCaps[i].fVAO = 
            gluCheckExtension (&quot;GL_APPLE_vertex_array_object&quot;, strExt);
          dCaps[i].fElementArray = 
            gluCheckExtension (&quot;GL_APPLE_element_array&quot;, strExt);
          dCaps[i].fVPEvals = 
            gluCheckExtension(&quot;GL_APPLE_vertex_program_evaluators&quot;,strExt);
          dCaps[i].fFloatPixels = 
            gluCheckExtension (&quot;GL_APPLE_float_pixels&quot;, strExt);
          dCaps[i].fFlushRenderer = 
            gluCheckExtension (&quot;GL_APPLE_flush_render&quot;, strExt);
          dCaps[i].fPixelBuffer = 
            gluCheckExtension (&quot;GL_APPLE_pixel_buffer&quot;, strExt);
          dCaps[i].fImaging = 
            gluCheckExtension (&quot;GL_ARB_imaging&quot;, strExt);
          dCaps[i].fTransposeMatrix = 
            gluCheckExtension (&quot;GL_ARB_transpose_matrix&quot;, strExt) ||
            (dCaps[i].glVersion &gt;= 0x0130);
          dCaps[i].fMultitexture = 
            gluCheckExtension (&quot;GL_ARB_multitexture&quot;, strExt) ||
            (dCaps[i].glVersion &gt;= 0x0130);
          dCaps[i].fTexEnvAdd = 
            gluCheckExtension (&quot;GL_ARB_texture_env_add&quot;, strExt) ||
            gluCheckExtension (&quot;GL_EXT_texture_env_add&quot;, strExt) ||
            (dCaps[i].glVersion &gt;= 0x0130);
          dCaps[i].fTexEnvCombine = 
            gluCheckExtension (&quot;GL_ARB_texture_env_combine&quot;, strExt) ||
            (dCaps[i].glVersion &gt;= 0x0130);
          dCaps[i].fTexEnvDot3 = 
            gluCheckExtension (&quot;GL_ARB_texture_env_dot3&quot;, strExt) ||
            (dCaps[i].glVersion &gt;= 0x0130);
          dCaps[i].fTexEnvCrossbar = 
            gluCheckExtension (&quot;GL_ARB_texture_env_crossbar&quot;, strExt) ||
            (dCaps[i].glVersion &gt;= 0x0140);
          dCaps[i].fTexCubeMap = 
            gluCheckExtension (&quot;GL_ARB_texture_cube_map&quot;, strExt) ||
            (dCaps[i].glVersion &gt;= 0x0130);
          dCaps[i].fTexCompress = 
            gluCheckExtension (&quot;GL_ARB_texture_compression&quot;, strExt) ||
            (dCaps[i].glVersion &gt;= 0x0130);
          dCaps[i].fMultisample = 
            gluCheckExtension (&quot;GL_ARB_multisample&quot;, strExt) ||
            (dCaps[i].glVersion &gt;= 0x0130);
          dCaps[i].fTexBorderClamp = 
            gluCheckExtension (&quot;GL_ARB_texture_border_clamp&quot;, strExt) ||
            (dCaps[i].glVersion &gt;= 0x0130);
          dCaps[i].fPointParam = 
            gluCheckExtension (&quot;GL_ARB_point_parameters&quot;, strExt) ||
            (dCaps[i].glVersion &gt;= 0x0140);
          dCaps[i].fVertexProg = 
            gluCheckExtension (&quot;GL_ARB_vertex_program&quot;, strExt);
          dCaps[i].fFragmentProg = 
            gluCheckExtension (&quot;GL_ARB_fragment_program&quot;, strExt);
          dCaps[i].fTexMirrorRepeat = 
            gluCheckExtension (&quot;GL_ARB_texture_mirrored_repeat&quot;, strExt) ||
            (dCaps[i].glVersion &gt;= 0x0140);
          dCaps[i].fDepthTex = 
            gluCheckExtension (&quot;GL_ARB_depth_texture&quot;, strExt) ||
            (dCaps[i].glVersion &gt;= 0x0140);
          dCaps[i].fShadow = 
            gluCheckExtension (&quot;GL_ARB_shadow&quot;, strExt) ||
            (dCaps[i].glVersion &gt;= 0x0140);
          dCaps[i].fShadowAmbient = 
            gluCheckExtension (&quot;GL_ARB_shadow_ambient&quot;, strExt);
          dCaps[i].fVertexBlend = 
            gluCheckExtension (&quot;GL_ARB_vertex_blend&quot;, strExt);
          dCaps[i].fWindowPos = 
            gluCheckExtension (&quot;GL_ARB_window_pos&quot;, strExt) ||
            (dCaps[i].glVersion &gt;= 0x0140);
          dCaps[i].fTex3D = 
            gluCheckExtension (&quot;GL_EXT_texture3D&quot;, strExt) ||
            (dCaps[i].glVersion &gt;= 0x0120);
          dCaps[i].fClipVolHint = 
            gluCheckExtension (&quot;GL_EXT_clip_volume_hint&quot;, strExt);
          dCaps[i].fRescaleNorm = 
            gluCheckExtension (&quot;GL_EXT_rescale_normal&quot;, strExt) ||
            (dCaps[i].glVersion &gt;= 0x0120);
          dCaps[i].fBlendColor = 
            gluCheckExtension (&quot;GL_EXT_blend_color&quot;, strExt) ||
            gluCheckExtension (&quot;GL_ARB_imaging&quot;, strExt);
          dCaps[i].fBlendMinMax = 
            gluCheckExtension (&quot;GL_EXT_blend_minmax&quot;, strExt) ||
            gluCheckExtension (&quot;GL_ARB_imaging&quot;, strExt);
          dCaps[i].fBlendSub = 
            gluCheckExtension (&quot;GL_EXT_blend_subtract&quot;, strExt) ||
            gluCheckExtension (&quot;GL_ARB_imaging&quot;, strExt);
          dCaps[i].fCVA = 
            gluCheckExtension (&quot;GL_EXT_compiled_vertex_array&quot;, strExt);
          dCaps[i].fTexLODBias = 
            gluCheckExtension (&quot;GL_EXT_texture_lod_bias&quot;, strExt) ||
            (dCaps[i].glVersion &gt;= 0x0140);
          dCaps[i].fABGR = 
            gluCheckExtension (&quot;GL_EXT_abgr&quot;, strExt);
          dCaps[i].fBGRA = 
            gluCheckExtension (&quot;GL_EXT_bgra&quot;, strExt) ||
            (dCaps[i].glVersion &gt;= 0x0120);
          dCaps[i].fTexFilterAniso = 
            gluCheckExtension (&quot;GL_EXT_texture_filter_anisotropic&quot;,strExt);
          dCaps[i].fPaletteTex = 
            gluCheckExtension (&quot;GL_EXT_paletted_texture&quot;, strExt);
          dCaps[i].fShareTexPalette = 
            gluCheckExtension (&quot;GL_EXT_shared_texture_palette&quot;, strExt);
          dCaps[i].fSecColor = 
            gluCheckExtension (&quot;GL_EXT_secondary_color&quot;, strExt) ||
            (dCaps[i].glVersion &gt;= 0x0140);
          dCaps[i].fTexCompressS3TC = 
            gluCheckExtension (&quot;GL_EXT_texture_compression_s3tc&quot;, strExt);
          dCaps[i].fTexRect = 
            gluCheckExtension (&quot;GL_EXT_texture_rectangle&quot;, strExt);
          dCaps[i].fFogCoord = 
            gluCheckExtension (&quot;GL_EXT_fog_coord&quot;, strExt);
          dCaps[i].fDrawRangeElements = 
            gluCheckExtension (&quot;GL_EXT_draw_range_elements&quot;, strExt);
          dCaps[i].fStencilWrap = 
            gluCheckExtension (&quot;GL_EXT_stencil_wrap&quot;, strExt) ||
            (dCaps[i].glVersion &gt;= 0x0140);
          dCaps[i].fBlendFuncSep = 
            gluCheckExtension (&quot;GL_EXT_blend_func_separate&quot;, strExt) ||
            (dCaps[i].glVersion &gt;= 0x0140);
          dCaps[i].fMultiDrawArrays = 
            gluCheckExtension (&quot;GL_EXT_multi_draw_arrays&quot;, strExt) ||
            (dCaps[i].glVersion &gt;= 0x0140);
          dCaps[i].fShadowFunc = 
            gluCheckExtension (&quot;GL_EXT_shadow_funcs&quot;, strExt);
          dCaps[i].fStencil2Side = 
            gluCheckExtension (&quot;GL_EXT_stencil_two_side&quot;, strExt) ||
            (dCaps[i].glVersion &gt;= 0x0140);
          dCaps[i].fColorSubtable = 
            gluCheckExtension (&quot;GL_EXT_color_subtable&quot;, strExt) || 
            gluCheckExtension (&quot;GL_ARB_imaging&quot;, strExt);
          dCaps[i].fConvolution = 
            gluCheckExtension (&quot;GL_EXT_convolution&quot;, strExt) || 
            gluCheckExtension (&quot;GL_ARB_imaging&quot;, strExt);
          dCaps[i].fHistogram = 
            gluCheckExtension (&quot;GL_EXT_histogram&quot;, strExt) || 
            gluCheckExtension (&quot;GL_ARB_imaging&quot;, strExt);
          dCaps[i].fColorTable = 
            gluCheckExtension (&quot;GL_SGI_color_table&quot;, strExt) || 
            gluCheckExtension (&quot;GL_ARB_imaging&quot;, strExt);
          dCaps[i].fColorMatrix = 
            gluCheckExtension (&quot;GL_SGI_color_matrix&quot;, strExt) || 
            gluCheckExtension (&quot;GL_ARB_imaging&quot;, strExt);
          dCaps[i].fTexEdgeClamp = 
            gluCheckExtension (&quot;GL_SGIS_texture_edge_clamp&quot;, strExt) ||
            (dCaps[i].glVersion &gt;= 0x0120);
          dCaps[i].fGenMipmap = 
            gluCheckExtension (&quot;GL_SGIS_generate_mipmap&quot;, strExt);
          dCaps[i].fTexLOD = 
            gluCheckExtension (&quot;GL_SGIS_texture_lod&quot;, strExt) ||
            (dCaps[i].glVersion &gt;= 0x0120);
          dCaps[i].fPointCull = 
            gluCheckExtension (&quot;GL_ATI_point_cull_mode&quot;, strExt);
          dCaps[i].fTexMirrorOnce = 
            gluCheckExtension (&quot;GL_ATI_texture_mirror_once&quot;, strExt);
          dCaps[i].fPNtriangles = 
            gluCheckExtension (&quot;GL_ATI_pn_triangles&quot;, strExt) ||
            gluCheckExtension (&quot;GL_ATIX_pn_triangles&quot;, strExt);
          dCaps[i].fTextFragShader = 
            gluCheckExtension (&quot;GL_ATI_text_fragment_shader&quot;, strExt);
          dCaps[i].fBlendEqSep = 
            gluCheckExtension (&quot;GL_ATI_blend_equation_separate&quot;, strExt);
          dCaps[i].fBlendWeightMinMax = 
            gluCheckExtension (&quot;GL_ATI_blend_weighted_minmax&quot;, strExt);
          dCaps[i].fCombine3 = 
            gluCheckExtension (&quot;GL_ATI_texture_env_combine3&quot;, strExt);
          dCaps[i].fSepStencil = 
            gluCheckExtension (&quot;GL_ATI_separate_stencil&quot;, strExt);
          dCaps[i].fArrayRevComps4Byte = 
            gluCheckExtension (&quot;GL_ATI_array_rev_comps_in_4_bytes&quot;,strExt);
          dCaps[i].fPointSprite = 
            gluCheckExtension (&quot;GL_NV_point_sprite&quot;, strExt);
          dCaps[i].fRegCombiners = 
            gluCheckExtension (&quot;GL_NV_register_combiners&quot;, strExt);
          dCaps[i].fRegCombiners2 = 
            gluCheckExtension (&quot;GL_NV_register_combiners2&quot;, strExt);
          dCaps[i].fTexEnvCombine4 = 
            gluCheckExtension (&quot;GL_NV_texture_env_combine4&quot;, strExt);
          dCaps[i].fBlendSquare = 
            gluCheckExtension (&quot;GL_NV_blend_square&quot;, strExt) ||
            (dCaps[i].glVersion &gt;= 0x0140);
          dCaps[i].fFogDist = 
            gluCheckExtension (&quot;GL_NV_fog_distance&quot;, strExt);
          dCaps[i].fMultisampleFilterHint = 
            gluCheckExtension (&quot;GL_NV_multisample_filter_hint&quot;, strExt);
          dCaps[i].fTexGenReflect = 
            gluCheckExtension (&quot;GL_NV_texgen_reflection&quot;, strExt);
          dCaps[i].fTexShader = 
            gluCheckExtension (&quot;GL_NV_texture_shader&quot;, strExt);
          dCaps[i].fTexShader2 = 
            gluCheckExtension (&quot;GL_NV_texture_shader2&quot;, strExt);
          dCaps[i].fTexShader3 = 
            gluCheckExtension (&quot;GL_NV_texture_shader3&quot;, strExt);
          dCaps[i].fDepthClamp = 
            gluCheckExtension (&quot;GL_NV_depth_clamp&quot;, strExt);
          dCaps[i].fLightMaxExp = 
            gluCheckExtension (&quot;GL_NV_light_max_exponent&quot;, strExt);
          dCaps[i].fRasterPosClip = 
            gluCheckExtension (&quot;GL_IBM_rasterpos_clip&quot;, strExt);
          dCaps[i].fConvBorderModes = 
            gluCheckExtension (&quot;GL_HP_convolution_border_modes&quot;, strExt) ||
            gluCheckExtension (&quot;GL_ARB_imaging&quot;, strExt);

          if (dCaps[i].fTexRect) // only check if extension supported
            glGetIntegerv (GL_MAX_RECTANGLE_TEXTURE_SIZE_EXT,
                           &amp;dCaps[i].maxRectTextureSize);
          else
            dCaps[i].maxRectTextureSize = 0;

          CGLDestroyContext (cglContext);
        }
      }
      CGLSetCurrentContext (curr_ctx); // reset current CGL context
    }
  }
}
</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/OpenGL_Screensaver/listing12.html%3Fid%3DDTS10003169-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/OpenGL_Screensaver/listing12.html%3Fid%3DDTS10003169-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/OpenGL_Screensaver/listing12.html%3Fid%3DDTS10003169-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>