<!-- Generated by Harlequin WebMaker 2.2.3 (23-Apr-1996)
LispWorks 3.2.2 -->
<HTML> <HEAD>
<TITLE>Handling Operating-System Events(IM:Tb)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING41></A>


<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="Toolbox-40.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Toolbox-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Toolbox-490.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="Toolbox-42.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="Toolbox-2.html"><B>Macintosh Toolbox Essentials</B></A> / <BR><DD><A HREF="Toolbox-28.html"><B>Chapter 2 - Event Manager</B></A> / <A HREF="Toolbox-36.html"><B>Using the Event Manager</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING41-0></A>
<H2><A NAME=MARKER-9-234></A>Handling Operating-System Events</H2>
 <A NAME=MARKER-2-126></A>Operating-system events include suspend, resume, and mouse-moved events. Your application receives suspend and resume events as a result of changes in its processing status. Your application can request that the Event Manager return mouse-moved events whenever the cursor is outside a specified region by specifying a nonempty region in <BR>the <CODE>mouseRgn</CODE> parameter to <CODE>WaitNextEvent</CODE>. If you specify an empty region or a <CODE>NIL</CODE> region handle in the <CODE>mouseRgn</CODE> parameter, the Event Manager does not report mouse- moved events.<P>
 Your application examines the event record to determine which event it received and to obtain additional information associated with the event.<P>
 The <CODE>what</CODE> field in the event record of an operating-system event contains the <BR><CODE>osEvt</CODE> constant.<P>
 The <CODE>message</CODE> field in the event record of an operating-system event contains information indicating whether the event is a suspend, resume, or mouse-moved event. The <CODE>message</CODE> field also indicates whether Clipboard conversion is required when the application resumes execution. The bits in the <CODE>message</CODE> field give this information: <A NAME=MARKER-2-221></A>
<TABLE BORDER="0" CELLPADDING=3><TH ALIGN=LEFT>Bit<TH>Contents<TR>
<TD>0<TD>0 if a suspend event<TR>
<TD>&nbsp;<TD>1 if a resume event<TR>
<TD>1<TD>0 if Clipboard conversion not required<TR>
<TD>&nbsp;<TD>1 if Clipboard conversion required<TR>
<TD>2-23<TD>Reserved<TR>
<TD>24-31<TD><CODE>suspendResumeMessage</CODE> if a suspend or resume event<BR><CODE>mouseMovedMessage</CODE> if a mouse-moved event</TABLE>
<P>
 Note that you need to examine bits 24-31 of the <CODE>message</CODE> field to determine what kind of operating-system event you have received. Bits 24-31 in the <CODE>message</CODE> field contain one of these two constants:<P>
<PRE>
CONST suspendResumeMessage = $01;      {suspend or resume event}
      mouseMovedMessage    = $FA;      {mouse-moved event}
</PRE>
 If the event is a suspend or resume event, you need to examine bit 0 to determine whether that event is a suspend or resume event. Bits 0 and 1 are meaningful only if bits 24-31 indicate that the event is a suspend or resume event. You can use the <CODE>resumeFlag</CODE> constant to determine whether the event is a suspend or resume event. If the event is a resume event, you can use the <CODE>convertClipboardFlag</CODE> constant to determine whether Clipboard conversion from the Clipboard to your application's scrap is required:<P>
<PRE>
CONST resumeFlag           = 1;  {resume event}
      convertClipboardFlag = 2;  {Clipboard conversion required}
</PRE>
 Whenever the user performs a copy or cut operation, your application should copy the selected data either to its private scrap or, if your application doesn't have a private scrap, to the Clipboard. If your application uses a private scrap, you need to convert the data from your private scrap to the Clipboard whenever your application receives a suspend event. Likewise, you need to convert any data from the Clipboard (if it has changed) when your application receives a resume event. For resume events, the value of bit 1 of the <CODE>message</CODE> field is 1 if your application needs to read in the new contents of the Clipboard.<P>
 <A HREF=#MARKER-9-237>Listing 2-13</A> shows a procedure that responds to operating-system events.<P>
<B>Listing 2-13  <A NAME=MARKER-9-237></A>Responding to operating-system events<A NAME=MARKER-2-219></A></B><P>
<PRE>
PROCEDURE DoOSEvent (event: EventRecord);
BEGIN
   CASE BAnd(BRotL(event.message, 8), $FF) OF {get high byte}
      mouseMovedMessage:
         DoIdle(event); {mouse-moved same as idle for this app}
      suspendResumeMessage:
         DoSuspendResumeEvent(event);{handle supend/resume event}
   END;  
END;           
</PRE>
 The <CODE>DoOSEvent</CODE> procedure in <A HREF=#MARKER-9-237>Listing 2-13</A> is called from the <CODE>DoEvent</CODE> procedure (shown in <A HREF=Toolbox-38.html#MARKER-9-110>Listing 2-3 on page 2-26</A>) whenever the application receives an operating-system event. The <CODE>DoOSEvent</CODE> procedure examines the high byte of the <CODE>message</CODE> field to determine whether the event is a mouse-moved, suspend, or resume event, and it then calls an application-defined procedure to handle the event. Note that most applications either adjust the cursor in response to mouse-moved events or adjust the cursor in their event loop whenever any type of event is received. The code in this chapter uses the latter approach, and thus the <CODE>DoOSEvent</CODE> procedure simply calls its <CODE>DoIdle</CODE> procedure in response to mouse-moved events. The next two sections show the code that handles suspend, resume, and mouse-moved events.<P>
<A NAME=HEADING41-14></A>
<H3><A NAME=MARKER-9-239></A>Responding to Suspend and Resume Events</H3>
 <A NAME=MARKER-2-212></A>The <CODE>WaitNextEvent</CODE> function returns a suspend event when your application is about to be switched to the background. <CODE>WaitNextEvent</CODE> returns a resume event when your application becomes the foreground process again. <P>
 Upon receiving a suspend event, your application should deactivate the front window, remove the highlighting from any selections, and hide any floating windows. Your application should also convert any private scrap into the global scrap, if necessary. <BR>If your application shows a window that displays the Clipboard contents, you should hide this window also, as the user might change the contents of the Clipboard before returning to your application. Your application can also do anything else necessary to <BR>get ready for a major switch. Then your application should call <CODE>WaitNextEvent</CODE> to relinquish the processor and allow the Operating System to schedule other processes <BR>for execution. <A NAME=MARKER-2-216></A><A NAME=MARKER-9-105></A><P>
 Upon receiving a resume event, your application should activate the front window and restore any windows to the state the user left them in at the time of the previous suspend event. For example, your application should show scroll bars, restore any selections that were previously in effect, and show any floating windows. Your application should copy the contents of the Clipboard and convert the data back to its private scrap, if necessary. If your application shows a window that displays the Clipboard contents, you can update the contents of the window after reading in the scrap. Your application can then resume interacting with the user. <P>
 Responding to a suspend or resume event usually involves activating or deactivating windows. If you set the <CODE>acceptSuspendResumeEvents</CODE> flag and the <CODE>doesActivateOnFGSwitch</CODE> flag in your application's <CODE>'SIZE'</CODE> resource, your application is responsible for activating or deactivating your application's windows <BR>in response to handling suspend and resume events. <P>
<DL>
<DT><B>Note</B>
<DD>If you set the <CODE>acceptSuspendResumeEvents</CODE> flag and do not set the <CODE>doesActivateOnFGSwitch</CODE> flag in your application's <CODE>'SIZE'</CODE> resource, your application receives an activate event immediately following a suspend or resume event. In most cases, you should set both the <CODE>acceptSuspendResumeEvents</CODE> and <CODE>doesActivateOnFGSwitch</CODE> flags in your application's <CODE>'SIZE'</CODE> resource. <EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
 Your application can use the Scrap Manager functions <CODE>InfoScrap</CODE>, <CODE>ZeroScrap</CODE>, <CODE>PutScrap<DFN>, </DFN></CODE>and <CODE>GetScrap</CODE> to read data from and write data to the Clipboard. <BR>See the chapter "Scrap Manager" in <I><A HREF="../MoreToolbox/MoreToolbox-2.html">Inside Macintosh: More Macintosh Toolbox</A></I> for <BR>additional details. <A NAME=MARKER-2-277></A><A NAME=MARKER-2-107></A><P>
<DL>
<DT><B>Note</B>
<DD>If your application does not handle suspend and resume events (as indicated by a flag in its <CODE>'SIZE'</CODE> resource), then the Operating System has to trick your application into performing scrap coercion to ensure that the contents of the Clipboard can be transferred from one applica- tion to another. This process adds to the time it takes to move the foreground application to the background and vice versa.<A NAME=MARKER-9-151></A> <EM>u</EM>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
 <A HREF=#MARKER-9-246>Listing 2-14</A> shows a procedure that responds to suspend and resume events. The <CODE>DoSuspendResumeEvent</CODE> procedure first gets a pointer to the front window using <BR>the Window Manager function <CODE>FrontWindow</CODE>. It then examines bit 0 of the <CODE>message</CODE> field of the event record to determine whether the event is a suspend or resume event. <BR>If the event is a resume event, the code examines bit 1 of the <CODE>message</CODE> field of the <BR>event record to determine whether it needs to read in the contents of the scrap. If so, <BR>the code calls an application-defined routine, <CODE>MyConvertScrap</CODE>, that reads in the <BR>scrap and converts the contents to its private scrap. It then sets a private global flag, <CODE>gInBackground</CODE>, to <CODE>FALSE</CODE>, to indicate that the application is not in the background. It then calls another application-defined routine, <CODE>DoActivate</CODE> (shown in <A HREF=Toolbox-40.html#MARKER-9-214>Listing 2-10</A>), to activate the application's front window.<P>
 For suspend events, the <CODE>DoSuspendResumeEvent</CODE> procedure calls the application-defined <CODE>MyConvertScrap</CODE> procedure to copy the contents of its private scrap to the global scrap. It then sets a private global flag, <CODE>gInBackground</CODE>, to <CODE>TRUE</CODE>, to indicate that the application is in the background. Finally, it calls another application-defined routine to deactivate the application's front window.<P>
<B>Listing 2-14  <A NAME=MARKER-9-246></A>Responding to suspend and resume events<A NAME=MARKER-2-223></A></B><P>
<PRE>
PROCEDURE DoSuspendResumeEvent (event: EventRecord);
VAR
   currentFrontWindow: WindowPtr;
BEGIN                         {handle suspend/resume event}
   currentFrontWindow := FrontWindow;
   IF (BAnd(event.message, resumeFlag) &lt;&gt; 0) THEN 
   BEGIN                {it's a resume event}
      IF (BAnd(event.message, convertClipboardFlag) &lt;&gt; 0) THEN
         MyConvertScrap(kClipboardToPrivate);
      gInBackground := FALSE;
                        {activate front window}
      DoActivate(currentFrontWindow, NOT gInBackground, event);
      MyShowClipboardWindow;  {show Clipboard window if it was }
                              { showing at last suspend event}
      MyShowFloatingWindows;  {show any floating windows}
   END
   ELSE

   BEGIN                {it's a suspend event}
      MyConvertScrap(kPrivateToClipboard);
      gInBackground := TRUE;
                        {deactivate front window}
      DoActivate(currentFrontWindow, NOT gInBackground, event);
      MyHideClipboardWindow; {hide Clipboard window if showing}
      MyHideFloatingWindows; {hide any floating windows}
   END;
END;           
</PRE>
 Your application can receive processing time while in the background and perform tasks in the background, but your application should not interact with the user or perform tasks that would slow down the responsiveness of the foreground process.<P>
 If you need to notify the user of some special occurrence while your application is executing in the background, you should use the Notification Manager to queue a notification request. See the chapter "Notification Manager" in <I>Inside Macintosh: <BR>Processes</I> for examples of how to post notification requests. <A NAME=MARKER-2-214></A><P>
<A NAME=HEADING41-28></A>
<H3><A NAME=MARKER-9-249></A>Responding to Mouse-Moved Events</H3>
 <A NAME=MARKER-2-517></A><A NAME=MARKER-2-516></A><A NAME=MARKER-2-97></A>Whenever the user moves the mouse, the mouse driver, the Event Manager, and your application are responsible for providing feedback to the user. The mouse driver performs low-level functions, such as continually polling the mouse for its location and status and maintaining the current location of the mouse in a global variable.<P>
 As the user moves the mouse, the user expects the cursor to move to a corresponding relative location on the screen. The low-level interrupt routines of the mouse driver map the movement of the mouse to relative locations on the screen. Whenever the user moves the mouse, a low-level interrupt routine of the mouse driver moves the cursor displayed on the screen and aligns the hot spot of the cursor with the new mouse location. A <B>hot spot</B> is a point that the mouse driver uses to align the cursor with the mouse location. <A NAME=MARKER-2-225></A><P>
 Your application is responsible for setting the initial appearance of the cursor, for restoring the cursor after <CODE>WaitNextEvent</CODE> returns, and for changing the appearance of the cursor as appropriate for your application. For example, most applications set the cursor to the I-beam when the cursor is inside a text-editing area of a document, and change the cursor to an arrow when the cursor is inside the scroll bar of a document. Your application can achieve this effect by requesting that the Event Manager report mouse-moved events if the user moves the cursor out of a region you specify in the <CODE>mouseRgn</CODE> parameter to the <CODE>WaitNextEvent</CODE> function. <A NAME=MARKER-2-98></A><P>
 The mouse driver and your application control the shape and appearance of the cursor. A cursor can be any 256-bit image, defined by a 16-by-16 bit square. The mouse driver displays the current cursor, which your application can change by using various cursor- handling routines (for example, the <CODE>SetCursor</CODE> procedure). <P>
 <A HREF=#MARKER-9-256>Figure 2-13</A> shows the standard arrow cursor. You can initialize the cursor to the standard arrow cursor using the <CODE>InitCursor</CODE> procedure. In <A HREF=#MARKER-9-256>Figure 2-13</A>, the hot spot <BR>for the arrow cursor is at location (1,1). See <I>Inside Macintosh: Imaging</I> for information on the cursor-handling routines and for specific details of how your application can define its own cursors. <A NAME=MARKER-2-292></A><P>
<B>Figure 2-13  <A NAME=MARKER-9-256></A>The standard arrow cursor</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/Figure_1-13_EV-12.jpg"><P>
 <A HREF=#MARKER-9-257>Figure 2-14</A> shows four other common cursors that are available to your application: the I-beam, crosshairs, plus sign, and wristwatch cursors. <P>
<B>Figure 2-14  <A NAME=MARKER-9-257></A>The I-beam, crosshairs, plus sign, and wristwatch cursors</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/Figure_1-14_EV-13.jpg"><P>
 The I-beam, crosshairs, plus sign, and wristwatch cursors are defined as resources, <BR>and your application can get a handle to any of these cursors by specifying their corresponding resource IDs to the <CODE>GetCursor</CODE> function. These constants specify the resource IDs for the I-beam, crosshairs, plus sign, and wristwatch cursors: <A NAME=MARKER-2-560></A><A NAME=MARKER-2-104></A><P>
<PRE>
CONST iBeamCursor = 1;{used in text editing}
      crossCursor = 2;{often used for manipulating graphics}
      plusCursor  = 3;{often used for selecting fields in }
                      { an array}
      watchCursor = 4;{used to mean a lengthy operation }
                      { is in progress}
</PRE>
 You can change the appearance of the cursor using the <CODE>SetCursor</CODE> procedure or other cursor-handling routines. You can also define your own cursors, store them in resources, and use them as needed in your application.<P>
 Your application usually needs to change the shape of the cursor as the user moves the cursor to different areas within a document. Your application can use mouse-moved events to accomplish this. Your application also needs to adjust the cursor in response to resume events. Most applications adjust the cursor once through the event loop in response to almost all events.<P>
 You can request that the Event Manager report mouse-moved events whenever <BR>the cursor is outside of a specified region that you pass as a parameter to the <CODE>WaitNextEvent</CODE> function. If you specify an empty region or a <CODE>NIL</CODE> handle to <BR>the <CODE>WaitNextEvent</CODE> function, <CODE>WaitNextEvent</CODE> does not report mouse-moved events.<P>
 If you specify a nonempty region in the <CODE>mouseRgn</CODE> parameter to the <CODE>WaitNextEvent</CODE> function, <CODE>WaitNextEvent</CODE> returns a mouse-moved event whenever the cursor is out of this region. For example, <A HREF=#MARKER-9-261>Figure 2-15</A> shows a document window. An application might define two regions: a region that encloses the text area of a window (the <I>I-beam region</I>), and a region that defines the scroll bars and all other areas outside the text area (the <I>arrow region</I>). By specifying the I-beam region to <CODE>WaitNextEvent</CODE>, the mouse driver continues to display the I-beam cursor until the user moves the cursor out of this region. <A NAME=MARKER-2-398></A><P>
<B>Figure 2-15  <A NAME=MARKER-9-261></A>The arrow region and the I-beam region</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/Figure_1-15_EV-18.jpg"><P>
 When the user moves the cursor out of the I-beam region, <CODE>WaitNextEvent</CODE> reports a mouse-moved event. Your application can then change the I-beam cursor to the arrow cursor and change the <CODE>mouseRgn</CODE> parameter to the area defined by the scroll bars and <BR>all other areas outside of the I-beam region. The cursor now remains an arrow until the user moves the cursor out of this region, at which point your application receives a mouse-moved event. <P>
 <A HREF=#MARKER-9-262>Figure 2-16</A> shows how an application might change the cursor from the I-beam cursor to the arrow cursor after receiving a mouse-moved event.<P>
<B>Figure 2-16  <A NAME=MARKER-9-262></A>Changing the cursor from the I-beam cursor to the arrow cursor</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/Figure_1-16_EV-16.jpg"><P>
 Note that your application should recalculate the <CODE>mouseRgn</CODE> parameter when it receives a mouse-moved event; otherwise, it will continue to receive mouse-moved events as long as the cursor position is outside the original region.<P>
 After receiving any event other than a high-level event, the MyEventLoop procedure (shown in <A HREF=Toolbox-38.html#MARKER-9-103>Listing 2-2</A> on <A HREF=Toolbox-38.html#MARKER-9-103>page 2-24</A>) calls the application-defined procedure <CODE>MyAdjustCursor</CODE> to adjust the cursor. After adjusting the cursor, if the event is an operating-system event, the <CODE>DoEvent</CODE> procedure calls the <CODE>DoOSEvent</CODE> procedure. The <CODE>DoOSEvent</CODE> procedure calls the <CODE>DoIdle</CODE> procedure for mouse-moved events. The <CODE>DoIdle</CODE> procedure simply calls <CODE>TEIdle</CODE> to blink the caret in the text-editing window.<P>
 <A NAME=MARKER-2-561></A><A HREF=#MARKER-9-264>Listing 2-15</A> shows the application-defined routine <CODE>MyAdjustCursor</CODE>.<P>
<B>Listing 2-15  <A NAME=MARKER-9-264></A>Changing the cursor<A NAME=MARKER-2-279></A></B><P>
<PRE>
PROCEDURE MyAdjustCursor (mouse: Point; VAR region: RgnHandle);
VAR
   window:        WindowPtr;
   arrowRgn:      RgnHandle;
   iBeamRgn:      RgnHandle;
   iBeamRect:     Rect;
   myData:        MyDocRecHnd;
   windowType:    Integer;
BEGIN
window := FrontWindow;
{determine the type of window--document, modeless, etc.}
windowType := MyGetWindowType(window);
CASE windowType OF
   kMyDocWindow:
   BEGIN
      {initialize regions for arrow and I-beam}
      arrowRgn := NewRgn;
      ibeamRgn := NewRgn;
      {set arrow region to large region at first}
      SetRectRgn(arrowRgn, -32768, -32768, 32766, 32766);
      {calculate I-beam region}
      {first get the document's TextEdit view rectangle}
      myData := MyDocRecHnd(GetWRefCon(window));
      iBeamRect := myData^^.editRec^^.viewRect;
      SetPort(window);
      WITH iBeamRect DO
      BEGIN
         LocalToGlobal(topLeft);
         LocalToGlobal(botRight);
      END;
      RectRgn(iBeamRgn, iBeamRect);
      WITH window^.portBits.bounds DO
         SetOrigin(-left, -top); 
      {intersect I-beam region with window's visible region}
      SectRgn(iBeamRgn, window^.visRgn, iBeamRgn);
      SetOrigin(0,0);
      {calculate arrow region by subtracting I-beam region}
      DiffRgn(arrowRgn, iBeamRgn, arrowRgn);
      {change the cursor and region parameter as necessary}
      IF PtInRgn(mouse, iBeamRgn) THEN {cursor is in I-beam rgn}
      BEGIN                   
         SetCursor(GetCursor(iBeamCursor)^^);      {set to I-beam}
         CopyRgn(iBeamRgn, region);     {update the region param}
      END;
      {update cursor if in arrow region}
      IF PtInRgn(mouse, arrowRgn) THEN {cursor is in arrow rgn}
      BEGIN
         SetCursor(arrow);             {set cursor to the arrow}
         CopyRgn(arrowRgn, region);    {update the region param}
      END;
      DisposeRgn(iBeamRgn);
      DisposeRgn(arrowRgn);
   END; {of kMyDocWindow}
   kMyGlobalChangesID:
      MyCalcCursorRgnForModelessDialogBox(window, region);
   kNil:
   BEGIN
      MySetRegionNoWindows(kNil, region);
      SetCursor(arrow);
   END;
 END; {of CASE}
END;
</PRE>
 The <CODE>MyAdjustCursor</CODE> procedure sets the cursor appropriately, according to whether a document window or modeless dialog box is active. <P>
 For a document window, the code in <A HREF=#MARKER-9-264>Listing 2-15</A> defines two regions, specified by <BR>the <CODE>arrowRgn</CODE> and <CODE>iBeamRgn</CODE> variables. If the cursor is inside the region described <BR>by the <CODE>arrowRgn</CODE> variable, the code sets the cursor to the arrow cursor and returns the region described by <CODE>arrowRgn</CODE>. Similarly, if the cursor is inside the region described <BR>by the <CODE>iBeamRgn</CODE> variable, the code sets the cursor to the I-beam cursor and returns <BR>the region described by <CODE>iBeamRgn</CODE>.<P>
 The <CODE>MyAdjustCursor</CODE> procedure calculates the two regions by first setting the arrow region to the largest possible region. It then sets the I-beam region to the region described by the document's TextEdit view rectangle. This region typically corresponds to the content area of the window minus the scroll bars. (If your application doesn't <BR>use TextEdit for its document window, then set this region as appropriate to your application.) The code then adjusts the I-beam region so that it includes only the part of the content area that is in the window's visible region (for example, to take into account any floating windows that might be over the window). The code then sets the arrow region to include the entire screen except for the region occupied by the I-beam region.<A NAME=MARKER-2-266></A><P>
 The procedure then determines which region the cursor is in and sets the cursor and region parameter appropriately. <A NAME=MARKER-2-176></A><A NAME=MARKER-2-268></A><A NAME=MARKER-2-269></A><A NAME=MARKER-2-503></A><P>
 For modeless dialog boxes (for example, the Global Changes modeless dialog box), the <CODE>MyAdjustCursor</CODE> procedure calls an application-defined routine to appropriately adjust the cursor for the modeless dialog box. The <CODE>MyAdjustCursor</CODE> procedure also appropriately adjusts the cursor if no windows are currently open.<P>
</BLOCKQUOTE>
<HR>
<center>
<A HREF="Toolbox-40.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Toolbox-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Toolbox-490.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="Toolbox-42.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="Toolbox-3.html">&copy; Apple Computer, Inc.</A><br>11 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>  
