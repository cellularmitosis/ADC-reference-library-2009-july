<!-- Generated by Harlequin WebMaker 2.2.3 (23-Apr-1996)
LispWorks 3.2.2 -->
<HTML> <HEAD>
<TITLE>Converting Data Between a Private Scrap and the Scrap (IM: MTb)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING119></A>


<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="MoreToolbox-118.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="MoreToolbox-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="MoreToolbox-513.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="MoreToolbox-120.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="MoreToolbox-2.html"><B>More Macintosh Toolbox</B></A> / <BR><DD><A HREF="MoreToolbox-109.html"><B>Chapter 2 - Scrap Manager</B></A> / <A HREF="MoreToolbox-115.html"><B>Using the Scrap Manager</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING119-0></A>
<H2>Converting Data Between a Private Scrap and the Scrap<A NAME=MARKER-2-182></A></H2>
 If you use a private scrap, you need to copy the data from your private scrap to the scrap upon receiving a suspend event. Upon receiving a resume event, you need to determine whether the contents of the scrap have changed since the previous suspend event. If so, your application must be sure to use the new data in the scrap for the user's next Paste command (unless the user chooses Cut or Copy before choosing Paste). In addition, your application needs to update the contents of its Clipboard window, if necessary.<P>
 <A HREF=#MARKER-9-116>Listing 2-7</A> shows the application-defined procedure <CODE>MyConvertScrap</CODE>. This procedure is called either indirectly as a result of a resume event (indicated by the <CODE>kClipboardToPrivate</CODE>, constant) or directly as a result of a suspend event (indicated by the <CODE>kPrivateToClipboard</CODE> constant). If the <CODE>whichWay</CODE> parameter contains <CODE>kClipboardToPrivate</CODE>, then the contents of the scrap have changed. In this <BR>case, <CODE>MyConvertScrap</CODE> uses <CODE>GetScrap</CODE> to read the contents of the scrap. The <CODE>MyConvertScrap</CODE> procedure checks the scrap for <CODE>'PICT'</CODE> data first, and then for <CODE>'TEXT'</CODE> data if the scrap doesn't contain any data in <CODE>'PICT'</CODE> format. <CODE>MyConvertScrap</CODE> then copies this data to its private scrap. <P>
 If the <CODE>MyConvertScrap</CODE> procedure is called as a result of a suspend event, the procedure copies the data from its private scrap to the scrap. It writes the data to the scrap in its own private format, in <CODE>'PICT'</CODE> format, and, if appropriate, in <CODE>'TEXT'</CODE> format. <P>
<B>Listing 2-7  <A NAME=MARKER-9-116></A>Converting data between the scrap and a private scrap<A NAME=MARKER-2-200></A></B><P>
<PRE>
PROCEDURE MyConvertScrap (whichWay: Integer);
VAR
   sizeOfTextData:   LongInt;
   sizeOfPictData:   LongInt;
   offset:           LongInt;
   hDest:            Handle;
   ptrToScrapData:   Ptr;
   length:           LongInt;
   myLongErr:        LongInt;
BEGIN
   IF whichWay = kClipboardToPrivate THEN
   BEGIN {copy scrap to private scrap}
      sizeOfPictData := GetScrap(NIL, 'PICT', offset);
      IF sizeOfPictData &gt; 0 THEN
      BEGIN
         {get handle to hold data from scrap, GetScrap }
         hDest := NewHandle(0);  { automatically resizes it}
         HLock(hDest);
         {put data into memory referenced by hDest handle}
         sizeOfPictData := GetScrap(hDest, 'PICT', offset);
         MyCopyToPrivateScrap(hDest);
         HUnlock(hDest);
         DisposeHandle(hDest);
      END
      ELSE  {if no 'PICT' data on scrap, check for 'TEXT'}
      BEGIN
         sizeOfTextData := GetScrap(NIL, 'TEXT', offset);
         IF sizeOfTextData &gt; 0 THEN
         BEGIN
            {allocate handle to hold scrap data--GetScrap }
            hDest := NewHandle(0);  { automatically resizes it}
            HLock(hDest);
            {put data into memory referenced by hDest handle}
            sizeOfTextData := GetScrap(hDest, 'TEXT', offset);
            {copy data to private scrap}
            MyCopyToPrivateScrap(hDest);
            HUnlock(hDest);
            DisposeHandle(hDest);
         END
      END;
   END
   ELSE
   BEGIN {copy private scrap into scrap}
      IF MyGetPrivateScrapSize &gt; 0 THEN   {if private scrap }
         myLongErr := ZeroScrap; { not empty, clear the scrap}
      ptrToScrapData := NewPtr(kDefaultSize);
      {retrieve data from private scrap in private format}
      IF (MyGetScrap('SURF', ptrToScrapData, length) &gt; 0) THEN
      BEGIN    {copy data to the scrap}
         myLongErr := PutScrap(length, 'SURF', ptrToScrapData);
         IF myLongErr &lt;&gt; noErr THEN DoError(myLongErr);
      END;
      {retrieve data from private scrap in 'PICT' format}
      IF (MyGetScrap('PICT', ptrToScrapData, length) &gt; 0) THEN
      BEGIN    {copy data to the scrap}
         myLongErr := PutScrap(length, 'PICT', ptrToScrapData);
         IF myLongErr &lt;&gt; noErr THEN DoError(myLongErr);
      END;
      {retrieve data from private scrap in 'TEXT' format}
      IF (MyGetScrap('TEXT', ptrToScrapData, length) &gt; 0) THEN
      BEGIN    {copy data to the scrap}
         myLongErr := PutScrap(length, 'TEXT', ptrToScrapData);
         IF myLongErr &lt;&gt; noErr THEN DoError(myLongErr);
      END;
      DisposePtr(ptrToScrapData);
   END;
END;
</PRE>
</BLOCKQUOTE>
<HR>
<center>
<A HREF="MoreToolbox-118.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="MoreToolbox-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="MoreToolbox-513.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="MoreToolbox-120.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="MoreToolbox-3.html">&copy; Apple Computer, Inc.</A><br>6 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>   
