/*	File:		MovieFile.c	Contains:	Movie file support for simple text application	Version:	SimpleText 1.4 or later** Copyright 1993-1996 Apple Computer. All rights reserved.****	You may incorporate this sample code into your applications without**	restriction, though the sample code has been provided "AS IS" and the**	responsibility for its operation is 100% yours.  However, what you are**	not permitted to do is to redistribute the source as "DSC Sample Code"**	after having made changes. If you're going to re-distribute the source,**	we require that you make it clear in the source that the code was**	descended from Apple Sample Code, but that you've made changes.*/#include "MacIncludes.h"#include "MovieFile.h"#pragma segment MovieFile// --------------------------------------------------------------------------------------------------------------static void DoFindInMovie(Movie theMovie, long *searchOffset, Boolean goBackwards){	Track	searchTrack = nil;	OSErr	anErr;		if (goBackwards)		(*searchOffset)--;	else		(*searchOffset)++;	anErr = MovieSearchText(theMovie, (Ptr)&gFindString[1], gFindString[0],				(gWrapAround ? findTextWrapAround : 0) |				(gCaseSensitive ? findTextCaseSensitive : 0) |				findTextUseOffset |				(goBackwards ? findTextReverseSearch : 0),				&searchTrack, (TimeValue*)nil, searchOffset);					if (anErr)		SysBeep(1);		} // DoFindInMovie// --------------------------------------------------------------------------------------------------------------static OSErr	MovieAdjustMenus(WindowRef pWindow, WindowDataPtr pData){#pragma unused (pWindow)	if (GetMovieIndTrackType( ((MovieDataPtr)pData)->theMovie, 1, 'text', movieTrackCharacteristic) != nil)		{		EnableCommand(cFind);		if (gFindString[0] != 0)			EnableCommand(cFindAgain);		}	return noErr;	} // MovieAdjustMenus// --------------------------------------------------------------------------------------------------------------static OSErr	MovieCommand(WindowRef pWindow, WindowDataPtr pData, short commandID, long menuResult){#pragma unused (pWindow, menuResult)	OSErr	anErr = noErr;		switch (commandID)		{		case cFind:			if (ConductFindOrReplaceDialog(kFindWindowID) == cancel)				break;				case cFindAgain:			DoFindInMovie(((MovieDataPtr)pData)->theMovie, 						&((MovieDataPtr)pData)->searchOffset,						((gEvent.modifiers & shiftKey) != 0));			break;		}		return(anErr);	} // MovieCommand// --------------------------------------------------------------------------------------------------------------static OSErr	MovieCloseWindow(WindowRef pWindow, WindowDataPtr pData){#pragma unused (pWindow)	DisposeMovieController( ((MovieDataPtr)pData)->thePlayer);	DisposeMovie( ((MovieDataPtr)pData)->theMovie);	CloseMovieFile(pData->resRefNum);	pData->resRefNum = -1;		return(noErr);	} // MovieCloseWindow// --------------------------------------------------------------------------------------------------------------static OSErr MovieAdjustCursor(WindowRef pWindow, WindowDataPtr pData, Point *localMouse, Rect *globalRect){#pragma unused (pWindow, pData, globalRect, localMouse)		return(eActionAlreadyHandled);	} // MovieAdjustCursor// --------------------------------------------------------------------------------------------------------------static OSErr	MovieGetBalloon(WindowRef pWindow, WindowDataPtr pData, 		Point *localMouse, short * returnedBalloonIndex, Rect *returnedRectangle){#pragma unused (pWindow, pData, localMouse, returnedRectangle)	*returnedBalloonIndex = iDidTheBalloon;		return(noErr);	} // MovieGetBalloon// --------------------------------------------------------------------------------------------------------------static Boolean	MovieFilterEvent(WindowRef pWindow, WindowDataPtr pData, EventRecord *pEvent){#pragma unused (pWindow)		return(MCIsPlayerEvent( ((MovieDataPtr)pData)->thePlayer, pEvent));	} // MovieFilterEvent// --------------------------------------------------------------------------------------------------------------static long MovieCalculateIdleTime(WindowRef pWindow, WindowDataPtr pData){#pragma unused (pWindow, pData)	if (!IsMovieDone( ((MovieDataPtr)pData)->theMovie))		return(0);	else		return(0x7FFFFFFF);		} // MovieCalculateIdleTime// --------------------------------------------------------------------------------------------------------------static OSErr	MovieMakeWindow(WindowRef pWindow, WindowDataPtr pData){	OSErr				anErr;	short				actualResId;	Movie				theMovie;	MovieController		thePlayer;	Rect				movieBounds;	long				version;		Gestalt(gestaltQuickTime, &version);		pData->pAdjustMenus			= (AdjustMenusProc)			MovieAdjustMenus;	pData->pCommand				= (CommandProc)				MovieCommand;	pData->pCloseWindow 		= (CloseWindowProc)			MovieCloseWindow;	pData->pFilterEvent 		= (FilterEventProc)			MovieFilterEvent;	pData->pGetBalloon 			= (GetBalloonProc)			MovieGetBalloon;	pData->pCalculateIdleTime	= (CalculateIdleTimeProc)	MovieCalculateIdleTime;	pData->pAdjustCursor		= (AdjustCursorProc)		MovieAdjustCursor;	pData->dragWindowAligned	= (version >= 0x01508000);		actualResId = DoTheRightThing;	// close down other paths to the file -- because we don't need them	if (pData->resRefNum != -1)		{		CloseResFile(pData->resRefNum);		pData->resRefNum = -1;		}	if (pData->dataRefNum != -1)		{		FSClose(pData->dataRefNum);		pData->dataRefNum = -1;		}	anErr = OpenMovieFile(&pData->fileSpec, &pData->resRefNum, 0);	if (anErr == noErr)		{		anErr = NewMovieFromFile(&theMovie, pData->resRefNum, &actualResId, (unsigned char *) 0, newMovieActive, (Boolean *) 0);		if (anErr == noErr)			anErr = GetMoviesError();		nrequire(anErr, NewMovieFromFile);		}		// position the movie	GetMovieBox(theMovie, &movieBounds);	OffsetRect(&movieBounds, -movieBounds.left, -movieBounds.top);	SetMovieBox(theMovie, &movieBounds);	OffsetRect(&movieBounds, pData->contentRect.left, pData->contentRect.top);	// make it draw in the correct window	SetMovieGWorld(theMovie, (CGrafPtr) pWindow, 0);	thePlayer = NewMovieController(theMovie, &movieBounds, mcTopLeftMovie);	MCGetControllerBoundsRect(thePlayer, &movieBounds);	// make sure the window is the proper size	SizeWindow(pWindow, movieBounds.right - movieBounds.left,							movieBounds.bottom - movieBounds.top, false);	pData->contentRect.right = pData->contentRect.left + 		movieBounds.right - movieBounds.left;	pData->contentRect.bottom = pData->contentRect.top + 		movieBounds.bottom - movieBounds.top;	if (pData->dragWindowAligned)		AlignWindow((WindowPtr)pWindow, false, nil, nil);		// enable keyboard events	MCDoAction(thePlayer, mcActionSetKeysEnabled, (void*)1);		// Save a reference to the movie	((MovieDataPtr)pData)->theMovie = theMovie;	((MovieDataPtr)pData)->thePlayer = thePlayer;	((MovieDataPtr)pData)->searchOffset = 0;	// FALL THROUGH EXCEPTION HANDLINGNewMovieFromFile:	return(anErr);	} // MovieMakeWindow// --------------------------------------------------------------------------------------------------------------OSErr	MoviePreflightWindow(PreflightPtr pPreflightData){		pPreflightData->continueWithOpen 	= true;	pPreflightData->makeProcPtr 		= MovieMakeWindow;	pPreflightData->resourceID			= kMovieWindowID;	pPreflightData->storageSize 		= sizeof(MovieDataRecord);	return(noErr);	} // MoviePreflightWindow// --------------------------------------------------------------------------------------------------------------void MovieGetFileTypes(OSType * pFileTypes, OSType * pDocumentTypes, short * numTypes){	if (gMachineInfo.haveQuickTime)		{		pFileTypes[*numTypes] 		= 'MooV';		pDocumentTypes[*numTypes] 	= kMovieWindow;		(*numTypes)++;		}		} // MovieGetFileTypes