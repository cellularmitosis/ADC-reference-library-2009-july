<!-- Generated by Harlequin WebMaker 2.2.3 (23-Apr-1996)
LispWorks 3.2.2 -->
<HTML> <HEAD>
<TITLE>Writing a Control Panel Function  (IM: MTb)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING461></A>


<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="MoreToolbox-460.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="MoreToolbox-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="MoreToolbox-513.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="MoreToolbox-462.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="MoreToolbox-2.html"><B>More Macintosh Toolbox</B></A> / <BR><DD><A HREF="MoreToolbox-453.html"><B>Chapter 8 - Control Panels</B></A> / <A HREF="MoreToolbox-457.html"><B>Creating Control Panel Files</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING461-0></A>
<H2><A NAME=MARKER-9-156></A>Writing a <A NAME=MARKER-9-157></A>Control Panel Function<A NAME=MARKER-2-402></A> </H2>
  <A NAME=MARKER-2-242></A>A control panel requires a control device (<CODE>'cdev'</CODE>) code resource, which contains the code t<A NAME=MARKER-9-210></A>hat implements the feature your control panel provides. The first piece of code in this resource must be a control device function that adheres to a defined interface. When the user opens your control panel, the Finder loads your code resource (of type <CODE>'cdev'</CODE>) into memory.<A NAME=MARKER-2-405></A><A NAME=MARKER-2-62></A><P>
 The Finder calls your control device function, requesting it to perform the action indicated by the <CODE>message</CODE> parameter, in response to events and the user's interaction with your control panel. Your control device function should perform the requested action and return a function result to the Finder. Your control device function should return as its function result either a standard value indicating that it has not allocated storage, a handle to any storage it has allocated, or an error code. Here is how you declare a control device function: <P>
<PRE>
FUNCTION MyCdev(message, item, numItems, CPrivateValue: Integer;
                VAR theEvent: EventRecord; 
                cdevStorageValue: LongInt; 
                CPDialog: DialogPtr): LongInt; 
</PRE>
 The <CODE>message</CODE> parameter can contain any of the values defined by these constants:<A NAME=MARKER-2-163></A><P>
<PRE>
CONST
   macDev      = 8;  {determine whether control panel can run}
   initDev     = 0;  {perform initialization}
   hitDev      = 1;  {handle click in enabled item}
   updateDev   = 4;  {respond to update event}
   activDev    = 5;  {respond to activate event}
   deActivDev  = 6;  {respond to control panel becoming inactive}
   keyEvtDev   = 7;  {respond to key-down or auto-key event}
   undoDev     = 9;  {handle Undo command}
   cutDev      = 10; {handle Cut command}
   copyDev     = 11; {handle Copy command}
   pasteDev    = 12; {handle Paste command}
   clearDev    = 13; {handle Clear command}
   nulDev      = 3;  {respond to null event}
   closeDev    = 2;  {respond to user closing control panel}
</PRE>
 These constants (as specified in the <CODE>message</CODE> parameter) indicate that your control device function should perform the following actions:<P>
<UL>
<LI><CODE><A NAME=MARKER-2-164></A>macDev</CODE>. Determine whether the control panel can run on the current system, and return a function result of 1 if it can and 0 if it cannot. 
<LI><CODE><A NAME=MARKER-2-165></A>initDev</CODE>. Perform initialization.
<LI><CODE><A NAME=MARKER-2-166></A>hitDev</CODE>. Handle a click in an enabled item.
<LI><CODE><A NAME=MARKER-2-167></A>updateDev</CODE>. Update any user items and redraw any controls that are not standard dialog items handled by the Dialog Manager.
<LI><CODE><A NAME=MARKER-2-168></A>activDev</CODE>. Respond to your control panel becoming active by making the default button and any other controls in your control panel active.
<LI><CODE><A NAME=MARKER-2-169></A>deActivDev</CODE>. Respond to your control panel becoming inactive by making the default button and any other controls in your control panel inactive.
<LI><CODE><A NAME=MARKER-2-170></A>keyEvtDev</CODE>. Handle a key-down or auto-key event.
<LI><CODE><A NAME=MARKER-2-171></A>undoDev</CODE>. Handle an Undo command. 
<LI><CODE><A NAME=MARKER-2-172></A>cutDev</CODE>. Handle a Cut command.
<LI><CODE><A NAME=MARKER-2-173></A>copyDev</CODE>. Handle a Copy command.
<LI><CODE><A NAME=MARKER-2-174></A>pasteDev</CODE>. Handle a Paste command.
<LI><CODE><A NAME=MARKER-2-175></A>clearDev</CODE>. Handle the Clear command.
<LI><CODE><A NAME=MARKER-2-176></A>nulDev</CODE>. Handle a null event by performing any idle processing.<A NAME=MARKER-2-177></A>
<LI><CODE><A NAME=MARKER-2-178></A>closeDe</CODE>v. Handle a click in the close box by terminating, after disposing of any handles and pointers created by your function. <P>
</UL>
 The control device function that implements the River control panel used as an example in this chapter shows one way of handling messages from the Finder. In this scenario, the user sets the screen saver's characteristics using the River control panel. The River control panel (<CODE>'cdev'</CODE>) file includes a system extension that displays the screen saver when the user signals it to do so. The River control panel uses the system extension to display the screen saver using the current settings whenever the user clicks the panel's default button (Show Me). (See <A HREF=MoreToolbox-458.html#MARKER-9-98>Figure 8-6</A> on <A HREF=MoreToolbox-458.html#MARKER-9-98>page 8-13</A>.)<P>
 The River control device function reads control settings from a resource stored in its preferences file, which is stored in the Preferences folder, and writes new values to that file at certain points after the user changes control settings. The control device function alerts the system extension of changes in the preferences file, and the system extension gets the new values to use from the preferences file. <P>
 In addition to the required resources, the River control device function uses a number of private resources that are included in the control panel file.<P>
 <A HREF=#MARKER-9-179>Listing 8-8</A> shows the River control panel's control device function, called <CODE>main</CODE>. To respond to requests from the Finder, the function uses a <CODE>CASE</CODE> statement that handles each type of message sent by the Finder. <P>
 The remainder of this section discusses each of these messages in detail and includes code showing how the River control panel processes the messages. <P>
<B>Listing 8-8  <A NAME=MARKER-9-179></A>A control device function</B><P>
<PRE>
UNIT RiverCP;
INTERFACE
      {include a Uses statement if your programming environment requires it}
CONST
   kShowMe                 = 1;
   kOnRadButton            = 3;
   kOffRadButton           = 4;
   kUphillRadButton        = 6;
   kDownhillRadButton      = 7;
   kCircularRadButton      = 8;
   kVelocityEditText       = 10;
   kUserItemUpArrow        = 11;
   kUserItemDownArrow      = 12;
   kPict                   = 13;
   kUserItemButtonOutline  = 15;
   kBabbleCheckBox         = 16;
   kRiverColorMenu         = 17;
TYPE
   MyRiverStorage = 
      RECORD
         err:              LongInt;
         count:            LongInt;
         settingsChanged:  Boolean;
      END;  
   MyRiverStoragePtr    = ^MyRiverStorage;
   MyRiverStorageHndl   = ^MyRiverStoragePtr;
FUNCTION main (message, item, numItems, CPrivateValue: Integer; 
               VAR theEvent: EventRecord; cdevStorageValue: LongInt; 
               CPDialog: DialogPtr): LongInt;
IMPLEMENTATION
FUNCTION main;
{any support routines used by your control panel function}
VAR
   myRiverHndl:         MyRiverStorageHndl;
   initDevOrMacDevMsg:  Boolean;
   okToRun:             LongInt;
   cpMemError:          Boolean;
BEGIN
   cpMemError := MyRoomToRun(message, cdevStorageValue);
   IF cpMemError THEN      {an error occurred or there isn't enough memory }
      main := cdevMemErr   { to run, return immediately}
   ELSE {handle the message}
   BEGIN
      IF (message &lt;&gt; macDev) AND (message &lt;&gt; initDev) THEN
         myRiverHndl := MyRiverStorageHndl(cdevStorageValue);
      CASE message OF
         macDev: {check machine characteristics}
            BEGIN
               MyCheckMachineCharacteristics(okToRun);
               main := okToRun;
            END;
         initDev:{perform initialization}
            MyInitializeCP(cdevStorageValue, CPDialog, myRiverHndl);
         hitDev: {user clicked dialog item}
            BEGIN
               item := item - numItems;
               MyHandleHitInDialogItem(item, cdevStorageValue, 
                                       CPDialog, myRiverHndl);
            END;
         activDev: {control panel is becoming active}
            MyActivateControlPanel(cdevStorageValue, CPDialog,
                                    myRiverHndl, TRUE);
         deActivDev: {control panel is becoming inactive}
            MyActivateControlPanel(cdevStorageValue, CPDialog,
                                    myRiverHndl, FALSE);
         updateDev: {update event -- draw any user items}
            MyUpdateControlPanel(cdevStorageValue, CPDialog, myRiverHndl);
         cutDev, copyDev, pasteDev, clearDev: {editing command}
            MyHandleEditCommand(message, CPDialog);
         keyEvtDev: {keyboard-related event}
            MyHandleKeyEvent(theEvent, CPDialog, message);
         nulDev:  {null event -- perform idle processing} 
            MyHandleIdleProcessing(cdevStorageValue, CPDialog, myRiverHndl);
         closeDev: {user closed control panel, release memory before exiting}
            MyCloseControlPanel(myRiverHndl, cdevStorageValue);
      END; {of CASE}
      IF message &lt;&gt; macDev THEN
         main := LongInt(cdevStorageValue);
   END;     {of handle message}
END;  {of main program}
END.
</PRE>
 When the Finder first calls your control device function, the current resource file is set to your control panel (<CODE>'cdev'</CODE>) file, the current graphics port is set to your control panel's dialog box, and the default volume is set to the System Folder of the current startup disk. Your control device function must preserve all of these settings. <P>
 Although the Finder intercedes with the system software and performs services on behalf of your control device function, it is your control device function's responsibility to detect and, if possible, recover from any error conditions. To avoid a memory error condition, your function should ensure that enough memory is available to handle the message from the Finder. On entry, the <CODE>main</CODE> function calls its <CODE>MyRoomToRun</CODE> procedure to perform this check. <P>
 The next sections describe how to handle each message passed in the <CODE>message</CODE> parameter. <P>
<A NAME=HEADING461-35></A>
<H3><A NAME=MARKER-9-180></A>Determining If a Control Panel Can Run on the Current System</H3>
 If<A NAME=MARKER-2-181></A> you want your control device function to determine if your control panel can run on the current system, specify the values in your machine resource accordingly (see <BR><A HREF=MoreToolbox-459.html#MARKER-9-13>Table 8-1 on page 8-21</A>). In this case, the Finder calls your function for the first time with a <CODE>macDev</CODE> message. The Finder calls your control device function with a <CODE>macDev</CODE> message only once. <P>
 In response to the <CODE>macDev</CODE> message, your control device function can check the hardware configuration of the current system. As necessary, your control device function should determine which computer it is being run on, what hardware is connected, and what is installed in the slots, if there are slots. The application-defined <CODE>MyCheckMachineCharacteristics</CODE> procedure, used in <A HREF=#MARKER-9-179>Listing 8-8 on page 8-27</A>, performs these checks for the River control panel. Your control device function should return either a 0 or a 1 as its function result in response to the <CODE>macDev</CODE> message. These values have specific meanings in response to a <CODE>macDev</CODE> message, and the Finder does not interpret them as error codes. If your control panel file can run on the current system, return a function result of 1; if your control panel file cannot run on it, return a function result of 0. If your function returns a result of 0, the Finder does not open your control panel; instead, it displays an alert box to the user.<A NAME=MARKER-2-182></A><A NAME=MARKER-2-183></A><P>
<DL>
<DT><B>Note</B>
<DD>If your machine resource specifies that your control panel runs on all systems, or if the machine resource identifes the restrictions that apply to your control panel, the Finder does not call your control device function with a <CODE>macDev</CODE> message.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
<A NAME=HEADING461-39></A>
<H3>Initializing the Control Panel Items and Allocating Storage</H3>
 If your control panel can run on the current system, the Finder calls your <A NAME=MARKER-2-184></A>control device function and specifies <CODE>initDev</CODE> in the <CODE>message</CODE> parameter. Except for a <CODE>macDev</CODE> message, your control device function should not process any other messages before it receives and successfully processes an <CODE>initDev</CODE> message. In response to an <CODE>initDev</CODE> message, your function should allocate any private storage it needs to implement its features<A NAME=MARKER-2-185></A>, initialize the settings of controls in the control panel, and perform any other necessary initialization tasks.<P>
 Because control panels cannot use normal global variables to retain information once the control device function returns, the interface between the Finder and the<A NAME=MARKER-2-186></A> control device function provides a way to preserve memory that your control device function might allocate. If, for example, your control device function allocates memory to save data between calls, you return a handle to the allocated memory as the function result in response to the Finder's <CODE>initDev</CODE> message. The next time it calls your function, the Finder passes this handle back as the value of the <A NAME=MARKER-2-187></A><CODE>cdevStorageValue</CODE> parameter. After sending an <CODE>initDev</CODE> message, the Finder always passes to your function the function result previously returned as the value of the <CODE>cdevStorageValue</CODE> parameter. In this way, the Finder makes the handle available to your function, until your function returns an error code. <P>
 When the Finder calls your function with the <CODE>initDev</CODE> message, it passes the constant <CODE><A NAME=MARKER-2-188></A>cdevUnset</CODE> in the <CODE>cdevStorageValue</CODE> parameter; this value indicates that your function has not allocated any memory. If you do not create a handle and allocate memory in response to the <CODE>initDev</CODE> message, you should return this value (<CODE>cdevUnset</CODE>) as your function result. In this case, the Finder continues to pass this value to your control device function, and your function should continue to return this value until your control device function encounters an error. <P>
 Before the Finder calls your function with an <CODE>initDev</CODE> message, it has already drawn the dialog box and any items defined in your item list resource, except for user items. During initialization, you set the default value for any controls, and, if necessary, draw any user items. You can store the default values for controls in a resource located in a <A NAME=MARKER-2-189></A>preferences file within the Preferences folder. To initially set the values for your panel's controls (such as radio buttons and checkboxes) and editable text, retrieve the default values from the resource and then use the Dialog Manager's<A NAME=MARKER-9-338></A> <CODE>GetDialogItem</CODE> procedure and the Control Manager's <CODE>SetControlValue</CODE> procedure.<P>
 The Finder calls QuickDraw to draw the static text for your control panel. QuickDraw uses the default application font for this purpose; for Roman scripts, this is 9-point Geneva. For System 7, you can include a font information (<CODE>'finf'</CODE>) resource in your control panel file to specify a font to be used for static text. <P>
 For example, you can use a font information resource to specify 12-point Chicago, which is the recommended font for Roman scripts. You can also use an <CODE>'finf'</CODE> resource to change the font of static text in control panels localized for other system scripts. If you include an <CODE>'finf'</CODE> resource, the Finder sets the font, font style, and font size for the graphics port to the values you specify and uses these values to draw any static text. See <A HREF=MoreToolbox-460.html#MARKER-9-137>"Specifying the Font of Text in a Control Panel" on page 8-23</A> for more information. <P>
<DL>
<DT><B>Note</B>
<DD>The Control Manager uses the system font for text strings that are part of a control item.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
 <A HREF=#MARKER-9-192>Listing 8-9</A> shows the <CODE>MyInitializeCP</CODE> procedure, which the River control <BR>device function calls to handle the <CODE>initDev</CODE> message. This procedure calls the <CODE>NewHandle</CODE> function to create a handle to a record of type <CODE>MyRiverStorage</CODE> (see <A HREF=#MARKER-9-179>Listing 8-8 on page 8-27</A>). The procedure then initializes the fields of this record. It also calls its own procedure, <CODE>MyGetUserPreferenceSettings</CODE>, which reads a resource file containing the initial settings for the controls. This resource contains either the original default values or new values set by the user from the control panel. <P>
 The <CODE>MyInitializeCP</CODE> procedure sets initial values for any controls in its control panel. For each control, <CODE>MyInitializeCP</CODE> calls the Dialog Manager's <CODE>GetDialogItem</CODE> procedure to get a handle to the control and then calls the Control Manager's <CODE>SetControlValue</CODE> procedure to restore the last setting of the control. The first time a user uses the control panel, the initial values are the default values; after that, the initial values are those last set by the user. The <CODE>MyInitializeCP</CODE> procedure restores the last settings of radio buttons and checkboxes, sets the menu item to the last item chosen by the user in pop-up menus, and restores the text that the user last entered in editable text items.<P>
 Finally, the <CODE>MyInitializeCP</CODE> procedure returns in the <CODE>cdevStorageValue</CODE> parameter a handle to the memory it has allocated. The control device function then returns this value as its function result. In all subsequent calls to the control device function, the Finder passes this value back in the <CODE>cdevStorageValue</CODE> parameter. <P>
 The River control panel uses the memory it allocates to save values indicating that the user has changed a setting. When the user clicks the Show Me button or closes the control panel, the control device function notifies the River screen saver system extension that the settings have changed. The River screen saver then uses the new settings when it displays the river on the screen.<P>
<B>Listing 8-9  <A NAME=MARKER-9-192></A>Initializing a control panel: Allocating memory and setting controls<A NAME=MARKER-2-193></A></B><P>
<PRE>
PROCEDURE MyInitializeCP (VAR cdevStorageValue: LongInt; CPDialog: DialogPtr;
                           VAR myRiverHndl: MyRiverStorageHndl);
VAR
   initOnSetting, initOffSetting, initUphillSetting, initDownhillSetting,
   initCircularSetting, initBabbleSetting, initRiverColorSetting: Integer;
   initVelocityText:    Str255;
   startSel, endSel:    Integer;
   itemType:            Integer;
   itemHandle:          Handle;
   itemRect:            Rect;






BEGIN
   myRiverHndl := MyRiverStorageHndl(NewHandle(Sizeof(MyRiverStorage)));
   IF myRiverHndl &lt;&gt; NIL THEN
   BEGIN    {initialize fields in myRiver record}
      myRiverHndl^^.count := 0;
      myRiverHndl^^.err := 0;
      myRiverHndl^^.settingsChanged := FALSE;
   END;
   {set default or saved values for each setting in this control panel-- }
   { usually a control panel reads these values from a resource file} 
   MyGetUserPreferenceSettings(initOnSetting, initOffSetting,
                               initUphillSetting, initDownhillSetting,
                               initCircularSetting, initBabbleSetting,
                               initRiverColorSetting, initVelocityText,
                               startSel, endSel);
   {set the initial values of buttons and other controls using the Dialog }
   { Manager's GetDialogItem &amp; the Control Mgr's SetControlValue procedures}

   GetDialogItem(CPDialog, kOnRadButton, itemType, itemHandle, itemRect);
   SetControlValue(ControlHandle(itemHandle), initOnSetting);

   GetDialogItem(CPDialog, kOffRadButton, itemType, itemHandle, itemRect);
   SetControlValue(ControlHandle(itemHandle), initOffSetting);

   GetDialogItem(CPDialog, kUphillRadButton, itemType, itemHandle, itemRect);
   SetControlValue(ControlHandle(itemHandle), initUphillSetting);

   GetDialogItem(CPDialog, kDownhillRadButton, itemType,itemHandle,itemRect); 
   SetControlValue(ControlHandle(itemHandle), initDownhillSetting);

   GetDialogItem(CPDialog, kCircularRadButton, itemType,itemHandle,itemRect);
   SetControlValue(ControlHandle(itemHandle), initCircularSetting);

   GetDialogItem(CPDialog, kBabbleCheckBox, itemType, itemHandle, itemRect);
   SetControlValue(ControlHandle(itemHandle), initBabbleSetting);

   GetDialogItem(CPDialog, kRiverColorMenu, itemType, itemHandle, itemRect);
   SetControlValue(ControlHandle(itemHandle), initRiverColorSetting);

   GetDialogItem(CPDialog, kVelocityEditText, itemType, itemHandle,itemRect);
   SetDialogItemText(itemHandle, initVelocityText);
   SelectDialogItemText(CPDialog, kVelocityEditText, startSel, endSel);
   cdevStorageValue := Ord4(myRiverHndl);
 END;
</PRE>
 If you define your text items as user items, your control device function must draw the text in response to an <CODE>initDev</CODE> message. See <A HREF=#MARKER-9-220>"Handling Text Defined as User Items" on page 8-43</A> for details. <P>
<A NAME=HEADING461-54></A>
<H3>Responding to Activate Events</H3>
 When a control panel is active, your control device function is responsible for making each control active or inactive, as appropriate. For example, your function should draw a bold outline around the control panel's default button. By contrast, when your control panel is inactive, your <A NAME=MARKER-2-194></A>control device function should make all its controls inactive, causing the Control Manager to draw them in gray or in grayscale, depending on the bit depth of the monitor. This provides a visual indication to the user that a control panel is inactive, and it distinguishes the active window from inactive ones. <P>
 Whenever the Event Manager generates an activate event for your control panel in response to a user action, the Finder intercepts the activate event and calls your control device function with either an <CODE>activDev</CODE> message or a <CODE>deActivDev</CODE> message. In either case, the Finder passes to your function, in the parameter <CODE>theEvent</CODE>, the event record for the activate event and, in the <CODE>cdevStorageValue</CODE> parameter, a handle to the memory previously allocated by your function. <P>
 For example, the Finder calls your control device function with an <CODE>activDev</CODE> message (after sending an <CODE>initDev</CODE> message) when the user opens your control panel or clicks your inactive control panel after using another control panel or an application. Your function should respond to an <CODE>activDev</CODE> message by drawing a bold outline around the default button. It should also make the default button and any other controls in your control panel active. You can use the Control Manager's <CODE>HiliteControl</CODE> procedure to make a control active or inactive. (See the chapter "Control Manager" in <I><A HREF="../Toolbox/Toolbox-2.html">Inside Macintosh: Macintosh Toolbox Essentials</A></I> for information about <CODE>HiliteControl</CODE>.)<P>
 In general, your function does not need to update user items in response to an activate event, apart from drawing a bold outline around the default button. If, however, your control panel includes a user item that requires updating, such as a clock that shows the current time, your control device function should update that user item. <P>
 The Finder calls your control device function with a <CODE>deActivDev</CODE> message when the user clicks another control panel, runs an application, or otherwise brings another window to the front. In this case, your function should respond by drawing the outline of the default button in gray and making inactive any other controls in your control panel. While a control is inactive, the Control Manager does not respond to mouse events in it. See the chapter "Dialog Manager" in <I><A HREF="../Toolbox/Toolbox-2.html">Inside Macintosh: Macintosh Toolbox Essentials</A></I> for information on how to make buttons, radio buttons, checkboxes, and pop-up menus inactive and active in response to activate events. <A HREF=#MARKER-9-195>Figure 8-10</A> shows the River control panel when it is inactive. Note that all of its controls are dimmed.<P>
<B>Figure 8-10  <A NAME=MARKER-9-195></A>Example of an inactive control panel</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/CP-S-10.jpg">
 The River control device function calls its own procedure to handle both <CODE>activDev</CODE> and <CODE>deActivDev</CODE> messages. <A HREF=#MARKER-9-196>Listing 8-10</A> shows the <CODE>MyActivateControlPanel</CODE> procedure, which either makes the controls active in response to an <CODE>activDev</CODE> message or inactive in response to a <CODE>deActivDev</CODE> message. <P>
 In response to activate events, this procedure calls the Dialog Manager's <CODE>GetDialogItem</CODE> procedure to get a handle to the default button and then calls the Control Manager's <CODE>HiliteControl</CODE> procedure to make the control active. To draw the bold outline around the default button, the <CODE>MyActivateControlPanel</CODE> procedure calls its own procedure, <CODE>MyDrawDefaultButtonOutline</CODE>. (See the chapter "Dialog Manager" in <I><A HREF="../Toolbox/Toolbox-2.html">Inside Macintosh: Macintosh Toolbox Essentials</A></I> for detailed instructions on drawing an outline around a default button.) The procedure then makes all other controls active. <P>
 In response to a <CODE>deActivDev</CODE> message, the <CODE>MyActivateControlPanel</CODE> procedure makes all its controls inactive. In addition, it uses its own procedure, <CODE>MyDrawDefaultButtonOutline</CODE>, to draw a gray outline around the default button. <P>
<DL>
<DT><B>Note</B>
<DD>If the dialog box uses a color graphics port, you can use the Color QuickDraw function <CODE>GetGray</CODE> to return a blended gray based on the foreground and background colors.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
<B>Listing 8-10  <A NAME=MARKER-9-196></A>Responding to an activate event <A NAME=MARKER-2-197></A></B><P>
<PRE>
PROCEDURE MyActivateControlPanel (VAR cdevStorageValue: LongInt; 
                                  CPDialog: DialogPtr; 
                                  myRiverHndl: MyRiverStorageHndl;
                                  activate: Boolean);
VAR
   itemType:      Integer;
   itemHandle:    Handle;
   itemRect:      Rect;
BEGIN
   IF activate THEN
   BEGIN    {control panel becoming active}
      {activate the default button (ShowMe) and draw bold outline around it}
      GetDialogItem(CPDialog, kShowMe, itemType, itemHandle, itemRect);
      HiliteControl(ControlHandle(itemHandle), 0);
      MyDrawDefaultButtonOutline(CPDialog, kShowMe);

      {make other controls active}
      GetDialogItem(CPDialog, kOnRadButton, itemType, itemHandle, itemRect);
      HiliteControl(ControlHandle(itemHandle), 0);

      GetDialogItem(CPDialog, kOffRadButton, itemType, itemHandle, itemRect);
      HiliteControl(ControlHandle(itemHandle), 0);

      GetDialogItem(CPDialog, kUphillRadButton,itemType,itemHandle,itemRect);
      HiliteControl(ControlHandle(itemHandle), 0);

      GetDialogItem(CPDialog, kDownhillRadButton, itemType, itemHandle,
                    itemRect);
      HiliteControl(ControlHandle(itemHandle), 0);

      GetDialogItem(CPDialog, kCircularRadButton, itemType, itemHandle,
                    itemRect);
      HiliteControl(ControlHandle(itemHandle), 0);



      GetDialogItem(CPDialog, kBabbleCheckBox, itemType, itemHandle,
                    itemRect);
      HiliteControl(ControlHandle(itemHandle), 0);

      GetDialogItem(CPDialog, kRiverColorMenu, itemType, itemHandle,
                    itemRect);
      HiliteControl(ControlHandle(itemHandle), 0);
   END
   ELSE
   BEGIN    {control panel becoming inactive}
      {make the default button inactive and draw gray outline around it} 
      GetDialogItem(CPDialog, kShowMe, itemType, itemHandle, itemRect);
      HiliteControl(ControlHandle(itemHandle), 255);
      MyDrawDefaultButtonOutline(CPDialog, kShowMe);

      {make other controls inactive}
      GetDialogItem(CPDialog, kOnRadButton, itemType, itemHandle, itemRect);
      HiliteControl(ControlHandle(itemHandle), 255);

      GetDialogItem(CPDialog, kOffRadButton, itemType, itemHandle, itemRect);
      HiliteControl(ControlHandle(itemHandle), 255);

      GetDialogItem(CPDialog,kUphillRadButton,itemType,itemHandle,itemRect);
      HiliteControl(ControlHandle(itemHandle), 255);

      GetDialogItem(CPDialog, kDownhillRadButton, itemType, itemHandle,
                    itemRect);
      HiliteControl(ControlHandle(itemHandle), 255);

      GetDialogItem(CPDialog, kCircularRadButton, itemType, itemHandle,
                    itemRect);
      HiliteControl(ControlHandle(itemHandle), 255);

      GetDialogItem(CPDialog,kBabbleCheckBox,itemType,itemHandle,itemRect);
      HiliteControl(ControlHandle(itemHandle), 255);

      GetDialogItem(CPDialog,kRiverColorMenu,itemType,itemHandle,itemRect);
      HiliteControl(ControlHandle(itemHandle), 255);
   END;
END;
</PRE>
<DL>
<DT><B>Using Multiple Dialog Boxes</B>
<DD>The use of nested dialog boxes is not recommended in control panels. If you decide to use them nevertheless, keep in mind that the Finder may send your control device function a <CODE>deActivDev</CODE> message before your code that displays and initializes the second dialog box completes. This is because when your control device function calls <CODE>DialogSelect</CODE> to handle an event in a second dialog box, <CODE>DialogSelect</CODE> issues a call to <CODE>GetNextEvent</CODE>. In turn, the system software sends to the Finder an activate event instructing it to deactivate the main control panel's dialog box. However, this situation should not cause unusual problems, and your code should handle the <CODE>deActivDev</CODE> message, then continue its processing for the second dialog box.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
<A NAME=HEADING461-70></A>
<H3><A NAME=MARKER-9-198></A>Responding to Keyboard Events<A NAME=MARKER-2-199></A></H3>
 The Finder intercepts all key-down and auto-key events for your control panel. The Finder sends your <A NAME=MARKER-2-200></A>control device function a keyboard event through the <CODE>keyEvtDev</CODE> message for all keystrokes except Command-key equivalents. The Finder processes all <A NAME=MARKER-2-201></A>Command-key equivalents on behalf of your control panel except those that it maps to its own Edit menu commands. The Finder converts these <A NAME=MARKER-2-202></A>Command-key equivalents to messages and passes them on (as <CODE>cutDev</CODE>, <CODE>copyDev</CODE>, <CODE>pasteDev</CODE>, <CODE>undoDev</CODE>, and <CODE>clearDev</CODE> messages) to your control panel for processing. (See <A HREF=#MARKER-9-227>"Handling Edit Menu Commands" on page 8-46</A> for more information.) <A NAME=MARKER-2-203></A><P>
<DL>
<DT><B>Note</B>
<DD><A NAME=MARKER-2-20></A>In System 6, the Control Panel desk accessory does not convert Command-key equivalents for Edit menu commands to edit messages; instead it passes the Command-key equivalent to your control device function as a <CODE>keyEvtDev</CODE> message. For backward compatibility, when your control device function receives a <CODE>keyEvtDev</CODE> message, it should check for Command-key equivalents as follows: it should examine the <CODE><A NAME=MARKER-2-206></A>modifiers</CODE> field and the <CODE><A NAME=MARKER-2-207></A>message</CODE> field of the event record to identify the Command-key equivalent, process it, and set the event record's <CODE>what</CODE> field to <CODE>nullEvent</CODE>. In this way, you prevent the Control Panel desk accessory from passing the keystroke to TextEdit for further handling. <A HREF=#MARKER-9-209>Listing 8-11</A> illustrates this technique.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
 In addition to handling Command-key equivalents, your control device function should respond appropriately when the user presses the Enter key or the Return key. In either case, your function should map the keypress to your control panel's default button, if any, and perform the action corresponding to that button. For instance, the <CODE>MyHandleKeyEvent</CODE> procedure shown in <A HREF=#MARKER-9-209>Listing 8-11</A> calls its <CODE>MyShowMe</CODE> routine whenever the user presses Enter or Return. This routine signals the River system extension to display the river on the screen. <P>
 Your control device function does not need to process most other keystrokes. The Finder passes keyboard events on to <CODE>DialogSelect</CODE>, which calls TextEdit to handle text entry in editable text items. However, in some cases you might want your function to process the keypress and return the constant <CODE>nullEvent</CODE> in the <A NAME=MARKER-2-208></A><CODE>what</CODE> field of the event record. For example, if your control panel includes an editable text item that accepts only numeric characters, your function can detect an invalid value, signal the user by beeping, then modify the <CODE>what</CODE> field to prevent the Finder from passing the event to the Dialog Manager. <A HREF=#MARKER-9-209>Listing 8-11</A> illustrates this technique: the user can enter only numeric values in the Velocity editable text item. <P>
<B>Listing 8-11  <A NAME=MARKER-9-209></A>Responding to a keyboard event<A NAME=MARKER-2-210></A></B><P>
<PRE>
PROCEDURE MyHandleKeyEvent (VAR theEvent: EventRecord; CPDialog: DialogPtr;
                            message: Integer);
VAR
   theChar:    Char;
   itemType:   Integer;
   itemHandle: Handle;
   itemRect:   Rect;
   finalTicks: LongInt;
BEGIN
   {in System 6, you need to check for Command-key equivalents}
   {get the character from the message field of the event record}
   theChar := CHR(BAnd(theEvent.message, charCodeMask));
   IF BAnd(theEvent.modifiers, cmdKey) &lt;&gt; 0 THEN
   BEGIN {Command key down}
      theEvent.what := nullEvent; {change the event to a null event so that }
                                  { TextEdit will ignore it}
      CASE theChar OF
         'X', 'x': 
            message := cutDev;
         'C', 'c': 
            message := copyDev;
         'V', 'v':
            message := pasteDev;
         OTHERWISE
            message := nulDev; {ignore any other Command-key equivalents}
      END;  {of CASE}
      MyHandleEditCommand(message, CPDialog);
   END; {of command-key down}
   CASE theChar Of
      '0', '1', '2', '3', '4', '5', '6', '7', '8', '9': 
      ;  {valid input, let DialogSelect/TextEdit handle key input}
      OTHERWISE
      BEGIN
         IF (theChar = Char(kCRkey)) OR (theChar = Char(kEnterKey)) THEN
         BEGIN {user pressed Return or Enter, map to default button}
            GetDialogItem(CPDialog, kShowMe, itemType, itemHandle, itemRect);
            HiliteControl(ControlHandle(itemHandle), inButton);
            Delay(8, finalTicks);
            HiliteControl(ControlHandle(itemHandle), 0);
            MyShowMe(CPDialog); {perform action defined by default button}
            theEvent.what := nullEvent;
         END {of Return or Enter}
         ELSE IF (theChar = Char(kDeleteKey)) THEN
            {let DialogSelect/TextEdit handle it}
         ELSE
         BEGIN    {invalid input, don't allow this character as input}
            SysBeep(40);
            theEvent.what := nullEvent;
         END;
      END; {of otherwise}
   END;  {of CASE} 
END; 
</PRE>
<A NAME=HEADING461-77></A>
<H3>Responding to Mouse Events </H3>
 When the user clicks any active, enabled controls in your control panel, system software generates a mouse event. The Finder intercepts this event and passes it to your <A NAME=MARKER-2-211></A>control device function as a <CODE>hitDev</CODE> message. Your control device function typically changes the setting of the control or performs the appropriate action in response to a <CODE>hitDev</CODE> message. <P>
 Along with the <CODE>hitDev</CODE> message, the Finder passes three values that your control device function uses to determine which item the user clicked. <P>
<UL>
<LI>In the <CODE>CPDialog</CODE> parameter, the Finder passes a pointer to your control panel's dialog box. 
<LI>In the <CODE>item</CODE> parameter, the Finder passes the number of the item, as defined in your item list, that the user clicked.
<LI>In the <CODE>numItems</CODE> parameter, a value provided for backward compatibility with the Control <A NAME=MARKER-2-212></A>Panel desk accessory, the value passed depends on the system currently in effect. In System 6, this number is the number of items in the item list of the Control Panel desk accessory. In System 7, the Finder always passes a value of 0 in <CODE>numItems</CODE>. <A NAME=MARKER-2-213></A><P>
</UL>
 In System 6, the Control Panel desk accessory uses the <CODE>numItems</CODE> parameter to pass the number of items in its own item list. The Control Panel desk accessory appends your control panel's item list to its own. To get the correct number of the clicked item, you need to subtract the number of items in the desk accessory's item list (<CODE>numItems</CODE>) from the number passed in the <CODE>item</CODE> parameter. Although the <CODE>numItems</CODE> parameter contains 0 in System 7, to maintain backward compatibility, you should always determine an item number by subtracting the value of <CODE>numItems</CODE> from the value of <CODE>item</CODE>. If you do so, your control panel can operate correctly with both the Finder and the Control Panel desk accessory. For more information about item lists, see <A HREF=MoreToolbox-459.html#MARKER-9-118>"Creating the Item List Resource" on page 8-17</A>, and the chapter "Dialog Manager" in <I><A HREF="../Toolbox/Toolbox-2.html">Inside Macintosh: Macintosh Toolbox Essentials</A></I>. <P>
 The River control device function determines the correct item number in its <CODE>CASE</CODE> statement before it calls its <CODE>MyHandleHitInDialogItem</CODE> procedure to handle the <CODE>hitDev</CODE> message. Here is the code segment, also shown in <A HREF=#MARKER-9-179>Listing 8-8 on page 8-27</A>, that determines the item number: <P>
<PRE>
            hitDev: {user clicked dialog item}
             BEGIN
               item := item - numItems;
               MyHandleHitInDialogItem(item, cdevStorageValue, 
                                       CPDialog, myRiverHndl);
            END;
</PRE>
 <A HREF=#MARKER-9-215>Listing 8-12</A> shows the River control panel's <CODE>MyHandleHitInDialogItem</CODE> procedure, which takes the appropriate action in response to the item the user clicked. For the Show Me button, the procedure calls its <CODE>MyShowMe</CODE> procedure, which instructs its system extension to display the River screen saver using any new values. <P>
 For the On and Off radio buttons, <CODE>MyHandleHitInDialogItem</CODE> first calls the Dialog Manager's <CODE>GetDialogItem</CODE> procedure to get a handle to each radio button and then the Control Manager's <A NAME=MARKER-2-214></A><CODE>GetControlValue</CODE> function to determine the current setting. If the radio button clicked was previously off, <CODE>MyHandleHitInDialogItem</CODE> reverses its setting and also reverses the setting of the radio button that was previously on. If the user clicks any one of the group of radio buttons governing flow direction (Uphill, Downhill, Circular), <CODE>MyHandleHitInDialogItem</CODE> calls another application-defined routine, the <CODE>MyHandleFlowRadioButton</CODE> procedure. Although not shown in this listing, this procedure handles each of the three radio buttons, checking whether a button's value has changed and, if so, resetting the control. <P>
 If the user clicked the Play Babble Sound checkbox, <CODE>MyHandleHitInDialogItem</CODE> reverses its setting. <P>
 The River control panel defines two user items that enclose the up arrow and the down arrow. If the user clicks either of these areas, <CODE>MyHandleHitInDialogItem</CODE> calls its own <CODE>MyHandleHitInArrows</CODE> procedure to handle this event. The routine either increments or decrements the number displayed in its editable text item accordingly. <P>
 The River control panel ignores clicks in any other item, because the Dialog Manager automatically handles clicks in pop-up controls and editable text items. <P>
 After handling the <CODE>hitDev</CODE> message, <CODE>MyHandleHitInDialogItem</CODE> sets the <CODE>settingsChanged</CODE> field of the <CODE>MyRiverStorage</CODE> record. Other routines use this value to determine if the preferences file needs updating or if its system extension needs to read the preferences file and use the new values when displaying the screen saver. <P>
<B>Listing 8-12  <A NAME=MARKER-9-215></A>Responding to the user's interaction with controls<A NAME=MARKER-2-216></A></B><P>
<PRE>
PROCEDURE MyHandleHitInDialogItem (item: Integer; 
                                   VAR cdevStorageValue: LongInt; 
                                   CPDialog: DialogPtr;
                                   myRiverHndl: MyRiverStorageHndl);
VAR
   newOnSetting, newOffSetting:  Integer;
   newUphillSetting, newDownhillSetting, newCircularSetting: Integer;
   newBabbleSetting:             Integer;
   newVelocityText:              Str255;
   newRiverColorSetting:         Integer;
   itemType:                     Integer;
   itemHandle:                   Handle;
   itemRect:                     Rect;
BEGIN
   CASE item OF
    kShowMe:
      MyShowMe(CPDialog);
    kOnRadButton:
      BEGIN
         {get handle to the On radio button, get its current value, }
         { and then if it was off, change it to on}
         GetDialogItem(CPDialog,kOnRadButton,itemType,itemHandle,itemRect);
         newOnSetting := GetControlValue(ControlHandle(itemHandle));
         IF (newOnSetting = 0) THEN
         BEGIN 
            newOnSetting := 1 - newOnSetting;
            SetControlValue(ControlHandle(itemHandle), newOnSetting);
            {get handle to the Off radio button, get its current value, }
            { and then change it}
            GetDialogItem(CPDialog, kOffRadButton, itemType, itemHandle,
                          itemRect);
            newOffSetting := 1 - newOnSetting;
            SetControlValue(ControlHandle(itemHandle), newOffSetting);
         END;
      END;
    kOffRadButton:
      BEGIN
         {get handle to the Off radio button, get its current value, }
          { and then if it was off, change it to on}
         GetDialogItem(CPDialog,kOffRadButton,itemType,itemHandle,itemRect);
         newOffSetting := GetCtlValue(ControlHandle(itemHandle));
         IF (newOffSetting = 0) THEN
         BEGIN
            newOffSetting := 1 - newOffSetting;
            SetControlValue(ControlHandle(itemHandle), newOffSetting);
            newOffSetting := GetCtlValue(ControlHandle(itemHandle));
            {get handle to the On radio button, get its current value, }
            { and then change it}
            GetDialogItem(CPDialog, kOnRadButton, itemType, itemHandle,
                          itemRect);
            newOnSetting := 1 - newOffSetting;
            SetControlValue(ControlHandle(itemHandle), newOnSetting);
         END;
      END;
    kUpHillRadButton, kDownHillRadButton, kCircularRadButton:
      {this routine handles the Flow Direction radio buttons}
      MyHandleFlowRadioButton(item, CPDialog); 
    kBabbleCheckBox:
      BEGIN
         {get handle to Play Babble Sound checkbox, get its current value, }
         { and then change it}
         GetDialogItem(CPDialog, kBabbleCheckBox, itemType, itemHandle,
                       itemRect);
         newBabbleSetting := GetControlValue(ControlHandle(itemHandle));
         newBabbleSetting := 1 - newBabbleSetting;
         SetControlValue(ControlHandle(itemHandle), newBabbleSetting);
      END;
    kUserItemUpArrow, kUserItemDownArrow:
      MyHandleHitInArrows(item, CPDialog);
   END; {of CASE} 
   myRiverHndl^^.settingsChanged := TRUE;
END; 
</PRE>
<A NAME=HEADING461-94></A>
<H3>Responding to Update Events</H3>
 Whenever the Event Manager generates an update event for your control panel, the Finder intercepts the update event and calls your <A NAME=MARKER-2-217></A>control device function with an <CODE>updateDev</CODE> message. Your control device function should perform any updating necessary, apart from the standard dialog item updating that the Dialog Manager performs. An update event gives your control device function the opportunity to redraw user items that might require updating, such as a clock. You should also redraw the outline around your default button in response to an update event. Notice that the <CODE>MyUpdateControlPanel</CODE> procedure in <A HREF=#MARKER-9-218>Listing 8-13</A> does this by calling its <CODE>MyDrawDefaultButtonOutline</CODE> procedure, which the control device function also calls in response to an <CODE>activDev</CODE> or <CODE>deActivDev</CODE> message. If your control panel has an editable text item, you don't need to include code to make the caret blink. The Dialog Manager calls <CODE>TEIdle</CODE> for this purpose. <P>
<B>Listing 8-13  Responding to update events <A NAME=MARKER-9-218></A><A NAME=MARKER-2-219></A></B><P>
<PRE>
PROCEDURE MyUpdateControlPanel (VAR cdevStorageValue: LongInt;
                                CPDialog: DialogPtr; 
                                myRiverHndl: MyRiverStorageHndl);
BEGIN
   {draw the outline around the default button on an update event}
   MyDrawDefaultButtonOutline(CPDialog, kShowMe);
END;
</PRE>
<A NAME=HEADING461-98></A>
<H3><A NAME=MARKER-9-220></A>Handling Text Defined as User Items </H3>
 If you want to use a font other than the default application font for your control panel's text, you should either include an <CODE>'finf'</CODE> resource in your control panel file and define your text as static text items or define your text using user items. See <A HREF=MoreToolbox-460.html#MARKER-9-149>"Creating a Font Information Resource" on page 8-23</A> for details on changing the font using an <CODE>'finf'</CODE> resource. This section gives details on how to define text using user items. You might want to use this approach so that your control panel can run in the Finder and the Control Panel desk accessory.<P>
 If you define the text in your control panel using user items, <A NAME=MARKER-2-221></A>you need to draw the text in response to an <CODE>updateDev</CODE> message, just as you would any other user item that requires updating. (You draw the text initially in response to an <CODE>initDev</CODE> message.) <P>
 For each item, this process entails <P>
<UL>
<LI>Setting the text font, style, and size fields to be used. (You use the QuickDraw procedures <CODE>TextFont</CODE>, <CODE>TextFace</CODE>, and <CODE>TextSize</CODE> for this purpose.)
<LI>Positioning the pen where you want to draw the text. You draw the text in the rectangle defined for it in the item list resource. (You can use the QuickDraw procedure <CODE>MoveTo</CODE> to set the initial location of the pen.)
<LI>Drawing the text string. (You can use the QuickDraw <CODE>DrawString</CODE> procedure for this purpose.)<P>
</UL>
 <A HREF=#MARKER-9-222>Listing 8-14</A> shows the <CODE>MyDrawText</CODE> procedure. The River control device function might use this procedure to draw any text that it defined as user items. First the <CODE>MyDrawText</CODE> procedure calls the QuickDraw <CODE>TextFont</CODE>, <CODE>TextFace</CODE>, and <CODE>TextSize</CODE> procedures to set the graphics port font to 12-point Chicago. <P>
 Then, for each text item, <CODE>MyDrawText</CODE> calls it own <CODE>MyGetUserText</CODE> procedure to get the text string and the coordinates of the text string as defined by the display rectangle <BR>of the user item. (See<A HREF=MoreToolbox-460.html#MARKER-9-154>"Defining Text in a Control Panel as User Items" on page 8-24</A> for details about the item list.) Next, <CODE>MyDrawText</CODE> calls the QuickDraw <CODE>MoveTo</CODE> procedure to position the pen and QuickDraw's <CODE>DrawString</CODE> procedure to draw the text. <P>
<B>Listing 8-14  Drawing text defined as user items<A NAME=MARKER-9-222></A><A NAME=MARKER-9-223></A></B><P>
<PRE>
PROCEDURE MyDrawText;
VAR
   textForUserItem:  Str255; 
   textH, textV:     Integer; 
BEGIN
   TextFont(0);      {set the font to the system font (Chicago)}
   TextFace([]);     {set the text face to normal}
   TextSize(12);     {set the font size to 12-point}
   {get the text and location for the first text string}
   MyGetUserText(kFlow, textForUserItem, textH, textV);
   MoveTo(textH, textV);
   DrawString(textForUserItem);     {draw the text}
   {get the text and location for the next text string}
   MyGetUserText(kVelocity, textForUserItem, textH, textV);
   MoveTo(textH, textV);
   DrawString(textForUserItem);     {draw the text}
   {get the text and location for the next text string}
   MoveTo(textH, textV);
   MyGetUserText(kMph, textForUserItem, textH, textV);
   DrawString(textForUserItem);     {draw the text}
END; 
</PRE>
<A NAME=HEADING461-109></A>
<H3>Responding to Null Events</H3>
 Whenever the Event Manager generates a null event for your control panel, the Finder intercepts the event and calls your control device function with a <CODE>nulDev</CODE> message. Your control device function should respond to a <CODE>nulDev</CODE> message by performing any needed idle processing. However, your control device function should do minimal processing in response to a null event; for example, it should not refresh control settings.<P>
<A NAME=HEADING461-111></A>
<H3>Responding to the User Closing the Control Panel </H3>
 When the user closes your control panel, the Finder calls your control device function with a <CODE>closeDev</CODE> message, signaling it to terminate gracefully. In response to this message, <A NAME=MARKER-2-224></A>your control device function must dispose of any memory it has allocated, including any pointers or handles it has allocated. <P>
 Before your function begins this process, however, it can perform other needed tasks. For example, the River control device function checks whether the user changed the values of any settings. If so, it updates its preferences file to reflect the changes. <P>
 <A HREF=#MARKER-9-225>Listing 8-15</A> shows the <CODE>MyCloseControlPanel</CODE> procedure, which the River control device function calls to handle the <CODE>closeDev</CODE> message. The <CODE>MyCloseControlPanel</CODE> procedure checks the <CODE>settingsChanged</CODE> field of its <CODE>MyRiverStorage</CODE> record to determine if the user changed the settings (the control device function sets this field whenever the user changes a setting). If necessary, <CODE>MyCloseControlPanel</CODE> calls a procedure to update the preferences file with the new values stored in the <CODE>MyRiverStorage</CODE> record. Next, <CODE>MyCloseControlPanel</CODE> disposes of the memory that the control device function previously allocated by disposing of the handle in the <CODE>myRiverHndl</CODE> parameter. It then sets the <CODE>cdevStorageValue</CODE> parameter to 0. The control device function returns this value as its function result. <P>
<B>Listing 8-15  <A NAME=MARKER-9-225></A>Terminating a control device function when the user closes the control panel<A NAME=MARKER-2-226></A></B><P>
<PRE>
PROCEDURE MyCloseControlPanel (myRiverHndl: MyRiverStorageHndl; 
                               VAR cdevStorageValue: LongInt);
BEGIN
   {if the user changed any of the settings, }
   { write the new settings to the River preferences file}
   IF myRiverHndl^^.settingsChanged THEN
      MyWriteUserPreferences(myRiverHndl);
   {dispose of any allocated storage}
   IF myRiverHndl &lt;&gt; NIL THEN
   BEGIN
      DisposeHandle(Handle(myRiverHndl));
      cdevStorageValue := 0;
   END;
END;
</PRE>
<A NAME=HEADING461-117></A>
<H3><A NAME=MARKER-9-227></A>Handling Edit Menu Commands</H3>
 <A NAME=MARKER-2-228></A>Although you cannot implement a menu bar in your control panel, the user can choose the Finder's Edit menu Undo, Cut, Copy, Paste, and Clear commands when working in an editable text item. When the user chooses one of these commands from the Edit menu or presses its Command-key equivalent, the Finder maps the command to a message and calls your control device function with the message. The values in the <CODE>message</CODE> parameter for these commands are <CODE>undoDev</CODE> for Undo, <CODE>cutDev</CODE> for Cut, <CODE>copyDev</CODE> for Copy, <CODE>pasteDev</CODE> for Paste, and <CODE>clearDev</CODE> for Clear. <P>
<DL>
<DT><B>Note</B>
<DD>In System 6, the Control Panel desk accessory does not convert Command-key equivalents for Edit menu commands to edit messages; instead it passes the Command-key equivalent to your control device function as a <CODE>keyEvtDev</CODE> message. See <A HREF=#MARKER-9-198>"Responding to Keyboard Events" beginning on page 8-37</A> for details on handling keyboard events, including Command-key equivalents.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
 <A HREF=#MARKER-9-229>Listing 8-16</A> show the <CODE>MyHandleEditCommand</CODE> procedure. The River control device function calls this procedure from within its <CODE>CASE</CODE> statement to handle an edit message. For the Cut, Copy, and Clear commands, <CODE>MyHandleEditCommand</CODE> calls Dialog Manager routines to perform the desired operation. For the Paste command, <CODE>MyHandleEditCommand</CODE> first uses its <CODE>MyCheckLength</CODE> function to ensure that the length of any text to be pasted does not exceed the TextEdit text buffer limit of 32 KB; only then does it call <CODE>DialogPaste</CODE>. The Dialog Manager calls TextEdit to perform the operation. <P>
<B>Listing 8-16  <A NAME=MARKER-9-229></A>Responding to Edit menu commands<A NAME=MARKER-2-230></A></B><P>
<PRE>
PROCEDURE MyHandleEditCommand (message: Integer; 
                               CPDialog: DialogPtr);
BEGIN
   CASE message OF
      cutDev:              {use Dialog Manager to cut the text}
         DialogCut(CPDialog);
      copyDev:             {use Dialog Manager to copy the text}
         DialogCopy(CPDialog);
      clearDev:            {use Dialog Manager to clear the text}
         DialogDelete(CPDialog);
      pasteDev:
       BEGIN               {check length, then paste the text}
         IF MyCheckLength(CPDialog) THEN
            DialogPaste(CPDialog);
       END;
   END;   {of CASE}
END;
</PRE>
<A NAME=HEADING461-123></A>
<H3><A NAME=MARKER-9-231></A>Handling Errors</H3>
 Your control device function is responsible for detecting and, if possible, recovering from error conditions. If your function cannot recover from an error condition, it must dispose of any memory that it previously allocated, restore the system stack, and return as its function result one of three error codes<A NAME=MARKER-2-232></A>. <P>
 If your control panel encounters an error due to missing resources or lack of memory, your control device function should return <CODE>cdevResErr</CODE> or <CODE>cdevMemErr</CODE>. When the Finder receives either of these error codes, it closes the control panel and displays an alert box reporting the problem. <P>
 Your control device function should return a generic error code (<CODE>cdevGenErr</CODE>) for all other errors. When the Finder receives this generic error code, it closes the control panel but does not display an alert box; if it can do so, your function should display an alert box to the user before completing. Your function can also return this error code to signal a missing-resources or lack-of-memory error. Use this error code instead of <CODE>cdevResErr</CODE> or <CODE>cdevMemErr</CODE> if you want your function, not the Finder, to display a meaningful error message that directs the user in resolving the problem. <P>
 The Finder in System 7 and the Control Panel desk accessory in System 6 respond differently to any error codes that your control panel returns. In System 6, after your control device function terminates, the Control Panel desk accessory fills the area previously occupied by your control panel with the background pattern, in effect dimming it. The Control Panel desk accessory dialog box remains open because the user can use other control panels represented in the icon list. Your control panel's area remains dimmed until the user selects another control panel. <P>
 <A HREF=#MARKER-9-1>Table 8-2</A> shows the constants defined for these error codes and the corresponding responses by the Finder and the Control Panel desk accessory.
<TABLE BORDER="0" CELLPADDING=3>
<CAPTION><A NAME=MARKER-9-1></A>Error codes and their <A NAME=MARKER-2-232></A>meaning (Continued) <A NAME=MARKER-2-316></A></CAPTION>
<TH>Constant<TH>Value<TH>Meaning<TR>
<TD rowspan=3><A NAME=MARKER-2-116></A>cdevGenErr<TD>-1<TD>Generic error<TR>
<TD>&nbsp;<TD>In System 7, the Finder closes your control panel but does not display an alert box to the user. <TR>
<TD>&nbsp;<TD>In System 6, the Control Panel desk accessory dims your control panel's area in the Control Panel window and passes 0 in the cdevStorageValue parameter the next time it calls your function.<TR>
<TD rowspan=3><A NAME=MARKER-2-5></A>cdevMemErr<TD>0<TD>Insufficient memory<TR>
<TD>&nbsp;<TD>In System 7, the Finder closes the control panel and displays an out-of-memory alert box to the user.<TR>
<TD>&nbsp;<TD>In System 6, the Control Panel desk accessory dims your control panel's area in the Control Panel window, displays an out-of-memory alert box to the user, and passes 0 in the cdevStorageValue parameter the next time it calls your function.<TR>
<TD colspan=3>&nbsp;<TR>
<TD rowspan=3><A NAME=MARKER-2-6></A>cdevResErr<TD>1<TD>Missing resource<TR>
<TD>&nbsp;<TD>In System 7, the Finder closes the control panel and displays a missing-resources alert box to the user.<TR>
<TD>&nbsp;<TD>In System 6, the Control Panel desk accessory dims your control panel's area in the Control Panel window, displays a missing-resources alert box to the user, and passes 0 in the cdevStorageValue parameter the next time it calls your function.<A NAME=MARKER-2-319></A> <A NAME=MARKER-9-444></A><A NAME=MARKER-2-9></A> <A NAME=MARKER-2-10></A></TABLE>
<P>
</BLOCKQUOTE>
<HR>
<center>
<A HREF="MoreToolbox-460.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="MoreToolbox-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="MoreToolbox-513.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="MoreToolbox-462.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="MoreToolbox-3.html">&copy; Apple Computer, Inc.</A><br>6 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>   
