<HTML><HEAD>   <TITLE>Read Me About OTMP</TITLE></HEAD><BODY BGCOLOR="#FFFFFF"><H1>Read Me About OTMP</H1><P>1.0a5</P><P>OTMP is a sample code library that lets you to call Open Transportsynchronously from preemptively scheduled tasks (MP tasks). Thelibrary enables high performance network programming from a commonsource base on both Mac OS 9 and Mac OS X. This package contains thelibrary itself, a number of supports modules, and a demoapplication.</P><P>On traditional Mac OS, the OTMP library requires Mac OS 9.0 orabove. Carbon applications should work with CarbonLib 1.2.5 andlater, assuming the underlying Mac OS version is sufficient. On MacOS X the OTMP library requires Mac OS X 10.0 or later.</P><H2>Justification</H2><P>Fast networking requires preemptive scheduling. When network dataarrives the system must buffer it until the application executes andreads the data. If the network is very fast, the memory required forthis buffering can be huge. Therefore it's vitally important that theapplication run as quickly as possible after the arrival of networkdata. Cooperatively scheduled threads do not fit this bill.</P><P>For example, let's say your application uses Thread Managerthreads for its networking. While inter-thread switch times are verylow, one of those threads must eventually call<CODE>WaitNextEvent</CODE> in order to respond to user events. Atthat point the Process Manager yields time to other applications. Ifthere are other applications running it's possible for yourapplication to remain unscheduled for a long time; a typically valuemight be 6 ticks, or 0.1 seconds. If your application is receivingdata from a gigabit network (1000 Gb/s, or approximate 100 MB/s), thesystem must buffer 10 MB of data (100 MB/s times 0.1 s) to preventflow control on the wire. This is prohibitively large buffer, whichimplies that a cooperatively scheduled application will never yieldexcellent network performance.</P><P>The traditional way to run your network application preemptivelyis to use notifiers. A notifier runs at <A HREF="http://developer.apple.com/technotes/tn/tn1104.html#ExecutionLevels">deferredtask time</A>, so there's very little latency between the arrival ofnetwork data (an interrupt from the network hardware) and theexecution of your application's code.</P><P>The big drawback to notifiers is that they run in an interruptcontext: your application must do its processing and leave thenotifier. Notifier-based applications must use a state machineexecution model, which makes them hard to program and unwieldy tomaintain. Unfortunately, given Mac OS's traditional lack ofpreemptive threads, notifiers are the only solution.</P><P>In Mac OS 8.6 Apple introduced a preemptive thread model to Mac OSin the form of multiprocessing (MP) tasks. While the name impliesthat these threads require a multiprocessor system, this is not thecase. MP tasks work just fine, and are preemptively scheduled, onsingle-processor systems. Unfortunately, MP tasks can only call avery limited set of system services. In Mac OS 8.6 this set was toosmall to write useful network applications. However, in Mac OS 9.0this set expanded such that MP task-based network applications becamepossible.</P><P>The two key changes in Mac OS 9.0 are:</P><UL>   <LI>the ability to make synchronous File Manager calls from an MP   task, and</LI>      <LI>the ability to schedule deferred tasks from an MP task.</LI></UL><P>The first change is critical because network applicationstypically need to access the file system as well as the network. Thisis especially true for network applications where speed is apriority; such applications typically move a lot of data, and thefile system is either the source or the sink for that data.</P><P>The second change is critical because it offers a low-latencycommunications mechanism between MP tasks and Open Transport. OTMPuses this mechanism to implement its simple and efficient interfaceto the network from MP tasks. The implementation is described laterin this <A HREF="#HowItWorks">document</A>.</P><P>In summary, high-speed networking requires a preemptivelyscheduled execution environment. You can use notifiers to implementhigh-speed networking, but the programming model is statemachine-based and therefore unnecessarily difficult. OTMP allows youto efficiently access the network using a synchronous threadedexecution model based on MP tasks.</P><H2>Packing List</H2><P>The sample contains the following items:</P><UL>   <LI>Read Me -- A document that redirects users to this   document.</LI>      <LI>MoreOpenTransport -- A folder containing OTMP and various   support files.      <UL>      <LI>Read_Me_About_OTMP.html (in "MoreOpenTransport" folder) --      This document.</LI>            <LI>OTMP.h -- The interface to the OTMP library. The library      exports two variants of most OT routines: OTMP routines allow      you to call OT from MP tasks on Mac OS 9; OTMPX routines allow      you to call OT from MP tasks on both Mac OS 9 and Mac OS      X.</LI>            <LI>OTMP.c -- The implementation of the OTMP library.</LI>            <LI>OpenTransportClientPPC.debug.o -- OTMP requires that you      use the "InContext" Open Transport routines, even when building      InterfaceLib-based applications. See DTS sample code <A HREF="http://developer.apple.com/samplecode/Sample_Code/Networking/OTClassicContext.htm">OTClassicContext</A>      for details.</LI>            <LI>OTMPSimpleServerHTTP -- A sample HTTP server that uses the      OTMP library to run preemptively.</LI>   </UL>   </LI>      <LI>MoreMultiprocessing -- MoreIsBetter Multiprocessing utilities.      <UL>      <LI>MoreBlueActions -- OTMP uses the MoreBlueActions library as      an abstraction layer on deferred tasks.</LI>            <LI>MoreMPLog -- OTMP logs its activities to the MoreMPLog      library for debugging purposes.</LI>   </UL>   </LI>      <LI>MoreMemory -- MoreIsBetter Memory Manager utilities.</LI>      <LI>MoreProcesses -- MoreIsBetter Process Manager utilities.</LI>      <LI>MoreSetup.h -- The standard MoreIsBetter include file.</LI>      <LI>MIB_Carbon.h -- A C prefix file for Carbon development.</LI></UL><H2>Using the Sample</H2><P>The OTMP library comes with a test application,OTMPSimpleServerHTTP, which you can run to demonstrate the libraryfunctioning on your computer. OTMPSimpleServerHTTP is an evolution ofthe DTS sample code <A HREF="http://developer.apple.com/samplecode/Sample_Code/Networking/OTSimpleServerHTTP.htm">OTSimpleServerHTTP</A>.The non-MP sample is a very simple HTTP server that is threaded usingThread Manager threads and Open Transport's "sync idle" programmingmodel. The MP sample is threaded using preemptively scheduled threads(MP tasks), along with synchronous network access using OTMP.</P><P>To try out this sample, take the following steps.</P><OL>   <LI>Set up a machine running Mac OS 9 or later with a statically   allocated IP address.</LI>      <LI>Make sure that no existing web server software is running. The   easiest way to check for a running web server is to connect to the   machine with a web browser and see if it responds.</LI>      <LI>Duplicate the "Sample HTTP Source" folder (inside the   OTMPSimpleServerHTTP folder) and rename the copy to the text of   the machine's IP address (for example, "1.2.3.4").</LI>      <LI>Run the application appropriate to your platform.      <UL>      <LI>Mac OS X -- Run the OTMPSimpleServer-Carbon,      OTMPSimpleServer-Mach-O, or OTMPSimpleServer-PB applications.      As the sample binds to a privileged port (port 80, the HTTP      port), you must be running with superuser privileges. The best      way to do this is to from Terminal. Switch to superuser      privileges using "sudo -s", then simply execute the application      on the command line (except for the Carbon version which you      must launch using LaunchCFMApp).</LI>            <LI>Mac OS 9 -- Run the OTMPSimpleServer-PPC application. If      you have CarbonLib prior to version 1.2.5 installed, you will      need to disable it before running this sample. See the      <A HREF="#Caveats">Caveats</A> section for an explanation of      why this is necessary.</LI>   </UL>   </LI>      <LI>Connect to the machine with your web browser. You should see   the sample main web page (index.html) from the HTTP source   folder.</LI></OL><H2>Building the Sample</H2><P>The sample was built using the CodeWarrior Pro 7 environmentupgraded to Universal Headers 3.4. To build a sample just open itsproject, select the appropriate target, and choose Make from theProject menu.</P><P>The sample also builds with Project Builder on Mac OS X 10.1. Tobuild it, open the "OTMPSimpleServerHTTP.pbproj" project and chooseBuild from the Build menu.</P><H2>Adding OTMP Support to Your Code</H2><P>The difficulty of adding OTMP support to your code depends on howyour existing code is structured.</P><UL>   <LI>If your existing code uses the sync/blocking/threaded OT   programming model (with "sync idle" events, described in <A HREF="http://developer.apple.com/techpubs/mac/NetworkingOT/NetworkingWOT-30.html#HEADING30-10">Using   Synchronous with Threads</A> in <A HREF="http://developer.apple.com/techpubs/mac/NetworkingOT/NetworkingWOT-2.html">Inside   Macintosh: Networking with Open Transport</A> (Chapter 5, page   130)), it is relatively easy to recast it to run preemptively   using OTMP. Doing so may yield an excellent performance gain.</LI>      <LI>If your code is structured as a notifier-based state machine   (see <A HREF="http://developer.apple.com/techpubs/mac/NetworkingOT/NetworkingWOT-30.html#HEADING30-23">Asynchronous   Processing with a Notifier</A> in&nbsp;<A HREF="http://developer.apple.com/techpubs/mac/NetworkingOT/NetworkingWOT-2.html">Inside   Macintosh: Networking with Open Transport</A> (Chapter 5, page   134), it is quite difficult to recast it to run as MP tasks.   Fortunately, a notifier-based state machine should yield excellent   network performance on Mac OS 9 (and good performance on Mac OS   X), so there is little need to adopt the OTMP technology.</LI></UL><P>The remainder of this section describes the various steps inconverting a sync/blocking/threaded to use OTMP.</P><H3>Being InContext</H3><P>The first step in adopting OTMP is to switch your code to use the"InContext" version of the various OT routines. The rationale forthis change is described in DTS Technote 1173 <A HREF="http://developer.apple.com/technotes/tn/tn1173.html">UnderstandingOpen Transport Asset Tracking</A>. If your code is Carbonized, youhave already made this change. If your code is not Carbonized, youcan make the change without Carbonizing your entire application usingthe technique shown in the DTS sample code <A HREF="http://developer.apple.com/samplecode/Sample_Code/Networking/OTClassicContext.htm">OTClassicContext</A>.</P><H3>OT to OTMP</H3><P><A NAME=SystemTask></A>The next step is to switch yoursync/blocking/threaded OT calls to use OTMP. It's easier to do thisbefore converting to preemptive threads because you can debug yourinitial OTMP changes with a standard debugger (good MP task-awaredebuggers are hard to find). You can safely call OTMP from systemtask time (including Thread Manager threads) as long as you install ayielder callback. To install a yielder callback, call the routine<CODE>InstallOTMPMainThreadYielder</CODE> (declared in "OTMP.h").Make sure you read the header comments for this routine beforecalling it.</P><P>The next step is to change all of your Open Transport calls to beOTMP calls. OTMP exports two versions of each of the APIs itsupports.</P><UL>   <LI>Routines with the OTMP prefix are for use on Mac OS 9 only.   This is the appropriate choice if you're building for Mac OS 9   only and you want the lightest weight solution.</LI>      <LI>Routines with the OTMPX prefix support both Mac OS 9 and Mac   OS X. Each routine tests the system version and either calls the   corresponding OTMP routine (Mac OS 9) or the OT compatibility   routine (provided by Mac OS X). In general, Carbon applications   should use these routines.</LI></UL><P>You should pick the API that best meets your requirements and thenstart converting your code. The regular expression"OT&#91;a-z0-9&#93;+\(" does a good job of finding all of the callsto Open Transport in a source file. Search each of your source filesfor these calls and then, for each call, decide on the appropriateaction.</P><UL>   <LI>For routines that deals with providers (endpoints, Internet   services, and so on), you must call the OTMP equivalent   routine.</LI>      <LI>For routines that allocate or deallocate memory   (<CODE>OTAllocMem</CODE>, <CODE>OTAllocMemInContext</CODE>,   <CODE>OTFreeMem</CODE>, <CODE>OTAlloc</CODE>,   <CODE>OTAllocInContext</CODE>, <CODE>OTFree</CODE>), you must   switch to use the MP memory allocator   (<CODE>MPAllocateAligned</CODE>, <CODE>MPFree</CODE>). OTMP does   not provide MP-safe OT memory allocators because MP already   provides a good memory allocator.</LI>      <LI>A number of Open Transport utilities are already MP-safe. See   DTS Technote 2006 <A HREF="http://developer.apple.com/technotes/tn/tn2006.html">MP-Safe   Routines</A> for details.</LI>      <LI>If the call doesn't fit into any of the above categories, you   may need to wrap it in an <CODE>MPRemoteCall</CODE>.</LI></UL><P>Once you have completed this step you should make sure yourapplication still runs correctly before making the switch to MPtasks.</P><P><STRONG>Important:</STRONG> For regular C programmers,<CODE>EndpointRef</CODE> is basically defined as a <CODE>void*</CODE>. This makes it easy to accidentally call a real OT routinewith an <CODE>OTMPEndpointRef</CODE> &#91;2553322&#93;. If yourprogram crashes with a PowerPC access exception in the first fewlines of an OT routine, it's likely that you've made thismistake.</P><P><STRONG>Important:</STRONG> The current version of OTMP does notprovide any <CODE>InetSvcRef</CODE> routines. This is deliberate.Most users of <CODE>InetSvcRef</CODE> are calling<CODE>OTInetStringToAddress</CODE> to translate a DNS string to an<CODE>InetAddress</CODE>, which they then pass to OT. If this is thecase, you should consider using an <CODE>AF_DNS</CODE> addressinstead. See DTS sample code <A HREF="http://developer.apple.com/samplecode/Sample_Code/Networking/OTSimpleDownloadHTTP.htm">OTSimpleDownloadHTTP</A>for an example. Using <CODE>AF_DNS</CODE> addresses will help makeyour code more compatible with IPv6. If you use other<CODE>InetSvcRef</CODE> routines let me know and I will add thoseroutines to OTMP.</P><H3>Thread Manager to MP</H3><P>The next step is to convert your Thread Manager threads to MPtasks. One quick way to flush out any dependencies on Thread Manageris to remove ThreadsLib from your project; the linker errors willthen tell you exactly what Thread Manager routines you use and whereyou use them. You must then work out an MP task equivalent for theThread Manager routines you are using. This can range from the veryeasy (<CODE>MPCreateTask</CODE> instead of <CODE>NewThread</CODE>) tothe non-trivial (<CODE>ThreadCurrentStackSpace</CODE>). For moreassistance in this area, see <A HREF="http://developer.apple.com/techpubs/macos8/OSSvcs/MultiPServices/MultiprocessingRef/index.html">AddingMultitasking Capabilities to Applications Using MultiprocessingServices</A>.</P><P>However, converting your Thread Manager calls to MP calls is onlythe tip of the iceberg: you also have to find and fix any MP-unsafecode within your threads.</P><UL>   <LI>The previous section discussed how to convert from OT to OTMP.   In addition, <STRONG>any MP task must prepare itself before   calling OTMP, and unprepare itself before terminating</STRONG>. To   prepare a task call <CODE>OTMPPrepareThisTask</CODE> (or   <CODE>OTMPXPrepareThisTask</CODE>). To unprepare a task call   <CODE>OTMPUnprepareThisTask</CODE> (or   <CODE>OTMPXUnprepareThisTask</CODE>).</LI>      <LI>Beyond Open Transport, MP tasks can only call a limited set of   system routines. You must carefully analyze the system routines   you call from your MP tasks and check that each one is MP-safe.   See DTS Technote 2006 <A HREF="http://developer.apple.com/technotes/tn/tn2006.html">MP-Safe   Routines</A> for details on which system services are   MP-safe.</LI>      <LI>For calls that aren't MP-safe, an easy but inefficient   workaround is to wrap them in an <CODE>MPRemoteCall</CODE>.   However, it may be better to restructure your application to avoid   using these MP-unsafe routines.</LI>      <LI>Cooperative threading radically simplifies many   synchronization problems. For example, you don't have to use   critical sections (mutexes) in cooperatively threaded code because   the code between two calls to <CODE>YieldToAnyThread</CODE> will   never be interrupted. Preemptively scheduled MP tasks will expose   a number of these synchronization problems. You must fix these   problems, either by using MP synchronization primitives (for   example, <CODE>MPEnterCriticalSection</CODE>) or by adopting   non-blocking synchronization primitives (such as using   <CODE>OTAtomicAdd32</CODE> to update a global counter).</LI></UL><P>The OTMPSimpleServerHTTP sample code illustrates a number of thetechniques required to turn Thread Manager code into MP taskcode.</P><H3>Debugging</H3><P>Once you have converted your code to use MP tasks, you then havethe arduous task of debugging it. Unless you have access to anMP-aware debugger, the only good debugging technique is printf-styledebugging. To this end, OTMP is bundled with a library, MoreMPLog,that supports a number of useful logging techniques. The easiest tograsp technique is, literally, printf-style debugging. MoreMPLogprovides a routine, <CODE>MPLogPrintfSlow</CODE>, that you can use toprint text to standard out from an MP task. This routine uses<CODE>MPRemoteCall</CODE> to do its job, so it isn't fast. Adding toomany calls to <CODE>MPLogPrintfSlow</CODE> to your code willsignificantly slow it down (which may have an effect on the problemyou're trying to debug).</P><P>A faster alternative to <CODE>MPLogPrintfSlow</CODE> is<CODE>MPLogPrintf</CODE>. This routine logs its text to a memorybuffer. Before calling this routine you must call<CODE>InitMPLog</CODE> to create the log buffer. You can call thisroutine from any execution environment, including MP tasks, systemtask code (the main thread and other cooperative threads), and allforms of interrupts.</P><P>The MoreMPLog module also provides a number of convenienceroutines to log events and parameters to those events. These routinesare named <CODE>MPLog</CODE>, <CODE>MPLog1</CODE>, and so on. Theseroutines have a number of useful features.</P><UL>   <LI>Like <CODE>MPLogPrintf</CODE>, these routines can be called   from any execution environment.</LI>      <LI>They take a "module" parameter which allows you to selectively   enable the logging for a particular module. The module parameter   acts as a bit number in a <CODE>UInt32</CODE> mask that you can   set up using <CODE>MPLogSetMask</CODE>. If that bit is on in the   mask when you call <CODE>MPLog</CODE>, the log entry is created.   Various components of OTMP use this feature so you can selectively   enable and disable their logging of events.</LI>      <LI>If you're compiling a non-debug build, MoreMPLog provides null   macros for these routines so you don't have to conditionally   compile them out yourself.</LI></UL><P>There are two ways of looking at the log. The simplest is to callthe routine <CODE>MPLogWriteToFile</CODE>, which writes the contentsof the log to a text file. This routine takes a non-synchronizedsnapshot of the log, so if threads are still logging you will seeinconsistent results. It's often best to call this routine in theprocess of quitting your application, after you have shut down yourMP tasks.</P><P>The second way of looking at the log is using MacsBug. The two keyMoreMPLog state variables, the logs position and size, are CFMexported by the module. If you link with the appropriate options,these values will be visible to MacsBug. You can then dump out thelog from within MacsBug.</P><P>As part of its startup processing, MoreMPLog defines a conveniencemacro, "MPLog", for finding the end of the log. When you execute thismacro from within MacsBug it will search the log for the most recententry and display the last 256 bytes of the log.</P><P>To read the log you need to understand a how it is structured.Each log entry is surrounded by french quotes (option-\ andoption-shift-\, &#171; and &#187;). The most recent entry isimmediately followed by a bullet character (option-8, &#149;). Notethat the log can wrap around at the end of the buffer: the end of thebuffer includes a text mark "___End Buffer___" so that you can easilyspot it.</P><H2><A NAME=HowItWorks></A>How it Works</H2><P>This section describes how the OTMP library works, in gruesomedetail. If your goal is to ship your next cool Mac product, you canprobably skip this section. If you want to learn about the gorydetails inside this library, read on MacDuff!</P><P>The key difficulty in implementing OTMP was to provide blockingnetwork I/O on Mac OS 9. On Mac OS X the Carbon Open Transportcompatibility library provides convenient and efficient blockingnetworking, so on that platform OTMP just calls the system and letsit do the heavy lifting. However, things are not that simple on MacOS 9.</P><P>On Mac OS 9 it's not possible to do networking directly from an MPtask. Open Transport is not MP-safe. Therefore, OTMP must get themain task to do all the actual networking. There are three keyproblems to consider.</P><UL>   <LI>MP to main communications -- When an MP task performs some   network operation, it must signal the main task to actual call   Open Transport. For good performance, this signaling mechanism   must have a low latency. <CODE>MPRemoteCall</CODE>, which stalls   the MP task until some application calls <CODE>SystemTask</CODE>,   does not meet this requirement.</LI>      <LI>Main to MP communications -- Once the MP task has signaled the   main task to start an asynchronous operation, the MP task must   block waiting for the operation to complete. When the operation   completes (which typically happens at deferred task time), the   main task must unblock the MP task, also with a minimum   latency.</LI>      <LI>Global Synchronization -- The communication between MP tasks   and the main task implies that some data structure must be shared   by the two execution environments. Access to this data structure   must be synchronized to prevent race conditions. However, the two   environments are very different, and require different   synchronization primitives. For example, the main task can't call   <CODE>MPEnterCriticalSection</CODE> at deferred task time and MP   tasks can't call <CODE>OTEnterNotifier</CODE>.</LI></UL><P>Each of these topics is discussed in a later section. But first,let's look at the core data structures used by OTMP.</P><H3>Data Structures</H3><P>OTMP uses three core data structures, as shown in Figure 1.</P><P><A NAME=Figure1></A></P><CENTER><IMG SRC="ReadMeFigure1.gif" WIDTH=396 HEIGHT=405 ALIGN=bottom><P><B>Figure 1. OTMP Data Structures</B></P></CENTER><P><A NAME=EventGroupAllocation></A>For every MP task that isprepared to call OTMP (every task that has called<CODE>OTMPPrepareThisTask</CODE>) there is an<CODE>OTMPTaskData</CODE> structure. This structure is referenced bya per-task variable (see <A HREF="http://developer.apple.com/techpubs/macos8/OSSvcs/MultiPServices/MultiprocessingRef/MP.5e.html"><CODE>MPGetTaskStorageValue</CODE></A>)and is allocated when the task calls <CODE>OTMPPrepareThisTask</CODE>and deallocated when the task calls<CODE>OTMPUnprepareThisTask</CODE>. The only interesting field ofthis structure is <CODE>waitEvents</CODE>, an MP <A HREF="http://developer.apple.com/techpubs/macos8/OSSvcs/MultiPServices/MultiprocessingRef/MP.40.html">eventgroup</A> that is allocated along with the structure. This eventgroup is used to block MP tasks when they are waiting for the maintask to complete an operation.</P><P><B>Note:</B> A per-task data structure is used to avoid memoryallocations on the data path. It is not possible to allocate an eventgroup per provider because there can be more than one outstandingblocking operations on the same provider (for example, an<CODE>OTMPSnd</CODE> and an <CODE>OTMPRcv</CODE>). On the other hand,allocating an event group for each operation would slow down everyoperation, including operations on the data path that should bequick. Using an event group per task is a good middle position. It'snot possible for a task to do two blocking calls simultaneously, soan event group per task is sufficient. It is also efficient, becauseit uses a single lightweight call (<A HREF="http://developer.apple.com/techpubs/macos8/OSSvcs/MultiPServices/MultiprocessingRef/MP.5e.html"><CODE>MPGetTaskStorageValue</CODE></A>)instead of a call that requires allocation (<A HREF="http://developer.apple.com/techpubs/macos8/OSSvcs/MultiPServices/MultiprocessingRef/MP.41.html"><CODE>MPCreateEvent</CODE></A>).</P><P>The next core data structure is the <CODE>OTMPProvider</CODE>. Itwraps the underlying Open Transport provider (a reference to which isin the <CODE>otEP</CODE> field) and adds some additional fields. Themost important extra field is <CODE>waitRecords</CODE>, a linked listof all operations blocked on this provider.</P><P><B>Note:</B> This has to be a list rather than a single pointerbecause there can be more than one outstanding blocking operation onthe provider.</P><P><B>Note:</B> Although the "EP" in <CODE>otEP</CODE> and<CODE>mpEP</CODE> implies that OTMP deals exclusively with endpoints,that is not true. Just like OT, OTMP works on providers at the bottomlevel. While OTMP currently only supports one class of providers, theendpoint class, this may not always be true.</P><P>The final core data structure is the <CODE>OTMPWaitRecord</CODE>.This structure holds all the information needed for</P><UL>   <LI>the MP task to request the main task to do a network   operation</LI>      <LI>the MP task to block waiting for the main task to complete the   operation</LI>      <LI>the main task to unblock the MP task</LI></UL><P>The <CODE>link</CODE> field is used to chain together all of thewait records for a given provider. The concurrency control on thislist is a tricky topic and is <A HREF="#GlobalSync">discussedbelow</A>.</P><P>The <CODE>waitingFor</CODE> field holds an<CODE>OTEventCode</CODE> that describes the event that the operationis waiting for. The example in figure one shows an<CODE>OTMPBind</CODE> operation, and hence the value is<CODE>T_BINDCOMPLETE</CODE>. When the provider's notifier (which isrun by the main task) is called with this value, the main task willunblock the corresponding MP task.</P><P>It's important to recognize that this value is not matchedexactly. For example, if an MP task does an <CODE>OTMPRcv</CODE> andno data is present, a wait record is queued with a<CODE>waitingFor</CODE> value of <CODE>T_DATA</CODE>. However, if theendpoint disconnects before more data arrives, the endpoint'snotifier will be called with a <CODE>T_DISCONNECT</CODE> event, whichwill cause the wait record to be dequeued and the MP task to continuewith a <CODE>kOTLookErr</CODE>. For more details, see the commentsassociated with the routine <CODE>WaitRecordSearchProc</CODE> in"OTMP.c".</P><P>The <CODE>noteProc</CODE> field of the wait record contains apointer to a routine that is called when the <CODE>waitingFor</CODE>event is delivered to the notifier. It allows the routine to doevent-specific notification processing. <CODE>OTMPBind</CODE> doesnot need this, so it sets this field to <CODE>nil</CODE>.</P><P>The <CODE>waitEvents</CODE> field contains the ID of the eventgroup associated with the MP task that made the request. The coderunning in the main task set an event in this event group when itwants to unblock the MP task (see <A HREF="#BlueToMP">Main to MPCommunication</A>). This field is <CODE>kInvalidID</CODE> when therequest is made by cooperatively scheduled code (the main thread or aThread Manager thread). In that case, the cooperative code polls the<CODE>waitComplete</CODE> Boolean and unblocks when the notifier setsit to true.</P><P>The <CODE>waitResult</CODE> field holds the result of theoperation. Although this field is initialized to<CODE>ioInProgress</CODE> (1) it is not possible to poll this fieldbecause some OT routines (for example, <CODE>OTMPIoctl</CODE> and<CODE>OTMPSnd</CODE>) return positive values to indicate success.When the MP task unblocks it extracts the operation result from thisfield and returns it as the function result for the OTMP routine.</P><P>The final field of the wait record is labeled <CODE>blue</CODE>.This is a <A HREF="#MPToBlue">Blue action</A> that is used schedulean operation that runs on the main task as soon as possible. It isbasically a wrapper around a deferred task: it contains a pointer toa routine that is called at deferred task time. See <A HREF="#MPToBlue">MPTo Main Communication</A> for more details.</P><P>The wait record is actually a sub-field of other structures thatholds additional parameters. The first wrapper structure is a<CODE>StdParam</CODE>. This holds fields required for standard OToperations, that is an operation on an provider that might runasynchronously. Some OTMP operations are not standard operations (forexample, <CODE>OTMPOpenEndpointQInContext</CODE> is non-standardbecause there is no endpoint present when the operation starts) butmost operations are standard (including <CODE>OTMPBind</CODE>, whichis used in this example).</P><P>Aside from the embedded wait record, the <CODE>StdParam</CODE>structure includes two additional fields. The <CODE>mpEP</CODE> fieldis a reference back to the <CODE>OTMPProvider</CODE>. This isrequired as part of the <CODE>StdAction</CODE> routine, which is<A HREF="#StdAction">discussed later</A>. The second extra field is<CODE>stdAction</CODE>, a pointer to a callback routine used by<CODE>StdAction</CODE>.</P><P>The outmost level of wrapping around the wait record is aparameter block that is unique to each OTMP routine. This parameterblock embeds the wait record (inside a <CODE>StdParam</CODE>, if theroutine implements a standard operation) and the other parametersnecessary for the routine. In this example we can see that<CODE>BindParam</CODE> includes a <CODE>StdParam</CODE> (which holdsthe <CODE>mpEP</CODE> parameter to <CODE>OTMPBind</CODE>) and twoother fields to hold the <CODE>reqAddr</CODE> and<CODE>retAddr</CODE> parameters to <CODE>OTMPBind</CODE>.</P><P>One crucial aspect of these routine-specific parameter blocks isthat they exist on the stack (that is, the parameter block is a localvariable of the OTMP routine). The OTMP routine fills out the fieldsof the parameter block, starts the operation by scheduling a Blueaction, and then blocks until the main task has completed theoperation and unblocks it. By allocating the parameter block on thestack we minimize the overhead of memory allocations on the datapath.</P><H3><A NAME=MPToBlue></A>MP to Main Communication</H3><P>Communication from MP to the main task is done via Blue actions,implemented in the module MoreBlueActions. A Blue action is much likea deferred task. The client supplies a <CODE>MoreBlueAction</CODE>structure to a routine <CODE>MoreBlueActionInstall</CODE>, which addsthe structure to a linked list of structures(<CODE>gMoreBlueActionList</CODE>). The module then installs adeferred task (using <CODE>DTInstall</CODE>). When the deferred taskcallback (<CODE>MoreBlueActionsRun</CODE>) executes, it dequeues allof the Blue actions on the list and calls their associated actioncallback. MoreBlueActions uses a single deferred task to run allqueued Blue actions, and uses an atomic lock,<CODE>gMoreBlueActionsRunInUse</CODE>, to track the usage of thatdeferred task.</P><P>OTMP uses Blue actions to schedule operations to run on the maintask. The <CODE>blue</CODE> field of the wait record is the Blueaction used for that record. <A NAME=StdAction></A>For a standardoperation, the <CODE>blue</CODE> field contains a pointer to theroutine <CODE>StdAction</CODE>. When this routine is called atdeferred task time it does three things.</P><OL>   <LI>On entry <CODE>StdAction</CODE> enters the provider's   notifier. On exit it leaves the notifier. This locks out other   notifications while the routine is running. This is a required   part of the <A HREF="#GlobalSync">global synchronization   model</A>.</LI>      <LI><CODE>StdAction</CODE> calls the callback routine referenced   by the <CODE>stdAction</CODE> field of the <CODE>StdParam</CODE>   structure. This routine is different from a standard Blue action   in that it returns a Boolean result indicating whether the   operation is complete.</LI>      <LI>If the callback routine returns true, <CODE>StdAction</CODE>   completes the wait record, which unblocks the MP task. If the   callback returns false, <CODE>StdAction</CODE> adds the wait   record to the list of wait records associated with the provider.   An event in the future (the delivery of an event to the provider's   notifier) will complete the operation and unblock the MP   task.</LI></OL><P>See the <CODE>StdAction</CODE> routine in "OTMP.c" for moredetails.</P><H3><A NAME=BlueToMP></A>Main to MP Communication</H3><P>Communication from the main task to the MP task in done via anevent group. The allocation of this event group is <A HREF="#EventGroupAllocation">discussedabove</A>. After the MP task has initialized an operation parameterblock, it schedules a Blue action to start the operation. It thenblocks itself on its event group. When the operation completes, thecode in the main task (typically running at deferred task time) isresponsible for unblocking the MP task. It does this in threesteps.</P><OL>   <LI>It sets the <CODE>waitResult</CODE> field of the wait record   to the result of the operation. After being unblocked the OTMP   routine will return this as its function result.</LI>      <LI>It sets the <CODE>waitComplete</CODE> field of the wait record   to true. This will unblock a cooperatively scheduled caller of   OTMP. See <A HREF="#SystemTaskExecution">System Task Execution</A>   for more details on how cooperatively scheduled clients of OTMP   work.</LI>      <LI>If the <CODE>waitEvents</CODE> field of the wait record is not   <CODE>kInvalidID</CODE>, it sets a bit it the event group using   <CODE>MPSetEvent</CODE>. This will unblock an MP task caller of   OTMP.</LI></OL><P>See the <CODE>CompleteWaitRecord</CODE> routine in "OTMP.c" forthe exact code.</P><P><CODE>CompleteWaitRecord</CODE> is called in two broad classes ofscenario.</P><UL>   <LI>If the Blue action completes immediately (either because it's   an immediate operation (for example, <CODE>OTLook</CODE>) or   because the attempt to start an asynchronous operation failed (for   example, <CODE>OTBind</CODE> returns an error), the Blue action   calls <CODE>CompleteWaitRecord</CODE> directly.</LI>      <LI>If the Blue action successfully starts an asynchronous   operation, it adds the wait record to the provider's list of wait   records and returns. When the operation completes, the provider's   notifier is called. The notifier finds the correct wait record by   walking the list of wait records, matching the notifier's   <CODE>OTEventCode</CODE> parameter to the <CODE>waitingFor</CODE>   field of each wait record. When it finds a match, it removes the   wait record from the list and, in most cases, calls   <CODE>CompleteWaitRecord</CODE> to unblock the MP task.</LI></UL><H3><A NAME=GlobalSync></A>Global Synchronization Model</H3><P>Whenever you write multithreaded code it is vital to synchronizeaccesses to data shared between the threads. OTMP is no exception tothis rule. However, OTMP's job is particularly tricky because itlives on the boundary between two threading models, MP tasks and OpenTransport (deferred tasks and notifiers).</P><P>MP tasks can use MP critical sections (mutexes) to synchronizedaccess to their shared data. However, MP critical sections can not beused to synchronize with deferred tasks -- they are blockingoperations, and it is not safe for the main task to block at deferredtask time. On the other hand the main task can use deferred tasks andnotifiers to synchronize access to its shared data, but this will notstop MP task accessing it. MP tasks can not call<CODE>OTEnterNotifier</CODE>!</P><P>OTMP's solution to this is to access all shared data from an OTnotifier running at deferred task time in the main task. The MP taskis responsible for initializing an operation parameter block and thenqueuing a Blue action. The Blue action does all of the work. It'srunning as a deferred task so it can use standard OT mechanisms tosynchronize access to data.</P><P>The key data structure that needs protection is the<CODE>waitRecords</CODE> list in the <CODE>OTMPProvider</CODE>. Thislist is a standard OT list and thus OTMP must ensure than only onethread of execution is touching it at any given time. It does this inthe following way.</P><UL>   <LI>Blue actions always run at deferred task time.</LI>      <LI>Blue actions that modify the list will always call   <CODE>OTEnterNotifier</CODE> before doing so. This prevents an OT   notification from being delivered while the Blue action is   running.</LI>      <LI>OT notifications are typically executed at deferred task time.   However, this is not always the case. It OT calls OTMP's notifier   at system task time, OTMP switches to deferred task time to   actually do the work.</LI>      <LI>OT notifications implicitly hold the notification lock for the   endpoint. This prevents other notifications for the same endpoint   from running until the notifier returns. Also, OT notifications   run at deferred task time, which prevents any Blue actions from   interrupting the notifier (Blue actions also run at deferred task   time and deferred tasks are serialized).</LI></UL><P><B>Note:</B> The third and fourth point are the reasons why theOTMPX routines must call the system-supplied OT compatibility libraryon Mac OS X rather than just calling the corresponding OTMP routine.Mac OS X provides no concurrency guarantees between deferred tasksand OT notifiers.</P><H3>A Walk Through OTMPXBind</H3><P>To illuminate the topics covered in the previous sections, let'slook at the various steps taken by <CODE>OTMPXBind</CODE> when it'scalled by an MP task.</P><OL>   <LI><CODE>OTMPXBind</CODE> tests whether it's running on Mac OS X.   The technique used is described in DTS Q&amp;A OV 03 <A HREF="http://developer.apple.com/qa/ov/ov03.html">Detecting   Classic and Carbon Environments</A>. If it's running on Mac OS X,   it calls <CODE>OTBind</CODE> and returns. Mac OS X's Open   Transport compatibility library is safe to call from MP tasks. If   it's running on Mac OS 9, <CODE>OTMPXBind</CODE> calls   <CODE>OTMPBind</CODE>. All of the remaining steps describe the   process on Mac OS 9.</LI>      <LI><CODE>OTMPBind</CODE> initializes a stack-based   <CODE>BindParam</CODE> structure to the state shown in <A HREF="#Figure1">Figure   1</A>. It then calls an OTMP internal routine,   <CODE>QueueBlueAndWait</CODE>.</LI>      <LI><CODE>QueueBlueAndWait</CODE> starts by calling   <CODE>MoreBlueActionInstall</CODE> to schedule the Blue action   associated with the operation. At this point the execution paths   fork. The MP task continues to run <CODE>QueueBlueAndWait</CODE>,   while the main task takes an interrupt and schedules a deferred   task which eventually runs the Blue action (in this case   <CODE>StdAction</CODE>). I will discuss the MP task first although   you must remember that these operations can happen in different   orders.</LI>      <LI>The MP task continues the execution of   <CODE>QueueBlueAndWait</CODE>. The next step is for the MP task to   block waiting on the <CODE>waitEvents</CODE> field of the event   record. The task remains blocked until it is unblocked by the Blue   action.</LI>      <LI>At some point after calling <CODE>MoreBlueActionInstall</CODE>   (step 3) the main task runs the Blue action, in this case   <CODE>StdAction</CODE>. This routine calls   <CODE>OTEnterNotifier</CODE> to prevent OT calling the endpoint's   notifier. It then calls the standard action (the   <CODE>stdAction</CODE> field of the <CODE>StdParam</CODE>   structure), which in this case calls   <CODE>BindStdAction</CODE>.</LI>      <LI><CODE>BindStdAction</CODE> is quite simple. It calls   <CODE>OTBind</CODE> with the parameters stored in the   <CODE>BindParam</CODE> parameter block. It is safe to call OT at   this time because we're running as a deferred task on the main   task. <CODE>BindStdAction</CODE> then returns, with a return   result of either true (the <CODE>OTBind</CODE> call returned an   error) or false (the <CODE>OTBind</CODE> call succeeded).</LI>      <LI>At this point <CODE>StdAction</CODE>'s behavior varies   depending on the result from the standard action   (<CODE>BindStdAction</CODE>). If the result is true,   <CODE>StdAction</CODE> will complete the wait record and unblock   the MP task by calling <CODE>CompleteWaitRecord</CODE>. However,   for the sake of this discussion let's assume that the result is   false. In that case <CODE>StdAction</CODE> adds the wait record to   the endpoint's <CODE>waitRecords</CODE> list.</LI>      <LI>Before returning, <CODE>StdAction</CODE> calls   <CODE>OTLeaveNotifier</CODE> to unblock notifications on this   endpoint (they were blocked in step 5). It's likely that the   <CODE>T_BINDCOMPLETE</CODE> event has already occurred (the bind   operation is very fast), in which case this call will actually   deliver that event to the endpoint's notifier   (<CODE>TrueBlueNotifier</CODE>).</LI>      <LI><CODE>TrueBlueNotifier</CODE> determines that it is being   called at deferred task time, and so can call BlueNotifier without   any complications.</LI>      <LI><CODE>BlueNotifier</CODE> searches the endpoint's   <CODE>waitRecords</CODE> list for a wait record that matches the   event that is being delivered. In this case it finds the wait   record that was added to the list in step 7. It removes that wait   record from the list and looks at the <CODE>noteProc</CODE> field.   If <CODE>noteProc</CODE> is not <CODE>nil</CODE>,   <CODE>BlueNotifier</CODE> calls it. However, in the case of   <CODE>OTMPBind</CODE> the <CODE>noteProc</CODE> field is   <CODE>nil</CODE>, which indicates that this request does not   require notification processing: <CODE>BlueNotifier</CODE> can   complete the wait record by calling   <CODE>CompleteWaitRecord</CODE>. It uses the notifier's   <CODE>result</CODE> parameter as the operation result for the wait   record.</LI>      <LI><CODE>CompleteWaitRecord</CODE> stores the operation result   into the <CODE>waitResult</CODE> field of the wait record and then   sets <CODE>waitComplete</CODE> to true. It then sets an event in   the event group designated by the <CODE>waitEvents</CODE> field.   This unblocks the MP task that was blocked in step 4. It then   returns to <CODE>BlueNotifier</CODE>, which in turns returns to   OT, which returns from <CODE>OTLeaveNotifier</CODE> to   <CODE>StdAction</CODE>, which returns to the Blue actions module,   which returns to the Deferred Task Manager. The critical thing is   that none of these routines touch the wait record after the MP   task has been unblocked. This is necessary because the wait record   exists on the MP task's stack, and may well be destroyed as soon   as the MP task unblocks.</LI>      <LI>After being unblocked (in the step above) the MP task is now   running the remainder of <CODE>QueueBlueAndWait</CODE>. This   extracts the operation result from the wait record and returns it   as its function result to <CODE>OTMPBind</CODE>, which returns the   result to <CODE>OTMPXBind</CODE>, which returns the result to the   original caller.</LI></OL><P>Neat huh?</P><P>While this is an accurate description of the implementation of<CODE>OTMPXBind</CODE>, it is an idealized view of OTMP as a whole.There are a number of OT routines that do not have simple completionevents, or have two completion events, or where OT breaks reentrancyinvariants. Some of the trickier cases include<CODE>OTMPXOpenEndpointQInContext</CODE>,<CODE>OTMPXCloseProvider</CODE>, <CODE>OTMPXLook</CODE>,<CODE>OTMPXConnect</CODE>, <CODE>OTMPXSnd</CODE>,<CODE>OTMPXRcv</CODE>, <CODE>OTMPXListen</CODE> and<CODE>OTMPXAccept</CODE>. These corner cases are extensivelydocumented in comments in "OTMP.c".</P><H3><A NAME=SystemTaskExecution></A>System Task Execution</H3><P>As mentioned <A HREF="#SystemTask">earlier in this document</A> itis possible to call OTMP from cooperative scheduled code. This has anumber of consequences. First, when a cooperative thread calls OTMPthere's no need for an event group on which to block the thread whilewaiting for the network. This is good because the technique used tostore the event group's ID (per-MP task storage) does not work wellfor multiple cooperative threads within the main task. Instead ofblocking on an event group the cooperative thread simply spins on the<CODE>waitComplete</CODE> field of the wait record. While it'sspinning it calls the thread yielder (installed using<CODE>InstallOTMPMainThreadYielder</CODE>) which allows the clientapplication to yield time to other threads and processes.</P><UL>   <LI>Step 4 -- Instead of blocking on the event group, the   cooperative thread loops waiting for the <CODE>waitComplete</CODE>   field to become true. While looping it calls the thread yielder   (if any) installed by the client.</LI>      <LI>Step 10 -- Wait records initialized by cooperative threads   have their <CODE>waitEvents</CODE> field set to   <CODE>kInvalidID</CODE>. <CODE>CompleteWaitRecord</CODE> detects   this special case and doesn't attempt to set an event in this   event group. Setting <CODE>waitComplete</CODE> to true is   sufficient to unblock the cooperatively scheduled thread.</LI></UL><H3>Reusing OTMP Techniques</H3><P>It is possible to reuse the techniques described above to make anyMac OS 9 interrupt-safe system service available from MP tasks. Forexample, say you want to call the USB API synchronously from an MPtask. You can do this by</P><UL>   <LI>creating a per-task event group,</LI>      <LI>allocating a <CODE>USBPB</CODE> on your MP task's stack,</LI>      <LI>using <CODE>DTInstall</CODE> (or   <CODE>MoreBlueActionInstall</CODE>) to run a Blue action that does   an asynchronous USB operation from deferred task time,</LI>      <LI>blocking the MP task on the event group, and</LI>      <LI>having the USB operation's completion routine set an event in   the event group to unblock the MP task.</LI></UL><P>Apple has used techniques similar to this to make the File Managerand Device Manager callable from MP tasks. You can extend thistechnique for any Mac OS API that is callable at <A HREF="http://developer.apple.com/technotes/tn/tn1104.html">interrupttime</A> (for example, USB, FireWire, SCSI Manager, ATA Manager,Sound Manager).</P><H2><A NAME=Caveats></A>Caveats</H2><P>This sample has a number of caveats of which you should beaware.</P><UL>   <LI>Due to a bug in CarbonLib &#91;2563553&#93;, OTMP will not run   if a version of CarbonLib older than 1.2.5 is installed. You can   use the function <CODE>OTMPGetCanRunStatus</CODE> to determine   whether OTMP will run on the current system.</LI>      <LI>Due to a bug in the system software, this sample may be   unreliable when run on Mac OS 9.1. The problem is that   <CODE>MPRemoteCall</CODE> sometimes deadlocks the system on Mac OS   9.1. The only workaround is to not use Mac OS 9.1. The problem   does not occur on Mac OS 9.0.x and is fixed on Mac OS 9.2.x.</LI>      <LI>OTMP does not implement all the the OT APIs that make sense to   call from MP tasks. Some routines, such as   <CODE>OTInetStringToAddress</CODE>, were deliberately omitted.   Other routines, for example <CODE>OTInetAddressToName</CODE>, were   left out because I ran out of time. Adding these routines is left   as an exercise for the reader (-: Seriously though, if you need   any additional OT routines please let me know and I will update   the sample.</LI>      <LI>There is no 68K support. This makes sense given that the OTMP   library uses MP features that are only available on Mac OS 9,   which in turn requires a PowerPC-based computer.</LI>      <LI>OTMP uses a per-task storage variables, as provided by the MP   library's <CODE>MPAllocateTaskStorageIndex</CODE> routine. These   variables are a very limited resource (current implementations   only provide 32), so it's possible to run out.</LI>      <LI>This sample makes use of the <A HREF="http://developer.apple.com/samplecode/Sample_Code/Networking/OTClassicContext.htm">OTClassicContext</A>   library. See that library's Read Me document for caveats   associated with the use of that library.</LI>      <LI>OTMPTest is a program I used it to explore various issues   during development; it's code is not meant to be copied into a   production application, which is why it isn't included in the   official sample distribution (it is available, however, as part of   MoreIsBetter). If you want to copy code for your production   application, copy it from the OTMPSimpleServerHTTP sample.</LI>      <LI>OTMP does not provide any notification mechanism. If you need   to receive unusual events from OT (for example,   <CODE>T_ATALKCABLERANGECHANGEDEVENT</CODE> ), you will have to   either add your own notification mechanism to OTMP or just not use   OTMP for that part of your software.</LI>      <LI>OTMP currently has no support for no copy sends (AckSends) and   receives. Adding support for no copy receives is fairly easy, but   adding support for no copy sends requires a little design effort   to solve the issue of how OT returns buffers to your preemptive   threads.</LI>      <LI>OTMP does not currently support non-blocking I/O. I believe   that you can use <CODE>OTMPCountDataBytes</CODE> to avoid the need   for non-blocking I/O. If I'm wrong, please let me know.</LI>      <LI>The implementation of <CODE>OTMPAccept</CODE> (and hence   <CODE>OTMPXAccept</CODE> when running on Mac OS 9) has a race   condition that you must avoid in your code. See the comments in   "OTMP.h" for details.</LI>      <LI>OTMP does not properly support expedited data. There are a   variety of technical reasons for this (see the comments in   "OTMP.c"). I could probably fix this, but at the moment I'm taking   the position that very few protocols use expedited data and thus   this problem is not a high priority. Let me know if I'm   wrong.</LI>      <LI>Mac OS X Public Beta had a number of MP-related bugs that   cause problems for the OTMPSimpleServerHTTP sample. These bugs are   fixed in Mac OS X 10.0.      <UL>      <LI>The clean quitting approach implemented by      OTMPSimpleServerHTTP does not work under Carbon on Mac OS X      Public Beta. This is due to a bug in      <CODE>OTCancelSynchronousCalls</CODE> on that platform      &#91;2529685&#93;. The workaround on Public Beta is to quit the      application using the Quit menu command (command-Q) without      first shutting down the server with the "q" command.</LI>            <LI><CODE>MPLogPrintfSlow</CODE> uses      <CODE>MPRemoteCall</CODE>, which isn't implemented on Mac OS X      Public Beta &#91;2544931&#93;. I have hacked up a workaround      that is good enough to get the sample to a demoable state. See      the comments in the implementation of that routine for details.      I've left that hack in place for the time being, although I      will eventually remove it once Public Beta is long      forgotten.</LI>            <LI>On Mac OS X Public Beta the construct      <CODE>MPTaskIsPreemptive(kInvalidID)</CODE> will always return      true, regardless of whether you're running on the main thread      or a preemptive thread &#91;2552548&#93;. Fortunately, all of      the calls to <CODE>MPTaskIsPreemptive</CODE> that run on Mac OS      X are inside debug assertions. The workaround is to ignore      these debug assertions.</LI>   </UL>   </LI>      <LI>The OTMPSimpleServerHTTP sample is not a production HTTP   server. The purpose of this sample is to demonstrate the OTMP   library, not to show you how to write an HTTP server.      <UL>      <LI>The sample creates an endpoint for each connection, and      disposes of it when the connection closes. This is bad for      performance because it takes a long time to create an endpoint,      especially on traditional Mac OS. A production server should      implement HTTP "keepalive" and create a pool of endpoints for      reuse by various connections.</LI>            <LI>The sample creates an MP task for each connection, and      disposes of it when the connection closes. This is bad for      performance because it takes a long time to create an MP task,      especially on Mac OS X. A production server should create a      pool of MP tasks for reuse by various connections.</LI>            <LI>The sample does a very poor job of parsing incoming      requests. It is susceptible to buffer overrun attacks. A      production server must protect against this form of      attack.</LI>            <LI>The sample copies data to the endpoint in 4 KB chunks. A      production server would use larger buffers, and cache the      contents of files to prevent excessive File Manager load      (especially on Mac OS 9).</LI>            <LI>The sample uses a 64 KB stack for all MP tasks. This is      probably excessive, but I haven't done the analysis required to      reduce it.</LI>   </UL>   </LI></UL><H2>Credits and Version History</H2><P>If you find any problems with this sample, mail&lt;DTS@apple.com&gt; and we will try to fix them up.</P><UL>   <LI>1.0d1 (Sep 2000) was released to a few employees for testing   purposes.</LI>      <LI>1.0a1 (Nov 2000) was released to Apple employees only for   internal evaluation.</LI>      <LI>1.0a2 (Dec 2000) is the first general release.</LI>      <LI>1.0a3 (Feb 2001) is the first cut at a release for Mac OS X   10.0. It still has a number of rough edges; I will polish them in   subsequent releases.</LI>      <LI>1.0a4 (Jul 2001) is an interim release to fix a particularly   nasty bug uncovered by a developer during testing.</LI>      <LI>1.0a5 (Sep 2001) is the polished release that includes both of   the recent updates (Mac OS X support and the 1.0a4 bug fix).</LI></UL><P>Share and Enjoy.</P><P>Worldwide Developer Technical Support<BR>21 Sep 2001</P><P></P></BODY></HTML>