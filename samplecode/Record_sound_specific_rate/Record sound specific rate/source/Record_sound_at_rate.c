/***	Apple Macintosh Developer Technical Support****	Demonstrates how to record to an AIFF file at a specific**	sampling rate, not necessarily a rate supported by the hardware.****	by Mark Cookson, Apple Developer Technical Support****	File:	Record_sound_at_rate.c****	Copyright ©1998-1999 Apple Computer, Inc.**	All rights reserved.****	You may incorporate this sample code into your applications without**	restriction, though the sample code has been provided "AS IS" and the**	responsibility for its operation is 100% yours.  However, what you are**	not permitted to do is to redistribute the source as "Apple Sample**	Code" after having made changes. If you're going to re-distribute the**	source, we require that you make it clear in the source that the code**	was descended from Apple Sample Code, but that you've made changes.*/#include		<Quickdraw.h>#include		<Windows.h>#include		<dialogs.h>#include		<Events.h>#include		<Memory.h>#include		<Packages.h>#include		<Sound.h>#include		<SoundInput.h>#include		<OSUtils.h>#include		<Files.h>#include		<StandardFile.h>#include		<Fonts.h>#include		<Devices.h>#include		"Record_sound.h"// GlobalsBoolean			lastBufferWritten;#if 1static void ToolBoxInit (void) {	MaxApplZone();	InitGraf (&qd.thePort);	InitFonts ();	InitWindows ();	InitMenus ();	TEInit ();	InitDialogs ((long)nil);	InitCursor ();	return;}void main (void) {	Vars		myVars;	Rect		r		= {100, 90, 150, 400};	WindowPtr	window	= nil;	unsigned long		temp;	OSErr		err;	ToolBoxInit ();	// Will be rate converted to 11.025kHz later.	err = PrepairToRecordToDisk (&myVars, 0, 8, rate44khz, 1, 'NONE', false);	if (err == noErr) {		err = RecordToDisk (&myVars);	}	if (err == noErr) {		// Make a little window		window = NewWindow (nil, &r, "\pRecording Sound", true, 0, (WindowRef)-1, false, 0);		SetPort (window);		MoveTo (20,20);		DrawString ("\pRecording 3 seconds of soundÉ");		Delay (180, &temp);		// record for about three seconds		err = myVars.theErr;	// were any errors returned from the recording?		if (err != noErr && err != abortErr) {			DebugStr ("\pRecording didn't complete without error");		}		DisposeWindow (window);		// if the error was that we ran out of disk space we can still write the		// header because we preallocated space for it.  The file may be bad,		// but it doesn't have to be.  At any rate we want to close the file and		// dispose of memory.		err = FinishRecording (&myVars);	}}#endifstatic OSErr	SetupDevice (long inputDevice,							short *numChannels,							short *sampleSize,							Fixed *sampleRate,							OSType *compression,							short *AGC,							long *devBuffer) {	OSErr				err;	Fixed				gain = 0x00008000;	short				on = 1;	err = SPBSetDeviceInfo (inputDevice, siSampleRate, (Ptr) sampleRate);	if (err != noErr)		DebugStr("\pcouldn't set sample rate");	err = SPBSetDeviceInfo (inputDevice, siSampleSize, (Ptr) sampleSize);	if (err != noErr)		DebugStr("\pcouldn't set sample size");	err = SPBSetDeviceInfo (inputDevice, siTwosComplementOnOff, (Ptr) &on);	if (err != noErr)		DebugStr("\pcouldn't set twos complement");	err = SPBSetDeviceInfo (inputDevice, siNumberChannels, (Ptr) numChannels);	if (err != noErr)		DebugStr("\pcouldn't set number of channels");	err = SPBSetDeviceInfo (inputDevice, siCompressionType, (Ptr) compression);	if (err != noErr)		DebugStr("\pcouldn't set compression type");	// turn on continuous recording to "warm up" the input device	err = SPBSetDeviceInfo (inputDevice, siContinuous, (Ptr) &on);	if (err != noErr) {		short	check = -1;		err = SPBGetDeviceInfo (inputDevice, siContinuous, (Ptr) &check);		if (check != on) {			DebugStr("\pcouldn't turn on continuous recording");		}	}	// turn on Automatic Gain Control	err = SPBSetDeviceInfo (inputDevice, siAGCOnOff, (Ptr) AGC);	if (AGC == 0 || err != noErr) {		// If AGC isn't available, just turn it all the way down to avoid over driving		err = SPBSetDeviceInfo (inputDevice, siInputGain, (Ptr) &gain);		if (err != noErr)			DebugStr("\pcouldn't get siInputGain");	}	// check to see what we really got	err = SPBGetDeviceInfo (inputDevice, siSampleRate, (Ptr) sampleRate);	if (err != noErr)		DebugStr("\pcouldn't get sample rate");	err = SPBGetDeviceInfo (inputDevice, siSampleSize, (Ptr) sampleSize);	if (err != noErr)		DebugStr("\pcouldn't get sample size");	err = SPBGetDeviceInfo (inputDevice, siNumberChannels, (Ptr) numChannels);	if (err != noErr)		DebugStr("\pcouldn't get number of channels");	err = SPBGetDeviceInfo (inputDevice, siDeviceBufferInfo, (Ptr) devBuffer);	if (err != noErr)		DebugStr("\pcouldn't get number of channels");	err = SPBGetDeviceInfo (inputDevice, siCompressionType, (Ptr) compression);	if (err != noErr)		DebugStr("\pcouldn't get compression type");	return err;}OSErr	PrepairToRecordToDisk (VarsPtr myVars, short refNum, short sampleSize, UnsignedFixed sampleRate, short numChannels, OSType compression, short AGC) {	OSErr					err		= noErr;	short					volRefNum;	unsigned long			buffSize,							outputBytes;	long					parID;	StandardFileReply		sfReply;	StringPtr				nameString;	if (refNum == 0) {		StandardPutFile ("\pPut recorded AIFF where...", "\pRecorded sound", &sfReply);		if (sfReply.sfGood) {			volRefNum = sfReply.sfFile.vRefNum;			myVars->volRefNum = volRefNum;			parID = sfReply.sfFile.parID;			myVars->parID = parID;			nameString = (StringPtr)&sfReply.sfFile.name;			BlockMoveData (nameString, myVars->nameString, nameString[0]+1);			if (err == noErr) {				HParamBlockRec		Hpb;				// create the file				Hpb.ioParam.ioCompletion = nil;				Hpb.ioParam.ioNamePtr = nameString;				Hpb.ioParam.ioVRefNum = volRefNum;				Hpb.fileParam.ioDirID = parID;				err = PBHCreateSync (&Hpb);				if (err == dupFNErr) {					err = noErr;	// overwriting the file is not an error				}				if (err != noErr)					DebugStr("\pPBHCreateSync failed");				if (err == noErr) {					// set the file type and creator					Hpb.fileParam.ioVRefNum = volRefNum;					Hpb.fileParam.ioDirID = parID;					Hpb.fileParam.ioNamePtr = nameString;					Hpb.fileParam.ioFVersNum = 0;					Hpb.fileParam.ioFDirIndex = 0;					err = PBHGetFInfoSync(&Hpb);					if (err != noErr)						DebugStr("\pPBHGetFInfoSync failed");				}				if (err == noErr) {					Hpb.fileParam.ioFlFndrInfo.fdType = 'AIFF';					Hpb.fileParam.ioFlFndrInfo.fdCreator = 'TVOD';					Hpb.fileParam.ioDirID = parID;					err = PBHSetFInfoSync (&Hpb);					if (err != noErr)						DebugStr("\pPBHSetFInfoSync failed");				}				if (err == noErr) {					// open the file for writing					Hpb.ioParam.ioCompletion = nil;					Hpb.ioParam.ioNamePtr = nameString;					Hpb.ioParam.ioVRefNum = volRefNum;					Hpb.ioParam.ioPermssn = fsRdWrPerm;					Hpb.fileParam.ioDirID = parID;					err = PBHOpenDFSync (&Hpb);					if (err != noErr)						DebugStr("\pPBHOpenDFSync failed");				}				if (err == noErr) {					myVars->fileRefNum = Hpb.ioParam.ioRefNum;				}			}		} else {			err = userCanceledErr;		}	} else {		myVars->fileRefNum = refNum;	}	if (err == noErr) {		myVars->numChannels	= numChannels;		myVars->sampleSize	= sampleSize;		myVars->sampleRate	= sampleRate;		myVars->compression	= compression;		myVars->AGC			= AGC;		if (refNum == 0) {			err = SPBOpenDevice (nil, siWritePermission, &myVars->soundRefNum);		}		if (err == noErr) {			err = SetupDevice (myVars->soundRefNum, &myVars->numChannels,													&myVars->sampleSize,													&myVars->sampleRate,													&myVars->compression,													&myVars->AGC,													&myVars->devBuffer);		}		if (err == noErr) {			// Set up conversion options now.			myVars->inputFormat.flags = 0;			if (myVars->compression == kSoundNotCompressed && myVars->sampleSize == 8)				myVars->inputFormat.format = k16BitBigEndianFormat;			else				myVars->inputFormat.format = myVars->compression;			myVars->inputFormat.numChannels = myVars->numChannels;			myVars->inputFormat.sampleSize = myVars->sampleSize;			myVars->inputFormat.sampleRate = myVars->sampleRate;			myVars->inputFormat.sampleCount = 0;			myVars->inputFormat.buffer = nil;			myVars->inputFormat.reserved = 0;			myVars->outputFormat.flags = 0;			if (myVars->compression == kSoundNotCompressed && myVars->sampleSize == 8)				myVars->outputFormat.format = k16BitBigEndianFormat;			else				myVars->outputFormat.format = myVars->compression;			myVars->outputFormat.numChannels = myVars->numChannels;			myVars->outputFormat.sampleSize = myVars->sampleSize;			myVars->outputFormat.sampleRate = rate11025hz;			myVars->outputFormat.sampleCount = 0;			myVars->outputFormat.buffer = nil;			myVars->outputFormat.reserved = 0;			// Have to open the sound converter at non-interrupt time.			err = SoundConverterOpen (&myVars->inputFormat, &myVars->outputFormat, &myVars->sc);		}		if (err == noErr) {			unsigned long	targetBytes;			targetBytes = myVars->devBuffer;			do {				targetBytes *= 2;				err = SoundConverterGetBufferSizes (myVars->sc, targetBytes, &myVars->inputFrames, &buffSize, &outputBytes);			} while (err == notEnoughBufferSpace && targetBytes < (MaxBlock () / 4));		}		if (err == noErr) {			err = SoundConverterBeginConversion (myVars->sc);		}		if (err == noErr) {			myVars->recBuffer0 = NewPtrClear(buffSize);			if (MemError() != noErr || myVars->recBuffer0 == nil) {				DebugStr("\pcouldn't get memory for recording buffer");				err = memFullErr;			}			myVars->recBuffer1 = NewPtrClear(buffSize);			if (MemError() != noErr || myVars->recBuffer1 == nil) {				DebugStr("\pcouldn't get memory for recording buffer");				err = memFullErr;			}			myVars->resampledBuf0 = NewPtrClear (outputBytes);			if (MemError() != noErr || myVars->resampledBuf0 == nil) {				DebugStr("\pcouldn't get memory for resampling buffer");				err = memFullErr;			}			myVars->resampledBuf1 = NewPtrClear (outputBytes);			if (MemError() != noErr || myVars->resampledBuf1 == nil) {				DebugStr("\pcouldn't get memory for resampling buffer");				err = memFullErr;			}		}		if (err == noErr) {			myVars->recordRec = (SPBPtr) NewPtrClear(sizeof (SPB));			if (MemError() != noErr || myVars->recordRec == nil) {				DebugStr("\pcouldn't get memory for recording record");				err = memFullErr;			}		}		if (err == noErr) {			myVars->pb0 = (myRecordingParmBlkPtr) NewPtrClear(sizeof (myRecordingParamBlockRec));			if (MemError() != noErr || myVars->pb0 == nil) {				DebugStr("\pcouldn't get memory for param block");				err = memFullErr;			}		}		if (err == noErr) {			myVars->pb1 = (myRecordingParmBlkPtr) NewPtrClear(sizeof (myRecordingParamBlockRec));			if (MemError() != noErr || myVars->pb1 == nil) {				DebugStr("\pcouldn't get memory for param block");				err = memFullErr;			}		}		if (err == noErr) {			ParamBlockRec		pb;			IOCompletionUPP 	MyPB0WriteCompUPP,								MyPB1WriteCompUPP;			SICompletionUPP 	MyRecCompUPP;			myVars->sanitycheck = 'SANE';			myVars->myA5 = SetCurrentA5 ();			myVars->whichBuffer = 0;			myVars->pb0->myA5 = SetCurrentA5 ();			myVars->pb1->myA5 = SetCurrentA5 ();			// set up the record parameters			MyRecCompUPP = NewSICompletionProc (MyRecComp);			myVars->recordRec->inRefNum = myVars->soundRefNum;			myVars->recordRec->count = buffSize;			myVars->recordRec->milliseconds = 0;			myVars->recordRec->bufferLength = buffSize;			myVars->recordRec->bufferPtr = myVars->recBuffer0;			myVars->recordRec->completionRoutine = MyRecCompUPP;			myVars->recordRec->interruptRoutine = nil;			myVars->recordRec->userLong = (long)myVars;			myVars->recordRec->error = 0;			myVars->recordRec->unused1 = 0;			// set up the parameter blocks for the coming writes			MyPB0WriteCompUPP = NewIOCompletionProc (MyPB0WriteComp);			MyPB1WriteCompUPP = NewIOCompletionProc (MyPB1WriteComp);			myVars->pb0->pb.ioParam.ioCompletion = MyPB0WriteCompUPP;			myVars->pb0->pb.ioParam.ioVRefNum = volRefNum;			myVars->pb0->pb.ioParam.ioRefNum = myVars->fileRefNum;			myVars->pb0->pb.ioParam.ioPosMode = fsFromStart;			myVars->pb1->pb.ioParam.ioCompletion = MyPB1WriteCompUPP;			myVars->pb1->pb.ioParam.ioVRefNum = volRefNum;			myVars->pb1->pb.ioParam.ioRefNum = myVars->fileRefNum;			myVars->pb1->pb.ioParam.ioPosMode = fsFromStart;			// write a temp AIFF header so file pointer for data is in the right place			err = SetupAIFFHeader (myVars->fileRefNum, myVars->outputFormat.numChannels, myVars->outputFormat.sampleRate, myVars->outputFormat.sampleSize, myVars->outputFormat.format, 0, 0);			if (err != noErr) {				DebugStr("\pSetupAIFFHeader failed");			}			pb.ioParam.ioCompletion = nil;			pb.ioParam.ioRefNum = myVars->fileRefNum;			err = PBGetFPosSync (&pb);			myVars->initialOffset = pb.ioParam.ioPosOffset;		}	} else {		err = userCanceledErr;	}	return err;}OSErr RecordToDisk (VarsPtr myVars) {	OSErr			err = noErr;	myVars->totalBytes = 0;	lastBufferWritten = false;	err = SPBRecord (myVars->recordRec, true);	if (err != noErr) {		DebugStr("\pSPBRecord failed");	}	return err;}/*	Stops the recording by calling SPBStopRecording and then writes the	correct file header to the file, closes the file and then disposes of	our pointers.*/OSErr	FinishRecording (VarsPtr myVars) {	OSErr			err;	ParamBlockRec	pb;	unsigned long	outputBytes,					outputFrames;	err = SPBStopRecording (myVars->soundRefNum);	if (err != noErr)		DebugStr("\pSPBStopRecording failed");	// wait for the last buffer to be written	while (!lastBufferWritten) {}	err = SoundConverterEndConversion (myVars->sc, myVars->resampledBuf0, &outputFrames, &outputBytes);	err = SoundConverterClose (myVars->sc);	if (outputBytes != 0) {		myVars->pb0->pb.ioParam.ioBuffer = myVars->resampledBuf0;		myVars->pb0->pb.ioParam.ioReqCount = outputBytes;		myVars->pb0->pb.ioParam.ioPosOffset = myVars->totalBytes + myVars->initialOffset;		myVars->totalBytes += outputBytes;		err = PBWriteSync (&myVars->pb0->pb);		myVars->totalBytes += outputBytes;	}	// Put the file pointer back to the start of the file to	// write the correct header over the temp header	pb.ioParam.ioCompletion = nil;	pb.ioParam.ioRefNum = myVars->fileRefNum;	pb.ioParam.ioPosMode = fsFromStart;	pb.ioParam.ioPosOffset = 0;	err = PBSetFPosSync (&pb);	if (err != noErr)		DebugStr("\pPBSetFPosSync failed");	if (err == noErr) {		// write the header with the correct information		err = SetupAIFFHeader (myVars->fileRefNum, myVars->outputFormat.numChannels, myVars->outputFormat.sampleRate, myVars->outputFormat.sampleSize, myVars->outputFormat.format, myVars->totalBytes, myVars->totalBytes/(myVars->sampleSize*myVars->numChannels));		if (err != noErr)			DebugStr("\pSetupAIFFHeader in FinishRecording failed");	}	err = PBCloseSync (&pb);	if (err != noErr)		DebugStr("\pPBCloseSync failed");	DisposePtr ((Ptr)myVars->recordRec);	DisposePtr (myVars->recBuffer0);	DisposePtr (myVars->recBuffer1);	DisposePtr ((Ptr)myVars->pb0);	DisposePtr ((Ptr)myVars->pb1);	return err;}/*	This gets called at the end of each record, it writes the recorded data to	disk (asynchronously) and then starts a new record using the same SPBPtr.	Make sure you have continous recording turned on otherwise the recording	may loose data between calls to SPBRecord.	*/pascal void MyRecComp (SPBPtr inParamPtr) {	VarsPtr			myVarsPtr;	OSErr			err;	unsigned long	outputFrames,					outputBytes;	#if !GENERATINGCFM		long		oldA5;		oldA5 = SetA5 (((VarsPtr)inParamPtr->userLong)->myA5);	#endif	myVarsPtr = (VarsPtr)inParamPtr->userLong;	// setting this now will avoid a race condition of the record finishing before	// we can toggle which buffer to use	myVarsPtr->whichBuffer = !myVarsPtr->whichBuffer;	// If the last write returned with no error then continue recording	if (myVarsPtr->pb0->pb.ioParam.ioResult >= noErr && myVarsPtr->pb1->pb.ioParam.ioResult >= noErr) {		// If we are aborting (stopping) the recording, we still want to write the last buffer		if (inParamPtr->error >= noErr || inParamPtr->error == abortErr) {			if (myVarsPtr->whichBuffer == 1) {				err = SoundConverterConvertBuffer (myVarsPtr->sc, myVarsPtr->recBuffer0, myVarsPtr->inputFrames, myVarsPtr->resampledBuf0, &outputFrames, &outputBytes);				myVarsPtr->pb0->pb.ioParam.ioBuffer = myVarsPtr->resampledBuf0;				myVarsPtr->pb0->pb.ioParam.ioReqCount = outputBytes;				myVarsPtr->pb0->pb.ioParam.ioPosOffset = myVarsPtr->totalBytes + myVarsPtr->initialOffset;				myVarsPtr->totalBytes += outputBytes;				if (inParamPtr->error == abortErr) {					myVarsPtr->pb0->lastWrite = true;				}				if (myVarsPtr->pb0->pbInUse == false) {					myVarsPtr->pb0->pbInUse = true;					err = PBWriteAsync (&myVarsPtr->pb0->pb);				}				inParamPtr->bufferPtr = myVarsPtr->recBuffer1;				if (inParamPtr->error >= noErr) {					err = SPBRecord (inParamPtr, true);					if (err != noErr)						DebugStr("\pSPBRecord1 failed");				}			} else {				err = SoundConverterConvertBuffer (myVarsPtr->sc, myVarsPtr->recBuffer1, myVarsPtr->inputFrames, myVarsPtr->resampledBuf1, &outputFrames, &outputBytes);				myVarsPtr->pb1->pb.ioParam.ioBuffer = myVarsPtr->resampledBuf1;				myVarsPtr->pb1->pb.ioParam.ioReqCount = outputBytes;				myVarsPtr->pb1->pb.ioParam.ioPosOffset = myVarsPtr->totalBytes + myVarsPtr->initialOffset;				myVarsPtr->totalBytes += outputBytes;				if (inParamPtr->error == abortErr) {					myVarsPtr->pb1->lastWrite = true;				}				if (myVarsPtr->pb1->pbInUse == false) {					myVarsPtr->pb1->pbInUse = true;					err = PBWriteAsync (&myVarsPtr->pb1->pb);				}				inParamPtr->bufferPtr = myVarsPtr->recBuffer0;				if (inParamPtr->error >= noErr) {					err = SPBRecord (inParamPtr, true);					if (err != noErr)						DebugStr("\pSPBRecord2 failed");				}			}		}	} else {		// There was an error from PBWrite, return the error		if (myVarsPtr->pb0->pb.ioParam.ioResult != noErr) {			err = myVarsPtr->pb0->pb.ioParam.ioResult;		} else {			err = myVarsPtr->pb1->pb.ioParam.ioResult;		}	}	myVarsPtr->theErr = err;	if (myVarsPtr->theErr != noErr) {		DebugStr("\pwe got an error");	}	#if !GENERATINGCFM		oldA5 = SetA5 (oldA5);	#endif	return;}/*	These routines are here just for error checking in this example,	you may wish to update a status record or something similar.	What do you do if you get a write error during async recording?	For this example we will simply terminate the recording process,	you should probably display an error.  Since the myParamBlockRec	doesn't contain the sound input device number we will check for	an error in the record completion routine and not start a new	recording if there was an error.  You can call SPBStopRecording	at interrupt time, but that isn't needed in this example.	These routines display the error, but the record completion	routine checks the parameter blocks to make sure there was no	error before continuing the recording.*/#if GENERATINGCFMpascal void MyPB0WriteComp (myRecordingParmBlkPtr passedPB)#else pascal void MyPB0WriteComp (myRecordingParmBlkPtr passedPB:__a0)#endif{	#if !GENERATINGCFM		long		oldA5;		oldA5 = SetA5 (passedPB->myA5);	#endif	if (passedPB->pb.ioParam.ioResult < noErr) {		DebugStr("\pPBWrite0 failed!");	}	passedPB->pbInUse = false;	if (passedPB->lastWrite == true) {		lastBufferWritten = true;	}	#if !GENERATINGCFM		oldA5 = SetA5 (oldA5);	#endif}#if GENERATINGCFMpascal void MyPB1WriteComp (myRecordingParmBlkPtr passedPB)#else pascal void MyPB1WriteComp (myRecordingParmBlkPtr passedPB:__a0)#endif{	#if !GENERATINGCFM		long		oldA5;		oldA5 = SetA5 (passedPB->myA5);	#endif	if (passedPB->pb.ioParam.ioResult < noErr) {		DebugStr("\pPBWrite1 failed!");	}	passedPB->pbInUse = false;	if (passedPB->lastWrite == true) {		lastBufferWritten = true;	}	#if !GENERATINGCFM		oldA5 = SetA5 (oldA5);	#endif}