<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>QTAudioContextInsert - /ACInsertProcessor.mm</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/QuickTime/index.html">QuickTime</a> &gt; <a href="../../samplecode/QuickTime/idxMusicAudio-date.html">Audio</a> &gt; <A HREF="javascript:location.replace('index.html');">QTAudioContextInsert</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->


	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">QTAudioContextInsert</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/ACInsertProcessor.mm</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/ACInsertManager.h</option>
<option value="listing2.html">/ACInsertManager.mm</option>
<option value="listing3.html">/ACInsertProcessor.h</option>
<option value="listing4.html">/ACInsertProcessor.mm</option>
<option value="listing5.html">/ACInsertWindowController.h</option>
<option value="listing6.html">/ACInsertWindowController.mm</option>
<option value="listing7.html">/AudioExtractionWindowController.h</option>
<option value="listing8.html">/AudioExtractionWindowController.mm</option>
<option value="listing9.html">/AudioPropertiesInspectorController.h</option>
<option value="listing10.html">/AudioPropertiesInspectorController.mm</option>
<option value="listing11.html">/CoreAudioPlayback.c</option>
<option value="listing12.html">/CoreAudioPlayback.h</option>
<option value="listing13.html">/CustomDataTypes.h</option>
<option value="listing14.html">/CustomDataTypes.mm</option>
<option value="listing15.html">/CustomTableColumns.h</option>
<option value="listing16.html">/CustomTableColumns.mm</option>
<option value="listing17.html">/English.lproj/ACInsertWindow.nib/_ACInsertWindow_EOArchive_English.java</option>
<option value="listing18.html">/English.lproj/AudioExtractionWindow.nib/_AudioExtractionWindow_EOArchive_English.java</option>
<option value="listing19.html">/English.lproj/AudioPropertiesWindow.nib/_AudioProperties_EOArchive_English.java</option>
<option value="listing20.html">/English.lproj/MainMenu.nib/_MainMenu_EOArchive_English.java</option>
<option value="listing21.html">/MovieDocument.h</option>
<option value="listing22.html">/MovieDocument.mm</option>
<option value="listing23.html">/MovieWindowController.h</option>
<option value="listing24.html">/MovieWindowController.mm</option>
<option value="listing25.html">/QTACInsertApp_main.mm</option>
<option value="listing26.html">/QTACInsertAppDelegate.h</option>
<option value="listing27.html">/QTACInsertAppDelegate.mm</option>
<option value="listing28.html">/QuickTimeAudioUtils.c</option>
<option value="listing29.html">/QuickTimeAudioUtils.h</option>
<option value="listing30.html">/README.txt</option></select>
				</p>
				</form>
				<p><strong><a href="QTAudioContextInsert.zip">Download Sample</a></strong> (&#147;QTAudioContextInsert.zip&#148;, 305.7K)<BR>
<strong><a href="QTAudioContextInsert.dmg">Download Sample</a></strong> (&#147;QTAudioContextInsert.dmg&#148;, 344.2K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*
    File:        ACInsertProcessor.h    

    Abstract:    This file implements the Audio Context Insert processor 
                object which does the actual processing for the insert. It
                is a wrapper around an Audio Unit, and implements the
                insert reset and process data callbacks.
                    
    Version:    1.0

    Disclaimer: IMPORTANT:  This Apple software is supplied to you by Apple
    Computer, Inc. (&quot;Apple&quot;) in consideration of your agreement to the
    following terms, and your use, installation, modification or
    redistribution of this Apple software constitutes acceptance of these
    terms.  If you do not agree with these terms, please do not use,
    install, modify or redistribute this Apple software.

    In consideration of your agreement to abide by the following terms, and
    subject to these terms, Apple grants you a personal, non-exclusive
    license, under Apple's copyrights in this original Apple software (the
    &quot;Apple Software&quot;), to use, reproduce, modify and redistribute the Apple
    Software, with or without modifications, in source and/or binary forms;
    provided that if you redistribute the Apple Software in its entirety and
    without modifications, you must retain this notice and the following
    text and disclaimers in all such redistributions of the Apple Software. 
    Neither the name, trademarks, service marks or logos of Apple Computer,
    Inc. may be used to endorse or promote products derived from the Apple
    Software without specific prior written permission from Apple.  Except
    as expressly stated in this notice, no other rights or licenses, express
    or implied, are granted by Apple herein, including but not limited to
    any patent rights that may be infringed by your derivative works or by
    other works in which the Apple Software may be incorporated.

    The Apple Software is provided by Apple on an &quot;AS IS&quot; basis.  APPLE
    MAKES NO WARRANTIES, EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION
    THE IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY AND FITNESS
    FOR A PARTICULAR PURPOSE, REGARDING THE APPLE SOFTWARE OR ITS USE AND
    OPERATION ALONE OR IN COMBINATION WITH YOUR PRODUCTS.

    IN NO EVENT SHALL APPLE BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL
    OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
    SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
    INTERRUPTION) ARISING IN ANY WAY OUT OF THE USE, REPRODUCTION,
    MODIFICATION AND/OR DISTRIBUTION OF THE APPLE SOFTWARE, HOWEVER CAUSED
    AND WHETHER UNDER THEORY OF CONTRACT, TORT (INCLUDING NEGLIGENCE),
    STRICT LIABILITY OR OTHERWISE, EVEN IF APPLE HAS BEEN ADVISED OF THE
    POSSIBILITY OF SUCH DAMAGE.

    Copyright &copy; 2006-2008 Apple Inc. All Rights Reserved.
*/

#import &quot;ACInsertProcessor.h&quot;

/*----------  Callbacks  -------------------------------------------------------------
*/
// AudioUnit Input Supplier Proc
static OSStatus audioUnitInputProc(void *inRefCon, 
                AudioUnitRenderActionFlags *ioActionFlags, 
                const AudioTimeStamp *inTimeStamp, 
                UInt32 inBusNumber, 
                UInt32 inNumberFrames, 
                AudioBufferList *ioData)
{
    ACInsertProcessor *myself = (ACInsertProcessor*)inRefCon;
    return ([myself myAudioUnitInputProc:ioActionFlags
                    timestamp:inTimeStamp
                    bus:inBusNumber
                    numFrames:inNumberFrames
                    buffer:ioData]);    
}


// Audio Context Insert Process data callback
static OSStatus insertProcessDataCallback (
        void                        *inUserData,
        AudioUnitRenderActionFlags  *ioRenderFlags,
        const AudioTimeStamp     *inTimeStamp,
        UInt32                   inNumberFrames,
        AudioBufferList          *inInputData,
        AudioBufferList             *outOutputData
)
{
    ACInsertProcessor *myself = (ACInsertProcessor*)inUserData;
    return ([myself myInsertProcessDataCallback:ioRenderFlags
                    timestamp:inTimeStamp
                    numFrames:inNumberFrames
                    inData:inInputData
                    outData:outOutputData]);
}


// Audio Context Insert Reset callback
static OSStatus insertResetCallback(
            void            *inUserData,
            Float64            inSampleRate,
            UInt32            inMaxFrames,
            Float64            *outLatency,
            Float64            *outTailTime
                                )
{
    ACInsertProcessor *myself = (ACInsertProcessor*)inUserData;
    return ([myself myInsertResetCallback:inSampleRate
                    maxFrames:inMaxFrames
                    outLatency:outLatency
                    outTailTime:outTailTime]);
}

// Audio Context Insert Finalize callback
// This callback is called by the Audio Context when it is being disposed (ie, the MovieAudioContext
// has been reset or the movie was disposed). No more calls for the insert registered with that Audio
// Context will be made. Here's our chance to dispose the Audio Context Processor instance that was
// created for the insert registered with this particular Audio Context.
static OSStatus insertFinalizeCallback(void    *inUserData)
{
    ACInsertProcessor *processor = (ACInsertProcessor *)inUserData;
    [processor release];    // de'allocs the processor, which closes the associated Audio Unit
    return noErr;
}

/*--------------------------------------------------------------------------------------
*/
@implementation ACInsertProcessor

- (id)initFromAUComponent:(Component)auComponent
{
    self = [super init];
    if (self) 
    {
        OpenAComponent(auComponent, &amp;mAudioUnit);
        NSAssert(mAudioUnit != nil, @&quot;initFromAUComponent: Unable to open AU&quot;);    
        [self setAURenderCallback];
        mMovieDocument = [[NSDocumentController sharedDocumentController] currentDocument];
        mProcessorIsInitialized = false;
        mMaxFrames = 0;
        mPullBuffer = NULL;
        mIsBypassed = false;
        mLatency = 0.;
        mTailTime = 0.;
    
    }
    return self;
}

- (void) dealloc 
{
    // Close Audio Unit
    if (mAudioUnit) 
    {
        AudioUnitUninitialize(mAudioUnit);
        CloseComponent(mAudioUnit);
    }
    [super dealloc];
}

#pragma mark
#pragma mark ---- Getters ----
- (AudioUnit)audioUnit
{
    return mAudioUnit;
}
- (Boolean)processorIsInitialized
{
    return mProcessorIsInitialized;
}
- (AudioChannelLayoutTag)inputLayoutTag
{
    return mInputChannelLayout.mChannelLayoutTag;
}

- (AudioChannelLayoutTag)outputLayoutTag
{
    return mOutputChannelLayout.mChannelLayoutTag;
}


#pragma mark
#pragma mark ---- Setters ----
// This method is called by the ACInsertManager when
// the bypass state of this insert needs to be changed.
// We change the bypass state of our Audio Unit to the
// new state
- (void) setAUBypassed:(UInt32)isBypassed
{
    OSStatus err = noErr;
    UInt32 bypass = isBypassed;
    
    err = AudioUnitSetProperty (mAudioUnit, 
                            kAudioUnitProperty_BypassEffect,
                            kAudioUnitScope_Global, 0,
                            &amp;bypass, sizeof(bypass));
    if (noErr == err) 
    {
        mIsBypassed = bypass;
    }
}

// This method is called by the ACInsertManager when the
// insert's input layout is changed. We update our 
// cached input layout.
- (void) setInputLayout:(AudioChannelLayoutTag)layoutTag
{
    
    memset(&amp;mInputChannelLayout, 0, sizeof(AudioChannelLayout));
    mInputChannelLayout.mChannelLayoutTag = layoutTag;
}

// This method is called by the ACInsertManager when the
// insert's output layout is changed. We update our 
// cached output layout and then set the format on our
// underlying Audio Unit.
- (void) setOutputLayout:(AudioChannelLayoutTag)layoutTag
{
    OSStatus err = noErr;
    
    memset(&amp;mOutputChannelLayout, 0, sizeof(AudioChannelLayout));
    mOutputChannelLayout.mChannelLayoutTag = layoutTag;

    // Once we have an output layout, we have all the information
    // needed to set the stream format and channel layout on our AU
    err = [self setAUFormatAndLayout];

}

// This method is called by the ACInsertManager in order to determine
// whether this insert is bypassable, and if it is, what the current 
// bypass state is. We answer these questions based on the bypass
// ability and state of our Audio Unit.
- (void) aUIsBypassable:(BOOL*)isBypassable currentBypassState:(UInt32*)bypassState
{
    OSStatus err = noErr;
    UInt32 ioDataSize = sizeof(UInt32);
    Boolean writable;

    err = AudioUnitGetPropertyInfo(mAudioUnit, 
                                kAudioUnitProperty_BypassEffect, 
                                kAudioUnitScope_Global, 0,
                                &amp;ioDataSize, &amp;writable);
    if (isBypassable != NULL) 
    {
        *isBypassable = (err ? NO : (writable ? YES : NO));
        if (*isBypassable &amp;&amp; (bypassState != NULL)) 
        {
            err = AudioUnitGetProperty (mAudioUnit,
                                         kAudioUnitProperty_BypassEffect, 
                                         kAudioUnitScope_Global, 0,
                                         bypassState, &amp;ioDataSize);
            if (err) 
            {
                *isBypassable = NO;
            }
            else 
            {
                mIsBypassed = *bypassState;
            }
        }
    }
}

// This following two methods are called by the ACInsertManager in order to determine
// whether a particular output layout / input layout combination is valid for the
// the insert. We answer this question based on our AU's layout restrictions.
- (BOOL) canDoOutputChannels:(int)outNumChannels
{
    UInt32 inNumChannels = AudioChannelLayoutTag_GetNumberOfChannels(mInputChannelLayout.mChannelLayoutTag);
    return ([self canDoInputChannels:inNumChannels outputChannels:outNumChannels]);
}

- (BOOL) canDoInputChannels:(int)inNumChannels outputChannels:(int)outNumChannels
{
    OSStatus err = noErr;
    AUChannelInfo *channelInfo = NULL;
    UInt32 numChanInfo = 0;
    // The default assumption of an audio effect unit
    Boolean* isWritable = 0;
    UInt32    dataSize = 0;
    // Find out if the unit has any channel restrictions
    err = AudioUnitGetPropertyInfo (mAudioUnit,
                                    kAudioUnitProperty_SupportedNumChannels,
                                    kAudioUnitScope_Global, 0,
                                    &amp;dataSize, isWritable); //don't care if this is writable
        
    // if this property is NOT implemented an FX unit
    // is expected to deal with same channel valance in and out
    if (err) 
    {
        if (inNumChannels == outNumChannels) 
        {
            return true;
        }
        else 
        {
            // assume the worst
            return false;
        }
    }
    
    // Allocate
    channelInfo = (AUChannelInfo *) calloc(1, dataSize);
    err = AudioUnitGetProperty(mAudioUnit,
                                    kAudioUnitProperty_SupportedNumChannels,
                                    kAudioUnitScope_Global, 0,
                                    channelInfo, &amp;dataSize);
    if (err) 
    { 
        return false; 
    }
    numChanInfo = (dataSize / sizeof (AUChannelInfo));

// we've the following cases (combinations) to test here:
/*
&gt;0        An explicit number of channels on either side
0        that side (generally input!) has no elements
-1        wild card:
-1,-1    any num channels as long as same channels on in and out
-1,-2    any num channels channels on in and out - special meaning
-2+     indicates total num channs AU can handle 
            - elements configurable to any num channels, 
            - element count in scope must be writable
*/

    // chan layout can contain -1 for either scope (ie. doesn't care)
    // when -1, the unit can handle any number of channels on that scope
    for (unsigned int i = 0; i &lt; numChanInfo; ++i)
    {
            //less than zero on both sides - check for special attributes
        if ((channelInfo[i].inChannels &lt; 0) &amp;&amp; (channelInfo[i].outChannels &lt; 0))
        {
                // unit can handle any number of channels in and out PROVIDED
                // they are the same number of channels
            if (channelInfo[i].inChannels == -1 &amp;&amp; channelInfo[i].outChannels == -1) 
            {
                if (outNumChannels == inNumChannels) 
                {
                    return true;
                }
            }
                // unit can handle any number of channels in and out
            else if ((channelInfo[i].inChannels == -1 &amp;&amp; channelInfo[i].outChannels == -2)
                    || (channelInfo[i].inChannels == -2 &amp;&amp; channelInfo[i].outChannels == -1)) 
            {
                return true;
            }
                // these are our total num channels matches
                // element count MUST be writable
            else 
            {
                bool outWrite = false; bool inWrite = false;
                outWrite = [self IsElementCountWritableForScope:kAudioUnitScope_Output];
                inWrite = [self IsElementCountWritableForScope:kAudioUnitScope_Input];
                if (inWrite &amp;&amp; outWrite) 
                {
                    if ((outNumChannels &lt;= abs(channelInfo[i].outChannels))
                        &amp;&amp; (inNumChannels &lt;= abs(channelInfo[i].inChannels))) 
                    {
                        return true;
                    }
                }
            }
        }
            
            // special meaning on input, specific num on output
        else if (channelInfo[i].inChannels &lt; 0) 
        {
            if (channelInfo[i].outChannels == outNumChannels) 
            {
                    // can do any in channels
                if (channelInfo[i].inChannels == -1) 
                {
                    return true;
                } 
                    // total chans on input
                else 
                {
                    bool inWrite = false;
                    inWrite = [self IsElementCountWritableForScope:kAudioUnitScope_Input];
                    if (inWrite &amp;&amp; (inNumChannels &lt;= abs(channelInfo[i].inChannels))) 
                    {
                        return true;
                    }
                }
            }
        }
        
            // special meaning on output, specific num on input
        else if (channelInfo[i].outChannels &lt; 0) 
        {
            if (channelInfo[i].inChannels == inNumChannels) 
            {
                    // can do any out channels
                if (channelInfo[i].outChannels == -1) 
                {
                    return true;
                } 
                    // total chans on output
                else 
                {
                    bool outWrite = false;
                    outWrite = [self IsElementCountWritableForScope:kAudioUnitScope_Output];
                    if (outWrite &amp;&amp; (outNumChannels &lt;= abs(channelInfo[i].outChannels))) 
                    {
                        return true;
                    }
                }
            }
        }

            // both chans in struct &gt;= 0 - thus has to explicitly match
        else if ((channelInfo[i].inChannels == inNumChannels) &amp;&amp; (channelInfo[i].outChannels == outNumChannels)) 
        {
            return true;
        } 
        
    }
    return false;
}

// This is a helper method called by the canDoInputChannels:: method
// to determine whether a particular element count is settable for 
// the given scope
- (BOOL) IsElementCountWritableForScope:(AudioUnitScope)scope
{
    OSStatus err = noErr;
    Boolean isWritable = false;
    UInt32 outDataSize = 0;
    err = AudioUnitGetPropertyInfo (mAudioUnit, kAudioUnitProperty_ElementCount, scope, 0, &amp;outDataSize, &amp;isWritable);
    if (err ) 
    {
        return NO;
    } 
    else
    {
        return ( isWritable ? true : false );
    }
}

// This method is called by the ACInsertManager when it is cloning processors
// This method sets the parameter values of the current (new) AU instance to those
// of the original AU instance
- (void) setAUParametersToThoseOfAU:(AudioUnit)auToClone
{
    OSStatus err = noErr;
    UInt32 size = 0;
    Boolean writable = false;
    AudioUnitParameterID *parameterArray = NULL;

    // Get parameter list
    err = AudioUnitGetPropertyInfo(auToClone,
                                kAudioUnitProperty_ParameterList,
                                kAudioUnitScope_Global, 0,
                                &amp;size, &amp;writable 
                                );
                                
    if (err == noErr &amp;&amp; size &gt; 0) 
    {
        parameterArray = (AudioUnitParameterID*)malloc(size);
        if (parameterArray) 
        {
            err = AudioUnitGetProperty(auToClone,
                                    kAudioUnitProperty_ParameterList,
                                    kAudioUnitScope_Global, 0,
                                    parameterArray, &amp;size);
            if (err == noErr)
            {
                // For each parameter in this list, get the value from the original
                // AU instance and set it on the current AU instance
                for (UInt32 paramNumber = 0; paramNumber &lt; size / sizeof (AudioUnitParameterID) ; paramNumber++)
                {
                    Float32 paramValue = 0.;
                    err = AudioUnitGetParameter(auToClone,
                                                parameterArray[paramNumber],
                                                kAudioUnitScope_Global, 0,
                                                &amp;paramValue
                                                );
                    if (err == noErr) 
                    {
                        err = AudioUnitSetParameter(mAudioUnit,
                                                parameterArray[paramNumber],
                                                kAudioUnitScope_Global, 0,
                                                paramValue, 0);
                        if (err) 
                        {
                            NSLog(@&quot;setAUParametersToThoseOfAU: Unable to set parameter %d, value %f&quot;, parameterArray[paramNumber], paramValue);
                        }
                    }                            
                }
            
            }
            free(parameterArray);
        }
    }    
}

#pragma mark
#pragma mark ---- AU Configuration ----
// This method is called whenever a new processor instance
// is created. It sets the input data supplier proc on the
// AU instance that it wraps around.
- (OSStatus)setAURenderCallback
{
    OSStatus err = noErr;
    AURenderCallbackStruct cb;
            
    // Set the render callback which
    // supplies input data to the AU
    cb.inputProc = audioUnitInputProc;
    cb.inputProcRefCon = (void*)self;
    err = AudioUnitSetProperty(
                            mAudioUnit,
                            kAudioUnitProperty_SetRenderCallback,
                            kAudioUnitScope_Global, 0,
                            &amp;cb, sizeof(cb) );
    if (err) 
    {
        NSLog(@&quot;setAURenderCallback: Unable to set render callback on AU (err=%ld)&quot;, err);
    }        
    return err;
}

/// This method is called once the insert's input and output layouts have been set
// It sets the input and output stream formats and channel layouts on the AU instance
// that it wraps around.
- (OSStatus)setAUFormatAndLayout
{
    OSStatus err = noErr;
    
    // The data that QuickTime will provide will always be non-interleaved, Float32, linear PCM
    // with a number of channels equal to the insert's input number of channels. QuickTime
    // will inform us of the sample rate of the data on the reset callback. Until then, assume a
    // default value of 44100 Hz. 
    mPlaybackSampleRate = 44100.0;
    mInputASBD.mSampleRate = mPlaybackSampleRate; 
    mInputASBD.mFormatID = kAudioFormatLinearPCM;
    mInputASBD.mFormatFlags = kAudioFormatFlagsNativeFloatPacked | kLinearPCMFormatFlagIsNonInterleaved;
    mInputASBD.mFramesPerPacket = 1;
    mInputASBD.mBytesPerFrame = sizeof( Float32 );  
    mInputASBD.mBytesPerPacket = mInputASBD.mBytesPerFrame;
    mInputASBD.mChannelsPerFrame = AudioChannelLayoutTag_GetNumberOfChannels(mInputChannelLayout.mChannelLayoutTag);
    mInputASBD.mBitsPerChannel = sizeof( Float32 ) * 8;
    
    memcpy(&amp;mOutputASBD, &amp;mInputASBD, sizeof(AudioStreamBasicDescription));
    mOutputASBD.mChannelsPerFrame = AudioChannelLayoutTag_GetNumberOfChannels(mOutputChannelLayout.mChannelLayoutTag);    
    
    // [1] Uninitialize the Audio Unit
    err = AudioUnitUninitialize(mAudioUnit);
    if (err) 
    {
        NSLog(@&quot;setAUFormatAndLayout: Unable to uninitialize AU (err=%ld)&quot;, err);
        goto bail;
    }
    
    // [2.1] Set input stream format
    err = AudioUnitSetProperty(
            mAudioUnit,
            kAudioUnitProperty_StreamFormat,
            kAudioUnitScope_Input,
            0, &amp;mInputASBD, sizeof(mInputASBD));
            
    if (err) 
    {
        NSLog(@&quot;setAUFormatAndLayout: Unable to set input stream format (err=%ld)&quot;, err);
    }
    // [2.2] Set input channel layout
    if (err == noErr) 
    {
        UInt32 dataSizeDontCare;
        Boolean isWritable = false;
        
        err = AudioUnitGetPropertyInfo(
            mAudioUnit,
            kAudioUnitProperty_AudioChannelLayout,
            kAudioUnitScope_Input, 0,
            &amp;dataSizeDontCare, &amp;isWritable
        );
        if (err || isWritable == false)
        {
            // Not the end of the world if this AU doesn't
            // support setting of channel layouts.
            err = noErr;
        } 
        else 
        {
            err = AudioUnitSetProperty(
                mAudioUnit,
                kAudioUnitProperty_AudioChannelLayout,
                kAudioUnitScope_Input,
                0, &amp;mInputChannelLayout, sizeof(AudioChannelLayout));
            if (err) 
            {
                NSLog(@&quot;setAUFormatAndLayout: Unable to set input layout (err=%ld)&quot;, err);
            }    
        }
    }    
        
    // [3.1] Set output stream format     
    err = AudioUnitSetProperty(
            mAudioUnit,
            kAudioUnitProperty_StreamFormat, 
            kAudioUnitScope_Output,
            0, &amp;mOutputASBD, sizeof(mOutputASBD));
    if (err) 
    {
        NSLog(@&quot;setAUFormatAndLayout: Unable to set output stream format (err=%ld)&quot;, err);
    }
    // [3.2] Set output channel layout
    if (err == noErr) 
    {
        UInt32 dataSizeDontCare;
        Boolean isWritable = false;
        
        err = AudioUnitGetPropertyInfo(
            mAudioUnit,
            kAudioUnitProperty_AudioChannelLayout,
            kAudioUnitScope_Input, 0,
            &amp;dataSizeDontCare, &amp;isWritable
        );
        if (err || isWritable == false) 
        {
            // Not the end of the world if this AU doesn't
            // support setting of channel layouts.
            err = noErr;
        } 
        else 
        {
            err = AudioUnitSetProperty(
                mAudioUnit,
                kAudioUnitProperty_AudioChannelLayout,
                kAudioUnitScope_Output,
                0, &amp;mOutputChannelLayout, sizeof(AudioChannelLayout));
            if (err) 
            {
                NSLog(@&quot;setAUFormatAndLayout: Unable to set output layout (err=%ld)&quot;, err);
            }
        }        
    }
    
    // [4] Initialize the AU, we're ready to start running        
    err = AudioUnitInitialize(mAudioUnit);
    if (err) 
    {
        NSLog(@&quot;setAUFormatAndLayout: Unable to initialize AU (err=%ld)&quot;, err);
    }
    else
    {
        mProcessorIsInitialized = true;
    }
    
bail:    
    return err;
}

// This method is called by the ACInsertManger to get information about the insert's
// input and output layouts and the addresses of the reset and process data callbacks
// Fill in the necessary information here.
-(void) getRegistrationInformation:(QTAudioContextInsertRegistryInfo *)registryInfo
{
    registryInfo-&gt;userData = (void*)self;
    registryInfo-&gt;inputChannelLayoutSize = sizeof(mInputChannelLayout); 
    registryInfo-&gt;inputChannelLayout = &amp;mInputChannelLayout; 
    registryInfo-&gt;outputChannelLayoutSize = sizeof(mOutputChannelLayout); 
    registryInfo-&gt;outputChannelLayout = &amp;mOutputChannelLayout; 
    registryInfo-&gt;processDataCallback = insertProcessDataCallback;
    registryInfo-&gt;resetCallback = insertResetCallback;
    registryInfo-&gt;finalizeCallback = insertFinalizeCallback;
}

/*-------------------------------------------------------------------------------------------------------------------------------------------------------------
*/
#pragma mark
#pragma mark ---- Callbacks ----

// This is the input data supplier proc, called when the AU we 
// wrap around needs input data to process.
- (OSStatus)myAudioUnitInputProc:(AudioUnitRenderActionFlags *)ioActionFlags
                            timestamp:(const AudioTimeStamp *)inTimeStamp
                            bus:(UInt32)inBusNumber 
                            numFrames:(UInt32)inNumberFrames
                            buffer:(AudioBufferList *)ioData
{

#pragma unused (ioActionFlags, inTimeStamp, inBusNumber, inNumberFrames)

    OSStatus err = noErr;

    // Ensure that the buffer we're about to provide is compatible
    // with what the Audio Unit is expecting
    if (mPullBuffer &amp;&amp; (mPullBuffer-&gt;mNumberBuffers == ioData-&gt;mNumberBuffers))
    {            
        for (UInt32 i = 0; i &lt; ioData-&gt;mNumberBuffers; i++)
        {
            ioData-&gt;mBuffers[i].mData = mPullBuffer-&gt;mBuffers[i].mData;
            ioData-&gt;mBuffers[i].mDataByteSize = mPullBuffer-&gt;mBuffers[i].mDataByteSize;
        }
    } 
    else 
    {
        NSLog(@&quot;myAudioUnitInputProc: NULL input bufferlist or incompatible output bufferlist&quot;);
    }
    
    return err;    
}

// This is the process data callback called by the Audio Context for each buffer of audio it renders.
// The source data is provided to us in inInputData, we process the data using our AudioUnit and hand
// it back to the Audio Context in outOutputData.  
- (OSStatus)myInsertProcessDataCallback:(AudioUnitRenderActionFlags *)ioRenderFlags
                            timestamp:(const AudioTimeStamp *)inTimeStamp
                            numFrames:(UInt32)inNumberFrames
                            inData:(AudioBufferList *)inInputData
                            outData:(AudioBufferList *)outOutputData
{
    OSStatus err = noErr;
    
    // Store a pointer to the source data so our input
    // proc callback can hand it to the AU 
    mPullBuffer = (AudioBufferList*)inInputData;

    // Pull on our AU
    err = AudioUnitRender(mAudioUnit, ioRenderFlags, inTimeStamp, 0/*output bus*/, inNumberFrames, outOutputData) ;
    
    if (err) 
    {
        static BOOL printedErr = false;
        if (!printedErr) 
        {
            NSLog(@&quot;myInsertProcessDataCallback(%@) at %f: AudioUnitRender (err=%ld)&quot;, self, inTimeStamp-&gt;mSampleTime / mPlaybackSampleRate, err);
            printedErr = true;
        } 
    }
    
    return err;
}

// This is the reset callback called by the Audio Context to initialize for rendering and whenever there
// is an interruption in the render chain (eg. playback jumps to a new point or changes direction). We 
// should reset any state that we're maintaining. We are informed about the sample rate and the maximum 
// number of frames that we will be asked to process on any single process data callback. We get to report
// our processing latency and tail times.
- (OSStatus) myInsertResetCallback:(Float64)inSampleRate
                    maxFrames:(UInt32)inMaxFrames
                    outLatency:(Float64*)outLatency
                    outTailTime:(Float64*)outTailTime
{    
    OSStatus err = noErr;
    OSStatus tempErr = noErr;
    UInt32 size;

    if (mPlaybackSampleRate == inSampleRate &amp;&amp; mMaxFrames == inMaxFrames)
    {
        // Neither the sample rate nor max render frames have changed
        // Just reset the Audio Unit    
        err = AudioUnitReset(mAudioUnit, kAudioUnitScope_Global, 0);
        if (err) 
        {
            NSLog(@&quot;myInsertResetCallback(%@): Unable to reset AU (err=%ld)&quot;, self, err);
            goto bail;
        } 
    } 
    else 
    {
        // [1] Uninitialize the Audio Unit
        err = AudioUnitUninitialize(mAudioUnit);
        if (err) 
        {
            NSLog(@&quot;myInsertResetCallback(%@): Unable to uninitialize AU (err=%ld)&quot;, self, err);
            goto bail;
        }
        if (mPlaybackSampleRate != inSampleRate) 
        {
            // Playback samplerate has changed 
            // Set the new rate on the AU
            mPlaybackSampleRate = inSampleRate;
            mInputASBD.mSampleRate = mPlaybackSampleRate;
            err = AudioUnitSetProperty(
                    mAudioUnit,
                    kAudioUnitProperty_StreamFormat,
                    kAudioUnitScope_Input,
                    0, &amp;mInputASBD, sizeof(mInputASBD));
            if (err) 
            {
                NSLog(@&quot;myInsertResetCallback(%@): Unable to set input stream format on AU (err=%ld)&quot;, self, err);
            } 
            mOutputASBD.mSampleRate = mPlaybackSampleRate;
            err = AudioUnitSetProperty(
                    mAudioUnit,
                    kAudioUnitProperty_StreamFormat, 
                    kAudioUnitScope_Output,
                    0, &amp;mOutputASBD, sizeof(mOutputASBD));
                
            if (err) 
            {
                NSLog(@&quot;myInsertResetCallback(%@): Unable to set output stream format on AU (err=%ld)&quot;, self, err);
            }
            
        }
        // Max render frames have changed
        if (mMaxFrames != inMaxFrames) 
        {
            mMaxFrames = inMaxFrames;
            err = AudioUnitSetProperty(
                    mAudioUnit, 
                    kAudioUnitProperty_MaximumFramesPerSlice, 
                    kAudioUnitScope_Global,
                    0, &amp;mMaxFrames, sizeof(mMaxFrames));
            if (err) 
            {
                NSLog(@&quot;myInsertResetCallback(%@): Unable to set max render frames on AU (err=%ld)&quot;, self, err);
            } 
        }
        tempErr = AudioUnitInitialize(mAudioUnit);
        if (tempErr) 
        {
            NSLog(@&quot;myInsertResetCallback(%@): Unable to initialize AU&quot;);
            err = tempErr;
            goto bail;
        } 
    } 

    // Get the audio unit's latency
    mLatency = 0.;
    size = sizeof(mLatency);
    err = AudioUnitGetProperty (mAudioUnit, 
                                kAudioUnitProperty_Latency, 
                                kAudioUnitScope_Global, 0, 
                                &amp;mLatency, &amp;size);
    if (err) 
    {
        NSLog(@&quot;myInsertResetCallback(%@): Unable to get AU latency (err=%ld)&quot;, err);
    }
    
    // Get the audio unit's tailtime
    mTailTime = 0.;
    size = sizeof(mTailTime);
    err = AudioUnitGetProperty(mAudioUnit,
                               kAudioUnitProperty_TailTime,
                               kAudioUnitScope_Global,0,
                               &amp;mTailTime, &amp;size);
    if (err) 
    {
        NSLog(@&quot;myInsertResetCallback(%@): Unable to get AU tail time (err=%ld)&quot;, err);
    }
    
bail:
    if (noErr == err) 
    {
        if (outLatency) 
        {
            *outLatency = mLatency;
        }
        if (outTailTime)
        {
            *outTailTime = mTailTime;
        }    
    }
    return err;
}

@end</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/QTAudioContextInsert/listing4.html%3Fid%3DDTS10003981-1.3&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/QTAudioContextInsert/listing4.html%3Fid%3DDTS10003981-1.3&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/QTAudioContextInsert/listing4.html%3Fid%3DDTS10003981-1.3&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>