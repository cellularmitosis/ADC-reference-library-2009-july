<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>rollercoasterold - /Sources/Track.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxGraphicsImaging-date.html">Graphics & Imaging</a> &gt; <A HREF="javascript:location.replace('index.html');">rollercoasterold</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/GraphicsImaging/index.html" target="_blank">Reference Library > Graphics & Imaging</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">rollercoasterold</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/Sources/Track.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/Interfaces/Document.h</option>
<option value="listing2.html">/Interfaces/MacApplication.h</option>
<option value="listing3.html">/Interfaces/QD3DSupport.h</option>
<option value="listing4.html">/Interfaces/TextureMap.h</option>
<option value="listing5.html">/Interfaces/Track.h</option>
<option value="listing6.html">/Interfaces/Utils.h</option>
<option value="listing7.html">/Interfaces/Win32Application.h</option>
<option value="listing8.html">/Interfaces/WinPrefix.h</option>
<option value="listing9.html">/READ ME.txt</option>
<option value="listing10.html">/resource.h</option>
<option value="listing11.html">/Sources/MacApplication.c</option>
<option value="listing12.html">/Sources/QD3DSupport.c</option>
<option value="listing13.html">/Sources/TextureMap.c</option>
<option value="listing14.html">/Sources/Track.c</option>
<option value="listing15.html">/Sources/Utils.c</option>
<option value="listing16.html">/Sources/Win32Application.c</option></select>
				</p>
				</form>
				<p><strong><a href="rollercoasterold.zip">Download Sample</a></strong> (&#147;rollercoasterold.zip&#148;, 102.0K)<BR>
<strong><a href="rollercoasterold.dmg">Download Sample</a></strong> (&#147;rollercoasterold.dmg&#148;, 165.7K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*
  File:    Track.c
  
  Contains:  Contains code to create our rollercoaster track
  
  Written by:  Scott Kuechle, based on original Gerbils code by Brian Greenstone

  Copyright:  &copy; 1998 by Apple Computer, Inc. All rights reserved
  
  Change History (most recent first)
  
    &lt;2&gt;    9/28/98    rtm    made changes for Metrowerks compiler
    &lt;1&gt;    9/01/98    srk    first file


*/

/************************************************************
*                                                           *
*    INCLUDE FILES                                          *
*                                                           *
*************************************************************/

#include &quot;Track.h&quot;


/************************************************************
*                                                           *
*    FUNCTION PROTOTYPES                                    *
*                                                           *
*************************************************************/

static float Track_AmountToRotateNubs(TrackSectionType  *trackSectionList,
                  long       numTrackSections,
                  NubEntryType   *coordPtr,
                  long       numNubsInPart,
                  long       sectionNum,
                  float       *scale);
static void Track_PutCameraOnTrack(TQ3CameraObject   camera,
                NubEntryType     *splinePtArray,
                long         numSplinePoints,
                long         curTrackLocation);

#if TARGET_OS_WIN32

  HANDLE WinIO_CreateFile();
  BOOL WinIO_WriteToFile(HANDLE fileHndl, PartType *thisPart);

#endif


/************************************************************
*                                                           *
*    FUNCTION:  Track_MakeRandomTrack                       *
*                                                           *
*    PURPOSE:   Generates a random series of track sections *
*                                                           *
*************************************************************/


void Track_MakeRandomTrack(TrackSectionType  *trackSectionList,
              long      numTrackSections)
{
  long  i,r;
    
    for (i = 0; i &lt; numTrackSections; i++)
    {
      do
      {
        r = Utils_MyRandomLong() &amp; numTrackSections;
      } while(r==7);
      
      trackSectionList[i].partNum = i;  
      trackSectionList[i].nubCoord.y = 0;
      trackSectionList[i].nubCoord.x = sin(6.24F/numTrackSections*(float)i)*(LAZY_SUSAN_RADIUS - 6.0F);
      trackSectionList[i].nubCoord.z = cos(6.24F/numTrackSections*(float)i)*(LAZY_SUSAN_RADIUS - 6.0F);
    }
        
}

/************************************************************
*                                                           *
*    FUNCTION:  Track_CreateMasterNubList                   *
*                                                           *
*    PURPOSE:   creates a master list of spline nubs which  *
*               contains all of the nubs within all         *
*               sections of a track                         *
*                                                           *
*************************************************************/

void Track_CreateMasterNubList(TrackSectionType *trackSectionList,
                unsigned long    numTrackSections,
                PartType       *partsList,
                NubEntryType    *nubList,
                long        *nubTotal)
{
  unsigned long  sectionNum,partNum,i,numNubsInPart;
  NubEntryType  *coordPtr;
  TQ3Point3D  sectionStartCoords,basePt,upPt;
  float    rotation,scale;

    *nubTotal = 0;

    for (sectionNum=0; sectionNum &lt; numTrackSections; sectionNum++)
    {
      partNum = trackSectionList[sectionNum].partNum;  /* get part # to add */

            /* GET INFO FOR PART */
    
      sectionStartCoords = trackSectionList[sectionNum].nubCoord;  /* get coords where track section should start */
      numNubsInPart = partsList[partNum].numNubs;    /* get # nubs in part */
      coordPtr = partsList[partNum].coordsPtr;      /* get ptr to coord list */

      rotation = Track_AmountToRotateNubs(trackSectionList,
                        numTrackSections,
                        coordPtr,
                        numNubsInPart,
                        sectionNum,
                        &amp;scale);

          /* COPY &amp; ADJUST PART NUBS */
      
      for (i=1; i &lt; (numNubsInPart-1); i++)        /* skip nub 0 &amp; last nub */
      {

        basePt = coordPtr-&gt;basePt;            /* get coords from part data */
        upPt = coordPtr-&gt;upPt;
        
        Utils_RotatePoint(&amp;basePt,rotation);          /* rotate the points into position */
        Utils_RotatePoint(&amp;upPt,rotation);
        
        basePt.x *= scale;  basePt.y *= scale;  basePt.z *= scale;  /* scale it */
        upPt.x *= scale;  upPt.y *= scale;  upPt.z *= scale;
        
        nubList[*nubTotal].basePt.x = basePt.x + sectionStartCoords.x;  /* tag nubs to end of previous part */
        nubList[*nubTotal].basePt.y = basePt.y + sectionStartCoords.y;
        nubList[*nubTotal].basePt.z = basePt.z + sectionStartCoords.z;


        nubList[*nubTotal].upPt.x = upPt.x + sectionStartCoords.x;
        nubList[*nubTotal].upPt.y = upPt.y + sectionStartCoords.y;
        nubList[*nubTotal].upPt.z = upPt.z + sectionStartCoords.z;


        nubList[*nubTotal].sectionNum = sectionNum;      /* remember which section this belongs to */


        coordPtr++;
        (*nubTotal)++;
      }    
    }
    
      /* CREATE 3 FINAL NUBS WHICH WRAP BACK TO BEGINNING TO CLOSE THE LOOP */

    partNum = trackSectionList[0].partNum;                /* get part # */
    coordPtr = partsList[partNum].coordsPtr;              /* point back to beginning */
    sectionStartCoords = trackSectionList[0].nubCoord;          /* get coords where track section should start */
    numNubsInPart = partsList[partNum].numNubs;            /* get # nubs in part */

    rotation = Track_AmountToRotateNubs(trackSectionList,
                      numTrackSections,
                      coordPtr,
                      numNubsInPart,
                      0,
                      &amp;scale);

    for (i=0; i &lt; 3; i++)
    {
      basePt = coordPtr-&gt;basePt;            /* get coords from part data */
      upPt = coordPtr-&gt;upPt;

      Utils_RotatePoint(&amp;basePt,rotation);        /* rotate the points into position */
      Utils_RotatePoint(&amp;upPt,rotation);

      basePt.x *= scale;  basePt.y *= scale;  basePt.z *= scale;  /* scale it */
      upPt.x *= scale;  upPt.y *= scale;  upPt.z *= scale;
      
      nubList[*nubTotal].basePt.x = basePt.x + sectionStartCoords.x;  /* tag nubs to end of previous part */
      nubList[*nubTotal].basePt.y = basePt.y + sectionStartCoords.y;
      nubList[*nubTotal].basePt.z = basePt.z + sectionStartCoords.z;


      nubList[*nubTotal].upPt.x = upPt.x + sectionStartCoords.x;
      nubList[*nubTotal].upPt.y = upPt.y + sectionStartCoords.y;
      nubList[*nubTotal].upPt.z = upPt.z + sectionStartCoords.z;


      (*nubTotal)++;
      coordPtr++;
    }

}

/************************************************************
*                                                           *
*    FUNCTION:  Track_AmountToRotateNubs                    *
*                                                           *
*    PURPOSE:   Calculates the amount to rotate nubs on the *
*               y axis so that the track section will go    *
*               from point A to point B. It also returns a  *
*               scaling value used to scale the nub based   *
*               on the change in length.                    *
*                                                           *
*************************************************************/

static float Track_AmountToRotateNubs(TrackSectionType  *trackSectionList,
                    long       numTrackSections,
                    NubEntryType   *coordPtr,
                    long       numNubsInPart,
                    long       sectionNum,
                    float       *scale)
{
  TQ3Vector3D  startVec,endVec,originalVec,desiredVec;
  long  i;
  float  rotation,originalSize,desiredSize;
  TQ3Point3D  originalPt,desiredPt,zeroPt = {0,0,0};


          /* CALC ORIGINAL VECTOR */


    startVec.x = coordPtr[1].basePt.x;          /* use 2nd nub as start coord (remember that we skip the 1st nub in a part) */
    startVec.y = coordPtr[1].basePt.y;
    startVec.z = coordPtr[1].basePt.z;
    endVec.x = coordPtr[numNubsInPart-1].basePt.x;    /* use last nub as end coord of original data */
    endVec.y = coordPtr[numNubsInPart-1].basePt.y;  
    endVec.z = coordPtr[numNubsInPart-1].basePt.z;  
    Q3Vector3D_Subtract(&amp;endVec,&amp;startVec,&amp;originalVec); /* calc vector from start to end */

          /* CALC DESIRED VECTOR */

    i = sectionNum+1;
    if (i &gt;= numTrackSections)
    {
      i = 0;
    }
    startVec.x = trackSectionList[sectionNum].nubCoord.x;  /* get vector of where we want it to endup */
    startVec.y = trackSectionList[sectionNum].nubCoord.y;        
    startVec.z = trackSectionList[sectionNum].nubCoord.z;        
    endVec.x = trackSectionList[i].nubCoord.x;        /* get vector of where we want it to endup */
    endVec.y = trackSectionList[i].nubCoord.y;        
    endVec.z = trackSectionList[i].nubCoord.z;        
    Q3Vector3D_Subtract(&amp;endVec,&amp;startVec,&amp;desiredVec); /* calc vector from start to desired end */
    
          /* CALC ANGLE */

    rotation = Utils_AngleBetweenVectors(originalVec,desiredVec);  /* calc amount we need to rotate all nubs in part */
    if (desiredVec.z &gt; originalVec.z)          /* see if need to negate (since we only have absolute angle between vecs) */
    {
      rotation = -rotation;
    }

      /* CALC SCALING TO ADJUST FOR DISTANCE CHANGE */

    originalPt.x = originalVec.x;          /* calc size of original segment */
    originalPt.y = originalVec.y;
    originalPt.z = originalVec.z;
    originalSize = Q3Point3D_Distance(&amp;originalPt,&amp;zeroPt);
    
    desiredPt.x = desiredVec.x;            /* calc size of desired seg */
    desiredPt.y = desiredVec.y;
    desiredPt.z = desiredVec.z;
    desiredSize = Q3Point3D_Distance(&amp;desiredPt,&amp;zeroPt);
      
    *scale = desiredSize/originalSize;        /* return scaling value */
      
    return(rotation);
}


#if TARGET_OS_WIN32

/************************************************************
*                                                           *
*    FUNCTION:  Track_LoadPartsFromFile                     *
*                                                           *
*    PURPOSE:   Loads our pre-generated track parts         *
*               from a file                                 *
*                                                           *
*************************************************************/

void Track_LoadPartsFromFile(PartType *partsList, short *partCount)

{
  HANDLE    fileHndl;
  DWORD    err;
  char    partFilePath[MAX_PATH];


    err = Utils_Win32_BuildCurDirPath((Ptr)&amp;partFilePath, kPartDataFileName);
    fileHndl = CreateFile((char *)&amp;partFilePath, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_READONLY, NULL);
    if ((fileHndl == NULL) || (fileHndl == INVALID_HANDLE_VALUE))

    {

      Utils_DisplayFatalErrorMsg(&quot;Failure loading track part file TrackPartData.dat!&quot;);

    }

    else

    {
      Ptr    currentIndex;
      HLOCAL  localMem;
      DWORD  numBytesRead, fileSize;
      BOOL  successfull = FALSE;


        fileSize = GetFileSize(fileHndl, NULL);
        localMem = LocalAlloc(LMEM_FIXED, fileSize);
        if (localMem != NULL)
        {
          currentIndex = localMem;
          *partCount = 0;
          successfull = FALSE;


          do
          {
              /* get count of nubs for this part */

            successfull = ReadFile(fileHndl, &amp;partsList[*partCount].numNubs, sizeof(partsList-&gt;numNubs), &amp;numBytesRead, NULL);
            if ((successfull == TRUE) &amp;&amp; (numBytesRead != 0))
            {
              numBytesRead = 0;
              successfull = ReadFile(fileHndl, currentIndex, sizeof(NubEntryType) * partsList[*partCount].numNubs, &amp;numBytesRead, NULL);
              if ((successfull == TRUE) &amp;&amp; (numBytesRead != 0))
              {
                  /* SAVE PART RECORD */
                partsList[*partCount].coordsPtr = (NubEntryType *)currentIndex;
                  /* move pointer to point to memory for next part */
                currentIndex = currentIndex + sizeof(NubEntryType) * partsList[*partCount].numNubs;
                ++ (*partCount);
              }
              else
              {
                Utils_DisplayFatalErrorMsg(&quot;Error reading track part file TrackPartData.dat!&quot;);

              }
            }
          }
          while ((successfull == TRUE) &amp;&amp; (numBytesRead != 0));
        }
        else
        {
          Utils_DisplayFatalErrorMsg(&quot;Memory allocation failure!&quot;);

        }
    }
}


#endif




/************************************************************
*                                                           *
*    FUNCTION:  Track_LoadPartsFromRez                      *
*                                                           *
*    PURPOSE:   Loads our pre-generated track parts         *
*               from a resource file                        *
*                                                           *
*************************************************************/


#if TARGET_OS_MAC


void Track_LoadPartsFromRez(PartType *partsList, short *partCount)
{
OSErr    err;
short    i;
Handle    partHandle;
PartType  *thisPart;
Byte    numNubs;
Ptr      nubCoordsPtr;


  *partCount = 0;

    /* get count of part resources in our resource file */
  *partCount = Count1Resources(kPartType);
  err = ResError();
  if (err != noErr)
  {
    Utils_DisplayFatalErrorMsg(&quot;Error Getting Part Resource&quot;);
  }
  else
  {
    for (i = 1; i &lt;= *partCount; i++)
    {
        /* get next part resource in our file */
      partHandle = GetIndResource(kPartType,i);
      if (partHandle == nil)
      {
        Utils_DisplayFatalErrorMsg(&quot;Error Getting Part Resource&quot;);
      }
      else
      {
        DetachResource(partHandle);      /* give it to me */
        HLockHi(partHandle);

        thisPart = (PartType *)(*partHandle);

          /* get number of points in this part from the numNubs field of
            the PartType structure */
            
        numNubs = thisPart-&gt;numNubs;

          /* allocate enough NubEntryType structures to hold all of the points
            in this part */

        nubCoordsPtr = NewPtr(sizeof(NubEntryType) * numNubs);// alloc memory for nub coords
        if (nubCoordsPtr == nil)
        {
          Utils_DisplayFatalErrorMsg(&quot;Not enough memory to load Part&quot;);
        }
        else
        {
            /* copy NubEntryType data to our memory block */
          //BlockMove((Ptr)&amp;thisPart-&gt;coordsPtr,nubCoordsPtr,sizeof(NubEntryType) * numNubs);
          BlockMove((Ptr)thisPart + sizeof(thisPart-&gt;numNubs),nubCoordsPtr,sizeof(NubEntryType) * numNubs);
          DisposeHandle(partHandle);
          
            /* save part record as a PartType structure */
          partsList[i-1].numNubs = numNubs;
          partsList[i-1].coordsPtr = (NubEntryType *)nubCoordsPtr;

        }
      }
    }
  }
}


#endif


/************************************************************
*                                                           *
*    FUNCTION:  Track_PutCameraOnTrack                      *
*                                                           *
*    PURPOSE:   Calculates placement of the camera on the   *
*               track                                       *
*                                                           *
*                                                           *
*                                                           *
*************************************************************/

void Track_PutCameraOnTrack(TQ3CameraObject   camera,
              NubEntryType     *splinePtArray,
              long         numSplinePoints,
              long         curTrackLocation
              )
{
  TQ3Point3D      cameraFrom,cameraTo;
  TQ3Vector3D      cameraUp,cameraFromVect;
  long        desti;
  TQ3CameraPlacement  placement;
    
      
    if (numSplinePoints == 0)
      return;

            
          /* CALC UP VECTOR */
          
    Q3Point3D_Subtract(&amp;splinePtArray[curTrackLocation].upPt,    /* calc vector from base to up point */
              &amp;splinePtArray[curTrackLocation].basePt,
              &amp;cameraUp);
    Q3Vector3D_Normalize(&amp;cameraUp,&amp;cameraUp);
    

      /* USE UP VECTOR TO CALC &quot;FROM&quot; POSITION */
      
    Q3Vector3D_Scale(&amp;cameraUp,DISTANCE_FROM_TRACK_TO_CAMERA,&amp;cameraFromVect);  /* calc how far above track to put camera */
    cameraFrom.x = (splinePtArray[curTrackLocation].basePt.x +
             cameraFromVect.x);
    cameraFrom.y = (splinePtArray[curTrackLocation].basePt.y +
             cameraFromVect.y);
    cameraFrom.z = (splinePtArray[curTrackLocation].basePt.z +
             cameraFromVect.z);
    
          /* SET &quot;TO&quot; PT */
                    
    desti = curTrackLocation + kSkipAheadPoints;
    if (desti &gt;= (numSplinePoints-1))
    {
      desti -= numSplinePoints;    /* loop back around */
    }

    cameraTo = splinePtArray[desti].basePt;      /* look at base spline point in distance */
        
              
          /* UPDATE CAMERA PLACEMENT */
          
    placement.cameraLocation = cameraFrom;        /* set placement data */
    placement.pointOfInterest = cameraTo;
    placement.upVector = cameraUp;
    Q3Camera_SetPlacement(camera,&amp;placement);
  
}


/************************************************************
*                                                           *
*    FUNCTION:  Track_BuildCoasterGeometry_Mesh_Textured    *
*                                                           *
*    PURPOSE:   Build a textured track using mesh objects   *
*                                                           *
*                                                           *
*************************************************************/

void Track_BuildCoasterGeometry_Mesh(long       skipValue,
                  TQ3GroupObject   theGroup,
                  long       numSplinePoints,
                  NubEntryType   *splinePointsPtr)
{
TQ3GeometryObject  myMesh = NULL;
TQ3GroupPosition  myGroupPosition;
TQ3ColorRGB      whiteColor = {1,1,1};
long        i,faceCount,colorTick = 0;
float        x2,y2,z2;
TQ3Vector3D      tangentVector;  
TQ3MeshVertex    meshVertexList[4];
TQ3Vertex3D      vertexList[4],firstLeft,firstRight;
TQ3AttributeSet    generalAttribs = NULL,vAttrib[4] = {NULL, NULL, NULL, NULL};
TQ3MeshFace      face;
float        ambient = 0.8F;
float        spec = 0.0F;
TQ3Param2D      corner1 = {0,1};  /* uv's for texture mapping */
TQ3Param2D      corner2 = {1,1};
TQ3Param2D      corner3 = {1,0};
TQ3Param2D      corner4 = {0,0};

  

        /* CREATE NEW MESH OBJECT */
  
  myMesh = Q3Mesh_New();
  
  if( myMesh == NULL )
  {
    Utils_DisplayErrorMsg(&quot;Group_AddObject failed!&quot;);
    goto memoryError;
  }
                
  Q3Mesh_DelayUpdates(myMesh);


        /* SETUP GENERAL ATTRIBUTES */

  generalAttribs = Q3AttributeSet_New();  
  if( generalAttribs == NULL )
  {
    Utils_DisplayErrorMsg(&quot;Q3AttributeSet_New failed!&quot;);
    goto memoryError;
  }
  Q3AttributeSet_Add(generalAttribs, kQ3AttributeTypeAmbientCoefficient, &amp;ambient);
  Q3AttributeSet_Add(generalAttribs, kQ3AttributeTypeSpecularControl, &amp;spec);  


      /* CREATE UV ATTRIBUTES FOR THE VERTICES */

  vAttrib[0] = Q3AttributeSet_New();  
  if( vAttrib[0] == NULL )
  {
    Utils_DisplayErrorMsg(&quot;Q3AttributeSet_New failed!&quot;);
    goto memoryError;
  }
  Q3AttributeSet_Add(vAttrib[0], kQ3AttributeTypeShadingUV, &amp;corner1);  

  vAttrib[1] = Q3AttributeSet_New();  
  if( vAttrib[1] == NULL )
  {
    Utils_DisplayErrorMsg(&quot;Q3AttributeSet_New failed!&quot;);
    goto memoryError;
  }
  Q3AttributeSet_Add(vAttrib[1], kQ3AttributeTypeShadingUV, &amp;corner2);  

  vAttrib[2] = Q3AttributeSet_New();  
  if( vAttrib[2] == NULL )
  {
    Utils_DisplayErrorMsg(&quot;Q3AttributeSet_New failed!&quot;);
    goto memoryError;
  }
  Q3AttributeSet_Add(vAttrib[2], kQ3AttributeTypeShadingUV, &amp;corner3);  

  vAttrib[3] = Q3AttributeSet_New();  
  if( vAttrib[3] == NULL )
  {
    Utils_DisplayErrorMsg(&quot;Q3AttributeSet_New failed!&quot;);
    goto memoryError;
  }
  Q3AttributeSet_Add(vAttrib[3], kQ3AttributeTypeShadingUV, &amp;corner4);  


  vertexList[0].attributeSet = nil;
  vertexList[1].attributeSet = nil;
  vertexList[2].attributeSet = nil;
  vertexList[3].attributeSet = nil;

  faceCount = 0;


  for (i = 0; i &lt; (numSplinePoints - 1 - skipValue); i += skipValue)
  {    
        /* GET SPLINE POINTS */
        
    x2 = splinePointsPtr[i+skipValue].basePt.x;    /* get coords of end pt #2 (far point) */
    y2 = splinePointsPtr[i+skipValue].basePt.y;
    z2 = splinePointsPtr[i+skipValue].basePt.z;


        /* CALC TANGENT VECTOR */

    Q3Point3D_CrossProductTri(&amp;splinePointsPtr[i].basePt,
                &amp;splinePointsPtr[i+skipValue].basePt,
                &amp;splinePointsPtr[i].upPt,&amp;tangentVector);

    Q3Vector3D_Normalize(&amp;tangentVector,&amp;tangentVector);
    Q3Vector3D_Scale(&amp;tangentVector,kTrackWidth,&amp;tangentVector);


        /* CALC NEW &quot;UPPER&quot; COORDS OF FACE */

    Q3Point3D_Set(&amp;vertexList[0].point,      /* upper left */
            x2-tangentVector.x,
            y2-tangentVector.y,
            z2-tangentVector.z);

    Q3Point3D_Set(&amp;vertexList[1].point,      /* upper right */
            x2+tangentVector.x,
            y2+tangentVector.y,
            z2+tangentVector.z);


    meshVertexList[0] = Q3Mesh_VertexNew(myMesh, &amp;vertexList[0]);    /* get new vertex for &quot;upper/far&quot; */
    meshVertexList[1] = Q3Mesh_VertexNew(myMesh, &amp;vertexList[1]);


          /* FOR 1ST FACE, MUST RIG &quot;BOTTOM&quot; COORDS */
          
    if (i == 0)
    {
      Q3Point3D_Set(&amp;vertexList[2].point,      /* lower right */
              splinePointsPtr[0].basePt.x+tangentVector.x,
              splinePointsPtr[0].basePt.y+tangentVector.y,
              splinePointsPtr[0].basePt.z+tangentVector.z);

      Q3Point3D_Set(&amp;vertexList[3].point,      /* lower left */
              splinePointsPtr[0].basePt.x-tangentVector.x,
              splinePointsPtr[0].basePt.y-tangentVector.y,
              splinePointsPtr[0].basePt.z-tangentVector.z);

      firstRight.point = vertexList[2].point;      /* remember these coords for wrap-back later */
      firstLeft.point = vertexList[3].point;
      
      meshVertexList[2] = Q3Mesh_VertexNew(myMesh, &amp;vertexList[2]);  /* set vertex */
      meshVertexList[3] = Q3Mesh_VertexNew(myMesh, &amp;vertexList[3]);
    }

    
          /* CREATE FACE */
          
    face = Q3Mesh_FaceNew(myMesh,4,&amp;meshVertexList[0],generalAttribs);

    if( face == NULL )
    {
      Utils_DisplayErrorMsg(&quot;Q3AttributeSet_New failed!&quot;);
      goto memoryError;
    }

          /* APPLY UV COORD ATTRIBS */
          
    Q3Mesh_SetCornerAttributeSet(myMesh, meshVertexList[0], face, vAttrib[0]);
    Q3Mesh_SetCornerAttributeSet(myMesh, meshVertexList[1], face, vAttrib[1]);
    Q3Mesh_SetCornerAttributeSet(myMesh, meshVertexList[2], face, vAttrib[2]);
    Q3Mesh_SetCornerAttributeSet(myMesh, meshVertexList[3], face, vAttrib[3]);

    colorTick++;    
    faceCount++;
    
      /* SEE IF MESH OBJECT IS LARGE ENOUGH TO USE NOW */
    
    if (faceCount &gt; kMaxFacesInMesh)
    {
      Q3Mesh_ResumeUpdates(myMesh);

      myGroupPosition = Q3Group_AddObject(theGroup, myMesh);  /* add mesh to group */
      Q3Object_Dispose(myMesh);                  /* make another mesh object */
      if ( myGroupPosition == nil )
      {
        Utils_DisplayErrorMsg(&quot;Q3Group_AddObject failed!&quot;);
        goto memoryError;
      }
      
      myMesh = Q3Mesh_New();
      if ( myMesh == nil )
      {
        Utils_DisplayErrorMsg(&quot;Q3Mesh_New failed!&quot;);
        goto memoryError;
      }
      Q3Mesh_DelayUpdates(myMesh);
      meshVertexList[0] = Q3Mesh_VertexNew(myMesh, &amp;vertexList[0]);  /* reset these to the new mesh */
      meshVertexList[1] = Q3Mesh_VertexNew(myMesh, &amp;vertexList[1]);
      
      faceCount = 0;    
    }  
  
        /* UPPERS WILL BE LOWERS ON NEXT POLY */
  
    vertexList[2] = vertexList[1];        /* this is so next poly's bottom will match last poly's top */
    vertexList[3] = vertexList[0];
    meshVertexList[2] = meshVertexList[1];
    meshVertexList[3] = meshVertexList[0];    

    if (colorTick &amp; 1)
    {
      vertexList[0].attributeSet = vAttrib[0];      /* apply uv attribs to the vertices */
      vertexList[1].attributeSet = vAttrib[1];
      vertexList[2].attributeSet = vAttrib[2];
      vertexList[3].attributeSet = vAttrib[3];
    }
    else
    {
      vertexList[0].attributeSet = vAttrib[3];      /* apply uv attribs to the vertices */
      vertexList[1].attributeSet = vAttrib[2];
      vertexList[2].attributeSet = vAttrib[1];
      vertexList[3].attributeSet = vAttrib[0];
    }
  }

        /* CREATE 1 FINAL FACE TO LINK BACK TO BEGINNING */

  vertexList[0].point = firstLeft.point;
  vertexList[1].point = firstRight.point;
  meshVertexList[0] = Q3Mesh_VertexNew(myMesh, &amp;vertexList[0]);    /* create vertex based on 1st */
  meshVertexList[1] = Q3Mesh_VertexNew(myMesh, &amp;vertexList[1]);
  
  if (faceCount &amp; 1)
  {
    face = Q3Mesh_FaceNew(myMesh,4,&amp;meshVertexList[0],nil);
  }
  else
  {
    face = Q3Mesh_FaceNew(myMesh,4,&amp;meshVertexList[0],nil);
  }
  faceCount++;

          /* APPLY ANY REMAINING MESH */
          
  Q3Mesh_ResumeUpdates(myMesh);

  if (faceCount &gt; 0)
  {
    myGroupPosition = Q3Group_AddObject(theGroup, myMesh);
    if ( myGroupPosition == nil )
    {
      Utils_DisplayErrorMsg(&quot;Q3Group_AddObject failed!&quot;);
      goto memoryError;
    }
  }

  Q3Object_Dispose(myMesh);              /* kill mesh object */
  Q3Object_Dispose(generalAttribs);  
  Q3Object_Dispose(vAttrib[0]);  
  Q3Object_Dispose(vAttrib[1]);  
  Q3Object_Dispose(vAttrib[2]);  
  Q3Object_Dispose(vAttrib[3]);
  
  return;
  
memoryError:
  if( myMesh )
  {
    Q3Object_Dispose(myMesh);
  }

  if( generalAttribs )
  {
    Q3Object_Dispose(generalAttribs);
  }

  if( vAttrib[0] )
  {
    Q3Object_Dispose(vAttrib[0]);
  }

  if( vAttrib[1] )
  {
    Q3Object_Dispose(vAttrib[1]);
  }

  if( vAttrib[2] )
  {
    Q3Object_Dispose(vAttrib[2]);
  }

  if( vAttrib[3] )
  {
    Q3Object_Dispose(vAttrib[3]);
  }
  
}


/************************************************************
*                                                           *
*    FUNCTION:  Track_CalcSplineCurve                       *
*                                                           *
*    PURPOSE:   Use our control points to construct a       *
*               spline curve for each section of the        *
*               track                                       *
*                                                           *
*                                                           *
*************************************************************/

void Track_CalcSplineCurve(NubEntryType   **splinePoints,
              long      maxSplinePoints,
              NubEntryType  *nubPoints,
              long      numSplineNubs,
              long      *numSplinePoints,
              float       subDivFactor)
{
  float    t,tSquared,tCubed,a,b,c,d,incVal;
  long    subCount,nubNum,numNubs,numSubDivs;
  TQ3Point3D  highestPoint = {0,0,0};

        /* ALLOC MEMORY FOR SPLINE DATA */

    *splinePoints = (NubEntryType *)NewPtr( sizeof(NubEntryType) * maxSplinePoints );
    if (*splinePoints == nil)
    {
      Utils_DisplayFatalErrorMsg(&quot;Sorry, but there doesnt seem to be enough memory to allocate the track spline curve&quot;);
    }
    else
    {

      numNubs = numSplineNubs;  /* # nubs */
      *numSplinePoints = 0;    /* # points generated */
      
            /* SCAN THRU NUBS */

        /* Note: skips 1st &amp; last nubs (sorta) */
      for (nubNum=1; nubNum &lt; (numNubs-2); nubNum++)
      {        
        numSubDivs = Q3Point3D_Distance(&amp;nubPoints[nubNum].basePt,
                        &amp;nubPoints[nubNum+1].basePt)*subDivFactor + 0.5F;  /* # segments between next nubs */
        if (numSubDivs &lt; 1)
          numSubDivs = 1;
        
        incVal = 1.0F/numSubDivs;        /* increment value */

        for (t=0, subCount=0; subCount &lt; numSubDivs; t+=incVal,subCount++)
        {
          tSquared = t*t;
          tCubed = tSquared*t;
          a = (-0.166F * tCubed)+(0.5F * tSquared)-(0.5F * t) + 0.166F;
          b = (0.5F * tCubed) - tSquared + 0.666F;
          c = (-0.5F * tCubed) + (0.5F * tSquared) + (0.5F * t + 0.166F);
          d = 0.166F * tCubed;

          if (*numSplinePoints &lt; maxSplinePoints)
          {  
                    /* CALC SEG OF BASE */
                    
            (*splinePoints)[*numSplinePoints].basePt.x =
                      (a * nubPoints[nubNum-1].basePt.x) +
                      (b * nubPoints[nubNum].basePt.x) +
                      (c * nubPoints[nubNum+1].basePt.x) +
                      (d * nubPoints[nubNum+2].basePt.x);
                    
            (*splinePoints)[*numSplinePoints].basePt.y =
                      (a * nubPoints[nubNum-1].basePt.y) + 
                      (b * nubPoints[nubNum].basePt.y) +
                      (c * nubPoints[nubNum+1].basePt.y) +
                      (d * nubPoints[nubNum+2].basePt.y);

            (*splinePoints)[*numSplinePoints].basePt.z =
                      (a * nubPoints[nubNum-1].basePt.z) +
                      (b * nubPoints[nubNum].basePt.z) +
                      (c * nubPoints[nubNum+1].basePt.z) +
                      (d * nubPoints[nubNum+2].basePt.z);

                    /* CALC SEG OF UP */
                    
            (*splinePoints)[*numSplinePoints].upPt.x =
                      (a * nubPoints[nubNum-1].upPt.x) +
                      (b * nubPoints[nubNum].upPt.x) +
                      (c * nubPoints[nubNum+1].upPt.x) +
                      (d * nubPoints[nubNum+2].upPt.x);
                    
            (*splinePoints)[*numSplinePoints].upPt.y =
                      (a * nubPoints[nubNum-1].upPt.y) + 
                      (b * nubPoints[nubNum].upPt.y) +
                      (c * nubPoints[nubNum+1].upPt.y) +
                      (d * nubPoints[nubNum+2].upPt.y);

            (*splinePoints)[*numSplinePoints].upPt.z =
                      (a * nubPoints[nubNum-1].upPt.z) +
                      (b * nubPoints[nubNum].upPt.z) +
                      (c * nubPoints[nubNum+1].upPt.z) +
                      (d * nubPoints[nubNum+2].upPt.z);

                    /* REMEMBER WHAT TYPE IT IS */
                    
            (*splinePoints)[*numSplinePoints].sectionNum = nubPoints[nubNum].sectionNum;

            (*numSplinePoints)++;
          }
          else
          {
            Utils_DisplayFatalErrorMsg(&quot;Too many spline points!  Overflowed array!&quot;);
          }
        }
      }
    }
}

/************************************************************
*                                                           *
*    FUNCTION:  Track_MoveCamera                            *
*                                                           *
*    PURPOSE:   Move the camera to the next location on the *
*               track                                       *
*                                                           *
*                                                           *
*************************************************************/

void Track_MoveCamera(TQ3CameraObject   camera,
          NubEntryType     *splinePtArray,
          long         numSplinePoints,
          long         *curTrackLocation)
{
  Track_PutCameraOnTrack(camera,
              splinePtArray,
              numSplinePoints,
              *curTrackLocation);
    /* have we reached the end of the track? */
  if ( ((*curTrackLocation) + 1) &gt;= numSplinePoints)
  {
      /* end-of-track, so wrap back to the beginning */
    (*curTrackLocation) = 0;
  }
  else
  {
      /* move to next location on track */
    ++(*curTrackLocation);
  }

}


/************************************************************
*                                                           *
*    FUNCTION:  Track_GetForwardVector                      *
*                                                           *
*    PURPOSE:   Returns the vector representing forward at  *
*               trackIndex                                  *
*                                                           *
*                                                           *
*************************************************************/

void Track_GetForwardVector(long trackIndex, NubEntryType *splinePointsPtr, long numSplinePoints, TQ3Vector3D *theVector)
{
TQ3Vector3D  forward;

  if ((trackIndex+1) == numSplinePoints)          /* see if +1 will wrap it */
    Q3Point3D_Subtract(&amp;splinePointsPtr[0].basePt,    /* calc vector from here to one in front */
            &amp;splinePointsPtr[trackIndex].basePt,
            &amp;forward);
  else
    Q3Point3D_Subtract(&amp;splinePointsPtr[trackIndex+1].basePt,    /* calc vector from here to one in front */
            &amp;splinePointsPtr[trackIndex].basePt,
            &amp;forward);
  Q3Vector3D_Normalize(&amp;forward,theVector);          /* normalize &amp; return it */
}


/************************************************************
*                                                           *
*    FUNCTION:  Track_GetNormalVector                       *
*                                                           *
*    PURPOSE:   Returns the vector to the normal of the     *
*               surface of the track at trackIndex          *
*                                                           *
*                                                           *
*************************************************************/

void Track_GetNormalVector(NubEntryType *splinePointsPtr, long trackIndex, TQ3Vector3D *theVector)
{
TQ3Vector3D  cameraUp;

  Q3Point3D_Subtract(&amp;splinePointsPtr[trackIndex].upPt,    /* calc vector from base to up point */
            &amp;splinePointsPtr[trackIndex].basePt,
            &amp;cameraUp);
  Q3Vector3D_Normalize(&amp;cameraUp,theVector);          /* normalize &amp; return it */
}

</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/rollercoasterold/listing14.html%3Fid%3DDTS10000135-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/rollercoasterold/listing14.html%3Fid%3DDTS10000135-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/rollercoasterold/listing14.html%3Fid%3DDTS10000135-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>