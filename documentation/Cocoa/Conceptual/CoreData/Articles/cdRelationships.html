<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>Core Data Programming Guide: Relationships and Fetched Properties</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Relationships and Fetched Properties"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP40001857" title="Relationships and Fetched Properties"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../index.html#//apple_ref/doc/uid/TP30000440-TP30000416" target="_top">Cocoa</a> &gt; <a href="../../../DesignGuidelines-date.html#//apple_ref/doc/uid/TP30000440-TP30000416-TP30000556" target="_top">Design Guidelines</a> &gt; <a href="../index.html" target="_top">Core Data Programming Guide</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="cdMemory.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="cdNSAttributes.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>
        
        
        <a name="//apple_ref/doc/uid/TP40001857-CJBDBHCB" title="Relationships and Fetched Properties"></a><hr /><H1>Relationships and Fetched Properties</H1><p>There are a number of things you have to decide when you create a relationship. What is the destination entity? Is it a to-one or a to-many? Is it optional? If it’s a to-many, are there maximum or minimum numbers of objects that can be in the relationship? What should happen when the source object is deleted? You can provide answers to all these in the model. One of the particularly interesting cases is a many-to-many relationship; there are two ways to model these, and which one you choose will depend on the semantics of your schema.</p><p>When you modify an object graph, it is important to maintain referential integrity. Core Data makes it easy for you to alter relationships between managed objects without causing referential integrity errors. Much of this behavior derives from the relationship descriptions specified in the managed object model.</p><p>Core Data does not let you create relationships that cross stores. If you need to create a relationship from objects in one store to objects in another, you should consider using fetched properties.</p>
<!-- This template is being used for both PDF and HTML. -->

    
    <!-- TopicBook.pm uses this template for its miniTOCs, but needs a different title. -->
    <h4>Contents:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="cdRelationships.html#//apple_ref/doc/uid/TP40001857-185436-TPXREF147">Relationship Definitions in the Model</a>
				
			<br/>
			
        
			
			
				<a href="cdRelationships.html#//apple_ref/doc/uid/TP40001857-SW3">Manipulating Relationships and Object Graph Integrity</a>
				
			<br/>
			
        
			
			
				<a href="cdRelationships.html#//apple_ref/doc/uid/TP40001857-SW10">Many-to-Many Relationships</a>
				
			<br/>
			
        
			
			
				<a href="cdRelationships.html#//apple_ref/doc/uid/TP40001857-SW6">Unidirectional Relationships</a>
				
			<br/>
			
        
			
			
				<a href="cdRelationships.html#//apple_ref/doc/uid/TP40001857-SW5">Cross-Store Relationships</a>
				
			<br/>
			
        
			
			
				<a href="cdRelationships.html#//apple_ref/doc/uid/TP40001857-SW7">Fetched Properties</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP40001857-185436" title="Relationship Definitions in the Model"></a><a name="//apple_ref/doc/uid/TP40001857-185436-TPXREF147" title="Relationship Definitions in the Model"></a><h2>Relationship Definitions in the Model</h2><p>Creating a relationship in a managed object model is straightforward, but there are a number of aspects of a relationship that you need to specify properly. The most immediately obvious features are the relationship's name, the destination entity, and the <strong>cardinality</strong> (is it a to-one relationship, or a to-many relationship). The most important features with respect to object graph integrity, however, are the inverse relationship and the delete rule. The validity of the graph is affected by the settings for optionality and for maximum and minimum count.</p><a name="//apple_ref/doc/uid/TP40001857-SW2" title="Relationship Fundamentals"></a><h3>Relationship Fundamentals</h3><p>A relationship specifies the entity, or the parent entity, of the objects at the destination. This can be the same as the entity at the source (a <strong>reflexive</strong> relationship). Relationships do not have to be homogeneous. If the Employee entity has two sub-entities, say Manager and Flunky, then a given department's employees may be made up of Employees (assuming Employee is not an abstract entity), Managers, Flunkies, or any combination thereof.</p><p>You can specify a relationship as being to-one or to-many. To-one relationships are represented by a reference to the destination object. To-many relationships are represented by mutable sets (although fetched properties are represented by arrays). Implicitly, “to-one” and “to-many” typically refer to “one-to-one” and “one-to-many” relationships respectively. A many-to-many relationship is one where a relationship and its inverse are both to-many. These present some additional considerations, and are discussed in greater detail in <span class="content_text"><a href="cdRelationships.html#//apple_ref/doc/uid/TP40001857-SW10">“Many-to-Many Relationships.”</a></span> </p><p>You can also put upper and lower limits on the number of objects at the destination of a to-many relationship. The lower limit does not have to be zero. You can if you want specify that the number of employees in a department must lie between 3 and 40. You also specify a relationship as either optional or not optional. If a relationship is not optional, then in order to be valid there must be an object or objects at the destination of the relationship. </p><p>Cardinality and optionality are orthogonal properties of a relationship. You can specify that a relationship is optional, even if you have specified upper and/or lower bounds. This means that there do not have to be any objects at the destination, but if there are then the number of objects must lie within the bounds specified.</p><p>It is important to note that simply defining a relationship does not cause a destination object to be created when a new source object is created. In this respect, defining a relationship is akin to declaring an instance variable in a standard Objective-C class. Consider the following example.</p><div class="codesample"><table><tr><td scope="row"><pre>@interface Widget : NSObject<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    Sprocket *sprocket;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div>	<p>If you create an instance of Widget, an instance of Sprocket is not created unless you write code to cause it to happen (for example, by overriding the <code>init</code> method). Similarly, if you define an Address entity, and a non-optional to-one relationship from Employee to Address, then simply creating an instance of Employee does not create a new Address instance. Likewise, if you define a non-optional to-many relationship from Employee to Address with a minimum count of <code>1</code>, then simply creating an instance of Employee does not create a new Address instance. </p><a name="//apple_ref/doc/uid/TP40001857-SW4" title="Inverse Relationships"></a><h3>Inverse Relationships</h3><p>Most relationships are inherently bi-directional. If a Department has a to-many relationship to the Employees that work in a Department, there is an inverse relationship from an Employee to the Department. The major exception is a fetched property, which represents a weak one-way relationship—there is no relationship from the destination to the source (see <span class="content_text"><a href="cdRelationships.html#//apple_ref/doc/uid/TP40001857-SW7">“Fetched Properties”</a></span>).</p><p>You should typically model relationships in both directions, and specify the inverse relationships appropriately. Core Data uses this information to ensure the consistency of the object graph if a change is made (see <span class="content_text"><a href="cdRelationships.html#//apple_ref/doc/uid/TP40001857-SW3">“Manipulating Relationships and Object Graph Integrity”</a></span>). For a discussion of some of the reasons why you might want to not model a relationship in both directions, and some of the problems that might arise if you don’t, see <span class="content_text"><a href="cdRelationships.html#//apple_ref/doc/uid/TP40001857-SW6">“Unidirectional Relationships.”</a></span></p><a name="//apple_ref/doc/uid/TP40001857-SW1" title="Relationship Delete Rules"></a><h3>Relationship Delete Rules</h3><p>A relationship's delete rule specifies what should happen if an attempt is made to delete the source object. Note the phrasing in the previous sentence—"if an attempt is made…". If a relationship's delete rule is set to Deny, it is possible that the source object will not be deleted. Consider again a department's employees relationship, and the effect that the different delete rules have.</p><dl class="termdef">	<dl class="content_text"><b>Deny</b><dd><p>If there is at least one object at the relationship destination, then the source object cannot be deleted.</p><p>For example, if you want to remove a department, you must ensure that all the employees in that department are first transferred elsewhere (or fired!) otherwise the department cannot be deleted.</p></dd></dl><dl class="content_text"><b>Nullify</b><dd><p>Set the inverse relationship for objects at the destination to null.</p><p>For example, if you delete a department, set the department for all the current members to null. This only makes sense if the department relationship for an employee is optional, or if you ensure that you set a new department for each of the employees before the next save operation.</p></dd></dl><dl class="content_text"><b>Cascade</b><dd><p>Delete the objects at the destination of the relationship.</p><p>For example, if you delete a department, fire all the employees in that department at the same time.</p></dd></dl><dl class="content_text"><b>No Action</b><dd><p>Do nothing to the object at the destination of the relationship.</p><p>For example, if you delete a department, leave all the employees as they are, even if they still believe they belong to that department.</p></dd></dl></dl><p>It should be clear that the first three of these rules are useful in different circumstances. For any given relationship it is up to you to choose which is most appropriate, depending on the business logic. It is less obvious why the No Action rule might be of use, since if you use it you have the possibility of leaving the object graph in an inconsistent state (employees having a relationship to a deleted department).</p><p>If you use the No Action rule, it is up to you to ensure that the consistency of the object graph is maintained. You are responsible for setting any inverse relationship to a meaningful value. This may be of benefit in a situation where you have a to-many relationship and there may be a large number of objects at the destination. </p><a name="//apple_ref/doc/uid/TP40001857-SW3" title="Manipulating Relationships and Object Graph Integrity"></a><h2>Manipulating Relationships and Object Graph Integrity</h2><p>In general, programmatically manipulating relationships is straightforward. For examples of how to manipulate relationships programmatically, see <span class="content_text"><a href="cdUsingMOs.html#//apple_ref/doc/uid/TP40001803-212651">“Accessing and Modifying Properties”</a></span></p><p>Since Core Data takes care of the object graph consistency maintenance for you, you only need to change one end of a relationship and all other aspects are managed for you. This applies to to-one, to-many, and many-to-many relationships. Consider the following examples.</p><p>An employee’s relationship to a manager implies a reverse relationship between a manager and the manager’s employees. If a new employee is assigned to a particular manager, it is important that the manager be made aware of this responsibility. The new employee must be added to the manager’s list of reports. Similarly, if an employee is transferred from one department to another, a number of modifications must be made, as illustrated in <span class="content_text"><a href="cdRelationships.html#//apple_ref/doc/uid/TP40001857-207896-BBCIECBD">Figure 1</a></span>. The employee’s new department is set, the employee is removed from the previous department’s list of employees, and the employee is added to the new department’s list of employees.</p><br/><div><a name="//apple_ref/doc/uid/TP40001857-207896-BBCIECBD" title="Figure 1Transferring an employee to a new department"></a><p><a name="//apple_ref/doc/uid/TP40001652-207896" title="Figure 1Transferring an employee to a new department"></a><strong>Figure 1&nbsp;&nbsp;</strong>Transferring an employee to a new department</p><img src = "../Art/transfer_to_new_department.gif" alt = "Transferring an employee to a new department" width="584" height="323"></div><br/><p>Without the Core Data framework, you must write several lines of code to ensure that the consistency of the object graph is maintained. Moreover you must be familiar with the implementation of the Department class to know whether or not the inverse relationship should be set (this may change as the application evolves). Using the Core Data framework, all this can be accomplished with a single line of code:</p><div class="codesample"><table><tr><td scope="row"><pre>anEmployee.department = newDepartment;<span></span></pre></td></tr></table></div><p>By reference to the managed object model, the framework automatically determines from the current state of the object graph which relationships must be established and which must be broken.</p><a name="//apple_ref/doc/uid/TP40001857-SW10" title="Many-to-Many Relationships"></a><h2>Many-to-Many Relationships</h2><p>You define a many-to-many relationship using two to-many relationships. The first to-many relationship goes from the first entity to the second entity. The second to-many relationship goes from the second entity to the first entity. You then set each to be the inverse of the other. (If you have a background in database management and this causes you concern, don't worry: if you use a SQLite store, Core Data automatically creates the intermediate join table for you.)</p><div class="importantbox"><a name="//apple_ref/doc/uid/TP40001857-DontLinkElementID_10" title="Important:"></a><p><strong>Important:</strong>&nbsp;You must define many-to-many relationships in both directions—that is, you must specify two relationships, each being the inverse of the other. You can’t just define a to-many relationship in one direction and try to use it as a many-to-many. If you do, you will end up with referential integrity problems. </p><p></p></div><p>This works even for relationships back to the same entity (often called “reflexive” relationships). For example, if an employee may have more than one manager (and a manager can have more than one direct report), then you can define a to-many relationship <code>directReports</code> from Employee to itself that is the inverse of another to-many relationship, <code>employees</code>, again from Employee to itself. This is illustrated in <span class="content_text"><a href="cdRelationships.html#//apple_ref/doc/uid/TP40001857-SW8">Figure 2</a></span>.</p><br/><div><a name="//apple_ref/doc/uid/TP40001857-SW8" title="Figure 2Example of a reflexive many-to-many relationship"></a><p><strong>Figure 2&nbsp;&nbsp;</strong>Example of a reflexive many-to-many relationship</p><img src = "../Art/reciprocalToMany.jpg" alt = "" ></div><br/><p>A relationship can also be the inverse of itself. For example, a Person entity may have a <code>cousins</code> relationship that is the inverse of itself.</p><div class="importantbox"><a name="//apple_ref/doc/uid/TP40001857-DontLinkElementID_11" title="Important:"></a><p><strong>Important:</strong>&nbsp;On Mac OS X v10.4, many-to-many relationships do not work with SQLite stores if the relationship is an inverse of itself (such as is the case with cousins).</p><p></p></div><p>You should also consider, though, the semantics of the relationship and how it should be modeled. A common example of a relationship that is initially modeled as a many-to-many relationship that’s the inverse of itself is “friends”. Although it’s the case that you are your cousin’s cousin whether they like it or not, it’s not necessarily the case that you are your friend’s friend. For this sort of relationship, you should use an intermediate (“join”) entity. An advantage of the intermediate entity is that you can also use it to add more information to the relationship—for example a “FriendInfo” entity might include some indication of the strength of the friendship with a “ranking” attribute. This is illustrated in <span class="content_text"><a href="cdRelationships.html#//apple_ref/doc/uid/TP40001857-SW9">Figure 3</a></span></p><br/><div><a name="//apple_ref/doc/uid/TP40001857-SW9" title="Figure 3A model illustrating a &acirc;&#128;&#156;friends&acirc;&#128;&#157; relationship using an intermediate entity"></a><p><strong>Figure 3&nbsp;&nbsp;</strong>A model illustrating a “friends” relationship using an intermediate entity</p><img src = "../Art/friendsRelationship.jpg" alt = "" ></div><br/><p>In this example, Person has two to-many relationships to FriendInfo: <code>friends</code> represents the source person’s friends, and <code>befriendedBy</code> represents those who count the source as their friend. FriendInfo represents information about one friendship, “in one direction.” A given instance notes who the source is, and one person they consider to be their friend. If the feeling is mutual, then there will be a corresponding instance where <code>source</code> and <code>friend</code> are swapped. There are several other considerations when dealing with this sort of model:</p><ul class="ul"><li class="li"><p>To establish a friendship from one person to another, you have to create an instance of FriendInfo. If both people like each other, you have to create two instances of FriendInfo.</p></li><li class="li"><p>To break a friendship, you must delete the appropriate instance of FriendInfo.</p></li><li class="li"><p>The delete rule from Person to FriendInfo should be cascade. If a person is removed from the store, then the FriendInfo instance becomes invalid, so must also be removed.</p><p>As a corollary, the relationships from FriendInfo to Person must not be optional—an instance of FriendInfo is invalid if the <code>source</code> or <code>friend</code> is null.</p></li><li class="li"><p>To find out who one person’s friends are, you have to aggregate all the <code>friend</code> destinations of the <code>friends</code> relationship, for example:</p><div class="codesample"><table><tr><td scope="row"><pre>NSSet *personsFriends = [aPerson valueForKeyPath:@"friends.friend"];<span></span></pre></td></tr></table></div><p>Conversely, to find out who consider a given person to be their friends, you have to aggregate all the <code>source</code> destinations of the <code>befriendedBy</code> relationship, for example:</p><div class="codesample"><table><tr><td scope="row"><pre>NSSet *befriendedByPerson = [aPerson valueForKeyPath:@"befriendedBy.source"];<span></span></pre></td></tr></table></div></li></ul><a name="//apple_ref/doc/uid/TP40001857-SW6" title="Unidirectional Relationships"></a><h2>Unidirectional Relationships</h2><p>It is not <em>strictly</em> necessary to model a relationship in both directions. In some cases it may be useful not to, for example when a to-many relationship may have a very large number of destination objects and you are rarely likely to traverse the relationship (you may want to ensure that you do not unnecessarily fault in a large number of objects at the destination of a relationship). Not modeling a relationship in both directions, however, imposes on you a great number of responsibilities, to ensure the consistency of the object graph, for change tracking, and for undo management. For this reason, the practice is strongly discouraged. It typically only makes sense to model a to-one relationship in one direction. </p><p>If you create a model with unidirectional relationships (relationships where you have specified no inverse), your object graph may end up in an inconsistent state.</p><p>The following example illustrates a situation where only modeling a relationship in one directions might cause problems. Consider a model in which you have two entities, Employee and Department, with a to-one relationship, "department", from Employee to Department. The relationship is non-optional and has a "deny" delete rule. The relationship does not have an inverse. Now consider the following code sample:</p><div class="codesample"><table><tr><td scope="row"><pre>Employee *employee;<span></span></pre></td></tr><tr><td scope="row"><pre>Department *department;<span></span></pre></td></tr><tr><td scope="row"><pre>// assume entity instances correctly instantiated<span></span></pre></td></tr><tr><td scope="row"><pre>[employee setDepartment:department];<span></span></pre></td></tr><tr><td scope="row"><pre>[managedObjectContext deleteObject:department];<span></span></pre></td></tr><tr><td scope="row"><pre>BOOL saved = [managedObjectContext save:&amp;error];<span></span></pre></td></tr></table></div><p>The save succeeds (despite the fact that the relationship is non-optional) as long as <code>employee</code> is not changed in any other way. Because there is no inverse for the Employee.department relationship, <code>employee</code> is not marked as changed when <code>department</code> is deleted (and therefore <code>employee</code> is not validated for saving).</p><p>If you then add the following line of code:</p><div class="codesample"><table><tr><td scope="row"><pre>id x = [employee department];<span></span></pre></td></tr></table></div><p><code>x</code> will be a fault to "nowhere" rather than <code>nil</code>.</p><p>If, on the other hand, the "department" relationship has an inverse (and the delete rule is not No Action), everything behaves "as expected" since <code>employee</code> is marked as changed during delete propagation.</p><p>This illustrates why, in general, you should avoid using unidirectional relationships. Bidirectional relationships provide the framework with additional information with which to better maintain the object graph. If you do want to use unidirectional relationships, you need to do some of this maintenance yourself. In the case above, this would mean that after this line of code:</p><div class="codesample"><table><tr><td scope="row"><pre>[managedObjectContext deleteObject:department];<span></span></pre></td></tr></table></div><p>you should write:</p><div class="codesample"><table><tr><td scope="row"><pre>[employee setValue:nil forKey:@"department"]<span></span></pre></td></tr></table></div><p>The subsequent save will now (correctly) fail because of the non-optional rule for the relationship.</p><a name="//apple_ref/doc/uid/TP40001857-SW5" title="Cross-Store Relationships"></a><h2>Cross-Store Relationships</h2><p>You must be careful not to create relationships from instances in one persistent store to instances in another persistent store, as this is not supported by Core Data. If you need to create a relationship between entities in different stores, you typically use fetched properties (see <span class="content_text"><a href="cdRelationships.html#//apple_ref/doc/uid/TP40001857-SW7">“Fetched Properties”</a></span>).</p><a name="//apple_ref/doc/uid/TP40001857-SW7" title="Fetched Properties"></a><h2>Fetched Properties</h2><p>Fetched properties represent weak, one-way relationships. In the employees and departments domain, a fetched property of a department might be "recent hires" (employees do not have an inverse to the recent hires relationship). In general, fetched properties are best suited to modeling cross-store relationships, "loosely coupled" relationships, and similar transient groupings. </p><p>A fetched property is like a relationship, but it differs in several important ways:</p><ul class="ul"><li class="li"><p>Rather than being a "direct" relationship, a fetched property's value is calculated using a fetch request. (The fetch request typically uses a predicate to constrain the result.)</p></li><li class="li"><p>A fetched property is represented by an array, not a set. The fetch request associated with the property can have a sort ordering, and thus the fetched property may be ordered.</p></li><li class="li"><p>A fetched property is evaluated lazily, and is subsequently cached.</p></li></ul><p>In some respects you can think of a fetched property as being similar to a smart playlist, but with the important constraint that it is not dynamic. If objects in the destination entity are changed, you must reevaluate the fetched property to ensure it is up-to-date. You use <code><a href="../../../Reference/CoreDataFramework/Classes/NSManagedObjectContext_Class/Reference/Reference.html#//apple_ref/occ/instm/NSManagedObjectContext/refreshObject:mergeChanges:" target="_top">refreshObject:mergeChanges:</a></code> to manually refresh the properties—this causes the fetch request associated with this property to be executed again when the object fault is next fired.</p><p>There are two special variables you can use in the predicate of a fetched property—<code>$FETCH_SOURCE</code> and <code>$FETCHED_PROPERTY</code>. The source refers to the specific managed object that has this property, and you can create key-paths that originate with this, for example <code>university.name LIKE [c] $FETCH_SOURCE.searchTerm</code>. The <code>$FETCHED_PROPERTY</code> is the entity's fetched property description. The property description has a userInfo dictionary that you can populate with whatever key-value pairs you want. You can therefore change some expressions within a fetched property's predicate or (via key-paths) any object to which that object is related.</p><p>To understand how the variables work, consider a fetched property with a destination entity Author and a predicate of the form, <code>(university.name LIKE [c] $FETCH_SOURCE.searchTerm) AND (favoriteColor LIKE [c] $FETCHED_PROPERTY.userInfo.color)</code>. If the source object had an attribute <code>searchTerm</code> equal to "Cambridge", and the fetched property had a user info dictionary with a key "color" and value "Green", then the resulting predicate would be <code>(university.name LIKE [c] "Cambridge") AND (favoriteColor LIKE [c] "Green")</code>. This would match any Authors at Cambridge whose favorite color is green. If you changed the value of searchTerm in the source object to, say, "Durham", then the predicate would be <code>(university.name LIKE [c] "Durham") AND (favoriteColor LIKE [c] "Green")</code>.</p><p>The most significant constraint is that you cannot use substitutions to change the structure of the predicate—for example you cannot change a LIKE predicate to a compound predicate, nor can you change the operator (in this example, <code>LIKE [c]</code>). Moreover, on Mac OS X version 10.4, this only works with the XML and Binary stores as the SQLite store will not generate the appropriate SQL.</p>

        <br/><br/> 

        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="cdMemory.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="cdNSAttributes.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2004, 2009 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2009-03-04<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Cocoa/Conceptual/CoreData/Articles/cdRelationships.html%3Fid%3DTP40001075-5.6&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Cocoa/Conceptual/CoreData/Articles/cdRelationships.html%3Fid%3DTP40001075-5.6&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Cocoa/Conceptual/CoreData/Articles/cdRelationships.html%3Fid%3DTP40001075-5.6&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>
