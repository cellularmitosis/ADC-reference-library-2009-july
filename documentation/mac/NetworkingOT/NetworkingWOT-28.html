<!-- Generated by Harlequin WebMaker 2.2.3 (30-Apr-1996)
Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->
<HTML> <HEAD>
<TITLE>Using Endpoints</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING28></A>
<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->

<!-- Main Body -->

<CENTER>
<P>
<A HREF="NetworkingWOT-27.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="NetworkingWOT-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="NetworkingWOT-491.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A>  <A HREF="NetworkingWOT-29.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html"><B>Inside Macintosh:</B></A> <A HREF="NetworkingWOT-2.html"><B>Networking With Open Transport </B></A> / <A HREF="NetworkingWOT-10.html"><B>Part 1 - Open Transport Essentials</B></A><BR><DD><A HREF="NetworkingWOT-26.html"><B>Chapter 4 - Endpoints</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING28-0></A>
<H1><A NAME=MARKER-9-79></A>Using Endpoints</H1>
 <A NAME=MARKER-13-80></A>This section begins by explaining how you create an endpoint and associate it with an address. Next, it introduces the functions you can use to obtain information about endpoints and discusses some issues relating to asynchronous processing that specifically affect endpoint providers. Then, it explains some issues relating to data transfer that apply to all types of endpoint providers. Finally, it describes how you can implement each type of service.<P>
 No matter what type of service you want to implement, you must read the sections <A HREF=#MARKER-9-82>"Opening and Binding Endpoints,"</A> <A HREF=#MARKER-9-90>"Obtaining Information About Endpoints,"</A> <A HREF=#MARKER-9-98>"Handling Events for Endpoints,"</A> and <A HREF=#MARKER-9-138>"Sending and Receiving Data."</A> After you have read these sections, you can read the section describing the type of service you are interested in implementing. <P>
 <A HREF=#MARKER-9-14>Table 4-6</A> shows how some of the Open Transport protocols fit with an endpoint's type of service. For example, if you want to use ATP, you would need to read the section <A HREF=#MARKER-9-172>"Using Connectionless Transaction-Based Service"</A>. If you want to use ADSP, you would need to read the section <A HREF=#MARKER-9-110>"Establishing and Terminating Connections"</A> and the section <A HREF=#MARKER-9-152>"Using Connection-Oriented Transactionless Service"</A>.<P>
<B>Table 4-6  The Open Transport type-of-service matrix and some Open Transport protocols</B>
<TABLE BORDER="0" CELLPADDING=3>
<CAPTION><A NAME=MARKER-9-14></A><A NAME=MARKER-13-15></A></CAPTION>
<TH>&nbsp;<TH>Connectionless&nbsp;&nbsp;<TH>Connection-oriented<TR>
<TD>Transactionless<TD>DDP<BR>PPP<BR>IP<BR>UDP<TD>Serial connection<BR>ADSP<BR>PAP<BR>TCP<TR>
<TD>Transaction-based&nbsp;&nbsp;<TD>ATP<TD>&nbsp;</TABLE>
<P>
<DL>
<DT><B>Note</B>
<DD><A NAME=MARKER-9-81></A>The sections that follow present information in such a way as to suggest that communication is always taking place between two Open Transport clients. This does not have to be true. For example, an Open Transport client using a connectionless transactionless DDP endpoint can communicate seamlessly with a client using classic AppleTalk's DDP protocol and interface. However, because this book is about Open Transport, we always show how communication works between two Open Transport clients.   <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
<A NAME=HEADING28-5></A>
<H2><A NAME=MARKER-9-82></A>Opening and <A NAME=MARKER-13-83></A>Binding Endpoints</H2>
 After you have initialized Open Transport and determined what the endpoint configuration is going to be then, you can open and bind the endpoint. You open the endpoint with the <CODE>OTOpenEndpoint</CODE> or <CODE>OTAsyncOpenEndpoint</CODE> functions. Opening an endpoint with the <A NAME=MARKER-11-120></A><CODE>OTOpenEndpoint</CODE> function sets the default mode of execution to be synchronous; opening an endpoint with the <A NAME=MARKER-11-122></A><CODE>OTAsyncOpenEndpoint</CODE> function sets the default mode of execution to be asynchronous. You can change an endpoint's mode of execution at any time by calling the <CODE>OTSetSynchronous</CODE> or <CODE>OTSetAsynchronous</CODE> functions, which are described in <A HREF=NetworkingWOT-23.html#MARKER-9-28>"Providers"</A>.<P>
 One of the parameters that you pass to the function used to open the endpoint is a pointer to a configuration structure that Open Transport needs to define the protocol stack providing data transport services. The chapter <A HREF=NetworkingWOT-16.html#MARKER-9-19>"Getting Started With Open Transport"</A>, contains information about creating a configuration structure for an endpoint provider. <P>
 If you use the <CODE>OTAsyncOpenEndpoint</CODE> function to open an endpoint, you also specify a notifier function that the endpoint provider can use to call your application when an asynchronous or completion event takes place. If you use the <CODE>OTOpenEndpoint</CODE> function to open an endpoint, and you want to handle asynchronous events using a notifier function, you must use the <CODE>OTInstallNotifier</CODE> function <A HREF=NetworkingWOT-118.html#MARKER-9-115></A> to install your notifier function.<A NAME=MARKER-13-86></A><P>
 When Open Transport creates an endpoint, it establishes important state information for the endpoint, including information about <A NAME=MARKER-13-87></A><P>
<UL>
<P><LI>the endpoint's modes and type of service 
<P><LI>the size of normal transport service data units (TSDUs) and expedited transport service data units (ETSDUs) or, in the case of transactions, the size of replies and requests
<P><LI>the maximum size of buffers used to hold address and option information for the endpoint
<P><LI>default option values for the endpoint<P>
</UL>
 You can retrieve this information by calling functions that return information about the endpoint. These functions are described in the next section, <A HREF=#MARKER-9-90>"Obtaining Information About Endpoints"</A>.<P>
 When the function you use to open the endpoint returns, it passes back to you an endpoint reference. You can pass this reference as a parameter to any endpoint provider function or any general provider function. For example, you pass this reference as a parameter to the <A NAME=MARKER-13-127></A><CODE>OTBind</CODE> function, which you must use to bind an endpoint after opening it. <P>
 Binding an endpoint associates the endpoint with a logical address. Depending on the protocol you use and on your application's needs, you can select a specific address or you can have the protocol choose an address for you. For information about valid address formats, consult the documentation for your protocol. The general rule for binding endpoints is simple: you cannot bind more than one connectionless endpoint to a single address. You can bind more than one connection-oriented endpoint to the same address; for additional information about this possibility, see the section <A HREF=#MARKER-9-119>"Processing Multiple Connection Requests"</A>.<P>
 No matter what type of service you need to implement, you must know how to obtain information about the endpoints you have opened and how to handle asynchronous and completion events for these endpoints. These issues are addressed in the next two sections, <A HREF=#MARKER-9-90>"Obtaining Information About E ndpoints"</A>, and <A HREF=#MARKER-9-98>"Handling Events for Endpoints"</A> After you read these sections, you can proceed by reading about the type of service you want to implement. <A NAME=MARKER-13-89></A><P>
<A NAME=HEADING28-18></A>
<H2><A NAME=MARKER-9-90></A>Obtaining Information About Endpoints</H2>
 While you can use general provider functions to determine an endpoint's mode of execution, you must use endpoint-specific functions to obtain the endpoint's type of service, state, or address. <A NAME=MARKER-13-91></A><P>
 The <A NAME=MARKER-13-82></A><CODE>TEndpointInfo</CODE> structure contains most of the information you need to determine how you can use an endpoint. You can obtain a copy of this structure when you open the endpoint, or by calling the <A NAME=MARKER-11-137></A><CODE>OTGetEndpointInfo</CODE> function. This structure specifies the maximum size of the buffers you need to allocate when calling functions that return address and option information or data, and it also contains more specific details about the type of service the endpoint provides. For example, if you have opened a connection-oriented endpoint, the <CODE>servtype</CODE> field of the <CODE>TEndpointInfo</CODE> structure specifies whether the endpoint supports orderly release. <P>
 To obtain information about an endpoint's state, you call the function <A NAME=MARKER-11-141></A><CODE>OTGetEndpointState</CODE>. This function returns a positive integer indicating the endpoint state or a negative integer corresponding to a result code. <A HREF=NetworkingWOT-27.html#MARKER-9-3>Table 4-3 </A> lists and describes endpoint states. If the endpoint is in asynchronous mode and you are not using a notifier function, you can use the <CODE>OTGetEndpointState</CODE> function to poll the endpoint and determine whether a specific function has finished executing. The completion of some functions result in an endpoint's changing state. For additional information, see <A HREF=NetworkingWOT-27.html#MARKER-9-12>Table 4-4 </A>.<P>
 To obtain address information about an endpoint or its peer, you can use one of the following two functions:<P>
<UL>
<P><LI><CODE><A NAME=MARKER-11-150></A>OTGetProtAddress</CODE>, which returns the address to which the endpoint is bound. If the endpoint is connection-oriented and currently connected, this function also returns the address to which the endpoint is connected.
<P><LI><CODE><A NAME=MARKER-11-154></A>OTResolveAddress</CODE>, which returns the lowest-layer protocol address corresponding to a higher-level address for the endpoint's protocol. If you are looking up the address that corresponds to a single name, you can use this function rather than having to open the mapper provider and use the mapper function <CODE>OTLookUpName</CODE>.<P>
</UL>
 For information about the address formats for the protocol you are using, please consult the documentation supplied for the protocol. This manual explains these formats for the TCP/IP and the AppleTalk protocols. For information about obtaining the addresses that correspond to a name pattern, see <A HREF=NetworkingWOT-34.html#MARKER-9-25>"Mappers"</A>. <A NAME=MARKER-13-97></A><P>
<A NAME=HEADING28-26></A>
<H2><A NAME=MARKER-9-98></A>Handling Events for Endpoints</H2>
 <A NAME=MARKER-13-99></A>Like other providers, endpoint providers can operate synchronously or asynchronously. If you use an asynchronous endpoint, you need to create a notifier function that the provider can call to inform you of provider events. This section describes how you handle events for endpoint providers.<P>
 Event handling for endpoints is basically the same as that described for providers in <A HREF=NetworkingWOT-24.html#MARKER-9-45>"Provider Events"</A>. One slight difference lies in the way the endpoint provider generates <A NAME=MARKER-13-27></A><CODE>T_DATA</CODE>, <A NAME=MARKER-13-28></A><CODE>T_EXDATA</CODE>, and <A NAME=MARKER-13-34></A><CODE>T_REQUEST</CODE> asynchronous events, which signal the arrival of incoming data or of an incoming transaction request. For the sake of efficiency, the provider notifies you just once that incoming data has arrived. To read all the data, you must call the function that clears the event until the function returns with the <A NAME=MARKER-15-14></A><CODE>kOTNoDataErr</CODE> result. <P>
<DL>
<DT><B>IMPORTANT</B>
<DD>An endpoint does not receive any more <CODE>T_DATA</CODE> events until its current <CODE>T_DATA</CODE> event is cleared.  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif"><P>
</DL>

 <A HREF=#MARKER-9-16>Table 4-7</A> lists the functions you use to clear pending asynchronous events.<A NAME=MARKER-13-104></A><P>
<B>Table 4-7  Pending asynchronous events and the functions that clear them</B>
<TABLE BORDER="0" CELLPADDING=3>
<CAPTION><A NAME=MARKER-9-16></A></CAPTION>
<TH>Pending event&nbsp;&nbsp;<TH>Open Transport function <BR>that clears the event<TR>
<TD><CODE>T_LISTEN</CODE><TD><CODE>OTListen</CODE><TR>
<TD><CODE>T_CONNECT</CODE><TD><CODE>OTRcvConnect</CODE><TR>
<TD><CODE>T_DATA</CODE><TD><CODE>OTRcv, OTRcvUData</CODE><TR>
<TD><CODE>T_EXDATA</CODE><TD><CODE>OTRcv</CODE><TR>
<TD><CODE>T_DISCONNECT</CODE><TD><CODE>OTRcvDisconnect</CODE><TR>
<TD><CODE>T_UDERR</CODE><TD><CODE>OTRcvUDErr</CODE><TR>
<TD><CODE>T_ORDREL</CODE><TD><CODE>OTRcvOrderlyDisconnect</CODE><TR>
<TD><CODE>T_GODATA</CODE><TD><CODE>OTSnd, OTSndUData, OTLook</CODE><TR>
<TD><CODE>T_GOEXDATA</CODE><TD><CODE>OTSnd, OTLook <A NAME=MARKER-13-17></A></CODE><TR>
<TD><CODE>T_PASSCON</CODE><TD>none</TABLE>
<A NAME=MARKER-13-105></A><P>
 This works as follows. A transport provider has a queue of data or commands to deliver to the client. If the queue is empty when the data or command arrives, the provider notifies the the client. If the queue is not empty, then no notification is delivered at the time the data or command is queued. Instead, whenever the client reads the data or command at the head of the queue, Open Transport examines the next element of the queue, if it exists. If this next element of the queue is of the same type as what was at the head of the queue, no event is generated. If there is a difference, the provider delivers a new event to the client. Typically, this new event is delivered to the client just before the function returns which removed the head element of the queue.<P>
<A NAME=HEADING28-32></A>
<H3>Clearing Events and Synchronization Problems</H3>
 You do not have to issue calls that clear events in the notification routine itself, but until you make the consuming calls and receive a <CODE>kOTNoDataErr</CODE> error, another <CODE>T_DATA</CODE>, <CODE>T_EXDATA</CODE>, or <CODE>T_REQUEST</CODE> event is not guaranteed to be issued. <P>
 One exception to this rule occurs when dealing with transaction-based protocols. When the client gets a <CODE>T_REPLY</CODE> event, it should call the function <CODE>OTRcvUReply</CODE> until the function returns the result <CODE>kOTNoDataErr</CODE>.  If the client calls <CODE>OTRcvUReply</CODE> from the foreground (rather than from a notification routine), the following sequence can occur: While the client is busy reading replies in the foreground, a request arrives. This will cause a <CODE>T_REQUEST</CODE> event to be generated. If the foreground client was calling <CODE>OTRcvUReply</CODE> at this point in time, a <CODE>kOTLookErr</CODE> will be generated rather than a <CODE>kOTNoDataErr</CODE>. In this case (and the converse case for <CODE>T_REQUEST</CODE> events), another <CODE>T_REPLY</CODE> event will be generated when a new reply arrives.<P>
<A NAME=HEADING28-35></A>
<H3>Notifier Reentrancy</H3>
 Open Transport endpoints are handled independently. That means that you can use the same code for the notifiers of two different endpoints. A different instance of the notfier is invoked for each endpoint using the notifier.<P>
 Whatever events are pending on one endpoint have (for the most part) no effect on any other endpoints. For example, assume that an endpoint is notified of a <CODE>T_DATA</CODE> event. Following this, a separate <CODE>T_DATA</CODE> event is sent to a second endpoint. The notifier for the second endpoint is invoked, interrupting the first endpoint's processing of its <CODE>T_DATA</CODE> event. For additional information, see <A HREF=NetworkingWOT-30.html#MARKER-9-26>"Using Asynchronous Processing With a Notifier"</A>.<P>
<A NAME=HEADING28-38></A>
<H3>Polling for Events</H3>
 Open Transport also includes the endpoint provider function <A NAME=MARKER-11-145></A><CODE>OTLook</CODE>. You can use the <CODE>OTLook</CODE> function<A NAME=MARKER-13-107></A> <P>
<UL>
<P><LI>to <A NAME=MARKER-13-144></A>poll for asynchronous events, like incoming data or connection requests
<P><LI>to determine the cause of a <A NAME=MARKER-15-10></A><CODE>kOTLookErr</CODE> result<P>
Asynchronous functions can return this result. In addition, asynchronous events that require immediate attention can cause some synchronous functions to fail with the <CODE>kOTLookErr</CODE> result. In this case, you can call the <CODE>OTLook</CODE> function to determine the event that caused the function to fail. <A HREF=#MARKER-9-18>Table 4-8</A> lists the functions that can return the result <CODE>kOTLookErr</CODE> when the corresponding event is pending. <P>
<B>Table 4-8  Pending asynchronous events and the synchronous functions they can affect</B>
<TABLE BORDER="0" CELLPADDING=3>
<CAPTION><A NAME=MARKER-9-18></A></CAPTION>
<TH>Function that fails<TH>Pending events<TR>
<TD><CODE>OTAccept, OTConnect</CODE><TD><CODE>T_DISCONNECT, T_LISTEN</CODE><TR>
<TD><CODE>OTListen, OTRcvConnect,<BR>OTRcvOrderlyDisconnect,<BR>OTSndOrderlyDisconnect,OTSndDisconnect</CODE>&nbsp;&nbsp;<TD><CODE>T_DISCONNECT</CODE><TR>
<TD><CODE>OTRcv, OTRcvRequest, OTRcvReply, <BR>OTSnd, OTSndRequest, OTSndReply</CODE><TD><CODE>T_GODATA, T_DISCONNECT, T_ORDREL</CODE><TR>
<TD><CODE>OTRcvUData, OTSndUData</CODE><TD><CODE>T_UDERR</CODE><TR>
<TD><CODE>OTUnbind</CODE><TD><CODE>T_LISTEN, T_DATA</CODE></TABLE>
<P>
Having used the <CODE>OTLook</CODE> function to determine what asynchronous event caused your function to fail, you must call one of the functions listed in <A HREF=#MARKER-9-16>Table 4-7 </A> to clear the event, and then you can retry the function that failed.<P>
</UL>
<A NAME=HEADING28-44></A>
<H2><A NAME=MARKER-9-110></A>Establishing and Terminating Connections</H2>
 To implement a connection-oriented service, you must complete the following steps:<P>
<UL>
<P><LI>establish a connection
<P><LI>process any data associated with establishing the connection if this is permitted for the endpoint
<P><LI>transfer data
<P><LI>terminate the connection when you are finished transferring data<P>
</UL>
 The following sections explain how you establish and terminate a connection. The functions you use to establish and terminate a connection are the same for transactionless as for transaction-based service, but the calls you use to transfer data differ. The section <A HREF=#MARKER-9-152>"Using Connection-Oriented Transactionless Service"</A> explains how you transfer data once you have established a connection. <A NAME=MARKER-13-111></A><P>
 Before you can use a connection-oriented endpoint to initiate or accept a connection, you must open and <A NAME=MARKER-13-121></A>bind the endpoint. For example, if you are using AppleTalk, you might open an ADSP endpoint, which offers connection-oriented transactionless service. You don't have to do anything special to bind an endpoint that is intended to be the active peer of a connection. However, when you bind an endpoint intended to be the passive peer of a connection, you must specify a value for the <CODE>qlen</CODE> field of the <CODE>reqAddr</CODE> parameter for the <CODE>OTBind</CODE> function. The <CODE>qlen</CODE> field indicates the number of outstanding connection requests that can be queued for that endpoint. <P>
<DL>
<DT><B>Note</B>
<DD>The value you specify for the <CODE>qlen</CODE> field indicates your desired value, but Open Transport may negotiate a lower value, depending upon the number of internal buffers available. The negotiated value of outstanding connection indications is returned to you in the <CODE>qlen</CODE> field of the <CODE>retAddr</CODE> parameter for the <CODE>OTBind</CODE> function. After calling the <CODE>OTBind</CODE> function, you might want to take a look at this field to see whether the protocol has imposed a limit on the <CODE>qlen</CODE> value.   <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
 You are allowed to bind multiple connection-oriented endpoints to a single address. However, only one of these endpoints can accept incoming connection requests. That is, only one endpoint can specify a value for <CODE>qlen</CODE> that is greater than 0. For more information, see the section <A HREF=#MARKER-9-119>"Processing Multiple Connection Requests"</A>.<P>
<A NAME=HEADING28-54></A>
<H3><A NAME=MARKER-9-113></A>Establishing a Connection</H3>
 You use the following functions to establish a connection:<A NAME=MARKER-13-114></A><P>
<TABLE BORDER="0" CELLPADDING=3><TH ALIGN=LEFT>Active peer calls&nbsp;&nbsp;<TH>Passive peer calls&nbsp;&nbsp;<TH>Meaning<TR>
<TD><CODE><A NAME=MARKER-13-19></A>OTConnect</CODE><TD><TD>Requests a connection to the passive peer.<TR>
<TD><TD><CODE><A NAME=MARKER-13-20></A>OTListen</CODE><TD>Gets information about an incoming connection request.<TR>
<TD><TD><CODE><A NAME=MARKER-13-21></A>OTAccept</CODE><TD>Accepts the connection request identified by the <CODE>OTListen</CODE> function. The connection can be accepted by a different endpoint than the one listening for incoming connection requests.<TR>
<TD><CODE><A NAME=MARKER-13-22></A>OTRcvConnect</CODE><TD><TD>Reads the status of a pending or completed asynchronous call to the <CODE>OTConnect</CODE> function.<TR>
<TD><TD><CODE><A NAME=MARKER-13-23></A>OTSndDisconnect</CODE><TD>Rejects an incoming connection request.<TR>
<TD><CODE><A NAME=MARKER-13-24></A>OTRcvDisconnect</CODE><TD><TD>Identifies the cause of a rejected connection and acknowledges the corresponding disconnection event.</TABLE>
<P>
 <A HREF=#MARKER-9-115>Figure 4-3</A> illustrates the process of establishing a connection in synchronous mode. <P>
<B>Figure 4-3  <A NAME=MARKER-9-115></A>Establishing a connection with the active peer in synchronous mode</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/OTE-L-05.gif"><P>
 As <A HREF=#MARKER-9-115>Figure 4-3</A> shows, if the active peer is in synchronous mode, the <CODE>OTConnect</CODE> function does not return until the connection has been established or the connection attempt has been rejected. If the passive peer has a notifier function installed, the endpoint provider calls it, passing <CODE>T_LISTEN</CODE> for the <CODE>code</CODE> parameter. The notifier calls the <CODE>OTListen</CODE> function, which reads the connection request. The passive peer can now either accept the connection request using the <CODE>OTAccept</CODE> function or reject the request by calling the <CODE>OTSndDisconnect</CODE> function. The connection attempt might also fail if the request is never received and the endpoint provider times out the call to the <CODE>OTConnect</CODE> function.<P>
 If the passive peer calls the <CODE>OTAccept</CODE> function to accept the connection, the <CODE>OTConnect</CODE> function returns with <CODE>kOTNoErr</CODE>. If the passive peer rejects the connection or the request times out, the <CODE>OTConnect</CODE> function returns with <CODE>kOTLookErr</CODE>. When the <CODE>OTConnect</CODE> function returns, the active peer must examine the result. If the call succeeded, it should begin to transfer data. If the call failed, the active peer should call the <CODE>OTRcvDisconnect</CODE> function to restore the endpoint to a valid state for subsequent operations. <P>
 If the active peer is in asynchronous mode, the <CODE>OTConnect</CODE> function returns right away with the <CODE>kOTNoDataErr</CODE> result, and the active peer must rely on its notifier function to determine whether the call succeeded. <A HREF=#MARKER-9-116>Figure 4-4</A> illustrates the process of establishing a connection when the active peer is in asynchronous mode.<P>
<B>Figure 4-4  <A NAME=MARKER-9-116></A>Establishing a connection in asynchronous mode</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/OTE-L-06.gif"><P>
 The active peer calls the <CODE>OTConnect</CODE> function, which returns right away with a code of <CODE>kOTNoDataErr</CODE>. The endpoint provider calls the passive peer's notifier, passing <CODE>T_LISTEN</CODE> for the <CODE>code</CODE> parameter. If the passive peer accepts the connection, the endpoint provider calls the active peer's notifier, passing <CODE>T_CONNECT </CODE>for the <CODE>code</CODE> parameter.<P>
  If the passive peer rejects the connection or if the connection times out, the endpoint provider calls the active peer's notifier, passing <CODE>T_DISCONNECT</CODE> for the <CODE>code</CODE> parameter. The active peer must then call either the <CODE>OTRcvConnect</CODE> function in response to a <CODE>T_CONNECT</CODE> event or the <CODE>OTRcvDisconnect</CODE> function in response to a <CODE>T_DISCONNECT</CODE> event. The endpoint provider, in turn, passes the <CODE>T_ACCEPTCOMPLETE</CODE> event back to the passive peer (for a successful connection) or the <CODE>T_DISCONNECTCOMPLETE</CODE> event (for a rejected connection). The passive peer requires the information provided by these two events to determine whether the connection succeeded. <A NAME=MARKER-13-117></A><P>
<A NAME=HEADING28-66></A>
<H4>Sending User Data With Connection or Disconnection Requests</H4>
 The <CODE>OTConnect</CODE> function and the <CODE>OTSndDisconnect</CODE> function both pass data structures that include fields for data that you might want to send at the time that you are setting up or tearing down a connection. However, you can only send data when calling these two functions if the <CODE>connect</CODE> and <CODE>discon</CODE> fields of the <CODE>TEndpointInfo</CODE> structure specify that the endpoint can send data with connection or disconnection requests. The amount of data sent must not exceed the limits specified by these two fields. To determine whether the endpoint provider for your endpoint supports data transfer during the establishment of a connection, you must examine the <CODE>connect</CODE> and <CODE>discon</CODE> fields of the <CODE>TEndpointInfo</CODE> structure for the endpoint. <A NAME=MARKER-13-118></A><P>
<A NAME=HEADING28-68></A>
<H4><A NAME=MARKER-9-119></A>Processing Multiple Connection Requests</H4>
 If you process multiple connection requests for a single endpoint, you must make sure that the number of outstanding connection requests does not exceed the limit defined for the listening endpoint when you bound that endpoint. An outstanding connection request is a request that you have read using the <CODE>OTListen</CODE> function but that you have neither accepted nor rejected. You must also decide whether to accept connections on the same endpoint that is listening for the connections or on a different endpoint. <A NAME=MARKER-13-120></A><P>
 When you <A NAME=MARKER-13-121></A>bind the passive endpoint, you must specify a value greater than 0 for the <CODE>qlen</CODE> field of the <CODE>reqAddr</CODE> parameter to the <CODE>OTBind</CODE> function. This value indicates the number of outstanding connections that the provider can queue for this endpoint. As you process incoming connection requests, you must check that the number of connections still waiting to be processed does not exceed this negotiated value for the listening endpoint. How you do this depends on the number of outstanding requests and on whether you are accepting connection requests on the same endpoint as the endpoint listening for requests or accepting them on a different endpoint. Connection acceptance is governed by the following rules:<A NAME=MARKER-13-122></A><P>
<UL>
<P><LI>You can bind more than one connection-oriented endpoint to the same address, but you can use only one of these endpoints to listen for connection requests.<P>
<P><LI>If you accept a connection on the same endpoint that is listening for connection requests, you must have responded to all previous connection requests received on the endpoint using <CODE>OTAccept</CODE> or <CODE>OTSndDisconnect</CODE> functions. Otherwise, the <CODE>OTAccept</CODE> function fails. If you have not responded to all previous connection requests, you should accept the connection on a different endpoint.<P>
<P><LI>If you accept a connection on an endpoint that is different from the endpoint that received the connection request, you do not have to bind the endpoint to which you are passing off the connection. If the endpoint is not bound, the endpoint provider automatically binds it to the address of the endpoint that listened for the connection request. <P>
If you choose to explicitly bind the endpoint accepting the connection to the address of the endpoint listening for the connection, you must set the <CODE>qlen</CODE> field of the <CODE>reqAddr</CODE> parameter to the <CODE>OTBind</CODE> function to 0.<P>
<P><LI>The underlying implemention determines whether you must bind the endpoint accepting a connection to the address of the endpoint listening for the connection. In general, it is recommend that you do not bind it to the same address. <P>
</UL>
 What these rules add up to in practical terms is that if you anticipate managing more than one connection at a time, you should open an endpoint to listen for connections and then open additional endpoints as needed to accept incoming connections. <A NAME=MARKER-13-123></A><A NAME=MARKER-13-124></A><P>
<A NAME=HEADING28-77></A>
<H3><A NAME=MARKER-9-125></A>Terminating a Connection</H3>
 You can terminate a connection using either an abortive or orderly disconnect. During an abortive disconnect, the connection is torn down without the underlying protocol taking any steps to make sure that data being transferred has been sent and received. When the client calls the <CODE>OTSndDisconnect</CODE> function, the connection is immediately torn down, and the client cannot be sure that the provider actually sent any locally buffered data. During an orderly disconnect, the underlying protocol ensures at least that all outgoing data is actually sent. Some protocols go further than this, using an over-the-wire handshake that allows both peers to finish transferring data and agree to disconnect. The following sections describe the steps required for abortive and orderly disconnects. For additional information about handling an unexpected disconnection from a remote client, see <A HREF=NetworkingWOT-33.html#MARKER-9-51>"Handling Dead Clients"</A>.<A NAME=MARKER-13-126></A><P>
<A NAME=HEADING28-79></A>
<H4>Using an Abortive Disconnect</H4>
 You use the <A NAME=MARKER-13-127></A><CODE>OTSndDisconnect</CODE> and <A NAME=MARKER-13-128></A><CODE>OTRcvDisconnect</CODE> functions to perform an abortive disconnect. <A HREF=#MARKER-9-129>Figure 4-5</A> illustrates the process for two asynchronous endpoints. The figure shows the active peer initiating the disconnection; in fact, either peer can initiate the disconnection.<P>
<B>Figure 4-5  <A NAME=MARKER-9-129></A>An abortive disconnect</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/OTE-L-08.gif"><P>
 In asynchronous mode, the endpoint initiating the disconnection calls the <CODE>OTSndDisconnect</CODE> function. Parameters to the function identify the endpoint and point to a <A NAME=MARKER-13-104></A><CODE>TCall</CODE> structure that is only of interest if the endpoint provider supports sending data with disconnection requests. To determine whether your protocol does, you must examine the value of the <CODE>discon</CODE> field of the <CODE>TEndpointInfo</CODE> structure for your endpoint. If you do not want to send data or if you cannot send data to the passive peer, you can set <CODE>TCall</CODE> to a <CODE>NULL</CODE> pointer. <P>
 The endpoint provider receiving the disconnect request calls the passive peer's notifier function, passing <CODE>T_DISCONNECT</CODE> for the <CODE>code</CODE> parameter. The client must acknowledge the disconnection event by calling the function <CODE>OTRcvDisconnect</CODE>. This function clears the event and retrieves any data sent with the event. Parameters to the <CODE>OTRcvDisconnect</CODE> function identify the endpoint sending the disconnection and point to a <A NAME=MARKER-13-113></A><CODE>TDiscon</CODE> structure that is only of interest if the endpoint provider supports sending data with disconnection requests or if the passive peer is managing multiple connections and needs to know which of the connections has been closed by using the <CODE>sequence</CODE> field of the <CODE>TDiscon</CODE> structure. Otherwise, you can set <CODE>TDiscon</CODE> to a <CODE>NULL</CODE> pointer. <P>
 When the connection has been closed, the endpoint provider calls the active peer's notifier, passing <CODE>T_DISCONNECTCOMPLETE</CODE> for the <CODE>event</CODE> parameter. At this time the endpoint is once more in the <CODE>T_IDLE</CODE> state. <A NAME=MARKER-13-132></A><P>
<A NAME=HEADING28-86></A>
<H4><A NAME=MARKER-9-133></A>Using Orderly Disconnects</H4>
 <CODE><A NAME=MARKER-13-134></A></CODE>There are two kinds of orderly disconnects: remote orderly disconnects and local orderly disconnects. The first kind, supported by TCP, provides an over-the-wire (three-way) handshake that guarantees that all data has been sent and that both peers have agreed to disconnect. The second kind, supported by ADSP and most other connection-oriented transactionless protocols, is a locally implemented orderly release mechanism ensuring that data currently being transferred has been received by both peers before the connection is torn down. To determine whether your protocol supports orderly disconnects, you must examine the <CODE>servtype</CODE> field of the <CODE>TEndpointInfo</CODE> structure for the endpoint. A value of <CODE>T_COTS_ORD</CODE> or <CODE>T_TRANS_ORD</CODE> indicates that the endpoint supports orderly disconnect. It is safest to assume, unless you know for certain it to be otherwise, that the endpoint supports only local orderly disconnects. <P>
 <A HREF=#MARKER-9-135>Figure 4-6</A> shows the steps required to complete a remote orderly disconnect. The figure shows the active peer initiating the disconnection; in fact, either peer can initiate the disconnection.<P>
<B>Figure 4-6  <A NAME=MARKER-9-135></A>Remote orderly disconnect</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/OTE-L-09.gif"><P>
 The active peer initiates the disconnection by calling the <CODE>OTSndOrderlyDisconnect</CODE> function to begin the process and to let the remote endpoint know that the active peer will not send any more data. (Once it calls this function, the active peer can receive data but it cannot send any more data.) The provider calls the passive peer's notifier function, passing <CODE>T_ORDREL</CODE> for the <CODE>code</CODE> parameter. In response, the passive peer must read any unread data and can send additional data. After it has finished reading the data, it must call the <CODE>OTRcvOrderlyDisconnect</CODE> function to acknowledge receipt of the orderly release indication. After calling this function, the passive peer cannot read any more data; however, it can continue to send data. This is a <I>half-closed</I> connection. When the passive peer is finished sending any additional data, it calls the <CODE>OTSndOrderlyDisconnect</CODE> function to complete its part of the disconnection. Following this call, it cannot send any data. The endpoint provider calls the active peer's notifier, passing <CODE>T_ORDREL</CODE> for the <CODE>code</CODE> parameter, and the active peer calls the <CODE>OTRcvOrderlyDisconnect</CODE> function to acknowledge receipt of the disconnection event and to place the endpoint in the <CODE>T_IDLE</CODE> state if this was the only outstanding connection.<P>
 <A HREF=#MARKER-9-136>Figure 4-7</A> shows the steps required to complete a local orderly disconnect.<P>
<B>Figure 4-7  <A NAME=MARKER-9-136></A>A local orderly disconnect</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/OTE-L-10.gif"><P>
 As you can see, the sequence of steps is very similar to that shown in <A HREF=#MARKER-9-135>Figure 4-6</A>. The main difference is that the connection is broken as soon as the active peer calls the <CODE>OTSndOrderlyDisconnect</CODE> function. As a result, either peer can continue to read any unread data, but neither peer can send data after the initial call to the <CODE>OTSndOrderlyDisconnect</CODE> function. <A NAME=MARKER-13-137></A><P>
<A NAME=HEADING28-96></A>
<H2><A NAME=MARKER-9-138></A>Sending and Receiving Data</H2>
 This section describes some of the issues that affect send and receive operations for all types of endpoints. After you read this section, you should read <A HREF=#MARKER-9-143>"Transferring Data Between Transactionless Endpoints"</A> or <A HREF=#MARKER-9-166>"Transferring Data Between Transaction-Based Endpoints"</A> for additional information about the type of endpoint you are using.<P>
 The chapter "Advanced Topics<A HREF=NetworkingWOT-46.html#MARKER-9-19></A>" presents additional material that concerns the transfer of data and improving performance; this material includes <P>
<UL>
<P><LI>sending non-contiguous data
<P><LI>transferring data in raw mode
<P><LI>doing no-copy receives<P>
</UL>
 Please consult that chapter for more information.<P>
<A NAME=HEADING28-103></A>
<H3><A NAME=MARKER-13-139></A>Sending Data Using Multiple Sends</H3>
 If you are sending a single data unit using multiple sends, you must do the following:<P>
<OL>
<P><LI>Set the <A NAME=MARKER-13-36></A><CODE>T_MORE</CODE> bit in the flags field each time you call the send function. This lets the provider know that it has not yet received the entire data unit.
<P><LI>Clear the <CODE>T_MORE</CODE> bit the last time you call the send function. This lets the provider know that the data unit is complete.<P>
</OL>
 Even though you are using multiple sends to send the data, the total size of the data sent cannot exceed the value specified for the <CODE>tsdu</CODE> field (for normal data or replies) or <CODE>etsdu</CODE> field (for expedited data or requests) of the <CODE>TEndpointInfo</CODE> structure for the endpoint.<P>
 Sending data using multiple sends does not necessarily affect the way in which the remote client receives the data. That is, just because you have used several calls to a send function to send data does not mean that the remote client must call a receiving function several times to read the data.<P>
<DL>
<DT><B>IMPORTANT</B>
<DD>Connectionless transactionless protocols do not support the <CODE>T_MORE</CODE> flag.   <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
<A NAME=HEADING28-110></A>
<H3><A NAME=MARKER-13-141></A>Receiving Data</H3>
 If you are reading data and if the <A NAME=MARKER-13-36></A><CODE>T_MORE</CODE> bit in the flags field is set, this means that the buffer you have allocated to hold the data is not big enough. You need to call the receive function again and read more data until the <CODE>T_MORE</CODE> bit is cleared, which indicates that you have read the entire data unit. <P>
<A NAME=HEADING28-112></A>
<H2><A NAME=MARKER-9-143></A>Transferring Data Between Transactionless Endpoints</H2>
 <A NAME=MARKER-13-144></A>Open Transport defines two sets of functions that you can use to send and receive data between transactionless endpoints. You use one set with connectionless service and the other with connection-oriented service. <P>
<A NAME=HEADING28-114></A>
<H3><A NAME=MARKER-9-145></A>Using Connectionless Transactionless Service</H3>
 <A NAME=MARKER-13-146></A>You use connectionless transactionless service, as provided by DDP and UDP, to send and receive discrete data packets. <P>
 After opening and binding a connectionless transactionless endpoint, you can use three functions to send and receive data:<P>
<UL>
<P><LI>the <A NAME=MARKER-11-173></A><CODE>OTSndUData</CODE> function to send data
<P><LI>the <A NAME=MARKER-11-179></A><CODE>OTRcvUData</CODE> function to receive data
<P><LI>the <A NAME=MARKER-11-176></A><CODE>OTRcvUDErr</CODE> function to determine why a send operation did not succeed <P>
</UL>
 Either endpoint can send or receive data. However, the endpoint sending data cannot determine whether the other endpoint has actually received the data. <P>
 Endpoints are not able to determine that the specified address or options are invalid until after the data is sent. In this case, the sender's endpoint provider might issue the <CODE><A NAME=MARKER-13-30></A>T_UDERR</CODE> event. You should include code in your notifier function that calls the <CODE>OTRcvUDErr</CODE> function in response to this event to determine what caused the send function to fail and to place the sending endpoint in the correct state for further processing. <P>
 If the endpoint receiving data has allocated a buffer that is too small to hold the data, the <CODE>OTRcvUData</CODE> function returns with the <CODE>T_MORE</CODE> bit set in the <CODE>flags</CODE> parameter. In this case, you should call the <CODE>OTRcvUData</CODE> function repeatedly until the <CODE>T_MORE</CODE> bit is cleared. <A NAME=MARKER-13-151></A><P>
<A NAME=HEADING28-123></A>
<H3><A NAME=MARKER-9-152></A> Using Connection-Oriented Transactionless Service </H3>
 You use connection-oriented transactionless service, such as provided by ADSP and TCP, to exchange full-duplex streams of data across a network. Connection-oriented transactionless endpoints use the <A NAME=MARKER-13-153></A><CODE>OTSnd</CODE> function to send data and the <A NAME=MARKER-13-154></A><CODE>OTRcv</CODE> function to receive data. Either endpoint can call either of these functions. Parameters to the <CODE>OTSnd</CODE> function identify the endpoint sending the data, the buffer that holds the data, the size of the data, and a <CODE>flags</CODE> value that specifies whether the data sent is normal or expedited and whether multiple sends are being used to send the data. Parameters to the <CODE>OTRcv</CODE> function identify the receiving endpoint, the buffer where the data should be copied, the size of the buffer, and a <CODE>flags</CODE> value that Open Transport sets to tell the client whether to call <CODE>OTRcv</CODE> more than once to retrieve the data being sent.<A NAME=MARKER-13-155></A><P>
 <A NAME=MARKER-13-156></A>Some endpoints support the use of expedited data, and some support the use of separators to break the data stream into logical units. You need to examine the endpoint's <A NAME=MARKER-13-82></A><CODE>TEndpointInfo</CODE> structure to determine if the endpoint supports either of these features: <A NAME=MARKER-13-158></A><P>
<UL>
<P><LI>The <CODE>etsdu</CODE> field of the <CODE>TEndpointInfo</CODE> structure specifies whether the endpoint supports the use of expedited data and, if so, specifies its size. For example, ADSP supports the use of expedited data to send attention messages. In general, it is recommended that you do not use expedited data because doing so results in code that is less transport independent. 
<P><LI>The <CODE>tsdu</CODE> field of the <CODE>TEndpointInfo</CODE> structure specifies the maximum size of normal data that the endpoint can send or receive. In those cases where the endpoint supports the breaking up of the data stream into logical units, the TSDU size specifies what the maximum size of any such unit may be.<P>
</UL>
<DL>
<DT><B>IMPORTANT</B>
<DD><A NAME=MARKER-9-159></A>Values for the <CODE>tsdu</CODE> and <CODE>etsdu</CODE> fields of the <CODE>TEndpointInfo</CODE> structure that are returned when you open an endpoint might change after the endpoint is connected, because the endpoint providers can negotiate different values when establishing a connection. If the endpoint supports variable maximum limits for TSDU and ETSDU size, you should call the <CODE>OTGetEndpointInfo</CODE> function after the connection has been established to determine what the current limits are.  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
 To send expedited data, you must set the <A NAME=MARKER-13-37></A><CODE>T_EXPEDITED</CODE> bit in the <CODE>flags</CODE> parameter. If the receiving client is in the middle of reading normal data and the <CODE>OTRcv</CODE> function returns expedited data, the next <CODE>OTRcv</CODE> that returns without <CODE>T_EXPEDITED</CODE> set in the flags field resumes the sending of normal data at the point where it was interrupted. It is the responsibility of the client to remember where that was. <A NAME=MARKER-13-161></A><A NAME=MARKER-13-162></A><P>
 There are two ways of breaking up a data stream into logical size units.<P>
<UL>
<P><LI>If the endpoint supports it, enable the use of the <CODE>T_MORE</CODE> flag bit to the <CODE>OTSnd</CODE> function. Then, when sending the last packet, do not set the <CODE>T_MORE</CODE> bit. Because these packets are guaranteed to be delivered in the order sent, the receiving endpoint can determine when the last packet has arrived by examining this flag bit.
<P><LI>Use the data transferred with your first send to specify the name and size of the data that you want to send. The receiving endpoint can save the size value and decrement it as it receives bytes until the number equals 0. This last method is the only one that is transport-independent. <A NAME=MARKER-13-163></A><A NAME=MARKER-13-164></A><A NAME=MARKER-13-165></A><P>
</UL>
<A NAME=HEADING28-133></A>
<H2><A NAME=MARKER-9-166></A>Transferring Data Between Transaction-Based Endpoints</H2>
 <A NAME=MARKER-13-167></A>Open Transport defines two sets of functions that you can use to perform a transaction. One set is defined for connectionless transactions; the other set is defined for connection-oriented transactions. A <B>transaction</B> is a process during which one endpoint, the <I>requester</I>, sends a request for a service. The remote endpoint, called the <I>responder</I>, reads the request, performs the service, and sends a reply. When the requester receives the reply, the transaction is complete.<A NAME=MARKER-13-168></A><P>
 You can implement applications that use transactions in the following two ways:<P>
<UL>
<P><LI>You can write a single application that handles both the requester and responder actions of a transaction and run that application on two networked nodes. This method allows each application to act as either the requester or the responder. Either side can initiate a transaction, but only one side can control the communication during a single transaction.
<P><LI>You can write two applications, one implementing the requester part of a transaction and the other implementing the responder side. This model lends itself well to a client-server relationship, in which many nodes on a network run the requester application (client), while one or more nodes run the responder application (server); one server can respond to transaction requests from several clients.<P>
</UL>
 Because one endpoint can conduct multiple transactions at any one time, it is crucial that requesters and responders be able to distinguish one transaction from another. This is done by means of a <B>transaction ID,</B> a number that uniquely identifies a transaction. Because this is not the same number for the requester as it is for the responder, some explanation is required. <A HREF=#MARKER-9-170>Figure 4-8</A> shows how the transaction ID is generated by the requesting application and the provider during the course of a transaction.<A NAME=MARKER-13-169></A><P>
<B>Figure 4-8  <A NAME=MARKER-9-170></A>How a transaction ID is generated</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/OTE-L-12.gif"><P>
 The requester initiates a transaction by sending a request. The requester passes information about the request in a data structure that includes a <CODE>seq</CODE> field, which specifies the transaction ID of the request. The requester initializes this field to some arbitrary, unique number. Before sending the request, the endpoint provider saves this number in an internal table and assigns another number to the <CODE>seq</CODE> field, which it guarantees to be unique for the requester's machine. The endpoint provider also saves the new number along with the requester-generated sequence number. For example, in <A HREF=#MARKER-9-170>Figure 4-8</A>, the requester assigns the number 1001; the endpoint provider assigns the number 5123. <P>
 When the responder receives the request, it reads the request information, including the provider-generated sequence number, into buffers it has reserved for the request data. When the responder sends a reply, it specifies the sequence number it read when it received the request.<P>
 Before the requester's endpoint provider advises the requester that the reply has arrived, it examines the sequence number of the reply and looks in its internal table to determine which requester-generated sequence number it matches. It then substitutes that number for the sequence number it received from the responder. By using this method Open Transport guarantees that transactions are uniquely identified, and the requester is able to match incoming replies with outgoing requests. <A NAME=MARKER-13-171></A><P>
<A NAME=HEADING28-144></A>
<H3><A NAME=MARKER-9-172></A>Using Connectionless Transaction-Based Service </H3>
 You use connectionless transaction-based service to enable two connectionless endpoints to complete a transaction. <A NAME=MARKER-13-173></A><P>
 The requester initiates the transaction by calling the <CODE>OTSndURequest</CODE> function. Parameters to the <CODE>OTSndURequest</CODE> function specify the destination address, the request data, any options, and a sequence number to identify this transaction. The requester must supply a sequence number if it is sending multiple requests, so that later on it can match replies to requests. The requester can cancel an outgoing request by calling the <A NAME=MARKER-11-194></A><CODE>OTCancelURequest</CODE> function. A requester can implement its own timeout mechanism (using the function <CODE>OTScheduleTimerTask</CODE>) and calling the <CODE>OTCancelURequest</CODE> function after a specific amount of time has elapsed without a response to the request.<P>
 If the responder is synchronous and blocking, the <CODE>OTRcvURequest</CODE> function returns after it has read the request. If the responder is asynchronous or not blocking and has a notifier installed, the endpoint provider calls the notifier, passing <CODE>T_REQUEST</CODE> for the <CODE>code</CODE> parameter. When the responder receives this event, it must call the <CODE>OTRcvURequest</CODE> function to read the request. On return, parameters to the <CODE>OTRcvURequest</CODE> function specify the address of the requester, option values, the request data, flags information, and a sequence number to identify the transaction. When the responder sends a reply to the request, it must use the same sequence number for the reply. If the responder's buffer is too small to contain the request, the endpoint provider sets the <CODE>T_MORE</CODE> bit in the <CODE>flags</CODE> parameter. The responder must call the <CODE>OTRcvURequest</CODE> function until the <CODE>T_MORE</CODE> bit is clear. This indicates that the entire request has been read.<P>
 Having read the request, the responder can reply to the request using the <CODE>OTSndUReply</CODE> function or reject the request using the <A NAME=MARKER-11-197></A><CODE>OTCancelUReply</CODE> function. Although the requester is not advised that the responder has rejected a request, it's important that the responder explicitly cancel an incoming request in order to free memory reserved by the <CODE>OTRcvURequest</CODE> function.<P>
 If the requester is in synchronous blocking mode, the <A NAME=MARKER-11-191></A><CODE>OTRcvUReply</CODE> function waits until a reply comes in. Otherwise, if a notifier is installed, the endpoint provider calls the notifier, passing <CODE>T_REPLY</CODE> for the <CODE>code</CODE> parameter. The notifier must call the <CODE>OTRcvUReply</CODE> function. On return, parameters to the function specify the address of the endpoint sending the reply, specify option values, flag values, reply data, and a sequence number that identifies the request matching this reply. If the <CODE>T_MORE</CODE> bit is set in the <CODE>flags</CODE> parameter, the requester has allocated a buffer that is too small to contain the reply data. The requester must call the <CODE>OTRcvUReply</CODE> function until the <CODE>T_MORE</CODE> bit is clear; this indicates that the complete reply has been read. <P>
 If the request is rejected or fails in some other way, the requester receives the <CODE>T_REPLY</CODE> event. However, the <CODE>OTRcvUReply</CODE> function returns with the result <A NAME=MARKER-15-59></A><CODE>kETIMEDOUTErr</CODE>. Otherwise, the only useful information returned by the function is the sequence number of the request that has failed.<P>
 <A HREF=#MARKER-9-178>Figure 4-9</A> illustrates how connectionless transaction-based endpoints in asynchronous mode exchange data. <P>
<B>Figure 4-9  Data transfer using connectionless transaction-based endpoints in asynchronous mode</B><BR>
<A NAME=MARKER-9-178></A> <A NAME=MARKER-13-179></A></B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/OTE-L-04.gif"><P>
<A NAME=HEADING28-154></A>
<H3><A NAME=MARKER-9-180></A>Using Connection-Oriented Transaction-Based Service</H3>
 Connection-oriented transaction-based endpoints allow you to transfer data in exactly the same way as connectionless transaction-based endpoints except that, because the endpoints are connected, it is not necessary to specify an address when using the functions to send and receive requests and replies. The only other difference is that a connection-oriented transaction may be interrupted by a connection or disconnection request. <A NAME=MARKER-13-181></A><P>
 The section <A HREF=#MARKER-9-172>"Using Connectionless Transaction-Based Service"</A> describes the sequence of functions used to transfer data using a transaction. <A HREF=#MARKER-9-182>Figure 4-10</A> shows the sequence of functions called during a connection-oriented transaction; both requester and responder are in asynchronous mode. This sequence is the same as for connectionless transaction-based service, as shown in <A HREF=#MARKER-9-178>Figure 4-9 </A>. Of course, you use different functions to complete these two types of transactions: the names of the functions shown in <A HREF=#MARKER-9-182>Figure 4-10</A> do not include a "U" in the function name. <P>
<B>Figure 4-10  Data transfer using connection-oriented transaction-based endpoints in asynchronous mode </B><BR>
<A NAME=MARKER-9-182></A><P>
<IMG ALIGN = BOTTOM SRC = "graphics/OTE-L-07.gif"><P>
 For information about how to handle disconnection requests that might occur during a transaction, see <A HREF=#MARKER-9-133>"Using Orderly Disconnects"</A>. <A NAME=MARKER-13-183></A><A NAME=MARKER-13-184></A><P>
 <P>
<HR>
<B>Subtopics</B>
<B><!-- TOC --><DL>
<DT><A HREF="NetworkingWOT-28.html#HEADING28-5">Opening and Binding Endpoints</A>
<DD>
<DT><A HREF="NetworkingWOT-28.html#HEADING28-18">Obtaining Information About Endpoints</A>
<DD>
<DT><A HREF="NetworkingWOT-28.html#HEADING28-26">Handling Events for Endpoints</A>
<DD>
<DT><A HREF="NetworkingWOT-28.html#HEADING28-32">Clearing Events and Synchronization Problems</A>
<DD>
<DT><A HREF="NetworkingWOT-28.html#HEADING28-35">Notifier Reentrancy</A>
<DD>
<DT><A HREF="NetworkingWOT-28.html#HEADING28-38">Polling for Events</A>
<DD>
<DT><A HREF="NetworkingWOT-28.html#HEADING28-44">Establishing and Terminating Connections</A>
<DD>
<DT><A HREF="NetworkingWOT-28.html#HEADING28-54">Establishing a Connection</A>
<DD>
<DT><A HREF="NetworkingWOT-28.html#HEADING28-66">Sending User Data With Connection or Disconnection Requests</A>
<DD>
<DT><A HREF="NetworkingWOT-28.html#HEADING28-68">Processing Multiple Connection Requests</A>
<DD>
<DT><A HREF="NetworkingWOT-28.html#HEADING28-77">Terminating a Connection</A>
<DD>
<DT><A HREF="NetworkingWOT-28.html#HEADING28-79">Using an Abortive Disconnect</A>
<DD>
<DT><A HREF="NetworkingWOT-28.html#HEADING28-86">Using Orderly Disconnects</A>
<DD>
<DT><A HREF="NetworkingWOT-28.html#HEADING28-96">Sending and Receiving Data</A>
<DD>
<DT><A HREF="NetworkingWOT-28.html#HEADING28-103">Sending Data Using Multiple Sends</A>
<DD>
<DT><A HREF="NetworkingWOT-28.html#HEADING28-110">Receiving Data</A>
<DD>
<DT><A HREF="NetworkingWOT-28.html#HEADING28-112">Transferring Data Between Transactionless Endpoints</A>
<DD>
<DT><A HREF="NetworkingWOT-28.html#HEADING28-114">Using Connectionless Transactionless Service</A>
<DD>
<DT><A HREF="NetworkingWOT-28.html#HEADING28-123"> Using Connection-Oriented Transactionless Service </A>
<DD>
<DT><A HREF="NetworkingWOT-28.html#HEADING28-133">Transferring Data Between Transaction-Based Endpoints</A>
<DD>
<DT><A HREF="NetworkingWOT-28.html#HEADING28-144">Using Connectionless Transaction-Based Service </A>
<DD>
<DT><A HREF="NetworkingWOT-28.html#HEADING28-154">Using Connection-Oriented Transaction-Based Service</A>
<DD>
</DL>
</B>
</BLOCKQUOTE>
<HR>
<center>
<A HREF="NetworkingWOT-27.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="NetworkingWOT-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="NetworkingWOT-491.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A>  <A HREF="NetworkingWOT-29.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="NetworkingWOT-4.html">&copy; Apple Computer, Inc.</A><br>15 JAN 1998<P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML> 
