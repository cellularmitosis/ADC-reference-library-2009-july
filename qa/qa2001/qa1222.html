<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"			"http://www.w3.org/TR/REC-html40/loose.dtd"><HTML><HEAD><LINK REL="stylesheet" HREF="../../adcstyle.css" TYPE="text/css"><LINK REL="stylesheet" HREF="../../style.css" TYPE="text/css"><title>Technical Q&amp;A QA1222: Using Clip Region and Buffer Rectangles with OpenGL Carbon</title><meta name="keywords" content="OpenGL, buffer rect, clip region, aglSetInteger, aglEnable"><meta name="Description" content="Technical Q&amp;A QA1222: This Q&amp;A shows the basics of usingbuffer rectangles and clip regions with AGL."><meta name="categories" content="OpenGL"><meta name="week-posted" content="Dec 16, 2002 - Dec 20, 2002"><LINK REL="stylesheet" HREF="../../css/adcstyle.css" TYPE="text/css"><script language="JavaScript" type="text/javascript" src="../../js/adc.js"></script></HEAD><BODY BGCOLOR="#FFFFFF"><a name="//apple_ref/doc/uid/DTS10001745" title="Using Clip Region and Buffer Rectangles with OpenGL Carbon"></a><!-- top_of_header_marker_comment --><!-- begin_header_information --><!--#include virtual="/adcnavbar" --><p><a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../technicalqas/index.html">Technical Q&As</a> &gt; <a href="../../technicalqas/GraphicsImaging/index.html">Graphics & Imaging</a> &gt; <a href="../../technicalqas/GraphicsImaging/idxOpenGL-date.html">OpenGL</a> &gt; </p><!-- end_header_information --><!-- bottom_of_header_marker_comment --><!-- top_of_titles_marker_comment --><CENTER><table width="600" cellpadding="0" cellspacing="0" border="0">
<tr><td align="left" scope="row">
<h1>
<div id="pagehead">Technical Q&amp;A QA1222</div>
<div id="pageheadsub">Using Clip Region and Buffer Rectangles with OpenGL Carbon</div>
</h1>
</td></tr></table></CENTER><!-- bottom_of_titles_marker_comment --><CENTER><TABLE BORDER=0 CELLSPACING=1 WIDTH=600> <TR> <td align="left"><!-- begin_content --><hr width=500 align=center>         <P id=p2>Q:      How are AGL buffer rectangles and clip regions used?</p>         <P id=p4>A:      Using AGL buffer rectangles and clip regions are very similar operations.      <code>aglSetInteger</code> is used to setup the rectangle or region then      <code>aglEnable</code> or <code>aglDisable</code> is used to turn the      feature on or off for both buffer rectangles and clip regions. Client      applications need to use these per context, for both the enable and the      setting of rectangle or region data.  Note, while applications are the      usual OpenGL client code, the techniques presented here work for other      Carbon OpenGL clients which have a drawable and an associated context.</p><P id=p4>      To use a buffer rectangle with a specific context both the buffer	  rectangle must be enabled and the size must be set.  Listing 1 shows an	  example.</p><BR><CENTER><TABLE BORDER=0 CELLPADDING=4 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>#include &lt;AGL/agl.h&gt;// aglContext must be a valid pre-existing contextshort left = 10, bottom = 10, width = 300, height = 300;GLint bufferRect[4];bufferRect[0] = left; // 0 = left edgebufferRect[1] = bottom; // 0 = bottom edgebufferRect[2] = width; // width of buffer rectbufferRect[3] = height; // height of buffer rectaglSetInteger (aglContext, AGL_BUFFER_RECT, bufferRect);aglEnable (aglContext, AGL_BUFFER_RECT);</pre></TD></TR><TR><td align="left"><P><B>Listing 1</B>.       Buffer Rect Setup</P></TD></TR></TABLE></CENTER><BR><P id=p4>      If the buffer rectangle is window size relative, the       area should also be reset whenever the window size changes, usually along      with the <code>glViewport</code>. It is recommended this be done in      response to <code>kEventWindowShown</code>,      <code>kEventWindowBoundsChanged</code>, <code>kEventWindowZoomed</code>      and <code>kEventWindowResizeCompleted</code> Carbon window events.      Additionally, window content should normally be drawn on      <code>kEventWindowActivated</code>, <code>kEventWindowDrawContent</code>,      and <code>kEventWindowBoundsChanged</code> Carbon window events to ensure      it is always up to date.</p><P id=p4>      Using a clip region with AGL is very similar to using buffer      rectangles. Specifically, a clip region has the same update requirements      as buffer rectangles. To set a clip region, construct a QuickDraw region      which will constrain the OpenGL update that is the region should only      include the parts of the window in which OpenGL should draw. The code in      Listing 2 is an example of this which uses some random geometry and      excludes the bounds rectangles of four predefined controls to construct      the clip region.</p><BR><CENTER><TABLE BORDER=0 CELLPADDING=4 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>#include &lt;AGL/agl.h&gt;#include &lt;Carbon/Carbon.h&gt; static void SetClipRegion (WindowRef win){    RgnHandle       clipRgn = NewRgn();    RgnHandle       maskRgn = NewRgn();    Rectangle       rectPort, bounds = { -32767, -32767, 32767, 32767 };    ControlID       idControl;    ControlRef      control;    GetWindowPortBounds(win, &amp;rectPort);    // set up some random region    SetEmptyRgn (clipRgn);    OpenRgn ();    MoveTo (rectPort.left + 10, rectPort.top + 30);    LineTo (rectPort.right - 20, rectPort.top + 50);    LineTo (rectPort.right - 50, rectPort.bottom - 25);    LineTo (rectPort.left + 10, rectPort.top + 50);    CloseRgn (clipRgn);    // cutouts for existing controls (assuming there are 4 in the window)    idControl.signature = 'cbrt'; // app can use any sig that is used in nib    for (idControl.id = 0; idControl.id &lt; 4; idControl.id++) {        GetControlByID (win, &amp;idControl, &amp;control);        GetControlBounds (control, &amp;bounds);        RectRgn(maskRgn, &amp;bounds);        DiffRgn(clipRgn, maskRgn, clipRgn);    }    // set clip region for AGL    //   aglContext is a valid pre-existing context for this window    aglSetInteger (aglContext, AGL_CLIP_REGION, (const GLint *)clipRgn);    DisposeRgn(clipRgn);    DisposeRgn(maskRgn);}</pre></TD></TR><TR><td align="left"><P><B>Listing 2</B>.       Clip Region Setup</P></TD></TR></TABLE></CENTER><BR><P id=p4>      It is important to understand the region supplied       to AGL via <code>aglSetInteger</code> is created manually and is not      associated with the window's clip or vis region. The window's clip region      could be supplied to AGL but AGL's copy would need to be updated manually      for any clip changes, that is there is no native clip region tracking in      the AGL Framework.  This was done because the QuickDraw clip region for      drawing will likely be an inverse, or close to an inverse, of the region      used for OpenGL drawing since OpenGL will likely draw in the places where      QuickDraw 2D is not drawing. Keeping AGL's region synced with an inverse      of QuickDraw's clip region would be difficult at best, especially with      OpenGL possibly receiving asynchronous updates without application      interaction.  This AGL API is designed for the client application to      provide a region directly with no specific ties to existing window regions      such as the <code>visRgn</code> or <code>clipRgn</code>.</p><P id=p4>      As alluded to above, AGL makes a copy of the region at       the time of the <code>aglSetInteger</code> with      <code>AGL_CLIP_REGION</code> call, so the application is free to dispose      of the region anytime after aglSetInteger returns.  The region copy      operation can be quite costly for complicated regions thus developers      should limit the use of <code>aglSetinteger</code> with      <code>AGL_CLIP_REGION</code> in performance critical code sections.</p><P id=p4>     Remember, clip regions still need to be enabled just as buffer rectangles      do and listing 3 shows an example.</p><BR><CENTER><TABLE BORDER=0 CELLPADDING=4 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>#include &lt;AGL/agl.h&gt;// aglContext is a valid pre-existing contextaglEnable (aglContext, AGL_CLIP_REGION);</pre></TD></TR><TR><td align="left"><P><B>Listing 3</B>.       Enabling a Clip Region</P></TD></TR></TABLE></CENTER><BR><P id=p4>      This enable could have been wrapped into the above	  <code>SetClipRegion</code> code if desired. In this example, a separate	  code section was chosen since the region itself does not need to be reset	  every time the clip region is enabled.  A final note, if a region is	  created relative to the window size, it has the same resize update	  requirements as buffer rectangles.</p><P id=p4>      Both clip regions and buffer rectangles provide AGL applications      with two convenient ways to limit the size and shape of accelerated surface      drawing within a window. This allows the application to draw 2D content in      areas not covered by the accelerated surface. Buffer rectangles are      available in all versions of Mac OS X while clip regions are available in      Mac OS X v10.2 and later.</p><hr width=500 align=center> <!-- begin_date --><H4 ALIGN=center>[Dec 3 2002]</H4><!-- end_date --></TD> </TR> </TABLE></CENTER><!-- begin_footer_information -->	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/qa/qa2001/qa1222.html%3Fid%3DDTS10001745-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/qa/qa2001/qa1222.html%3Fid%3DDTS10001745-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/qa/qa2001/qa1222.html%3Fid%3DDTS10001745-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>
<!--#include virtual="/includes/footer"--><!-- end_footer_information --></BODY></HTML>