<html>

<body bgcolor="#FFFFFF">

<CENTER><H1>Class next.util.NextObject</H1></CENTER>

<a name="description"></a><CENTER><H2>CLASS DESCRIPTION</H2></CENTER>

<!-- extends:java.lang.Object -->

<DL>

<DT><B>Extends:</B></DT><DD>java.lang.Object</DD>

</DL>

<P>

<DL>

<DT><B>Implements:</B></DT>

<!-- implements:java/lang/Cloneable -->

<DD>java/lang/Cloneable</DD><BR>

<!-- implements:next/util/KeyValueCoding  -->

<DD>next/util/KeyValueCoding </DD><BR>

</DL>

<P>

NextObject is the superclass of many of the classes in this package. From NextObject, other classes inherit a basic interface to the run-time system, and its instances enhance their ability to behave as objects.
<P>
Among other things, the NextObject class provides inheriting classes with a framework for creating, initializing, finalizing, copying, comparing, archiving and distributing objects, for performing methods selected at run-time. For example, to find out whether it implements a particular method, you'd send it a <B>respondsToMethod</B> message.
<P>
The NextObject class is mostly an abstract class; programs use instances of classes that inherit from NextObject, but rarely instances of NextObject itself.
<P>
The NextObject class defines a number of methods that subclasses are expected to override. Often, NextObject's default implementation simply returns the receiving object. Putting these "empty" methods in the NextObject class serves two purposes:
<UL>
<LI>It means that every object can readily respond to certain standard messages, even if the response is to do nothing. It's not necessary to check (using <B>respondsToMethod</B>) before sending the message.
<LI>It establishes conventions that, when followed by all classes, make object interactions more reliable. These conventions are explained in full under the method descriptions.
</UL>
<hr>

</body>

</html><html>

<body bgcolor="#FFFFFF"><!-- constructors -->

<a name="constructors"><CENTER><H2>CONSTRUCTORS</H2></CENTER></a>

<!-- consKey:NextObject(public) cons:NextObject descr:<TT>public  <B>NextObject</B>()</TT> -->

<H3><a name="NextObject(public)">NextObject</a></H3>

   <TT>public  <B>NextObject</B>()</TT>

<P>

Returns a newly-allocated and initialized object of the NextObject class.
<P>

<!-- <B>See Also: </B>[See Also's go here] -->

<hr>

</body>

</html><html>

<body bgcolor="#FFFFFF"><!-- methods -->

<a name="methods"><CENTER><H2>METHODS</H2></CENTER></a>

<!-- methKey:awakeAfterUsingCoder(public) meth:awakeAfterUsingCoder descr:<TT>public java.lang.Object <B>awakeAfterUsingCoder</B>(next.util.Coder <I>aCoder</I>)</TT> -->

<H3><a name="awakeAfterUsingCoder(public)">awakeAfterUsingCoder</a></H3>

<TT>public java.lang.Object <B>awakeAfterUsingCoder</B>(next.util.Coder <I>aCoder</I>)</TT>

<P>

Overridden by subclasses to return another object in its place after being decoded. Perhaps this object was just unarchived and an equivalent object already exists (such as a font or image). By returning a replacement object, redundant objects can be eliminated. If a replacement is returned, this method implementation is responsible for releasing the receiver. This method is invoked by Coder. NextObject's implementation simply returns the receiver. 
<P>

<!-- <B>See Also: </B>[See Also's go here] -->

<hr>

<!-- methKey:clone(public) meth:clone descr:<TT>public java.lang.Object <B>clone</B>()</TT> -->

<H3><a name="clone(public)">clone</a></H3>

<TT>public java.lang.Object <B>clone</B>()</TT>

<P>

Returns a new instance that's a copy of the receiver. The copy returned is immutable if the consideration "immutable vs. mutable" applies to the receiving object; otherwise the exact nature of the copy is determined by the class. 
<P>

<!-- <B>See Also: </B>[See Also's go here] -->

<hr>

<!-- methKey:equals(public) meth:equals descr:<TT>public boolean <B>equals</B>(java.lang.Object <I>anObject</I>)</TT> -->

<H3><a name="equals(public)">equals</a></H3>

<TT>public boolean <B>equals</B>(java.lang.Object <I>anObject</I>)</TT>

<P>

Returns <B>true</B> if the receiver and <I>anObject</I> are equal, <B>false</B> otherwise. NextObject's implementation compares the id of <I>anObject</I> and the receiver to determine equality. Subclasses can override this method to redefine what it means for objects to be equal. For example, a container object might define two containers as equal if they contain the same contents. Note that equality as defined by this method is not necessarily reflexive. For example, A is equal to B, does not imply B is equal to A, especially if B is a subclass of A.
<P>

<!-- <B>See Also: </B>[See Also's go here] -->

<hr>

<!-- methKey:finalize(protected) meth:finalize descr:<TT>protected void <B>finalize</B>()</TT> -->

<H3><a name="finalize(protected)">finalize</a></H3>

<TT>protected void <B>finalize</B>()</TT>

<P>

Releases any corresponding Objective-C object when the Java object is garbage collected.
<P>

<!-- <B>See Also: </B>[See Also's go here] -->

<hr>

<!-- methKey:hashCode(public) meth:hashCode descr:<TT>public int <B>hashCode</B>()</TT> -->

<H3><a name="hashCode(public)">hashCode</a></H3>

<TT>public int <B>hashCode</B>()</TT>

<P>

Returns an integer that can be used as a table address in a hash table structure. NextObject's implementation returns a value based on the object's id. If two objects are equal (as determined by the <B>equal</B> method), they must return the same hash value. This last point is particularly important if you define hash in a subclass and intend to put instances of that subclass into a collection.
<P>

<!-- <B>See Also: </B>[See Also's go here] -->

<hr>

<!-- methKey:loadLibrary(public) meth:loadLibrary descr:<TT>public static void <B>loadLibrary</B>(java.lang.String <I>aString</I>)</TT> -->

<H3><a name="loadLibrary(public)">loadLibrary</a></H3>

<TT>public static void <B>loadLibrary</B>(java.lang.String <I>libraryName</I>)</TT>

<P>

Loads a library and calls the library's initialization function.  The name of the initialization function is constructed by appending "Initialize" to the name of the library and removing extensions like ".dll".
<P>
Note that libraries generated by bridget must be loaded using NextObject. loadLibrary rather than Runtime.loadLibrary, because the former performs initialization needed by bridget. NextObject.loadLibrary is idempotent--it will only load a requested library once so that it can, for example, be called from static initializers in many different classes.
<P>

<!-- <B>See Also: </B>[See Also's go here] -->

<hr>

<!-- methKey:nextRootPath(public) meth:nextRootPath descr:<TT>public final static java.lang.String <B>nextRootPath</B>()</TT> -->

<H3><a name="nextRootPath(public)">nextRootPath</a></H3>

<TT>public final static java.lang.String <B>nextRootPath</B>()</TT>

<P>

Returns as a string the path to the $NEXT_ROOT directory--the directory in which WebObjects or OPENSTEP Enterprise was installed. This directory is usually something like "C:\Next".
<P>

<!-- <B>See Also: </B>[See Also's go here] -->

<hr>

<!-- methKey:performMethod(public) meth:performMethod descr:<TT>public next.util.NextObject <B>performMethod</B>(java.lang.String <I>aString</I>)</TT> -->

<H3><a name="performMethod(public)">performMethod</a></H3>

<TT>public next.util.NextObject <B>performMethod</B>(java.lang.String <I>methodName</I>)</TT>

<P>

Sends a <I>methodName</I> message to the receiver and returns the result of the message.  If <I>methodName</I> is NULL, an exception is raised.
<P>
<B>performMethod</B> is equivalent to sending a <I>methodName</I> message directly to the receiver.<!--  For example, all three of the following messages do the same thing:
id myClone = [anObject copy];
id myClone = [anObject performSelector:@selector(copy)];
id myClone = [anObject performSelector:sel_getUid("copy")];
--> 
However, <B>performMethod</B> allows you to send messages that aren't determined until run time.<!--  A variable selector can be passed as the argument:
SEL myMethod = findTheAppropriateSelectorForTheCurrentSituation();
[anObject performSelector:myMethod];
--> 
<P>
<I>methodName</I> should identify a method that takes no arguments.<!--  For methods that return anything other than an object, use NSInvocation.
--> 
<P>

<!-- <B>See Also: </B>[See Also's go here] -->

<hr>

<!-- methKey:performMethodWithObject(public) meth:performMethodWithObject descr:<TT>public next.util.NextObject <B>performMethodWithObject</B>(java.lang.String <I>aString</I>, java.lang.Object <I>anObject</I>)</TT> -->

<H3><a name="performMethodWithObject(public)">performMethodWithObject</a></H3>

<TT>public next.util.NextObject <B>performMethodWithObject</B>(java.lang.String <I>methodName</I>, java.lang.Object <I>anObject</I>)</TT>

<P>

Sends a <I>methodName</I> message to the receiver with <I>anObject</I> as the argument. If <I>methodName</I> is NULL, an exception is raised.
<P>
This method is the same as <B>performMethod</B> except that you can supply an argument for <I>methodName</I>. <I>methodName</I> should identify a method that takes a single argument of type java.lang.Object.
<P>

<!-- <B>See Also: </B>[See Also's go here] -->

<hr>

<!-- methKey:performMethodWithObjects(public) meth:performMethodWithObjects descr:<TT>public next.util.NextObject <B>performMethodWithObjects</B>(java.lang.String <I>aString</I>, java.lang.Object <I>anObject</I>, java.lang.Object <I>anObject</I>)</TT> -->

<H3><a name="performMethodWithObjects(public)">performMethodWithObjects</a></H3>

<TT>public next.util.NextObject <B>performMethodWithObjects</B>(java.lang.String <I>methodName</I>, java.lang.Object <I>anObject</I>, java.lang.Object <I>anotherObject</I>)</TT>

<P>

Sends the receiver an <I>methodName</I> message with <I>anObject</I> and <I>anotherObject</I> as arguments. If <I>methodName</I> is NULL, an exception is raised. 
<P>
This method is the same as <B>performMethod</B> except that you can supply two arguments for <I>methodName</I>. <I>methodName</I> should identify a method that can take two arguments of type next.java.Object.
<P>

<!-- <B>See Also: </B>[See Also's go here] -->

<hr>

<!-- methKey:replacementObjectForArchiver(public) meth:replacementObjectForArchiver descr:<TT>public next.util.Coding <B>replacementObjectForArchiver</B>(next.util.Coder <I>aCoder</I>)</TT> -->

<H3><a name="replacementObjectForArchiver(public)">replacementObjectForArchiver</a></H3>

<TT>public next.util.Coding <B>replacementObjectForArchiver</B>(next.util.Coder <I>aCoder</I>)</TT>

<P>

Overridden by subclasses to substitute another object for itself during archiving. See the <B>replacementObjectForArchiver:</B> method description in the NSObject class specification (in the <I>Foundation Framework Reference</I>) for implementation information.
<P>

<!-- <B>See Also: </B>[See Also's go here] -->

<hr>

<!-- methKey:replacementObjectForPortCoder(public) meth:replacementObjectForPortCoder descr:<TT>public next.util.Coding <B>replacementObjectForPortCoder</B>(next.util.Coder <I>aCoder</I>)</TT> -->

<H3><a name="replacementObjectForPortCoder(public)">replacementObjectForPortCoder</a></H3>

<TT>public next.util.Coding <B>replacementObjectForPortCoder</B>(next.util.Coder <I>aCoder</I>)</TT>

<P>

Overridden by subclasses to substitute another object or a copy for itself during distribution encoding. See the <B>replacementObjectForPortCoder:</B> method description in the NSObject class specification (in the <I>Foundation Framework Reference</I>) for implementation information.
<P>

<!-- <B>See Also: </B>[See Also's go here] -->

<hr>

<!-- methKey:respondsToMethod(public) meth:respondsToMethod descr:<TT>public boolean <B>respondsToMethod</B>(java.lang.String <I>aString</I>)</TT> -->

<H3><a name="respondsToMethod(public)">respondsToMethod</a></H3>

<TT>public boolean <B>respondsToMethod</B>(java.lang.String <I>methodName</I>)</TT>

<P>

Returns <B>true</B> if the receiver implements or inherits a method that can respond to <I>methodName</I> messages, <B>false</B> otherwise. The application is responsible for determining whether a <B>false</B> response should be considered an error.
<P>
Note that if the receiver is able to forward <I>methodName</I> messages to another object, it will be able to respond to the message, albeit indirectly, even though this method returns <B>false</B>.
<P>

<!-- <B>See Also: </B>[See Also's go here] -->

<hr>

<!-- methKey:takeValueForKey(public) meth:takeValueForKey descr:<TT>public void <B>takeValueForKey</B>(java.lang.Object <I>anObject</I>, java.lang.String <I>aString</I>)</TT> -->

<H3><a name="takeValueForKey(public)">takeValueForKey</a></H3>

<TT>public void <B>takeValueForKey</B>(java.lang.Object <I>anObject</I>, java.lang.String <I>key</I>)</TT>

<P>

Sets the value for the property identified by <I>key</I> to <I>anObject</I>. See the KeyValueCoding interface description for more information.
<P>

<!-- <B>See Also: </B>[See Also's go here] -->

<hr>

<!-- methKey:toString(public) meth:toString descr:<TT>public java.lang.String <B>toString</B>()</TT> -->

<H3><a name="toString(public)">toString</a></H3>

<TT>public java.lang.String <B>toString</B>()</TT>

<P>

Returns a String object that describes the contents of the receiver. <B>gdb</B>'s print-object command indirectly invokes this method to produce a textual description of an object.
<P>

<!-- <B>See Also: </B>[See Also's go here] -->

<hr>

<!-- methKey:valueForKey(public) meth:valueForKey descr:<TT>public java.lang.Object <B>valueForKey</B>(java.lang.String <I>aString</I>)</TT> -->

<H3><a name="valueForKey(public)">valueForKey</a></H3>

<TT>public java.lang.Object <B>valueForKey</B>(java.lang.String <I>key</I>)</TT>

<P>

Returns the value for the property identified by <I>key</I>. See the KeyValueCoding interface description for more information.
<P>

<!-- <B>See Also: </B>[See Also's go here] -->

<hr>

</body>

</html>