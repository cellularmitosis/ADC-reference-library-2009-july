<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>Plug-in  - Sample Renderer - /Source/SR.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxGraphicsImaging-date.html">Graphics & Imaging</a> &gt; <A HREF="javascript:location.replace('index.html');">Plug-in  - Sample Renderer</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/GraphicsImaging/index.html" target="_blank">Reference Library > Graphics & Imaging</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">Plug-in  - Sample Renderer</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/Source/SR.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/Headers/resource.h</option>
<option value="listing2.html">/Headers/SR.h</option>
<option value="listing3.html">/Headers/SR_ClipUtilities.h</option>
<option value="listing4.html">/Headers/SR_ConfigData.h</option>
<option value="listing5.html">/Headers/SR_MacDialog.h</option>
<option value="listing6.html">/Headers/SR_Marker.h</option>
<option value="listing7.html">/Headers/SR_MarkerRenderer.h</option>
<option value="listing8.html">/Headers/SR_Math.h</option>
<option value="listing9.html">/Headers/SR_PixmapMarkerRenderer.h</option>
<option value="listing10.html">/Headers/SR_PrefixFile.h</option>
<option value="listing11.html">/Headers/SR_Rasterizers.h</option>
<option value="listing12.html">/Headers/SR_WinDialog.h</option>
<option value="listing13.html">/Source/SR.c</option>
<option value="listing14.html">/Source/SR_ClipUtilities.c</option>
<option value="listing15.html">/Source/SR_ConfigData.c</option>
<option value="listing16.html">/Source/SR_Line.c</option>
<option value="listing17.html">/Source/SR_LinePipe.c</option>
<option value="listing18.html">/Source/SR_MacDialog.c</option>
<option value="listing19.html">/Source/SR_Marker.c</option>
<option value="listing20.html">/Source/SR_MarkerRasterize_32.c</option>
<option value="listing21.html">/Source/SR_MarkerRasterize_8.c</option>
<option value="listing22.html">/Source/SR_Math.c</option>
<option value="listing23.html">/Source/SR_PipelineSetup.c</option>
<option value="listing24.html">/Source/SR_PixmapMarker.c</option>
<option value="listing25.html">/Source/SR_PixmapMarkerRasterize_32.c</option>
<option value="listing26.html">/Source/SR_PixmapMarkerRasterize_8.c</option>
<option value="listing27.html">/Source/SR_Point.c</option>
<option value="listing28.html">/Source/SR_PointPipe.c</option>
<option value="listing29.html">/Source/SR_Rasterizers.c</option>
<option value="listing30.html">/Source/SR_Triangle.c</option>
<option value="listing31.html">/Source/SR_WinDialog.c</option></select>
				</p>
				</form>
				<p><strong><a href="Plug-in__-_Sample_Renderer.zip">Download Sample</a></strong> (&#147;Plug-in__-_Sample_Renderer.zip&#148;, 101.9K)<BR>
<strong><a href="Plug-in__-_Sample_Renderer.dmg">Download Sample</a></strong> (&#147;Plug-in__-_Sample_Renderer.dmg&#148;, 165.9K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/****************************************************************************** **                                       ** **   Module:    SR.c                           ** **                                      ** **                                      ** **   Purpose:   Generic sample renderer routines              ** **                                      ** **                                      ** **                                      ** **   Copyright (C) 1996 Apple Computer, Inc.  All rights reserved.      ** **                                      ** **                                      ** *****************************************************************************/  #include &lt;assert.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &quot;QD3D.h&quot;#include &quot;QD3DErrors.h&quot;#include &quot;QD3DView.h&quot;#include &quot;QD3DDrawContext.h&quot;#include &quot;QD3DRenderer.h&quot;#include &quot;QD3DExtension.h&quot;#include &quot;QD3DIO.h&quot;#include &quot;SR.h&quot;#include &quot;SR_Rasterizers.h&quot;#include &quot;SR_ConfigData.h&quot;#if defined(WINDOW_SYSTEM_MACINTOSH) &amp;&amp; WINDOW_SYSTEM_MACINTOSH#include &lt;Resources.h&gt;#include &lt;Aliases.h&gt;#include &quot;SR_MacDialog.h&quot;#elif defined(WINDOW_SYSTEM_WIN32) &amp;&amp; WINDOW_SYSTEM_WIN32#include &quot;SR_WinDialog.h&quot;#endif  /*  WINDOW_SYSTEM_MACINTOSH  *//****************************************************************************** **                                       ** **              Forward Declarations               ** **                                       ** *****************************************************************************/#if defined(WINDOW_SYSTEM_MACINTOSH) &amp;&amp; WINDOW_SYSTEM_MACINTOSH/* *  Shared library initialization entry point */OSErr SR_Initialize(   const CFragInitBlock  *initBlock);#elif defined(WINDOW_SYSTEM_WIN32) &amp;&amp; WINDOW_SYSTEM_WIN32#endif  /*  WINDOW_SYSTEM_MACINTOSH  *//* *  Shared library exit function */TQ3Status SR_Exit(   void);/* *  IO Functions */static TQ3RendererObject SR_Read(  TQ3FileObject    file);  static TQ3Status SR_Traverse(  TQ3RendererObject  renderer,  void        *unused,  TQ3ViewObject    view);#if defined(WINDOW_SYSTEM_MACINTOSH) &amp;&amp; WINDOW_SYSTEM_MACINTOSH/* * Macintosh resource fork functions */static OSErr SR_CreateAliasHandle(   const CFragInitBlock  *initBlock);  static TQ3Status SR_FreeAliasHandle(  void);#endif  /*  WINDOW_SYSTEM_MACINTOSH  *//****************************************************************************** **                                       ** **                  Globals                   ** **                                       ** *****************************************************************************/static TQ3XObjectClass  SRgRendererClass;static TQ3ObjectType  SRgClassType;static unsigned long   SRgSharedLibrary = NULL;#if defined(WINDOW_SYSTEM_MACINTOSH) &amp;&amp; WINDOW_SYSTEM_MACINTOSHAliasHandle SRgAliasHandle = NULL;#endif  /*  WINDOW_SYSTEM_MACINTOSH  *//****************************************************************************** **                                       ** **              Sample Renderer routines             ** **                                       ** *****************************************************************************//*===========================================================================*\ * *  Routine:  SR_IdleProgress() * *  Comments:  Every n primitives, call the view's idle progress method. *\*===========================================================================*/TQ3Status SR_IdleProgress(  TQ3ViewObject  view,  TSRPrivate    *srPrivate){  srPrivate-&gt;primitiveCount++;    if (srPrivate-&gt;primitiveCount % 10000 == 0) {    return (Q3XView_IdleProgress(view, 0, 0));  } else {    return (kQ3Success);  }}/*===========================================================================*\ * *  Routine:  SR_UpdateRasterFunctions() * *  Comments:  Depending on pixel type, assign rasterization routines for *        the cases of clipped and not clipped (windows). In the *        case of unsupported pixel types, set rasterizers to NULL *        NULL functions. *\*===========================================================================*/TQ3Status SR_UpdateRasterFunctions(    TSRPrivate    *srPrivate){  TQ3XClipMaskState      clipMaskState;  TQ3XDrawRegionDescriptor  *descriptor;    assert(srPrivate != NULL);  descriptor = srPrivate-&gt;descriptor;    switch (descriptor-&gt;pixelType) {    case kQ3XDevicePixelTypeARGB32  :    case kQ3XDevicePixelTypeRGB32  : {      srPrivate-&gt;rasterFunctions[SRcRasterBasic].lineFunction     =         SRLine_Rasterize_32;      srPrivate-&gt;rasterFunctions[SRcRasterBasic].pointFunction     =         SRPoint_Rasterize_32;      srPrivate-&gt;rasterFunctions[SRcRasterBasic].markerFunction     =         SRMarker_Rasterize_32;      srPrivate-&gt;rasterFunctions[SRcRasterBasic].pixmapMarkerFunction  =         SRPixmapMarker_Rasterize_32;      srPrivate-&gt;rasterFunctions[SRcRasterClip].lineFunction       =         SRLine_Rasterize_32_WClip;      srPrivate-&gt;rasterFunctions[SRcRasterClip].pointFunction     =         SRPoint_Rasterize_32_WClip;      srPrivate-&gt;rasterFunctions[SRcRasterClip].markerFunction    =         SRMarker_Rasterize_32_WClip;      srPrivate-&gt;rasterFunctions[SRcRasterClip].pixmapMarkerFunction  =         SRPixmapMarker_Rasterize_32_WClip;      break;    }    case kQ3XDevicePixelTypeIndexed8: {      srPrivate-&gt;rasterFunctions[SRcRasterBasic].lineFunction     =         SRLine_Rasterize_8;      srPrivate-&gt;rasterFunctions[SRcRasterBasic].pointFunction     =         SRPoint_Rasterize_8;      srPrivate-&gt;rasterFunctions[SRcRasterBasic].markerFunction     =         SRMarker_Rasterize_8;      srPrivate-&gt;rasterFunctions[SRcRasterBasic].pixmapMarkerFunction =         SRPixmapMarker_Rasterize_8;      srPrivate-&gt;rasterFunctions[SRcRasterClip].lineFunction       =         SRLine_Rasterize_8_WClip;      srPrivate-&gt;rasterFunctions[SRcRasterClip].pointFunction     =         SRPoint_Rasterize_8_WClip;      srPrivate-&gt;rasterFunctions[SRcRasterClip].markerFunction     =         SRMarker_Rasterize_8_WClip;      srPrivate-&gt;rasterFunctions[SRcRasterClip].pixmapMarkerFunction  =         SRPixmapMarker_Rasterize_8_WClip;            break;    }    default: {      srPrivate-&gt;rasterFunctions[SRcRasterBasic].lineFunction     =         SRLine_Rasterize_Null;      srPrivate-&gt;rasterFunctions[SRcRasterBasic].pointFunction     =         SRPoint_Rasterize_Null;      srPrivate-&gt;rasterFunctions[SRcRasterClip].markerFunction     =         SRMarker_Rasterize_Null;      srPrivate-&gt;rasterFunctions[SRcRasterBasic].pixmapMarkerFunction =         SRPixmapMarker_Rasterize_Null;      srPrivate-&gt;rasterFunctions[SRcRasterClip].lineFunction       =         SRLine_Rasterize_Null;      srPrivate-&gt;rasterFunctions[SRcRasterClip].pointFunction     =         SRPoint_Rasterize_Null;      srPrivate-&gt;rasterFunctions[SRcRasterClip].markerFunction     =         SRMarker_Rasterize_Null;      srPrivate-&gt;rasterFunctions[SRcRasterClip].pixmapMarkerFunction   =         SRPixmapMarker_Rasterize_Null;      fprintf(stderr, &quot;unsupported pixel depth/type\n&quot;);            break;    }  }    /*   *  Check if we're clipped or not, and set up the current raster function   *  vector to the appropriate function vector.   */  if (Q3XDrawRegion_GetClipFlags(      srPrivate-&gt;drawRegion,       &amp;clipMaskState) == kQ3Failure) {    return (kQ3Failure);  }      if (clipMaskState == kQ3XClipMaskFullyExposed) {    srPrivate-&gt;currentRasterFunctions =       &amp;(srPrivate-&gt;rasterFunctions[SRcRasterBasic]);  } else {    srPrivate-&gt;currentRasterFunctions =       &amp;(srPrivate-&gt;rasterFunctions[SRcRasterClip]);  }    return (kQ3Success);}/*===========================================================================*\ * *  Routine:  SR_New() * *  Comments:  Initialize the private state. *\*===========================================================================*/static TQ3Status SR_New(  TQ3RendererObject     renderer,  TSRPrivate        *srPrivate,  void          *initData){  UNUSED(renderer);  UNUSED(initData);    assert(renderer != NULL);  assert(srPrivate != NULL);  /*   *  Zero everything out.   */  memset(srPrivate, 0, sizeof(*srPrivate));      /*   *  Set the rasterizers to the &quot;null&quot; rasterization functions.   */  srPrivate-&gt;rasterFunctions[SRcRasterBasic].lineFunction     =     SRLine_Rasterize_Null;  srPrivate-&gt;rasterFunctions[SRcRasterBasic].pointFunction     =     SRPoint_Rasterize_Null;  srPrivate-&gt;rasterFunctions[SRcRasterBasic].markerFunction     =     SRMarker_Rasterize_Null;  srPrivate-&gt;rasterFunctions[SRcRasterBasic].pixmapMarkerFunction =     SRPixmapMarker_Rasterize_Null;  srPrivate-&gt;rasterFunctions[SRcRasterClip].lineFunction       =     SRLine_Rasterize_Null;  srPrivate-&gt;rasterFunctions[SRcRasterClip].pointFunction     =     SRPoint_Rasterize_Null;  srPrivate-&gt;rasterFunctions[SRcRasterClip].markerFunction     =     SRMarker_Rasterize_Null;  srPrivate-&gt;rasterFunctions[SRcRasterClip].pixmapMarkerFunction   =     SRPixmapMarker_Rasterize_Null;      return (kQ3Success);}/*===========================================================================*\ * *  Routine:  SR_Delete() * *  Comments:  Get rid of anything we have a reference to. *\*===========================================================================*/static void SR_Delete(  TQ3RendererObject  renderer,  TSRPrivate      *srPrivate){  UNUSED(renderer);    assert(renderer != NULL);  assert(srPrivate != NULL);    if (srPrivate-&gt;viewHighlightAttributeSet != NULL) {    Q3Object_Dispose(srPrivate-&gt;viewHighlightAttributeSet);    srPrivate-&gt;viewHighlightAttributeSet = NULL;  }    if (srPrivate-&gt;camera != NULL) {    Q3Object_Dispose(srPrivate-&gt;camera);    srPrivate-&gt;camera = NULL;  }}/*===========================================================================*\ * *  Routine:  SR_StartFrame() * *  Comments:  Called by the View at the start of the frame, set up *        the initial data. *\*===========================================================================*/static TQ3Status SR_StartFrame(  TQ3ViewObject      view,  TSRPrivate         *srPrivate,  TQ3DrawContextObject  drawContext){  TQ3CameraObject    camera;  TQ3XDrawRegion    drawRegion;  TQ3Boolean      isActive;    UNUSED(view);    assert(view != NULL);  assert(srPrivate != NULL);  assert(drawContext != NULL);      if (Q3View_GetCamera(view, &amp;camera) == kQ3Failure) {    return (kQ3Failure);  }  assert(camera != NULL);    /*   *  Set primitive counter to zero   */  srPrivate-&gt;primitiveCount = 0;    /*   *  Initial camera and transform setup   */  SR_SetupPipelineInitCamera(srPrivate, camera);  Q3Object_Dispose(camera);    /*   *  Get the current draw context   */  srPrivate-&gt;currentDrawContext = Q3Shared_GetReference(drawContext);  /*   *  Clear update flags   */  Q3XDrawContext_ClearValidationFlags(srPrivate-&gt;currentDrawContext);  /*   *  Get the first draw region   */  Q3XDrawContext_GetDrawRegion(    srPrivate-&gt;currentDrawContext,    &amp;drawRegion);    Q3XDrawRegion_IsActive(drawRegion, &amp;isActive);  if (isActive != kQ3True) {    /*      *  Need to find the first active region if there is one      */    while (drawRegion != NULL) {      Q3XDrawRegion_GetNextRegion(drawRegion, &amp;drawRegion);      if (drawRegion != NULL) {        Q3XDrawRegion_IsActive(drawRegion, &amp;isActive);        if (isActive) {          break;        }      }        }  }    if (drawRegion != NULL) {    Q3XDrawRegion_IsActive(drawRegion, &amp;isActive);    if (isActive) {      srPrivate-&gt;drawRegion = drawRegion;    } else {      srPrivate-&gt;drawRegion = NULL;    }  } else {     srPrivate-&gt;drawRegion = NULL;  }    srPrivate-&gt;descriptor   = NULL;  srPrivate-&gt;image    = NULL;          return (kQ3Success);}/*===========================================================================*\ * *  Routine:  SR_Pass() * *  Comments:  Called at the start of each pass. *\*===========================================================================*/ static TQ3Status SR_Pass(  TQ3ViewObject      view,  TSRPrivate         *srPrivate,  TQ3CameraObject      camera,  TQ3GroupObject      lightGroup){  TQ3Boolean  isActive;    UNUSED(view);  UNUSED(lightGroup);  UNUSED(camera);    assert(srPrivate != NULL);    if (srPrivate-&gt;drawRegion == NULL) {    /*     *  No active region     */    return (kQ3Success);  }    /*   *  Call the &quot;startRegion&quot; function, if there is one.   */  Q3XDrawRegion_IsActive(srPrivate-&gt;drawRegion, &amp;isActive);    if (isActive) {    TQ3XClipMaskState clipMaskState;        /*     *  Get the descriptor, and tell the draw region you're starting up     */    if (Q3XDrawRegion_StartAccessToImageBuffer(        srPrivate-&gt;drawRegion,        kQ3XDrawRegionServicesClearFlag,         &amp;srPrivate-&gt;descriptor,         &amp;srPrivate-&gt;image) == kQ3Failure) {      goto errorCondition;    }        /*     *  Find out if you're exposed or not. If not exposed, no need to go      *  any further.     */    Q3XDrawRegion_GetClipFlags(      srPrivate-&gt;drawRegion,       &amp;clipMaskState);    if (clipMaskState == kQ3XClipMaskNotExposed) {      return (kQ3Success);    }        /*     *  Make sure we've got a raster to draw to     */    assert(srPrivate-&gt;image);    if (srPrivate-&gt;image == NULL) {      goto errorCondition;    }    /*     *  Set up the frustum-to-device transformation     */    SR_SetupRegionDependentTransformations(srPrivate);    if (SR_UpdateRasterFunctions(srPrivate) == kQ3Failure) {      goto errorCondition;    }  }  return (kQ3Success);errorCondition:  /*   *  On error, set rasterizer vector entries to NULL functions.   */  srPrivate-&gt;rasterFunctions[SRcRasterBasic].lineFunction     =     SRLine_Rasterize_Null;  srPrivate-&gt;rasterFunctions[SRcRasterBasic].pointFunction     =     SRPoint_Rasterize_Null;  srPrivate-&gt;rasterFunctions[SRcRasterBasic].markerFunction     =     SRMarker_Rasterize_Null;  srPrivate-&gt;rasterFunctions[SRcRasterBasic].pixmapMarkerFunction =     SRPixmapMarker_Rasterize_Null;  srPrivate-&gt;rasterFunctions[SRcRasterClip].lineFunction       =     SRLine_Rasterize_Null;  srPrivate-&gt;rasterFunctions[SRcRasterClip].pointFunction     =     SRPoint_Rasterize_Null;  srPrivate-&gt;rasterFunctions[SRcRasterClip].markerFunction     =       SRMarker_Rasterize_Null;  srPrivate-&gt;rasterFunctions[SRcRasterClip].pixmapMarkerFunction   =     SRPixmapMarker_Rasterize_Null;    return (kQ3Failure);}/*===========================================================================*\ * *  Routine:  SR_EndPass() * *  Comments:  Called by the view at the end of each pass. Multiple passes *        will be used if we have multiple draw regions (i.e., there is *        more than one monitor) *\*===========================================================================*/static TQ3ViewStatus SR_EndPass(  TQ3ViewObject   view,  TSRPrivate     *srPrivate){  TQ3XDrawRegion    currentRegion;  TQ3Boolean      isActive;    UNUSED(view);    assert(srPrivate != NULL);  if (srPrivate-&gt;drawRegion) {    /*     *  We are done with this region, call the &quot;endRegion&quot; function,      *  if there is one.     */    if (Q3XDrawRegion_IsActive(        srPrivate-&gt;drawRegion,         &amp;isActive) == kQ3Failure) {      return (kQ3ViewStatusError);    }    if (isActive) {      if (Q3XDrawRegion_End(          srPrivate-&gt;drawRegion) == kQ3Failure) {        return (kQ3ViewStatusError);      }    }      /*      *  If there is more than one device, request another pass      *  for the next device      */    if (Q3XDrawRegion_GetNextRegion(        srPrivate-&gt;drawRegion,         &amp;currentRegion) == kQ3Failure) {      return (kQ3ViewStatusError);    }             while (currentRegion != NULL) {      if (Q3XDrawRegion_IsActive(          currentRegion,           &amp;isActive) == kQ3Failure) {        return (kQ3ViewStatusError);      }      if (isActive) {        srPrivate-&gt;drawRegion = currentRegion;        return (kQ3ViewStatusRetraverse);      }            if (Q3XDrawRegion_GetNextRegion(          currentRegion,           &amp;currentRegion) == kQ3Failure) {        return (kQ3ViewStatusError);      }    }   }      SR_SetupPipelineExit(srPrivate);  /*   *  We are done with the draw context   */  Q3Object_Dispose(srPrivate-&gt;currentDrawContext);  srPrivate-&gt;currentDrawContext = NULL;    return (kQ3ViewStatusDone);}/*===========================================================================*\ * *  Routine:  SR_Cancel() * *  Comments:  Called when the view is cancelled. Dispose of the reference *        to the draw context. *\*===========================================================================*/static void SR_Cancel(  TQ3ViewObject   view,  TSRPrivate    *srPrivate){  UNUSED(view);    assert(srPrivate != NULL);  SR_SetupPipelineExit(srPrivate);  /*   *  We are done with the draw context   */  if (srPrivate-&gt;currentDrawContext) {    Q3Object_Dispose(srPrivate-&gt;currentDrawContext);    srPrivate-&gt;currentDrawContext = NULL;  }}/*===========================================================================*\ * *  Routine:  SR_Geometry_MetaHandler() * *  Comments:  Provide entry points for geometric primitive rendering *        functions. *\*===========================================================================*/static TQ3XFunctionPointer SR_Geometry_MetaHandler(  TQ3XMethodType      methodType){  switch (methodType) {    case kQ3GeometryTypeLine: {      return (TQ3XFunctionPointer) SR_Geometry_Line;      break;    }    case kQ3GeometryTypeMarker: {      return (TQ3XFunctionPointer) SR_Geometry_Marker;      break;    }    case kQ3GeometryTypePixmapMarker: {      return (TQ3XFunctionPointer) SR_Geometry_PixmapMarker;      break;    }    case kQ3GeometryTypePoint: {      return (TQ3XFunctionPointer) SR_Geometry_Point;      break;    }    case kQ3GeometryTypeTriangle: {      return (TQ3XFunctionPointer) SR_Geometry_Triangle;      break;    }    default: {      return NULL;      break;    }  }}/*===========================================================================*\ * *  Routine:  SR_Attribute_MetaHandler() * *  Comments:  Provide callbacks for updating attributes the sample *        renderer cares about. Since it's only a simple wireframe *        renderer, we only deal with diffuse color and highlight state. *\*===========================================================================*/static TQ3XFunctionPointer SR_Attribute_MetaHandler(  TQ3XMethodType      methodType){  switch (methodType) {    case kQ3AttributeTypeDiffuseColor: {      return (TQ3XFunctionPointer) SR_Update_DiffuseColor;      break;    }    case kQ3AttributeTypeHighlightState: {      return (TQ3XFunctionPointer) SR_Update_HighlightState;      break;    }    default: {      return NULL;      break;    }  }}/*===========================================================================*\ * *  Routine:  SR_Matrix_MetaHandler() * *  Comments:  Provide callbacks for updating the various transformation *        states. *\*===========================================================================*/static TQ3XFunctionPointer SR_Matrix_MetaHandler(  TQ3XMethodType      methodType){  switch (methodType) {    case kQ3XMethodTypeRendererUpdateMatrixLocalToWorld: {      return ((TQ3XFunctionPointer) SR_Update_LocalToWorldMatrix);      break;    }    case kQ3XMethodTypeRendererUpdateMatrixWorldToFrustum: {      return ((TQ3XFunctionPointer) SR_Update_WorldToFrustumMatrix);      break;    }    case kQ3XMethodTypeRendererUpdateMatrixLocalToFrustum: {      return ((TQ3XFunctionPointer) SR_Update_LocalToFrustumMatrix);      break;    }    default: {      return (NULL);      break;    }  }}/*===========================================================================*\ * *  Routine:  SR_Style_MetaHandler() * *  Comments:  Provide callbacks for updating the styles. *        Only backfacing, hightlight, orientation, and fill style *        are dealt with in this sample renderer. *\*===========================================================================*/static TQ3XFunctionPointer SR_Style_MetaHandler(  TQ3XMethodType      methodType){  switch (methodType) {    case kQ3StyleTypeBackfacing: {      return (TQ3XFunctionPointer) SR_Update_BackfacingStyle;      break;    }    case kQ3StyleTypeHighlight: {      return (TQ3XFunctionPointer) SR_Update_HighlightStyle;      break;    }    case kQ3StyleTypeOrientation: {      return (TQ3XFunctionPointer) SR_Update_OrientationStyle;      break;    }    case kQ3StyleTypeFill: {      return (TQ3XFunctionPointer) SR_Update_FillStyle;      break;    }    default: {      return NULL;      break;    }  }}/*===========================================================================*\ * *  Routine:  SR_MetaHandler() * *  Comments:  Main metahandler. Provides entry point for various *        required and optional renderer functions, and for the *        metahandlers for geometric primitive rendering and *        style, matrix, and attribute updates. *\*===========================================================================*/static TQ3XFunctionPointer SR_MetaHandler(  TQ3XMethodType    methodType){  switch (methodType) {    /*      *  Object      */    case kQ3XMethodTypeObjectNew: {      return (TQ3XFunctionPointer) SR_New;      break;    }    case kQ3XMethodTypeObjectDelete: {      return (TQ3XFunctionPointer) SR_Delete;      break;    }          /*      *  I/O      */    case kQ3XMethodTypeObjectRead: {      return (TQ3XFunctionPointer) SR_Read;      break;    }    case kQ3XMethodTypeObjectAttach: {      return (TQ3XFunctionPointer) NULL;      break;    }    case kQ3XMethodTypeObjectTraverse: {      return (TQ3XFunctionPointer) SR_Traverse;      break;    }    case kQ3XMethodTypeObjectWrite: {      return (TQ3XFunctionPointer) NULL;      break;    }          /*      *  Renderer      */    case kQ3XMethodTypeRendererStartFrame: {      return (TQ3XFunctionPointer) SR_StartFrame;      break;    }    case kQ3XMethodTypeRendererStartPass: {      return (TQ3XFunctionPointer) SR_Pass;      break;    }    case kQ3XMethodTypeRendererEndPass: {      return (TQ3XFunctionPointer) SR_EndPass;      break;    }    case kQ3XMethodTypeRendererCancel: {      return (TQ3XFunctionPointer) SR_Cancel;      break;    }          /*      *  Renderer Draw      */    case kQ3XMethodTypeRendererSubmitGeometryMetaHandler: {      return (TQ3XFunctionPointer) SR_Geometry_MetaHandler;      break;    }    /*      *  Renderer Update      */    case kQ3XMethodTypeRendererUpdateStyleMetaHandler: {      return (TQ3XFunctionPointer) SR_Style_MetaHandler;      break;    }    case kQ3XMethodTypeRendererUpdateAttributeMetaHandler: {      return (TQ3XFunctionPointer) SR_Attribute_MetaHandler;      break;    }    case kQ3XMethodTypeRendererUpdateMatrixMetaHandler: {      return (TQ3XFunctionPointer) SR_Matrix_MetaHandler;      break;    }        /*     *  Modal dialog     */    case kQ3XMethodTypeRendererModalConfigure: {#if defined(WINDOW_SYSTEM_MACINTOSH) &amp;&amp; WINDOW_SYSTEM_MACINTOSH      return (TQ3XFunctionPointer) SR_MacModalDialog;#elif defined (WINDOW_SYSTEM_WIN32) &amp;&amp; WINDOW_SYSTEM_WIN32      return (TQ3XFunctionPointer) SR_WinModalDialog;#endif  /*  WINDOW_SYSTEM_MACINTOSH  */      break;    }        /*     *  &quot;isInteractive&quot; control     */    case kQ3XMethodTypeRendererIsInteractive: {      return (TQ3XFunctionPointer) kQ3True;      break;    }        /*     *  renderer name string     */    case kQ3XMethodTypeRendererGetNickNameString: {      return (TQ3XFunctionPointer) SR_GetNameString;      break;    }        /*     *  Configuration data     */    case kQ3XMethodTypeRendererGetConfigurationData: {      return (TQ3XFunctionPointer) SR_GetConfigurationData;      break;    }    case kQ3XMethodTypeRendererSetConfigurationData: {      return (TQ3XFunctionPointer) SR_SetConfigurationData;      break;    }    default: {      return NULL;      break;    }  }}/*===========================================================================*\ * *  Routine:  SR_Read() * *  Comments:   *\*===========================================================================*/static TQ3RendererObject SR_Read(  TQ3FileObject    file){  UNUSED(file);    return Q3Renderer_NewFromType(SRgClassType);}/*===========================================================================*\ * *  Routine:  SR_Traverse() * *  Comments:   *\*===========================================================================*/static TQ3Status SR_Traverse(  TQ3RendererObject  renderer,  void        *unused,  TQ3ViewObject    view){  UNUSED(unused);  UNUSED(renderer);    return Q3XView_SubmitWriteData(view, 0, NULL, NULL);}/*===========================================================================*\ * *  Routine:  SR_Register() * *  Comments:  Create/register this sample renderer, as a subclass of  *        kQ3SharedTypeRenderer *\*===========================================================================*/static TQ3Status SR_Register(  void){  /*   *  Create/register the class   */  SRgRendererClass =     Q3XObjectHierarchy_RegisterClass(      kQ3SharedTypeRenderer,      &amp;SRgClassType,      &quot;SampleRenderer&quot;,      SR_MetaHandler,      NULL,      0,      sizeof(TSRPrivate));  /*   *  Make sure it worked   */  if (SRgRendererClass == NULL) {    return (kQ3Failure);  }  return (kQ3Success);}#if defined(WINDOW_SYSTEM_MACINTOSH) &amp;&amp; WINDOW_SYSTEM_MACINTOSH/*===========================================================================*\ * *  Routine:  SR_Initialize() * *  Comments:  This is the initialization routine called by the shared library *        manager.  This function passes SR_Register to QuickDraw 3D *\*===========================================================================*/OSErr SR_Initialize(   const CFragInitBlock  *initBlock){  TQ3XSharedLibraryInfo  sharedLibraryInfo;  OSErr          err = noErr;    sharedLibraryInfo.registerFunction   = SR_Register;  sharedLibraryInfo.sharedLibrary   = (unsigned long)                        initBlock-&gt;connectionID;                          Q3XSharedLibrary_Register(&amp;sharedLibraryInfo);    SRgSharedLibrary = (unsigned long)initBlock-&gt;connectionID;    err = SR_CreateAliasHandle(initBlock);    return (err);}#endif#if defined(WINDOW_SYSTEM_WIN32) &amp;&amp; WINDOW_SYSTEM_WIN32HINSTANCE  hinstMyDLL = NULL;/*===========================================================================*\ * *  Routine:  DllMain() * *  Comments:  The Win32 extension entry point *\*===========================================================================*/BOOL WINAPI DllMain(  HINSTANCE  hinstDLL,  DWORD    fdwReason,  LPVOID    lpvReserved){  TQ3XSharedLibraryInfo  sharedLibraryInfo;    if (fdwReason == DLL_PROCESS_ATTACH) {    hinstMyDLL = hinstDLL;    sharedLibraryInfo.registerFunction = SR_Register;    sharedLibraryInfo.sharedLibrary = (unsigned long)hinstDLL;    if (Q3XSharedLibrary_Register(&amp;sharedLibraryInfo) == kQ3Success) {      return TRUE;    } else {      return FALSE;    }  }    if (fdwReason == DLL_PROCESS_DETACH) {    Q3XSharedLibrary_Unregister((unsigned long)hinstDLL);  }  return (TRUE);}#endif /* WINDOW_SYSTEM_WIN32 *//*===========================================================================*\ * *  Routine:  SR_Exit() * *  Comments:  Called on exiting from QD3D, this function unregisters this *        plug-in renderer. *\*===========================================================================*/TQ3Status SR_Exit(   void){  if (SRgSharedLibrary != NULL) {    Q3XSharedLibrary_Unregister(SRgSharedLibrary);    SRgSharedLibrary = NULL;  }  #if defined(WINDOW_SYSTEM_MACINTOSH) &amp;&amp; WINDOW_SYSTEM_MACINTOSH  SR_FreeAliasHandle();#endif  /*  WINDOW_SYSTEM_MACINTOSH  */    return (kQ3Success);}#if defined(WINDOW_SYSTEM_MACINTOSH) &amp;&amp; WINDOW_SYSTEM_MACINTOSH/*===========================================================================*\ * *  Routine:  SR_CreateAliasHandle() * *  Comments:   *\*===========================================================================*/static OSErr SR_CreateAliasHandle(   const CFragInitBlock  *initBlock){    OSErr    err = noErr;    if (initBlock-&gt;fragLocator.where == kDataForkCFragLocator) {        err = NewAlias(          NULL,           initBlock-&gt;fragLocator.u.onDisk.fileSpec,           &amp;SRgAliasHandle);  }    return (err);}/*===========================================================================*\ * *  Routine:  SR_FreeAliasHandle() * *  Comments:   *\*===========================================================================*/static TQ3Status SR_FreeAliasHandle(  void){  if (SRgAliasHandle != NULL) {    DisposeHandle((Handle) SRgAliasHandle);  }    return (kQ3Success);}#endif  /*  WINDOW_SYSTEM_MACINTOSH  */</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/Plug-in__-_Sample_Renderer/listing13.html%3Fid%3DDTS10000120-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/Plug-in__-_Sample_Renderer/listing13.html%3Fid%3DDTS10000120-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/Plug-in__-_Sample_Renderer/listing13.html%3Fid%3DDTS10000120-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>