<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>MoreIsBetter - /MIB-Libraries/MoreOpenTransport/OTMPTest/OTMPTest.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxMacOS9Earlier-date.html">Mac OS 9 & Earlier</a> &gt; <A HREF="javascript:location.replace('index.html');">MoreIsBetter</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->


	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">MoreIsBetter</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/MIB-Libraries/MoreOpenTransport/OTMPTest/OTMPTest.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/MIB-Clients/Demos/MoreOpenAndSaveDemo/AnswerShell.c</option>
<option value="listing2.html">/MIB-Clients/MacCVSProTool/MacCVSProTool.c</option>
<option value="listing3.html">/MIB-Clients/SampleSubmit/SampleSubmit.c</option>
<option value="listing4.html">/MIB-Documentation/index.html</option>
<option value="listing5.html">/MIB-Documentation/MoreDocumentation/0ReleaseNotes.html</option>
<option value="listing6.html">/MIB-Documentation/MoreDocumentation/0toc.html</option>
<option value="listing7.html">/MIB-Documentation/MoreDocumentation/banner.html</option>
<option value="listing8.html">/MIB-Documentation/MoreDocumentation/BuildingAndUsing.html</option>
<option value="listing9.html">/MIB-Documentation/MoreDocumentation/ContributingToMoreIsBetter.html</option>
<option value="listing10.html">/MIB-Documentation/MoreDocumentation/copyright.html</option>
<option value="listing11.html">/MIB-Documentation/MoreDocumentation/index.html</option>
<option value="listing12.html">/MIB-Documentation/MoreDocumentation/intro.html</option>
<option value="listing13.html">/MIB-Documentation/MoreDocumentation/MoreAppearance.html</option>
<option value="listing14.html">/MIB-Documentation/MoreDocumentation/MoreAppleEvents.html</option>
<option value="listing15.html">/MIB-Documentation/MoreDocumentation/MoreCDs.html</option>
<option value="listing16.html">/MIB-Documentation/MoreDocumentation/MoreCodeFragments.html</option>
<option value="listing17.html">/MIB-Documentation/MoreDocumentation/MoreControls.html</option>
<option value="listing18.html">/MIB-Documentation/MoreDocumentation/MoreDevices.html</option>
<option value="listing19.html">/MIB-Documentation/MoreDocumentation/MoreDialogs.html</option>
<option value="listing20.html">/MIB-Documentation/MoreDocumentation/MoreDisks.html</option>
<option value="listing21.html">/MIB-Documentation/MoreDocumentation/MoreErrors.html</option>
<option value="listing22.html">/MIB-Documentation/MoreDocumentation/MoreEvents.html</option>
<option value="listing23.html">/MIB-Documentation/MoreDocumentation/MoreInterfaceLib.html</option>
<option value="listing24.html">/MIB-Documentation/MoreDocumentation/MoreLists.html</option>
<option value="listing25.html">/MIB-Documentation/MoreDocumentation/MoreMemory.html</option>
<option value="listing26.html">/MIB-Documentation/MoreDocumentation/MoreMenus.html</option>
<option value="listing27.html">/MIB-Documentation/MoreDocumentation/MoreMultiprocessing.html</option>
<option value="listing28.html">/MIB-Documentation/MoreDocumentation/MoreNavigation.html</option>
<option value="listing29.html">/MIB-Documentation/MoreDocumentation/MoreNetworkSetup.html</option>
<option value="listing30.html">/MIB-Documentation/MoreDocumentation/MoreOpenAndSave.html</option>
<option value="listing31.html">/MIB-Documentation/MoreDocumentation/MoreOpenTransport.html</option>
<option value="listing32.html">/MIB-Documentation/MoreDocumentation/MoreOSL.html</option>
<option value="listing33.html">/MIB-Documentation/MoreDocumentation/MoreOSUtils.html</option>
<option value="listing34.html">/MIB-Documentation/MoreDocumentation/MorePatches.html</option>
<option value="listing35.html">/MIB-Documentation/MoreDocumentation/MorePreferences.html</option>
<option value="listing36.html">/MIB-Documentation/MoreDocumentation/MoreProcesses.html</option>
<option value="listing37.html">/MIB-Documentation/MoreDocumentation/MoreQuickDraw.html</option>
<option value="listing38.html">/MIB-Documentation/MoreDocumentation/MoreResources.html</option>
<option value="listing39.html">/MIB-Documentation/MoreDocumentation/MoreTextUtils.html</option>
<option value="listing40.html">/MIB-Documentation/MoreDocumentation/MoreToolbox.html</option>
<option value="listing41.html">/MIB-Documentation/MoreDocumentation/MoreWindows.html</option>
<option value="listing42.html">/MIB-Libraries/MIB_Carbon.h</option>
<option value="listing43.html">/MIB-Libraries/MIB_SourceHeader.txt</option>
<option value="listing44.html">/MIB-Libraries/MoreAppearance/MoreAppearance.cp</option>
<option value="listing45.html">/MIB-Libraries/MoreAppearance/MoreAppearance.h</option>
<option value="listing46.html">/MIB-Libraries/MoreAppleEvents/MoreAEDataModel.c</option>
<option value="listing47.html">/MIB-Libraries/MoreAppleEvents/MoreAEDataModel.h</option>
<option value="listing48.html">/MIB-Libraries/MoreAppleEvents/MoreAEObjects.c</option>
<option value="listing49.html">/MIB-Libraries/MoreAppleEvents/MoreAEObjects.h</option>
<option value="listing50.html">/MIB-Libraries/MoreAppleEvents/MoreAppleEvents.cp</option>
<option value="listing51.html">/MIB-Libraries/MoreAppleEvents/MoreAppleEvents.h</option>
<option value="listing52.html">/MIB-Libraries/MoreAppleEvents/MoreAppleEventsPlus.c</option>
<option value="listing53.html">/MIB-Libraries/MoreAppleEvents/MoreAppleEventsPlus.h</option>
<option value="listing54.html">/MIB-Libraries/MoreAppleEvents/MoreFinderEvents.c</option>
<option value="listing55.html">/MIB-Libraries/MoreAppleEvents/MoreFinderEvents.h</option>
<option value="listing56.html">/MIB-Libraries/MoreAppleEvents/MoreOSA.c</option>
<option value="listing57.html">/MIB-Libraries/MoreAppleEvents/MoreOSA.h</option>
<option value="listing58.html">/MIB-Libraries/MoreAppleEvents/ProductInfo.txt</option>
<option value="listing59.html">/MIB-Libraries/MoreAppleEvents/TestMoreAppleEvents/Carbon.r</option>
<option value="listing60.html">/MIB-Libraries/MoreAppleEvents/TestMoreAppleEvents/HelloWorld.c</option>
<option value="listing61.html">/MIB-Libraries/MoreAppleEvents/TestMoreAppleEvents/Info.plist.r</option>
<option value="listing62.html">/MIB-Libraries/MoreAppleEvents/TestMoreAppleEvents/TestMoreAppleEvents.c</option>
<option value="listing63.html">/MIB-Libraries/MoreAppleEvents/VersionInfo.r</option>
<option value="listing64.html">/MIB-Libraries/MoreCarbonEvents/MoreCarbonEvents.c</option>
<option value="listing65.html">/MIB-Libraries/MoreCarbonEvents/MoreCarbonEvents.h</option>
<option value="listing66.html">/MIB-Libraries/MoreCFQ/MoreCFQ.c</option>
<option value="listing67.html">/MIB-Libraries/MoreCFQ/MoreCFQ.h</option>
<option value="listing68.html">/MIB-Libraries/MoreCodeFragments/CFMLateImport/CallMachOFramework/CallMachOFramework.c</option>
<option value="listing69.html">/MIB-Libraries/MoreCodeFragments/CFMLateImport/CallMachOFramework/CallMachOFramework.r</option>
<option value="listing70.html">/MIB-Libraries/MoreCodeFragments/CFMLateImport/CallMachOFramework/Read Me CallMachOFramework.txt</option>
<option value="listing71.html">/MIB-Libraries/MoreCodeFragments/CFMLateImport/CallMachOFramework/System Framework Stub/Stub Library Read Me.txt</option>
<option value="listing72.html">/MIB-Libraries/MoreCodeFragments/CFMLateImport/CFMLateImport.c</option>
<option value="listing73.html">/MIB-Libraries/MoreCodeFragments/CFMLateImport/CFMLateImport.h</option>
<option value="listing74.html">/MIB-Libraries/MoreCodeFragments/CFMLateImport/LateImportTest/LateImportTest.c</option>
<option value="listing75.html">/MIB-Libraries/MoreCodeFragments/CFMLateImport/LateImportTest/TestLibrary/TestLibrary.h</option>
<option value="listing76.html">/MIB-Libraries/MoreCodeFragments/CFMLateImport/LateImportTest/TestLibrary/TestLibraryImpl.c</option>
<option value="listing77.html">/MIB-Libraries/MoreControls/MoreControls.cp</option>
<option value="listing78.html">/MIB-Libraries/MoreControls/MoreControls.h</option>
<option value="listing79.html">/MIB-Libraries/MoreCRC/MoreCRC.c</option>
<option value="listing80.html">/MIB-Libraries/MoreCRC/MoreCRC.h</option>
<option value="listing81.html">/MIB-Libraries/MoreDebugging/MoreAddrToSym.c</option>
<option value="listing82.html">/MIB-Libraries/MoreDebugging/MoreAddrToSym.h</option>
<option value="listing83.html">/MIB-Libraries/MoreDebugging/MoreBacktrace.c</option>
<option value="listing84.html">/MIB-Libraries/MoreDebugging/MoreBacktrace.h</option>
<option value="listing85.html">/MIB-Libraries/MoreDebugging/MoreBacktraceTest/MoreBacktraceTest.c</option>
<option value="listing86.html">/MIB-Libraries/MoreDebugging/MoreBBLog.c</option>
<option value="listing87.html">/MIB-Libraries/MoreDebugging/MoreBBLog.h</option>
<option value="listing88.html">/MIB-Libraries/MoreDevices/InterruptSafeDebug/GenerateFont/GenerateFont.c</option>
<option value="listing89.html">/MIB-Libraries/MoreDevices/InterruptSafeDebug/InterruptSafeDebug.c</option>
<option value="listing90.html">/MIB-Libraries/MoreDevices/InterruptSafeDebug/InterruptSafeDebug.h</option>
<option value="listing91.html">/MIB-Libraries/MoreDevices/InterruptSafeDebug/InterruptSafeDebug.s</option>
<option value="listing92.html">/MIB-Libraries/MoreDevices/InterruptSafeDebug/TestInterruptSafeDebug/TestInterruptSafeDebug.c</option>
<option value="listing93.html">/MIB-Libraries/MoreDevices/TradDriverLoaderLib/ReadMe.html</option>
<option value="listing94.html">/MIB-Libraries/MoreDevices/TradDriverLoaderLib/TestTradDriverLoaderLib/TestDriver/TestDriverMain.c</option>
<option value="listing95.html">/MIB-Libraries/MoreDevices/TradDriverLoaderLib/TestTradDriverLoaderLib/TestTradDriverLoader.c</option>
<option value="listing96.html">/MIB-Libraries/MoreDevices/TradDriverLoaderLib/TradDriverLoaderLib.c</option>
<option value="listing97.html">/MIB-Libraries/MoreDevices/TradDriverLoaderLib/TradDriverLoaderLib.h</option>
<option value="listing98.html">/MIB-Libraries/MoreDialogs/MoreDialogs.cp</option>
<option value="listing99.html">/MIB-Libraries/MoreDialogs/MoreDialogs.h</option>
<option value="listing100.html">/MIB-Libraries/MoreDisks/MoreCDs.c</option>
<option value="listing101.html">/MIB-Libraries/MoreDisks/MoreCDs.h</option>
<option value="listing102.html">/MIB-Libraries/MoreDisks/MoreDisks.c</option>
<option value="listing103.html">/MIB-Libraries/MoreDisks/MoreDisks.h</option>
<option value="listing104.html">/MIB-Libraries/MoreDisks/TestMoreDisks/TestMoreDisks.c</option>
<option value="listing105.html">/MIB-Libraries/MoreErrors/MoreErrors.c</option>
<option value="listing106.html">/MIB-Libraries/MoreErrors/MoreErrors.h</option>
<option value="listing107.html">/MIB-Libraries/MoreErrors/MoreErrors.r</option>
<option value="listing108.html">/MIB-Libraries/MoreEvents/MoreEvents.h</option>
<option value="listing109.html">/MIB-Libraries/MoreInterfaceLib/MoreInterfaceLib.c</option>
<option value="listing110.html">/MIB-Libraries/MoreInterfaceLib/MoreInterfaceLib.h</option>
<option value="listing111.html">/MIB-Libraries/MoreInterfaceLib/RemoteAccessInterface.h</option>
<option value="listing112.html">/MIB-Libraries/MoreInterfaceLib/TestMoreInterfaceLib/TestMoreInterfaceLib.c</option>
<option value="listing113.html">/MIB-Libraries/MoreIsBetter.h</option>
<option value="listing114.html">/MIB-Libraries/MoreLists/MoreLists.c</option>
<option value="listing115.html">/MIB-Libraries/MoreLists/MoreLists.h</option>
<option value="listing116.html">/MIB-Libraries/MoreMemory/MoreMemory.c</option>
<option value="listing117.html">/MIB-Libraries/MoreMemory/MoreMemory.h</option>
<option value="listing118.html">/MIB-Libraries/MoreMemory/TestMoreMemory/TestMoreMemory.c</option>
<option value="listing119.html">/MIB-Libraries/MoreMenus/MenuKeyGlyphs.h</option>
<option value="listing120.html">/MIB-Libraries/MoreMenus/MoreMenus.c</option>
<option value="listing121.html">/MIB-Libraries/MoreMenus/MoreMenus.h</option>
<option value="listing122.html">/MIB-Libraries/MoreMenus/MoreSystemMenus.c</option>
<option value="listing123.html">/MIB-Libraries/MoreMenus/MoreSystemMenus.h</option>
<option value="listing124.html">/MIB-Libraries/MoreMenus/TestMoreSystemMenus/TestMoreSystemMenus.c</option>
<option value="listing125.html">/MIB-Libraries/MoreMultiprocessing/MoreBlueActions.c</option>
<option value="listing126.html">/MIB-Libraries/MoreMultiprocessing/MoreBlueActions.h</option>
<option value="listing127.html">/MIB-Libraries/MoreMultiprocessing/MoreMPLog.c</option>
<option value="listing128.html">/MIB-Libraries/MoreMultiprocessing/MoreMPLog.h</option>
<option value="listing129.html">/MIB-Libraries/MoreNavigation/MoreNavigation.c</option>
<option value="listing130.html">/MIB-Libraries/MoreNavigation/MoreNavigation.h</option>
<option value="listing131.html">/MIB-Libraries/MoreOpenAndSave/MoreOpenAndSave.cp</option>
<option value="listing132.html">/MIB-Libraries/MoreOpenAndSave/MoreOpenAndSave.h</option>
<option value="listing133.html">/MIB-Libraries/MoreOpenTransport/MoreAutoPush.c</option>
<option value="listing134.html">/MIB-Libraries/MoreOpenTransport/MoreAutoPush.h</option>
<option value="listing135.html">/MIB-Libraries/MoreOpenTransport/MoreAutoPushTest/MoreAutoPushTest.c</option>
<option value="listing136.html">/MIB-Libraries/MoreOpenTransport/OTClassicContext.h</option>
<option value="listing137.html">/MIB-Libraries/MoreOpenTransport/OTClassicContextTest/OTClassicContextTest.c</option>
<option value="listing138.html">/MIB-Libraries/MoreOpenTransport/OTMP.c</option>
<option value="listing139.html">/MIB-Libraries/MoreOpenTransport/OTMP.h</option>
<option value="listing140.html">/MIB-Libraries/MoreOpenTransport/OTMPSimpleServerHTTP/OTMPSimpleServerHTTP.c</option>
<option value="listing141.html">/MIB-Libraries/MoreOpenTransport/OTMPSimpleServerHTTP/OTMPSimpleServerHTTP.h</option>
<option value="listing142.html">/MIB-Libraries/MoreOpenTransport/OTMPSimpleServerHTTP/OTMPSimpleServerHTTPTest.c</option>
<option value="listing143.html">/MIB-Libraries/MoreOpenTransport/OTMPSimpleServerHTTP/OTMPSimpleServerHTTPTest.r</option>
<option value="listing144.html">/MIB-Libraries/MoreOpenTransport/OTMPSimpleServerHTTP/Sample HTTP Source/index.html</option>
<option value="listing145.html">/MIB-Libraries/MoreOpenTransport/OTMPTest/OTMPTest.c</option>
<option value="listing146.html">/MIB-Libraries/MoreOpenTransport/Read_Me_About_OTMP.html</option>
<option value="listing147.html">/MIB-Libraries/MoreOpenTransport/ReadMeOTClassicContext.html</option>
<option value="listing148.html">/MIB-Libraries/MoreOSL/MoreOSL.c</option>
<option value="listing149.html">/MIB-Libraries/MoreOSL/MoreOSL.h</option>
<option value="listing150.html">/MIB-Libraries/MoreOSL/MoreOSLHelpers.c</option>
<option value="listing151.html">/MIB-Libraries/MoreOSL/MoreOSLHelpers.h</option>
<option value="listing152.html">/MIB-Libraries/MoreOSL/MoreOSLStringComp.applescript</option>
<option value="listing153.html">/MIB-Libraries/MoreOSL/MoreOSLStringCompare.c</option>
<option value="listing154.html">/MIB-Libraries/MoreOSL/MoreOSLStringCompare.h</option>
<option value="listing155.html">/MIB-Libraries/MoreOSL/MoreOSLTokens.c</option>
<option value="listing156.html">/MIB-Libraries/MoreOSL/MoreOSLTokens.h</option>
<option value="listing157.html">/MIB-Libraries/MoreOSL/ReadMe.html</option>
<option value="listing158.html">/MIB-Libraries/MoreOSL/TestMoreOSL/Test Script.applescript</option>
<option value="listing159.html">/MIB-Libraries/MoreOSL/TestMoreOSL/TestMoreOSL.c</option>
<option value="listing160.html">/MIB-Libraries/MoreOSL/TestMoreOSL/TestMoreOSLTerminology.h</option>
<option value="listing161.html">/MIB-Libraries/MoreOSL/TestMoreOSL/TestMoreOSLTerminology.r</option>
<option value="listing162.html">/MIB-Libraries/MoreOSUtils/MoreOSUtils.c</option>
<option value="listing163.html">/MIB-Libraries/MoreOSUtils/MoreOSUtils.h</option>
<option value="listing164.html">/MIB-Libraries/MoreOSUtils/TestMoreOSUtils/TestMoreOSUtils.c</option>
<option value="listing165.html">/MIB-Libraries/MorePatches/MoreCFMPatches/MoreCFMPatches.c</option>
<option value="listing166.html">/MIB-Libraries/MorePatches/MoreCFMPatches/MoreCFMPatches.h</option>
<option value="listing167.html">/MIB-Libraries/MorePatches/MoreCFMPatches/MoreCFMPatches.s</option>
<option value="listing168.html">/MIB-Libraries/MorePatches/MoreCFMPatches/MoreCFMPatchesTest/MoreCFMPatchesTest.c</option>
<option value="listing169.html">/MIB-Libraries/MorePreferences/MorePreferences.cp</option>
<option value="listing170.html">/MIB-Libraries/MorePreferences/MorePreferences.h</option>
<option value="listing171.html">/MIB-Libraries/MoreProcesses/MoreProcesses.cp</option>
<option value="listing172.html">/MIB-Libraries/MoreProcesses/MoreProcesses.h</option>
<option value="listing173.html">/MIB-Libraries/MoreProcesses/MoreScheduledExec.c</option>
<option value="listing174.html">/MIB-Libraries/MoreProcesses/MoreScheduledExec.h</option>
<option value="listing175.html">/MIB-Libraries/MoreProcesses/TestMoreScheduledExec/TestMoreScheduledExec.c</option>
<option value="listing176.html">/MIB-Libraries/MoreQuickDraw/MoreQuickDraw.cp</option>
<option value="listing177.html">/MIB-Libraries/MoreQuickDraw/MoreQuickDraw.h</option>
<option value="listing178.html">/MIB-Libraries/MoreResources/MoreResources.c</option>
<option value="listing179.html">/MIB-Libraries/MoreResources/MoreResources.h</option>
<option value="listing180.html">/MIB-Libraries/MoreSCF/MoreSCF.c</option>
<option value="listing181.html">/MIB-Libraries/MoreSCF/MoreSCF.h</option>
<option value="listing182.html">/MIB-Libraries/MoreSCF/MoreSCFCCLScanner.c</option>
<option value="listing183.html">/MIB-Libraries/MoreSCF/MoreSCFCCLScanner.h</option>
<option value="listing184.html">/MIB-Libraries/MoreSCF/MoreSCFDigest.c</option>
<option value="listing185.html">/MIB-Libraries/MoreSCF/MoreSCFDigest.h</option>
<option value="listing186.html">/MIB-Libraries/MoreSCF/MoreSCFHelpers.c</option>
<option value="listing187.html">/MIB-Libraries/MoreSCF/MoreSCFHelpers.h</option>
<option value="listing188.html">/MIB-Libraries/MoreSCF/MoreSCFPortScanner.c</option>
<option value="listing189.html">/MIB-Libraries/MoreSCF/MoreSCFPortScanner.h</option>
<option value="listing190.html">/MIB-Libraries/MoreSCF/MoreSCFTest/MoreSCFTest.c</option>
<option value="listing191.html">/MIB-Libraries/MoreSCF/ReadMeAboutMoreSCF.html</option>
<option value="listing192.html">/MIB-Libraries/MoreSecurity/MoreSecurity.c</option>
<option value="listing193.html">/MIB-Libraries/MoreSecurity/MoreSecurity.h</option>
<option value="listing194.html">/MIB-Libraries/MoreSecurity/MoreSecurityTest/MoreSecurityTest.c</option>
<option value="listing195.html">/MIB-Libraries/MoreSecurity/MoreSecurityTest/MoreSecurityTestCommon.h</option>
<option value="listing196.html">/MIB-Libraries/MoreSecurity/MoreSecurityTest/MoreSecurityTestTool.c</option>
<option value="listing197.html">/MIB-Libraries/MoreSecurity/ReadMeAboutMoreAuthSample.html</option>
<option value="listing198.html">/MIB-Libraries/MoreSetup.h</option>
<option value="listing199.html">/MIB-Libraries/MoreSetup.r</option>
<option value="listing200.html">/MIB-Libraries/MoreSound/MoreSound.cp</option>
<option value="listing201.html">/MIB-Libraries/MoreSound/MoreSound.h</option>
<option value="listing202.html">/MIB-Libraries/MoreTextUtils/MoreTextUtils.cp</option>
<option value="listing203.html">/MIB-Libraries/MoreTextUtils/MoreTextUtils.h</option>
<option value="listing204.html">/MIB-Libraries/MoreTextUtils/TestMoreTextUtils/TestMoreTextUtils.c</option>
<option value="listing205.html">/MIB-Libraries/MoreTextUtils/TestMoreTextUtils/TestMoreTextUtils.r</option>
<option value="listing206.html">/MIB-Libraries/MoreToolbox/MoreToolbox.cp</option>
<option value="listing207.html">/MIB-Libraries/MoreToolbox/MoreToolbox.h</option>
<option value="listing208.html">/MIB-Libraries/MoreUNIX/MoreUNIX.c</option>
<option value="listing209.html">/MIB-Libraries/MoreUNIX/MoreUNIX.h</option>
<option value="listing210.html">/MIB-Libraries/MoreWindows/MoreWindows.cp</option>
<option value="listing211.html">/MIB-Libraries/MoreWindows/MoreWindows.h</option>
<option value="listing212.html">/MIB-Libraries/NetworkSetup/MoreNetworkSetup.c</option>
<option value="listing213.html">/MIB-Libraries/NetworkSetup/MoreNetworkSetup.h</option>
<option value="listing214.html">/MIB-Libraries/NetworkSetup/Network Setup SDK Bits/ Read Me.txt</option>
<option value="listing215.html">/MIB-Libraries/NetworkSetup/Network Setup SDK Bits/NetworkSetupBigPicture.html</option>
<option value="listing216.html">/MIB-Libraries/NetworkSetup/NetworkSetupHelpers.c</option>
<option value="listing217.html">/MIB-Libraries/NetworkSetup/NetworkSetupHelpers.h</option>
<option value="listing218.html">/MIB-Libraries/NetworkSetup/NetworkSetupTest/NetworkSetupTest.c</option>
<option value="listing219.html">/MIB-Libraries/NetworkSetup/OldStyleAPI/OldOTConfigLib.h</option>
<option value="listing220.html">/MIB-Libraries/NetworkSetup/ReadMe.html</option>
<option value="listing221.html">/MIB-Libraries/PascalInterfaces/MoreSetup.p</option>
<option value="listing222.html">/MIB-Libraries/PascalInterfaces/TradDriverLoaderLib.p</option></select>
				</p>
				</form>
				<p><strong><a href="MoreIsBetter.zip">Download Sample</a></strong> (&#147;MoreIsBetter.zip&#148;, 1.61M)<BR>
<strong><a href="MoreIsBetter.dmg">Download Sample</a></strong> (&#147;MoreIsBetter.dmg&#148;, 2.04M)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*
  File:    OTMPTest.c

  Contains:  Test application for the OTMP library.

  Written by:  Quinn

  Copyright:  Copyright (c) 2000-2001 by Apple Computer, Inc., All Rights Reserved.

  Disclaimer:  IMPORTANT:  This Apple software is supplied to you by Apple Computer, Inc.
        (&quot;Apple&quot;) in consideration of your agreement to the following terms, and your
        use, installation, modification or redistribution of this Apple software
        constitutes acceptance of these terms.  If you do not agree with these terms,
        please do not use, install, modify or redistribute this Apple software.

        In consideration of your agreement to abide by the following terms, and subject
        to these terms, Apple grants you a personal, non-exclusive license, under Apple's
        copyrights in this original Apple software (the &quot;Apple Software&quot;), to use,
        reproduce, modify and redistribute the Apple Software, with or without
        modifications, in source and/or binary forms; provided that if you redistribute
        the Apple Software in its entirety and without modifications, you must retain
        this notice and the following text and disclaimers in all such redistributions of
        the Apple Software.  Neither the name, trademarks, service marks or logos of
        Apple Computer, Inc. may be used to endorse or promote products derived from the
        Apple Software without specific prior written permission from Apple.  Except as
        expressly stated in this notice, no other rights or licenses, express or implied,
        are granted by Apple herein, including but not limited to any patent rights that
        may be infringed by your derivative works or by other works in which the Apple
        Software may be incorporated.

        The Apple Software is provided by Apple on an &quot;AS IS&quot; basis.  APPLE MAKES NO
        WARRANTIES, EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION THE IMPLIED
        WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY AND FITNESS FOR A PARTICULAR
        PURPOSE, REGARDING THE APPLE SOFTWARE OR ITS USE AND OPERATION ALONE OR IN
        COMBINATION WITH YOUR PRODUCTS.

        IN NO EVENT SHALL APPLE BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL OR
        CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
        GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
        ARISING IN ANY WAY OUT OF THE USE, REPRODUCTION, MODIFICATION AND/OR DISTRIBUTION
        OF THE APPLE SOFTWARE, HOWEVER CAUSED AND WHETHER UNDER THEORY OF CONTRACT, TORT
        (INCLUDING NEGLIGENCE), STRICT LIABILITY OR OTHERWISE, EVEN IF APPLE HAS BEEN
        ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

  Change History (most recent first):

$Log: OTMPTest.c,v $
Revision 1.6  2002/11/08 23:45:25         
Convert nil to NULL. Convert MoreAssertQ to assert.

Revision 1.5  2001/11/07 15:57:16         
Tidy up headers, add CVS logs, update copyright.


         &lt;4&gt;      9/7/01    Quinn   Eliminated a bunch of MPLogPrintfSlow calls because I'm having
                                    problems with that routine.
         &lt;3&gt;      5/7/01    Quinn   Changes required for a new &quot;connect&quot; test.
         &lt;2&gt;      8/2/01    Quinn   Added code to test OTMPGetMessage and OTMPPutMessage.
         &lt;1&gt;     7/11/00    Quinn   First checked in.
*/

#include &quot;MoreSetup.h&quot;

#include &quot;OTMP.h&quot;
#include &quot;MoreMPLog.h&quot;

#include &lt;Multiprocessing.h&gt;
#include &lt;Events.h&gt;
#include &lt;OpenTransportProtocol.h&gt;
#include &lt;OpenTransportProviders.h&gt;
#include &lt;DriverServices.h&gt;
#include &lt;Folders.h&gt;

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

static OSStatus OrderlyDisconnect(OTMPEndpointRef ep)
  // Gosh XTI is lame.  RcvOrderlyDisconnect is non-blocking 
  // (it doesn't wait for the T_ORDREL event) so we have to 
  // block in a Rcv call.
{
  OSStatus   err;
  UInt8     tmp;
  OTFlags   junkFlags;
  OTResult   look;
  
  err = OTMPXSndOrderlyDisconnect(ep);
  if (err == noErr) {
    err = OTMPXRcv(ep, &amp;tmp, sizeof(tmp), &amp;junkFlags);
    if (err == kOTLookErr) {
      look = OTMPXLook(ep);
      switch (look) {
        case T_ORDREL:
          err = OTMPXRcvOrderlyDisconnect(ep);
          break;
        default:
          // leave err set to kOTLookErr
          break;
      }
    } else if (err == noErr) {
      err = kOTLookErr;      // something is happening, but it's not a disconnect
    }
  }
  return err;
}

static pascal OSStatus MyMainThreadYielder(void)
{
  OSStatus err;
  static UInt32 gTimeLastPrinted;
  
  if ( TickCount() &gt; (gTimeLastPrinted + 30) ) {
    printf(&quot;.&quot;);
    fflush(stdout);
    gTimeLastPrinted = TickCount();
  }

  #if TARGET_API_MAC_CARBON
    {
      err = noErr;
      if (GetCurrentKeyModifiers() &amp; alphaLock) {
        err = kOTCanceledErr;
      }
    }
  #else
    {
      EventRecord event;
      
      err = noErr;
      (void) OSEventAvail(0, &amp;event);
      if (event.modifiers &amp; alphaLock) {
        err = kOTCanceledErr;
      }
    }
  #endif
  return err;
}

static pascal OSStatus IoctlTest(OTMPEndpointRef ep)
{
  OSStatus err;
  str_mlist moduleList[10];
  str_list  iList;
  
  iList.sl_nmods = 10;
  iList.sl_modlist = moduleList;
  
  err = OTMPXIoctl(ep, I_LIST, &amp;iList);
  if (err == noErr) {
    SInt32 i;
    
    printf(&quot;\n&quot;);
    printf(&quot;Module List\n&quot;);
    printf(&quot;-----------\n&quot;);
    for (i = 0; i &lt; iList.sl_nmods; i++) {
      printf(&quot;  %ld = &quot;%s&quot;\n&quot;, i, &amp;moduleList[i]);
    }
  }
  return err;
}

static pascal OSStatus DoOutgoingBind(OTMPEndpointRef ep)
{
  OSStatus err;
  TBind ret;
  InetAddress boundAddr;
  
  OTMemzero(&amp;ret, sizeof(ret));
  ret.addr.maxlen = sizeof(boundAddr);
  ret.addr.buf    = (UInt8 *) &amp;boundAddr;
  
  err = OTMPXBind(ep, NULL, &amp;ret);
  if (err == noErr) {
    char addrAsStr[32];
    
    OTInetHostToString(boundAddr.fHost, addrAsStr);
    printf(&quot;\n&quot;);
    printf(&quot;boundAddr = %s:%d\n&quot;, addrAsStr, boundAddr.fPort);
  }
  return err;
}

static pascal OSStatus DoIncomingBind(OTMPEndpointRef ep, InetPort portNum, OTQLen qlen)
{
  OSStatus err;
  TBind req;
  TBind ret;
  InetAddress reqAddr;
  InetAddress retAddr;

  OTInitInetAddress(&amp;reqAddr, portNum, kOTAnyInetAddress);
  OTMemzero(&amp;req, sizeof(req));
  req.addr.len    = sizeof(reqAddr);
  req.addr.buf    = (UInt8 *) &amp;reqAddr;
  req.qlen        = qlen;
    
  OTMemzero(&amp;ret, sizeof(ret));
  ret.addr.maxlen = sizeof(retAddr);
  ret.addr.buf    = (UInt8 *) &amp;retAddr;
  
  err = OTMPXBind(ep, &amp;req, &amp;ret);
  if (err == noErr) {
    char addrAsStr[32];
    
    OTInetHostToString(retAddr.fHost, addrAsStr);
    MPLogPrintf(&quot;\n&quot;);
    MPLogPrintf(&quot;Bound to = %s:%d with qlen of %d\n&quot;, addrAsStr, retAddr.fPort, ret.qlen);
  }
  return err;
}

static OTResult SetFourByteOption(OTMPEndpointRef ep, OTXTILevel level, OTXTIName name, UInt32 value)
{
  OTResult err;
  TOption option;
  TOptMgmt request;
  TOptMgmt result;

  /* Set up the option buffer to specify the option and value to set. */

  option.len = kOTFourByteOptionSize;
  option.level = level;
  option.name = name;
  option.status = 0;
  option.value[0] = value;

  /* Set up request parameter for OTOptionManagement */

  request.opt.buf = (UInt8 *) &amp;option;
  request.opt.len = sizeof(option);
  request.flags = T_NEGOTIATE;

  /* Set up reply parameter for OTOptionManagement. */
  
  result.opt.buf = (UInt8 *) &amp;option;
  result.opt.maxlen = sizeof(option);
  err = OTMPXOptionManagement(ep, &amp;request, &amp;result);
  if (err == noErr) {
    if (option.status != T_SUCCESS) {
      err = option.status;
    }
  }
  return (err);
}

static OSStatus BasicEchoTest(OTMPEndpointRef ep)
{
  OSStatus err;
  OSStatus err2;
  
  err = DoOutgoingBind(ep);
  
  if (err == noErr) {
    InetAddress sndAddr;
    InetAddress rcvAddr;
    TCall sndCall;
    TCall rcvCall;
    
    OTInitInetAddress(&amp;sndAddr, 7, 0x7f000001);    // localhost addr
    OTMemzero(&amp;rcvAddr, sizeof(rcvAddr));

    OTMemzero(&amp;sndCall, sizeof(sndCall));
    sndCall.addr.buf = (UInt8 *) &amp;sndAddr;
    sndCall.addr.len = sizeof(sndAddr);
    
    OTMemzero(&amp;rcvCall, sizeof(rcvCall));
    rcvCall.addr.buf    = (UInt8 *) &amp;rcvAddr;
    rcvCall.addr.maxlen = sizeof(rcvAddr);
    
    err = OTMPXConnect(ep, &amp;sndCall, &amp;rcvCall);
    if (err == kOTLookErr) {
      OTResult look;
      
      look = OTMPXLook(ep);
      if (look == T_DISCONNECT) {
        TDiscon discon;
        
        OTMemzero(&amp;discon, sizeof(discon));
        err = OTMPXRcvDisconnect(ep, &amp;discon);
        if (err == noErr) {
          printf(&quot;\n&quot;);
          printf(&quot;Connect failed with reason %ld.\n&quot;, discon.reason);
        }
      }
    } else if (err == noErr) {
      err = OTMPXSnd(ep, &quot;Hello Cruel World!\x0d\x0a&quot;, 20, 0);
      if (err == 20) {
        err = noErr;
      }
      if (err == noErr) {
        OTFlags flags;
        char rcvBuf[100];
        
        OTMemzero(rcvBuf, sizeof(rcvBuf));
        flags = 0;
        err = OTMPXRcv(ep, rcvBuf, sizeof(rcvBuf), &amp;flags);
        if (err == 20) {
          err = noErr;
        }
      }
    
      err2 = OTMPXSndDisconnect(ep, NULL);
      if (err == noErr) {
        err = err2;
      }
    }
  }
  
  if (err == noErr) {
    err = OTMPXUnbind(ep);
  }

  return err;
}

static OSStatus EchoDisconnectTest(OTMPEndpointRef ep)
{
  OSStatus err;
  
  err = DoOutgoingBind(ep);
  
  if (err == noErr) {
    InetAddress sndAddr;
    InetAddress rcvAddr;
    TCall sndCall;
    TCall rcvCall;
    
    OTInitInetAddress(&amp;sndAddr, 7, 0x7f000001);    // localhost addr
    OTMemzero(&amp;rcvAddr, sizeof(rcvAddr));

    OTMemzero(&amp;sndCall, sizeof(sndCall));
    sndCall.addr.buf = (UInt8 *) &amp;sndAddr;
    sndCall.addr.len = sizeof(sndAddr);
    
    OTMemzero(&amp;rcvCall, sizeof(rcvCall));
    rcvCall.addr.buf    = (UInt8 *) &amp;rcvAddr;
    rcvCall.addr.maxlen = sizeof(rcvAddr);
    
    err = OTMPXConnect(ep, &amp;sndCall, &amp;rcvCall);
    if (err == noErr) {
      OTFlags flags;
      char rcvBuf[100];
      
      printf(&quot;\n&quot;);
      printf(&quot;Now quit Mac TCP Watcher.\n&quot;);
      
      OTMemzero(rcvBuf, sizeof(rcvBuf));
      flags = 0;
      err = OTMPXRcv(ep, rcvBuf, sizeof(rcvBuf), &amp;flags);
      if (err == kOTLookErr) {
        OTResult look;

        look = OTMPXLook(ep);
        if (look == T_DISCONNECT) {
          TDiscon discon;
          
          OTMemzero(&amp;discon, sizeof(discon));
          err = OTMPXRcvDisconnect(ep, &amp;discon);
          if (err == noErr) {
            printf(&quot;\n&quot;);
            printf(&quot;Received disconnected with reason %ld.\n&quot;, discon.reason);
          }
        } else {
          printf(&quot;\n&quot;);
          printf(&quot;look = %ld\n&quot;, look);
        }
      }
    }
  }
  
  if (err == noErr) {
    err = OTMPXUnbind(ep);
  }

  return err;
}

static OSStatus ListenTest(OTMPEndpointRef ep)
{
  OSStatus err;
  OSStatus junk;
  TCall call;
  InetAddress remoteAddr;
  OTMPEndpointRef worker;
  
  worker = NULL;
  err = SetFourByteOption(ep, INET_IP, IP_REUSEADDR, 0);
  if (err == noErr) {
    err = DoIncomingBind(ep, 1024, 10);
  }
  if (err == noErr) {
    OTMemzero(&amp;remoteAddr, sizeof(remoteAddr));
    OTMemzero(&amp;call, sizeof(call));
    
    call.addr.buf    = (UInt8 *) &amp;remoteAddr;
    call.addr.maxlen = sizeof(remoteAddr);
    
    err = OTMPXListen(ep, &amp;call);
    if (err == noErr) {
      char addrAsStr[100];
      
      OTInetHostToString(remoteAddr.fHost, addrAsStr);
      printf(&quot;\n&quot;);
      printf(&quot;Call from %s:%d\n&quot;, addrAsStr, remoteAddr.fPort);
      
      worker = OTMPXOpenEndpointQInContext(&quot;tcp&quot;, 0, NULL, &amp;err, NULL);
    }
    if (err == noErr) {
      err = OTMPXAccept(ep, worker, &amp;call);
    }
  }
  if (err == noErr) {
    err = OTMPXSndDisconnect(worker, NULL);
  }
  if (err == noErr) {
    err = OTMPXUnbind(ep);
  }
  if (worker != NULL) {
    junk = OTMPXCloseProvider(worker);
    assert(junk == noErr);
  }
  return err;
}

static OSStatus MiscEndpointTest(OTMPEndpointRef ep)
{
  OSStatus err;
  OSStatus junk;
  TEndpointInfo info;
  char addrAsStr[100];
  
  err = OTMPXGetEndpointInfo(ep, &amp;info);
  if (err == noErr) {
    printf(&quot;addr     = %ld\n&quot;, info.addr);
    printf(&quot;options  = %ld\n&quot;, info.options);
    printf(&quot;tsdu     = %ld\n&quot;, info.tsdu);
    printf(&quot;etsdu    = %ld\n&quot;, info.etsdu);
    printf(&quot;connect  = %ld\n&quot;, info.connect);
    printf(&quot;discon   = %ld\n&quot;, info.discon);
    printf(&quot;servtype = %ld\n&quot;, info.servtype);
    printf(&quot;flags    = %ld\n&quot;, info.flags);
  }
  if (err == noErr) {
    err = OTMPXGetEndpointState(ep);
    if (err &gt;= noErr) {
      printf(&quot;state1 = %ld\n&quot;, err);
      err = noErr;
    }
  }
  if (err == noErr) {
    err = OTMPXBind(ep, NULL, NULL);
  }
  if (err == noErr) {
    err = OTMPXGetEndpointState(ep);
    if (err &gt;= noErr) {
      printf(&quot;state2 = %ld\n&quot;, err);
      err = noErr;
    }
    if (err == noErr) {
      TBind local;
      InetAddress localAddr;
      
      OTMemzero(&amp;localAddr, sizeof(localAddr));
      OTMemzero(&amp;local, sizeof(local));
      local.addr.maxlen = sizeof(localAddr);
      local.addr.buf    = (UInt8 *) &amp;localAddr;
      err = OTMPXGetProtAddress(ep, &amp;local, NULL);
      if (err == noErr) {
        OTInetHostToString(localAddr.fHost, addrAsStr);
        printf(&quot;localAddr = %s:%d\n&quot;, addrAsStr, localAddr.fPort);
      }
    }
    if (err == noErr) {
      TBind dns;
      TBind inet;
      DNSAddress  dnsAddr;
      InetAddress inetAddr;
      
      OTMemzero(&amp;dns, sizeof(dns));
      OTMemzero(&amp;inet, sizeof(inet));
      OTMemzero(&amp;inetAddr, sizeof(inetAddr));
      
      dns.addr.len = OTInitDNSAddress(&amp;dnsAddr, &quot;1.2.3.4:80&quot;);
      dns.addr.buf = (UInt8 *) &amp;dnsAddr;
      
      inet.addr.maxlen = sizeof(inetAddr);
      inet.addr.buf    = (UInt8 *) &amp;inetAddr;
      
      err = OTMPXResolveAddress(ep, &amp;dns, &amp;inet, 1000);
      if (err == noErr) {
        OTInetHostToString(inetAddr.fHost, addrAsStr);
        printf(&quot;inetAddr = %s:%d\n&quot;, addrAsStr, inetAddr.fPort);
      }
    }
    junk = OTMPXUnbind(ep);
    assert(junk == noErr);
  }
  if (err == noErr) {
    OTByteCount byteCount;

    byteCount = 666;
    err = OTMPXCountDataBytes(ep, &amp;byteCount);
    assert(err == kOTNoDataErr);
    assert(byteCount == 0);
    if (err == kOTNoDataErr) {
      printf(&quot;byteCount = %ld\n&quot;, byteCount);
      err = noErr;
    } else {
      err = -1;
    }
  }

  return err;
}

static OSStatus UnitDataTest(void)
{
  OSStatus err;
  OTMPEndpointRef ep;
  TUnitData udata;
  const char *message = &quot;Hello Cruel World!\x0d\x0a&quot;;
  
  ep = OTMPXOpenEndpointQInContext(&quot;udp&quot;, 0, NULL, &amp;err, NULL);
  if (err == noErr) {
    err = OTMPXBind(ep, NULL, NULL);
  }
  if (err == noErr) {
    InetAddress dest;
    
    OTMemzero(&amp;udata, sizeof(udata));
    OTInitInetAddress(&amp;dest, 7, 0x01020304);
    udata.addr.len = sizeof(dest);
    udata.addr.buf = (UInt8 *) &amp;dest;
    udata.udata.len = OTStrLength(message);
    udata.udata.buf = (UInt8 *) message;
    err = OTMPXSndUData(ep, &amp;udata);
  }
  if (err == noErr) {
    char buffer[256];
    InetAddress src;
    OTFlags junkFlags;
    
    OTMemzero(&amp;udata, sizeof(udata));
    OTMemzero(&amp;src, sizeof(src));
    udata.addr.maxlen  = sizeof(src);
    udata.addr.buf     = (UInt8 *) &amp;src;
    udata.udata.maxlen = sizeof(buffer);
    udata.udata.buf    = (UInt8 *) buffer;
    
    err = OTMPXRcvUData(ep, &amp;udata, &amp;junkFlags);
    if (err == noErr) {
      if ( udata.udata.len != OTStrLength(message) ||
          ! OTMemcmp(buffer, message, udata.udata.len) ) {
        err = -1;
      }
    } else if (err == kOTLookErr) {
      OTResult look;

      // If echo server isn't running, previous send will generate 
      // an ICMP port unreachable, which the above RcvUData will return 
      // as a look error and which we consume here.
      
      look = OTMPXLook(ep);
      if (look == T_UDERR) {
        TUDErr   uderr;
        
        OTMemzero(&amp;uderr, sizeof(uderr));
        OTMemzero(&amp;src, sizeof(src));
        uderr.addr.maxlen = sizeof(src);
        uderr.addr.buf    = (UInt8 *) &amp;src;
        uderr.opt.maxlen  = sizeof(buffer);
        uderr.opt.buf     = (UInt8 *) buffer;
        
        err = OTMPXRcvUDErr(ep, &amp;uderr);
        if (err == noErr) {
          printf(&quot;uderr src = %08xl\n&quot;, src.fHost);
          printf(&quot;uderr error = %ld\n&quot;, uderr.error);
        }
      }
    }
  }
  if (err == noErr) {
    err = OTMPXUnbind(ep);
  }
  
  if (ep != NULL) {
    OTMPXCloseProvider(ep);
  }
  
  return err;
}

static void BasicDebuggingTests(void)
{
  OSStatus err;
  OSStatus junk;
  OTMPEndpointRef ep;

  InstallOTMPMainThreadYielder(MyMainThreadYielder);
  RunOTMPAsSystemTasks(true);

  ep = OTMPXOpenEndpointQInContext(&quot;tcp&quot;, 0, NULL, &amp;err, NULL);
  if (err == noErr) {
    err = IoctlTest(ep);
    if (err == noErr) {
      // err = BasicEchoTest(ep);
    }
    if (err == noErr) {
      // err = EchoDisconnectTest(ep);
    }
    if (err == noErr) {
      // err = ListenTest(ep);
    }
    if (err == noErr) {
      // err = MiscEndpointTest(ep);
    }
    if (err == noErr) {
      // err = UnitDataTest();
    }
  
    junk = OTMPXCloseProvider(ep);
    assert(junk == noErr);
  }

  if (err == noErr) {
    printf(&quot;Success!\n&quot;);
  } else {
    printf(&quot;Failed with error %ld.\n&quot;, err);
  }

  InstallOTMPMainThreadYielder(NULL);
  RunOTMPAsSystemTasks(false);
}

static void NestedInitTest(void)  
  // Test nested inits.
{
  OSStatus err;
  OTClientContextPtr thisContext;

  err = InitOpenTransportMPInContext(kInitOTForExtensionMask, &amp;thisContext);
  if (err == noErr) {
    CloseOpenTransportMPInContext(thisContext);
  }
  if (err == noErr) {
    printf(&quot;Success!\n&quot;);
  } else {
    printf(&quot;Failed with error %ld.\n&quot;, err);
  }
}

static UInt8 gJunkBuffer[1024];

static volatile Boolean gRcvStarted;

static volatile OTMPEndpointRef gLookerEP;

static volatile Boolean gQuitLooker;

static void RcvSleep()
{
  OSStatus     junk;
  AbsoluteTime   timeToWakeUp;

  MPLogPrintf(&quot;SFCRcv: Going to sleep for 1 seconds&quot;);
  timeToWakeUp = AddDurationToAbsolute(1000, UpTime());
  junk = MPDelayUntil(&amp;timeToWakeUp);
  assert(junk == noErr);
  MPLogPrintf(&quot;SFCRcv: Waking up\n&quot;);
}

static OSStatus SFCRcv(void *parameter)
{
  #pragma unused(parameter)
  OSStatus err;
  OSStatus junk;
  OTMPEndpointRef ep;
  TCall call;
  OTFlags junkFlags;
  UInt32  sleepCounter;

  ep = NULL;
  
  err = OTMPXPrepareThisTask();
  if (err == noErr) {
    ep = OTMPXOpenEndpointQInContext(&quot;tcp&quot;, 0, NULL, &amp;err, NULL);
  }
  if (err == noErr) {
    err = SetFourByteOption(ep, INET_IP, IP_REUSEADDR, 1);
  }
  if (err == noErr) {
    err = DoIncomingBind(ep, 1025, 1);
  }
  gRcvStarted = true;
  if (err == noErr) {
    OTMemzero(&amp;call, sizeof(call));
    err = OTMPXListen(ep, &amp;call);
  }
  if (err == noErr) {
    err = OTMPXAccept(ep, ep, &amp;call);
  }
  if (err == noErr) {
    sleepCounter = 0;
    do {
      if (sleepCounter == 0) {
        RcvSleep();
      }
      err = OTMPXRcv(ep, gJunkBuffer, sizeof(gJunkBuffer), &amp;junkFlags);
      if (err &gt; noErr) {
        err = noErr;
      }
      sleepCounter += 1;
      if (sleepCounter &gt; 64) {
        sleepCounter = 0;
      }
    } while (err == noErr);
    if (err == kOTLookErr) {
      OTResult look;
      
      look = OTMPXLook(ep);
      switch (look) {
        case T_ORDREL:
          err = OTMPXRcvOrderlyDisconnect(ep);
          if (err == noErr) {
            err = OTMPXSndOrderlyDisconnect(ep);
          }
          break;
        case T_DISCONNECT:
          err = OTMPXRcvDisconnect(ep, NULL);
          break;
        default:
          MPLogPrintf(&quot;look = %08lx\n&quot;, look);
          break;
      }
    }
  }
  
  if (ep != NULL) {
    junk = OTMPXCloseProvider(ep);
    assert(junk == noErr);
  }
  
  OTMPXUnprepareThisTask();
  return err;
}

static OSStatus SFCSnd(void *parameter)
{
  #pragma unused(parameter)
  OSStatus err;
  OSStatus junk;
  OTMPEndpointRef ep;
  TCall call;
  InetAddress inet;
  OTByteCount bytesThisTime;
  OTByteCount bytesRemaining;

  ep = NULL;
  
  err = OTMPXPrepareThisTask();
  if (err == noErr) {
    ep = OTMPXOpenEndpointQInContext(&quot;tcp&quot;, 0, NULL, &amp;err, NULL);
  }
  if (err == noErr) {
    gLookerEP = ep;
    err = OTMPXBind(ep, NULL, NULL);
  }
  if (err == noErr) {
    OTInitInetAddress(&amp;inet, 1025, 0x7f000001);      // 127.0.0.1:1025
    OTMemzero(&amp;call, sizeof(call));
    call.addr.buf = (UInt8 *) &amp;inet;
    call.addr.len = sizeof(inet);
    err = OTMPXConnect(ep, &amp;call, NULL);
  }
  if (err == noErr) {
    if (false) {
      bytesRemaining = 0x01000000;            // 16 MB
    } else {
      bytesRemaining = 0x00100000;            // 1 MB
    }
    do {
      if (bytesRemaining &gt; sizeof(gJunkBuffer)) {
        bytesThisTime = sizeof(gJunkBuffer);
      } else {
        bytesThisTime = bytesRemaining;
      }
      err = OTMPXSnd(ep, gJunkBuffer, bytesThisTime, 0);
      if (err &gt; noErr) {
        bytesRemaining -= err;
        err = noErr;
      }
    } while ( (err == noErr) &amp;&amp; (bytesRemaining != 0) );
  }
  if (err == noErr) {
    err = OTMPXSndDisconnect(ep, NULL);
  }
  
  gLookerEP = NULL;
  gQuitLooker = true;
  if (ep != NULL) {
    junk = OTMPXCloseProvider(ep);
    assert(junk == noErr);
  }
  
  OTMPXUnprepareThisTask();
  return err;
}

static SInt32 gLookCounter;

static OSStatus SFCLooker(void *parameter)
{
  #pragma unused(parameter)
  OSStatus err;
  OSStatus junk;
  
  err = OTMPXPrepareThisTask();
  if (err == noErr) {
    while ( ! gQuitLooker ) {
      if ( gLookerEP != NULL ) {
        (void) OTAtomicAdd32(1, &amp;gLookCounter);
        
        junk = OTMPXLook(gLookerEP);
        
        if (1) {
          AbsoluteTime timeToWakeUp;
          
          timeToWakeUp = AddDurationToAbsolute(-64, UpTime());
          junk = MPDelayUntil(&amp;timeToWakeUp);
          assert(junk == noErr);
          
          // MPLogPrintfSlow(&quot;&lt;look&gt;&quot;);
        }
      }
    }
  }
  
  OTMPXUnprepareThisTask();
  return err;
}

static void SendFlowControlTest(void)
{
  OSStatus  err;
  OSStatus  junk;
  MPQueueID deathQueue;
  MPTaskID  rcvTask;
  MPTaskID  sndTask;

  gRcvStarted = false;
  gLookerEP = NULL;
  gQuitLooker = false;
  
  deathQueue = kInvalidID;
  err = MPCreateQueue(&amp;deathQueue);
  if (err == noErr) {
    err = MPCreateTask(SFCRcv, NULL, 65536, deathQueue, (void *) 1, (void *) 666, kNilOptions, &amp;rcvTask);
  }
  if (err == noErr) {
    MPLogPrintf(&quot;Waiting for receiver to start.\n&quot;);
    while ( ! gRcvStarted ) {
      printf(&quot;.&quot;);
      fflush(stdout);
    }
    MPLogPrintf(&quot;\n&quot;);
  }
  if (err == noErr) {
    err = MPCreateTask(SFCSnd, NULL, 65536, deathQueue, (void *) 2, (void *) 666, kNilOptions, &amp;sndTask);
  }
  if (err == noErr) {
    err = MPCreateTask(SFCLooker, NULL, 65536, deathQueue, (void *) 3, (void *) 666, kNilOptions, &amp;rcvTask);
  }
  if (err == noErr) {
    UInt32 terminatedTaskCount;
    UInt32 taskNumber;
    OSStatus taskStatus;
    UInt32 lastPrinted;
    
    lastPrinted = 0;
    terminatedTaskCount = 0;
    do {
      err = MPWaitOnQueue(deathQueue, (void **) &amp;taskNumber, NULL, (void **) &amp;taskStatus, kDurationImmediate);
      if (err == noErr) {
        MPLogPrintf(&quot;Task number %ld completed with status %ld.\n&quot;, taskNumber, taskStatus);
        terminatedTaskCount += 1;
      } else if (err == kMPTimeoutErr) {
        #if !TARGET_API_MAC_CARBON
          SystemTask();
        #endif
        if (TickCount() &gt; (lastPrinted + 60)) {
          printf(&quot;.&quot;);
          fflush(stdout);
          lastPrinted = TickCount();
        }
        err = noErr;
      }
    } while ( (err == noErr) &amp;&amp; (terminatedTaskCount &lt; 3) );
  }
  
  // Clean up.
  
  if (deathQueue != kInvalidID) {
    junk = MPDeleteQueue(deathQueue);
    assert(junk == noErr);
  }

  printf(&quot;gLookCounter = %ld\n&quot;, gLookCounter);
  gLookCounter = 0;
  
  if (err == noErr) {
    printf(&quot;Success!\n&quot;);
  } else {
    printf(&quot;Failed with error %ld.\n&quot;, err);
  }
}

static void DoWriteMPLog(void)
{
  OSStatus err;
  FSSpec fss;
  
  err = FindFolder(kOnSystemDisk, kDesktopFolderType, true, &amp;fss.vRefNum, &amp;fss.parID);
  if (err == noErr) {
    (void) FSMakeFSSpec(fss.vRefNum, fss.parID, &quot;\pMPLog&quot;, &amp;fss);
    err = MPLogWriteToFile(&amp;fss);
  }

  if (err == noErr) {
    printf(&quot;Success!\n&quot;);
  } else {
    printf(&quot;Failed with error %ld.\n&quot;, err);
  }
}

static OSStatus EchoWorker(void *parameter)
{
  OSStatus err;
  OSStatus junk;
  OTMPEndpointRef worker;
  char buffer[1024];      // cheesy, but we do have 64 KB of stack for this thread (-:
  
  worker = (OTMPEndpointRef) parameter;

  err = OTMPXPrepareThisTask();
  if (err == noErr) {
  
    // Echo incoming data back out to the client.
    
    do {
      OTFlags junkFlags;
      
      err = OTMPXRcv(worker, buffer, sizeof(buffer), &amp;junkFlags);
      if (err &gt; noErr) {
        err = OTMPXSnd(worker, buffer, err, 0);
        if (err &gt; noErr) {
          err = noErr;
        }
      }
    } while (err == noErr);

    // The above terminates when the client disconnects.  We 
    // are notified by a kOTLookErr, which we handle below.
    
    if (err == kOTLookErr) {
      OTResult look;
      
      look = OTMPXLook(worker);
      switch (look) {
        case T_DISCONNECT:
          err = OTMPXRcvDisconnect(worker, NULL);
          break;
        case T_ORDREL:
          err = OTMPXSndOrderlyDisconnect(worker);
          break;
        default:
          printf(&quot;look = %08lx\n&quot;, look);
          // leave err set to kOTLookErr
          break;
      }
    }
  }
  
  // Clean up.
  
  junk = OTMPXCloseProvider(worker);
  assert(junk == noErr);
  OTMPXUnprepareThisTask();
  
  return err;
}

static volatile Boolean gEchoListenerStarted;
static MPQueueID gEchoDeathQueue;
static SInt32 gEchoWorkerNumber;

static OSStatus EchoListener(void *parameter)
{
  #pragma unused(parameter)
  OSStatus err;
  OSStatus junk;
  TCall call;
  OTMPEndpointRef listener;

  listener = NULL;
  
  err = OTMPXPrepareThisTask();
  if (err == noErr) {
    listener = OTMPXOpenEndpointQInContext(&quot;tilisten,tcp&quot;, 0, NULL, &amp;err, NULL);
  }
  if (err == noErr) {
    err = SetFourByteOption(listener, INET_IP, IP_REUSEADDR, 1);
  }
  if (err == noErr) {
    err = DoIncomingBind(listener, 1026, 10);
  }
  gEchoListenerStarted = true;
  if (err == noErr) {
    do {
      Boolean listenPending;
      OTMPEndpointRef worker;
      MPTaskID junkTaskID;
      
      worker = NULL;
      
      OTMemzero(&amp;call, sizeof(call));
      err = OTMPXListen(listener, &amp;call);
      listenPending = (err == noErr);
      
      if (err == noErr) {
        worker = OTMPXOpenEndpointQInContext(&quot;tcp&quot;, 0, NULL, &amp;err, NULL);
      }
      if (err == noErr) {
        err = OTMPXAccept(listener, worker, &amp;call);
        listenPending = (err != noErr);
      }
      if (err == noErr) {
        err = MPCreateTask(EchoWorker, worker, 65536, gEchoDeathQueue, (void *) OTAtomicAdd32(1, &amp;gEchoWorkerNumber), NULL, kNilOptions, &amp;junkTaskID);
        if (err == noErr) {
          worker = NULL;
        } else {
          // Typically we get here with a kMPInsufficientResourcesErr 
          // because we don't have the space to allocate the worker's 
          // stack.  If this happens, don't kill the server entirely.
          // Instead, swallow the error, which will cause this thread 
          // to close &quot;worker&quot; and all will be well.
          err = noErr;
        }
      }
      
      // Clean up.
      
      if (listenPending) {
        junk = OTMPXSndDisconnect(listener, &amp;call);
        assert(junk == noErr);
      }
      if (worker != NULL) {
        junk = OTMPXCloseProvider(worker);
        assert(junk == noErr);
      }
    } while (err == noErr);
  }
  
  // Clean up.
  
  if (listener != NULL) {
    junk = OTMPXCloseProvider(listener);
    assert(junk == noErr);
  }
  
  OTMPXUnprepareThisTask();
  gEchoListenerStarted = false;
  return err;
}

static void StartEchoServer(void)
{
  OSStatus err;
  MPTaskID junkTaskID;
  
  err = noErr;
  if (gEchoDeathQueue != kInvalidID) {
    printf(&quot;Echo server is already running.\n&quot;);
    err = userCanceledErr;
  }
  if (err == noErr) {
    err = MPCreateQueue(&amp;gEchoDeathQueue);
  }
  if (err == noErr) {
    err = MPCreateTask(EchoListener, NULL, 65536, gEchoDeathQueue, 0, NULL, kNilOptions, &amp;junkTaskID);
  }

  if (err == noErr) {
    printf(&quot;Success!\n&quot;);
  } else {
    printf(&quot;Failed with error %ld.\n&quot;, err);
  }
}

static void PrintEchoDeathInfo(void)
{
  OSStatus err;
  SInt32   taskNumber;
  OSStatus taskStatus;
  
  err = noErr;
  if (gEchoDeathQueue == kInvalidID) {
    printf(&quot;Echo server is not running.\n&quot;);
    err = userCanceledErr;
  }
  if (err == noErr) {
    do {
      err = MPWaitOnQueue(gEchoDeathQueue, (void **) &amp;taskNumber, NULL, (void **) &amp;taskStatus, kDurationImmediate);
      if (err == noErr) {
        printf(&quot;Task number %ld stopped with error %ld.\n&quot;, taskNumber, taskStatus);
      }
    } while (err == noErr);
    if (err == kMPTimeoutErr) {
      err = noErr;
    }
  }
  
  if (err != noErr) {
    printf(&quot;Failed with error %ld.\n&quot;, err);
  }
}

static void FillSendBuffer(UInt32 buf[], ItemCount numEntries)
{
  ItemCount i;
  
  for (i = 0; i &lt; numEntries; i++) {
    buf[i] = i;
  }
}

static void CheckReceiveBuffer(UInt32 rcvBuf[], UInt32 sndBuf[], ItemCount numEntries)
{
  ItemCount i;
  
  for (i = 0; i &lt; numEntries; i++) {
    assert(rcvBuf[i] == sndBuf[i]);
  }
}

#if TARGET_API_MAC_CARBON

EXTERN_API_C( UInt32 )
OTGetRandomSeed                 (void);
EXTERN_API_C( UInt32 )
OTGetRandomNumber               (UInt32 *               seed,
                                 UInt32                 lo,
                                 UInt32                 hi);

EXTERN_API_C( UInt32 )
OTGetRandomSeed                 (void)
{
  return 0;
}

EXTERN_API_C( UInt32 )
OTGetRandomNumber               (UInt32 *               seed,
                                 UInt32                 lo,
                                 UInt32                 hi)
{
  #pragma unused(seed)
  #pragma unused(lo)
  #pragma unused(hi)
  return 0;
}

#endif

static SInt32 gPoundersRunning;

static OSStatus EchoPounder(void *parameter)
{
  OSStatus     err;
  OSStatus     junk;
  InetHost    ipAddr;
  OTMPEndpointRef ep;
  InetAddress    inetAddr;
  TCall       call;
  UInt32      sndBuffer[256];
  UInt32      rcvBuffer[256];
  UInt32      seed;

  ipAddr = (InetHost) parameter;
  
  ep = NULL;
  seed = OTGetRandomSeed();
  
  err = OTMPXPrepareThisTask();
  if (err == noErr) {
    ep = OTMPXOpenEndpointQInContext(&quot;tcp&quot;, 0, NULL, &amp;err, NULL);
  }
  if (err == noErr) {
    err = OTMPXBind(ep, NULL, NULL);
  }
  if (err == noErr) {
    OTInitInetAddress(&amp;inetAddr, 1026, ipAddr);
    OTMemzero(&amp;call, sizeof(call));
    call.addr.buf = (UInt8 *) &amp;inetAddr;
    call.addr.len = sizeof(inetAddr);
    err = OTMPXConnect(ep, &amp;call, NULL);
  }
  if (err == noErr) {
    UInt32 numberOfBlocksLeftToSend;
    
    // MPLogPrintfSlow(&quot;seed = %08lx\n&quot;, seed);
    numberOfBlocksLeftToSend = OTGetRandomNumber(&amp;seed, 0, 100);
    // MPLogPrintfSlow(&quot;numberOfBlocksLeftToSend = %ld\n&quot;, numberOfBlocksLeftToSend);
    while (err == noErr &amp;&amp; numberOfBlocksLeftToSend &gt; 0) {
      FillSendBuffer(sndBuffer, 256);
      err = OTMPXSnd(ep, sndBuffer, sizeof(sndBuffer), 0);
      if (err &gt; noErr) {
        err = noErr;
      }
      if (err == noErr) {
        OTByteCount bytesNeeded;
        char *    rcvCursor;
        OTFlags   junkFlags;
        
        bytesNeeded = 256 * sizeof(UInt32);
        rcvCursor = (char *) rcvBuffer;
        do {
          err = OTMPXRcv(ep, rcvCursor, bytesNeeded, &amp;junkFlags);
          if (err &gt; noErr) {
            rcvCursor += err;
            bytesNeeded -= err;
            err = noErr;
          }
        } while (err == noErr &amp;&amp; bytesNeeded != 0);
      }
      if (err == noErr) {
        CheckReceiveBuffer(rcvBuffer, sndBuffer, 256);
        numberOfBlocksLeftToSend -= 1;
      }
    };
  }
  if (err == noErr) {
    err = OrderlyDisconnect(ep);
  }
  
  if (ep != NULL) {
    junk = OTMPXCloseProvider(ep);
    assert(junk == noErr);
  }
  OTMPXUnprepareThisTask();

  (void) OTAtomicAdd32(-1, &amp;gPoundersRunning);

  return err;
}

static SInt32 gPounderNumber;

static void PoundEchoServer(Boolean lotsOfPounding)
{
  OSStatus   err;
  char     ipAddrStr[256];
  InetHost   ipAddr;
  MPTaskID   junkTaskID;

  err = noErr;
  printf(&quot;Enter IP address of echo server:\n&quot;);
  gets(ipAddrStr);
  if (ipAddrStr[0] == 'q') {
    err = userCanceledErr;
  }
  if (err == noErr) {
    if (ipAddrStr[0] == 0) {
      ipAddr = 0x7f000001;      // 127.0.0.1
    } else {
      err = OTInetStringToHost(ipAddrStr, &amp;ipAddr);
    }
  }
  if (err == noErr) {
    if (lotsOfPounding) {
      UInt32 startTicks;
      UInt32 lastPrinted;
      
      startTicks = TickCount();
      lastPrinted = TickCount();
      do {
        if (TickCount() &gt; (lastPrinted + 30)) {
          printf(&quot;.&quot;);
          fflush(stdout);
          lastPrinted = TickCount();
        }
        if (gPoundersRunning &lt; 5) {
          gPounderNumber -= 1;
          err = MPCreateTask(EchoPounder, (void *) ipAddr, 65536, gEchoDeathQueue, (void *) gPounderNumber, NULL, kNilOptions, &amp;junkTaskID);
          if (err == noErr) {
            (void) OTAtomicAdd32(1, &amp;gPoundersRunning);
          }
        }
      } while ( (err == noErr) &amp;&amp; (TickCount() &lt; (startTicks + (60 * 60))) );
    } else {
      gPounderNumber -= 1;
      err = MPCreateTask(EchoPounder, (void *) ipAddr, 65536, gEchoDeathQueue, (void *) gPounderNumber, NULL, kNilOptions, &amp;junkTaskID);
    }
  }
  
  if (err == noErr) {
    printf(&quot;Success!\n&quot;);
  } else {
    printf(&quot;Failed with error %ld.\n&quot;, err);
  }
}

static void RawStreamTest(void)
{
  OSStatus     err;
  OSStatus     junk;
  OTMPEndpointRef ep;
  UInt32       i;
  UInt32       data;
  strbuf       dataBuf;

  dataBuf.buf   = (char *) &amp;data;
  dataBuf.len   = sizeof(data);
  dataBuf.maxlen   = sizeof(data);
  
  ep = OTMPOpenEndpointQInContext(&quot;QTestMod&quot;, 0, NULL, &amp;err, NULL);
  if (err == noErr) {
    for (i = 0; i &lt; 1000; i++) {
      data = i;
      err = OTMPPutMessage(ep, NULL, &amp;dataBuf, 0);
      if (err != noErr) {
        break;
      }
    }
  }
  if (err == noErr) {
    for (i = 0; i &lt; 1000; i++) {
      OTFlags flags;
      err = OTMPGetMessage(ep, NULL, &amp;dataBuf, &amp;flags);
      if (err == noErr) {
        assert(dataBuf.len == sizeof(data));
        assert(i == data);
      } else {
        break;
      }
    }
  }
  
  if (ep != NULL) {
    junk = OTMPCloseProvider(ep);
    assert(junk == noErr);
  }

  if (err == noErr) {
    printf(&quot;Success.\n&quot;);
  } else {
    printf(&quot;Failed with error %ld.\n&quot;, err);
  }
}

static OSStatus ConnectTask(void *parameter)
{
  #pragma unused(parameter)
  OSStatus err;
  OSStatus junk;
  OTMPEndpointRef ep;

  ep = NULL;

  DebugStr(&quot;\pFoo&quot;);
    
  err = OTMPXPrepareThisTask();
  if (err == noErr) {
    ep = OTMPXOpenEndpointQInContext(&quot;tcp&quot;, 0, NULL, &amp;err, NULL);
  }
  if (err == noErr) {
    err = OTMPXBind(ep, NULL, NULL);
  }
  if (err == noErr) {
    TCall sndCall;
    DNSAddress dnsAddr;
    
    OTMemzero(&amp;sndCall, sizeof(sndCall));
    sndCall.addr.buf = (UInt8 *) &amp;dnsAddr;
    sndCall.addr.len = OTInitDNSAddress(&amp;dnsAddr, &quot;www.apple.com:80&quot;);
    
    err = OTMPXConnect(ep, &amp;sndCall, NULL);
  }
  if (err == noErr) {
    OTByteCount numBytes;
    
    err = OTMPXCountDataBytes(ep, &amp;numBytes);
    MPLog2(kOTMPAPILogID, 'CNT!', (void *) err, (void *) numBytes);
  }
  
  if (ep != NULL) {
    junk = OTMPXCloseProvider(ep);
    assert(junk == noErr);
  }
  
  OTMPXUnprepareThisTask();
  return err;
}

static void DoOTMPConnectTest(void)
{
  OSStatus   err;
  OSStatus   junk;
  MPQueueID   deathQueue;
  MPTaskID    junkTask;
  OSStatus  taskStatus;
  Boolean    done;
  UInt32    lastPrinted;

  deathQueue = kInvalidID;
  err = MPCreateQueue(&amp;deathQueue);
  if (err == noErr) {
    err = MPCreateTask(ConnectTask, NULL, 65536, deathQueue, (void *) 1, (void *) 666, kNilOptions, &amp;junkTask);
  }
  if (err == noErr) {
    printf(&quot;Waiting for MP task to terminate.\n&quot;);

    done = false;
    lastPrinted = TickCount();
    do {
      err = MPWaitOnQueue(deathQueue, NULL, NULL, (void **) &amp;taskStatus, kDurationImmediate);
      if (err == noErr) {
        printf(&quot;MP task completed with status %ld.\n&quot;, taskStatus);
        done = true;
      } else if (err == kMPTimeoutErr) {
        #if !TARGET_API_MAC_CARBON
          SystemTask();
        #endif
        if (TickCount() &gt; (lastPrinted + 60)) {
          printf(&quot;.&quot;);
          fflush(stdout);
          lastPrinted = TickCount();
        }
        err = noErr;
      }
    } while ( ! done );
  }
  
  if (deathQueue != kInvalidID) {
    junk = MPDeleteQueue(deathQueue);
    assert(junk == noErr);
  }
  if (err == noErr) {
    printf(&quot;Success.\n&quot;);
  } else {
    printf(&quot;Failed with error %ld.\n&quot;, err);
  }
}

void main(void)
{
  OSStatus err;
  OTClientContextPtr junkContext;
  Boolean quitNow;
  char commandStr[256];

  // Can't use MPLogPrintfSlow because MP isn't initialised yet.
    
  printf(&quot;Hello Cruel World!\n&quot;);
  printf(&quot;OTMPTest.c\n&quot;);

  err = noErr;
  if ( ! MPLibraryIsLoaded() ) {
    err = -1;
  }
  if (err == noErr) {
    err = InitMPLog(65536);
  }
  if (err == noErr) {
    // MPLogSetMask(0xFFFFFFFF);
    MPLogSetMask(0);
    err = InitOpenTransportMPXInContext(kInitOTForApplicationMask, &amp;junkContext);
  }
  if (err == noErr) {
    quitNow = false;
    do {
      printf(&quot;\n&quot;);
      printf(&quot;q) Quit\n&quot;);
      printf(&quot;n) Nested init test\n&quot;);
      printf(&quot;b) Basic debugging test\n&quot;);
      printf(&quot;s) Send flow control test\n&quot;);
      printf(&quot;l) Set MPLog mask\n&quot;);
      printf(&quot;w) Write MPLog\n&quot;);
      printf(&quot;f) Print OTMPSnd flow control info\n&quot;);
      printf(&quot;e) Start echo server\n&quot;);
      printf(&quot;d) Display echo death info\n&quot;);
      printf(&quot;p) Test the echo server\n&quot;);
      printf(&quot;P) Pound echo server\n&quot;);
      printf(&quot;r) Raw stream test\n&quot;);
      printf(&quot;c) OTMPConnect test\n&quot;);
      printf(&quot;Enter a command:\n&quot;);
      gets(commandStr);
      switch (commandStr[0]) {
        case 'q':
          quitNow = true;
          break;
        case 'n':
          NestedInitTest();
          break;
        case 'b':
          BasicDebuggingTests();
          break;
        case 's':
          SendFlowControlTest();
          break;
        case 'l':
          printf(&quot;Enter new log mask (in hex):\n&quot;);
          gets(commandStr);
          if (commandStr[0] != 0) {
            UInt32 newMask;
            
            sscanf(commandStr, &quot;%x&quot;, &amp;newMask);
            MPLogSetMask(newMask);
            printf(&quot;MPLogSetMask(0x%08lx)\n&quot;, newMask);
          }
          break;
        case 'w':
          DoWriteMPLog();
          break;
        case 'f':
          OTMPPrintSndRetryFreqDist();
          break;
        case 'e':
          StartEchoServer();
          break;
        case 'd':
          PrintEchoDeathInfo();
          break;
        case 'p':
        case 'P':
          PoundEchoServer(commandStr[0] == 'P');
          break;
        case 'r':
          RawStreamTest();
          break;
        case 'c':
          DoOTMPConnectTest();
          break;
        default:
          printf(&quot;Huh?\n&quot;);
          break;
      }
    } while (!quitNow);

    // StopEchoServer();
    
    CloseOpenTransportMPXInContext(NULL);
  }
  
  // Test that startup after shutdown works.
  
  if (err == noErr) {
    err = InitOpenTransportMPXInContext(kInitOTForApplicationMask, &amp;junkContext);
    if (err == noErr) {
      CloseOpenTransportMPXInContext(NULL);
    }
  }
  
  printf(&quot;\n&quot;);
  if (err == noErr) {
    printf(&quot;Success!\n&quot;);
  } else {
    printf(&quot;Failed with error %ld\n&quot;, err);
  }
  
  printf(&quot;Done.  Press command-Q to Quit.\n&quot;);
}
</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/MoreIsBetter/listing145.html%3Fid%3DDTS10000732-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/MoreIsBetter/listing145.html%3Fid%3DDTS10000732-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/MoreIsBetter/listing145.html%3Fid%3DDTS10000732-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>