<html><head><title>Mac OS X Developer Tools
 Manual Page For Tcl_FSJoinToPath(3tcl)</title>
<style type="text/css"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { font-size: 1px; background: #ffffff; color: #ffffff; } --></style>
<style type="text/css" media="print, aural, braille, embossed, projection, tty"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { display: none; } --></style>
</head><body bgcolor="white">
<a name="//apple_ref/doc/man/3tcl/Tcl_FSJoinToPath" title="Mac OS X Developer Tools
 Manual Page for Tcl_FSJoinToPath(3tcl)"><a name="//apple_ref/doc/man/3/Tcl_FSJoinToPath" title="Mac OS X Developer Tools
 Manual Page for Tcl_FSJoinToPath(3tcl)"><!-- headerDoc=man; indexgroup=Section 3tcl; uid="//apple_ref/doc/man/3tcl/Tcl_FSJoinToPath"; name=Tcl_FSJoinToPath(3tcl) --></a>
<!--#include virtual="/includes/framesetheader"-->
<table width=600><tr><td scope="row">
<!-- begin breadcrumb insert request --><font face="Geneva,Helvetica,Arial" size="1">
 <a target="_top" href="http://developer.apple.com">ADC Home</a> <b>&gt;</b> <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> <b>&gt;</b> <a href="../../../../../reference/index.html#//apple_ref/doc/uid/TP30001281" target="_top">Reference</a> <b>&gt;</b> <!-- a href="" target="_top" -->Mac OS X<!-- /a --> <b>&gt;</b> <a href="../index.html#//apple_ref/doc/framework/manpages" target="_top">Mac OS X Man Pages</a></font>
<!-- end breadcrumb insert request -->
<p>&nbsp;</p>
</td></tr></table>
<!-- end of header -->
<table border="0"  cellpadding="2" cellspacing="2" width="630pt"><tr><td valign="top" height="12" colspan="5" scope="row">
<p style='text-align:justify;'>This document is a Mac&nbsp;OS&nbsp;X manual page.  Manual pages are a command-line technology
for providing documentation.  You can view these manual pages locally using the
<a href="../man1/man.1.html#//apple_ref/doc/man/1/man">man(1)</a> command.
These manual pages come from many different sources, and thus, have a variety of writing
styles.</p>

<p style='text-align:justify;'>This manual page is associated with the Mac&nbsp;OS&nbsp;X
developer tools.  The software or headers described may not be present on your
Mac&nbsp;OS&nbsp;X installation until you install the developer tools
package.  This package is available on your Mac&nbsp;OS&nbsp;X installation DVD,
and the latest versions can be downloaded from
<a href="http://developer.apple.com/tools/download/">developer.apple.com</a>.</p>

<p style='text-align:justify;'>For more information about the manual page format, see the manual page for 
<a href="../man5/manpages.5.html#//apple_ref/doc/man/5/manpages">manpages(5)</a>.</p>
</td></tr></table>
<hr />
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row"><pre class="manpages"><tt>
Filesystem(3)                              Tcl Library Procedures                              <!-- a -->Filesystem(3)<!-- /a -->



____________________________________________________________________________________________________________

<b>NAME</b>
       Tcl_FSRegister,   Tcl_FSUnregister,   Tcl_FSData,   Tcl_FSMountsChanged,  Tcl_FSGetFileSystemForPath,
       Tcl_FSGetPathType,  Tcl_FSCopyFile,  Tcl_FSCopyDirectory,  Tcl_FSCreateDirectory,   Tcl_FSDeleteFile,
       Tcl_FSRemoveDirectory,    Tcl_FSRenameFile,    Tcl_FSListVolumes,   Tcl_FSEvalFile,   Tcl_FSLoadFile,
       Tcl_FSMatchInDirectory, Tcl_FSLink, Tcl_FSLstat, Tcl_FSUtime, Tcl_FSFileAttrsGet, Tcl_FSFileAttrsSet,
       Tcl_FSFileAttrStrings,  Tcl_FSStat,  Tcl_FSAccess,  Tcl_FSOpenFileChannel, Tcl_FSGetCwd, Tcl_FSChdir,
       Tcl_FSPathSeparator,  Tcl_FSJoinPath,  Tcl_FSSplitPath,  Tcl_FSEqualPaths,   Tcl_FSGetNormalizedPath,
       Tcl_FSJoinToPath,  Tcl_FSConvertToPathType, Tcl_FSGetInternalRep, Tcl_FSGetTranslatedPath, Tcl_FSGet-<font color="#ffffff" class="whiteout">TranslatedStringPath,&nbsp;Tcl_FSGetTranslatedStringPath,</font>
       TranslatedStringPath, Tcl_FSNewNativePath, Tcl_FSGetNativePath, Tcl_FSFileSystemInfo,  Tcl_AllocStat-<font color="#ffffff" class="whiteout">Buf&nbsp;Tcl_AllocStatBuf</font>
       Buf - procedures to interact with any filesystem

<b>SYNOPSIS</b>
       <b>#include</b> <b>&lt;tcl.h&gt;</b>

       int
       <b>Tcl_FSRegister</b>(<u>clientData,</u> <u>fsPtr</u>)

       int
       <b>Tcl_FSUnregister</b>(<u>fsPtr</u>)

       ClientData
       <b>Tcl_FSData</b>(<u>fsPtr</u>)

       void
       <b>Tcl_FSMountsChanged</b>(<u>fsPtr</u>)

       Tcl_Filesystem*
       <b>Tcl_FSGetFileSystemForPath</b>(<u>pathObjPtr</u>)

       Tcl_PathType
       <b>Tcl_FSGetPathType</b>(<u>pathObjPtr</u>)

       int
       <b>Tcl_FSCopyFile</b>(<u>srcPathPtr,</u> <u>destPathPtr</u>)

       int
       <b>Tcl_FSCopyDirectory</b>(<u>srcPathPtr,</u> <u>destPathPtr,</u> <u>errorPtr</u>)

       int
       <b>Tcl_FSCreateDirectory</b>(<u>pathPtr</u>)

       int
       <b>Tcl_FSDeleteFile</b>(<u>pathPtr</u>)

       int
       <b>Tcl_FSRemoveDirectory</b>(<u>pathPtr,</u> <u>int</u> <u>recursive,</u> <u>errorPtr</u>)

       int
       <b>Tcl_FSRenameFile</b>(<u>srcPathPtr,</u> <u>destPathPtr</u>)

       Tcl_Obj*
       <b>Tcl_FSListVolumes</b>(<u>void</u>)

       int
       <b>Tcl_FSEvalFile</b>(<u>interp,</u> <u>pathPtr</u>)

       int
       <b>Tcl_FSLoadFile</b>(<u>interp,</u> <u>pathPtr,</u> <u>sym1,</u> <u>sym2,</u> <u>proc1Ptr,</u> <u>proc2Ptr,</u> <u>handlePtr,</u> <u>unloadProcPtr</u>)

       int
       <b>Tcl_FSMatchInDirectory</b>(<u>interp,</u> <u>result,</u> <u>pathPtr,</u> <u>pattern,</u> <u>types</u>)

       Tcl_Obj*
       <b>Tcl_FSLink</b>(<u>linkNamePtr,</u> <u>toPtr,</u> <u>linkAction</u>)

       int
       <b>Tcl_FSLstat</b>(<u>pathPtr,</u> <u>statPtr</u>)

       int
       <b>Tcl_FSUtime</b>(<u>pathPtr,</u> <u>tval</u>)

       int
       <b>Tcl_FSFileAttrsGet</b>(<u>interp,</u> <u>int</u> <u>index,</u> <u>pathPtr,</u> <u>objPtrRef</u>)

       int
       <b>Tcl_FSFileAttrsSet</b>(<u>interp,</u> <u>int</u> <u>index,</u> <u>pathPtr,</u> <u>Tcl</u><b>_</b><u>Obj</u> <u>*objPtr</u>)

       CONST char**
       <b>Tcl_FSFileAttrStrings</b>(<u>pathPtr,</u> <u>objPtrRef</u>)

       int
       <b>Tcl_FSStat</b>(<u>pathPtr,</u> <u>statPtr</u>)

       int
       <b>Tcl_FSAccess</b>(<u>pathPtr,</u> <u>mode</u>)

       Tcl_Channel
       <b>Tcl_FSOpenFileChannel</b>(<u>interp,</u> <u>pathPtr,</u> <u>modeString,</u> <u>permissions</u>)

       Tcl_Obj*
       <b>Tcl_FSGetCwd</b>(<u>interp</u>)

       int
       <b>Tcl_FSChdir</b>(<u>pathPtr</u>)

       Tcl_Obj*
       <b>Tcl_FSPathSeparator</b>(<u>pathPtr</u>)

       Tcl_Obj*
       <b>Tcl_FSJoinPath</b>(<u>listObj,</u> <u>elements</u>)

       Tcl_Obj*
       <b>Tcl_FSSplitPath</b>(<u>pathPtr,</u> <u>lenPtr</u>)

       int
       <b>Tcl_FSEqualPaths</b>(<u>firstPtr,</u> <u>secondPtr</u>)

       Tcl_Obj*
       <b>Tcl_FSGetNormalizedPath</b>(<u>interp,</u> <u>pathPtr</u>)

       Tcl_Obj*
       <b>Tcl_FSJoinToPath</b>(<u>basePtr,</u> <u>objc,</u> <u>objv</u>)

       int
       <b>Tcl_FSConvertToPathType</b>(<u>interp,</u> <u>pathPtr</u>)

       ClientData
       <b>Tcl_FSGetInternalRep</b>(<u>pathPtr,</u> <u>fsPtr</u>)

       Tcl_Obj*
       <b>Tcl_FSGetTranslatedPath</b>(<u>interp,</u> <u>pathPtr</u>)

       CONST char*
       <b>Tcl_FSGetTranslatedStringPath</b>(<u>interp,</u> <u>pathPtr</u>)

       Tcl_Obj*
       <b>Tcl_FSNewNativePath</b>(<u>fsPtr,</u> <u>clientData</u>)

       CONST char*
       <b>Tcl_FSGetNativePath</b>(<u>pathPtr</u>)

       Tcl_Obj*
       <b>Tcl_FSFileSystemInfo</b>(<u>pathPtr</u>)

       Tcl_StatBuf*
       <b>Tcl_AllocStatBuf</b>()

<b>ARGUMENTS</b>
       Tcl_Filesystem   <u>*fsPtr</u>   (in)      Points to a structure containing the addresses of procedures that
                                           can be called to perform the various filesystem operations.

       Tcl_Obj          <u>*pathPtr</u> (in)      The path represented by this object is used for the operation  in
                                           question.   If  the object does not already have an internal <b>path</b>
                                           representation, it will be converted to have one.

       Tcl_Obj          <u>*srcPathPtr</u>(in)    As for <b>pathPtr</b>, but used for the source file for a copy or rename
                                           operation.

       Tcl_Obj          <u>*destPathPtr</u>(in)   As  for <b>pathPtr</b>, but used for the destination filename for a copy
                                           or rename operation.

       CONST char       <u>*pattern</u> (in)      Only files or directories matching this pattern will be  returned
                                           by <b>Tcl_FSMatchInDirectory</b>.

       GlobTypeData     <u>*types</u>   (in)      Only  files  or  directories  matching the type descriptions con-<font color="#ffffff" class="whiteout">tained&nbsp;contained</font>
                                           tained in this structure will be returned by  <b>Tcl_FSMatchInDirec</b>-<font color="#ffffff" class="whiteout">tory.&nbsp;Tcl_FSMatchInDirectory.</font>
                                           <b>tory</b>.  It is very important that the 'directory' flag is properly
                                           handled.  This parameter may be NULL.

       Tcl_Interp       <u>*interp</u>  (in)      Interpreter to use either for results, evaluation,  or  reporting
                                           error messages.

       ClientData       <u>clientData</u>(in)     The native description of the path object to create.

       Tcl_Obj          <u>*firstPtr</u>(in)      The first of two path objects to compare.  The object may be con-<font color="#ffffff" class="whiteout">verted&nbsp;converted</font>
                                           verted to <b>path</b> type.

       Tcl_Obj          <u>*secondPtr</u>(in)     The second of two path objects to compare.   The  object  may  be
                                           converted to <b>path</b> type.

       Tcl_Obj          <u>*listObj</u> (in)      The list of path elements to operate on with a <b>join</b> operation.

       int              <u>elements</u> (in)      If  non-negative,  the  number  of  elements in the listObj which
                                           should be joined together.  If negative, then  all  elements  are
                                           joined.

       Tcl_Obj          <u>**errorPtr</u>(out)    In  the  case  of  an error, filled with an object containing the
                                           name of the file which caused an error in the various copy/rename
                                           operations.

       Tcl_Obj          <u>**objPtrRef</u>(out)   Filled with an object containing the result of the operation.

       Tcl_Obj          <u>*result</u>  (out)     Pre-allocated  object  in which to store (by lappending) the list
                                           of  files  or  directories  which  are  successfully  matched  in
                                           <b>Tcl_FSMatchInDirectory</b>.

       int              <u>mode</u>     (in)      Mask  consisting  of  one  or  more of R_OK, W_OK, X_OK and F_OK.
                                           R_OK, W_OK and X_OK request checking whether the file exists  and
                                           has   read,  write and  execute  permissions, respectively.  F_OK
                                           just requests checking for the existence of the file.

       Tcl_StatBuf      <u>*statPtr</u> (out)     The structure that contains the result of a stat or lstat  opera-<font color="#ffffff" class="whiteout">tion.&nbsp;operation.</font>
                                           tion.

       CONST char       <u>*sym1</u>    (in)      Name of a procedure to look up in the file's symbol table

       CONST char       <u>*sym2</u>    (in)      Name of a procedure to look up in the file's symbol table

       Tcl_PackageInitProc       <u>**proc1Ptr</u>(out)
                                           Filled with the init function for this code.

       Tcl_PackageInitProc       <u>**proc2Ptr</u>(out)
                                           Filled with the safe-init function for this code.

       ClientData       <u>*clientDataPtr</u>(out)
                                           Filled  with  the  clientData value to pass to this code's unload
                                           function when it is called.

       TclfsUnloadFileProc_      <u>**unloadProcPtr</u>(out)
                                           Filled with the function to use to unload this piece of code.

       utimbuf          <u>*tval</u>    (in)      The access and modification times in this structure are read  and
                                           used to set those values for a given file.

       CONST char       <u>*modeString</u>(in)    Specifies  how  the  file is to be accessed.  May have any of the
                                           values allowed for the <u>mode</u> argument to the Tcl <b>open</b> command.

       int              <u>permissions</u>(in)    POSIX-style permission flags such as 0644.  If a new file is cre-<font color="#ffffff" class="whiteout">ated,&nbsp;created,</font>
                                           ated, these permissions will be set on the created file.

       int              <u>*lenPtr</u>  (out)     If  non-NULL,  filled  with  the  number of elements in the split
                                           path.

       Tcl_Obj          <u>*basePtr</u> (in)      The base path on to which to join the  given  elements.   May  be
                                           NULL.

       int              <u>objc</u>     (in)      The number of elements in <u>objv</u>.

       Tcl_Obj *CONST   <u>objv[]</u>   (in)      The elements to join to the given base path.
____________________________________________________________________________________________________________


<b>DESCRIPTION</b>
       There  are several reasons for calling the <b>Tcl_FS...</b> functions rather than calling system level func-<font color="#ffffff" class="whiteout">tions&nbsp;functions</font>
       tions like <b>access</b> and <b>stat</b> directly.  First, they will work cross-platform,  so  an  extension  which
       calls  them should work unmodified on Unix, MacOS and Windows.  Second, the Windows implementation of
       some of these functions fixes some bugs in the system level calls.  Third, these function calls  deal
       with  any  'Utf to platform-native' path conversions which may be required (and may cache the results
       of such conversions for greater efficiency on subsequent calls).  Fourth,  and  perhaps  most  impor-<font color="#ffffff" class="whiteout">tantly,&nbsp;importantly,</font>
       tantly, all of these functions are 'virtual filesystem aware'.  Any virtual filesystem which has been
       registered (through <b>Tcl_FSRegister</b>) may reroute file access to alternative media or  access  methods.
       This  means  that  all of these functions (and therefore the corresponding <b>file</b>, <b>glob</b>, <b>pwd</b>, <b>cd</b>, <b>open</b>,
       etc.  Tcl commands) may be operate on 'files' which are not native files in  the  native  filesystem.
       This  also  means  that any Tcl extension which accesses the filesystem through this API is automati-<font color="#ffffff" class="whiteout">cally&nbsp;automatically</font>
       cally 'virtual filesystem aware'.  Of course, if an extension accesses the native filesystem directly
       (through platform-specific APIs, for example), then Tcl cannot intercept such calls.

       If  appropriate  vfs's  have  been registered, the 'files' may, to give two examples, be remote (e.g.
       situated on a remote ftp server) or archived (e.g. lying inside a  .zip  archive).   Such  registered
       filesystems  provide a lookup table of functions to implement all or some of the functionality listed
       here.  Finally, the <b>Tcl_FSStat</b> and <b>Tcl_FSLstat</b> calls abstract away from what the 'struct stat' buffer
       buffer is actually declared to be, allowing the same code to be used both on systems with and systems
       without support for files larger than 2GB in size.

       The <b>Tcl_FS...</b> are objectified and may cache internal representations and other  path-related  strings
       (e.g.  the  current working directory).  One side-effect of this is that one must not pass in objects
       with a refCount of zero to any of these functions.  If such calls were handled, they might result  in
       memory  leaks  (under  some  circumstances, the filesystem code may wish to retain a reference to the
       passed in object, and so one must not assume that after any of these calls return, the  object  still
       has  a  refCount  of  zero - it may have been incremented), or in a direct segfault due to the object
       being freed part way through the complex object manipulation required to  ensure  that  the  path  is
       fully  normalized and absolute for filesystem determination.  The practical lesson to learn from this
       is that <b>Tcl_Obj</b> <b>*path</b> <b>=</b> <b>Tcl_NewStringObj(...)</b>  <b>;</b> <b>Tcl_FS...(path)</b> <b>;</b> <b>Tcl_DecrRefCount(path)</b>  is  wrong,
       and  may segfault.  The 'path' must have its refCount incremented before passing it in, or decrement-<font color="#ffffff" class="whiteout">ing&nbsp;decrementing</font>
       ing it.  For this reason, objects with a refCount of zero are considered not to be  valid  filesystem
       paths and calling any Tcl_FS API with such an object will result in no action being taken.

       <b>Tcl_FSCopyFile</b>  attempts  to copy the file given by srcPathPtr to the path name given by destPathPtr.
       If the two paths given lie in the same filesystem (according to <b>Tcl_FSGetFileSystemForPath</b>) then that
       filesystem's  'copy  file' function is called (if it is non-NULL).  Otherwise the function returns -1
       and sets Tcl's errno to the 'EXDEV' posix error code (which signifies a 'cross-domain link').

       <b>Tcl_FSCopyDirectory</b> attempts to copy the directory given by srcPathPtr to  the  path  name  given  by
       destPathPtr.  If the two paths given lie in the same filesystem (according to <b>Tcl_FSGetFileSystemFor</b>-<font color="#ffffff" class="whiteout">Path)&nbsp;Tcl_FSGetFileSystemForPath)</font>
       <b>Path</b>) then that filesystem's 'copy file' function is called (if it is non-NULL).  Otherwise the func-<font color="#ffffff" class="whiteout">tion&nbsp;function</font>
       tion returns -1 and sets Tcl's errno to the 'EXDEV' posix error code (which signifies a 'cross-domain
       link').

       <b>Tcl_FSCreateDirectory</b> attempts to create the  directory  given  by  pathPtr  by  calling  the  owning
       filesystem's 'create directory' function.

       <b>Tcl_FSDeleteFile</b>  attempts  to  delete  the  file given by pathPtr by calling the owning filesystem's
       'delete file' function.

       <b>Tcl_FSRemoveDirectory</b> attempts to remove the  directory  given  by  pathPtr  by  calling  the  owning
       filesystem's 'remove directory' function.

       <b>Tcl_FSRenameFile</b>  attempts to rename the file or directory given by srcPathPtr to the path name given
       by destPathPtr.  If the two paths given lie in the same filesystem (according to <b>Tcl_FSGetFileSystem</b>-<font color="#ffffff" class="whiteout">ForPath)&nbsp;Tcl_FSGetFileSystemForPath)</font>
       <b>ForPath</b>)  then that filesystem's 'rename file' function is called (if it is non-NULL).  Otherwise the
       function returns -1 and sets Tcl's errno to the 'EXDEV' posix error code (which signifies a  ``cross-<font color="#ffffff" class="whiteout">domain&nbsp;``crossdomain</font>
       domain link'').

       <b>Tcl_FSListVolumes</b> calls each filesystem which has a non-NULL 'list volumes' function and asks them to
       return their list of root volumes.  It accumulates the return values in a list which is  returned  to
       the caller (with a refCount of 0).

       <b>Tcl_FSEvalFile</b>  reads  the  file  given  by  <u>pathPtr</u>  and evaluates its contents as a Tcl script.  It
       returns the same information as <b>Tcl_EvalObjEx</b>.  If the file couldn't be read  then  a  Tcl  error  is
       returned  to  describe  why  the  file couldn't be read.  The eofchar for files is '\32' (^Z) for all
       platforms.  If you require a  ``^Z''  in  code  for  string  comparison,  you  can  use  ``\032''  or
       ``\u001a'', which will be safely substituted by the Tcl interpreter into ``^Z''.

       <b>Tcl_FSLoadFile</b> dynamically loads a binary code file into memory and returns the addresses of two pro-<font color="#ffffff" class="whiteout">cedures&nbsp;procedures</font>
       cedures within that file, if they are defined.  The appropriate function for the filesystem to  which
       pathPtr  belongs  will  be called.  If that filesystem does not implement this function (most virtual
       filesystems will not, because of OS limitations in dynamically loading binary code), Tcl will attempt
       to copy the file to a temporary directory and load that temporary file.

       Returns a standard Tcl completion code.  If an error occurs, an error message is left in the interp's
       result.

       <b>Tcl_FSMatchInDirectory</b> is used by the globbing code to search a directory for all files which match a
       given  pattern.  The appropriate function for the filesystem to which pathPtr belongs will be called.

       The return value is a standard Tcl result indicating whether an error occurred  in  globbing.   Error
       messages are placed in interp, but good results are placed in the resultPtr given.
                          Note  that the 'glob' code implements recursive patterns internally, so this func-<font color="#ffffff" class="whiteout">tion&nbsp;function</font>
       tion will only ever be passed simple patterns, which can  be  matched  using  the  logic  of  'string
       match'.   To  handle recursion, Tcl will call this function frequently asking only for directories to
       be returned.

       <b>Tcl_FSLink</b> replaces the library version of readlink(), and extends it  to  support  the  creation  of
       links.  The appropriate function for the filesystem to which linkNamePtr belongs will be called.

       If  the  <u>toPtr</u>  is NULL, a readlink action is performed.  The result is a Tcl_Obj specifying the con-<font color="#ffffff" class="whiteout">tents&nbsp;contents</font>
       tents of the symbolic link given by <u>linkNamePtr</u>, or NULL if the link could not be read.   The  result
       is  owned  by the caller, which should call Tcl_DecrRefCount when the result is no longer needed.  If
       the <u>toPtr</u> is not NULL, Tcl should create a link of one of the types passed in in the <u>linkAction</u> flag.
       This  flag  is  an  or'd  combination  of TCL_CREATE_SYMBOLIC_LINK and TCL_CREATE_HARD_LINK.  Where a
       choice exists (i.e. more than one flag is passed in), the Tcl convention is to prefer symbolic links.
       When  a  link  is  successfully created, the return value should be <u>toPtr</u> (which is therefore already
       owned by the caller).  If unsuccessful, NULL should be returned.

       <b>Tcl_FSLstat</b> fills the stat structure <u>statPtr</u> with information about the specified file.  You  do  not
       need any access rights to the file to get this information but you need search rights to all directo-<font color="#ffffff" class="whiteout">ries&nbsp;directories</font>
       ries named in the path leading to the file.  The stat structure includes info regarding device, inode
       (always  0  on  Windows), privilege mode, nlink (always 1 on Windows), user id (always 0 on Windows),
       group id (always 0 on Windows), rdev (same as device on Windows), size, last access time, last  modi-<font color="#ffffff" class="whiteout">fication&nbsp;modification</font>
       fication time, and creation time.

       If  <u>path</u>  exists, <b>Tcl_FSLstat</b> returns 0 and the stat structure is filled with data.  Otherwise, -1 is
       returned, and no stat info is given.

       <b>Tcl_FSUtime</b> replaces the library version of utime.

       For results see 'utime' documentation.  If successful, the  function  will  update  the  'atime'  and
       'mtime' values of the file given.

       <b>Tcl_FSFileAttrsGet</b>  implements read access for the hookable 'file attributes' subcommand.  The appro-<font color="#ffffff" class="whiteout">priate&nbsp;appropriate</font>
       priate function for the filesystem to which pathPtr belongs will be called.

       If the result is TCL_OK, then an object was placed in objPtrRef, which will only be temporarily valid
       (unless Tcl_IncrRefCount is called).

       <b>Tcl_FSFileAttrsSet</b> implements write access for the hookable 'file attributes' subcommand.  The appro-<font color="#ffffff" class="whiteout">priate&nbsp;appropriate</font>
       priate function for the filesystem to which pathPtr belongs will be called.

       <b>Tcl_FSFileAttrStrings</b> implements part of the hookable 'file attributes' subcommand.  The  appropriate
       function for the filesystem to which pathPtr belongs will be called.

       The  called  procedure  may either return an array of strings, or may instead return NULL and place a
       Tcl list into the given objPtrRef.  Tcl will take that list and first increment its  refCount  before
       using  it.   On completion of that use, Tcl will decrement its refCount.  Hence if the list should be
       disposed of by Tcl when done, it should have a refCount of zero, and if the list should not  be  dis-<font color="#ffffff" class="whiteout">posed&nbsp;disposed</font>
       posed of, the filesystem should ensure it retains a refCount on the object.

       <b>Tcl_FSAccess</b>  checks whether the process would be allowed to read, write or test for existence of the
       file (or other file system object) whose name is pathname.   If pathname is a symbolic link on  Unix,
       then permissions of the file referred by this symbolic link are tested.

       On success (all requested permissions granted), zero is returned.  On error (at least one bit in mode
       asked for a permission that is denied, or some other  error occurred), -1 is returned.

       <b>Tcl_FSStat</b> fills the stat structure <u>statPtr</u> with information about the specified file.   You  do  not
       need any access rights to the file to get this information but you need search rights to all directo-<font color="#ffffff" class="whiteout">ries&nbsp;directories</font>
       ries named in the path leading to the file.  The stat structure includes info regarding device, inode
       (always  0  on  Windows), privilege mode, nlink (always 1 on Windows), user id (always 0 on Windows),
       group id (always 0 on Windows), rdev (same as device on Windows), size, last access time, last  modi-<font color="#ffffff" class="whiteout">fication&nbsp;modification</font>
       fication time, and creation time.

       If  <u>path</u>  exists,  <b>Tcl_FSStat</b> returns 0 and the stat structure is filled with data.  Otherwise, -1 is
       returned, and no stat info is given.

       <b>Tcl_FSOpenFileChannel</b> opens a file specified by <u>pathPtr</u> and returns a channel handle that can be used
       to  perform  input  and output on the file. This API is modeled after the <b>fopen</b> procedure of the Unix
       standard I/O library.  The syntax and meaning of all arguments is similar to those given in  the  Tcl
       <b>open</b>  command when opening a file.  If an error occurs while opening the channel, <b>Tcl_FSOpenFileChan</b>-<font color="#ffffff" class="whiteout">nel&nbsp;Tcl_FSOpenFileChannel</font>
       <b>nel</b> returns NULL and records a POSIX error code that can be retrieved with  <b>Tcl_GetErrno</b>.   In  addi-<font color="#ffffff" class="whiteout">tion,&nbsp;addition,</font>
       tion,  if  <u>interp</u> is non-NULL, <b>Tcl_FSOpenFileChannel</b> leaves an error message in <u>interp</u>'s result after
       any error.

       The newly created channel is not registered in the supplied interpreter; to register it, use <b>Tcl_Reg</b>-<font color="#ffffff" class="whiteout">isterChannel,&nbsp;Tcl_RegisterChannel,</font>
       <b>isterChannel</b>,  described  below.  If one of the standard channels, <b>stdin,</b> <b>stdout</b> or <b>stderr</b> was previ-<font color="#ffffff" class="whiteout">ously&nbsp;previously</font>
       ously closed, the act of creating the new channel also assigns it as a replacement for  the  standard
       channel.

       <b>Tcl_FSGetCwd</b> replaces the library version of getcwd().

       It  returns  the  Tcl library's current working directory.  This may be different to the native plat-<font color="#ffffff" class="whiteout">form's&nbsp;platform's</font>
       form's working directory, in the case for which the cwd is not in the native filesystem.

       The result is a pointer to a Tcl_Obj specifying the current directory, or NULL if the current  direc-<font color="#ffffff" class="whiteout">tory&nbsp;directory</font>
       tory  could not be determined.  If NULL is returned, an error message is left in the interp's result.
                         The result already has its refCount incremented for the  caller.   When  it  is  no
       longer  needed,  that  refCount should be decremented.  This is needed for thread-safety purposes, to
       allow multiple threads to access this and related functions, while ensuring the  results  are  always
       valid.

       <b>Tcl_FSChdir</b>  replaces  the library version of chdir().  The path is normalized and then passed to the
       filesystem which claims it.  If that filesystem does not implement this function, Tcl  will  fallback
       to a combination of stat and access to check whether the directory exists and has appropriate permis-<font color="#ffffff" class="whiteout">sions.&nbsp;permissions.</font>
       sions.

       For results, see chdir() documentation.  If successful, we keep a record of the  successful  path  in
       cwdPathPtr for subsequent calls to getcwd.

       <b>Tcl_FSPathSeparator</b>  returns the separator character to be used for most specific element of the path
       specified by pathPtr (i.e. the last part of the path).

       The separator is returned as a Tcl_Obj containing a string of length 1.  If the path is invalid, NULL
       is returned.

       <b>Tcl_FSJoinPath</b>  takes  the  given  Tcl_Obj, which should be a valid list, and returns the path object
       given by considering the first 'elements' elements as valid path segments.  If elements &lt; 0,  we  use
       the entire list.

       Returns object with refCount of zero, containing the joined path.

       <b>Tcl_FSSplitPath</b>  takes the given Tcl_Obj, which should be a valid path, and returns a Tcl List object
       containing each segment of that path as an element.

       Returns list object with refCount of zero.  If the passed in lenPtr is non-NULL, we use it to  return
       the number of elements in the returned list.

       <b>Tcl_FSEqualPaths</b> tests whether the two paths given represent the same filesystem object

       It  returns  1  if  the  paths  are equal, and 0 if they are different.  If either path is NULL, 0 is
       always returned.

       <b>Tcl_FSGetNormalizedPath</b> this important function attempts to extract from the given Tcl_Obj  a  unique
       normalized path representation, whose string value can be used as a unique identifier for the file.

       It  returns  the  normalized  path  object, with refCount of zero, or NULL if the path was invalid or
       could otherwise not be successfully converted.  Extraction of  absolute,  normalized  paths  is  very
       efficient  (because the filesystem operates on these representations internally), although the result
       when the filesystem contains numerous symbolic links may not be the most user-friendly version  of  a
       path.

       <b>Tcl_FSJoinToPath</b> takes the given object, which should usually be a valid path or NULL, and joins onto
       it the array of paths segments given.

       Returns object with refCount of zero, containing the joined path.

       <b>Tcl_FSConvertToPathType</b> tries to convert the given Tcl_Obj to a valid Tcl path type,  taking  account
       of  the  fact  that the cwd may have changed even if this object is already supposedly of the correct
       type.  The filename may begin with "~" (to indicate current user's home directory) or  "~&lt;user&gt;"  (to
       indicate any user's home directory).

       If  the conversion succeeds (i.e. the object is a valid path in one of the current filesystems), then
       TCL_OK is returned.  Otherwise TCL_ERROR is returned, and an error message may be left in the  inter-<font color="#ffffff" class="whiteout">preter.&nbsp;interpreter.</font>
       preter.

       <b>Tcl_FSGetInternalRep</b>  extracts  the  internal  representation  of  a  given path object, in the given
       filesystem.  If the path object belongs to a different filesystem, we return NULL.  If  the  internal
       representation  is  currently NULL, we attempt to generate it, by calling the filesystem's <b>Tcl_FSCre</b>-<font color="#ffffff" class="whiteout">ateInternalRepProc.&nbsp;Tcl_FSCreateInternalRepProc.</font>
       <b>ateInternalRepProc</b>.

       Returns NULL or a valid internal path representation.  This internal  representation  is  cached,  so
       that repeated calls to this function will not require additional conversions.

       <b>Tcl_FSGetTranslatedPath</b> attempts to extract the translated path from the given Tcl_Obj.

       If  the  translation succeeds (i.e. the object is a valid path), then it is returned.  Otherwise NULL
       will be returned, and an error message may be left in the interpreter.  A "translated"  path  is  one
       which  contains no "~" or "~user" sequences (these have been expanded to their current representation
       in the filesystem).  The object returned is owned  by  the  caller,  which  must  store  it  or  call
       Tcl_DecrRefCount to ensure memory is freed.  This function is of little practical use, and <b>Tcl_FSGet</b>-<font color="#ffffff" class="whiteout">NormalizedPath&nbsp;Tcl_FSGetNormalizedPath</font>
       <b>NormalizedPath</b> or <b>Tcl_GetNativePath</b> are usually better functions to use for most purposes.

       <b>Tcl_FSGetTranslatedStringPath</b> does the same  as  <b>Tcl_FSGetTranslatedPath</b>,  but  returns  a  character
       string  or  NULL.   The  string returned is dynamically allocated and owned by the caller, which must
       store it or call ckfree to ensure it is freed.  Again, <b>Tcl_FSGetNormalizedPath</b>  or  <b>Tcl_GetNativePath</b>
       are usually better functions to use for most purposes.

       <b>Tcl_FSNewNativePath</b>  performs  something  like that reverse of the usual obj-&gt;path-&gt;nativerep conver-<font color="#ffffff" class="whiteout">sions.&nbsp;conversions.</font>
       sions.  If some code retrieves a path in native form (from, e.g. readlink or a  native  dialog),  and
       that  path is to be used at the Tcl level, then calling this function is an efficient way of creating
       the appropriate path object type.

       The resulting object is a pure 'path' object, which will only receive a Utf-8  string  representation
       if that is required by some Tcl code.

       <b>Tcl_FSGetNativePath</b>  is  for  use  by  the Win/Unix/MacOS native filesystems, so that they can easily
       retrieve the native (char* or TCHAR*) representation of a path.  This function is a convenience wrap-<font color="#ffffff" class="whiteout">per&nbsp;wrapper</font>
       per  around  <b>Tcl_FSGetInternalRep</b>,  and assumes the native representation is string-based.  It may be
       desirable in the future to have non-string-based native representations (for  example,  on  MacOS,  a
       representation  using  a fileSpec of FSRef structure would probably be more efficient).  On Windows a
       full Unicode representation would allow for paths of unlimited length.  Currently the  representation
       is simply a character string containing the complete, absolute path in the native encoding.

       The  native  representation  is cached so that repeated calls to this function will not require addi-<font color="#ffffff" class="whiteout">tional&nbsp;additional</font>
       tional conversions.

       <b>Tcl_FSFileSystemInfo</b> returns a list of two elements.  The first element is the name of the filesystem
       (e.g. "native" or "vfs" or "zip" or "prowrap", perhaps), and the second is the particular type of the
       given path within that filesystem (which is filesystem dependent).  The second element may  be  empty
       if the filesystem does not provide a further categorization of files.

       A  valid  list  object  is  returned,  unless  the  path  object is not recognized, when NULL will be
       returned.

       <b>Tcl_FSGetFileSystemForPath</b> returns the a pointer to the <b>Tcl_Filesystem</b> which  accepts  this  path  as
       valid.

       If no filesystem will accept the path, NULL is returned.

       <b>Tcl_FSGetPathType</b> determines whether the given path is relative to the current directory, relative to
       the current volume, or absolute.

       It returns one of TCL_PATH_ABSOLUTE, TCL_PATH_RELATIVE, or TCL_PATH_VOLUME_RELATIVE

       <b>Tcl_AllocStatBuf</b> allocates a <u>Tcl</u><b>_</b><u>StatBuf</u> on the system heap (which may be deallocated by being passed
       to  <b>ckfree</b>.)   This allows extensions to invoke <b>Tcl_FSStat</b> and <b>Tcl_FSLStat</b> without being dependent on
       the size of the buffer.  That in turn depends on the flags used to build Tcl.


<b>TCL_FILESYSTEM</b>
       A filesystem provides a <b>Tcl_Filesystem</b> structure that contains pointers to functions  that  implement
       the  various operations on a filesystem; these operations are invoked as needed by the generic layer,
       which generally occurs through the functions listed above.

       The <b>Tcl_Filesystem</b> structures are manipulated using the following methods.

       <b>Tcl_FSRegister</b> takes a pointer to a filesystem structure and an optional piece of data to  associated
       with  that filesystem.  On calling this function, Tcl will attach the filesystem to the list of known
       filesystems, and it will become fully functional  immediately.   Tcl  does  not  check  if  the  same
       filesystem is registered multiple times (and in general that is not a good thing to do).  TCL_OK will
       be returned.

       <b>Tcl_FSUnregister</b> removes the given filesystem structure from the list of known filesystems, if it  is
       known, and returns TCL_OK.  If the filesystem is not currently registered, TCL_ERROR is returned.

       <b>Tcl_FSData</b>  will  return  the  ClientData associated with the given filesystem, if that filesystem is
       registered.  Otherwise it will return NULL.

       <b>Tcl_FSMountsChanged</b> is used to inform the Tcl's core that the set  of  mount  points  for  the  given
       (already  registered)  filesystem have changed, and that cached file representations may therefore no
       longer be correct.

       The <b>Tcl_Filesystem</b> structure contains the following fields:
              typedef struct Tcl_Filesystem {
                  CONST char *<u>typeName</u>;
                  int <u>structureLength</u>;
                  Tcl_FSVersion <u>version</u>;
                  Tcl_FSPathInFilesystemProc *<u>pathInFilesystemProc</u>;
                  Tcl_FSDupInternalRepProc *<u>dupInternalRepProc</u>;
                  Tcl_FSFreeInternalRepProc *<u>freeInternalRepProc</u>;
                  Tcl_FSInternalToNormalizedProc *<u>internalToNormalizedProc</u>;
                  Tcl_FSCreateInternalRepProc *<u>createInternalRepProc</u>;
                  Tcl_FSNormalizePathProc *<u>normalizePathProc</u>;
                  Tcl_FSFilesystemPathTypeProc *<u>filesystemPathTypeProc</u>;
                  Tcl_FSFilesystemSeparatorProc *<u>filesystemSeparatorProc</u>;
                  Tcl_FSStatProc *<u>statProc</u>;
                  Tcl_FSAccessProc *<u>accessProc</u>;
                  Tcl_FSOpenFileChannelProc *<u>openFileChannelProc</u>;
                  Tcl_FSMatchInDirectoryProc *<u>matchInDirectoryProc</u>;
                  Tcl_FSUtimeProc *<u>utimeProc</u>;
                  Tcl_FSLinkProc *<u>linkProc</u>;
                  Tcl_FSListVolumesProc *<u>listVolumesProc</u>;
                  Tcl_FSFileAttrStringsProc *<u>fileAttrStringsProc</u>;
                  Tcl_FSFileAttrsGetProc *<u>fileAttrsGetProc</u>;
                  Tcl_FSFileAttrsSetProc *<u>fileAttrsSetProc</u>;
                  Tcl_FSCreateDirectoryProc *<u>createDirectoryProc</u>;
                  Tcl_FSRemoveDirectoryProc *<u>removeDirectoryProc</u>;
                  Tcl_FSDeleteFileProc *<u>deleteFileProc</u>;
                  Tcl_FSCopyFileProc *<u>copyFileProc</u>;
                  Tcl_FSRenameFileProc *<u>renameFileProc</u>;
                  Tcl_FSCopyDirectoryProc *<u>copyDirectoryProc</u>;
                  Tcl_FSLstatProc *<u>lstatProc</u>;
                  Tcl_FSLoadFileProc *<u>loadFileProc</u>;
                  Tcl_FSGetCwdProc *<u>getCwdProc</u>;
                  Tcl_FSChdirProc *<u>chdirProc</u>;
              } Tcl_Filesystem;

       Except for the first three fields in this structure which contain simple data elements,  all  entries
       contain  addresses  of functions called by the generic filesystem layer to perform the complete range
       of filesystem related actions.

       The many functions in this structure are broken down into three categories: infrastructure  functions
       (almost all of which must be implemented), operational functions (which must be implemented if a com-<font color="#ffffff" class="whiteout">plete&nbsp;complete</font>
       plete filesystem is provided), and efficiency functions (which need only be implemented if  they  can
       be  done  so  efficiently, or if they have side-effects which are required by the filesystem; Tcl has
       less efficient emulations it can fall back on).  It is important to note that, in the current version
       of  Tcl,  most  of  these fallbacks are only used to handle commands initiated in Tcl, not in C. What
       this means is, that if a 'file rename' command is issued in Tcl, and the  relevant  <!-- a -->filesystem(s)<!-- /a -->  do
       not  implement their <u>Tcl</u><b>_</b><u>FSRenameFileProc</u>, Tcl's core will instead fallback on a combination of other
       filesystem functions (it  will  use  <u>Tcl</u><b>_</b><u>FSCopyFileProc</u>  followed  by  <u>Tcl</u><b>_</b><u>FSDeleteFileProc</u>,  and  if
       <u>Tcl</u><b>_</b><u>FSCopyFileProc</u>  is  not implemented there is a further fallback).  However, if a <u>Tcl</u><b>_</b><u>FSRenameFile</u>
       command is issued at the C level, no such fallbacks occur.  This is true except  for  the  last  four
       entries  in the filesystem table (lstat, load, getcwd and chdir) for which fallbacks do in fact occur
       at the C level.

       As an example, here is the filesystem lookup table used by the "vfs" extension which allows  filesys-<font color="#ffffff" class="whiteout">tem&nbsp;filesystem</font>
       tem actions to be implemented in Tcl.
              static Tcl_Filesystem vfsFilesystem = {
                  "tclvfs",
                  sizeof(Tcl_Filesystem),
                  TCL_FILESYSTEM_VERSION_1,
                  &amp;VfsPathInFilesystem,
                  &amp;VfsDupInternalRep,
                  &amp;VfsFreeInternalRep,
                  /* No internal to normalized, since we don't create any
                   * pure 'internal' Tcl_Obj path representations */
                  NULL,
                  /* No create native rep function, since we don't use it
                   * and don't choose to support uses of 'Tcl_FSNewNativePath' */
                  NULL,
                  /* Normalize path isn't needed - we assume paths only have
                   * one representation */
                  NULL,
                  &amp;VfsFilesystemPathType,
                  &amp;VfsFilesystemSeparator,
                  &amp;VfsStat,
                  &amp;VfsAccess,
                  &amp;VfsOpenFileChannel,
                  &amp;VfsMatchInDirectory,
                  &amp;VfsUtime,
                  /* We choose not to support symbolic links inside our vfs's */
                  NULL,
                  &amp;VfsListVolumes,
                  &amp;VfsFileAttrStrings,
                  &amp;VfsFileAttrsGet,
                  &amp;VfsFileAttrsSet,
                  &amp;VfsCreateDirectory,
                  &amp;VfsRemoveDirectory,
                  &amp;VfsDeleteFile,
                  /* No copy file - fallback will occur at Tcl level */
                  NULL,
                  /* No rename file - fallback will occur at Tcl level */
                  NULL,
                  /* No copy directory - fallback will occur at Tcl level */
                  NULL,
                  /* Core will use stat for lstat */
                  NULL,
                  /* No load - fallback on core implementation */
                  NULL,
                  /* We don't need a getcwd or chdir - fallback on Tcl's versions */
                  NULL,
                  NULL
              };

       Any  functions  which take path names in Tcl_Obj form take those names in UTF-8 form.  The filesystem
       infrastructure API is designed to support efficient, cached conversion of these UTF-8 paths to  other
       native representations.

<b>TYPENAME</b>
       The  <u>typeName</u>  field  contains  a  null-terminated  string that identifies the type of the filesystem
       implemented, e.g.  <b>native</b> or <b>zip</b> or <b>vfs</b>.


<b>STRUCTURE</b> <b>LENGTH</b>
       The <u>structureLength</u> field is generally implemented as <u>sizeof(Tcl</u><b>_</b><u>Filesystem)</u>, and is there  to  allow
       easier binary backwards compatibility if the size of the structure changes in a future Tcl release.

<b>VERSION</b>
       The <u>version</u> field should be set to <b>TCL_FILESYSTEM_VERSION_1</b>.

<b>FILESYSTEM</b> <b>INFRASTRUCTURE</b>
       These  fields contain addresses of functions which are used to associate a particular filesystem with
       a file path, and deal with the internal handling of path representations,  for  example  copying  and
       freeing such representations.

<b>PATHINFILESYSTEMPROC</b>
       The  <u>pathInFilesystemProc</u>  field  contains  the  address  of  a function which is called to determine
       whether a given path object belongs to this filesystem or not.  Tcl will only call the  rest  of  the
       filesystem  functions  with a path for which this function has returned <b>TCL_OK</b>.  If the path does not
       belong, -1 should be returned (the behaviour of Tcl for any other return value is not  defined).   If
       <b>TCL_OK</b>  is returned, then the optional <b>clientDataPtr</b> output parameter can be used to return an inter-<font color="#ffffff" class="whiteout">nal&nbsp;internal</font>
       nal (filesystem specific) representation of the path, which will be cached inside  the  path  object,
       and  may  be  retrieved efficiently by the other filesystem functions.  Tcl will simultaneously cache
       the fact that this path belongs to this filesystem.  Such  caches  are  invalidated  when  filesystem
       structures are added or removed from Tcl's internal list of known filesystems.

              typedef int Tcl_FSPathInFilesystemProc(
                Tcl_Obj *<u>pathPtr</u>,
                ClientData *<u>clientDataPtr</u>);

<b>DUPINTERNALREPPROC</b>
       This  function  makes  a  copy  of  a path's internal representation, and is called when Tcl needs to
       duplicate a path object.  If NULL, Tcl will simply not copy the internal  representation,  which  may
       then need to be regenerated later.

              typedef ClientData Tcl_FSDupInternalRepProc(
                ClientData <u>clientData</u>);

<b>FREEINTERNALREPPROC</b>
       Free  the internal representation.  This must be implemented if internal representations need freeing
       (i.e. if some memory is allocated when an internal representation is generated), but may otherwise be
       NULL.

              typedef void Tcl_FSFreeInternalRepProc(
                ClientData <u>clientData</u>);

<b>INTERNALTONORMALIZEDPROC</b>
       Function  to  convert  internal representation to a normalized path.  Only required if the filesystem
       creates pure path objects with no string/path representation.  The return value is a Tcl object whose
       string representation is the normalized path.

              typedef Tcl_Obj* Tcl_FSInternalToNormalizedProc(
                ClientData <u>clientData</u>);

<b>CREATEINTERNALREPPROC</b>
       Function  to  take  a  path  object,  and calculate an internal representation for it, and store that
       native representation in the object.  May be NULL if paths have no internal representation, or if the
       <u>Tcl</u><b>_</b><u>FSPathInFilesystemProc</u>  for this filesystem always immediately creates an internal representation
       for paths it accepts.

              typedef ClientData Tcl_FSCreateInternalRepProc(
                Tcl_Obj *<u>pathPtr</u>);

<b>NORMALIZEPATHPROC</b>
       Function to normalize a path.  Should be implemented for all  filesystems  which  can  have  multiple
       string  representations  for  the  same  path object.  In Tcl, every 'path' must have a single unique
       'normalized' string representation.  Depending on the filesystem, there may be more than  one  unnor-<font color="#ffffff" class="whiteout">malized&nbsp;unnormalized</font>
       malized  string representation which refers to that path (e.g. a relative path, a path with different
       character case if the filesystem is case insensitive, a path contain a reference to a home  directory
       such  as  '~',  a  path containing symbolic links, etc).  If the very last component in the path is a
       symbolic link, it should not be converted into the object it points to (but its case or other aspects
       should be made unique).  All other path components should be converted from symbolic links.  This one
       exception is required to agree with Tcl's semantics with 'file delete', 'file  rename',  'file  copy'
       operating  on symbolic links.  This function may be called with 'nextCheckpoint' either at the begin-<font color="#ffffff" class="whiteout">ning&nbsp;beginning</font>
       ning of the path (i.e. zero), at the end of the path, or at any intermediate file  separator  in  the
       path.   It  will  never  point  to any other arbitrary position in the path. In the last of the three
       valid cases, the implementation can assume that the path up to and including the  file  separator  is
       known and normalized.

              typedef int Tcl_FSNormalizePathProc(
                Tcl_Interp *<u>interp</u>,
                Tcl_Obj *<u>pathPtr</u>,
                int <u>nextCheckpoint</u>);

<b>FILESYSTEM</b> <b>OPERATIONS</b>
       The  fields in this section of the structure contain addresses of functions which are called to carry
       out the basic filesystem operations.  A filesystem which expects to be used with the  complete  stan-<font color="#ffffff" class="whiteout">dard&nbsp;standard</font>
       dard  Tcl command set must implement all of these.  If some of them are not implemented, then certain
       Tcl commands may fail when operating on paths within that filesystem.   However,  in  some  instances
       this  may  be desirable (for example, a read-only filesystem should not implement the last four func-<font color="#ffffff" class="whiteout">tions,&nbsp;functions,</font>
       tions, and a filesystem which does not support symbolic links need not implement the  <b>readlink</b>  func-<font color="#ffffff" class="whiteout">tion,&nbsp;function,</font>
       tion, etc.  The Tcl core expects filesystems to behave in this way).

<b>FILESYSTEMPATHTYPEPROC</b>
       Function  to  determine  the  type  of a path in this filesystem.  May be NULL, in which case no type
       information will be available to users of the filesystem.  The 'type' is used only for  informational
       purposes,  and  should  be returned as the string representation of the Tcl_Obj which is returned.  A
       typical return value might be "networked", "zip" or "ftp".   The  Tcl_Obj  result  is  owned  by  the
       filesystem  and  so Tcl will increment the refCount of that object if it wishes to retain a reference
       to it.

              typedef Tcl_Obj* Tcl_FSFilesystemPathTypeProc(
                Tcl_Obj *<u>pathPtr</u>);

<b>FILESYSTEMSEPARATORPROC</b>
       Function to return the separator <!-- a -->character(s)<!-- /a --> for this filesystem.  Must  be  implemented,  otherwise
       the  <b>file</b>  <b>separator</b>  command  will not function correctly.  The usual return value will be a Tcl_Obj
       containing the string "/".

              typedef Tcl_Obj* Tcl_FSFilesystemSeparatorProc(
                Tcl_Obj *<u>pathPtr</u>);

<b>STATPROC</b>
       Function to process a <b>Tcl_FSStat()</b> call.  Must be implemented for any  reasonable  filesystem,  since
       many  Tcl  level  commands  depend  crucially  upon it (e.g. <b>file</b> <b>atime</b>, <b>file</b> <b>isdirectory</b>, <b>file</b> <b>size</b>,
       <b>glob</b>).

              typedef int Tcl_FSStatProc(
                Tcl_Obj *<u>pathPtr</u>,
                Tcl_StatBuf *<u>statPtr</u>);

       The <b>Tcl_FSStatProc</b> fills the stat structure <u>statPtr</u> with information about the specified  file.   You
       do  not  need any access rights to the file to get this information but you need search rights to all
       directories named in the path leading to the  file.   The  stat  structure  includes  info  regarding
       device,  inode  (always 0 on Windows), privilege mode, nlink (always 1 on Windows), user id (always 0
       on Windows), group id (always 0 on Windows), rdev (same as device  on  Windows),  size,  last  access
       time, last modification time, and creation time.

       If  the  file  represented  by <u>pathPtr</u> exists, the <b>Tcl_FSStatProc</b> returns 0 and the stat structure is
       filled with data.  Otherwise, -1 is returned, and no stat info is given.

<b>ACCESSPROC</b>
       Function to process a <b>Tcl_FSAccess()</b> call.  Must be implemented for any reasonable filesystem,  since
       many Tcl level commands depend crucially upon it (e.g. <b>file</b> <b>exists</b>, <b>file</b> <b>readable</b>).

              typedef int Tcl_FSAccessProc(
                Tcl_Obj *<u>pathPtr</u>,
                int <u>mode</u>);

       The <b>Tcl_FSAccessProc</b> checks whether the process would be allowed to read, write or test for existence
       of the file (or other file system object) whose name is pathname.  If pathname is  a  symbolic  link,
       then permissions of the file referred by this symbolic link should be tested.

       On success (all requested permissions granted), zero is returned.  On error (at least one bit in mode
       asked for a permission that is denied, or some other  error occurred), -1 is returned.


<b>OPENFILECHANNELPROC</b>
       Function to process a <b>Tcl_FSOpenFileChannel()</b> call.  Must be implemented for any reasonable  filesys-<font color="#ffffff" class="whiteout">tem,&nbsp;filesystem,</font>
       tem,  since  any operations which require open or accessing a file's contents will use it (e.g. <b>open</b>,
       <b>encoding</b>, and many Tk commands).

              typedef Tcl_Channel Tcl_FSOpenFileChannelProc(
                Tcl_Interp *<u>interp</u>,
                Tcl_Obj *<u>pathPtr</u>,
                int <u>mode</u>,
                int <u>permissions</u>);

       The <b>Tcl_FSOpenFileChannelProc</b> opens a file specified by <u>pathPtr</u> and returns a channel handle that can
       be  used  to  perform input and output on the file.  This API is modeled after the <b>fopen</b> procedure of
       the Unix standard I/O library.  The syntax and meaning of all arguments is similar to those given  in
       the Tcl <b>open</b> command when opening a file, where the <u>mode</u> argument is a combination of the POSIX flags
       O_RDONLY, O_WRONLY, etc.  If an error occurs while opening the channel, the <b>Tcl_FSOpenFileChannelProc</b>
       returns NULL and records a POSIX error code that can be retrieved with <b>Tcl_GetErrno</b>.  In addition, if
       <u>interp</u> is non-NULL, the <b>Tcl_FSOpenFileChannelProc</b> leaves an error message in  <u>interp</u>'s  result  after
       any error.

       The newly created channel is not registered in the supplied interpreter; to register it, use <b>Tcl_Reg</b>-<font color="#ffffff" class="whiteout">isterChannel.&nbsp;Tcl_RegisterChannel.</font>
       <b>isterChannel</b>. If one of the standard channels, <b>stdin,</b> <b>stdout</b> or <b>stderr</b> was previously closed, the act
       of creating the new channel also assigns it as a replacement for the standard channel.

<b>MATCHINDIRECTORYPROC</b>
       Function  to  process  a  <b>Tcl_FSMatchInDirectory()</b> call.  If not implemented, then glob and recursive
       copy functionality will be lacking in the filesystem (and this may  impact  commands  like  'encoding
       names' which use glob functionality internally).

              typedef int Tcl_FSMatchInDirectoryProc(
                Tcl_Interp* <u>interp</u>,
                Tcl_Obj *<u>result</u>,
                Tcl_Obj *<u>pathPtr</u>,
                CONST char *<u>pattern</u>,
                Tcl_GlobTypeData * <u>types</u>);

       The  function  should  return  all files or directories (or other filesystem objects) which match the
       given pattern and accord with the <u>types</u> specification given.  There are two ways in which this  func-<font color="#ffffff" class="whiteout">tion&nbsp;function</font>
       tion  may  be called.  If <u>pattern</u> is NULL, then <u>pathPtr</u> is a full path specification of a single file
       or directory which should be checked for existence and correct type.  Otherwise, <u>pathPtr</u> is a  direc-<font color="#ffffff" class="whiteout">tory,&nbsp;directory,</font>
       tory,  the  contents of which the function should search for files or directories which have the cor-<font color="#ffffff" class="whiteout">rect&nbsp;correct</font>
       rect type.  In either case, <u>pathPtr</u> can be assumed to be both non-NULL and non-empty.  It is not cur-<font color="#ffffff" class="whiteout">rently&nbsp;currently</font>
       rently  documented  whether  <u>pathPtr</u>  will have a file separator at its end of not, so code should be
       flexible to both possibilities.

       The return value is a standard Tcl result indicating  whether  an  error  occurred  in  the  matching
       process.   Error messages are placed in interp, but on a TCL_OK result, the interpreter should not be
       modified, but rather results should be added to the <u>result</u> object given (which can be assumed to be a
       valid  Tcl  list).  The matches added to <u>result</u> should include any path prefix given in <u>pathPtr</u> (this
       usually means they will be absolute path specifications).  Note that if no matches  are  found,  that
       simply  leads  to an empty result --- errors are only signaled for actual file or filesystem problems
       which may occur during the matching process.

<b>UTIMEPROC</b>
       Function to process a <b>Tcl_FSUtime()</b> call.  Required to allow setting  (not  reading)  of  times  with
       'file mtime', 'file atime' and the open-r/open-w/fcopy implementation of 'file copy'.

              typedef int Tcl_FSUtimeProc(
                Tcl_Obj *<u>pathPtr</u>,
                struct utimbuf *<u>tval</u>);

       The  access  and  modification times of the file specified by <u>pathPtr</u> should be changed to the values
       given in the <u>tval</u> structure.

       The return value is a standard Tcl result indicating whether an error occurred in the process.

<b>LINKPROC</b>
       Function to process a <b>Tcl_FSLink()</b> call.  Should be  implemented  only  if  the  filesystem  supports
       links, and may otherwise be NULL.

              typedef Tcl_Obj* Tcl_FSLinkProc(
                Tcl_Obj *<u>linkNamePtr</u>,
                Tcl_Obj *<u>toPtr</u>,
                int <u>linkAction</u>);

       If  <u>toPtr</u>  is  NULL,  the  function  is  being asked to read the contents of a link.  The result is a
       Tcl_Obj specifying the contents of the link given by <u>linkNamePtr</u>, or NULL if the link  could  not  be
       read.   The  result  is owned by the caller, which should call Tcl_DecrRefCount when the result is no
       longer needed.  If <u>toPtr</u> is not NULL, the function should attempt to create a link.   The  result  in
       this  case should be <u>toPtr</u> if the link was successful and NULL otherwise.  In this case the result is
       not owned by the caller. See the documentation for <b>Tcl_FSLink</b> for the correct interpretation  of  the
       <u>linkAction</u> flags.

<b>LISTVOLUMESPROC</b>
       Function  to list any filesystem volumes added by this filesystem.  Should be implemented only if the
       filesystem adds volumes at the head of the filesystem, so that they can be  returned  by  'file  vol-<font color="#ffffff" class="whiteout">umes'.&nbsp;volumes'.</font>
       umes'.

              typedef Tcl_Obj* Tcl_FSListVolumesProc(void);

       The  result  should  be  a list of volumes added by this filesystem, or NULL (or an empty list) if no
       volumes are provided.  The result object is considered to be owned by the filesystem  (not  by  Tcl's
       core), but should be given a refCount for Tcl.  Tcl will use the contents of the list and then decre-<font color="#ffffff" class="whiteout">ment&nbsp;decrement</font>
       ment that refCount.  This allows filesystems to choose whether they actually want to retain a 'master
       list' of volumes or not (if not, they generate the list on the fly and pass it to Tcl with a refCount
       of 1 and then forget about the list, if yes, then they simply increment the refCount of their  master
       list  and  pass  it to Tcl which will copy the contents and then decrement the count back to where it
       was).

       Therefore, Tcl considers return values from this proc to be read-only.


<b>FILEATTRSTRINGSPROC</b>
       Function to list all attribute strings which are valid for this filesystem.  If not  implemented  the
       filesystem  will  not support the <b>file</b> <b>attributes</b> command.  This allows arbitrary additional informa-<font color="#ffffff" class="whiteout">tion&nbsp;information</font>
       tion to be attached to files in the filesystem.  If it is not implemented, there is no need to imple-<font color="#ffffff" class="whiteout">ment&nbsp;implement</font>
       ment the <b>get</b> and <b>set</b> methods.

              typedef CONST char** Tcl_FSFileAttrStringsProc(
                Tcl_Obj *<u>pathPtr</u>,
                Tcl_Obj** <u>objPtrRef</u>);

       The called function may either return an array of strings, or may instead return NULL and place a Tcl
       list into the given objPtrRef.  Tcl will take that list and first increment its refCount before using
       it.   On  completion  of that use, Tcl will decrement its refCount.  Hence if the list should be dis-<font color="#ffffff" class="whiteout">posed&nbsp;disposed</font>
       posed of by Tcl when done, it should have a refCount of zero, and if the list should not be  disposed
       of, the filesystem should ensure it retains a refCount on the object.

<b>FILEATTRSGETPROC</b>
       Function to process a <b>Tcl_FSFileAttrsGet()</b> call, used by 'file attributes'.

              typedef int Tcl_FSFileAttrsGetProc(
                Tcl_Interp *<u>interp</u>,
                int <u>index</u>,
                Tcl_Obj *<u>pathPtr</u>,
                Tcl_Obj **<u>objPtrRef</u>);

       Returns a standard Tcl return code.  The attribute value retrieved, which corresponds to the <u>index</u>'th
       element in the list returned by the Tcl_FSFileAttrStringsProc, is a Tcl_Obj placed in  objPtrRef  (if
       TCL_OK  was  returned)  and is likely to have a refCount of zero.  Either way we must either store it
       somewhere (e.g. the Tcl result), or Incr/Decr its refCount to ensure it is properly freed.

<b>FILEATTRSSETPROC</b>
       Function to process a <b>Tcl_FSFileAttrsSet()</b> call, used by 'file attributes'.   If  the  filesystem  is
       read-only, there is no need to implement this.

              typedef int Tcl_FSFileAttrsSetProc(
                Tcl_Interp *<u>interp</u>,
                int <u>index</u>,
                Tcl_Obj *<u>pathPtr</u>,
                Tcl_Obj *<u>objPtr</u>);

       The  attribute  value  of  the <u>index</u>'th element in the list returned by the Tcl_FSFileAttrStringsProc
       should be set to the <u>objPtr</u> given.

<b>CREATEDIRECTORYPROC</b>
       Function to process a <b>Tcl_FSCreateDirectory()</b> call.  Should be implemented unless  the  FS  is  read-<font color="#ffffff" class="whiteout">only.&nbsp;readonly.</font>
       only.

              typedef int Tcl_FSCreateDirectoryProc(
                Tcl_Obj *<u>pathPtr</u>);

       The  return  value  is a standard Tcl result indicating whether an error occurred in the process.  If
       successful, a new directory should have been added to the filesystem in  the  location  specified  by
       <u>pathPtr</u>.

<b>REMOVEDIRECTORYPROC</b>
       Function  to  process a 'Tcl_FSRemoveDirectory()' call.  Should be implemented unless the FS is read-<font color="#ffffff" class="whiteout">only.&nbsp;readonly.</font>
       only.

              typedef int Tcl_FSRemoveDirectoryProc(
                Tcl_Obj *<u>pathPtr</u>,
                int <u>recursive</u>,
                Tcl_Obj **<u>errorPtr</u>);

       The return value is a standard Tcl result indicating whether an error occurred in  the  process.   If
       successful,  the directory specified by <u>pathPtr</u> should have been removed from the filesystem.  If the
       <u>recursive</u> flag is given, then a non-empty directory should be deleted without  error.   If  an  error
       does occur, the name of the file or directory which caused the error should be placed in <u>errorPtr</u>.

<b>DELETEFILEPROC</b>
       Function to process a <b>Tcl_FSDeleteFile()</b> call.  Should be implemented unless the FS is read-only.

              typedef int Tcl_FSDeleteFileProc(
                Tcl_Obj *<u>pathPtr</u>);

       The  return  value  is a standard Tcl result indicating whether an error occurred in the process.  If
       successful, the file specified by <u>pathPtr</u> should have been removed from the filesystem.   Note  that,
       if the filesystem supports symbolic links, Tcl will always call this function and not Tcl_FSRemoveDi-<font color="#ffffff" class="whiteout">rectoryProc&nbsp;Tcl_FSRemoveDirectoryProc</font>
       rectoryProc when needed to delete them (even if they are symbolic links to directories).

<b>FILESYSTEM</b> <b>EFFICIENCY</b>
<b>LSTATPROC</b>
       Function to process a <b>Tcl_FSLstat()</b> call.  If not implemented, Tcl will attempt to use  the  <u>statProc</u>
       defined  above  instead.   Therefore  it  need  only be implemented if a filesystem can differentiate
       between <b>stat</b> and <b>lstat</b> calls.

              typedef int Tcl_FSLstatProc(
                Tcl_Obj *<u>pathPtr</u>,
                Tcl_StatBuf *<u>statPtr</u>);

       The behavior of this function is very similar to that of the  Tcl_FSStatProc  defined  above,  except
       that if it is applied to a symbolic link, it returns information about the link, not about the target
       file.


<b>COPYFILEPROC</b>
       Function to process a <b>Tcl_FSCopyFile()</b> call.  If not implemented Tcl will fall back on open-r, open-w
       and  fcopy  as a copying mechanism.  Therefore it need only be implemented if the filesystem can per-<font color="#ffffff" class="whiteout">form&nbsp;perform</font>
       form that action more efficiently.

              typedef int Tcl_FSCopyFileProc(
                Tcl_Obj *<u>srcPathPtr</u>,
                Tcl_Obj *<u>destPathPtr</u>);

       The return value is a standard Tcl result  indicating  whether  an  error  occurred  in  the  copying
       process.   Note that, <u>destPathPtr</u> is the name of the file which should become the copy of <u>srcPathPtr</u>.
       It is never the name of a directory into which <u>srcPathPtr</u> could be copied (i.e. the function is  much
       simpler  than  the Tcl level 'file copy' subcommand).  Note that, if the filesystem supports symbolic
       links, Tcl will always call this function and not Tcl_FSCopyDirectoryProc when needed  to  copy  them
       (even if they are symbolic links to directories).

<b>RENAMEFILEPROC</b>
       Function  to process a <b>Tcl_FSRenameFile()</b> call.  If not implemented, Tcl will fall back on a copy and
       delete mechanism.  Therefore it need only be implemented if the filesystem can  perform  that  action
       more efficiently.

              typedef int Tcl_FSRenameFileProc(
                Tcl_Obj *<u>srcPathPtr</u>,
                Tcl_Obj *<u>destPathPtr</u>);

       The  return  value  is  a  standard  Tcl  result indicating whether an error occurred in the renaming
       process.

<b>COPYDIRECTORYPROC</b>
       Function to process a <b>Tcl_FSCopyDirectory()</b> call.  If not implemented, Tcl will fall back on a recur-<font color="#ffffff" class="whiteout">sive&nbsp;recursive</font>
       sive  create-dir,  file  copy mechanism.  Therefore it need only be implemented if the filesystem can
       perform that action more efficiently.

              typedef int Tcl_FSCopyDirectoryProc(
                Tcl_Obj *<u>srcPathPtr</u>,
                Tcl_Obj *<u>destPathPtr</u>,
                Tcl_Obj **<u>errorPtr</u>);

       The return value is a standard Tcl result  indicating  whether  an  error  occurred  in  the  copying
       process.   If an error does occur, the name of the file or directory which caused the error should be
       placed in <u>errorPtr</u>. Note that, <u>destPathPtr</u> is the name of the directory-name which should become  the
       mirror-image  of <u>srcPathPtr</u>. It is not the name of a directory into which <u>srcPathPtr</u> should be copied
       (i.e. the function is much simpler than the Tcl level 'file copy' subcommand).

<b>LOADFILEPROC</b>
       Function to process a <b>Tcl_FSLoadFile()</b> call.  If not implemented, Tcl will fall back  on  a  copy  to
       native-temp  followed  by  a Tcl_FSLoadFile on that temporary copy.  Therefore it need only be imple-<font color="#ffffff" class="whiteout">mented&nbsp;implemented</font>
       mented if the filesystem can load code directly, or it can be implemented simply to return  TCL_ERROR
       to disable load functionality in this filesystem entirely.

              typedef int Tcl_FSLoadFileProc(
                Tcl_Interp * <u>interp</u>,
                Tcl_Obj *<u>pathPtr</u>,
                Tcl_LoadHandle * <u>handlePtr</u>,
                Tcl_FSUnloadFileProc * <u>unloadProcPtr</u>);

       Returns a standard Tcl completion code.  If an error occurs, an error message is left in the interp's
       result.  The function dynamically loads a binary code file into memory.  On a  successful  load,  the
       <u>handlePtr</u> should be filled with a token for the dynamically loaded file, and the <u>unloadProcPtr</u> should
       be filled in with the address of a procedure.  The procedure will be called with the given  Tcl_Load-<font color="#ffffff" class="whiteout">Handle&nbsp;Tcl_LoadHandle</font>
       Handle as its only parameter when Tcl needs to unload the file.

<b>UNLOADFILEPROC</b>
       Function  to unload a previously successfully loaded file.  If load was implemented, then this should
       also be implemented, if there is any cleanup action required.

              typedef void Tcl_FSUnloadFileProc(
                Tcl_LoadHandle <u>loadHandle</u>);

<b>GETCWDPROC</b>
       Function to process a <b>Tcl_FSGetCwd()</b> call.  Most filesystems need not implement this.  It  will  usu-<font color="#ffffff" class="whiteout">ally&nbsp;usually</font>
       ally only be called once, if 'getcwd' is called before 'chdir'.  May be NULL.

              typedef Tcl_Obj* Tcl_FSGetCwdProc(
                Tcl_Interp *<u>interp</u>);

       If the filesystem supports a native notion of a current working directory (which might perhaps change
       independent of Tcl), this function should return that cwd as the  result,  or  NULL  if  the  current
       directory  could  not  be  determined (e.g. the user does not have appropriate permissions on the cwd
       directory).  If NULL is returned, an error message is left in the interp's result.


<b>CHDIRPROC</b>
       Function to process a <b>Tcl_FSChdir()</b> call.  If filesystems do not implement this, it will be  emulated
       by  a  series  of directory access checks.  Otherwise, virtual filesystems which do implement it need
       only respond with a positive return result if the dirName is a valid, accessible directory  in  their
       filesystem.   They  need not remember the result, since that will be automatically remembered for use
       by GetCwd.  Real filesystems should carry out the  correct  action  (i.e.  call  the  correct  system
       'chdir' api).

              typedef int Tcl_FSChdirProc(
                Tcl_Obj *<u>pathPtr</u>);

       The  <b>Tcl_FSChdirProc</b>  changes  the  applications  current working directory to the value specified in
       <u>pathPtr</u>. The function returns -1 on error or 0 on success.

<b>KEYWORDS</b>
       stat access filesystem vfs



Tcl                                                  8.4                                       <!-- a -->Filesystem(3)<!-- /a -->
</tt></pre>
</td></tr></table>
	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Darwin/Reference/ManPages/man3/Tcl_FSJoinToPath.3tcl.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Darwin/Reference/ManPages/man3/Tcl_FSJoinToPath.3tcl.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Darwin/Reference/ManPages/man3/Tcl_FSJoinToPath.3tcl.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

</body></html>
