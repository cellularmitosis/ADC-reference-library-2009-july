/****************************************************************************** **																			 ** ** 	Module:		SR_PixmapMarker.c										 ** ** 																		 ** ** 																		 ** ** 	Purpose: 	This is the entry point into SR for pixmap markers.	 	 ** ** 																		 ** ** 																		 ** ** 																		 ** ** 	Copyright (C) 1996 Apple Computer, Inc.  All rights reserved.	 	 ** ** 																		 ** ** 																		 ** *****************************************************************************/#include <assert.h>#include <stdlib.h>#include "QD3D.h"#include "QD3DMath.h"#include "SR.h"#include "SR_Marker.h"#include "QD3DShader.h"/*===========================================================================*\ * *	Routine	:	SR_Geometry_PixmapMarker() * *	Comment	:	This function is the pixmapMarker renderer entry point, it  *				collects the state of escher, updates the state of the world *				and then calls the appropiate rendering function. *\*===========================================================================*/TQ3Status SR_Geometry_PixmapMarker(	TQ3ViewObject 				view, 	TSRPrivate 					*srPrivate,	TQ3GeometryObject 			pixmapMarker,	const TQ3PixmapMarkerData	*pixmapMarkerData){	TQ3Boolean				highlightState;	TQ3ColorRGB				highlightColor;	TQ3XClipMaskState		clipMaskState;		UNUSED(pixmapMarker);	assert(view 			!= NULL);	assert(srPrivate 		!= NULL);	assert(pixmapMarkerData != NULL);		/*	 *  Call the application's idle progress method, via the view.  If	 *  the app's method returns kQ3Failure, then we don't go on.	 */	if (SR_IdleProgress(view, srPrivate) == kQ3Failure) {		return (kQ3Success);	}	if (srPrivate->drawRegion == NULL) {		return (kQ3Success);	}	/*	 *  Find out if we're clipped out or not. No reason to go any	 *  further if the region is obscured or entirely off-screen. 	 */	Q3XDrawRegion_GetClipFlags(srPrivate->drawRegion, &clipMaskState);	if (clipMaskState == kQ3XClipMaskNotExposed) {		return (kQ3Success);	}	/*	 *  Lazy-evaluate the various transforms for the pipeline	 */	if (SR_UpdatePipeline(srPrivate) == kQ3Failure) {		return (kQ3Failure);	}	/*	 *  Highlight state and  color are from the view, unless	 *  overridden by the lineAttributeSet	 */	Q3ColorRGB_Set(&highlightColor, kQ3ViewDefaultHighlightColor);		/*	 *  Get highlight state from the current view state	 */	highlightState = srPrivate->viewHighlightState;		/*	 *  Check for highlight state in the pixmap marker itself	 */	if (pixmapMarkerData->pixmapMarkerAttributeSet != NULL) {		TQ3XAttributeMask	attributeMask;				attributeMask = Q3XAttributeSet_GetMask(							pixmapMarkerData->pixmapMarkerAttributeSet);		if (attributeMask & kQ3XAttributeMaskHighlightState) {			Q3AttributeSet_Get(				pixmapMarkerData->pixmapMarkerAttributeSet, 				kQ3AttributeTypeHighlightState, 				&highlightState);		}	}	/*	 *  If highlight state is true, and there's a view hightlight attribute set, and if 	 *  there's a color in there, use that as the highlight color.	 */	if ((highlightState == kQ3True) &&		(srPrivate->viewHighlightAttributeSet != NULL)) {		TQ3XAttributeMask	attributeMask;				attributeMask = Q3XAttributeSet_GetMask(							srPrivate->viewHighlightAttributeSet);									if (attributeMask & kQ3XAttributeMaskDiffuseColor) {			Q3AttributeSet_Get( 				srPrivate->viewHighlightAttributeSet, 				kQ3AttributeTypeDiffuseColor, 				&highlightColor);		}	}			{		TQ3Matrix4x4				*localToDC;		TQ3RationalPoint4D			*deviceVertices = NULL;		TQ3RationalPoint4D			*renderVertices = NULL;		PixmapMarkerFunction2D		pixmapMarkerFunc;		TSRPixmapMarkerRasterData	rasterPixmapMarker;		TQ3Point2D					saveDeviceVertices;		/*				 *  1.0 	transform local coordinate vertices to DC		 *	1.5		add in offsets		 *  2.0		clip in DC		 *  3.0 	paste bitmap		 */		TQ3StoragePixmap	*pixmapPtr = (TQ3StoragePixmap *)											&(pixmapMarkerData->pixmap);		float				inverseW;				localToDC = &srPrivate->transforms.localToDC;		deviceVertices = malloc(sizeof(TQ3RationalPoint4D));		if (deviceVertices == NULL) {			return (kQ3Failure);		}		/* 1. transform LC to DC */		Q3Point3D_To4DTransformArray(&pixmapMarkerData->position, 									 localToDC,									 deviceVertices, 									 1,									 sizeof(TQ3Point3D), 									 sizeof(TQ3RationalPoint4D));									 		inverseW = 1.0 / deviceVertices->w;		deviceVertices->x *= inverseW;		deviceVertices->y *= inverseW;		deviceVertices->z *= inverseW;		deviceVertices->x += pixmapMarkerData->xOffset;		deviceVertices->y += pixmapMarkerData->yOffset;				deviceVertices->x = FLOAT_ROUND_TO_LONG_POSITIVE(								deviceVertices->x);		deviceVertices->y = FLOAT_ROUND_TO_LONG_POSITIVE(								deviceVertices->y);				/* Check for trivial rejection clipping */				if (deviceVertices->z < srPrivate->clipPlanesInDC[4] 	|| 			deviceVertices->z > srPrivate->clipPlanesInDC[5] 	||			deviceVertices->x + pixmapPtr->width - 1 < 				srPrivate->clipPlanesInDC[0] 					||			deviceVertices->x > srPrivate->clipPlanesInDC[1] 	||			deviceVertices->y + pixmapPtr->height - 1 < 				srPrivate->clipPlanesInDC[2]					||			deviceVertices->y > srPrivate->clipPlanesInDC[3]) {			/* trivial rejection */			return (kQ3Success);		}		/* 		 *  PixmapMarker dimensions could be bigger than window 		 *  so clip against all boundaries 		 */		rasterPixmapMarker.pixmap = pixmapPtr;		rasterPixmapMarker.startRowSkip = 0;		rasterPixmapMarker.endRowSkip = 0;		saveDeviceVertices.x = deviceVertices->x;		saveDeviceVertices.y = deviceVertices->y;				if (deviceVertices->x < srPrivate->clipPlanesInDC[0]) {			rasterPixmapMarker.startRowSkip = 				srPrivate->clipPlanesInDC[0] - deviceVertices->x;			deviceVertices->x = srPrivate->clipPlanesInDC[0];		}				if (saveDeviceVertices.x + pixmapPtr->width - 1 > 				srPrivate->clipPlanesInDC[1]) {			rasterPixmapMarker.endRowSkip = 				saveDeviceVertices.x + pixmapPtr->width - 1 									  - srPrivate->clipPlanesInDC[1];		}				rasterPixmapMarker.startLineSkip = 0;		rasterPixmapMarker.endLineSkip = 0;				if (deviceVertices->y < srPrivate->clipPlanesInDC[2]) {			rasterPixmapMarker.startLineSkip = 				srPrivate->clipPlanesInDC[2] - deviceVertices->y;			deviceVertices->y = srPrivate->clipPlanesInDC[2];		}				if (saveDeviceVertices.y + pixmapPtr->height - 1 > 				srPrivate->clipPlanesInDC[3]) {			rasterPixmapMarker.endLineSkip = 				saveDeviceVertices.y + pixmapPtr->height - 1 									   - srPrivate->clipPlanesInDC[3];		}				/*		 *  Call the appropriate pixmap marker rasterizer.		 */		pixmapMarkerFunc = ((TSRRasterFunctions *)			(srPrivate->currentRasterFunctions))->pixmapMarkerFunction;		if ((*pixmapMarkerFunc)(				srPrivate, 				(TQ3Point3D *) deviceVertices, 				&rasterPixmapMarker,				highlightState == kQ3True ? &highlightColor : NULL) == kQ3Failure) {			if (deviceVertices != NULL) {				free(deviceVertices);			}						return (kQ3Failure);		}			if (deviceVertices != NULL) {			free(deviceVertices);		}	}		return (kQ3Success);}