<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>QTMusicToo - /&bull;Instrument Editor/Instrument Editor Controls.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/QuickTime/index.html">QuickTime</a> &gt; <a href="../../samplecode/QuickTime/idxMusicAudio-date.html">Audio</a> &gt; <A HREF="javascript:location.replace('index.html');">QTMusicToo</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Not Recommended Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>The information in this document is <strong>Not Recommended</strong> and should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/QuickTime/idxMusicAudio-date.html" target="_blank">QuickTime > Audio</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">QTMusicToo</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/&bull;Instrument Editor/Instrument Editor Controls.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/BigEasy/BigEasy2.c</option>
<option value="listing2.html">/BigEasy/BigEasy2.h</option>
<option value="listing3.html">/BigEasy/BigEasyControls.c</option>
<option value="listing4.html">/BigEasy/BigEasyControls.h</option>
<option value="listing5.html">/BigEasy/BigEasyDialogs.c</option>
<option value="listing6.html">/BigEasy/BigEasyDialogs.h</option>
<option value="listing7.html">/BigEasy/BigEasyGestalt.c</option>
<option value="listing8.html">/BigEasy/BigEasyGestalt.h</option>
<option value="listing9.html">/BigEasy/BigEasyGrafish.c</option>
<option value="listing10.html">/BigEasy/BigEasyGrafish.h</option>
<option value="listing11.html">/BigEasy/BigEasyPPC.c</option>
<option value="listing12.html">/BigEasy/BigEasyPPC.h</option>
<option value="listing13.html">/BigEasy/BigEasyStandardControls.c</option>
<option value="listing14.html">/BigEasy/BigEasyStandardControls.h</option>
<option value="listing15.html">/BigEasy/BigEasyTextish.c</option>
<option value="listing16.html">/BigEasy/BigEasyTextish.h</option>
<option value="listing17.html">/BigEasy/BigEasyUtils.c</option>
<option value="listing18.html">/BigEasy/BigEasyUtils.h</option>
<option value="listing19.html">/BigEasy/IconUtilsPriv.h</option>
<option value="listing20.html">/BigEasy/NWindows.c</option>
<option value="listing21.html">/BigEasy/OneWindow.c</option>
<option value="listing22.html">/•Instrument Editor/All The MIDI Components.h</option>
<option value="listing23.html">/•Instrument Editor/IE KeyboardDiagram.c</option>
<option value="listing24.html">/•Instrument Editor/IE KeyboardDiagram.h</option>
<option value="listing25.html">/•Instrument Editor/IE PrintUtilities.c</option>
<option value="listing26.html">/•Instrument Editor/IE PrintUtilities.h</option>
<option value="listing27.html">/•Instrument Editor/Instrument Editor Controls.c</option>
<option value="listing28.html">/•Instrument Editor/Instrument Editor Controls.h</option>
<option value="listing29.html">/•Instrument Editor/Instrument Editor Draw.c</option>
<option value="listing30.html">/•Instrument Editor/Instrument Editor Filing.c</option>
<option value="listing31.html">/•Instrument Editor/Instrument Editor Filing.h</option>
<option value="listing32.html">/•Instrument Editor/Instrument Editor Menus.c</option>
<option value="listing33.html">/•Instrument Editor/Instrument Editor Menus.h</option>
<option value="listing34.html">/•Instrument Editor/Instrument Editor.c</option>
<option value="listing35.html">/•Instrument Editor/Instrument Editor.h</option>
<option value="listing36.html">/•Instrument Editor/Instrument Editor.r</option>
<option value="listing37.html">/•Instrument Editor/Instrument Tests.c</option>
<option value="listing38.html">/•Instrument Editor/More IE Routines.c</option>
<option value="listing39.html">/•Instrument Editor/More IE Routines.h</option>
<option value="listing40.html">/•Instrument Picker Test/InstrumentPickerTest.c</option>
<option value="listing41.html">/•QTMusic Sample Keyboards/EasyKeyboardDiagram.c</option>
<option value="listing42.html">/•QTMusic Sample Keyboards/EasyKeyboardDiagram.h</option>
<option value="listing43.html">/•QTMusic Sample Keyboards/EasyKeyboardDiagram.r</option>
<option value="listing44.html">/•QTMusic Sample Keyboards/QTMusic Sample Keyboards.c</option>
<option value="listing45.html">/•QTMusic Sample Keyboards/QTMusic Sample Keyboards.r</option>
<option value="listing46.html">/•QTMusic Sample Sequencer/Event Priority Queue.c</option>
<option value="listing47.html">/•QTMusic Sample Sequencer/Event Priority Queue.h</option>
<option value="listing48.html">/•QTMusic Sample Sequencer/Sequencer Test Movies.c</option>
<option value="listing49.html">/•QTMusic Sample Sequencer/Sequencer Test Movies.h</option>
<option value="listing50.html">/•QTMusic Sample Sequencer/SequencerTest Filing.c</option>
<option value="listing51.html">/•QTMusic Sample Sequencer/SequencerTest Filing.h</option>
<option value="listing52.html">/•QTMusic Sample Sequencer/SequencerTest Movies.h</option>
<option value="listing53.html">/•QTMusic Sample Sequencer/SequencerTest Realtime.c</option>
<option value="listing54.html">/•QTMusic Sample Sequencer/SequencerTest Realtime.h</option>
<option value="listing55.html">/•QTMusic Sample Sequencer/SequencerTest.c</option>
<option value="listing56.html">/•QTMusic Sample Sequencer/SequencerTest.h</option></select>
				</p>
				</form>
				<p><strong><a href="QTMusicToo.zip">Download Sample</a></strong> (&#147;QTMusicToo.zip&#148;, 115.5K)<BR>
<strong><a href="QTMusicToo.dmg">Download Sample</a></strong> (&#147;QTMusicToo.dmg&#148;, 173.6K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/************************************* Inclusions************************************/#include &lt;QuickDraw.h&gt;#include &lt;Memory.h&gt;#include &lt;Resources.h&gt;#include &lt;OSUtils.h&gt;#include &lt;OSUtils.h&gt;#include &lt;OSUtils.h&gt;#include &lt;Events.h&gt;#define privateEasyControls#include &quot;BigEasy2.h&quot;#include &quot;BigEasyGrafish.h&quot;#include &quot;BigEasyTextish.h&quot;#include &quot;BigEasyControls.h&quot;#include &quot;Instrument Editor Controls.h&quot;/************************************* Constants************************************/#define kSlop 10#define kBarVMargin 4#define kSliderCursor 200/************************************  Default Styles************************************/static tSliderStyle dDefaultSliderStyle =  {  longNum,  120,15,  80,13,  nil  };/************************************* Prototypes************************************/static void MaybeRaisedRect(short c,Rect *r,Boolean b);static void NewSlider(easyControlPtr ec);static void DisposeSlider(easyControlPtr ec);static void DrawSlider(easyControlPtr );static void TrackSlider(easyControlPtr,Point p);static void KeySlider(easyControlPtr,short k,short m,Boolean *tookKey);static void DrawSliderValue(easyControlPtr );static void HitTestSlider(void);static void SetSliderValue(struct easyControlRecord *ec,long value);static void NewBoolean(easyControlPtr ec);static void DisposeBoolean(easyControlPtr ec);static void DrawBoolean(easyControlPtr );static void TrackBoolean(easyControlPtr,Point p);static void KeyBoolean(easyControlPtr,short k,short m,Boolean *tookKey);static void DrawBooleanValue(easyControlPtr );static void HitTestBoolean(void);static void SetBooleanValue(struct easyControlRecord *ec,long value);static void NewToggle(easyControlPtr ec);static void DisposeToggle(easyControlPtr ec);static void DrawToggle(easyControlPtr );static void DrawToggleValue(easyControlPtr );static void HitTestToggle(easyControlPtr,Point p);static void TrackToggle(easyControlPtr,Point p,short *trackResult,short mods);static void KeyToggle(easyControlPtr,short k,short mods,Boolean *tookKey);static void SetToggleValue(easyControlPtr,long);static void Idle(easyControlPtr,long *);easyControlType toggleType =  {  NewToggle,  DisposeToggle,  DrawToggle,  HitTestToggle,  TrackToggle,  KeyToggle,  SetToggleValue,  Idle,  DrawToggleValue  };easyControlType sliderType =  {  NewSlider,  DisposeSlider,  DrawSlider,  (becHitTestProcPtr)HitTestSlider,  (becTrackProcPtr)TrackSlider,  KeySlider,  SetSliderValue,  Idle,  DrawSliderValue  };easyControlType booleanType =  {  NewBoolean,  DisposeBoolean,  DrawBoolean,  (becHitTestProcPtr)HitTestBoolean,  (becTrackProcPtr)TrackBoolean,  KeyBoolean,  SetBooleanValue,  Idle,  DrawBooleanValue  };/************************************* Routines************************************/void MaybeRaisedRect(short c,Rect *r,Boolean b)/*  * if background, draw a flat rect,  * else a raised rect.  */  {  if(b)    {    Fore555(c);    PaintRect(r);    }  else    RaisedRect(r,c);  }/*  * Sliders  *  * Sliders copy their style into a handle, stored  * in the slide field of the easyControl.  */void TrackSlider(easyControlPtr ec,Point p) /*   * Track the mouse within the slider as long   * as the button is held down, all the while   * updating the value and drawing the bar.   */  {   tSliderStyle *st;   Point lastP;   long oldValue;   long value;   long vRange, rRange,rounding;   double fVRange, fRRange, fRounding;    /* for floating point sliders  */   Rect slopRect;   long q;   Boolean zingCursor;   Handle tempH;    GoCursor(kSliderCursor);   zingCursor = true;    st = *(tSliderStyle **)ec-&gt;style;   HLock(tempH = RecoverHandle((Ptr)st));   oldValue = ec-&gt;value;    slopRect = ec-&gt;rect;   InsetRect(&amp;slopRect,-kSlop,-kSlop);    if(st-&gt;numberType == floatNum)     {     fVRange = AsFloat(ec-&gt;high) - AsFloat(ec-&gt;low);     fRRange = st-&gt;sWidth - 2;     fRounding = (fRRange / fVRange) / 2;     }   else     {     vRange = ec-&gt;high - ec-&gt;low;     rRange = st-&gt;sWidth - 2;     rounding = (rRange / vRange) / 2;     }    if(ec-&gt;initActionProc)          /* Call initAction proc once    */    (*ec-&gt;initActionProc)(ec-&gt;value,ec-&gt;refcon);  while(Button())     {    q = TickCount()+2;    while(TickCount() &lt; q)      SystemTask();    if(ec-&gt;actionProc)          /* Call action proc every time    */      (*ec-&gt;actionProc)(ec-&gt;value,ec-&gt;refcon);    lastP.h = p.h+1;            /* Guarantee do first time through  */    GetMouse(&amp;p);     if( (p.h != lastP.h) || (p.v != lastP.v) )       {       if(PtInRect(p,&amp;slopRect))         {         if(!zingCursor)           {           GoCursor(kSliderCursor);           zingCursor = true;           }         if(st-&gt;numberType == floatNum)           ;         else          value = ec-&gt;low + (long)(p.h - ec-&gt;rect.left + rounding + 1) * vRange/rRange;        }      else        {        value = oldValue;        if(zingCursor)          {          InitCursor();          zingCursor = false;          }        }      if(value &lt; ec-&gt;low)        value = ec-&gt;low;      else if(value &gt; ec-&gt;high)        value = ec-&gt;high;      if(value != ec-&gt;value)        {        ec-&gt;value = value;        DrawSliderValue(ec);        if(ec-&gt;valueProc)        /* Call value proc for new value  *//*          (*ec-&gt;valueProc)(ec); */          (*ec-&gt;valueProc)((easyControl)RecoverHandle((Ptr)ec));        }      lastP = p;      }     }   if(ec-&gt;doneActionProc)          /* Call doneAction proc once    */    (*ec-&gt;doneActionProc)(ec-&gt;value,ec-&gt;refcon);    HUnlock(tempH);   InitCursor();   }void DrawSlider(easyControlPtr ec)/*  * Draw the slider passed.  */  {  register tSliderStyle *st;  Rect r;  Handle tempH;  st = *(tSliderStyle **)ec-&gt;style;  HLock(tempH = RecoverHandle((Ptr)st));  r = ec-&gt;rect;/*  r.right = r.left + st-&gt;sWidth;  r.bottom = r.top + st-&gt;sHeight;*/  if(ec-&gt;flags &amp; easyControlActive)    PenPat((Pattern *)dBlackPat);  else    PenPat((Pattern *)&amp;dGrayPat);  Fore555(ec-&gt;color[controlFrame]);  PenSize(1,1);  FrameRect(&amp;r);  InsetRect(&amp;r,1,1);  Fore555(ec-&gt;color[controlBackground]);  PaintRect(&amp;r);  DrawSliderValue(ec);  HUnlock(tempH);  }void DrawSliderValue(easyControlPtr ec)  {  Rect bar,r;  register tSliderStyle *st;  long value;  Boolean undefined;  st = *(tSliderStyle **)ec-&gt;style;    /* already locked by caller  */  value = ec-&gt;value;  undefined = false;  if(value == 0x7FFFffff)    {    value = ec-&gt;high;    undefined = true;    }  else if(value &lt; ec-&gt;low)    value = ec-&gt;low;  else if(value &gt; ec-&gt;high)    value = ec-&gt;high;  bar.top = ec-&gt;rect.top + kBarVMargin;  bar.bottom = ec-&gt;rect.top + st-&gt;sHeight - kBarVMargin;  bar.left = ec-&gt;rect.left + 1;  bar.right = ec-&gt;rect.left + 1 + (long)(value - ec-&gt;low) * (long)(st-&gt;sWidth - 2) /      (long)(ec-&gt;high - ec-&gt;low);  if(undefined)    InsetRect(&amp;bar,0,2);  if(ec-&gt;flags &amp; easyControlActive)    PenPat((Pattern *)&amp;dBlackPat);  else    PenPat((Pattern *)&amp;dGrayPat);  RaisedRect(&amp;bar,ec-&gt;color[controlPart1]);  bar.left = bar.right;  bar.right = ec-&gt;rect.left + st-&gt;sWidth - 1;  if(ec-&gt;variation &amp; drawRightSlider)    RaisedRect(&amp;bar,ec-&gt;color[controlPart2]);  else    {    Fore555(ec-&gt;color[controlBackground]);    PaintRect(&amp;bar);    }  if(st-&gt;tHeight)            /* tHeight = 0 means no text  */    {    r.left = ec-&gt;rect.left;    r.top = ec-&gt;rect.top + st-&gt;sHeight - 1;    r.right = r.left + st-&gt;tWidth;    r.bottom = r.top + st-&gt;tHeight;    Fore555(ec-&gt;color[controlFrame]);    FrameRect(&amp;r);    InsetRect(&amp;r,1,1);    Fore555(ec-&gt;color[controlBackground]);    PaintRect(&amp;r);    MoveTo(r.left + 2,r.bottom - (st-&gt;tHeight - 9)/2);    Fore555(ec-&gt;color[controlFrame]);    if(st-&gt;drawValue)      (*st-&gt;drawValue)((easyControl)RecoverHandle((Ptr)ec));    else      {      if(undefined)        DrawString(&quot;\p----&quot;);      else if(st-&gt;numberType == longNum)        DrawNum(value);      else if(st-&gt;numberType == fixedNum)        DrawFixed(value,4);      else if(st-&gt;numberType == fracNum)        DrawFrac(value,8);      else        DrawString((StringPtr)&quot;\pxyz&quot;);      }    }  }void NewSlider(easyControlPtr ec)/*  * Do allocations for a new easyControl slider type  */  {  Handle h;  register tSliderStyle *st;/*  * Copy the style information to our very own handle  */  if(ec-&gt;style == 0)    ec-&gt;style = &amp;dDefaultSliderStyle;  h = NewHandle(sizeof(tSliderStyle));  BlockMove(ec-&gt;style,*h,sizeof(tSliderStyle));  ec-&gt;style = h;  st = (tSliderStyle *)*h;  st-&gt;sWidth = ec-&gt;rect.right - ec-&gt;rect.left;  st-&gt;sHeight = ec-&gt;rect.bottom - ec-&gt;rect.top;  ec-&gt;low = 0;  ec-&gt;high = 100;  }void DisposeSlider(easyControlPtr ec)/*  * Deallocate the slider  */  {  DisposHandle((Handle)ec-&gt;style);  }void SetSliderValue(struct easyControlRecord *ec,long value)  {  ec-&gt;value = value;    }void HitTestSlider()  {  }void NewToggle(easyControlPtr ec)  {  ec-&gt;low = 0;  ec-&gt;high = 1;  }void DisposeToggle(easyControlPtr ec)  {  #pragma unused(ec)  }void DrawToggle(easyControlPtr ec)  {  Rect r;  r = ec-&gt;rect;  Fore555(ec-&gt;color[0]);  PenSize(1,1);  FrameRect(&amp;r);  DrawToggleValue(ec);  }void DrawToggleValue(easyControlPtr ec)  {  register tToggleStyle *st;  Rect r;  short c;  PicHandle p;  r = ec-&gt;rect;  InsetRect(&amp;r,1,1);  if((ec-&gt;variation &amp; checkboxToggle) &amp;&amp; !(ec-&gt;flags &amp; easyControlTracking))  /* checkbox version ? */    {    MaybeRaisedRect(ec-&gt;color[controlBackground],&amp;r,ec-&gt;flags &amp; easyControlBack);    if(ec-&gt;value)      {      Fore555(ec-&gt;color[controlFrame]);      PenSize(2,2);      MoveTo(r.left,r.top);      LineTo(r.right-2,r.bottom-2);      MoveTo(r.left,r.bottom-2);      LineTo(r.right-2,r.top);      }    }  else    {    if((!ec-&gt;value) ^ (ec-&gt;variation &amp; checkboxToggle != 0))      c = ec-&gt;color[controlBackground];    else      c = ec-&gt;color[controlPart1];        if(ec-&gt;flags &amp; easyControlBack)      {      Fore555(c);      PaintRect(&amp;r);      }    else      {      RaisedRect(&amp;r,c);          st = ec-&gt;style;      if(st &amp;&amp; st-&gt;p)          /* res ID zero doesn't draw */        {        p = (PicHandle)GetResource('PICT',st-&gt;p);        if(p)          {          r = (**p).picFrame;          OffsetRect(&amp;r,((ec-&gt;rect.left  + ec-&gt;rect.right) - (r.left + r.right))/2,              ((ec-&gt;rect.top + ec-&gt;rect.bottom) - (r.top + r.bottom))/2);          DrawPicture(p,&amp;r);          }        else            /* missing picture */          {          GoBlack();          PenSize(1,1);          MoveTo(ec-&gt;rect.left,ec-&gt;rect.top);          LineTo(ec-&gt;rect.right-1,ec-&gt;rect.bottom-1);          }        }      }    }  }void TrackToggle(register easyControlPtr ec,Point p,      short *trackResult,short mods)  {  long oldValue,newValue;  register Boolean inRect;  long dummylong;    #pragma unused(mods)  oldValue = ec-&gt;value;  newValue = !ec-&gt;value;  if(ec-&gt;variation &amp; dontTrackToggle)    {    ec-&gt;value = newValue;    DrawToggleValue(ec);    if(!(ec-&gt;variation &amp; toggleToggle))      Delay(5,&amp;dummylong);    inRect = true;    }  else    do      {      SystemTask();      GetMouse(&amp;p);      inRect = PtInRect(p,&amp;ec-&gt;rect);      if(inRect)        newValue = !oldValue;      else        newValue = oldValue;      if(newValue != ec-&gt;value)        {        ec-&gt;value = newValue;        DrawToggleValue(ec);        }      } while(Button());  if(!(ec-&gt;variation &amp; toggleToggle) &amp;&amp; (ec-&gt;value))    /* if it's not toggle-ish, reset it  */    {    ec-&gt;value = 0;    DrawToggleValue(ec);    }  *trackResult = inRect;  }void SetToggleValue(easyControlPtr ec,long v)  {  ec-&gt;value = v;  DrawToggleValue(ec);  }void HitTestToggle(easyControlPtr ec,Point p)  {  #pragma unused(ec)  #pragma unused(p)  }void Idle(easyControlPtr ec, long *r)  {  if(*r &amp; 1)    Fore555(ec-&gt;color[1]);  else    Fore555(ec-&gt;color[0]);  PenSize(1,1);  FrameRect(&amp;ec-&gt;rect);  }void KeySlider(register easyControlPtr ec,short k,short m,register Boolean *tookKey)  {  register short step;  *tookKey = true;  if(m&amp;shiftKey)    step = 10;  else    step = 1;  switch(k)    {    case 28:      ec-&gt;value-=step;      break;    case 29:      ec-&gt;value+=step;      break;    default:      *tookKey = false;    }  DrawSliderValue(ec);  }void KeyToggle(easyControlPtr ec,short k,short m,Boolean *tookKey)  {#pragma unused (m)  long dummylong;    if(k == ' ')    /* spacebar only */    {    *tookKey = true;    if(ec-&gt;variation &amp; toggleToggle)      {      ec-&gt;value = !ec-&gt;value;      DrawToggleValue(ec);      }    else      {      ec-&gt;value = 1;      DrawToggleValue(ec);      Delay(5,&amp;dummylong);      ec-&gt;value = 0;      DrawToggleValue(ec);      }      if(ec-&gt;valueProc)      (*ec-&gt;valueProc)((easyControl)RecoverHandle((Ptr)ec));    }  else    *tookKey = false;  }void NewBoolean(easyControlPtr ec)/*  * Do allocations for a new easyControl Boolean type  */  {  Handle h;  register tSliderStyle *st;/*  * Copy the style information to our very own handle  */  if(ec-&gt;style == 0)    ec-&gt;style = &amp;dDefaultSliderStyle;  h = NewHandle(sizeof(tSliderStyle));  BlockMove(ec-&gt;style,*h,sizeof(tSliderStyle));  ec-&gt;style = h;  st = (tSliderStyle *)*h;  st-&gt;sWidth = ec-&gt;rect.right - ec-&gt;rect.left;  st-&gt;sHeight = ec-&gt;rect.bottom - ec-&gt;rect.top;  ec-&gt;low = 0;  ec-&gt;high = 100;  }void DisposeBoolean(easyControlPtr ec)/*  * Deallocate the slider  */  {  DisposHandle((Handle)ec-&gt;style);  }void SetBooleanValue(struct easyControlRecord *ec,long value)  {  ec-&gt;value = value;    }void HitTestBoolean()  {  }void DrawBoolean(easyControlPtr ec)/*  * Draw the slider passed.  */  {  register tSliderStyle *st;  Rect r;  Handle tempH;  short bCount;  bCount = 0;    {    long x;    x = ec-&gt;high;    while(x&gt;&gt;=1)      bCount++;    }  st = *(tSliderStyle **)ec-&gt;style;  HLock(tempH = RecoverHandle((Ptr)st));  r = ec-&gt;rect;  if(ec-&gt;flags &amp; easyControlActive)    PenPat((Pattern *)dBlackPat);  else    PenPat((Pattern *)&amp;dGrayPat);  Fore555(ec-&gt;color[controlFrame]);  PenSize(1,1);  FrameRect(&amp;r);  InsetRect(&amp;r,1,1);  Fore555(ec-&gt;color[controlBackground]);  PaintRect(&amp;r);  DrawBooleanValue(ec);  EraseRect(&amp;r);  HUnlock(tempH);  }void DrawBooleanValue(easyControlPtr ec)  {  Rect bar,r;  register tSliderStyle *st;  long value;  Boolean undefined;  st = *(tSliderStyle **)ec-&gt;style;    /* already locked by caller  */  value = ec-&gt;value;  undefined = false;  if(value == 0x7FFFffff)    {    value = ec-&gt;high;    undefined = true;    }  else if(value &lt; ec-&gt;low)    value = ec-&gt;low;  else if(value &gt; ec-&gt;high)    value = ec-&gt;high;  bar.top = ec-&gt;rect.top + kBarVMargin;  bar.bottom = ec-&gt;rect.top + st-&gt;sHeight - kBarVMargin;  bar.left = ec-&gt;rect.left + 1;  bar.right = ec-&gt;rect.left + 1 + (long)(value - ec-&gt;low) * (long)(st-&gt;sWidth - 2) /      (long)(ec-&gt;high - ec-&gt;low);  if(undefined)    InsetRect(&amp;bar,0,2);  if(ec-&gt;flags &amp; easyControlActive)    PenPat((Pattern *)&amp;dBlackPat);  else    PenPat((Pattern *)&amp;dGrayPat);  RaisedRect(&amp;bar,ec-&gt;color[controlPart1]);  bar.left = bar.right;  bar.right = ec-&gt;rect.left + st-&gt;sWidth - 1;  if(ec-&gt;variation &amp; drawRightSlider)    RaisedRect(&amp;bar,ec-&gt;color[controlPart2]);  else    {    Fore555(ec-&gt;color[controlBackground]);    PaintRect(&amp;bar);    }  if(st-&gt;tHeight)            /* tHeight = 0 means no text  */    {    r.left = ec-&gt;rect.left;    r.top = ec-&gt;rect.top + st-&gt;sHeight - 1;    r.right = r.left + st-&gt;tWidth;    r.bottom = r.top + st-&gt;tHeight;    Fore555(ec-&gt;color[controlFrame]);    FrameRect(&amp;r);    InsetRect(&amp;r,1,1);    Fore555(ec-&gt;color[controlBackground]);    PaintRect(&amp;r);    MoveTo(r.left + 2,r.bottom - (st-&gt;tHeight - 9)/2);    Fore555(ec-&gt;color[controlFrame]);    if(st-&gt;drawValue)      (*st-&gt;drawValue)((easyControl)RecoverHandle((Ptr)ec));    else      {      if(undefined)        DrawString(&quot;\p----&quot;);      else if(st-&gt;numberType == longNum)        DrawNum(value);      else if(st-&gt;numberType == fixedNum)        DrawFixed(value,4);      else if(st-&gt;numberType == fracNum)        DrawFrac(value,8);      else        DrawString((StringPtr)&quot;\pxyz&quot;);      }    }  }          void TrackBoolean(easyControlPtr ec,Point p) /*   * Track the mouse within the slider as long   * as the button is held down, all the while   * updating the value and drawing the bar.   */  {   tSliderStyle *st;   Point lastP;   long oldValue;   long value;   long vRange, rRange,rounding;   double fVRange, fRRange, fRounding;    /* for floating point sliders  */   Rect slopRect;   long q;   Boolean zingCursor;   Handle tempH;    GoCursor(kSliderCursor);   zingCursor = true;    st = *(tSliderStyle **)ec-&gt;style;   HLock(tempH = RecoverHandle((Ptr)st));   oldValue = ec-&gt;value;    slopRect = ec-&gt;rect;   InsetRect(&amp;slopRect,-kSlop,-kSlop);    if(st-&gt;numberType == floatNum)     {     fVRange = AsFloat(ec-&gt;high) - AsFloat(ec-&gt;low);     fRRange = st-&gt;sWidth - 2;     fRounding = (fRRange / fVRange) / 2;     }   else     {     vRange = ec-&gt;high - ec-&gt;low;     rRange = st-&gt;sWidth - 2;     rounding = (rRange / vRange) / 2;     }    if(ec-&gt;initActionProc)          /* Call initAction proc once    */    (*ec-&gt;initActionProc)(ec-&gt;value,ec-&gt;refcon);  while(Button())     {    q = TickCount()+2;    while(TickCount() &lt; q)      SystemTask();    if(ec-&gt;actionProc)          /* Call action proc every time    */      (*ec-&gt;actionProc)(ec-&gt;value,ec-&gt;refcon);    lastP.h = p.h+1;            /* Guarantee do first time through  */    GetMouse(&amp;p);     if( (p.h != lastP.h) || (p.v != lastP.v) )       {       if(PtInRect(p,&amp;slopRect))         {         if(!zingCursor)           {           GoCursor(kSliderCursor);           zingCursor = true;           }         if(st-&gt;numberType == floatNum)           ;         else          value = ec-&gt;low + (long)(p.h - ec-&gt;rect.left + rounding + 1) * vRange/rRange;        }      else        {        value = oldValue;        if(zingCursor)          {          InitCursor();          zingCursor = false;          }        }      if(value &lt; ec-&gt;low)        value = ec-&gt;low;      else if(value &gt; ec-&gt;high)        value = ec-&gt;high;      if(value != ec-&gt;value)        {        ec-&gt;value = value;        DrawSliderValue(ec);        if(ec-&gt;valueProc)        /* Call value proc for new value  *//*          (*ec-&gt;valueProc)(ec); */          (*ec-&gt;valueProc)((easyControl)RecoverHandle((Ptr)ec));        }      lastP = p;      }     }   if(ec-&gt;doneActionProc)          /* Call doneAction proc once    */    (*ec-&gt;doneActionProc)(ec-&gt;value,ec-&gt;refcon);    HUnlock(tempH);   InitCursor();   }void KeyBoolean(register easyControlPtr ec,short k,short m,register Boolean *tookKey)  {  register short step;  *tookKey = true;  if(m&amp;shiftKey)    step = 10;  else    step = 1;  switch(k)    {    case 28:      ec-&gt;value-=step;      break;    case 29:      ec-&gt;value+=step;      break;    default:      *tookKey = false;    }  DrawSliderValue(ec);  }</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/QTMusicToo/listing27.html%3Fid%3DDTS10000915-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/QTMusicToo/listing27.html%3Fid%3DDTS10000915-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/QTMusicToo/listing27.html%3Fid%3DDTS10000915-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>