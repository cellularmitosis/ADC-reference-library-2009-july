<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>MenuScripter - /Sources/MSDrag.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxMacOS9Earlier-date.html">Mac OS 9 & Earlier</a> &gt; <A HREF="javascript:location.replace('index.html');">MenuScripter</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/Carbon/idxInterapplicationCommunication-date.html" target="_blank">Carbon > Interapplication Communication</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">MenuScripter</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/Sources/MSDrag.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/Resources/MenuScripterAETE.r</option>
<option value="listing2.html">/Sources/DebugUtils.c</option>
<option value="listing3.html">/Sources/DebugUtils.h</option>
<option value="listing4.html">/Sources/MenuScripter.r</option>
<option value="listing5.html">/Sources/MenuScripterPPC.r</option>
<option value="listing6.html">/Sources/MSAccessors.c</option>
<option value="listing7.html">/Sources/MSAccessors.h</option>
<option value="listing8.html">/Sources/MSAEClone.c</option>
<option value="listing9.html">/Sources/MSAEClone.h</option>
<option value="listing10.html">/Sources/MSAEClose.c</option>
<option value="listing11.html">/Sources/MSAEClose.h</option>
<option value="listing12.html">/Sources/MSAECoercions.c</option>
<option value="listing13.html">/Sources/MSAECoercions.h</option>
<option value="listing14.html">/Sources/MSAECompare.c</option>
<option value="listing15.html">/Sources/MSAECompare.h</option>
<option value="listing16.html">/Sources/MSAECopy.c</option>
<option value="listing17.html">/Sources/MSAECopy.h</option>
<option value="listing18.html">/Sources/MSAECountElements.c</option>
<option value="listing19.html">/Sources/MSAECountElements.h</option>
<option value="listing20.html">/Sources/MSAECreate.c</option>
<option value="listing21.html">/Sources/MSAECreate.h</option>
<option value="listing22.html">/Sources/MSAECut.c</option>
<option value="listing23.html">/Sources/MSAECut.h</option>
<option value="listing24.html">/Sources/MSAEDelete.c</option>
<option value="listing25.html">/Sources/MSAEDelete.h</option>
<option value="listing26.html">/Sources/MSAEGetData.c</option>
<option value="listing27.html">/Sources/MSAEGetData.h</option>
<option value="listing28.html">/Sources/MSAEGetDataSize.c</option>
<option value="listing29.html">/Sources/MSAEGetDataSize.h</option>
<option value="listing30.html">/Sources/MSAEMenuUtils.c</option>
<option value="listing31.html">/Sources/MSAEMenuUtils.h</option>
<option value="listing32.html">/Sources/MSAEMove.c</option>
<option value="listing33.html">/Sources/MSAEMove.h</option>
<option value="listing34.html">/Sources/MSAEObjectsExist.c</option>
<option value="listing35.html">/Sources/MSAEObjectsExist.h</option>
<option value="listing36.html">/Sources/MSAEPaste.c</option>
<option value="listing37.html">/Sources/MSAEPaste.h</option>
<option value="listing38.html">/Sources/MSAERecording.c</option>
<option value="listing39.html">/Sources/MSAERecording.h</option>
<option value="listing40.html">/Sources/MSAERevert.c</option>
<option value="listing41.html">/Sources/MSAERevert.h</option>
<option value="listing42.html">/Sources/MSAESave.c</option>
<option value="listing43.html">/Sources/MSAESave.h</option>
<option value="listing44.html">/Sources/MSAESelect.c</option>
<option value="listing45.html">/Sources/MSAESelect.h</option>
<option value="listing46.html">/Sources/MSAESetData.c</option>
<option value="listing47.html">/Sources/MSAESetData.h</option>
<option value="listing48.html">/Sources/MSAETextUtils.c</option>
<option value="listing49.html">/Sources/MSAETextUtils.h</option>
<option value="listing50.html">/Sources/MSAEUtils.c</option>
<option value="listing51.html">/Sources/MSAEUtils.h</option>
<option value="listing52.html">/Sources/MSAEWindowUtils.c</option>
<option value="listing53.html">/Sources/MSAEWindowUtils.h</option>
<option value="listing54.html">/Sources/MSAppleEvents.c</option>
<option value="listing55.html">/Sources/MSAppleEvents.h</option>
<option value="listing56.html">/Sources/MSASSubroutines.c</option>
<option value="listing57.html">/Sources/MSASSubroutines.h</option>
<option value="listing58.html">/Sources/MSDrag.c</option>
<option value="listing59.html">/Sources/MSDrag.h</option>
<option value="listing60.html">/Sources/MSFile.c</option>
<option value="listing61.html">/Sources/MSFile.h</option>
<option value="listing62.html">/Sources/MSGlobals.c</option>
<option value="listing63.html">/Sources/MSGlobals.h</option>
<option value="listing64.html">/Sources/MSGXPrinting.c</option>
<option value="listing65.html">/Sources/MSGXPrinting.h</option>
<option value="listing66.html">/Sources/MSMain.c</option>
<option value="listing67.html">/Sources/MSMain.h</option>
<option value="listing68.html">/Sources/MSResultWind.c</option>
<option value="listing69.html">/Sources/MSResultWind.h</option>
<option value="listing70.html">/Sources/MSScript.c</option>
<option value="listing71.html">/Sources/MSScript.h</option>
<option value="listing72.html">/Sources/MSToken.h</option>
<option value="listing73.html">/Sources/MSUtils.c</option>
<option value="listing74.html">/Sources/MSUtils.h</option>
<option value="listing75.html">/Sources/MSWindow.c</option>
<option value="listing76.html">/Sources/MSWindow.h</option>
<option value="listing77.html">/Sources/Offscreen.c</option>
<option value="listing78.html">/Sources/Offscreen.h</option>
<option value="listing79.html">/Sources/PLStrs.c</option>
<option value="listing80.html">/Sources/PLStrs.h</option></select>
				</p>
				</form>
				<p><strong><a href="MenuScripter.zip">Download Sample</a></strong> (&#147;MenuScripter.zip&#148;, 288.0K)<BR>
<strong><a href="MenuScripter.dmg">Download Sample</a></strong> (&#147;MenuScripter.dmg&#148;, 355.0K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">// SVDrag.c//// Original version by Jon Lansdell and Nigel Humphreys.// 4.0 and 3.1 updates by Greg Sutton.// Drag Manager support by Chris White// &copy;Apple Computer Inc 1996, all rights reserved.#include &quot;MSDrag.h&quot;#include &quot;MSWindow.h&quot;#include &quot;MSGlobals.h&quot;#include &quot;Offscreen.h&quot;#include &quot;DebugUtils.h&quot;#include &lt;Drag.h&gt;#include &lt;LowMem.h&gt;#include &lt;Errors.h&gt;#include &lt;Folders.h&gt;static short  gCaretOffset;    // Caret drawn during a drag#pragma segment Drag//// InitDragHandlers creates the UPPs for the Drag Manager // callback routines _if_ the Drag Manager is available.//OSErr InitDragHandlers ( void ){  OSErr  theErr = noErr;    if ( gHasDragManager )  {    gDragTrackingHandlerUPP = NewDragTrackingHandlerProc ( MyTrackingHandler );    gDragReceiveHandlerUPP = NewDragReceiveHandlerProc ( MyReceiveHandler );  }    return theErr;}//// InstallDragHandlers attaches the tracking and receive handlers to// one of the application's windows.//OSErr InstallDragHandlers ( WindowRef theWindow ){    OSErr   theErr = noErr;    if ( gHasDragManager )  {        theErr = InstallTrackingHandler ( gDragTrackingHandlerUPP, theWindow, nil );      if ( theErr == noErr )    {      theErr = InstallReceiveHandler ( gDragReceiveHandlerUPP, theWindow, nil );      if ( theErr )        (void) RemoveTrackingHandler ( gDragTrackingHandlerUPP, theWindow );    }      }    return theErr;}//// RemoveDragHandlers removes the tracking and receive handlers from// one of the application's windows (usually just prior to disposal).//void RemoveDragHandlers ( WindowRef theWindow ){  if ( gHasDragManager )  {        RemoveReceiveHandler ( gDragReceiveHandlerUPP, theWindow );    RemoveTrackingHandler ( gDragTrackingHandlerUPP, theWindow );      }    return;}Boolean IsDragInWindowContent ( DragReference theDrag, WindowRef theWindow ){  Point  localPt;    GetDragMouse ( theDrag, &amp;localPt, 0L );  GlobalToLocal ( &amp;localPt );      // Assumes theWindow is current port    return PtInWindow ( localPt, theWindow );}Boolean PtInWindow ( Point localPt, WindowRef theWindow ){  DPtr theDocument;    theDocument = DPtrFromWindowPtr ( theWindow );  return PtInDocument ( localPt, theDocument );}Boolean PtInDocument ( Point localPt, DPtr theDocument ){  return PtInRect ( localPt, &amp;(**(theDocument-&gt;theText)).viewRect );}Boolean CanAcceptDragItems ( DragReference theDrag, WindowPtr theWindow ){  OSErr      theErr;  ItemReference  theRef;  Boolean      bCanAccept = false;  HFSFlavor     currHFSFlavor;  Size      flavorDataSize;  FlavorFlags    currFlavorFlags;  DPtr      theDocument;    theDocument = DPtrFromWindowPtr ( theWindow );  if (theDocument-&gt;windowType == kOrdinaryWind)  {    theErr = GetDragItemReferenceNumber ( theDrag, 1, &amp;theRef );    if ( theErr == noErr )    {      // use GetFlavorFlags to check on flavor existence of TEXT data.      theErr = GetFlavorFlags ( theDrag, theRef, 'TEXT', &amp;currFlavorFlags );      if ( theErr == noErr )        bCanAccept = true;      else      {        // check if the item is a file spec, and it contains TEXT        flavorDataSize = sizeof ( HFSFlavor );        theErr = GetFlavorData ( theDrag, theRef, flavorTypeHFS, &amp;currHFSFlavor,                        &amp;flavorDataSize, 0  );                if ( theErr == noErr &amp;&amp; currHFSFlavor.fileType == 'TEXT' )           bCanAccept = true;      }    }  }              return (bCanAccept);}pascal OSErr MyTrackingHandler ( DragTrackingMessage theMessage, WindowPtr theWindow,                  void* handlerRefCon, DragReference theDrag ){#ifdef __MWERKS__  #pragma unused(handlerRefCon)#endif  static Boolean  bHasAcceptableDrag;  static Boolean  bHasHilitedWindow;  static Boolean  bShowCaret;    static long    caretMovedTime;  static short  lastOffset, insertPosition;    short      theOffset;  OSErr      theErr = noErr;  long      theTime = TickCount ( );  unsigned long  theAttributes;  RgnHandle    tempRgn;  DPtr      theDocument, hitDocument;      GetDragAttributes ( theDrag, &amp;theAttributes );  theDocument = DPtrFromWindowPtr ( theWindow );    switch ( theMessage )  {    case dragTrackingEnterHandler:      // Any initialization for this window handler.            bHasAcceptableDrag = CanAcceptDragItems ( theDrag, theWindow );            // Let the drag manager know if we can't accept this drag      if ( !bHasAcceptableDrag )        theErr = dragNotAcceptedErr;    break;          case dragTrackingEnterWindow:             caretMovedTime = theTime;      gCaretOffset = lastOffset = -1;      bShowCaret = true;      bHasHilitedWindow = false;          break;        case dragTrackingInWindow:      // Hiliting of the window during a drag is done      // here.  Do it only if we can accept these items      // and we're not in the source window.            if ( bHasAcceptableDrag )      {        // Check if the mouse is in a window's content region. Make an        // exception if the window has yet to leave the source window,        // since we don't want to hilite it in that stuation.        Boolean    bMouseInContent;        Point    theMouse;                bMouseInContent = false;        if ( theAttributes &amp; dragHasLeftSenderWindow )        {          bMouseInContent = IsDragInWindowContent ( theDrag, theWindow );        }                // If the mouse is in a window and it isn't hilited...        if ( bMouseInContent &amp;&amp; !bHasHilitedWindow )        {          tempRgn = NewRgn ( );          RectRgn ( tempRgn, &amp;(**(theDocument-&gt;theText)).viewRect );                    // ...draw the hilight...          if ( ShowDragHilite ( theDrag, tempRgn, true ) == noErr )            // ... and remember it's now hilited            bHasHilitedWindow = true;                    DisposeRgn ( tempRgn );        }                        GetDragMouse ( theDrag, &amp;theMouse, 0L );        theOffset = HitTest ( theMouse, &amp;hitDocument );                if ( theDocument == hitDocument )        {                  // Do not allow tracking through the selection in the          // window that sourced the drag.          if ( theAttributes &amp; dragInsideSenderWindow )            if ( IsOffsetInSelection ( theOffset, theDocument-&gt;theText ) )              theOffset = -1;                                          insertPosition = theOffset;                    //  Reset flashing counter if the offset has moved. This makes the          //  caret blink only after the caret has stopped moving long enough.          if ( theOffset != lastOffset )          {            caretMovedTime = theTime;            bShowCaret = true;          }          lastOffset = theOffset;                              //  Flash caret.          if ( theTime - caretMovedTime &gt; LMGetCaretTime ( ) )          {            bShowCaret = !bShowCaret;            caretMovedTime = theTime;          }                    if ( !bShowCaret )            theOffset = -1;                      //  If caret offset has changed, move caret on screen.          if (theOffset != gCaretOffset)          {            if (gCaretOffset != -1)              DrawCaret(gCaretOffset, theDocument-&gt;theText);                        if (theOffset != -1)              DrawCaret(theOffset, theDocument-&gt;theText);          }                    gCaretOffset = theOffset;        }        else        {          lastOffset = theOffset;          insertPosition = -1;        }      }    break;        case dragTrackingLeaveWindow:      //  If the caret is on the screen, remove it.      if (gCaretOffset != -1)      {        DrawCaret(gCaretOffset, theDocument-&gt;theText);        gCaretOffset = -1;      }            // Remove any window hiliting here. If the mouse      // is not in the window and it's hilited...      if ( bHasHilitedWindow )        // ...erase the hilight...        if ( HideDragHilite ( theDrag ) == noErr )          // ...remember that nothing is hilited          bHasHilitedWindow = false;    break;        case dragTrackingLeaveHandler:    break;        default:      theErr = paramErr;    break;  }    return theErr;}Boolean IsOffsetInSelection ( short theOffset, TEHandle theTE ){  return (theOffset &gt;= (*theTE)-&gt;selStart &amp;&amp; theOffset &lt;= (*theTE)-&gt;selEnd);}//// DragIsNotInSourceWindow returns true if the drag in progress// is not in the same window it originated in. This is called by// the tracking and receive handlers.//static Boolean DragIsNotInSourceWindow ( DragReference theDrag ){  DragAttributes currDragFlags;    GetDragAttributes ( theDrag, &amp;currDragFlags );  return !(currDragFlags &amp; dragInsideSenderWindow);}//// DragReceiver is called by the drag manager whenever an// item is dropped on one of the application's windows.//pascal OSErr MyReceiveHandler ( WindowPtr theWindow, void* handlerRefCon,                   DragReference theDrag ){#ifdef __MWERKS__  #pragma unused(handlerRefCon)#endif  Boolean        bHaveData = false;  Boolean        bMove = false;  OSErr        theErr = noErr;      unsigned short    numItems;  int          i;  unsigned long    theAttributes;  ItemReference    theItem;  Size        textSize, styleSize;  DPtr        theDocument;    short        theOffset;  Point        thePoint = { 0, 0 };    Ptr          textData = nil;  StScrpHandle    styleHandle = nil;  TEHandle      tempTE = nil;  Rect        tempRect;      RgnHandle      tempRgn;  Rect        sourceRect, targetRect;  tWindowOffscreen*  theOffscreen = nil;    if ( !(CanAcceptDragItems ( theDrag, theWindow ) &amp;&amp; IsDragInWindowContent ( theDrag, theWindow )) )    return dragNotAcceptedErr;    theDocument = DPtrFromWindowPtr ( theWindow );  GetDragAttributes ( theDrag, &amp;theAttributes );    // Get the location of the drop  theErr = GetDragMouse ( theDrag, &amp;thePoint, 0L );  if ( theErr ) goto CleanupAndBail;    GlobalToLocal ( &amp;thePoint );      // Assumes theWindow is current port  // Map the drop location to the text  theOffset = TEGetOffset ( thePoint, theDocument-&gt;theText );  // Don't allow a drop within the original selection  if ( theAttributes &amp; dragInsideSenderWindow )    if ( IsOffsetInSelection ( theOffset, theDocument-&gt;theText ) )      return dragNotAcceptedErr;          // Is this drag copying or a moving the text?  bMove = IsDragMoving ( theDrag );    // First, gather all the text into a temp TE record, and then insert that into  // the doucment. This approach makes it easy to handle things like text selection.  SetRect ( &amp;tempRect, 0, 0, 0, 0 );  tempTE = TEStylNew ( &amp;tempRect, &amp;tempRect );  theErr = MemError ( );  if ( tempTE == nil || theErr ) goto CleanupAndBail;    theErr = CountDragItems ( theDrag, &amp;numItems );  if ( theErr ) goto CleanupAndBail;    for ( i = 1; i &lt;= numItems; i++ )  {        theErr = GetDragItemReferenceNumber ( theDrag, i, &amp;theItem );    if ( theErr ) goto CleanupAndBail;        theErr = GetFlavorDataSize ( theDrag, theItem, 'TEXT', &amp;textSize );    if ( theErr ) goto CleanupAndBail;        textData = NewPtr ( textSize );    theErr = MemError ( );    if ( textData == nil || theErr ) goto CleanupAndBail;        theErr = GetFlavorData ( theDrag, theItem, 'TEXT', textData, &amp;textSize, 0L );    if ( theErr ) goto CleanupAndBail;            // Check for optional styl data for the TEXT.    styleHandle = 0L;    theErr = GetFlavorDataSize ( theDrag, theItem, 'styl', &amp;styleSize );    if ( !theErr )    {      styleHandle = (StScrpHandle) NewHandle ( styleSize );      theErr = MemError ( );      if ( styleHandle == nil || theErr ) goto CleanupAndBail;            HLock ( (Handle) styleHandle );      theErr = GetFlavorData ( theDrag, theItem, 'styl', *styleHandle, &amp;styleSize, 0L );      if ( theErr ) goto CleanupAndBail;      HUnlock ( (Handle) styleHandle );    }        // Insert this drag item's text into the tempTE.    TESetSelect ( 32767, 32767, tempTE );    TEStylInsert ( textData, textSize, styleHandle, tempTE );        DisposePtr ( textData );    textData = nil;    if ( styleHandle )    {      DisposeHandle ( (Handle) styleHandle );      styleHandle = nil;    }      }      // Pull the TEXT and styl data out of the tempTE handle.  textData = NewPtr (textSize = (**tempTE).teLength );  theErr = MemError ( );  if ( textData == nil || theErr ) goto CleanupAndBail;    BlockMoveData ( *(*tempTE)-&gt;hText, textData, textSize );  TESetSelect ( 0, 32767, tempTE );  styleHandle = TEGetStyleScrapHandle (tempTE );  TEDispose ( tempTE );  tempTE = nil;      // Insert any text into the destination.  if ( textSize != 0 )  {        // Get rid of the hilite/caret before inserting    if ( theAttributes &amp; dragHasLeftSenderWindow )      HideDragHilite ( theDrag );        if ( gCaretOffset != -1 )    {      DrawCaret ( gCaretOffset, theDocument-&gt;theText );      gCaretOffset = -1;    }        //  If the drag occurred completely within the same window and the window is not    //  frontmost, bring the window forward and update its contents before completing    //  the drag.    if ( (theAttributes &amp; dragInsideSenderWindow) &amp;&amp; (theWindow != FrontWindow ( )) )    {      SelectWindow ( theWindow );      DoUpdate ( theWindow );      if (theDocument-&gt;windowType == kOrdinaryWind)        TEActivate ( theDocument-&gt;theText );    }        //  If the window is not active, must activate TE before inserting    //  text or the background hilite will not update correctly.    if ( !IsWindowHilited ( theWindow ) )      if (theDocument-&gt;windowType == kOrdinaryWind)        TEActivate ( theDocument-&gt;theText );        //  Draw everything into offscreen pixmap.    theOffscreen = DrawOffscreen ( theWindow );    if ( theOffscreen  )      (*theDocument-&gt;theText)-&gt;inPort = (GrafPtr) theOffscreen-&gt;offscreenWorld;        if ( bMove )    {      // Get the current hilite rgn for zooming (source)      tempRgn = NewRgn ( );      theErr = MemError ( );      if ( theErr )  goto CleanupAndBail;      GetSelectedTextRgn ( theDocument, tempRgn );      sourceRect = (*tempRgn)-&gt;rgnBBox;      LocalRectToGlobalRect ( &amp;sourceRect, theWindow );            // If this is a move operation, delete the old text.      DeleteTextSelection ( theDocument-&gt;theText, &amp;theOffset );    }        InsertTextAtOffset ( theOffset, textData, textSize, styleHandle, theDocument-&gt;theText );        // If the text is moving (not copying) within the same window, provide a ZoomRects    // from the source to the destination before revealing the reflowed text.        if ( bMove )    {      // Get the current hilite rgn for zooming (target)      GetSelectedTextRgn ( theDocument, tempRgn );      targetRect = (*tempRgn)-&gt;rgnBBox;      DisposeRgn ( tempRgn );      tempRgn = nil;      LocalRectToGlobalRect ( &amp;targetRect, theWindow );            ZoomRects ( &amp;sourceRect, &amp;targetRect, 12, zoomDecelerate );    }  }    // Undo the TEActivate, if needed.  if ( !IsWindowHilited ( theWindow ) )    TEDeactivate ( theDocument-&gt;theText );    //  Show the offscreen bitmap.  if ( theOffscreen )  {    theOffscreen = DrawOnscreen ( theOffscreen );    (*theDocument-&gt;theText)-&gt;inPort = theWindow;  }    // Make the document dirty  theDocument-&gt;dirty = true;    CleanupAndBail:      // All of these will be nil if no error occurred  if ( textData )    DisposePtr ( textData );  if ( styleHandle )    DisposeHandle ( (Handle) styleHandle );  if ( tempTE )    TEDispose ( tempTE );  if ( tempRgn )    DisposeRgn ( tempRgn );    // Normally  nil since DrawOnscreen calls DisposeOffscreen  if ( theOffscreen )  {    DisposeOffscreen ( theOffscreen );    (*theDocument-&gt;theText)-&gt;inPort = theWindow;  }      return theErr;}void DeleteTextSelection ( TEHandle theTE, short* theInsertPosition ){  short selStart, selEnd;    selStart = (*theTE)-&gt;selStart;  selEnd = (*theTE)-&gt;selEnd;  if ( WhiteSpaceAtOffset ( selStart - 1, theTE ) &amp;&amp;      !WhiteSpaceAtOffset ( selStart, theTE ) &amp;&amp;      !WhiteSpaceAtOffset ( selEnd - 1, theTE ) &amp;&amp;       WhiteSpaceAtOffset ( selEnd, theTE ) )  {        if ( GetCharAtOffset ( selEnd, theTE ) == ' ' )      (*theTE)-&gt;selEnd++;  }    if ( *theInsertPosition &gt; selStart )    *theInsertPosition -= ((*theTE)-&gt;selEnd - (*theTE)-&gt;selStart);    TEDelete ( theTE );    return;}static Boolean IsDragMoving ( DragReference theDrag ){  DragAttributes  theAttributes;    GetDragAttributes ( theDrag, &amp;theAttributes );  return (theAttributes &amp; dragInsideSenderWindow) &amp;&amp; !IsDragWithOptionKey ( theDrag );}static Boolean IsDragWithOptionKey ( DragReference theDrag ){  short  mouseDownModifiers, mouseUpModifiers;    GetDragModifiers ( theDrag, 0L, &amp;mouseDownModifiers, &amp;mouseUpModifiers );  return (mouseDownModifiers &amp; optionKey) | (mouseUpModifiers &amp; optionKey);}void OutlineRegion ( RgnHandle theRgn ){  RgnHandle tempRgn;    tempRgn = NewRgn ( );  CopyRgn ( theRgn, tempRgn );  InsetRgn ( tempRgn, 1, 1 );  DiffRgn ( theRgn, tempRgn, theRgn );  DisposeRgn ( tempRgn );    return;}OSErr DoWindowContentDrag ( WindowPtr theWindow, EventRecord* theEvent ){  OSErr      theErr = noErr;  DragReference  theDrag = (unsigned long) nil;  RgnHandle    dragRgn = nil;  Ptr        dataPtr = nil;  StScrpHandle  styleHandle = nil;  short      dataSize;    DPtr      theDocument;  Rect      dragBounds;  ItemReference  theItem;      // create a new drag  theErr = NewDrag ( &amp;theDrag );  if ( theErr ) goto CleanupAndBail;    // use the window ptr as item reference for the heck of it  theItem = (ItemReference) theWindow;    // add the data to the drag  theDocument = DPtrFromWindowPtr ( theWindow );  dataPtr = NewPtr ( 0L );  theErr = GetSelectedText ( theDocument, dataPtr, &amp;dataSize );  if ( theErr || dataSize == 0 )  goto CleanupAndBail;    theErr = AddDragItemFlavor ( theDrag, theItem, 'TEXT', dataPtr, dataSize, 0 );  if ( theErr )  goto CleanupAndBail;  DisposePtr ( dataPtr );  dataPtr = nil;      // Add style data  styleHandle = TEGetStyleScrapHandle ( theDocument-&gt;theText );  HLock ( (Handle) styleHandle );  AddDragItemFlavor ( theDrag, theItem, 'styl', (Ptr) *styleHandle, GetHandleSize ( (Handle) styleHandle ), 0 );  HUnlock ( (Handle) styleHandle );  DisposeHandle ( (Handle) styleHandle );  styleHandle = nil;      // generate the bounds and region for the drag using the window's  // content rectangle  dragBounds = (**((WindowPeek) theWindow)-&gt;contRgn).rgnBBox;  theErr = SetDragItemBounds(theDrag, theItem, &amp;dragBounds);  if ( theErr ) goto CleanupAndBail;    dragRgn = NewRgn ( );  GetSelectedTextRgn ( theDocument, dragRgn );  LocalRgnToGlobalRgn ( dragRgn, nil );  OutlineRegion ( dragRgn );    // do the drag and clean up  TrackDrag ( theDrag, theEvent, dragRgn );      if ( DragIsNotInSourceWindow ( theDrag ) )  {    AEDesc  dropLocation;        // Get the drop location    GetDropLocation ( theDrag, &amp;dropLocation );    if ( !IsDragWithOptionKey ( theDrag ) &amp;&amp; DropLocationIsFinderTrash ( &amp;dropLocation) )    {      // Delete the exact text. Don't call DeleteTextSelection      TEDelete ( theDocument-&gt;theText );      theDocument-&gt;dirty = true;    }        AEDisposeDesc ( &amp;dropLocation );  }    CleanupAndBail:    if ( theDrag )    DisposeDrag(theDrag);    if ( dragRgn )    DisposeRgn ( dragRgn );    // These should be nil  if ( dataPtr )    DisposePtr ( dataPtr );  if ( styleHandle )    DisposeHandle ( (Handle) styleHandle );      return theErr;}void LocalRgnToGlobalRgn ( RgnHandle theRgn, WindowRef theWindow ){  GrafPtr    savePort;  Point    localPt, globalPt;      if ( theWindow )  {    GetPort ( &amp;savePort );    SetPortWindowPort ( theWindow );  }    localPt = globalPt = *(Point*) &amp;(*theRgn)-&gt;rgnBBox;    // top left  LocalToGlobal ( &amp;globalPt );  SubPt ( localPt, &amp;globalPt );  OffsetRgn ( theRgn, globalPt.h, globalPt.v );    if ( theWindow )    SetPort ( savePort );      return;}void LocalRectToGlobalRect ( Rect* theRect, WindowRef theWindow ){  GrafPtr    savePort;  Point    localPt, globalPt;      if ( theWindow )  {    GetPort ( &amp;savePort );    SetPortWindowPort ( theWindow );  }    localPt = globalPt = *(Point*) theRect;    // top left  LocalToGlobal ( &amp;globalPt );  SubPt ( localPt, &amp;globalPt );  OffsetRect ( theRect, globalPt.h, globalPt.v );    if ( theWindow )    SetPort ( savePort );      return;}OSErr GetSelectedText ( DPtr theDocument, Ptr dataPtr, short* dataSize ){  OSErr theErr;  TEHandle teHandle = theDocument-&gt;theText;    *dataSize = (**(teHandle)).selEnd - (**(teHandle)).selStart;  if ( *dataSize )  {    SetPtrSize ( dataPtr, *dataSize );    theErr = MemError ( );    if ( theErr )      return theErr;    BlockMoveData ( *(**(teHandle)).hText + (**(teHandle)).selStart, dataPtr, *dataSize );  }    return noErr;}void GetSelectedTextRgn ( DPtr theDocument, RgnHandle dataRgn ){  TEGetHiliteRgn ( dataRgn, theDocument-&gt;theText );    return;}//// Does the user want to drag something? First, checks the click could// be a drag, then waits to see if the user starts to drag the text.// Boolean UserWantsToDrag ( WindowRef theWindow, Point globalPt ){  Point  localPt;    localPt = globalPt;  GlobalToLocal ( &amp;localPt );      // Assumes theWindow is current port  if ( PointInWindowSelection ( localPt, theWindow ) )    return WaitMouseMoved ( globalPt );      return false;}//// Returns true if the local point is in the window's current selection//Boolean PointInWindowSelection ( Point localPt, WindowRef theWindow ){  Boolean    bHit;  RgnHandle  tempRgn;  DPtr    theDocument;    theDocument = DPtrFromWindowPtr ( theWindow );  if ( !(PtInDocument ( localPt, theDocument )) )    return false;    tempRgn = NewRgn ( );  GetSelectedTextRgn ( theDocument, tempRgn );  bHit = PtInRgn ( localPt, tempRgn );  DisposeRgn ( tempRgn );    return bHit;}////  Given a point in global coordinates, HitTest returns a pointer to a//  document structure if the point is inside a document window on the screen.//  If the point is not inside a document window, HitTest return NULL in//  theDoc. If the point is in a doument window and also in the viewRect of//  the document's TextEdit field, HitTest also returns the offset into//  the text that corresponds to that point. If the point is not in the text,//  HitTest returns -1.//short HitTest(Point theLoc, DPtr* theDoc){  GrafPtr    savePort;  WindowPtr  theWindow;  short    offset;    *theDoc = 0L;  offset = -1;    if (FindWindow(theLoc, &amp;theWindow) == inContent)  {    if ( Ours ( theWindow ) )    {      *theDoc = DPtrFromWindowPtr ( theWindow );      GetPort ( &amp;savePort );      SetPort(theWindow);      GlobalToLocal(&amp;theLoc);      SetPort ( savePort );            if ((PtInRect(theLoc, &amp;(**((**theDoc).theText)).viewRect)) &amp;&amp;         (PtInRect(theLoc, &amp;(**((**theDoc).theText)).destRect))) {                offset = TEGetOffset(theLoc, (**theDoc).theText);        if ((TEIsFrontOfLine(offset, (**theDoc).theText)) &amp;&amp; (offset) &amp;&amp;                  ((*((**((**theDoc).theText)).hText))[offset - 1] != 0x0D) &amp;&amp;            (TEGetPoint(offset - 1, (**theDoc).theText).h &lt; theLoc.h)) {          offset--;        }      }    }  }  return(offset);}// TEIsFrontOfLine, given an offset and a TextEdit handle, returns true if// the given offset is at the beginning of a line start.short TEIsFrontOfLine ( short offset, TEHandle theTE ){  short    line = 0;  if ((**theTE).teLength == 0)    return(true);  if (offset &gt;= (**theTE).teLength)    return( (*((**theTE).hText))[(**theTE).teLength - 1] == 0x0d );  while ((**theTE).lineStarts[line] &lt; offset)    line++;  return( (**theTE).lineStarts[line] == offset );}// TEGetLine, given an offset and a TextEdit handle, returns the line number// of the line that contains the offset.short TEGetLine ( short offset, TEHandle theTE ){  short    line = 0;  if (offset &gt; (**theTE).teLength)    return((**theTE).nLines);  while ((**theTE).lineStarts[line] &lt; offset)    line++;    return(line);}////  DrawCaret draws a caret in a TextEdit field at the given offset. DrawCaret//  expects the port to be set to the port that the TextEdit field is in.//  DrawCaret inverts the image of the caret onto the screen.//void DrawCaret(short offset, TEHandle theTE){  Point    theLoc;  short    theLine, lineHeight;  // Get the coordinates and the line of the offset to draw the caret.  theLoc  = TEGetPoint(offset, theTE);  theLine = TEGetLine(offset, theTE);      // For some reason, TextEdit dosen't return the proper coordinates  // of the last offset in the field if the last character in the record  // is a carriage return. TEGetPoint returns a point that is one line  // higher than expected. The following code fixes this problem.  if ((offset == (**theTE).teLength) &amp;&amp;      (*((**theTE).hText))[(**theTE).teLength - 1] == 0x0D) {    theLoc.v += TEGetHeight(theLine, theLine, theTE);  }  // Always invert the caret when drawing.  PenMode(patXor);  //Get the height of the line that the offset points to.  lineHeight = TEGetHeight(theLine, theLine, theTE);  // Draw the appropriate caret image.  MoveTo(theLoc.h - 1, theLoc.v - 1);  Line(0, 1 - lineHeight);  PenNormal();}char GetCharAtOffset(short offset, TEHandle theTE){  if (offset &lt; 0)    return(0x0D);  return(((char *) *((**theTE).hText))[offset]);}Boolean WhiteSpace(char theChar){  return((theChar == ' ') || (theChar == 0x0D));}Boolean WhiteSpaceAtOffset(short offset, TEHandle theTE){  char    theChar;  if ((offset &lt; 0) || (offset &gt; (**theTE).teLength - 1))    return(true);  theChar = ((char *) *((**theTE).hText))[offset];  return((theChar == ' ') || (theChar == 0x0D));}void InsertTextAtOffset(short offset, char *theBuf, long size, StScrpHandle theStyl, TEHandle theTE){  if (size == 0)    return;  // If inserting at the end of a word and the selection does not begin with  // a space, insert a space before the insertion.  if (!WhiteSpaceAtOffset(offset - 1, theTE) &amp;&amp;     WhiteSpaceAtOffset(offset, theTE) &amp;&amp;    !WhiteSpace(theBuf[0])) {    TESetSelect(offset, offset, theTE);    TEKey(' ', theTE);    offset++;  }  //  If inserting at the beginning of a word and the selection does not end  //  with a space, insert a space after the insertion.  if ( WhiteSpaceAtOffset(offset - 1, theTE) &amp;&amp;    !WhiteSpaceAtOffset(offset, theTE) &amp;&amp;    !WhiteSpace(theBuf[size - 1])) {    TESetSelect(offset, offset, theTE);    TEKey(' ', theTE);  }    TESetSelect(offset, offset, theTE);  TEStylInsert(theBuf, size, theStyl, theTE);  TESetSelect(offset, offset + size, theTE);    return;}//// DropLocationIsFinderTrash returns true if the given dropLocation// AEDesc is a descriptor of the Finder's Trash.//Boolean DropLocationIsFinderTrash ( AEDesc* dropLocation ){  OSErr      result;  AEDesc      dropSpec;  FSSpecPtr    theSpec;  CInfoPBRec    thePB;  short      trashVRefNum;  long      trashDirID;        //  Coerce the dropLocation descriptor to an FSSpec. If there's no dropLocation or  //  it can't be coerced into an FSSpec, then it couldn't have been the Trash.  if ( (dropLocation-&gt;descriptorType != typeNull) &amp;&amp;    (AECoerceDesc(dropLocation, typeFSS, &amp;dropSpec) == noErr))  {    HLock(dropSpec.dataHandle);    theSpec = (FSSpec *) *dropSpec.dataHandle;    //  Get the directory ID of the given dropLocation object.    thePB.dirInfo.ioCompletion = 0L;    thePB.dirInfo.ioNamePtr = (StringPtr) &amp;theSpec-&gt;name;    thePB.dirInfo.ioVRefNum = theSpec-&gt;vRefNum;    thePB.dirInfo.ioFDirIndex = 0;    thePB.dirInfo.ioDrDirID = theSpec-&gt;parID;        result = PBGetCatInfo(&amp;thePB, false);    HUnlock(dropSpec.dataHandle);    AEDisposeDesc(&amp;dropSpec);        if ( result )      return(false);    //  If the result is not a directory, it cannot be the Trash.    if (!(thePB.dirInfo.ioFlAttrib &amp; (1 &lt;&lt; 4)))      return(false);    //  Get information about the Trash folder.    FindFolder ( theSpec-&gt;vRefNum, kTrashFolderType, kCreateFolder, &amp;trashVRefNum, &amp;trashDirID);    //  If the directory ID of the dropLocation object is the same as the directory ID    //  returned by FindFolder, then the drop must have occurred into the Trash.    if ( thePB.dirInfo.ioDrDirID == trashDirID )      return true;  }      return false;}</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/MenuScripter/listing58.html%3Fid%3DDTS10000668-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/MenuScripter/listing58.html%3Fid%3DDTS10000668-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/MenuScripter/listing58.html%3Fid%3DDTS10000668-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>