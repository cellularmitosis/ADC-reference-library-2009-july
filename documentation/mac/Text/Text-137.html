<!-- Generated by Harlequin WebMaker 2.2.3 (23-Apr-1996)
LispWorks 3.2.2 -->
<HTML> <HEAD>
<TITLE>Specifying the Transfer Mode(IM: Tx)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING137></A>



<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="Text-136.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Text-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Text-594.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="Text-138.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="Text-2.html"><B>Text</B></A> / <BR><DD><A HREF="Text-126.html"><B>Chapter 3 - QuickDraw Text</B></A> / <A HREF="Text-133.html"><B>Using QuickDraw Text</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING137-0></A>
<H2><A NAME=MARKER-9-91></A>Specifying the Transfer Mode</H2>
 The value of the <A NAME=MARKER-2-331></A>current graphics port transfer mode (<CODE>txMode</CODE>) field determines the way glyphs are placed in the bit image and how the text is to appear. It defines the way text to be drawn interacts with text and graphics already drawn. (When a glyph is drawn, QuickDraw does a bit-by-bit comparison based on the mode and stores the resulting bits into the bit image.) You set the text mode by calling the <A NAME=MARKER-2-41></A><CODE>TextMode</CODE> procedure.<P>
 By default, the transfer mode <A NAME=MARKER-9-263></A>field is set to <A NAME=MARKER-9-287></A><A NAME=MARKER-0-96></A><CODE>srcOr</CODE>, which specifies that text to be drawn should overlay the existing graphics. The <CODE>srcOr</CODE> transfer mode produces the best results for drawing text because it writes only those bits that make up the actual glyph. In most situations, when drawing text with the basic transfer modes, you should use only <CODE>srcOr</CODE> or <CODE>srcBic</CODE>; all other modes can result in clipping of glyphs by adjacent glyphs. For example, the <CODE>Copy</CODE> operation paints over what already exists on the destination, replacing it entirely.<P>
<A NAME=HEADING137-3></A>
<H3>Basic Transfer Mode Operations</H3>
 For each type of drawing <A NAME=MARKER-9-398></A>mode, there <A NAME=MARKER-9-140></A>are four basic kinds of operations: <A NAME=MARKER-2-291></A><CODE>Copy</CODE>,<A NAME=MARKER-9-292></A> <CODE>Or</CODE>, <CODE><A NAME=MARKER-2-293></A>Xor</CODE>, and<A NAME=MARKER-2-294></A> <CODE>Bic</CODE> (bit clear).<A NAME=MARKER-2-399></A> For Color QuickDraw, there are additional arithmetic drawing mode operations designed specifically for use with color. They are discussed later in this section, and fully in <I><A HREF="../QuickDraw/QuickDraw-2.html">Inside Macintosh: Imaging</A></I>.<P>
 The transfer mode operation determines how the text is to be displayed: for each bit in the item to be drawn, the corresponding bit in the destination bitmap is identified, the specified Boolean operation is performed on the pair of bits, and the resulting bit is stored into the destination bit image. When you work with color pixels, transfer modes produce different results on indexed and direct devices.<P>
 In addition to drawing the entire glyph in all cases, the <CODE>srcOr</CODE> mode is recommended for all applications because it uses the least memory. The <CODE>srcOr</CODE> mode only affects other parts of existing glyphs if the glyphs overlap. In <CODE>srcOr</CODE> mode the color of the glyph is determined by the foreground color.<P>
 The maximum stack space required for a text drawing operation can be considerable. Text drawing uses a minimum amount of stack if the following conditions are true:<P>
<UL>
<LI>The transfer mode is <CODE>srcOr</CODE>.
<LI>The foreground color is black. 
<LI>The destination of the text is contained within a rectangular portion of the region of the graphics port that is actually visible on the screen.
<LI>The text is not scaled.
<LI>The text does not have to be italicized, outlined, or shadowed by QuickDraw.<P>
</UL>
 Otherwise, the amount of stack space required to draw all of the text at once depends most on the size and the width of the text and the depth of the destination.<P>
 If QuickDraw can't get enough stack space to draw an entire text segment at once, it draws the segment in pieces. <A NAME=MARKER-2-296></A>This can produce unusual results in modes other than <CODE>srcOr</CODE> or <CODE>srcBic</CODE> if some of the glyphs overlap because of kerning or italicizing. If the mode is <CODE>srcCopy</CODE>, overlapping glyphs are clipped by the last drawn glyph. If the mode is <CODE>srcXor</CODE>, pixels where the glyphs overlap are not drawn at all. If the mode is one of the arithmetic modes, the arithmetic rules are followed, ignoring that the destination may include part of the text being drawn.<P>
 The stack space required for a drawing operation in Color QuickDraw is roughly estimated by the following calculation.<P>
<PRE>
(text width) * (text height) * (font depth) / (8 bits per byte) + 3K
</PRE>
 Pixel depth normally equals the screen depth. If the amount of stack space available is small (less than 3.5K), QuickDraw instead uses a pixel depth of 1, which is slow, but uses less stack space.<P>
 For the original QuickDraw, the required stack space is roughly estimated by the following calculation.<P>
<PRE>
(text width) * (text height) / (8 bits per byte) + 2K
</PRE>
<A NAME=HEADING137-20></A>
<H3>Arithmetic Transfer Mode Operations</H3>
 Arithmetic <A NAME=MARKER-2-297></A>transfer modes calculate pixel values by adding, subtracting, or averaging the RGB components of the source and destination pixels. The arithmetic modes <A NAME=MARKER-2-298></A>change the destination pixels by performing arithmetic operations on the source and destination pixels.<P>
 Each drawing routine converts the source and destination pixels to their RGB (red, green, and blue) components, performs an operation on each pair of components to produce a new RGB value for the destination, and then assigns the destination to a pixel value close to the calculated RGB value. The arithmetic drawing modes are <CODE>addOver</CODE>, <CODE>addPin</CODE>, <CODE>subOver</CODE>, <CODE>subPin</CODE>, <CODE>adMax</CODE>, <CODE>adMin</CODE>, and <CODE>blend</CODE>. To specify an arithmetic mode, you pass the operation to be used to the <CODE>TextMode</CODE> procedure. For example, the following calls save the current state of the text mode field, then set it to the transfer mode blend.<P>
<PRE>
oldTextMode := theport.^txMode; 
TextMode(blend);
</PRE>
 The arithmetic modes were designed for use with color. They are most useful for 8-bit color, but they work on 4-bit and 2-bit color also. When the destination bitmap is one bit deep, the mode reverts to the basic transfer mode that best approximates the arithmetic mode requested. For more information about arithmetic mode operations, see the QuickDraw chapters in <I>Inside Macintosh:</I> Imaging<I></I>.<P>
<DL>
<DT><B>Note</B>
<DD>To help make color work well on different screen depths, Color QuickDraw does some validity checking of the foreground and background colors. If your application is drawing to a <CODE>CGrafPort</CODE> with a depth equal to 1 or 2, and if the RGB values of the foreground and background colors aren't the same, but both of them map to the same pixel value, then the foreground color is inverted. This ensures that, for instance, red text drawn on a green background doesn't map to black on black.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
<A NAME=HEADING137-26></A>
<H3>The grayishTextOr Transfer Mode</H3>
 You can use the<A NAME=MARKER-2-400></A> text drawing mode, <A NAME=MARKER-9-304></A><CODE>grayishTextOr</CODE>, to draw dimmed text on the screen. It is especially useful for displaying disabled user interface items. If the destination device is color and <CODE>grayishTextOr</CODE> is the transfer mode, QuickDraw draws with a blend of the foreground and background colors. If the destination device is black and white, the <CODE>grayishTextOr</CODE> mode dithers black and white.<B> Dithering</B> is a <A NAME=MARKER-2-189></A>technique that creates the effect of additional colors, if the destination device is color. If the destination device is black-and-white, dithering creates the effect of levels of gray.<P>
 Note that <CODE>grayishTextOr</CODE> is not considered a standard transfer mode because currently it is not stored in pictures, and printing with it is undefined. (It does not pass through the QuickDraw bottleneck procedure.) The following calls show how to use <CODE>grayishTextOr</CODE>. They save the current state of the text mode field, then set it to <CODE>grayishTextOr</CODE>.<P>
<PRE>
oldTextMode := theport.^txMode;
TextMode(grayishTextOr);
</PRE>
<A NAME=HEADING137-30></A>
<H3><A NAME=MARKER-9-110></A>Text Mask Mode</H3>
 You can add the <A NAME=MARKER-2-515></A><CODE>mask</CODE> constant <A NAME=MARKER-9-217></A>to another <A NAME=MARKER-2-401></A>transfer mode to cause only the glyph portion of the text to be applied in the current transfer mode to the destination. If the text font contains more than one color or if the drawing mode is an arithmetic mode, the mask mode causes only the portion of the glyphs not equal to the background to be drawn.<P>
 The arithmetic transfer modes apply the glyph's background to the destination; this can lead to undesirable results if you draw the text in pieces. QuickDraw draws the leftmost part of a piece of text on top of a previous piece if the font kerns to the left. Using <CODE>maskMode</CODE> in addition to these modes causes only the foreground part of the glyph to be drawn.<P>
 Because the rightmost glyph is clipped, to kern to the right in text mask mode, you should use <CODE>srcOr</CODE>, or add trailing spaces. The following call sets the transfer mode to blend with mask mode.<P>
<PRE>
TextMode(blend + mask);
</PRE>
<A NAME=HEADING137-35></A>
<H3>Transparent Transfer Mode</H3>
 The <CODE>transparent</CODE> <A NAME=MARKER-2-509></A>mode replaces the destination pixel with the source pixel when the source pixel isn't equal to the background color. For a complete description of the transparent mode, see the QuickDraw chapters in <I><A HREF="../QuickDraw/QuickDraw-2.html">Inside Macintosh: Imaging</A></I>.<P>
 The arithmetic transfer modes apply the glyph's background to the destination; this can produce undesirable results if you draw the text in pieces. QuickDraw draws the leftmost part of a piece of text on top of a previous piece if the font kerns to the left. If you use the mask mode (<CODE>maskMode</CODE>) in addition to these modes, QuickDraw draws only the foreground part of the glyph. Because the rightmost glyph is clipped, to kern to the right in text mask mode, you should use <CODE>srcOr</CODE>. For an explanation of kerning, see the chapter "Font Manager" in this book.<P>
<A NAME=HEADING137-38></A>
<H3>Transfer Modes and Multibit Fonts</H3>
 Multibit fonts can have a specific color. Some transfer modes may not produce the desired results with a <A NAME=MARKER-2-226></A>multibit font. However, the <A NAME=MARKER-2-227></A>arithmetic mode and transparent mode work equally well with single bit and multibit fonts.<P>
 Unlike single bit fonts, multibit fonts draw quickly in <CODE>srcOr</CODE> mode only if the foreground is white. Single bit fonts draw quickly in <CODE>srcOr</CODE> mode only if the foreground is black. Grayscale fonts produce a spectrum of colors, rather than just the foreground and background colors.<A NAME=MARKER-2-415></A><P>
</BLOCKQUOTE>
<HR>
<center>
<A HREF="Text-136.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Text-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Text-594.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="Text-138.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="Text-3.html">&copy; Apple Computer, Inc.</A><br>6 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>  
