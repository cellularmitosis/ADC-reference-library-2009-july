//¥	----------------------------------------	Includes#include <Movies.h>#include "Graphics.h"#include "MoviePlayback.h"//¥	----------------------------------------	Definitions//¥	----------------------------------------	Types//¥	----------------------------------------	Private Variablesstatic Movie	gTheMovie;static CGrafPtr	gMovieWindow;static short	gMovieRefNum;static Rect		gMovieBox;//¥	----------------------------------------	Private Functionsstatic void CenterRectOnWindow(RectPtr theRect, CGrafPtr theWindow);//¥	----------------------------------------	Public VariablesFSSpec	gMovieSpec;//¥	--------------------	PlaybackMovievoidPlaybackMovie(void){GDHandle	movieDevice;OSErr	theErr;short	movieResID = 0;Boolean	wasChanged;	GraphicsGetUnderlayGrafPort(&gMovieWindow, &movieDevice);	theErr = OpenMovieFile(&gMovieSpec, &gMovieRefNum, fsRdPerm);	if (theErr)		return;			theErr = NewMovieFromFile(&gTheMovie, gMovieRefNum, &movieResID, "\p", newMovieActive, &wasChanged);	if (theErr)		return;	//¥	Find the dimensions of the movie and translate them to a (0, 0) base	GetMovieBox(gTheMovie, &gMovieBox);	OffsetRect(&gMovieBox, -gMovieBox.left, -gMovieBox.top);	CenterRectOnWindow(&gMovieBox, gMovieWindow);	SetMovieGWorld(gTheMovie, gMovieWindow, gGameGDH);	SetMovieBox(gTheMovie, &gMovieBox);		//¥	Rewind the movie	SetMovieTimeValue(gTheMovie, 0L);		//¥	Preroll the movie and start playback	MoviesTask(gTheMovie, 0);	MoviesTask(gTheMovie, 0);	StartMovie(gTheMovie);		FlushEvents(everyEvent, 0);	//¥	Service the movie until it is finished.  Minimally look for key strokes and mouse clicks.	MoviesTask(gTheMovie, 0);	GraphicsSetUnderlayRectDirty(&gMovieBox);}//¥	--------------------	ServiceMoviePlaybackvoidServiceMoviePlayback(void){	if (gTheMovie)	{		//¥	If the movie is finished then rewind it and start the playback over again		if (IsMovieDone(gTheMovie))		{			SetMovieTimeValue(gTheMovie, 0L);			StartMovie(gTheMovie);		}		//¥	Otherwise, service the movie and update the underlay buffer		MoviesTask(gTheMovie, 0);		GraphicsSetUnderlayRectDirty(&gMovieBox);	}}//¥	--------------------	ShutdownMoviePlaybackvoidShutdownMoviePlayback(void){	if (gTheMovie)	{		StopMovie(gTheMovie);		DisposeMovie(gTheMovie);		CloseMovieFile(gMovieRefNum);				gTheMovie = 0;	}}//¥	--------------------	CenterRectOnWindowstatic voidCenterRectOnWindow(RectPtr theRect, CGrafPtr theWindow){short	newH, newV;Rect		wRect;	wRect = theWindow->portRect;	//¥	Zero the origin of the rects	OffsetRect(&wRect, -wRect.left, -wRect.top);	OffsetRect(theRect, -theRect->left, -theRect->top);	//¥	Find the difference between the two rects' sizes	newH = (wRect.right - wRect.left) - (theRect->right - theRect->left);	newV = (wRect.bottom - wRect.top) - (theRect->bottom - theRect->top);	//¥	Half the difference so that it's centered top-to-bottom and left-to-right	newH >>= 1;	newV >>= 1;	//¥	Add that offset to the upper-left of the monitor	newH += wRect.left;	newV += wRect.top;	//¥	Center the rect	OffsetRect(theRect, newH, newV);}//¥	--------------------	SelectBackgroundMovievoidSelectBackgroundMovie(void){SFTypeList			typeList = { MovieFileType };StandardFileReply	theReply;	StandardGetFile(nil, 1, typeList, &theReply);	if (! theReply.sfGood)		return;			BlockMoveData(&theReply.sfFile, &gMovieSpec, sizeof (FSSpec));}