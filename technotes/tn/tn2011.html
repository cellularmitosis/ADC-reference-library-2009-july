<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"            "http://www.w3.org/TR/REC-html40/loose.dtd"><HTML><HEAD><LINK REL="stylesheet" HREF="../../adcstyle.css" TYPE="text/css"><LINK REL="stylesheet" HREF="../../style.css" TYPE="text/css"><title>Technical Note TN2011: File Mapping in Mac OS 9.1</title><meta name="keywords" content="file mapping virtual memory">    <meta name="Description" content="Technical Note TN2011: A description and explanation of thenew file mapping APIs provided in Mac OS 9.1."><meta name="categories" content="Runtime Architecture, Files, Memory, Operating System, Overview and System Releases"><meta name="week-posted" content="Jan 22, 2001 - Jan 26, 2001"><LINK REL="stylesheet" HREF="../../css/adcstyle.css" TYPE="text/css"><script language="JavaScript" type="text/javascript" src="../../js/adc.js"></script></HEAD><BODY bgcolor="#ffffff"><a name="//apple_ref/doc/uid/DTS10003050" title="File Mapping in Mac OS 9.1"></a><!-- top_of_header_marker_comment --><!-- begin_header_information --><!--#include virtual="/adcnavbar" --><p><a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../technicalnotes/index.html">Technical Notes</a> &gt; <a href="../../technicalnotes/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../technicalnotes/LegacyTechnologies/idxMacOS9Earlier-date.html">Mac OS 9 & Earlier</a> &gt; </p><div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/Carbon/idxFileManagement-date.html" target="_blank">Carbon > File Management</a></li>
		<li><a href="http://developer.apple.com/referencelibrary/Carbon/idxRuntimeArchitecture-date.html" target="_blank">Carbon > Runtime Architecture</a></li>
	</ul>
</div>




</div></div></div><!-- end_header_information --><!-- bottom_of_header_marker_comment --><!-- top_of_titles_marker_comment --><CENTER><table width="600" cellpadding="0" cellspacing="0" border="0">
<tr><td align="left" scope="row">
<h1>
<div id="pagehead">Technical Note TN2011</div>
<div id="pageheadsub">File Mapping in Mac OS 9.1</div>
</h1>
</td></tr></table></CENTER><!-- bottom_of_titles_marker_comment --><center><table width="600" cellpadding="0" cellspacing="0" border="0"><tr><td align="left" scope="row"><A NAME="doctop" title="Back to Top"></A><table width="600" cellpadding="0" cellspacing="0" border="0">    <tr>        <td width=300 valign="top" align=left>            <table border="0" width="300" cellpadding="0" cellspacing="0">                <tr>                                <td width=300 align=left> <img src="images/tnmenutop.gif" alt="" align="bottom" width=300 height=7></td>                </tr>                <tr bgcolor="#e6e6e6">                    <td background="images/tnmenubody.gif" width=300 align=left>                        <span id="menutitle">                            CONTENTS                             <br>                        </span>                    </td>                </tr>                <tr bgcolor="#e6e6e6">                    <td background="images/tnmenubody.gif" width=300 align=left>                            <br>                        <p id="menutext">                            <A HREF="#fmp_overview">Overview</a>                        </p>                        <p id="menutext2">                            <A HREF="#fmp_availability">Availability</a>                            <br>                            <br>                      <A HREF="#fmp_mappedforks">Mapped File Forks</a>                            <br>                            <br>                      <A HREF="#fmp_mappedviews">Mapped File Views</a>                            <br>                            <br>          <A HREF="#fmp_ownership">Process Ownership of File Mappings</a>                            <br>                            <br>          <A HREF="#fmp_shutdown">File Mappings and System Shutdown</a>                            <br>                            <br>          <A HREF="#fmp_pagesize">Memory Page Size</a>                            <br>                        </p>                        <p id="menutext">                            <A HREF="#fmp_apidescs">File Mapping APIs</a>                            <br>                            <br>                            <A HREF="#implementationnotes">Implementation Notes for Mac OS 9.1</a>                            <br>                            <br>                            <A HREF="#fmpdownloads">Downloadables</a>                            <br>                            <br>                        </p>                    </td>                </tr>                <tr>                    <td width=300 align=left scope="row">                        <img src="images/tnmenubottom.gif" alt="" width=300 height=16>                    </td>                </tr>            </table>        </td>        <td width=300 valign="top" align=left><p id="introtext">This Technical Note discusses the new file mapping APIs introduced in Mac&nbsp;OS&nbsp;9.1.  These APIs allow applications to take advantage of the virtual memory system to supplement the virtual memory address space available for their use.  Using these new APIs, not only is it possible for an application to create and use its own private blocks of virtual memory, but it is also possible for an application to specify the data files that will be used by the virtual memory system as the backing store for the virtual memory it allocates.  </p><p id="introtext">All developers interested in taking advantage of the virtual memory system for supplementing the addressable memory available to their application or implementing memory mapped access to large collections of data stored on disk will want to read this Technical Note.</p><!-- begin_date -->            <h4 align=center>                [Jan 25 2001]            </h4><!-- end_date -->        </td>    </tr></table><br><hr width=500 align=center><table width="600" cellpadding="0" cellspacing="0" border="0"><tr><td align="left" scope="row"><BR><BR><A NAME="fmp_overview" title="Overview"></A><h2>Overview</h2>         <p>File mapping allows an application to take advantage of the virtual memory system and supplement the memory space allocated for it with additional pageable memory.   This mechanism works by implementing a direct one to one mapping between the range of file mapped memory addresses allocated for the application and the contents of a file on disk.  Once a file mapped address range has been allocated for an application, the application can use that range of memory addresses as if it were any other block of memory.</p><p><img src="images/filemap.jpg" alt="File Mapping" align=left width=350 height=350>Terminology used in this document makes a distinction between the contents of the file on disk and the virtual contents of the file in memory.  A file that has been opened for use with these APIs is referred to as a mapped file, and the particular fork that is being used for file mapping is referred to as the mapped file fork.  The address range in memory allocated by the virtual memory system for your application's use is referred to as the mapped file view.</p><P>There is a one to one correspondence between the addresses within the mapped file view and offsets into the section of the mapped file fork used for file mapping purposes.  Specifically, the lowest address in the mapped file view will correspond to the lowest offset into the mapped file fork and the highest address in the mapped file view will correspond to the highest offset into the mapped file fork.</P><P>An application is free to use as many file mappings as it requires.  As well, file mappings can be allocated and deallocated on the fly during particular processing operations.  For example, say a particular function in an application required access to a very large lookup table during execution, but that function wasn't called very often.  In this case, the table could be stored in a file rather than in memory and the function could open a read-only memory mapped view to the file and then access elements in stored in the table in the file as if it were accessing a elements in an array stored in memory.</P></td></tr></table><BR><BR><A NAME="fmp_availability" title="Availability"></A><h3>Availability</h3><A NAME="gestaltFileMappingAttr"></A><A NAME="gestaltFileMappingPresent"></A><p>The <CODE>gestaltFileMappingAttr</CODE> <CODE><A HREF="http://developer.apple.com/documentation/mac/OSUtilities/OSUtilities-11.html">Gestalt</A></CODE> selector can be used to determine if the file mapping APIs are available.  Your application can use this selector to test for the availability of the file mapping APIs as follows:</p><A NAME="FileMappingAvailable"></A><BR><BR><CENTER><TABLE BORDER=0 CELLPADDING=4 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>    /* FileMappingAvailable returns true if the file mapping APIs    discussed in this document are available for your application    to use. */Boolean FileMappingAvailable(void) {    long response;    if (<A HREF="http://developer.apple.com/documentation/mac/OSUtilities/OSUtilities-11.html">Gestalt</A>(gestaltFileMappingAttr, &amp;response) != <CODE>noErr</CODE>)        response = 0;    return ((response &amp; (1&lt;&lt;gestaltFileMappingPresent)) != 0);}</pre></TD></TR></TABLE></CENTER><BR><BR> <p>The file mapping APIs are exported from <CODE>InterfaceLib</CODE>.</p><P><A HREF="#doctop">Back to top</A></P>              <BR><BR><A NAME="fmp_mappedforks" title="Mapped File Forks"></A><H3>Mapped File Forks</H3><P>A file must be opened using <CODE><A HREF="#OpenMappedFile">OpenMappedFile</A></CODE> before a mapped file view can be created. <CODE><A HREF="#OpenMappedFile">OpenMappedFile</A></CODE> lets you to specify the file to be opened, the fork to be opened, and the <CODE><A HREF="#MappingPrivileges">MappingPrivileges</A></CODE> to be used when opening the file fork.  <CODE><A HREF="#OpenMappedFile">OpenMappedFile</A></CODE> returns a <CODE><A HREF="#BackingFileID">BackingFileID</A></CODE> that is used to identify the mapped file fork. <CODE><A HREF="#OpenMappedFile">OpenMappedFile</A></CODE> fails if the file fork cannot be opened with the <CODE><A HREF="#MappingPrivileges">MappingPrivileges</A></CODE> requested.</P><P>While the mapped file fork is open, all other access paths to the file fork are denied regardless of the <CODE><A HREF="#MappingPrivileges">MappingPrivileges</A></CODE> requested. Mapped file forks cannot be accessed by way of the File Manager while the mapped file fork is open. Likewise, file forks opened by the File Manager cannot be opened as mapped file forks.</P><P>Two variants of <CODE><A HREF="#OpenMappedFile">OpenMappedFile</A></CODE>, <CODE><A HREF="#FSpOpenMappedFile">FSpOpenMappedFile</A></CODE> and <CODE><A HREF="#OpenMappedScratchFile">OpenMappedScratchFile</A></CODE>, are provided. <CODE><A HREF="#FSpOpenMappedFile">FSpOpenMappedFile</A></CODE> allows applications to specify the file fork to be opened using a <CODE><A HREF="http://developer.apple.com/documentation/Carbon/Files/FileManager/File_Manager/DataTypes/FSSpec.html">FSSpec</A></CODE> instead of a <CODE><A HREF="http://developer.apple.com/documentation/Carbon/Files/FileManager/File_Manager/DataTypes/FSRef.html">FSRef</A></CODE>. <CODE><A HREF="#OpenMappedScratchFile">OpenMappedScratchFile</A></CODE> attempts to create and open a scratch file for use as a mapped file fork on a specified volume. The data for a scratch file is only valid in an open mapped file view. When a mapped file view is created for a scratch file, data on disk is not paged into memory. When a mapped file view for a scratch file is unmapped, changes are not written from memory to disk.</P><P>A program can obtain information about an open mapped file fork using <CODE><A HREF="#GetMappedFileInformation">GetMappedFileInformation</A></CODE>. A program can obtain a list of open mapped file forks using <CODE><A HREF="#GetNextMappedFile">GetNextMappedFile</A></CODE>. A program can change the size of an open mapped file fork using <CODE><A HREF="#SetMappedFileSize">SetMappedFileSize</A></CODE>.</P><P>When a program is finished using a mapped file fork, it must close the mapped file fork using <CODE><A HREF="#CloseMappedFile">CloseMappedFile</A></CODE>. All mapped file views using the <CODE><A HREF="#BackingFileID">BackingFileID</A></CODE> must be closed before closing the mapped file fork. <CODE><A HREF="#CloseMappedFile">CloseMappedFile</A></CODE> deletes the scratch file after it is closed if the <CODE><A HREF="#BackingFileID">BackingFileID</A></CODE> is for a scratch file.</P>         <P><A HREF="#doctop">Back to top</A></P><BR><BR><A NAME="fmp_mappedviews" title="Mapped File Views"></A><H3>Mapped File Views</H3><P>To access the data in a mapped file fork, a program must create a mapped file view by using <CODE><A HREF="#MapFileView">MapFileView</A></CODE>. <CODE><A HREF="#MapFileView">MapFileView</A></CODE> lets you to specify the mapped file fork, the offset into the mapped file fork where the mapped file view should start, the length of the mapped file view, the memory access level (<CODE><A HREF="#FileViewAccess">FileViewAccess</A></CODE>), the size of a excluded range of bytes (a guard zone) to place adjacent to each end of the mapped file view, the optional characteristics of the mapped file view (<CODE><A HREF="#FileViewOptions">FileViewOptions</A></CODE>), and the requested base address of the mapped file view. <CODE><A HREF="#MapFileView">MapFileView</A></CODE> returns the base address of the mapped file view, the length of the mapped file view, and a <CODE><A HREF="#FileViewID">FileViewID</A></CODE> that identifies the mapped file view.</P><P>A program can obtain the valid bits allowed in the <CODE><A HREF="#FileViewAccess">FileViewAccess</A></CODE> and <CODE><A HREF="#FileViewOptions">FileViewOptions</A></CODE> passed to <CODE><A HREF="#MapFileView">MapFileView</A></CODE> using <CODE><A HREF="#GetFileViewAccessOptions">GetFileViewAccessOptions</A></CODE>. A program can obtain information about a mapped file view using <CODE><A HREF="#GetFileViewInformation">GetFileViewInformation</A></CODE>. A program can obtain the <CODE><A HREF="#FileViewID">FileViewID</A></CODE> for a specific address using <CODE><A HREF="#GetFileViewFromAddress">GetFileViewFromAddress</A></CODE>. A program can obtain a list of mapped file views using <CODE><A HREF="#GetNextView">GetNextView</A></CODE>. A program can change memory access level of a mapped file view using <CODE><A HREF="#SetFileViewAccess">SetFileViewAccess</A></CODE>. A program can change the backing base of a mapped file view using <CODE><A HREF="#SetFileViewBackingBase">SetFileViewBackingBase</A></CODE>.</P> <P>When a program is finished using a mapped file view, it must close the mapped file view using <CODE><A HREF="#UnmapFileView">UnmapFileView</A></CODE>. Any modified memory in a mapped file view is written to the mapped file fork when the mapped file view is un-mapped unless the mapped file fork is a scratch file created with <CODE><A HREF="#OpenMappedScratchFile">OpenMappedScratchFile</A></CODE>.</P>         <P><A HREF="#doctop">Back to top</A></P><BR><BR><A NAME="fmp_ownership" title="Process Ownership of File Mappings"></A><H3>Process Ownership of File Mappings</H3><P>When a mapped file fork is opened, the current process becomes the owning process for that mapped file fork and all of its mapped file views. The owning process is the only process that can change or un-map the mapped file views it owns, and change or close the mapped file forks it owns. When the owning process terminates, all mapped file views created by that process are unmapped, and all mapped file forks opened by a process are closed.</P><P>Process ownership may be overridden by specifying <CODE><A HREF="#kNoProcessMappedFile">kNoProcessMappedFile</A></CODE> in the <CODE><A HREF="#MappingPrivileges">MappingPrivileges</A></CODE> when a mapped file fork is opened. Mapped file forks opened with the <CODE><A HREF="#kNoProcessMappedFile">kNoProcessMappedFile</A></CODE> privilege are not owned by any process.</P><BR><BR><CENTER><TABLE BORDER=0 CELLPADDING=4 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>IMPORTANT:</B><BR>Programs using <CODE><A HREF="#kNoProcessMappedFile">kNoProcessMappedFile</A></CODE> must un-map mapped file views and close mapped file forks when they are no longer needed. Failing to do so is a programming error and will cause the system to run out of logical address space.</P></TD></TR></TABLE></CENTER><BR><BR><P><A HREF="#doctop">Back to top</A></P>         <BR><BR><A NAME="fmp_shutdown" title="File Mappings and System Shutdown"></A><H3>File Mappings and System Shutdown</H3><P>All mapped file views are unmapped and all mapped file forks are closed at the <CODE>sdOnUnmount</CODE> stage of the system shutdown process. This means that the only safe time to use code or data stored in file mapped files opened with the File Mapping programming interfaces is at or before the <CODE>sdOnDrivers</CODE> stage of the system shutdown process.</P>         <P><A HREF="#doctop">Back to top</A></P><BR><BR><A NAME="fmp_pagesize" title="Memory Page Size"></A><H3>Memory Page Size</H3><P>The page size used by the file mapping APIs is the same as the page size used by the Virtual Memory Manager.  This page size can be determined by using the <CODE>gestaltLogicalPageSize</CODE> <CODE><A HREF="http://developer.apple.com/documentation/mac/OSUtilities/OSUtilities-11.html">Gestalt</A></CODE> selector.</P>         <P><A HREF="#doctop">Back to top</A></P>                                    <BR><BR><A NAME="fmp_apidescs" title="File Mapping APIs"></A><H2>File Mapping APIs</H2><P>This section presents the new file mapping APIs together with comments describing their usage.  </P>         <P><A HREF="#doctop">Back to top</A></P><BR><BR><A NAME="BackingFileID"></A><P><B><CODE>BackingFileID</CODE></B></P><P>A BackingFileID is used to access a mapped file fork.</P><BR><BR><CENTER><TABLE BORDER=0 CELLPADDING=4 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>typedef struct OpaqueBackingFileID *BackingFileID;</pre></TD></TR></TABLE></CENTER><BR><BR>                             <P><A HREF="#doctop">Back to top</A></P><BR><BR><A NAME="MappingPrivileges"></A><P><B><CODE>MappingPrivileges</CODE></B></P><P>A set of flags that describe what operations can be performed on a                    mapped file fork.</P><BR><BR><CENTER><TABLE BORDER=0 CELLPADDING=4 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>typedef OptionBits MappingPrivileges;enum {    kInvalidMappedPrivileges = 0x00000000,    kCanReadMappedFile = 0x00000001,   /* mapped file fork                                       has read access */    kCanWriteMappedFile = 0x00000002,  /* mapped file fork                                       has write access */    kNoProcessMappedFile = (long)0x80000000,  /* mapped file fork                                              and views are not                                              tracked by process */    kValidMappingPrivilegesMask =        kCanReadMappedFile        + kCanWriteMappedFile        + kNoProcessMappedFile};</pre></TD></TR></TABLE></CENTER><BR><BR>                    <UL><LI><A NAME="kCanReadMappedFile"></A><B>kCanReadMappedFile</B> - Allow the file fork to be mapped such that the memory can be read (this is required).<BR><BR></LI><LI><A NAME="kCanWriteMappedFile"></A><B>kCanWriteMappedFile</B> - Allow the file fork to be mapped such that the memory can be written. If not set, then the memory can be mapped read-only.<BR><BR></LI><LI><A NAME="kNoProcessMappedFile"></A><B>kNoProcessMappedFile</B> - The mapped file fork and its mapped file views are not tracked by process ID.<BR><BR></LI></UL>         <P><A HREF="#doctop">Back to top</A></P><BR><BR><A NAME="MappedFileAttributes"></A><P><B><CODE>MappedFileAttributes</CODE></B></P><P>A set of flags returned by <CODE><A HREF="#GetMappedFileInformation">GetMappedFileInformation</A></CODE> that describe the attributes of a mapped file fork.</P><BR><BR><CENTER><TABLE BORDER=0 CELLPADDING=4 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>typedef OptionBits MappedFileAttributes;enum {    kIsMappedScratchFile = 0x00000001  /* mapped file fork                                       is scratch file */};</pre></TD></TR></TABLE></CENTER><BR><BR>                    <UL><LI><A NAME="kIsMappedScratchFile"></A><B>kIsMappedScratchFile</B> - Set when the mapped file fork is a scratch file created with <CODE><A HREF="#OpenMappedScratchFile">OpenMappedScratchFile</A></CODE>.<BR><BR></LI></UL>         <P><A HREF="#doctop">Back to top</A></P><BR><BR><A NAME="kMappedFileInformationVersion1"></A><P><B><CODE>kMappedFileInformationVersion1</CODE></B></P><P>The version number of the <CODE>MappedFileInformation</CODE> struct.</P><BR><BR><CENTER><TABLE BORDER=0 CELLPADDING=4 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>enum {    kMappedFileInformationVersion1 = 1    /* version 1 of                                          MappedFileInformation */};</pre></TD></TR></TABLE></CENTER><BR><BR>                             <P><A HREF="#doctop">Back to top</A></P><BR><BR><A NAME="MappedFileInformation"></A><P><B><CODE>MappedFileInformation</CODE></B></P><P>Receives the information supplied by <CODE><A HREF="#GetMappedFileInformation">GetMappedFileInformation</A></CODE>. The current version of this struct is <CODE>kMappedFileInformationVersion1</CODE>.</P><BR><BR><CENTER><TABLE BORDER=0 CELLPADDING=4 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>struct MappedFileInformation {    <A HREF="http://developer.apple.com/documentation/mac/Processes/Processes-34.html">ProcessSerialNumber</A> owningProcess; /* owning process */    <A HREF="http://developer.apple.com/documentation/Carbon/Files/FileManager/File_Manager/DataTypes/FSRef.html">FSRef</A> *ref; /* pointer to <A HREF="http://developer.apple.com/documentation/Carbon/Files/FileManager/File_Manager/DataTypes/FSRef.html">FSRef</A> or NULL */    <A HREF="http://developer.apple.com/documentation/Carbon/Files/FileManager/File_Manager/DataTypes/HFSUniStr255.html">HFSUniStr255</A> *forkName; /* pointer to <A HREF="http://developer.apple.com/documentation/Carbon/Files/FileManager/File_Manager/DataTypes/HFSUniStr255.html">HFSUniStr255</A> or NULL */    <A HREF="#MappingPrivileges">MappingPrivileges</A> privileges; /* mapping privileges */    UInt64 currentSize; /* size in bytes */    <A HREF="#MappedFileAttributes">MappedFileAttributes</A> attributes; /* attributes */};typedef struct MappedFileInformation MappedFileInformation;</pre></TD></TR></TABLE></CENTER><BR><BR>                    <UL><LI><B>owningProcess</B> - The <CODE><A HREF="http://developer.apple.com/documentation/mac/Processes/Processes-34.html">ProcessSerialNumber</A></CODE> of the process that owns this mapped file fork. <BR><BR></LI><LI><B>ref</B> - A pointer to a <CODE><A HREF="http://developer.apple.com/documentation/Carbon/Files/FileManager/File_Manager/DataTypes/FSRef.html">FSRef</A></CODE> where the <CODE><A HREF="http://developer.apple.com/documentation/Carbon/Files/FileManager/File_Manager/DataTypes/FSRef.html">FSRef</A></CODE> of the mapped file fork is returned, or <CODE>NULL</CODE> if the <CODE><A HREF="http://developer.apple.com/documentation/Carbon/Files/FileManager/File_Manager/DataTypes/FSRef.html">FSRef</A></CODE> is not needed.<BR><BR></LI><LI><B>forkName</B> - A pointer to a <CODE><A HREF="http://developer.apple.com/documentation/Carbon/Files/FileManager/File_Manager/DataTypes/HFSUniStr255.html">HFSUniStr255</A></CODE> where the fork name of the mapped file fork is returned, or <CODE>NULL</CODE> if the fork name is not needed.<BR><BR></LI><LI><B>privileges</B> - The <CODE><A HREF="#MappingPrivileges">MappingPrivileges</A></CODE> of the mapped file fork.<BR><BR></LI><LI><B>currentSize</B> - The size, in bytes, of the mapped file fork.<BR><BR></LI><LI><B>attributes</B> - The <CODE><A HREF="#MappedFileAttributes">MappedFileAttributes</A></CODE> of the mapped file fork.</LI></UL><CENTER><TABLE BORDER=0 CELLPADDING=4 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>IMPORTANT:</B><BR>An application must set both the <CODE>ref</CODE> and <CODE>forkName</CODE> fields of <CODE><A HREF="#MappedFileInformation">MappedFileInformation</A></CODE> structure before calling <CODE><A HREF="#GetMappedFileInformation">GetMappedFileInformation</A></CODE>.</P></TD></TR></TABLE></CENTER><BR><BR>                             <P><A HREF="#doctop">Back to top</A></P><BR><BR><A NAME="FileViewAccess"></A><P><B><CODE>FileViewAccess</CODE></B></P><P>Values of type <CODE>FileViewAccess</CODE> represent allowable access to the memory in a mapped file view.</P><BR><BR><CENTER><TABLE BORDER=0 CELLPADDING=4 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>typedef OptionBits FileViewAccess;enum {        /* defined bit numbers */    <A HREF="#kFileViewAccessReadBit">kFileViewAccessReadBit</A> = 0, /* Reads allowed */    <A HREF="#kFileViewAccessWriteBit">kFileViewAccessWriteBit</A> = 1, /* Writes allowed */    <A HREF="#kFileViewAccessExecuteBit">kFileViewAccessExecuteBit</A> = 2, /* Instruction execution                                   permitted */        /* masks */    <A HREF="#kFileViewAccessReadMask">kFileViewAccessReadMask</A> = /* Reads allowed */        1L &lt;&lt; <A HREF="#kFileViewAccessReadBit">kFileViewAccessReadBit</A>,    <A HREF="#kFileViewAccessWriteMask">kFileViewAccessWriteMask</A> = /* Writes allowed */        1L &lt;&lt; <A HREF="#kFileViewAccessWriteBit">kFileViewAccessWriteBit</A>,    <A HREF="#kFileViewAccessExecuteMask">kFileViewAccessExecuteMask</A> = /* Instruction execution permitted */        1L &lt;&lt; <A HREF="#kFileViewAccessExecuteBit">kFileViewAccessExecuteBit</A>,};enum {        /* special masks */    <A HREF="#kFileViewAccessExcluded">kFileViewAccessExcluded</A> = 0, /* All access is prohibited */    <A HREF="#kFileViewAccessReadOnly">kFileViewAccessReadOnly</A> =        <A HREF="#kFileViewAccessReadMask">kFileViewAccessReadMask</A>        | <A HREF="#kFileViewAccessExecuteMask">kFileViewAccessExecuteMask</A>,    <A HREF="#kFileViewAccessReadWrite">kFileViewAccessReadWrite</A> =        <A HREF="#kFileViewAccessReadMask">kFileViewAccessReadMask</A>        | <A HREF="#kFileViewAccessWriteMask">kFileViewAccessWriteMask</A>        | <A HREF="#kFileViewAccessExecuteMask">kFileViewAccessExecuteMask</A>};</pre></TD></TR></TABLE></CENTER><BR><BR><P>Only three bits of <CODE><A HREF="#FileViewAccess">FileViewAccess</A></CODE> have been defined for use at the current time.  All remaining bits are reserved by Apple for future use.  For convenience, most a number of masks have been provided that can be used in conjunction with the binary-or operator ( | ) to produce desired <CODE><A HREF="#FileViewAccess">FileViewAccess</A></CODE> value.  These masks aredefined as follows:</P>                     <UL><LI><A NAME="kFileViewAccessReadBit"></A><A NAME="kFileViewAccessReadMask"></A><B>kFileViewAccessReadMask</B> - Memory in mapped file view can be read from.<BR><BR></LI><LI><A NAME="kFileViewAccessWriteBit"></A><A NAME="kFileViewAccessWriteMask"></A><B>kFileViewAccessWriteMask</B> - Memory in mapped file view can be written to.<BR><BR></LI><LI><A NAME="kFileViewAccessExecuteBit"></A><A NAME="kFileViewAccessExecuteMask"></A><B>kFileViewAccessExecuteMask</B> - Instruction execution from mapped file view is permitted (currently unsupported).<BR><BR></LI><LI><A NAME="kFileViewAccessExcluded"></A><B>kFileViewAccessExcluded</B> - Absolutely no access is permitted.  If any access occurs, then an exception will be generated (currently unsupported).<BR><BR></LI><LI><A NAME="kFileViewAccessReadOnly"></A><B>kFileViewAccessReadOnly</B> - Only read operations are permitted.<BR><BR></LI><LI><A NAME="kFileViewAccessReadWrite"></A><B>kFileViewAccessReadWrite</B> - All types of access are permitted, including reading, writing, and instruction execution.<BR><BR></LI></UL><CENTER><TABLE BORDER=0 CELLPADDING=4 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>All memory maintained by the Mac OS 9.1 Virtual Memory Manager isexecutable. As discussed in the <A HREF="#implementationnotes">Implementation Notes for Mac OS 9.1</a> section, the only values defined for variables of type <CODE><A HREF="#FileViewAccess">FileViewAccess</A></CODE> are <CODE>kFileViewAccessReadOnly</CODE> or <CODE>kFileViewAccessReadWrite</CODE>. Any other <CODE><A HREF="#FileViewAccess">FileViewAccess</A></CODE> values used with the routines defined in this document will result in a <CODE>paramErr</CODE>.</P></TD></TR></TABLE></CENTER><BR><BR>                    <P><A HREF="#doctop">Back to top</A></P><BR><BR><A NAME="FileViewOptions"></A><P><B><CODE>FileViewOptions</CODE></B></P><P>Values of type <CODE>FileViewOptions</CODE> specify desired characteristics of the mapped file view being created. At this time, only <CODE>kNilOptions</CODE> is supported.</P><BR><BR><CENTER><TABLE BORDER=0 CELLPADDING=4 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>typedef OptionBits FileViewOptions;</pre></TD></TR></TABLE></CENTER><BR><BR><P>Possible values that are defined for <CODE>FileViewOptions</CODE> include:</P>         <UL><LI><A NAME="kNilOptions"></A><B>kNilOptions</B> - no options.<BR><BR></LI></UL><P><A HREF="#doctop">Back to top</A></P>              <BR><BR><A NAME="kMapEntireFork"></A><P><B><CODE>kMapEntireFork</CODE></B></P><P>Pass <CODE>kMapEntireFork</CODE> to <CODE><A HREF="#MapFileView">MapFileView</A></CODE> as the <CODE>backingLength</CODE> parameter to file map the entire contents of a file.</P><BR><BR><CENTER><TABLE BORDER=0 CELLPADDING=4 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>enum {    kMapEntireFork = (-1)};</pre></TD></TR></TABLE></CENTER><BR><BR>     <P><A HREF="#doctop">Back to top</A></P><BR><BR><A NAME="FileViewID"></A><P><B><CODE>FileViewID</CODE></B></P><P>A <CODE>FileViewID</CODE> is used to access a mapped file view.</P><BR><BR><CENTER><TABLE BORDER=0 CELLPADDING=4 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>typedef struct OpaqueFileViewID* FileViewID;</pre></TD></TR></TABLE></CENTER><BR><BR>                             <P><A HREF="#doctop">Back to top</A></P><BR><BR><A NAME="kFileViewInformationVersion1"></A><P><B><CODE>kFileViewInformationVersion1</CODE></B></P><P>The version number of the <CODE>FileViewInformation</CODE> struct.</P><BR><BR><CENTER><TABLE BORDER=0 CELLPADDING=4 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>enum {    kFileViewInformationVersion1 = 1        /* version 1 of <A HREF="#MappedFileInformation">MappedFileInformation</A> */};</pre></TD></TR></TABLE></CENTER><BR><BR>                             <P><A HREF="#doctop">Back to top</A></P><BR><BR><A NAME="FileViewInformation"></A><P><B><CODE>FileViewInformation</CODE></B></P><P>Receives the information supplied by <CODE><A HREF="#GetFileViewInformation">GetFileViewInformation</A></CODE>. The current version of this <CODE>struct</CODE> is <CODE>kFileViewInformationVersion1</CODE>.</P><BR><BR><CENTER><TABLE BORDER=0 CELLPADDING=4 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>struct FileViewInformation {    <A HREF="http://developer.apple.com/documentation/mac/Processes/Processes-34.html">ProcessSerialNumber</A> owningProcess; /* owning process */    LogicalAddress viewBase; /* starting address of mapped file view */    ByteCount viewLength; /* length of the mapped file view */    <A HREF="#BackingFileID">BackingFileID</A> backingFile; /* the mapped file fork */    UInt64 backingBase; /* offset into mapped file fork */    <A HREF="#FileViewAccess">FileViewAccess</A> access; /* the <A HREF="#FileViewAccess">FileViewAccess</A> */    ByteCount guardLength; /* size of the guard ranges */    <A HREF="#FileViewOptions">FileViewOptions</A> options; /* the <A HREF="#FileViewOptions">FileViewOptions</A> */};typedef struct FileViewInformation FileViewInformation;</pre></TD></TR></TABLE></CENTER><BR><BR>                    <UL><LI><B>owningProcess</B> - The <CODE><A HREF="http://developer.apple.com/documentation/mac/Processes/Processes-34.html">ProcessSerialNumber</A></CODE> of the process that owns this mapped file view.<BR><BR></LI><LI><B>viewBase</B> - The starting address of mapped file view.<BR><BR></LI><LI><B>viewLength</B> - The length of the mapped file view.<BR><BR></LI><LI><B>backingFile</B> - The <CODE><A HREF="#BackingFileID">BackingFileID</A></CODE> of the mapped file fork.<BR><BR></LI><LI><B>backingBase</B> - The offset into mapped file fork.<BR><BR></LI><LI><B>access</B> - The <CODE><A HREF="#FileViewAccess">FileViewAccess</A></CODE>.<BR><BR></LI><LI><B>guardLength</B> - The size of the guard ranges.<BR><BR></LI><LI><B>options</B> - The <CODE><A HREF="#FileViewOptions">FileViewOptions</A></CODE>.<BR><BR></LI></UL>         <P><A HREF="#doctop">Back to top</A></P><BR><BR><A NAME="OpenMappedFile"></A><P><B><CODE>OpenMappedFile</CODE></B></P><P>Opens a file fork with the privileges requested for use as backing storage.</P><BR><BR><CENTER><TABLE BORDER=0 CELLPADDING=4 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>OSErr OpenMappedFile(    const <A HREF="http://developer.apple.com/documentation/Carbon/Files/FileManager/File_Manager/DataTypes/FSRef.html">FSRef</A> *ref,    UniCharCount forkNameLength,    const UniChar *forkName, /* can be NULL */    <A HREF="#MappingPrivileges">MappingPrivileges</A> privileges,    <A HREF="#BackingFileID">BackingFileID</A> *backingFile);</pre></TD></TR></TABLE></CENTER><BR><BR>                    <UL><LI><B>ref</B> - The file to map.<BR><BR></LI><LI><B>forkNameLength</B> - The fork name length in Unicode characters.<BR><BR></LI><LI><B>forkName</B> - The fork name in Unicode (<CODE>NULL</CODE> = data fork).<BR><BR></LI><LI><B>privileges</B> - The requested <CODE><A HREF="#MappingPrivileges">MappingPrivileges</A></CODE>.<BR><BR></LI><LI><B>backingFile</B> - Receives a <CODE><A HREF="#BackingFileID">BackingFileID</A></CODE> which you can use to access the mapped file fork.<BR><BR></LI><LI>result - An operating system result code: <CODE>noErr</CODE>, <CODE>paramErr</CODE>, <CODE>vmMappingPrivilegesErr</CODE>, or various File Manager and Memory Manager errors.<BR><BR></LI></UL><P>The <CODE><A HREF="#OpenMappedFile">OpenMappedFile</A></CODE> function opens the fork specified by the <CODE>forkNameLength</CODE> and <CODE>forkName</CODE> parameters of the file specified by the ref parameter and returns a <CODE><A HREF="#BackingFileID">BackingFileID</A></CODE> in the <CODE>backingFile</CODE> parameter. You can pass the <CODE><A HREF="#BackingFileID">BackingFileID</A></CODE> to other routines which accept a <CODE><A HREF="#BackingFileID">BackingFileID</A></CODE> as an input parameter.</P><BR><BR><CENTER><TABLE BORDER=0 CELLPADDING=4 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>Additional information about the Mac OS 9.1 implementation of <CODE><A HREF="#OpenMappedFile">OpenMappedFile</A></CODE> can be found in <A HREF="#implementationnotes">Implementation Notes for Mac OS 9.1</a> section at the end of this document.</P></TD></TR></TABLE></CENTER><BR><BR><P>The privileges parameter specifies what operations you want to perform on the mapped file fork. Programs can request either <CODE><A HREF="#kCanReadMappedFile">kCanReadMappedFile</A></CODE> privileges, or both <CODE><A HREF="#kCanReadMappedFile">kCanReadMappedFile</A></CODE> and <CODE><A HREF="#kCanWriteMappedFile">kCanWriteMappedFile</A></CODE> privileges. To disable Process Manager tracking of the mapped file fork and its mapped file views, you may also request <CODE><A HREF="#kNoProcessMappedFile">kNoProcessMappedFile</A></CODE> privileges.</P>         <P><A HREF="#doctop">Back to top</A></P><BR><BR><A NAME="FSpOpenMappedFile"></A><P><B><CODE>FSpOpenMappedFile</CODE></B></P><P>Opens a file fork with the privileges requested for use as backing storage.</P><BR><BR><CENTER><TABLE BORDER=0 CELLPADDING=4 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>OSErr FSpOpenMappedFile(    const <A HREF="http://developer.apple.com/documentation/Carbon/Files/FileManager/File_Manager/DataTypes/FSSpec.html">FSSpec</A> *spec,    Boolean mapResFork,    <A HREF="#MappingPrivileges">MappingPrivileges</A> privileges,    <A HREF="#BackingFileID">BackingFileID</A> *backingFile);</pre></TD></TR></TABLE></CENTER><BR><BR>                    <UL><LI><B>spec</B> - The file to map.<BR><BR></LI><LI><B>mapResFork</B> - Fork to map: false = data fork; true = resource fork.<BR><BR></LI><LI><B>privileges</B> - The requested <CODE><A HREF="#MappingPrivileges">MappingPrivileges</A></CODE>.<BR><BR></LI><LI><B>backingFile</B> - Receives a <CODE><A HREF="#BackingFileID">BackingFileID</A></CODE> which you can use to access the mapped file fork.<BR><BR></LI><LI>result - An operating system result code: <CODE>noErr</CODE>, <CODE>paramErr</CODE>, <CODE>vmMappingPrivilegesErr</CODE>, or various File Manager and Memory Manager errors.<BR><BR></LI></UL><P>The <CODE><A HREF="#FSpOpenMappedFile">FSpOpenMappedFile</A></CODE> function opens the fork specified by the <CODE>mapResFork</CODE> parameter of the file specified by the <CODE>spec</CODE> parameter and returns a <CODE><A HREF="#BackingFileID">BackingFileID</A></CODE> in the <CODE>backingFile</CODE> parameter. You can pass the <CODE><A HREF="#BackingFileID">BackingFileID</A></CODE> to other routines which accept a <CODE><A HREF="#BackingFileID">BackingFileID</A></CODE> as an input parameter.</P><BR><BR><CENTER><TABLE BORDER=0 CELLPADDING=4 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>Additional information about the Mac OS 9.1 implementation of <CODE><A HREF="#FSpOpenMappedFile">FSpOpenMappedFile</A></CODE> can be found in <A HREF="#implementationnotes">Implementation Notes for Mac OS 9.1</a> section at the end of this document.</P></TD></TR></TABLE></CENTER><BR><BR><P>The <CODE>privileges</CODE> parameter specifies what operations you want to perform on the mapped file fork. Programs can request either <CODE><A HREF="#kCanReadMappedFile">kCanReadMappedFile</A></CODE> privileges, or both <CODE><A HREF="#kCanReadMappedFile">kCanReadMappedFile</A></CODE> and <CODE><A HREF="#kCanWriteMappedFile">kCanWriteMappedFile</A></CODE> privileges. To disable Process Manager tracking of the mapped file fork and its mapped file views, you may also request <CODE><A HREF="#kNoProcessMappedFile">kNoProcessMappedFile</A></CODE> privileges.</P>         <P><A HREF="#doctop">Back to top</A></P><BR><BR><A NAME="OpenMappedScratchFile"></A><P><B><CODE>OpenMappedScratchFile</CODE></B></P><P>Creates and opens a scratch file with the privileges requested for use as backing storage.</P><BR><BR><CENTER><TABLE BORDER=0 CELLPADDING=4 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>OSErr OpenMappedScratchFile(    FSVolumeRefNum volume,    ByteCount fileSize,    <A HREF="#MappingPrivileges">MappingPrivileges</A> privileges,    <A HREF="#BackingFileID">BackingFileID</A> *backingFile);</pre></TD></TR></TABLE></CENTER><BR><BR>                    <UL><LI><B>volume</B> - The volume where scratch file should be created or <CODE>kFSInvalidVolumeRefNum</CODE> to let the system choose the volume.<BR><BR></LI><LI><B>fileSize</B> - The size of the scratch file.<BR><BR></LI><LI><B>privileges</B> - The requested <CODE><A HREF="#MappingPrivileges">MappingPrivileges</A></CODE>.<BR><BR></LI><LI><B>backingFile</B> - Receives a <CODE><A HREF="#BackingFileID">BackingFileID</A></CODE> which you can use to access the mapped file fork.<BR><BR></LI><LI>result - An operating system result code: <CODE>noErr</CODE>, <CODE>paramErr</CODE>, <CODE>vmMappingPrivilegesErr</CODE>, or various File Manager and Memory Manager errors.<BR><BR></LI></UL><P>The <CODE><A HREF="#OpenMappedScratchFile">OpenMappedScratchFile</A></CODE> function creates a file with the size specified by the <CODE>fileSize</CODE> parameter on the volume specified by the volume parameter. If <CODE>kFSInvalidVolumeRefNum</CODE> is passed as the volume parameter, the system code will choose the location of the file. <CODE><A HREF="#OpenMappedScratchFile">OpenMappedScratchFile</A></CODE> then opens the file and returns a <CODE><A HREF="#BackingFileID">BackingFileID</A></CODE> in the backingFile parameter. You can pass the <CODE><A HREF="#BackingFileID">BackingFileID</A></CODE> to other routines which accept a <CODE><A HREF="#BackingFileID">BackingFileID</A></CODE> as an input parameter.</P><P>The privileges parameter specifies what operations you want to perform on the mapped file fork. Programs can request either <CODE><A HREF="#kCanReadMappedFile">kCanReadMappedFile</A></CODE> privileges, or both <CODE><A HREF="#kCanReadMappedFile">kCanReadMappedFile</A></CODE> and <CODE><A HREF="#kCanWriteMappedFile">kCanWriteMappedFile</A></CODE> privileges. To disable Process Manager tracking of the mapped file fork and its mapped file views, you may also request <CODE><A HREF="#kNoProcessMappedFile">kNoProcessMappedFile</A></CODE> privileges.</P><BR><BR><CENTER><TABLE BORDER=0 CELLPADDING=4 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>The contents of the backing file created by <CODE><A HREF="#OpenMappedScratchFile">OpenMappedScratchFile</A></CODE> is undefined and are not initialized for your application.  </P></TD></TR></TABLE></CENTER><BR><BR><P>The data for a scratch file is only valid in an open mapped file view. When a mapped file view is first created for a scratch file with <CODE><A HREF="#MapFileView">MapFileView</A></CODE>, data on disk is not paged into memory. When that mapped file view is unmapped with <CODE><A HREF="#UnmapFileView">UnmapFileView</A></CODE>, changes are not flushed from memory to disk.</P>         <P><A HREF="#doctop">Back to top</A></P><BR><BR><A NAME="CloseMappedFile"></A><P><B><CODE>CloseMappedFile</CODE></B></P><P>Closes a mapped file fork.</P><BR><BR><CENTER><TABLE BORDER=0 CELLPADDING=4 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>OSErr CloseMappedFile(<A HREF="#BackingFileID">BackingFileID</A> backingFile);</pre></TD></TR></TABLE></CENTER><BR><BR>                    <UL><LI><B>backingFile</B> - The mapped file fork to close.<BR><BR></LI><LI>result - An operating system result code: <CODE>noErr</CODE>, <CODE>vmInvalidBackingFileIDErr</CODE>, <CODE>vmInvalidOwningProcessErr</CODE>, <CODE>vmBusyBackingFileErr</CODE>, or various File Manager errors.<BR><BR></LI></UL><P>The <CODE>CloseMappedFile</CODE> function closes the mapped file fork specified by the <CODE>backingFile</CODE> parameter.</P><P>All mapped file views using the <CODE><A HREF="#BackingFileID">BackingFileID</A></CODE> must be closed before closing the mapped file fork. If the <CODE><A HREF="#BackingFileID">BackingFileID</A></CODE> is for a scratch file created with <CODE><A HREF="#OpenMappedScratchFile">OpenMappedScratchFile</A></CODE>, the scratch file is deleted by <CODE><A HREF="#CloseMappedFile">CloseMappedFile</A></CODE> after it is closed. </P>         <P><A HREF="#doctop">Back to top</A></P><BR><BR><A NAME="GetMappedFileInformation"></A><P><B><CODE>GetMappedFileInformation</CODE></B></P><P>Returns information about a mapped file fork.</P><BR><BR><CENTER><TABLE BORDER=0 CELLPADDING=4 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>OSErr GetMappedFileInformation(    <A HREF="#BackingFileID">BackingFileID</A> backingFile,    <A HREF="http://developer.apple.com/documentation/quicktime/qtdevdocs/APIREF/SOURCESIV/systemandtoolboxtypes.htm">PBVersion</A> version,    <A HREF="#MappedFileInformation">MappedFileInformation</A> *mappedFileInfo);</pre></TD></TR></TABLE></CENTER><BR><BR>                    <UL><LI><B>backingFile</B> - The mapped file fork.<BR><BR></LI><LI><B>version</B> - The version of the <CODE><A HREF="#MappedFileInformation">MappedFileInformation</A></CODE> struct passed.<BR><BR></LI><LI><B>mappedFileInfo</B> - A pointer to the <CODE><A HREF="#MappedFileInformation">MappedFileInformation</A></CODE> struct where the information about a mapped file fork is returned.<BR><BR></LI><LI>result - An operating system result code: <CODE>noErr</CODE>, <CODE>paramErr</CODE>, <CODE>vmInvalidBackingFileIDErr</CODE>, or various File Manager errors.</LI></UL><CENTER><TABLE BORDER=0 CELLPADDING=4 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>IMPORTANT:</B><BR>An application must set both the <CODE>ref</CODE> and <CODE>forkName</CODE> fields of <CODE><A HREF="#MappedFileInformation">MappedFileInformation</A></CODE> structure before calling <CODE><A HREF="#GetMappedFileInformation">GetMappedFileInformation</A></CODE>.</P></TD></TR></TABLE></CENTER><BR><BR><P>The <CODE><A HREF="#GetMappedFileInformation">GetMappedFileInformation</A></CODE> function returns information about the mapped file fork specified by the <CODE>backingFile</CODE> parameter. The struct version of the <CODE>mappedFileInfo</CODE> parameter is passed in the version parameter. The mapped file fork information is returned in the <CODE>mappedFileInfo</CODE> parameter.</P>         <P><A HREF="#doctop">Back to top</A></P><BR><BR><A NAME="GetNextMappedFile"></A><P><B><CODE>GetNextMappedFile</CODE></B></P><P>Gets a list of mapped file forks.</P><BR><BR><CENTER><TABLE BORDER=0 CELLPADDING=4 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>OSErr GetNextMappedFile(<A HREF="#BackingFileID">BackingFileID</A> *backingFile);</pre></TD></TR></TABLE></CENTER><BR><BR>                    <UL><LI><B>backingFile</B> - <BR>Input: The last <CODE><A HREF="#BackingFileID">BackingFileID</A></CODE> returned by <CODE>GetNextMappedFile</CODE>, or <CODE>kInvalidID</CODE> to get the first mapped file fork.<BR>Output: If <CODE>noErr</CODE>, receives the <CODE><A HREF="#BackingFileID">BackingFileID</A></CODE> of the next mapped file fork.<BR><BR></LI><LI>result - An operating system result code: <CODE>noErr</CODE>, <CODE>vmInvalidBackingFileIDErr</CODE>, or <CODE>vmNoMoreBackingFilesErr</CODE>.<BR><BR></LI></UL><P>The <CODE>GetNextMappedFile</CODE> function returns the <CODE><A HREF="#BackingFileID">BackingFileID</A></CODE> of the mapped file fork next in the list of mapped file forks. You can enumerate through the list of mapped file forks by passing <CODE>kInvalidID</CODE> as the <CODE>backingFile</CODE> parameter and then repetitively calling <CODE><A HREF="#GetNextMappedFile">GetNextMappedFile</A></CODE> with the last <CODE><A HREF="#BackingFileID">BackingFileID</A></CODE> returned until the result code <CODE>vmNoMoreBackingFilesErr</CODE> is returned.</P>         <P><A HREF="#doctop">Back to top</A></P><BR><BR><A NAME="SetMappedFileSize"></A><P><B><CODE>SetMappedFileSize</CODE></B></P><P>Changes the size (logical end-of-file) of a mapped file fork.</P><BR><BR><CENTER><TABLE BORDER=0 CELLPADDING=4 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>OSErr SetMappedFileSize(    <A HREF="#BackingFileID">BackingFileID</A> backingFile,    UInt16 positionMode,    const SInt64 *positionOffset);</pre></TD></TR></TABLE></CENTER><BR><BR>                    <UL><LI><B>backingFile</B> - The mapped file fork to change the size of.<BR><BR></LI><LI><B>positionMode</B> - The base location for the new size: <CODE>fsFromStart</CODE>, or <CODE>fsFromLEOF</CODE>.<BR><BR></LI><LI><B>positionOffset</B> - Pointer to a <CODE>SInt64</CODE> which contains the offset of the size from the base.<BR><BR></LI><LI>result - An operating system result code: <CODE>noErr</CODE>, <CODE>paramErr</CODE>, or various File Manager errors.<BR><BR></LI></UL><P>The <CODE><A HREF="#SetMappedFileSize">SetMappedFileSize</A></CODE> function sets the logical end-of-file of the mapped file fork specified by <CODE>backingFile</CODE>. The new logical end-of-file is specified by the <CODE>positionMode</CODE> and <CODE>positionOffset</CODE> parameters.</P><BR><BR><CENTER><TABLE BORDER=0 CELLPADDING=4 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>Additional information about the Mac OS 9.1 implementation of <CODE><A HREF="#SetMappedFileSize">SetMappedFileSize</A></CODE> can be found in <A HREF="#implementationnotes">Implementation Notes for Mac OS 9.1</a> section at the end of this document.</P></TD></TR></TABLE></CENTER><BR><BR>                             <P><A HREF="#doctop">Back to top</A></P><BR><BR><A NAME="GetFileViewAccessOptions"></A><P><B><CODE>GetFileViewAccessOptions</CODE></B></P><P>Returns the valid <CODE><A HREF="#FileViewAccess">FileViewAccess</A></CODE> and <CODE><A HREF="#FileViewOptions">FileViewOptions</A></CODE> bits.</P><BR><BR><CENTER><TABLE BORDER=0 CELLPADDING=4 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>OSErr GetFileViewAccessOptions(    <A HREF="#FileViewAccess">FileViewAccess</A> *access,    <A HREF="#FileViewOptions">FileViewOptions</A> *options);</pre></TD></TR></TABLE></CENTER><BR><BR>                    <UL><LI><B>access</B> - Receives the valid memory access flags.<BR><BR></LI><LI><B>options</B> - Receives the valid view options.<BR><BR></LI><LI>result - An operating system result code: <CODE>noErr</CODE>, or <CODE>paramErr</CODE>.<BR><BR></LI></UL><P>The <CODE>GetFileViewAccessOptions</CODE> function returns the valid <CODE><A HREF="#FileViewAccess">FileViewAccess</A></CODE> and <CODE><A HREF="#FileViewOptions">FileViewOptions</A></CODE> bits. Programs can use it to determine what <CODE><A HREF="#FileViewAccess">FileViewAccess</A></CODE> and <CODE><A HREF="#FileViewOptions">FileViewOptions</A></CODE> are available.</P>         <P><A HREF="#doctop">Back to top</A></P><BR><BR><A NAME="MapFileView"></A><P><B><CODE>MapFileView</CODE></B></P><P>Creates a mapped file view into a mapped file fork.</P><BR><BR><CENTER><TABLE BORDER=0 CELLPADDING=4 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>OSErr MapFileView(    <A HREF="#BackingFileID">BackingFileID</A> backingFile,    const UInt64 *backingBase, /* can be NULL */    ByteCount backingLength,    <A HREF="#FileViewAccess">FileViewAccess</A> access,    ByteCount guardLength,    <A HREF="#FileViewOptions">FileViewOptions</A> options,    LogicalAddress *viewBase,    ByteCount *viewLength,    <A HREF="#FileViewID">FileViewID</A> *theView);</pre></TD></TR></TABLE></CENTER><BR><BR>                    <UL><LI><B>backingFile</B> - The mapped file fork to create a mapped file view from.<BR><BR></LI><LI><B>backingBase</B> - Pointer to the offset into mapped file fork. Passing a <CODE>NULL</CODE> pointer is the same as passing an offset of zero.<BR><BR></LI><LI><B>backingLength</B> - The number of bytes to map, or <CODE><A HREF="#kMapEntireFork">kMapEntireFork</A></CODE> to map from <CODE>backingBase</CODE> to the mapped file fork's logical end-of-file.  The backingBase parameter must be a whole multiple of the logical page size (as determined using the<CODE>gestaltLogicalPageSize</CODE> <CODE><A HREF="http://developer.apple.com/documentation/mac/OSUtilities/OSUtilities-11.html">Gestalt</A></CODE> selector).<BR><BR></LI><LI><B>access</B> - The <CODE><A HREF="#FileViewAccess">FileViewAccess</A></CODE>.<BR><BR></LI><LI><B>guardLength</B> - The size, in bytes, of the excluded logical address ranges to place adjacent to each end of the mapped file view.<BR><BR></LI><LI><B>options</B> - The desired characteristics of the mapped file view.<BR><BR></LI><LI><B>viewBase</B> - <BR>Input: The requested viewBase.<BR>Output: Receives the starting address of mapped file view.<BR><BR></LI><LI><B>viewLength</B> - Receives the mapped file view length.<BR><BR></LI><LI><B>theView</B> - Receives a <CODE><A HREF="#FileViewID">FileViewID</A></CODE> which you can use to access the mapped file view.<BR><BR></LI><LI>result - An operating system result code: <CODE>noErr</CODE>, <CODE>paramErr</CODE>, <CODE>vmInvalidBackingFileIDErr</CODE>, <CODE>vmInvalidOwningProcessErr</CODE>, <CODE>vmFileViewAccessErr</CODE>, or various File Manager and Memory Manager errors.<BR><BR></LI></UL><P>The <CODE><A HREF="#MapFileView">MapFileView</A></CODE> function creates a mapped file view into the mapped file fork specified by the <CODE>backingFile</CODE> parameter. <CODE><A HREF="#MapFileView">MapFileView</A></CODE> returns a <CODE><A HREF="#FileViewID">FileViewID</A></CODE> in the <CODE>theView</CODE> parameter. You can pass the <CODE><A HREF="#FileViewID">FileViewID</A></CODE> to other routines which accept a <CODE><A HREF="#FileViewID">FileViewID</A></CODE> as an input parameter.</P><BR><BR><CENTER><TABLE BORDER=0 CELLPADDING=4 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>Additional information about the Mac OS 9.1 implementation of <CODE><A HREF="#MapFileView">MapFileView</A></CODE> can be found in <A HREF="#implementationnotes">Implementation Notes for Mac OS 9.1</a> section at the end of this document.</P></TD></TR></TABLE></CENTER><BR><BR><P>The <CODE>backingBase</CODE> and <CODE>backingLength</CODE> parameters specify what part of the mapped file fork will be mapped to memory. The access parameter specifies the allowable access to the memory in a mapped file view. The <CODE>guardLength</CODE> parameter specifies the size, in bytes, of the excluded logical address ranges to place adjacent to each end of the mapped file view. The options parameter specifies the desired characteristics of the mapped file view. The <CODE>viewBase</CODE> parameter, as an optional input, specifies the requested <CODE>viewBase</CODE>.</P><P>The <CODE>backingBase</CODE> parameter must be a whole multiple of the logical page size. If <CODE><A HREF="#kMapEntireFork">kMapEntireFork</A></CODE> is passed as <CODE>backingLength</CODE>, accesses past the mapped file fork's logical end-of-file will not cause exceptions, but will have undefined behavior. Only accesses up to <CODE>viewLength</CODE> should be considered valid.</P><P>The starting address of the mapped file view is returned in the <CODE>viewBase</CODE> parameter. The length of the mapped file view is returned in the <CODE>viewLength</CODE> parameter.</P>         <P><A HREF="#doctop">Back to top</A></P><BR><BR><A NAME="UnmapFileView"></A><P><B><CODE>UnmapFileView</CODE></B></P><P>Un-maps a mapped file view.</P><BR><BR><CENTER><TABLE BORDER=0 CELLPADDING=4 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>OSErr UnmapFileView(<A HREF="#FileViewID">FileViewID</A> theView);</pre></TD></TR></TABLE></CENTER><BR><BR>                    <UL><LI><B>theView</B> - The mapped file view to un-map.<BR><BR></LI><LI><B>result</B> - An operating system result code: <CODE>noErr</CODE>, <CODE>vmInvalidFileViewIDErr</CODE>, <CODE>vmInvalidOwningProcessErr</CODE>, or various File Manager and Memory Manager errors.<BR><BR></LI></UL><P>The <CODE>UnmapFileView</CODE> function un-maps a mapped file view specified by the <CODE>theView</CODE> parameter from memory.</P><P>All modified memory is flushed to the mapped file fork before the mapped file view is unmapped unless the mapped file view is to a scratch file.</P>         <P><A HREF="#doctop">Back to top</A></P><BR><BR><A NAME="GetFileViewInformation"></A><P><B><CODE>GetFileViewInformation</CODE></B></P><P>Returns information about a mapped file view.</P><BR><BR><CENTER><TABLE BORDER=0 CELLPADDING=4 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>OSErr GetFileViewInformation(    <A HREF="#FileViewID">FileViewID</A> theView,    <A HREF="http://developer.apple.com/documentation/quicktime/qtdevdocs/APIREF/SOURCESIV/systemandtoolboxtypes.htm">PBVersion</A> version,    <A HREF="#FileViewInformation">FileViewInformation</A> *fileViewInfo);</pre></TD></TR></TABLE></CENTER><BR><BR>                    <UL><LI><B>theView</B> - The mapped file view.<BR><BR></LI><LI><B>version</B> - The version of the <CODE><A HREF="#FileViewInformation">FileViewInformation</A></CODE> <CODE>struct</CODE> passed.<BR><BR></LI><LI><B>fileViewInfo</B> - A pointer to the <CODE><A HREF="#FileViewInformation">FileViewInformation</A></CODE> <CODE>struct</CODE> where the information about a mapped file view is returned.<BR><BR></LI><LI>result - An operating system result code: <CODE>noErr</CODE>, <CODE>paramErr</CODE>, or <CODE>vmInvalidFileViewIDErr</CODE>.<BR><BR></LI></UL><P>The <CODE><A HREF="#GetFileViewInformation">GetFileViewInformation</A></CODE> function returns information about the mapped file view specified by the <CODE>theView</CODE> parameter. The struct version of the <CODE>fileViewInfo</CODE> parameter is passed in the <CODE>version</CODE> parameter. The mapped file view information is returned in the <CODE>fileViewInfo</CODE> parameter.</P>         <P><A HREF="#doctop">Back to top</A></P><BR><BR><A NAME="GetFileViewFromAddress"></A><P><B><CODE>GetFileViewFromAddress</CODE></B></P><P>Returns the <CODE><A HREF="#FileViewID">FileViewID</A></CODE> for a given address.</P><BR><BR><CENTER><TABLE BORDER=0 CELLPADDING=4 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>OSErr GetFileViewFromAddress(    LogicalAddress address,    <A HREF="#FileViewID">FileViewID</A> *theView);</pre></TD></TR></TABLE></CENTER><BR><BR>                    <UL><LI><B>address</B> - The memory address.<BR><BR></LI><LI><B>theView</B> - Receives a <CODE><A HREF="#FileViewID">FileViewID</A></CODE> for the given memory address.<BR><BR></LI><LI>result - An operating system result code: <CODE>noErr</CODE>, <CODE>paramErr</CODE>, or <CODE>vmAddressNotInFileViewErr</CODE>.<BR><BR></LI></UL><P>The <CODE>GetFileViewFromAddress</CODE> function returns the <CODE><A HREF="#FileViewID">FileViewID</A></CODE> for address specified in the address parameter.</P>         <P><A HREF="#doctop">Back to top</A></P><BR><BR><A NAME="GetNextView"></A><P><B><CODE>GetNextView</CODE></B></P><P>Gets a list of mapped file views.</P><BR><BR><CENTER><TABLE BORDER=0 CELLPADDING=4 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>OSErr GetNextFileView(<A HREF="#FileViewID">FileViewID</A> *theView);</pre></TD></TR></TABLE></CENTER><BR><BR>                    <UL><LI><B>theView</B> - <BR>Input: The last <CODE><A HREF="#FileViewID">FileViewID</A></CODE> returned by <CODE>GetNextView</CODE>, or <CODE>kInvalidID</CODE> to get the first mapped file view.<BR>Output: If <CODE>noErr</CODE>, receives the <CODE><A HREF="#FileViewID">FileViewID</A></CODE> of the next mapped file view.<BR><BR></LI><LI>result - An operating system result code: <CODE>noErr</CODE>, <CODE>paramErr</CODE>, <CODE>vmInvalidFileViewIDErr</CODE>, or vmNoMoreFileViewsErr.<BR><BR></LI></UL><P>The <CODE>GetNextView</CODE> function returns the <CODE><A HREF="#FileViewID">FileViewID</A></CODE> of the mapped file view next in the list of mapped file views. You can enumerate through the list of mapped file views by passing <CODE>kInvalidID</CODE> as the <CODE>theView</CODE> parameter and then repetitively calling <CODE><A HREF="#GetNextView">GetNextView</A></CODE> with the last <CODE><A HREF="#FileViewID">FileViewID</A></CODE> returned until the result code <CODE>vmNoMoreFileViewsErr</CODE> is returned.</P>         <P><A HREF="#doctop">Back to top</A></P><BR><BR><A NAME="SetFileViewAccess"></A><P><B><CODE>SetFileViewAccess</CODE></B></P><P>Changes a mapped file view's <CODE><A HREF="#FileViewAccess">FileViewAccess</A></CODE>.</P><BR><BR><CENTER><TABLE BORDER=0 CELLPADDING=4 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>OSErr SetFileViewAccess(    <A HREF="#FileViewID">FileViewID</A> theView,    <A HREF="#FileViewAccess">FileViewAccess</A> access);</pre></TD></TR></TABLE></CENTER><BR><BR>                    <UL><LI><B>theView</B> - The mapped file view.<BR><BR></LI><LI><B>accessLevel</B> - The new <CODE><A HREF="#FileViewAccess">FileViewAccess</A></CODE>.<BR><BR></LI><LI>result - An operating system result code: <CODE>noErr</CODE>, <CODE>paramErr</CODE>, <CODE>vmInvalidFileViewIDErr</CODE>, or <CODE>vmFileViewAccessErr</CODE>.<BR><BR></LI></UL><P>The <CODE>SetFileViewAccess</CODE> function changes the <CODE><A HREF="#FileViewAccess">FileViewAccess</A></CODE> of the mapped file view specified by the <CODE>theView</CODE> parameter. The new <CODE><A HREF="#FileViewAccess">FileViewAccess</A></CODE> is specified by the <CODE>accessLevel</CODE> parameter.</P><BR><BR><CENTER><TABLE BORDER=0 CELLPADDING=4 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>Additional information about the Mac OS 9.1 implementation of <CODE><A HREF="#SetFileViewAccess">SetFileViewAccess</A></CODE> can be found in <A HREF="#implementationnotes">Implementation Notes for Mac OS 9.1</a> section at the end of this document.</P></TD></TR></TABLE></CENTER><BR><BR>         <P><A HREF="#doctop">Back to top</A></P><BR><BR><A NAME="SetFileViewBackingBase"></A><P><B><CODE>SetFileViewBackingBase</CODE></B></P><P>Changes the backing base of a mapped file view.</P><BR><BR><CENTER><TABLE BORDER=0 CELLPADDING=4 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>OSErr SetFileViewBackingBase(    <A HREF="#FileViewID">FileViewID</A> theView,    const UInt64 *newBackingBase); /* can be NULL */</pre></TD></TR></TABLE></CENTER><BR><BR>                    <UL><LI><B>theView</B> - The mapped file view.<BR><BR></LI><LI><B>newBackingBase</B> - Pointer to the offset into mapped file fork. Passing a <CODE>NULL</CODE> pointer is the same as passing an offset of zero.<BR><BR></LI><LI>result - An operating system result code: <CODE>noErr</CODE>, <CODE>vmInvalidFileViewIDErr</CODE>, or <CODE>paramErr</CODE>.<BR><BR></LI></UL><P>The <CODE>SetFileViewBackingBase</CODE> function changes the backing base of the mapped file view specified by <CODE>theView</CODE>. The new backing base is specified by the <CODE>newBackingBase</CODE> parameter.</P><BR><BR><CENTER><TABLE BORDER=0 CELLPADDING=4 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>Additional information about the Mac OS 9.1 implementation of <CODE><A HREF="#SetFileViewBackingBase">SetFileViewBackingBase</A></CODE> can be found in <A HREF="#implementationnotes">Implementation Notes for Mac OS 9.1</a> section at the end of this document.</P></TD></TR></TABLE></CENTER><BR><BR>         <P><A HREF="#doctop">Back to top</A></P><BR><BR><A NAME="implementationnotes" title="Implementation Notes for Mac OS 9.1"></A><H2>Implementation Notes for Mac OS 9.1</H2><P>Mac OS 9.1 is the first implementation of the File Mapping APIs, and as such there are some limitations in the values that may be provided as parameters to some of its routines.  This section outlines these limitations.</P><H3>Address Space Limitations</H3><P>The Mac OS 9.1 Virtual Memory Manager provides a single address space of1023 megabytes. Part of that address space is used for main memory andpageable system data. The remainder of that address space is available forfile mapping (both CFM file mappings and mapped file views created with<A HREF="#MapFileView">MapFileView</A>). Thus, the size and number of mapped file views is limited.</P><H3><CODE><A HREF="#OpenMappedFile">OpenMappedFile</A></CODE></H3><UL><LI>Only the data fork can be opened for use as backing storage. <CODE>paramErr</CODE> is returned if you try to map a fork other than the data fork.<BR><BR></LI><LI>The backing storage file is opened, but <CODE><A HREF="#OpenMappedFile">OpenMappedFile</A></CODE> does not obtain exclusive access to that file. Instead, <CODE><A HREF="#MapFileView">MapFileView</A></CODE> obtains exclusive access to the backing storage file when the file is mapped to memory.<BR><BR></LI></UL><H3><CODE><A HREF="#FSpOpenMappedFile">FSpOpenMappedFile</A></CODE></H3><UL><LI>Only the data fork can be opened for use as backing storage. <CODE>paramErr</CODE> is returned if you try to map a fork other than the data fork.<BR><BR></LI><LI>The backing storage file is opened, but <CODE><A HREF="#FSpOpenMappedFile">FSpOpenMappedFile</A></CODE> does not obtain exclusive access to that file. Instead, <CODE><A HREF="#MapFileView">MapFileView</A></CODE> obtains exclusive access to the backing storage file when the file is mapped to memory.<BR><BR></LI></UL><H3><CODE><A HREF="#SetMappedFileSize">SetMappedFileSize</A></CODE></H3><UL><LI><CODE><A HREF="#SetMappedFileSize">SetMappedFileSize</A></CODE> is not implemented and always returns <CODE>paramErr</CODE>.<BR><BR></LI></UL><H3><CODE><A HREF="#MapFileView">MapFileView</A></CODE></H3><UL><LI>The entire file fork must be mapped (creating a mapped file view smaller than the entire file is not implemented). Thus: <BR><BR><UL><LI>The <CODE>backingBase</CODE> parameter must be 0. <CODE>paramErr</CODE> is returned if <CODE>backingBase</CODE> is not 0.<BR><BR></LI><LI>The <CODE>backingLength</CODE> parameter must be <CODE><A HREF="#kMapEntireFork">kMapEntireFork</A></CODE>. <CODE>paramErr</CODE> is returned if <CODE>backingLength</CODE> is not <CODE><A HREF="#kMapEntireFork">kMapEntireFork</A></CODE>.<BR><BR></LI><LI>The <CODE>guardLength</CODE> parameter is ignored in the 9.1 implementation.<BR><BR></LI><LI>The <CODE>viewBase</CODE> parameter is only used as an output variable in the 9.1 implementation - any value provided in the variable pointed to by this parameter when <CODE><A HREF="#MapFileView">MapFileView</A></CODE> will be ignored.<BR><BR></LI></UL></LI><LI>The <CODE><A HREF="#FileViewAccess">FileViewAccess</A></CODE> parameter must be either <CODE><A HREF="#kFileViewAccessReadOnly">kFileViewAccessReadOnly</A></CODE> or <CODE><A HREF="#kFileViewAccessReadWrite">kFileViewAccessReadWrite</A></CODE>. <CODE>paramErr</CODE> is returned if anything else is passed.<BR><BR></LI><LI><A HREF="#FileViewOptions">FileViewOptions</A> must be <CODE><A HREF="#kNilOptions">kNilOptions</A></CODE> (as reflected by <CODE><A HREF="#GetFileViewAccessOptions">GetFileViewAccessOptions</A></CODE>). <CODE>paramErr</CODE> is returned if anything else is passed.<BR><BR></LI><LI>The <CODE>viewBase</CODE> parameter as an input is currently ignored.<BR><BR></LI><LI><CODE><A HREF="#MapFileView">MapFileView</A></CODE> will fail with <CODE>opWrErr</CODE> or <CODE>permErr</CODE> if exclusive access to the backing storage file cannot be obtained.<BR><BR></LI></UL><H3><CODE><A HREF="#SetFileViewAccess">SetFileViewAccess</A></CODE></H3><UL><LI>The <CODE><A HREF="#FileViewAccess">FileViewAccess</A></CODE> parameter must be either <CODE><A HREF="#kFileViewAccessReadOnly">kFileViewAccessReadOnly</A></CODE> or <CODE><A HREF="#kFileViewAccessReadWrite">kFileViewAccessReadWrite</A></CODE>.  <CODE>paramErr</CODE> is returned if anything else is passed.<BR><BR></LI></UL><H3><A HREF="#SetFileViewBackingBase">SetFileViewBackingBase</A></H3><UL><LI><CODE><A HREF="#SetFileViewBackingBase">SetFileViewBackingBase</A></CODE> is not implemented and always returns <CODE>paramErr</CODE>.<BR><BR></LI></UL>         <P><A HREF="#doctop">Back to top</A></P><BR><BR>         <A NAME="fmpdownloads" title="Downloadables"></A>                  <H2>Downloadables</H2>                  <TABLE BORDER=0 CELLPADDING=3 WIDTH="100%">            <TR>               <td width=50 align=left>                  <P ALIGN=center><img src="images/acrobatsmall.gif" width=22 height=23 align=middle alt="Acrobat gif"></P>               </TD>               <td align="left">                  <P>Acrobat version of this Note (360K).</P>               </TD>               <td width=60 align=left>                  <P><A HREF="pdf/tn2011.pdf">Download</A></P>               </TD>            </TR>                    </table>         <BR>                  <P><A HREF="#doctop">Back to top</A></P></td></tr></table></center><!-- begin_footer_information -->	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/technotes/tn/tn2011.html%3Fid%3DDTS10003050-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/technotes/tn/tn2011.html%3Fid%3DDTS10003050-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/technotes/tn/tn2011.html%3Fid%3DDTS10003050-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>
<!--#include virtual="/includes/footer"--><!-- end_footer_information --></BODY></HTML>