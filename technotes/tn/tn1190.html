<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"			"http://www.w3.org/TR/REC-html40/loose.dtd"><HTML><!-- Template 01-05-01 --><HEAD><LINK REL="stylesheet" HREF="../../adcstyle.css" TYPE="text/css"><LINK REL="stylesheet" HREF="../../style.css" TYPE="text/css">   <title>Technical Note TN1190: Power Manager 2.0</title>   <meta name="keywords" content="Mac OS power manager"><meta name="Description" content="Technical Note TN1190: The Power Manager 2.0 is an  updateto Mac OS that facilitates the implementation of a more aggressive power management policy, supports new capabilitiesin the  latest Macintosh hardware and the NewWorld ROM architecture."><meta name="categories" content="Operating System, Processes, Hardware and Devices"><meta name="week-posted" content="Nov 1, 1999 - Nov 5, 1999"><LINK REL="stylesheet" HREF="../../css/adcstyle.css" TYPE="text/css"><script language="JavaScript" type="text/javascript" src="../../js/adc.js"></script></HEAD><BODY BGCOLOR="#FFFFFF"><a name="//apple_ref/doc/uid/DTS10003029" title="Power Manager 2.0"></a><A NAME="top"></A><!-- begin_header_information --><!--#include virtual="/adcnavbar" --><p><a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../technicalnotes/index.html">Technical Notes</a> &gt; <a href="../../technicalnotes/Carbon/index.html">Carbon</a> &gt; <a href="../../technicalnotes/Carbon/idxProcessManagement-date.html">Process Management</a> &gt; </p><!-- end_header_information --><!-- bottom_of_header_marker_comment --><!-- top_of_titles_marker_comment --><CENTER><table width="600" cellpadding="0" cellspacing="0" border="0">
<tr><td align="left" scope="row">
<h1>
<div id="pagehead">Technical Note TN1190</div>
<div id="pageheadsub">Power Manager 2.0</div>
</h1>
</td></tr></table></CENTER><!-- bottom_of_titles_marker_comment --><CENTER><TABLE BORDER=0 CELLSPACING=1 WIDTH=600><TR><td align="left">         <!-- begin_header_box --><table width="600" cellpadding="0" cellspacing="0" border="0">     <tr><td width=300 valign="top" align=left scope="row">    <table border="0" width="300" cellpadding="0" cellspacing="0">			<tr>                        <td width=300 align=left> <img src="images/tnmenutop.gif" alt="" align="bottom" width=300 height=7></td>        </tr>        <tr bgcolor="#e6e6e6">   <td background="images/tnmenubody.gif" width=300 align=left>       <span id="menutitle">CONTENTS   <br>  <br>       </span>   </td>        </tr>        <tr bgcolor="#e6e6e6">   <td background="images/tnmenubody.gif" width=300 align=left>       <!-- begin_toc -->         <P id ="menutext">  <A HREF = "#Section1">Participating in Power Management </A><BR><BR>  <A HREF = "#Section2">Changes to Sleep and Wake</A><BR><BR>   <A HREF = "#Section3">Device Power Handlers</A><BR><BR>   <A HREF = "#Section4">New Routines in Power Manager 2.0</A><BR><BR>  <A HREF = "#Section5">New Sleep Types</A><BR><BR>   <A HREF = "#Section6">Sleep Messages</A><BR><BR>   <A HREF = "#Section8">More New Messages</A><BR><BR>  <A HREF = "#Section9">Wake on Network Activity</A><BR><BR>  <A HREF = "#Section10">Adding Power Sources</A><BR><BR>  <A HREF = "#Section11">Obtaining Microprocessor Temperature</A><BR><BR>   <A HREF = "#Section12">Power Manager Apple Events </A><BR><BR> <A HREF = "#Section13">Server Mode</A><BR><BR> <A HREF = "#References">References</A><BR><BR><A HREF="#Downloads">Downloadables</A></p>  <!-- end_toc --></td>        </tr>        <tr>   <td width=300 align=left scope="row">       <img src="images/tnmenubottom.gif" alt="" width=300 height=16>   </td>        </tr>    </table></td>        <td width=300 valign="top" align=left><!-- begin_intro_text --><P id = "introtext">The Power Manager 2.0 is an update to Mac OS thatfacilitates the implementationof a more aggressive power management policy, andsupports new capabilities in thelatest Macintosh hardware and the NewWorld ROM architecture.</P><P id = "introtext">Power Manager 2.0 is available on all iMacs, Blue&amp; White G3 and Power Mac G4 desktops, the "bronzekeyboard" PowerBook G3 Series, the iBook, and future portables and desktops.</P><P id = "introtext">While internal changes have been made to theMac OS to support Power Manager 2.0, there are a few new APIroutines that are available to developers. Thus, this document describes thefeatures new or updated in Power Manager 2.0. For completedetails on using Power Manager services, please see the chapter"Power Manager" in <I>Inside Macintosh:Devices</I>.</P><P id = "introtext"> This Note is not only directed at application developerswho previously had concerns about running on portables, but indeed to all Mac OS application developers. Device Driver writers onthe other hand, should review <I>Updating Driversfor PM</I> for detailed information on how tosupport removal of power to the PCI slots.</P><!-- end_intro_text --><!-- begin_date --><h3>&nbsp;Updated: [Nov 22 1999]</h3><!-- end_date --></TD>             </TR>          </TABLE> <!-- end_header_box --><BR><BR><hr width=500 align=center><BR><BR><!-- begin_content --><A NAME="Section1"></A> <H2>Participating in Power Management</H2><P>The new Power Manager is less and less aPowerBook-specific manager. Indeed, the new Power Manager performs the same power savings activities on desktop machines (where supported) as it does onportables, and will continue to do so in future products. It is important to use power efficiently in all computer systems, even those that never leave the den or office.</P> <P>With the introduction of the new nanokernel that first becameavailable in Mac OS 8.6 a task is allowed to block when it is notbusy or does not require CPU time. As a result, the processor (or insome cases multiple processors), can be put into a low-power stateuntil needed. This provides improved power savings, which translatesto a noticeable improvement in battery life.</P><P>In order to take advantage of the new power-saving capability,applications and other software can help keep the system idle by simply following some basic guidelines.</P><h4>WaitNextEvent</h4><P>Do not use a zero sleep value in your calls to<code>WaitNextEvent</code>. Doing so causes your application tomonopolize the CPU and prevents the system from becoming idle.</P><h4>VBLs and Time Tasks</h4><P>Reduce your use of VBLs and Time Manager tasks, especially if theytrigger with high frequency. Again, the more tasks that are used and thehigher the frequency, the more the CPU is burdened with executingpossibly needless instructions.</P><h4>Polling/Spin Looping</h4><P>Do not sit in a loop and spin, waiting for an event. Do not use aspin loop to wait for <code>ioResult</code> to change in DeviceManager calls. Instead, use the new, idle-friendly <CODE>PBWaitIOComplete</CODE>routine in the Device Manager.</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>   OSStatus PBWaitIOComplete(IOParamPtr ioPB, Duration timeout)</pre></TD></TR></TABLE></CENTER><BR><BR><P><code>PBWaitIOComplete</code> will keep the system idle until eitheran interrupt occurs (one which possibly affects your wait on<code>ioResult</code>), or the specified timeout value has beenreached. If the timeout has been reached, this routine will return<code>kMPTimeoutErr</code>.</P> <P><A HREF = "#top">Back to top</a></p><BR>  <A NAME="Section2"></A>   <H2>Changes to Sleep and Wake</H2>   <P>To meet more aggressive power management requirements,the sleep/wake process has been enhanced to permit new hardwarecapabilities, including removing power from the PCI slots duringsleep, if possible, and entering a new state called "deep sleep."However, the overall process is the same and the use of the sleepqueue remains unchanged, other than additional messages that entriesmay or may not need to handle.</p><P>DriverServices has been updated to provide services, which, if usedby PCI (and other) device drivers, allow devices to control theirpower during the sleep/wake process at a later stage than thetraditional sleep queue. While using these new services is similar tousing the classic sleep queue, the point at which device powerhandlers will be called is much later in the process, therebyallowing those devices to provide their services until the lastpossible moment before power is removed.</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>   For complete details on using the traditional sleepqueue, see the chapter "Power Manager" in <i>Inside Macintosh:Devices</i>.</P></TD></TR></TABLE></CENTER><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Important:</B><BR>Device Driver writers should review the separate document,<i>Updating Drivers for PM</i>, for detailed information on howto support removal of power to the PCI slots.</P></TD></TR></TABLE></CENTER><BR><BR><P><A HREF = "#top">Back to top</a></p><BR>  <A NAME="Section3"></A>   <H2>Device Power Handlers</H2> <P>A device power handler is a routine called by the Power Managerthat services power management requests on behalf of devices attachedto the computer.</P><P>The Power Manager defines a new low-level sleep queue called the<B>device sleep queue</B>. The device sleep queue is comprised of powerhandlers that are called with sleep-related power managementrequests very late in the sleep process and very early in the wakeprocess. This queue is intended primarily for device drivers to settheir power state in response to a sleep or wake event. The devicesleep queue will receive the same messages sent to the traditionalsleep queue, and both queues can receive some additional messages(please see "New Sleep Messages" below).</p><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>typedef pascal OSStatus (*PowerHandlerProcPtr)(UInt32  message,void * param,UInt32 refCon,RegEntryID * regEntryID);</pre></TD></TR></TABLE></CENTER><BR><BR><P>This is the definition of a power handler. The parameter<code>message</code>is the current power management request. <code>param</code>is message-specific and is currently only used for<code>kGetDevicePowerLevel</code> and<code>kSetDevicePowerLevel</code> messages and the<code>kGetPowerInfo</code> and <code>kGetWakeOnNetInfo</code>messages. The <code>refCon</code> is provided for the power handler to use.Any value passed in this parameter during registration will bereturned to the power handler each time it is called. The lastparameter, <code>regEntryID</code>, is the device that the power handlercontrols and is the same as that presented to the PowerManager when the power handler was registered.  </p> <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Important:</B><BR>All power handlers should return the<code>kPowerMgtMessageNotHandled</code> if they do not handle aparticular power management message.</P></TD></TR></TABLE></CENTER><BR><BR> <P><A HREF = "#top">Back to top</a></p><BR>  <A NAME="Section4"></A>   <H2>New Routines in Power Manager 2.0</H2><BR> <h4>AddDevicePowerHandler</h4><P>You can use <CODE>AddDevicePowerHandler</CODE> to add a power handler to thedevice sleep queue. <CODE>regEntryID</CODE> is the address of your device'sregistry entry ID. Note that this is a required parameter and a valid<CODE>RegEntryID</CODE> must be provided. <CODE>handler</CODE> is the power handler you are registering for the given device. This is a pointer to PowerPC code and NOT a routine descriptor. Only PowerPC code can register a powerhandler, so a routine descriptor is not required. The <CODE>refCon</CODE> field is for your internal use and will be passed back to you on each powermanagement request. <CODE>deviceType</CODE> is a string describing the type ofdevice you have. Most power handlers wont need to use this parameteras the Power Manager will lookup your device type based on the<CODE>regEntryID</CODE> parameter.</p><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>    AddDevicePowerHandler (RegEntryIDPtr regEntryID,PowerHandlerProcPtr handler,UInt32 refCon,char * deviceType);</pre></TD></TR></TABLE></CENTER><BR><BR>  <h4>RemoveDevicePowerHandler</h4>  <P>You can use <CODE>RemoveDevicePowerHandler</CODE> to uninstall your powerhandler. <CODE>regEntryID</CODE> is the registry entry ID for the device yourpower handler controls.</p><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>   OSStatus RemoveDevicePowerHandler (RegEntryIDPtrregEntryID);</pre></TD></TR></TABLE></CENTER><BR><BR> <h4>GetDevicePowerLevel</h4><P>You can use <CODE>GetDevicePowerLevel</CODE> to query a device's power handlerfor current power information.</p><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>OSStatus GetDevicePowerLevel (RegEntryIDPtr regEntryID,PowerLevel * devicePowerLevel);</pre></TD></TR></TABLE></CENTER><BR><BR> <h4>SetDevicePowerLevel</h4><P>You can use <CODE>SetDevicePowerLevel</CODE> to set a device's power level tothe state you provide in the <CODE>devicePowerLevel</CODE> parameter. Please see "Updating Drivers for PM" for a description of power leveldefinitions and how to use <CODE>GetDevicePowerLevel</CODE> and<CODE>SetDevicePowerLevel</CODE>.</p><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>OSStatus SetDevicePowerLevel (RegEntryIDPtr regEntryID,PowerLevel devicePowerLevel);</pre></TD></TR></TABLE></CENTER><BR><BR><BR><P><A HREF="#top">Back to top</A></P><A NAME="Section5"></A><H2>New Sleep Types</H2><P>With Power Manager 2.0 and the latest hardware from Apple, includingthe iBook and later machines, there are a few variations on sleep.</p><h4>Simple Sleep</h4><P>This form of sleep is what most have come to know as traditionalPowerBook sleep. Most of the machine is powered off, but memory isplaced into self-refresh mode so that the contents are not lost whilethe machine is asleep.</p><h4>Safe Sleep</h4><P> This form of sleep is similar to simple sleep, but a file iswritten to disk that represents the contents of memory at the pointof sleeping so that -- should an unexpected loss of power occur -- theuser's working context can be fully restored upon the next startup.Currently, this variation of sleep is only available if VirtualMemory is turned on in the Memory Control Panel. Safe sleep isenabled if the user checks the "Preserve memory contents on sleep"checkbox in the Advanced Settings panel of the Energy Saver ControlPanel.</p><h4>Deep Sleep</h4><P>  This form of sleep is one where the contents of memory are writtento disk and the machine is fully powered off. When the user pressesthe power key the machine is booted to the point where it isdetermined if the preserved memory contents exist on disk and, if so,memory is reconstructed and the machine wakes up as though it hadonly just slept.</p><P>Deep sleep is currently only available if Virtual Memory is turned onin the Memory Control Panel. Currently, deep sleep is only enteredwhen the machine goes into a Safe Sleep state and power is lostduring that time (such as when battery power is fully drained whilethe machine is asleep).</p><P>To see if safe or deep sleep is a supported feature of a givenmachine, use the <CODE>PMFeatures</CODE> routine and check to see if the<CODE>hasDeepSleep</CODE> bit is set.</p> <P><A HREF = "#top">Back to top</a></p><BR><A NAME="Section6"></A><H2>Sleep Messages</H2><P>Given the variations now possible for sleep, the messages sent to thesleep queue and the device sleep queue can also vary.</p><h4>Messages for Simple Sleep</h4><P>In this case, sleep queue entries and device sleep queue entries willreceive the standard set of messages: <code>kSleepRequest</code>(previously <CODE>sleepRequest</CODE>) or <CODE>kSleepDemand</CODE>(previously <CODE>sleepDemand</CODE>) and <CODE>kSleepWakeup</CODE>on wake (previously <CODE>sleepWakeup</CODE>). These cases should behandled as before. Alternatively, these queues will receive thevarious doze messages on Blue &#38; White G3s and iMacs:<CODE>kDozeRequest</CODE>, <CODE>kDozeDemand</CODE>, and<CODE>kDozeWakeup</CODE>.</p><h4>Messages for Safe Sleep </h4><P>In the safe sleep case, the standard set of messages described aboveis sent, but prior to a <CODE>kSleepRequest</CODE> or<CODE>kSleepDemand</CODE>, a sleep queue entry will receive a<CODE>kSuspendRequest</CODE> or <CODE>kSuspendDemand</CODE>, respectively. For the sleep queue, these latter new messages are sent not only in addition to the existing messages but also prior to them.The reason both messages are sent is that legacy software might notrecognize a new message, and therefore might not properly prepare forthe imminent sleep. The device sleep queue entries will receive the<CODE>kSuspendRequest</CODE> and/or <CODE>kSuspendDemand</CODE>message in lieu of the <CODE>kSleepRequest</CODE> or<CODE>kSleepDemand</CODE> messages.</p><P>On wakeup, if power was lost, then the sleep queue will receive a<CODE>kSuspendWakeup</CODE> message in addition and prior to a<CODE>kSleepWakeup</CODE> message. The device sleep queue entrieswill only receive a <CODE>kSuspendWakeup</CODE> if the machine isresuming from a powered-off state and is to restore the contents ofmemory that were saved to disk. If waking from normal sleep, bothqueues will receive a <CODE>kSleepWakeup</CODE> message.</p>   <P><B>Very Important!</B><BR>Software registered in the traditional sleep queue must maintain itsown state regarding these additional messages. For example, ifsoftware receives a <CODE>kSuspendDemand</CODE> message and proceeds to performactivities such that when a <CODE>kSleepDemand</CODE> message is received thoseactivities do not need to be performed again, then it is up to thatsoftware to properly manage the sequence and not duplicate theactivities. For the device sleep queue, since entries registered init only receive one or the other message, this is not an issue.</p> <H3>Sleep Message Examples</H3><P>   In order to clarify the complexity of the new messages, thefollowing examples are provided to show the order of events for eachtype of sleep. It is important to note that most software will nothave to change how sleep is handled to run correctly with the newPower Manager, since most software typically should not care if safesleep is being entered or not. In this case, follow the sameguidelines as described in <i>Inside Macintosh: Devices</i>. Onlydevice driver writers and those who must do something differently inthe case of safe sleep need to understand when the new messages aresent and how to respond to them.</p><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>For older desktops (Blue &#38; White G3s, iMacs) and machines thatotherwise cannot enter the normal sleep state, replace "sleep" in thefollowing examples with "doze" (but only in the simple sleep casessince safe sleep is not available to such machines). For example,<CODE>kSleepRequest</CODE> becomes <CODE>kDozeRequest</CODE>.</p></TD></TR></TABLE></CENTER><BR><BR><h4>Simple Sleep Request (Idle Sleep)</h4><P>This is the sequence of messages sent when the user-specified sleeptimeout occurs:</p><OL><LI>Sleep queue sent <CODE>kSleepRequest</CODE>.<BR></li><LI>If a sleep queue element denies request,<CODE>kSleepRevoke</CODE> sent to sleep queue and sleep is aborted .Goto step 10.<BR></li><LI>Device sleep queue sent <CODE>kSleepRequest</CODE>.<BR></li><LI>If a device sleep queue element denies request,<CODE>kSleepRevoke</CODE> sent to device sleep queue and to sleepqueue, and sleep is aborted. Goto step 10.<BR></li><LI>Sleep queue sent <CODE>kSleepDemand</CODE>.<BR></li><LI>Device sleep queue sent <CODE>kSleepDemand</CODE>.<BR></li><LI>Machine sleeps...then a wakeup event occurs.<BR></li><LI>Device sleep queue sent <CODE>kSleepWakeup</CODE>.<BR></li><LI>Sleep queue sent sleep <CODE>kSleepWakeup</CODE>.<BR></li><LI>Machine is awake.<BR></li></OL><h4>Simple Sleep Demand (User-Demand Sleep)</h4><P>  This is the sequence of messages sent when the user (or a low-powercondition) initiates sleep:</p><OL><LI>Sleep queue sent <CODE>kSleepDemand</CODE>.<BR></li><LI>Device sleep queue sent <CODE>kSleepRequest</CODE>.<BR></li><LI>If a device sleep queue element denies request,<CODE>kSleepRevoke</CODE> sent to device sleep queue and<CODE>kSleepWakeup</CODE> sent to sleep queue, and sleep is aborted. Goto step 8.<BR></li><LI>Device sleep queue sent <CODE>kSleepDemand</CODE>.<BR></li><LI>Machine sleeps...then a wakeup event occurs.<BR></li><LI>Device sleep queue sent <CODE>kSleepWakeup</CODE>. <BR></li><LI>Sleep queue sent sleep <CODE>kSleepWakeup</CODE>.<BR></li><LI>Machine is awake.<BR></li></OL> <h4>Safe Sleep Request</h4><P>  This is the sequence of messages sent when the user-specified sleeptimeout occurs for safe sleep:</p><OL><LI>Sleep queue sent <CODE>kSuspendRequest</CODE>.<BR></li><LI>Sleep queue sent <CODE>kSleepRequest</CODE>.<BR></li><LI>If an sleep queue element denies request,<CODE>kSleepRevoke</CODE> sent to sleep queue and sleep is aborted.Goto step 14.<BR></li><LI>Device sleep queue sent <CODE>kSuspendRequest</CODE>.<BR></li><LI>If a device sleep queue element denies request,<CODE>kSuspendRevoke</CODE> sent to device sleep queue and<CODE>kSleepRevoke</CODE> sent to sleep queue and sleep is abortedthen goto step 14.<BR></li><LI>Sleep queue sent <CODE>kSuspendDemand</CODE>.<BR></li><LI>Sleep queue sent <CODE>kSleepDemand</CODE>.<BR></li><LI>Device sleep queue sent <CODE>kSuspendDemand</CODE>.<BR></li><LI> Machine sleeps (and subsequently may or may not losepower)...then a wakeup/powerup event occurs.<BR></li><LI>If waking from normal sleep, device sleep queue sent<CODE>kSleepWakeup</CODE>. Goto step 13.<BR></li><LI>If waking from power off, device sleep queue sent<CODE>kSuspendWakeup</CODE>.<BR></li><LI>If waking from power off, sleep queue sent <CODE>kSuspendWakeup</CODE>.<BR></li><LI>Sleep queue sent <CODE>kSleepWakeup</CODE>.<BR></li><LI>Machine is awake.<BR></li></OL><h4>Safe Sleep Demand</h4><P>  This is the sequence of messages sent when the user (or a low-powercondition) initiates safe sleep:</p><OL><LI>Sleep queue sent <CODE>kSuspendDemand</CODE>.<BR></li><LI>Sleep queue sent <CODE>kSleepDemand</CODE>.<BR></li><LI>Device sleep queue sent <CODE>kSuspendRequest</CODE>.<BR></li><LI>If a device sleep queue element denies request,<CODE>kSleepRevoke</CODE> sent to device sleep queue and<CODE>kSleepWakeup</CODE> sent to sleep queue. Sleep is aborted, thengoto step 11.<BR></li><LI> Device sleep queue sent <CODE>kSuspendDemand</CODE>.<BR></li><LI>Machine sleeps (and subsequently may or may not losepower)...then a wakeup/powerup event occurs.<BR></li><LI>If waking from normal sleep, device sleep queue sent<CODE>kSleepWakeup</CODE> then goto step 10.<BR></li><LI>If waking from power off, device sleep queue sent<CODE>kSuspendWakeup</CODE>.<BR></li><LI>If waking from power off, sleep queue sent <CODE>kSuspendWakeup</CODE>.<BR></li><LI>Sleep queue sent sleep <CODE>kSleepWakeup</CODE>.<BR></li><LI>Machine is awake.</li></OL><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>A request is always sent to the device sleep queue regardless ofwhether the original sleep is a request (idle) or demand(user-initiated) sleep. This is because device sleep queue entriesmust always be given the opportunity to deny a sleep due to the factthat the device whose power they manage may not support low-powersleep (which can occur on Power Macintosh G4 desktops where power isremoved from the PCI slots if all devices support it).</P></TD></TR></TABLE></CENTER><BR><BR><P><A HREF = "#top">Back to top</a></p><BR><A NAME="Section8"></A><H2>More New Messages</H2><h4>WakeToDoze</h4><P>The <CODE>kWakeToDoze</CODE> message is sent to both the sleep queueand the device sleep queue if the machine is to wake up to a certainpoint to service a network or other request that was the cause ofwaking the machine (rather than the user). Most sleep queue entrieswill not need to respond to this message separately and would return<CODE>noErr</CODE>. Most device sleep queue entries must treat a<CODE>kWakeToDoze</CODE> message in the same way as they treat a<CODE>kSleepWakeup</CODE> message. They should always handle and NOTignore the message. Some device power handlers, video devices inparticular (and possibly mass storage devices), should respond to therequest differently and only perform the minimum wake tasks short ofbringing the display back to life or spinning up the hard drive(unless necessary).</p><P>Sample handler that doesn't do anything special for <CODE>kWakeToDoze</CODE>:</p><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>pascal OSStatus MyPowerHandler (UInt32 message,  void *param,  UInt32 refCon,  RegEntryID * regEntryID){   switch (message)   {   case kWakeToDoze:   case kSleepWakeup:   WakeMyDevice ();   break;   case kDozeToFullWakeUp: // We can ignore since we awoke fully on the kWakeToDoze msg   break;:   }}</pre></TD></TR></TABLE></CENTER><BR><BR><P>Sample handler that DOES handle <CODE>kWakeToDoze</CODE> differently:<BR></P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>pascal OSStatus MyPowerHandler (UInt32 message,  void *param,  UInt32 refCon,  RegEntryID * regEntryID){   switch (message)   {   case kWakeToDoze:   WakeMyDevicePartially();   break;   case kSleepWakeup:   WakeMyDevice ();   break;   case kDozeToFullWakeUp:WakeMyDeviceFromPartialState ();   break;:   }}</pre></TD></TR></TABLE></CENTER><BR><BR><H4>DozeToFullWakeUp</H4><P>The <CODE>kDozeToFullWakeUp</CODE> message follows the<CODE>kWakeToDoze</CODE> message if the user has elected to wake the machine manually while it is in the intermediate doze state.Again,most entries may choose to ignore this message, but those whoresponded to the <CODE>kWakeToDoze</CODE> message should performwhatever steps are required to bring their device to a full wakestate.</p><P>If the machine is in the intermediate wake state (doze) and thenormal sleep timeout occurs, the sleep queue entries will get thenormal sleep or suspend request messages, and should handle themaccordingly as the machine goes back to full sleep.</p> <h4>GetPowerLevel &#38; GetPowerLevel</h4><P>The <CODE>kGetPowerLevel</CODE> and <CODE>kSetPowerLevel</CODE>messages will only be sent to entries in the new device sleep queue.They are used to inform a power handler in the device sleep queuethat a piece of software wishes to change the state of the devices itcontrols by using the new DriverServices<CODE>GetDevicePowerLevel</CODE> and <CODE>SetDevicePowerLevel</CODE>routines.See <i>Updating Drivers for PM</i> for a full description ofthe power level definitions.</p><h4>DeviceInitiatedWake</h4><P>The <CODE>kDeviceInitiatedWake</CODE> message is sent to all powerhandlers to query if they control a device that caused a wakeup tooccur. Most power handlers will not respond to this request. Devicesthat can wake up the machine should respond to this message byreturning an appropriate value that indicates if the device didinitiate the wake up and if the wake up should be full using<CODE>kDeviceRequestsFullWake</CODE> or partial using<CODE>kDeviceRequestsWakeToDoze</CODE>. These values are to bereturned via the param parameter of the power handler function.</p><P>Here is an example of a function that indicates to the Power Mgr thatits device caused the wakeup:</p><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>pascal OSStatus MyPowerHandler (UInt32 message,void *param,UInt32 refCon,RegEntryID * regEntryID){  OSStatus  status = kPowerMgtMessageNotHandled;  switch (message)  {case kDeviceInitiatedWake:  *param = kDeviceDidNotWakeMachine;  if (IWokeTheMachine())*param = kDeviceRequestsFullWake;  status = noErr;  break;// handle other cases  }  return err;}</pre></TD></TR></TABLE></CENTER><BR><BR> <P><A HREF = "#top">Back to top</a></p><BR><A NAME="Section9"></A><H2>Wake on Network Activity</H2><P>New hardware (including iBook and Power Mac G4) has a new featurecalled "Wake on Network." This means that, based on user preference,certain types of network activity will cause a sleeping computer toawaken to respond to the network request. The user (via Energy Saver)or developer can specify two options insofar as what network activitycan wake a sleeping machine (using the<CODE>kWakeOnNetAdminAccessesBit</CODE> and<CODE>kWakeOnAllNetAccessesBit</CODE> values described below).<CODE>kConfigSupportsWakeOnNetBit</CODE> is used only by powerhandlers for network interface cards in response to the<CODE>kGetWakeOnNetInfo</CODE> power management request where thosecards support wake on network activity.</p><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>// Net Activity Wake Optionsenum  {  kConfigSupportsWakeOnNetBit   = 0, // current interfacesupports wake on network  kWakeOnNetAdminAccessesBit= 1, // wake on network admin packet  kWakeOnAllNetAccessesBit  = 2, // wake on any packet  kUnmountServersBeforeSleepBit = 3, // disconnect from servers  kConfigSupportsWakeOnNetMask  = (1&lt;&lt;kConfigSupportsWakeOnNetBit),  kWakeOnNetAdminAccessesMask   = (1&lt;&lt;kWakeOnNetAdminAccessesBit),  kWakeOnAllNetAccessesMask = (1&lt;&lt;kWakeOnAllNetAccessesBit)  kUnmountServersBeforeSleepMask=(1&lt;&lt;kUnmountServersBeforeSleepBit);  };</pre></TD></TR></TABLE></CENTER><BR><BR>  <h4>GetWakeOnNetworkOptions</h4><P><CODE>GetWakeOnNetworkOptions</CODE> can be used to retrieve whattypes of network accesses the system thinks are allowed to wake upthe machine.</p><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>   OptionBits GetWakeOnNetworkOptions (void);char * deviceType);</pre></TD></TR></TABLE></CENTER><BR><BR><h4>SetWakeOnNetworkOptions</h4>  <P><CODE>SetWakeOnNetworkOptions</CODE> can be used to instruct thesystem on what network events should allow the machine to be awakenedfor servicing. Pass a value with the <CODE>kWakeOnNetAdminAccessesBit</CODE> andthe <CODE>kWakeOnAllNetAccessesBit</CODE> set to zero in the <CODE>inOptions</CODE> parameterto disable wake on network.</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>OptionBits SetWakeOnNetworkOptions (OptionBitsinOptions);</pre></TD></TR></TABLE></CENTER><BR><BR> <h3>Networking Drivers and Wake On Network</h3><P>Drivers that control a network interface card should be sure toregister a power handler with the Power Manager (see <A HREF = "#Section3">Device Power Handlers</A>) so that they may respondto queries about whether they caused the system to be awakened.</p><P>The <CODE>kGetWakeOnNetInfo</CODE> message will be sent to see if thenetwork device that is currently selected in fact supports waking onnetwork activity.</p><P>The <CODE>kDeviceInitiatedWake</CODE> message will be sent to thenetworking device's power handler upon wakeup. The power handlershould respond with a result indicating if the device which the powerhandler represents is responsible for waking the system. The powerhandler should return <CODE>kDeviceRequestsWakeToFull</CODE> if thesystem should be fully awakened to service the request and<CODE>kDeviceRequestsWakeToDoze</CODE> if the system should only bepartially awakened to service the request. A partially awakenedsystem is one that is put into the doze state instead of the fullrunning state.</p><P><A HREF = "#top">Back to top</a></p><BR><A NAME="Section10"></A><H2>Adding Power Sources </H2><P>Power Manager 2.0 has the provision to control and interact with anumber of devices such as AC, batteries, or UPS devices that supplypower to the system.</p><P>As such, the Power Manager needs to be informed of the existenceand status of all attached power sources to reliably provide the userimportant information, particularly if the system is running onbattery or backup power alone (e.g., UPS).</p><P>The Power manager is made aware of the existence of these devicesthrough the power source data structure (referred to simple as apower source).</p><h4>Power Source data structure</h4><P>The following describes the structure of a power source:</p><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>   typedef SInt16 PowerSourceID;struct PowerSourceParamBlock{PowerSourceID sourceID; // unique ID assigned by Power MgrUInt16 sourceCapacityUsage; // how currentCapacity is usedUInt32 sourceVersion;   // use kVersionOnePowerSourceOptionBits   sourceAttr;// attributes (see below)OptionBits   sourceFlags;   // flags (see below)UInt32 currentCapacity; // current capacity, in//  milliwatts, or as percentageUInt32 maxCapacity; // full capacity, in milliwattsUInt32 timeRemaining;   // time left to deplete,//  in milliwatt-hoursUInt32 timeToFullCharge;// time to charge,//  in milliwatt-hoursUInt32 voltage; // voltage in millivoltsSInt32 current; // current in milliamperes// (negative if consuming,//  positive if charging)};</pre></TD></TR></TABLE></CENTER><BR><BR> <P>The power source can specify how the Power Manager should interpretthe <CODE>currentCapacity</CODE> field of the power source relativeto the <CODE>maxCapacity</CODE> field. The following<CODE>sourceCapacityUsage</CODE> constants have been defined:  </p><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>enum{kCapacityIsActual= 0,   // capacity expressed in actual unitskCapacityIsPercentOfMax = 1 // capacity expressed as percentage// of maxCapacity field};</pre></TD></TR></TABLE></CENTER><BR><BR><P>The following power source attribute flags can be used:</p><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>enum{bSourceIsBattery   = 0, // power source is batterybSourceIsAC = 1,// power source is ACbSourceCanBeCharged = 2,// power source can be chargedbSourceIsUPS = 3// power source is a UPS};</pre></TD></TR></TABLE></CENTER><BR><BR><P>The following power source state flags can be used:  </p><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>enum{bSourceIsAvailable  = 0,   // power source is installedbSourceIsCharging  = 1,   // power source being chargedbChargerIsAttached  = 2,   // a charger is connected};</pre></TD></TR></TABLE></CENTER><BR><BR> <h4>AddPowerSource</h4><P>You can add a power source to the list of sources the PowerManager monitors by calling <CODE>AddPowerSource</CODE>.</p> <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>pascal OSStatus AddPowerSource (PowerSourceParamBlock *ioSource);</pre></TD></TR></TABLE></CENTER><BR><BR> <P>The client will receive a unique <CODE>PowerSourceID</CODE> which canbe used to manage this power source. <CODE>ioSource</CODE> is aparameter block containing information describing the power source.The Power Manager retains a local copy of this information in itsinternal list of power sources.</p><h4>RemovePowerSource</h4><P>If a device's power source is no longer available, you can tell thePower Manager to remove the source from its list using<CODE>RemovePowerSource</CODE> so that it is no longer a factor inthe power summary calculation.</p><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>   pascal OSStatus RemovePowerSource (PowerSourceIDinSourceID);</pre></TD></TR></TABLE></CENTER><BR><BR><P><CODE>inSourceID</CODE> is the ID of the power source to be removed.The routine will return <CODE>kNoSuchPowerSource</CODE> if the sourcewith the specified <CODE>PowerSourceID</CODE> was not found in thePower Manager's list of power sources.</p><h4>UpdatePowerSource</h4><P>You can update a power source's vital statistics (power consumptionrate, capacity remaining, etc.) by calling<CODE>UpdatePowerSource</CODE>. How the source information isobtained is internal to your software.</p><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>   pascal OSStatus UpdatePowerSource (PowerSourceParamBlock *ioSource);</pre></TD></TR></TABLE></CENTER><BR><BR> <P><CODE>ioSource</CODE> contains the power source information,including the <CODE>PowerSourceID</CODE> assigned to your powersource, which is to be updated. The routine will return<CODE>kNoSuchPowerSource</CODE> if the source with the specified<CODE>PowerSourceID</CODE> of this parameter block was not found inthe Power Manager's list of power sources.</p><h3>Example A simple UPS Power Source</h3><P>Let's say the user attaches a UPS to the system that is capable ofcommunicating its status to the Power Manager. The UPS driversoftware should register a power source with the Power Manager toindicate its existence:</p><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>static PowerSourceParamBlock mySource;void RegisterUPSSource (void){OSStatus  status = noErr;mySource.sourceCapacityUsage= kCapacityIsActual;mySource.sourceAttr = (1&lt;&lt;bSourceIsUPS)| (1&lt;&lt;bSourceIsAC)| (1&lt;&lt;bSourceIsBattery);   // note how we register that we're AC AND battery aswell as UPSmySource.sourceFlags= (1&lt;&lt;bSourceIsAvailable);mySource.currentCapacity= myCurrentCapacityInMilliWatts;mySource.maxCapacity= myMaxCapacityInMilliWatts;mySource.timeRemaining  = secondsLeftToDischarge;mySource.timeToFullCharge   = secondsToFullChargeIfCharging;mySource.voltage= myVoltageInMilliVolts;mySource.current= -1234;   // negative if consumingstatus = AddPowerSource (&#38;mySource);   // handle errors}</pre></TD></TR></TABLE></CENTER><BR><BR><P>When AC power is removed, the UPS can update the status by making thefollowing change during its periodic update:</p><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>  void UpdateUPSSource (void){OSStatus  status = noErr;// Gather updated dataif (NoACConnected())  // note that we remove the AC attribute. This tells  // the Power Manager to ignore internal AC and act like  // were running off battery power  mySource.sourceAttr &#38;= ~(1&lt;&lt;bSourceIsAC);  mySource.currentCapacity = myCurrentCapacityInMilliWatts;  mySource.timeRemaining   = secondsLeftToDischarge;  mySource.timeToFullCharge= secondsToFullChargeIfCharging;  mySource.voltage = myVoltageInMilliVolts;  mySource.current = -1234; // negative if consuming  status = UpdatePowerSource (&#38;mySource);  // handle errors}</pre></TD></TR></TABLE></CENTER><BR><BR><P>When the UPS specifies that no AC is present, it is an indication tothe Power Manager that any internal readings about the presence of ACare invalid and, hence, the Power Manager treats the system as thoughit were running off battery. As a result, under low-power conditions,the system will perform the same low-power actions that it does onPowerBooks with low battery power, that is, it will put the systeminto a low-power state. If the system supports deep sleep, it willtry to put that system into deep sleep. If not, then the system isput into normal sleep unless it doesn't normally provide battery power(as is the case with desktops) in which case the system will bepowered off. Note that Apple Events will be sent to active processesto indicate when a low-power condition exists and when low-poweractions are imminent. Please see "Power Manager Apple Events" belowfor a description of these events.</p><P><A HREF = "#top">Back to top</a></p><BR><A NAME="Section11"></A><H2>Obtaining Microprocessor Temperature</H2><P>You can use the Power Manager to obtain the core temperature of themicroprocessor or microprocessors on board.</p><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>SInt32 GetCoreProcessorTemperature (MPCpuID inCpuID);</pre></TD></TR></TABLE></CENTER><BR><BR><P>The parameter, <CODE>inCpuID</CODE>, specifies from which processorthe Power Mgr should get the core temperature. This ID can beobtained using the MP API (typically by calling<CODE>MPProcessors</CODE> to get the processor count and then using<CODE>MPGetNextCpuID</CODE> to iterate through the availableprocessors). This method will work for both uniprocessor andmultiprocessor systems.</p><P>The temperature is expressed in degrees centigrade. The result willbe a positive value if the temperature was correctly obtained. If theresult is negative, then an error is being returned.</p><P>  This routine will return<CODE>kCantReportProcessorTemperature</CODE> if the hardware inquestion does not support reporting the core processor temperature orif MP services are not available.</p>  <P><A HREF = "#top">Back to top</a></p><BR><A NAME="Section12"></A><H2>Power Manager Apple Events</H2><P>The Power Manager now provides limited support for Apple Events.Currently, only four events are broadcast to all active processesthat indicate they are high-level event aware.</p><h4>Power Management Event Class</h4><P>All events are broadcast using an event class of<CODE>kAEMacPowerMgtEvt</CODE>:</p><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>   enum  {  kAEMacPowerMgtEvt= 'pmgt'  }</pre></TD></TR></TABLE></CENTER><BR><BR>   <h4>Power Management Event IDs</h4><P>  The following event ids have been defined:</p><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>enum  {  kAEMacToWake= 'wake',  kAEMacLowPowerSaveData  = 'pmsd',  kAEMacEmergencySleep= 'emsl',  kAEMacEmergencyShutdown = 'emsd'  };</pre></TD></TR></TABLE></CENTER><BR><BR>  <P>The <CODE>kAEMacToWake</CODE> message is sent whenever the Macintoshis waking up from sleep.</p><P>The <CODE>kAEMacLowPowerSaveData</CODE> message is sent whenever theMacintosh is experiencing main power loss and the backup power issufficiently low to warrant sleep or shutdown in the near future.Applications should do what is necessary to save the state of theservices they provide (by saving unsaved documents to a temporaryfile for future restoration if necessary).</p><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Important:</B><BR>Software should avoid posting alerts or dialogs for user interactionwhen handling this Apple Event, or, if they must, they should be surethose dialogs have a brief time-out associated with them. This isbecause the machine may be unattended and to get the full benefit ofpower loss handling in the OS, the system must be able to begracefully put to sleep or powered off.</p></TD></TR></TABLE></CENTER><BR><BR>   <P>One of two emergency low-power action warnings is broadcast when themachine is about to run out of backup power. Which message is sentdepends on the machine and the features it supports.  </p>  <P>The <CODE>kAEMacEmergencySleep</CODE> message is sent just before thecomputer is to go to sleep or deep sleep due to very little backuppower remaining. No user interaction is allowed during this message.The low-power action will occur within several seconds of thebroadcast of this event.</p>  <P>The <CODE>kAEMacEmergencyShutdown</CODE> message is sent just beforethe computer is to be shutdown due to very little backup powerremaining. Some models (such as Blue &#38; White G3s and most iMacs) willshutdown instead of going to sleep. No user interaction is allowedduring this message. The low-power action will occur within severalseconds of the broadcast of this event.</p> <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Important:</B><BR>If a particular Macintosh model supports deep sleep, it will enterthat state instead of sleep or shutdown, if possible. If a modelindicates it supports deep sleep, but that option is unavailable atthe time of the low-power action, then the machine will be put tosleep if it has battery support (such as iBook or PowerBooks) orpowered off if not. Software should usually treat<CODE>kAEMacEmergencySleep</CODE> and<CODE>kAEMacEmergencyShutdown</CODE> the same because while one mightbe broadcast, the nature of the system at the time when the action istaken might cause the opposite to actually be implemented. That is,even though the system broadcasts a <CODE>kAEMacEmergencySleep</CODE>message, the given context might force a shutdown instead.</P></TD></TR></TABLE></CENTER><BR><BR>  <P><A HREF = "#top">Back to top</a></p><BR><A NAME="Section13"></A><H2>Server Mode</H2><P>The new Power Manager provides two new routines to allow server modeoperation. This mode, most useful on servers (!), allows the machineto be started automatically in the event of unexpected loss of ACpower and then subsequent restoration of AC power.</p> <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>pascal void EnableServerMode (Boolean inEnable);</pre></TD></TR></TABLE></CENTER><BR><BR><P>You can use <CODE>EnableServerMode</CODE> to enable or disable theserver mode feature. When enabled, the machine will be automaticallystarted when AC power is provided (only after an unexpected loss ofAC power).</p><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>pascal Boolean IsServerModeEnabled (void);</pre></TD></TR></TABLE></CENTER><BR><BR><P> You can use <CODE>IsServerModeEnabled</CODE> to determine ifserver mode is currently enabled. A return value of TRUE means thatit is enabled, and FALSE means it is not enabled.</p><P><A HREF = "#top">Back to top</a></p><BR><a name="References"></a><H2>References</H2><p><a href="../../documentation/hardware/DeviceManagers/powermgr/powermgr.html">Inside Macintosh: Devices (Chapter 6 - Power Manager)</A></p><p><A HREF = "tn1039.html">TN1039: Disk Access &#38; Power Manager.</a></p><p><A HREF = "tn1046.html">TN1046: PowerMgr Addenda.</a></p><p><A HREF = "tn1079.html">TN1079: Power Management &#38; Servers.</a></p><p><A HREF = "tn1086.html">TN1086: Power Management &#38; The Energy Saver API</a></p><p>"Updating Drivers for PM" (this document is part of the<A HREF = "http://developer.apple.com/sdk/">Power Mgr DDK</a>)</p><BR><P><A HREF="#top">Back to top</A></P><A NAME="Downloads"></A> <h2>Downloadables</h2><center><TABLE BORDER=0 CELLPADDING=3 WIDTH="600"> <TR> <td width=50 align=left>   <P ALIGN=center><img src="images/acrobatsmall.gif" align=middle alt="Acrobat" width=22 height=23></P></TD><td align="left">   <p>Acrobat version of this Note (88K).</P></TD><td width=60 align=left>   <p><A HREF="pdf/tn1190.pdf">Download</A></P></TD>  </TR>    <TR> <td width=50 align=left>   <P ALIGN=center><img src="images/bluebook.gif" align=middle alt="Acrobat" width=22 height=23></P></TD><td align="left">   <p>Power Manager 1.0 DDK</P></TD><td width=60 align=left>   <p><A HREF = "http://developer.apple.com/sdk/">Download</a></P></TD>  </TR> </table></center><BR><BR><BR><P><A HREF="#top">Back to top</A></P></TD></TR></TABLE></CENTER><!-- end_content --><!-- begin_footer_information -->	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/technotes/tn/tn1190.html%3Fid%3DDTS10003029-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/technotes/tn/tn1190.html%3Fid%3DDTS10003029-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/technotes/tn/tn1190.html%3Fid%3DDTS10003029-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>
<!--#include virtual="/includes/footer"--><!-- end_footer_information --></BODY></HTML>