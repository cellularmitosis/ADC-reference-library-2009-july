<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>Quartz Programming Guide for QuickDraw Developers: Converting PICT Data</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Converting PICT Data"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP40001098-CH221" title="Converting PICT Data"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../index.html#//apple_ref/doc/uid/TP30000440-TP30000420" target="_top">Carbon</a> &gt; <a href="../../../GraphicsImaging-date.html#//apple_ref/doc/uid/TP30000440-TP30000420-TP30000450" target="_top">Graphics &amp; Imaging</a> &gt; <a href="../tq_intro/tq_intro.html#//apple_ref/doc/uid/TP40001098-CH201-TPXREF101">Quartz Programming Guide for QuickDraw Developers</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../tq_color/tq_color.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../tq_image_data/tq_image_data.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP40001098-CH221-TPXREF101" title="Converting PICT Data"></a><h1>Converting PICT Data</h1><p>The QuickDraw picture (PICT) format is the graphics metafile format in Mac OS 9 and earlier. A picture contains a recorded sequence of QuickDraw imaging operations and associated data, suitable for later playback to a graphics device on any platform that supports the PICT format. </p><p>In Mac OS X, the Portable Document Format (PDF) is the native metafile and print-spooling format. PDF provides a convenient, efficient mechanism for viewing and printing digital content across all platforms and operating systems. PDF is better suited than the PICT format to serve as a general-purpose metafile format for digital documents. PDF offers these advantages:</p><ul class="ul"><li class="li"><p>PDF represents the full range of Quartz graphics. The PICT format cannot be used to record drawing in a Quartz context.</p></li><li class="li"><p>PDF allows multiple pages. The PICT format can represent only a single drawing space—there’s no concept of multiple pages. </p></li><li class="li"><p>PDF supports a wide variety of color spaces. The PICT format supports RGB and grayscale color, but lacks support for other types of color spaces such as CMYK, Lab, and DeviceN. </p></li><li class="li"><p>PDF supports embedded Type 1 and TrueType fonts and font subsets. Embedded fonts aren’t supported in pictures, so text can’t be fully represented. </p></li><li class="li"><p> PDF supports compression of font, image, and page data streams. PICT supports compression for images, but in many cases the PDF representation of PICT data is more compact.</p></li><li class="li"><p> PDF supports encryption and authentication. The PICT format has no built-in security features. </p></li></ul><p>As you convert your QuickDraw application to one that uses only Quartz, there are two primary issues you’ll face with respect to PICT data:</p><ul class="ul"><li class="li"><p>You will need to handle PICT data that you previously shipped with your application. The best approach is to convert is to another format (JPG, PNG, PDF) and use those formats with Quartz.</p></li><li class="li"><p>You will want to support PICT data in your applications. This includes support for copying and pasting PDF to the pasteboard and opening existing documents.</p></li></ul><p>This chapter provides approaches for handling PICT data and also shows how to handle PDF data from the Clipboard.</p>
<!-- This template is being used for both PDF and HTML. -->

    
    <h4>In this section:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="tq_moving_data.html#//apple_ref/doc/uid/TP40001098-CH221-DontLinkElementID_11">Reading and Writing Picture Data</a>
				
			<br/>
			
        
			
			
				<a href="tq_moving_data.html#//apple_ref/doc/uid/TP40001098-CH221-DontLinkElementID_12">Working With PICT Data on the Clipboard (Pasteboard)</a>
				
			<br/>
			
        
			
			
				<a href="tq_moving_data.html#//apple_ref/doc/uid/TP40001098-CH221-DontLinkElementID_13">Copying PDF Data From the Clipboard (Pasteboard)</a>
				
			<br/>
			
        
			
			
				<a href="tq_moving_data.html#//apple_ref/doc/uid/TP40001098-CH221-DontLinkElementID_14">Relevant Resources</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP40001098-CH221-DontLinkElementID_11" title="Reading and Writing Picture Data"></a><h2>Reading and Writing Picture Data</h2><p>This section provides examples of how you can read and write picture data for the purpose of converting it to PDF or another Quartz-compatible format. Some general strategies include the following: </p><ul class="ul"><li class="li"><p>As you convert data, you may find that some PICTs don’t convert well. In these cases, you’ll want to first convert the PICT to a pixel picture first. See <span class="content_text"><a href="tq_moving_data.html#//apple_ref/doc/uid/TP40001098-CH221-BBCFIEJB">“Avoiding PICT Wrappers for Bitmap Images.”</a></span></p></li><li class="li"><p>For PICTs that are wrappers for JPEG data, use the function <code><a href="../../../../GraphicsImaging/Reference/CGImage/Reference/reference.html#//apple_ref/c/func/CGImageCreateWithJPEGDataProvider" target="_top">CGImageCreateWithJPEGDataProvider</a></code> for the JPEG data rather than working with the PICT.</p></li><li class="li"><p>If your application uses predefined PICT files or resources that are drawn repeatedly, you can convert them into PDF and place them in the Resources folder inside the application bundle. See <span class="content_text"><a href="tq_moving_data.html#//apple_ref/doc/uid/TP40001098-CH221-BBCEBIAE">“Converting QDPict Pictures Into PDF Documents.”</a></span></p></li><li class="li"><p>Use Quartz data providers to work with QDPict data. See <span class="content_text"><a href="tq_moving_data.html#//apple_ref/doc/uid/TP40001098-CH221-BBCDGAJG">“Creating a QDPict Picture From Data in Memory”</a></span> and <span class="content_text"><a href="tq_moving_data.html#//apple_ref/doc/uid/TP40001098-CH221-BBCCIHGE">“Creating a QDPict Picture From a PICT File.”</a></span></p></li><li class="li"><p>If you need to draw PICT data scaled, evaluate which type of scaling is best for your purposes. See <span class="content_text"><a href="tq_moving_data.html#//apple_ref/doc/uid/TP40001098-CH221-BBCJDBCC">“Scaling QDPict Pictures.”</a></span></p></li></ul><a name="//apple_ref/doc/uid/TP40001098-CH221-BBCFIEJB" title="Avoiding PICT Wrappers for Bitmap Images"></a><h3>Avoiding PICT Wrappers for Bitmap Images</h3><p>A popular strategy used by QuickDraw developers is to create a PICT wrapper around a bitmap image. With a bitmap image inside a <code>PICT</code> container, the picture acts as a transport mechanism for the image. If the bitmap is a JPEG or other image data, it’s best to create a CGImage from that data. For example, you can draw the bitmap to a bitmap graphics context and then create a CGImage by calling the function <code><a href="../../../../GraphicsImaging/Reference/CGBitmapContext/Reference/reference.html#//apple_ref/c/func/CGBitmapContextCreateImage" target="_top">CGBitmapContextCreateImage</a></code> (available starting in Mac OS X v10.4). If the bitmap is JPEG or PNG data, you can use <code><a href="../../../../GraphicsImaging/Reference/CGImage/Reference/reference.html#//apple_ref/c/func/CGImageCreateWithJPEGDataProvider" target="_top">CGImageCreateWithJPEGDataProvider</a></code> or <code><a href="../../../../GraphicsImaging/Reference/CGImage/Reference/reference.html#//apple_ref/c/func/CGImageCreateWithPNGDataProvider" target="_top">CGImageCreateWithPNGDataProvider</a></code> to create a CGImage.</p><p>PICT uses a vector-based format. If you use the <code><a href="../../../Reference/QuickDraw_Ref/DeprecationAppendix/AppendixADeprecatedAPI.html#//apple_ref/c/func/CopyBits" target="_top">CopyBits</a></code> function to create a <code>PICT</code> representation of a bitmap image by opening a QuickDraw picture, and copying an image onto itself (by specifying the same pixel map as source and destination), then you replace the vector-based format with at bit-based one. In general, the wrapper strategy in QuickDraw is not a good one. As you move your code to Quartz, you’ll want to convert PICTs to PDF documents. There is no need to create PICT wrappers to do so.</p><p>PDF is the format used to copy-and-paste between applications in Mac OS X. It’s also the metafile format for Quartz because PDF is resolution independent. Although you can use a PDF wrapper for a bitmap image (just as PICT has been used) if you wrap a PDF with a bitmap image, the bitmap is limited by resolution at which it was created.</p><p>To convert existing PICT images to PDF documents, you can use the QuickDraw QDPict API. This API is declared in the interface file <code>QDPictToCGContext.h</code> in the Application Services framework. Note that if a QuickDraw picture contains drawing operations such as <code><a href="../../../Reference/QuickDraw_Ref/DeprecationAppendix/AppendixADeprecatedAPI.html#//apple_ref/c/func/CopyBits" target="_top">CopyBits</a></code> that use transfer modes that don’t have an analogue in PDF, the PDF representation may not look exactly the same.</p><p>The QDPict API includes these data types and functions:</p><ul class="spaceabove"><li class="li"><p><code><!--a target="_top" -->QDPictRef<!--/a--></code>—An opaque type that represents picture data in the Quartz drawing environment. An instance of this type is called a QDPict picture.</p></li><li class="li"><p><code><a href="../../../Reference/QuickDraw_Ref/Reference/reference.html#//apple_ref/c/func/QDPictCreateWithProvider" target="_top">QDPictCreateWithProvider</a></code> and <code><a href="../../../Reference/QuickDraw_Ref/Reference/reference.html#//apple_ref/c/func/QDPictCreateWithURL" target="_top">QDPictCreateWithURL</a></code>,—Functions that create QDPict pictures using picture data supplied with a Quartz data provider or with a PICT file.</p></li><li class="li"><p><code><a href="../../../Reference/QuickDraw_Ref/Reference/reference.html#//apple_ref/c/func/QDPictDrawToCGContext" target="_top">QDPictDrawToCGContext</a></code>—A function that draws a QDPict picture into a Quartz graphics context. If redrawing performance is an issue, draw the PICT into a PDF graphics context, save it as a PDF document, and then use the PDF document with the Quartz routines for drawing PDF data, such as the function <code><a href="../../../../GraphicsImaging/Reference/CGContext/Reference/reference.html#//apple_ref/c/func/CGContextDrawPDFPage" target="_top">CGContextDrawPDFPage</a></code>.</p></li></ul><a name="//apple_ref/doc/uid/TP40001098-CH221-BBCDGAJG" title="Creating a QDPict Picture From Data in Memory"></a><h3>Creating a QDPict Picture From Data in Memory</h3><p>To create a QDPict picture from picture data in memory, you call <code><a href="../../../Reference/QuickDraw_Ref/Reference/reference.html#//apple_ref/c/func/QDPictCreateWithProvider" target="_top">QDPictCreateWithProvider</a></code> and supply the data using a Quartz data provider. When you create the provider, you pass it a pointer to the picture data—for example, by dereferencing a locked <code>PicHandle</code>.</p><p>When using the functions <code>QDPictCreateWithURL</code> and <code>QDPictCreateWithProvider</code>, the picture data must begin at either the first byte or the 513th byte. The picture bounds must not be an empty rectangle.</p><p><span class="content_text">Listing 4-1</span> shows how to implement this method using two custom functions—a creation function, and a release function associated with the data provider. A detailed explanation of each numbered line of code follows the listing.</p><a name="//apple_ref/doc/uid/TP40001098-CH221-BBCEIHHF" title="Listing 4-1Routines that create a QDPict picture from PICT data"></a><p class="codesample"><strong>Listing 4-1&nbsp;&nbsp;</strong>Routines that create a QDPict picture from PICT data</p><div class="codesample"><table><tr><td scope="row"><pre>QDPictRef MyCreateQDPictWithData (void *data, size_t size)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    QDPictRef picture = NULL;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    CGDataProviderRef provider =<span></span></pre></td></tr><tr><td scope="row"><pre>    CGDataProviderCreateWithData (NULL, data, size, MyReleaseProc);<span>// 1</span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if (provider != NULL)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        picture = QDPictCreateWithProvider (provider);<span>// 2</span></pre></td></tr><tr><td scope="row"><pre>        CFRelease (provider);<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    return picture;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>void MyReleaseProc (void *info, const void *data, size_t size)<span>// 3</span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    if (info != NULL) {<span></span></pre></td></tr><tr><td scope="row"><pre>        /* release private information here */<span></span></pre></td></tr><tr><td scope="row"><pre>    };<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if (data != NULL) {<span></span></pre></td></tr><tr><td scope="row"><pre>        /* release picture data here */<span></span></pre></td></tr><tr><td scope="row"><pre>    };<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>Here’s what the code does:</p><ol class="ol"><li class="li"><p>Creates a Quartz data provider for your picture data. The parameters are private information (not used here), the address of the picture data, the size of the picture data in bytes, and your custom release function.</p></li><li class="li"><p>Creates and returns a QDPict picture unless the picture data is not valid.</p></li><li class="li"><p>Handles the release of any private resources when the QDPict picture is released. This is a good place to deallocate the picture data, if you’re finished using it.</p></li></ol><a name="//apple_ref/doc/uid/TP40001098-CH221-BBCCIHGE" title="Creating a QDPict Picture From a PICT File"></a><h3>Creating a QDPict Picture From a PICT File</h3><p>To create a QDPict picture from picture data in a PICT file, you call <code><a href="../../../Reference/QuickDraw_Ref/Reference/reference.html#//apple_ref/c/func/QDPictCreateWithURL" target="_top">QDPictCreateWithURL</a></code> and specify the file location with a Core Foundation URL. <span class="content_text">Listing 4-2</span> shows how to implement this method using an opaque <code>FSRef</code> file specification. </p><a name="//apple_ref/doc/uid/TP40001098-CH221-BBCBBJCB" title="Listing 4-2A routine that creates a QDPict picture using data in a PICT file"></a><p class="codesample"><strong>Listing 4-2&nbsp;&nbsp;</strong>A routine that creates a QDPict picture using data in a PICT file</p><div class="codesample"><table><tr><td scope="row"><pre>QDPictRef MyCreateQDPictWithFSRef (const FSRef *file)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    QDPictRef picture = NULL;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    CFURLRef url = CFURLCreateFromFSRef (NULL, file);<span></span></pre></td></tr><tr><td scope="row"><pre>    if (url != NULL)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        picture = QDPictCreateWithURL (url);<span></span></pre></td></tr><tr><td scope="row"><pre>        CFRelease(url);<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    return picture;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40001098-CH221-BBCEBIAE" title="Converting QDPict Pictures Into PDF Documents"></a><h3>Converting QDPict Pictures Into PDF Documents</h3><p><span class="content_text">Listing 4-3</span> shows how to write a function that converts a QDPict picture into a PDF document stored in a file. A detailed explanation of each numbered line of code follows the listing. (Source code to create the URL and the optional PDF auxiliary information dictionary is not included here.) </p><a name="//apple_ref/doc/uid/TP40001098-CH221-BBCJAEFB" title="Listing 4-3Code that converts a picture into a single-page PDF document"></a><p class="codesample"><strong>Listing 4-3&nbsp;&nbsp;</strong>Code that converts a picture into a single-page PDF document</p><div class="codesample"><table><tr><td scope="row"><pre>void MyConvertQDPict (QDPictRef picture, CFURLRef url,<span></span></pre></td></tr><tr><td scope="row"><pre>                        CFDictionaryRef dict)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    CGContextRef context = NULL;<span></span></pre></td></tr><tr><td scope="row"><pre>    CGRect bounds = QDPictGetBounds (picture);<span></span></pre></td></tr><tr><td scope="row"><pre>    bounds.origin.x = 0;<span></span></pre></td></tr><tr><td scope="row"><pre>    bounds.origin.y = 0;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    context = CGPDFContextCreateWithURL (url, &amp;bounds, dict);<span>// 1</span></pre></td></tr><tr><td scope="row"><pre>    if (context != NULL)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        CGContextBeginPage (context, &amp;bounds);<span>// 2</span></pre></td></tr><tr><td scope="row"><pre>        (void) QDPictDrawToCGContext (context, bounds, picture);<span>// 3</span></pre></td></tr><tr><td scope="row"><pre>        CGContextEndPage (context);<span>// 4</span></pre></td></tr><tr><td scope="row"><pre>        CGContextRelease (context);<span>// 5</span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>Here’s what the code does:</p><ol class="ol"><li class="li"><p>Creates a PDF graphics context that directs the PDF content stream to a URL. If the URL is a file, the filename should end with the <code>.pdf</code> extension. The second parameter uses the picture bounds to specify the media box. The third parameter is an optional PDF auxiliary information dictionary, which contains the title and creator of the PDF document.</p></li><li class="li"><p>Begins a new page. In a PDF context, all drawing outside of an explicit page boundary is ignored. Here the page size (or media box) is the picture bounds, but you could specify any page size.</p></li><li class="li"><p>Draws the picture. The drawing rectangle is identical to the picture bounds, so there is no change of scale.</p></li><li class="li"><p>Ends the current PDF page.</p></li><li class="li"><p>Releases the PDF context, which finalizes the PDF content stream and finishes creating the file.</p></li></ol><div class="notebox"><a name="//apple_ref/doc/uid/TP40001098-CH221-DontLinkElementID_44" title="Note"></a><p><strong>Note:</strong>&nbsp; Quartz provides an opaque type called <code>CGPDFDocumentRef</code> for working with existing PDF documents. When you need to examine, draw, or print a PDF page, you create an object of this type. <code>CGPDFDocumentRef</code> isn’t needed here because the objective is to create a PDF document, not to use it.</p></div><a name="//apple_ref/doc/uid/TP40001098-CH221-BBCJDBCC" title="Scaling QDPict Pictures"></a><h3>Scaling QDPict Pictures</h3><p>When drawing a picture in a Quartz context, you have two ways to change the horizontal or vertical scale of the picture:</p><ul class="spaceabove"><li class="li"><p>Create a drawing rectangle by applying the change of scale to the bounds rectangle returned by <code><a href="../../../Reference/QuickDraw_Ref/Reference/reference.html#//apple_ref/c/func/QDPictGetBounds" target="_top">QDPictGetBounds</a></code> and pass this drawing rectangle to <code><a href="../../../Reference/QuickDraw_Ref/Reference/reference.html#//apple_ref/c/func/QDPictDrawToCGContext" target="_top">QDPictDrawToCGContext</a></code>. When the picture is rendered, patterns are not scaled along with other graphic elements. This is the same behavior as that of the <code><a href="../../../Reference/QuickDraw_Ref/DeprecationAppendix/AppendixADeprecatedAPI.html#//apple_ref/c/func/DrawPicture" target="_top">DrawPicture</a></code> function. For example, compare the original picture in <span class="content_text"><a href="tq_moving_data.html#//apple_ref/doc/uid/TP40001098-CH221-BBCDFEEH">Figure 4-1</a></span> with the scaled picture in <span class="content_text"><a href="tq_moving_data.html#//apple_ref/doc/uid/TP40001098-CH221-BBCCHIBG">Figure 4-2</a></span>. </p></li><li class="li"><p>Before drawing the picture, apply the appropriate affine transformation—for example, by calling <code><a href="../../../../GraphicsImaging/Reference/CGContext/Reference/reference.html#//apple_ref/c/func/CGContextScaleCTM" target="_top">CGContextScaleCTM</a></code>. When the picture is rendered, the entire picture is scaled, including patterns. The effect is equivalent to viewing the picture with the Preview application and clicking the Zoom In button. Compare the original in <span class="content_text"><a href="tq_moving_data.html#//apple_ref/doc/uid/TP40001098-CH221-BBCDFEEH">Figure 4-1</a></span> with the scaled picture in <span class="content_text"><a href="tq_moving_data.html#//apple_ref/doc/uid/TP40001098-CH221-BBCCCEDB">Figure 4-3</a></span> to see how this looks.</p></li></ul><p><span class="content_text">Listing 4-4</span> shows how to implement both types of scaling. A detailed explanation of each numbered line of code follows the listing.</p><a name="//apple_ref/doc/uid/TP40001098-CH221-BBCIFEDG" title="Listing 4-4A routine that uses two ways to scale a QDPict picture"></a><p class="codesample"><strong>Listing 4-4&nbsp;&nbsp;</strong>A routine that uses two ways to scale a QDPict picture</p><div class="codesample"><table><tr><td scope="row"><pre>void MyScaleQDPict (QDPictRef picture, CFURLRef url)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    float scaleXY = 2.0;<span></span></pre></td></tr><tr><td scope="row"><pre>    CGRect bounds = QDPictGetBounds (picture);<span>// 1</span></pre></td></tr><tr><td scope="row"><pre>    float w = (bounds.size.width) * scaleXY;<span></span></pre></td></tr><tr><td scope="row"><pre>    float h = (bounds.size.height) * scaleXY;<span></span></pre></td></tr><tr><td scope="row"><pre>    CGRect scaledBounds = CGRectMake (0, 0, w, h);<span></span></pre></td></tr><tr><td scope="row"><pre>    bounds.origin.x = 0;<span></span></pre></td></tr><tr><td scope="row"><pre>    bounds.origin.y = 0;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    CGContextRef context = CGPDFContextCreateWithURL (url, NULL, NULL);<span>// 2</span></pre></td></tr><tr><td scope="row"><pre>    if (context != NULL)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        /* page 1: scale without affecting patterns */<span></span></pre></td></tr><tr><td scope="row"><pre>        CGContextBeginPage (context, &amp;scaledBounds);<span></span></pre></td></tr><tr><td scope="row"><pre>        (void) QDPictDrawToCGContext (context, scaledBounds, picture);<span>// 3</span></pre></td></tr><tr><td scope="row"><pre>        CGContextEndPage (context);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        /* page 2: scale everything */<span></span></pre></td></tr><tr><td scope="row"><pre>        CGContextBeginPage (context, &amp;scaledBounds);<span></span></pre></td></tr><tr><td scope="row"><pre>        CGContextScaleCTM (context, scaleXY, scaleXY);<span>// 4</span></pre></td></tr><tr><td scope="row"><pre>        (void) QDPictDrawToCGContext (context, bounds, picture);<span>// 5</span></pre></td></tr><tr><td scope="row"><pre>        CGContextEndPage (context);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        CGContextRelease (context);<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>Here’s what the code does:</p><ol class="ol"><li class="li"><p>Creates a Quartz rectangle that represents the origin and size of the picture in user space. The resolution is 72 units per inch and the origin is (0,0).</p></li><li class="li"><p>Creates a PDF context that renders into a file. The choice of PDF is arbitrary—you can draw QDPict pictures in any type of Quartz graphics context.</p></li><li class="li"><p>Draws the picture into a scaled drawing rectangle. Patterns are not scaled along with the other graphic elements in the picture.</p></li><li class="li"><p>Applies the scaling transform to the current transformation matrix (CTM) in the graphics context. This scaling affects all subsequent drawing.</p></li><li class="li"><p>Draws the picture into a drawing rectangle with the same dimensions. This time the picture is scaled by the CTM, including patterns. </p></li></ol><br/><div><a name="//apple_ref/doc/uid/TP40001098-CH221-BBCDFEEH" title="Figure 4-1Original picture"></a><p><strong>Figure 4-1&nbsp;&nbsp;</strong>Original picture</p><img src = "../art/patterns1.gif" alt = "Original picture" width="203" height="69"></div><br/><br/><div><a name="//apple_ref/doc/uid/TP40001098-CH221-BBCCHIBG" title="Figure 4-2Scaling with a larger drawing rectangle (patterns not affected)"></a><p><strong>Figure 4-2&nbsp;&nbsp;</strong>Scaling with a larger drawing rectangle (patterns not affected)</p><img src = "../art/patterns2.gif" alt = "Scaling with a larger drawing rectangle (patterns not affected)" width="400" height="127"></div><br/><br/><div><a name="//apple_ref/doc/uid/TP40001098-CH221-BBCCCEDB" title="Figure 4-3Scaling with a matrix transform (patterns affected)"></a><p><strong>Figure 4-3&nbsp;&nbsp;</strong>Scaling with a matrix transform (patterns affected)</p><img src = "../art/patterns3.gif" alt = "Scaling with a matrix transform (patterns affected)" width="400" height="128"></div><br/><a name="//apple_ref/doc/uid/TP40001098-CH221-DontLinkElementID_12" title="Working With PICT Data on the Clipboard (Pasteboard)"></a><h2>Working With PICT Data on the Clipboard (Pasteboard)</h2><p>In Mac OS X, the Clipboard supports a rich set of data formats, including PDF. Beginning in Mac OS X version 10.3 (Panther), Carbon applications can use the Pasteboard Manager to exchange PDF data using the Clipboard or any other pasteboard. The Pasteboard Manager provides a robust data transport mechanism for user interface services such as copying, cutting, pasting, and dragging data of various flavors, and for generic interprocess communication. </p><p>A pasteboard is a global resource that uses Core Foundation data types to exchange information. Data formats called flavors are specified using uniform type identifiers. Supported flavors include plain text, rich text, PICT, and PDF. For a more detailed description of pasteboards, see <em><a href="../../Pasteboard_Prog_Guide/index.html#//apple_ref/doc/uid/TP40001439" target="_top">Pasteboard Manager Programming Guide</a></em>. For more information about uniform type identifiers, see <em><a href="../../understanding_utis/index.html#//apple_ref/doc/uid/TP40001319" target="_top">Uniform Type Identifiers Overview</a></em>. </p><p>To draw a PDF version of a QuickDraw picture and copy the PDF data to the Clipboard using the Pasteboard Manager, you need to do the following:</p><ol class="ol"><li class="li"><p>Create a Quartz data consumer to transfer the rendered output from a PDF context into a CFData object for the Pasteboard Manager.</p></li><li class="li"><p>Create a PDF context using your data consumer, draw content in this context, and release the context.</p></li><li class="li"><p>Create a <code><a href="../../../Reference/Pasteboard_Reference/Reference/reference.html#//apple_ref/c/tdef/PasteboardRef" target="_top">PasteboardRef</a></code> representation of the Clipboard, clear the current contents, and write your PDF data to it.</p></li></ol><p><span class="content_text">Listing 4-5</span> shows how to implement this procedure. A detailed explanation of each numbered line of code follows the listing. (To simplify this listing, <code>OSStatus</code> result codes are cast to <code>void</code>. If you use this sample code in an actual application, you should remove the casts and add the necessary error handling.) </p><a name="//apple_ref/doc/uid/TP40001098-CH221-BBCBEEBB" title="Listing 4-5Code that pastes the PDF representation of a picture to the Clipboard"></a><p class="codesample"><strong>Listing 4-5&nbsp;&nbsp;</strong>Code that pastes the PDF representation of a picture to the Clipboard</p><div class="codesample"><table><tr><td scope="row"><pre>size_t MyPutBytes (void* info, const void* buffer, size_t count)<span>// 1</span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    CFDataAppendBytes ((CFMutableDataRef) info, buffer, count);<span></span></pre></td></tr><tr><td scope="row"><pre>    return count;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>void MyCopyQDPictToClipboard (QDPictRef picture)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    static CGDataConsumerCallbacks callbacks = { MyPutBytes, NULL };<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    CFDataRef data = CFDataCreateMutable (kCFAllocatorDefault, 0);<span>// 2</span></pre></td></tr><tr><td scope="row"><pre>    if (data != NULL)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        CGDataConsumerRef consumer = NULL;<span></span></pre></td></tr><tr><td scope="row"><pre>        consumer = CGDataConsumerCreate ((void*) data, &amp;callbacks);<span>// 3</span></pre></td></tr><tr><td scope="row"><pre>        if (consumer != NULL)<span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>            CGContextRef context = NULL;<span></span></pre></td></tr><tr><td scope="row"><pre>            CGRect bounds = QDPictGetBounds (picture);<span></span></pre></td></tr><tr><td scope="row"><pre>            bounds.origin.x = 0;<span></span></pre></td></tr><tr><td scope="row"><pre>            bounds.origin.y = 0;<span></span></pre></td></tr><tr><td scope="row"><pre>            context = CGPDFContextCreate (consumer, &amp;bounds, NULL);<span>// 4</span></pre></td></tr><tr><td scope="row"><pre>            CGDataConsumerRelease (consumer);<span></span></pre></td></tr><tr><td scope="row"><pre>            if (context != NULL)<span></span></pre></td></tr><tr><td scope="row"><pre>            {<span></span></pre></td></tr><tr><td scope="row"><pre>                /* convert PICT to PDF */<span></span></pre></td></tr><tr><td scope="row"><pre>                CGContextBeginPage (context, &amp;bounds);<span></span></pre></td></tr><tr><td scope="row"><pre>                (void) QDPictDrawToCGContext (context, bounds, picture);<span>// 5</span></pre></td></tr><tr><td scope="row"><pre>                CGContextEndPage (context);<span></span></pre></td></tr><tr><td scope="row"><pre>                CGContextRelease (context);<span>// 6</span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>                /* copy PDF to clipboard */<span></span></pre></td></tr><tr><td scope="row"><pre>                PasteboardRef clipboard = NULL;<span></span></pre></td></tr><tr><td scope="row"><pre>                (void) PasteboardCreate (kPasteboardClipboard, &amp;clipboard);<span>// 7</span></pre></td></tr><tr><td scope="row"><pre>                (void) PasteboardClear (clipboard);<span>// 8</span></pre></td></tr><tr><td scope="row"><pre>                (void) PasteboardPutItemFlavor (clipboard, <span>// 9</span></pre></td></tr><tr><td scope="row"><pre>                        (PasteboardItemID) 1, kUTTypePDF,<span></span></pre></td></tr><tr><td scope="row"><pre>                        data, kPasteboardFlavorNoFlags);<span></span></pre></td></tr><tr><td scope="row"><pre>                CFRelease (clipboard);<span></span></pre></td></tr><tr><td scope="row"><pre>            }<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>    CFRelease (data); // You should ensure that data is not NULL.<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div>	<p>Here’s what the code does:</p><ol class="ol"><li class="li"><p>Implements a custom callback function to handle the PDF content stream coming from a Quartz PDF context. This function copies the PDF bytes from a Quartz-supplied buffer into a mutable <code><a href="../../../../CoreFoundation/Reference/CFDataRef/Reference/reference.html#//apple_ref/c/tdef/CFDataRef" target="_top">CFDataRef</a></code> object.</p></li><li class="li"><p>Creates a mutable <code><a href="../../../../CoreFoundation/Reference/CFDataRef/Reference/reference.html#//apple_ref/c/tdef/CFDataRef" target="_top">CFDataRef</a></code> object for the PDF data.</p></li><li class="li"><p>Creates a Quartz data consumer that uses the custom callback.</p></li><li class="li"><p>Creates a PDF context to draw the picture, using the data consumer.</p></li><li class="li"><p>Draws the QDPict picture in the PDF context.</p></li><li class="li"><p>Releases the PDF context, which “finalizes” the PDF data.</p></li><li class="li"><p>Creates an object of type <code><a href="../../../Reference/Pasteboard_Reference/Reference/reference.html#//apple_ref/c/tdef/PasteboardRef" target="_top">PasteboardRef</a></code> that serves as a data transport channel for a new or existing pasteboard—in this case, the Clipboard.</p></li><li class="li"><p>Clears the Clipboard of its current contents and makes it mutable.</p></li><li class="li"><p>Adds the PDF data to the Clipboard. Since there’s only one data item, the item identifier is <code>1</code>. The uniform type identifier for PDF is declared in the interface file <code>UTCoreTypes.h</code> inside the Application Services framework.</p></li></ol><p>Now that you’ve seen how to copy PICT data to the pasteboard, see <span class="content_text">Listing 4-6</span>, which contains a routine that you can use to copy any Quartz drawing to the pasteboard. This routine is from the CarbonSketch sample application. The routine <code>AddWindowContextToPasteboardAsPDF</code> takes two parameters: a pasteboard reference and an application-defined data type that tracks various attributes of the drawing document, such as its size and content.</p><a name="//apple_ref/doc/uid/TP40001098-CH221-BBCEJAFB" title="Listing 4-6A routine that copies window content to the pasteboard (Clipboard)"></a><p class="codesample"><strong>Listing 4-6&nbsp;&nbsp;</strong>A routine that copies window content to the pasteboard (Clipboard)</p><div class="codesample"><table><tr><td scope="row"><pre>static OSStatus AddWindowContentToPasteboardAsPDF (<span></span></pre></td></tr><tr><td scope="row"><pre>                        PasteboardRef pasteboard, const DocStorage *docStP)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    OSStatus    err     = noErr;<span></span></pre></td></tr><tr><td scope="row"><pre>    CGRect  docRect = CGRectMake (0, 0, docStP->docSize.h,<span></span></pre></td></tr><tr><td scope="row"><pre>                                    docStP->docSize.v);<span></span></pre></td></tr><tr><td scope="row"><pre>    CFDataRef       pdfData = CFDataCreateMutable (kCFAllocatorDefault, 0);<span></span></pre></td></tr><tr><td scope="row"><pre>    CGContextRef            pdfContext;<span></span></pre></td></tr><tr><td scope="row"><pre>    CGDataConsumerRef       consumer;<span></span></pre></td></tr><tr><td scope="row"><pre>    CGDataConsumerCallbacks cfDataCallbacks = {MyCFDataPutBytes,<span></span></pre></td></tr><tr><td scope="row"><pre>                                         MyCFDataRelease };<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    err = PasteboardClear (pasteboard);<span>// 1</span></pre></td></tr><tr><td scope="row"><pre>    require_noerr err, PasteboardClear_FAILED);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    consumer = CGDataConsumerCreate ((void*)pdfData, &amp;cfDataCallbacks);<span>// 2</span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    pdfContext = CGPDFContextCreate (consumer, &amp;docRect, NULL);<span>// 3</span></pre></td></tr><tr><td scope="row"><pre>    require(pdfContext != NULL, CGPDFContextCreate_FAILED);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    MyDrawIntoPDFPage (pdfContext, docRect, docStP, 1);<span>// 4</span></pre></td></tr><tr><td scope="row"><pre>    CGContextRelease (pdfContext);<span>// 5</span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    err = PasteboardPutItemFlavor( pasteboard, (PasteboardItemID)1,<span>// 6</span></pre></td></tr><tr><td scope="row"><pre>                        kUTTypePDF, pdfData, kPasteboardFlavorNoFlags );<span></span></pre></td></tr><tr><td scope="row"><pre>    require_noerr( err, PasteboardPutItemFlavor_FAILED );<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>CGPDFContextCreate_FAILED:<span></span></pre></td></tr><tr><td scope="row"><pre>PasteboardPutItemFlavor_FAILED:<span></span></pre></td></tr><tr><td scope="row"><pre>    CGDataConsumerRelease (consumer);   <span>// 7</span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>PasteboardClear_FAILED:<span></span></pre></td></tr><tr><td scope="row"><pre>    return err;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>Here’s what the code does:</p><ol class="ol"><li class="li"><p>Clears the pasteboard of its contents so that this application can own it and add its own data.</p></li><li class="li"><p>Creates a data consumer to receive the data from the application. </p></li><li class="li"><p>Creates a PDF graphics context, providing the data consumer, the rectangle that defines the size and location of the PDF page, and <code>NULL</code> for the auxiliary dictionary. The entire PDF page is supplied here, but in your application you restrict the data you paste to the contents of the selection made by the user. In this example, there isn’t any additional information to be used by the PDF context when generating the PDF, so the auxiliary dictionary is <code>NULL</code>.</p></li><li class="li"><p>Calls an application-defined function to draw the actual data into the PDF graphics context. You need to supply your own drawing function here.</p></li><li class="li"><p>Releases the PDF graphics context, which finalizes the PDF data.</p></li><li class="li"><p>Puts the PDF data (supplied by the data consumer) on the pasteboard. The <code><a href="../../../Reference/Pasteboard_Reference/Reference/reference.html#//apple_ref/c/func/PasteboardPutItemFlavor" target="_top">PasteboardPutItemFlavor</a></code> function takes the pasteboard cleared earlier, the identifier for the item to add flavor data for, a flavor type, the data to add, and a bit field of flags for the specified flavor.</p></li><li class="li"><p>Releases the data consumer.</p></li></ol><a name="//apple_ref/doc/uid/TP40001098-CH221-DontLinkElementID_13" title="Copying PDF Data From the Clipboard (Pasteboard)"></a><h2>Copying PDF Data From the Clipboard (Pasteboard)</h2><p>To bring PDF data back into your application you retrieve the PDF data from the pasteboard, create a Quartz data provider that copies the PDF data into a Quartz buffer, and use the provider to create a <code><a href="../../../../GraphicsImaging/Reference/CGPDFDocument/Reference/reference.html#//apple_ref/c/tdef/CGPDFDocumentRef" target="_top">CGPDFDocumentRef</a></code> object. You can call <code><a href="../../../../GraphicsImaging/Reference/CGContext/Reference/reference.html#//apple_ref/c/func/CGContextDrawPDFDocument" target="_top">CGContextDrawPDFDocument</a></code> to draw the PDF version of your picture in any graphics context. The <code>PasteboardContainsPDF</code> routine in <span class="content_text">Listing 4-7</span> is taken from the CarbonSketch sample application.</p><p>The routine checks whether the pasteboard provided to it contains PDF data. If it does, the PDF data is returned as CFData in the <code>pdfData</code> parameter. A detailed explanation for each numbered line of code appears following the listing.</p><a name="//apple_ref/doc/uid/TP40001098-CH221-BBCEIJAG" title="Listing 4-7A routine that gets PDF data from the pasteboard (Clipboard)"></a><p class="codesample"><strong>Listing 4-7&nbsp;&nbsp;</strong>A routine that gets PDF data from the pasteboard (Clipboard)</p><div class="codesample"><table><tr><td scope="row"><pre>static Boolean PasteboardContainsPDF (PasteboardRef inPasteboard,<span></span></pre></td></tr><tr><td scope="row"><pre>                                 CFDataRef* pdfData)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    Boolean             gotPDF      = false;<span></span></pre></td></tr><tr><td scope="row"><pre>    OSStatus            err         = noErr;<span></span></pre></td></tr><tr><td scope="row"><pre>    ItemCount           itemCount;<span></span></pre></td></tr><tr><td scope="row"><pre>    UInt32              itemIndex;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    err = PasteboardGetItemCount (inPasteboard, &amp;itemCount);<span>// 1</span></pre></td></tr><tr><td scope="row"><pre>    require_noerr(err, PasteboardGetItemCount_FAILED);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    for (itemIndex = 1; itemIndex &lt;= itemCount; ++itemIndex)<span>// 2</span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        PasteboardItemID    itemID;<span></span></pre></td></tr><tr><td scope="row"><pre>        CFArrayRef          flavorTypeArray;<span></span></pre></td></tr><tr><td scope="row"><pre>        CFIndex             flavorCount;<span></span></pre></td></tr><tr><td scope="row"><pre>        CFIndex             flavorIndex;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        err = PasteboardGetItemIdentifier (inPasteboard, <span>// 3</span></pre></td></tr><tr><td scope="row"><pre>                            itemIndex, &amp;itemID );<span></span></pre></td></tr><tr><td scope="row"><pre>        require_noerr( err, PasteboardGetItemIdentifier_FAILED );<span></span></pre></td></tr><tr><td scope="row"><pre>        err = PasteboardCopyItemFlavors (inPasteboard, itemID,<span>// 4</span></pre></td></tr><tr><td scope="row"><pre>                                 &amp;flavorTypeArray );<span></span></pre></td></tr><tr><td scope="row"><pre>        require_noerr( err, PasteboardCopyItemFlavors_FAILED );<span></span></pre></td></tr><tr><td scope="row"><pre>        flavorCount = CFArrayGetCount( flavorTypeArray );<span>// 5</span></pre></td></tr><tr><td scope="row"><pre>        for (flavorIndex = 0; flavorIndex &lt; flavorCount; ++flavorIndex)<span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>            CFStringRef             flavorType;<span></span></pre></td></tr><tr><td scope="row"><pre>            CFComparisonResult      comparisonResult;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>            flavorType = (CFStringRef)CFArrayGetValueAtIndex (<span>// 6</span></pre></td></tr><tr><td scope="row"><pre>                                         flavorTypeArray, flavorIndex );<span></span></pre></td></tr><tr><td scope="row"><pre>            comparisonResult = CFStringCompare(flavorType,<span>// 7</span></pre></td></tr><tr><td scope="row"><pre>                                        kUTTypePDF, 0);<span></span></pre></td></tr><tr><td scope="row"><pre>            if (comparisonResult == kCFCompareEqualTo)<span></span></pre></td></tr><tr><td scope="row"><pre>            {<span></span></pre></td></tr><tr><td scope="row"><pre>                if (pdfData != NULL)<span></span></pre></td></tr><tr><td scope="row"><pre>                {<span></span></pre></td></tr><tr><td scope="row"><pre>                    err = PasteboardCopyItemFlavorData( inPasteboard,<span>// 8</span></pre></td></tr><tr><td scope="row"><pre>                                 itemID, flavorType, pdfData );<span></span></pre></td></tr><tr><td scope="row"><pre>                    require_noerr (err,<span></span></pre></td></tr><tr><td scope="row"><pre>                            PasteboardCopyItemFlavorData_FAILED );<span></span></pre></td></tr><tr><td scope="row"><pre>                }<span></span></pre></td></tr><tr><td scope="row"><pre>                gotPDF = true;<span>// 9</span></pre></td></tr><tr><td scope="row"><pre>                break;<span></span></pre></td></tr><tr><td scope="row"><pre>            }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>PasteboardCopyItemFlavorData_FAILED:<span></span></pre></td></tr><tr><td scope="row"><pre>PasteboardGetItemFlavorFlags_FAILED:<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>        CFRelease(flavorTypeArray);<span>// 10</span></pre></td></tr><tr><td scope="row"><pre>PasteboardCopyItemFlavors_FAILED:<span></span></pre></td></tr><tr><td scope="row"><pre>PasteboardGetItemIdentifier_FAILED:<span></span></pre></td></tr><tr><td scope="row"><pre>        ;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>PasteboardGetItemCount_FAILED:<span></span></pre></td></tr><tr><td scope="row"><pre>    return gotPDF;<span>// 11</span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>Here’s what that code does:</p><ol class="ol"><li class="li"><p>Gets the number of items on the pasteboard. </p></li><li class="li"><p>Iterates through each item on the pasteboard.</p></li><li class="li"><p>Gets the unique identifier for this pasteboard item.</p></li><li class="li"><p>Copies the flavor types for that item ID into an array. Note that the flavor type array is a <code>CFArrayType</code> that you need to release later.</p></li><li class="li"><p>Gets a count of the flavor types in the array. You need to iterate through these to find the PDF flavor.</p></li><li class="li"><p>Gets the flavor type stored in a specific location in the array.</p></li><li class="li"><p>Checks for the PDF flavor type. Note that in Mac OS X v10.4 you should use the universal type <code>kUTTypePDF</code>, as shown here, instead of <code>CFSTR('com.adobe.pdf')</code>. </p></li><li class="li"><p>Copies the PDF data, if any is found.</p></li><li class="li"><p>Sets the <code>gotPDF</code> flag to <code>true</code>.</p></li><li class="li"><p>Releases the array.</p></li><li class="li"><p>Returns <code>true</code> if successful.</p></li></ol><p>After you get the PDF data from the pasteboard, you can draw it in your application, using a routine similar to the <code>DrawPDFData</code> routine shown in <span class="content_text">Listing 4-8</span>. The routine takes a <code>CFDataRef</code> data type (which is what you get from the routine in <span class="content_text"><a href="tq_moving_data.html#//apple_ref/doc/uid/TP40001098-CH221-BBCEIJAG">Listing 4-7</a></span> when you copy data from the pasteboard), a graphics context, and a destination rectangle. A detailed explanation for each numbered line of code appears following the listing.</p><a name="//apple_ref/doc/uid/TP40001098-CH221-BBCEAICD" title="Listing 4-8A routine that draws PDF data "></a><p class="codesample"><strong>Listing 4-8&nbsp;&nbsp;</strong>A routine that draws PDF data </p><div class="codesample"><table><tr><td scope="row"><pre>static void MyPDFDataRelease (void *info, const void *data, size_t size)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    if(info != NULL)<span></span></pre></td></tr><tr><td scope="row"><pre>        CFRelease((CFDataRef)info);<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>static void DrawPDFData (CGContextRef ctx, CFDataRef pdfData,<span></span></pre></td></tr><tr><td scope="row"><pre>                            CGRect dstRect)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    CGDataProviderRef   provider;<span></span></pre></td></tr><tr><td scope="row"><pre>    CGPDFDocumentRef    document;<span></span></pre></td></tr><tr><td scope="row"><pre>    CGPDFPageRef        page;<span></span></pre></td></tr><tr><td scope="row"><pre>    CGRect              pageSize;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    CFRetain (pdfData);<span></span></pre></td></tr><tr><td scope="row"><pre>    provider = CGDataProviderCreateWithData (pdfData, <span>// 1</span></pre></td></tr><tr><td scope="row"><pre>                        CFDataGetBytePtr(pdfData),<span></span></pre></td></tr><tr><td scope="row"><pre>                        CFDataGetLength(pdfData), MyPDFDataRelease);<span></span></pre></td></tr><tr><td scope="row"><pre>    document = CGPDFDocumentCreateWithProvider (provider);<span>// 2</span></pre></td></tr><tr><td scope="row"><pre>    CFRelease(provider);<span>// 3</span></pre></td></tr><tr><td scope="row"><pre>    page = CGPDFDocumentGetPage (document, 1);<span>// 4</span></pre></td></tr><tr><td scope="row"><pre>    pageSize = CGPDFPageGetBoxRect (page, kCGPDFMediaBox);<span>// 5</span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    CGContextSaveGState(ctx);<span>// 6</span></pre></td></tr><tr><td scope="row"><pre>    MySetupTransform(ctx, pageSize, dstRect); <span>// 7</span></pre></td></tr><tr><td scope="row"><pre>// Scale pdf page into dstRect, if the pdf is too big<span></span></pre></td></tr><tr><td scope="row"><pre>    CGContextDrawPDFPage (ctx, page);<span>// 8</span></pre></td></tr><tr><td scope="row"><pre>    CGContextRestoreGState(ctx);<span>// 9</span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    CFRelease(document);<span>// 10</span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>Here’s what the code does:</p><ol class="ol"><li class="li"><p>Creates a data provider to read PDF data provided to your application from a <code>CGDataRef</code> data source. Note that you need to supply a release function for Quartz to call when it frees the data provider.</p></li><li class="li"><p>Creates a CGPDFDocument object using data supplied by the data provider you just created.</p></li><li class="li"><p>Releases the data provider. You should release a data provider immediately after using it to create the CGPDFDocument object.</p></li><li class="li"><p>Gets the first page of the newly created document. </p></li><li class="li"><p>Gets the media box rectangle for the PDF. You need this to determine how to scale the content later.</p></li><li class="li"><p>Saves the graphics state so that you can later restore it.</p></li><li class="li"><p>Calls an application-defined routine to set a transform, if necessary. This routine (which you would need to write) determines whether the PDF is too big to fit in the destination rectangle, and transforms the context appropriately. </p></li><li class="li"><p>Draws the PDF document into the graphics context that is passed to the <code>DrawPDFData</code> routine.</p></li><li class="li"><p>Restores the graphics state.</p></li><li class="li"><p>Releases the PDF document object.</p></li></ol><a name="//apple_ref/doc/uid/TP40001098-CH221-DontLinkElementID_14" title="Relevant Resources"></a><h2>Relevant Resources</h2><p>See these reference documents:</p><ul class="ul"><li class="li"><p><em><a href="../../../../GraphicsImaging/Reference/CGContext/index.html#//apple_ref/doc/uid/TP30000950" target="_top">CGContext Reference</a></em></p></li><li class="li"><p><em><a href="../../../../GraphicsImaging/Reference/CGImage/index.html#//apple_ref/doc/uid/TP30000956" target="_top">CGImage Reference</a></em></p></li><li class="li"><p><em><a href="../../../../GraphicsImaging/Reference/CGPDFDocument/index.html#//apple_ref/doc/uid/TP30000958" target="_top">CGPDFDocument Reference</a></em></p></li><li class="li"><p><em><a href="../../../Reference/Pasteboard_Reference/index.html#//apple_ref/doc/uid/TP40001413" target="_top">Pasteboard Manager Reference</a></em></p></li><li class="li"><p><em><a href="../../../Reference/QuickDraw_Ref/index.html#//apple_ref/doc/uid/TP30000975" target="_top">QuickDraw Reference</a></em>, describes the <code><a href="../../../Reference/QuickDraw_Ref/Reference/reference.html#//apple_ref/c/tdef/QDPictRef" target="_top">QDPictRef</a></code> data type that represents a QuickDraw picture in the Quartz graphics environment.</p></li></ul><p>For comprehensive information about using pasteboards in Carbon applications, see <em><a href="../../Pasteboard_Prog_Guide/index.html#//apple_ref/doc/uid/TP40001439" target="_top">Pasteboard Manager Programming Guide</a></em>.</p><p>For more information about uniform type identifiers, see the document <em><a href="../../understanding_utis/index.html#//apple_ref/doc/uid/TP40001319" target="_top">Uniform Type Identifiers Overview</a></em>.</p><p>To learn more about drawing QDPict pictures in a Carbon application, see the project example <em><a href="../../../../../samplecode/CGDrawPicture/index.html#//apple_ref/doc/uid/DTS10000490" target="_top">CGDrawPicture</a></em> in the <span class="content_text"><a href="../../../../../samplecode/GraphicsImaging/idxQuartz-date.html#//apple_ref/doc/uid/TP30000925-TP30000424-TP30000559" target="_top">Graphics &amp; Imaging Quartz Sample Code Library</a></span>. </p>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../tq_color/tq_color.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../tq_image_data/tq_image_data.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2004, 2006 Apple Computer, Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2006-09-05<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Carbon/Conceptual/QuickDrawToQuartz2D/tq_moving_data/tq_moving_data.html%3Fid%3DTP40001098-5.2&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Carbon/Conceptual/QuickDrawToQuartz2D/tq_moving_data/tq_moving_data.html%3Fid%3DTP40001098-5.2&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Carbon/Conceptual/QuickDrawToQuartz2D/tq_moving_data/tq_moving_data.html%3Fid%3DTP40001098-5.2&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>