<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>Apple Filing Protocol Programming Guide: Concepts</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Concepts"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP40000854-CH3" title="Concepts"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../index.html#//apple_ref/doc/uid/TP30000440-TP30000429" target="_top">Networking</a> &gt; <a href="../../../MacOSXServer-date.html#//apple_ref/doc/uid/TP30000440-TP30000429-TP30000542" target="_top">Mac OS X Server</a> &gt; <a href="../Introduction/Introduction.html#//apple_ref/doc/uid/TP40000854-CH1-DontLinkElementID_18">Apple Filing Protocol Programming Guide</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../Introduction/Introduction.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../UsingLoginCommands/UsingLoginCommands.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP40000854-CH3-SW1" title="Concepts"></a><h1>Concepts</h1>
<!-- This template is being used for both PDF and HTML. -->

    
    <h4>In this section:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="Concepts.html#//apple_ref/doc/uid/TP40000854-CH3-CIFEEJAH">File Access Model</a>
				
			<br/>
			
        
			
			
				<a href="Concepts.html#//apple_ref/doc/uid/TP40000854-CH3-CIFBBCCE">File System Structure</a>
				
			<br/>
			
        
			
			
				<a href="Concepts.html#//apple_ref/doc/uid/TP40000854-CH3-CHBBGAJA">Designating a Path to a CNode</a>
				
			<br/>
			
        
			
			
				<a href="Concepts.html#//apple_ref/doc/uid/TP40000854-CH3-CHBGCJDA">AFP Login</a>
				
			<br/>
			
        
			
			
				<a href="Concepts.html#//apple_ref/doc/uid/TP40000854-CH3-CHBICDAH">File Server Security</a>
				
			<br/>
			
        
			
			
				<a href="Concepts.html#//apple_ref/doc/uid/TP40000854-CH3-CHBBGICJ">File Sharing Modes</a>
				
			<br/>
			
        
			
			
				<a href="Concepts.html#//apple_ref/doc/uid/TP40000854-CH3-CHDGEHBB">Access Control Lists</a>
				
			<br/>
			
        
			
			
				<a href="Concepts.html#//apple_ref/doc/uid/TP40000854-CH3-CHBGJDCE">Desktop Database</a>
				
			<br/>
			
        
			
			
				<a href="Concepts.html#//apple_ref/doc/uid/TP40000854-CH3-CHBBEJDF">Character Encoding</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP40000854-CH3-48750" title="File Access Model"></a><a name="//apple_ref/doc/uid/TP40000854-CH3-CIFEEJAH" title="File Access Model"></a><h2>File Access Model</h2><p>This section introduces the file access model used by AFP to enable file sharing and discusses the components of AFP software.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40000854-CH3-DontLinkElementID_4" title="Note"></a><p><strong>Note:</strong>&nbsp;All values exchanged between an AFP client and an AFP server are sent over the network in network byte order.</p></div><br/><div><a name="//apple_ref/doc/uid/TP40000854-CH3-48838" title="Figure 1-1AFP file access model"></a><a name="//apple_ref/doc/uid/TP40000854-CH3-CHBBJJCH" title="Figure 1-1AFP file access model"></a><p><strong>Figure 1-1&nbsp;&nbsp;</strong>AFP file access model</p><img src = "../Art/afp_l_02.gif" alt = "AFP file access model" width="509" height="258"></div><br/><p>A program running in a local computer requests and manipulates files by using that computer’s native file system commands. These commands manipulate files on disk or other memory resource that is physically connected to the local computer. Through AFP, a program can use the same native file system commands to manipulate files on a shared resource that resides on a remote computer (for example, a file server).</p><p>A program running on the local computer sends a command to the native file system. A data structure in local memory indicates whether the volume is managed by the native file system or by some external file system. The native file system discovers whether the requested file resides locally or remotely by looking at this data structure. If the data structure indicates an external file system, the native file system routes the command to the AFP translator.</p><p>The translator, as its name implies, translates the native commands into AFP commands and sends them through to the file server that manages the remote resource. The AFP translator is not defined in the AFP specification; it is up to the applications programmer to design it.</p><p>A program running on the local computer may also need to send AFP commands for which no equivalent command exists in the native file system. In this case, the AFP command is sent directly to the desired external file system, as shown in <span class="content_text">Figure 1-1</span>. For example, user authentication might have to be handled through an interface written for that purpose.</p><p>AFP supports computers using Mac OS and personal computers using MS-DOS. AFP can be extended to support additional types of computers. Any implementation of AFP must take into account the capabilities of the networked computer’s native file system and simulate its functionality in the shared environment. In other words, the shared file system should duplicate the characteristics of a local computer’s file system. Simulating the functionality of each local computer’s native file system becomes increasingly complex as different computer types share the same file server. Because each computer type has different characteristics in the way it manipulates files, the shared file system needs to possess the combined capabilities of all computers on the same network.</p><p>Three system components make up AFP:</p><ul class="ul"><li class="li"><p>a file system structure, which is made up of resources (such as file servers, volumes, directories, files, and forks) that are addressable through the network. These resources are called AFP-file-system-visible entities. AFP specifies the relationship between these entities. For example, one directory can be the parent of another. For descriptions of AFP-file-system-visible entities, see <span class="content_text">“File System Structure”</span> later in this chapter.</p></li><li class="li"><p>AFP commands, which are the commands the local computer uses to manipulate the AFP file system structure. As mentioned earlier, the translator sends file system commands to the file server in the form of AFP commands, or the application running on the local computer can make AFP commands directly. Each AFP command is described in detail in the “Tasks” section of this document.</p></li><li class="li"><p>algorithms associated with the commands, which specify the actions performed by the AFP commands.</p></li></ul><p>Although this chapter distinguishes between local computers and file servers, AFP can support these two functions within the same node. However, AFP does not solve the concurrency problems that can arise when a computer is both an AFP client and an AFP server. The software on such combined nodes must be carefully designed to avoid potential conflicts.</p><p>AFP does not provide commands that support administration of the file server. Administrative functions, such as registering users and changing passwords, must be handled by separate network-administration software. Additional software must also be provided to add, remove, and find servers within the network.</p><a name="//apple_ref/doc/uid/TP40000854-CH3-49061" title="File System Structure"></a><a name="//apple_ref/doc/uid/TP40000854-CH3-CIFBBCCE" title="File System Structure"></a><h2>File System Structure</h2><p>This section describes the AFP file system structure and the parameters associated with its AFP-file-system-visible entities. These entities include the file server, its volumes, directories (“folders” in Mac OS terminology), files. and file forks. This section also describes the tree structure, called the volume catalog, which is a description of the relationships between directories and files.</p><p>By sending AFP commands, the AFP client can</p><ul class="ul"><li class="li"><p>obtain information about the file server and other parts of the file system structure</p></li><li class="li"><p>modify information that is obtained from a file server</p></li><li class="li"><p>create and delete files and directories</p></li><li class="li"><p>retrieve and store information within individual files</p></li></ul><p>The following sections describe the file system structure’s AFP-file-system-visible entities.</p><a name="//apple_ref/doc/uid/TP40000854-CH3-49283" title="File Server"></a><a name="//apple_ref/doc/uid/TP40000854-CH3-CHBHGGJJ" title="File Server"></a><h3>File Server</h3><p>A file server is a computer with at least one large-capacity disk that allows other computers on the network to share information stored in it. AFP imposes no limit on the number of shared disks. Each disk attached to a file server usually contains one volume, although the disk may be subdivided into multiple volumes. Each volume appears as a separate entity to the AFP client.</p><p>A file server has a unique name and other identifying parameters. These parameters identify the server’s machine type and number of attached volumes, as well as the AFP versions user authentication methods (UAMs) that the server supports. AFP file server parameters are listed <span class="content_text">Table 1-1</span>.</p><a name="//apple_ref/doc/uid/TP40000854-CH3-49337" title="Table 1-1File server parameters"></a><a name="//apple_ref/doc/uid/TP40000854-CH3-CHBIBJDA" title="Table 1-1File server parameters"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 1-1&nbsp;&nbsp;</strong>File server parameters</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Parameter</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Description</p></th></tr><tr><td  scope="row"><p>Server name</p></td><td ><p>A string in Pascal format of up to 32 characters.</p></td></tr><tr><td  scope="row"><p>Server machine type</p></td><td ><p>A string in Pascal format of up to 16 characters that describes the file server’s hardware and software but has no significance to AFP.</p></td></tr><tr><td  scope="row"><p>Number of volumes</p></td><td ><p>A two-byte integer.</p></td></tr><tr><td  scope="row"><p>AFP version strings</p></td><td ><p>One or more strings of up to 16 characters each. For more information, see <span class="content_text"><a href="Concepts.html#//apple_ref/doc/uid/TP40000854-CH3-59626">Table 1-12</a></span>.</p></td></tr><tr><td  scope="row"><p>UAM strings</p></td><td ><p>One or more strings of up to 16 characters each. For more information, see <span class="content_text"><a href="Concepts.html#//apple_ref/doc/uid/TP40000854-CH3-59715">Table 1-13</a></span>.</p></td></tr><tr><td  scope="row"><p>Server icon</p></td><td ><p>A optional value of 256 bytes that is used to customize the appearance of server volumes on the Mac OS Desktop. It consists of a 32-by-32 bit (128 bytes) icon bitmap followed by a 32-by-32 bit (128 bytes) icon mask. The mask usually consists of the icon’s outline filled with black (bits that are set). For more information about icons, refer to <em>Inside Mac OS X</em>.</p></td></tr><tr><td  scope="row"><p>Server signature</p></td><td ><p>A 16-byte value that uniquely identifies a server used to prevent an AFP client from logging on to the same server twice.</p></td></tr></table></div><a name="//apple_ref/doc/uid/TP40000854-CH3-49466" title="Volumes"></a><a name="//apple_ref/doc/uid/TP40000854-CH3-CHBIFGEG" title="Volumes"></a><h3>Volumes</h3><p>A file server can make one or more volumes visible to AFP clients. Each volume has parameters associated with it, as listed in <span class="content_text"><a href="Concepts.html#//apple_ref/doc/uid/TP40000854-CH3-49563">Table 1-2</a></span>. To provide security at the volume level, the server can maintain an optional password parameter for any volume.</p><a name="//apple_ref/doc/uid/TP40000854-CH3-49563" title="Table 1-2Bit definitions for the Volume parameter "></a><a name="//apple_ref/doc/uid/TP40000854-CH3-CHBHEIAD" title="Table 1-2Bit definitions for the Volume parameter "></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 1-2&nbsp;&nbsp;</strong>Bit definitions for the Volume parameter </caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Constant and bit position</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Parameter size</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Description</p></th></tr><tr><td  scope="row"><p><code>kFPVolAttributeBit</code> (bit 0)</p></td><td ><p>Short</p></td><td ><p>Volume attributes. See <span class="content_text"><a href="Concepts.html#//apple_ref/doc/uid/TP40000854-CH3-49913">Table 1-3</a></span> for details.</p></td></tr><tr><td  scope="row"><p><code>kFPVolSignatureBit</code> (bit 1)</p></td><td ><p>Two bytes</p></td><td ><p>The volume signature identifies the volume type (flat, fixed Directory ID, or variable Directory ID). For details, see the section <span class="content_text"><a href="Concepts.html#//apple_ref/doc/uid/TP40000854-CH3-50143">“Volume Types.”</a></span></p></td></tr><tr><td  scope="row"><p><code>kFPVolCreateDateBit</code> (bit 2)</p></td><td ><p>Four bytes</p></td><td ><p>The date the server created the volume. This parameter cannot be modified by an AFP client.</p></td></tr><tr><td  scope="row"><p><code>kFPVolModDateBit</code> (bit 3)</p></td><td ><p>Four bytes</p></td><td ><p>Updated by the server each time anything on the volume is modified. This parameter cannot be modified by an AFP client.</p></td></tr><tr><td  scope="row"><p><code>kFPVolBackupDateBit</code> (bit 4)</p></td><td ><p>Four bytes</p></td><td ><p>Set by a backup program each time the volume’s contents are backed up. When a volume is created, the Backup Date is set to 0x80000000 (the earliest representable date-time value).</p></td></tr><tr><td  scope="row"><p><code>kFPVolIDBit</code> (bit 5)</p></td><td ><p>Two bytes</p></td><td ><p>For each session between the server and an AFP client, the server assigns a Volume ID to each of its volumes. This value is unique among the volumes of a given server for that session.</p></td></tr><tr><td  scope="row"><p><code>kFPVolBytesFreeBit</code> (bit 6)</p></td><td ><p>Four unsigned bytes</p></td><td ><p>Total bytes free on volumes less than 4 GB in size. If a volume is more than 4 GB, the Bytes Free parameters may not reflect the actual value. In any case, Extended Bytes Total always reflects the correct value. This value is maintained by the server and cannot be modified by an AFP client.</p></td></tr><tr><td  scope="row"><p><code>kFPVolBytesTotalBit</code> (bit 7)</p></td><td ><p>Four unsigned bytes</p></td><td ><p>Total bytes on volumes less than 4 GB in size. If a volume is more than 4 GB, the Bytes Total parameter may not reflect the actual value. In any case, Extended Bytes Total always reflects the correct value. This value is maintained by the server and cannot be modified by an AFP client.</p></td></tr><tr><td  scope="row"><p><code>kFPVolNameBit</code> (bit 8)</p></td><td ><p>A string of up to 2 7 characters</p></td><td ><p>The volume name identifies a server volume to an AFP client user, so it must be unique among all volumes managed by the server. All eight-bit ASCII characters, except null (0x00) and colon (0x3A), are permitted in a volume name. This name is not used directly to specify files and directories on the volume. Instead, the AFP client sends an AFP command to obtain a particular volume identifier, which it then uses when sending subsequent AFP commands. For more information, see <span class="content_text"><a href="Concepts.html#//apple_ref/doc/uid/TP40000854-CH3-53319">“Designating a Path to a CNode.”</a></span></p></td></tr><tr><td  scope="row"><p><code>kFPVolExtBytesFreeBit</code> (bit 9)</p></td><td ><p>Eight unsigned bytes</p></td><td ><p>Total bytes free on this volume. This value is maintained by the server and cannot be modified by an AFP client</p></td></tr><tr><td  scope="row"><p><code>kFPVolExtBytesTotalBit</code> (bit 10)</p></td><td ><p>Eight unsigned bytes</p></td><td ><p>Total bytes on this volume. This value is maintained by the server and cannot be modified by an AFP client.</p></td></tr><tr><td  scope="row"><p><code>kFPVolBlockSizeBit</code> (bit 11)</p></td><td ><p>Four bytes</p></td><td ><p>The block allocation size.</p></td></tr></table></div><p>The Attributes parameter for volumes provides additional information about the volume. <span class="content_text">Table 1-3</span> lists the bit definitions for the Attributes parameter for volumes.</p><a name="//apple_ref/doc/uid/TP40000854-CH3-49913" title="Table 1-3Bit definitions for the Volume Attributes parameter "></a><a name="//apple_ref/doc/uid/TP40000854-CH3-CHBCGIDE" title="Table 1-3Bit definitions for the Volume Attributes parameter "></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 1-3&nbsp;&nbsp;</strong>Bit definitions for the Volume Attributes parameter </caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Constant and bit position</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Description</p></th></tr><tr><td  scope="row"><p><code>kReadOnly</code> (bit 0)</p></td><td ><p>If set, the volume is available for reading only.</p></td></tr><tr><td  scope="row"><p><code>kHasVolumePassword</code> (bit 1)</p></td><td ><p>If set, the volume has a volume password. Volume passwords were supported in prior versions of AFP; now the volume attributes reflect this information. This bit is the same as the HasPassword bit returned for each volume by <code>FPGetSrvrParms</code>.</p></td></tr><tr><td  scope="row"><p><code>kSupportsFileIDs</code> (bit 2)</p></td><td ><p>If set, the volume supports file IDs. In general, if file IDs are supported on one volume, they are supported on all volumes, but this bit allows the server to be more selective, if necessary.</p></td></tr><tr><td  scope="row"><p><code>kSupportsCatSearch</code> (bit 3)</p></td><td ><p>If set, the volume supports the <code>FPCatSearch</code> and <code>FPCatSearchExt</code> commands. Support for <code>FPCatSearch</code> and <code>FPCatSearchExt</code> is optional. This bit allows the server to make this capability available on a per-volume basis.</p></td></tr><tr><td  scope="row"><p><code>kSupportsBlankAccessPrivs</code> (bit 4)</p></td><td ><p>If set, the volume has a Supports Blank Access Privileges bit that, when set for a directory, causes the directory to inherit its access privileges from its parent directory.</p></td></tr><tr><td  scope="row"><p><code>kSupportsUnixPrivs</code> (bit 5)</p></td><td ><p>If set, the volume supports UNIX privileges.</p></td></tr><tr><td  scope="row"><p><code>kSupportsUTF8Names</code> (bit 6)</p></td><td ><p>If set, the volume supports UTF-8–encoded user names, group names, and pathnames.</p></td></tr><tr><td  scope="row"><p><code>kNoNetworkUserIDs</code> (bit 7)</p></td><td ><p>If set, always map UNIX user IDs, group IDs and permissions to traditional User IDs, Group IDs and permissions. If not set, after logging into the server, an AFP client running on a UNIX-based machine should call <code>getuid()</code> to get the user’s local user ID and send an FPGetUserInfo command to get the user’s user ID from the server. If the user IDs match, the AFP client should call <code>getpwuid()</code> to get the user’s local user name, which is returned in the <code>pw_name </code>field, and send an <code>FPMapID</code> command to get the user’s user name from the server. If the user names match, the AFP client assumes both machines are operating from a common user directory, and displays UNIX permissions without mapping them. Showing UNIX user IDs, group IDs, and permissions is useful for home directory servers and other servers participating in a network user database. If the user IDs or user names do not match, or if the AFP client is not running on a UNIX-based machine, the AFP client should map UNIX user IDs, group IDs and permissions to traditional User IDs, Group IDs and permissions. This default behavior can be changed by settings on the server. The server can be forced to always set or to never set the <code>kNoNetworkUserIDs</code> bit.</p></td></tr><tr><td  scope="row"><p><code>kDefaultPrivsFromParent</code> (bit 8)</p></td><td ><p>If set, directories inherit default privileges from the parent directory.</p></td></tr><tr><td  scope="row"><p><code>kNoExchangeFiles</code> (bit 9)</p></td><td ><p>If set, exchange files is not supported.</p></td></tr><tr><td  scope="row"><p><code>kSupportsExtAttrs</code> (bit 10)</p></td><td ><p>If set, the volume supports extended attributes.</p></td></tr><tr><td  scope="row"><p><code>kSupportsACLs</code> (bit 11)</p></td><td ><p>If set, the volume supports access control lists (ACLs).</p></td></tr></table></div><a name="//apple_ref/doc/uid/TP40000854-CH3-50143" title="Volume Types"></a><a name="//apple_ref/doc/uid/TP40000854-CH3-CHBHGACC" title="Volume Types"></a><h4>Volume Types</h4><p>An AFP volume is structured hierarchically. There are two types of hierarchical volumes: fixed and variable. A fixed Directory ID volume contains multiple directories, with each directory having its own permanent Directory ID that is assigned when the directory is created. The Directory ID is not used for any other directory during the lifetime of the volume, even if the directory to which it is assigned is later deleted.</p><p>A variable Directory ID volume also maintains the uniqueness of its Directory IDs but differs from a fixed Directory ID volume in that it does not associate a permanent Directory ID with each directory. For variable Directory ID volumes, the file server creates a unique Directory ID for a directory whenever the AFP client sends an <code>FPOpenDir</code> command. The file server then maintains this Directory ID until the client sends an <code>FPCloseDir</code> command or the AFP session terminates. A Directory ID obtained by sending an <code>FPOpenDir</code> command to a variable Directory ID volume must be used only for that session. If the Directory ID is stored and used to reference the directory in a later session, the results cannot be predicted: the command may fail, manipulate the wrong directory, or accidentally manipulate the correct directory.</p><a name="//apple_ref/doc/uid/TP40000854-CH3-50214" title="Table 1-4Volume types"></a><a name="//apple_ref/doc/uid/TP40000854-CH3-CHBIHBGG" title="Table 1-4Volume types"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 1-4&nbsp;&nbsp;</strong>Volume types</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Value</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Description</p></th></tr><tr><td  scope="row"><p>1</p></td><td ><p>Flat</p></td></tr><tr><td  scope="row"><p>2</p></td><td ><p>Fixed Directory ID</p></td></tr><tr><td  scope="row"><p>3</p></td><td ><p>Variable Directory ID (deprecated)</p></td></tr></table></div><p>The volume types have the following support capabilities and constraints: Personal computers using MS-DOS can gain access to any type of server volume because the concept of Directory IDs is foreign to their file systems. However, Macintosh computers using the hierarchical file system (HFS) cannot directly use variable Directory ID volumes. Macintosh HFS volumes are fixed Directory ID volumes and hierarchical volumes on the file server can be handled by HFS only if they are fixed Directory ID volumes. Mac OS applications, such as the Finder, save Directory IDs and do no expect them to vary.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40000854-CH3-DontLinkElementID_5" title="Note"></a><p><strong>Note:</strong>&nbsp;AFP 3.<em>x</em> servers do not advertise support for variable Directory ID volumes, and AFP 3.<em>x</em><code></code><code></code> clients are not required to support variable Directory ID volumes.</p></div><a name="//apple_ref/doc/uid/TP40000854-CH3-50308" title="Volume Catalog"></a><a name="//apple_ref/doc/uid/TP40000854-CH3-CHBEHFDB" title="Volume Catalog"></a><h4>Volume Catalog</h4><p>The volume catalog is the structure that describes the branching tree arrangement of files and directories on fixed and variable Directory ID volumes. The catalog does not span multiple volumes; the AFP client sees a separate volume catalog for each server volume that is visible to AFP clients. <span class="content_text"><a href="Concepts.html#//apple_ref/doc/uid/TP40000854-CH3-50392">Figure 1-2</a></span> shows an example of a volume catalog and illustrates its elements.</p><p>The volume catalog contains directories and files branching from a base directory known as the root. These directories and files are referred to as catalog nodes or CNodes (not to be confused with devices on a network, which are also known as nodes). Within the tree structure, CNodes can be positioned in two ways:</p><ul class="spaceabove"><li class="li"><p>at the end of a limb, in which case the CNode is called a leaf; a leaf CNode can be a file or an empty directory</p></li><li class="li"><p>connected from above and below to other CNodes, which case the CNode is called an internal CNode. Internal CNodes are always directories</p></li></ul><p>CNodes have a parent/offspring relationship. A given CNode is the offspring of the CNode above it in the catalog tree, and the higher CNode is considered its parent directory. Offspring are contained within the parent directory. The only CNode that does not have a parent directory is the root directory.</p><p>When an AFP command makes its way through the volume catalog, it can take only one shortest path from the root to a specific CNode. The CNodes along that path are said to be ancestors of the destination node, which in turn is called the descendent of each of its ancestors.</p><br/><div><a name="//apple_ref/doc/uid/TP40000854-CH3-50392" title="Figure 1-2Volume catalog"></a><a name="//apple_ref/doc/uid/TP40000854-CH3-CHBEGEBE" title="Figure 1-2Volume catalog"></a><p><strong>Figure 1-2&nbsp;&nbsp;</strong>Volume catalog</p><img src = "../Art/afp_l_03.gif" alt = "Volume catalog" width="278" height="327"></div><br/><a name="//apple_ref/doc/uid/TP40000854-CH3-50412" title="Catalog Node Names"></a><a name="//apple_ref/doc/uid/TP40000854-CH3-CHBBEFBI" title="Catalog Node Names"></a><h3>Catalog Node Names</h3><p>CNode names identify every directory and file in a volume catalog. Each directory and file has a Long Name, a Short Name, and may also have an AFPName.</p><p>Long Names and Short Names correspond in two of the native file systems that AFP supports: the Mac OS refers to files and directories by Long Names; MS-DOS computers use Short Names.</p><p>AFPNames are encoded in conformance to the Unicode standard (UTF-8), which uses 16-bits to encode more than 65,000 characters. To keep character coding simple and efficient, the Unicode Standard assigns each character a unique numeric value and name. To help when converting from UTF-8 to other script systems, AFPNames begin with a four-byte text encoding hint that specifies the script that was originally used to compose the name. The text encoding hint is followed by a two-byte length field specifying the length of the UTF-8 encoded name that follows.</p><p>The header file, <code>TextCommon.h</code>, for the Text Encoding Conversion Manager defines the constants for the text encoding hint:</p><div class="codesample"><table><tr><td scope="row"><pre>enum {<span></span></pre></td></tr><tr><td scope="row"><pre>    kTextEncodingMacRoman = 0,<span></span></pre></td></tr><tr><td scope="row"><pre>    kTextEncodingMacJapanese = 1,<span></span></pre></td></tr><tr><td scope="row"><pre>    kTextEncodingMacChineseTrad = 2,<span></span></pre></td></tr><tr><td scope="row"><pre>    kTextEncodingMacKorean = 3,<span></span></pre></td></tr><tr><td scope="row"><pre>    kTextEncodingMacArabic = 4,<span></span></pre></td></tr><tr><td scope="row"><pre>    kTextEncodingMacHebrew = 5,<span></span></pre></td></tr><tr><td scope="row"><pre>    kTextEncodingMacGreek = 6,<span></span></pre></td></tr><tr><td scope="row"><pre>    kTextEncodingMacCyrillic = 7,<span></span></pre></td></tr><tr><td scope="row"><pre>    kTextEncodingMacDevanagari = 9,<span></span></pre></td></tr><tr><td scope="row"><pre>    kTextEncodingMacGurmukhi = 10,<span></span></pre></td></tr><tr><td scope="row"><pre>    kTextEncodingMacGujarati = 11,<span></span></pre></td></tr><tr><td scope="row"><pre>    kTextEncodingMacOriya = 12,<span></span></pre></td></tr><tr><td scope="row"><pre>    kTextEncodingMacBengali = 13,<span></span></pre></td></tr><tr><td scope="row"><pre>    kTextEncodingMacTamil = 14,<span></span></pre></td></tr><tr><td scope="row"><pre>    kTextEncodingMacTelugu = 15,<span></span></pre></td></tr><tr><td scope="row"><pre>    kTextEncodingMacKannada = 16,<span></span></pre></td></tr><tr><td scope="row"><pre>    kTextEncodingMacMalayalam = 17,<span></span></pre></td></tr><tr><td scope="row"><pre>    kTextEncodingMacSinhalese = 18,<span></span></pre></td></tr><tr><td scope="row"><pre>    kTextEncodingMacBurmese = 19,<span></span></pre></td></tr><tr><td scope="row"><pre>    kTextEncodingMacKhmer = 20,<span></span></pre></td></tr><tr><td scope="row"><pre>    kTextEncodingMacThai = 21,<span></span></pre></td></tr><tr><td scope="row"><pre>    kTextEncodingMacLaotian = 22,<span></span></pre></td></tr><tr><td scope="row"><pre>    kTextEncodingMacGeorgian = 23,<span></span></pre></td></tr><tr><td scope="row"><pre>    kTextEncodingMacArmenian = 24,<span></span></pre></td></tr><tr><td scope="row"><pre>    kTextEncodingMacChineseSimp = 25,<span></span></pre></td></tr><tr><td scope="row"><pre>    kTextEncodingMacTibetan = 26,<span></span></pre></td></tr><tr><td scope="row"><pre>    kTextEncodingMacMongolian = 27,<span></span></pre></td></tr><tr><td scope="row"><pre>    kTextEncodingMacEthiopic = 28,<span></span></pre></td></tr><tr><td scope="row"><pre>    kTextEncodingMacCentralEurRoman = 29,<span></span></pre></td></tr><tr><td scope="row"><pre>    kTextEncodingMacVietnamese = 30,<span></span></pre></td></tr><tr><td scope="row"><pre>    kTextEncodingMacExtArabic = 31,<span></span></pre></td></tr><tr><td scope="row"><pre>    kTextEncodingMacSymbol = 33,<span></span></pre></td></tr><tr><td scope="row"><pre>    kTextEncodingMacDingbats = 34,<span></span></pre></td></tr><tr><td scope="row"><pre>    kTextEncodingMacTurkish = 35,<span></span></pre></td></tr><tr><td scope="row"><pre>    kTextEncodingMacCroatian = 36,<span></span></pre></td></tr><tr><td scope="row"><pre>    kTextEncodingMacIcelandic = 37,<span></span></pre></td></tr><tr><td scope="row"><pre>    kTextEncodingMacRomanian = 38,<span></span></pre></td></tr><tr><td scope="row"><pre>    kTextEncodingMacCeltic = 39,<span></span></pre></td></tr><tr><td scope="row"><pre>    kTextEncodingMacGaelic = 40,<span></span></pre></td></tr><tr><td scope="row"><pre>    kTextEncodingMacKeyboardGlyphs = 41,<span></span></pre></td></tr><tr><td scope="row"><pre>    kTextEncodingMacUnicode = 126,<span></span></pre></td></tr><tr><td scope="row"><pre>    kTextEncodingMacFarsi = 140,<span></span></pre></td></tr><tr><td scope="row"><pre>    kTextEncodingMacUkrainian = 152,<span></span></pre></td></tr><tr><td scope="row"><pre>    kTextEncodingMacInuit = 236,<span></span></pre></td></tr><tr><td scope="row"><pre>    kTextEncodingMacVT100 = 252,<span></span></pre></td></tr><tr><td scope="row"><pre>    kTextEncodingMacHFS = 255,<span></span></pre></td></tr><tr><td scope="row"><pre>    kTextEncodingUnicodeDefault = 256,<span></span></pre></td></tr><tr><td scope="row"><pre>    kTextEncodingUnicodeV1_1 = 257,<span></span></pre></td></tr><tr><td scope="row"><pre>    kTextEncodingISO10646_1993 = 257,<span></span></pre></td></tr><tr><td scope="row"><pre>    kTextEncodingUnicodeV2_0 = 259,<span></span></pre></td></tr><tr><td scope="row"><pre>    kTextEncodingUnicodeV2_1 = 259,<span></span></pre></td></tr><tr><td scope="row"><pre>    kTextEncodingUnicodeV3_0 = 260,<span></span></pre></td></tr><tr><td scope="row"><pre>    kTextEncodingISOLatin1 = 513,<span></span></pre></td></tr><tr><td scope="row"><pre>    kTextEncodingISOLatin2 = 514,<span></span></pre></td></tr><tr><td scope="row"><pre>    kTextEncodingISOLatin3 = 515,<span></span></pre></td></tr><tr><td scope="row"><pre>    kTextEncodingISOLatin4 = 516,<span></span></pre></td></tr><tr><td scope="row"><pre>    kTextEncodingISOLatinCyrillic = 517,<span></span></pre></td></tr><tr><td scope="row"><pre>    kTextEncodingISOLatinArabic = 518,<span></span></pre></td></tr><tr><td scope="row"><pre>    kTextEncodingISOLatinGreek = 519,<span></span></pre></td></tr><tr><td scope="row"><pre>    kTextEncodingISOLatinHebrew = 520,<span></span></pre></td></tr><tr><td scope="row"><pre>    kTextEncodingISOLatin5 = 521,<span></span></pre></td></tr><tr><td scope="row"><pre>    kTextEncodingISOLatin6 = 522,<span></span></pre></td></tr><tr><td scope="row"><pre>    kTextEncodingISOLatin7 = 525,<span></span></pre></td></tr><tr><td scope="row"><pre>    kTextEncodingISOLatin8 = 526,<span></span></pre></td></tr><tr><td scope="row"><pre>    kTextEncodingISOLatin9 = 527,<span></span></pre></td></tr><tr><td scope="row"><pre>    kTextEncodingDOSLatinUS = 1024,<span></span></pre></td></tr><tr><td scope="row"><pre>    kTextEncodingDOSGreek = 1029,<span></span></pre></td></tr><tr><td scope="row"><pre>    kTextEncodingDOSBalticRim = 1030,<span></span></pre></td></tr><tr><td scope="row"><pre>    kTextEncodingDOSLatin1 = 1040,<span></span></pre></td></tr><tr><td scope="row"><pre>    kTextEncodingDOSGreek1 = 1041,<span></span></pre></td></tr><tr><td scope="row"><pre>    kTextEncodingDOSLatin2 = 1042,<span></span></pre></td></tr><tr><td scope="row"><pre>    kTextEncodingDOSCyrillic = 1043,<span></span></pre></td></tr><tr><td scope="row"><pre>    kTextEncodingDOSTurkish = 1044,<span></span></pre></td></tr><tr><td scope="row"><pre>    kTextEncodingDOSPortuguese = 1045,<span></span></pre></td></tr><tr><td scope="row"><pre>    kTextEncodingDOSIcelandic = 1046,<span></span></pre></td></tr><tr><td scope="row"><pre>    kTextEncodingDOSHebrew = 1047,<span></span></pre></td></tr><tr><td scope="row"><pre>    kTextEncodingDOSCanadianFrench = 1048,<span></span></pre></td></tr><tr><td scope="row"><pre>    kTextEncodingDOSArabic = 1049,<span></span></pre></td></tr><tr><td scope="row"><pre>    kTextEncodingDOSNordic = 1050,<span></span></pre></td></tr><tr><td scope="row"><pre>    kTextEncodingDOSRussian = 1051,<span></span></pre></td></tr><tr><td scope="row"><pre>    kTextEncodingDOSGreek2 = 1052,<span></span></pre></td></tr><tr><td scope="row"><pre>    kTextEncodingDOSThai = 1053,<span></span></pre></td></tr><tr><td scope="row"><pre>    kTextEncodingDOSJapanese = 1056,<span></span></pre></td></tr><tr><td scope="row"><pre>    kTextEncodingDOSChineseSimplif = 1057,<span></span></pre></td></tr><tr><td scope="row"><pre>    kTextEncodingDOSKorean = 1058,<span></span></pre></td></tr><tr><td scope="row"><pre>    kTextEncodingDOSChineseTrad = 1059,<span></span></pre></td></tr><tr><td scope="row"><pre>    kTextEncodingWindowsLatin1 = 1280,<span></span></pre></td></tr><tr><td scope="row"><pre>    kTextEncodingWindowsANSI = 1280,<span></span></pre></td></tr><tr><td scope="row"><pre>    kTextEncodingWindowsLatin2 = 1281,<span></span></pre></td></tr><tr><td scope="row"><pre>    kTextEncodingWindowsCyrillic = 1282,<span></span></pre></td></tr><tr><td scope="row"><pre>    kTextEncodingWindowsGreek = 1283,<span></span></pre></td></tr><tr><td scope="row"><pre>    kTextEncodingWindowsLatin5 = 1284,<span></span></pre></td></tr><tr><td scope="row"><pre>    kTextEncodingWindowsHebrew = 1285,<span></span></pre></td></tr><tr><td scope="row"><pre>    kTextEncodingWindowsArabic = 1286,<span></span></pre></td></tr><tr><td scope="row"><pre>    kTextEncodingWindowsBalticRim = 1287,<span></span></pre></td></tr><tr><td scope="row"><pre>    kTextEncodingWindowsVietnamese = 1288,<span></span></pre></td></tr><tr><td scope="row"><pre>    kTextEncodingWindowsKoreanJohab = 1296,<span></span></pre></td></tr><tr><td scope="row"><pre>    kTextEncodingUS_ASCII = 1536,<span></span></pre></td></tr><tr><td scope="row"><pre>    kTextEncodingJIS_X0201_76 = 1568,<span></span></pre></td></tr><tr><td scope="row"><pre>    kTextEncodingJIS_X0208_83 = 1569,<span></span></pre></td></tr><tr><td scope="row"><pre>    kTextEncodingJIS_X0208_90 = 1570<span></span></pre></td></tr><tr><td scope="row"><pre>};<span></span></pre></td></tr></table></div><p>To allow dissimilar computers to share resources, the file server provides CNode names in all three formats. When creating or renaming files and directories, the user provides a name consistent with the native file system. The server then uses an algorithm to generate the other name (Long or Short). This section describes the rules for forming CNode names and the algorithm used for creating and maintaining dual names.</p><p>The syntax for forming AFP Long Names is the same as the naming syntax used by the Macintosh HFS, with one exception: Null (0x00) is not a permissible character in AFP Long Names. Otherwise, the mapping of character code to character is the same for AFP as it is for Mac OS X. [See <span class="content_text"><a href="Concepts.html#//apple_ref/doc/uid/TP40000854-CH3-58652">“Character Encoding.”</a></span>] AFP Long Names are made up of at most 31 characters; valid characters are any printable ASCII code except colon (0x3A) and null (0x00). The volume name, and by inference the root’s Long Name, cannot be longer than 27 bytes.</p><p>The syntax for forming AFP Short Names is the same as the naming syntax used by MS-DOS, which is more restrictive than the naming syntax used in the Mac OS: Names may be up to eight alphanumeric characters, optionally followed by a period (0x2E) and a one-to-three character alphanumeric character extension.</p><p>To ensure that a CNode can be uniquely specified by either name, AFP defines the following rules:</p><ul class="spaceabove"><li class="li"><p>no two offspring of a given directory can have the same Short Name or the same Long Name.</p></li><li class="li"><p>a Short Name can match a Long Name if they both belong to the same file or directory.</p></li></ul><p>Therefore, either name, Long or Short, uniquely identifies CNodes within the same directory.</p><p>AFP naming rules are such that any MS-DOS name can be used directly as a CNode Short Name, and any Mac OS X name can be used as a Long Name. The file server generates the other name for each CNode, deriving it from the first name specified and matching the second name as closely as possible. The Long Name format is a superset of the Short Name format. The name management algorithm mandates that whenever a CNode is created or renamed with a Short Name, the Long Name will always match. Deriving a Short Name from a Long Name is not so simple, and AFP does not stipulate an exact algorithm for this derivation. Therefore, different servers may create Short Names differently.</p><p>When a CNode is created, the caller supplies the node’s name and a name type that indicates whether the name is a Long or Short Name. The server then checks the name to verify that the name conforms to the accepted format. The algorithm that follows describes how servers assign Short and Long Names to a CNode (referred to as an object of this algorithm).</p><div class="codesample"><table><tr><td scope="row"><pre>IF name type is Short or name is in Short format<span></span></pre></td></tr><tr><td scope="row"><pre>THEN check for new name in list of Short Names<span></span></pre></td></tr><tr><td scope="row"><pre>    IF name already exists<span></span></pre></td></tr><tr><td scope="row"><pre>    THEN return ObjectExists result<span></span></pre></td></tr><tr><td scope="row"><pre>    ELSE set object’s Short and Long Names to new name<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>ELSE { name type is Long OR name is in Long format }<span></span></pre></td></tr><tr><td scope="row"><pre>    check for new name in list of Long Names<span></span></pre></td></tr><tr><td scope="row"><pre>    IF name already exists<span></span></pre></td></tr><tr><td scope="row"><pre>    THEN return ObjectExists result<span></span></pre></td></tr><tr><td scope="row"><pre>    ELSE set object’s Long Name to new name<span></span></pre></td></tr><tr><td scope="row"><pre>        derive Short Name from Long Name<span></span></pre></td></tr></table></div><p>This algorithm is used for renaming as well as for creating new names. When a user renames an object, its other name is changed using the above algorithm.</p><p>One limitation of this algorithm is that it does not prevent a user from specifying a Long Name that matches the Short Name generated by the file server for another file. A server-generated Short Name is normally not visible to an user that sees only Long Names. If a user inadvertently specifies a Long Name that matches a Short Name, the command fails and the server returns a kFPObjectErr.</p><p>For example, for a file created with the Long Name “MacFileLongName”, a file server can generate a Short Name of “MacFile”. When the user tries to create a new file with the Long Name “MacFile” in the same directory, the command fails because the above algorithm stipulates that the Long Name and the Short Name would both have to be set to “MacFile”.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40000854-CH3-DontLinkElementID_6" title="Note"></a><p><strong>Note:</strong>&nbsp;The root directory of a volume catalog represents the volume, and the root’s Long Name is the same as the volume name. The volume may also have a UTF-8–encoded name. The volume has a Short Name, which is the Short Name of the root directory, but AFP does not allow its use. Neither the root nor the volume can be deleted or renamed through AFP.</p></div><p>If an AFP client creates a file having a UTF-8–encoded name, the file server is required to generate a valid Long Name and a valid Short Name for the file. The algorithm for generating Long and Short Names for a file having a UTF-8–encoded file name is beyond the scope of this specification.</p><a name="//apple_ref/doc/uid/TP40000854-CH3-50665" title="Directories and Files"></a><a name="//apple_ref/doc/uid/TP40000854-CH3-CHBFAFAH" title="Directories and Files"></a><h3>Directories and Files</h3><p>Directories and files are stored in volumes and constitute the next level of the file system structure visible to AFP clients. As was shown in <span class="content_text"><a href="Concepts.html#//apple_ref/doc/uid/TP40000854-CH3-50392">Figure 1-2</a></span>, directories branch to files and other directories. Each directory has an identifier through which it and its offspring can be addressed. Therefore, directories can be thought of as logically containing their offspring directories and files with the parameters described below.</p><a name="//apple_ref/doc/uid/TP40000854-CH3-50695" title="Directory IDs"></a><a name="//apple_ref/doc/uid/TP40000854-CH3-CHBIIEJG" title="Directory IDs"></a><h4>Directory IDs</h4><p>Each directory in the volume catalog is identified by a four-byte long integer known as its Directory ID. Because two directories on the same volume cannot have the same Directory ID, the Directory ID uniquely identifies a directory within a volume.</p><p>Within the volume catalog, as mentioned earlier, directories have ancestor, parent, and offspring relationships with each other. The Directory ID of a CNode’s parent is called the CNode’s Parent ID.</p><p>A CNode can have only one parent, so a given CNode has an unique Parent ID. However, a CNode can have several ancestor directory identifiers, one for each ancestor. The parent directory is considered an ancestor.</p><p>Directory IDs from 1 to 16 are reserved. The Directory ID of the root is always 2. The root’s Parent ID is always 1. (The root does not really have a parent; this value is returned only if an AFP command asks for the root’s Parent ID.) Zero (0) is not a valid Directory ID.</p><a name="//apple_ref/doc/uid/TP40000854-CH3-50759" title="Directory Parameters"></a><a name="//apple_ref/doc/uid/TP40000854-CH3-CHBFCHAB" title="Directory Parameters"></a><h4>Directory Parameters</h4><p>For each directory, the server must maintain the parameters listed in <span class="content_text">Table 1-5</span>. The parameters are obtained by calling <code>FPGetFileDirParms</code> and specifying in the <code>DirBitMap </code><em></em>parameter the directory parameters that are to be obtained. Some directory parameters can be set by calling <code>FPSetDirParms</code> or <code>FPSetFileDirParms</code>.</p><a name="//apple_ref/doc/uid/TP40000854-CH3-50880" title="Table 1-5Definitions for the Directory bitmap "></a><a name="//apple_ref/doc/uid/TP40000854-CH3-CHBCBECD" title="Table 1-5Definitions for the Directory bitmap "></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 1-5&nbsp;&nbsp;</strong>Definitions for the Directory bitmap </caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Constant and bit position</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Parameter size</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Description</p></th></tr><tr><td  scope="row"><p><code>kFPAttributeBit </code>(bit 0)</p></td><td ><p>Two bytes</p></td><td ><p>Additional information about the directory. For details, see <span class="content_text"><a href="Concepts.html#//apple_ref/doc/uid/TP40000854-CH3-51297">Table 1-6</a></span>.</p></td></tr><tr><td  scope="row"><p><code>kFPParentDirIDBit</code> (bit 1)</p></td><td ><p>Four bytes</p></td><td ><p>The unique identifier of the directory’s parent directory.</p></td></tr><tr><td  scope="row"><p><code>kFPCreateDateBit </code>(bit 2)</p></td><td ><p>Four bytes</p></td><td ><p>Date the directory was created. For more details, see the section <span class="content_text"><a href="Concepts.html#//apple_ref/doc/uid/TP40000854-CH3-52714">“Date-Time Values.”</a></span></p></td></tr><tr><td  scope="row"><p><code>kFPModDateBit</code> (bit 3)</p></td><td ><p>Four bytes</p></td><td ><p>Date the directory was most recently modified. For more details, see the section <span class="content_text"><a href="Concepts.html#//apple_ref/doc/uid/TP40000854-CH3-52714">“Date-Time Values.”</a></span></p></td></tr><tr><td  scope="row"><p><code>kFPBackupDateBit</code> (bit 4)</p></td><td ><p>Four bytes</p></td><td ><p>Date the directory was most recently backed up. For more details, see the section <span class="content_text"><a href="Concepts.html#//apple_ref/doc/uid/TP40000854-CH3-52714">“Date-Time Values.”</a></span></p></td></tr><tr><td  scope="row"><p><code>kFPFinderInfoBit</code> (bit 5)</p></td><td ><p>32 bytes</p></td><td ><p>Accompanies directories that are used by computers with HFS. This parameter is maintained by the AFP client and is not examined by AFP.</p></td></tr><tr><td  scope="row"><p><code>kFPLongNameBit </code>(bit 6)</p></td><td ><p>String of up to 32 characters</p></td><td ><p>The directory’s Long Name. For details, see <span class="content_text"><a href="Concepts.html#//apple_ref/doc/uid/TP40000854-CH3-50412">“Catalog Node Names.”</a></span></p></td></tr><tr><td  scope="row"><p><code>kFPShortNameBit </code>(bit 7)</p></td><td ><p>String of up to 12 characters</p></td><td ><p>The directory’s Short Name. For details, see <span class="content_text"><a href="Concepts.html#//apple_ref/doc/uid/TP40000854-CH3-50412">“Catalog Node Names.”</a></span></p></td></tr><tr><td  scope="row"><p><code>kFPNodeIDBit</code> (bit 8)</p></td><td ><p>Four bytes</p></td><td ><p>The directory’s unique identifier.</p></td></tr><tr><td  scope="row"><p><code>kFPOffspringCountBit</code> (bit 9)</p></td><td ><p>Four bytes</p></td><td ><p>Number of files and directories contained by the directory.</p></td></tr><tr><td  scope="row"><p><code>kFPOwnerIDBit</code> (bit 10)</p></td><td ><p>Four bytes</p></td><td ><p>A User ID that uniquely identifies the owner of the directory. Starting with AFP 2.0, a directory can be owned by a group. For more information about the Owner ID parameter, see the section <span class="content_text"><a href="Concepts.html#//apple_ref/doc/uid/TP40000854-CH3-56219">“Directory Access Controls.”</a></span></p></td></tr><tr><td  scope="row"><p><code>kFPGroupIDBit</code> (bit 11)</p></td><td ><p>Four bytes</p></td><td ><p>A number that uniquely identifies the group affiliation of the directory. Starting with AFP 2.0, the Group ID can be a User ID. For more information about the Group ID parameter, see the section <span class="content_text"><a href="Concepts.html#//apple_ref/doc/uid/TP40000854-CH3-56219">“Directory Access Controls.”</a></span></p></td></tr><tr><td  scope="row"><p><code>kFPAccessRightsBit</code> (bit 12)</p></td><td ><p>Four bytes</p></td><td ><p>A bitmap that describes the access rights for the directory’s owner, group affiliation, and Everyone. This bitmap also includes the UARights Summary byte.</p></td></tr><tr><td  scope="row"><p><code>kFPUTF8NameBit </code>(bit 13)</p></td><td ><p>AFPName</p></td><td ><p>The directory’s UTF-8–encoded name. For information about this encoding, see the discussion on the Unicode standard in the section <span class="content_text"><a href="Concepts.html#//apple_ref/doc/uid/TP40000854-CH3-50412">“Catalog Node Names.”</a></span></p></td></tr><tr><td  scope="row"><p><code>kFPUnixPrivsBit</code> (bit 15)</p></td><td ><p>16 bytes</p></td><td ><p>If the directory has UNIX privileges, they are stored in an <code>FPUnixPrivs</code> structure.</p></td></tr></table></div><p>The Attributes parameter for directories provides additional information about the directory. <span class="content_text">Table 1-6</span> lists the bit definitions for the Attributes parameter for directories.</p><a name="//apple_ref/doc/uid/TP40000854-CH3-51297" title="Table 1-6Bit definitions for the directory Attributes parameter "></a><a name="//apple_ref/doc/uid/TP40000854-CH3-CHBJGJGD" title="Table 1-6Bit definitions for the directory Attributes parameter "></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 1-6&nbsp;&nbsp;</strong>Bit definitions for the directory Attributes parameter </caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Bit</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Description</p></th></tr><tr><td  scope="row"><p>Invisible (bit 0)</p></td><td ><p>The directory should not be made visible to the user.</p></td></tr><tr><td  scope="row"><p>IsExpFolder (bit 1)</p></td><td ><p>The directory is a share point. This directory, and all directories within it, indicate to the user that access privileges are valid (for example, by displaying tabbed folders or drop-box folder icons or by enabling the Sharing menu item). None of the directories outside the shared (exported) area show access privileges on local computers, although they may still have valid access privilege information that only an administrator can see or modify. This bit is a read only bit. It cannot be set by <code>FPSetFileDirParms</code>.</p></td></tr><tr><td  scope="row"><p>System (bit 2)</p></td><td ><p>The directory is a system directory; the definition of “system directory” is left to the local computer.</p></td></tr><tr><td  scope="row"><p>Mounted (bit 3)</p></td><td ><p>The directory is mounted by a user who is not an administrator. The icon for such a folder indicates to the user of the local computer that this directory is a share point, and that a remote user currently has it mounted. This bit is a read only bit. It cannot be set by <code>FPSetFileDirParms</code>.</p></td></tr><tr><td  scope="row"><p>InExpFolder (bit 4)</p></td><td ><p>The directory is in a shared area. This directory, and all directories within this directory, indicate to the user that access privileges are valid. This directory cannot be shared because a share point cannot exist within another share point. This bit is a read only bit. It cannot be set by <code>FPSetFileDirParms</code>.</p></td></tr><tr><td  scope="row"><p>BackupNeeded (bit 6)</p></td><td ><p>The directory needs to be backed up. This bit is set whenever the directory’s modification date-time is modified.</p></td></tr><tr><td  scope="row"><p>RenameInhibit (bit 7)</p></td><td ><p>The directory cannot be renamed.</p></td></tr><tr><td  scope="row"><p>DeleteInhibit (bit 8)</p></td><td ><p>The directory cannot be deleted.</p></td></tr><tr><td  scope="row"><p>Set/Clear (bit 15)</p></td><td ><p>When used in conjunction with the <code>FPSetFileDirParms</code> command, indicates whether the specified attributes are to be set (1) or cleared (0). It is not possible to set some attributes and clear other attributes in the same call.</p></td></tr></table></div><p>No specific bit exists to inhibit moving a directory, but directory movement is constrained by the RenameInhibit bit when a directory is moved or moved and renamed.</p><p>Access Rights (a four-byte quantity) contains the read, write, and search access privileges corresponding to the directory’s owner, group, and Everyone. The upper byte of the Access Rights parameter is the User Access Rights Summary byte, which indicates the privileges the current user of the AFP client has to this directory. <span class="content_text">Table 1-7</span> lists the bit definitions for the Access Rights parameter for directories.</p><a name="//apple_ref/doc/uid/TP40000854-CH3-51536" title="Table 1-7Bit definitions for the directory Access Rights parameter "></a><a name="//apple_ref/doc/uid/TP40000854-CH3-CHBCFDAD" title="Table 1-7Bit definitions for the directory Access Rights parameter "></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 1-7&nbsp;&nbsp;</strong>Bit definitions for the directory Access Rights parameter </caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Bit</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Description</p></th></tr><tr><td  scope="row"><p>(bit 0)</p></td><td ><p>Set if the directory’s owner has search access to this directory.</p></td></tr><tr><td  scope="row"><p>(bit 1)</p></td><td ><p>Set if the directory’s owner has read access to this directory.</p></td></tr><tr><td  scope="row"><p>(bit 2)</p></td><td ><p>Set if the directory’s owner has write access to this directory.</p></td></tr><tr><td  scope="row"><p>(bit 8)</p></td><td ><p>Set if the directory’s group has search access to this directory.</p></td></tr><tr><td  scope="row"><p>(bit 9)</p></td><td ><p>Set if the directory’s group has read access to this directory.</p></td></tr><tr><td  scope="row"><p>(bit 10)</p></td><td ><p>Set if the directory’s group has write access to this directory.</p></td></tr><tr><td  scope="row"><p>(bit 16)</p></td><td ><p>Set if Everyone has search access to this directory.</p></td></tr><tr><td  scope="row"><p>(bit 17)</p></td><td ><p>Set if Everyone has read access to this directory.</p></td></tr><tr><td  scope="row"><p>(bit 18)</p></td><td ><p>Set if Everyone has write access to this directory.</p></td></tr><tr><td  scope="row"><p>(bit 24)</p></td><td ><p>Set if the user has search access to this directory.</p></td></tr><tr><td  scope="row"><p>(bit 25)</p></td><td ><p>Set if the user has read access to this directory.</p></td></tr><tr><td  scope="row"><p>(bit 26)</p></td><td ><p>Set if the user has write access to this directory.</p></td></tr><tr><td  scope="row"><p>Blank Access Privileges (bit 28)</p></td><td ><p>This directory has blank access privileges and has the same access privileges as the directory enclosing it.</p></td></tr><tr><td  scope="row"><p>(bit 31)</p></td><td ><p>Set if the user is the owner of the directory. It is also set if the directory is not owned by a registered user.</p></td></tr></table></div><p>An <code>FPUnixPrivs</code> structure is used to return UNIX privileges if a file or directory resides on a volume that supports UNIX privileges. The <code>FPUnixPrivs</code> structure is defined as</p><div class="codesample"><table><tr><td scope="row"><pre>struct FPUnixPrivs {<span></span></pre></td></tr><tr><td scope="row"><pre>    unsigned long uid;<span></span></pre></td></tr><tr><td scope="row"><pre>    unsigned long gid;<span></span></pre></td></tr><tr><td scope="row"><pre>    unsigned long permissions;<span></span></pre></td></tr><tr><td scope="row"><pre>    unsigned long ua_permissions;<span></span></pre></td></tr><tr><td scope="row"><pre>};<span></span></pre></td></tr></table></div><p>where</p><ul class="spaceabove"><li class="li"><p><code>uid</code> is the user ID of the file or directory’s owner</p></li><li class="li"><p><code>gid</code> is the group ID of the file or directory’s owner</p></li><li class="li"><p><code>permissions</code> is the setting of the file or directory’s permission bits</p></li><li class="li"><p><code>ua_permissions</code> is the user’s access rights to the file or directory; bit 31 is set if the user is the owner of the file or directory</p></li></ul><a name="//apple_ref/doc/uid/TP40000854-CH3-51880" title="File Parameters"></a><a name="//apple_ref/doc/uid/TP40000854-CH3-CHBIEAED" title="File Parameters"></a><h4>File Parameters</h4><p>For each file, the server must maintain the parameters listed in <span class="content_text">Table 1-8</span>. The parameters are obtained by calling <code>FPGetFileDirParms</code> and specifying in the<code> FileBitmap</code><em></em>parameter the file parameters that are to be obtained, by calling <code>FPResolveID</code> and specifying the file’s File ID, or by calling <code>FPGetForkParms</code>. Some file parameters can be set by sending <code>FPSetFileParms</code>, <code>FPSetFileDirParms</code>, and <code>FPSetForkParms</code> commands.</p><a name="//apple_ref/doc/uid/TP40000854-CH3-52019" title="Table 1-8Definitions for the File bitmap"></a><a name="//apple_ref/doc/uid/TP40000854-CH3-CHBBDIFJ" title="Table 1-8Definitions for the File bitmap"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 1-8&nbsp;&nbsp;</strong>Definitions for the File bitmap</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Constant and bit position</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Parameter size</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Description</p></th></tr><tr><td  scope="row"><p><code>kFPAttributeBit</code>  (bit 0)</p></td><td ><p>Two bytes</p></td><td ><p>Additional information about the file. For details, see <span class="content_text"><a href="Concepts.html#//apple_ref/doc/uid/TP40000854-CH3-52457">Table 1-9</a></span>.</p></td></tr><tr><td  scope="row"><p><code>KFPParentDirIDBit</code> (bit 1)</p></td><td ><p>Four bytes</p></td><td ><p>The unique identifier for the file’s parent directory.</p></td></tr><tr><td  scope="row"><p><code>kFPCreateDateBit </code> (bit 2)</p></td><td ><p>Four bytes</p></td><td ><p>Date the file was created. For more details, see the section <span class="content_text"><a href="Concepts.html#//apple_ref/doc/uid/TP40000854-CH3-52714">“Date-Time Values.”</a></span></p></td></tr><tr><td  scope="row"><p><code>kFPModDateBit </code>(bit 3)</p></td><td ><p>Four bytes</p></td><td ><p>Date the file was most recently modified. For more details, see the section <span class="content_text"><a href="Concepts.html#//apple_ref/doc/uid/TP40000854-CH3-52714">“Date-Time Values.”</a></span></p></td></tr><tr><td  scope="row"><p><code>kFPBackupDateBit </code> (bit 4)</p></td><td ><p>Four bytes</p></td><td ><p>Date the file was most recently backed up. For more details, see the section <span class="content_text"><a href="Concepts.html#//apple_ref/doc/uid/TP40000854-CH3-52714">“Date-Time Values.”</a></span></p></td></tr><tr><td  scope="row"><p><code>kFPFinderInfoBit </code> (bit 5)</p></td><td ><p>32 bytes</p></td><td ><p>Accompanies files that are used by computers with HFS. This parameter is maintained by the AFP client and is not examined by AFP.</p></td></tr><tr><td  scope="row"><p><code>kFPLongNameBit </code> (bit 6)</p></td><td ><p>String of up to 32 characters</p></td><td ><p>The file’s Long Name. For details, see <span class="content_text"><a href="Concepts.html#//apple_ref/doc/uid/TP40000854-CH3-50412">“Catalog Node Names.”</a></span></p></td></tr><tr><td  scope="row"><p><code>kFPShortNameBit </code> (bit 7)</p></td><td ><p>String of up to 12 characters</p></td><td ><p>The file’s Short Name. For details, see <span class="content_text"><a href="Concepts.html#//apple_ref/doc/uid/TP40000854-CH3-50412">“Catalog Node Names.”</a></span></p></td></tr><tr><td  scope="row"><p><code>kFPNodeIDBit</code> (bit 8)</p></td><td ><p>Four bytes</p></td><td ><p>The file’s unique number obtained by the file server from the File Manager’s PBGetCatInfo call.</p></td></tr><tr><td  scope="row"><p><code>kFPDataForkLenBit</code> (bit 9)</p></td><td ><p>Four-byte unsigned integer</p></td><td ><p>The current length of the file’s data fork. If the data fork’s length is greater than 4 GB, specifying this bit returns the actual length of the data fork. If the data fork’s length is greater than 4 GB, specifying this bit returns 4 GB.</p></td></tr><tr><td  scope="row"><p><code>kFPRsrcForkLenBit</code> (bit 10)</p></td><td ><p>Four-byte unsigned integer</p></td><td ><p>The current length of the file’s resource fork. If the resource fork’s length is greater than 4 GB, specifying this bit returns the actual length of the resource fork. If the resource fork’s length is greater than 4 GB, specifying this bit returns 4 GB.</p></td></tr><tr><td  scope="row"><p><code>kFPExtDataForkLenBit</code> (bit 11)</p></td><td ><p>Eight-byte unsigned integer</p></td><td ><p>The current length of the file’s data fork.</p></td></tr><tr><td  scope="row"><p><code>kFPLaunchLimitBit </code>(bit 12)</p></td><td ><p></p></td><td ><p></p></td></tr><tr><td  scope="row"><p><code>kFPUTF8NameBit</code> (bit 13)</p></td><td ><p>AFPName</p></td><td ><p>The file’s name in UTF-8 format.</p></td></tr><tr><td  scope="row"><p><code>kFPExtRsrcForkLenBit</code> (bit 14)</p></td><td ><p>Eight-byte unsigned integer</p></td><td ><p>The current length of the file’s resource fork.</p></td></tr><tr><td  scope="row"><p><code>kFPUnixPrivsBit</code> (bit 15)</p></td><td ><p>16 bytes</p></td><td ><p>If the file has UNIX privileges, they are returned in an <code>FPUnixPrivs</code> structure.</p></td></tr></table></div><p>The file number is a unique number associated with each file on the volume. This number is purely informative; AFP does not allow the specification of a file by its file number.</p><p>The Attributes parameter for files provides additional information about the file. <span class="content_text">Table 1-9</span> lists the bit definitions for the Attributes parameter for files.</p><a name="//apple_ref/doc/uid/TP40000854-CH3-52457" title="Table 1-9Bit definitions for file Attributes parameter "></a><a name="//apple_ref/doc/uid/TP40000854-CH3-CHBHACAC" title="Table 1-9Bit definitions for file Attributes parameter "></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 1-9&nbsp;&nbsp;</strong>Bit definitions for file Attributes parameter </caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Constant and bit position</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Description</p></th></tr><tr><td  scope="row"><p><code>kFPInvisibleBit</code> (bit 0)</p></td><td ><p>File should not be made visible to the user.</p></td></tr><tr><td  scope="row"><p><code>kFPMultiUserBit</code> (bit 1)</p></td><td ><p>File is an application that has been written for simultaneous use by more than one user.</p></td></tr><tr><td  scope="row"><p><code>kFPSystemBit</code> (bit 2)</p></td><td ><p>File is a system file.</p></td></tr><tr><td  scope="row"><p><code>kFPDAlreadyOpenBit</code> (bit 3)</p></td><td ><p>File’s data fork is currently open by a user.</p></td></tr><tr><td  scope="row"><p><code>kFPRAlreadyOpenBit</code> (bit 4)</p></td><td ><p>File’s resource fork is currently open by a user.</p></td></tr><tr><td  scope="row"><p><code>kFPWriteInhibitBit</code> (bit 5)</p></td><td ><p>User cannot write to the file’s forks.</p></td></tr><tr><td  scope="row"><p><code>kFPBackUpNeededBit</code> (bit 6)</p></td><td ><p>File needs to be backed up.</p></td></tr><tr><td  scope="row"><p><code>kFPRenameInhibitBit</code> (bit 7)</p></td><td ><p>File cannot be renamed.</p></td></tr><tr><td  scope="row"><p><code>kFPDeleteInhibitBit</code> (bit 8)</p></td><td ><p>File cannot be deleted.</p></td></tr><tr><td  scope="row"><p><code>kFPCopyProtectBit</code> (bit 10)</p></td><td ><p>File should not be copied.</p></td></tr><tr><td  scope="row"><p><code>kFPSetClearBit</code> (bit 15)</p></td><td ><p>When used in conjunction with the <code>FPSetFileDirParms</code> command, indicates whether the specified attributes are to be set (1) or cleared (0). It is not possible to set some attributes and clear other attributes in the same call.</p></td></tr></table></div><p>No specific bit exists to inhibit moving a file, but file movement is constrained by the RenameInhibit bit only when a file is moved and renamed, not when it is simply moved.</p><p>The Finder will not copy a file whose CopyProtect bit is set. An attempt to copy the file using the FPCopyFile request will in an error. This bit may be read, but not set, using AFP. It is to be set by some administrative program, whose specification is beyond the scope of this document.</p><p>The BackupNeeded bit is set whenever the file’s modification date-time changes.</p><p>The data fork length and resource fork length are equal to the number of bytes in the corresponding fork.</p><p>The creation, backup, and modification date-time parameters are described next.</p><a name="//apple_ref/doc/uid/TP40000854-CH3-52714" title="Date-Time Values"></a><a name="//apple_ref/doc/uid/TP40000854-CH3-CHBBJDDA" title="Date-Time Values"></a><h4>Date-Time Values</h4><p>All date-time quantities used by AFP specify values of the server’s clock. These values correspond to the number of seconds measured from 12:00 am on January 1, 2000 in Greenwich Mean Time (GMT). AFP represents date-time values with four-byte signed integers. One of the AFP commands allows the AFP client to obtain the current value of the server’s clock. At login time, the AFP client should read this value (<em>s</em>) and the value of the AFP client’s clock (<em>w</em><code></code>) and computer the offset between these values (<em>s - w</em>). All subsequent date-time values read from the server should be adjusted by adding this offset to the date-time. This adjustment will correct for differences between the two clocks and will ensure that all computers see a consistent time base.</p><p>The creation date-time of a directory or a file is set to the server’s system clock when the file or directory is created. The backup date-time is set by backup programs. When a file or directory is created, the server sets the backup date-time to 0x80000000, which is the earliest representable time.</p><p>The server changes the modification date-time of a directory each time the directory’s contents are modified. Therefore, any of the following actions will cause the server to assign a new modification date to the directory: renaming the directory; creating or deleting a CNode in the directory; moving the directory; changing its access privileges, Finder Info, or changing the Invisible attributes of one of its offspring.</p><p>An AFP client with the appropriate privileges can set the creation and modification date-time parameters to any value.</p><a name="//apple_ref/doc/uid/TP40000854-CH3-52798" title="File Forks"></a><a name="//apple_ref/doc/uid/TP40000854-CH3-CHBCAGDF" title="File Forks"></a><h4>File Forks</h4><p>A file consists of two forks: a data fork and a resource fork. The bytes in a file fork are sequentially numbered starting with 0. The data fork is an unstructured finite sequence of bytes. The resource fork is used to hold Mac OS resources, such as icons and drivers, and a data structure for mapping them within the fork. AFP is designed to consider both forks as finite-length byte sequences; however, AFP contains no rules relating to the structure of the resource fork. For more information about resource forks, refer to <em>Inside Mac OS X</em><em></em>.</p><p>Either or both forks of a given file can be empty. Non-Mac OS AFP clients that need only one file fork must use the data fork. Files created by a computer with an MS-DOS operating system will have an empty resource fork because a resource fork is unintelligible to that operating system. Consequently, an MS-DOS computer that has gained access to a server file created by a Macintosh may not be aware of the existence of the file’s resource fork.</p><p>Although AFP allows the creation of MS-DOS applications that can understand and manipulate resource forks, such applications would have to preserve the internal structure of the forks. Mac OS computers expect a specific format in the resource fork of any file, so AFP clients of computers that cannot manage the internal structure of the resource fork should never alter the contents of a resource fork.</p><p>To read from or write to the contents of a file’s data or resource fork, the AFP client first sends a command to open the particular fork of the file, creating an access path to that file fork. The access path is not be confused with the paths and pathnames described in the next section.</p><p>Once the AFP client creates this access path, all subsequent read and write commands refer to it for the duration of the session. For each access path, the server maintains the parameters listed in <span class="content_text">Table 1-10</span>.</p><a name="//apple_ref/doc/uid/TP40000854-CH3-53022" title="Table 1-10Access path parameters"></a><a name="//apple_ref/doc/uid/TP40000854-CH3-CHBFGAFF" title="Table 1-10Access path parameters"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 1-10&nbsp;&nbsp;</strong>Access path parameters</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Parameter</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Description</p></th></tr><tr><td  scope="row"><p><code>OForkRefNum </code><em></em></p></td><td ><p>Two bytes (0 is invalid)</p></td></tr><tr><td  scope="row"><p><code>AccessMode</code></p></td><td ><p>Two-byte bitmap</p></td></tr><tr><td  scope="row"><p><code>Flag</code></p></td><td ><p>Bit 7 of a one-byte value</p></td></tr></table></div><p>The <code>OForkRefNum</code> parameter uniquely identifies the access path among all access paths within a given session. The <code>AccessMode</code> parameter indicates to the server whether this access path allows reading or writing. It is maintained by the server and is inaccessible to clients of AFP. The <code>Flag</code> parameter indicates to the server that the access path belongs to the data or the resource fork.</p><p>In addition to the above parameters, the server must provide a way to gain access to the parameters of the file to which an open fork belongs. For details, see the <code>FPGetForkParms</code> command in the Reference section.</p><a name="//apple_ref/doc/uid/TP40000854-CH3-53319" title="Designating a Path to a CNode"></a><a name="//apple_ref/doc/uid/TP40000854-CH3-CHBBGAJA" title="Designating a Path to a CNode"></a><h2>Designating a Path to a CNode</h2><p>In order to perform any action on a CNode, the AFP client must designate a path to the CNode. AFP provides rules for specifying a path to any CNode in the volume catalog. A CNode (file or directory) can be unambiguously specified to the server by the identifiers shown in <span class="content_text">Figure 1-3</span>.</p><br/><div><a name="//apple_ref/doc/uid/TP40000854-CH3-53349" title="Figure 1-3CNode specification"></a><a name="//apple_ref/doc/uid/TP40000854-CH3-CHBDDFIE" title="Figure 1-3CNode specification"></a><p><strong>Figure 1-3&nbsp;&nbsp;</strong>CNode specification</p><img src = "../Art/afp_l_04.gif" alt = "CNode specification" width="386" height="44"></div><br/><p>The Volume ID specifies the volume on which the destination CNode resides. The Directory ID can belong to the destination CNode (if the CNode is a directory) or to any one of its ancestor directories, up to and including the root directory and the root’s parent directory.</p><p>An AFP pathname is formatted as a Pascal string (one length byte followed by the number of characters specified by the length byte) or a UTF-8 string (a four-byte text encoding hint followed by two length bytes followed by the number of characters specified by the length bytes). An AFP pathname is made up of CNode names, concatenated with intervening null-byte separators. Each element of a pathname must be the name of a directory, except for the last one, which can be the name of a directory or a file.</p><p>The elements of a pathname can be Long or Short Names. However, a given pathname cannot contain a mixture of Long and Short Names. A path type byte, which indicates whether the elements of the pathname are all Short or all Long Names, is associated with each pathname. A pathname consisting of Short Names and a path type of 1. A pathname consisting of Long Names has a path type of 2.</p><p>An AFP pathname that consists of Long or Short Names can be up to 255 characters long. The length of an AFP pathname that consists of UTF-8–encoded names is virtually unlimited. A single null byte as the length byte indicates that no pathname is supplied. Because the length byte is included at the beginning of the string, each pathname element (CNode name) does not include a length indicator.</p><p>The syntax of an AFP pathname follows this paragraph. The asterisk (<code>*</code>) represents a sequence of zero or more of the preceding elements of the pathname; the plus (<code>+</code>) represents a sequence of one or more of the preceding elements; <code>&lt;Sep></code> represents the separators in the pathname; the vertical bar (<code>|</code>) is an OR operator; and the term on the left side of the <code>::=</code> symbol is defined as the term(s) on the right side.</p><div class="codesample"><table><tr><td scope="row"><pre>&lt;Sep> ::= &lt;null-byte>+<span></span></pre></td></tr><tr><td scope="row"><pre>&lt;Pathname> ::= empty-string |<span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;Sep>*&lt;CNode name>(&lt;Sep>&lt;Pathname>*<span></span></pre></td></tr></table></div><p>The syntax represents a concatenation of CNode names separated by one or more null bytes. Pathnames can also start or end with a string of null bytes.</p><p>A pathname can be used to traverse the volume catalog in any direction. The pathname syntax allows paths either to descend from a particular CNode through its offspring or to ascend from a CNode to its ancestors. In either case, the directory that is the starting point of this path is defined separately from the pathname by its Directory ID. The first element of the pathname is an offspring of the starting point of the directory. The pathname must be parsed from left to right to obtain each element that is used as the next node on the path.</p><p>To descend through a volume, a valid pathname must proceed in order from parent to offspring. A single null-byte separator preceding this first element is ignored.</p><p>To ascend through a volume, a valid pathname must proceed from a particular CNode to its ancestor. To ascend one level in the catalog tree, two consecutive null bytes should follow the offspring CNode name. To ascend two levels in the catalog tree, three consecutive null bytes are used as the separator, and so on.</p><p>A particular volume may descend and ascend through the volume catalog. Because of this, many valid pathnames may refer to the same CNode.</p><p>A complete path specification can take a number of forms. The table that follows summarizes the different kinds of path specifications that can be used to traverse the volume catalog illustrated in <span class="content_text"><a href="Concepts.html#//apple_ref/doc/uid/TP40000854-CH3-53592">Figure 1-4</a></span>. A zero in square brackets <code>[0]</code> represents a null-byte separator.</p><p>The descriptors and examples that follow refer to this table and the corresponding volume catalog illustrated in <span class="content_text">Figure 1-4</span>. To simplify these examples, the CNodes in this catalog are named <em>a</em> through <em>j</em>, except the root, which is named <em>x</em>. The path type is ignored in this example. The letter <em>v</em> represents the volume’s two-byte Volume ID. Lines connect the CNodes; the unconnected lines indicate that other CNodes in this volume are not shown.</p><br/><div><a name="//apple_ref/doc/uid/TP40000854-CH3-53592" title="Figure 1-4Example of a volume catalog"></a><a name="//apple_ref/doc/uid/TP40000854-CH3-CHBEIFJA" title="Figure 1-4Example of a volume catalog"></a><p><strong>Figure 1-4&nbsp;&nbsp;</strong>Example of a volume catalog</p><img src = "../Art/afp_examplecatalog.gif" alt = "Example of a volume catalog" width="314" height="297"></div><br/><p><span class="content_text">Table 1-11</span> provides the Volume ID, Directory ID, and pathname for some sample path specifications in <span class="content_text"><a href="Concepts.html#//apple_ref/doc/uid/TP40000854-CH3-53592">Figure 1-4</a></span>.</p><a name="//apple_ref/doc/uid/TP40000854-CH3-59380" title="Table 1-11Sample path specifications "></a><a name="//apple_ref/doc/uid/TP40000854-CH3-CHBFFAGF" title="Table 1-11Sample path specifications "></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 1-11&nbsp;&nbsp;</strong>Sample path specifications </caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Example</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Volume ID</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Directory IDs</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Pathname</p></th></tr><tr><td  scope="row"><p>First</p></td><td ><p>v</p></td><td ><p>2</p></td><td ><p>a[0]c[0]e[0]j[o]</p></td></tr><tr><td  scope="row"><p>Second</p></td><td ><p>v</p></td><td ><p>104</p></td><td ><p>e[0]j</p></td></tr><tr><td  scope="row"><p>Third</p></td><td ><p>v</p></td><td ><p>106</p></td><td ><p>[0]j</p></td></tr><tr><td  scope="row"><p>Fourth</p></td><td ><p>v</p></td><td ><p>106</p></td><td ><p>j</p></td></tr><tr><td  scope="row"><p>Fifth</p></td><td ><p>v</p></td><td ><p>106</p></td><td ><p>[0]</p></td></tr><tr><td  scope="row"><p>Sixth</p></td><td ><p>v</p></td><td ><p>104</p></td><td ><p>e[0][0]g[0][0]h</p></td></tr><tr><td  scope="row"><p>Seventh</p></td><td ><p>v</p></td><td ><p>104</p></td><td ><p>e[0][0][0]</p></td></tr><tr><td  scope="row"><p>Eighth</p></td><td ><p>v</p></td><td ><p>1</p></td><td ><p>x[0]a[0]c[0]h</p></td></tr></table></div><p>The first example of a path specification in <span class="content_text">Table 1-11</span> contains the Volume ID, the root directory’s Directory ID, which is always 2, and a pathname. In this case, the pathname must contain the names of all of the destination file’s ancestors except the root, and it must end with the name of the file itself. The single trailing null byte is ignored.</p><p>The second example contains the Volume ID, the Directory ID of an ancestor, and a pathname.</p><p>The third example is essentially the same as the second example. The single leading null byte is ignored.</p><p>In the fourth example, the Directory ID is the Parent ID of the destination file. In this case, the pathname need contain only the name of the destination file itself.</p><p>The fifth example illustrates another way to uniquely specify a descending path to a directory. It includes the CNode’s Volume ID, its Directory ID, and a null pathname. This path specification is used to specify the directory <em>e</em>.</p><p>The sixth example illustrates a descending path. The first CNode in the pathname is the offspring of the starting point Directory ID. Then the pathname ascends though <em>e</em>’s parent (c) down to directory <em>g</em>, backup to <em>g</em>’s parent (<em>c</em>), and down again to <em>h</em>.</p><p>The seventh shows an ascending pathname that starts at directory <em>c</em> (whose Directory ID is 104), moves down to <em>e</em>, and then ascends to <em>e</em>’s parent’s parent (<em>a</em>).</p><p>The eighth example is a special case in which the starting point of the path is Directory ID 1, the parent of the root. The first name of the pathname must be the volume name or root directory name corresponding to Volume ID <em>v</em>; beyond that, pathname traversal is performed as in the other examples.</p><a name="//apple_ref/doc/uid/TP40000854-CH3-53965" title="AFP Login"></a><a name="//apple_ref/doc/uid/TP40000854-CH3-CHBGCJDA" title="AFP Login"></a><h2>AFP Login</h2><p>To make use of any resource managed by a file server, the AFP client must first log in to the server. This section provides an overview of the AFP login process.</p><p>After a user selects an AFP server to log in to, the AFP client sends the <code>FPGetSrvrInfo </code>command to request information about that server. The server returns information that includes</p><ul class="ul"><li class="li"><p>the AFP versions the server supports</p></li><li class="li"><p>the user authentication methods (UAMs) the server supports</p></li><li class="li"><p>the server’s machine type</p></li><li class="li"><p>the server’s name</p></li><li class="li"><p>the server’s network address</p></li><li class="li"><p>the server’s signature</p></li><li class="li"><p>whether the server supports optional functionality, such as reconnect, Open Directory, <code>FPCopyFile</code>, <code>FPChangePassword</code>, saving passwords, and server notifications</p></li></ul><p>During the AFP login process, the AFP client tells the server which AFP version the client will use to establish the connection and which UAM it will use to authenticate the user.</p><p>Each AFP version is uniquely described by a string of up to 16 characters called the AFP version string. The AFP version strings for the AFP versions supported by AFP 3.<em>x</em> are listed in <span class="content_text"><a href="Concepts.html#//apple_ref/doc/uid/TP40000854-CH3-59626">Table 1-12</a></span>.</p><a name="//apple_ref/doc/uid/TP40000854-CH3-59626" title="Table 1-12AFP version strings"></a><a name="//apple_ref/doc/uid/TP40000854-CH3-CHBFGCAE" title="Table 1-12AFP version strings"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 1-12&nbsp;&nbsp;</strong>AFP version strings</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>AFP version</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>AFP version string</p></th></tr><tr><td  scope="row"><p>AFP 2.1</p></td><td ><p>AFPVersion 2.1</p></td></tr><tr><td  scope="row"><p>AFP 2.2</p></td><td ><p>AFP2.2</p></td></tr><tr><td  scope="row"><p>AFP 2.3</p></td><td ><p>AFP2.3</p></td></tr><tr><td  scope="row"><p>AFP 3.0</p></td><td ><p>AFPX03</p></td></tr><tr><td  scope="row"><p>AFP 3.1</p></td><td ><p>AFP3.1</p></td></tr><tr><td  scope="row"><p>AFP 3.2</p></td><td ><p>AFP3.2</p></td></tr></table></div><p>The UAMs supported by AFP 3.<em>x</em> and their corresponding strings are listed in <span class="content_text"><a href="Concepts.html#//apple_ref/doc/uid/TP40000854-CH3-59715">Table 1-13</a></span>.</p><a name="//apple_ref/doc/uid/TP40000854-CH3-59715" title="Table 1-13AFP UAM strings "></a><a name="//apple_ref/doc/uid/TP40000854-CH3-CHBJDAFE" title="Table 1-13AFP UAM strings "></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 1-13&nbsp;&nbsp;</strong>AFP UAM strings </caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>String</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>UAM name</p></th></tr><tr><td  scope="row"><p><code>No User Authent</code></p></td><td ><p>No User Authentication UAM. For details, see <span class="content_text"><a href="Concepts.html#//apple_ref/doc/uid/TP40000854-CH3-54648">“No User Authentication.”</a></span></p></td></tr><tr><td  scope="row"><p><code>Cleartxt Passwrd</code></p></td><td ><p>Cleartext Password. For details, see <span class="content_text"><a href="Concepts.html#//apple_ref/doc/uid/TP40000854-CH3-54697">“Cleartext Password.”</a></span></p></td></tr><tr><td  scope="row"><p><code>Randnum Exchange</code></p></td><td ><p>Random Number Exchange. For details, see <span class="content_text"><a href="Concepts.html#//apple_ref/doc/uid/TP40000854-CH3-54792">“Random Number Exchange.”</a></span></p></td></tr><tr><td  scope="row"><p><code>2-Way Randnum</code></p></td><td ><p>Two-Way Random Number Exchange. For details, see <span class="content_text"><a href="Concepts.html#//apple_ref/doc/uid/TP40000854-CH3-54997">“Two-Way Random Number Exchange.”</a></span></p></td></tr><tr><td  scope="row"><p><code>DHCAST128</code></p></td><td ><p>Diffie-Hellman Key Exchange. Allows the client to send a password of up to 64 bytes to the server through a strongly encrypted “tunnel.” This type of encryption is useful for servers that require the use of cleartext password. For details, see <span class="content_text"><a href="Concepts.html#//apple_ref/doc/uid/TP40000854-CH3-55119">“Diffie-Hellman Key Exchange.”</a></span></p></td></tr><tr><td  scope="row"><p><code>DHX2</code></p></td><td ><p>Diffie-Hellman Key Exchange 2. Allows the client to send a password of up to 256 bytes to the server through a strongly encrypted “tunnel.” This type of encryption is useful for servers that require the use of cleartext password. For details, see <span class="content_text"><a href="Concepts.html#//apple_ref/doc/uid/TP40000854-CH3-81479">“Diffie-Hellman Key Exchange 2.”</a></span></p></td></tr><tr><td  scope="row"><p><code>Client Krb v2 </code></p></td><td ><p>Kerberos. Allows the client to use Kerberos v4 and Kerberos v5 tickets to authenticate a user.</p></td></tr><tr><td  scope="row"><p><code>Recon1</code></p></td><td ><p>The Reconnect UAM. Allows the client to use the <code>FPLoginExt</code> command to reconnect using a reconnect token (also known as a <em>credential</em>) containing all of the information required to authenticate.</p></td></tr></table></div><p>The prospective AFP client initiates the login process by sending an <code>FPLogin</code> or an <code>FPLoginExt</code> command to the server. Both commands include the AFP version string and the UAM string that the client has selected. Depending on the selected UAM method, the <code>FPLogin</code> or <code>FPLoginExt</code> command may include user login information (such as a user name or password), or a subsequent <code>FPLoginCont</code> command may include such information. The sending of additional <code>FPLoginCont</code> commands may be required to complete user authentication, as described in the next section, <span class="content_text"><a href="Concepts.html#//apple_ref/doc/uid/TP40000854-CH3-54580">“File Server Security.”</a></span></p><p>If the UAM succeeds, an AFP session between the AFP client and the server begins.</p><p>As mentioned earlier, in addition to the AFP and UAM versions that the server supports, the <code>FPGetSrvrInfo</code> command returns a <code>Flags</code> parameter whose bits provide additional information about the server that is useful to an AFP client. The bits of the <code>Flags</code> parameter are listed in <span class="content_text">Table 1-14</span>.</p><a name="//apple_ref/doc/uid/TP40000854-CH3-62061" title="Table 1-14Bit definitions for the Flags parameter returned by FPGetSrvrInfo"></a><a name="//apple_ref/doc/uid/TP40000854-CH3-CHBFJCHJ" title="Table 1-14Bit definitions for the Flags parameter returned by FPGetSrvrInfo"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 1-14&nbsp;&nbsp;</strong>Bit definitions for the Flags parameter returned by <code>FPGetSrvrInfo</code></caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Constant and bit position</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Description</p></th></tr><tr><td  scope="row"><p><code>kSupportsCopyFile</code> (bit 0)</p></td><td ><p>Set if the server supports the <code>FPCopyFile</code> command.</p></td></tr><tr><td  scope="row"><p><code>kSupportsChgPwd</code> (bit 1)</p></td><td ><p>Set if the server supports the <code>FPChangePassword</code> command.</p></td></tr><tr><td  scope="row"><p><code>kDontAllowSavePwd</code> (bit 2)</p></td><td ><p>Set if the client should not allow the user to save his or her password for volumes mounted at system startup. The item-selection dialog box may still allow the user to save his or her name. However, when this bit is set, the button offering that option is not displayed.</p></td></tr><tr><td  scope="row"><p><code>kSupportsSrvrMsg</code> (bit 3)</p></td><td ><p>Set if the server supports the <code>FPGetSrvrMsg</code> command.</p></td></tr><tr><td  scope="row"><p><code>kSrvrSig</code> (bit 4)</p></td><td ><p>Server supports server signatures, which is a 16-byte number that uniquely identifies the server. An AFP client should use the server signature to ensure that it does not log in to the same server multiple times. Preventing multiple logins is important when the server is configured for multihoming.</p></td></tr><tr><td  scope="row"><p><code>kSupportsTCP</code> (bit 5)</p></td><td ><p>Set if the server supports TCP/IP.</p></td></tr><tr><td  scope="row"><p><code>kSupportsSrvrNotify</code> (bit 6)</p></td><td ><p>Set if the server supports server notifications.</p></td></tr><tr><td  scope="row"><p><code>kSupportsReconnect</code> (bit 7)</p></td><td ><p>Set if the server supports the <code>FPGetSessionToken</code> and <code>FPDisconnectOldSession</code> commands.</p></td></tr><tr><td  scope="row"><p><code>kSupportsDirServices</code> (bit 8)</p></td><td ><p>Set if the server supports Open Directory.</p></td></tr><tr><td  scope="row"><p><code>kSupportsUTF8SrvrName</code> (bit 9)</p></td><td ><p>Set if the server supports server names in UTF-8 encoding.</p></td></tr><tr><td  scope="row"><p><code>kSupportsUUIDs</code></p></td><td ><p>Set if the servers supports Universal Unique Identifiers (UUIDs).</p></td></tr></table></div><a name="//apple_ref/doc/uid/TP40000854-CH3-62208" title="Reconnecting Sessions"></a><a name="//apple_ref/doc/uid/TP40000854-CH3-CHBEBIAA" title="Reconnecting Sessions"></a><h3>Reconnecting Sessions</h3><p>If an AFP session is disconnected due, for example, a network outage, but the AFP client still has the required information, the AFP client can reconnect the session.</p><p>Clients that use the Reconnect UAM, described in <span class="content_text"><a href="Concepts.html#//apple_ref/doc/uid/TP40000854-CH3-87985">“Reconnect,”</a></span> follow these steps to reconnect:</p><ol class="ol"><li class="li"><p>Log in successfully by calling <code>FPLoginExt </code>using a UAM that provides a session key.</p></li><li class="li"><p>Call <code>FPGetSessionToken</code> to get a token, specifying the <code>Type</code> parameters as <code>kRecon1Login</code> (5).</p></li><li class="li"><p>Periodically call <code>FPGetSessionToken</code> with the <code>Type </code>parameter set to <code>kReconn1Refresh </code>(7) to refresh the token before it expires.</p></li><li class="li"><p>If a disconnect occurs, call <code>FPLoginExt </code>to log in again, specifying the Reconnect UAM as the UAM, and passing the current token obtained by calling <code>FPGetSessionToken</code> in step 2 or 3. The reconnect token contains all of the user name and password information required for the server to authenticate the client, so logging in again does not require the client to repeat the authentication steps that took place in step 1.</p></li><li class="li"><p>If the login in step 4 completes successfully, call <code>FPDisconnectOldSession</code> and pass the token obtained in step 2. If the server can find the previous session identified by the token, it will transfer all the previous session’s open files and locked resources to the new session and return a result code of <code>kFPNoErr</code>.</p></li></ol><p>Clients that don’t use the Reconnect UAM follow these steps to reconnect:</p><ol class="ol"><li class="li"><p>Log in successfully by calling <code>FPLogin</code> or <code>FPLoginExt</code>.</p></li><li class="li"><p>Call <code>FPGetSessionToken</code> to get a token.</p></li><li class="li"><p>If a disconnect occurs, log in again using the same UAM, user name and password that were used in step 1.</p></li><li class="li"><p>Call <code>FPDisconnectOldSession</code> and pass the token obtained in step 2. If the server can find the previous session identified by the token, it will transfer all the previous session’s open files and locked resources to the new session and return a result code of <code>kFPNoErr</code>.</p></li></ol><p>In either case, if the reconnect fails for any reason, the client must start over by logging in again as in step 1. The client should call <code>FPDisconnectOldSession </code>and send the current token to tell the server that it can free resources that were locked up by the earlier session.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40000854-CH3-DontLinkElementID_7" title="Note"></a><p><strong>Note:</strong>&nbsp;The <code>FPDisconnectOldSession </code>command will fail if the server cannot find the previous session or if the AFP client does not use same information to log in again. For security reasons, the <code></code>server also fails all reconnects if the user originally logged in as the Guest user.</p></div><p>If the server returns a result code other than <code>kFPNoErr</code>, the AFP client can attempt to reopen its files. If the files were previously opened without Deny Modes and the AFP client did not apply byte range locks, the client should be able to reopen those files. In this case, reconnect is also deemed successful. If the reconnect is not successful, an AFP client can take the steps described in the next section, <span class="content_text">“Recovering From a System Crash.”</span></p><a name="//apple_ref/doc/uid/TP40000854-CH3-62266" title="Recovering From a System Crash"></a><a name="//apple_ref/doc/uid/TP40000854-CH3-CHBCFDGD" title="Recovering From a System Crash"></a><h3>Recovering From a System Crash</h3><p>If an AFP session is disconnected and the client reconnect information is lost due to a local system crash, the AFP client will not be able to reconnect the session. If the server allows reconnect, any files that were left open on the remote server when the local system crashed will be saved but will not be available for opening until the reconnect timeout expires. This also applies to the case where a sleeping AFP client fails to wake up or crashes and the server is saving the information until the sleep timeout expires.</p><p>To tell the server to close files left open by an old session and disconnect that session, an AFP client that supports AFP 3.1 and later can create and save a unique client-defined identifier and use the <code>FPGetSessionToken</code> command to send it the server. The client must do this before the local system crashes, for example, as part of its login sequence. When it receives the identifier, the server associates the identifier with the current session.</p><p>Later, if the local system crashes and is restarted, the AFP client can log in and send the <code>FPGetSessionToken</code> command again, this time telling the server to look for a session having the specified identifier. If the server finds such a session, it closes the files that are associated with it, frees any other associated resources, and disconnects the old session.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40000854-CH3-DontLinkElementID_8" title="Note"></a><p><strong>Note:</strong>&nbsp;For security purposes, before disconnecting the old session, the server verifies that the same login information was used to log in from the same system. For security purposes, the <code></code>server also fails <code>FPGetSessionToken </code>if the user originally logged in as the Guest user.</p></div><a name="//apple_ref/doc/uid/TP40000854-CH3-78425" title="Disconnect Timers"></a><a name="//apple_ref/doc/uid/TP40000854-CH3-BIHFJGJF" title="Disconnect Timers"></a><h3>Disconnect Timers</h3><p>In previous versions of AFP, there was only one timer for determining whether a disconnect had occurred. With 10.2.x, there are two timers for determining disconnections:</p><ul class="spaceabove"><li class="li"><p>Active timer, which is set to 60 seconds by default</p></li><li class="li"><p>Idle timer, which is set to 120 seconds by default</p></li></ul><p>If the client has an outstanding request to the server and has not received any data (including tickles) from the server, the client waits until the active timer expires before assuming that a disconnect has occurred.</p><p>If the client has no outstanding requests to the server, the client waits until the idle timer expires before assuming that a disconnect has occurred.</p><p>Special considerations arise when the system is awakening from sleep:</p><ul class="spaceabove"><li class="li"><p>If the system is on a LAN, the active timer is set to (activeTimer / 4).</p></li><li class="li"><p>If the system is on a WAN, the active timer is set to (activeTimer / 2).</p></li></ul><p>If the client is connected to an AFP 2.x server, the Active time and the Idle timer are both set to 120 seconds.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40000854-CH3-DontLinkElementID_9" title="Note"></a><p><strong>Note:</strong>&nbsp;The <code>check_afp.app </code>plist contains an option that can be set to disallow idle sleep if an AFP volume is mounted.</p></div><p>In all situations, after a disconnect, if the server supports reconnect, reconnect is started.</p><a name="//apple_ref/doc/uid/TP40000854-CH3-54580" title="File Server Security"></a><a name="//apple_ref/doc/uid/TP40000854-CH3-CHBICDAH" title="File Server Security"></a><h2>File Server Security</h2><p>Information stored in a shared resource needs protection from unauthorized users. The role of file server security is to provide varying amounts and kinds of protection, depending on what users feel is necessary.</p><p>AFP provides security in three ways:</p><ul class="ul"><li class="li"><p>user authentication when the user logs in to the server</p></li><li class="li"><p>an optional volume-level password when the user first attempts to gain access to a volume</p></li><li class="li"><p>directory access controls</p></li></ul><a name="//apple_ref/doc/uid/TP40000854-CH3-54617" title="User Authentication Methods"></a><a name="//apple_ref/doc/uid/TP40000854-CH3-CHBCEJBD" title="User Authentication Methods"></a><h3>User Authentication Methods</h3><p>AFP provides the capability for servers and AFP clients to use a variety of methods to authenticate users when they log in. Five user authentication methods are defined: no user authentication, cleartext password, random number exchange, two-way random number exchange, and Diffie-Hellman Key Exchange. Some UAMs are also used to change a password after the user logs in.</p><p>The AFP client indicates its choice of UAM by giving the server a UAM string. These strings are intended to be case-insensitive and diacritical-sensitive.</p><p>Some UAMs require additional user authentication information to be passed to the server in the <code>FPLogin</code> or <code>FPLoginExt</code> command. The following sections describe the UAMs and the kinds of information they require.</p><a name="//apple_ref/doc/uid/TP40000854-CH3-54648" title="No User Authentication"></a><a name="//apple_ref/doc/uid/TP40000854-CH3-CHBGEFBB" title="No User Authentication"></a><h4>No User Authentication</h4><p>The No User Authentication UAM requires no authentication information. When the <code>FPLogin</code> and <code>FPLoginExt </code>commands use the No User Authentication UAM, there is no <em>UserAuthInfo</em> parameter. The corresponding case-insensitive UAM protocol name for the No User Authentication UAM is <code>No User Authent</code>. The No User Authentication UAM is used when a user logs on as the Guest user.</p><p>In order to implement the directory access controls described later in this section, the server must assign a User ID and a Group ID to the user for the session.</p><p>User ID numbers and Group ID numbers are assigned from the same pool of numbers. In addition, starting with AFP 2.1, AFP servers must assign zero to users who log in as the Guest user and 1 to the Administrator/Owner.</p><p>In this UAM, the server assigns to the user “Everyone” access privileges for every directory in every server volume. “Everyone” access privileges are described in the section <span class="content_text"><a href="Concepts.html#//apple_ref/doc/uid/TP40000854-CH3-56219">“Directory Access Controls.”</a></span></p><a name="//apple_ref/doc/uid/TP40000854-CH3-54697" title="Cleartext Password"></a><a name="//apple_ref/doc/uid/TP40000854-CH3-CHBHBGDD" title="Cleartext Password"></a><h4>Cleartext Password</h4><p>The Cleartext Password UAM transmits the user name and password to the server as cleartext (that is, not encoded). The protocol name for the Cleartext Password UAM is <code>Cleartxt Passwrd</code>.</p><p>For the <code>FPLogin</code> command, the<code> UserAuthInfo</code> parameter consists of a user name (which is a string of up to 255 Macintosh Roman characters) followed by the user’s password (up to 8 bytes). For the <code>FPLoginExt</code> command, the <code>UserAuthInfo</code> parameter consists of a user name (which is a string of up to 255 Unicode characters) followed by the user’s password (up to 8 bytes). To ensure that the user’s password is aligned on an even byte boundary in the packet, the AFP client may have to insert a null byte (0x00) between the user name and the password. If the user provides a password that is shorter than 8 bytes, it must be padded at the end with null bytes to make the password eight bytes long. The permissible set of characters in passwords consists of all 8-bit ASCII characters.</p><p>User name comparison is case-insensitive, but password comparison is case-sensitive for this UAM. If there is a user of the specified name whose password matches the password supplied by the caller of <code>FPLogin</code> or <code>FPLoginExt</code>, the user has been authenticated and the login succeeds. If the passwords do not match, a <code>kFPUserNotAuth</code> result code is returned.</p><p>The Cleartext Password UAM should be used by AFP clients only if the intervening network is secure against eavesdropping. Otherwise, the password information can be read from <code>FPLogin</code> or <code>FPLoginExt</code> command packets by anyone listening on the network.</p><p><span class="content_text"><a href="Concepts.html#//apple_ref/doc/uid/TP40000854-CH3-54778">Figure 1-5</a></span> shows the request block for calling <code>FPChangePassword</code> when using the Cleartext Password UAM.</p><br/><div><a name="//apple_ref/doc/uid/TP40000854-CH3-54778" title="Figure 1-5Request block when using the Cleartext Password UAM"></a><a name="//apple_ref/doc/uid/TP40000854-CH3-CHBDAFGD" title="Figure 1-5Request block when using the Cleartext Password UAM"></a><p><strong>Figure 1-5&nbsp;&nbsp;</strong>Request block when using the Cleartext Password UAM</p><img src = "../Art/afp_083.gif" alt = "Request block when using the Cleartext Password UAM" width="500" height="238"></div><br/><a name="//apple_ref/doc/uid/TP40000854-CH3-54792" title="Random Number Exchange"></a><a name="//apple_ref/doc/uid/TP40000854-CH3-CHBCBACG" title="Random Number Exchange"></a><h4>Random Number Exchange</h4><p>In environments in which the network is not secure against eavesdropping, Random Number Exchange is a more secure user authentication method. The protocol name for this UAM is <code>Randum Exchange</code>. With Random Number Exchange, the user’s password is never sent over the network and cannot be picked up by eavesdropping. Deriving the password from information sent over the network is as difficult as breaking a DES-encrypted password.</p><p>With the Random Number Exchange UAM, only the user name is sent in the UserAuthInfo parameter of the <code>FPLogin</code> or <code>FPLoginExt</code> command. If the user name is valid, the server generates an eight-byte random number and sends it back to the AFP client, along with an ID number and a <code>kFPAuthContinue</code> result code. The <code>kFPAuthContinue</code> result code indicates that all is well at this point, but the user has not yet been authenticated. The AFP client then encrypts the random number with the user’s password and sends the result to the server in the <code>UserAuthInfo</code> parameter of the <code>FPLoginCont</code> command along with the ID number returned earlier by the server in the reply block from the <code>FPLogin</code> or <code>FPLoginExt</code> command. The server uses the ID number to associate an earlier <code>FPLogin</code> or <code>FPLoginExt</code> command with this call to <code>FPLoginCont</code>. The server looks up the password for that user and uses it as a key to encrypt the same random number. If the two encrypted numbers match, the user has been authenticated and the login succeeds. Otherwise, the server returns a <code>kFPUserNotAuth</code> result code.</p><p>The following steps explain the Random Number Exchange UAM in greater detail:</p><ol class="ol"><li class="li"><p>The AFP client sends the <code>FPLogin</code> or <code>FPLoginExt</code> command block with the UAM string and the <code>UserAuthInfo</code> parameter containing the user name string. For <code>FPLogin</code>, the user name can be up to 255 Macintosh Roman characters long; for <code>FPLoginExt</code>, the user name can be up to 255 Unicode characters long.</p></li><li class="li"><p>Upon receiving this command block, the server examines its user database to determine whether the user name is valid. User name comparison is case-insensitive and diacritical-sensitive.</p></li><li class="li"><p>If the server does not find the user name in the user database, it sends an error code to the AFP client indicating that the user name is not valid and denies the login request. If the server finds the name in the user database, it generates an eight-byte random number and sends it to the AFP client, along with an ID number and an <code>kFPAuthContinue</code> result code. The <code>kFPAuthContinue</code> result code indicates that all is well at this point, but the user is not yet authenticated.</p></li><li class="li"><p>Both the AFP client and the server use the National Institute of Standards and Technology Data Encryption Standard (NIST DES) algorithm to encrypt the random number. The user’s case-sensitive password is applied as the encryption key to generate an eight-byte value. The server applies the same algorithm to the password it finds associated with the user name in its database.</p></li><li class="li"><p>The AFP client sends the encrypted value to the server in the <code>UserAuthInfo </code><em></em>parameter of the <code>FPLoginCont</code> command, along with the ID number it received from the server. The server uses the ID number to associate a previous <code>FPLogin</code> or <code>FPLoginExt</code> command with its corresponding <code>FPLoginCont</code> command.</p></li><li class="li"><p>The server compares the AFP client’s encrypted value with the encrypted value obtained using the password from its user database. If the two encrypted values match, the authentication process is complete and the login succeeds. The server returns a result code of <code>kFPNoErr</code> to the AFP client. If the two encrypted values do not match, the server returns the <code>kFPUserNotAuth</code> result code.</p></li></ol><div class="notebox"><a name="//apple_ref/doc/uid/TP40000854-CH3-DontLinkElementID_10" title="Note"></a><p><strong>Note:</strong>&nbsp;The Random Number Exchange UAM uses eight-byte passwords consisting of eight-bit ASCII characters. The NIST DES algorithm ignores the low-order bit of each byte thereby using only 56 bits of the 64-bit password. The result is that in passwords, “0” is equivalent to “1”, “b” is equivalent to “c”, and so on.</p></div><p><span class="content_text"><a href="Concepts.html#//apple_ref/doc/uid/TP40000854-CH3-54983">Figure 1-6</a></span> shows the request block for calling <code>FPChangePassword</code> when using the Random Number Exchange UAM.</p><br/><div><a name="//apple_ref/doc/uid/TP40000854-CH3-54983" title="Figure 1-6Request block when using the Random Number Exchange UAM to change a password"></a><a name="//apple_ref/doc/uid/TP40000854-CH3-CHBCIDAD" title="Figure 1-6Request block when using the Random Number Exchange UAM to change a password"></a><p><strong>Figure 1-6&nbsp;&nbsp;</strong>Request block when using the Random Number Exchange UAM to change a password</p><img src = "../Art/afp_081.gif" alt = "Request block when using the Random Number Exchange UAM to change a password" width="198" height="278"></div><br/><a name="//apple_ref/doc/uid/TP40000854-CH3-54997" title="Two-Way Random Number Exchange"></a><a name="//apple_ref/doc/uid/TP40000854-CH3-CHBEJAIE" title="Two-Way Random Number Exchange"></a><h4>Two-Way Random Number Exchange</h4><p>With the Two-Way Random Number Exchange UAM, the user is authenticated to the server and the server is authenticated to the user, which guards against spoofing (that is, using a fake server to get passwords or data). This method uses the same steps as the Random Number Exchange UAM with three additional steps. The corresponding UAM string is <code>2-Way Randum</code>.</p><p>Like the Random Number Exchange UAM, the Two-Way Random Number Exchange UAM starts when the client sends the <code>FPLogin</code> or <code>FPLoginExt</code> request to the server that includes the user’s user name. If the server finds the user name in the user name database, the server returns an ID number, an eight-byte random number, and a result code of <code>kFPAuthContinue</code>. The client then encodes the random number with the user’s password and sends the encoded number and the ID number to the server in an <code>FPLoginCont</code> request. If the encoded password matches the server’s copy of the random number encoded by the server’s copy of the password, the client is authenticated and <code>kFPNoErr</code> is returned.</p><p>The additional steps of the Two-Way Random Number Exchange are</p><ol class="ol"><li class="li"><p>The client sends to the server an <code></code><code>FPLoginCont</code> request that includes a second eight-byte random number.</p></li><li class="li"><p>The server encodes the second eight-byte random number with it’s copy of the user’s password from the user database and returns the encoded random number in the <code>FPLoginCont</code> reply block.</p></li><li class="li"><p>The client encodes the random number with the user’s password and compares it with the encoded random number from the server. If they match, the server is also authenticated.</p></li></ol><p><span class="content_text"><a href="Concepts.html#//apple_ref/doc/uid/TP40000854-CH3-55088">Figure 1-7</a></span> shows the request and reply block formats for the <code>FPLoginCont </code>command when the Two-Way Random Number Exchange UAM is used.</p><br/><div><a name="//apple_ref/doc/uid/TP40000854-CH3-55088" title="Figure 1-7Request and reply blocks for Two-Way Random Number Exchange"></a><a name="//apple_ref/doc/uid/TP40000854-CH3-CHBHJIAB" title="Figure 1-7Request and reply blocks for Two-Way Random Number Exchange"></a><p><strong>Figure 1-7&nbsp;&nbsp;</strong>Request and reply blocks for Two-Way Random Number Exchange</p><img src = "../Art/afp_001.gif" alt = "Request and reply blocks for Two-Way Random Number Exchange" width="276" height="449"></div><br/><p>The Two-Way Random Number Exchange UAM is not available for use with the <code>FPChangePassword</code> command. Instead, the Random Number Exchange UAM should be used to change a password. A user who has already logged in using the Two-Way Random Number Exchange UAM and who is changing his or her password has already authenticated the server, so there is no need to authenticate the server again by using the Two-Way Random Number Exchange UAM.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40000854-CH3-DontLinkElementID_11" title="Note"></a><p><strong>Note:</strong>&nbsp;With the Two-Way Random Number Exchange UAM, each password byte is shifted left one bit before it is used to encrypt the random number. This shifting causes the password’s high-order bit to be ignored by the NIST DES algorithm instead of the low-order bit as with the Random Number Exchange UAM. Two values are still accepted for each byte of the password. However, the two values will not be adjacent in ASCII space and so will probably not be adjacent alphabetically. For example, “0” will match “∞”, “7” will match “”, and so on.</p></div><a name="//apple_ref/doc/uid/TP40000854-CH3-55119" title="Diffie-Hellman Key Exchange"></a><a name="//apple_ref/doc/uid/TP40000854-CH3-CHBBAGCB" title="Diffie-Hellman Key Exchange"></a><h4>Diffie-Hellman Key Exchange</h4><p>Diffie-Hellman Key Exchange (DHX) is an implementation of the Diffie-Hellman Key Agreement Protocol using the SSLeay/OpenSSL implementation of CAST 128 in CBC mode. The UAM protocol name for DHX is <code>‘DHCAST128’</code>.</p><p>DHX is strong against packet sniffing attacks but vulnerable to active attacks such “Man in the Middle.” There is no way for the client to verify that the server knows the password, so the server could easily be spoofed. There is some weakness in using fixed initialization vectors, p and g. DHX is useful when the server requires passwords in cleartext. </p><p>With DHX, the client and the server each generate  a random number, Ra and Rb respectively, which serve as “private keys” for the  session. The client and server use modulus exponentiation to derive “public keys”,  Ma and Mb, from the private keys and exchange them. The client combines Ra and Mb, and  the server combines Ma with Rb to generate identical session keys, K.</p><p>After the key exchange is complete, a key verification phase follows.  Each side generates a random number (nonce), encrypts it with the session key,  and sends it to the other side. Each side takes the other’s verifier, decrypts  to get the nonce, modifies the nonce in a way that is known to both parties, encrypts it with the session key, and sends it back. The originator verifies  that the nonce was modified as expected. Incrementing the nonce is a simple  and effective way of modifying the verifier.</p><p><span class="content_text">Table 1-15</span> lists the values used to calculate the content of messages exchanged between the client and server when the UAM is DHX.</p><a name="//apple_ref/doc/uid/TP40000854-CH3-79418" title="Table 1-15Variables and notation used by the DHX UAM"></a><a name="//apple_ref/doc/uid/TP40000854-CH3-CHDGEEJD" title="Table 1-15Variables and notation used by the DHX UAM"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 1-15&nbsp;&nbsp;</strong>Variables and notation used by the DHX UAM</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Value</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Meaning</p></th></tr><tr><td  scope="row"><p>password</p></td><td ><p>User password padded with nulls to 64 bytes.</p></td></tr><tr><td  scope="row"><p>username</p></td><td ><p>Pascal string (pstring), padded to an even byte length.</p></td></tr><tr><td  scope="row"><p>ServerSig</p></td><td ><p>Obtained from the server by sending <code>FPGetSrvrInfo</code> command.Due to a problem in the initial implementation, the ServerSig   must be set to 16 bytes of 0x00 in message #2.</p></td></tr><tr><td  scope="row"><p>AFP Vers</p></td><td ><p>Pascal string (pstring) denoting the version of the AFP protocol used for the session.</p></td></tr><tr><td  scope="row"><p>ID</p></td><td ><p>A two-byte number used by the server to keep track of the login/change   password request. The server may send any two-byte number, the client passes it   back unchanged.</p></td></tr><tr><td  scope="row"><p> x^y</p></td><td ><p>Raise x to the yth power.</p></td></tr><tr><td  scope="row"><p>nonce</p></td><td ><p>A random number.</p></td></tr><tr><td  scope="row"><p>nonce + 1</p></td><td ><p>Add one to the nonce.</p></td></tr><tr><td  scope="row"><p>Ra</p></td><td ><p>32 byte (256 bits) random number used internally by the client.</p></td></tr><tr><td  scope="row"><p>Rb</p></td><td ><p>32-byte (256 bit) random number used internally by the server.</p></td></tr><tr><td  scope="row"><p>p</p></td><td ><p>16 byte (128 bit) prime number satisfying the property   that (p - 1)/2 is also prime (called a Sophie Germain prime).</p></td></tr><tr><td  scope="row"><p>g</p></td><td ><p>A small number that is primitive mod p.</p></td></tr><tr><td  scope="row"><p>Ma</p></td><td ><p>g^Ra mod p (sent by the client to the server in the first message); 16 bytes.</p></td></tr><tr><td  scope="row"><p>Mb</p></td><td ><p>g^Rb mod p (sent by the server to the client in the second message); 16 bytes.</p></td></tr><tr><td  scope="row"><p>K</p></td><td ><p>Key = Mb^Ra mod p = Ma^Rb mod p.</p></td></tr><tr><td  scope="row"><p>(dataBytes, IV)K</p></td><td ><p>Encrypt dataBytes using CAST 128 CBC using initialization vector (IV).</p></td></tr><tr><td  scope="row"><p>C2SIV</p></td><td ><p>Client-to-server initialization vector.</p></td></tr><tr><td  scope="row"><p>S2CIV</p></td><td ><p>Server-to-client initializaion vector.</p></td></tr></table></div><p>For DHX, the constants p and g are defined as follows (MSB first):</p><div class="codesample"><table><tr><td scope="row"><pre>UInt8 p = { 0xBA, 0x28, 0x73, 0xDF, 0xB0, 0x60, 0x57, 0xD4, 0x3F,  0x20, 0x24, 0x74,  0x4C, 0xEE, 0xE7, 0x5B  };<span></span></pre></td></tr><tr><td scope="row"><pre>UInt8 g = { 0x07 };<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr></table></div><p>For DHX, the client-to-server (C2SIV) and server-to-client S2CIV) initialization vectors are defined as follows:</p><div class="codesample"><table><tr><td scope="row"><pre>UInt8 C2SIV[] = { 0x4c, 0x57, 0x61, 0x6c, 0x6c, 0x61, 0x63, 0x65  };<span></span></pre></td></tr><tr><td scope="row"><pre>Uint8 S2CIV[] = { 0x43, 0x4a, 0x61, 0x6c, 0x62, 0x65, 0x72, 0x74  };<span></span></pre></td></tr></table></div><div class="notebox"><a name="//apple_ref/doc/uid/TP40000854-CH3-DontLinkElementID_12" title="Note"></a><p><strong>Note:</strong>&nbsp;Numbers are encoded in network byte order, most significant byte (MSB) first.</p></div><a name="//apple_ref/doc/uid/TP40000854-CH3-82771" title="Logging in Using DHX"></a><a name="//apple_ref/doc/uid/TP40000854-CH3-CHDCEDIB" title="Logging in Using DHX"></a><h5>Logging in Using DHX</h5><p>The login sequence when using the DHX UAM consists of an exchange of the four messages shown in <span class="content_text">Table 1-16</span>. In <span class="content_text">Table 1-16</span>, the pipe symbol (|) is used to separate the elements that make up the message.</p><a name="//apple_ref/doc/uid/TP40000854-CH3-82792" title="Table 1-16Login sequence using DHX"></a><a name="//apple_ref/doc/uid/TP40000854-CH3-CHDFIJEJ" title="Table 1-16Login sequence using DHX"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 1-16&nbsp;&nbsp;</strong>Login sequence using DHX</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Message</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Sender/Receiver</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Content</p></th></tr><tr><td  scope="row"><p>1</p></td><td ><p>Client to server</p></td><td ><p>| <code>FPLogin</code> (2 bytes)  | AFP Vers | <code>‘DHCAST128’</code> | username (padded) | Ma |</p></td></tr><tr><td  scope="row"><p>2</p></td><td ><p>Server to client</p></td><td ><p>| ID | Mb | (nonce, ServerSig, S2CIV)K | and a result code</p></td></tr><tr><td  scope="row"><p>3</p></td><td ><p>Client to server</p></td><td ><p>| <code>FPLoginCont</code> (2 bytes) | ID | (nonce + 1, password, C2SIV)K |</p></td></tr><tr><td  scope="row"><p>4</p></td><td ><p>Server to client</p></td><td ><p>A result code of <code>kFPNoErr</code> if authentication was successful</p></td></tr></table></div><p>In response to Message 1, the server may return the following result codes (but it may delay sending some of these result codes until Message 4):</p><ul class="spaceabove"><li class="li"><p><code>kFPBadUAM</code> — the server doesn’t support the DHX UAM.</p></li><li class="li"><p><code>kFPBadVersNum</code> — the server doesn't support the requested AFP version.</p></li><li class="li"><p><code>kFPParamErr</code> — the user name is not valid.</p></li><li class="li"><p><code>kFPMiscErr</code> — the session is already authenticated.</p></li><li class="li"><p><code>kFPServerGoingDown</code> — the server is shutting down.</p></li><li class="li"><p><code>kFPUserAlreadyLoggedOnErr</code> — the server allows only one active session per user.</p></li><li class="li"><p><code>kFPAuthContinue</code> — the server is prepared to continue to login process.</p></li></ul><p>The server may delay sending some of the above result codes until the fourth message or may report a <code>kFPUserNotAuth</code> result as <code>kFPParamErr </code>  to limit the amount of information disclosed to the client.</p><p>In response to Message 3, the server may return any of the following result codes:</p><ul class="spaceabove"><li class="li"><p><code>kFPNoErr</code> — authentication was successful; the server decrypted the nonce/password and verified that the nonce was incremented properly and the password sent by the client matches the password on the server.</p></li><li class="li"><p><code>kFPUserNotAuth</code> — the password is incorrect.</p></li><li class="li"><p><code>kFPParamErr</code> — authentication failed and the server prefers not to indicate whether the user name or the password is invalid.</p></li><li class="li"><p><code>kFPPwdExpiredErr</code> — the user’s password has expired.</p></li><li class="li"><p><code>kFPPwdNeedsChangeErr</code> — the user’s password needs to be changed.</p></li></ul><p><span class="content_text"><a href="Concepts.html#//apple_ref/doc/uid/TP40000854-CH3-83018">Figure 1-8</a></span> shows the request and reply blocks for <code>FPLogin</code> when using the DHX UAM.</p><br/><div><a name="//apple_ref/doc/uid/TP40000854-CH3-83018" title="Figure 1-8Request and reply blocks when using DHX with FPLogin"></a><a name="//apple_ref/doc/uid/TP40000854-CH3-CHBHHGJB" title="Figure 1-8Request and reply blocks when using DHX with FPLogin"></a><p><strong>Figure 1-8&nbsp;&nbsp;</strong>Request and reply blocks when using DHX with <code>FPLogin</code></p><img src = "../Art/afp_082.gif" alt = "Request and reply blocks when using DHX with FPLogin" width="509" height="270"></div><br/><a name="//apple_ref/doc/uid/TP40000854-CH3-83744" title="Changing Passwords Using DHX"></a><a name="//apple_ref/doc/uid/TP40000854-CH3-CHDECJDB" title="Changing Passwords Using DHX"></a><h5>Changing Passwords Using DHX</h5><p>There is no equivalent to <code>FPLoginCont </code>when changing a password, so the client has send the <code>FPChangePassword</code> command at least twice and use the ID to <code></code>keep track of the state of the password-changing process. The ID first appears in Message 1 and is set to 2 bytes of 0x00. The server sends a non-zero value for ID in Message 2, and the client must copy it from Message 2 into Message 3. The key used to encrypt the old and new passwords is created in the same  way as the key when logging in. The values of p and g are the same values that are used when logging in.</p><p>When using the DHX UAM, the password changing sequence consists of an exchange of at least four messages shown in <span class="content_text">Table 1-17</span>. In <span class="content_text">Table 1-17</span>, the pipe symbol (|) is used to separate the elements that make up the message.</p><a name="//apple_ref/doc/uid/TP40000854-CH3-83777" title="Table 1-17Password-changing sequence using DHX"></a><a name="//apple_ref/doc/uid/TP40000854-CH3-CHDBCIAE" title="Table 1-17Password-changing sequence using DHX"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 1-17&nbsp;&nbsp;</strong>Password-changing sequence using DHX</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Message</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Sender/Receiver</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Content</p></th></tr><tr><td  scope="row"><p>1</p></td><td ><p>Client to server</p></td><td ><p> | <code>FPChangePassword</code> (2 bytes)  | <code>‘DHCAST128’</code> | Username (padded) | ID (0x00 0x00) | Ma |</p></td></tr><tr><td  scope="row"><p>2</p></td><td ><p>Server to client</p></td><td ><p>| ID | Mb | (nonce, ServerSig, S2CIV)K | and a result code</p></td></tr><tr><td  scope="row"><p>3</p></td><td ><p>Client to server</p></td><td ><p> | <code>FPChangePassword</code> (2 bytes)  | <code>‘DHCAST128’</code> | Username (padded) | ID | (nonce + 1, newPassword, oldPassword, C2SIV)K |</p></td></tr><tr><td  scope="row"><p>4</p></td><td ><p>Server to client</p></td><td ><p>A result code of <code>kFPNoErr</code> if the password was changed</p></td></tr></table></div><p>In response to Message 1, the server may return any of the following result codes (or may wait until it receives the second <code>FPChangePassword</code> command to return the first three result codes):</p><ul class="spaceabove"><li class="li"><p><code>kFPBadUAM</code> —the server doesn’t support DHX for changing passwords.</p></li><li class="li"><p><code>kFPParamErr</code> — the user name is not valid.</p></li><li class="li"><p><code>kFPServerGoingDown</code> — the server is shutting down.</p></li><li class="li"><p><code>kFPAuthContinue</code> — the server is prepared to continue the password-changing process.</p></li></ul><p>In response to Message 3, the server may return any of the following result codes:</p><ul class="spaceabove"><li class="li"><p><code>kFPNoErr</code> — the password was changed.</p></li><li class="li"><p><code>kFPUserNotAuth</code> — the old password is incorrect.</p></li><li class="li"><p><code>kFPParamErr</code> — to limit the amount of information released to the client.</p></li><li class="li"><p><code>kFPPwdPolicyErr</code> — the new password does not conform to the server’s password policy.</p></li><li class="li"><p><code>kFPPwdSameErr</code> — the new password is the same as the old password.</p></li><li class="li"><p><code>kFPPwdTooShortErr</code> — the new password is too short.</p></li></ul><p><span class="content_text"><a href="Concepts.html#//apple_ref/doc/uid/TP40000854-CH3-83984">Figure 1-9</a></span> shows the request and reply blocks for calling <code>FPChangePassword </code><code></code>with the DHX UAM.</p><br/><div><a name="//apple_ref/doc/uid/TP40000854-CH3-83984" title="Figure 1-9Request and reply blocks when using DHX with FPChangePassword"></a><a name="//apple_ref/doc/uid/TP40000854-CH3-CHBGDJBH" title="Figure 1-9Request and reply blocks when using DHX with FPChangePassword"></a><p><strong>Figure 1-9&nbsp;&nbsp;</strong>Request and reply blocks when using DHX with <code>FPChangePassword</code></p><img src = "../Art/afp_084.gif" alt = "Request and reply blocks when using DHX with FPChangePassword" width="526" height="255"></div><br/><a name="//apple_ref/doc/uid/TP40000854-CH3-81479" title="Diffie-Hellman Key Exchange 2"></a><a name="//apple_ref/doc/uid/TP40000854-CH3-CHDDAIFH" title="Diffie-Hellman Key Exchange 2"></a><h4>Diffie-Hellman Key Exchange 2</h4><p>Diffie-Hellman Key Exchange 2 (DHX2) is an implementation of the Diffie-Hellman Key Agreement Protocol using the SSLeay/OpenSSL implementation of CAST 128 in CBC mode. The UAM protocol name for DHX2 is <code>‘DHX2’</code>.</p><p>DHX2 differs from DHX in that DHX2 uses variable-sized prime (p) and generator (g) values, which allows servers to choose an appropriate level of security. The minimum size of the prime is increased to 512 bits to improve resistance to numerical methods of attack. In addition, unlike DHX, DHX2 does not use the server signature(ServerSig) in Message 2.</p><p>DHX2 is strong against packet sniffing attacks but vulnerable to active attacks such “Man in the Middle.” There is no way for the client to verify that the server knows the password, so the server could easily be spoofed. There is some weakness in using fixed initialization vectors, p and g, which is alleviated by putting the random nonces first in the encrypted portions of the messages. DHX2 is useful when the server requires passwords in cleartext. </p><p>As with DHX, in DHX2 the client and server each generate  a random number, Ra and Rb respectively, which serve as “private keys” for the  session. The client and server use modulus exponentiation to derive “public keys”,  Ma and Mb, from the private keys and exchange them. The client combines Ra and Mb, and  the server combines Ma with Rb to generate identical session keys, K.</p><p> After the key exchange is complete, a key verification phase follows.  Each side generates a random number (nonce), encrypts it with the session key,  and sends it to the other side. Each side takes the other’s verifier, decrypts  to get the nonce, modifies the nonce in a way that is known to both parties, encrypts it with the session key, and sends it back. The originator verifies  that the nonce was modified as expected. Incrementing the nonce is a simple  and effective way of modifying the verifier.</p><p><span class="content_text">Table 1-18</span> lists the values used to calculate the content of messages exchanged between the client and server when the UAM is DHX2.</p><a name="//apple_ref/doc/uid/TP40000854-CH3-80616" title="Table 1-18Variables used by the DHX2 UAM"></a><a name="//apple_ref/doc/uid/TP40000854-CH3-CHDEIBHB" title="Table 1-18Variables used by the DHX2 UAM"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 1-18&nbsp;&nbsp;</strong>Variables used by the DHX2 UAM</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Value</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Meaning</p></th></tr><tr><td  scope="row"><p>password</p></td><td ><p>User password padded with nulls to 256 bytes.</p></td></tr><tr><td  scope="row"><p>username</p></td><td ><p>Pascal string (pstring), padded to an even byte length. </p></td></tr><tr><td  scope="row"><p>AFP Vers</p></td><td ><p>Pascal string (pstring) denoting the version of the AFP protocol used for the session.</p></td></tr><tr><td  scope="row"><p>ID</p></td><td ><p>A two-byte number used by the server to keep track of the login/change   password request. The server may send any two-byte number, the client passes it   back unchanged.</p></td></tr><tr><td  scope="row"><p>ID + 1 </p></td><td ><p>The ID incremented by one.</p></td></tr><tr><td  scope="row"><p>clientNonce </p></td><td ><p>A 16-byte random number used in the key verification portion of the exchange.</p></td></tr><tr><td  scope="row"><p>serverNonce</p></td><td ><p>A 16-byte random number used in the key verification portion of the exchange.</p></td></tr><tr><td  scope="row"><p>clientNonce + 1</p></td><td ><p>The clientNonce incremented by one.</p></td></tr><tr><td  scope="row"><p>MD5(data)</p></td><td ><p>Take the MD5 hash of the data, which results in a 16-byte (128 bit) value.</p></td></tr><tr><td  scope="row"><p>p</p></td><td ><p>A variable length prime number (at minimum 512 bits in size) satisfying the property that (p - 1)/2 is also a prime(called a Sophie Germain prime) sent by the server to the client. (Two byte length followed by data.)</p></td></tr><tr><td  scope="row"><p>g</p></td><td ><p>A small number that is primitive mod p sent by the server to the client. (Four bytes.)</p></td></tr><tr><td  scope="row"><p> x^y</p></td><td ><p>Raise x to the yth power.</p></td></tr><tr><td  scope="row"><p>Ra</p></td><td ><p>An x bit random number used internally by the client.</p></td></tr><tr><td  scope="row"><p>Rb</p></td><td ><p>An x bit random number used internally by the server.</p></td></tr><tr><td  scope="row"><p>Ma</p></td><td ><p>g^Ra mod p (sent by the client to the server); the same number of bytes as p, padded with nulls at the MSB end.</p></td></tr><tr><td  scope="row"><p>Mb</p></td><td ><p>g^Rb mod p (sent by the server to the client); the same number of bytes as p, padded with nulls at the MSB end.</p></td></tr><tr><td  scope="row"><p>x</p></td><td ><p>The size of p in bits.</p></td></tr><tr><td  scope="row"><p>len</p></td><td ><p>The size of p &amp; Ma &amp; Mb in bytes; a two-byte value.</p></td></tr><tr><td  scope="row"><p>K</p></td><td ><p>Key = MD5(Mb^Ra mod p) = MD5(Ma^Rb mod p)</p></td></tr><tr><td  scope="row"><p>(dataBytes, IV)K</p></td><td ><p>Encrypt dataBytes using CAST 128 CBC using initialization vector (IV)</p></td></tr><tr><td  scope="row"><p>C2SIV</p></td><td ><p>Client-to-server initialization vector.</p></td></tr><tr><td  scope="row"><p>S2CIV</p></td><td ><p>Server-to-client initialization vector.</p></td></tr></table></div><p>For DHX2, the client-to-server (C2SIV) and server-to-client (S2CIV) initialization vectors are defined as follows:</p><div class="codesample"><table><tr><td scope="row"><pre>UInt8 C2SIV[] = { 0x4c, 0x57, 0x61, 0x6c, 0x6c, 0x61, 0x63, 0x65  };<span></span></pre></td></tr><tr><td scope="row"><pre>Uint8 S2CIV[] = { 0x43, 0x4a, 0x61, 0x6c, 0x62, 0x65, 0x72, 0x74  };<span></span></pre></td></tr></table></div><div class="notebox"><a name="//apple_ref/doc/uid/TP40000854-CH3-DontLinkElementID_13" title="Note"></a><p><strong>Note:</strong>&nbsp;Numbers are encoded in network byte order; most significant byte (MSB) first. The constants C2SIV and S2CIV have the same definitions in DHX and DHX2.</p></div><a name="//apple_ref/doc/uid/TP40000854-CH3-84728" title="Logging In Using DHX2"></a><a name="//apple_ref/doc/uid/TP40000854-CH3-CHDHDBFH" title="Logging In Using DHX2"></a><h5>Logging In Using DHX2</h5><p>When using the DHX2 UAM, the login sequence consists of an exchange of the six messages shown in <span class="content_text">Table 1-19</span>. In <span class="content_text">Table 1-19</span>, the pipe symbol (|) is used to separate the elements that make up the message.</p><a name="//apple_ref/doc/uid/TP40000854-CH3-84744" title="Table 1-19Login sequence using DHX2"></a><a name="//apple_ref/doc/uid/TP40000854-CH3-CHDHJFEF" title="Table 1-19Login sequence using DHX2"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 1-19&nbsp;&nbsp;</strong>Login sequence using DHX2</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Message</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Sender/Receiver</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Content</p></th></tr><tr><td  scope="row"><p>1</p></td><td ><p>Client to server</p></td><td ><p>| <code>FPLogin</code> (2 bytes)  | AFP Vers | <code>‘DHX2’</code> | Username (padded) |</p></td></tr><tr><td  scope="row"><p>2</p></td><td ><p>Server to client</p></td><td ><p>| ID | g | len | p | Mb | and a result code</p></td></tr><tr><td  scope="row"><p>3</p></td><td ><p>Client to server</p></td><td ><p>| <code>FPLoginCont</code> (2 bytes) | ID | Ma | (client nonce, C2SIV)K |</p></td></tr><tr><td  scope="row"><p>4</p></td><td ><p>Server to client</p></td><td ><p>| ID + 1 | (clientNonce + 1, serverNonce, S2CIV)K | and a result code</p></td></tr><tr><td  scope="row"><p>5</p></td><td ><p>Client to server</p></td><td ><p>| <code>FPLoginCont</code> (2 bytes) | ID + 1 | (serverNonce+1, password, C2SIV)K |</p></td></tr><tr><td  scope="row"><p>6</p></td><td ><p>Server to client</p></td><td ><p>A result code of <code>kFPNoErr</code> if authentication was successful</p></td></tr></table></div><p>Some older implementations of Apple's AFP client add ten extra bytes to the end of the <code>FPLoginCont</code> packet (message five in <span class="content_text">Table 1-19</span>). Similarly, two extra bytes are added to the end of message two in <span class="content_text">Table 1-19</span>. Servers should ignore the presence and contents of these bytes.</p><p>In response to Message 1, the server may return the following result codes (but it may delay sending some of these result codes until Message 6):</p><ul class="spaceabove"><li class="li"><p><code>kFPBadUAM</code> — the server doesn’t support the DHX2 UAM.</p></li><li class="li"><p><code>kFPBadVersNum</code> — the server doesn't support the requested AFP version.</p></li><li class="li"><p><code>kFPParamErr</code> — the user name is not valid.</p></li><li class="li"><p><code>kFPMiscErr</code> — the session is already authenticated.</p></li><li class="li"><p><code>kFPServerGoingDown</code> — the server is shutting down.</p></li><li class="li"><p><code>kFPUserAlreadyLoggedOnErr</code> — the server allows only one active session per user.</p></li><li class="li"><p><code>kFPAuthContinue</code> — the server is prepared to continue to login process.</p></li></ul><p>The server may delay sending some of the above result codes until the sixth message or may report a <code>kFPUserNotAuth</code> result as <code>kFPParamErr </code>  to limit the amount of information disclosed to the client.</p><p>In response to the <code>FPLoginCont</code> command, the server may return any of the following result codes:</p><ul class="spaceabove"><li class="li"><p><code>kFPNoErr</code> — authentication was successful; the server decrypted the nonce/password and verified that the nonce was incremented properly and the password sent by the client matches the password on the server</p></li><li class="li"><p><code>kFPUserNotAuth</code> — the password is incorrect</p></li><li class="li"><p><code>kFPParamErr</code> — authentication failed and the server prefers not to indicate whether the user name or the password is invalid</p></li><li class="li"><p><code>kFPPwdExpiredErr</code> — the user’s password has expired</p></li><li class="li"><p><code>kFPPwdNeedsChangeErr</code> — the user’s password needs to be changed</p></li></ul><a name="//apple_ref/doc/uid/TP40000854-CH3-85006" title="Changing Passwords Using DHX2"></a><a name="//apple_ref/doc/uid/TP40000854-CH3-CHDEFBDE" title="Changing Passwords Using DHX2"></a><h5>Changing Passwords Using DHX2</h5><p>There is no equivalent to <code>FPLoginCont </code>when changing a password, so the client has send the <code>FPChangePassword</code> command at least twice and use the ID to <code></code>keep track of the state of the password-changing process. The ID first appears in Message 1 and is set to 2 bytes of 0x00. The server sends a non-zero value for ID in Message 2, and the client must copy it from Message 2 into Message 3 as well as from Message 4 into Message 5. The key used to encrypt the old and new passwords is created in the same  way as the key when logging in. The values of p and g are the same values that are used when logging in.</p><p>When using the DHX2 UAM, the password changing sequence consists of an exchange of at least six messages shown in <span class="content_text">Table 1-20</span>. In <span class="content_text">Table 1-20</span>, the pipe symbol (|) is used to separate the elements that make up the message.</p><a name="//apple_ref/doc/uid/TP40000854-CH3-85039" title="Table 1-20Password-changing sequence using DHX2"></a><a name="//apple_ref/doc/uid/TP40000854-CH3-CHDGGECA" title="Table 1-20Password-changing sequence using DHX2"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 1-20&nbsp;&nbsp;</strong>Password-changing sequence using DHX2</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Message</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Sender/Receiver</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Content</p></th></tr><tr><td  scope="row"><p>1</p></td><td ><p>Client to server</p></td><td ><p> | <code>FPChangePassword</code> (2 bytes)  | <code>‘DHX2’</code> | Username (padded) | ID (0x00 0x00) |</p></td></tr><tr><td  scope="row"><p>2</p></td><td ><p>Server to client</p></td><td ><p>| ID | g | len | p | Mb | and a result code</p></td></tr><tr><td  scope="row"><p>3</p></td><td ><p>Client to server</p></td><td ><p> | <code>FPChangePassword</code> (2 bytes)  | <code>‘DHX2’</code> | Username (padded) | ID | Ma | (clientNonce, C2SIV)K |</p></td></tr><tr><td  scope="row"><p>4</p></td><td ><p>Server to client</p></td><td ><p>| ID+1 | (clientNonce+1, serverNonce, S2CIV)K | and a result code</p></td></tr><tr><td  scope="row"><p>5</p></td><td ><p>Client to server</p></td><td ><p>| <code>FPChangePassword</code> (2 bytes) | <code>‘DHX2’</code> | Username (padded) | ID+1 | (serverNonce+1, newPassword, oldPassword, C2SIV)K |</p></td></tr><tr><td  scope="row"><p>6</p></td><td ><p>Server to client</p></td><td ><p>A result code of <code>kFPNoErr</code> if the password was changed</p></td></tr></table></div><p>In response to Message 1, the server may return <code>kFPAuthContinue</code> or any of the following result codes:</p><ul class="spaceabove"><li class="li"><p><code>kFPBadUAM</code> —the server doesn’t support DHX2 for changing passwords.</p></li><li class="li"><p><code>kFPParamErr</code> — the user name is not valid.</p></li><li class="li"><p><code>kFPServerGoingDown</code> — the server is shutting down.</p></li></ul><p>In response to Message 3, the server may return <code>kFPAuthContinue</code> or any of the following result codes:</p><ul class="spaceabove"><li class="li"><p><code>kFPUserNotAuth</code> — the old password is incorrect.</p></li><li class="li"><p><code>kFPPwdPolicyErr</code> — the new password does not conform to the server’s password policy.</p></li><li class="li"><p><code>kFPPwdSameErr</code> — the new password is the same as the old password.</p></li><li class="li"><p><code>kFPPwdTooShortErr</code> — the new password is too short.</p></li></ul><a name="//apple_ref/doc/uid/TP40000854-CH3-55950" title="Kerberos"></a><a name="//apple_ref/doc/uid/TP40000854-CH3-CHBFFAFD" title="Kerberos"></a><h4>Kerberos</h4><p>The AFP client learns whether a server supports the Kerberos UAM by examining the <code>kSupportsDirServices</code> bit in the <code>Flags</code> parameter returned by the <code>FPGetSrvrInfo </code>command. If that bit is set, a server that supports Kerberos UAM places its principal name in the <code>DirectoryNames </code>parameter returned by <code>FPGetSrvrInfo</code>. </p><p>The AFP client uses the principal name to determine if the server supports Kerberos v4 or v5.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40000854-CH3-DontLinkElementID_14" title="Note"></a><p><strong>Note:</strong>&nbsp;Mac OS X AFP servers only support Kerberos V5 authentication.</p></div><p>Then the client tries to get a service ticket from the server. If it cannot get a ticket, the client must use some other authentication method. If the client gets a service ticket, it can call <code>FPLoginExt</code>, providing the following values in the request block:</p><ul class="spaceabove"><li class="li"><p>two-byte <code>Flags </code>parameter</p></li><li class="li"><p>AFP Version string</p></li><li class="li"><p>UAM string (<code>Client Krb v2</code>)</p></li><li class="li"><p><code>kFPUTF8Name</code> (defined as 3)</p></li><li class="li"><p>length of the user name that follows</p></li><li class="li"><p>UTF-8–encoded user name</p></li><li class="li"><p><code>kFPUTF8Name</code> (defined as 3)</p></li><li class="li"><p>length of the realm in that follows</p></li><li class="li"><p>UTF-8–encoded realm</p></li></ul><p>The server replies with a result code of <code>kFPAuthContinue</code>. The reply block contains a two-byte <code>ID </code>value.</p><p>If the client is using Kerberos v4, it calls <code>FPLoginCont, </code>providing the following values in the request block:</p><ul class="spaceabove"><li class="li"><p>UTF-8–encoded user name</p></li><li class="li"><p>pad byte if one is necessary to force user name to end on an even boundary</p></li><li class="li"><p>length of the ticket that follows</p></li><li class="li"><p>ticket, created by <code>KClientGetTicketForService()</code></p></li></ul><p>The user is authenticated if the server returns a result code of <code>kFPNoErr </code>and a reply block consisting of a two-byte length parameter and an authenticator.</p><p>If the client is using Kerberos v5, it calls <code>FPLoginCont</code>, providing the following values in the request block:</p><ul class="spaceabove"><li class="li"><p>ID returned by <code>FPLoginExt</code></p></li></ul><ul class="spaceabove"><li class="li"><p>UTF-8–encoded user name</p></li><li class="li"><p>pad byte if one is necessary to force user name to end on an even boundary</p></li><li class="li"><p>length of the ticket that follows</p></li><li class="li"><p>ticket, created by <code>gss_init_sec_context</code> with <code>GSS_C_MUTUAL_FLAG</code> and <code>GSS_C_REPLAY_FLAG</code> set and no channel bindings</p></li></ul><p>The user is authenticated if the server returns a result code of <code>kFPNoErr </code>and a reply block consisting of a two-byte length parameter and an authenticator.</p><p>After the client receives the <code>FPLoginCont</code> reply packet, the client sends an <code>FPGetSessionToken</code> command with a type of <code>kGetKerberosSessionKey</code> (8) in order to get a random session key from the server. This session key is encrypted on the server using <code>gss_wrap()</code> and is decrypted on the client using <code>gss_unwrap()</code>. Note that the client may call <code>FPGetSessionToken</code> later on in order to get a disconnect token.</p><p><span class="content_text"><a href="Concepts.html#//apple_ref/doc/uid/TP40000854-CH3-87967">Figure 1-10</a></span> shows the request and reply blocks for <code>FPLoginExt</code> and <code>FPLoginCont </code>when using the Kerberos UAM.</p><br/><div><a name="//apple_ref/doc/uid/TP40000854-CH3-87967" title="Figure 1-10Request and reply blocks when using Kerberos with FPLoginExt"></a><a name="//apple_ref/doc/uid/TP40000854-CH3-CHBDEFGF" title="Figure 1-10Request and reply blocks when using Kerberos with FPLoginExt"></a><p><strong>Figure 1-10&nbsp;&nbsp;</strong>Request and reply blocks when using Kerberos with <code>FPLoginExt</code></p><img src = "../Art/afp_094.gif" alt = "Request and reply blocks when using Kerberos with FPLoginExt" width="499" height="463"></div><br/><a name="//apple_ref/doc/uid/TP40000854-CH3-87985" title="Reconnect"></a><a name="//apple_ref/doc/uid/TP40000854-CH3-BIHBGEJA" title="Reconnect"></a><h4>Reconnect</h4><p>Unlike the other UAMs described in this section, which are used to log in to an AFP server, the Reconnect UAM is used only to reconnect to a server. The Reconnect UAM can be used when the original connection was made using a UAM that provides a session key, such as DHX, DHX2, and Kerberos. The UAM protocol name for the Reconnect UAM is <code>‘Recon1’</code>.</p><p>The goals of the Reconnect UAM are:</p><ul class="spaceabove"><li class="li"><p>Store in a token returned by the <code>FPGetSessionToken</code> command all of the information required to reconnect, even if the server has been rebooted.</p></li><li class="li"><p>Use only a secure hash function and a symmetric encryption algorithm.</p></li><li class="li"><p>Provide mutual authentication to prove that the server to which the client is reconnecting is the same server that was originally authenticated.</p></li><li class="li"><p>Ensure that a compromised session key or seed value will not compromise the long term server key.</p></li></ul><p><span class="content_text">Table 1-21</span> lists the variables used to calculate values for the Reconnect UAM.</p><a name="//apple_ref/doc/uid/TP40000854-CH3-88042" title="Table 1-21Variables used by the Reconnect UAM"></a><a name="//apple_ref/doc/uid/TP40000854-CH3-BIHJCCDB" title="Table 1-21Variables used by the Reconnect UAM"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 1-21&nbsp;&nbsp;</strong>Variables used by the Reconnect UAM</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Value</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Size in Bytes</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Meaning</p></th></tr><tr><td  scope="row"><p>k1</p></td><td ><p>16</p></td><td ><p>Initial session key returned by the UAM that was used to log in; known to both the client and the server at the time of reconnect.</p></td></tr><tr><td  scope="row"><p>ks</p></td><td ><p>16</p></td><td ><p>Long term server key.</p></td></tr><tr><td  scope="row"><p>s</p></td><td ><p>8</p></td><td ><p>Lamports hash seed.</p></td></tr><tr><td  scope="row"><p>n</p></td><td ><p>4</p></td><td ><p>Number of times to run the hash function.</p></td></tr><tr><td  scope="row"><p>m</p></td><td ><p>4</p></td><td ><p>Maximum number of times to run the hash function (m >= n).</p></td></tr><tr><td  scope="row"><p>clientNonce</p></td><td ><p>8</p></td><td ><p>A random number selected by the client nonce.</p></td></tr><tr><td  scope="row"><p>serverNonce</p></td><td ><p>8</p></td><td ><p>A random number selected by the server.</p></td></tr><tr><td  scope="row"><p>t1</p></td><td ><p>4</p></td><td ><p>Initial timestamp.</p></td></tr><tr><td  scope="row"><p>t2</p></td><td ><p>4</p></td><td ><p>Timestamp used when reconnecting.</p></td></tr><tr><td  scope="row"><p>t3</p></td><td ><p>4</p></td><td ><p>Time interval between the server’s clock and the client’s clock.</p></td></tr><tr><td  scope="row"><p>exp</p></td><td ><p>4</p></td><td ><p>Credential’s expiration time.</p></td></tr><tr><td  scope="row"><p>now</p></td><td ><p>4</p></td><td ><p>Current time as known by the server or by the client.</p></td></tr><tr><td  scope="row"><p>user/domain</p></td><td ><p></p></td><td ><p>Username information that uniquely identifies the user.</p></td></tr><tr><td  scope="row"><p>sessionInfo</p></td><td ><p></p></td><td ><p>Information that uniquely identifies a session.</p></td></tr><tr><td  scope="row"><p>(data)key</p></td><td ><p></p></td><td ><p>Data encrypted using a symmetric encryption algorithm using key. (CBC mode)</p></td></tr><tr><td  scope="row"><p>(data)H</p></td><td ><p></p></td><td ><p>Data hashed with a secure hash function.</p></td></tr><tr><td  scope="row"><p>(data)H(n)</p></td><td ><p></p></td><td ><p>Data hashed n times with a secure hash function.</p></td></tr><tr><td  scope="row"><p>(data)HMAC(key)</p></td><td ><p></p></td><td ><p>Data signed by a keyed HMAC algorithm.</p></td></tr><tr><td  scope="row"><p>revocation list</p></td><td ><p></p></td><td ><p>List of hash value and time-to-live pairs. Pairs stay in the list until the time-to-live value has passed.</p></td></tr><tr><td  scope="row"><p>cred</p></td><td ><p></p></td><td ><p>(s, m, exp, t3, user/domain)ks</p></td></tr></table></div><p><span class="content_text">Table 1-22</span> describes common methods of attack and the ways in which the Reconnect UAM is protected from these attacks.</p><a name="//apple_ref/doc/uid/TP40000854-CH3-88273" title="Table 1-22Attacks on the Reconnect UAM"></a><a name="//apple_ref/doc/uid/TP40000854-CH3-BIHJECGB" title="Table 1-22Attacks on the Reconnect UAM"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 1-22&nbsp;&nbsp;</strong>Attacks on the Reconnect UAM</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Attack</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Defense</p></th></tr><tr><td  scope="row"><p>Man in the Middle</p></td><td ><p>If the original UAM used to connect to the server was resistant to Man in the Middle attacks, nonce checks in message <em>a</em>, which require knowledge of <code></code><em>s</em>, should keep out the Man in the Middle.</p></td></tr><tr><td  scope="row"><p>Replay</p></td><td ><p>The timestamp in message <code></code><em>a</em>, protected by the HMAC, and the credential revocation list should prevent simple replay attacks. Even if the attacker succeeds in controlling the clock on the server and manages to force a server restart, the attacker cannot log in because s is not known, so the challenge/response step cannot be performed successfully.</p></td></tr><tr><td  scope="row"><p>Reflection</p></td><td ><p>This type of attack is thwarted by the use of chained nonces, by having the user information in the credential, and by having each message be non-symmetrical.</p></td></tr><tr><td  scope="row"><p>Interleaving</p></td><td ><p>This type of attack is thwarted by the use of chained nonces.</p></td></tr><tr><td  scope="row"><p>Chosen Text</p></td><td ><p>The server’s key is not used to encrypt any data that is obtained from the client.</p></td></tr><tr><td  scope="row"><p>Forced Delay</p></td><td ><p>Timestamps, key expiration and the use of the revocation list should thwart this type of attack.</p></td></tr></table></div><a name="//apple_ref/doc/uid/TP40000854-CH3-88352" title="Getting a Credential"></a><a name="//apple_ref/doc/uid/TP40000854-CH3-CHDDBJDG" title="Getting a Credential"></a><h5>Getting a Credential</h5><p>After the client successfully logs in and mounts a remote volume, it calls <code>FPGetSessionToken</code>, setting the <code></code><code>Type</code> parameter to <code>kRecon1Login</code> (5), and sending to the server its initial timestamp (t1) encrypted with the session key (k1):</p><p>(t1)k1</p><p>As a result of the login process, the server also knows the session key (k1) and the sessionInfo for this session. The server also has a long term session key (ks).</p><p>The server uses t1 to compute the clock skew and determine an appropriate expiration time for the credential it is about to create. The server then generates a credential by concatenating the Lamports hash seed (s), the maximum number of times to run the hash function (m), the expiration time, the user/domain, and encrypting the concatenation using its long term session key (ks):</p><p>cred = (s, m, exp, t3, user/domain)ks</p><p>The server also computes (cred)H and stores the result in its revocation list. The server then uses the session key (k1) to encrypt a concatenation of the credential (cred), the Lamports hash seed (s), the maximum number of times to run the hash function (m), the expiration time (exp), and sessionInfo, and sends the result to the client. The formula for this calculation is:</p><p>(cred, s, m, exp, sessionInfo)k1</p><p>The client uses the session key (k1) to decrypt the result, obtaining the encrypted credential, the Lamports hash seed, the maximum number of times to run the hash function, the encrypted credential’s expiration time, and the sessionInfo. The client is responsible for storing this information so that it can use it later.</p><p><span class="content_text">Table 1-23</span> summarizes the exchange between client and server when getting a credential.</p><a name="//apple_ref/doc/uid/TP40000854-CH3-89063" title="Table 1-23Getting a credential"></a><a name="//apple_ref/doc/uid/TP40000854-CH3-CHDGIBEC" title="Table 1-23Getting a credential"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 1-23&nbsp;&nbsp;</strong>Getting a credential</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Message</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Sender/Receiver</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Content</p></th></tr><tr><td  scope="row"><p>1</p></td><td ><p>Client to server</p></td><td ><p> | <code>FPGetSessionToken</code> (2 bytes)  | <code>kRecon1Login</code> | IDLength | (t1)k1 | ID |</p></td></tr><tr><td  scope="row"><p>2</p></td><td ><p>Server to client</p></td><td ><p>| (cred, s, m, exp, sessionInfo)k1 |</p></td></tr></table></div><a name="//apple_ref/doc/uid/TP40000854-CH3-88417" title="Refreshing the Credential"></a><a name="//apple_ref/doc/uid/TP40000854-CH3-CHDBIIEF" title="Refreshing the Credential"></a><h5>Refreshing the Credential</h5><p>Before the credential expires, the client calls <code>FPGetSessionToken</code> again, setting the <code>Type</code> parameter to <code>kRecon1RefreshToken</code> (7) and sending to the server the initial timestamp (t1) and the current credential encrypted with the session key (k1). The formula for this calculating this value is:</p><p>(t1, cred)k1</p><p>Both the client and the server compute k2 using the following formula:</p><p>k2 = (cred, s)H</p><p>The server decrypts the value sent by the client. If the credential is valid, the server creates a new credential encrypted with the long term session key and a new expiration time, stores (cred’)H on the revocation list, and returns the encrypted credential to the client along with a new Lamports hash seed, a new maximum number of times to run the hash function, and the sessionInfo, all encrypted by k2. The formula for creating this value is:</p><p>(cred’, s’, m’, exp’, sessionInfo)k2</p><p>The client uses k2 to decrypt the reply, obtaining the new credential, the new Lamports hash seed, the new maximum number of times to run the hash function, the new expiration and the sessionInfo. Before this credential expires, the client refreshes it again.</p><p><span class="content_text">Table 1-24</span> summarizes the exchange between client and server when refreshing a credential.</p><a name="//apple_ref/doc/uid/TP40000854-CH3-89212" title="Table 1-24Refreshing a credential"></a><a name="//apple_ref/doc/uid/TP40000854-CH3-CHDFAIIC" title="Table 1-24Refreshing a credential"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 1-24&nbsp;&nbsp;</strong>Refreshing a credential</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Message</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Sender/Receiver</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Content</p></th></tr><tr><td  scope="row"><p>1</p></td><td ><p>Client to server</p></td><td ><p> | <code>FPGetSessionToken</code> (2 bytes)  | <code>kRecon1RefreshToken</code> | IDLength| (t1, cred)k1 | ID |</p></td></tr><tr><td  scope="row"><p>2</p></td><td ><p>Server to client</p></td><td ><p>| (cred’, s’, m’, exp’, sessionInfo)k2 |</p></td></tr></table></div><a name="//apple_ref/doc/uid/TP40000854-CH3-88473" title="Using the Credential to Reconnect"></a><a name="//apple_ref/doc/uid/TP40000854-CH3-CHDJGEFE" title="Using the Credential to Reconnect"></a><h5>Using the Credential to Reconnect</h5><p>If the connection to the server goes down for any reason, the client has the current credential, the Lamports hash seed (s), and the maximum number of times to run the hash (m).</p><p>The client logs back in using the <code>FPLoginExt </code>command, specifying <code>Recon1ReconnectLogin</code> as the UAM, and sending the following information to the server:</p><p>(cred, (s)H(n), n, t2, (clientNonce)[(s)H(n-1])HMAC(s)</p><p>The server uses its long term session key (ks) to decrypt cred. If decryption fails, the server fails the login attempt. It also retrieves s, m, exp, t3, and user/domain. </p><p>If the decryption succeeds, the server computes (cred)H and looks it up in the revocation list. If found, the credential has expired, so the server fails the login attempt.</p><p>If (cred)H is not found in the revocation list, the server checks exp, m >= n, and HMAC(s) user/domain. If any are invalid, the server fails the login attempt.</p><p>The server then computes and compares (s)H(n)’ and (s)H(n1). If they don’t match, the server fails the login attempt.</p><p>The server then decrypts and hashes clientNonce, chooses serverNonce, adds (cred)H, t3+now to the revocation list, and sends the following value to the client:</p><p>(serverNonce, (clientNonce)H)[(s)H(n-1)]</p><p>The client decrypts the value, verifies (clientNonce)H, and hashes serverNonce. The client uses the <code>FPLoginCont</code> command to send the following value to the server:</p><p>((serverNonce)H[(s)H(n-1)]</p><p>The server decrypts the value and verifies (serverNonce)H. If they don’t match, the server fails the login attempt. If they match, the server replies to the client with a result code of <code>kFPNoErr</code>. The client is now logged in. Both the server and the client make the following calculation:</p><p>k1’ = (clientNonce, serverNonce)H</p><p>The client calls <code>FPGetSessionToken </code>using k1’ as the session key to get a new credential. It also calls <code>FPDisconnectOldSession</code> to tell the server to disconnect the old session and transfer is resources to the new session.</p><p><span class="content_text">Table 1-25</span> summarizes the exchange between client and server when reconnecting.</p><a name="//apple_ref/doc/uid/TP40000854-CH3-88849" title="Table 1-25Reconnecting using the Recon1 UAM"></a><a name="//apple_ref/doc/uid/TP40000854-CH3-CHDHFFFI" title="Table 1-25Reconnecting using the Recon1 UAM"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 1-25&nbsp;&nbsp;</strong>Reconnecting using the Recon1 UAM</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Message</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Sender/Receiver</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Content</p></th></tr><tr><td  scope="row"><p>1</p></td><td ><p>Client to server</p></td><td ><p> | <code>FPLoginExt</code> (2 bytes) | Flags | AFP version | <code>‘Recon1’</code> | UserNameType | UserName | PathType | Pathname | (cred, (s)H(n), n, t2, (clientNonce)[(s)H(n-1])HMAC(s) |</p></td></tr><tr><td  scope="row"><p>2</p></td><td ><p>Server to client</p></td><td ><p>|(serverNonce, (clientNonce)H)[(s)H(n-1)] | and a result code</p></td></tr><tr><td  scope="row"><p>3</p></td><td ><p>Client to server</p></td><td ><p> | <code>FPLoginCont</code> (2 bytes) | ID | ((serverNonce)H[(s)H(n-1)] |</p></td></tr><tr><td  scope="row"><p>4</p></td><td ><p>Server to client</p></td><td ><p><code>kFPNoErr</code> or another result code indicating log in failure</p></td></tr><tr><td  scope="row"><p>5</p></td><td ><p>Client to server if result is <code>kFPNoErr</code></p></td><td ><p>| <code>FPGetSessionToken</code> (2 bytes)  | <code>kRecon1ReconnectLogin</code> | IDLength| (t1, cred)k1 | ID |</p></td></tr></table></div><a name="//apple_ref/doc/uid/TP40000854-CH3-88576" title="Volume Passwords"></a><a name="//apple_ref/doc/uid/TP40000854-CH3-CHBCCECB" title="Volume Passwords"></a><h3>Volume Passwords</h3><p>AFP provides an optional second-level of access control through volume passwords. A server can associate a fixed-length 8-character password with each volume it makes visible to AFP clients.</p><p>The AFP client can issue an <code>FPGetSrvrParms</code> command to the server to discover the names of each volume and to get an indication of whether each of them is password-protected.</p><p>To send AFP commands that refer to a server volume, the AFP client uses a volume identifier called the Volume ID. The AFP client obtains this ID by sending an <code>FPOpenVol</code> command to the server. This command contains the name of the volume as one of its parameters. If a password is associated with the volume, the command must also include the password as another parameter.</p><p>Volume passwords constitute a simple protection for servers that do not need to implement the directory access controls described in the next section. However, volume passwords are not as secure as directory access controls.</p><a name="//apple_ref/doc/uid/TP40000854-CH3-56219" title="Directory Access Controls"></a><a name="//apple_ref/doc/uid/TP40000854-CH3-CHBDIEBG" title="Directory Access Controls"></a><h3>Directory Access Controls</h3><p>Directory access controls provide the greatest degree of network security in AFP by access privileges to users. Once the user has logged in, access privileges allow users varying degrees of freedom for performing actions within the directory structure.</p><p>AFP defines three directory access privileges: search, read, and write:</p><ul class="spaceabove"><li class="li"><p>A user with <em>search</em> access to a directory can list the parameters of directories contained within the directory.</p></li><li class="li"><p>A user with <em>read</em> access to a directory can list the parameters of files contained within the directory in addition to being able to read the contents of a file.</p></li><li class="li"><p>A user with <em>write</em> access to a directory can modify the contents of a directory including the parameters of files and directories contained within the directory. Write access allows the user to ad and delete directories and files as well as modify the data contained within a file.</p></li></ul><p>Each directory on a server volume has an owner and a group affiliation. Initially, the owner is the user who created the directory, although ownership of a directory may be transferred to another user. Only the owner of a directory can change its access privileges. The server uses a name of up to 31 characters and a four-byte ID number to represent owners of directories. Owner name and Owner ID are synonymous with User name and User ID.</p><p>The group affiliation is used to assign a different set of access privileges for the directory to a group of users. For each group, the server maintains a name of up to 31 characters, a four-byte ID number and a list of users belonging to the group. Assigning group access privileges to a directory gives those privileges to that set of users.</p><p>Each user may belong to any number of groups or to no group. One of the user’s group affiliations may be designated as the user’s primary group. This group will be assigned initially to each new directory created by the user. The directory’s group affiliation may be removed or changed later by the owner of the directory.</p><p>The term <em>Everyone</em> is used to indicate every user that is able to log in to the server. A directory may be assigned certain access privileges for Everyone that would be granted to a user who is neither the directory’s owner nor a member of the group with which the directory is affiliated.</p><p>With each directory, the file server stores three access privileges bytes, which correspond to the owner of the directory, its group affiliation, and Everyone. Each of these bytes is a bitmap that encodes the access privileges (search, read, and write) that correspond to each category. The most significant bits of each access privileges byte must be zero.</p><p>To perform directory access control, AFP associates the five parameters shown in <span class="content_text">Table 1-26</span> with each directory.</p><a name="//apple_ref/doc/uid/TP40000854-CH3-60336" title="Table 1-26Directory access control parameters "></a><a name="//apple_ref/doc/uid/TP40000854-CH3-CHBDAJAJ" title="Table 1-26Directory access control parameters "></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 1-26&nbsp;&nbsp;</strong>Directory access control parameters </caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Parameter</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Size</p></th></tr><tr><td  scope="row"><p>Owner ID</p></td><td ><p>Four bytes</p></td></tr><tr><td  scope="row"><p>Group ID</p></td><td ><p>Four bytes</p></td></tr><tr><td  scope="row"><p>Owner access privileges</p></td><td ><p>One byte</p></td></tr><tr><td  scope="row"><p>Group access privileges</p></td><td ><p>One byte</p></td></tr><tr><td  scope="row"><p>Everyone access privileges</p></td><td ><p>One byte</p></td></tr></table></div><p>The Owner ID is the same as the owner’s User ID. The Group ID is the ID number of the group with which the directory is affiliated, or zero. The file server maintains a one-to-one mapping between the Owner ID and the user name and between the Group ID and the group name. As a result, each name is associated with a unique ID. AFP includes commands that allow users to map IDs to names and names to IDs. Assignment of User IDs, Group IDs, and primary groups is an administrative function and is outside the scope of this protocol.</p><p>A Group ID of zero means that the directory has no group affiliation. The groups access privileges are ignored.</p><p>When a user logs on to a server, identifiers are retrieved from a user database maintained on the server. These identifiers include the User ID (a four-byte number unique among all server users) and one or more four-byte Group IDs, which indicate the user’s group memberships. The exact number of group memberships is implementation-dependent. One of these Group IDs may represent the user’s primary group.</p><p>The server must be able to derive what access privileges a particular user has to a certain directory. The user access privileges (UARights) contain a summary of the privileges, regardless of the category (Owner, Group, Everyone) from which they were obtained. In addition, the user access privileges contain a flag indicating whether the user owns the directory.</p><p>The server uses the following algorithm to extract user access privileges. The OR in this algorithm indicates inclusive OR operations.</p><div class="codesample"><table><tr><td scope="row"><pre>UARights := Everyone’s access rights;<span></span></pre></td></tr><tr><td scope="row"><pre>clear UARights owner flag<span></span></pre></td></tr><tr><td scope="row"><pre>If (Owner ID = 0) then<span></span></pre></td></tr><tr><td scope="row"><pre>    set UARights own flag<span></span></pre></td></tr><tr><td scope="row"><pre>If (User ID = Owner ID) then<span></span></pre></td></tr><tr><td scope="row"><pre>    UARights := UARights OR owner’s access privileges;<span></span></pre></td></tr><tr><td scope="row"><pre>    set UARights owner flag<span></span></pre></td></tr><tr><td scope="row"><pre>If (any of user’s Group IDs = directory’s Group ID) then<span></span></pre></td></tr><tr><td scope="row"><pre>    UARights := UARights OR directory’s group access privileges<span></span></pre></td></tr></table></div><p>An Owner ID of zero means that the directory is not owned or is owned by another user. The owner bit of the access privileges byte is always set for such a directory.</p><p>The access privileges required by the user to perform most file management functions are explained in the following paragraphs according to the symbols listed in <span class="content_text">Table 1-27</span>.</p><a name="//apple_ref/doc/uid/TP40000854-CH3-60450" title="Table 1-27Access privilege notation "></a><a name="//apple_ref/doc/uid/TP40000854-CH3-CHBBBGHD" title="Table 1-27Access privilege notation "></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 1-27&nbsp;&nbsp;</strong>Access privilege notation </caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Symbol</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Meaning</p></th></tr><tr><td  scope="row"><p><em>SA</em></p></td><td ><p>Search access to all ancestors down to, but not including the parent directory</p></td></tr><tr><td  scope="row"><p><em>WA</em></p></td><td ><p>Search or write access to all ancestors down to, but not including, the parent directory</p></td></tr><tr><td  scope="row"><p><em>SP</em></p></td><td ><p>Search access to the parent directory</p></td></tr><tr><td  scope="row"><p><em>RP</em></p></td><td ><p>Read access to the parent directory</p></td></tr><tr><td  scope="row"><p><em></em><em>WP</em></p></td><td ><p>Write access to the parent directory</p></td></tr></table></div><p>Almost all operations require <em>SA</em>. To perform any action within a given directory, the user must have permission to search every directory in the path from the root to the parent’s parent directory. Access to files and directories within the parent directory is then determined by <em>SP</em>, <em>RP</em>, and <em>WP</em>.</p><p>Specific file management functions and the access privileges needed to perform them are listed in <span class="content_text">Table 1-28</span>.</p><a name="//apple_ref/doc/uid/TP40000854-CH3-60583" title="Table 1-28File management functions and required privileges "></a><a name="//apple_ref/doc/uid/TP40000854-CH3-CHBIIDFG" title="Table 1-28File management functions and required privileges "></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 1-28&nbsp;&nbsp;</strong>File management functions and required privileges </caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Function</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Required access privileges</p></th></tr><tr><td  scope="row"><p>Create a file or a directory</p></td><td ><p>The user must have <em>WA</em> plus <em>WP</em>. A hard create (delete first of the file exists) requires the same privileges as deleting a file.</p></td></tr><tr><td  scope="row"><p>Enumerate a directory</p></td><td ><p>To enumerate a directory is to list in numerical order the offspring of the directory and selected parameters of those offspring. The user must have search access to all directories down to but not necessarily including the directory being enumerated (<em>SA</em>). In addition, to view its directory offspring, the user must have search access to the directory being enumerated (<em>SP</em>). To view its file offspring, search access to the directory is not required, but the user must have read access to the directory (<em>RP</em>).</p></td></tr><tr><td  scope="row"><p>Delete a file</p></td><td ><p>The user must have <em>SA</em>, <em>RP</em>, and <em>WP</em>. A file can be deleted only it if is not open at that time.</p></td></tr><tr><td  scope="row"><p>Delete a directory</p></td><td ><p>The user must have <em>WA</em> plus <em>WP</em>. A hard create (delete first of the file exists) requires the same privileges as deleting a file.</p></td></tr><tr><td  scope="row"><p>Rename a file</p></td><td ><p>To enumerate a directory is to list in numerical order the offspring of the directory and selected parameters of those offspring. The user must have search access to all directories down to but not necessarily including the directory being enumerated (<em>SA</em>). In addition, to view its directory offspring, the user must have search access to the directory being enumerated (<em>SP</em>). To view its file offspring, search access to the directory is not required, but the user must have read access to the directory (<em>RP</em>).</p></td></tr><tr><td  scope="row"><p>Rename a directory</p></td><td ><p>The user must have <em>SA</em>, <em>RP</em>, and <em>WP</em>. A file can be deleted only it if is not open at that time.</p></td></tr><tr><td  scope="row"><p>Rename a file</p></td><td ><p>The user must have <em>SA</em>, <em>SP</em>, and <em>WP</em>. A directory can be deleted only if it is empty</p></td></tr><tr><td  scope="row"><p>Rename a directory</p></td><td ><p>The user must have <em>SA</em>, <em>RP</em>, and <em>WP</em>.</p></td></tr><tr><td  scope="row"><p>Read directory parameters</p></td><td ><p>The user must have SA and SP.</p></td></tr><tr><td  scope="row"><p>Open a file for reading</p></td><td ><p>A file’s fork must be opened in read mode before its contents can be read. To open a file in read mode, the user must have <em>SA</em> and <em>RP</em>. Read mode and other access modes are described in the next section.</p></td></tr><tr><td  scope="row"><p>Open a file for writing</p></td><td ><p>A file’s fork must be opened in write mode in order to write to it. To open an empty fork for writing, the user must have <em>WA</em> and <em>WP</em>. (The empty fork must belong to a file that has both forks of zero length. To open an existing fork (when either fork is not empty) for writing, <em>SA</em>, <em>RP</em>, and <em>WP</em> are required.</p></td></tr><tr><td  scope="row"><p>Write file parameters</p></td><td ><p>For an empty file (where both forks are zero length), the user must have <em>WA</em> plus <em>WP</em>. For a non-empty file (where one or both forks are not zero length), the user must have <em>SA</em>, <em>RP</em>, and <em>WP</em>.</p></td></tr><tr><td  scope="row"><p>Write directory parameters</p></td><td ><p>For directories that contain offspring, the user must <em>SA</em>, <em>SP</em>, and <em>WP</em>. For directories that are empty, the user must have <em>WA</em> and <em>WP</em>.</p></td></tr><tr><td  scope="row"><p>Move a directory or a file</p></td><td ><p>Through AFP, a directory or a file can be moved from its parent directory to a destination parent directory on the same volume. To move a directory, the use must have <em>SA </em>and <em>SP</em> to the source parent directory, <em>WA</em> to the destination parent directory, plus <em>WA</em> to both the source and the destination parent directories. To move a file, the user needs <em>SA</em> plus <em>RP</em> to the source parent directory, plus <em>WP</em> to both the source and the destination parent directories.</p></td></tr><tr><td  scope="row"><p>Modify a directory’s privileges</p></td><td ><p>A directory’s Owner ID, Group ID, and the three access privileges bytes can be modified only if the user is the directory’s owner and then only if the user has <em>WA</em> plus <em>WP</em> or <em>SP</em> access to the parent directory.</p></td></tr><tr><td  scope="row"><p>Copy a file (<em></em><code>FPCopyFile</code>)</p></td><td ><p>To copy a file, on a single volume or across volumes managed by the server, the user must have <em>SA</em> plus <em>RP</em> access to the source parent and <em>WA</em> plus <em>WP</em> to the destination parent directory.</p></td></tr></table></div><a name="//apple_ref/doc/uid/TP40000854-CH3-56871" title="Inherited Access Privileges"></a><a name="//apple_ref/doc/uid/TP40000854-CH3-CHBFCIFB" title="Inherited Access Privileges"></a><h4>Inherited Access Privileges</h4><p>AFP Version 2.1 and later supports inherited access privileges through the directory’s Blank Access Privileges bit in the Directory bitmap. When the Blank Access Privileges bit is set for a directory, its other access privilege bits are ignored and the access privilege bits of the directory’s parent apply to the directory, including the parent’s group affiliation.</p><p>The Blank Access Privileges bit cannot be set for a directory that is a share point. Likewise, the Blank Access Privileges bit cannot be set for a volume root directory (Directory ID = 2) of a shared volume because it is always a share point for the administrator/owner.</p><div class="importantbox"><a name="//apple_ref/doc/uid/TP40000854-CH3-DontLinkElementID_15" title="Important:"></a><p><strong>Important:</strong>&nbsp;Inherited access privileges are useful because they cause access privileges to behave as users expect them to: When a directory with the Blank Access Privileges bit set is moved within the directory hierarchy, it always reflects the access privileges of the directory containing it. When the Blank Access Privileges bit is cleared, its current access privileges “stick” to that directory and remain unchanged no matter where the directory is moved. Therefore, although implementing inherited access privileges is optional, it is highly recommended that you include this feature in your AFP implementation as it has subtle human interface repercussions.</p><p></p></div><a name="//apple_ref/doc/uid/TP40000854-CH3-57324" title="File Sharing Modes"></a><a name="//apple_ref/doc/uid/TP40000854-CH3-CHBBGICJ" title="File Sharing Modes"></a><h2>File Sharing Modes</h2><p>AFP controls user access to shared files in two ways. The first, described in the previous section, provides security by controlling user access to specific directories. The second, described in this section, preserves data integrity by controlling a user’s access to a file while it is being used by another user.</p><p>To control simultaneous file access, the file server must enforce synchronization rules. These rules prevent applications from damaging each other’s files by modifying the same version simultaneously. These rules also prevent users from obtaining access to information while it is being changed.</p><p>Synchronization rules are built from the mode in which a first user and subsequent users open a file. AFP provides two classes of modes: access modes and deny modes.</p><a name="//apple_ref/doc/uid/TP40000854-CH3-57347" title="Access and Deny Modes"></a><a name="//apple_ref/doc/uid/TP40000854-CH3-CHBDEIJE" title="Access and Deny Modes"></a><h3>Access and Deny Modes</h3><p>Most file systems use a set of permissions to regulate the opening of files. This set includes permission to modify the contents of a file (read-write) and permission to see the file’s contents (read only). In a stand-alone system, these two file-access modes are sufficient.</p><p>In the shared environment of a file server, this set of permissions, or access modes, is expanded. In addition to the expanded set of access modes, a set of restrictions is provided by deny modes.</p><p>A user application can specify an access mode and a deny mode when it opens a file on the file server. AFP supports the access modes: read, write, read-write, and none. None access allows no further access to the fork, except to close it, and may be useful in implementing synchronization. In addition to one of these access modes, the user indicates a deny mode to the server to specify which rights should be denied to others trying to open the fork while the first user has it open. Users that subsequently try to open that fork can be denied read, write, read-write, or none access.</p><p>A user sending an <code>FPOpenFork</code> command can be denied file access for the following reasons:</p><ul class="spaceabove"><li class="li"><p>The user does not possess the rights (as owner, group, or Everyone) to open the file with the requested access mode. A result code of <code>kFPAccessDenied</code> is returned.</p></li><li class="li"><p>The fork is already open with a deny mode that prohibits the second user’s requested access. For example, the first user opened the fork with a deny mode of DenyWrite, and the second user tries to open the for in the write mode. A <code>kFPDenyConflict</code> result code is returned to the second user.</p></li><li class="li"><p>The fork is already open with an access mode that conflicts with the second user’s requested deny mode. For example, the first user opened the fork for Write access and a deny mode of DenyNone. The second user tries to open the fork with a deny mode indicating DenyWrite. This request is not granted because the fork is already open for Write access. A <code>kFPDenyConflict</code> result code is returned to the second user.</p></li></ul><p>Deny modes are cumulative in that each successful opening of a fork combines its deny mode with previous deny modes. Therefore, if the first user opening a file specifies a deny mode of DenyRead, and the second user specifies DenyWrite, the fork’s current deny mode is DenyRead-Write. DenyNone and DenyRead combine to form a current deny mode of DenyRead.</p><p>Similarly, access modes are cumulative. If the first user opening a file has Read access and the second has Write access, the current access mode is Read-Write.</p><a name="//apple_ref/doc/uid/TP40000854-CH3-57421" title="Synchronization Rules"></a><a name="//apple_ref/doc/uid/TP40000854-CH3-CHBICIIG" title="Synchronization Rules"></a><h3>Synchronization Rules</h3><p>Synchronization rules, as previously discussed, allow or deny simultaneous access to a file fork. They are based on the current deny mode and current access mode of the fork and on the new deny and access modes being requested in a new <code>FPOpenFork</code> command. Synchronization rules are summarized in <span class="content_text"><a href="Concepts.html#//apple_ref/doc/uid/TP40000854-CH3-57442">Figure 1-11</a></span>. A dot indicates that a new open command has succeeded; otherwise, it has failed.</p><br/><div><a name="//apple_ref/doc/uid/TP40000854-CH3-57442" title="Figure 1-11Synchronization rules"></a><a name="//apple_ref/doc/uid/TP40000854-CH3-CHBHFFCF" title="Figure 1-11Synchronization rules"></a><p><strong>Figure 1-11&nbsp;&nbsp;</strong>Synchronization rules</p><img src = "../Art/afp_l_06.gif" alt = "Synchronization rules" width="447" height="461"></div><br/><a name="//apple_ref/doc/uid/TP40000854-CH3-106862" title="Access Control Lists"></a><a name="//apple_ref/doc/uid/TP40000854-CH3-CHDGEHBB" title="Access Control Lists"></a><h2>Access Control Lists</h2><p>This version of AFP includes support for access control lists (ACLs), which can be enabled on a per volume basis. The inheritance and multiple ownership capabilities of ACLs improve workflow in environments where files and directories require different owners at various phases of work. When ACLs are enabled, computers running Mac OS X are full-fledged peers on Windows networks, which promotes the adoption of XServe as an NT replacement.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40000854-CH3-DontLinkElementID_16" title="Note"></a><p><strong>Note:</strong>&nbsp;ACLs also eliminate the 16 group membership limit.</p></div><p>When ACLs are enabled for a volume, each file and directory has a security descriptor. A security descriptor includes:</p><ul class="ul"><li class="li"><p>a set of flags, including flags for the discretionary and system ACL (described below), each indicating whether the ACL inherits the settings of the ACLs above it.</p></li><li class="li"><p>an owner SID, similar to the UNIX file owner</p></li><li class="li"><p>a primary group SID, similar to the UNIX file group owner</p></li><li class="li"><p>a discretionary access control list (DACL) that specifies which permissions are granted or denied to which users or groups</p></li><li class="li"><p>a system control list (SACL) that determines which file accesses by which users cause the access to be logged in a security log</p></li></ul><p>Access control entries (ACEs) in the DACLs and SACLs contain the following information:</p><ul class="ul"><li class="li"><p>a SID, specifying the user or group to which the ACE applies</p></li><li class="li"><p>a set of flags, including inheritance flags (listed in <span class="content_text">Table 1-29</span>) and a flag that applies only to SACL entries</p></li></ul><a name="//apple_ref/doc/uid/TP40000854-CH3-106931" title="Table 1-29Inheritance flags"></a><a name="//apple_ref/doc/uid/TP40000854-CH3-CHDDFADB" title="Table 1-29Inheritance flags"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 1-29&nbsp;&nbsp;</strong>Inheritance flags</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Flag</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Description</p></th></tr><tr><td  scope="row"><p><code>INHERITED_ACE</code></p></td><td ><p>Indicates whether the entry was inherited from a parent ACL.</p></td></tr><tr><td  scope="row"><p><code>INHERIT_ONLY_ACE</code></p></td><td ><p>Indicates whether the entry exists only to be propagated to children and is used only when child objects are created or when that entry is changed. If set, the entry is not checked when access or audit checks are done.</p></td></tr><tr><td  scope="row"><p><code>CONTAINER_INHERIT_ACE</code></p></td><td ><p>Indicates whether the entry should be inherited by directories below the object to which the entry applies.</p></td></tr><tr><td  scope="row"><p><code>OBJECT_INHERIT_ACE</code></p></td><td ><p>Indicates whether the entry should be inherited by files below the object to which the entry applies.</p></td></tr><tr><td  scope="row"><p><code>NO_PROPAGATE_INHERIT_ACE</code></p></td><td ><p>Indicates, when the entry is copied to a child, whether the settings of the <code>CONTAINER_INHERIT_ACE</code> and <code>OBJECT_INHERIT_ACE</code> flags should be cleared, so that changes to the entry don’t propagate to grandchildren or objects below grandchildren.</p></td></tr></table></div><ul class="ul"><li class="li"><p>a set of access right bits (listed in <span class="content_text">Table 1-30</span>); for DACL entries, the access rights bits allow or deny permission; for SACL entries, the access rights bits specifying the types of accesses to be audited</p></li></ul><a name="//apple_ref/doc/uid/TP40000854-CH3-130884" title="Table 1-30Access rights bits"></a><a name="//apple_ref/doc/uid/TP40000854-CH3-CHDFJGDH" title="Table 1-30Access rights bits"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 1-30&nbsp;&nbsp;</strong>Access rights bits</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Access right bit</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Description</p></th></tr><tr><td  scope="row"><p>Generic access rights</p></td><td ><p>The four high-order bits of the access mask format used by securable objects. Each securable object maps these bits to a set of its standard and object-specific access rights. For example, a file object maps the <code>GENERIC_READ</code> bit to the <code>READ_CONTROL</code> and <code>SYNCHRONIZE</code> standard access rights and to the <code>FILE_READ_DATA</code>, <code>FILE_READ_EA</code> and <code>FILE_READ_ATTRIBUTES</code> object-specific access rights.</p></td></tr><tr><td  scope="row"><p><code>GENERIC_ALL</code></p></td><td ><p>Read, w rite, and execute access</p></td></tr><tr><td  scope="row"><p><code>GENERIC_EXECUTE</code></p></td><td ><p>Execute access, including <code>FILE_READ_ATTRIBUTES</code>, <code>FILE_EXECUTE</code>, and <code>SYNCHRONIZE</code>, all of which are described below.</p></td></tr><tr><td  scope="row"><p><code>GENERIC_READ</code></p></td><td ><p>Read access, including <code>FILE_READ_ATTRIBUTES</code>, <code>FILE_READ_DATA</code>, <code>READ_CONTROL</code>, and <code>SYNCHRONIZE</code>, all of which are described below</p></td></tr><tr><td  scope="row"><p><code>GENERIC_WRITE</code></p></td><td ><p>Write access, including <code>FILE_APPEND_DATA</code>, <code>FILE_WRITE_ATTRIBUTES</code>, <code>FILE_WRITE_DATA</code>, <code>FILE_WRITE_EA</code>, <code>WRITE_CONTROL</code>, and <code>SYNCHRONIZE</code>, all of which are described below.</p></td></tr><tr><td  scope="row"><p>Standard access rights</p></td><td ><p>A set of standard access rights that correspond to operations common to most types of securable object. Constants defined for the standard access rights bits include the following:</p></td></tr><tr><td  scope="row"><p><code>DELETE</code></p></td><td ><p>Right to delete the object</p></td></tr><tr><td  scope="row"><p><code>READ_CONTROL</code></p></td><td ><p>Right to read the object’s security descriptor, but not including information in the SACL</p></td></tr><tr><td  scope="row"><p><code>SYNCHRONIZE</code></p></td><td ><p>Right for a thread to block until the object is in the “signaled state”</p></td></tr><tr><td  scope="row"><p><code>WRITE_DAC</code></p></td><td ><p>Right to modify the DACL in the object’s security descriptor</p></td></tr><tr><td  scope="row"><p><code>WRITE_OWNER</code></p></td><td ><p>Right to change the object’s owner in the object’s security descriptor</p></td></tr><tr><td  scope="row"><p>File and directory access rights<code></code></p></td><td ><p></p></td></tr><tr><td  scope="row"><p><code>FILE_ADD_FILE</code></p></td><td ><p>Right to create a file in a directory</p></td></tr><tr><td  scope="row"><p><code>FILE_ADD_SUBDIRECTORY</code></p></td><td ><p>Right to create a directory in a directory</p></td></tr><tr><td  scope="row"><p><code>FILE_APPEND_DATA</code></p></td><td ><p>Right to create a directory in a directory (when set for a directory) or to append data to a file (when set for a file)</p></td></tr><tr><td  scope="row"><p><code>FILE_DELETE_CHILD</code></p></td><td ><p>Right to delete a directory and all the files it contains</p></td></tr><tr><td  scope="row"><p><code>FILE_EXECUTE</code></p></td><td ><p>Right to execute a program</p></td></tr><tr><td  scope="row"><p><code>FILE_LIST_DIRECTORY</code></p></td><td ><p>Right to list the contents of a directory</p></td></tr><tr><td  scope="row"><p><code>FILE_READ_ATTRIBUTES</code></p></td><td ><p>Right to read a file’s DOS attributes, including hidden, read-only, system, and archive attributes.</p></td></tr><tr><td  scope="row"><p><code>FILE_READ_DATA</code></p></td><td ><p>Right to read data from a file or pipe (when set for a file or pipe), or to list the contents of a directory (when set for a directory)</p></td></tr><tr><td  scope="row"><p><code>FILE_READ_EA</code></p></td><td ><p>Right to read an object’s extended attributes</p></td></tr><tr><td  scope="row"><p><code>FILE_TRAVERSE</code></p></td><td ><p>Right to traverse a directory; equivalent to <code>FILE_EXECUTE</code></p></td></tr><tr><td  scope="row"><p><code>FILE_WRITE_ATTRIBUTES</code></p></td><td ><p>Right to write a file’s attributes.</p></td></tr><tr><td  scope="row"><p><code>FILE_WRITE_DATA</code></p></td><td ><p>Right to write to a file (when set for a file) or create a file in a directory (when set for a directory); when applied to a directory, this bit is equivalent to <code>FILE_ADD_FILE</code>.</p></td></tr><tr><td  scope="row"><p><code>FILE_WRITE_EA</code></p></td><td ><p>Right to write extended attributes</p></td></tr></table></div><p>An ACL can have a mixture of explicitly set and inherited ACEs. When a file or directory is created, ACEs are copied to the new object in the following order:</p><ol class="ol"><li class="li"><p>Explicit ACL entries that deny an SID certain rights</p></li><li class="li"><p>Explicit ACL entries that grant an SID certain rights</p></li><li class="li"><p>Inherited ACL entries that deny an SID certain rights</p></li><li class="li"><p>Inherited ACL entries that grant an SID certain rights</p></li></ol><p>Inherited entries are placed in order in which they are inherited. ACEs inherited from the parent come first, then entries inherited from the grandparent (that is, that the parent inherited and passed on), and so on. As ACEs are processed from first to last, explicit entries override entries inherited from further up the tree.</p><p>Inheritance occurs when the object is created and at the time an ACL for a directory is changed, and does not occur at the time that an object is moved into the directory tree. When a folder or file is moved within the volume, its ACL is also moved without change and without updating inherited permissions. Instead, the ACL is updated the next time its permissions are changed, which forces the parent to propagate its permissions.</p><p>ACEs in which the <code>CONTAINER_INHERIT_ACE</code> bit or the <code>OBJECT_INHERIT_ACE</code> bit is not set are not copied.</p><p>ACEs in which the <code>CONTAINER_INHERIT_ACE</code> bit is set are copied when a directory is created, but not when a file is created. The <code>INHERIT_ONLY_ACE</code> bit is cleared.</p><p>ACEs in which the <code>OBJECT_INHERIT_ACE</code> are copied when a file or a directory is created. If copied to a file, the <code>INHERIT_ONLY_ACE</code> bit is cleared. If copied to a directory, the <code>INHERIT_ONLY_ACE</code> bit is set. The intention is to allow directories to give one set of permissions to subdirectories and another set of permissions to files.</p><p>The <code>INHERITED_ACE</code> bit is set on all ACEs that are copied.</p><p>If the <code>NO_PROPAGATE_INHERIT_ACE</code> bit is set on the entry being copied, the <code>CONTAINER_INHERIT_ACE</code> and <code>OBJECT_INHERIT_ACE</code> bits are cleared in the copy.</p><p>When ACLs are enabled for a volume, they are mapped to effective owner, group, and everyone UNIX permissions.</p><p>When accessing remote volumes for which ACL is enabled, use the <code>FPAccess</code> command to determine whether the client has access to the file or directory, and use the <code>FPGetACL</code> command to get the ACLs for a file or directory, and the <code>FPSetACL</code> command to set the ACLs for a file or directory.</p><a name="//apple_ref/doc/uid/TP40000854-CH3-57484" title="Desktop Database"></a><a name="//apple_ref/doc/uid/TP40000854-CH3-CHBGJDCE" title="Desktop Database"></a><h2>Desktop Database</h2><p>For file server volumes, AFP provides an interface that replaces the Finder’s direct use of the Desktop file. This interface is necessary because the Desktop file was designed for a standalone environment and could not be shared by multiple users. The AFP interface to the Desktop database replaces the Desktop file and can be used transparently for both local and remote volumes.</p><p>The Desktop database is used by the file server to hold information needed specifically by the Finder to build its unique user interface, in which icons are used to represent objects on a disk volume. To create certain parts of this interface, the Finder uses the Desktop database to perform three functions:</p><ul class="ul"><li class="li"><p>to associate documents and applications with particular icons and store the icon bitmaps</p></li><li class="li"><p>to locate the corresponding application when a user opens a document</p></li><li class="li"><p>to hold text comments associated with files and directories</p></li></ul><p>Macintosh applications usually contain an icon that is to be displayed for the application itself as well as other icons to be displayed for documents that the application creates. These icons are stored in the application’s resource fork and in the Desktop database. The Desktop database associates these icons with each file’s creator (the <code>fdCreator</code> field in the FInfo record) and the type (the <code>fdType</code> field in the FInfo record), which are stored as part of the file’s Finder information.</p><p>The Finder allows a Mac OS user to open a document, that is, to select a file and implicitly start the application that created the file. To do this, the Desktop database maintains a mapping between the file creator and a list of the locations of each application that has that file creator associated with it. This mapping is referred to as an APPL mapping because all Macintosh applications have a file creator of <code>‘APPL’</code>. The Finder obtains the first item in the list and tries to start the application. If for some reason the application cannot be started (for example, if it is currently in use), the Finder will obtain the next application from the Desktop database’s list and try that one. This list is dynamically filtered to present to the Finder only those applications for which the AFP client has the proper access rights.</p><p>The Desktop database is also a repository for the text of comments associated with files and directories on the volume. The Finder will make calls to the Desktop database to read or write these comments, which can be viewed and modified by selecting the Get Info item in the Finder’s File menu. Comments are completely uninterpreted by the Desktop database.</p><p>For more information about the Finder and the use of the Desktop file, refer to <em>Inside Mac OS X</em>.</p><a name="//apple_ref/doc/uid/TP40000854-CH3-58652" title="Character Encoding"></a><a name="//apple_ref/doc/uid/TP40000854-CH3-CHBBEJDF" title="Character Encoding"></a><h2>Character Encoding</h2><p>If the server and the sharepoint support UTF-8 names, the AFP server and client send and receive decomposed UTF-8. However, characters in the range of U2000 to U2FFF, UFE30 to UFE4F, and U2F800 to U2FA1F are not decomposed. For complex characters, Unicode 3.2-based tables are used. For additional information, see <span class="content_text"><a href="http://developer.apple.com/technotes/tn/tn1150.html#UnicodeSubtleties" target="_top">http://developer.apple.com/technotes/tn/tn1150.html#UnicodeSubtleties</a></span><code></code> and the Unicode specifications.</p><p>For Macintosh Roman, AFP utilizes character string entity names that can be composed of any 8-bit character. Character representations are exactly the same as those used by the Mac OS and are shown in <span class="content_text"><a href="Concepts.html#//apple_ref/doc/uid/TP40000854-CH3-58677">Figure 1-12</a></span>.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40000854-CH3-DontLinkElementID_17" title="Note"></a><p><strong>Note:</strong>&nbsp;The information in this section applies only to Macintosh Roman character representations and does not apply to Unicode character representations.</p></div><br/><div><a name="//apple_ref/doc/uid/TP40000854-CH3-58677" title="Figure 1-12AFP character set mapping"></a><a name="//apple_ref/doc/uid/TP40000854-CH3-CHBHADEG" title="Figure 1-12AFP character set mapping"></a><p><strong>Figure 1-12&nbsp;&nbsp;</strong>AFP character set mapping</p><img src = "../Art/afp_l_07.gif" alt = "AFP character set mapping" width="516" height="520"></div><br/><p>Throughout AFP, character string comparison is done in a case-insensitive manner (that is, K = k), and it must also be done in a diacritical-sensitive manner (that is, e  é).</p><p>The mapping in <span class="content_text">Figure 1-12</span> shows the rules for uppercase equivalence of characters in AFP. Any character that does not appear in this table has no uppercase equivalent in AFP and therefore can only match itself. Note that this mapping does not exactly conform to the standards used in all human languages. In certain languages, the uppercase equivalent of e is E; in other languages (and in AFP), it is E´.</p>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../Introduction/Introduction.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../UsingLoginCommands/UsingLoginCommands.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2006 Apple Computer, Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2006-04-04<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Networking/Conceptual/AFP/Concepts/Concepts.html%3Fid%3DTP40000854-4.1&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Networking/Conceptual/AFP/Concepts/Concepts.html%3Fid%3DTP40000854-4.1&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Networking/Conceptual/AFP/Concepts/Concepts.html%3Fid%3DTP40000854-4.1&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>