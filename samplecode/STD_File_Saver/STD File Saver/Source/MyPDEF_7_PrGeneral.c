/*** Copyright 1991-1996 Apple Computer. All rights reserved.****	You may incorporate this sample code into your applications without**	restriction, though the sample code has been provided "AS IS" and the**	responsibility for its operation is 100% yours.  However, what you are**	not permitted to do is to redistribute the source as "DSC Sample Code"**	after having made changes. If you're going to re-distribute the source,**	we require that you make it clear in the source that the code was**	descended from Apple Sample Code, but that you've made changes.*/#include <Printing.h>#include <Files.h>#include "driverTypes.h"enum {	// PrGeneral result codes as defined in IM:Imaging, 9-74	prGeneralNoErr = 0,	noSuchResolution,	opcodeNotSupported};pascal void FilePrGeneral(Ptr pData);#if defined(__MWERKS__)asm void __Startup__ (void);asm void __Startup__ (void){	JMP	FilePrGeneral}#endifstatic void GetResolution(TGetRslBlk *data){#ifdef VAR_RESOLUTION	SysEnvRec theWorld;	SysEnvirons(1, &theWorld);	if (!theWorld.hasColorQD) {		// if we don't have color QD, we can't have var-res		setPrintErr(noErr);		data->iRgType = VER_SHORT;		data->iError = noErr;		data->xRslRg.iMin = 0;		data->xRslRg.iMax = 0;		data->yRslRg.iMin = 0;		data->yRslRg.iMax = 0;		data->iRslRecCnt = 1;		data->rgRslRec[0].iXRsl = 72;		data->rgRslRec[0].iYRsl = 72;	} else {		// variable resolution. Wee-haw.	}#else	setPrintErr(noErr);	data->iError = noErr;	data->iRgType = VER_SHORT;	data->xRslRg.iMin = 0;	data->xRslRg.iMax = 0;	data->yRslRg.iMin = 0;	data->yRslRg.iMax = 0;	data->iRslRecCnt = 1;	data->rgRslRec[0].iXRsl = 72;	data->rgRslRec[0].iYRsl = 72;#endif}static void SetResolution(TSetRslBlk *data){#ifdef VAR_RESOLUTION	SysEnvRec theWorld;	SysEnvirons(1, &theWorld);	if (!theWorld.hasColorQD) {		// we can't support setting the resolution if we only said we		// had one choice and no range. Error.		setPrintErr(opcodeNotSupported);		data->iError = opcodeNotSupported;	} else {		setPrintErr(noErr);		data->iError = noErr;		// Change the resolution to what they asked for	}#else	setPrintErr(opcodeNotSupported);	data->iError = opcodeNotSupported;#endif}static void DraftBits(TDftBitsBlk *data){#ifdef DEBUG	DebugStr("\pprGeneral DraftBits called, and I haven't written it yet!");#endif	setPrintErr(noErr);	data->iError = opcodeNotSupported;}static void GetRotation(TGetRotnBlk *data){	THPrint	printHandle = data->hPrint;	Rect	pageRect = (**printHandle).prInfo.rPage;	short	width = pageRect.right - pageRect.left;	short	height = pageRect.bottom - pageRect.top;	// the following logic is overly simplistic and won't deal with	// pages that are designed to be landscape (i.e. ledger instead	// of tabloid), but it works for the sizes I've defined. Note	// that there just isn't a good way to deal with LEF pages in	// the old printing architecture. GX has a way of dealing with	// them, but if you were interested in GX, you wouldn't be	// looking at this sample, now would you? -DaveP	data->fLandscape = (width > height);	data->iError = noErr;	setPrintErr(noErr);}// refer to Inside Macintosh vol. V and the relevant Technical Notes for details pascal void FilePrGeneral(Ptr pData){	TGnlData *localData = (TGnlData *)pData;	setPrintErr(prGeneralNoErr);	switch (localData->iOpCode) { 		case getRslDataOp:			GetResolution((TGetRslBlk *)pData);			break;		case setRslOp:			SetResolution((TSetRslBlk *)pData);			break;		case draftBitsOp:		case noDraftBitsOp:			DraftBits((TDftBitsBlk *)pData);			break;		case getRotnOp:			GetRotation((TGetRotnBlk *)pData);			break;		default:#ifdef DEBUG			DebugStr("\pprGeneral called with a selctor I don't understand.");#endif			setPrintErr(opcodeNotSupported);			localData->iError = opcodeNotSupported;			break;	}}