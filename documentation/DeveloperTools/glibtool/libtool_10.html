<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html401/loose.dtd">
<html>
<!-- Created on February, 19 2008 by texi2html 1.70 -->
<!--
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Many creative people <dev@texi2html.cvshome.org>
Send bugs and suggestions to <users@texi2html.cvshome.org>

-->
<head>
<title>GNU Libtool: 10. Using libltdl</title>

<meta name="description" content="GNU Libtool: 10. Using libltdl">
<meta name="keywords" content="GNU Libtool: 10. Using libltdl">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="texi2html 1.70">
<meta http-equiv="Content-Type" content="text/html; charset=us-ascii">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
pre.display {font-family: serif}
pre.format {font-family: serif}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: serif; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: serif; font-size: smaller}
pre.smalllisp {font-size: smaller}
ul.toc {list-style: none}
-->
</style>


</head>

<body lang="en" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">

<a name="NOD46"></a>
<a name="SEC45"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left" scope="row">[<a href="libtool_9.html#SEC44" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC46" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libtool_9.html#SEC40" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="libtool.html#SEC_Top" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libtool_11.html#SEC53" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libtool.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libtool_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libtool_15.html#SEC86" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libtool_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h1 class="chapter"> 10. Using libltdl </h1>

<p>Libtool provides a small library, called `<tt>libltdl</tt>', that aims at
hiding the various difficulties of dlopening libraries from programmers.
It consists of a header-file and a small C source file that can be
distributed with applications that need dlopening functionality.  On
some platforms, whose dynamic linkers are too limited for a simple
implementation of `<tt>libltdl</tt>' services, it requires GNU DLD, or it
will only emulate dynamic linking with libtool's dlpreopening mechanism.

</p>
<p>libltdl supports currently the following dynamic linking mechanisms:

</p><ul>
<li>
<p><code>dlopen</code> (Solaris, Linux and various BSD flavors)
</p></li><li>
<p><code>shl_load</code> (HP-UX)
</p></li><li>
<p><code>LoadLibrary</code> (Win16 and Win32)
</p></li><li>
<p><code>load_add_on</code> (BeOS)
</p></li><li>
<p>GNU DLD (emulates dynamic linking for static libraries)
</p></li><li>
<p>libtool's dlpreopen (see see section <a href="libtool_9.html#SEC42">Dlpreopening</a>)
</p></li></ul>


<p>libltdl is licensed under the terms of the GNU Library General Public License,
with the following exception:

</p><blockquote>
<p>As a special exception to the GNU Lesser General Public License,
if you distribute this file as part of a program or library that
is built using GNU libtool, you may include it under the same
distribution terms that you use for the rest of that program.
</p></blockquote>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top" scope="row"><a href="#SEC46">10.1 How to use libltdl in your programs</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top"></td></tr>
<tr><td align="left" valign="top" scope="row"><a href="#SEC47">10.2 Creating modules that can be <code>dlopen</code>ed</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top"></td></tr>
<tr><td align="left" valign="top" scope="row"><a href="#SEC48">10.3 Using libtldl in a multi threaded environment</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">	Registering callbacks for multi-thread safety.
</td></tr>
<tr><td align="left" valign="top" scope="row"><a href="#SEC49">10.4 Data associated with loaded modules</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">    Associating data with loaded modules.
</td></tr>
<tr><td align="left" valign="top" scope="row"><a href="#SEC50">10.5 How to create and register new module loaders</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">  Creating user defined module loaders.
</td></tr>
<tr><td align="left" valign="top" scope="row"><a href="#SEC52">10.6 How to distribute libltdl with your package</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top"></td></tr>
</table>

<hr size="6">
<a name="NOD47"></a>
<a name="SEC46"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left" scope="row">[<a href="#SEC45" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC47" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC45" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC45" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libtool_11.html#SEC53" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libtool.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libtool_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libtool_15.html#SEC86" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libtool_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 10.1 How to use libltdl in your programs </h2>


<p>The libltdl API is similar to the dlopen interface of Solaris and Linux,
which is very simple but powerful.

</p>
<p>To use libltdl in your program you have to include the header file `<tt>ltdl.h</tt>':

</p><table><tr><td scope="row">&nbsp;</td><td><pre class="example">#include &lt;ltdl.h&gt;
</pre></td></tr></table>

<p>The last release of libltdl used some symbols that violated the
<small>POSIX</small> namespace conventions.  These symbols are now deprecated,
and have been replaced by those described here.  If you have code that
relies on the old deprecated symbol names, defining
`<samp>LT_NON_POSIX_NAMESPACE</samp>' before you include `<tt>ltdl.h</tt>' provides
conversion macros.  Whichever set of symbols you use, the new api is
not binary compatible with the last, so you will need to recompile
your application in order to use this version of libltdl.

</p>
<p>Note that libltdl is not threadsafe, i.e. a multithreaded application
has to use a mutex for libltdl.  It was reported that GNU/Linux's glibc
2.0's <code>dlopen</code> with `<samp>RTLD_LAZY</samp>' (which libltdl uses by
default) is not thread-safe, but this problem is supposed to be fixed in
glibc 2.1.  On the other hand, `<samp>RTLD_NOW</samp>' was reported to introduce
problems in multi-threaded applications on FreeBSD.  Working around
these problems is left as an exercise for the reader; contributions are
certainly welcome.

</p>
<p>The following types are defined in `<tt>ltdl.h</tt>':

</p><dl>
<dt><u>Type:</u> <b>lt_ptr</b>
<a name="IDX71"></a>
</dt>
<dd><p><code>lt_ptr</code> is a generic pointer.
</p></dd></dl>

<dl>
<dt><u>Type:</u> <b>lt_dlhandle</b>
<a name="IDX72"></a>
</dt>
<dd><p><code>lt_dlhandle</code> is a module &quot;handle&quot;.
Every lt_dlopened module has a handle associated with it.
</p></dd></dl>

<dl>
<dt><u>Type:</u> <b>lt_dlsymlist</b>
<a name="IDX73"></a>
</dt>
<dd><p><code>lt_dlsymlist</code> is a symbol list for dlpreopened modules.
This structure is described in see section <a href="libtool_9.html#SEC42">Dlpreopening</a>.
</p></dd></dl>



<p>libltdl provides the following functions:

</p><dl>
<dt><u>Function:</u> int <b>lt_dlinit</b><i> (void)</i>
<a name="IDX74"></a>
</dt>
<dd><p>Initialize libltdl.
This function must be called before using libltdl
and may be called several times.
Return 0 on success, otherwise the number of errors.
</p></dd></dl>

<dl>
<dt><u>Function:</u> int <b>lt_dlexit</b><i> (void)</i>
<a name="IDX75"></a>
</dt>
<dd><p>Shut down libltdl and close all modules.
This function will only then shut down libltdl when it was called as
many times as <code>lt_dlinit</code> has been successfully called.
Return 0 on success, otherwise the number of errors.
</p></dd></dl>

<dl>
<dt><u>Function:</u> lt_dlhandle <b>lt_dlopen</b><i> (const char *<var>filename</var>)</i>
<a name="IDX76"></a>
</dt>
<dd><p>Open the module with the file name <var>filename</var> and return a
handle for it.  <code>lt_dlopen</code> is able to open libtool dynamic
modules, preloaded static modules, the program itself and
native dynamic libraries.

</p><p>Unresolved symbols in the module are resolved using its dependency
libraries (not implemented yet) and previously dlopened modules.  If the
executable using this module was linked with the <code>-export-dynamic</code>
flag, then the global symbols in the executable will also be used to
resolve references in the module.

</p><p>If <var>filename</var> is <code>NULL</code> and the program was linked with
<code>-export-dynamic</code> or <code>-dlopen self</code>, <code>lt_dlopen</code> will
return a handle for the program itself, which can be used to access its
symbols.

</p><p>If libltdl cannot find the library and the file name <var>filename</var> does
not have a directory component it will additionally search in the
following search paths for the module (in the order as follows):

</p><ol>
<li><p> user-defined search path:
This search path can be changed by the program using the
functions <code>lt_dlsetsearchpath</code>, <code>lt_dladdsearchdir</code> and
<code>lt_dlinsertsearchdir</code>.

</p></li><li><p> libltdl's search path:
This search path is the value of the environment variable
<var>LTDL_LIBRARY_PATH</var>.

</p></li><li><p> system library search path:
The system dependent library search path
(e.g. on Linux it is <var>LD_LIBRARY_PATH</var>).
</p></li></ol>

<p>Each search path must be a colon-separated list of absolute directories,
for example, <code>&quot;/usr/lib/mypkg:/lib/foo&quot;</code>.

</p><p>If the same module is loaded several times, the same handle is returned.
If <code>lt_dlopen</code> fails for any reason, it returns <code>NULL</code>.
</p></dd></dl>

<dl>
<dt><u>Function:</u> lt_dlhandle <b>lt_dlopenext</b><i> (const char *<var>filename</var>)</i>
<a name="IDX77"></a>
</dt>
<dd><p>The same as <code>lt_dlopen</code>, except that it tries to append
different file name extensions to the file name.
If the file with the file name <var>filename</var> cannot be found
libltdl tries to append the following extensions:

</p><ol>
<li><p> the libtool archive extension `<samp>.la</samp>'
</p></li><li><p> the extension used for native dynamic libraries on the host platform,
e.g., `<samp>.so</samp>', `<samp>.sl</samp>', etc.
</p></li></ol>

<p>This lookup strategy was designed to allow programs that don't
have knowledge about native dynamic libraries naming conventions
to be able to <code>dlopen</code> such libraries as well as libtool modules
transparently.
</p></dd></dl>

<dl>
<dt><u>Function:</u> int <b>lt_dlclose</b><i> (lt_dlhandle <var>handle</var>)</i>
<a name="IDX78"></a>
</dt>
<dd><p>Decrement the reference count on the module <var>handle</var>.
If it drops to zero and no other module depends on this module,
then the module is unloaded.
Return 0 on success.
</p></dd></dl>

<dl>
<dt><u>Function:</u> lt_ptr <b>lt_dlsym</b><i> (lt_dlhandle <var>handle</var>, const char *<var>name</var>)</i>
<a name="IDX79"></a>
</dt>
<dd><p>Return the address in the module <var>handle</var>, where the symbol given
by the null-terminated string <var>name</var> is loaded.
If the symbol cannot be found, <code>NULL</code> is returned.
</p></dd></dl>

<dl>
<dt><u>Function:</u> const char * <b>lt_dlerror</b><i> (void)</i>
<a name="IDX80"></a>
</dt>
<dd><p>Return a human readable string describing the most
recent error that occurred from any of libltdl's functions.
Return <code>NULL</code> if no errors have occurred since initialization
or since it was last called.
</p></dd></dl>

<dl>
<dt><u>Function:</u> int <b>lt_dlpreload</b><i> (const lt_dlsymlist *<var>preloaded</var>)</i>
<a name="IDX81"></a>
</dt>
<dd><p>Register the list of preloaded modules <var>preloaded</var>.
If <var>preloaded</var> is <code>NULL</code>, then all previously registered
symbol lists, except the list set by <code>lt_dlpreload_default</code>,
are deleted. Return 0 on success.
</p></dd></dl>

<dl>
<dt><u>Function:</u> int <b>lt_dlpreload_default</b><i> (const lt_dlsymlist *<var>preloaded</var>)</i>
<a name="IDX82"></a>
</dt>
<dd><p>Set the default list of preloaded modules to <var>preloaded</var>, which
won't be deleted by <code>lt_dlpreload</code>.  Note that this function does
<em>not</em> require libltdl to be initialized using <code>lt_dlinit</code> and
can be used in the program to register the default preloaded modules.
Instead of calling this function directly, most programs will use the
macro <code>LTDL_SET_PRELOADED_SYMBOLS</code>.

</p><p>Return 0 on success.
</p></dd></dl>

<dl>
<dt><u>Macro:</u> <b>LTDL_SET_PRELOADED_SYMBOLS</b>
<a name="IDX83"></a>
</dt>
<dd><p>Set the default list of preloaded symbols.
Should be used in your program to initialize libltdl's
list of preloaded modules.

</p><table><tr><td scope="row">&nbsp;</td><td><pre class="example">#include &lt;ltdl.h&gt;

int main() {
  /* ... */
  LTDL_SET_PRELOADED_SYMBOLS();
  /* ... */
}
</pre></td></tr></table></dd></dl>

<dl>
<dt><u>Function:</u> int <b>lt_dladdsearchdir</b><i> (const char *<var>search_dir</var>)</i>
<a name="IDX84"></a>
</dt>
<dd><p>Append the search directory <var>search_dir</var> to the current user-defined
library search path. Return 0 on success.
</p></dd></dl>

<dl>
<dt><u>Function:</u> int <b>lt_dlinsertsearchdir</b><i> (const char *<var>before</var>, const char *<var>search_dir</var>)</i>
<a name="IDX85"></a>
</dt>
<dd><p>Insert the search directory <var>search_dir</var> into the user-defined library
search path, immediately before the element starting at address
<var>before</var>.  If <var>before</var> is `<samp>NULL</samp>', then <var>search_dir</var> is
appending as if <code>lt_dladdsearchdir</code> had been called.  Return 0 on success.
</p></dd></dl>

<dl>
<dt><u>Function:</u> int <b>lt_dlsetsearchpath</b><i> (const char *<var>search_path</var>)</i>
<a name="IDX86"></a>
</dt>
<dd><p>Replace the current user-defined library search path with
<var>search_path</var>, which must be a colon-separated list of absolute
directories.  Return 0 on success.
</p></dd></dl>

<dl>
<dt><u>Function:</u> const char * <b>lt_dlgetsearchpath</b><i> (void)</i>
<a name="IDX87"></a>
</dt>
<dd><p>Return the current user-defined library search path.
</p></dd></dl>

<dl>
<dt><u>Function:</u> int <b>lt_dlforeachfile</b><i> (const char *<var>search_path</var>, int (*<var>func</var>) (const char *<var>filename</var>, lt_ptr <var>data</var>), lt_ptr <var>data</var>)</i>
<a name="IDX88"></a>
</dt>
<dd><p>In some applications you may not want to load individual modules with
known names, but rather find all of the modules in a set of
directories and load them all during initialisation.  With this function
you can have libltdl scan the colon delimited directory list in
<var>search_path</var> for candidates, and pass them, along with <var>data</var>
to your own callback function, <var>func</var>.  If <var>seach_path</var> is
`<samp>NULL</samp>', then search all of the standard locations that
<code>lt_dlopen</code> would examine.  This function will continue to make
calls to <var>func</var> for each file that it discovers in <var>search_path</var>
until one of these calls returns non-zero, or until the files are
exhausted.  `<samp>lt_dlforeachfile</samp>' returns value returned by the last
call made to <var>func</var>.

</p><p>For example you could define <var>func</var> to build an ordered
<em>argv</em>-like vector of files using <var>data</var> to hold the address of
the start of the vector.
</p></dd></dl>

<dl>
<dt><u>Function:</u> int <b>lt_dlmakeresident</b><i> (lt_dlhandle <var>handle</var>)</i>
<a name="IDX89"></a>
</dt>
<dd><p>Mark a module so that it cannot be `<samp>lt_dlclose</samp>'d.  This can be
useful if a module implements some core functionality in your project,
which would cause your code to crash if removed.  Return 0 on success.

</p><p>If you use `<samp>lt_dlopen (NULL)</samp>' to get a <var>handle</var> for the running
binary, that handle will always be marked as resident, and consequently
cannot be successfully `<samp>lt_dlclose</samp>'d.
</p></dd></dl>

<dl>
<dt><u>Function:</u> int <b>lt_dlisresident</b><i> (lt_dlhandle <var>handle</var>)</i>
<a name="IDX90"></a>
</dt>
<dd><p>Check whether a particular module has been marked as resident, returning 1
if it has or 0 otherwise.  If there is an error while executing this
function, return -1 and set an error message for retrieval with
<code>lt_dlerror</code>.
</p></dd></dl>

<dl>
<dt><u>Variable:</u> lt_ptr (*) (size_t <var>size</var>) <b>lt_dlmalloc</b>
<a name="IDX91"></a>
</dt>
<dt><u>Variable:</u> lt_ptr (*) (lt_ptr <var>ptr</var>, size_t <var>size</var>) <b>lt_dlrealloc</b>
<a name="IDX92"></a>
</dt>
<dt><u>Variable:</u> void (*) (lt_ptr <var>ptr</var>) <b>lt_dlfree</b>
<a name="IDX93"></a>
</dt>
<dd><p>These variables are set to <code>malloc</code>, <code>realloc</code> and <code>free</code> by
default, but you can set them to any other functions that provide equivalent
functionality.  If you change any of these function pointers, you will almost
certainly need to change all three to point into the same malloc library.
Strange things will happen if you allocate memory from one library, and then
pass it to an implementation of <code>free</code> that doesn't know what book
keeping the allocator used.

</p><p>You must not modify any of their values after calling any libltdl function
other than <code>lt_dlpreopen_default</code> or the macro
<code>LTDL_SET_PRELOADED_SYMBOLS</code>.
</p></dd></dl>

<hr size="6">
<a name="NOD48"></a>
<a name="SEC47"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left" scope="row">[<a href="#SEC46" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC48" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC45" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC45" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libtool_11.html#SEC53" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libtool.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libtool_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libtool_15.html#SEC86" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libtool_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 10.2 Creating modules that can be <code>dlopen</code>ed </h2>

<p>Libtool modules are like normal libtool libraries with a few exceptions:

</p><p>You have to link the module with libtool's `<samp>-module</samp>' switch,
and you should link any program that is intended to dlopen the module with
`<samp>-dlopen modulename.la</samp>' so that libtool can dlpreopen the module
on platforms which don't support dlopening.  If the module depends on any
other libraries, make sure you specify them either when you link the module
or when you link programs that dlopen it.
If you want to disable see section <a href="libtool_6.html#SEC32">Library interface versions</a> for a specific module
you should link it with the `<samp>-avoid-version</samp>' switch.
Note that libtool modules don't need to have a &quot;lib&quot; prefix.
However, automake 1.4 or higher is required to build such modules.

</p><p>Usually a set of modules provide the same interface, i.e, exports the same
symbols, so that a program can dlopen them without having to know more
about their internals.
In order to avoid symbol conflicts all exported symbols must be prefixed
with &quot;modulename_LTX_&quot; (`<samp>modulename</samp>' is the name of the module).
Internal symbols must be named in such a way that they won't conflict
with other modules, for example, by prefixing them with &quot;_modulename_&quot;.
Although some platforms support having the same symbols defined more than
once it is generally not portable and it makes it impossible to dlpreopen
such modules.  libltdl will automatically cut the prefix off to get
the real name of the symbol.  Additionally, it supports modules which
don't use a prefix so that you can also dlopen non-libtool modules.

</p><p>`<tt>foo1.c</tt>' gives an example of a portable libtool module.
Exported symbols are prefixed with &quot;foo1_LTX_&quot;, internal symbols
with &quot;_foo1_&quot;. Aliases are defined at the beginning so that the code
is more readable.

</p><table><tr><td scope="row">&nbsp;</td><td><pre class="example">/* aliases for the exported symbols */
#define foo	foo1_LTX_foo
#define bar	foo1_LTX_bar

/* a global variable definition */
int bar = 1;

/* a private function */
int _foo1_helper() {
  return bar;
}

/* an exported function */
int foo() {
  return _foo1_helper();
}
</pre></td></tr></table>

<p>The `<tt>Makefile.am</tt>' contains the necessary rules to build the
module `<tt>foo1.la</tt>':

</p><table><tr><td scope="row">&nbsp;</td><td><pre class="example">...
lib_LTLIBRARIES = foo1.la

foo1_la_SOURCES = foo1.c
foo1_la_LDFLAGS = -module
...
</pre></td></tr></table>

<hr size="6">
<a name="NOD49"></a>
<a name="SEC48"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left" scope="row">[<a href="#SEC47" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC49" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC45" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC45" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libtool_11.html#SEC53" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libtool.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libtool_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libtool_15.html#SEC86" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libtool_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 10.3 Using libtldl in a multi threaded environment </h2>

<p>Using the <code>lt_dlmutex_register()</code> function, and by providing some
appropriate callback function definitions, libltdl can be used in a
multi-threaded environment.

</p><dl>
<dt><u>Type:</u> void <b>lt_dlmutex_lock</b><i> (void)</i>
<a name="IDX94"></a>
</dt>
<dd><p>This is the type of a function pointer holding the address of a function
which will be called at the start of parts of the libltdl implementation
code which require a mutex lock.

</p><p>Because libltdl is inherently recursive, it is important that the
locking mechanism employed by these callback functions are reentrant, or
else strange problems will occur.
</p></dd></dl>

<dl>
<dt><u>Type:</u> void <b>lt_dlmutex_unlock</b><i> (void)</i>
<a name="IDX95"></a>
</dt>
<dd><p>The type of a matching unlock function.
</p></dd></dl>

<dl>
<dt><u>Type:</u> void <b>lt_dlmutex_seterror</b><i> (const char *<var>error</var>);</i>
<a name="IDX96"></a>
</dt>
<dd><p>Many of the functions in the libltdl <small>API</small> have a special return
value to indicate to the client that an error has occurred.  Normally (in
single threaded applications) a string describing that error can be
retrieved from internal storage with <code>lt_dlerror()</code>.

</p><p>A function of this type must be registered with the library in order for
it to work in a multi-threaded context.  The function should store any
error message passed in thread local storage.
</p></dd></dl>

<dl>
<dt><u>Type:</u> const char * <b>lt_dlmutex_geterror</b><i> (void)</i>
<a name="IDX97"></a>
</dt>
<dd><p>The type of a matching callback function to retrieve the last stored
error message from thread local storage.

</p><p>When registered correctly this function will be used by
<code>lt_dlerror())</code> from all threads to retrieve error messages for the
client.
</p></dd></dl>

<dl>
<dt><u>Function:</u> int <b>lt_dlmutex_register</b><i> (lt_dlmutex_lock *<var>lock</var>, lt_dlmutex_unlock *<var>unlock</var>, lt_dlmutex_set_error *<var>seterror</var>, lt_dlmutex_geterror *<var>geterror</var>)</i>
<a name="IDX98"></a>
</dt>
<dd><p>Use this function to register one of each of function types described
above in preparation for multi-threaded use of libltdl.  All arguments
must be valid non-<code>NULL</code> function addresses, or else all
<code>NULL</code> to return to single threaded operation.
</p></dd></dl>


<hr size="6">
<a name="NOD50"></a>
<a name="SEC49"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left" scope="row">[<a href="#SEC48" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC50" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC45" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC45" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libtool_11.html#SEC53" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libtool.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libtool_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libtool_15.html#SEC86" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libtool_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 10.4 Data associated with loaded modules </h2>

<p>Some of the internal information about each loaded module that is
maintained by libltdl is available to the user, in the form of this
structure:

</p><dl>
<dt><u>Type:</u> struct <b>lt_dlinfo</b><i> { char *<var>filename</var>; char *<var>name</var>; int <var>ref_count</var>; }</i>
<a name="IDX99"></a>
</dt>
<dd><p><code>lt_dlinfo</code> is used to store information about a module.
The <var>filename</var> attribute is a null-terminated character string of
the real module file name.  If the module is a libtool module then
<var>name</var> is its module name (e.g. <code>&quot;libfoo&quot;</code> for
<code>&quot;dir/libfoo.la&quot;</code>), otherwise it is set to <code>NULL</code>.  The
<var>ref_count</var> attribute is a reference counter that describes how
often the same module is currently loaded.
</p></dd></dl>

<p>The following function will return a pointer to libltdl's internal copy
of this structure for the given <var>handle</var>:

</p><dl>
<dt><u>Function:</u> const lt_dlinfo * <b>lt_dlgetinfo</b><i> (lt_dlhandle <var>handle</var>)</i>
<a name="IDX100"></a>
</dt>
<dd><p>Return a pointer to a struct that contains some information about
the module <var>handle</var>.  The contents of the struct must not be modified.
Return <code>NULL</code> on failure.
</p></dd></dl>

<p>Furthermore, in order to save you from having to keep a list of the
handles of all the modules you have loaded, these functions allow you to
iterate over libltdl's list of loaded modules:

</p><dl>
<dt><u>Function:</u> int <b>lt_dlforeach</b><i> (int (*<var>func</var>) (lt_dlhandle <var>handle</var>, lt_ptr <var>data</var>), lt_ptr <var>data</var>)</i>
<a name="IDX101"></a>
</dt>
<dd><p>For each loaded module call the function <var>func</var>.  The argument
<var>handle</var> is the handle of one of the loaded modules, <var>data</var> is
the <var>data</var> argument passed to <code>lt_dlforeach</code>.
As soon as <var>func</var> returns a non-zero value for one of the handles,
<code>lt_dlforeach</code> will stop calling <var>func</var> and immediately return 1.
Otherwise 0 is returned.
</p></dd></dl>

<dl>
<dt><u>Function:</u> lt_dlhandle <b>lt_dlhandle_next</b><i> (lt_dlhandle place)</i>
<a name="IDX102"></a>
</dt>
<dd><p>Iterate over the loaded module handles, returning the first handle in the
list if <var>place</var> is <code>NULL</code>, and the next one on subsequent calls.
If <var>place</var> is the last element in the list of loaded modules, this
function returns <code>NULL</code>.
</p></dd></dl>

<p>Of course, you would still need to maintain your own list of loaded
module handles to parallel the list maintained by libltdl if there are
any other data that you need to associate with each handle for the
purposes of your application.  However, if you use the following
<small>API</small> calls to associate your application data with individual module
handles as they are loaded there is actually no need to do that.  You
must first obtain a unique caller id from libltdl which you subsequently
use to retrieve the data you stored earlier.  This allows for different
libraries that each wish to store their own data against loaded modules
to do so without interfering with one another's data.

</p><dl>
<dt><u>Type:</u> <b>lt_dlcaller_id</b>
<a name="IDX103"></a>
</dt>
<dd><p>The opaque type used to hold individual data set keys.
</p></dd></dl>

<dl>
<dt><u>Function:</u> lt_dlcaller_id <b>lt_dlcaller_register</b><i> (void)</i>
<a name="IDX104"></a>
</dt>
<dd><p>Use this to obtain a unique key to store and retrieve individual sets of
per module data.
</p></dd></dl>

<dl>
<dt><u>Function:</u> lt_ptr <b>lt_dlcaller_set_data</b><i> (lt_dlcaller_id <var>key</var>, lt_dlhandle <var>handle</var>, lt_ptr <var>data</var>)</i>
<a name="IDX105"></a>
</dt>
<dd><p>Set <var>data</var> as the set of data uniquely associated with <var>key</var> and
<var>handle</var> for later retrieval.  This function returns the <var>data</var>
previously associated with <var>key</var> and <var>handle</var> if any.  A result of
0, may indicate that a diagnostic for the last error (if any) is available
from <code>lt_dlerror()</code>.

</p><p>For example, to correctly remove some associated data:

</p><table><tr><td scope="row">&nbsp;</td><td><pre class="example">    lt_ptr stale = lt_dlcaller_set_data (key, handle, 0);
    if (stale == NULL)
      {
        char *error_msg = lt_dlerror ();

        if (error_msg != NULL)
          {
            my_error_handler (error_msg);
            return STATUS_FAILED;
          }
      }
    else
      {
        free (stale);
      }
</pre></td></tr></table></dd></dl>

<dl>
<dt><u>Function:</u> lt_ptr <b>lt_dlcaller_get_data</b><i> (lt_dlcaller_id <var>key</var>, lt_dlhandle <var>handle</var>)</i>
<a name="IDX106"></a>
</dt>
<dd><p>Return the address of the data associated with <var>key</var> and
<var>handle</var>, or else <code>NULL</code> if there is none.
</p></dd></dl>

<p>The preceding functions can be combined with <code>lt_dlforeach</code> to
implement search and apply operations without the need for your
application to track the modules that have been loaded and unloaded:

</p><table><tr><td scope="row">&nbsp;</td><td><pre class="example">int
my_dlcaller_callback (lt_dlhandle handle, lt_ptr key_ptr)
{
  struct my_module_data *my_data;

  my_data = lt_dlcaller_get_data (handle, (lt_dlcaller_id) *key_ptr);

  return process (my_data);
}

int
my_dlcaller_foreach (lt_dlcaller_id key)
{
  lt_dlforeach (my_dlcaller_callback, (lt_ptr) &amp;key);
}
</pre></td></tr></table>

<hr size="6">
<a name="NOD51"></a>
<a name="SEC50"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left" scope="row">[<a href="#SEC49" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC51" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC45" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC45" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libtool_11.html#SEC53" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libtool.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libtool_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libtool_15.html#SEC86" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libtool_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 10.5 How to create and register new module loaders </h2>

<p>Sometimes libltdl's many ways of gaining access to modules are not
sufficient for the purposes of a project.  You can write your own
loader, and register it with libltdl so that <code>lt_dlopen</code> will be
able to use it.

</p><p>Writing a loader involves writing at least three functions which can be
called  by <code>lt_dlopen</code>, <code>lt_dlsym</code> and <code>lt_dlclose</code>.
Optionally, you can provide a finalisation function to perform any
cleanup operations when <code>lt_dlexit</code> executes, and a symbol prefix
string which will be prepended to any symbols passed to <code>lt_dlsym</code>.
These functions must match the function pointer types below, after
which they can be allocated to an instance of <code>lt_user_dlloader</code>
and registered.

</p><p>Registering the loader requires that you choose a name for it, so that it
can be recognised by <code>lt_dlloader_find</code> and removed with
<code>lt_dlloader_remove</code>.  The name you choose must be unique, and not
already in use by libltdl's builtin loaders:

</p><dl compact="compact">
<dt> &quot;dlopen&quot;</dt>
<dd><p>The system dynamic library loader, if one exists.
</p></dd>
<dt> &quot;dld&quot;</dt>
<dd><p>The <small>GNU</small> dld loader, if `<tt>libdld</tt>' was installed when libltdl was
built.
</p></dd>
<dt> &quot;dlpreload&quot;</dt>
<dd><p>The loader for <code>lt_dlopen</code>ing of preloaded static modules.
</p></dd>
</dl>

<p>The prefix &quot;dl&quot; is reserved for loaders supplied with future versions of
libltdl, so you should not use that for your own loader names.

</p>
<p>The following types are defined in `<tt>ltdl.h</tt>':

</p><dl>
<dt><u>Type:</u> <b>lt_module</b>
<a name="IDX107"></a>
</dt>
<dd><p><code>lt_module</code> is a dlloader dependent module.
The dynamic module loader extensions communicate using these low
level types.
</p></dd></dl>

<dl>
<dt><u>Type:</u> <b>lt_dlloader</b>
<a name="IDX108"></a>
</dt>
<dd><p><code>lt_dlloader</code> is a handle for module loader types.
</p></dd></dl>

<dl>
<dt><u>Type:</u> <b>lt_user_data</b>
<a name="IDX109"></a>
</dt>
<dd><p><code>lt_user_data</code> is used for specifying loader instance data.
</p></dd></dl>

<dl>
<dt><u>Type:</u> struct <b>lt_user_dlloader</b><i> {const char *<var>sym_prefix</var>; lt_module_open *<var>module_open</var>; lt_module_close *<var>module_close</var>; lt_find_sym *<var>find_sym</var>; lt_dlloader_exit *<var>dlloader_exit</var>; }</i>
<a name="IDX110"></a>
</dt>
<dd><p>If you want to define a new way to open dynamic modules, and have the
<code>lt_dlopen</code> <small>API</small> use it, you need to instantiate one of these
structures and pass it to <code>lt_dlloader_add</code>.  You can pass whatever
you like in the <var>dlloader_data</var> field, and it will be passed back as
the value of the first parameter to each of the functions specified in
the function pointer fields.
</p></dd></dl>

<dl>
<dt><u>Type:</u> lt_module <b>lt_module_open</b><i> (const char *<var>filename</var>)</i>
<a name="IDX111"></a>
</dt>
<dd><p>The type of the loader function for an <code>lt_dlloader</code> module
loader.  The value set in the dlloader_data field of the <code>struct
lt_user_dlloader</code> structure will be passed into this function in the
<var>loader_data</var> parameter.  Implementation of such a function should
attempt to load the named module, and return an <code>lt_module</code>
suitable for passing in to the associated <code>lt_module_close</code> and
<code>lt_sym_find</code> function pointers.  If the function fails it should
return <code>NULL</code>, and set the error message with <code>lt_dlseterror</code>.
</p></dd></dl>

<dl>
<dt><u>Type:</u> int <b>lt_module_close</b><i> (lt_user_data <var>loader_data</var>, lt_module <var>module</var>)</i>
<a name="IDX112"></a>
</dt>
<dd><p>The type of the unloader function for a user defined module loader.
Implementation of such a function should attempt to release
any resources tied up by the <var>module</var> module, and then unload it
from memory.  If the function fails for some reason, set the error
message with <code>lt_dlseterror</code> and return non-zero.
</p></dd></dl>

<dl>
<dt><u>Type:</u> lt_ptr <b>lt_find_sym</b><i> (lt_module <var>module</var>, const char *<var>symbol</var>)</i>
<a name="IDX113"></a>
</dt>
<dd><p>The type of the symbol lookup function for a user defined module loader.
Implementation of such a function should return the address of the named
<var>symbol</var> in the module <var>module</var>, or else set the error message
with <code>lt_dlseterror</code> and return <code>NULL</code> if lookup fails.
</p></dd></dl>

<dl>
<dt><u>Type:</u> int <b>lt_dlloader_exit</b><i> (lt_user_data <var>loader_data</var>)</i>
<a name="IDX114"></a>
</dt>
<dd><p>The type of the finalisation function for a user defined module loader.
Implementation of such a function should free any resources associated
with the loader, including any user specified data in the
<code>dlloader_data</code> field of the <code>lt_user_dlloader</code>.  If non-<code>NULL</code>,
the function will be called by <code>lt_dlexit</code>, and
<code>lt_dlloader_remove</code>.
</p></dd></dl>

<p>For example:

</p><table><tr><td scope="row">&nbsp;</td><td><pre class="example">int
register_myloader (void)
{
  lt_user_dlloader dlloader;

  /* User modules are responsible for their own initialisation. */
  if (myloader_init () != 0)
    return MYLOADER_INIT_ERROR;

  dlloader.sym_prefix    = NULL;
  dlloader.module_open   = myloader_open;
  dlloader.module_close  = myloader_close;
  dlloader.find_sym      = myloader_find_sym.
  dlloader.dlloader_exit = myloader_exit;
  dlloader.dlloader_data = (lt_user_data)myloader_function;

  /* Add my loader as the default module loader. */
  if (lt_dlloader_add (lt_dlloader_next (NULL), &amp;dlloader, &quot;myloader&quot;) \
                != 0)
    return ERROR;

  return OK;
}
</pre></td></tr></table>
<p>Note that if there is any initialisation required for the loader,
it must be performed manually before the loader is registered -
libltdl doesn't handle user loader initialisation.

</p><p>Finalisation <em>is</em> handled by libltdl however, and it is important
to ensure the <code>dlloader_exit</code> callback releases any resources claimed
during the initialisation phase.

</p>

<p>libltdl provides the following functions for writing your own module
loaders:

</p><dl>
<dt><u>Function:</u> int <b>lt_dlloader_add</b><i> (lt_dlloader *<var>place</var>, lt_user_dlloader *<var>dlloader</var>, const char *<var>loader_name</var>)</i>
<a name="IDX115"></a>
</dt>
<dd><p>Add a new module loader to the list of all loaders, either as the
last loader (if <var>place</var> is <code>NULL</code>), else immediately before the
loader passed as <var>place</var>.  <var>loader_name</var> will be returned by
<code>lt_dlloader_name</code> if it is subsequently passed a newly
registered loader.  These <var>loader_name</var>s must be unique, or
<code>lt_dlloader_remove</code> and <code>lt_dlloader_find</code> cannot
work. Returns 0 for success.

</p><table><tr><td scope="row">&nbsp;</td><td><pre class="example">{
  /* Make myloader be the last one. */
  if (lt_dlloader_add (NULL, myloader) != 0)
    perror (lt_dlerror ());
}
</pre></td></tr></table></dd></dl>

<dl>
<dt><u>Function:</u> int <b>lt_dlloader_remove</b><i> (const char *<var>loader_name</var>)</i>
<a name="IDX116"></a>
</dt>
<dd><p>Remove the loader identified by the unique name, <var>loader_name</var>.
Before this can succeed, all modules opened by the named loader must
have been closed.  Returns 0 for success, otherwise an error message can
be obtained from <code>lt_dlerror</code>.

</p><table><tr><td scope="row">&nbsp;</td><td><pre class="example">{
  /* Remove myloader. */
  if (lt_dlloader_remove (&quot;myloader&quot;) != 0)
    perror (lt_dlerror ());
}
</pre></td></tr></table></dd></dl>

<dl>
<dt><u>Function:</u> lt_dlloader * <b>lt_dlloader_next</b><i> (lt_dlloader *<var>place</var>)</i>
<a name="IDX117"></a>
</dt>
<dd><p>Iterate over the module loaders, returning the first loader if <var>place</var> is
<code>NULL</code>, and the next one on subsequent calls. The handle is for use with
<code>lt_dlloader_add</code>.

</p><table><tr><td scope="row">&nbsp;</td><td><pre class="example">{
  /* Make myloader be the first one. */
  if (lt_dlloader_add (lt_dlloader_next (NULL), myloader) != 0)
    return ERROR;
}
</pre></td></tr></table></dd></dl>

<dl>
<dt><u>Function:</u> lt_dlloader * <b>lt_dlloader_find</b><i> (const char *<var>loader_name</var>)</i>
<a name="IDX118"></a>
</dt>
<dd><p>Return the first loader with a matching <var>loader_name</var> identifier, or else
<code>NULL</code>, if the identifier is not found.

</p><p>The identifiers which may be used by libltdl itself, if the host
architecture supports them are <em>dlopen</em><a name="DOCF9" href="libtool_fot.html#FOOT9">(9)</a>, <em>dld</em> and <em>dlpreload</em>.

</p><table><tr><td scope="row">&nbsp;</td><td><pre class="example">{
  /* Add a user loader as the next module loader to be tried if
     the standard dlopen loader were to fail when lt_dlopening. */
  if (lt_dlloader_add (lt_dlloader_find (&quot;dlopen&quot;), myloader) != 0)
    return ERROR;
}
</pre></td></tr></table></dd></dl>

<dl>
<dt><u>Function:</u> const char * <b>lt_dlloader_name</b><i> (lt_dlloader *<var>place</var>)</i>
<a name="IDX119"></a>
</dt>
<dd><p>Return the identifying name of <var>PLACE</var>, as obtained from
<code>lt_dlloader_next</code> or <code>lt_dlloader_find</code>.  If this function fails,
it will return <code>NULL</code> and set an error for retrieval with
<code>lt_dlerror</code>.
</p></dd></dl>

<dl>
<dt><u>Function:</u> lt_user_data * <b>lt_dlloader_data</b><i> (lt_dlloader *<var>place</var>)</i>
<a name="IDX120"></a>
</dt>
<dd><p>Return the address of the <code>dlloader_data</code> of <var>PLACE</var>, as
obtained from <code>lt_dlloader_next</code> or <code>lt_dlloader_find</code>.  If
this function fails, it will return <code>NULL</code> and set an error for
retrieval with <code>lt_dlerror</code>.
</p></dd></dl>

<hr size="6">
<a name="SEC51"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left" scope="row">[<a href="#SEC50" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC52" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC45" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC50" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libtool_11.html#SEC53" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libtool.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libtool_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libtool_15.html#SEC86" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libtool_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 10.5.1 Error handling within user module loaders </h3>

<dl>
<dt><u>Function:</u> int <b>lt_dladderror</b><i> (const char *<var>diagnostic</var>)</i>
<a name="IDX121"></a>
</dt>
<dd><p>This function allows you to integrate your own error messages into
<code>lt_dlerror</code>.  Pass in a suitable diagnostic message for return by
<code>lt_dlerror</code>, and an error identifier for use with
<code>lt_dlseterror</code> is returned.

</p><p>If the allocation of an identifier fails, this function returns -1.

</p><table><tr><td scope="row">&nbsp;</td><td><pre class="example">int myerror = lt_dladderror (&quot;Doh!&quot;);
if (myerror &lt; 0)
  perror (lt_dlerror ());
</pre></td></tr></table></dd></dl>

<dl>
<dt><u>Function:</u> int <b>lt_dlseterror</b><i> (int <var>errorcode</var>)</i>
<a name="IDX122"></a>
</dt>
<dd><p>When writing your own module loaders, you should use this function to
raise errors so that they are propagated through the <code>lt_dlerror</code>
interface. All of the standard errors used by libltdl are declared in
`<tt>ltdl.h</tt>', or you can add more of your own with
<code>lt_dladderror</code>.  This function returns 0 on success.

</p><table><tr><td scope="row">&nbsp;</td><td><pre class="example">if (lt_dlseterror (LTDL_ERROR_NO_MEMORY) != 0)
  perror (lt_dlerror ());
</pre></td></tr></table></dd></dl>

<hr size="6">
<a name="NOD52"></a>
<a name="SEC52"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left" scope="row">[<a href="#SEC51" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="libtool_11.html#SEC53" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC45" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC45" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="libtool_11.html#SEC53" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libtool.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libtool_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libtool_15.html#SEC86" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libtool_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 10.6 How to distribute libltdl with your package </h2>

<p>Even though libltdl is installed together with libtool, you may wish to
include libltdl in the distribution of your package, for the convenience
of users of your package that don't have libtool or libltdl installed.
In this case, you must decide whether to manually add the <code>ltdl</code>
objects to your package, or else which flavor of libltdl you want to use:
a convenience library or an installable libtool library.

</p><p>The most simplistic way to add <code>libltdl</code> to your package is to copy
the source files, `<tt>ltdl.c</tt>' and `<tt>ltdl.h</tt>', to a source directory
within your package and to build and link them along with the rest of
your sources.  To help you do this, the m4 macros for autoconf are
available in `<tt>ltdl.m4</tt>'.  You must ensure that they are available in
`<tt>aclocal.m4</tt>' before you run Autoconf - by appending the contents
of `<tt>ltdl.m4</tt>' to `<tt>acinclude.m4</tt>', if you are using automake, or
to `<tt>aclocal.m4</tt>' if you are not.  Having made the macros available,
you must add a call to the `<samp>AC_LIB_LTDL</samp>' macro to your package's
`<tt>configure.in</tt>' to perform the configure time checks required to
build `<tt>ltdl.o</tt>' correctly.  This method has problems if you then try
to link the package binaries with an installed libltdl, or a library
which depends on libltdl: you may have problems with duplicate symbol
definitions.

</p><p>One advantage of the convenience library is that it is not installed, so
the fact that you use libltdl will not be apparent to the user, and it
will not overwrite a pre-installed version of libltdl a user might have.
On the other hand, if you want to upgrade libltdl for any reason
(e.g. a bugfix) you'll have to recompile your package instead of just
replacing an installed version of libltdl.
However, if your programs or libraries are linked with other libraries
that use such a pre-installed version of libltdl, you may get linker
errors or run-time crashes.  Another problem is that you cannot link the
convenience library into more than one libtool library, then link a
single program with these libraries, because you may get duplicate
symbols. In general you can safely use the convenience library in programs
which don't depend on other libraries that might use libltdl too.
In order to enable this flavor of libltdl, you should add the
line `<samp>AC_LIBLTDL_CONVENIENCE</samp>' to your `<tt>configure.in</tt>',
<em>before</em> `<samp>AC_PROG_LIBTOOL</samp>'.

</p><p>In order to select the installable version of libltdl, you should add a
call of the macro `<samp>AC_LIBLTDL_INSTALLABLE</samp>' to your
`<tt>configure.in</tt>' <em>before</em> `<samp>AC_PROG_LIBTOOL</samp>'.  This macro
will check whether libltdl is already installed and, if not, request the
libltdl embedded in your package to be built and installed.  Note,
however, that no version checking is performed.  The user may override
the test and determine that the libltdl embedded must be installed,
regardless of the existence of another version, using the configure
switch `<samp>--enable-ltdl-install</samp>'.

</p><p>In order to embed libltdl into your package, just add `<samp>--ltdl</samp>' to
the <code>libtoolize</code> command line. It will copy the libltdl sources
to a subdirectory `<samp>libltdl</samp>' in your package.
Both macros accept an optional argument to specify the location
of the `<samp>libltdl</samp>' directory. By the default both macros assume that it
is `<samp>${top_srcdir}/libltdl</samp>'.

</p><p>Whatever macro you use, it is up to you to ensure that your
`<tt>configure.in</tt>' will configure libltdl, using
`<samp>AC_CONFIG_SUBDIRS</samp>', and that your `<tt>Makefile</tt>'s will start
sub-makes within libltdl's directory, using automake's <var>SUBDIRS</var>,
for example.  Both macros define the shell variables <var>LIBLTDL</var>, to
the link flag that you should use to link with libltdl, and
<var>LTDLINCL</var>, to the preprocessor flag that you should use to compile
with programs that include `<tt>ltdl.h</tt>'.  It is up to you to use
`<samp>AC_SUBST</samp>' to ensure that this variable will be available in
`<tt>Makefile</tt>'s, or add them to variables that are `<samp>AC_SUBST</samp>'ed by
default, such as <var>LIBS</var> and <var>CPPFLAGS</var>.  Also note that you should
not include `<tt>libltdl/Makefile</tt>' in the list of files to be configured
from your toplevel `<tt>configure.in</tt>'; this is done by
`<tt>libltdl/configure.ac</tt>'.

</p><p>If you're using the convenience libltdl, <var>LIBLTDL</var> will be the
pathname for the convenience version of libltdl and <var>LTDLINCL</var> will be
`<samp>-I</samp>' followed by the directory that contains libltdl, both starting
with `<samp>${top_builddir}/</samp>' or `<samp>${top_srcdir}/</samp>', respectively.

</p><p>If you request an installed version of libltdl and one is
found<a name="DOCF10" href="libtool_fot.html#FOOT10">(10)</a>, <var>LIBLTDL</var> will
be set to `<samp>-lltdl</samp>' and <var>LTDLINCL</var> will be empty (which is just a
blind assumption that `<tt>ltdl.h</tt>' is somewhere in the include path if
libltdl is in the library path).  If an installable version of libltdl
must be built, its pathname, starting with `<samp>${top_builddir}/</samp>',
will be stored in <var>LIBLTDL</var>, and <var>LTDLINCL</var> will be set just like
in the case of convenience library.

</p><p>So, when you want to link a program with libltdl, be it a convenience,
installed or installable library, just compile with `<samp>$(LTDLINCL)</samp>'
and link it with `<samp>$(LIBLTDL)</samp>', using libtool.

</p><p>You should probably also add `<samp>AC_LIBTOOL_DLOPEN</samp>' to your
`<tt>configure.in</tt>' <em>before</em> `<samp>AC_PROG_LIBTOOL</samp>', otherwise
libtool will assume no dlopening mechanism is supported, and revert to
dlpreopening, which is probably not what you want.

</p><p>Avoid using the <code>-static</code> or <code>-all-static</code> switches when
linking programs with libltdl.  This will not work on all platforms,
because the dlopening functions may not be available for static linking.

</p><p>The following example shows you how to embed the convenience libltdl in
your package.  In order to use the installable variant just replace
`<samp>AC_LIBLTDL_CONVENIENCE</samp>' with `<samp>AC_LIBLTDL_INSTALLABLE</samp>'.  We
assume that libltdl was embedded using `<samp>libtoolize --ltdl</samp>'.

</p><p>configure.in:
</p><table><tr><td scope="row">&nbsp;</td><td><pre class="example">...
dnl Enable building of the convenience library
dnl and set LIBLTDL accordingly
AC_LIBLTDL_CONVENIENCE
dnl Check for dlopen support
AC_LIBTOOL_DLOPEN
dnl Configure libtool
AC_PROG_LIBTOOL
dnl Configure libltdl
AC_CONFIG_SUBDIRS(libltdl)
...
</pre></td></tr></table>
<p>Makefile.am:
</p><table><tr><td scope="row">&nbsp;</td><td><pre class="example">...
SUBDIRS = libltdl

INCLUDES = $(LTDLINCL)

myprog_LDFLAGS = -export-dynamic
# The quotes around -dlopen below fool automake &lt;= 1.4 into accepting it
myprog_LDADD = $(LIBLTDL) &quot;-dlopen&quot; self &quot;-dlopen&quot; foo1.la
myprog_DEPENDENCIES = $(LIBLTDL) foo1.la
...
</pre></td></tr></table>
<hr size="6">
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left" scope="row">[<a href="#SEC45" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="libtool_11.html#SEC53" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="libtool.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="libtool_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="libtool_15.html#SEC86" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="libtool_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<p>
 <font size="-1">
  This document was generated by <em>System Administrator</em> on <em>February, 19 2008</em> using <a href="http://texi2html.cvshome.org/"><em>texi2html 1.70</em></a>.
 </font>
 <br>

</p>
</body>
</html>
