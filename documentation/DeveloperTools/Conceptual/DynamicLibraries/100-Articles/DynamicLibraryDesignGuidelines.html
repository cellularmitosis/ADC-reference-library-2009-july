<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>Dynamic Library Programming Topics: Dynamic Library Design Guidelines</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Dynamic Library Design Guidelines"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP40002013" title="Dynamic Library Design Guidelines"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../../Darwin/index.html#//apple_ref/doc/uid/TP30000440-TP30000422" target="_top">Darwin</a> &gt; <a href="../../../../Darwin/RuntimeArchitecture-date.html#//apple_ref/doc/uid/TP30000440-TP30000422-TP30000459" target="_top">Runtime Architecture</a> &gt; <a href="../index.html" target="_top">Dynamic Library Programming Topics</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="OverviewOfDynamicLibraries.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="DynamicLibraryUsageGuidelines.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>
        
        
        <a name="//apple_ref/doc/uid/TP40002013-SW19" title="Dynamic Library Design Guidelines"></a><hr /><H1>Dynamic Library Design Guidelines</H1><p>Dynamic libraries, in addition to grouping common functionality, help reduce an application’s launch time. However, when designed improperly, dynamic libraries can degrade the performance of their clients. (A dynamic library <strong>client</strong> is an application or a library that either is linked against the library or loads the library at runtime. This document also uses the word <strong>image</strong> to refer to dynamic library clients.) Therefore, before creating a dynamic library, you must define its purpose and its intended use. Devising a small and effective interface to the library’s functionality goes a long way towards facilitating its adoption in other libraries or applications.</p><p>This article addresses the main issues dynamic library developers face when designing and implementing dynamic libraries. The focus of this article is to show you how to design libraries in a way that facilitates their improvement through revisions and makes it easy for the libraries’ users to correctly interact with the library.</p>
<!-- This template is being used for both PDF and HTML. -->

    
    <!-- TopicBook.pm uses this template for its miniTOCs, but needs a different title. -->
    <h4>Contents:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="DynamicLibraryDesignGuidelines.html#//apple_ref/doc/uid/TP40002013-SW22">Designing an Optimal Dynamic Library</a>
				
			<br/>
			
        
			
			
				<a href="DynamicLibraryDesignGuidelines.html#//apple_ref/doc/uid/TP40002013-SW20">Managing Client Compatibility With Dependent Libraries</a>
				
			<br/>
			
        
			
			
				<a href="DynamicLibraryDesignGuidelines.html#//apple_ref/doc/uid/TP40002013-SW24">Specifying Your Library’s Interface</a>
				
			<br/>
			
        
			
			
				<a href="DynamicLibraryDesignGuidelines.html#//apple_ref/doc/uid/TP40002013-SW21">Locating External Resources</a>
				
			<br/>
			
        
			
			
				<a href="DynamicLibraryDesignGuidelines.html#//apple_ref/doc/uid/TP40002013-SW27">Library Dependencies</a>
				
			<br/>
			
        
			
			
				<a href="DynamicLibraryDesignGuidelines.html#//apple_ref/doc/uid/TP40002013-SW17">Module Initializers and Finalizers</a>
				
			<br/>
			
        
			
			
				<a href="DynamicLibraryDesignGuidelines.html#//apple_ref/doc/uid/TP40002013-SW28">C++–Based Libraries</a>
				
			<br/>
			
        
			
			
				<a href="DynamicLibraryDesignGuidelines.html#//apple_ref/doc/uid/TP40002013-SW32">Objective-C–Based Libraries</a>
				
			<br/>
			
        
			
			
				<a href="DynamicLibraryDesignGuidelines.html#//apple_ref/doc/uid/TP40002013-SW36">Design Guidelines Checklist</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP40002013-SW22" title="Designing an Optimal Dynamic Library"></a><h2>Designing an Optimal Dynamic Library</h2><p>Dynamic libraries contain code that can be shared by multiple applications in a user’s computer. Therefore, they should contain code that several applications can use. They should not contain code specific to one application. These are the attributes of an optimal dynamic library:</p><ul class="ul"><li class="li"><p><strong>Focused:</strong> The library should focus on few, highly related goals. A highly focused library is easier to implement and use than a multi-purpose library.</p></li><li class="li"><p><strong>Easy to use:</strong> The library’s interface, the symbols that the clients of the library use to interact with it, should be few and easy to understand. A simple interface allows a library’s users to understand its functionality faster than they could understand a large interface.</p></li><li class="li"><p><strong>Easy to maintain:</strong> The library’s developers must be able to make changes to the library that improve its performance and add features. A clear separation between a library’s private and public interfaces gives library developers freedom to make profound changes to the library’s inner workings with minimal impact to its clients. When designed properly, a client created with an early version of a library can use the latest version of the library unchanged and benefit from the improvements it provides.</p></li></ul><a name="//apple_ref/doc/uid/TP40002013-SW20" title="Managing Client Compatibility With Dependent Libraries"></a><h2>Managing Client Compatibility With Dependent Libraries</h2><p>The client of a dynamic library can use the library in two ways: as a dependent library or as a runtime loaded library. A <strong>dependent library</strong>, from the client’s point of view, is a dynamic library the client is linked against. Dependent libraries are loaded into the same process the client is being loaded into as part of its load process. For example, when an application is launched, its dependent libraries are loaded as part of the launch process, before the main function is executed. When a dynamic library is loaded into a running process, its dependent libraries are loaded into the process before control is passed to the routine that opened the library.</p><p>A <strong>runtime loaded library</strong> is a dynamic library the client opens with the <code><a href="../../../Reference/MachOReference/Reference/reference.html#//apple_ref/c/func/dlopen" target="_top">dlopen</a></code> function. Clients do not include runtime loaded libraries in their link line. The dynamic loader, therefore, doesn’t open these libraries when the client is loaded. Clients open a runtime loaded library when they’re about to use a symbol it exports. Clients don’t have any undefined external references to symbols in runtime loaded libraries. Clients get the address of all the symbols they need from runtime loaded libraries by calling the <code><a href="../../../Reference/MachOReference/Reference/reference.html#//apple_ref/c/func/dlsym" target="_top">dlsym</a></code> function with the symbol name.</p><p>A client must always be compatible with its dependent libraries. Otherwise, an application doesn’t launch or a runtime loaded library fails to load.</p><p>When you design a dynamic library, you may have to consider its ongoing maintenance. Sometime you may have to make changes to the library to implement new features or to correct problems. But you also have to think about the library’s existing clients. There are two types of revisions you can make to a library: revisions that are compatible with current clients and require no client-developer intervention and revisions that require that clients be linked against the new revision. The former are <strong>minor revisions</strong> and the latter are <strong>major revisions</strong>.</p><p>The following sections explore compatibility issues to consider before implementing a library that may need to updated at a later time.</p><a name="//apple_ref/doc/uid/TP40002013-SW2" title="Defining Client Compatibility"></a><h3>Defining Client Compatibility</h3><p>As a library upon which existing clients depend is revised, changes to it may affect the clients’ ability to use new versions of the library. The degree to which a client can use earlier or later versions of a dependent library than the one it is linked against is called <strong>client compatibility</strong>.</p><p>Some changes are minor; these include adding symbols that are unknown to clients. Other changes are major; such changes include removing a symbol, changing a symbol’s size or visibility, and changing the semantics of a function. All the symbols a library exposes to clients make up the library’s ABI (application binary interface). The library’s API (application programming interface) comprises only the functions that a library makes available to its clients. The degree to which a library’s ABI remains the same from the point of view of the clients that were developed using an earlier version of the library determines the library’s stability. Ensuring that a library’s ABI remains stable guarantees that clients can use newer versions of the library unchanged. That is, users of an application that depends on a library that’s updated regularly can see their application’s performance improve as they update the library (think of the Mac OS X Software Update mechanism) without obtaining a new version of the application.</p><p>For example, assume an application is linked against the first version of a dynamic library and released to end users. Later, the library’s developer makes minor changes to the library and releases it. When end users install the new version of the library on their computers, the application can to use the new version without requiring the end users to get an updated application file from the developer. The application may benefit from efficiency improvements made to the library’s API. And, depending on how the library was written, the application might be able to take advantage of features introduced by the new version. However, these features are accessed by the application only through the API available in the first version of the library. Any interfaces introduced in the new version of the library go unused by the application.</p><p><span class="content_text"><a href="DynamicLibraryDesignGuidelines.html#//apple_ref/doc/uid/TP40002013-SW1">Figure 1</a></span> illustrates the life cycle of the Draw dynamic library and one of its clients.</p><br/><div><a name="//apple_ref/doc/uid/TP40002013-SW1" title="Figure 1The life cycle of a dynamic library and a client"></a><p><strong>Figure 1&nbsp;&nbsp;</strong>The life cycle of a dynamic library and a client</p><img src = "../art/revisions.gif" alt = "" width="586" height="403"></div><br/><p>This list describes the versions of the library and the client:</p><ul class="spaceabove"><li class="li"><p>Draw 1.0 is the initial version of the library. It exports two functions, <code>draw_line</code> and <code>draw_square</code> .</p></li><li class="li"><p>Client 1.0 is linked against Draw 1.0. Therefore, it can use the two symbols the library exports.</p></li><li class="li"><p>Draw 1.1 has faster versions of <code>draw_line</code> and <code>draw_square</code> , but their semantics are unchanged, maintaining client compatibility. This is a compatible, minor revision because Client 1.0 can use Draw 1.1.</p></li><li class="li"><p>Draw 1.2 introduces the <code>draw_polygon</code> function. The API of the new revision of the library is a superset of the previous version’s API. The Draw 1.1 API subset of the 1.2 version is unchanged. Therefore, Client 1.0 can use Draw 1.2. However, Client 1.0 doesn't know of the existence of <code>draw_polygon</code> and, therefore, it doesn’t use it. This is a minor revision because the API Client 1.0 knows about is unchanged in Draw 1.2. But this is also an incompatible revision because the API changed. Clients linked against this version of the library cannot use earlier versions.</p></li><li class="li"><p>Client 1.1 is linked against Draw 1.2 and uses <code>draw_polygon</code>. Client 1.1 cannot use earlier versions of the library because it uses <code>draw_polygon</code>, a function that isn’t exported by those versions. However, if the library’s developer adds the <code>weak_import</code> attribute to the symbol’s definition, Client 1.1 would be able to use earlier versions of the library by ensuring that <code>draw_polygon</code> exists in its namespace before using it. If the symbol isn’t defined, the client may use other means of performing the desired task, or it may not perform the task. See <span class="content_text"><a href="DynamicLibraryDesignGuidelines.html#//apple_ref/doc/uid/TP40002013-SW18">“Symbol Exporting Strategies”</a></span> for details.</p></li><li class="li"><p>Draw 2.0 doesn’t export <code>draw_square</code>. This is a major revision because a symbol exported in the previous version of the library is not exported in this version. Clients linked against this version of the library cannot use earlier versions.</p></li></ul><p>Clients should be able to use all the minor revisions to the library they’re linked against without relinking. In general, to use a major revision of a library, the client must be linked against the new version. The client may also need to be changed to take advantage of new symbols, to adapt its use of symbols that have been modified, or to not use symbols that are not exported by the new revision.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40002013-SW37" title="Note"></a><p><strong>Note:</strong>&nbsp;The header files for your libraries should include only the symbols the libraries’ clients should actually use. If clients use symbols other than the ones you specify, they limit the compatibility of their products with new or earlier versions of your libraries.</p></div><a name="//apple_ref/doc/uid/TP40002013-SW23" title="Specifying Version Information"></a><h3>Specifying Version Information</h3><p>The filename of a dynamic libraries normally contains the library’s name with the lib prefix and the <code>.dylib</code> extension. For example, a library called Dynamo would have the filename <code>libDynamo.dylib</code>. However, if a library may go through one or more revisions after it’s released, its filename must include the major version number of the revision. Clients linked against libraries whose filename includes the major version number of the revision never use a new major revision of the library because major revisions are published under different filenames. This versioning model prevents clients from using library revisions whose API is incompatible with the API known to the clients.</p><p>When you publish a dynamic library intended to have future revisions, you must disclose the library’s major version number in its filename. For example, the filename for the first version of the Draw library, introduced in <span class="content_text"><a href="DynamicLibraryDesignGuidelines.html#//apple_ref/doc/uid/TP40002013-SW2">“Defining Client Compatibility,”</a></span> could be <code>libDraw.A.dylib</code>. The letter A specifies the major version number for the initial release. You can use any nomenclature for the major version. For example, the Draw library could also be named <code>libDraw.1.dylib</code>, or <code>libDraw.I.dylib</code>. The important thing is that the filenames of subsequent major revisions of the library have different (and preferably incremental) major version numbers. Continuing the Draw library example, a major revision to the library could be named <code>libDraw.B.dylib</code> , <code>libDraw.2.dylib</code>, or <code>libDraw.II.dylib</code>. Minor revisions to the library are released under the same filename used by the previous major revision.</p><p>In addition to the major version number, a library has a minor version number. The minor version number is an incremental number using the format <code>X[.Y[.Z]]</code> , where X is a number between 0 and 65535, and Y and Z are numbers between 0 and 255. For example, the minor version number for the first release of the Draw library could be 1.0. To set the minor version number of a dynamic library, use the <code>gcc -current_version</code> option.</p><p>The compatibility version number is similar to the minor version number; it’s set through the <code>gcc -compatibility_version</code> option. The compatibility version number of a library release specifies the earliest minor version of the clients linked against that release can use. For instance, the example in <span class="content_text"><a href="DynamicLibraryDesignGuidelines.html#//apple_ref/doc/uid/TP40002013-SW2">“Defining Client Compatibility”</a></span> indicates that Client 1.1 cannot use versions of the Draw library earlier than 1.2 because they don’t export the <code>draw_polygon</code> function.</p><p>Before loading a dynamic library, the dynamic loader compares the current version of the <code>.dylib</code> file in the user’s file system with the compatibility version of the <code>.dylib</code> file the client was linked against in the developer’s file system. If the current version is earlier (less) than the compatibility version, the dependent library is not loaded. Therefore, the launch process (for client applications) or the load process (for client  libraries) is aborted.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40002013-SW38" title="Note"></a><p><strong>Note:</strong>&nbsp;The dynamic loader performs the version compatibility test only with dependent libraries. Dynamic libraries opened at runtime with <code>dlopen</code> don’t go through this test. </p></div><a name="//apple_ref/doc/uid/TP40002013-SW24" title="Specifying Your Library&acirc;&#128;&#153;s Interface"></a><h2>Specifying Your Library’s Interface</h2><p>The most important aspect to define before implementing a dynamic library is its interface to its clients. The public interface affects several areas in the use of the library by its clients, the library’s development and maintenance, and the performance of the applications in which the library is used:</p><ul class="ul"><li class="li"><p><strong>Ease of use:</strong> A library with a few but easily understandable public symbols is far easier to use than one that exports all the symbols it defines.</p></li><li class="li"><p><strong>Ease of maintenance:</strong> A library that has a small set of public symbols and an adequate set of private symbols, is far easier to maintain because there are few client entry points to test. Also, developers can change the private symbols to improve the library in newer versions without impacting the functionality of clients that were linked against an earlier version.</p></li><li class="li"><p><strong>Performance:</strong> Designing a dynamic library so that it exports the minimum number of symbols optimizes the amount of time the dynamic loader takes to load the library into a process. The fewer exported symbols a library has, the faster the dynamic loader loads it.</p></li></ul><p>The following sections show how to determine which of the library’s symbols to export, how to name them, and how to export them.</p><a name="//apple_ref/doc/uid/TP40002013-SW25" title="Deciding What Symbols to Export"></a><h3>Deciding What Symbols to Export</h3><p>Reducing the set of symbols your library exports makes the library easy to use and easy to maintain. With a reduced symbol set, the users of your library are exposed only to the symbols that are relevant to them. And with few public symbols, you are free to make substantial changes to the internal interfaces, such as adding or removing internal symbols that do not affect clients of your library.</p><p>Global variables should never be exported. Providing uncontrolled access to a library’s global variables leaves the library open to problems caused by clients assigning inappropriate values to those variables. It’s also difficult to make changes to global variables from one version of your library to another without making newer revisions incompatible with clients that were not linked against them. One of the main features of dynamic libraries is the fact that, when implemented correctly, clients can use newer versions of them without relinking. If clients need to access a value stored in a global variable, your library should export accessor functions but not the global variable itself. Adhering to this guideline allows library developers to change the definitions of global variables between versions of the library, without introducing incompatible revisions.</p><p>If your library needs the functionality implemented by functions it exports, you should consider implementing internal versions of the functions, adding wrapper functions to them, and exporting the wrappers. For example, your library may have a function whose arguments must be validated, but you’re certain that the library always provides valid values when invoking the function. The internal version of the function could be optimized by removing validation code from it, making internal use more efficient. The validation code can then be placed in the wrapper function, maintaining the validation process for clients. In addition, you can further change the internal implementation of the function to include more parameters, for example, while maintaining the external version the same.</p><p>Having wrapper functions call internal versions reduces the performance of an application, especially if the function is called repeatedly by clients. However, the advantages of flexible maintenance for you and a stable interface for your clients greatly outweigh this negligible performance impact.</p><a name="//apple_ref/doc/uid/TP40002013-SW26" title="Naming Exported Symbols"></a><h3>Naming Exported Symbols</h3><p>The dynamic loader doesn’t detect naming conflicts between the symbols exported by the dynamic libraries it loads. When a client contains a reference to a symbol that two or more of its dependent libraries export, the dynamic loader binds the reference to the first dependent library that exports the symbol in the client’s dependent library list. The <strong>dependent library list</strong> is a list of the client’s dependent libraries in the order they were specified when the client was linked against them. Also, when the <code><a href="../../../Reference/MachOReference/Reference/reference.html#//apple_ref/c/func/dlsym" target="_top">dlsym</a></code> function is invoked, the dynamic loader returns the address of the first symbol it finds in the specified scope (global, local, or next) with a matching name. For details on symbol-search scope, see <span class="content_text"><a href="DynamicLibraryUsageGuidelines.html#//apple_ref/doc/uid/TP40001928-SW9">“Using Symbols.”</a></span></p><p>To ensure that your library’s clients always have access to the symbols your library exports, the symbols must have unique names in a process’s namespace. One way is for applications to use two-level namespaces. Another is to add prefixes to every exported symbol. This is the convention used by most of the Mac OS X frameworks, such as Carbon and Cocoa. For more information on two-level namespace, see “<span class="content_text"><a href="../../MachOTopics/1-Articles/executing_files.html#//apple_ref/doc/uid/TP40001829" target="_top">Executing Mach-O Files</a></span>” in <em><a href="../../MachOTopics/index.html#//apple_ref/doc/uid/TP40001519" target="_top">Mach-O Programming Topics</a></em>.</p><a name="//apple_ref/doc/uid/TP40002013-SW18" title="Symbol Exporting Strategies"></a><h3>Symbol Exporting Strategies</h3><p>After you have identified the symbols you want to expose to your library’s users, you must devise a strategy for exporting them or for not exporting the rest of the symbols. This process is also known as setting the <strong>visibility</strong> of the symbols—that is, whether they are accessible to clients. Public or exported symbols are accessible to clients; private, hidden, or unexported symbols are not accessible to clients. In Mac OS X, there are several ways of specifying the visibility of a library’s symbols:</p><ul class="spaceabove"><li class="li"><p>The <code>static</code> storage class: This is the easiest way to indicate that you don’t want to export a symbol.</p></li><li class="li"><p>The exported symbols list or the unexported symbols list: The list is a file with the names of symbols to export or a list of symbols to keep private. The symbol names must include the underscore (<code>_</code>) prefix. You can use only one type of list when generating the dynamic library file.</p></li><li class="li"><p>The GCC <code>visibility</code> attribute: You place this attribute in the definition of symbols in implementation files to set the visibility of symbols individually. It gives you more granular control over which symbols are public or private.</p></li><li class="li"><p>The <code>gcc -fvisibility</code> option: This option specifies at compilation time the visibility of symbols with unspecified visibility in implementation files. This option, combined with the <code>visibility</code> attribute, is the most safe and convenient way of identifying public symbols.</p></li><li class="li"><p>The GCC <code>weak_import</code> attribute: Placing this attribute in the declaration of a symbol in a header file tells the compiler to generate a weak reference to the symbol. This feature is called <strong>weak linking</strong>; symbols with the <code>weak_import</code> attribute are called <strong>weakly linked symbols</strong>. With weak linking, clients do not fail to launch when the version of the dependent library found at launch time or load time doesn’t export a weakly linked symbol referenced by the client. It’s important to place the <code>weak_import</code> attribute in the header files that the source files of the library’s clients use, so that the client developers know that they must ensure the existence of the symbol before using it. Otherwise, the client would crash or function incorrectly when it attempts to use the symbol. See <span class="content_text"><a href="DynamicLibraryUsageGuidelines.html#//apple_ref/doc/uid/TP40001928-SW20">“Using Weakly Linked Symbols”</a></span> for further details on weakly linked symbols. For more information on symbol definitions, see <span class="content_text"><a href="../../MachOTopics/1-Articles/executing_files.html#//apple_ref/doc/uid/TP40001829" target="_top">Executing Mach-O Files</a></span> in <em><a href="../../MachOTopics/index.html#//apple_ref/doc/uid/TP40001519" target="_top">Mach-O Programming Topics</a></em>.</p></li><li class="li"><p>The <code>gcc -weak_library</code> option: This option tells the compiler to treat all the library’s exported symbols as weakly linked symbols.</p></li></ul><p>To illustrate how to set the visibility of a library’s symbols, let’s start with a dynamic library that allows its clients to set a value kept in a global variable in the library, and to retrieve the value. <span class="content_text">Listing 1</span> shows the code that makes up the library.</p><a name="//apple_ref/doc/uid/TP40002013-SW3" title="Listing 1A simple dynamic library"></a><p class="codesample"><strong>Listing 1&nbsp;&nbsp;</strong>A simple dynamic library</p><div class="codesample"><table><tr><td scope="row"><pre>/* File: Person.h */<span></span></pre></td></tr><tr><td scope="row"><pre>char* name(void);<span></span></pre></td></tr><tr><td scope="row"><pre>void set_name(char* name);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/* File: Person.c */<span></span></pre></td></tr><tr><td scope="row"><pre>#include "Person.h"<span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;string.h><span></span></pre></td></tr><tr><td scope="row"><pre>char _person_name[30] = {'\0'};<span></span></pre></td></tr><tr><td scope="row"><pre>char* name(void) {<span></span></pre></td></tr><tr><td scope="row"><pre>    return _person_name;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>void _set_name(char* name) {<span></span></pre></td></tr><tr><td scope="row"><pre>   strcpy(_person_name, name);<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>void set_name(char* name) {<span></span></pre></td></tr><tr><td scope="row"><pre>    if (name == NULL) {<span></span></pre></td></tr><tr><td scope="row"><pre>        _set_name("");<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    else {<span></span></pre></td></tr><tr><td scope="row"><pre>        _set_name(name);<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>The intent of the library’s developer is to provide clients the ability to set the value of <code>_person_name</code> with the <code>set_name</code> function and to let them obtain the value of the variable with the name function. However, the library exports more than the <code>name</code> and <code>set_name</code> functions, as shown by the output of the <code>nm</code> command-line tool:</p><div class="codesample"><table><tr><td scope="row"><pre>% gcc -dynamiclib Person.c -o libPerson.dylib<span></span></pre></td></tr><tr><td scope="row"><pre>% nm -gm libPerson.dylib<span></span></pre></td></tr><tr><td scope="row"><pre>...<span></span></pre></td></tr><tr><td scope="row"><pre>libPerson.dylib(ccfM2qAA.o):<span></span></pre></td></tr><tr><td scope="row"><pre>00001004 (__DATA,__data) external __person_name   // Inadvertently exported<span></span></pre></td></tr><tr><td scope="row"><pre>00000eec (__TEXT,__text) external __set_name      // Inadvertently exported<span></span></pre></td></tr><tr><td scope="row"><pre>00000eb8 (__TEXT,__text) external _name<span></span></pre></td></tr><tr><td scope="row"><pre>00000f30 (__TEXT,__text) external _set_name<span></span></pre></td></tr><tr><td scope="row"><pre>...<span></span></pre></td></tr></table></div><p>Note that the <code>_person_name</code> global variable and the <code>_set_name</code> function are exported along with the <code>name</code> and <code>set_name</code> functions. There are many options to remove <code>_person_name</code> and <code>_set_name</code> from the symbols exported by the library. This section explores a few.</p><p>The first option is to add the static storage class to the definition of <code>_person_name</code> and <code>_set_name</code> in <code>Person.c</code> , as shown in <span class="content_text">Listing 2</span>.</p><a name="//apple_ref/doc/uid/TP40002013-SW4" title="Listing 2Person module hiding a symbol with the static storage class"></a><p class="codesample"><strong>Listing 2&nbsp;&nbsp;</strong>Person module hiding a symbol with the static storage class</p><div class="codesample"><table><tr><td scope="row"><pre>/* File: Person.c */<span></span></pre></td></tr><tr><td scope="row"><pre>#include "Person.h"<span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;string.h><span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>static char _person_name[30] = {'\0'};        // Added 'static' storage class<span></span></pre></td></tr><tr><td scope="row"><pre>char* name(void) {<span></span></pre></td></tr><tr><td scope="row"><pre>    return _person_name;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>static void _set_name(char* name) {           // Added 'static' storage class<span></span></pre></td></tr><tr><td scope="row"><pre>   strcpy(_person_name, name);<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>void set_name(char* name) {<span></span></pre></td></tr><tr><td scope="row"><pre>    if (name == NULL) {<span></span></pre></td></tr><tr><td scope="row"><pre>        _set_name("");<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    else {<span></span></pre></td></tr><tr><td scope="row"><pre>        _set_name(name);<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>Now, the <code>nm</code> output, looks like this:</p><div class="codesample"><table><tr><td scope="row"><pre>libPerson.dylib(ccPQ6JXF.o):<span></span></pre></td></tr><tr><td scope="row"><pre>00000ebc (__TEXT,__text) external _name<span></span></pre></td></tr><tr><td scope="row"><pre>00000f34 (__TEXT,__text) external _set_name<span></span></pre></td></tr></table></div><p>This means that the library exports only <code>name</code> and <code>set_name</code>. Actually, the library also exports some undefined symbols, including <code>strcpy</code>. They are references to symbols the library obtains from its dependent libraries.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40002013-SW39" title="Note"></a><p><strong>Note:</strong>&nbsp;You should always use the static storage class for symbols that you want to keep private for a specific file. It’s a very effective fail-safe measure against inadvertently exposing symbols that should be hidden from clients.</p></div><p>The problem with this approach is that it hides the internal <code>_set_name</code> function from other modules in the library. If the library’s developer trusts that any internal call to <code>_set_name</code> doesn’t need to be validated but wants to validate all client calls, the symbol must be visible to other modules within the library but not to the library’s client. Therefore, the <code>static</code> storage class is not appropriate to hide symbols from the client but disclose them to all the library’s modules.</p><p>A second option for exposing only the symbols intended for client use is to have an exported symbols file that lists the symbols to export; all other symbols are hidden. <span class="content_text">Listing 3</span> shows the <code>export_list</code> file.</p><a name="//apple_ref/doc/uid/TP40002013-SW5" title="Listing 3File listing the names of the symbols to export"></a><p class="codesample"><strong>Listing 3&nbsp;&nbsp;</strong>File listing the names of the symbols to export</p><div class="codesample"><table><tr><td scope="row"><pre># File: export_list<span></span></pre></td></tr><tr><td scope="row"><pre>_name<span></span></pre></td></tr><tr><td scope="row"><pre>_set_name<span></span></pre></td></tr></table></div><p>To compile the library, you use the <code>gcc -exported_symbols_list</code> option to specify the file containing the names of the symbols to export, as shown here:</p><div class="codesample"><table><tr><td scope="row"><pre>gcc -dynamiclib Person.c -exported_symbols_list export_list -o libPerson.dylib<span></span></pre></td></tr></table></div><p>The third and most convenient option for exposing only <code>name</code> and <code>set_name</code> is to set the visibility attribute in their implementations to <code>"default"</code> and set the <code>gcc -fvisibility</code> option to hidden when compiling the library’s source files.  <span class="content_text">Listing 4</span> shows how the <code>Person.c</code> file looks after setting the <code>visibility</code> attribute for the symbols to be exported.</p><a name="//apple_ref/doc/uid/TP40002013-SW6" title="Listing 4Person module using visibility attribute to export symbols"></a><p class="codesample"><strong>Listing 4&nbsp;&nbsp;</strong>Person module using visibility attribute to export symbols</p><div class="codesample"><table><tr><td scope="row"><pre>/* File: Person.c */<span></span></pre></td></tr><tr><td scope="row"><pre>#include "Person.h"<span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;string.h><span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>// Symbolic name for visibility("default") attribute.<span></span></pre></td></tr><tr><td scope="row"><pre>#define EXPORT __attribute__((visibility("default")))<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>static char _person_name[30] = {'\0'};<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>EXPORT                        // Symbol to export<span></span></pre></td></tr><tr><td scope="row"><pre>char* name(void) {<span></span></pre></td></tr><tr><td scope="row"><pre>    return _person_name;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>void _set_name(char* name) {<span></span></pre></td></tr><tr><td scope="row"><pre>   strcpy(_person_name, name);<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>EXPORT                        // Symbol to export<span></span></pre></td></tr><tr><td scope="row"><pre>void set_name(char* name) {<span></span></pre></td></tr><tr><td scope="row"><pre>    if (name == NULL) {<span></span></pre></td></tr><tr><td scope="row"><pre>        _set_name("");<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    else {<span></span></pre></td></tr><tr><td scope="row"><pre>        _set_name(name);<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>The library would then be compiled using the following command:</p><div class="codesample"><table><tr><td scope="row"><pre>% gcc -dynamiclib Person.c -fvisibility=hidden -o libPerson.dylib<span></span></pre></td></tr></table></div><p>The <code>gcc -fvisibility=hidden</code> option tells the compiler to set the visibility of any symbols without a visibility attribute to hidden, thereby hiding them from the library’s clients. For details on the <code>visibility</code> attribute and the <code>gcc -fvisibility</code> option, see <em><a href="../../../gcc-4.0.1/gcc/index.html#//apple_ref/doc/uid/TP40001838" target="_top">GNU C/C++/Objective-C 4.0.1 Compiler User Guide</a></em>  and the <code>gcc</code> man page.</p><p>Following these symbol-exporting guidelines ensures that libraries export only the symbols you want to make available to your clients, simplifying the use of the library by its clients and facilitating its maintenance by its developers. The document <em>How to Write Shared Libraries</em> provides an in-depth analysis of symbol exporting strategies. This document is available at <span class="content_text"><a href="http://people.redhat.com/drepper/dsohowto.pdf" target="_blank">http://people.redhat.com/drepper/dsohowto.pdf</a></span>.</p><a name="//apple_ref/doc/uid/TP40002013-SW21" title="Locating External Resources"></a><h2>Locating External Resources</h2><p>When you need to locate resources your library or program needs at runtime—such as frameworks, images, and so on—you can use either of the following methods:</p><ul class="ul"><li class="li"><p><strong>Executable-relative location.</strong> To specify a file path relative to the location of the main executable, not the referencing library, place the <code>@executable_path</code> macro at the beginning of the path. For example, in an application package that contains private frameworks (which, in turn, contain shared libraries), any of the libraries can locate an application resource called <code>MyImage.tiff</code> inside the package by specifying the path <code>@executable_path/../Resources/MyImage.tiff</code>. Because <code>@executable_path</code> resolves to the binary inside the <code>MacOS</code> directory in the application bundle, the resource file path must specify the <code>Resources</code> directory as a subdirectory of the <code>MacOS</code> parent directory (the <code>Contents</code> directory). For a detailed discussion of directory bundles, see <em><a href="../../../../CoreFoundation/Conceptual/CFBundles/index.html#//apple_ref/doc/uid/10000123i" target="_top">Bundle Programming Guide</a></em>.</p></li><li class="li"><p><strong>Library-relative location.</strong> To specify a file path relative to the location of the library itself, place the <code>@loader_path</code> macro at the beginning of the pathname. Library-relative location allows you to locate library resources within a directory hierarchy regardless of where the main executable is located.</p></li></ul><a name="//apple_ref/doc/uid/TP40002013-SW27" title="Library Dependencies"></a><h2>Library Dependencies</h2><p>When you develop a dynamic library, you specify its dependent libraries by linking your source code against them. When a client of your library tries to load it, your library’s dependent libraries must be present in the file system for your library to load successfully. (See <span class="content_text"><a href="RunpathDependentLibraries.html#//apple_ref/doc/uid/TP40008306-SW1">“Run-Path Dependent Libraries”</a></span> to learn about installing dependent libraries in a relocatable directory.) Depending on how the client loads your library, some or all of your library’s references to symbols exported by its dependent libraries are resolved. You should consider using the <code><a href="../../../Reference/MachOReference/Reference/reference.html#//apple_ref/c/func/dlsym" target="_top">dlsym</a></code> function to get the address of symbols when they are needed instead of having references that may always have to be resolved at load time. See <span class="content_text"><a href="DynamicLibraryUsageGuidelines.html#//apple_ref/doc/uid/TP40001928-SW9">“Using Symbols”</a></span> for details.</p><p>The more dependent libraries your library has, the longer it takes for your library to load. Therefore, you should link your library against only those dynamic libraries required at load time. After you compile your library, you can view its dependent libraries in a shell editor with the <code>otool -L</code> command-line tool.</p><p>Any dynamic libraries your library seldom uses or whose functionality is needed only when performing specific tasks should be used as runtime loaded libraries; that is, they should be opened with the <code><a href="../../../Reference/MachOReference/Reference/reference.html#//apple_ref/c/func/dlopen" target="_top">dlopen</a></code> function. For example, when a module in your library needs to perform a task that requires the use of a nondependent library, the module should use <code>dlopen</code> to load the library, use the library to perform its task, and close the library with <code><a href="../../../Reference/MachOReference/Reference/reference.html#//apple_ref/c/func/dlclose" target="_top">dlclose</a></code> when finished. For additional information on loading libraries at runtime, see <span class="content_text"><a href="DynamicLibraryUsageGuidelines.html#//apple_ref/doc/uid/TP40001928-SW12">“Opening Dynamic Libraries.”</a></span></p><p>You should also keep to a minimum the number of external references to symbols in dependent libraries. This practice optimizes further your library’s load time.</p><p>You must disclose to your library’s users all the libraries your library uses and whether they are dependent libraries. When users of your dynamic library link their images, the static linker must be able to find all your library’s dependent libraries, either through the link line or symbolic links. Also, because your dynamic library loads successfully even when some or all the libraries it opens at runtime are not present at load time, users of your library must know which dynamic libraries your library opens at runtime and under which circumstances. Your library’s users can use that information when investigating unexpected behavior by your library.</p><a name="//apple_ref/doc/uid/TP40002013-SW17" title="Module Initializers and Finalizers"></a><h2>Module Initializers and Finalizers</h2><p>When dynamic libraries are loaded, they may need to prepare resources or perform special initialization before doing anything else. Conversely, when the libraries are unloaded, they may need to perform some finalization processes. These tasks are performed by <strong>initializer functions</strong> and <strong>finalizer functions</strong>, also called constructors and destructors, respectively.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40002013-SW40" title="Note"></a><p><strong>Note:</strong>&nbsp;Applications can also define and use initializer and finalizers. However, this section focuses on their use in dynamic libraries.</p></div><p>Initializers can safely use symbols from dependent libraries because the dynamic loader executes the static initializers of an image’s dependent libraries before invoking the image’s static initializers.</p><p>You indicate that a function is an initializer by adding the <code>constructor</code> attribute to its definition. The <code>destructor</code> attribute identifies finalizer functions. Initializers and finalizers must not be exported. A dynamic library’s initializers are executed in the order they are encountered by the compiler. It’s finalizers, on the other hand, are executed in the reverse order as encountered by the compiler.</p><p>For example, <span class="content_text">Listing 5</span> shows a set of initializers and finalizers defined identically in two files <code>File1.c</code> and <code>File2.c</code> in a dynamic library called Inifi.</p><a name="//apple_ref/doc/uid/TP40002013-SW7" title="Listing 5Inifi initializer and finalizer definitions"></a><p class="codesample"><strong>Listing 5&nbsp;&nbsp;</strong>Inifi initializer and finalizer definitions</p><div class="codesample"><table><tr><td scope="row"><pre>/* Files: File1.c, File2.c */<span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;stdio.h><span></span></pre></td></tr><tr><td scope="row"><pre>__attribute__((constructor))<span></span></pre></td></tr><tr><td scope="row"><pre>static void initializer1() {<span></span></pre></td></tr><tr><td scope="row"><pre>    printf("[%s] initializer()\n", __FILE__);<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>__attribute__((constructor))<span></span></pre></td></tr><tr><td scope="row"><pre>static void initializer2() {<span></span></pre></td></tr><tr><td scope="row"><pre>    printf("[%s] initializer2()\n", __FILE__);<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>__attribute__((constructor))<span></span></pre></td></tr><tr><td scope="row"><pre>static void initializer3() {<span></span></pre></td></tr><tr><td scope="row"><pre>    printf("[%s] initializer3()\n", __FILE__);<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>__attribute__((destructor))<span></span></pre></td></tr><tr><td scope="row"><pre>static void finalizer1() {<span></span></pre></td></tr><tr><td scope="row"><pre>    printf("[%s] finalizer()\n", __FILE__);<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>__attribute__((destructor))<span></span></pre></td></tr><tr><td scope="row"><pre>static void finalizer2() {<span></span></pre></td></tr><tr><td scope="row"><pre>    printf("[%s] finalizer2()\n", __FILE__);<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>__attribute__((destructor))<span></span></pre></td></tr><tr><td scope="row"><pre>static void finalizer3() {<span></span></pre></td></tr><tr><td scope="row"><pre>    printf("[%s] finalizer3()\n", __FILE__);<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>Continuing the example, the Inifi dynamic library is the sole dependent library of the Trial application, generated from the <code>Trial.c</code> file, shown in <span class="content_text">Listing 6</span>.</p><a name="//apple_ref/doc/uid/TP40002013-SW9" title="Listing 6The Trial.c file"></a><p class="codesample"><strong>Listing 6&nbsp;&nbsp;</strong>The <code>Trial.c</code> file</p><div class="codesample"><table><tr><td scope="row"><pre>/* Trial.c */<span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;stdio.h><span></span></pre></td></tr><tr><td scope="row"><pre>int main(int argc, char** argv) {<span></span></pre></td></tr><tr><td scope="row"><pre>    printf("[%s] Finished loading. Now quitting.\n", __FILE__);<span></span></pre></td></tr><tr><td scope="row"><pre>    return 0;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p><span class="content_text">Listing 7</span> shows the output produced by the Trial application.</p><a name="//apple_ref/doc/uid/TP40002013-SW8" title="Listing 7Execution order of a dynamic library&acirc;&#128;&#153;s initializers and finalizers"></a><p class="codesample"><strong>Listing 7&nbsp;&nbsp;</strong>Execution order of a dynamic library’s initializers and finalizers</p><div class="codesample"><table><tr><td scope="row"><pre>% gcc -dynamiclib File1.c File2.c -fvisibility=hidden -o libInifi.dylib<span></span></pre></td></tr><tr><td scope="row"><pre>% gcc Trial.c libInifi.dylib -o trial<span></span></pre></td></tr><tr><td scope="row"><pre>% ./trial<span></span></pre></td></tr><tr><td scope="row"><pre>[File1.c] initializer1()<span></span></pre></td></tr><tr><td scope="row"><pre>[File1.c] initializer2()<span></span></pre></td></tr><tr><td scope="row"><pre>[File1.c] initializer3()<span></span></pre></td></tr><tr><td scope="row"><pre>[File2.c] initializer1()<span></span></pre></td></tr><tr><td scope="row"><pre>[File2.c] initializer2()<span></span></pre></td></tr><tr><td scope="row"><pre>[File2.c] initializer3()<span></span></pre></td></tr><tr><td scope="row"><pre>[Trial.c] Finished loading. Now quitting.<span></span></pre></td></tr><tr><td scope="row"><pre>[File2.c] finalizer3()<span></span></pre></td></tr><tr><td scope="row"><pre>[File2.c] finalizer2()<span></span></pre></td></tr><tr><td scope="row"><pre>[File2.c] finalizer1()<span></span></pre></td></tr><tr><td scope="row"><pre>[File1.c] finalizer3()<span></span></pre></td></tr><tr><td scope="row"><pre>[File1.c] finalizer2()<span></span></pre></td></tr><tr><td scope="row"><pre>[File1.c] finalizer1()<span></span></pre></td></tr></table></div><p>Although you can have as many static initializers and finalizers in an image as you want, you should consolidate your initialization and finalization code into one initializer and one finalizer per module, as needed. You may also choose to have one initializer and one finalizer per library.</p><p>In Mac OS X v10.4 and later, static initializers can access the arguments given to the current application. By defining the initializer’s parameters as you would define the parameters to an application’s main function, you can get the number of arguments given, the arguments themselves, and the process’s environment variables. In addition, to guard against an initializer or finalizer being called twice, you should conditionalize  your initialization and finalization code inside the function. <span class="content_text">Listing 8</span> shows the definition of a static initializer that has access to the application’s arguments and conditionalizes its initialization code.</p><a name="//apple_ref/doc/uid/TP40002013-SW10" title="Listing 8Definition of a static initializer"></a><p class="codesample"><strong>Listing 8&nbsp;&nbsp;</strong>Definition of a static initializer</p><div class="codesample"><table><tr><td scope="row"><pre>__attribute__((constructor))<span></span></pre></td></tr><tr><td scope="row"><pre>static void initializer(int argc, char** argv, char** envp) {<span></span></pre></td></tr><tr><td scope="row"><pre>static initialized = 0;<span></span></pre></td></tr><tr><td scope="row"><pre>if (!initialized) {<span></span></pre></td></tr><tr><td scope="row"><pre>// Initialization code.<span></span></pre></td></tr><tr><td scope="row"><pre>initialized = 1;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><div class="notebox"><a name="//apple_ref/doc/uid/TP40002013-SW41" title="Note"></a><p><strong>Note:</strong>&nbsp;Some systems support a naming convention for initializers and finalizers, <code>_init</code> and <code>_fini</code> , respectively. This convention is not supported in Mac OS X v10.4.</p></div><a name="//apple_ref/doc/uid/TP40002013-SW28" title="C++&acirc;&#128;&#147;Based Libraries"></a><h2>C++–Based Libraries</h2><p>Using C++ to implement a dynamic library presents a couple of challenges—mainly exporting symbol names and creating and destroying objects. The following sections detail how to export symbols from a C++–based dynamic library and how to provide clients with functions that create and destroy instances of a class.</p><a name="//apple_ref/doc/uid/TP40002013-SW29" title="Exporting C++ Symbols"></a><h3>Exporting C++ Symbols</h3><p>C++ uses <strong>name mangling</strong> to encode size and type information in a symbol name. Name mangling in C++ makes exporting symbols in a standard way across different platforms impossible.  When a dynamic library is compiled, each symbol is renamed to include that information, but the encoding used is not standard between platforms. The dynamic loader uses string matching to locate symbols at runtime; the name of the symbol searched must match exactly the name of the target. When the symbol names have been mangled, the dynamic loader has no way of knowing how the name of the symbol it’s searching for has been encoded.</p><p>To export nonmember symbols from a C++–based dynamic library so that the dynamic loader can find it, you must add the <code>extern "C"</code> directive to the symbols’ declarations. This keyword tells the compiler not to mangle the symbol name. For example, the following declaration makes the <code>NewPerson</code> function available to the library’s clients:</p><div class="codesample"><table><tr><td scope="row"><pre>extern "C" Person* NewPerson(void);<span></span></pre></td></tr></table></div><p>Without this directive, the function name could be changed to <code>_Z9NewPersonv</code> , which would make it impossible for the dynamic loader to find the <code>NewPerson</code> symbol at runtime.</p><p>The only nonmember functions that must be exported are constructors and destructors, especially in dynamic libraries that can be used by clients as dependent libraries instead of runtime-loaded libraries. This is because clients must have access to a class’s constructors and destructors so that they can use the <code>new</code> and <code>delete</code> operators on the class.</p><a name="//apple_ref/doc/uid/TP40002013-SW30" title="Defining C++ Class Interfaces"></a><h3>Defining C++ Class Interfaces</h3><p>A dynamic library should always publish its public interface to clients through header files. (Although clients can use dynamic libraries without their header files, doing so is very difficult and is prone to error.) The header file for a class that’s available to clients must include the declarations of its public methods. Dynamic libraries that make a class available to its clients must include the virtual keyword in the declaration of all the class’s methods, except for its constructors and destructors. For example, <span class="content_text">Listing 9</span> shows the declaration for the Person class.</p><a name="//apple_ref/doc/uid/TP40002013-SW11" title="Listing 9Declaration for the Person class"></a><p class="codesample"><strong>Listing 9&nbsp;&nbsp;</strong>Declaration for the Person class</p><div class="codesample"><table><tr><td scope="row"><pre>class Person {<span></span></pre></td></tr><tr><td scope="row"><pre>    private:<span></span></pre></td></tr><tr><td scope="row"><pre>        char _person_name[30];<span></span></pre></td></tr><tr><td scope="row"><pre>    public:<span></span></pre></td></tr><tr><td scope="row"><pre>        Person();<span></span></pre></td></tr><tr><td scope="row"><pre>        virtual void set_name(char person_name[]);<span></span></pre></td></tr><tr><td scope="row"><pre>        virtual char* name();<span></span></pre></td></tr><tr><td scope="row"><pre>};<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40002013-SW31" title="Creating and Destroying C++ Objects"></a><h3>Creating and Destroying C++ Objects</h3><p>When a C++–based dynamic library is a dependent library of its client, the client can use the <code>new</code> and <code>delete</code> operators to create and destroy instances of a class the library defines. However, clients that open a C++–based library at runtime through <code><a href="../../../Reference/MachOReference/Reference/reference.html#//apple_ref/c/func/dlopen" target="_top">dlopen</a></code> do not have access to the library’s constructors because the constructors are exported with their names mangled, preventing the dynamic loader from locating them. See <span class="content_text"><a href="DynamicLibraryDesignGuidelines.html#//apple_ref/doc/uid/TP40002013-SW12">Listing 11</a></span>  for details about name mangling.</p><p>Clients that load a library at runtime to use a class must have a way to create and destroy a class’s objects without using the <code>new</code> and <code>delete</code> operators. A library provides this functionality to its clients by exporting at least two class factory functions. <strong>Class factory functions</strong> create and destroy objects of a class on behalf of a class’s user. Creator functions create an object of the class and return a pointer to it. Destructor functions dispose of an object created by a creator function for the same class. In addition to the factory functions, the library must define a data type for each exported factory function.</p><p>For example, <span class="content_text">Listing 10</span> shows the header and implementation files of the Person class, exported by the Person library. The header file includes the declaration and type definition of a pair of factory functions, <code>NewPerson</code> , and <code>DeletePerson</code> :</p><a name="//apple_ref/doc/uid/TP40002013-SW13" title="Listing 10Interface and implementation of a C++ class in a dynamic library"></a><p class="codesample"><strong>Listing 10&nbsp;&nbsp;</strong>Interface and implementation of a C++ class in a dynamic library</p><div class="codesample"><table><tr><td scope="row"><pre>/* File: Person.h */<span></span></pre></td></tr><tr><td scope="row"><pre>class Person {<span></span></pre></td></tr><tr><td scope="row"><pre>    private:<span></span></pre></td></tr><tr><td scope="row"><pre>        char _person_name[30];<span></span></pre></td></tr><tr><td scope="row"><pre>    public:<span></span></pre></td></tr><tr><td scope="row"><pre>        Person();<span></span></pre></td></tr><tr><td scope="row"><pre>        virtual void set_name(char person_name[]);<span></span></pre></td></tr><tr><td scope="row"><pre>        virtual char* name();<span></span></pre></td></tr><tr><td scope="row"><pre>};<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>// Constructor function and function type.<span></span></pre></td></tr><tr><td scope="row"><pre>extern "C" Person* NewPerson(void);<span></span></pre></td></tr><tr><td scope="row"><pre>typedef Person * Person_creator(void);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>// Destructor function and function type.<span></span></pre></td></tr><tr><td scope="row"><pre>extern "C" void DeletePerson(Person* person);<span></span></pre></td></tr><tr><td scope="row"><pre>typedef void Person_disposer(Person*);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/* File: Person.cpp */<span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;iostream><span></span></pre></td></tr><tr><td scope="row"><pre>#include "Person.h"<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>#define EXPORT __attribute__((visibility("default")))<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>EXPORT<span></span></pre></td></tr><tr><td scope="row"><pre>Person::Person() {<span></span></pre></td></tr><tr><td scope="row"><pre>    this->set_name("&lt;no value>");<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>EXPORT<span></span></pre></td></tr><tr><td scope="row"><pre>Person* NewPerson(void) {<span></span></pre></td></tr><tr><td scope="row"><pre>    return new Person;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>EXPORT<span></span></pre></td></tr><tr><td scope="row"><pre>void DeletePerson(Person* person) {<span></span></pre></td></tr><tr><td scope="row"><pre>    delete person;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>void Person::set_name(char name[]) {<span></span></pre></td></tr><tr><td scope="row"><pre>    strcpy(_person_name, name);<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>char* Person::name(void) {<span></span></pre></td></tr><tr><td scope="row"><pre>    return _person_name;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p><span class="content_text">Listing 11</span> shows how a client might use the Person library.</p><a name="//apple_ref/doc/uid/TP40002013-SW12" title="Listing 11Client using a C++ class implemented in a runtime loaded library"></a><p class="codesample"><strong>Listing 11&nbsp;&nbsp;</strong>Client using a C++ class implemented in a runtime loaded library</p><div class="codesample"><table><tr><td scope="row"><pre>/* File: Client.cpp */<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;iostream><span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;dlfcn.h><span></span></pre></td></tr><tr><td scope="row"><pre>#include "Person.h"<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>int main() {<span></span></pre></td></tr><tr><td scope="row"><pre>    using std::cout;<span></span></pre></td></tr><tr><td scope="row"><pre>    using std::cerr;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Open the library.<span></span></pre></td></tr><tr><td scope="row"><pre>    void* lib_handle = dlopen("./libPerson.dylib", RTLD_LOCAL);<span></span></pre></td></tr><tr><td scope="row"><pre>    if (!lib_handle) {<span></span></pre></td></tr><tr><td scope="row"><pre>        cerr &lt;&lt; "[" &lt;&lt; __FILE__ &lt;&lt; "] main: Unable to open library: "<span></span></pre></td></tr><tr><td scope="row"><pre>             &lt;&lt; dlerror() &lt;&lt; "\n";<span></span></pre></td></tr><tr><td scope="row"><pre>        exit(EXIT_FAILURE);<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Get the NewPerson function.<span></span></pre></td></tr><tr><td scope="row"><pre>    Person_creator* NewPerson = (Person_creator*)dlsym(lib_handle, "NewPerson");<span></span></pre></td></tr><tr><td scope="row"><pre>    if (!NewPerson) {<span></span></pre></td></tr><tr><td scope="row"><pre>        cerr &lt;&lt; "[" &lt;&lt; __FILE__ &lt;&lt; "] main: Unable to find NewPerson method: "<span></span></pre></td></tr><tr><td scope="row"><pre>             &lt;&lt; dlerror() &lt;&lt; "\n";<span></span></pre></td></tr><tr><td scope="row"><pre>        exit(EXIT_FAILURE);<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Get the DeletePerson function.<span></span></pre></td></tr><tr><td scope="row"><pre>    Person_disposer* DeletePerson =<span></span></pre></td></tr><tr><td scope="row"><pre>        (Person_disposer*)dlsym(lib_handle, "DeletePerson");<span></span></pre></td></tr><tr><td scope="row"><pre>    if (!DeletePerson) {<span></span></pre></td></tr><tr><td scope="row"><pre>        cerr &lt;&lt; "[" &lt;&lt; __FILE__<span></span></pre></td></tr><tr><td scope="row"><pre>             &lt;&lt; "] main: Unable to find DeletePerson method: "<span></span></pre></td></tr><tr><td scope="row"><pre>             &lt;&lt; dlerror() &lt;&lt; "\n";<span></span></pre></td></tr><tr><td scope="row"><pre>        exit(EXIT_FAILURE);<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Create Person object.<span></span></pre></td></tr><tr><td scope="row"><pre>    Person* person = (Person*)NewPerson();<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Use Person object.<span></span></pre></td></tr><tr><td scope="row"><pre>    cout &lt;&lt; "[" &lt;&lt; __FILE__ &lt;&lt; "] person->name() = " &lt;&lt; person->name() &lt;&lt; "\n";<span></span></pre></td></tr><tr><td scope="row"><pre>    person->set_name("Floriane");<span></span></pre></td></tr><tr><td scope="row"><pre>    cout &lt;&lt; "[" &lt;&lt; __FILE__ &lt;&lt; "] person->name() = " &lt;&lt; person->name() &lt;&lt; "\n";<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Destroy Person object.<span></span></pre></td></tr><tr><td scope="row"><pre>    DeletePerson(person);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Close the library.<span></span></pre></td></tr><tr><td scope="row"><pre>    if (dlclose(lib_handle) != 0) {<span></span></pre></td></tr><tr><td scope="row"><pre>        cerr &lt;&lt; "[" &lt;&lt; __FILE__ &lt;&lt; "] main: Unable to close library: "<span></span></pre></td></tr><tr><td scope="row"><pre>             &lt;&lt; dlerror() &lt;&lt; "\n";<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    return 0;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>For further details on how clients use C++ classes implemented in dynamic libraries, see <span class="content_text"><a href="DynamicLibraryUsageGuidelines.html#//apple_ref/doc/uid/TP40001928-SW11">“Using C++ Classes.”</a></span></p><a name="//apple_ref/doc/uid/TP40002013-SW32" title="Objective-C&acirc;&#128;&#147;Based Libraries"></a><h2>Objective-C–Based Libraries</h2><p>There are a few issues to consider while designing or updating an Objective-C–based dynamic library:</p><ul class="ul"><li class="li"><p>Publishing the public interface of an Objective-C class or category is different from the way symbols are exported in C.</p><p>In Objective-C every method of every class is available at runtime. Clients can introspect classes to find out which methods are available. However, so that client developers don’t receive a flurry of warnings about missing method implementations, library developers should publish the interface to their classes and categories as protocols to client developers.</p></li><li class="li"><p>Objective-C–based libraries have access to more initialization facilities than those available to C-based libraries.</p></li><li class="li"><p>Objective-C has an class-alias facility that allows library developers to rename classes in a revision but allow clients to link against that revision to continue using the names used in earlier revisions.</p></li></ul><p>The following sections explore these areas in detail.</p><a name="//apple_ref/doc/uid/TP40002013-SW33" title="Defining Class and Category Interfaces"></a><h3>Defining Class and Category Interfaces</h3><p>Because client developers generally don’t have access to the implementation of Objective-C classes and categories defined in dynamic libraries, library developers must publish the public interfaces of classes and categories as protocols in header files. Client developers compile their products using those header files and are able to instantiate the classes correctly by adding the necessary protocol names to variable definitions. <span class="content_text">Listing 12</span> shows the header and implementation files of the Person class in an Objective-C–based library. <span class="content_text">Listing 13</span> shows the header and implementation files of the Titling category in the same library, which adds the <code>-setTitle</code> method to the Person class.</p><a name="//apple_ref/doc/uid/TP40002013-SW14" title="Listing 12Header and implementation files of the Person class"></a><p class="codesample"><strong>Listing 12&nbsp;&nbsp;</strong>Header and implementation files of the Person class</p><div class="codesample"><table><tr><td scope="row"><pre>/* File: Person.h */<span></span></pre></td></tr><tr><td scope="row"><pre>#import &lt;Foundation/Foundation.h><span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>@protocol Person<span></span></pre></td></tr><tr><td scope="row"><pre>- (void)setName:(NSString*)name;<span></span></pre></td></tr><tr><td scope="row"><pre>- (NSString*)name;<span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>@interface Person : NSObject &lt;Person> {<span></span></pre></td></tr><tr><td scope="row"><pre>    @private<span></span></pre></td></tr><tr><td scope="row"><pre>NSString* _person_name;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/* File: Person.m */<span></span></pre></td></tr><tr><td scope="row"><pre>#import &lt;Foundation/Foundation.h><span></span></pre></td></tr><tr><td scope="row"><pre>#import "Person.h"<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>@implementation Person<span></span></pre></td></tr><tr><td scope="row"><pre>- (id)init {<span></span></pre></td></tr><tr><td scope="row"><pre>    if (self = [super init]) {<span></span></pre></td></tr><tr><td scope="row"><pre>        _person_name = @"";<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (void)dealloc {<span></span></pre></td></tr><tr><td scope="row"><pre>    [_person_name release];<span></span></pre></td></tr><tr><td scope="row"><pre>    [super dealloc];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (void)setName:(NSString*)name {<span></span></pre></td></tr><tr><td scope="row"><pre>    [_person_name release];<span></span></pre></td></tr><tr><td scope="row"><pre>    _person_name = [name retain];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (NSString*)name {<span></span></pre></td></tr><tr><td scope="row"><pre>    return _person_name;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40002013-SW15" title="Listing 13Header and implementation files of the Titling category to the Person class"></a><p class="codesample"><strong>Listing 13&nbsp;&nbsp;</strong>Header and implementation files of the Titling category to the Person class</p><div class="codesample"><table><tr><td scope="row"><pre>/* File: Titling.h */<span></span></pre></td></tr><tr><td scope="row"><pre>#import &lt;Foundation/Foundation.h><span></span></pre></td></tr><tr><td scope="row"><pre>#import "Person.h"<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>@protocol Titling<span></span></pre></td></tr><tr><td scope="row"><pre>- (void)setTitle:(NSString*)title;<span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>@interface Person (Titling) &lt;Titling><span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/* File: Titling.m */<span></span></pre></td></tr><tr><td scope="row"><pre>#import &lt;Foundation/Foundation.h><span></span></pre></td></tr><tr><td scope="row"><pre>#import "Titling.h"<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>@implementation Person (Titling)<span></span></pre></td></tr><tr><td scope="row"><pre>- (void)setTitle:(NSString*)title {<span></span></pre></td></tr><tr><td scope="row"><pre>    [self setName:[[title stringByAppendingString:@" "]<span></span></pre></td></tr><tr><td scope="row"><pre>        stringByAppendingString:[self name]]];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr></table></div><p><span class="content_text">Listing 14</span> shows how a client might use the library.</p><a name="//apple_ref/doc/uid/TP40002013-SW16" title="Listing 14Client using the Person library"></a><p class="codesample"><strong>Listing 14&nbsp;&nbsp;</strong>Client using the Person library</p><div class="codesample"><table><tr><td scope="row"><pre>/* File: Client.m */<span></span></pre></td></tr><tr><td scope="row"><pre>#import &lt;Foundation/Foundation.h><span></span></pre></td></tr><tr><td scope="row"><pre>#import &lt;dlfcn.h><span></span></pre></td></tr><tr><td scope="row"><pre>#import "Person.h"<span></span></pre></td></tr><tr><td scope="row"><pre>#import "Titling.h"<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>int main() {<span></span></pre></td></tr><tr><td scope="row"><pre>    NSAutoreleasePool* pool = [NSAutoreleasePool new];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Open the library.<span></span></pre></td></tr><tr><td scope="row"><pre>    void* lib_handle = dlopen("./libPerson.dylib", RTLD_LOCAL);<span></span></pre></td></tr><tr><td scope="row"><pre>    if (!lib_handle) {<span></span></pre></td></tr><tr><td scope="row"><pre>        NSLog(@"[%s] main: Unable to open library: %s\n",<span></span></pre></td></tr><tr><td scope="row"><pre>            __FILE__, dlerror());<span></span></pre></td></tr><tr><td scope="row"><pre>        exit(EXIT_FAILURE);<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Get the Person class (required with runtime-loaded libraries).<span></span></pre></td></tr><tr><td scope="row"><pre>    Class Person_class = objc_getClass("Person");<span></span></pre></td></tr><tr><td scope="row"><pre>    if (!Person_class) {<span></span></pre></td></tr><tr><td scope="row"><pre>        NSLog(@"[%s] main: Unable to get Person class", __FILE__);<span></span></pre></td></tr><tr><td scope="row"><pre>        exit(EXIT_FAILURE);<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Create an instance of Person.<span></span></pre></td></tr><tr><td scope="row"><pre>    NSLog(@"[%s] main: Instantiating Person_class", __FILE__);<span></span></pre></td></tr><tr><td scope="row"><pre>    NSObject&lt;Person,Titling>* person = [Person_class new];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Use person.<span></span></pre></td></tr><tr><td scope="row"><pre>    [person setName:@"Perrine LeVan"];<span></span></pre></td></tr><tr><td scope="row"><pre>    [person setTitle:@"Ms."];<span></span></pre></td></tr><tr><td scope="row"><pre>    NSLog(@"[%s] main: [person name] = %@", __FILE__, [person name]);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Dispose of person.<span></span></pre></td></tr><tr><td scope="row"><pre>    [person release];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Close the library.<span></span></pre></td></tr><tr><td scope="row"><pre>    if (dlclose(lib_handle) != 0) {<span></span></pre></td></tr><tr><td scope="row"><pre>        NSLog(@"[%s] Unable to close library: %s\n",<span></span></pre></td></tr><tr><td scope="row"><pre>            __FILE__, dlerror());<span></span></pre></td></tr><tr><td scope="row"><pre>        exit(EXIT_FAILURE);<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    [pool release];<span></span></pre></td></tr><tr><td scope="row"><pre>    return(EXIT_SUCCESS);<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40002013-SW34" title="Initializing Objective-C Classes"></a><h3>Initializing Objective-C Classes</h3><p>Objecive-C–based dynamic libraries provide several initialization facilities for modules, classes, and categories. The following list describes those facilities in the order they are executed.</p><ol class="ol"><li class="li"><p>The <code>+load</code> method: Initializes resources needed by a class or a category. The Objective-C runtime sends the load message to every class a library implements; it then sends the <code>load</code> message to every category the library implements. The order in which sibling classes are sent the <code>load</code> message is undetermined. Implement the <code>+load</code> method to initialize resources needed by a class or category. Note that there’s no corresponding “unload” method.</p></li><li class="li"><p>Module initializers: Initializes a module. The dynamic loader calls all the initializer functions (defined with the <code>constructor</code> attribute) in each of a library’s modules. See <span class="content_text"><a href="DynamicLibraryDesignGuidelines.html#//apple_ref/doc/uid/TP40002013-SW17">“Module Initializers and Finalizers”</a></span> for more information on module initializers.</p></li><li class="li"><p>The <code>+initialize</code> method: Initializes resources needed by instances of a class before any instances are created. The Objective-C runtime sends the <code>initialize</code> message to a class just before creating an instance of the class. Note that there’s no corresponding “finalize” message sent to a class when the library is unloaded or the process terminates.</p></li></ol><a name="//apple_ref/doc/uid/TP40002013-SW35" title="Creating Aliases to a Class"></a><h3>Creating Aliases to a Class</h3><p>When you rename a class in a revision of a dynamic library, you can reduce the adoption burden to client developers by adding an alias to the new name in the library’s header file. This practice allows client developers to release clients that take advantage of the new version of the library quickly. Client developers can later update references to the class at their leisure. </p><a name="//apple_ref/doc/uid/TP40002013-SW36" title="Design Guidelines Checklist"></a><h2>Design Guidelines Checklist</h2><p>This list provides a summary of the guidelines for improving specific aspects of a dynamic library:</p><ul class="ul"><li class="li"><p>Ease of use</p><ul class="nested"><li class="nested li"><p>Reduce the number of symbols a library exports.</p></li><li class="nested li"><p>Provide unique names to public interfaces.</p></li></ul></li><li class="li"><p>Ease of maintenance</p><ul class="nested"><li class="nested li"><p>Export accessor functions to variables. Don’t export variables.</p></li><li class="nested li"><p>Implement public interfaces as wrappers to internal, private interfaces.</p></li></ul></li><li class="li"><p>Performance</p><ul class="nested"><li class="nested li"><p>Minimize the number of references to symbols in dependent libraries. Use <code>dlsym(RTLD_GLOBAL, &lt;symbol_name>)</code> to obtain the address of symbols exported by dependent libraries when they are needed.</p></li><li class="nested li"><p>Minimize the number of dependent libraries. Consider loading libraries with <code>dlopen</code> when absolutely necessary. Remember to close the library with <code>dlclose</code> when done.</p></li><li class="nested li"><p>Implement public interfaces as wrappers to internal, private interfaces.</p></li></ul></li><li class="li"><p>Compatibility</p><ul class="nested"><li class="nested li"><p>Export symbols as weakly linked symbols.</p></li><li class="nested li"><p>Encode a library’s major version number in its filename.</p></li></ul></li></ul>

        <br/><br/> 

        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="OverviewOfDynamicLibraries.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="DynamicLibraryUsageGuidelines.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2009 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2009-02-26<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/DeveloperTools/Conceptual/DynamicLibraries/100-Articles/DynamicLibraryDesignGuidelines.html%3Fid%3DTP40001869-1.6&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/DeveloperTools/Conceptual/DynamicLibraries/100-Articles/DynamicLibraryDesignGuidelines.html%3Fid%3DTP40001869-1.6&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/DeveloperTools/Conceptual/DynamicLibraries/100-Articles/DynamicLibraryDesignGuidelines.html%3Fid%3DTP40001869-1.6&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>
