<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>STD File Saver - /Source/MyPDEF_0_DraftMode.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxPrinting-date.html">Printing</a> &gt; <A HREF="javascript:location.replace('index.html');">STD File Saver</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/Printing/index.html" target="_blank">Reference Library > Printing</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">STD File Saver</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/Source/MyPDEF_0_DraftMode.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/Source/DAEntry.a</option>
<option value="listing2.html">/Source/driverTypes.h</option>
<option value="listing3.html">/Source/FileUtils.c</option>
<option value="listing4.html">/Source/FileUtils.h</option>
<option value="listing5.html">/Source/MyPACK.r</option>
<option value="listing6.html">/Source/MyPACK_4096.c</option>
<option value="listing7.html">/Source/MyPACK_4096_Nothing.a</option>
<option value="listing8.html">/Source/MyPDEF_0_DraftMode.a</option>
<option value="listing9.html">/Source/MyPDEF_0_DraftMode.c</option>
<option value="listing10.html">/Source/MyPDEF_4_HandlingDialogs.a</option>
<option value="listing11.html">/Source/MyPDEF_4_HandlingDialogs.c</option>
<option value="listing12.html">/Source/MyPDEF_5_PrPicFile.a</option>
<option value="listing13.html">/Source/MyPDEF_5_PrPicFile.c</option>
<option value="listing14.html">/Source/MyPDEF_7_PrGeneral.a</option>
<option value="listing15.html">/Source/MyPDEF_7_PrGeneral.c</option>
<option value="listing16.html">/Source/MyPrintTypes.r</option>
<option value="listing17.html">/Source/SettingsUtils.c</option>
<option value="listing18.html">/Source/SettingsUtils.h</option>
<option value="listing19.html">/Source/StdFileSaver.a</option>
<option value="listing20.html">/Source/StdFileSaver.c</option>
<option value="listing21.html">/Source/StdFileSaver.r</option>
<option value="listing22.html">/Source/StringUtils.c</option>
<option value="listing23.html">/Source/StringUtils.h</option></select>
				</p>
				</form>
				<p><strong><a href="STD_File_Saver.zip">Download Sample</a></strong> (&#147;STD_File_Saver.zip&#148;, 47.0K)<BR>
<strong><a href="STD_File_Saver.dmg">Download Sample</a></strong> (&#147;STD_File_Saver.dmg&#148;, 104.7K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*** Copyright 1991-1996 Apple Computer. All rights reserved.****  You may incorporate this sample code into your applications without**  restriction, though the sample code has been provided &quot;AS IS&quot; and the**  responsibility for its operation is 100% yours.  However, what you are**  not permitted to do is to redistribute the source as &quot;DSC Sample Code&quot;**  after having made changes. If you're going to re-distribute the source,**  we require that you make it clear in the source that the code was**  descended from Apple Sample Code, but that you've made changes.*/#include &lt;stddef.h&gt;#include &lt;types.h&gt;#include &lt;Printing.h&gt;#include &lt;Memory.h&gt;#include &lt;Files.h&gt;#include &lt;Resources.h&gt;#include &lt;TextUtils.h&gt;#include &lt;StandardFile.h&gt;#include &lt;Events.h&gt;#include &quot;driverTypes.h&quot;#include &quot;StringUtils.h&quot;#include &quot;FileUtils.h&quot;#include &quot;SettingsUtils.h&quot;pascal TPPrPort DraftPrOpenDoc(THPrint hPrint, TPPrPort pPrPort, Ptr pIOBuf);pascal void DraftPrCloseDoc(TPPrPort pPrPort);pascal void DraftPrOpenPage(TPPrPort pPrPort, TPRect pPageFrame);pascal void DraftPrClosePage(TPPrPort pPrPort);#if defined(__MWERKS__)asm void __Startup__ (void);asm void __Startup__ (void){  JMP  DraftPrOpenDoc  JMP  DraftPrCloseDoc  JMP  DraftPrOpenPage  JMP  DraftPrClosePage}#endif/*******************************************************************************  Constants for the Command-period checker.*******************************************************************************/#define  kModifiersMask    0xFF00 &amp; ~cmdKey  /*  We need all modifiers                          except the command key                          for KeyTrans. */#define  kOtherCharCodeMask  0x00FF0000      /*  Get the key out of the                          ASCII1 byte. */static Boolean IsColorGrafPort(GrafPtr thePort){  return(thePort-&gt;portBits.rowBytes &lt; 0);}static void GetEventChars(EventRecord *theEvent, long *lowChar, long *highChar){  unsigned  long  state = 0;  long        keyInfo;  long        virtualKey = (theEvent-&gt;message &amp; keyCodeMask) &gt;&gt; 8;  long        keyCID  = GetScript(GetEnvirons(smKeyScript), smScriptKeys);  Handle        hKCHR  = GetResource('KCHR', keyCID);  unsigned  short  keyCode  = (theEvent-&gt;modifiers &amp; kModifiersMask) | virtualKey;  if (hKCHR != nil) {    HLock(hKCHR);    keyInfo = KeyTranslate((void *)(*hKCHR), keyCode, &amp;state);    HUnlock(hKCHR);    ReleaseResource( hKCHR );  } else {    keyInfo = theEvent-&gt;message;  }  *lowChar =  keyInfo &amp; charCodeMask;  *highChar = (keyInfo &amp; kOtherCharCodeMask) &gt;&gt; 16;}static Boolean CmdPeriod(EventRecord *theEvent){  Boolean  result;  if ((theEvent-&gt;what == keyDown) || (theEvent-&gt;what == autoKey)) {    long  lowChar, highChar;    GetEventChars(theEvent, &amp;lowChar, &amp;highChar);    if ((theEvent-&gt;modifiers &amp; cmdKey) != 0 ) {      result = ((lowChar == period) || (highChar == period));    } else {      result = ((lowChar == escape) || (highChar == escape));    }  } else result = false;  // it wasn't my kind of event  return result;}static void MyIdleProc(void){  const short mask = (keyDownMask | autoKeyMask);  EventRecord  theEvent;    if (EventAvail(mask,&amp;theEvent)) {    if (CmdPeriod(&amp;theEvent)) {      (void)GetNextEvent(mask,&amp;theEvent);  // eat the event      setPrintErr(iPrAbort);    }  }}static void CallIdleProc(PrIdleUPP idleProc){  if (idleProc)    CallPrIdleProc(idleProc);  else    MyIdleProc();}pascal void DraftPrText(short byteCount, Ptr textBuf, Point numer, Point denom){#pragma unused(numer)#pragma unused(denom)  GrafPtr pPrPort;  MyPrintPtr myPrintRecord;#ifdef TRACKING  DebugStr(&quot;\pin DraftPrText;g&quot;);#endif  GetPort(&amp;pPrPort);  // don't need to worry about rgnSave or polySave for text  myPrintRecord = (MyPrintPtr)(((TPPrPort)pPrPort)-&gt;lGParam4);  BlockMoveData(pPrPort, myPrintRecord-&gt;OtherPort, mostOfGrafPort);  SetPort(myPrintRecord-&gt;OtherPort);  // do scaling here  DrawText(textBuf, 0, byteCount);  CallIdleProc(myPrintRecord-&gt;idleProc);  SetPort(pPrPort);  // adjust the pen location for scaling}pascal void DraftPrLine(Point newPt){  GrafPtr pPrPort;  MyPrintPtr printRecord;#ifdef TRACKING  DebugStr(&quot;\pin DraftPrLine;g&quot;);#endif  GetPort(&amp;pPrPort);  printRecord = (MyPrintPtr)(((TPPrPort)pPrPort)-&gt;lGParam4);  // if rgnSave field of grafPort is non-nil, don't change port,  // since that screws up region recording, same goes for polySave  if ((pPrPort-&gt;rgnSave) || (pPrPort-&gt;polySave)) {    StdLine(newPt);  } else {    BlockMoveData(pPrPort, printRecord-&gt;OtherPort, mostOfGrafPort);    SetPort(printRecord-&gt;OtherPort);    // do scaling here    LineTo(newPt.h, newPt.v);    SetPort(pPrPort);    pPrPort-&gt;pnLoc = newPt;  // set the pen location correctly  }  CallIdleProc(printRecord-&gt;idleProc);}pascal void DraftPrRect(GrafVerb verb, RectPtr r){  GrafPtr pPrPort;  MyPrintPtr printRecord;#ifdef TRACKING  DebugStr(&quot;\pin DraftPrRect;g&quot;);#endif  GetPort(&amp;pPrPort);  printRecord = (MyPrintPtr)(((TPPrPort)pPrPort)-&gt;lGParam4);  // if rgnSave field of grafPort is non-nil, don't change port,  // since that screws up region recording, same goes for polySave  if ((pPrPort-&gt;rgnSave) || (pPrPort-&gt;polySave)) {    StdRect(verb,r);  } else {    BlockMoveData(pPrPort, printRecord-&gt;OtherPort, mostOfGrafPort);    SetPort(printRecord-&gt;OtherPort);    // do scaling here    switch (verb) {       case frame:        FrameRect(r);        break;      case paint:        PaintRect(r);        break;      case erase:        EraseRect(r);        break;      case invert:        InvertRect(r);        break;      case fill:        FillRect(r, &amp;printRecord-&gt;OtherPort-&gt;fillPat);        break;      default:        DebugStr(&quot;\pUnknown verb for rect&quot;);        break;    }    SetPort(pPrPort);  }  CallIdleProc(printRecord-&gt;idleProc);}pascal void DraftPrrRect(GrafVerb verb, Rect * r, short ovalWidth, short ovalHeight){  GrafPtr pPrPort;  MyPrintPtr printRecord;#ifdef TRACKING  DebugStr(&quot;\pin DraftPrrRect;g&quot;);#endif  GetPort(&amp;pPrPort);  printRecord = (MyPrintPtr)(((TPPrPort)pPrPort)-&gt;lGParam4);  // if rgnSave field of grafPort is non-nil, don't change port,  // since that screws up region recording, same goes for polySave  if ((pPrPort-&gt;rgnSave) || (pPrPort-&gt;polySave)) {    StdRRect(verb,r,ovalWidth,ovalHeight);  } else {    BlockMoveData(pPrPort, printRecord-&gt;OtherPort, mostOfGrafPort);    SetPort(printRecord-&gt;OtherPort);    // do scaling here    switch (verb) {       case frame:        FrameRoundRect(r, ovalWidth, ovalHeight);        break;      case paint:        PaintRoundRect(r, ovalWidth, ovalHeight);        break;      case erase:        EraseRoundRect(r, ovalWidth, ovalHeight);        break;      case invert:        InvertRoundRect(r, ovalWidth, ovalHeight);        break;      case fill:        FillRoundRect(r, ovalWidth, ovalHeight, &amp;printRecord-&gt;OtherPort-&gt;fillPat);        break;      default:        DebugStr(&quot;\pUnknown verb for RoundRect&quot;);        break;    }    SetPort(pPrPort);  }  CallIdleProc(printRecord-&gt;idleProc);}pascal void DraftPrOval(GrafVerb verb, Rect * r){  GrafPtr pPrPort;  MyPrintPtr printRecord;#ifdef TRACKING  DebugStr(&quot;\pin DraftPrOval;g&quot;);#endif  GetPort(&amp;pPrPort);  printRecord = (MyPrintPtr)(((TPPrPort)pPrPort)-&gt;lGParam4);  // if rgnSave field of grafPort is non-nil, don't change port,  // since that screws up region recording, same goes for polySave  if ((pPrPort-&gt;rgnSave) || (pPrPort-&gt;polySave)) {    StdOval(verb,r);  } else {    BlockMoveData(pPrPort, printRecord-&gt;OtherPort, mostOfGrafPort);    SetPort(printRecord-&gt;OtherPort);    // do scaling here    switch (verb) {       case frame:        FrameOval(r);        break;      case paint:        PaintOval(r);        break;      case erase:        EraseOval(r);        break;      case invert:        InvertOval(r);        break;      case fill:        FillOval(r, &amp;printRecord-&gt;OtherPort-&gt;fillPat);        break;      default:        DebugStr(&quot;\pUnknown verb for oval&quot;);        break;    }    SetPort(pPrPort);  }  CallIdleProc(printRecord-&gt;idleProc);}pascal void DraftPrArc(GrafVerb verb, Rect * r, short startAngle, short arcAngle){  GrafPtr pPrPort;  MyPrintPtr printRecord;#ifdef TRACKING  DebugStr(&quot;\pin DraftPrArc;g&quot;);#endif  GetPort(&amp;pPrPort);  printRecord = (MyPrintPtr)(((TPPrPort)pPrPort)-&gt;lGParam4);  // if rgnSave field of grafPort is non-nil, don't change port,  // since that screws up region recording, same goes for polySave  if ((pPrPort-&gt;rgnSave) || (pPrPort-&gt;polySave)) {    StdArc(verb,r,startAngle,arcAngle);  } else {    BlockMoveData(pPrPort, printRecord-&gt;OtherPort, mostOfGrafPort);    SetPort(printRecord-&gt;OtherPort);    // do scaling here    switch (verb) {       case frame:        FrameArc(r, startAngle, arcAngle);        break;      case paint:        PaintArc(r, startAngle, arcAngle);        break;      case erase:        EraseArc(r, startAngle, arcAngle);        break;      case invert:        InvertArc(r, startAngle, arcAngle);        break;      case fill:        FillArc(r, startAngle, arcAngle, &amp;printRecord-&gt;OtherPort-&gt;fillPat);        break;      default:        DebugStr(&quot;\pUnknown verb for arc&quot;);        break;    }    SetPort(pPrPort);  }  CallIdleProc(printRecord-&gt;idleProc);}pascal void DraftPrPoly(GrafVerb verb, PolyHandle Poly){  GrafPtr pPrPort;  MyPrintPtr printRecord;#ifdef TRACKING  DebugStr(&quot;\pin DraftPrPoly;g&quot;);#endif  GetPort(&amp;pPrPort);  printRecord = (MyPrintPtr)(((TPPrPort)pPrPort)-&gt;lGParam4);  // if rgnSave field of grafPort is non-nil, don't change port,  // since that screws up region recording  // calling poly procs with poly recording on is bad, so we won't  // even think about that possibility  if (pPrPort-&gt;rgnSave) {    StdPoly(verb,Poly);  } else {    BlockMoveData(pPrPort, printRecord-&gt;OtherPort, mostOfGrafPort);    SetPort(printRecord-&gt;OtherPort);    // do scaling here    switch (verb) {       case frame:        FramePoly(Poly);        break;      case paint:        PaintPoly(Poly);        break;      case erase:        ErasePoly(Poly);        break;      case invert:        InvertPoly(Poly);        break;      case fill:        FillPoly(Poly, &amp;printRecord-&gt;OtherPort-&gt;fillPat);        break;      default:        DebugStr(&quot;\pUnknown verb for poly&quot;);        break;    }    SetPort(pPrPort);  }  CallIdleProc(printRecord-&gt;idleProc);}pascal void DraftPrRgn(GrafVerb verb, RgnHandle Rgn){  GrafPtr pPrPort;  MyPrintPtr printRecord;#ifdef TRACKING  DebugStr(&quot;\pin DraftPrRgn;g&quot;);#endif  GetPort(&amp;pPrPort);  printRecord = (MyPrintPtr)(((TPPrPort)pPrPort)-&gt;lGParam4);  // if rgnSave field of grafPort is non-nil, don't change port,  // since that screws up region recording, same goes for polySave  // calling poly procs with poly recording on would be  // bad enough that I'm just going to ignore it.  if (pPrPort-&gt;polySave) {    StdRgn(verb,Rgn);  } else {    BlockMoveData(pPrPort,printRecord-&gt;OtherPort, mostOfGrafPort);    SetPort(printRecord-&gt;OtherPort);    // do scaling here    switch (verb) {       case frame:        FrameRgn(Rgn);        break;      case paint:        PaintRgn(Rgn);        break;      case erase:        EraseRgn(Rgn);        break;      case invert:        InvertRgn(Rgn);        break;      case fill:        FillRgn(Rgn, &amp;printRecord-&gt;OtherPort-&gt;fillPat);        break;      default:        DebugStr(&quot;\pUnknown region verb&quot;);        break;    }    SetPort(pPrPort);  }  CallIdleProc(printRecord-&gt;idleProc);}pascal void DraftPrBits(BitMapPtr srcBits, Rect * srcRect, Rect * dstRect, short mode, RgnHandle maskRgn){  GrafPtr pPrPort;  Rect aRect;  MyPrintPtr printRecord;#ifdef TRACKING  DebugStr(&quot;\pin DraftPrBits;g&quot;);#endif  GetPort(&amp;pPrPort);  printRecord = (MyPrintPtr)(((TPPrPort)pPrPort)-&gt;lGParam4);  BlockMoveData(pPrPort, printRecord-&gt;OtherPort, mostOfGrafPort);  SetPort(printRecord-&gt;OtherPort);  aRect = *dstRect;  // do scaling here  CopyBits(srcBits, &amp;printRecord-&gt;OtherPort-&gt;portBits, srcRect, &amp;aRect, mode, maskRgn);  CallIdleProc(printRecord-&gt;idleProc);  SetPort(pPrPort);}pascal void DraftPrComment(short kind, short dataSize, Handle dataHandle){  GrafPtr pPrPort;  MyPrintPtr printRecord;#ifdef TRACKING  DebugStr(&quot;\pin DraftPrComment;g&quot;);#endif  GetPort(&amp;pPrPort);  printRecord = (MyPrintPtr)(((TPPrPort)pPrPort)-&gt;lGParam4);  BlockMoveData(pPrPort, printRecord-&gt;OtherPort, mostOfGrafPort);  SetPort(printRecord-&gt;OtherPort);  PicComment(kind, dataSize, dataHandle);  CallIdleProc(printRecord-&gt;idleProc);  SetPort(pPrPort);}pascal short DraftPrTxMeas(short byteCount, Ptr textAddr,  Point *numer, Point *denom, FontInfo *info){  short  retval;#ifdef TRACKING  DebugStr(&quot;\pin DraftPrTxMeas;g&quot;);#endif  // If the port is scaled, you'll need to modify the values  // passed to and returned by StdTxMeas() to take the  // scaling into account  retval = StdTxMeas(byteCount,textAddr,numer,denom,info);  return retval;}#ifdef COMPRESSED_DATApascal void DraftPrPix(PixMapPtr src, const Rect *srcRect, MatrixRecordPtr matrix,  short mode, RgnHandle mask, PixMapPtr matte, Rect *matteRect, short flags){#pragma unused(src)#pragma unused(srcRect)#pragma unused(matrix)#pragma unused(mode)#pragma unused(mask)#pragma unused(matte)#pragma unused(matteRect)#pragma unused(flags)  // If we want to support sending compressed data, this is the  // place to hook in the support. See Develop 24, pp 72-83 for  // details. Also see IM:QuickTime pg 3-137 and IM:Imaging for  // more details. As an added benefit, CopyDeepMask comes through  // this proc, which is why the setIsPrintingFlag and  // clearIsPrintingFlag macros are commented out in the header  // file and point you to here for more explanation.  DebugStr(&quot;\pTsk. COMPRESSED_DATA flag set, but no code written.&quot;);}#endifvoid SetPrgProcs(TPPrPort myPPrPort){  // Using UPPs, since this hopes to be native some day  myPPrPort-&gt;gProcs.textProc = NewQDTextProc(DraftPrText);  myPPrPort-&gt;gProcs.lineProc = NewQDLineProc(DraftPrLine);  myPPrPort-&gt;gProcs.rectProc = NewQDRectProc(DraftPrRect);  myPPrPort-&gt;gProcs.rRectProc = NewQDRRectProc(DraftPrrRect);  myPPrPort-&gt;gProcs.ovalProc = NewQDOvalProc(DraftPrOval);  myPPrPort-&gt;gProcs.arcProc = NewQDArcProc(DraftPrArc);  myPPrPort-&gt;gProcs.polyProc = NewQDPolyProc(DraftPrPoly);  myPPrPort-&gt;gProcs.rgnProc = NewQDRgnProc(DraftPrRgn);  myPPrPort-&gt;gProcs.bitsProc = NewQDBitsProc(DraftPrBits);  myPPrPort-&gt;gProcs.commentProc = NewQDCommentProc(DraftPrComment);  myPPrPort-&gt;gProcs.txMeasProc = NewQDTxMeasProc(DraftPrTxMeas);  // note: no bottleneck replacement for getPicProc or putPicProc    // Note: also no pixProc bottleneck, since it ain't there unless  // it's a CGrafPort, which this ain't.}pascal void ChangeBottleNeck(Boolean withColor, TPPrPort myPPrPort, MyPrintPtr thePrintPtr){  if (withColor) {    OpenCPort((CGrafPtr)myPPrPort);    SetStdCProcs(&amp;thePrintPtr-&gt;cProcs);        // even with a Color PICT saving, we set the gProcs field of the Printing port     // just in case some weird application wants to use them directly     // to my knowledge, no application do such an absurd thing as that but Murphy Lives !     SetPrgProcs(myPPrPort);        thePrintPtr-&gt;cProcs.textProc = NewQDTextProc(DraftPrText);    thePrintPtr-&gt;cProcs.lineProc = NewQDLineProc(DraftPrLine);    thePrintPtr-&gt;cProcs.rectProc = NewQDRectProc(DraftPrRect);    thePrintPtr-&gt;cProcs.rRectProc = NewQDRRectProc(DraftPrrRect);    thePrintPtr-&gt;cProcs.ovalProc = NewQDOvalProc(DraftPrOval);    thePrintPtr-&gt;cProcs.arcProc = NewQDArcProc(DraftPrArc);    thePrintPtr-&gt;cProcs.polyProc = NewQDPolyProc(DraftPrPoly);    thePrintPtr-&gt;cProcs.rgnProc = NewQDRgnProc(DraftPrRgn);    thePrintPtr-&gt;cProcs.bitsProc = NewQDBitsProc(DraftPrBits);    thePrintPtr-&gt;cProcs.commentProc = NewQDCommentProc(DraftPrComment);    thePrintPtr-&gt;cProcs.txMeasProc = NewQDTxMeasProc(DraftPrTxMeas);#ifdef COMPRESSED_DATA    // If we want to handle compressed data, we put in our stdPix replacement    ///// Hmm. There doesn't seem to be a declaration for a NewQDPixProc in QuickDraw.h    ///// Bummer. Radar ID#1341027. -DaveP 4/15/96    ((CGrafPort)(myPPrPort-&gt;gPort)).grafProcs-&gt;newProc1 = DraftPrPix;#endif    ((CGrafPtr)myPPrPort)-&gt;grafProcs = &amp;(thePrintPtr-&gt;cProcs);  } else {    OpenPort((GrafPtr)myPPrPort);    SetStdProcs(&amp;myPPrPort-&gt;gProcs);    SetPrgProcs(myPPrPort);    myPPrPort-&gt;gPort.grafProcs = &amp;myPPrPort-&gt;gProcs;  }}pascal TPPrPort DraftPrOpenDoc(THPrint hPrint, TPPrPort pPrPort, Ptr pIOBuf){#pragma unused(pIOBuf)  SysEnvRec  theWorld;  OSErr    bugOutError;  TPPrPort  myPPrPort;  THPrint    *myHPrint;  MyPrintPtr  printRecord;#ifdef TRACKING  DebugStr(&quot;\pin DraftPrOpenDoc;g&quot;);#endif  myHPrint = &amp;hPrint;  if (pPrPort == NULL) {  // does the caller give us a Printing Port or do we allocate it ?     myPPrPort = (TPPrPort)NewPtrClear(sizeof(TPrPort));    if (myPPrPort == NULL) {      bugOutError = iMemFullErr;      goto BUGOUT;    }    myPPrPort-&gt;fOurPtr = true;  } else {    myPPrPort = pPrPort;    myPPrPort-&gt;fOurPtr = false;  }  myPPrPort-&gt;lGParam1 = 0xDEADBEEF;  // a flag value showing badness  myPPrPort-&gt;lGParam2 = 0xDEADBEEF;  // a flag value showing badness  myPPrPort-&gt;lGParam3 = 0xDEADBEEF;  // a flag value showing badness  myPPrPort-&gt;lGParam4 = (long) NewPtrClear(sizeof(MyPrintRec));  // we need this space to work  if (myPPrPort-&gt;lGParam4 == 0) {    bugOutError = iMemFullErr;    goto BUGOUT;  }    SysEnvirons(1, &amp;theWorld);    // the real job is here, changing the QuickDraw Bottleneck to install our printing routines   ChangeBottleNeck(((theWorld.hasColorQD) &amp;&amp; ((**hPrint).printX[8] == 0)),     myPPrPort, (MyPrintPtr)myPPrPort-&gt;lGParam4);    // to prevent any real drawing, set the bounds to EmptyRect  if (IsColorGrafPort(&amp;(myPPrPort-&gt;gPort))) {    CGrafPtr  thePort = (CGrafPtr)(&amp;(myPPrPort-&gt;gPort));    Rect    *theRect = &amp;((**(thePort-&gt;portPixMap)).bounds);    SetRect(theRect, 0, 0, 0, 0);  } else {    SetRect(&amp;(myPPrPort-&gt;gPort.portBits.bounds), 0, 0, 0, 0);  }  myPPrPort-&gt;gPort.portRect = (**hPrint).prInfo.rPage;    printRecord = (MyPrintPtr)(myPPrPort-&gt;lGParam4);    if ((**hPrint).printX[6]) {    // just print specified range    printRecord-&gt;firstPage = (**hPrint).prJob.iFstPage;    printRecord-&gt;lastPage = (**hPrint).prJob.iLstPage;  } else {    // print all pages    printRecord-&gt;firstPage = iPrPgFst;    printRecord-&gt;lastPage = iPrPgMax;  }  printRecord-&gt;idleProc = (**hPrint).prJob.pIdleProc;  printRecord-&gt;OtherPort = (GrafPtr)(NewPtrClear(sizeof(GrafPort)));  if (printRecord-&gt;OtherPort == NULL) {    bugOutError = iMemFullErr;    goto BUGOUT;  }  BlockMoveData(myPPrPort, printRecord-&gt;OtherPort, mostOfGrafPort);    bugOutError = SelectOutputFile(&amp;(printRecord-&gt;fileSpec));  if (bugOutError != noErr) {    DebugStr(&quot;\pFailed to select&quot;);    goto BUGOUT;  }  bugOutError = OpenOutputFile(&amp;(printRecord-&gt;fileSpec),                &amp;(printRecord-&gt;fileRef),                GetSavedRadioOption());  if (bugOutError != noErr) {    DebugStr(&quot;\pFailed to open&quot;);    goto BUGOUT;  }// normal return  return myPPrPort;// error conditions make us come hereBUGOUT:  if (myPPrPort != NULL) {    if (myPPrPort-&gt;lGParam4 != 0) {      if (!((*(*myHPrint))-&gt;printX[7] == 0)) {        DisposePtr((Ptr)(printRecord-&gt;OtherPort));      }      DisposePtr((Ptr)printRecord);      if (IsColorGrafPort(&amp;(myPPrPort-&gt;gPort)))        CloseCPort((CGrafPtr)(myPPrPort));      else         ClosePort((GrafPtr)(myPPrPort));    }    if (myPPrPort-&gt;fOurPtr)       DisposePtr((Ptr)(myPPrPort));  }  setPrintErr(bugOutError);  return 0L;}static void DisposeQDBottleNeckProcs(QDProcs theOldProcs){  DisposeRoutineDescriptor(theOldProcs.textProc);  DisposeRoutineDescriptor(theOldProcs.lineProc);  DisposeRoutineDescriptor(theOldProcs.rectProc);  DisposeRoutineDescriptor(theOldProcs.rRectProc);  DisposeRoutineDescriptor(theOldProcs.ovalProc);  DisposeRoutineDescriptor(theOldProcs.arcProc);  DisposeRoutineDescriptor(theOldProcs.polyProc);  DisposeRoutineDescriptor(theOldProcs.rgnProc);  DisposeRoutineDescriptor(theOldProcs.bitsProc);  DisposeRoutineDescriptor(theOldProcs.commentProc);  DisposeRoutineDescriptor(theOldProcs.txMeasProc);}static void DisposeCQDBottleNeckProcs(CQDProcs theColorProcs){  DisposeRoutineDescriptor(theColorProcs.textProc);  DisposeRoutineDescriptor(theColorProcs.lineProc);  DisposeRoutineDescriptor(theColorProcs.rectProc);  DisposeRoutineDescriptor(theColorProcs.rRectProc);  DisposeRoutineDescriptor(theColorProcs.ovalProc);  DisposeRoutineDescriptor(theColorProcs.arcProc);  DisposeRoutineDescriptor(theColorProcs.polyProc);  DisposeRoutineDescriptor(theColorProcs.rgnProc);  DisposeRoutineDescriptor(theColorProcs.bitsProc);  DisposeRoutineDescriptor(theColorProcs.commentProc);  DisposeRoutineDescriptor(theColorProcs.txMeasProc);  ///// The following gets commented in when the NewxxxxxProc macro is used#ifdef COMPRESSED_DATA  // If we want to handle compressed data, we put in our stdPix replacement  ///// Hmm. There doesn't seem to be a declaration for a NewQDPixProc in QuickDraw.h  ///// Bummer. Radar ID#1341027. -DaveP 4/15/96/////  DisposeRoutineDescriptor(grafProcs-&gt;newProc1);#endif}pascal void DraftPrCloseDoc(TPPrPort pPrPort){#ifdef TRACKING  DebugStr(&quot;\pin DraftPrCloseDoc;g&quot;);#endif  if (pPrPort != NULL) {    if (pPrPort-&gt;lGParam4 != 0) {      MyPrintPtr  printRecord = (MyPrintPtr)(pPrPort-&gt;lGParam4);      (void) CloseOutputFile(printRecord-&gt;fileRef, GetSavedRadioOption());      // Clean up the routineDescriptors in the procs      // This is needed for PPC native drivers, which this      // isn't yet, but I put it in now so I didn't space it.      // -DaveP 4/15/96      DisposeQDBottleNeckProcs(pPrPort-&gt;gProcs);      DisposeCQDBottleNeckProcs(printRecord-&gt;cProcs);      DisposePtr((Ptr)printRecord-&gt;OtherPort);      DisposePtr((Ptr)printRecord);    } else {      DebugStr(&quot;\pThis doesn't seem to be my Print Record that I've been asked to close!&quot;);    }    if (IsColorGrafPort((GrafPtr)pPrPort))      CloseCPort((CGrafPtr)pPrPort);    else       ClosePort((GrafPtr)pPrPort);    // only nuke the grafport if we made it    if (pPrPort-&gt;fOurPtr) DisposePtr((Ptr)pPrPort);  } else {    DebugStr(&quot;\pTsk. Naughty application calls PrCloseDoc with a bad port&quot;);  }}pascal void DraftPrOpenPage(TPPrPort pPrPort, TPRect pPageFrame){#pragma unused(pPageFrame)  // in case of PICT saving, we create a new PICT file for each page   // the name of the PICT file is the name chosen by the user + the  // number of the page and we store that file in the folder with the  // same name that we created in DraftPrOpenDoc   MyPrintPtr printRecord = (MyPrintPtr)pPrPort-&gt;lGParam4;#ifdef TRACKING  DebugStr(&quot;\pin DraftPrOpenPage;g&quot;);#endif  printRecord-&gt;CurPage++;  setIsPrintingFlag();  // we reinitialize this every page, even though I'm not sure I need to  BlockMoveData(pPrPort, printRecord-&gt;OtherPort, mostOfGrafPort);  printRecord-&gt;OtherPort-&gt;picSave = NULL;  printRecord-&gt;OtherPort-&gt;rgnSave = NULL;  printRecord-&gt;OtherPort-&gt;polySave = NULL;  printRecord-&gt;OtherPort-&gt;grafProcs = NULL;  SetPort(printRecord-&gt;OtherPort);  // do scaling here  printRecord-&gt;thePict = OpenPicture(&amp;printRecord-&gt;OtherPort-&gt;portRect);  if (printRecord-&gt;thePict == NULL) {    setPrintErr(iMemFullErr);    return;  }  ClipRect(&amp;(printRecord-&gt;OtherPort-&gt;portRect));  SetPort((GrafPtr)pPrPort);}static CTabHandle GetPmTable(CGrafPtr thePort){  PixMapHandle thePixMap = thePort-&gt;portPixMap;  return((**thePixMap).pmTable);}static Boolean IsInRange(short num, short min, short max){  return ((num &gt;= min) &amp;&amp; (num &lt;= max));}pascal void DraftPrClosePage(TPPrPort pPrPort){  long    theCount;  MyPrintPtr  printRecord = (MyPrintPtr)(pPrPort-&gt;lGParam4);#ifdef TRACKING  DebugStr(&quot;\pin DraftPrClosePage;g&quot;);#endif  SetPort(printRecord-&gt;OtherPort);  ClosePicture();  clearIsPrintingFlag();  SetPort((GrafPtr)pPrPort);  if (IsInRange(printRecord-&gt;CurPage,printRecord-&gt;firstPage,printRecord-&gt;lastPage)) {    // the following disposes of the handle correctly, too    OSErr  writeError = WritePictData(printRecord-&gt;fileRef,              (Handle) printRecord-&gt;thePict,              printRecord-&gt;CurPage,              GetSavedRadioOption());    if (writeError) {      setPrintErr(writeError);      return;    }        // we also save the current color table as a 'clut' resource    // in the same file since a lot of Color Paint or Draw software    // use that kind of information to get the colors right    writeError = WriteCLUTData(printRecord-&gt;fileRef);    if (writeError) {      setPrintErr(writeError);      return;    }  } else {    DisposeHandle((Handle)(printRecord-&gt;thePict));  }}</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/STD_File_Saver/listing9.html%3Fid%3DDTS10000307-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/STD_File_Saver/listing9.html%3Fid%3DDTS10000307-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/STD_File_Saver/listing9.html%3Fid%3DDTS10000307-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>