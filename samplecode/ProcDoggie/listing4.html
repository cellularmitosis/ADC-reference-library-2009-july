<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>ProcDoggie - /UEmergMem.p</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxCarbon-date.html">Carbon</a> &gt; <A HREF="javascript:location.replace('index.html');">ProcDoggie</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/Carbon/idxProcessManagement-date.html" target="_blank">Carbon > Process Management</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">ProcDoggie</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/UEmergMem.p</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/ProcDoggie.p</option>
<option value="listing2.html">/StubLDEF/StubLDEF.p</option>
<option value="listing3.html">/UDialogUtils.p</option>
<option value="listing4.html">/UEmergMem.p</option>
<option value="listing5.html">/UEvents.p</option>
<option value="listing6.html">/UGlobals.p</option>
<option value="listing7.html">/UMenuHandler.p</option>
<option value="listing8.html">/UProcessGuts.p</option>
<option value="listing9.html">/UProcessLDEF.p</option>
<option value="listing10.html">/UProcessUtils.p</option></select>
				</p>
				</form>
				<p><strong><a href="ProcDoggie.zip">Download Sample</a></strong> (&#147;ProcDoggie.zip&#148;, 94.4K)<BR>
<strong><a href="ProcDoggie.dmg">Download Sample</a></strong> (&#147;ProcDoggie.dmg&#148;, 163.0K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">{  File:    UEmergMem.p  Contains:  EmergMem contains routines to handle emergency memory situations.  This is        used for Toolbox routines that either don't check for memory-full errors, or        that call _SysErr when they can't allocate the memory that they need.  The        purpose of the routines in this unit is to make sure that these toolbox        routines always get the memory they need.  Written by: Forrest Tanaka    Copyright:  Copyright &copy; 1988-1999 by Apple Computer, Inc., All Rights Reserved.        You may incorporate this Apple sample source code into your program(s) without        restriction. This Apple sample source code has been provided &quot;AS IS&quot; and the        responsibility for its operation is yours. You are not permitted to redistribute        this Apple sample source code as &quot;Apple sample source code&quot; after having made        changes. If you're going to re-distribute the source, we require that you make        it clear in the source that the code was descended from Apple sample source        code, but that you've made changes.  Change History (most recent first):        7/27/1999  Karl Groethe  Updated for Metrowerks Codewarror Pro 2.1        }UNIT UEmergMem;{[j=20/57/1$] Pasmat Options}INTERFACE(******************************************************************************** Used Units*******************************************************************************)  USES    Memory    ;(******************************************************************************** Constants*******************************************************************************)  CONST    kAllocApp = TRUE; {For NewPtrMargin/NewHandleMargin for app heap alloc}    kAllocClr = TRUE; {For NewPtrMargin/NewHandleMargin to clear mem block}(******************************************************************************** ConnectAppGZ - Connect the application grow zone proc** This routine is called whenever this application's simple grow-zone procedure* (see below for the source for the grow-zone procedure) is to be* connected.  From this point on, any requests for memory by this application or* the system invoke our grow-zone procedure if there isn't enough memory to* satisfy the request.*******************************************************************************)  PROCEDURE ConnectAppGZ;(******************************************************************************** DisconnectAppGZ - Disconnect the application grow zone proc** This routine is called whenever this application's simple grow-zone procedure* (see below for the source for the grow-zone procedure) is to be* disconnected.  From this point on, any requests for memory by this application* or the system return memFullErr if there isn't enough memory to satisfy the* request.*******************************************************************************)  PROCEDURE DisconnectAppGZ;(******************************************************************************** InitEmergMem - Allocate emergency memory** This is called at startup time to allocate the emergency memory block that's* deallocated in the grow zone procedure (this application's grow-zone procedure* is a privately-declared procedure defined below).  InitEmergMem* also installs this application's grow-zone proc.** If there isn't enough memory to allocate the block of emergency memory, then* a subsequent call to FailLowMemory(0) returns TRUE.*******************************************************************************)  PROCEDURE InitEmergMem;(******************************************************************************** NoEmergMem - Check to see if emergency memory is being used or not** Before my application attempts to use more memory, I call this routine to* check if I'm already using my emergency memory.  If so, then I'd better* prepare to die or get my emergency memory back.*******************************************************************************)  FUNCTION NoEmergMem: Boolean;(******************************************************************************** RecoverEmergMem - Recover emergency memory** This is called from the event loop if NoEmergMem indicates that the emergency* memory was deallocated by this application's grow-zone procedure.  This* routine will attempt recover the emergency memory.  If this fails, then some* usually some application options and commands are disabled until there is* enough free memory to enable them again.*******************************************************************************)  PROCEDURE RecoverEmergMem;(******************************************************************************** FailLowMemory - Is there enough free space in heap to allocate memory?** FailLowMemory is called any time a potentially significant amount of non-* temporary memory is about to be allocated.  It returns TRUE if there's enough* free space in the heap to allocate the requested amount of memory and still* have a significant amount of free space left over, and if the emergency memory* isn't being used.  See below for the definition of &quot;significant* amount.&quot;  &quot;memRequest&quot; specifies the number of bytes that are about to be* allocated.** This routine is also used even if the amount of memory about to be allocated* isn't clear.  In this case, it's called after the significant amount of memory* is allocated and 0 is passed in memRequest.  If FailLowMemory returns TRUE,* then there's was enough memory for the requested amount and still leave 32K* free and the emergency memory allocated.  If FailLowMemory returns FALSE, then* either there isn't 32K free, or the emergency memory was deallocated by this* application's grow-zone procedure, or both.  This is actually the usual way* that I use this function, because I normally use it for calls to the Toolbox,* and there's usually no reliable way to determine how much memory the Toolbox* is going to allocate.*******************************************************************************)  FUNCTION FailLowMemory (memRequest: LongInt): Boolean;(******************************************************************************** NewHandleMargin - Create a new handle without using emergency memory** Many toolbox routines simply call SysErr when they run out of memory.  That's* not too cool, so I try to make certain that the memory they need is always* available by making sure that I never request so much memory that the toolbox* routines are in danger of running out of memory and calling SysErr.  This is* achieved by calling NewHandleMargin instead of NewHandle any time a* relocatable memory block is desired.  NewHandle returns memFullErr in MemErr* if there isn't enough free contiguous space to satisfy the request and still* leave a significant amount of free memory.** NewHandleMargin returns NIL if there isn't enough memory to allocated a block* of the size specified by &quot;requestedSize&quot;.** If &quot;appHeapAlloc&quot; is kAppHeap, then the block of memory is allocated in the* application's heap.  If &quot;appHeapAlloc&quot; is NOT kAppHeap, then the block of* memory is allocated in the system heap.** If &quot;clearMem&quot; is kAllocClr, then all the bytes in the block of memory are* cleared to zero.  If NOT kAllocClr is passed, then none of the bytes in the* block of memory are touched after being allocated.*******************************************************************************)  FUNCTION NewHandleMargin (requestedSize: Size;                            appHeapAlloc:  Boolean;                            clearMem:      Boolean): Handle;(******************************************************************************** NewPtrMargin - Create a new pointer without using emergency memory** Many toolbox routines simply call SysErr when they run out of memory.  That's* not too cool, so I try to make certain that the memory they need is always* available by making sure that I never request so much memory that the toolbox* routines are in danger of running out of memory and calling SysErr.  This is* achieved by calling NewPtr instead of NewHandle any time a non-relocatable* memory block is desired.  NewHandle returns memFullErr in MemErr if there* isn't enough free contiguous space to satisfy the request and still leave a* significant amount of free memory.** NewptrMargin returns NIL if there isn't enough memory to allocated a block of* the size specified by &quot;requestedSize&quot;.** If &quot;appHeapAlloc&quot; is kAppHeap, then the block of memory is allocated in the* application's heap.  If &quot;appHeapAlloc&quot; is NOT kAppHeap, then the block of* memory is allocated in the system heap.** If &quot;clearMem&quot; is kAllocClr, then all the bytes in the block of memory are* cleared to zero.  If NOT kAllocClr is passed, then none of the bytes in the* block of memory are touched after being allocated.*******************************************************************************)  FUNCTION NewPtrMargin (requestedSize: Size;                         appHeapAlloc:  Boolean;                         clearMem:      Boolean): Ptr;IMPLEMENTATION  USES    OSUtils;(******************************************************************************** Constants*******************************************************************************)  CONST    kEmergMemSize = 32768; {Number of bytes of emergency memory to allocate}    kMemoryMargin = 32768; {Minimum amount of free memory I allow in the heap}(******************************************************************************** Global Variables*******************************************************************************)  VAR    gEmergMem: Handle; {Handle to block of emergency memory}{$S Main}(******************************************************************************** Private: AppGrowZoneProc - Custom grow-zone procedure** This is a very basic grow zone procedure.  My application keeps a reserve* handle of memory in case the Memory Manager gets a request for some memory* that is not available in my heap.  If memory were to get tight (&lt;32k), the* Toolbox will crash the system.  This grow-zone proc tries to thwart that* possibility by releasing the 32K block of emergency memory if it hasn't been* released already and if the amount of memory requested is less than 32K.* Hopefully, that's enough to satisfy the memory request.** There are three conditions in which the emergency memory isn't freed.  If the* emergency memory is already free, obviously there isn't much that can be done.* If the emergency memory is equal to GZSaveHnd, then it was the reallocation of* emergency memory that caused this grow-zone proc to be called.  So it doesn't* make much sense to free it in that case.  If the size of the memory request is* more than the size of emergency memory, then I don't bother to free emergency* memory because I assume that the toolbox handles such huge requests for memory* properly.  Warning: that isn't always a good assumption, but that's not my* fault.**     WARNING: Register A5 might not be valid when grow-zone procedures*     are called. Read Technical Note #136 and 208.** The &quot;cbNeeded&quot; parameter is the number of bytes that the Memory Manager needs* to fulfill the memory request it had received.  The number of bytes actually* freed by AppGrowZoneProc is returned.*******************************************************************************)  FUNCTION AppGrowZoneProc (cbNeeded: Size): LongInt;    VAR      theA5: LongInt; {Value of A5 when AppGrowZoneProc is called}  BEGIN    (* Remember the current value of A5 *)    theA5 := SetCurrentA5;    (* Free emergency memory if possible *)    IF (gEmergMem^ &lt;&gt; NIL) &amp; (gEmergMem &lt;&gt; GZSaveHnd) &amp; (cbNeeded &lt;=        kEmergMemSize) THEN      BEGIN        EmptyHandle (gEmergMem);        AppGrowZoneProc := kEmergMemSize      END    ELSE      AppGrowZoneProc := 0;    (* Restore A5 *)    theA5 := SetA5 (theA5)  END;{$S Main}(******************************************************************************** Public: ConnectAppGZ** It's pretty self-explanatory.*******************************************************************************)  VAR    gAppGrowZoneUPP: GrowZoneUPP;      PROCEDURE ConnectAppGZ;  BEGIN    SetGrowZone (gAppGrowZoneUPP);  END;{$S Main}(******************************************************************************** Public: DisconnectAppGZ** It's pretty self-explanatory.*******************************************************************************)  PROCEDURE DisconnectAppGZ;  BEGIN    SetGrowZone (NIL)  END;{$S Startup}(******************************************************************************** Public: InitEmergMem** It's pretty self-explanatory.*******************************************************************************)  PROCEDURE InitEmergMem;  BEGIN    gAppGrowZoneUPP := NewGrowZoneProc(@AppGrowZoneProc);    gEmergMem := NewHandle (kEmergMemSize);    ConnectAppGZ  END;{$S Main}(******************************************************************************** Public: NoEmergMem** We check on the handle and the master pointer of gEmergMem to see if the* emergency memory block has been emptied by AppGrowZoneProc, or was never allocated* in the first place.*******************************************************************************)  FUNCTION NoEmergMem: Boolean;  BEGIN    (* Empty handle means no emergency memory *)    NoEmergMem := (gEmergMem = NIL) | (gEmergMem^ = NIL)  END;{$S Main}(******************************************************************************** Public: RecoverEmergMem** Not much to describe.*******************************************************************************)  PROCEDURE RecoverEmergMem;  BEGIN    ReallocateHandle (gEmergMem, kEmergMemSize);  END;{$S Main}(******************************************************************************** Public: FailLowMemory** PurgeSpace is used to determine how much free memory there'd be in the heap if* all purgeable blocks were purged.  If this amount is less than the amount* needed, or if there isn't any emergency memory, TRUE is returned.*******************************************************************************)  FUNCTION FailLowMemory (memRequest: LongInt): Boolean;  VAR    total:  LongInt; {Total amount of free memory if heap was purged}    contig: LongInt; {Max amount of free contiguous memory if heap was purged}  BEGIN    PurgeSpace ((*&lt;*)total, (*&lt;*)contig);    FailLowMemory := (total &lt; (memRequest + kMemoryMargin)) | NoEmergMem  END;{$S Main}(******************************************************************************** Public: NewHandleMargin** I don't call SysError with an ID 25 if there isn't enough memory to satisfy* the request, so there isn't much reason to use the grow-zone proc.  So, I* disconnect the grow-zone proc temporarily just before I allocate the memory.*******************************************************************************)  FUNCTION NewHandleMargin (requestedSize: Size;                            appHeapAlloc:  Boolean;                            clearMem:      Boolean): Handle;  BEGIN    IF FailLowMemory (requestedSize) THEN      NewHandleMargin := NIL    ELSE      BEGIN        (* We handle memFullErr properly, so don't need grow-zone proc *)        DisconnectAppGZ;        (* Allocate the memory with the requested options *)        IF (NOT appHeapAlloc) AND clearMem THEN          NewHandleMargin := NewHandleSysClear (requestedSize)        ELSE IF (NOT appHeapAlloc) THEN          NewHandleMargin := NewHandleSys (requestedSize)        ELSE IF clearMem THEN          NewHandleMargin := NewHandleClear (requestedSize)        ELSE          NewHandleMargin := NewHandle (requestedSize);        (* Connect up the grow-zone proc again *)        ConnectAppGZ      END  END;{$S Main}(******************************************************************************** Public: NewPtrMargin** I don't call SysError with an ID 25 if there isn't enough memory to satisfy* the request, so there isn't much reason to use the grow-zone proc.  So, I* disconnect the grow-zone proc temporarily just before I allocate the memory.*******************************************************************************)  FUNCTION NewPtrMargin (requestedSize: Size;                         appHeapAlloc:  Boolean;                         clearMem:      Boolean): Ptr;  BEGIN    IF FailLowMemory (requestedSize) THEN      NewPtrMargin := NIL    ELSE      BEGIN        (* We handle memFullErr properly, so don't need grow-zone proc *)        DisconnectAppGZ;        (* Allocate the memory with the requested options *)        IF (NOT appHeapAlloc) AND clearMem THEN          NewPtrMargin := NewPtrSysClear (requestedSize)        ELSE IF NOT appHeapAlloc THEN          NewPtrMargin := NewPtrSys (requestedSize)        ELSE IF clearMem THEN          NewPtrMargin := NewPtrClear (requestedSize)        ELSE          NewPtrMargin := NewPtr (requestedSize);        (* Connect up the grow-zone proc again *)        ConnectAppGZ      END  END;END.</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/ProcDoggie/listing4.html%3Fid%3DDTS10000315-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/ProcDoggie/listing4.html%3Fid%3DDTS10000315-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/ProcDoggie/listing4.html%3Fid%3DDTS10000315-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>