<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"			"http://www.w3.org/TR/REC-html40/loose.dtd"><HTML><!-- Template 03-24-01 --><HEAD><LINK REL="stylesheet" HREF="../../adcstyle.css" TYPE="text/css"><LINK REL="stylesheet" HREF="../../style.css" TYPE="text/css"><title>Technical Note TN1077: Calling CFM Code From Classic 68K Code</title>     <meta name="keywords" content="Mac OS 8 Code Fragment Manager CFM calling classic 68k">    <meta name="Description" content="Technical Note TN1077: This Technical Note discusses callingCFM code from classic 68k Code and explains how to add librarysupport to classic code. Included is a discussion of routinedescriptors and code snippets illustrating the process ofcalling CFM code from classic 68k applications."><meta name="categories" content="Runtime Architecture"><meta name="week-posted" content="Oct 28, 1996 - Nov 1, 1996"><LINK REL="stylesheet" HREF="../../css/adcstyle.css" TYPE="text/css"><script language="JavaScript" type="text/javascript" src="../../js/adc.js"></script></HEAD><BODY BGCOLOR="#FFFFFF"><a name="//apple_ref/doc/uid/DTS10002918" title="Calling CFM Code From Classic 68K Code"></a><A NAME="top"></A><!-- begin_header_information --><!--#include virtual="/adcnavbar" --><p><a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../technicalnotes/index.html">Technical Notes</a> &gt; <a href="../../technicalnotes/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../technicalnotes/LegacyTechnologies/idxCarbon-date.html">Carbon</a> &gt; </p><div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/Carbon/idxRuntimeArchitecture-date.html" target="_blank">Carbon > Runtime Architecture</a></li>
	</ul>
</div>




</div></div></div><!-- end_header_information --><!-- bottom_of_header_marker_comment --><!-- top_of_titles_marker_comment --><CENTER><table width="600" cellpadding="0" cellspacing="0" border="0">
<tr><td align="left" scope="row">
<h1>
<div id="pagehead">Technical Note TN1077</div>
<div id="pageheadsub">Calling CFM Code From Classic 68K Code</div>
</h1>
</td></tr></table></CENTER><!-- bottom_of_titles_marker_comment --><CENTER><TABLE BORDER=0 CELLSPACING=1 WIDTH=600><TR><td align="left"> <!-- begin_header_box --> <table width="600" cellpadding="0" cellspacing="0" border="0">	<tr>		<td width=300 valign="top" align=left scope="row">			<table border="0" width="300" cellpadding="0" cellspacing="0">			<tr>                        <td width=300 align=left> <img src="images/tnmenutop.gif" alt="" align="bottom" width=300 height=7></td>				</tr>				<tr bgcolor="#e6e6e6">					<td background="images/tnmenubody.gif" width=300 align=left>						<span id="menutitle">							CONTENTS                             <br>                            <br>						</span>					</td>				</tr>				<tr bgcolor="#e6e6e6">					<td background="images/tnmenubody.gif" width=300 align=left><!-- begin_toc --><p id="menutext"><A HREF = "#C1">Calling CFM From Classic Code</a><BR><BR><A HREF = "#C2">Shortcuts, Detours &amp; Dead-Ends</a><BR><BR><A HREF = "#C3">About Mixed Mode and Routine Descriptors</a><BR><BR><A HREF = "#Summary">Summary</a><BR><BR><A HREF = "#References">References</a><BR><BR><A HREF="#Downloads">Downloadables</A></p>                  <!-- end_toc --> 								</td>				</tr>				<tr>					<td width=300 align=left scope="row">						<img src="images/tnmenubottom.gif" alt="" width=300 height=16>					</td>				</tr>			</table>		</td>		<td width=300 valign="top" align=left>			<!-- begin_intro_text -->            <P id = "introtext">There are specific instances when you must call Code Fragment Manager (CFM) code from classic 68K code -- for example, if your application cannot be converted to CFM, but you want to be able to use CFM libraries. Or, you want to add plug-in support to an existing classic 68K application without having to convert it to CFM68K.</p><P id = "introtext">In addition, you may want to use CFM68K to develop an application to run on both 68K and PowerPC computers and use a single FAT library for both environments. Another instance would be developing for OpenDoc, which requires shared library support. Prior to this Technote, only CFM applications could take advantage of OpenDoc. This Technote explains how to add library support to classic code.</P><!-- end_intro_text --><!-- begin_date --><h3>&nbsp;Updated: [Nov 14 1996]</h3><!-- end_date -->                </TD>             </TR>          </TABLE>          <!-- end_header_box --> <BR><BR><hr width=500 align=center>          <BR><BR> <!-- begin_content --><a name="C1"></a><H2>Calling CFM From Classic Code</h2><P>The basic steps for calling CFM from classic code are as follows: </p><OL TYPE="1" START="1">    <LI>Determine the address of the CFM routines you want to call.</li>    <LI>Create a routine descriptor for the CFM routine.</li>    <LI>Call the routine descriptor.</li>    <LI>Clean-up after yourself.</li></OL><H3>Determining the Address of the CFM Routines</h3><P>The most common way to determine the address of a CFM routine is to use <code>FindSymbol</code> against a shared library.</P>  <CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>  OSErr FindSymbol (ConnectionID connID, Str255 symName,   Ptr* symAddr, SymClass *symClass);</pre>	</TD></TR></TABLE></CENTER><P>The first parameter is a connection ID to a fragment. This can be obtained from a call to <code>GetSharedLibrary</code>, <code>GetDiskFragment</code> or <code>GetMemoryFragment</code>. The second parameter is the name of the symbol, in this case the name of the routine we want to call. The address of the symbol is returned in the third parameter and the last parameter returns the symbols class.</p><H3>Creating a Routine Descriptor</h3><P>In CFM code, you normally use the <code>NewRoutineDescriptor</code> routine to create routine descriptors. The non-CFM version of this is the <code>NewRoutineDescriptorTrap()</code> routine. See the notes on using <code>New[Fat]RoutineDescriptor[Trap]</code> at the end of this Technote.</P><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>pascal UniversalProcPtr NewRoutineDescriptorTrap(  ProcPtr theProc,  ProcInfoType theProcInfo,  ISAType theISA);</pre>	</TD></TR></TABLE></CENTER><P>To create a routine descriptor, you need the address, the procedure information and the architecture of the routine being described. The address was obtained in the first step. The procedure information is based on the calling conventions for the parameters passed to and returned from the routine. The last parameter is the architecture of the routine being called. In the headers, this is defined as the ISAType, which is a combination of two separate 4 bit values, the <B>Instruction Set Architecture</B> (ISA) and <B>Runtime Architecture</B> (RTA).</p><H3>Determining the Procedure Information</h3><P>The Mixed Mode Manager supports many calling conventions. The most common are stack based for Pascal and C, register based for operating system traps and register dispatched for selector based Toolbox traps. The easiest way to define the procedure information is via an enum: for example, if your routine was defined like this: </P><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>pascal Ptr Get_Message(short pResID, short pIndex);</pre>	</TD></TR></TABLE></CENTER><P>Its procedure information would then be defined like this: </P><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>enum {    kGet_MessageProcInfo = kPascalStackBased  | RESULT_SIZE(SIZE_CODE(sizeof(Ptr)))  | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(short)))  | STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(short)))};</pre>	</TD></TR></TABLE></CENTER><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>The RESULT_SIZE, SIZE_CODE &amp; STACK_ROUTINE_PARAMETER macros are defined in MixedMode.h. ProcInfo is documented in <a href="http://developer.apple.com/documentation/mac/PPCSoftware/PPCSoftware-17.html">Chapter Two, Inside Macintosh: PowerPC System Software.</A></P></TD></TR></TABLE></CENTER><BR><H3>Determining the Architecture</h3><P>Everyone seems to be tempted to use <code>GetCurrentArchitecture</code> here; JUST SAY NO! <code>GetCurrentArchitecture</code> is a macro that returns the architecture of the currently compiling code; in our case, classic. What we want is the architecture of the CFM code that we are calling from our classic code. Remember: the architecture includes the ISA and the RTA. The correct thing to do is to call Gestalt to find out what kind of CPU the code is running on (68K or PPC) and use this to create the routine descriptor with the correct architecture: </P><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>static pascal OSErr GetSystemArchitecture(OSType *archType){  // static so we only Gestalt once  static long sSysArchitecture = 0;  OSErr tOSErr = noErr;  // assume wild architecture  *archType = kAnyCFragArch;  // If we don't know the system architecture yet...  // Ask Gestalt what kind of machine we are running on.  if (sSysArchitecture == 0)   tOSErr = Gestalt(gestaltSysArchitecture,      &amp;sSysArchitecture);  if (tOSErr == noErr) // if no errors  {   if (sSysArchitecture == gestalt68k) // 68k?    *archType = kMotorola68KArch;   else if (sSysArchitecture == gestaltPowerPC) // PPC?    *archType = kPowerPCArch;   else    tOSErr = gestaltUnknownErr;    // who knows what might be next?  } return tOSErr;}</pre>	</TD></TR></TABLE></CENTER><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>Don't confuse the OSType architecture used to specify fragment architecture with the SInt8 ISA/RTA architecture used to specify routine descriptors. This routine determines the OSType architecture. I did it this way because I use it to open the connection to my shared library, which requires the OSType. When I create my routine descriptors, I use this value to conditionally execute the <CODE>NewRoutineDescriptorTrap</CODE> routine with the correct ISA/RTA type parameter: </P></TD></TR></TABLE></CENTER><BR><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre> static OSType sArchType = kAnyCFragArch; ISAType tISAType; if (sArchType == kAnyCFragArch) // if architecture is still undefined... {  // &amp; determine current atchitecture.  sOSErr = GetSystemArchitecture(&amp;sArchType);  if (sOSErr != noErr)   return sOSErr; } if (sArchType == kMotorola68KArch) // ...for CFM68K    tISAType = kM68kISA | kCFM68kRTA; else if (sArchType == kPowerPCArch)  // ...for PPC CFM    tISAType = kPowerPCISA | kPowerPCRTA; else  sOSErr = gestaltUnknownErr; // who knows what might be next?    if (sOSErr == noErr)  myUPP = NewRoutineDescriptorTrap((ProcPtr) * pSymAddr,    pProcInfo,tISAType); return sOSErr;</pre>	</TD></TR></TABLE></CENTER><H3>Calling the Routine Descriptor</h3><P>From CFM code you normally use CallUniversalProc to call the routine associated with a routine descriptor. (A Universal Procedure Pointer (UPP) is a pointer to a routine descriptor.) However, <code>CallUniversalProc</code> is only implemented in shared libraries. For compatabality reasons, in classic code UPP's can be treated like <code>ProcPtr</code>'s, i.e., they are pointers to executable code. This is because the first two bytes of a routine descriptor is the 68K mixed mode magic <code>ATrap</code>. When we jump here from 68K code, the trap is executed and the Mixed Mode Manager takes over, setting up passed parameters in registers or on the stack, based on the <code>ProcInfo</code> in the routine descriptor: switching the architecture and then jumping to the CFM code. This is how you would call your routine: </P><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>// define a ProcPtr of our typetypedef pascal Ptr (*Get_Message_ProcPtr)(short pResID,  short pIndex);// call it.  myPtr = ((Get_Message_ProcPtr)myUPP)(128,3);  </pre>	</TD></TR></TABLE></CENTER><H3>Cleaning Up After Yourself</H3><P><code>DisposeRoutineDescriptorTrap</code> is used to release the memory allocated for routine descriptors by the <code>NewRoutineDescriptorTrap</code>. </p><P><A HREF="#top">Back to top</A></p><a name="C2"></A><H2>Shortcuts, Detours &amp; Dead-Ends</h2><P>You may be tempted to use the macro <code>BUILD_ROUTINE_DESCRIPTOR</code>, so that you can build your routine descriptors statically. Unfortunately, this macro expands to include the macro <code>GetCurrentArchitecture</code> whose problem was described in the section above. Another problem with this approach is that the <code>ProcPtr</code> passed to the macro is expected to be a constant at compile-time. One solution to both of these problems is to build your routine descriptors in your CFM library and export them. This way the <code>GetCurrentArchitecture</code> macro returns the correct architecture for the library and the <code>ProcPtr</code> is a compile-time constant. And since these routine descriptors are staticly allocated at compile time, you don't have to worry about disposing them: their memory is released when the library is unloaded. Unfortunately, this only works if you have source to the library you want to connect to.</P><P>Using <code>BUILD_ROUTINE_DESCRIPTOR</code> to dynamically initialize a routine descriptor is not a good idea. From the classic 68K perspective, the routine descriptor is code being assembled out of data. This can cause problems due to the split caches on 68040 CPUs and some 68K emulator optimizations on PowerPCs. You're trying to execute data but instead are executing old values from the instruction cache. Using <code>NewRoutineDescriptorTrap</code> insures that the instruction cache is flushed for the executable range of the routine descriptor - two bytes.</P><P>In order to make the connection between classic code and the CFM code as transparent as possible, I like to put all my CFM glue code in its own separate file and use the same API in it as defined for my library (usually by using the library's header file). Each entry point into the library has its own glue routine that declares a static UPP variable initialized to <code>kUnresolvedSymbolAddress</code>. By checking for this initial value, the routine knows when it needs to look up its address in the library and create a routine descriptor. Here's the glue code for the library: </P><H3>Source Code for CFM Library Glue</h3><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>#include &lt;CodeFragments.h&gt;#include "DemoLib.h"// Private function prototypesstatic OSErr Find_Symbol(Ptr* pSymAddr,       Str255 pSymName,       ProcInfoType pProcInfo);static pascal OSErr GetSystemArchitecture(OSType *archType);// Private functionsstatic pascal OSErr GetSystemArchitecture(OSType *archType){ static long sSysArchitecture = 0; // static so we only Gestalt once. OSErr tOSErr = noErr; *archType = kAnyCFragArch;   // assume wild architecture // If we don't know the system architecture yet... if (sSysArchitecture == 0)  // ...Ask Gestalt what kind of machine we are running on.  tOSErr = Gestalt(gestaltSysArchitecture, &amp;sSysArchitecture); if (tOSErr == noErr) // if no errors {  if (sSysArchitecture == gestalt68k)   // 68k?   *archType = kMotorola68KCFragArch;  else if (sSysArchitecture == gestaltPowerPC) // PPC?   *archType = kPowerPCCFragArch;  else   tOSErr = gestaltUnknownErr;  // who knows what might be next? } return tOSErr;}static OSErr Find_Symbol(Ptr* pSymAddr,       Str255 pSymName,       ProcInfoType pProcInfo){ static ConnectionID sCID = 0; static OSType sArchType = kAnyCFragArch; static OSErr sOSErr = noErr; Str255 errMessage; Ptr mainAddr; SymClass symClass;    ISAType    tISAType; if (sArchType == kAnyCFragArch)  // if architecture is undefined... {  sCID = 0;     // ...force (re)connect to library  sOSErr = GetSystemArchitecture(&amp;sArchType); // determine architecture  if (sOSErr != noErr)   return sOSErr; // OOPS! } if (sArchType == kMotorola68KArch) // ...for CFM68K    tISAType = kM68kISA | kCFM68kRTA; else if (sArchType == kPowerPCArch)  // ...for PPC CFM    tISAType = kPowerPCISA | kPowerPCRTA; else  sOSErr = gestaltUnknownErr; // who knows what might be next? if (sCID == 0) // If we haven't connected to the library yet... {  // NOTE: The library name is hard coded here.  // I try to isolate the glue code, one file per library.  // I have had developers pass in the Library name to allow  // plug-in type support. Additional code has to be added to  // each entry points glue routine to support multiple or  // switching connection IDs.  sOSErr = GetSharedLibrary("\pDemoLibrary", sArchType, kLoadCFrag,     &amp;sCID, &amp;mainAddr, errMessage);  if (sOSErr != noErr)   return sOSErr; // OOPS! } // If we haven't looked up this symbol yet... if ((Ptr) *pSymAddr == (Ptr) kUnresolvedCFragSymbolAddress) {  // ...look it up now  sOSErr = FindSymbol(sCID,pSymName,pSymAddr,&amp;symClass);  if (sOSErr != noErr) // in case of error...   // ...clear the procedure pointer   *(Ptr*) &amp;pSymAddr = (Ptr) kUnresolvedSymbolAddress;#if !GENERATINGCFM // if this is classic 68k code...   *pSymAddr = (Ptr)NewRoutineDescriptorTrap((ProcPtr) *pSymAddr,        pProcInfo, tISAType);  // ...create a routine descriptor...#endif } return sOSErr;}/* Public functions &amp;amp; globals */pascal void Do_Demo(void){ static Do_DemoProcPtr sDo_DemoProcPtr = kUnresolvedSymbolAddress; // if this symbol has not been setup yet... if ((Ptr) sDo_DemoProcPtr == (Ptr) kUnresolvedSymbolAddress)  Find_Symbol((Ptr*) &amp;sDo_DemoProcPtr,"\pDo_Demo",kDo_DemoProcInfo); if ((Ptr) sDo_DemoProcPtr != (Ptr) kUnresolvedSymbolAddress)  sDo_DemoProcPtr();}pascal void Set_DemoValue(long pLong){ static Set_DemoValueProcPtr sSet_DemoValueProcPtr =  kUnresolvedSymbolAddress; // if this symbol has not been setup yet... if ((Ptr) sSet_DemoValueProcPtr == (Ptr) kUnresolvedSymbolAddress)  Find_Symbol((Ptr*) &amp;sSet_DemoValueProcPtr,   "\pSet_DemoValue", kSet_DemoValueProcInfo); if ((Ptr) sSet_DemoValueProcPtr != (Ptr) kUnresolvedSymbolAddress)  sSet_DemoValueProcPtr(pLong);}pascal long Get_DemoValue(void){ static Get_DemoValueProcPtr sGet_DemoValueProcPtr =  kUnresolvedSymbolAddress; // if this symbol has not been setup yet... if ((Ptr) sGet_DemoValueProcPtr == (Ptr) kUnresolvedSymbolAddress)  Find_Symbol((Ptr*) &amp;sGet_DemoValueProcPtr,   "\pGet_DemoValue",kGet_DemoValueProcInfo); if ((Ptr) sGet_DemoValueProcPtr != (Ptr) kUnresolvedSymbolAddress)  return sGet_DemoValueProcPtr(); else  return 0L;}pascal Ptr Get_DemoString(void){ static Get_DemoStringProcPtr sGet_DemoStringProcPtr =  kUnresolvedSymbolAddress; // if this symbol has not been setup yet... if ((Ptr) sGet_DemoStringProcPtr == (Ptr) kUnresolvedSymbolAddress)  Find_Symbol((Ptr*) &amp;sGet_DemoStringProcPtr,   "\pGet_DemoString",kGet_DemoStringProcInfo); if ((Ptr) sGet_DemoStringProcPtr != (Ptr) kUnresolvedSymbolAddress)  return sGet_DemoStringProcPtr(); else  return 0L;}</pre>	</TD></TR></TABLE></CENTER><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>The above routines will silently do nothing if their <code>Find_Symbol</code> call fails. Routines that do this sort of load/resolve on the fly should always have a means to bail out in case there are any errors. For example, return <code>OSErr</code>, use some kind of exception mechanism, etc. At the least, have <code>Find_Symbol</code> put up a fatal alert. This is left as an exercise for the programmer.</P></TD></TR></TABLE></CENTER><BR><H3>Notes on Using the New[Fat]RoutineDescriptor[Trap]</h3><P>When calling <code>NewRoutineDescriptor</code> from classic 68K code, there are two possible intentions. The first is source compatibility with code ported to CFM (either Power PC or 68K CFM). When the code is compiled for CFM, the functions create routine descriptors that can be used by the mixed mode manager operating on that machine. When the code is compiled for classic 68K, these functions do nothing so that the code will run on Macintoshes that do not have a Mixed mode manager. The dual nature of these functions is achieved by turning the CFM calls into "no-op" macros for classic 68K: You can put "NewRoutineDescriptor" in your source, compile it for any architecture, and it will run correctly on the intended platform. All without source changes and/or conditional source.</P><P>The other intention is for code that "knows" that it is executing as classic 68K and is specifically trying to call code of another architecture using mixed mode. Since the routines were designed with classic &lt;-&gt; CFM source compatibility in mind, this second case is treated specially. For classic 68k code to create routines descriptors for use by mixed mode, it must call the "Trap" versions of the routines (<code>NewRoutineDescriptorTrap</code>). These versions are only available to classic 68K callers: rigging the interfaces to allow calling them from CFM code will result in runtime failure because no shared library implements or exports these functions.</P><P>This almost appears seamless until you consider "fat" routine descriptors and the advent of CFM-68K. What does "fat" mean? CFM-68K is not emulated on Power PC and Power PC is not emulated on CFM-68K. It makes no sense to create a routine descriptor having both a CFM-68K routine and a Power PC native routine pointer. Therefore "fat" is defined to be a mix of classic and CFM for the hardware's native instruction set: on Power PC fat is classic and Power PC native, on a 68k machine with CFM-68K installed fat is classic and CFM-68K.By definition fat routine descriptors are only constructed by code that is aware of the architecture it is executing as and that another architecture exists. Source compatibility between code intended as pure classic and pure CFM is not an issue and so <code>NewFatRoutineDescriptor</code> is not available when building pure classic code. <code>NewFatRoutineDescriptorTrap</code> is available to classic code on both Power PC and CFM-68K. The classic code can use the code fragment manager routine "FindSymbol" to obtain the address of a routine in a shared library and then construct a routine descriptor with both the CFM routine and classic routine.</p><P><A HREF="#top">Back to top</A></p><a name="C3"></a><H2>About Mixed Mode and Routine Descriptors</h2><P>In the beginning (1984), there was the classic Macintosh programming model, based on the Motorola 680x0 processor and code segments. Then in 1991, the PowerPC processor was introduced. There was concern about compatibility with existing 68K applications (including the Finder), and the first step in addressing this concern was writing a 68LC040 emulator which allowed 68K code to run unmodified in the new environment. As part of this effort, a method had to be devised to switch between the native PPC and the emulated 68K modes - thus, the Mixed Mode Manager was born.</P><P>The Mixed Mode Manager is system software that manages mode switches between code in different instruction set architectures (ISA's). An ISA is the set of instructions recognized by a particular processor or family of processors. You indicate the ISA of a particular routine by creating a routine descriptor for that routine.</P><p>Click <A HREF = "#Downloads">here</A> to find a downloadable binhexed library of routine descriptors at the end of this Technote.</p><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>For more information about the Mixed Mode Manager, read its chapter in <a href="http://developer.apple.com/documentation/mac/PPCSoftware/PPCSoftware-17.html">Inside Macintosh: PowerPC System Software.</A> The documentation also applies to CFM68K - just consider "native" code to be either PowerPC or CFM68K. </P></TD></TR></TABLE></CENTER><BR><H3>Code Fragment Manager</h3><P>CFM was developed initially for PowerPC-based Macintosh computers to prepare code fragments for execution. A fragment is a block of executable code and its associated data. On PowerPC-based Macintosh computers, native programs, applications, libraries, and standalone code are packaged as fragments.</P><P>In 1994, CFM was ported back to 68K. The Mixed Mode Manager was again used to handle transitions between classic 68K and the CFM conventions for the CPU it is running on, i.e., on PowerPC it can handle classic to PowerPC transitions, and on 68K it can handle classic to CFM68K transitions. Classic 68K code is generally ignorant of mode switches while CFM code must be aware of them. Classic 68K code can treat a routine descriptor pointer as a classic 68K proc pointer, but CFM code cannot treat a routine descriptor as a proc pointer.  </P><P><A HREF="#top">Back to top</A></p><a name="Summary"></a><H2>Summary</h2><P>Calling CFM from classic code may be necessary for a number of reasons, particularly if you want to take advantage of both the classic and CFM libraries. It may also be the simplest and easiest method of adding plug-in support to an existing 68K or FAT application without having to port the 68K code to CFM68K.</P><P>This Technote discusses some straightforward methods you can use to call CFM code from classic code. There are problems, however, that you ought to consider when trying to build routine descriptors for C routines in a shared library.</P><P><A HREF="#top">Back to top</A></p><a name="References"></a><h2>References</h2><p><a href="http://developer.apple.com/documentation/mac/PPCSoftware/PPCSoftware-2.html">   Inside Macintosh: PowerPC System Software.</A></p><p><A HREF = "tn1084.html"> TECHNOTE 1084: Running CFM-68K Code at Interrupt Time: Is Your Code at Risk?</A></p><p><A HREF = "http://www.triplesoft.com/fragment/"><CITE>Fragments of Your Imagination</CITE></A> by Joe Zobkiw, Addison-Wesley, ISBN 0-201-48358-0</p><P><A HREF="#top">Back to top</A></p> <A NAME=Downloads></A>                  <H2>Downloadables</H2>                  <TABLE BORDER=0 CELLPADDING=3 WIDTH="500">            <TR>               <td width=50 align=left>                  <P ALIGN=center><img src="images/acrobatsmall.gif" width=22 height=23 align=middle alt="Acrobat"></P>               </TD>               <td align="left">                  <P>Acrobat version of this Note (60K).</P>               </TD>               <td width=60 align=left>                  <P><A HREF="pdf/tn1077.pdf">Download</A></P>               </TD>            </TR>            <TR>               <td width=50 align=left>                  <P ALIGN=center><img src="images/bluebook.gif" width=22 height=23 align=bottom alt="Bluebook gif"></P>               </TD>               <td align="left">                  <P>Binhexed Metrowerks Project File (116K)</P>               </TD>               <td width=60 align=left>                  <P><A HREF="downloads/tn_1077.1.hqx">Download</A></P>               </TD>            </TR>             <TR>               <td width=50 align=left>                  <P ALIGN=center><img src="images/bluebook.gif" width=22 height=23 align=bottom alt="Bluebook gif"></P>               </TD>               <td align="left">                  <P>Binhexed Routine Descriptor Lib (68K)</P>               </TD>               <td width=60 align=left>                  <P><A HREF="downloads/tn_1077.2.hqx">Download</A></P>               </TD>            </TR></TABLE><P><A HREF="#top">Back to top</A></P></TD></TR></table></center><!-- begin_footer_information -->	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/technotes/tn/tn1077.html%3Fid%3DDTS10002918-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/technotes/tn/tn1077.html%3Fid%3DDTS10002918-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/technotes/tn/tn1077.html%3Fid%3DDTS10002918-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>
<!--#include virtual="/includes/footer"--><!-- end_footer_information --></BODY></HTML>