<html><head><title>Mac OS X
 Manual Page For MPI_Gather(3)</title>
<style type="text/css"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { font-size: 1px; background: #ffffff; color: #ffffff; } --></style>
<style type="text/css" media="print, aural, braille, embossed, projection, tty"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { display: none; } --></style>
</head><body bgcolor="white">
<a name="//apple_ref/doc/man/3/MPI_Gather" title="Mac OS X
 Manual Page for MPI_Gather(3)"><!-- headerDoc=man; indexgroup=Section 3; uid="//apple_ref/doc/man/3/MPI_Gather"; name=MPI_Gather(3) --></a>
<!--#include virtual="/includes/framesetheader"-->
<table width=600><tr><td scope="row">
<!-- begin breadcrumb insert request --><font face="Geneva,Helvetica,Arial" size="1">
 <a target="_top" href="http://developer.apple.com">ADC Home</a> <b>&gt;</b> <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> <b>&gt;</b> <a href="../../../../../reference/index.html#//apple_ref/doc/uid/TP30001281" target="_top">Reference</a> <b>&gt;</b> <!-- a href="" target="_top" -->Mac OS X<!-- /a --> <b>&gt;</b> <a href="../index.html#//apple_ref/doc/framework/manpages" target="_top">Mac OS X Man Pages</a></font>
<!-- end breadcrumb insert request -->
<p>&nbsp;</p>
</td></tr></table>
<!-- end of header -->
<table border="0"  cellpadding="2" cellspacing="2" width="630pt"><tr><td valign="top" height="12" colspan="5" scope="row">
<p style='text-align:justify;'>This document is a Mac OS X manual page.  Manual pages are a command-line technology
for providing documentation.  You can view these manual pages locally using the
<a href="../man1/man.1.html#//apple_ref/doc/man/1/man">man(1)</a> command.
These manual pages come from many different sources, and thus, have a variety of writing
styles.</p>
<p style='text-align:justify;'>For more information about the manual page format, see the manual page for 
<a href="../man5/manpages.5.html#//apple_ref/doc/man/5/manpages">manpages(5)</a>.</p>
</td></tr></table>
<hr />
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row"><pre class="manpages"><tt>
MPI_Gather(3OpenMPI)                                                                    MPI_Gather(3OpenMPI)



<b>NAME</b>
       <b>MPI_Gather</b> - Gathers values from a group of processes.


<b>SYNOPSIS</b>
<b>C</b> <b>Syntax</b>
       #include &lt;mpi.h&gt;
       int MPI_Gather(void <u>*sendbuf</u>, int <u>sendcount</u>, MPI_Datatype <u>sendtype</u>,
            void <u>*recvbuf</u>, int <u>recvcount</u>, MPI_Datatype <u>recvtype</u>, int <u>root</u>,
            MPI_Comm <u>comm</u>)


<b>Fortran</b> <b>Syntax</b>
       INCLUDE 'mpif.h'
       MPI_GATHER(<u>SENDBUF,</u> <u>SENDCOUNT,</u> <u>SENDTYPE,</u> <u>RECVBUF,</u> <u>RECVCOUNT,</u>
                 <u>RECVTYPE,</u> <u>ROOT,</u> <u>COMM,</u> <u>IERROR</u>)
            &lt;type&gt;    <u>SENDBUF(*),</u> <u>RECVBUF(*)</u>
            INTEGER   <u>SENDCOUNT,</u> <u>SENDTYPE,</u> <u>RECVCOUNT,</u> <u>RECVTYPE,</u> <u>ROOT</u>
            INTEGER   <u>COMM,</u> <u>IERROR</u>


<b>C++</b> <b>Syntax</b>
       #include &lt;mpi.h&gt;
       void MPI::Comm::Gather(const void* <u>sendbuf</u>, int <u>sendcount</u>,
            const MPI::Datatype&amp; <u>sendtype</u>, void* <u>recvbuf</u>,
            int <u>recvcount</u>, const MPI::Datatype&amp; <u>recvtype</u>, int <u>root</u>,
            const = 0


<b>INPUT</b> <b>PARAMETERS</b>
       sendbuf   Starting address of send buffer (choice).

       sendcount Number of elements in send buffer (integer).

       sendtype  Datatype of send buffer elements (handle).

       recvcount Number of elements for any single receive (integer, significant only at root).

       recvtype  Datatype of recvbuffer elements (handle, significant only at root).

       root      Rank of receiving process (integer).

       comm      Communicator (handle).


<b>OUTPUT</b> <b>PARAMETERS</b>
       recvbuf   Address of receive buffer (choice, significant only at root).

       IERROR    Fortran only: Error status (integer).


<b>DESCRIPTION</b>
       Each  process  (root process included) sends the contents of its send buffer to the root process. The
       root process receives the messages and stores them in rank order. The outcome is as if each of the  n
       processes in the group (including the root process) had executed a call to

           MPI_Send(sendbuf, sendcount, sendtype, root, ...)

       and the root had executed n calls to

           MPI_Recv(recfbuf + i * recvcount * extent(recvtype),
                    recvcount, recvtype, i, ...)

       where extent(recvtype) is the type extent obtained from a call to MPI_Type_extent().

       An alternative description is that the n messages sent by the processes in the group are concatenated
       in rank order, and the resulting message is received by the root as if by a call to MPI_RECV(recvbuf,
       recvcount * n, recvtype, . . . ).

       The receive buffer is ignored for all nonroot processes.

       General,  derived  datatypes  are allowed for both sendtype and recvtype. The type signature of send-<font color="#ffffff" class="whiteout">count,&nbsp;sendcount,</font>
       count, sendtype on process i must be equal to the type signature of recvcount, recvtype at the  root.
       This  implies  that  the  amount  of data sent must be equal to the amount of data received, pairwise
       between each process and the root. Distinct type maps between sender and receiver are still  allowed.

       All  arguments  to the function are significant on process root, while on other processes, only argu-<font color="#ffffff" class="whiteout">ments&nbsp;arguments</font>
       ments sendbuf, sendcount, sendtype, root, comm are significant. The arguments root and comm must have
       identical values on all processes.

       The  specification  of  counts and types should not cause any location on the root to be written more
       than once. Such a call is erroneous.

       Note that the recvcount argument at the root indicates the number of  items  it  receives  from  each
       process, not the total number of items it receives.

       <b>Example</b> <b>1:</b>  Gather 100 ints from every process in group to root.

         MPI_Comm comm;
             int gsize,sendarray[100];
             int root, *rbuf;
             ...
             MPI_Comm_size( comm, &amp;gsize);
             rbuf = (int *)malloc(gsize*100*sizeof(int));
             MPI_Gather( sendarray, 100, MPI_INT, rbuf, 100, MPI_INT, root, comm);


       <b>Example</b> <b>2:</b> Previous example modified -- only the root allocates memory for the receive buffer.

         MPI_Comm comm;
             int gsize,sendarray[100];
             int root, myrank, *rbuf;
             ...
             MPI_Comm_rank( comm, myrank);
             if ( myrank == root) {
                MPI_Comm_size( comm, &amp;gsize);
                rbuf = (int *)malloc(gsize*100*sizeof(int));
                }
             MPI_Gather( sendarray, 100, MPI_INT, rbuf, 100, MPI_INT, root, comm);

       <b>Example</b> <b>3:</b> Do the same as the previous example, but use a derived datatype. Note that the type cannot
       be the entire set of  gsize * 100 ints since type matching is defined pairwise between the  root  and
       each process in the gather.

         MPI_Comm comm;
             int gsize,sendarray[100];
             int root, *rbuf;
             MPI_Datatype rtype;
             ...
             MPI_Comm_size( comm, &amp;gsize);
             MPI_Type_contiguous( 100, MPI_INT, &amp;rtype );
             MPI_Type_commit( &amp;rtype );
             rbuf = (int *)malloc(gsize*100*sizeof(int));
             MPI_Gather( sendarray, 100, MPI_INT, rbuf, 1, rtype, root, comm);


<b>USE</b> <b>OF</b> <b>IN-PLACE</b> <b>OPTION</b>
       When  the communicator is an intracommunicator, you can perform a gather operation in-place (the out-<font color="#ffffff" class="whiteout">put&nbsp;output</font>
       put buffer is used as the input buffer).  Use the variable MPI_IN_PLACE as  the  value  of  the  root
       process  <u>sendbuf</u>.  In this case, <u>sendcount</u> and <u>sendtype</u> are ignored, and the contribution of the root
       process to the gathered vector is assumed to already be in the correct place in the receive buffer.

       Note that MPI_IN_PLACE is a special kind of value; it  has  the  same  restrictions  on  its  use  as
       MPI_BOTTOM.

       Because  the  in-place  option  converts the receive buffer into a send-and-receive buffer, a Fortran
       binding that includes INTENT must mark these as INOUT, not OUT.


<b>WHEN</b> <b>COMMUNICATOR</b> <b>IS</b> <b>AN</b> <b>INTER-COMMUNICATOR</b>
       When the communicator is an inter-communicator, the root process in the first group gathers data from
       all  the processes in the second group.  The first group defines the root process.  That process uses
       MPI_ROOT as the value of its <u>root</u> argument.  The remaining processes use MPI_PROC_NULL as  the  value
       of  their  <u>root</u> argument.  All processes in the second group use the rank of that root process in the
       first group as the value of their <u>root</u> argument.   The send buffer argument of the processes  in  the
       first  group  must  be  consistent with the receive buffer argument of the root process in the second
       group.



<b>ERRORS</b>
       Almost all MPI routines return an error value; C routines as the value of the  function  and  Fortran
       routines  in  the  last argument. C++ functions do not return errors. If the default error handler is
       set to MPI::ERRORS_THROW_EXCEPTIONS, then on error the C++ exception mechanism will be used to  throw
       an MPI:Exception object.

       Before  the  error value is returned, the current MPI error handler is called. By default, this error
       handler aborts the MPI job, except for I/O function errors. The error handler  may  be  changed  with
       MPI_Comm_set_errhandler;  the  predefined  error handler MPI_ERRORS_RETURN may be used to cause error
       values to be returned. Note that MPI does not guarantee that an MPI  program  can  continue  past  an
       error.

       See the MPI man page for a full list of MPI error codes.


<b>SEE</b> <b>ALSO</b>
       MPI_Gatherv
       MPI_Scatter
       MPI_Scatterv




Open MPI 1.2                                   September 2006                           MPI_Gather(3OpenMPI)
</tt></pre>
</td></tr></table>
	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Darwin/Reference/ManPages/man3/MPI_Gather.3.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Darwin/Reference/ManPages/man3/MPI_Gather.3.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Darwin/Reference/ManPages/man3/MPI_Gather.3.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

</body></html>
