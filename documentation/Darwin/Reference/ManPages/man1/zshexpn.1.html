<html><head><title>Mac OS X
 Manual Page For zshexpn(1)</title>
<style type="text/css"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { font-size: 1px; background: #ffffff; color: #ffffff; } --></style>
<style type="text/css" media="print, aural, braille, embossed, projection, tty"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { display: none; } --></style>
</head><body bgcolor="white">
<a name="//apple_ref/doc/man/1/zshexpn" title="Mac OS X
 Manual Page for zshexpn(1)"><!-- headerDoc=man; indexgroup=Section 1; uid="//apple_ref/doc/man/1/zshexpn"; name=zshexpn(1) --></a>
<!--#include virtual="/includes/framesetheader"-->
<table width=600><tr><td scope="row">
<!-- begin breadcrumb insert request --><font face="Geneva,Helvetica,Arial" size="1">
 <a target="_top" href="http://developer.apple.com">ADC Home</a> <b>&gt;</b> <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> <b>&gt;</b> <a href="../../../../../reference/index.html#//apple_ref/doc/uid/TP30001281" target="_top">Reference</a> <b>&gt;</b> <!-- a href="" target="_top" -->Mac OS X<!-- /a --> <b>&gt;</b> <a href="../index.html#//apple_ref/doc/framework/manpages" target="_top">Mac OS X Man Pages</a></font>
<!-- end breadcrumb insert request -->
<p>&nbsp;</p>
</td></tr></table>
<!-- end of header -->
<table border="0"  cellpadding="2" cellspacing="2" width="630pt"><tr><td valign="top" height="12" colspan="5" scope="row">
<p style='text-align:justify;'>This document is a Mac OS X manual page.  Manual pages are a command-line technology
for providing documentation.  You can view these manual pages locally using the
<a href="man.1.html#//apple_ref/doc/man/1/man">man(1)</a> command.
These manual pages come from many different sources, and thus, have a variety of writing
styles.</p>
<p style='text-align:justify;'>For more information about the manual page format, see the manual page for 
<a href="../man5/manpages.5.html#//apple_ref/doc/man/5/manpages">manpages(5)</a>.</p>
</td></tr></table>
<hr />
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row"><pre class="manpages"><tt>
ZSHEXPN(1)                                                                                        ZSHEXPN(1)



<b>NAME</b>
       zshexpn - zsh expansion and substitution

<b>DESCRIPTION</b>
       The following types of expansions are performed in the indicated order in five steps:

       <u>History</u> <u>Expansion</u>
              This is performed only in interactive shells.

       <u>Alias</u> <u>Expansion</u>
              Aliases are expanded immediately before the command line is parsed as explained under Aliasing
              in <a href="zshmisc.1.html#//apple_ref/doc/man/1/zshmisc"><u>zshmisc</u>(1)</a>.

       <u>Process</u> <u>Substitution</u>
       <u>Parameter</u> <u>Expansion</u>
       <u>Command</u> <u>Substitution</u>
       <u>Arithmetic</u> <u>Expansion</u>
       <u>Brace</u> <u>Expansion</u>
              These five are performed in one step in left-to-right fashion.  After  these  expansions,  all
              unquoted occurrences of the characters `<b>\</b>', `<b>'</b>' and `<b>"</b>' are removed.

       <u>Filename</u> <u>Expansion</u>
              If  the  <b>SH_FILE_EXPANSION</b> option is set, the order of expansion is modified for compatibility
              with <b>sh</b> and <b>ksh</b>.  In that case <u>filename</u> <u>expansion</u> is performed immediately after <u>alias</u>  <u>expan</u>-<font color="#ffffff" class="whiteout">sion,&nbsp;expansion,</font>
              <u>sion</u>, preceding the set of five expansions mentioned above.

       <u>Filename</u> <u>Generation</u>
              This expansion, commonly referred to as <b>globbing</b>, is always done last.

       The following sections explain the types of expansion in detail.


<b>HISTORY</b> <b>EXPANSION</b>
       History  expansion  allows  you  to use words from previous command lines in the command line you are
       typing.  This simplifies spelling corrections and the repetition of  complicated  commands  or  argu-<font color="#ffffff" class="whiteout">ments.&nbsp;arguments.</font>
       ments.  Immediately before execution, each command is saved in the history list, the size of which is
       controlled by the <b>HISTSIZE</b> parameter.  The one most recent command is always retained  in  any  case.
       Each  saved command in the history list is called a history <u>event</u> and is assigned a number, beginning
       with 1 (one) when the shell starts up.  The history number that you  may  see  in  your  prompt  (see
       Prompt Expansion in <a href="zshmisc.1.html#//apple_ref/doc/man/1/zshmisc"><u>zshmisc</u>(1)</a>) is the number that is to be assigned to the <u>next</u> command.


   <b>Overview</b>
       A  history  expansion  begins  with  the  first character of the <b>histchars</b> parameter, which is `<b>!</b>' by
       default, and may occur anywhere on the command line; history expansions do not nest.  The `<b>!</b>' can  be
       escaped  with  `<b>\</b>'  or  can  be enclosed between a pair of single quotes (<b>''</b>) to suppress its special
       meaning.  Double quotes will <u>not</u> work for this.  Following this  history  character  is  an  optional
       event designator (see the section `Event Designators') and then an optional word designator (the sec-<font color="#ffffff" class="whiteout">tion&nbsp;section</font>
       tion `Word Designators'); if neither of these designators is present, no history expansion occurs.

       Input lines containing history expansions are echoed after  being  expanded,  but  before  any  other
       expansions  take place and before the command is executed.  It is this expanded form that is recorded
       as the history event for later references.

       By default, a history reference with no event designator refers to the same event  as  any  preceding
       history  reference  on that command line; if it is the only history reference in a command, it refers
       to the previous command.  However, if the option <b>CSH_JUNKIE_HISTORY</b> is set, then every history refer-<font color="#ffffff" class="whiteout">ence&nbsp;reference</font>
       ence with no event specification <u>always</u> refers to the previous command.

       For  example,  `<b>!</b>'  is  the event designator for the previous command, so `<b>!!:1</b>' always refers to the
       first word of the previous command, and `<b>!!$</b>' always refers to the last word of the previous command.
       With  <b>CSH_JUNKIE_HISTORY</b>  set,  then  `<b>!:1</b>' and `<b>!$</b>' function in the same manner as `<b>!!:1</b>' and `<b>!!$</b>',
       respectively.  Conversely, if <b>CSH_JUNKIE_HISTORY</b> is unset, then `<b>!:1</b>' and `<b>!$</b>' refer to the first and
       last words, respectively, of the same event referenced by the nearest other history reference preced-<font color="#ffffff" class="whiteout">ing&nbsp;preceding</font>
       ing them on the current command line, or to the previous command if there is no preceding  reference.

       The character sequence `<b>^</b><u>foo</u><b>^</b><u>bar</u>' (where `<b>^</b>' is actually the second character of the <b>histchars</b> param-<font color="#ffffff" class="whiteout">eter)&nbsp;parameter)</font>
       eter) repeats the last command, replacing the string <u>foo</u> with  <u>bar</u>.   More  precisely,  the  sequence
       `<b>^</b><u>foo</u><b>^</b><u>bar</u><b>^</b>'  is  synonymous with `<b>!!:s^</b><u>foo</u><b>^</b><u>bar</u><b>^</b>', hence other modifiers (see the section `Modifiers')
       may follow the final `<b>^</b>'.  In particular, `<b>^</b><u>foo</u><b>^</b><u>bar</u><b>:G</b>' performs a global substitution.

       If the shell encounters the character sequence `<b>!"</b>' in the input, the history mechanism is  temporar-<font color="#ffffff" class="whiteout">ily&nbsp;temporarily</font>
       ily  disabled  until the current list (see <a href="zshmisc.1.html#//apple_ref/doc/man/1/zshmisc"><u>zshmisc</u>(1)</a>) is fully parsed.  The `<b>!"</b>' is removed from the
       input, and any subsequent `<b>!</b>' characters have no special significance.

       A less convenient but more comprehensible form of command history  support  is  provided  by  the  <b>fc</b>
       builtin.

   <b>Event</b> <b>Designators</b>
       An  event  designator is a reference to a command-line entry in the history list.  In the list below,
       remember that the initial <b>`!'</b> in each item may  be  changed  to  another  character  by  setting  the
       <b>histchars</b> parameter.

       <b>!</b>      Start  a history expansion, except when followed by a blank, newline, `<b>=</b>' or `<b>(</b>'.  If followed
              immediately by a word designator (see the section `Word Designators'), this  forms  a  history
              reference with no event designator (see the section `Overview').

       <b>!!</b>     Refer to the previous command.  By itself, this expansion repeats the previous command.

       <b>!</b><u>n</u>     Refer to command-line <u>n</u>.

       <b>!-</b><u>n</u>    Refer to the current command-line minus <u>n</u>.

       <b>!</b><u>str</u>   Refer to the most recent command starting with <u>str</u>.

       <b>!?</b><u>str</u>[<b>?</b>]
              Refer to the most recent command containing <u>str</u>.  The trailing `<b>?</b>' is necessary if this refer-<font color="#ffffff" class="whiteout">ence&nbsp;reference</font>
              ence is to be followed by a modifier or followed by any text that is not to be considered part
              of <u>str</u>.

       <b>!#</b>     Refer to the current command line typed in so far.  The line is treated as if it were complete
              up to and including the word before the one with the `<b>!#</b>' reference.

       <b>!{</b>...<b>}</b> Insulate a history reference from adjacent characters (if necessary).

   <b>Word</b> <b>Designators</b>
       A word designator indicates which word or words of a given command line are to be included in a  his-<font color="#ffffff" class="whiteout">tory&nbsp;history</font>
       tory reference.  A `<b>:</b>' usually separates the event specification from the word designator.  It may be
       omitted only if the word designator begins with a `<b>^</b>',  `<b>$</b>',  `<b>*</b>',  `<b>-</b>'  or  `<b>%</b>'.   Word  designators
       include:

       <b>0</b>      The first input word (command).
       <u>n</u>      The <u>n</u>th argument.
       <b>^</b>      The first argument.  That is, <b>1</b>.
       <b>$</b>      The last argument.
       <b>%</b>      The word matched by (the most recent) <b>?</b><u>str</u> search.
       <u>x</u><b>-</b><u>y</u>    A range of words; <u>x</u> defaults to <b>0</b>.
       <b>*</b>      All the arguments, or a null value if there are none.
       <u>x</u><b>*</b>     Abbreviates `<u>x</u><b>-$</b>'.
       <u>x</u><b>-</b>     Like `<u>x</u><b>*</b>' but omitting word <b>$</b>.

       Note  that  a  `<b>%</b>' word designator works only when used in one of `<b>!%</b>', `<b>!:%</b>' or `<b>!?</b><u>str</u><b>?:%</b>', and only
       when used after a <b>!?</b> expansion (possibly in an earlier command).  Anything else results in an  error,
       although the error may not be the most obvious one.

   <b>Modifiers</b>
       After the optional word designator, you can add a sequence of one or more of the following modifiers,
       each preceded by a `<b>:</b>'.  These modifiers also work on the result of <u>filename</u> <u>generation</u> and <u>parameter</u>
       <u>expansion</u>, except where noted.

       <b>h</b>      Remove a trailing pathname component, leaving the head.  This works like `<b>dirname</b>'.

       <b>r</b>      Remove a filename extension of the form `<b>.</b><u>xxx</u>', leaving the root name.

       <b>e</b>      Remove all but the extension.

       <b>t</b>      Remove all leading pathname components, leaving the tail.  This works like `<b>basename</b>'.

       <b>p</b>      Print the new command but do not execute it.  Only works with history expansion.

       <b>q</b>      Quote the substituted words, escaping further substitutions.  Works with history expansion and
              parameter expansion, though for parameters it is only useful if the resulting text  is  to  be
              re-evaluated such as by <b>eval</b>.

       <b>Q</b>      Remove one level of quotes from the substituted words.

       <b>x</b>      Like <b>q</b>, but break into words at whitespace.  Does not work with parameter expansion.

       <b>l</b>      Convert the words to all lowercase.

       <b>u</b>      Convert the words to all uppercase.

       <b>s/</b><u>l</u><b>/</b><u>r</u>[<b>/</b>]
              Substitute  <u>r</u>  for  <u>l</u>  as described below.  The substitution is done only for the first string
              that matches <u>l</u>.  For arrays and for filename generation, this applies  to  each  word  of  the
              expanded text.  See below for further notes on substitutions.

              The  forms  `<b>gs/</b><u>l</u><b>/</b><u>r</u>'  and `<b>s/</b><u>l</u><b>/</b><u>r</u><b>/:G</b>' perform global substitution, i.e. substitute every occur-<font color="#ffffff" class="whiteout">rence&nbsp;occurrence</font>
              rence of <u>r</u> for <u>l</u>.  Note that the <b>g</b> or <b>:G</b> must appear in exactly the position shown.

       <b>&amp;</b>      Repeat the previous <b>s</b> substitution.  Like <b>s</b>, may be preceded immediately by a <b>g</b>.  In parameter
              expansion the <b>&amp;</b> must appear inside braces, and in filename generation it must be quoted with a
              backslash.

       The <b>s/l/r/</b> substitution works as follows.  By default the left-hand side  of  substitutions  are  not
       patterns,  but  character  strings.   Any  character can be used as the delimiter in place of `<b>/</b>'.  A
       backslash quotes the delimiter character.  The character `<b>&amp;</b>', in the right-hand-side <u>r</u>,  is  replaced
       by  the  text  from the left-hand-side <u>l</u>.  The `<b>&amp;</b>' can be quoted with a backslash.  A null <u>l</u> uses the
       previous string either from the previous <u>l</u> or from the contextual scan string <u>s</u> from `<b>!?</b><u>s</u>'.  You  can
       omit  the rightmost delimiter if a newline immediately follows <u>r</u>; the rightmost `<b>?</b>' in a context scan
       can similarly be omitted.  Note the same record of the last <u>l</u> and <u>r</u> is maintained across all forms of
       expansion.

       If  the option <b>HIST_SUBST_PATTERN</b> is set, <u>l</u> is treated as a pattern of the usual form desribed in the
       section FILENAME GENERATION below.  This can be used in all the places where modifiers are available;
       note, however, that in globbing qualifiers parameter substitution has already taken place, so parame-<font color="#ffffff" class="whiteout">ters&nbsp;parameters</font>
       ters in the replacement string should be quoted to ensure they are  replaced  at  the  correct  time.
       Note  also that complicated patterns used in globbing qualifiers may need the extended glob qualifier
       notation <b>(#q:s/</b><u>...</u><b>/</b><u>...</u><b>/)</b> in order for the shell to recognize the expression as a glob qualifer.  Fur-<font color="#ffffff" class="whiteout">ther,&nbsp;Further,</font>
       ther, note that bad patterns in the substitution are not subject to the <b>NO_BAD_PATTERN</b> option so will
       cause an error.

       When <b>HIST_SUBST_PATTERN</b> is set, <u>l</u> may start with a <b>#</b> to indicate that the pattern must match  at  the
       start of the string to be substituted, and a <b>%</b> may appear at the start or after an <b>#</b> to indicate that
       the pattern must match at the end of the string to be substituted.  The <b>%</b> or <b>#</b> may be quoted with two
       backslashes.

       For example, the following piece of filename generation code with the <b>EXTENDED_GLOB</b> option:

              <b>print</b> <b>*.c(#q:s/#%(#b)s(*).c/'S${match[1]}.C'/)</b>

       takes  the expansion of <b>*.c</b> and applies the glob qualifiers in the <b>(#q</b><u>...</u><b>)</b> expression, which consists
       of a substitution modifier anchored to the start and end of each word (<b>#%</b>).  This turns on backrefer-<font color="#ffffff" class="whiteout">ences&nbsp;backreferences</font>
       ences  (<b>(#b)</b>),  so  that  the  parenthesised  subexpression is available in the replacement string as
       <b>${match[1]}</b>.  The replacement string is quoted so that the parameter is not  substituted  before  the
       start of filename generation.

       The  following  <b>f</b>,  <b>F</b>,  <b>w</b> and <b>W</b> modifiers work only with parameter expansion and filename generation.
       They are listed here to provide a single point of reference for all modifiers.

       <b>f</b>      Repeats the immediately (without a colon) following modifier until the resulting word  doesn't
              change any more.

       <b>F:</b><u>expr</u><b>:</b>
              Like  <b>f</b>, but repeats only <u>n</u> times if the expression <u>expr</u> evaluates to <u>n</u>.  Any character can be
              used instead of the `<b>:</b>'; if `<b>(</b>', `<b>[</b>', or `<b>{</b>' is used as the  opening  delimiter,  the  closing
              delimiter should be '<b>)</b>', `<b>]</b>', or `<b>}</b>', respectively.

       <b>w</b>      Makes the immediately following modifier work on each word in the string.

       <b>W:</b><u>sep</u><b>:</b> Like  <b>w</b>  but words are considered to be the parts of the string that are separated by <u>sep</u>. Any
              character can be used instead of the `<b>:</b>';  opening  parentheses  are  handled  specially,  see
              above.

<b>PROCESS</b> <b>SUBSTITUTION</b>
       Each  command  argument of the form `<b>&lt;(</b><u>list</u><b>)</b>', `<b>&gt;(</b><u>list</u><b>)</b>' or `<b>=(</b><u>list</u><b>)</b>' is subject to process substitu-<font color="#ffffff" class="whiteout">tion.&nbsp;substitution.</font>
       tion.  In the case of the <b>&lt;</b> or <b>&gt;</b> forms, the shell runs process <u>list</u> asynchronously.   If  the  system
       supports  the <b>/dev/fd</b> mechanism, the command argument is the name of the device file corresponding to
       a file descriptor; otherwise, if the system supports named pipes (FIFOs), the command  argument  will
       be a named pipe.  If the form with <b>&gt;</b> is selected then writing on this special file will provide input
       for <u>list</u>.  If <b>&lt;</b> is used, then the file passed as an argument will be connected to the output  of  the
       <u>list</u> process.  For example,

              <b>paste</b> <b>&lt;(cut</b> <b>-f1</b> <u>file1</u><b>)</b> <b>&lt;(cut</b> <b>-f3</b> <u>file2</u><b>)</b> <b>|</b>
              <b>tee</b> <b>&gt;(</b><u>process1</u><b>)</b> <b>&gt;(</b><u>process2</u><b>)</b> <b>&gt;/dev/null</b>

       cuts  fields  1  and  3 from the files <u>file1</u> and <u>file2</u> respectively, pastes the results together, and
       sends it to the processes <u>process1</u> and <u>process2</u>.

       If <b>=(</b><u>...</u><b>)</b> is used instead of <b>&lt;(</b><u>...</u><b>)</b>, then the file passed as an argument will be the name of a tempo-
       rary  file  containing  the output of the <u>list</u> process.  This may be used instead of the <b>&lt;</b> form for a
       program that expects to lseek (see <a href="../man2/lseek.2.html#//apple_ref/doc/man/2/lseek"><u>lseek</u>(2)</a>) on the input file.

       There is an optimisation for substitutions of the form <b>=(&lt;&lt;&lt;</b><u>arg</u><b>)</b>, where <u>arg</u> is a single-word argument
       to the here-string redirection <b>&lt;&lt;&lt;</b>.  This form produces a file name containing the value of <u>arg</u> after
       any substitutions have been performed.  This is handled entirely within the current shell.   This  is
       effectively  the  reverse of the special form <b>$(&lt;</b><u>arg</u><b>)</b> which treats <u>arg</u> as a file name and replaces it
       with the file's contents.

       The <b>=</b> form is useful as both the <b>/dev/fd</b> and the named pipe implementation of <b>&lt;(</b><u>...</u><b>)</b> have  drawbacks.
       In  the  former  case, some programmes may automatically close the file descriptor in question before
       examining the file on the command line, particularly if this is necessary for security  reasons  such
       as when the programme is running setuid.  In the second case, if the programme does not actually open
       the file, the subshell attempting to read from or write to the pipe will (in  a  typical  implementa-
       tion,  different operating systems may have different behaviour) block for ever and have to be killed
       explicitly.  In both cases, the shell actually supplies the information using a pipe,  so  that  pro-<font color="#ffffff" class="whiteout">grammes&nbsp;programmes</font>
       grammes that expect to lseek (see <a href="../man2/lseek.2.html#//apple_ref/doc/man/2/lseek"><u>lseek</u>(2)</a>) on the file will not work.

       Also  note that the previous example can be more compactly and efficiently written (provided the <b>MUL</b>-<font color="#ffffff" class="whiteout">TIOS&nbsp;MULTIOS</font>
       <b>TIOS</b> option is set) as:

              <b>paste</b> <b>&lt;(cut</b> <b>-f1</b> <u>file1</u><b>)</b> <b>&lt;(cut</b> <b>-f3</b> <u>file2</u><b>)</b> <b>\</b>
              <b>&gt;</b> <b>&gt;(</b><u>process1</u><b>)</b> <b>&gt;</b> <b>&gt;(</b><u>process2</u><b>)</b>

       The shell uses pipes instead of FIFOs to implement the latter two process substitutions in the  above
       example.

       There  is  an  additional  problem with <b>&gt;(</b><u>process</u><b>)</b>; when this is attached to an external command, the
       parent shell does not wait for <u>process</u> to finish and hence an immediately  following  command  cannot
       rely  on  the results being complete.  The problem and solution are the same as described in the sec-<font color="#ffffff" class="whiteout">tion&nbsp;section</font>
       tion <u>MULTIOS</u> in <a href="zshmisc.1.html#//apple_ref/doc/man/1/zshmisc"><u>zshmisc</u>(1)</a>.  Hence in a simplified version of the example above:

              <b>paste</b> <b>&lt;(cut</b> <b>-f1</b> <u>file1</u><b>)</b> <b>&lt;(cut</b> <b>-f3</b> <u>file2</u><b>)</b> <b>&gt;</b> <b>&gt;(</b><u>process</u><b>)</b>

       (note that no <b>MULTIOS</b> are involved), <u>process</u> will be run asynchronously.  The workaround is:

              <b>{</b> <b>paste</b> <b>&lt;(cut</b> <b>-f1</b> <u>file1</u><b>)</b> <b>&lt;(cut</b> <b>-f3</b> <u>file2</u><b>)</b> <b>}</b> <b>&gt;</b> <b>&gt;(</b><u>process</u><b>)</b>

       The extra processes here are spawned from the parent shell which will wait for their completion.


<b>PARAMETER</b> <b>EXPANSION</b>
       The character `<b>$</b>' is used to introduce parameter expansions.  See <a href="zshparam.1.html#//apple_ref/doc/man/1/zshparam"><u>zshparam</u>(1)</a> for  a  description  of
       parameters,  including  arrays, associative arrays, and subscript notation to access individual array
       elements.

       Note in particular the fact that words of unquoted parameters are not automatically split  on  white-<font color="#ffffff" class="whiteout">space&nbsp;whitespace</font>
       space  unless  the option <b>SH_WORD_SPLIT</b> is set; see references to this option below for more details.
       This is an important difference from other shells.

       In the expansions discussed below that require a pattern, the form of the pattern is the same as that
       used for filename generation; see the section `Filename Generation'.  Note that these patterns, along
       with the replacement text of any substitutions, are themselves subject to parameter  expansion,  com-<font color="#ffffff" class="whiteout">mand&nbsp;command</font>
       mand substitution, and arithmetic expansion.  In addition to the following operations, the colon mod-<font color="#ffffff" class="whiteout">ifiers&nbsp;modifiers</font>
       ifiers described in the section `Modifiers' in the section `History Expansion' can be  applied:   for
       example, <b>${i:s/foo/bar/}</b> performs string substitution on the expansion of parameter <b>$i</b>.

       <b>${</b><u>name</u><b>}</b>
              The  value,  if  any,  of  the  parameter <u>name</u> is substituted.  The braces are required if the
              expansion is to be followed by a letter, digit, or underscore that is not to be interpreted as
              part  of <u>name</u>.  In addition, more complicated forms of substitution usually require the braces
              to be present; exceptions, which only apply if the option <b>KSH_ARRAYS</b> is not set, are a  single
              subscript  or any colon modifiers appearing after the name, or any of the characters `<b>^</b>', `<b>=</b>',
              `<b>~</b>', `<b>#</b>' or `<b>+</b>' appearing before the name, all of which work with or without braces.

              If <u>name</u> is an array parameter, and the <b>KSH_ARRAYS</b> option is not set, then the  value  of  each
              element of <u>name</u> is substituted, one element per word.  Otherwise, the expansion results in one
              word only; with <b>KSH_ARRAYS</b>, this is the first element of an array.  No field splitting is done
              on the result unless the <b>SH_WORD_SPLIT</b> option is set.  See also the flags <b>=</b> and <b>s:</b><u>string</u><b>:</b>.

       <b>${+</b><u>name</u><b>}</b>
              If <u>name</u> is the name of a set parameter `<b>1</b>' is substituted, otherwise `<b>0</b>' is substituted.

       <b>${</b><u>name</u><b>:-</b><u>word</u><b>}</b>
              If  <u>name</u>  is set and is non-null then substitute its value; otherwise substitute <u>word</u>. If <u>name</u>
              is missing, substitute <u>word</u>.  Note that you can use standard shell quoting in the  <u>word</u>  value
              to selectively override the splitting done by the <b>SH_WORD_SPLIT</b> option and the <b>=</b> flag, but not
              the <b>s:</b><u>string</u><b>:</b> flag.

       <b>${</b><u>name</u><b>:=</b><u>word</u><b>}</b>
       <b>${</b><u>name</u><b>::=</b><u>word</u><b>}</b>
              In the first form, if <u>name</u> is unset or is null then set it to <u>word</u>; in the second form, uncon-<font color="#ffffff" class="whiteout">ditionally&nbsp;unconditionally</font>
              ditionally set <u>name</u> to <u>word</u>.  In both forms, the value of the parameter is then substituted.

       <b>${</b><u>name</u><b>:?</b><u>word</u><b>}</b>
              If  <u>name</u> is set and is non-null then substitute its value; otherwise, print <u>word</u> and exit from
              the shell.  Interactive shells instead return to the prompt.  If <u>word</u> is omitted, then a stan-<font color="#ffffff" class="whiteout">dard&nbsp;standard</font>
              dard message is printed.

       <b>${</b><u>name</u><b>:+</b><u>word</u><b>}</b>
              If  <u>name</u> is set and is non-null then substitute <u>word</u>; otherwise substitute nothing.  Note that
              you can use standard shell quoting in the <u>word</u> value to  selectively  override  the  splitting
              done by the <b>SH_WORD_SPLIT</b> option and the <b>=</b> flag, but not the <b>s:</b><u>string</u><b>:</b> flag.

       If  the  colon  is  omitted from one of the above expressions containing a colon, then the shell only
       checks whether <u>name</u> is set, not whether its value is null.

       In the following expressions, when <u>name</u> is an array and the substitution is not  quoted,  or  if  the
       `<b>(@)</b>' flag or the <u>name</u><b>[@]</b> syntax is used, matching and replacement is performed on each array element
       separately.

       <b>${</b><u>name</u><b>#</b><u>pattern</u><b>}</b>
       <b>${</b><u>name</u><b>##</b><u>pattern</u><b>}</b>
              If the <u>pattern</u> matches the beginning of the value of <u>name</u>, then substitute the value  of  <u>name</u>
              with  the matched portion deleted; otherwise, just substitute the value of <u>name</u>.  In the first
              form, the smallest matching pattern is preferred; in the second  form,  the  largest  matching
              pattern is preferred.

       <b>${</b><u>name</u><b>%</b><u>pattern</u><b>}</b>
       <b>${</b><u>name</u><b>%%</b><u>pattern</u><b>}</b>
              If  the  <u>pattern</u>  matches the end of the value of <u>name</u>, then substitute the value of <u>name</u> with
              the matched portion deleted; otherwise, just substitute the value of <u>name</u>.  In the first form,
              the  smallest  matching pattern is preferred; in the second form, the largest matching pattern
              is preferred.

       <b>${</b><u>name</u><b>:#</b><u>pattern</u><b>}</b>
              If the <u>pattern</u> matches the value of <u>name</u>, then substitute the empty  string;  otherwise,  just
              substitute  the  value  of  <u>name</u>.  If <u>name</u> is an array the matching array elements are removed
              (use the `<b>(M)</b>' flag to remove the non-matched elements).

       <b>${</b><u>name</u><b>/</b><u>pattern</u><b>/</b><u>repl</u><b>}</b>
       <b>${</b><u>name</u><b>//</b><u>pattern</u><b>/</b><u>repl</u><b>}</b>
              Replace the longest possible match of <u>pattern</u> in the expansion of  parameter  <u>name</u>  by  string
              <u>repl</u>.   The  first  form  replaces just the first occurrence, the second form all occurrences.
              Both <u>pattern</u> and <u>repl</u> are subject to double-quoted  substitution,  so  that  expressions  like
              <b>${name/$opat/$npat}</b>  will  work,  but note the usual rule that pattern characters in <b>$opat</b> are
              not treated specially unless either the option <b>GLOB_SUBST</b> is set, or <b>$opat</b> is instead  substi-<font color="#ffffff" class="whiteout">tuted&nbsp;substituted</font>
              tuted as <b>${~opat}</b>.

              The  <u>pattern</u>  may  begin  with a `<b>#</b>', in which case the <u>pattern</u> must match at the start of the
              string, or `<b>%</b>', in which case it must match at the end of the string, or `<b>#%</b>'  in  which  case
              the  <u>pattern</u> must match the entire string.  The <u>repl</u> may be an empty string, in which case the
              final `<b>/</b>' may also be omitted.  To quote the final `<b>/</b>' in other cases it should be preceded by
              a  single  backslash;  this is not necessary if the `<b>/</b>' occurs inside a substituted parameter.
              Note also that the `<b>#</b>', `<b>%</b>' and `<b>#%</b> are not active if they occur inside a substituted  parame-<font color="#ffffff" class="whiteout">ter,&nbsp;parameter,</font>
              ter, even at the start.

              The  first  `<b>/</b>'  may  be  preceded  by  a `<b>:</b>', in which case the match will only succeed if it
              matches the entire word.  Note also the effect of the <b>I</b> and <b>S</b> parameter expansion flags below;
              however, the flags <b>M</b>, <b>R</b>, <b>B</b>, <b>E</b> and <b>N</b> are not useful.

              For example,

                     <b>foo="twinkle</b> <b>twinkle</b> <b>little</b> <b>star"</b> <b>sub="t*e"</b> <b>rep="spy"</b>
                     <b>print</b> <b>${foo//${~sub}/$rep}</b>
                     <b>print</b> <b>${(S)foo//${~sub}/$rep}</b>

              Here,  the  `<b>~</b>'  ensures  that  the  text  of <b>$sub</b> is treated as a pattern rather than a plain
              string.  In the first case, the longest match for <b>t*e</b> is substituted and the  result  is  `<b>spy</b>
              <b>star</b>',  while  in  the  second case, the shortest matches are taken and the result is `<b>spy</b> <b>spy</b>
              <b>lispy</b> <b>star</b>'.

       <b>${#</b><u>spec</u><b>}</b>
              If <u>spec</u> is one of the above substitutions, substitute the length in characters of  the  result
              instead  of  the result itself.  If <u>spec</u> is an array expression, substitute the number of ele-<font color="#ffffff" class="whiteout">ments&nbsp;elements</font>
              ments of the result.  Note that `<b>^</b>', `<b>=</b>', and `<b>~</b>', below, must appear to the left of `<b>#</b>'  when
              these forms are combined.

       <b>${^</b><u>spec</u><b>}</b>
              Turn  on the <b>RC_EXPAND_PARAM</b> option for the evaluation of <u>spec</u>; if the `<b>^</b>' is doubled, turn it
              off.  When this option is set, array expansions of the form <u>foo</u><b>${</b><u>xx</u><b>}</b><u>bar</u>, where  the  parameter
              <u>xx</u>  is  set  to <b>(</b><u>a</u> <u>b</u> <u>c</u><b>)</b>, are substituted with `<u>fooabar</u> <u>foobbar</u> <u>foocbar</u>' instead of the default
              `<u>fooa</u> <u>b</u> <u>cbar</u>'.

              Internally, each such expansion is converted into the equivalent  list  for  brace  expansion.
              E.g.,  <b>${^var}</b>  becomes  <b>{$var[1],$var[2],</b>...<b>}</b>,  and  is processed as described in the section
              `Brace Expansion' below.  If word splitting is also in effect the <b>$var[</b><u>N</u><b>]</b>  may  themselves  be
              split into different list elements.

       <b>${=</b><u>spec</u><b>}</b>
              Perform  word  splitting  using the rules for <b>SH_WORD_SPLIT</b> during the evaluation of <u>spec</u>, but
              regardless of whether the parameter appears in double quotes; if the `<b>=</b>' is doubled,  turn  it
              off.   This  forces  parameter expansions to be split into separate words before substitution,
              using <b>IFS</b> as a delimiter.  This is done by default in most other shells.

              Note that splitting is applied to <u>word</u> in the assignment forms of <u>spec</u> <u>before</u>  the  assignment
              to <u>name</u> is performed.  This affects the result of array assignments with the <b>A</b> flag.

       <b>${~</b><u>spec</u><b>}</b>
              Turn  on the <b>GLOB_SUBST</b> option for the evaluation of <u>spec</u>; if the `<b>~</b>' is doubled, turn it off.
              When this option is set, the string resulting from the expansion will be interpreted as a pat-<font color="#ffffff" class="whiteout">tern&nbsp;pattern</font>
              tern anywhere that is possible, such as in filename expansion and filename generation and pat-<font color="#ffffff" class="whiteout">tern-matching&nbsp;pattern-matching</font>
              tern-matching contexts like the right hand side of the `<b>=</b>' and `<b>!=</b>' operators in conditions.

              In nested substitutions, note that the effect of the <b>~</b> applies to the result  of  the  current
              level  of  substitution.  A surrounding pattern operation on the result may cancel it.  Hence,
              for example, if the parameter <b>foo</b> is set to <b>*</b>, <b>${~foo//\*/*.c}</b> is substituted by  the  pattern
              <b>*.c</b>,  which  may be expanded by filename generation, but <b>${${~foo}//\*/*.c}</b> substitutes to the
              string <b>*.c</b>, which will not be further expanded.

       If a <b>${</b>...<b>}</b> type parameter expression or a <b>$(</b>...<b>)</b> type command substitution is used in place of  <u>name</u>
       above,  it is expanded first and the result is used as if it were the value of <u>name</u>.  Thus it is pos-<font color="#ffffff" class="whiteout">sible&nbsp;possible</font>
       sible to perform nested operations:  <b>${${foo#head}%tail}</b> substitutes the  value  of  <b>$foo</b>  with  both
       `<b>head</b>'  and  `<b>tail</b>'  deleted.   The  form  with  <b>$(</b>...<b>)</b> is often useful in combination with the flags
       described next; see the examples below.  Each <u>name</u> or nested <b>${</b>...<b>}</b> in a parameter expansion may also
       be followed by a subscript expression as described in <u>Array</u> <u>Parameters</u> in <a href="zshparam.1.html#//apple_ref/doc/man/1/zshparam"><u>zshparam</u>(1)</a>.

       Note  that  double quotes may appear around nested expressions, in which case only the part inside is
       treated as quoted; for example, <b>${(f)"$(foo)"}</b> quotes the result of <b>$(foo)</b>, but the flag  `<b>(f)</b>'  (see
       below)  is  applied using the rules for unquoted expansions.  Note further that quotes are themselves
       nested in this context; for example, in <b>"${(@f)"$(foo)"}"</b>, there are two sets  of  quotes,  one  sur-<font color="#ffffff" class="whiteout">rounding&nbsp;surrounding</font>
       rounding the whole expression, the other (redundant) surrounding the <b>$(foo)</b> as before.


   <b>Parameter</b> <b>Expansion</b> <b>Flags</b>
       If  the  opening  brace is directly followed by an opening parenthesis, the string up to the matching
       closing parenthesis will be taken as a list of flags.  In cases where repeating a flag is meaningful,
       the  repetitions  need  not  be  consecutive; for example, `(<b>q%q%q</b>)' means the same thing as the more
       readable `(<b>%%qqq</b>)'.  The following flags are supported:

       <b>#</b>      Evaluate the resulting words as numeric expressions and output the characters corresponding to
              the  resulting  integer.   Note  that this form is entirely distinct from use of the <b>#</b> without
              parentheses.

              If the <b>MULTIBYTE</b> option is set and the number is greater than 127 (i.e. not an  ASCII  charac-<font color="#ffffff" class="whiteout">ter)&nbsp;character)</font>
              ter) it is treated as a Unicode character.

       <b>%</b>      Expand  all  <b>%</b>  escapes  in the resulting words in the same way as in prompts (see the section
              `Prompt Expansion'). If this flag is given twice, full prompt expansion is done on the result-<font color="#ffffff" class="whiteout">ing&nbsp;resulting</font>
              ing  words,  depending  on  the  setting  of  the <b>PROMPT_PERCENT</b>, <b>PROMPT_SUBST</b> and <b>PROMPT_BANG</b>
              options.

       <b>@</b>      In double quotes, array elements are put into separate words.  E.g., `<b>"${(@)foo}"</b>' is  equiva-<font color="#ffffff" class="whiteout">lent&nbsp;equivalent</font>
              lent  to  `<b>"${foo[@]}"</b>'  and `<b>"${(@)foo[1,2]}"</b>' is the same as `<b>"$foo[1]"</b> <b>"$foo[2]"</b>'.  This is
              distinct from <u>field</u> <u>splitting</u> by the the <b>f</b>, <b>s</b> or <b>z</b> flags,  which  still  applies  within  each
              array element.

       <b>A</b>      Create an array parameter with `<b>${</b>...<b>=</b>...<b>}</b>', `<b>${</b>...<b>:=</b>...<b>}</b>' or `<b>${</b>...<b>::=</b>...<b>}</b>'.  If this flag is
              repeated (as in `<b>AA</b>'), create an associative array parameter.  Assignment is made before sort-<font color="#ffffff" class="whiteout">ing&nbsp;sorting</font>
              ing  or  padding.  The <u>name</u> part may be a subscripted range for ordinary arrays; the <u>word</u> part
              <u>must</u> be converted to an array, for example  by  using  `<b>${(AA)=</b><u>name</u><b>=</b>...<b>}</b>'  to  activate  field
              splitting, when creating an associative array.

       <b>a</b>      Sort  in  array  index  order; when combined with `<b>O</b>' sort in reverse array index order.  Note
              that `<b>a</b>' is therefore equivalent to the default but `<b>Oa</b>' is useful for  obtaining  an  array's
              elements in reverse order.

       <b>c</b>      With  <b>${#</b><u>name</u><b>}</b>, count the total number of characters in an array, as if the elements were con-<font color="#ffffff" class="whiteout">catenated&nbsp;concatenated</font>
              catenated with spaces between them.

       <b>C</b>      Capitalize the resulting words.  `Words' in this case  refers  to  sequences  of  alphanumeric
              characters separated by non-alphanumerics, <u>not</u> to words that result from field splitting.

       <b>e</b>      Perform <u>parameter</u> <u>expansion</u>, <u>command</u> <u>substitution</u> and <u>arithmetic</u> <u>expansion</u> on the result. Such
              expansions can be nested but too deep recursion may have unpredictable effects.

       <b>f</b>      Split the result of the expansion to lines. This is a shorthand for `<b>ps:\n:</b>'.

       <b>F</b>      Join the words of arrays together using newline as a  separator.   This  is  a  shorthand  for
              `<b>pj:\n:</b>'.

       <b>i</b>      Sort case-insensitively.  May be combined with `<b>n</b>' or `<b>O</b>'.

       <b>k</b>      If  <u>name</u>  refers  to an associative array, substitute the <u>keys</u> (element names) rather than the
              values of the elements.  Used with subscripts (including ordinary arrays),  force  indices  or
              keys  to  be  substituted even if the subscript form refers to values.  However, this flag may
              not be combined with subscript ranges.

       <b>L</b>      Convert all letters in the result to lower case.

       <b>n</b>      Sort decimal numbers numerically; if the first differing characters of two  test  strings  are
              not digits, sorting is lexical.   Numbers with initial zeroes are sorted before those without.
              Hence the array `<b>foo1</b> <b>foo02</b> <b>foo2</b> <b>foo3</b> <b>foo20</b> <b>foo23</b>' is sorted into the order  shown.   Trailing
              non-digits  are  not  sorted;  the order of `<b>2foo</b>' and `<b>2bar</b>' is not defined.  May be combined
              with `<b>i</b>' or `<b>O</b>'.

       <b>o</b>      Sort the resulting words in ascending order; if this appears on its own the sorting is lexical
              and  case-sensitive  (unless  the  locale  renders it case-insensitive).  Sorting in ascending
              order is the default for other forms of sorting, so this is ignored if combined with `<b>a</b>',  `<b>i</b>'
              or `<b>n</b>'.

       <b>O</b>      Sort  the  resulting  words  in descending order; `<b>O</b>' without `<b>a</b>', `<b>i</b>' or `<b>n</b>' sorts in reverse
              lexical order.  May be combined with `<b>a</b>', `<b>i</b>' or `<b>n</b>' to reverse the order of sorting.

       <b>P</b>      This forces the value of the parameter <u>name</u> to be interpreted as  a  further  parameter  name,
              whose value will be used where appropriate. If used with a nested parameter or command substi-<font color="#ffffff" class="whiteout">tution,&nbsp;substitution,</font>
              tution, the result of that will be taken as a parameter name in the same way.  For example, if
              you  have  `<b>foo=bar</b>' and `<b>bar=baz</b>', the strings <b>${(P)foo}</b>, <b>${(P)${foo}}</b>, and <b>${(P)$(echo</b> <b>bar)}</b>
              will be expanded to `<b>baz</b>'.

       <b>q</b>      Quote the resulting words with backslashes. If this flag is given twice, the  resulting  words
              are  quoted  in  single  quotes and if it is given three times, the words are quoted in double
              quotes. If it is given four times, the words are quoted in single quotes preceded by a <b>$</b>.

       <b>Q</b>      Remove one level of quotes from the resulting words.

       <b>t</b>      Use a string describing the type of the parameter where the value of the parameter would  usu-<font color="#ffffff" class="whiteout">ally&nbsp;usually</font>
              ally appear. This string consists of keywords separated by hyphens (`<b>-</b>'). The first keyword in
              the string describes the main type, it can be one of `<b>scalar</b>', `<b>array</b>', `<b>integer</b>', `<b>float</b>'  or
              `<b>association</b>'. The other keywords describe the type in more detail:

              <b>local</b>  for local parameters

              <b>left</b>   for left justified parameters

              <b>right_blanks</b>
                     for right justified parameters with leading blanks

              <b>right_zeros</b>
                     for right justified parameters with leading zeros

              <b>lower</b>  for parameters whose value is converted to all lower case when it is expanded

              <b>upper</b>  for parameters whose value is converted to all upper case when it is expanded

              <b>readonly</b>
                     for readonly parameters

              <b>tag</b>    for tagged parameters

              <b>export</b> for exported parameters

              <b>unique</b> for arrays which keep only the first occurrence of duplicated values

              <b>hide</b>   for parameters with the `hide' flag

              <b>special</b>
                     for special parameters defined by the shell

       <b>u</b>      Expand only the first occurrence of each unique word.

       <b>U</b>      Convert all letters in the result to upper case.

       <b>v</b>      Used with <b>k</b>, substitute (as two consecutive words) both the key and the value of each associa-<font color="#ffffff" class="whiteout">tive&nbsp;associative</font>
              tive array element.  Used with subscripts, force values to be substituted  even  if  the  sub-<font color="#ffffff" class="whiteout">script&nbsp;subscript</font>
              script form refers to indices or keys.

       <b>V</b>      Make any special characters in the resulting words visible.

       <b>w</b>      With  <b>${#</b><u>name</u><b>}</b>,  count words in arrays or strings; the <b>s</b> flag may be used to set a word delim-<font color="#ffffff" class="whiteout">iter.&nbsp;delimiter.</font>
              iter.

       <b>W</b>      Similar to <b>w</b> with the difference  that  empty  words  between  repeated  delimiters  are  also
              counted.

       <b>X</b>      With  this  flag,  parsing  errors occurring with the <b>Q</b>, <b>e</b> and <b>#</b> flags or the pattern matching
              forms such as `<b>${</b><u>name</u><b>#</b><u>pattern</u><b>}</b>' are reported.  Without the flag, errors are silently  ignored.

       <b>z</b>      Split  the result of the expansion into words using shell parsing to find the words, i.e. tak-<font color="#ffffff" class="whiteout">ing&nbsp;taking</font>
              ing into account any quoting in the value.

              Note that this is done very late, as for the `<b>(s)</b>' flag. So to  access  single  words  in  the
              result,  one  has  to  use  nested expansions as in `<b>${${(z)foo}[2]}</b>'. Likewise, to remove the
              quotes in the resulting words one would do: `<b>${(Q)${(z)foo}}</b>'.

       <b>0</b>      Split the result of the expansion on null bytes.  This is a shorthand for `<b>ps:\0:</b>'.

       The following flags (except <b>p</b>) are followed by one or more arguments as shown.  Any character, or the
       matching  pairs `<b>(</b>...<b>)</b>', `<b>{</b>...<b>}</b>', `<b>[</b>...<b>]</b>', or `<b>&lt;</b>...<b>&gt;</b>', may be used in place of a colon as delimiters,
       but note that when a flag takes more than one argument, a matched pair of  delimiters  must  surround
       each argument.

       <b>p</b>      Recognize  the  same  escape  sequences as the <b>print</b> builtin in string arguments to any of the
              flags described below.

       <b>j:</b><u>string</u><b>:</b>
              Join the words of arrays together using <u>string</u> as a separator.  Note that this  occurs  before
              field splitting by the <b>s:</b><u>string</u><b>:</b> flag or the <b>SH_WORD_SPLIT</b> option.

       <b>l:</b><u>expr</u><b>::</b><u>string1</u><b>::</b><u>string2</u><b>:</b>
              Pad  the resulting words on the left.  Each word will be truncated if required and placed in a
              field <u>expr</u> characters wide.

              The arguments <b>:</b><u>string1</u><b>:</b> and <b>:</b><u>string2</u><b>:</b> are optional; neither, the first, or both may be  given.
              Note  that  the  same  pairs  of delimiters must be used for each of the three arguments.  The
              space to the left will be filled with <u>string1</u> (concatenated as often as needed) or  spaces  if
              <u>string1</u>  is  not  given.   If  both  <u>string1</u>  and  <u>string2</u> are given, <b>string2</b> is inserted once
              directly to the left of each word, truncated if necessary, before <u>string1</u> is used  to  produce
              any remaining padding.

              If  the <b>MULTIBYTE</b> option is in effect, the flag <b>m</b> may also be given, in which case widths will
              be used for the calculation of padding; otherwise individual multibyte characters are  treated
              as occupying one unit of width.

              IF  the <b>MULTIBYTE</b> option is not in effect, each byte in the string is treated as occupying one
              unit of width.

              Control characters are always assumed to be one unit wide; this allows  the  mechanism  to  be
              used for generating repetitions of control characters.

       <b>m</b>      Only  useful  together with <b>l</b> and <b>r</b> when the <b>MULTIBYTE</b> option is in effect.  Use the character
              width reported by the system in calculating the how much of  the  string  it  occupies.   Most
              printable  characters  have a width of one unit, however certain Asian character sets and cer-<font color="#ffffff" class="whiteout">tain&nbsp;certain</font>
              tain special effects use wider characters.

       <b>r:</b><u>expr</u><b>::</b><u>string1</u><b>::</b><u>string2</u><b>:</b>
              As <b>l</b>, but pad the words on the right and insert <u>string2</u> immediately to the right of the string
              to be padded.

              Left  and right padding may be used together.  In this case the strategy is to apply left pad-<font color="#ffffff" class="whiteout">ding&nbsp;padding</font>
              ding to the first half width of each of the resulting words, and right padding to  the  second
              half.  If the string to be padded has odd width the extra padding is applied on the left.

       <b>s:</b><u>string</u><b>:</b>
              Force  field  splitting at the separator <u>string</u>.  Note that a <u>string</u> of two or more characters
              means that all of them must match in sequence; this differs from the treatment of two or  more
              characters in the <b>IFS</b> parameter.  See also the <b>=</b> flag and the <b>SH_WORD_SPLIT</b> option.

       The  following  flags  are meaningful with the <b>${</b>...<b>#</b>...<b>}</b> or <b>${</b>...<b>%</b>...<b>}</b> forms.  The <b>S</b> and <b>I</b> flags may
       also be used with the <b>${</b>...<b>/</b>...<b>}</b> forms.

       <b>S</b>      Search substrings as well as beginnings or ends; with <b>#</b> start from the beginning  and  with  <b>%</b>
              start  from the end of the string.  With substitution via <b>${</b>...<b>/</b>...<b>}</b> or <b>${</b>...<b>//</b>...<b>}</b>, specifies
              non-greedy matching, i.e. that the shortest instead of the longest match should be replaced.

       <b>I:</b><u>expr</u><b>:</b>
              Search the <u>expr</u>th match (where <u>expr</u> evaluates to a number).  This only applies when  searching
              for  substrings,  either with the <b>S</b> flag, or with <b>${</b>...<b>/</b>...<b>}</b> (only the <u>expr</u>th match is substi-<font color="#ffffff" class="whiteout">tuted)&nbsp;substituted)</font>
              tuted) or <b>${</b>...<b>//</b>...<b>}</b> (all matches from the <u>expr</u>th on are substituted).   The  default  is  to
              take the first match.

              The  <u>expr</u>th  match is counted such that there is either one or zero matches from each starting
              position in the string, although for global substitution matches overlapping previous replace-<font color="#ffffff" class="whiteout">ments&nbsp;replacements</font>
              ments  are  ignored.  With the <b>${</b>...<b>%</b>...<b>}</b> and <b>${</b>...<b>%%</b>...<b>}</b> forms, the starting position for the
              match moves backwards from the end as the index increases, while with the other forms it moves
              forward from the start.

              Hence with the string
                     <b>which</b> <b>switch</b> <b>is</b> <b>the</b> <b>right</b> <b>switch</b> <b>for</b> <b>Ipswich?</b>
              substitutions  of  the  form <b>${</b>(<b>SI:</b><u>N</u><b>:</b>)<b>string#w*ch}</b> as <u>N</u> increases from 1 will match and remove
              `<b>which</b>', `<b>witch</b>', `<b>witch</b>' and `<b>wich</b>'; the form using `<b>##</b>' will match and remove `<b>which</b>  <b>switch</b>
              <b>is</b> <b>the</b> <b>right</b> <b>switch</b> <b>for</b> <b>Ipswich</b>', `<b>witch</b> <b>is</b> <b>the</b> <b>right</b> <b>switch</b> <b>for</b> <b>Ipswich</b>', `<b>witch</b> <b>for</b> <b>Ipswich</b>'
              and `<b>wich</b>'. The form using `<b>%</b>' will remove the same matches as for `<b>#</b>', but in reverse  order,
              and the form using `<b>%%</b>' will remove the same matches as for `<b>##</b>' in reverse order.

       <b>B</b>      Include the index of the beginning of the match in the result.

       <b>E</b>      Include the index of the end of the match in the result.

       <b>M</b>      Include the matched portion in the result.

       <b>N</b>      Include the length of the match in the result.

       <b>R</b>      Include the unmatched portion in the result (the <u>R</u>est).


   <b>Rules</b>
       Here is a summary of the rules for substitution; this assumes that braces are present around the sub-<font color="#ffffff" class="whiteout">stitution,&nbsp;substitution,</font>
       stitution, i.e. <b>${...}</b>.  Some particular examples are given below.  Note  that  the  Zsh  Development
       Group  accepts  <u>no</u> <u>responsibility</u> for any brain damage which may occur during the reading of the fol-<font color="#ffffff" class="whiteout">lowing&nbsp;following</font>
       lowing rules.

       <b>1.</b> <u>Nested</u> <u>Substitution</u>
              If multiple nested <b>${...}</b> forms are present, substitution is performed from  the  inside  out-<font color="#ffffff" class="whiteout">wards.&nbsp;outwards.</font>
              wards.  At each level, the substitution takes account of whether the current value is a scalar
              or an array, whether the whole substitution is in double quotes, and what flags  are  supplied
              to  the  current level of substitution, just as if the nested substitution were the outermost.
              The flags are not propagated up to  enclosing  substitutions;  the  nested  substitution  will
              return  either a scalar or an array as determined by the flags, possibly adjusted for quoting.
              All the following steps take place where applicable at all levels of substitution.  Note that,
              unless  the `<b>(P)</b>' flag is present, the flags and any subscripts apply directly to the value of
              the nested substitution; for example, the expansion <b>${${foo}}</b>  behaves  exactly  the  same  as
              <b>${foo}</b>.

              At  each  nested level of substitution, the substituted words undergo all forms of single-word
              substitution (i.e. not filename generation), including command substitution, arithmetic expan-<font color="#ffffff" class="whiteout">sion&nbsp;expansion</font>
              sion and filename expansion (i.e. leading <b>~</b> and <b>=</b>).  Thus, for example, <b>${${:-=cat}:h}</b> expands
              to the directory where the <b>cat</b> program resides.  (Explanation: the internal  substitution  has
              no parameter but a default value <b>=cat</b>, which is expanded by filename expansion to a full path;
              the outer substitution then applies the modifier <b>:h</b> and takes the directory part of the path.)

       <b>2.</b> <u>Parameter</u> <u>Subscripting</u>
              If  the  value is a raw parameter reference with a subscript, such as <b>${</b><u>var</u><b>[3]}</b>, the effect of
              subscripting is applied directly to the parameter.  Subscripts are evaluated  left  to  right;
              subsequent  subscripts  apply  to the scalar or array value yielded by the previous subscript.
              Thus if <b>var</b> is an array,  <b>${var[1][2]}</b>  is  the  second  character  of  the  first  word,  but
              <b>${var[2,4][2]}</b>  is  the  entire  third word (the second word of the range of words two through
              four of the original array).  Any number of subscripts may appear.

       <b>3.</b> <u>Parameter</u> <u>Name</u> <u>Replacement</u>
              The effect of any <b>(P)</b> flag, which treats the value so far as a parameter name and replaces  it
              with the corresponding value, is applied.

       <b>4.</b> <u>Double-Quoted</u> <u>Joining</u>
              If  the  value  after this process is an array, and the substitution appears in double quotes,
              and no <b>(@)</b> flag is present at the current level, the words of the value are  joined  with  the
              first  character  of  the  parameter  <b>$IFS</b>, by default a space, between each word (single word
              arrays are not modified).  If the <b>(j)</b> flag is present, that is used  for  joining  instead  of
              <b>$IFS</b>.

       <b>5.</b> <u>Nested</u> <u>Subscripting</u>
              Any remaining subscripts (i.e. of a nested substitution) are evaluated at this point, based on
              whether the value is an array or a scalar.  As with <b>2.</b>, multiple subscripts can appear.   Note
              that <b>${foo[2,4][2]}</b> is thus equivalent to <b>${${foo[2,4]}[2]}</b> and also to <b>"${${(@)foo[2,4]}[2]}"</b>
              (the nested substitution returns an array in both cases), but not to <b>"${${foo[2,4]}[2]}"</b>  (the
              nested substitution returns a scalar because of the quotes).

       <b>6.</b> <u>Modifiers</u>
              Any modifiers, as specified by a trailing `<b>#</b>', `<b>%</b>', `<b>/</b>' (possibly doubled) or by a set of mod-<font color="#ffffff" class="whiteout">ifiers&nbsp;modifiers</font>
              ifiers of the form <b>:...</b> (see the section `Modifiers' in the section `History Expansion'),  are
              applied to the words of the value at this level.

       <b>7.</b> <u>Forced</u> <u>Joining</u>
              If  the  `<b>(j)</b>'  flag  is present, or no `<b>(j)</b>' flag is present but the string is to be split as
              given by rules <b>8.</b> or <b>9.</b>, and joining did not take place at step <b>4.</b>, any words in the value are
              joined  together using the given string or the first character of <b>$IFS</b> if none.  Note that the
              `<b>(F)</b>' flag implicitly supplies a string for joining in this manner.

       <b>8.</b> <u>Forced</u> <u>Splitting</u>
              If one of the `<b>(s)</b>', `<b>(f)</b>' or `<b>(z)</b>' flags are present, or the `<b>=</b>' specifier was present  (e.g.
              <b>${=</b><u>var</u><b>}</b>),  the word is split on occurrences of the specified string, or (for <b>=</b> with neither of
              the two flags present) any of the characters in <b>$IFS</b>.

       <b>9.</b> <u>Shell</u> <u>Word</u> <u>Splitting</u>
              If no `<b>(s)</b>', `<b>(f)</b>' or `<b>=</b>' was given, but the word is not quoted and the  option  <b>SH_WORD_SPLIT</b>
              is  set,  the  word is split on occurrences of any of the characters in <b>$IFS</b>.  Note this step,
              too, takes place at all levels of a nested substitution.

       <b>10.</b> <u>Uniqueness</u>
              If the result is an array and the `<b>(u)</b>' flag was present, duplicate elements are removed  from
              the array.

       <b>11.</b> <u>Ordering</u>
              If  the result is still an array and one of the `<b>(o)</b>' or `<b>(O)</b>' flags was present, the array is
              reordered.

       <b>12.</b> <u>Re-Evaluation</u>
              Any `<b>(e)</b>' flag is applied to the value, forcing it to be re-examined for new parameter substi-<font color="#ffffff" class="whiteout">tutions,&nbsp;substitutions,</font>
              tutions, but also for command and arithmetic substitutions.

       <b>13.</b> <u>Padding</u>
              Any padding of the value by the `<b>(l.</b><u>fill</u><b>.)</b>' or `<b>(r.</b><u>fill</u><b>.)</b>' flags is applied.

       <b>14.</b> <u>Semantic</u> <u>Joining</u>
              In contexts where expansion semantics requires a single word to result, all words are rejoined
              with the first character of <b>IFS</b> between.  So in `<b>${(P)${(f)lines}}</b>' the value of  <b>${lines}</b>  is
              split at newlines, but then must be joined again before the <b>P</b> flag can be applied.

              If a single word is not required, this rule is skipped.


   <b>Examples</b>
       The   flag  <b>f</b>  is  useful  to  split  a  double-quoted  substitution  line  by  line.   For  example,
       <b>${(f)"$(&lt;</b><u>file</u><b>)"}</b> substitutes the contents of <u>file</u> divided so that each line  is  an  element  of  the
       resulting array.  Compare this with the effect of <b>$(&lt;</b><u>file</u><b>)</b> alone, which divides the file up by words,
       or the same inside double quotes, which makes the entire content of the file a single string.

       The following illustrates the rules for nested parameter expansions.  Suppose that <b>$foo</b> contains  the
       array <b>(bar</b> <b>baz)</b>:

       <b>"${(@)${foo}[1]}"</b>
              This  produces  the  result <b>b</b>.  First, the inner substitution <b>"${foo}"</b>, which has no array (<b>@</b>)
              flag, produces a single word result <b>"bar</b> <b>baz"</b>.  The outer substitution <b>"${(@)...[1]}"</b>  detects
              that  this is a scalar, so that (despite the `<b>(@)</b>' flag) the subscript picks the first charac-
              ter.

       <b>"${${(@)foo}[1]}"</b>
              This produces the result `<b>bar</b>'.  In this case, the inner substitution <b>"${(@)foo}"</b> produces the
              array `<b>(bar</b> <b>baz)</b>'.  The outer substitution <b>"${...[1]}"</b> detects that this is an array and picks
              the first word.  This is similar to the simple case <b>"${foo[1]}"</b>.

       As an example of the rules for word splitting and joining, suppose  <b>$foo</b>  contains  the  array  `<b>(ax1</b>
       <b>bx1)</b>'.  Then

       <b>${(s/x/)foo}</b>
              produces the words `<b>a</b>', `<b>1</b> <b>b</b>' and `<b>1</b>'.

       <b>${(j/x/s/x/)foo}</b>
              produces `<b>a</b>', `<b>1</b>', `<b>b</b>' and `<b>1</b>'.

       <b>${(s/x/)foo%%1*}</b>
              produces `<b>a</b>' and ` <b>b</b>' (note the extra space).  As substitution occurs before either joining or
              splitting, the operation  first generates the modified array <b>(ax</b> <b>bx)</b>, which is joined to  give
              <b>"ax</b> <b>bx"</b>, and then split to give `<b>a</b>', ` <b>b</b>' and `'.  The final empty string will then be elided,
              as it is not in double quotes.


<b>COMMAND</b> <b>SUBSTITUTION</b>
       A command enclosed in parentheses preceded by a dollar sign, like  `<b>$(</b>...<b>)</b>',  or  quoted  with  grave
       accents,  like `<b>`</b>...<b>`</b>', is replaced with its standard output, with any trailing newlines deleted.  If
       the substitution is not enclosed in double quotes, the output is broken  into  words  using  the  <b>IFS</b>
       parameter.  The substitution `<b>$(cat</b> <u>foo</u><b>)</b>' may be replaced by the equivalent but faster `<b>$(&lt;</b><u>foo</u><b>)</b>'.  In
       either case, if the option <b>GLOB_SUBST</b> is set, the output is eligible for filename generation.

<b>ARITHMETIC</b> <b>EXPANSION</b>
       A string of the form `<b>$[</b><u>exp</u><b>]</b>' or `<b>$((</b><u>exp</u><b>))</b>' is substituted with the value of the  arithmetic  expres-
       sion  <u>exp</u>.   <u>exp</u>  is  subjected to <u>parameter</u> <u>expansion</u>, <u>command</u> <u>substitution</u> and <u>arithmetic</u> <u>expansion</u>
       before it is evaluated.  See the section `Arithmetic Evaluation'.

<b>BRACE</b> <b>EXPANSION</b>
       A string of the form `<u>foo</u><b>{</b><u>xx</u><b>,</b><u>yy</u><b>,</b><u>zz</u><b>}</b><u>bar</u>' is expanded to the individual  words  `<u>fooxxbar</u>',  `<u>fooyybar</u>'
       and  `<u>foozzbar</u>'.   Left-to-right  order  is  preserved.  This construct may be nested.  Commas may be
       quoted in order to include them literally in a word.

       An expression of the form `<b>{</b><u>n1</u><b>..</b><u>n2</u><b>}</b>', where <u>n1</u> and <u>n2</u> are  integers,  is  expanded  to  every  number
       between  <u>n1</u> and <u>n2</u> inclusive.  If either number begins with a zero, all the resulting numbers will be
       padded with leading zeroes to that minimum width.  If the numbers are in decreasing order the result-<font color="#ffffff" class="whiteout">ing&nbsp;resulting</font>
       ing sequence will also be in decreasing order.

       If  a  brace  expression  matches none of the above forms, it is left unchanged, unless the <b>BRACE_CCL</b>
       option is set.  In that case, it is expanded to a sorted list of the  individual  characters  between
       the  braces,  in the manner of a search set.  `<b>-</b>' is treated specially as in a search set, but `<b>^</b>' or
       `<b>!</b>' as the first character is treated normally.

       Note that brace expansion is not part of  filename  generation  (globbing);  an  expression  such  as
       <b>*/{foo,bar}</b>  is split into two separate words <b>*/foo</b> and <b>*/bar</b> before filename generation takes place.
       In particular, note that this is liable to produce a `no match' error if <u>either</u> of  the  two  expres-<font color="#ffffff" class="whiteout">sions&nbsp;expressions</font>
       sions does not match; this is to be contrasted with <b>*/(foo|bar)</b>, which is treated as a single pattern
       but otherwise has similar effects.

       To combine brace expansion with array expansion, see the  <b>${^</b><u>spec</u><b>}</b>  form  described  in  the  section
       Parameter Expansion above.


<b>FILENAME</b> <b>EXPANSION</b>
       Each  word  is  checked  to see if it begins with an unquoted `<b>~</b>'.  If it does, then the word up to a
       `<b>/</b>', or the end of the word if there is no `<b>/</b>', is checked to see if it can be substituted in one  of
       the ways described here.  If so, then the `<b>~</b>' and the checked portion are replaced with the appropri-<font color="#ffffff" class="whiteout">ate&nbsp;appropriate</font>
       ate substitute value.

       A `<b>~</b>' by itself is replaced by the value of <b>$HOME</b>.  A `<b>~</b>' followed by a `<b>+</b>' or a `<b>-</b>' is  replaced  by
       the value of <b>$PWD</b> or <b>$OLDPWD</b>, respectively.

       A  `<b>~</b>'  followed  by  a  number is replaced by the directory at that position in the directory stack.
       `<b>~0</b>' is equivalent to `<b>~+</b>', and `<b>~1</b>' is the top of the stack.  `<b>~+</b>' followed by a number is  replaced
       by  the directory at that position in the directory stack.  `<b>~+0</b>' is equivalent to `<b>~+</b>', and `<b>~+1</b>' is
       the top of the stack.  `<b>~-</b>' followed by a number is replaced by the  directory  that  many  positions
       from  the  bottom  of the stack.  `<b>~-0</b>' is the bottom of the stack.  The <b>PUSHD_MINUS</b> option exchanges
       the effects of `<b>~+</b>' and `<b>~-</b>' where they are followed by a number.

       A `<b>~</b>' followed by anything not already covered is looked up as a named directory, and replaced by the
       value  of  that named directory if found.  Named directories are typically home directories for users
       on the system.  They may also be defined if the text after the `<b>~</b>' is the  name  of  a  string  shell
       parameter whose value begins with a `<b>/</b>'.  Note that trailing slashes will be removed from the path to
       the directory (though the original parameter is not modified).  It is also possible to define  direc-<font color="#ffffff" class="whiteout">tory&nbsp;directory</font>
       tory names using the <b>-d</b> option to the <b>hash</b> builtin.

       In  certain  circumstances  (in  prompts,  for  instance),  when the shell prints a path, the path is
       checked to see if it has a named directory as its prefix.  If so, then the prefix portion is replaced
       with  a `<b>~</b>' followed by the name of the directory.  The shortest way of referring to the directory is
       used, with ties broken in favour of using a named directory, except when the directory is  <b>/</b>  itself.
       The parameters <b>$PWD</b> and <b>$OLDPWD</b> are never abbreviated in this fashion.

       If  a  word  begins  with  an unquoted `<b>=</b>' and the <b>EQUALS</b> option is set, the remainder of the word is
       taken as the name of a command.  If a command exists by that name, the word is replaced by  the  full
       pathname of the command.

       Filename  expansion  is  performed  on the right hand side of a parameter assignment, including those
       appearing after commands of the <b>typeset</b> family.  In this case, the right hand side will be treated as
       a  colon-separated  list in the manner of the <b>PATH</b> parameter, so that a `<b>~</b>' or an `<b>=</b>' following a `<b>:</b>'
       is eligible for expansion.  All such behaviour can be disabled by quoting the `<b>~</b>', the  `<b>=</b>',  or  the
       whole expression (but not simply the colon); the <b>EQUALS</b> option is also respected.

       If  the  option <b>MAGIC_EQUAL_SUBST</b> is set, any unquoted shell argument in the form `<u>identifier</u><b>=</b><u>expres</u>-<font color="#ffffff" class="whiteout">sion'&nbsp;`identifier=expression'</font>
       <u>sion</u>' becomes eligible for file expansion as described in the previous paragraph.  Quoting the  first
       `<b>=</b>' also inhibits this.

<b>FILENAME</b> <b>GENERATION</b>
       If  a word contains an unquoted instance of one of the characters `<b>*</b>', `<b>(</b>', `<b>|</b>', `<b>&lt;</b>', `<b>[</b>', or `<b>?</b>', it
       is regarded as a pattern  for  filename  generation,  unless  the  <b>GLOB</b>  option  is  unset.   If  the
       <b>EXTENDED_GLOB</b> option is set, the `<b>^</b>' and `<b>#</b>' characters also denote a pattern; otherwise they are not
       treated specially by the shell.

       The word is replaced with a list of sorted filenames that match the pattern.  If no matching  pattern
       is  found,  the  shell  gives an error message, unless the <b>NULL_GLOB</b> option is set, in which case the
       word is deleted; or unless the <b>NOMATCH</b> option is unset, in which case the word is left unchanged.

       In filename generation, the character `<b>/</b>' must be matched explicitly; also, a  `<b>.</b>'  must  be  matched
       explicitly  at  the  beginning  of  a pattern or after a `<b>/</b>', unless the <b>GLOB_DOTS</b> option is set.  No
       filename generation pattern matches the files `<b>.</b>' or `<b>..</b>'.  In other instances of  pattern  matching,
       the `<b>/</b>' and `<b>.</b>' are not treated specially.

   <b>Glob</b> <b>Operators</b>
       <b>*</b>      Matches any string, including the null string.

       <b>?</b>      Matches any character.

       <b>[</b>...<b>]</b>  Matches  any  of the enclosed characters.  Ranges of characters can be specified by separating
              two characters by a `<b>-</b>'.  A `<b>-</b>' or `<b>]</b>' may be matched by including it as the  first  character
              in  the list.  There are also several named classes of characters, in the form `<b>[:</b><u>name</u><b>:]</b>' with
              the following meanings.  The first set use the macros provided by the operating system to test
              for  the  given character combinations, including any modifications due to local language set-
              tings, see <a href="../man3/ctype.3.html#//apple_ref/doc/man/3/ctype"><u>ctype</u>(3)</a>:

              <b>[:alnum:]</b>
                     The character is alphanumeric

              <b>[:alpha:]</b>
                     The character is alphabetic

              <b>[:ascii:]</b>
                     The character is 7-bit, i.e. is a single-byte character without the top bit set.

              <b>[:blank:]</b>
                     The character is either space or tab

              <b>[:cntrl:]</b>
                     The character is a control character

              <b>[:digit:]</b>
                     The character is a decimal digit

              <b>[:graph:]</b>
                     The character is a printable character other than whitespace

              <b>[:lower:]</b>l
                     The character is a lowercase letter

              <b>[:print:]</b>
                     The character is printable

              <b>[:punct:]</b>
                     The character is printable but neither alphanumeric nor whitespace

              <b>[:space:]</b>
                     The character is whitespace

              <b>[:upper:]</b>
                     The character is an uppercase letter

              <b>[:xdigit:]</b>
                     The character is a hexadecimal digit

              Another set of named classes is handled internally by the shell and is not  sensitive  to  the
              locale:

              <b>[:IDENT:]</b>
                     The character is allowed to form part of a shell identifier, such as a parameter name

              <b>[:IFS:]</b>
                     The character is used as an input field separator, i.e. is contained in the <b>IFS</b> parame-<font color="#ffffff" class="whiteout">ter&nbsp;parameter</font>
                     ter

              <b>[:IFSSPACE:]</b>
                     The character is an IFS white space character; see the documentation  for  <b>IFS</b>  in  the
                     <a href="zshparam.1.html#//apple_ref/doc/man/1/zshparam"><u>zshparam</u>(1)</a> manual page.

              <b>[:WORD:]</b>
                     The  character is treated as part of a word; this test is sensitive to the value of the
                     <b>WORDCHARS</b> parameter

              Note that the square brackets are additional to those enclosing the whole set  of  characters,
              so  to  test for a single alphanumeric character you need `<b>[[:alnum:]]</b>'.  Named character sets
              can be used alongside other types, e.g. `<b>[[:alpha:]0-9]</b>'.

       <b>[^</b>...<b>]</b>
       <b>[!</b>...<b>]</b> Like <b>[</b>...<b>]</b>, except that it matches any character which is not in the given set.

       <b>&lt;</b>[<u>x</u>]<b>-</b>[<u>y</u>]<b>&gt;</b>
              Matches any number in the range <u>x</u> to <u>y</u>, inclusive.  Either of the numbers may  be  omitted  to
              make  the  range  open-ended; hence `<b>&lt;-&gt;</b>' matches any number.  To match individual digits, the
              <b>[</b>...<b>]</b> form is more efficient.

              Be careful when using other wildcards adjacent to patterns of this form; for  example,  <b>&lt;0-9&gt;*</b>
              will  actually  match any number whatsoever at the start of the string, since the `<b>&lt;0-9&gt;</b>' will
              match the first digit, and the `<b>*</b>' will match any others.  This is a trap for the unwary,  but
              is  in  fact an inevitable consequence of the rule that the longest possible match always suc-<font color="#ffffff" class="whiteout">ceeds.&nbsp;succeeds.</font>
              ceeds.  Expressions such as `<b>&lt;0-9&gt;[^[:digit:]]*</b>' can be used instead.

       <b>(</b>...<b>)</b>  Matches the enclosed pattern.  This is used for grouping.  If the <b>KSH_GLOB</b> option is set, then
              a  `<b>@</b>',  `<b>*</b>',  `<b>+</b>', `<b>?</b>' or `<b>!</b>' immediately preceding the `<b>(</b>' is treated specially, as detailed
              below. The option <b>SH_GLOB</b> prevents bare parentheses from being used in this  way,  though  the
              <b>KSH_GLOB</b> option is still available.

              Note  that  grouping  cannot  extend  over  multiple directories: it is an error to have a `<b>/</b>'
              within a group (this only applies for patterns used in filename  generation).   There  is  one
              exception:   a  group  of  the  form  <b>(</b><u>pat</u><b>/)#</b> appearing as a complete path segment can match a
              sequence  of  directories.   For  example,   <b>foo/(a*/)#bar</b>   matches   <b>foo/bar</b>,   <b>foo/any/bar</b>,
              <b>foo/any/anyother/bar</b>, and so on.

       <u>x</u><b>|</b><u>y</u>    Matches  either <u>x</u> or <u>y</u>.  This operator has lower precedence than any other.  The `<b>|</b>' character
              must be within parentheses, to avoid interpretation as a pipeline.

       <b>^</b><u>x</u>     (Requires <b>EXTENDED_GLOB</b> to be set.)  Matches anything except the pattern <u>x</u>.  This has a higher
              precedence  than  `<b>/</b>',  so `<b>^foo/bar</b>' will search directories in `<b>.</b>' except `<b>./foo</b>' for a file
              named `<b>bar</b>'.

       <u>x</u><b>~</b><u>y</u>    (Requires <b>EXTENDED_GLOB</b> to be set.)  Match anything that matches the pattern <u>x</u>  but  does  not
              match <u>y</u>.  This has lower precedence than any operator except `<b>|</b>', so `<b>*/*~foo/bar</b>' will search
              for all files in all directories in `<b>.</b>'  and then exclude `<b>foo/bar</b>' if there was such a match.
              Multiple patterns can be excluded by `<u>foo</u><b>~</b><u>bar</u><b>~</b><u>baz</u>'.  In the exclusion pattern (<u>y</u>), `<b>/</b>' and `<b>.</b>'
              are not treated specially the way they usually are in globbing.

       <u>x</u><b>#</b>     (Requires <b>EXTENDED_GLOB</b> to be set.)  Matches zero or more occurrences of the pattern <u>x</u>.   This
              operator  has  high precedence; `<b>12#</b>' is equivalent to `<b>1(2#)</b>', rather than `<b>(12)#</b>'.  It is an
              error for an unquoted `<b>#</b>' to follow something which cannot be repeated; this includes an empty
              string,  a  pattern  already  followed by `<b>##</b>', or parentheses when part of a <b>KSH_GLOB</b> pattern
              (for example, `<b>!(</b><u>foo</u><b>)#</b>' is invalid and must be replaced by `<b>*(!(</b><u>foo</u><b>))</b>').

       <u>x</u><b>##</b>    (Requires <b>EXTENDED_GLOB</b> to be set.)  Matches one or more occurrences of the pattern  <u>x</u>.   This
              operator has high precedence; `<b>12##</b>' is equivalent to `<b>1(2##)</b>', rather than `<b>(12)##</b>'.  No more
              than two active `<b>#</b>' characters may appear together.  (Note the potential clash with glob qual-<font color="#ffffff" class="whiteout">ifiers&nbsp;qualifiers</font>
              ifiers in the form `<b>1(2##)</b>' which should therefore be avoided.)

   <b>ksh-like</b> <b>Glob</b> <b>Operators</b>
       If  the  <b>KSH_GLOB</b>  option is set, the effects of parentheses can be modified by a preceding `<b>@</b>', `<b>*</b>',
       `<b>+</b>', `<b>?</b>' or `<b>!</b>'.  This character need not be unquoted to have special effects, but the `<b>(</b>' must be.

       <b>@(</b>...<b>)</b> Match the pattern in the parentheses.  (Like `<b>(</b>...<b>)</b>'.)

       <b>*(</b>...<b>)</b> Match any number of occurrences.  (Like `<b>(</b>...<b>)#</b>'.)

       <b>+(</b>...<b>)</b> Match at least one occurrence.  (Like `<b>(</b>...<b>)##</b>'.)

       <b>?(</b>...<b>)</b> Match zero or one occurrence.  (Like `<b>(|</b>...<b>)</b>'.)

       <b>!(</b>...<b>)</b> Match anything but the expression in parentheses.  (Like `<b>(^(</b>...<b>))</b>'.)

   <b>Precedence</b>
       The precedence of the operators given above is (highest) `<b>^</b>', `<b>/</b>', `<b>~</b>', `<b>|</b>' (lowest);  the  remaining
       operators  are  simply  treated from left to right as part of a string, with `<b>#</b>' and `<b>##</b>' applying to
       the shortest possible preceding unit (i.e. a character, `<b>?</b>', `<b>[</b>...<b>]</b>',  `<b>&lt;</b>...<b>&gt;</b>',  or  a  parenthesised
       expression).  As mentioned above, a `<b>/</b>' used as a directory separator may not appear inside parenthe-<font color="#ffffff" class="whiteout">ses,&nbsp;parentheses,</font>
       ses, while a `<b>|</b>' must do so; in patterns used in other contexts than filename generation  (for  exam-<font color="#ffffff" class="whiteout">ple,&nbsp;example,</font>
       ple,  in  <b>case</b> statements and tests within `<b>[[</b>...<b>]]</b>'), a `<b>/</b>' is not special; and `<b>/</b>' is also not spe-<font color="#ffffff" class="whiteout">cial&nbsp;special</font>
       cial after a `<b>~</b>' appearing outside parentheses in a filename pattern.

   <b>Globbing</b> <b>Flags</b>
       There are various flags which affect any text to their right up to the end of the enclosing group  or
       to  the end of the pattern; they require the <b>EXTENDED_GLOB</b> option. All take the form <b>(#</b><u>X</u><b>)</b> where <u>X</u> may
       have one of the following forms:

       <b>i</b>      Case insensitive:  upper or lower case characters in the pattern match  upper  or  lower  case
              characters.

       <b>l</b>      Lower  case characters in the pattern match upper or lower case characters; upper case charac-<font color="#ffffff" class="whiteout">ters&nbsp;characters</font>
              ters in the pattern still only match upper case characters.

       <b>I</b>      Case sensitive:  locally negates the effect of <b>i</b> or <b>l</b> from that point on.

       <b>b</b>      Activate backreferences for parenthesised groups in the pattern; this does not work  in  file-<font color="#ffffff" class="whiteout">name&nbsp;filename</font>
              name  generation.   When  a  pattern  with a set of active parentheses is matched, the strings
              matched by the groups are stored in the array <b>$match</b>, the indices  of  the  beginning  of  the
              matched  parentheses in the array <b>$mbegin</b>, and the indices of the end in the array <b>$mend</b>, with
              the first element of each array corresponding to the first parenthesised  group,  and  so  on.
              These  arrays  are not otherwise special to the shell.  The indices use the same convention as
              does parameter substitution, so that elements of <b>$mend</b> and <b>$mbegin</b> may be used in  subscripts;
              the  <b>KSH_ARRAYS</b>  option is respected.  Sets of globbing flags are not considered parenthesised
              groups; only the first nine active parentheses can be referenced.

              For example,

                     <b>foo="a</b> <b>string</b> <b>with</b> <b>a</b> <b>message"</b>
                     <b>if</b> <b>[[</b> <b>$foo</b> <b>=</b> <b>(a|an)'</b> <b>'(#b)(*)'</b> <b>'*</b> <b>]];</b> <b>then</b>
                       <b>print</b> <b>${foo[$mbegin[1],$mend[1]]}</b>
                     <b>fi</b>

              prints `<b>string</b> <b>with</b> <b>a</b>'.  Note that the first parenthesis is before the <b>(#b)</b> and does not  cre-<font color="#ffffff" class="whiteout">ate&nbsp;create</font>
              ate a backreference.

              Backreferences  work  with  all  forms of pattern matching other than filename generation, but
              note that when performing matches on an entire array, such as <b>${</b><u>array</u><b>#</b><u>pattern</u><b>}</b>,  or  a  global
              substitution,  such as <b>${</b><u>param</u><b>//</b><u>pat</u><b>/</b><u>repl</u><b>}</b>, only the data for the last match remains available.
              In the case of global replacements this may still be useful.  See the example for the  <b>m</b>  flag
              below.

              The  numbering  of  backreferences  strictly follows the order of the opening parentheses from
              left to right in the pattern string, although sets of parentheses may be  nested.   There  are
              special rules for parentheses followed by `<b>#</b>' or `<b>##</b>'.  Only the last match of the parenthesis
              is remembered: for example, in `<b>[[</b> <b>abab</b> <b>=</b> <b>(#b)([ab])#</b> <b>]]</b>', only the final  `<b>b</b>'  is  stored  in
              <b>match[1]</b>.  Thus extra parentheses may be necessary to match the complete segment: for example,
              use `<b>X((ab|cd)#)Y</b>' to match a whole string of either `<b>ab</b>' or `<b>cd</b>' between `<b>X</b>' and  `<b>Y</b>',  using
              the value of <b>$match[1]</b> rather than <b>$match[2]</b>.

              If  the match fails none of the parameters is altered, so in some cases it may be necessary to
              initialise them beforehand.  If some of the backreferences fail to match -- which  happens  if
              they are in an alternate branch which fails to match, or if they are followed by <b>#</b> and matched
              zero times -- then the matched string is set to the  empty  string,  and  the  start  and  end
              indices are set to -1.

              Pattern matching with backreferences is slightly slower than without.

       <b>B</b>      Deactivate backreferences, negating the effect of the <b>b</b> flag from that point on.

       <b>m</b>      Set  references to the match data for the entire string matched; this is similar to backrefer-<font color="#ffffff" class="whiteout">encing&nbsp;backreferencing</font>
              encing and does not work in filename generation.  The flag must be in effect at the end of the
              pattern,  i.e.  not local to a group. The parameters <b>$MATCH</b>,  <b>$MBEGIN</b> and <b>$MEND</b> will be set to
              the string matched and to the indices of the beginning and end of  the  string,  respectively.
              This is most useful in parameter substitutions, as otherwise the string matched is obvious.

              For example,

                     <b>arr=(veldt</b> <b>jynx</b> <b>grimps</b> <b>waqf</b> <b>zho</b> <b>buck)</b>
                     <b>print</b> <b>${arr//(#m)[aeiou]/${(U)MATCH}}</b>

              forces  all the matches (i.e. all vowels) into uppercase, printing `<b>vEldt</b> <b>jynx</b> <b>grImps</b> <b>wAqf</b> <b>zhO</b>
              <b>bUck</b>'.

              Unlike backreferences, there is no speed penalty for using match references,  other  than  the
              extra substitutions required for the replacement strings in cases such as the example shown.

       <b>M</b>      Deactivate the <b>m</b> flag, hence no references to match data will be created.

       <b>a</b><u>num</u>   Approximate  matching: <u>num</u> errors are allowed in the string matched by the pattern.  The rules
              for this are described in the next subsection.

       <b>s</b>, <b>e</b>   Unlike the other flags, these have only a local effect, and  each  must  appear  on  its  own:
              `<b>(#s)</b>' and `<b>(#e)</b>' are the only valid forms.  The `<b>(#s)</b>' flag succeeds only at the start of the
              test string, and the `<b>(#e)</b>' flag succeeds only at the end of the test string; they  correspond
              to `<b>^</b>' and `<b>$</b>' in standard regular expressions.  They are useful for matching path segments in
              patterns other than those in filename generation (where path segments are in any case  treated
              separately).   For  example,  `<b>*((#s)|/)test((#e)|/)*</b>' matches a path segment `<b>test</b>' in any of
              the following strings: <b>test</b>, <b>test/at/start</b>, <b>at/end/test</b>, <b>in/test/middle</b>.

              Another use is in parameter substitution; for example `<b>${array/(#s)A*Z(#e)}</b>' will remove  only
              elements of an array which match the complete pattern `<b>A*Z</b>'.  There are other ways of perform-<font color="#ffffff" class="whiteout">ing&nbsp;performing</font>
              ing many operations of this type, however the combination of the substitution  operations  `<b>/</b>'
              and `<b>//</b>' with the `<b>(#s)</b>' and `<b>(#e)</b>' flags provides a single simple and memorable method.

              Note  that assertions of the form `<b>(^(#s))</b>' also work, i.e. match anywhere except at the start
              of the string, although this actually means `anything except  a  zero-length  portion  at  the
              start of the string'; you need to use `<b>(""~(#s))</b>' to match a zero-length portion of the string
              not at the start.

       <b>q</b>      A `<b>q</b>' and everything up to the closing parenthesis of the globbing flags are  ignored  by  the
              pattern  matching  code.   This  is intended to support the use of glob qualifiers, see below.
              The result is that the pattern `<b>(#b)(*).c(#q.)</b>' can be used both for globbing and for matching
              against a string.  In the former case, the `<b>(#q.)</b>' will be treated as a glob qualifier and the
              `<b>(#b)</b>' will not be useful, while in the latter case the `<b>(#b)</b>' is  useful  for  backreferences
              and  the  `<b>(#q.)</b>'  will be ignored.  Note that colon modifiers in the glob qualifiers are also
              not applied in ordinary pattern matching.

       <b>u</b>      Respect the current locale in determining the presence of multibyte characters in  a  pattern,
              provided  the shell was compiled with <b>MULTIBYTE_SUPPORT</b>.  This overrides the <b>MULTIBYTE</b> option;
              the default behaviour is taken from the option.  Compare <b>U</b>.   (Mnemonic:  typically  multibyte
              characters  are  from Unicode in the UTF-8 encoding, although any extension of ASCII supported
              by the system library may be used.)

       <b>U</b>      All characters are considered to be a single byte long.  The opposite of  <b>u</b>.   This  overrides
              the <b>MULTIBYTE</b> option.

       For  example,  the  test  string <b>fooxx</b> can be matched by the pattern <b>(#i)FOOXX</b>, but not by <b>(#l)FOOXX</b>,
       <b>(#i)FOO(#I)XX</b> or <b>((#i)FOOX)X</b>.  The string <b>(#ia2)readme</b> specifies case-insensitive matching of  <b>readme</b>
       with up to two errors.

       When  using  the  ksh  syntax  for  grouping both <b>KSH_GLOB</b> and <b>EXTENDED_GLOB</b> must be set and the left
       parenthesis should be preceded by <b>@</b>.  Note also that the flags do not  affect  letters  inside  <b>[...]</b>
       groups, in other words <b>(#i)[a-z]</b> still matches only lowercase letters.  Finally, note that when exam-<font color="#ffffff" class="whiteout">ining&nbsp;examining</font>
       ining whole paths case-insensitively every directory must be searched for all files which  match,  so
       that a pattern of the form <b>(#i)/foo/bar/...</b> is potentially slow.


   <b>Approximate</b> <b>Matching</b>
       When  matching  approximately,  the  shell keeps a count of the errors found, which cannot exceed the
       number specified in the <b>(#a</b><u>num</u><b>)</b> flags.  Four types of error are recognised:

       1.     Different characters, as in <b>fooxbar</b> and <b>fooybar</b>.

       2.     Transposition of characters, as in <b>banana</b> and <b>abnana</b>.

       3.     A character missing in the target string, as with the pattern <b>road</b> and target string <b>rod</b>.

       4.     An extra character appearing in the target string, as with <b>stove</b> and <b>strove</b>.

       Thus, the pattern <b>(#a3)abcd</b> matches <b>dcba</b>, with the errors occurring by using the first rule twice and
       the second once, grouping the string as <b>[d][cb][a]</b> and <b>[a][bc][d]</b>.

       Non-literal  parts of the pattern must match exactly, including characters in character ranges: hence
       <b>(#a1)???</b>  matches strings of length four, by applying rule 4 to an empty part of the pattern, but not
       strings  of  length  two,  since all the <b>?</b> must match.  Other characters which must match exactly are
       initial dots in filenames (unless the <b>GLOB_DOTS</b> option is set), and all slashes in filenames, so that
       <b>a/bc</b>  is  two  errors  from <b>ab/c</b> (the slash cannot be transposed with another character).  Similarly,
       errors are counted separately for non-contiguous strings in the pattern, so  that  <b>(ab|cd)ef</b>  is  two
       errors from <b>aebf</b>.

       When  using exclusion via the <b>~</b> operator, approximate matching is treated entirely separately for the
       excluded part and must be activated separately.  Thus, <b>(#a1)README~READ_ME</b> matches  <b>READ.ME</b>  but  not
       <b>READ_ME</b>, as the trailing <b>READ_ME</b> is matched without approximation.  However, <b>(#a1)README~(#a1)READ_ME</b>
       does not match any pattern of the form <b>READ</b><u>?</u><b>ME</b> as all such forms are now excluded.

       Apart from exclusions, there is only one overall error count; however, the maximum errors allowed may
       be altered locally, and this can be delimited by grouping.  For example, <b>(#a1)cat((#a0)dog)fox</b> allows
       one error in total, which may not occur in the <b>dog</b> section, and the pattern  <b>(#a1)cat(#a0)dog(#a1)fox</b>
       is  equivalent.   Note  that the point at which an error is first found is the crucial one for estab-<font color="#ffffff" class="whiteout">lishing&nbsp;establishing</font>
       lishing whether to use approximation; for example, <b>(#a1)abc(#a0)xyz</b> will not match  <b>abcdxyz</b>,  because
       the error occurs at the `<b>x</b>', where approximation is turned off.

       Entire  path  segments  may  be  matched approximately, so that `<b>(#a1)/foo/d/is/available/at/the/bar</b>'
       allows one error in any path segment.  This is much less efficient than without the  <b>(#a1)</b>,  however,
       since  every  directory  in the path must be scanned for a possible approximate match.  It is best to
       place the <b>(#a1)</b> after any path segments which are known to be correct.


   <b>Recursive</b> <b>Globbing</b>
       A pathname component of the form `<b>(</b><u>foo</u><b>/)#</b>' matches a path consisting  of  zero  or  more  directories
       matching the pattern <u>foo</u>.

       As a shorthand, `<b>**/</b>' is equivalent to `<b>(*/)#</b>'; note that this therefore matches files in the current
       directory as well as subdirectories.  Thus:

              <b>ls</b> <b>(*/)#bar</b>

       or

              <b>ls</b> <b>**/bar</b>

       does a recursive directory search for files named `<b>bar</b>' (potentially including the file `<b>bar</b>' in  the
       current  directory).  This form does not follow symbolic links; the alternative form `<b>***/</b>' does, but
       is otherwise identical.  Neither of these can be combined with other forms  of  globbing  within  the
       same path segment; in that case, the `<b>*</b>' operators revert to their usual effect.

   <b>Glob</b> <b>Qualifiers</b>
       Patterns  used  for filename generation may end in a list of qualifiers enclosed in parentheses.  The
       qualifiers specify which filenames that otherwise match the given pattern will  be  inserted  in  the
       argument list.

       If  the  option  <b>BARE_GLOB_QUAL</b>  is  set, then a trailing set of parentheses containing no `<b>|</b>' or `<b>(</b>'
       characters (or `<b>~</b>' if it is special) is taken as a set of glob qualifiers.  A glob subexpression that
       would  normally  be taken as glob qualifiers, for example `<b>(^x)</b>', can be forced to be treated as part
       of the glob pattern by doubling the parentheses, in this case producing `<b>((^x))</b>'.

       If the option <b>EXTENDED_GLOB</b> is set, a different syntax  for  glob  qualifiers  is  available,  namely
       `<b>(#qx)</b>'  where  <b>x</b>  is  any of the same glob qualifiers used in the other format.  The qualifiers must
       still appear at the end of the pattern.  However, with this syntax multiple glob  qualifiers  may  be
       chained  together.   They are treated as a logical AND of the individual sets of flags.  Also, as the
       syntax is unambiguous, the expression will be treated as glob qualifiers just as long any parentheses
       contained  within  it  are  balanced; appearance of `<b>|</b>', `<b>(</b>' or `<b>~</b>' does not negate the effect.  Note
       that qualifiers will be recognised in this form even if a bare glob qualifier exists at  the  end  of
       the pattern, for example `<b>*(#q*)(.)</b>' will recognise executable regular files if both options are set;
       however, mixed syntax should probably be avoided for the sake of clarity.

       A qualifier may be any one of the following:

       <b>/</b>      directories

       <b>F</b>      `full' (i.e. non-empty) directories.  Note that the  opposite  sense  <b>(^F)</b>  expands  to  empty
              directories and all non-directories.  Use <b>(/^F)</b> for empty directories

       <b>.</b>      plain files

       <b>@</b>      symbolic links

       <b>=</b>      sockets

       <b>p</b>      named pipes (FIFOs)

       <b>*</b>      executable plain files (0100)

       <b>%</b>      device files (character or block special)

       <b>%b</b>     block special files

       <b>%c</b>     character special files

       <b>r</b>      owner-readable files (0400)

       <b>w</b>      owner-writable files (0200)

       <b>x</b>      owner-executable files (0100)

       <b>A</b>      group-readable files (0040)

       <b>I</b>      group-writable files (0020)

       <b>E</b>      group-executable files (0010)

       <b>R</b>      world-readable files (0004)

       <b>W</b>      world-writable files (0002)

       <b>X</b>      world-executable files (0001)

       <b>s</b>      setuid files (04000)

       <b>S</b>      setgid files (02000)

       <b>t</b>      files with the sticky bit (01000)

       <b>f</b><u>spec</u>  files with access rights matching <u>spec</u>. This <u>spec</u> may be a octal number optionally preceded by
              a `<b>=</b>', a `<b>+</b>', or a `<b>-</b>'. If none of these characters is given, the behavior is the same as  for
              `<b>=</b>'.  The  octal  number  describes  the mode bits to be expected, if combined with a `<b>=</b>', the
              value given must match the file-modes exactly, with a `<b>+</b>', at least the bits in the given num-<font color="#ffffff" class="whiteout">ber&nbsp;number</font>
              ber  must  be  set  in the file-modes, and with a `<b>-</b>', the bits in the number must not be set.
              Giving a `<b>?</b>' instead of a octal digit anywhere in the number ensures  that  the  corresponding
              bits in the file-modes are not checked, this is only useful in combination with `<b>=</b>'.

              If the qualifier `<b>f</b>' is followed by any other character anything up to the next matching char-<font color="#ffffff" class="whiteout">acter&nbsp;character</font>
              acter (`<b>[</b>', `<b>{</b>', and `<b>&lt;</b>' match `<b>]</b>', `<b>}</b>', and `<b>&gt;</b>' respectively,  any  other  character  matches
              itself)  is taken as a list of comma-separated <u>sub-spec</u>s. Each <u>sub-spec</u> may be either an octal
              number as described above or a list of any of the characters `<b>u</b>', `<b>g</b>', `<b>o</b>', and `<b>a</b>',  followed
              by a `<b>=</b>', a `<b>+</b>', or a `<b>-</b>', followed by a list of any of the characters `<b>r</b>', `<b>w</b>', `<b>x</b>', `<b>s</b>', and
              `<b>t</b>', or an octal digit. The first list of characters specify which access  rights  are  to  be
              checked. If a `<b>u</b>' is given, those for the owner of the file are used, if a `<b>g</b>' is given, those
              of the group are checked, a `<b>o</b>' means to test those of other users, and the `<b>a</b>' says  to  test
              all  three  groups.  The `<b>=</b>', `<b>+</b>', and `<b>-</b>' again says how the modes are to be checked and have
              the same meaning as described for the first form above. The second list of characters  finally
              says  which  access  rights are to be expected: `<b>r</b>' for read access, `<b>w</b>' for write access, `<b>x</b>'
              for the right to execute the file (or to search a directory), `<b>s</b>' for the  setuid  and  setgid
              bits, and `<b>t</b>' for the sticky bit.

              Thus,  `<b>*(f70?)</b>'  gives the files for which the owner has read, write, and execute permission,
              and for which other group members have no rights, independent of  the  permissions  for  other
              users.  The  pattern `<b>*(f-100)</b>' gives all files for which the owner does not have execute per-<font color="#ffffff" class="whiteout">mission,&nbsp;permission,</font>
              mission, and `<b>*(f:gu+w,o-rx:)</b>' gives the files for which the owner and the  other  members  of
              the group have at least write permission, and for which other users don't have read or execute
              permission.

       <b>e</b><u>string</u>
       <b>+</b><u>cmd</u>   The <u>string</u> will be executed as shell code.  The filename will be included in the list  if  and
              only  if  the  code returns a zero status (usually the status of the last command).  The first
              character after the `<b>e</b>' will be used as a separator and anything up to the next matching sepa-<font color="#ffffff" class="whiteout">rator&nbsp;separator</font>
              rator  will  be taken  as the <u>string</u>; `<b>[</b>', `<b>{</b>', and `<b>&lt;</b>' match `<b>]</b>', `<b>}</b>', and `<b>&gt;</b>', respectively,
              while any other character matches itself. Note that expansions must be quoted in the <u>string</u> to
              prevent them from being expanded before globbing is done.

              During the execution of <u>string</u> the filename currently being tested is available in the parame-<font color="#ffffff" class="whiteout">ter&nbsp;parameter</font>
              ter <b>REPLY</b>; the parameter may be altered to a string to be inserted into the  list  instead  of
              the  original  filename.  In addition, the parameter <b>reply</b> may be set to an array or a string,
              which overrides the value of <b>REPLY</b>.  If set to an array, the latter is inserted into the  com-<font color="#ffffff" class="whiteout">mand&nbsp;command</font>
              mand line word by word.

              For  example,  suppose  a  directory  contains  a  single  file `<b>lonely</b>'.  Then the expression
              `<b>*(e:'reply=(${REPLY}{1,2})':)</b>' will cause the words `<b>lonely1</b> <b>lonely2</b>' to be inserted into the
              command line.  Note the quotation marks.

              The form <b>+</b><u>cmd</u> has the same effect, but no delimiters appear around <u>cmd</u>.  Instead, <u>cmd</u> is taken
              as the longest sequence of characters following the <b>+</b> that  are  alphanumeric  or  underscore.
              Typically  <u>cmd</u>  will  be the name of a shell function that contains the appropriate test.  For
              example,

                     <b>nt()</b> <b>{</b> <b>[[</b> <b>$REPLY</b> <b>-nt</b> <b>$NTREF</b> <b>]]</b> <b>}</b>
                     <b>NTREF=reffile</b>
                     <b>ls</b> <b>-l</b> <b>*(+nt)</b>

              lists all files in the directory that have been modified more recently than <b>reffile</b>.

       <b>d</b><u>dev</u>   files on the device <u>dev</u>

       <b>l</b>[<b>-</b>|<b>+</b>]<u>ct</u>
              files having a link count less than <u>ct</u> (<b>-</b>), greater than <u>ct</u> (<b>+</b>), or equal to <u>ct</u>

       <b>U</b>      files owned by the effective user ID

       <b>G</b>      files owned by the effective group ID

       <b>u</b><u>id</u>    files owned by user ID <u>id</u> if that is a number.  Otherwise, <u>id</u> specifies a user name: the char-<font color="#ffffff" class="whiteout">acter&nbsp;character</font>
              acter after the `<b>u</b>' will be taken as a separator and the string between it and the next match-<font color="#ffffff" class="whiteout">ing&nbsp;matching</font>
              ing separator will be taken as a user name.  The starting separators `<b>[</b>', `<b>{</b>', and  `<b>&lt;</b>'  match
              the final separators `<b>]</b>', `<b>}</b>', and `<b>&gt;</b>', respectively; any other character matches itself.  The
              selected files are those owned by this user.  For example, `<b>u:foo:</b>' or `<b>u[foo]</b>' selects  files
              owned by user `<b>foo</b>'.

       <b>g</b><u>id</u>    like <b>u</b><u>id</u> but with group IDs or names

       <b>a</b>[<b>Mwhms</b>][<b>-</b>|<b>+</b>]<u>n</u>
              files accessed exactly <u>n</u> days ago.  Files accessed within the last <u>n</u> days are selected using a
              negative value for <u>n</u> (<b>-</b><u>n</u>).  Files accessed more than <u>n</u> days ago are selected by a  positive  <u>n</u>
              value  (<b>+</b><u>n</u>).   Optional unit specifiers `<b>M</b>', `<b>w</b>', `<b>h</b>', `<b>m</b>' or `<b>s</b>' (e.g. `<b>ah5</b>') cause the check
              to be performed with months (of 30 days), weeks, hours, minutes or seconds  instead  of  days,
              respectively.   For  instance,  `<b>echo</b>  <b>*(ah-5)</b>' would echo files accessed within the last five
              hours.

       <b>m</b>[<b>Mwhms</b>][<b>-</b>|<b>+</b>]<u>n</u>
              like the file access qualifier, except that it uses the file modification time.

       <b>c</b>[<b>Mwhms</b>][<b>-</b>|<b>+</b>]<u>n</u>
              like the file access qualifier, except that it uses the file inode change time.

       <b>L</b>[<b>+</b>|<b>-</b>]<u>n</u>
              files less than <u>n</u> bytes (<b>-</b>), more than <u>n</u> bytes (<b>+</b>), or exactly <u>n</u> bytes in length. If this flag
              is  directly followed by a `<b>k</b>' (`<b>K</b>'), `<b>m</b>' (`<b>M</b>'), or `<b>p</b>' (`<b>P</b>') (e.g. `<b>Lk-50</b>') the check is per-<font color="#ffffff" class="whiteout">formed&nbsp;performed</font>
              formed with kilobytes, megabytes, or blocks (of 512 bytes) instead.

       <b>^</b>      negates all qualifiers following it

       <b>-</b>      toggles between making the qualifiers work on symbolic links (the default) and the files  they
              point to

       <b>M</b>      sets the <b>MARK_DIRS</b> option for the current pattern

       <b>T</b>      appends  a  trailing  qualifier mark to the filenames, analogous to the <b>LIST_TYPES</b> option, for
              the current pattern (overrides <b>M</b>)

       <b>N</b>      sets the <b>NULL_GLOB</b> option for the current pattern

       <b>D</b>      sets the <b>GLOB_DOTS</b> option for the current pattern

       <b>n</b>      sets the <b>NUMERIC_GLOB_SORT</b> option for the current pattern

       <b>o</b><u>c</u>     specifies how the names of the files should be sorted. If <u>c</u> is <b>n</b> they are sorted by name  (the
              default);  if  it  is <b>L</b> they are sorted depending on the size (length) of the files; if <b>l</b> they
              are sorted by the number of links; if <b>a</b>, <b>m</b>, or <b>c</b> they are sorted  by  the  time  of  the  last
              access,  modification,  or  inode  change  respectively;  if <b>d</b>, files in subdirectories appear
              before those in the current directory at each level of the search --  this  is  best  combined
              with  other criteria, for example `<b>odon</b>' to sort on names for files within the same directory;
              if <b>N</b>, no sorting is performed.  Note that <b>a</b>, <b>m</b>, and <b>c</b> compare  the  age  against  the  current
              time,  hence  the  first name in the list is the youngest file. Also note that the modifiers <b>^</b>
              and <b>-</b> are used, so `<b>*(^-oL)</b>' gives a list of all files  sorted  by  file  size  in  descending
              order,  following  any symbolic links.  Unless <b>oN</b> is used, multiple order specifiers may occur
              to resolve ties.

       <b>O</b><u>c</u>     like `<b>o</b>', but sorts in descending order; i.e. `<b>*(^oc)</b>' is the same as `<b>*(Oc)</b>' and `<b>*(^Oc)</b>'  is
              the  same  as `<b>*(oc)</b>'; `<b>Od</b>' puts files in the current directory before those in subdirectories
              at each level of the search.

       <b>[</b><u>beg</u>[<b>,</b><u>end</u>]<b>]</b>
              specifies which of the matched filenames should be included in the returned list.  The  syntax
              is the same as for array subscripts. <u>beg</u> and the optional <u>end</u> may be mathematical expressions.
              As in parameter subscripting they may be negative to make them count from the last match back-<font color="#ffffff" class="whiteout">ward.&nbsp;backward.</font>
              ward. E.g.: `<b>*(-OL[1,3])</b>' gives a list of the names of the three largest files.

       More than one of these lists can be combined, separated by commas. The whole list matches if at least
       one of the sublists matches (they are `or'ed, the qualifiers in  the  sublists  are  `and'ed).   Some
       qualifiers,  however,  affect  all  matches  generated,  independent of the sublist in which they are
       given.  These are the qualifiers `<b>M</b>', `<b>T</b>', `<b>N</b>', `<b>D</b>', `<b>n</b>', `<b>o</b>', `<b>O</b>' and the subscripts given in brack-<font color="#ffffff" class="whiteout">ets&nbsp;brackets</font>
       ets (`<b>[...]</b>').

       If  a  `<b>:</b>' appears in a qualifier list, the remainder of the expression in parenthesis is interpreted
       as a modifier (see the section `Modifiers' in the section `History Expansion').  Note that each modi-<font color="#ffffff" class="whiteout">fier&nbsp;modifier</font>
       fier  must  be  introduced  by a separate `<b>:</b>'.  Note also that the result after modification does not
       have to be an existing file.  The name of any existing file can be followed by a modifier of the form
       `<b>(:..)</b>' even if no actual filename generation is performed.  Thus:

              <b>ls</b> <b>*(-/)</b>

       lists all directories and symbolic links that point to directories, and

              <b>ls</b> <b>*(%W)</b>

       lists all world-writable device files in the current directory, and

              <b>ls</b> <b>*(W,X)</b>

       lists all files in the current directory that are world-writable or world-executable, and

              <b>echo</b> <b>/tmp/foo*(u0^@:t)</b>

       outputs  the  basename of all root-owned files beginning with the string `<b>foo</b>' in <b>/tmp</b>, ignoring sym-<font color="#ffffff" class="whiteout">links,&nbsp;symlinks,</font>
       links, and

              <b>ls</b> <b>*.*~(lex|parse).[ch](^D^l1)</b>

       lists all files having a link count of one whose names contain a dot (but not those starting  with  a
       dot, since <b>GLOB_DOTS</b> is explicitly switched off) except for <b>lex.c</b>, <b>lex.h</b>, <b>parse.c</b> and <b>parse.h</b>.

              <b>print</b> <b>b*.pro(#q:s/pro/shmo/)(#q.:s/builtin/shmiltin/)</b>

       demonstrates  how  colon modifiers and other qualifiers may be chained together.  The ordinary quali-<font color="#ffffff" class="whiteout">fier&nbsp;qualifier</font>
       fier `<b>.</b>' is applied first, then the colon modifiers in order from left to right.  So if <b>EXTENDED_GLOB</b>
       is   set  and  the  base  pattern  matches  the  regular  file  <b>builtin.pro</b>,  the  shell  will  print
       `<b>shmiltin.shmo</b>'.



zsh 4.3.4                                      April 19, 2006                                     ZSHEXPN(1)
</tt></pre>
</td></tr></table>
	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Darwin/Reference/ManPages/man1/zshexpn.1.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Darwin/Reference/ManPages/man1/zshexpn.1.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Darwin/Reference/ManPages/man1/zshexpn.1.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

</body></html>
