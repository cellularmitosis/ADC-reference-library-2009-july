<html><head><title>Mac OS X
 Manual Page For Time::HiRes(3pm)</title>
<style type="text/css"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { font-size: 1px; background: #ffffff; color: #ffffff; } --></style>
<style type="text/css" media="print, aural, braille, embossed, projection, tty"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { display: none; } --></style>
</head><body bgcolor="white">
<a name="//apple_ref/doc/man/3pm/Time::HiRes" title="Mac OS X
 Manual Page for Time::HiRes(3pm)"><a name="//apple_ref/doc/man/3/Time::HiRes" title="Mac OS X
 Manual Page for Time::HiRes(3pm)"><!-- headerDoc=man; indexgroup=Section 3pm; uid="//apple_ref/doc/man/3pm/Time::HiRes"; name=Time::HiRes(3pm) --></a>
<!--#include virtual="/includes/framesetheader"-->
<table width=600><tr><td scope="row">
<!-- begin breadcrumb insert request --><font face="Geneva,Helvetica,Arial" size="1">
 <a target="_top" href="http://developer.apple.com">ADC Home</a> <b>&gt;</b> <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> <b>&gt;</b> <a href="../../../../../reference/index.html#//apple_ref/doc/uid/TP30001281" target="_top">Reference</a> <b>&gt;</b> <!-- a href="" target="_top" -->Mac OS X<!-- /a --> <b>&gt;</b> <a href="../index.html#//apple_ref/doc/framework/manpages" target="_top">Mac OS X Man Pages</a></font>
<!-- end breadcrumb insert request -->
<p>&nbsp;</p>
</td></tr></table>
<!-- end of header -->
<table border="0"  cellpadding="2" cellspacing="2" width="630pt"><tr><td valign="top" height="12" colspan="5" scope="row">
<p style='text-align:justify;'>This document is a Mac OS X manual page.  Manual pages are a command-line technology
for providing documentation.  You can view these manual pages locally using the
<a href="../man1/man.1.html#//apple_ref/doc/man/1/man">man(1)</a> command.
These manual pages come from many different sources, and thus, have a variety of writing
styles.</p>
<p style='text-align:justify;'>For more information about the manual page format, see the manual page for 
<a href="../man5/manpages.5.html#//apple_ref/doc/man/5/manpages">manpages(5)</a>.</p>
</td></tr></table>
<hr />
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row"><pre class="manpages"><tt>
Time::HiRes(3pm)                      Perl Programmers Reference Guide                      Time::HiRes(3pm)



<b>NAME</b>
       Time::HiRes - High resolution alarm, sleep, gettimeofday, interval timers

<b>SYNOPSIS</b>
         use Time::HiRes qw( usleep ualarm gettimeofday tv_interval nanosleep
                             clock_gettime clock_getres clock_nanosleep clock );

         usleep ($microseconds);
         nanosleep ($nanoseconds);

         ualarm ($microseconds);
         ualarm ($microseconds, $interval_microseconds);

         $t0 = [gettimeofday];
         ($seconds, $microseconds) = gettimeofday;

         $elapsed = tv_interval ( $t0, [$seconds, $microseconds]);
         $elapsed = tv_interval ( $t0, [gettimeofday]);
         $elapsed = tv_interval ( $t0 );

         use Time::HiRes qw ( time alarm sleep );

         $now_fractions = time;
         sleep ($floating_seconds);
         alarm ($floating_seconds);
         alarm ($floating_seconds, $floating_interval);

         use Time::HiRes qw( setitimer getitimer
                             ITIMER_REAL ITIMER_VIRTUAL ITIMER_PROF ITIMER_REALPROF );

         setitimer ($which, $floating_seconds, $floating_interval );
         getitimer ($which);

         $realtime   = clock_gettime(CLOCK_REALTIME);
         $resolution = clock_getres(CLOCK_REALTIME);

         clock_nanosleep(CLOCK_REALTIME, 1.5);
         clock_nanosleep(CLOCK_REALTIME, time() + 10, TIMER_ABSTIME);

         my $ticktock = clock();

<b>DESCRIPTION</b>
       The "Time::HiRes" module implements a Perl interface to the "usleep", "nanosleep", "ualarm", "get-<font color="#ffffff" class="whiteout">timeofday",&nbsp;"gettimeofday",</font>
       timeofday", and "setitimer"/"getitimer" system calls, in other words, high resolution time and
       timers. See the "EXAMPLES" section below and the test scripts for usage; see your system documenta-<font color="#ffffff" class="whiteout">tion&nbsp;documentation</font>
       tion for the description of the underlying "nanosleep" or "usleep", "ualarm", "gettimeofday", and
       "setitimer"/"getitimer" calls.

       If your system lacks "gettimeofday()" or an emulation of it you don't get "gettimeofday()" or the
       one-argument form of "tv_interval()".  If your system lacks all of "nanosleep()", "usleep()",
       "select()", and "poll", you don't get "Time::HiRes::usleep()", "Time::HiRes::nanosleep()", or
       "Time::HiRes::sleep()".  If your system lacks both "ualarm()" and "setitimer()" you don't get
       "Time::HiRes::ualarm()" or "Time::HiRes::alarm()".

       If you try to import an unimplemented function in the "use" statement it will fail at compile time.

       If your subsecond sleeping is implemented with "nanosleep()" instead of "usleep()", you can mix sub-<font color="#ffffff" class="whiteout">second&nbsp;subsecond</font>
       second sleeping with signals since "nanosleep()" does not use signals.  This, however, is not porta-<font color="#ffffff" class="whiteout">ble,&nbsp;portable,</font>
       ble, and you should first check for the truth value of &amp;Time::HiRes::d_nanosleep to see whether you
       have nanosleep, and then carefully read your "nanosleep()" C API documentation for any peculiarities.

       If you are using "nanosleep" for something else than mixing sleeping with signals, give some thought
       to whether Perl is the tool you should be using for work requiring nanosecond accuracies.

       The following functions can be imported from this module.  No functions are exported by default.

       gettimeofday ()
           In array context returns a two-element array with the seconds and microseconds since the epoch.
           In scalar context returns floating seconds like "Time::HiRes::time()" (see below).

       usleep ( $useconds )
           Sleeps for the number of microseconds (millionths of a second) specified.  Returns the number of
           microseconds actually slept.  Can sleep for more than one second, unlike the "usleep" system
           call. Can also sleep for zero seconds, which often works like a <u>thread</u> <u>yield</u>.  See also
           "Time::HiRes::usleep()", "Time::HiRes::sleep()", and "Time::HiRes::clock_nanosleep()".

           Do not expect <u>usleep()</u> to be exact down to one microsecond.

       nanosleep ( $nanoseconds )
           Sleeps for the number of nanoseconds (1e9ths of a second) specified.  Returns the number of
           nanoseconds actually slept (accurate only to microseconds, the nearest thousand of them).  Can
           sleep for more than one second.  Can also sleep for zero seconds, which often works like a <u>thread</u>
           <u>yield</u>.  See also "Time::HiRes::sleep()", "Time::HiRes::usleep()", and
           "Time::HiRes::clock_nanosleep()".

           Do not expect <u>nanosleep()</u> to be exact down to one nanosecond.  Getting even accuracy of one thou-<font color="#ffffff" class="whiteout">sand&nbsp;thousand</font>
           sand nanoseconds is good.

       ualarm ( $useconds [, $interval_useconds ] )
           Issues a "ualarm" call; the $interval_useconds is optional and will be zero if unspecified,
           resulting in "alarm"-like behaviour.

           Note that the interaction between alarms and sleeps is unspecified.

       tv_interval
           tv_interval ( $ref_to_gettimeofday [, $ref_to_later_gettimeofday] )

           Returns the floating seconds between the two times, which should have been returned by "gettime-<font color="#ffffff" class="whiteout">ofday()".&nbsp;"gettimeofday()".</font>
           ofday()". If the second argument is omitted, then the current time is used.

       time ()
           Returns a floating seconds since the epoch. This function can be imported, resulting in a nice
           drop-in replacement for the "time" provided with core Perl; see the "EXAMPLES" below.

           <b>NOTE</b> <b>1</b>: This higher resolution timer can return values either less or more than the core
           "time()", depending on whether your platform rounds the higher resolution timer values up, down,
           or to the nearest second to get the core "time()", but naturally the difference should be never
           more than half a second.  See also "clock_getres", if available in your system.

           <b>NOTE</b> <b>2</b>: Since Sunday, September 9th, 2001 at 01:46:40 AM GMT, when the "time()" seconds since
           epoch rolled over to 1_000_000_000, the default floating point format of Perl and the seconds
           since epoch have conspired to produce an apparent bug: if you print the value of
           "Time::HiRes::time()" you seem to be getting only five decimals, not six as promised (microsec-<font color="#ffffff" class="whiteout">onds).&nbsp;(microseconds).</font>
           onds).  Not to worry, the microseconds are there (assuming your platform supports such granular-<font color="#ffffff" class="whiteout">ity&nbsp;granularity</font>
           ity in the first place).  What is going on is that the default floating point format of Perl only
           outputs 15 digits.  In this case that means ten digits before the decimal separator and five
           after.  To see the microseconds you can use either "printf"/"sprintf" with "%.6f", or the "get-<font color="#ffffff" class="whiteout">timeofday()"&nbsp;"gettimeofday()"</font>
           timeofday()" function in list context, which will give you the seconds and microseconds as two
           separate values.

       sleep ( $floating_seconds )
           Sleeps for the specified amount of seconds.  Returns the number of seconds actually slept (a
           floating point value).  This function can be imported, resulting in a nice drop-in replacement
           for the "sleep" provided with perl, see the "EXAMPLES" below.

           Note that the interaction between alarms and sleeps is unspecified.

       alarm ( $floating_seconds [, $interval_floating_seconds ] )
           The "SIGALRM" signal is sent after the specified number of seconds.  Implemented using
           "ualarm()".  The $interval_floating_seconds argument is optional and will be zero if unspecified,
           resulting in "alarm()"-like behaviour.  This function can be imported, resulting in a nice drop-<font color="#ffffff" class="whiteout">in&nbsp;dropin</font>
           in replacement for the "alarm" provided with perl, see the "EXAMPLES" below.

           <b>NOTE</b> <b>1</b>: With some combinations of operating systems and Perl releases "SIGALRM" restarts
           "select()", instead of interrupting it.  This means that an "alarm()" followed by a "select()"
           may together take the sum of the times specified for the the "alarm()" and the "select()", not
           just the time of the "alarm()".

           Note that the interaction between alarms and sleeps is unspecified.

       setitimer ( $which, $floating_seconds [, $interval_floating_seconds ] )
           Start up an interval timer: after a certain time, a signal arrives, and more signals may keep
           arriving at certain intervals.  To disable an "itimer", use $floating_seconds of zero.  If the
           $interval_floating_seconds is set to zero (or unspecified), the timer is disabled <b>after</b> the next
           delivered signal.

           Use of interval timers may interfere with "alarm()", "sleep()", and "usleep()".  In standard-<font color="#ffffff" class="whiteout">speak&nbsp;standardspeak</font>
           speak the "interaction is unspecified", which means that <u>anything</u> may happen: it may work, it may
           not.

           In scalar context, the remaining time in the timer is returned.

           In list context, both the remaining time and the interval are returned.

           There are usually three or four interval timers available: the $which can be "ITIMER_REAL",
           "ITIMER_VIRTUAL", "ITIMER_PROF", or "ITIMER_REALPROF".  Note that which ones are available
           depends: true UNIX platforms usually have the first three, but (for example) Win32 and Cygwin
           have only "ITIMER_REAL", and only Solaris seems to have "ITIMER_REALPROF" (which is used to pro-<font color="#ffffff" class="whiteout">file&nbsp;profile</font>
           file multithreaded programs).

           "ITIMER_REAL" results in "alarm()"-like behaviour.  Time is counted in <u>real</u> <u>time</u>; that is, wall-<font color="#ffffff" class="whiteout">clock&nbsp;wallclock</font>
           clock time.  "SIGALRM" is delivered when the timer expires.

           "ITIMER_VIRTUAL" counts time in (process) <u>virtual</u> <u>time</u>; that is, only when the process is run-<font color="#ffffff" class="whiteout">ning.&nbsp;running.</font>
           ning.  In multiprocessor/user/CPU systems this may be more or less than real or wallclock time.
           (This time is also known as the <u>user</u> <u>time</u>.)  "SIGVTALRM" is delivered when the timer expires.

           "ITIMER_PROF" counts time when either the process virtual time or when the operating system is
           running on behalf of the process (such as I/O).  (This time is also known as the <u>system</u> <u>time</u>.)
           (The sum of user time and system time is known as the <u>CPU</u> <u>time</u>.)  "SIGPROF" is delivered when the
           timer expires.  "SIGPROF" can interrupt system calls.

           The semantics of interval timers for multithreaded programs are system-specific, and some systems
           may support additional interval timers.  See your "setitimer()" documentation.

       getitimer ( $which )
           Return the remaining time in the interval timer specified by $which.

           In scalar context, the remaining time is returned.

           In list context, both the remaining time and the interval are returned.  The interval is always
           what you put in using "setitimer()".

       clock_gettime ( $which )
           Return as seconds the current value of the POSIX high resolution timer specified by $which.  All
           implementations that support POSIX high resolution timers are supposed to support at least the
           $which value of "CLOCK_REALTIME", which is supposed to return results close to the results of
           "gettimeofday", or the number of seconds since 00:00:00:00 January 1, 1970 Greenwich Mean Time
           (GMT).  Do not assume that CLOCK_REALTIME is zero, it might be one, or something else.  Another
           potentially useful (but not available everywhere) value is "CLOCK_MONOTONIC", which guarantees a
           monotonically increasing time value (unlike <u>time()</u>, which can be adjusted).  See your system doc-<font color="#ffffff" class="whiteout">umentation&nbsp;documentation</font>
           umentation for other possibly supported values.

       clock_getres ( $which )
           Return as seconds the resolution of the POSIX high resolution timer specified by $which.  All
           implementations that support POSIX high resolution timers are supposed to support at least the
           $which value of "CLOCK_REALTIME", see "clock_gettime".

       clock_nanosleep ( $which, $seconds, $flags = 0)
           Sleeps for the number of seconds (1e9ths of a second) specified.  Returns the number of seconds
           actually slept.  The $which is the "clock id", as with <u>clock</u><b>_</b><u>gettime()</u> and <u>clock</u><b>_</b><u>getres()</u>.  The
           flags default to zero but "TIMER_ABSTIME" can specified (must be exported explicitly) which means
           that $nanoseconds is not a time interval (as is the default) but instead an absolute time.  Can
           sleep for more than one second.  Can also sleep for zero seconds, which often works like a <u>thread</u>
           <u>yield</u>.  See also "Time::HiRes::sleep()", "Time::HiRes::usleep()", and "Time::HiRes::nanosleep()".

           Do not expect <u>clock</u><b>_</b><u>nanosleep()</u> to be exact down to one nanosecond.  Getting even accuracy of one
           thousand nanoseconds is good.

       <u>clock()</u>
           Return as seconds the <u>process</u> <u>time</u> (user + system time) spent by the process since the first call
           to <u>clock()</u> (the definition is <b>not</b> "since the start of the process", though if you are lucky these
           times may be quite close to each other, depending on the system).  What this means is that you
           probably need to store the result of your first call to <u>clock()</u>, and subtract that value from the
           following results of <u>clock()</u>.

           The time returned also includes the process times of the terminated child processes for which
           <u>wait()</u> has been executed.  This value is somewhat like the second value returned by the <u>times()</u>
           of core Perl, but not necessarily identical.  Note that due to backward compatibility limitations
           the returned value may wrap around at about 2147 seconds or at about 36 minutes.

<b>EXAMPLES</b>
         use Time::HiRes qw(usleep ualarm gettimeofday tv_interval);

         $microseconds = 750_000;
         usleep($microseconds);

         # signal alarm in 2.5s &amp; every .1s thereafter
         ualarm(2_500_000, 100_000);

         # get seconds and microseconds since the epoch
         ($s, $usec) = gettimeofday();

         # measure elapsed time
         # (could also do by subtracting 2 gettimeofday return values)
         $t0 = [gettimeofday];
         # do bunch of stuff here
         $t1 = [gettimeofday];
         # do more stuff here
         $t0_t1 = tv_interval $t0, $t1;

         $elapsed = tv_interval ($t0, [gettimeofday]);
         $elapsed = tv_interval ($t0); # equivalent code

         #
         # replacements for time, alarm and sleep that know about
         # floating seconds
         #
         use Time::HiRes;
         $now_fractions = Time::HiRes::time;
         Time::HiRes::sleep (2.5);
         Time::HiRes::alarm (10.6666666);

         use Time::HiRes qw ( time alarm sleep );
         $now_fractions = time;
         sleep (2.5);
         alarm (10.6666666);

         # Arm an interval timer to go off first at 10 seconds and
         # after that every 2.5 seconds, in process virtual time

         use Time::HiRes qw ( setitimer ITIMER_VIRTUAL time );

         $SIG{VTALRM} = sub { print time, "\n" };
         setitimer(ITIMER_VIRTUAL, 10, 2.5);

         use Time::HiRes qw( clock_gettime clock_getres CLOCK_REALTIME );
         # Read the POSIX high resolution timer.
         my $high = clock_getres(CLOCK_REALTIME);
         # But how accurate we can be, really?
         my $reso = clock_getres(CLOCK_REALTIME);

         use Time::HiRes qw( clock_nanosleep TIMER_ABSTIME );
         clock_nanosleep(CLOCK_REALTIME, 1e6);
         clock_nanosleep(CLOCK_REALTIME, 2e9, TIMER_ABSTIME);

         use Time::HiRes qw( clock );
         my $clock0 = clock();
         ... # Do something.
         my $clock1 = clock();
         my $clockd = $clock1 - $clock0;

<b>C</b> <b>API</b>
       In addition to the perl API described above, a C API is available for extension writers.  The follow-<font color="#ffffff" class="whiteout">ing&nbsp;following</font>
       ing C functions are available in the modglobal hash:

         name             C prototype
         ---------------  ----------------------<font color="#ffffff" class="whiteout">Time::NVtime&nbsp;---------------------Time::NVtime</font>
         Time::NVtime     double (*)()
         Time::U2time     void (*)(pTHX_ UV ret[2])

       Both functions return equivalent information (like "gettimeofday") but with different representa-<font color="#ffffff" class="whiteout">tions.&nbsp;representations.</font>
       tions.  The names "NVtime" and "U2time" were selected mainly because they are operating system inde-<font color="#ffffff" class="whiteout">pendent.&nbsp;independent.</font>
       pendent.  ("gettimeofday" is Unix-centric, though some platforms like Win32 and VMS have emulations
       for it.)

       Here is an example of using "NVtime" from C:

         double (*myNVtime)(); /* Returns -1 on failure. */
         SV **svp = hv_fetch(PL_modglobal, "Time::NVtime", 12, 0);
         if (!svp)         croak("Time::HiRes is required");
         if (!SvIOK(*svp)) croak("Time::NVtime isn't a function pointer");
         myNVtime = INT2PTR(double(*)(), SvIV(*svp));
         printf("The current time is: %f\n", (*myNVtime)());

<b>DIAGNOSTICS</b>
       <b>negative</b> <b>time</b> <b>not</b> <b>invented</b> <b>yet</b>

       You tried to use a negative time argument.

       <b>internal</b> <b>error:</b> <b>useconds</b> <b>&lt;</b> <b>0</b> <b>(unsigned</b> <b>...</b> <b>signed</b> <b>...)</b>

       Something went horribly wrong-- the number of microseconds that cannot become negative just became
       negative.  Maybe your compiler is broken?

<b>CAVEATS</b>
       Notice that the core "time()" maybe rounding rather than truncating.  What this means is that the
       core "time()" may be reporting the time as one second later than "gettimeofday()" and
       "Time::HiRes::time()".

       Adjusting the system clock (either manually or by services like ntp) may cause problems, especially
       for long running programs that assume a monotonously increasing time (note that all platforms do not
       adjust time as gracefully as UNIX ntp does).  For example in Win32 (and derived platforms like Cygwin
       and MinGW) the <u>Time::HiRes::time()</u> may temporarily drift off from the system clock (and the original
       <u>time()</u>)  by up to 0.5 seconds. Time::HiRes will notice this eventually and recalibrate.  Note that
       since Time::HiRes 1.77 the clock_gettime(CLOCK_MONOTONIC) might help in this (in case your system
       supports CLOCK_MONOTONIC).

<b>SEE</b> <b>ALSO</b>
       Perl modules BSD::Resource, Time::TAI64.

       Your system documentation for "clock_gettime", "clock_settime", "gettimeofday", "getitimer",
       "setitimer", "ualarm".

<b>AUTHORS</b>
       D. Wegscheid &lt;wegscd@whirlpool.com&gt; R. Schertler &lt;roderick@argon.org&gt; J. Hietaniemi &lt;jhi@iki.fi&gt; G.
       Aas &lt;gisle@aas.no&gt;

<b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b>
       Copyright (c) 1996-2002 Douglas E. Wegscheid.  All rights reserved.

       Copyright (c) 2002, 2003, 2004, 2005 Jarkko Hietaniemi.  All rights reserved.

       This program is free software; you can redistribute it and/or modify it under the same terms as Perl
       itself.



perl v5.8.8                                      2001-09-21                                 Time::HiRes(3pm)
</tt></pre>
</td></tr></table>
	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Darwin/Reference/ManPages/man3/Time__HiRes.3pm.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Darwin/Reference/ManPages/man3/Time__HiRes.3pm.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Darwin/Reference/ManPages/man3/Time__HiRes.3pm.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

</body></html>
