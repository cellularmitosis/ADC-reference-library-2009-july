<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>Interface Builder User Guide: Connections and Bindings</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Connections and Bindings"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP40005344-CH7" title="Connections and Bindings"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../index.html#//apple_ref/doc/uid/TP30000440-TP30000436" target="_top">Tools</a> &gt; <a href="../../../InterfaceBuilder-date.html#//apple_ref/doc/uid/TP30000440-TP30000436-TP30000525" target="_top">Interface Builder</a> &gt; <a href="../Introduction/Introduction.html#//apple_ref/doc/uid/TP40005344-CH1-SW1">Interface Builder User Guide</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../ObjectAttributes/ObjectAttributes.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../CodeIntegration/CodeIntegration.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP40005344-CH7-SW1" title="Connections and Bindings"></a><h1>Connections and Bindings</h1><p>For Mac OS X and iPhone OS developers, the ability to connect objects at design time is a key part of the rapid development aspect of applications. Many Cocoa classes use connections to implement basic behaviors, including event handling, window management, focus management, and action dispatch. Connections are therefore an important consideration in the design of your Cocoa and iPhone applications. </p><p>This chapter covers the techniques for creating connections and bindings using Interface Builder. </p><div class="notebox"><a name="//apple_ref/doc/uid/TP40005344-CH7-SW4" title="Note"></a><p><strong>Note:</strong>&nbsp;The information in this chapter applies to nib files developed for Cocoa and iPhone applications only. Carbon applications do not support connections. Instead, Carbon objects must be configured with command IDs that are then used by the underlying code to respond to interactions with views and controls. For more information on configuring Carbon nib files, see <span class="content_text"><a href="../ObjectAttributes/ObjectAttributes.html#//apple_ref/doc/uid/TP40005344-CH20-SW27">“Specifying Carbon Attributes.”</a></span></p></div>
<!-- This template is being used for both PDF and HTML. -->

    
    <h4>In this section:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="ConnectionsandBindings.html#//apple_ref/doc/uid/TP40005344-CH7-SW25">About Connections and Bindings</a>
				
			<br/>
			
        
			
			
				<a href="ConnectionsandBindings.html#//apple_ref/doc/uid/TP40005344-CH7-SW2">Creating and Managing Outlet and Action Connections</a>
				
			<br/>
			
        
			
			
				<a href="ConnectionsandBindings.html#//apple_ref/doc/uid/TP40005344-CH7-SW8">Configuring Cocoa Bindings in Mac OS X</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP40005344-CH7-SW25" title="About Connections and Bindings"></a><h2>About Connections and Bindings</h2><p>There are three fundamental types of connections you can create in a Cocoa or iPhone application: </p><ul class="ul"><li class="li"><p>Outlet connections</p></li><li class="li"><p>Action connections (Mac OS X only)</p></li><li class="li"><p>Event connections (iPhone OS only)</p></li><li class="li"><p>Bindings (Mac OS X only)</p></li></ul><p>An <strong>outlet</strong> connection is a special type of instance variable that you specify in your source files and configure using Interface Builder. You use outlets to store references to important objects in your nib file, such as important views, controls, and controller objects. Your view classes can similarly use outlets to store references to related objects. For example, many Cocoa views use outlets to locate the data formatters, delegates, and contextual menus they should use. Because they are instance variables, you can modify outlets programmatically if you wish, but doing so is unusual. In most cases, you connect an outlet to its target object in Interface Builder and do not change the outlet later.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40005344-CH7-SW27" title="Note"></a><p><strong>Note:</strong>&nbsp;The name “outlet” comes from the notion that when you connect an object to an outlet, you “plug in” the object to that outlet. </p></div><p>An <strong>action</strong> connection is a message-passing relationship between a control and a target object in a Cocoa application. Whenever the user interacts with a control in a predetermined way or selects a menu item from a menu, the control or menu invokes the action method of its associated target object. You can use action methods to perform whatever tasks are needed to respond to the given interaction. For example, if the user clicked an Apply button in a panel, your action method could apply the specified settings to your application’s data structures. Clicking a push button, checking or unchecking a checkbox, or selecting an item from a pop-up menu button are all examples of control interactions that generate action messages. </p><p>An <strong>event</strong> connection is similar in nature to an action connection but is specific to iPhone applications. Controls in the UIKit framework can send different action messages for different types of interactions within a control. For example, a control can send separate messages when the user first touches the control and then subsequently lifts that finger from the screen. In addition each event can have multiple target objects, so that when the event occurs, different action messages are sent to each object. </p><p>Cocoa <strong>bindings</strong> are a way to connect your application’s user interface to its underlying data without writing a lot of glue code to synchronize the two. Bindings take advantage of the key-value coding (KVC) and key-value observing (KVO) protocols to bridge the data in your data structures with the views you create in Interface Builder. Whenever the user changes a value in a view, the bindings code automatically propagates that change down to the associated data structure. Similarly, if your program changes the data by calling an accessor method, the bindings code propagates that change back to the associated view. </p><a name="//apple_ref/doc/uid/TP40005344-CH7-SW2" title="Creating and Managing Outlet and Action Connections"></a><h2>Creating and Managing Outlet and Action Connections</h2><p>You can manage outlet, action, and event connections in Interface Builder using the inspector window or the connections panel. These two tools provide the same basic behavior but do so in slightly different ways. The connections pane of the inspector window displays the connections associated with the currently selected object. Only the connections for the currently selected object are displayed and changing the selection changes the contents of the inspector. The connections panel, on the other hand, is an on-demand window that you can create for one or more objects simultaneously. Unlike the inspector, a connections panel displays the connections for the same object until the panel is dismissed. Its contents do not change to match the current selection.</p><p>The connection creation behavior in Interface Builder is designed to be as flexible as possible. The sections that follow describe the techniques you can use to create connections in your nib files.</p><a name="//apple_ref/doc/uid/TP40005344-CH7-SW14" title="Making Quick Connections By Dragging"></a><h3>Making Quick Connections By Dragging</h3><p>If you want to make a single outlet or action connection quickly, you can do so directly from the design surface or your Interface Builder document window. </p><ol class="ol"><li class="li"><p>Control-click (or right-click) the source object of the connection and do not release the mouse button.</p></li><li class="li"><p>While holding the mouse button, drag to the target object.</p></li><li class="li"><p>Release the mouse button over the target. Interface Builder displays a prospective list of actions and outlets.  </p></li><li class="li"><p>Select the desired outlet (of the source object) or the desired action or event (of the target object) to create the connection. </p></li></ol><p>For action connections in Cocoa, this technique is equivalent to opening the connections panel and configuring the source object’s sent actions connection. Because a source object in Cocoa can send its action message to only one target object, you should use this technique only once to configure a given source object’s action connection. Repeating the process for the same source object would break the old connection before establishing the new one. You can use this technique, however, to configure each of the source object’s outlets. </p><a name="//apple_ref/doc/uid/TP40005344-CH7-SW13" title="Making Connections Using the Connections Panel"></a><h3>Making Connections Using the Connections Panel</h3><p>The connections panel is a convenient way to create multiple connections for the same object in quick succession. To use the connections panel, do the following:</p><ol class="ol"><li class="li"><p>Control-click (or right-click) an object and release the mouse button to display the panel.</p></li><li class="li"><p>Click in the circle to the right of the action, outlet, or event you want to connect and begin dragging.</p></li><li class="li"><p>Drag the mouse over the target object for the connection. (If the target of a connection is not visible, hovering over its parent object causes the parent to open and reveal its children.)</p><p>The target object should highlight to indicate a connection is possible. If it does not highlight, the target object is not of the right type and cannot be connected to the source object in that way.</p></li><li class="li"><p>If the target object highlights, release the mouse button to create the connection. </p></li><li class="li"><p>If you are using the connections panel to configure the sent action or referencing outlet for the object, Interface Builder displays a list of the target object’s action methods or outlets. Select the desired action method or outlet from the list to finish the connection.</p><p>Other types of connections do not require this configuration step.</p></li></ol><p>After you establish a connection, the connections panel fills the circle next to that action or outlet and displays information about the connection. Each connection also includes a close box icon that you can use to break the connection. If a received action has multiple source objects associated with it, the panel displays a disclosure triangle, which you can use to reveal the individual connections. </p><p>The connections panel remains visible as long as you use it. If you click outside the panel (by selecting a different object in your window, for example) Interface Builder dismiss the panel automatically to get it out of your way. You can also dismiss the panel explicitly by clicking its close box. </p><p>If you want to select other objects in your nib file but do not want the connections panel to disappear, simply drag the panel to a new location. (You do not have to drag the window far; even dragging it a single pixel is sufficient.) Dragging the panel lets Interface Builder know that you want to continue using it. If you do this, however, you must dismiss the window yourself by clicking its close box when you are done.  </p><a name="//apple_ref/doc/uid/TP40005344-CH7-SW28" title="Example: Creating Action Connections"></a><h4>Example: Creating Action Connections</h4><p>There are two ways to create connections using the connections panel:</p><ul class="spaceabove"><li class="li"><p>You can start at the source object:</p><ul class="nested"><li class="nested li"><p>For Cocoa applications, connect from the sent action selector.</p></li><li class="nested li"><p>For iPhone applications, connect from one of the specified events. </p></li></ul></li><li class="li"><p>You can start at the target object and connect one of its action methods to the desired source object. </p></li></ul><p>To create a connection starting at the source object, Control-click it to display the connections panel and scroll to the appropriate entry. Click in the circle next to the entry and drag to the desired target object that you want to receive the action or event message, as shown in <span class="content_text">Figure 6-1</span>. When you let go of the mouse over a valid target object, Interface Builder displays a second connections panel that lists the action methods of the target object. Selecting a method from the list completes the connection.</p><br/><div><a name="//apple_ref/doc/uid/TP40005344-CH7-SW5" title="Figure 6-1Connecting from source to target"></a><p><strong>Figure 6-1&nbsp;&nbsp;</strong>Connecting from source to target</p><img src = "../Art/connecting_action1.jpg" alt = "Connecting from source to target" ></div><br/><p>To create a connection starting at the target object (the one that defines the action method), control-click the target object to display its connections panel. Click in the circle next to the desired action method and drag to the source object, as shown in <span class="content_text">Figure 6-2</span>. When dragging from the target to the source object in a Cocoa application, Interface Builder does not need to display a second panel at the source object. For iPhone applications, however, it displays a second panel so that you can choose the event you want to trigger the action message. </p><br/><div><a name="//apple_ref/doc/uid/TP40005344-CH7-SW6" title="Figure 6-2Connecting from target to source"></a><p><strong>Figure 6-2&nbsp;&nbsp;</strong>Connecting from target to source</p><img src = "../Art/connecting_action2.jpg" alt = "Connecting from target to source" ></div><br/><p>When connecting from target to source, you can connect each action method multiple times. After you make the first connection, the circle next to the action method is filled to show that there is an associated source object. To connect an additional source object, simply click in the circle again and drag to the desired object. Performing this action does not remove the original connection. </p><a name="//apple_ref/doc/uid/TP40005344-CH7-SW3" title="Example: Connecting Outlets"></a><h4>Example: Connecting Outlets</h4><p>Like action connections, you can create outlet connections starting at either the source or target object. <span class="content_text">Figure 6-3</span> shows an example of connecting an outlet starting at the outlet’s source, which in this case is the File’s Owner object. Control-clicking the File’s Owner object brings up its connections panel. From there, it is a matter of dragging from the circle next to the window outlet to the window object. </p><br/><div><a name="//apple_ref/doc/uid/TP40005344-CH7-SW10" title="Figure 6-3Connecting an outlet to the target"></a><p><strong>Figure 6-3&nbsp;&nbsp;</strong>Connecting an outlet to the target</p><img src = "../Art/connecting_outlet.jpg" alt = "Connecting an outlet to the target" ></div><br/><div class="notebox"><a name="//apple_ref/doc/uid/TP40005344-CH7-SW30" title="Note"></a><p><strong>Note:</strong>&nbsp;Only one object at a time may be connected to a given outlet.</p></div><p>To connect an outlet starting at the target object, open the connections panel and click in the circle next to the New Referencing Outlet entry. From there, drag to the object that contains the desired outlet and release the mouse over that object. When you release the mouse, Interface Builder prompts you to select the outlet from a list of available outlets on the source object. Selecting an item from that list completes the connection.  </p><a name="//apple_ref/doc/uid/TP40005344-CH7-SW12" title="Making Connections Using the Inspector"></a><h3>Making Connections Using the Inspector</h3><p>The connections pane of the inspector window (<span class="content_text">Figure 6-4</span>) provides a summary of the outlets and actions (or events) of the selected object. You can use the inspector window to view the status of connections, to create new connections, and to break existing connections. </p><br/><div><a name="//apple_ref/doc/uid/TP40005344-CH7-SW7" title="Figure 6-4Connections inspector"></a><p><strong>Figure 6-4&nbsp;&nbsp;</strong>Connections inspector</p><img src = "../Art/insp_connections_pane.jpg" alt = "Connections inspector" ></div><br/><p>To make a connection, do the following: </p><ol class="ol"><li class="li"><p>Select an object and open the connections inspector.</p></li><li class="li"><p>Click in the circle next to the entry you want to connect and hold the mouse button down.</p></li><li class="li"><p>Drag the mouse over the target object for the connection. (If the target of a connection is not visible, hovering over its parent object causes the parent to open and reveal its children.)</p><p>The target object should highlight to indicate a connection is possible. If it does not highlight, the target object is not of the right type and cannot be connected to the source object in that way.</p></li><li class="li"><p>If the target object highlights, release the mouse button to create the connection. </p></li><li class="li"><p>If you are using the connections inspector to configure the sent action or referencing outlet for the object, Interface Builder displays a list of the target object’s action methods or outlets. Select the desired action method or outlet from the list to finish the connection.</p><p>Other types of connections do not require this configuration step.</p></li></ol><p>After you establish a connection, the connections inspector fills the circle next to that entry and displays information about the connection. Each connection also includes a close box icon that you can use to break the connection. If a received action has multiple source objects associated with it, the panel displays a disclosure triangle, which you can use to reveal the individual connections. </p><a name="//apple_ref/doc/uid/TP40005344-CH7-SW31" title="Breaking Connections"></a><h3>Breaking Connections</h3><p>To break a connection using the connections panel, do the following:</p><ol class="ol"><li class="li"><p>Control-click the desired object to display its connections panel.</p></li><li class="li"><p>Locate the outlet or action whose connection you want to break.</p></li><li class="li"><p>Click the "Break connection box” next to the name of the connected object. </p><div class="item_figure"><img src = "../Art/connection_close_box.jpg" alt = "The break connection box." ></div></li></ol><p>An alternative to using the connections panel is to break connections using the inspector window. The connections pane of the inspector window lists all of the connections for the currently selected objects. To break a connection using the inspector window, you select the desired connection and click the disconnect button at the bottom of the inspector pane. For more information about the connections inspector, see <span class="content_text"><a href="ConnectionsandBindings.html#//apple_ref/doc/uid/TP40005344-CH7-SW12">“Making Connections Using the Inspector.”</a></span> </p><a name="//apple_ref/doc/uid/TP40005344-CH7-SW32" title="Establishing Connections to the First Responder"></a><h3>Establishing Connections to the First Responder</h3><p>The First Responder proxy object acts as a placeholder for an object that is determined dynamically at runtime. The AppKit and UIKit frameworks use several factors to determine which object should be the First Responder, including which window is frontmost, which view has the focus, or which view is designated as the initial responder. </p><p>In Cocoa applications, many First Responder actions are initiated by menu items and other objects of your program that operate on the application, the current document, or the frontmost window. Typical actions that are dispatched to the First Responder include the following:</p><ul class="spaceabove"><li class="li"><p>Document-level operations (such as undo, save, and print)</p></li><li class="li"><p>Pasteboard operations</p></li><li class="li"><p>Text-manipulation operations</p></li><li class="li"><p>Selection management operations (such as select all)</p></li><li class="li"><p>Application-level operations (open document, hide, unhide, show help) </p></li><li class="li"><p>Custom actions that you define</p></li></ul><p>In iPhone applications, touch events are delivered to the first responder initially and then passed down the responder chain as needed until an object handles the event. In most cases, the first responder is the view in which a touch occurred, but it can be other views or objects in the application.</p><p>If you have an action message that should be handled by the First Responder, you can use the First Responder proxy object as the target object for your action. By default, the First Responder knows about the action messages supported by the system (if any) and those defined in your Xcode source files. If you want to add new action messages, you must add those messages to the First Responder’s supported list by doing the following:</p><ol class="ol"><li class="li"><p>Select the First Responder proxy object in your Interface Builder document.</p></li><li class="li"><p>Open the inspector window and select the identity pane.</p></li><li class="li"><p>Click the plus (+) button in the First Responder Actions section to create a new action method entry. (The new method name is selected by default.)</p></li><li class="li"><p>Type a new name for the method. (The syntax of the method must match the expected syntax for action methods on the given platform; see <span class="content_text"><a href="../CodeIntegration/CodeIntegration.html#//apple_ref/doc/uid/TP40005344-CH18-SW15">“Defining Action Methods”</a></span> for more information.)</p></li><li class="li"><p>Press Return to save the action method.</p></li><li class="li"><p>Repeat as needed to add additional action methods.</p></li></ol><p>Adding action methods to the First Responder proxy object does not add the corresponding method definition to your Xcode source files. All it does is let Interface Builder know that such a method exists in one of your program’s objects. It is up to you to ensure the method names you add to the First Responder proxy match the names of the methods in your code. Interface Builder does not validate these method names for you. At runtime, if a method name is misspelled or does not exist in an object, the corresponding action message will never be received by the target object.  </p><div class="notebox"><a name="//apple_ref/doc/uid/TP40005344-CH7-SW33" title="Note"></a><p><strong>Note:</strong>&nbsp;The First Responder proxy is only for configuring action messages. You cannot connect the First Responder proxy object to one of your custom outlets in hopes of receiving a dynamically changing pointer to the selected object in your window. In Cocoa applications, you should instead use the <code>firstResponder</code> method of the current <code>NSWindow</code> object to get the first responder. In iPhone applications, there is no single first responder object; the first responder is always the view that is the target of a touch. </p></div><p>Interface Builder does not prevent you from deleting the standard system messages associated with the First Responder proxy. Doing so removes the message name from the current nib file only. </p><a name="//apple_ref/doc/uid/TP40005344-CH7-SW29" title="Connecting Menu Items to Your Code"></a><h3>Connecting Menu Items to Your Code</h3><p>There are two common techniques for handling menu commands in a Cocoa application: </p><ul class="spaceabove"><li class="li"><p>Connect the corresponding menu item to a First Responder method. </p></li><li class="li"><p>Connect the menu item to a method of your custom application object or your application delegate object. </p></li></ul><p>Of these two techniques, the first is somewhat more common given that many menu commands act on the current document or its contents, which are part of the responder chain. The second technique is used primarily to handle commands that are global to the application, such as displaying preferences or creating a new document. It is possible for a custom application object or its delegate to dispatch events to documents, but doing so is generally more cumbersome and prone to errors. </p><p>The behavior for connecting a menu command to an appropriate target is the same as for creating other types of connections. You can use the connections panel or do a quick connection by Control-clicking and dragging from the menu item to the desired target. For information about creating connections using these techniques, see <span class="content_text"><a href="ConnectionsandBindings.html#//apple_ref/doc/uid/TP40005344-CH7-SW13">“Making Connections Using the Connections Panel”</a></span> and <span class="content_text"><a href="ConnectionsandBindings.html#//apple_ref/doc/uid/TP40005344-CH7-SW14">“Making Quick Connections By Dragging.”</a></span>  </p><div class="notebox"><a name="//apple_ref/doc/uid/TP40005344-CH7-SW34" title="Note"></a><p><strong>Note:</strong>&nbsp;In addition to implementing action methods to respond to your menu commands, also remember to implement the methods of the <code>NSMenuValidation</code> protocol to enable the menu items for those commands.</p></div><a name="//apple_ref/doc/uid/TP40005344-CH7-SW8" title="Configuring Cocoa Bindings in Mac OS X"></a><h2>Configuring Cocoa Bindings in Mac OS X</h2><p>Introduced in Mac OS X v10.3, Cocoa bindings are a controller-layer mechanism used to synchronize the view and model layers of your Cocoa application. Bindings establish a mediated connection between a view and a piece of data, binding them in such a way that a change in one is reflected in the other. You can use bindings to replace the traditional glue code (action messages and custom synchronization code) that you would normally write to synchronize your application’s user interface. For example, you might use bindings to tie a property in one of your custom data objects to a text field in your user interface. As the user changes the value in that field, the bindings code automatically updates the corresponding data object; conversely, if you change the property programmatically, bindings propagate the change back to the text field. </p><p>One of the advantages of using bindings over traditional glue code is that you can use Interface Builder to configure them. Objects with bindable properties can expose those properties in Interface Builder through their Interface Builder plug-in object. For each exposed binding, Interface Builder creates an interface that lets the user configure that binding directly using the bindings inspector. The configured bindings are then saved in the nib file and recreated at runtime like other types of connections. </p><p>You configure bindings in Interface Builder by starting at the object that exposes a bindable property. Typically, this object is a Cocoa view or controller object, although you can also expose bindable properties from your own custom objects using an Interface Builder plug-in. You then use the bindings pane of the inspector window to specify the target of the binding and the binding options. You must configure each binding separately and each binding can be attached to a different target object if desired. The target of a binding is always one of the recognized controller objects in your nib file, which typically includes the File’s Owner, the application, the shared user defaults controller, and any custom controller objects (especially <code>NSController</code> objects) you add to the nib file.  </p><p>For more information about how Cocoa bindings work, see <em><a href="../../../../Cocoa/Conceptual/CocoaBindings/index.html#//apple_ref/doc/uid/10000167i" target="_top">Cocoa Bindings Programming Topics</a></em>. </p><div class="notebox"><a name="//apple_ref/doc/uid/TP40005344-CH7-SW41" title="Note"></a><p><strong>Note:</strong>&nbsp;Cocoa bindings are not available in iPhone OS.</p></div><a name="//apple_ref/doc/uid/TP40005344-CH7-SW36" title="Creating a Binding"></a><h3>Creating a Binding</h3><p>In Interface Builder, you typically bind Cocoa views and controller objects in your nib file to the data in your custom controller objects. The high-level process for creating a binding in Interface Builder is as follows:</p><ol class="ol"><li class="li"><p>Create the views needed to display your data.</p></li><li class="li"><p>Create any intermediate controller objects needed to manage your data. (Typical controller objects include instances of your custom <code>NSDocument</code> or <code>NSWindowController</code> subclasses, <code>NSController</code> subclasses, or custom <code>NSObject</code> subclasses that you create to manage your data structures.) </p></li><li class="li"><p>Use the bindings pane of the inspector window (<span class="content_text">Figure 6-5</span>) to configure each desired binding.</p><div class="item_figure"><a name="//apple_ref/doc/uid/TP40005344-CH7-SW26" title="Figure 6-5Bindings inspector"></a><p><strong>Figure 6-5&nbsp;&nbsp;</strong>Bindings inspector</p><img src = "../Art/insp_bindings_pane.jpg" alt = "Bindings inspector" ></div></li></ol><p>Although each binding displays several configuration options, the most important part of a binding is the target of the binding. You must configure, at a minimum, the following fields for any given binding:</p><ul class="spaceabove"><li class="li"><p>Bind to</p></li><li class="li"><p>Model Key Path</p></li></ul><p>The Bind to field specifies the controller object to use as the starting point for accessing the target data. The Model Key Path field contains a string representing the key path for the desired data. Key path strings are of the form <code>&lt;property_name>[.&lt;property_name>]*</code>. The first property name in this string is a property on the controller object specified by the Bind to field. Each subsequent property name corresponds to a property of the object returned by the previous property name. Say, for example, that you have a custom controller object and the key path string “<code>person.address.street</code>“. The <code>person</code> property returns the person object of the bound controller. The <code>address</code> property returns the address of the corresponding person object. And the <code>street</code> property returns the desired data value stored in the address object.</p><p>Because key paths are dependent on your data model, the best way to understand how to configure them in Interface Builder is to go through some examples. The following sections show how to bind a text field to an <code>NSNumber</code> object so as to display the number value in that text field. In each successive example, the data model used to access the number value gets progressively more complex, and so the bindings must be adjusted to compensate for the increased complexity. </p><p>For additional bindings examples, see <em><a href="../../../../Cocoa/Conceptual/CocoaBindings/index.html#//apple_ref/doc/uid/10000167i" target="_top">Cocoa Bindings Programming Topics</a></em>. For information about the key fields in the bindings inspector, see <span class="content_text"><a href="ConnectionsandBindings.html#//apple_ref/doc/uid/TP40005344-CH7-SW15">“Configuring the Attributes of a Binding.”</a></span> </p><a name="//apple_ref/doc/uid/TP40005344-CH7-SW17" title="Binding Directly to the Value"></a><h4>Binding Directly to the Value</h4><p><span class="content_text">Figure 6-6</span> shows a simple relationship between a document object and some data. In this case, the document object contains an instance variable called <code>quantity</code> that contains a pointer to an <code>NSNumber</code> object. (The document also implements the <code>quantity</code> and <code>setQuantity:</code> accessor methods, which are the KVC-compliant methods for accessing the data.) To display the value from <code>quantity</code> in the text field, you would configure the “value” binding for the text field. For this binding, you would set the target object to the document (File's Owner) and the model key path to the string “quantity”.</p><br/><div><a name="//apple_ref/doc/uid/TP40005344-CH7-SW9" title="Figure 6-6A simple bindings example"></a><p><strong>Figure 6-6&nbsp;&nbsp;</strong>A simple bindings example</p><img src = "../Art/bindings_simple.jpg" alt = "A simple bindings example" ></div><br/><div class="notebox"><a name="//apple_ref/doc/uid/TP40005344-CH7-SW37" title="Note"></a><p><strong>Note:</strong>&nbsp;Because Cocoa knows how to convert between many scalar types and their object equivalents, the binding configuration would be the same if you implemented the <code>quantity</code> property as a scalar value. </p></div><a name="//apple_ref/doc/uid/TP40005344-CH7-SW18" title="Binding Through an Intermediate Object"></a><h4>Binding Through an Intermediate Object</h4><p>The following example builds on the example in <span class="content_text"><a href="ConnectionsandBindings.html#//apple_ref/doc/uid/TP40005344-CH7-SW17">“Binding Directly to the Value”</a></span> by introducing an intermediate object between the document and the <code>NSNumber</code> object. In this case, the document now contains an <code>Entry</code> object, which is a generic data object based on the <code>NSObject</code> class.</p><p><span class="content_text">Figure 6-7</span> shows the data model relationships for the document and also shows one way to bind a text field to the <code>quantity</code> attribute of the <code>Entry</code> object. In this case, the text field binds to the document (File's Owner) and has a key path that includes both the <code>entry</code> property of the document and the <code>quantity</code> property of the <code>Entry</code> object. </p><br/><div><a name="//apple_ref/doc/uid/TP40005344-CH7-SW19" title="Figure 6-7Binding through another data object"></a><p><strong>Figure 6-7&nbsp;&nbsp;</strong>Binding through another data object</p><img src = "../Art/bindings_less_simple.jpg" alt = "Binding through another data object" ></div><br/><p>Although the preceding example would work when the document’s <code>entry</code> property is non-<code>nil</code>, a problem arises if <code>entry</code> ever becomes <code>nil</code>. When Cocoa encounters a <code>nil</code> value in the middle of a key path, it generates a runtime error. This error does not abort your program but it does prevent Cocoa from retrieving and setting the bound value, which is certainly undesirable. </p><p>Rather than binding the text field directly to the File’s Owner, as in the previous example, a better solution is to bind the text field to the value through an <code>NSObjectController</code> object. Controller objects act somewhat like a buffer layer between your views and data object. In this case, the controller object acts as a proxy for the document’s current <code>Entry</code> object, providing a valid binding target even if the document’s <code>entry</code> property is <code>nil</code>.</p><p><span class="content_text">Figure 6-8</span> therefore shows the newly introduced object controller and the revised bindings paths. Now, the text field binds to the object controller as if it were the document’s <code>Entry</code> object. The object controller, in turn, binds to the <code>entry</code> property of the document. </p><br/><div><a name="//apple_ref/doc/uid/TP40005344-CH7-SW20" title="Figure 6-8Binding through an object controller"></a><p><strong>Figure 6-8&nbsp;&nbsp;</strong>Binding through an object controller</p><img src = "../Art/bindings_less_simple2.jpg" alt = "Binding through an object controller" ></div><br/><p>Because it knows about controllers and their properties, Interface Builder displays the bindable properties of the selected controller object in the Controller Key popup menu. You typically set the value of this field to either <code>selection</code> or <code>selectedObjects</code>, depending on your needs. To finish your binding, you add the target property in the Model Key Path field, which in this case is <code>quantity</code>. Cocoa combines the strings in the Controller Key and Model Key Path fields to get the final key path. In this case, the final key path would be <code>selection.quantity</code>. </p><a name="//apple_ref/doc/uid/TP40005344-CH7-SW38" title="Binding to a Collection of Objects"></a><h4>Binding to a Collection of Objects</h4><p>Using controller objects, it is as simple to bind to a collection of objects as it is to bind to a single object. In fact, the bindings themselves are almost identical. In the example at hand, instead of binding to a single <code>Entry</code> object, you would bind the text field to a collection of <code>Entry</code> objects through an <code>NSArrayController</code> object. The array controller manages both the collection of objects and the list of indexes corresponding to the selected objects and uses that information to provide an appropriate value to the text field.</p><p><span class="content_text">Figure 6-9</span> shows the data model for the revised document, which now contains an array of <code>Entry</code> objects. You would then bind the text field to an <code>NSArrayController</code> object’s selection property, which represents the currently selected <code>Entry</code> object, and specify the <code>quantity</code> string for the key path to finish the binding. </p><br/><div><a name="//apple_ref/doc/uid/TP40005344-CH7-SW16" title="Figure 6-9Binding to an array of objects"></a><p><strong>Figure 6-9&nbsp;&nbsp;</strong>Binding to an array of objects</p><img src = "../Art/bindings_complex.jpg" alt = "Binding to an array of objects" ></div><br/><p>Although the array controller manages the selection indexes for you, you can bind an <code>NSMutableIndexSet</code> object to the array controller if you want to keep track of the currently selected indexes. You might store the selected index information as part of your document format. You can also use the index set to change the currently selected objects (instead of using the methods of the <code>NSArrayController</code> class). When modifying your bound index set directly, however, you must do so in a KVO-compliant manner by calling the <code>willChangeValueForKey:</code> and <code>didChangeValueForKey:</code> methods before and after you make your changes. If you forget to call these methods, the array controller may not notice your changes. </p><a name="//apple_ref/doc/uid/TP40005344-CH7-SW15" title="Configuring the Attributes of a Binding"></a><h3>Configuring the Attributes of a Binding</h3><p>Although the bindings inspector may seem complex at first, for many bindings, you need to configure only a few options initially.  You may not need to configure every option every time (except for the Bind to and Model Key Path fields). During your initial design phase, you can probably leave most of the options configured with their default values. As you improve your design, you can customize the options more until you have the behavior you want.</p><p><span class="content_text">Table 6-1</span> lists some of the key attributes used in most binding entries. Except where noted otherwise, all attributes are optional. </p><a name="//apple_ref/doc/uid/TP40005344-CH7-SW21" title="Table 6-1Common binding attributes"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 6-1&nbsp;&nbsp;</strong>Common binding attributes</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Binding attribute</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Description</p></th></tr><tr><td  scope="row"><p>Bind to:</p></td><td ><p>(Required) The controller object in your nib file that serves as the starting point of the binding. The first entry in the corresponding key path must correspond to a property in this object.</p></td></tr><tr><td  scope="row"><p>Controller Key</p></td><td ><p>An attribute of an <code>NSController</code> object. When binding to an <code>NSController</code> object, you use this field to select the first entry in the key path. The menu associated with this field displays the properties available on the selected controller object as a convenience. You can type the name of the property or simply select it from the provided list.</p></td></tr><tr><td  scope="row"><p>Model Key Path</p></td><td ><p>(Required) The key path to the desired data value. The string you enter into this field is a period-separated list of keywords, each of which represents a property of an object in the path. The objects and properties represented by this key path must exist or Cocoa will be unable to bind to the value. If you specified a value in the Controller Key field, that value is added to the beginning of this string during resolution of the key path. The format of entries in this field is <code>&lt;property_name>[.&lt;property_name>]*</code>.</p></td></tr><tr><td  scope="row"><p>Value Transformer</p></td><td ><p>The name of the value transformer object you want to use to use with this binding. Value transformers let the Cocoa bindings code adjust unknown data formats to a format compatible with the corresponding view. The name you specify in this field corresponds to the name under which your value transformer object is registered in your code, which may or may not correspond to the actual class name. For more information about creating and using value transformers, see <em><a href="../../../../Cocoa/Conceptual/ValueTransformers/index.html#//apple_ref/doc/uid/10000175i" target="_top">Value Transformer Programming Guide</a></em>.</p></td></tr><tr><td  scope="row"><p>Multiple Values Placeholder</p></td><td ><p>The behavior of a view when the binding is associated with multiple objects. The exact configuration of this field depends on the type of the object exposing the binding. For views and controls, you use this field to specify the default behavior (or value) of the view when multiple objects are selected.</p></td></tr><tr><td  scope="row"><p>No Selection Placeholder</p></td><td ><p>The behavior of a view when the binding is associated with a valid set of objects but none of them are actually selected. The exact configuration of this field depends on the type of the object exposing the binding. For views and controls, you use this field to specify the default behavior (or value) of the view when there is no selection. </p></td></tr><tr><td  scope="row"><p>Not Applicable Placeholder</p></td><td ><p>The behavior of a view when an exception is raised because the key of an object cannot be applied for some reason. This might occur if the specified object is not key-value coding compliant for the specified key. </p></td></tr><tr><td  scope="row"><p>Null Placeholder</p></td><td ><p>The behavior of a view when the binding is associated with a <code>nil</code> object. The exact configuration of this field depends on the type of the object. For views and controls, you can use this field to specify a default value to display. </p></td></tr></table></div><p>For an exact list of bindings available for a given view or controller object, see <em><a href="../../../../Cocoa/Reference/CocoaBindingsRef/index.html#//apple_ref/doc/uid/10000189i" target="_top">Cocoa Bindings Reference</a></em>.</p><a name="//apple_ref/doc/uid/TP40005344-CH7-SW11" title="Using Cocoa Controller Objects"></a><h3>Using Cocoa Controller Objects</h3><p>Although you can bind the views of your user interface to any key-value coding (KVC) and key-value observing (KVO) compliant object, it is strongly recommended that you use an intermediate Cocoa controller object to manage the bindings for you. Cocoa controller objects are instances of the <code>NSController</code> class that manage bindings-related behavior. These objects provide several very important features, including the following:</p><ul class="spaceabove"><li class="li"><p>Controller objects manage their own current selection and placeholder values, providing appropriate values if the selection is empty. </p></li><li class="li"><p>Controller objects implement the <code>NSEditor</code> and <code>NSEditorRegistration</code> protocols, which provide the associated view with a way to negotiate uncommitted changes between itself and the controller. </p></li><li class="li"><p>Controller objects eliminate the need for complex management code. Nearly all of your controller object setup is done in Interface Builder.</p></li><li class="li"><p>Most controllers provide default actions for manipulating the managed content.</p></li></ul><p>Cocoa provides controller objects for managing several different types of data objects. Most of these controllers enable you to manage collections of objects, with the controller object itself managing things like the currently selected objects. <span class="content_text">Table 6-2</span> lists the available controller object classes along with information about when you might use each one and how you configure its attributes. </p><a name="//apple_ref/doc/uid/TP40005344-CH7-SW22" title="Table 6-2Cocoa controller objects"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 6-2&nbsp;&nbsp;</strong>Cocoa controller objects</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Class</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Description</p></th></tr><tr><td  scope="row"><p><code>NSObjectController</code></p></td><td ><p>Manages any single <code>NSObject</code> instance. Use this controller to manage a single custom object and its properties. When configuring the attributes for this controller, the Class Name field (in the attributes pane of the inspector) should contain the class of the object being managed.</p></td></tr><tr><td  scope="row"><p><code>NSArrayController</code></p></td><td ><p>Manages the contents of an <code>NSArray</code> or <code>NSSet</code> object. (You can also use this controller to manage custom data objects that implement ordered sets of data. For more information, see <em><a href="../../../../Cocoa/Conceptual/CocoaBindings/index.html#//apple_ref/doc/uid/10000167i" target="_top">Cocoa Bindings Programming Topics</a></em>.) An array controller tracks not only the contents of the array or set but also the subset of objects in the set that represent the current selection. When configuring the attributes for this controller, the Class Name field (in the attributes pane of the inspector) should contain the class of the objects in the array and not the class of the array itself.</p></td></tr><tr><td  scope="row"><p><code>NSTreeController</code></p></td><td ><p>Manages a custom set of objects organized in a tree structure. When configuring this controller, you must specify the keys used to access child objects in the tree. In addition, the Class Name field (in the attributes pane of the inspector) should contain the class of the objects in the tree. For more information, see <span class="content_text"><a href="ConnectionsandBindings.html#//apple_ref/doc/uid/TP40005344-CH7-SW23">“Configuring an NSTreeController Object.”</a></span> </p></td></tr><tr><td  scope="row"><p><code>NSUserDefaultsController</code></p></td><td ><p>Provides your application with access to the application’s defaults database. You typically use this controller to implement preferences panels by binding the controls in your preferences window to keys in the defaults database. The user defaults controller does not use object class name information. For more information, see <span class="content_text"><a href="ConnectionsandBindings.html#//apple_ref/doc/uid/TP40005344-CH7-SW24">“Using the Shared User Defaults Controller.”</a></span> </p></td></tr><tr><td  scope="row"><p><code>NSDictionaryController</code></p></td><td ><p>Introduced in Mac OS X v10.5, this controller manages the keys and values inside an <code>NSDictionary</code> object. The controller turns the contents of the dictionary into an array of key-value pairs that can be bound to user interface items, such as columns in a table view. For more information about using this object, see <em><a href="../../../../Cocoa/Reference/NSDictionaryController_Class/index.html#//apple_ref/doc/uid/TP40004257" target="_top">NSDictionaryController Class Reference</a></em>.  </p></td></tr></table></div><p>When creating bindings in your nib file, you should always use Cocoa controller objects when you are binding through some intermediate object. In other words, unless you are binding directly to a scalar type, you should probably be using a Cocoa controller object to manage the objects in your binding key path. </p><div class="notebox"><a name="//apple_ref/doc/uid/TP40005344-CH7-SW39" title="Note"></a><p><strong>Note:</strong>&nbsp;Cocoa controller objects are not necessary for managing data in Cocoa objects that store scalar data types, including <code>NSString</code>, <code>NSNumber</code>, and <code>NSValue</code>. You can bind directly to those objects as if they were scalar types.</p></div><p>In the attributes pane of the inspector window, many controllers let you specify a list of key names. These keys represent the properties of the managed object to which clients can bind themselves. Adding keys to this list is a shortcut that eliminates the need to type the key name each time you want to bind to them. Interface Builder displays the key names in the Model Key Path field’s popup menu whenever you bind to the corresponding controller object. To finish the binding, simply select the key from this menu.</p><p>For more information about object management in controllers, see <em><a href="../../../../Cocoa/Conceptual/CocoaBindings/index.html#//apple_ref/doc/uid/10000167i" target="_top">Cocoa Bindings Programming Topics</a></em>. </p><a name="//apple_ref/doc/uid/TP40005344-CH7-SW23" title="Configuring an NSTreeController Object"></a><h3>Configuring an NSTreeController Object</h3><p>If your program contains a custom tree data structure, you can use an <code>NSTreeController</code> object to coordinate bindings to the objects in that data structure. Tree controllers are often used to bind data objects to an <code>NSBrowser</code> or <code>NSOutlineView</code> object in order to display hierarchical sets of data to the user. </p><p>To configure a tree controller object, do the following:</p><ol class="ol"><li class="li"><p>Add the tree controller object to your document and select it.</p></li><li class="li"><p>Open the inspector window and select the attributes pane.</p></li><li class="li"><p>Fill in the Object Controller section.</p><ul class="ul"><li class="li"><p>In Class Name field, specify the class name of the objects in the tree. </p></li><li class="li"><p>Optionally, specify any custom keys of the tree objects that you want to expose in the Model Key Path field of the bindings inspector. </p></li></ul></li><li class="li"><p>Fill in the Tree Controller section.</p><ul class="ul"><li class="li"><p>In the Children field, specify the key path for the property that identifies the child nodes of a given tree object. </p></li><li class="li"><p>In the Count field, specify the key path for the property that indicates how many children a given tree object has. (This key path is optional.)</p></li><li class="li"><p>In the Leaf field, specify the key path for the property that identifies whether the current tree object is a leaf node. (This key path is optional but recommended because it can improve the tree controller’s performance as it navigates your tree at runtime.) </p></li></ul></li></ol><p>For more information on using tree controllers, see <em><a href="../../../../Cocoa/Conceptual/CocoaBindings/index.html#//apple_ref/doc/uid/10000167i" target="_top">Cocoa Bindings Programming Topics</a></em>. </p><a name="//apple_ref/doc/uid/TP40005344-CH7-SW24" title="Using the Shared User Defaults Controller"></a><h3>Using the Shared User Defaults Controller</h3><p>An <code>NSUserDefaultsController</code> object is most often used when implementing a preferences window or in any situation where you want to bind a view to values in the defaults database. Although you can add a new <code>NSUserDefaultsController</code> objects to your nib file, you generally do not need to do so. Interface Builder provides a shared user defaults controller object that you can use to bind to your application’s preferences. </p><p>To use the shared defaults controller to implement your application’s preferences window, you would do the following:</p><ol class="ol"><li class="li"><p>Select the control you want to bind to a preference.</p></li><li class="li"><p>Open the inspector window and select the bindings pane. </p></li><li class="li"><p>In the appropriate binding for your control, set the Bind to field to Shared User Defaults Controller. </p></li><li class="li"><p>In the Model Key Path field, enter the key name of the preference you want to associate with the control. </p></li></ol><p>By default, the shared user defaults controller sets the value in the Controller Key field to "values”. Individual preference values are accessed through this property on the user defaults controller, so you should leave this field configured as is.</p><p>For more information on configuring user defaults bindings, see <span class="content_text"><a href="../../../../Cocoa/Conceptual/CocoaBindings/Concepts/NSUserDefaultsController.html#//apple_ref/doc/uid/TP40001092" target="_top">User Defaults and Bindings</a></span> in <em><a href="../../../../Cocoa/Conceptual/CocoaBindings/index.html#//apple_ref/doc/uid/10000167i" target="_top">Cocoa Bindings Programming Topics</a></em>. </p>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../ObjectAttributes/ObjectAttributes.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../CodeIntegration/CodeIntegration.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2008 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2008-11-19<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/DeveloperTools/Conceptual/IB_UserGuide/ConnectionsandBindings/ConnectionsandBindings.html%3Fid%3DTP40005344-1.3&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/DeveloperTools/Conceptual/IB_UserGuide/ConnectionsandBindings/ConnectionsandBindings.html%3Fid%3DTP40005344-1.3&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/DeveloperTools/Conceptual/IB_UserGuide/ConnectionsandBindings/ConnectionsandBindings.html%3Fid%3DTP40005344-1.3&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>