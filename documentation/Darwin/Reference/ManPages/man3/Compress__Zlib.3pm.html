<html><head><title>Mac OS X
 Manual Page For Compress::Zlib(3pm)</title>
<style type="text/css"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { font-size: 1px; background: #ffffff; color: #ffffff; } --></style>
<style type="text/css" media="print, aural, braille, embossed, projection, tty"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { display: none; } --></style>
</head><body bgcolor="white">
<a name="//apple_ref/doc/man/3pm/Compress::Zlib" title="Mac OS X
 Manual Page for Compress::Zlib(3pm)"><a name="//apple_ref/doc/man/3/Compress::Zlib" title="Mac OS X
 Manual Page for Compress::Zlib(3pm)"><!-- headerDoc=man; indexgroup=Section 3pm; uid="//apple_ref/doc/man/3pm/Compress::Zlib"; name=Compress::Zlib(3pm) --></a>
<!--#include virtual="/includes/framesetheader"-->
<table width=600><tr><td scope="row">
<!-- begin breadcrumb insert request --><font face="Geneva,Helvetica,Arial" size="1">
 <a target="_top" href="http://developer.apple.com">ADC Home</a> <b>&gt;</b> <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> <b>&gt;</b> <a href="../../../../../reference/index.html#//apple_ref/doc/uid/TP30001281" target="_top">Reference</a> <b>&gt;</b> <!-- a href="" target="_top" -->Mac OS X<!-- /a --> <b>&gt;</b> <a href="../index.html#//apple_ref/doc/framework/manpages" target="_top">Mac OS X Man Pages</a></font>
<!-- end breadcrumb insert request -->
<p>&nbsp;</p>
</td></tr></table>
<!-- end of header -->
<table border="0"  cellpadding="2" cellspacing="2" width="630pt"><tr><td valign="top" height="12" colspan="5" scope="row">
<p style='text-align:justify;'>This document is a Mac OS X manual page.  Manual pages are a command-line technology
for providing documentation.  You can view these manual pages locally using the
<a href="../man1/man.1.html#//apple_ref/doc/man/1/man">man(1)</a> command.
These manual pages come from many different sources, and thus, have a variety of writing
styles.</p>
<p style='text-align:justify;'>For more information about the manual page format, see the manual page for 
<a href="../man5/manpages.5.html#//apple_ref/doc/man/5/manpages">manpages(5)</a>.</p>
</td></tr></table>
<hr />
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row"><pre class="manpages"><tt>
Zlib(3)                              User Contributed Perl Documentation                             <!-- a -->Zlib(3)<!-- /a -->



<b>NAME</b>
       Compress::Zlib - Interface to zlib compression library

<b>SYNOPSIS</b>
           use Compress::Zlib ;

           ($d, $status) = deflateInit( [OPT] ) ;
           ($out, $status) = $d-&gt;deflate($buffer) ;
           $status = $d-&gt;deflateParams([OPT]) ;
           ($out, $status) = $d-&gt;flush() ;
           $d-&gt;dict_adler() ;
           $d-&gt;total_in() ;
           $d-&gt;total_out() ;
           $d-&gt;msg() ;

           ($i, $status) = inflateInit( [OPT] ) ;
           ($out, $status) = $i-&gt;inflate($buffer) ;
           $status = $i-&gt;inflateSync($buffer) ;
           $i-&gt;dict_adler() ;
           $i-&gt;total_in() ;
           $i-&gt;total_out() ;
           $i-&gt;msg() ;

           $dest = compress($source, [$level]) ;
           $dest = uncompress($source) ;

           $gz = gzopen($filename or filehandle, $mode) ;
           $bytesread = $gz-&gt;gzread($buffer [,$size]) ;
           $bytesread = $gz-&gt;gzreadline($line) ;
           $byteswritten = $gz-&gt;gzwrite($buffer) ;
           $status = $gz-&gt;gzflush($flush) ;
           $status = $gz-&gt;gzclose() ;
           $status = $gz-&gt;gzeof() ;
           $status = $gz-&gt;gzsetparams($level, $strategy) ;
           $errstring = $gz-&gt;gzerror() ;
           $gzerrno

           $dest = Compress::Zlib::memGzip($buffer) ;
           $dest = Compress::Zlib::memGunzip($buffer) ;

           $crc = adler32($buffer [,$crc]) ;
           $crc = crc32($buffer [,$crc]) ;

           ZLIB_VERSION

<b>DESCRIPTION</b>
       The <u>Compress::Zlib</u> module provides a Perl interface to the <u>zlib</u> compression library (see "AUTHOR" for
       details about where to get <u>zlib</u>). Most of the functionality provided by <u>zlib</u> is available in
       <u>Compress::Zlib</u>.

       The module can be split into two general areas of functionality, namely in-memory
       compression/decompression and read/write access to <u>gzip</u> files. Each of these areas will be discussed
       separately below.

<b>DEFLATE</b>
       The interface <u>Compress::Zlib</u> provides to the in-memory <u>deflate</u> (and <u>inflate</u>) functions has been
       modified to fit into a Perl model.

       The main difference is that for both inflation and deflation, the Perl interface will <u>always</u> consume
       the complete input buffer before returning. Also the output buffer returned will be automatically
       grown to fit the amount of output available.

       Here is a definition of the interface available:

       <b>($d,</b> <b>$status)</b> <b>=</b> <b>deflateInit(</b> <b>[OPT]</b> <b>)</b>

       Initialises a deflation stream.

       It combines the features of the <u>zlib</u> functions <b>deflateInit</b>, <b>deflateInit2</b> and <b>deflateSetDictionary</b>.

       If successful, it will return the initialised deflation stream, <b>$d</b> and <b>$status</b> of "Z_OK" in a list
       context. In scalar context it returns the deflation stream, <b>$d</b>, only.

       If not successful, the returned deflation stream (<b>$d</b>) will be <u>undef</u> and <b>$status</b> will hold the exact
       <u>zlib</u> error code.

       The function optionally takes a number of named options specified as "-Name=&gt;value" pairs. This
       allows individual options to be tailored without having to specify them all in the parameter list.

       For backward compatibility, it is also possible to pass the parameters as a reference to a hash
       containing the name=&gt;value pairs.

       The function takes one optional parameter, a reference to a hash.  The contents of the hash allow the
       deflation interface to be tailored.

       Here is a list of the valid options:

       <b>-Level</b>
            Defines the compression level. Valid values are 0 through 9, "Z_NO_COMPRESSION", "Z_BEST_SPEED",
            "Z_BEST_COMPRESSION", and "Z_DEFAULT_COMPRESSION".

            The default is "-Level =&gt;Z_DEFAULT_COMPRESSION".

       <b>-Method</b>
            Defines the compression method. The only valid value at present (and the default) is "-Method
            =&gt;Z_DEFLATED".

       <b>-WindowBits</b>
            For a definition of the meaning and valid values for <b>WindowBits</b> refer to the <u>zlib</u> documentation
            for <u>deflateInit2</u>.

            Defaults to "-WindowBits =&gt;MAX_WBITS".

       <b>-MemLevel</b>
            For a definition of the meaning and valid values for <b>MemLevel</b> refer to the <u>zlib</u> documentation
            for <u>deflateInit2</u>.

            Defaults to "-MemLevel =&gt;MAX_MEM_LEVEL".

       <b>-Strategy</b>
            Defines the strategy used to tune the compression. The valid values are "Z_DEFAULT_STRATEGY",
            "Z_FILTERED" and "Z_HUFFMAN_ONLY".

            The default is "-Strategy =&gt;Z_DEFAULT_STRATEGY".

       <b>-Dictionary</b>
            When a dictionary is specified <u>Compress::Zlib</u> will automatically call <b>deflateSetDictionary</b>
            directly after calling <b>deflateInit</b>. The Adler32 value for the dictionary can be obtained by
            calling the method "$d-"<u>dict</u><b>_</b><u>adler()&gt;</u>.

            The default is no dictionary.

       <b>-Bufsize</b>
            Sets the initial size for the deflation buffer. If the buffer has to be reallocated to increase
            the size, it will grow in increments of <b>Bufsize</b>.

            The default is 4096.

       Here is an example of using the <b>deflateInit</b> optional parameter list to override the default buffer
       size and compression level. All other options will take their default values.

           deflateInit( -Bufsize =&gt; 300,
                        -Level =&gt; Z_BEST_SPEED  ) ;

       <b>($out,</b> <b>$status)</b> <b>=</b> <u></u><b><u>$</u></b><b>-&gt;deflate($buffer)</b>

       Deflates the contents of <b>$buffer</b>. The buffer can either be a scalar or a scalar reference.  When
       finished, <b>$buffer</b> will be completely processed (assuming there were no errors). If the deflation was
       successful it returns the deflated output, <b>$out</b>, and a status value, <b>$status</b>, of "Z_OK".

       On error, <b>$out</b> will be <u>undef</u> and <b>$status</b> will contain the <u>zlib</u> error code.

       In a scalar context <b>deflate</b> will return <b>$out</b> only.

       As with the <u>deflate</u> function in <u>zlib</u>, it is not necessarily the case that any output will be produced
       by this method. So don't rely on the fact that <b>$out</b> is empty for an error test.

       <b>($out,</b> <b>$status)</b> <b>=</b> <u></u><b><u>$</u></b><b>-&gt;flush([flush_type])</b>

       Typically used to finish the deflation. Any pending output will be returned via <b>$out</b>.  <b>$status</b> will
       have a value "Z_OK" if successful.

       In a scalar context <b>flush</b> will return <b>$out</b> only.

       Note that flushing can seriously degrade the compression ratio, so it should only be used to
       terminate a decompression (using "Z_FINISH") or when you want to create a <u>full</u> <u>flush</u> <u>point</u> (using
       "Z_FULL_FLUSH").

       By default the "flush_type" used is "Z_FINISH". Other valid values for "flush_type" are "Z_NO_FLUSH",
       "Z_PARTIAL_FLUSH", "Z_SYNC_FLUSH" and "Z_FULL_FLUSH". It is strongly recommended that you only set
       the "flush_type" parameter if you fully understand the implications of what it does. See the "zlib"
       documentation for details.

       <b>$status</b> <b>=</b> <u></u><b><u>$</u></b><b>-&gt;deflateParams([OPT])</b>

       Change settings for the deflate stream $d.

       The list of the valid options is shown below. Options not specified will remain unchanged.

       <b>-Level</b>
            Defines the compression level. Valid values are 0 through 9, "Z_NO_COMPRESSION", "Z_BEST_SPEED",
            "Z_BEST_COMPRESSION", and "Z_DEFAULT_COMPRESSION".

       <b>-Strategy</b>
            Defines the strategy used to tune the compression. The valid values are "Z_DEFAULT_STRATEGY",
            "Z_FILTERED" and "Z_HUFFMAN_ONLY".

       <b>$d-&gt;</b><u></u><b><u>d</u></b><u></u><b><u>c</u></b><b>_</b><u></u><b><u>a</u></b><u></u><b><u>l</u></b><u></u><b><u>r</u></b><u></u><b><u>)</u></b>

       Returns the adler32 value for the dictionary.

       <b>$d-&gt;</b><u></u><b><u>m</u></b><u></u><b><u>g</u></b><u></u><b><u>)</u></b>

       Returns the last error message generated by zlib.

       <b>$d-&gt;</b><u></u><b><u>t</u></b><u></u><b><u>t</u></b><u></u><b><u>l</u></b><b>_</b><u></u><b><u>i</u></b><u></u><b><u>(</u></b>

       Returns the total number of bytes uncompressed bytes input to deflate.

       <b>$d-&gt;</b><u></u><b><u>t</u></b><u></u><b><u>t</u></b><u></u><b><u>l</u></b><b>_</b><u></u><b><u>o</u></b><u></u><b><u>t</u></b><u></u><b><u>)</u></b>

       Returns the total number of compressed bytes output from deflate.

       <b>Example</b>

       Here is a trivial example of using <b>deflate</b>. It simply reads standard input, deflates it and writes it
       to standard output.

           use strict ;
           use warnings ;

           use Compress::Zlib ;

           binmode STDIN;
           binmode STDOUT;
           my $x = deflateInit()
              or die "Cannot create a deflation stream\n" ;

           my ($output, $status) ;
           while (&lt;&gt;)
           {
               ($output, $status) = $x-&gt;deflate($_) ;

               $status == Z_OK
                   or die "deflation failed\n" ;

               print $output ;
           }

           ($output, $status) = $x-&gt;flush() ;

           $status == Z_OK
               or die "deflation failed\n" ;

           print $output ;

<b>INFLATE</b>
       Here is a definition of the interface:

       <b>($i,</b> <b>$status)</b> <b>=</b> <u></u><b><u>i</u></b><u></u><b><u>f</u></b><u></u><b><u>a</u></b><u></u><b><u>e</u></b><u></u><b><u>n</u></b><u></u><b><u>t</u></b><u></u><b><u>)</u></b>

       Initialises an inflation stream.

       In a list context it returns the inflation stream, <b>$i</b>, and the <u>zlib</u> status code (<b>$status</b>). In a
       scalar context it returns the inflation stream only.

       If successful, <b>$i</b> will hold the inflation stream and <b>$status</b> will be "Z_OK".

       If not successful, <b>$i</b> will be <u>undef</u> and <b>$status</b> will hold the <u>zlib</u> error code.

       The function optionally takes a number of named options specified as "-Name=&gt;value" pairs. This
       allows individual options to be tailored without having to specify them all in the parameter list.

       For backward compatibility, it is also possible to pass the parameters as a reference to a hash
       containing the name=&gt;value pairs.

       The function takes one optional parameter, a reference to a hash.  The contents of the hash allow the
       deflation interface to be tailored.

       Here is a list of the valid options:

       <b>-WindowBits</b>
            For a definition of the meaning and valid values for <b>WindowBits</b> refer to the <u>zlib</u> documentation
            for <u>inflateInit2</u>.

            Defaults to "-WindowBits =&gt;MAX_WBITS".

       <b>-Bufsize</b>
            Sets the initial size for the inflation buffer. If the buffer has to be reallocated to increase
            the size, it will grow in increments of <b>Bufsize</b>.

            Default is 4096.

       <b>-Dictionary</b>
            The default is no dictionary.

       Here is an example of using the <b>inflateInit</b> optional parameter to override the default buffer size.

           inflateInit( -Bufsize =&gt; 300 ) ;

       <b>($out,</b> <b>$status)</b> <b>=</b> <u></u><b><u>$</u></b><b>-&gt;inflate($buffer)</b>

       Inflates the complete contents of <b>$buffer</b>. The buffer can either be a scalar or a scalar reference.

       Returns "Z_OK" if successful and "Z_STREAM_END" if the end of the compressed data has been
       successfully reached.  If not successful, <b>$out</b> will be <u>undef</u> and <b>$status</b> will hold the <u>zlib</u> error
       code.

       The $buffer parameter is modified by "inflate". On completion it will contain what remains of the
       input buffer after inflation. This means that $buffer will be an empty string when the return status
       is "Z_OK". When the return status is "Z_STREAM_END" the $buffer parameter will contains what (if
       anything) was stored in the input buffer after the deflated data stream.

       This feature is useful when processing a file format that encapsulates a  compressed data stream
       (e.g. gzip, zip).

       <b>$status</b> <b>=</b> <u></u><b><u>$</u></b><b>-&gt;inflateSync($buffer)</b>

       Scans $buffer until it reaches either a <u>full</u> <u>flush</u> <u>point</u> or the end of the buffer.

       If a <u>full</u> <u>flush</u> <u>point</u> is found, "Z_OK" is returned and $buffer will be have all data up to the flush
       point removed. This can then be passed to the "deflate" method.

       Any other return code means that a flush point was not found. If more data is available,
       "inflateSync" can be called repeatedly with more compressed data until the flush point is found.

       <b>$i-&gt;</b><u></u><b><u>d</u></b><u></u><b><u>c</u></b><b>_</b><u></u><b><u>a</u></b><u></u><b><u>l</u></b><u></u><b><u>r</u></b><u></u><b><u>)</u></b>

       Returns the adler32 value for the dictionary.

       <b>$i-&gt;</b><u></u><b><u>m</u></b><u></u><b><u>g</u></b><u></u><b><u>)</u></b>

       Returns the last error message generated by zlib.

       <b>$i-&gt;</b><u></u><b><u>t</u></b><u></u><b><u>t</u></b><u></u><b><u>l</u></b><b>_</b><u></u><b><u>i</u></b><u></u><b><u>(</u></b>

       Returns the total number of bytes compressed bytes input to inflate.

       <b>$i-&gt;</b><u></u><b><u>t</u></b><u></u><b><u>t</u></b><u></u><b><u>l</u></b><b>_</b><u></u><b><u>o</u></b><u></u><b><u>t</u></b><u></u><b><u>)</u></b>

       Returns the total number of uncompressed bytes output from inflate.

       <b>Example</b>

       Here is an example of using <b>inflate</b>.

           use strict ;
           use warnings ;

           use Compress::Zlib ;

           my $x = inflateInit()
              or die "Cannot create a inflation stream\n" ;

           my $input = '' ;
           binmode STDIN;
           binmode STDOUT;

           my ($output, $status) ;
           while (read(STDIN, $input, 4096))
           {
               ($output, $status) = $x-&gt;inflate(\$input) ;

               print $output
                   if $status == Z_OK or $status == Z_STREAM_END ;

               last if $status != Z_OK ;
           }

           die "inflation failed\n"
               unless $status == Z_STREAM_END ;

<b>COMPRESS/UNCOMPRESS</b>
       Two high-level functions are provided by <u>zlib</u> to perform in-memory compression/uncompression of
       RFC1950 data streams. They are called <b>compress</b> and <b>uncompress</b>.

       The two Perl subs defined below provide the equivalent functionality.

       <b>$dest</b> <b>=</b> <b>compress($source</b> <b>[,</b> <u></u><b><u>$</u></b><u></u><b><u>e</u></b><u></u><b><u>e</u></b><b>]</b> <b>)</b> <b>;</b>
            Compresses <b>$source</b>. If successful it returns the compressed data. Otherwise it returns <u>undef</u>.

            The source buffer can either be a scalar or a scalar reference.

            The <b>$level</b> paramter defines the compression level. Valid values are 0 through 9,
            "Z_NO_COMPRESSION", "Z_BEST_SPEED", "Z_BEST_COMPRESSION", and "Z_DEFAULT_COMPRESSION".  If
            <b>$level</b> is not specified "Z_DEFAULT_COMPRESSION" will be used.

       <b>$dest</b> <b>=</b> <b>uncompress($source)</b> <b>;</b>
            Uncompresses <b>$source</b>. If successful it returns the uncompressed data. Otherwise it returns
            <u>undef</u>.

            The source buffer can either be a scalar or a scalar reference.

       Please note: the two functions defined above are <u>not</u> compatible with the Unix commands of the same
       name.

<b>GZIP</b> <b>INTERFACE</b>
       A number of functions are supplied in <u>zlib</u> for reading and writing <u>gzip</u> files. This module provides
       an interface to most of them. In general the interface provided by this module operates identically
       to the functions provided by <u>zlib</u>. Any differences are explained below.

       <b>$gz</b> <b>=</b> <b>gzopen(filename</b> <b>or</b> <b>filehandle,</b> <b>mode)</b>
            This function operates identically to the <u>zlib</u> equivalent except that it returns an object which
            is used to access the other <u>gzip</u> methods.

            As with the <u>zlib</u> equivalent, the <b>mode</b> parameter is used to specify both whether the file is
            opened for reading or writing and to optionally specify a a compression level. Refer to the <u>zlib</u>
            documentation for the exact format of the <b>mode</b> parameter.

            If a reference to an open filehandle is passed in place of the filename, gzdopen will be called
            behind the scenes. The third example at the end of this section, <u>gzstream</u>, uses this feature.

       <b>$bytesread</b> <b>=</b> <u></u><b><u>$</u></b><u></u><b><u>z</u></b><b>-&gt;gzread($buffer</b> <b>[,</b> <b>$size])</b> <b>;</b>
            Reads <b>$size</b> bytes from the compressed file into <b>$buffer</b>. If <b>$size</b> is not specified, it will
            default to 4096. If the scalar <b>$buffer</b> is not large enough, it will be extended automatically.

            Returns the number of bytes actually read. On EOF it returns 0 and in the case of an error, -1.

       <b>$bytesread</b> <b>=</b> <u></u><b><u>$</u></b><u></u><b><u>z</u></b><b>-&gt;gzreadline($line)</b> <b>;</b>
            Reads the next line from the compressed file into <b>$line</b>.

            Returns the number of bytes actually read. On EOF it returns 0 and in the case of an error, -1.

            It is legal to intermix calls to <b>gzread</b> and <b>gzreadline</b>.

            At this time <b>gzreadline</b> ignores the variable $/ ($INPUT_RECORD_SEPARATOR or $RS when "English"
            is in use). The end of a line is denoted by the C character '\n'.

       <b>$byteswritten</b> <b>=</b> <u></u><b><u>$</u></b><u></u><b><u>z</u></b><b>-&gt;gzwrite($buffer)</b> <b>;</b>
            Writes the contents of <b>$buffer</b> to the compressed file. Returns the number of bytes actually
            written, or 0 on error.

       <b>$status</b> <b>=</b> <u></u><b><u>$</u></b><u></u><b><u>z</u></b><b>-&gt;gzflush($flush)</b> <b>;</b>
            Flushes all pending output to the compressed file.  Works identically to the <u>zlib</u> function it
            interfaces to. Note that the use of <b>gzflush</b> can degrade compression.

            Returns "Z_OK" if <b>$flush</b> is "Z_FINISH" and all output could be flushed. Otherwise the zlib error
            code is returned.

            Refer to the <u>zlib</u> documentation for the valid values of <b>$flush</b>.

       <b>$status</b> <b>=</b> <u></u><b><u>$</u></b><u></u><b><u>z</u></b><b>-&gt;</b><u></u><b><u>g</u></b><u></u><b><u>e</u></b><u></u><b><u>f</u></b><u></u><b><u>)</u></b> <b>;</b>
            Returns 1 if the end of file has been detected while reading the input file, otherwise returns
            0.

       <b>$gz-&gt;gzclose</b>
            Closes the compressed file. Any pending data is flushed to the file before it is closed.

       <b>$gz-&gt;gzsetparams($level,</b> <u></u><b><u>$</u></b><u></u><b><u>t</u></b><u></u><b><u>a</u></b><u></u><b><u>e</u></b><u></u><b><u>y</u></b>
            Change settings for the deflate stream $gz.

            The list of the valid options is shown below. Options not specified will remain unchanged.

            Note: This method is only available if you are running zlib 1.0.6 or better.

            <b>$level</b>
                 Defines the compression level. Valid values are 0 through 9, "Z_NO_COMPRESSION",
                 "Z_BEST_SPEED", "Z_BEST_COMPRESSION", and "Z_DEFAULT_COMPRESSION".

            <b>$strategy</b>
                 Defines the strategy used to tune the compression. The valid values are
                 "Z_DEFAULT_STRATEGY", "Z_FILTERED" and "Z_HUFFMAN_ONLY".

       <b>$gz-&gt;gzerror</b>
            Returns the <u>zlib</u> error message or number for the last operation associated with <b>$gz</b>. The return
            value will be the <u>zlib</u> error number when used in a numeric context and the <u>zlib</u> error message
            when used in a string context. The <u>zlib</u> error number constants, shown below, are available for
            use.

                Z_OK
                Z_STREAM_END
                Z_ERRNO
                Z_STREAM_ERROR
                Z_DATA_ERROR
                Z_MEM_ERROR
                Z_BUF_ERROR

       <b>$gzerrno</b>
            The <b>$gzerrno</b> scalar holds the error code associated with the most recent <u>gzip</u> routine. Note that
            unlike <u></u><b><u>g</u></b><u></u><b><u>e</u></b><u></u><b><u>r</u></b><u></u><b><u>r</u></b><u></u><b><u>)</u></b>, the error is <u>not</u> associated with a particular file.

            As with <u></u><b><u>g</u></b><u></u><b><u>e</u></b><u></u><b><u>r</u></b><u></u><b><u>r</u></b><u></u><b><u>)</u></b> it returns an error number in numeric context and an error message in string
            context. Unlike <u></u><b><u>g</u></b><u></u><b><u>e</u></b><u></u><b><u>r</u></b><u></u><b><u>r</u></b><u></u><b><u>)</u></b> though, the error message will correspond to the <u>zlib</u> message when the
            error is associated with <u>zlib</u> itself, or the UNIX error message when it is not (i.e. <u>zlib</u>
            returned "Z_ERRORNO").

            As there is an overlap between the error numbers used by <u>zlib</u> and UNIX, <b>$gzerrno</b> should only be
            used to check for the presence of <u>an</u> error in numeric context. Use <u></u><b><u>g</u></b><u></u><b><u>e</u></b><u></u><b><u>r</u></b><u></u><b><u>r</u></b><u></u><b><u>)</u></b> to check for
            specific <u>zlib</u> errors. The <u>gzcat</u> example below shows how the variable can be used safely.

       <b>Examples</b>

       Here is an example script which uses the interface. It implements a <u>gzcat</u> function.

           use strict ;
           use warnings ;

           use Compress::Zlib ;

           die "Usage: gzcat file...\n"
               unless @ARGV ;

           my $file ;

           foreach $file (@ARGV) {
               my $buffer ;

               my $gz = gzopen($file, "rb")
                    or die "Cannot open $file: $gzerrno\n" ;

               print $buffer while $gz-&gt;gzread($buffer) &gt; 0 ;

               die "Error reading from $file: $gzerrno" . ($gzerrno+0) . "\n"
                   if $gzerrno != Z_STREAM_END ;

               $gz-&gt;gzclose() ;
           }

       Below is a script which makes use of <b>gzreadline</b>. It implements a very simple <u>grep</u> like script.

           use strict ;
           use warnings ;

           use Compress::Zlib ;

           die "Usage: gzgrep pattern file...\n"
               unless @ARGV &gt;= 2;

           my $pattern = shift ;

           my $file ;

           foreach $file (@ARGV) {
               my $gz = gzopen($file, "rb")
                    or die "Cannot open $file: $gzerrno\n" ;

               while ($gz-&gt;gzreadline($_) &gt; 0) {
                   print if /$pattern/ ;
               }

               die "Error reading from $file: $gzerrno\n"
                   if $gzerrno != Z_STREAM_END ;

               $gz-&gt;gzclose() ;
           }

       This script, <u>gzstream</u>, does the opposite of the <u>gzcat</u> script above. It reads from standard input and
       writes a gzip file to standard output.

           use strict ;
           use warnings ;

           use Compress::Zlib ;

           binmode STDOUT;     # gzopen only sets it on the fd

           my $gz = gzopen(\*STDOUT, "wb")
                 or die "Cannot open stdout: $gzerrno\n" ;

           while (&lt;&gt;) {
               $gz-&gt;gzwrite($_)
               or die "error writing: $gzerrno\n" ;
           }

           $gz-&gt;gzclose ;

       <b>Compress::Zlib::memGzip</b>

       This function is used to create an in-memory gzip file.  It creates a minimal gzip header.

           $dest = Compress::Zlib::memGzip($buffer) ;

       If successful, it returns the in-memory gzip file, otherwise it returns undef.

       The buffer parameter can either be a scalar or a scalar reference.

       <b>Compress::Zlib::memGunzip</b>

       This function is used to uncompress an in-memory gzip file.

           $dest = Compress::Zlib::memGunzip($buffer) ;

       If successful, it returns the uncompressed gzip file, otherwise it returns undef.

       The buffer parameter can either be a scalar or a scalar reference. The contents of the buffer
       parameter are destroyed after calling this function.

<b>CHECKSUM</b> <b>FUNCTIONS</b>
       Two functions are provided by <u>zlib</u> to calculate a checksum. For the Perl interface, the order of the
       two parameters in both functions has been reversed. This allows both running checksums and one off
       calculations to be done.

           $crc = adler32($buffer [,$crc]) ;
           $crc = crc32($buffer [,$crc]) ;

       The buffer parameters can either be a scalar or a scalar reference.

       If the $crc parameters is "undef", the crc value will be reset.

<b>FAQ</b>
       <b>Compatibility</b> <b>with</b> <b>Unix</b> <b>compress/uncompress.</b>

       Although "Compress::Zlib" has a pair of functions called "compress" and "uncompress", they are <u>not</u>
       the same as the Unix programs of the same name. The "Compress::Zlib" library is not compatable with
       Unix "compress".

       If you have the "uncompress" program available, you can use this to read compressed files

           open F, "uncompress -c $filename |";
           while (&lt;F&gt;)
           {
               ...

       If you have the "gunzip" program available, you can use this to read compressed files

           open F, "gunzip -c $filename |";
           while (&lt;F&gt;)
           {
               ...

       and this to write compress files if you have the "compress" program available

           open F, "| compress -c $filename ";
           print F "data";
           ...
           close F ;

       <b>Accessing</b> <b>.tar.Z</b> <b>files</b>

       The "Archive::Tar" module can optionally use "Compress::Zlib" (via the "IO::Zlib" module) to access
       tar files that have been compressed with "gzip". Unfortunately tar files compressed with the Unix
       "compress" utility cannot be read by "Compress::Zlib" and so cannot be directly accesses by
       "Archive::Tar".

       If the "uncompress" or "gunzip" programs are available, you can use one of these workarounds to read
       ".tar.Z" files from "Archive::Tar"

       Firstly with "uncompress"

           use strict;
           use warnings;
           use Archive::Tar;

           open F, "uncompress -c $filename |";
           my $tar = Archive::Tar-&gt;new(*F);
           ...

       and this with "gunzip"

           use strict;
           use warnings;
           use Archive::Tar;

           open F, "gunzip -c $filename |";
           my $tar = Archive::Tar-&gt;new(*F);
           ...

       Similarly, if the "compress" program is available, you can use this to write a ".tar.Z" file

           use strict;
           use warnings;
           use Archive::Tar;
           use IO::File;

           my $fh = newIO::File "| compress -c &gt;$filename";
           my $tar = Archive::Tar-&gt;new();
           ...
           $tar-&gt;write($fh);
           $fh-&gt;close ;

       <b>Accessing</b> <b>ZIP</b> <b>Files</b>

       Although it is possible to use this module to access .zip files, there is a module on CPAN that will
       do all the hard work for you. Check out

           <a href="http://www.cpan.org/modules/by-module/Archive/Archive-Zip-*.tar.gz">http://www.cpan.org/modules/by-module/Archive/Archive-Zip-*.tar.gz</a>

       Assuming you don't want to use this module to access zip files there are a number of undocumented
       features in the zlib library you need to be aware of.

       1.   When calling <b>inflateInit</b> or <b>deflateInit</b> the <b>WindowBits</b> parameter must be set to "-MAX_WBITS".
            This disables the creation of the zlib header.

       2.   The zlib function <b>inflate</b>, and so the <b>inflate</b> method supplied in this module, assume that there
            is at least one trailing byte after the compressed data stream. Normally this isn't a problem
            because both the gzip and zip file formats will guarantee that there is data directly after the
            compressed data stream.

<b>CONSTANTS</b>
       All the <u>zlib</u> constants are automatically imported when you make use of <u>Compress::Zlib</u>.

<b>AUTHOR</b>
       The <u>Compress::Zlib</u> module was written by Paul Marquess, <u>pmqs@cpan.org</u>. The latest copy of the module
       can be found on CPAN in <u>modules/by-module/Compress/Compress-Zlib-x.x.tar.gz</u>.

       The primary site for the <u>zlib</u> compression library is <a href="http://www.zlib.org"><u>http://www.zlib.org</u></a>

<b>MODIFICATION</b> <b>HISTORY</b>
       See the Changes file.



perl v5.8.8                                      2007-09-23                                          <!-- a -->Zlib(3)<!-- /a -->
</tt></pre>
</td></tr></table>
	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Darwin/Reference/ManPages/man3/Compress__Zlib.3pm.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Darwin/Reference/ManPages/man3/Compress__Zlib.3pm.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Darwin/Reference/ManPages/man3/Compress__Zlib.3pm.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

</body></html>
