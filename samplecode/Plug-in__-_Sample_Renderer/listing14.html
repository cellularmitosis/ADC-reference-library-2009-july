<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>Plug-in  - Sample Renderer - /Source/SR_ClipUtilities.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxGraphicsImaging-date.html">Graphics & Imaging</a> &gt; <A HREF="javascript:location.replace('index.html');">Plug-in  - Sample Renderer</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/GraphicsImaging/index.html" target="_blank">Reference Library > Graphics & Imaging</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">Plug-in  - Sample Renderer</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/Source/SR_ClipUtilities.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/Headers/resource.h</option>
<option value="listing2.html">/Headers/SR.h</option>
<option value="listing3.html">/Headers/SR_ClipUtilities.h</option>
<option value="listing4.html">/Headers/SR_ConfigData.h</option>
<option value="listing5.html">/Headers/SR_MacDialog.h</option>
<option value="listing6.html">/Headers/SR_Marker.h</option>
<option value="listing7.html">/Headers/SR_MarkerRenderer.h</option>
<option value="listing8.html">/Headers/SR_Math.h</option>
<option value="listing9.html">/Headers/SR_PixmapMarkerRenderer.h</option>
<option value="listing10.html">/Headers/SR_PrefixFile.h</option>
<option value="listing11.html">/Headers/SR_Rasterizers.h</option>
<option value="listing12.html">/Headers/SR_WinDialog.h</option>
<option value="listing13.html">/Source/SR.c</option>
<option value="listing14.html">/Source/SR_ClipUtilities.c</option>
<option value="listing15.html">/Source/SR_ConfigData.c</option>
<option value="listing16.html">/Source/SR_Line.c</option>
<option value="listing17.html">/Source/SR_LinePipe.c</option>
<option value="listing18.html">/Source/SR_MacDialog.c</option>
<option value="listing19.html">/Source/SR_Marker.c</option>
<option value="listing20.html">/Source/SR_MarkerRasterize_32.c</option>
<option value="listing21.html">/Source/SR_MarkerRasterize_8.c</option>
<option value="listing22.html">/Source/SR_Math.c</option>
<option value="listing23.html">/Source/SR_PipelineSetup.c</option>
<option value="listing24.html">/Source/SR_PixmapMarker.c</option>
<option value="listing25.html">/Source/SR_PixmapMarkerRasterize_32.c</option>
<option value="listing26.html">/Source/SR_PixmapMarkerRasterize_8.c</option>
<option value="listing27.html">/Source/SR_Point.c</option>
<option value="listing28.html">/Source/SR_PointPipe.c</option>
<option value="listing29.html">/Source/SR_Rasterizers.c</option>
<option value="listing30.html">/Source/SR_Triangle.c</option>
<option value="listing31.html">/Source/SR_WinDialog.c</option></select>
				</p>
				</form>
				<p><strong><a href="Plug-in__-_Sample_Renderer.zip">Download Sample</a></strong> (&#147;Plug-in__-_Sample_Renderer.zip&#148;, 101.9K)<BR>
<strong><a href="Plug-in__-_Sample_Renderer.dmg">Download Sample</a></strong> (&#147;Plug-in__-_Sample_Renderer.dmg&#148;, 165.9K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/****************************************************************************** **                                       ** **   Module:    SR_ClipUtilities.c                     ** **                                      ** **                                      ** **   Purpose:   Clipping utilities for Sample Renderer           ** **                                      ** **                                      ** **                                      ** **   Copyright (C) 1996-1997 Apple Computer, Inc.  All rights reserved.   ** **                                      ** **                                      ** *****************************************************************************/#include &quot;QD3D.h&quot;#include &quot;QD3DMath.h&quot;#include &quot;SR.h&quot;#include &quot;SR_ClipUtilities.h&quot;#define  TRUNC(X)        (float)((long)(X))#define SUBPIXEL_SNAP      ((float) 64.0)  #define SUBPIXEL_SNAP_INVERSE  ((float) 1.0 / (float) 64.0)/*===========================================================================*\ * *  Routine:  SRPointList_WDivide() * *  Comments:   *\*===========================================================================*/void SRPointList_WDivide(  TQ3RationalPoint4D     *in,   unsigned long       numVertices,   unsigned long       sizeOfIn){  float          w;  long          i;  TQ3RationalPoint4D    *s = in;  long          ci;  float          cf;  float          c;  float          wInv;  for (i = 0; i &lt; numVertices; i++) {    w = s-&gt;w;        if (s-&gt;w != 0.0) {      wInv = 1.0 / w;    } else {      wInv = kQ3MaxFloat;    }    c = s-&gt;x * wInv;    ci = FLOAT_TRUNC_TO_LONG(c);    cf = c - (float)ci;        cf = FLOAT_ROUND_TO_LONG_POSITIVE(cf * SUBPIXEL_SNAP);    cf = cf * SUBPIXEL_SNAP_INVERSE;    s-&gt;x = (float)ci + cf;    c = s-&gt;y * wInv;    ci = FLOAT_TRUNC_TO_LONG(c);    cf = c - (float)ci;        cf = FLOAT_ROUND_TO_LONG_POSITIVE(cf * SUBPIXEL_SNAP);    cf = cf * SUBPIXEL_SNAP_INVERSE;    s-&gt;y = (float)ci + cf;    s-&gt;z *= wInv;    s = (TQ3RationalPoint4D *)((unsigned char *)s + sizeOfIn);  }}/*===========================================================================*\ * *  Routine:  SRPointList_ClipTestVertices() * *  Comments:  Check if we have any clipped-out vertices *\*===========================================================================*/void SRPointList_ClipTestVertices(  TQ3RationalPoint4D     *deviceVertices,   unsigned long       *clipFlags,   long           numVertices,   float           *clipPlanes,   long           *clipFound,   long           *allOut,   unsigned long       sizeOfIn){  long        i;  float        x, y, z, w;  long        clipFlag;  TQ3RationalPoint4D  *s;  float        xMin, xMax,             yMin, yMax,             zMin, zMax;  s = deviceVertices;  xMin = clipPlanes[0];  xMax = clipPlanes[1];  yMin = clipPlanes[2];  yMax = clipPlanes[3];  zMin = clipPlanes[4];  zMax = clipPlanes[5];  *clipFound = *allOut = 0;    i = 0;  while (i &lt; numVertices) {    clipFlag = 0;    x = s-&gt;x;    y = s-&gt;y;    z = s-&gt;z;    w = s-&gt;w;    /*      *  The view clip planes are defined by xmin, xmax, ymin, ymax,       *  zmin, zmax. Clearly these planes are perpendicular to the       *  appropriate axis.  For example, xmin is perpendicular to the YZ       *  plane and defines the minimum x coordinate for clipping.     *     *  In this clip test, we allow the clipping planes to be any     *  value.  They are not just limited to  -1,1 like in some     *  clipping environments.  The only stipulation is that the     *  min actually be less than the max for a plane combination.     *     *  The same set of tests is applied consistently to all point      *  regardless of the sign of w.  Normally, only the geometry in front     *  of the camera is desired so the tests for the positive- w space      *  should be applied consistently.  Sometimes, the geometry in the      *  negative w space is desired too.  Then all the points should be      *  retraversed with the negative-w tests applied to all points.     */    if (x &lt; xMin * w) {      clipFlag |= SR_MIN_X;    }    if (x &gt; xMax * w) {      clipFlag |= SR_MAX_X;    }    if (y &lt; yMin * w) {      clipFlag |= SR_MIN_Y;    }    if (y &gt; yMax * w) {      clipFlag |= SR_MAX_Y;    }    if (z - w * zMin &lt; 0.0) {      clipFlag |= SR_MIN_Z;    } else if (z - w * zMax &gt; 0.0) {      clipFlag |= SR_MAX_Z;    }    /*      *  All vertices are out if &amp; of all points is not 0      */    if (i == 0) {      *allOut = clipFlag;    } else {      *allOut &amp;= clipFlag;    }    *clipFound |= clipFlag;    /*      *  Vertices are clipped if | of all clip flags is 0      */    clipFlags[i] = clipFlag;      s = (TQ3RationalPoint4D *)((unsigned char *)s + sizeOfIn);    i++;  }}#define  OUTPUT_POINT(DEST, SRC_POINT)              \{                                \  double  w;                          \                                \  w = SRC_POINT-&gt;w;                      \                                \  DEST-&gt;x = (double)SRC_POINT-&gt;x / w;              \  DEST-&gt;y = (double)SRC_POINT-&gt;y / w;              \  DEST-&gt;z = (double)SRC_POINT-&gt;z / w;              \  DEST-&gt;w = 1.0;                        \}#define  OUTPUT_POINT_INTERPOLATE(DEST, PREV, CURR, PARAM)    \{                                \  double  w;                          \  double  oneMinusPARAM;                    \                                \  oneMinusPARAM = (double)1.0 - (double)PARAM;        \                                \  w = oneMinusPARAM * (double)PREV-&gt;w + (double)PARAM * (double)CURR-&gt;w;        \                                            \  DEST-&gt;x = (oneMinusPARAM * (double)PREV-&gt;x + (double)PARAM * (double)CURR-&gt;x) / w;  \  DEST-&gt;y = (oneMinusPARAM * (double)PREV-&gt;y + (double)PARAM * (double)CURR-&gt;y) / w;  \  DEST-&gt;z = (oneMinusPARAM * (double)PREV-&gt;z + (double)PARAM * (double)CURR-&gt;z) / w;  \  DEST-&gt;w = 1.0;                        \}#define COMPUTE_PLANE_INTERSECTIONS(VALUES, COORDS, CLIP_PLANES)      \{                                      \  int    j;                                \  double  w = COORDS[3];                          \                                      \  for (j = 0; j &lt; 6; j++) {                        \      /* For each clip plane; compute parametric intersection. */      \    VALUES[j] = (double)COORDS[j &gt;&gt; 1] - w * (double)CLIP_PLANES[j];  \  }                                    \}#define  BUMP_DEST_POINTERS                          \  clippedVertices =(TQ3RationalPoint4D *)((unsigned char *)clippedVertices\    + sizeOfClippedVertex);/*===========================================================================*\ * *  Routine:  SRPointList_ClipVertices() * *  Comments:  Given a set of vertices, compute a clipped set. *\*===========================================================================*/void SRPointList_ClipVertices(    TQ3RationalPoint4D     *vertices,  long           sizeOfVertex,  TQ3RationalPoint4D     *clippedVertices,   long           sizeOfClippedVertex,  unsigned long       *clipFlags,   long           *clippedVertexFlags,  long           sourceNumberOfPoints,   long           *destNumberOfPoints,  float           *clipPlanes,  long          mode){  long          i, j;  float          *coords;  TQ3RationalPoint4D    *sPrevious,               *sCurrent;  double          previousValues[6],               currentValues[6];  double          prevParametricValue,               currParametricValue;  double          parametricValue;  long          lineClipped;    (*destNumberOfPoints) = 0;  sPrevious = vertices;  /* if first point not clipped then output it */  if ((clipFlags[0] &amp; SR_CLIP_ALL) == 0) {    OUTPUT_POINT(clippedVertices, sPrevious);    clippedVertexFlags[*destNumberOfPoints] = SR_DRAW_NEXT;    (*destNumberOfPoints)++;    BUMP_DEST_POINTERS;  }  sCurrent =     (TQ3RationalPoint4D *)((unsigned char *)sPrevious + sizeOfVertex);  for (i = 1; i &lt; sourceNumberOfPoints; i++) {    if ((clipFlags[i - 1] &amp; SR_CLIP_ALL) &amp; (clipFlags[i] &amp; SR_CLIP_ALL)) {      /*         *  Previous and current are outside; do nothing        */    } else if (!((clipFlags[i - 1] &amp; SR_CLIP_ALL)   |            (clipFlags[i]     &amp; SR_CLIP_ALL))) {      /*       *  Previous and current vertex are inside turn       *  on draw vector bit and output current vertex       */      OUTPUT_POINT(clippedVertices, sCurrent);      clippedVertexFlags[*destNumberOfPoints] = SR_DRAW_NEXT;      (*destNumberOfPoints)++;      BUMP_DEST_POINTERS;    } else {      /*          * For each clip plane; compute parametric clip with        * previous and current point.        */        /* point to current XYZW */      coords = (float *)&amp;sPrevious-&gt;x;      COMPUTE_PLANE_INTERSECTIONS(previousValues, coords, clipPlanes);      /* point to current XYZW */      coords = (float *)&amp;sCurrent-&gt;x;      COMPUTE_PLANE_INTERSECTIONS(currentValues, coords, clipPlanes);      prevParametricValue = 0.0;      currParametricValue = 1.0;      lineClipped = 1;      for (j = 0; j &lt; 6; j++) {        /*          *  If previous flag and current differ then we cross          *  a clip boundary and we must compute the intersection.          */        if (lineClipped) {          if (((clipFlags[i - 1] ^ clipFlags[i]) &gt;&gt; j) &amp; 1) {            parametricValue =               previousValues[j] /                 (previousValues[j] - currentValues[j]);            if ((clipFlags[i] &gt;&gt; j) &amp; 1) {              if (currParametricValue &gt; parametricValue) {                currParametricValue = parametricValue;              }            } else {              if (prevParametricValue &lt; parametricValue) {                prevParametricValue = parametricValue;              }            }          } else {            lineClipped = !((clipFlags[i] &gt;&gt; j) &amp; 1);          }          lineClipped =             lineClipped &amp;               (prevParametricValue &lt; currParametricValue);        }      }      if (lineClipped) {        /*          *  Compute clip for previous vertex          */        if (prevParametricValue &gt; 0.0) {          OUTPUT_POINT_INTERPOLATE(            clippedVertices,             sPrevious,             sCurrent,             prevParametricValue);          /*           *  Point is clipped on the way into the visible region           *  so set draw bit           */          clippedVertexFlags[*destNumberOfPoints] = SR_DRAW_NEXT;          (*destNumberOfPoints)++;          BUMP_DEST_POINTERS;        }        /*         *  Compute clip for current vertex         */        if (currParametricValue &lt; 1.0) {          OUTPUT_POINT_INTERPOLATE(            clippedVertices,             sPrevious,             sCurrent,             currParametricValue);          /*           *  Point is clipped on the way out of the visible region           *  so turn off draw bit           */          clippedVertexFlags[*destNumberOfPoints] &amp;= ~SR_DRAW_NEXT;          (*destNumberOfPoints)++;                      BUMP_DEST_POINTERS;        } else {          OUTPUT_POINT(clippedVertices, sCurrent);          /*           *  Point is inside visible region so turn on draw bit           */          clippedVertexFlags[*destNumberOfPoints] = SR_DRAW_NEXT;          (*destNumberOfPoints)++;          BUMP_DEST_POINTERS;        }      }    }    /*     *  Update previous and current pointers     */    sPrevious = sCurrent;    sCurrent = (TQ3RationalPoint4D *)            ((unsigned char *)sPrevious + sizeOfVertex);  }  /*   *  If we have fewer than 3 vertices then don't clip from the last to the   *  first vertex since that doesn't make any sense.   */  if (sourceNumberOfPoints &lt; 3) {    return;  }  /*   *  'mode' is either polygon or polyline.  When mode is polygon (0) then    *  we must clip from the last vertex to the first vertex.  When mode is    *  polyline (1) then we don't do this clip.   */  if (mode == DO_POLYLINE) {    return;  }  /*   *  If first vertex is in then do nothing.   *  If first vertex is clipped and last vertex is displayed then compute   *  another clip point from last vertex to first   */  if (!((clipFlags[0] &amp; SR_CLIP_ALL) |     (clipFlags[sourceNumberOfPoints - 1] &amp; SR_CLIP_ALL))) {    /*      *  First and last are inside; do nothing since     *  draw bit of last should be set     */  } else {    sPrevious = &amp;vertices[sourceNumberOfPoints - 1];        coords = (float *)&amp;sPrevious-&gt;x;    COMPUTE_PLANE_INTERSECTIONS(previousValues, coords, clipPlanes);    sCurrent = vertices;    coords = (float *)&amp;sCurrent-&gt;x;    COMPUTE_PLANE_INTERSECTIONS(currentValues, coords, clipPlanes);    /* compute clip from last vertex to first vertex */    prevParametricValue = 0.0;    currParametricValue = 1.0;    lineClipped = 1;    for (j = 0; j &lt; 6; j++) {      /*        *  If previous flag and current differ then we cross        *  a clip boundary and we must compute the intersection.        */      if (lineClipped) {        if (((clipFlags[sourceNumberOfPoints - 1] ^ clipFlags[0]) &gt;&gt; j) &amp; 1) {          parametricValue = previousValues[j] /                     (previousValues[j] - currentValues[j]);          if ((clipFlags[0] &gt;&gt; j) &amp; 1) {            if (currParametricValue &gt; parametricValue) {              currParametricValue = parametricValue;            }          } else {            if (prevParametricValue &lt; parametricValue) {              prevParametricValue = parametricValue;            }          }        } else {          lineClipped = !((clipFlags[0] &gt;&gt; j) &amp; 1);        }        lineClipped = lineClipped &amp;                 (prevParametricValue &lt; currParametricValue);      }    }    if (lineClipped) {      /*        *  Compute clip for previous vertex        */      if (prevParametricValue &gt; 0.0) {        OUTPUT_POINT_INTERPOLATE(          clippedVertices,           sPrevious,           sCurrent,           prevParametricValue);        clippedVertexFlags[*destNumberOfPoints] = SR_DRAW_NEXT;        (*destNumberOfPoints)++;        BUMP_DEST_POINTERS;      }      /*       *  Compute clip for current vertex       */      if (currParametricValue &lt; 1.0) {        OUTPUT_POINT_INTERPOLATE(          clippedVertices,           sPrevious,           sCurrent,           currParametricValue);        clippedVertexFlags[*destNumberOfPoints] &amp;= ~SR_DRAW_NEXT;        (*destNumberOfPoints)++;        BUMP_DEST_POINTERS;      } else {        OUTPUT_POINT(clippedVertices, sCurrent);        /*         *  Point is clipped so compute last vertex and don't          *  display it         */        clippedVertexFlags[*destNumberOfPoints] = SR_DRAW_NEXT;        (*destNumberOfPoints)++;        BUMP_DEST_POINTERS;      }    }  }}</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/Plug-in__-_Sample_Renderer/listing14.html%3Fid%3DDTS10000120-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/Plug-in__-_Sample_Renderer/listing14.html%3Fid%3DDTS10000120-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/Plug-in__-_Sample_Renderer/listing14.html%3Fid%3DDTS10000120-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>