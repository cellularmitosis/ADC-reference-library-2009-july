<!-- Generated by Harlequin WebMaker 2.2.3 (23-Apr-1996)
LispWorks 3.2.2 -->
<HTML> <HEAD>
<TITLE>About the Mixed Mode Manager (IM: PS)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING18></A>



<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="PPCSoftware-17.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="PPCSoftware-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="PPCSoftware-86.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="PPCSoftware-19.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="PPCSoftware-2.html"><B>PowerPC System Software</B></A> / <BR><DD><A HREF="PPCSoftware-17.html"><B>Chapter 2 - Mixed Mode Manager</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING18-0></A>
<H1>About the Mixed Mode Manager</H1>
 The Mixed Mode Manager is the part of the Macintosh Operating System that allows PowerPC processor-based Macintosh computers to cooperatively run 680x0 applications, PowerPC applications, 680x0 system software, and PowerPC system software. It provides a number of capabilities, including<A NAME=MARKER-2-6></A><P>
<UL>
<LI>transparent access to 680x0-based system software from PowerPC applications
<LI>transparent access to PowerPC processor-based system software from 680x0 applications
<LI>a method--independent of the instruction set architecture--of calling an external piece of code. This includes<P>
<UL>
<LI>transparent access to PowerPC code by 680x0 applications
<LI>system support for calling 680x0 code from PowerPC code
<LI>system support for calling PowerPC code from 680x0 code<P>
</UL>
<LI>support for patching PowerPC or 680x0 code with PowerPC or 680x0 code
<LI>support for stand-alone code resources containing either 680x0 or PowerPC code<P>
</UL>
 In short, the Mixed Mode Manager is intended to provide both PowerPC processor-<BR>based and 680x0-based code transparent access to code written in another instruction set (or in an instruction set whose type is unknown). It does this by keeping track of what kind of code is currently executing and, when necessary, switching modes. For example, if some PowerPC code calls a Macintosh Operating System routine that exists only in 680x0 form, the Mixed Mode Manager translates the routine's parameters from their PowerPC arrangement (for example, stored in registers GPR3 and GPR4) into the appropriate 680x0 arrangement (for example, stored in registers D0 and D1, with the result placed into register A0).<P>
 The Mixed Mode Manager is an integral part of the system software for PowerPC processor-based Macintosh computers. It is designed to hide, as much as possible, the dual nature of the operating environment supported on PowerPC processor-based Macintosh computers running the 68LC040 Emulator. Except in specific cases described later, your application or other software should not need to call the routines provided by the Mixed Mode Manager.<P>
<A NAME=HEADING18-12></A>
<H2>External Code</H2>
 <A NAME=MARKER-2-7></A>To appreciate when and why you might need to use the routines provided by the Mixed Mode Manager, you need to understand the circumstances in which you might directly or indirectly call code in an instruction set architecture different from that of the calling code. There are several ways to execute <B>external code</B> (code that is not directly contained in your application or software), including<P>
<UL>
<LI>calling a trap
<LI>calling a device driver (for example, by calling the driver's Open, Status, or <BR>Control routines)
<LI>loading and then executing code contained in a resource
<LI>using the address of a procedure or function obtained from an unknown source<P>
</UL>
 In any of these four cases, the external code that you call might be in an instruction set architecture that is different from the instruction set architecture of the calling code. (For example, an application that uses the PowerPC instruction set might call a ROM-based Toolbox trap that uses the 680x0 instruction set.) As a result, in all these cases, the Mixed Mode Manager might have to switch environments to allow the called routine to execute and then switch back to allow your application or other software to continue execution.<P>
 In the first two of the four cases, the Mixed Mode Manager is able to handle all required mode switching virtually transparently to the calling software. In the two last cases, however, you might need to intervene in the otherwise automatic operations of the Mixed Mode Manager. This is because the Mixed Mode Manager cannot tell, from a given pointer to some executable code, what kind of code the pointer references.<P>
 The following section describes in greater detail the extent of this problem and the way you need to solve it, using universal procedure pointers in place of procedure pointers. See <A HREF=PPCSoftware-69.html#MARKER-9-12>"Using the Mixed Mode Manager" beginning on page 2-14</A> for code samples that illustrate how to create and use universal procedure pointers.<A NAME=MARKER-2-8></A><P>
<A NAME=HEADING18-21></A>
<H2>Procedure Pointers</H2>
 <A NAME=MARKER-2-9></A>For present purposes, a <B>procedure pointer</B> is any reference generated by a compiler when taking the address of a routine. On 680x0-based Macintosh computers, a procedure pointer is simply the address of the routine's executable code (and is defined by the <CODE>ProcPtr</CODE> data type). On PowerPC processor-based Macintosh computers, a procedure pointer is the address of the routine's transition vector. <A HREF=#MARKER-9-10>Figure 2-1</A> illustrates the structure of procedure pointers in each environment.<P>
<B>Figure 2-1  <A NAME=MARKER-9-10></A>680x0 and PowerPC procedure pointers</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/PPCO-L-08.jpg">
 A <B>transition vector</B> is a set of two addresses: the address of the routine's executable code and the address of the fragment's table of contents (TOC).<A NAME=MARKER-2-11></A><P>
 The Macintosh programming interfaces allow you to use procedure pointers in several ways. A procedure pointer can be<P>
<UL>
<LI>passed as a parameter to a system software routine (for example, the <CODE>growZone</CODE> parameter to the <CODE>SetGrowZone</CODE> routine)
<LI>passed in a field of a parameter block or other data structure (for example, the <CODE>gzProc</CODE> field of a <CODE>Zone</CODE> parameter block)
<LI>stored in an application-specific global data structure (for example, the addresses stored in a <CODE>grafProcs</CODE> field of a graphics port)
<LI>installed into a vector accessed through system global variables (for example, the <CODE>jGNEFilter</CODE> global variable)
<LI>installed into the trap dispatch table or into a patch daisy chain using the <CODE>SetToolTrapAddress</CODE> or <CODE>SetOSTrapAddress</CODE> routine<P>
</UL>
 As indicated previously, the Mixed Mode Manager cannot tell, from a given procedure pointer, what kind of code the pointer references (either directly through a pointer of type <CODE>ProcPtr</CODE> or indirectly through a transition vector). The Mixed Mode Manager solves this problem by requiring you to use generalized procedure pointers, known as universal procedure pointers, whenever you would previously have used a procedure pointer. A <B>universal procedure pointer</B> is either a normal 680x0 procedure pointer <BR>(that is, the address of a routine) or the address of a <B>routine descriptor,</B> a data structure that the Mixed Mode Manager uses to encapsulate information about an externally referenced routine. A routine descriptor describes the address of the routine, its parameters, and its calling conventions.<A NAME=MARKER-2-12></A><A NAME=MARKER-2-13></A><P>
<PRE>
typedef RoutineDescriptor *UniversalProcPtr;
</PRE>
<DL>
<DT><B>Note</B>
<DD><A NAME=MARKER-9-15></A>See <A HREF=PPCSoftware-28.html#MARKER-9-320>"Routine Descriptors" on page 2-37</A> for a description <BR>of the fields of a routine descriptor.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
 <A NAME=MARKER-2-13></A><A NAME=MARKER-9-17></A>The Macintosh application programming interfaces have been revised for the PowerPC platform to change all references to procedure pointers to references to universal procedure pointers. (The new interfaces are called the universal interface files.) For example, the <CODE>SetGrowZone</CODE> function was previously declared in the interface file <CODE>Memory.h</CODE> like this:<A NAME=MARKER-2-144></A><A NAME=MARKER-2-19></A><P>
<PRE>
typedef ProcPtr GrowZoneProcPtr;
pascal void SetGrowZone (GrowZoneProcPtr growZone);
</PRE>
 In the updated interface file <CODE>Memory.h</CODE>, <CODE>SetGrowZone</CODE> is declared like this:<P>
<PRE>
typedef UniversalProcPtr GrowZoneUPP;
extern pascal void SetGrowZone (GrowZoneUPP growZone);
</PRE>
 This redefinition of all procedure pointers as universal procedure pointers ensures that at the time a procedure is to be executed, the Operating System has enough information <BR>to determine the routine's instruction set architecture and hence to determine whether <BR>a mode switch is necessary. In addition, if a mode switch is necessary, the universal procedure pointer (if it is a pointer to a routine descriptor) provides information about the routine's calling conventions, the number and sizes of its parameters, and so forth.<P>
 It's important to understand exactly when you need to be concerned about routine descriptors and when you need to use the new programming interfaces when writing your application. The following cases cover most of the relevant possibilities:<P>
<UL>
<LI>If your application uses the 680x0 instruction set (and therefore executes under the 68LC040 Emulator on PowerPC processor-based Macintosh computers) and does not support external code modules, you do not need to use routine descriptors or the new programming interfaces.
<LI>If your application uses the PowerPC instruction set, you must use the new program-<BR>ming interfaces.
<LI>If your application uses either the 680x0 instruction set or the PowerPC instruction set and makes calls only to code of the same type, you do not need to create routine descriptors.
<LI>If your code uses the PowerPC instruction set and passes a routine's address to code that might be in the 680x0 instruction set, then you need instead to pass the address of a routine descriptor. This applies to all the methods of passing a routine address listed earlier in this section (as a parameter to a system software routine, in a field of a parameter block, and so forth).
<LI>If you create a resource containing PowerPC code that might be called either by 680x0 code or by PowerPC code, that code must be preceded by a routine descriptor. It's possible that the calling code simply loads the resource and jumps to its beginning; <BR>if the resource does not begin with a routine descriptor, the Mixed Mode Manager <BR>will not be called to determine whether a mode switch is necessary. See <A HREF=PPCSoftware-19.html#MARKER-9-93>"Executing Resource-Based Code" on page 2-24</A> for more details.<P>
</UL>
<DL>
<DT><B>IMPORTANT</B>
<DD>In short, you need to convert procedure pointers to universal procedure pointers only if you pass a routine's address to code that is external to your application. See <A HREF=PPCSoftware-19.html#MARKER-9-67>"Using Universal Procedure Pointers" beginning on page 2-21</A> for details on making the appropriate modifications to your application.<EM></EM><A NAME=MARKER-2-20></A><A NAME=MARKER-2-146></A><A NAME=MARKER-2-22></A><A NAME=MARKER-2-23></A><A NAME=MARKER-2-32></A>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
<A NAME=HEADING18-47></A>
<H2>Mode Switches</H2>
 <A NAME=MARKER-2-181></A>This section describes the operations of the Mixed Mode Manager in switching modes (from PowerPC native mode to 680x0 emulation mode, or vice versa). It describes the circumstances under which mode switches are performed and the mechanism that the Mixed Mode Manager uses to switch modes.<A NAME=MARKER-2-184></A><P>
<DL>
<DT><B>IMPORTANT</B>
<DD>The information in this section is provided for debugging purposes only. Your application (or other code) should not rely on the details of mode switching presented here.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
 Every mode switch occurs as a result of either an explicit or an implicit cross-mode <BR>call. An <B>explicit cross-mode call</B> occurs when the calling software itself calls the <CODE>CallUniversalProc</CODE> function and passes a universal procedure pointer of a routine that exists in an instruction set architecture other than that of the caller. An <B>implicit cross-mode call</B> occurs when the calling software executes a routine descriptor for a routine that exists in an instruction set architecture other than that of the caller.<A NAME=MARKER-2-185></A><A NAME=MARKER-2-183></A><P>
 The mixed-mode architecture of PowerPC processor-based computers running 680x0-<BR>based code gives rise to four possible situations when a piece of code calls a system software routine:<P>
<UL>
<LI>When 680x0 code calls a system software routine that exists as 680x0 code, the <BR>routine is called directly, using the trap dispatch mechanism provided in the <BR>68LC040 Emulator.
<LI>When 680x0 code calls a system software routine that exists as PowerPC code, the routine is called indirectly, using the address--contained in the trap dispatch table--of a routine descriptor, which invokes a mode switch to the PowerPC environment. When the PowerPC code returns, the executing environment is switched back to the 68LC040 Emulator. See the next section, <A HREF=#MARKER-9-29>"Calling PowerPC Code From 680x0 Code,"</A> for more details.
<LI>When PowerPC code calls a system software routine that exists as PowerPC code, the routine is called through glue in the system software import library. The glue code calls <CODE>CallUniversalProc</CODE>, which determines that the routine is PowerPC code and then calls it directly.
<LI>When PowerPC code calls a system software routine that exists as 680x0 code, the routine is called through glue code contained in the system software import library. The glue code sets up a 680x0 universal procedure pointer (which is simply a 680x0 procedure pointer) and executes the 680x0 code by calling the <CODE>CallUniversalProc</CODE> function. See <A HREF=#MARKER-9-38>"Calling 680x0 Code From PowerPC Code" on page 2-12</A> for more details.<P>
</UL>
<DL>
<DT><B>IMPORTANT</B>
<DD>Only 680x0 code can make implicit cross-mode calls. Native PowerPC code must always make explicit cross-mode calls. The Mixed Mode Manager determines whether a mode switch is necessary.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
<A NAME=HEADING18-57></A>
<H3><A NAME=MARKER-9-29></A>Calling PowerPC Code From 680x0 Code</H3>
 This section describes how the Mixed Mode Manager switches modes from the 680x0 emulated environment to the PowerPC native environment. This usually happens <BR>when 680x0 code calls a system software routine that is implemented in the PowerPC instruction set.<P>
 Suppose that a 680x0 application calls some system software routine. The application is not aware that it is running under the 68LC040 Emulator, so it just pushes the routine's parameters onto the stack (or stores them into registers) and then jumps to the routine <BR>or calls a trap that internally jumps to the routine. If the routine exists as 680x0 code, <BR>no mode switch is required and the routine is called as usual. If, however, the routine exists as PowerPC code, the calling application must implicitly invoke the Mixed <BR>Mode Manager.<P>
 If the calling application merely jumps to the PowerPC code, the code must begin with <BR>a routine descriptor, as explained in <A HREF=PPCSoftware-19.html#MARKER-9-93>"Executing Resource-Based Code" on page 2-24</A>. If the calling application calls a trap, the trap dispatch table must contain--instead of the address of the routine's executable code--the address of a routine descriptor for that routine. This routine descriptor is created at system startup time.<P>
 <A HREF=#MARKER-9-30>Figure 2-2</A> shows the path followed when a 680x0 application calls a system software routine implemented as PowerPC code. The trap dispatch table contains the address <BR>of the native routine's routine descriptor. The routine descriptor contains the address <BR>of the routine's transition vector, which in turn contains the routine's entry point and TOC value.<P>
<B>Figure 2-2  <A NAME=MARKER-9-30></A>Calling PowerPC code from a 680x0 application</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/PPCO-L-09.jpg">
 For example, suppose that your application calls the <CODE>CountResources</CODE> function, <BR>as follows:<P>
<PRE>
myResCount = CountResources('PROC');
</PRE>
 Suppose further that <CODE>CountResources</CODE> has been ported to the PowerPC instruction set. When your application calls <CODE>CountResources</CODE>, the stack looks like the one shown in <A HREF=#MARKER-9-31>Figure 2-3</A>.<P>
<B>Figure 2-3  <A NAME=MARKER-9-31></A>The stack before a mode switch</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/PPCO-L-10.jpg">
 <A NAME=MARKER-2-109></A>The trap dispatcher executes the <CODE>CountResources</CODE> routine descriptor, which begins with an executable instruction that invokes the Mixed Mode Manager. The Mixed Mode Manager retrieves the transition vector and creates a switch frame on the stack. A <B>switch frame</B> is a stack frame that contains information about the routine to be executed, the state of various registers, and the address of the previous frame. <A HREF=#MARKER-9-34>Figure 2-4</A> shows the structure of a 680x0-to-PowerPC switch frame.<P>
<DL>
<DT><B>IMPORTANT</B>
<DD>Notice in <A HREF=#MARKER-9-34>Figure 2-4</A> that the low-order bit in the back chain pointer to the saved A6 value is set. The Mixed Mode Manager uses that bit internally as a signal that a switch frame is on the stack. The Mixed Mode Manager will fail if the stack pointer has an odd value.<EM></EM><A NAME=MARKER-2-33></A>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
<B>Figure 2-4  <A NAME=MARKER-9-34></A>A 680x0-to-PowerPC switch frame</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/PPCO-L-11.jpg">
 In addition to creating a switch frame, the Mixed Mode Manager also sets up several CPU registers:<P>
<UL>
<LI>The Table of Contents Register (RTOC) must be set to the TOC address of the fragment containing the <CODE>CountResources</CODE> routine. This value is obtained from <BR>the transition vector whose address is extracted from the routine descriptor.<A NAME=MARKER-2-35></A>
<LI>The Link Register (LR) must be set to point to code that cleans up the stack and restarts the emulator.<A NAME=MARKER-2-36></A><P>
</UL>
 At this point, it's safe to execute the native <CODE>CountResources</CODE> code. When <CODE>CountResources</CODE> completes, the Mixed Mode Manager copies the return value from R3 into its proper location (in a register or on the stack). The RTOC, LR, and CR are restored to their saved values, and the switch frame is popped off the stack. The Mixed Mode Manager also pops the return address off the stack, as well as the parameters of routines of type <CODE>pascal</CODE>. Finally, the Mixed Mode Manager jumps back into the 68LC040 Emulator and the application continues execution.<A NAME=MARKER-2-188></A><P>
<A NAME=HEADING18-77></A>
<H3><A NAME=MARKER-9-38></A>Calling 680x0 Code From PowerPC Code</H3>
 This section describes how the Mixed Mode Manager switches modes from the PowerPC native environment to the 680x0 emulated environment. This usually happens when PowerPC code calls a system software routine that is implemented in the 680x0 instruction set.<P>
 For example, suppose that a PowerPC application calls a system software routine that exists only as 680x0 code. In the system software import library must exist a small piece of glue code that<P>
<UL>
<LI>allocates space on the stack for the routine's result, if any
<LI>determines the address of the 680x0 routine from the trap dispatch table
<LI>provides the procedure information for the routine
<LI>calls the <CODE>CallUniversalProc</CODE> function<P>
</UL>
 <A HREF=#MARKER-9-39>Listing 2-1</A> illustrates a sample glue routine for the QuickDraw text-measuring routine <CODE>TextWidth</CODE>.<P>
<DL>
<DT><B>IMPORTANT</B>
<DD>Glue routines like the one illustrated in <A HREF=#MARKER-9-39>Listing 2-1</A> are part of <BR>the system software import library. You do not need to write <BR>glue routines like this.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
<B>Listing 2-1  <A NAME=MARKER-9-39></A>Sample glue code for a 680x0 routine</B><P>
<PRE>
enum {
   uppTextWidthProcInfo =  kPascalStackBased 
                     | RESULT_SIZE(kTwoByteCode) 
                     | STACK_ROUTINE_PARAMETER(1, kFourByteCode)
                     | STACK_ROUTINE_PARAMETER(2, kTwoByteCode)
                     | STACK_ROUTINE_PARAMETER(3, kTwoByteCode)
};

short TextWidth (Ptr textBuf, short firstByte, short byteCount)
{
   ProcPtr        textWidth_68K;

   textWidth_68K = NGetTrapAddress(_TextWidth, ToolTrap);
   return CallUniversalProc((UniversalProcPtr)textWidth_68K, 
               uppTextWidthProcInfo, textBuf, firstByte, byteCount);
}
</PRE>
 See <A HREF=PPCSoftware-19.html#MARKER-9-50>"Specifying Procedure Information" beginning on page 2-14</A> for a description of the constants and macros used to define the procedure information (that is, the <CODE>myProcInfo</CODE> parameter).<P>
<DL>
<DT><B>Note</B>
<DD>For Operating System traps (that is, traps of type <CODE>OSTrap</CODE>), the <BR>trap dispatcher copies the trap number into register D1. As a result, <BR>the glue code illustrated in <A HREF=#MARKER-9-39>Listing 2-1</A> would need to call the <BR>function <CODE>CallOSTrapUniversalProc</CODE>.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
 <A NAME=MARKER-2-191></A>The call to <CODE>CallUniversalProc</CODE> invokes the Mixed Mode Manager, which verifies that a mode switch is necessary. At that point, the Mixed Mode Manager saves all nonvolatile registers and other necessary information on the stack in a switch frame. <A HREF=#MARKER-9-41>Figure 2-5</A> shows the structure of a PowerPC-to-680x0 switch frame.<P>
<B>Figure 2-5  <A NAME=MARKER-9-41></A>A PowerPC-to-680x0 switch frame</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/PPCO-L-12.jpg">
 Once the switch frame is set up, the Mixed Mode Manager sets up the 68LC040 Emulator's context block and then jumps into the emulator. When the routine has finished executing, it attempts to jump to the return address pushed onto the stack. That return address points to a mode-switching structure contained in the Reserved area in the switch frame. The emulator encounters the instruction in the <CODE>goMixedModeTrap</CODE> field of the routine descriptor and then saves the current 680x0 state in its context block. Once this is done, the Mixed Mode Manager restores native registers that were previously saved and deallocates the switch frame. Control then returns to the caller of <CODE>CallUniversalProc</CODE>.<P>
<DL>
<DT><B>IMPORTANT</B>
<DD><A NAME=MARKER-9-42></A>As currently implemented, the instruction that causes a return from the 68LC040 Emulator to the native PowerPC environment clears the low-order 5 bits of the Condition Code Register (CCR). This prevents 680x0 callback procedures from returning information in the CCR. If you want to port 680x0 code that calls an external routine that returns results in the CCR, you must instead call a 680x0 stub that saves that information in some other place.<EM></EM><A NAME=MARKER-2-179></A><A NAME=MARKER-2-180></A><A NAME=MARKER-2-196></A><A NAME=MARKER-2-31></A><A NAME=MARKER-2-36></A>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>

</BLOCKQUOTE>
<HR>
<center>
<A HREF="PPCSoftware-17.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="PPCSoftware-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="PPCSoftware-86.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="PPCSoftware-19.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="PPCSoftware-3.html">&copy; Apple Computer, Inc.</A><br>3 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>  
