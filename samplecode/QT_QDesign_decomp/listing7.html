<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>QT QDesign decomp - /source/AIFF.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/QuickTime/index.html">QuickTime</a> &gt; <a href="../../samplecode/QuickTime/idxMusicAudio-date.html">Audio</a> &gt; <A HREF="javascript:location.replace('index.html');">QT QDesign decomp</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Not Recommended Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>The information in this document is <strong>Not Recommended</strong> and should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/QuickTime/idxMusicAudio-date.html" target="_blank">QuickTime > Audio</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">QT QDesign decomp</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/source/AIFF.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/headers/AIFF.h</option>
<option value="listing2.html">/headers/DBFF_Errors.h</option>
<option value="listing3.html">/headers/Defines.h</option>
<option value="listing4.html">/headers/LDandFix.h</option>
<option value="listing5.html">/headers/SetupDBHeader.h</option>
<option value="listing6.html">/headers/SoundStruct.h</option>
<option value="listing7.html">/source/AIFF.c</option>
<option value="listing8.html">/source/LDandFix.c</option>
<option value="listing9.html">/source/QDesign_decomp.c</option>
<option value="listing10.html">/source/SetupDBHeader.c</option></select>
				</p>
				</form>
				<p><strong><a href="QT_QDesign_decomp.zip">Download Sample</a></strong> (&#147;QT_QDesign_decomp.zip&#148;, 22.3K)<BR>
<strong><a href="QT_QDesign_decomp.dmg">Download Sample</a></strong> (&#147;QT_QDesign_decomp.dmg&#148;, 78.5K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/***  Apple Macintosh Developer Technical Support****  Routine demonstrating how to parse AIFF sound files.****  by Mark Cookson, Apple Developer Technical Support****  File:  AIFF.c****  Copyright &copy;1996 Apple Computer, Inc.**  All rights reserved.****  You may incorporate this sample code into your applications without**  restriction, though the sample code has been provided &quot;AS IS&quot; and the**  responsibility for its operation is 100% yours.  However, what you are**  not permitted to do is to redistribute the source as &quot;Apple Sample**  Code&quot; after having made changes. If you're going to re-distribute the**  source, we require that you make it clear in the source that the code**  was descended from Apple Sample Code, but that you've made changes.*/#include &quot;AIFF.h&quot;/*  need to substitute this code where using long doublestypedef struct myLongDouble {  double  firstHalf;  double  secondHalf;} myLongDouble;*//* Given an AIFF File gets the sample rate and other relavent pieces of information.   This has been modified from its orignal form found in the Develop 11 MultiBuffer source. *//*-----------------------------------------------------------------------*/    OSErr  ASoundGetAIFFHeader    (SoundInfoPtr theSoundInfo, long *length, void *waveData)/*-----------------------------------------------------------------------*/{  ChunkTemplatePtr    chunkTemplate    = nil;      /* ...for ease of access */  unsigned long      type        = kInit;  long          filePosition    = kInit,              byteCount      = kInit;  Fixed          sampleRate      = kInit;  unsigned short      chunkFlags      = kInit;    /* remember chunks we've seen */  OSErr          err          = noErr;  char          chunkBuffer[kChunkBufferSize];  theSoundInfo-&gt;dataStart = kInit;  /*  Parse the AIFF (or AIFC) header */  do {    /*  Position ourselves at the beginning of the next chunk and read in      a hunk-o-data... */    err = SetFPos (theSoundInfo-&gt;refNum, fsFromStart, filePosition);    if (err != noErr) {      DebugPrint (&quot;\pSetFPos failed!&quot;);      break;    }    byteCount = kChunkBufferSize;    err = FSRead (theSoundInfo-&gt;refNum, &amp;byteCount, chunkBuffer);            /* read a chunk */    if ((err != noErr) &amp;&amp; (err != eofErr)) {      DebugPrint (&quot;\pFSRead failed!&quot;);      break;    }    /*  Now, position the template over the data... */    chunkTemplate = (ChunkTemplatePtr) chunkBuffer;    /* assume a failure and break out of the do {} while loop if the next case isn't found.       if the case is found and no other error is detected, then each case needs to set noErr */    err = badFileFormat;                    switch (chunkTemplate-&gt;generic.ckID) {      case FORMID:                                  /* Format Version Chunk? */        /*  make sure that this is a standard, noncompressed AIFF file. */        if ((chunkFlags &amp; kFORM) == false) {                    /* see if this chunk already exists */          chunkFlags |= kFORM;                          /* otherwise mark it found */          theSoundInfo-&gt;bytesTotal = chunkTemplate-&gt;container.ckSize;          filePosition += sizeof (ContainerChunk);    /* Can't use ckSize because it's the size of the file, not this header */          type = chunkTemplate-&gt;container.formType;          err = noErr;        }        break;      case FormatVersionID:                              /* Format Version Chunk? */        if ((chunkFlags &amp; kFormatVersion) == false) {                /* see if this chunk already exists */          chunkFlags |= kFormatVersion;                      /* otherwise mark it found */          filePosition += chunkTemplate-&gt;formatVersion.ckSize + kChunkHeaderSize;  /* calculate next chunk's position */          if (chunkTemplate-&gt;formatVersion.timestamp != AIFCVersion1) {            err = kUnknownFormat;          }          else {            err = noErr;          }        }        break;      case CommonID:        if ((chunkFlags &amp; kCommon) == false) {                    /* see if this chunk already exists */          long double    tempLD  = 0.0;          chunkFlags |= kCommon;                          /* otherwise mark it found */          filePosition += chunkTemplate-&gt;common.ckSize + kChunkHeaderSize;    /* calculate next chunk's position */          #ifdef powerc            x80told (&amp;(chunkTemplate-&gt;common.sampleRate), &amp;tempLD);          #else            tempLD = chunkTemplate-&gt;common.sampleRate;          #endif          sampleRate = ASoundLongDoubleToFix (tempLD);          if (type == AIFCID) {             err = SetupDBHeader  (theSoundInfo,                      sampleRate,                      chunkTemplate-&gt;common.sampleSize,                      chunkTemplate-&gt;common.numChannels,                      fixedCompression,                      chunkTemplate-&gt;extCommon.compressionType);            theSoundInfo-&gt;needsMasking = false;          }          else {            err = SetupDBHeader  (theSoundInfo,                      sampleRate,                      chunkTemplate-&gt;common.sampleSize,                      chunkTemplate-&gt;common.numChannels,                      notCompressed,                      NoneType);            if (chunkTemplate-&gt;common.sampleSize == kSixteen) {              theSoundInfo-&gt;needsMasking = false;            }            else {              theSoundInfo-&gt;needsMasking = true;            }          }        }        break;      case SoundDataID:        if ((chunkFlags &amp; kSoundData) == false) {                        /* see if this chunk already exists */          /*  Let's remember where the Sound Data starts, so we can find the position in the file later.            The mark will be positioned at the beginning of the chunk, so move 16 bytes past to get past            the header information to the data. */          theSoundInfo-&gt;dataStart = filePosition + 16;          *length = chunkTemplate-&gt;soundData.ckSize - kChunkHeaderSize;          chunkFlags |= kSoundData;                              /* otherwise mark it found */          filePosition += chunkTemplate-&gt;soundData.ckSize + kChunkHeaderSize;          /* calculate next chunk's position */          err = noErr;        }        break;      case 'wave':        filePosition += chunkTemplate-&gt;generic.ckSize + kChunkHeaderSize;        BlockMoveData ((char*)(&amp;(chunkTemplate-&gt;generic)) + kChunkHeaderSize, waveData, chunkTemplate-&gt;generic.ckSize);        err = noErr;        break;      /*          The following list of chunks we don't care about, so we'll just skip over them.      */      case MarkerID:        if ((chunkFlags &amp; kMarker) == false) {                          /* see if this chunk already exists */          chunkFlags |= kMarker;                                /* otherwise mark it found */          filePosition += chunkTemplate-&gt;marker.ckSize + kChunkHeaderSize;          /* calculate next chunk's position */          err = noErr;        }        break;      case CommentID:        if ((chunkFlags &amp; kComment) == false) {                          /* see if this chunk already exists */          chunkFlags |= kComment;                                /* otherwise mark it found */          filePosition += chunkTemplate-&gt;comments.ckSize + kChunkHeaderSize;          /* calculate next chunk's position */          err = noErr;        }        break;      case InstrumentID:        if ((chunkFlags &amp; kInstrument) == false) {                        /* see if this chunk already exists */          chunkFlags |= kInstrument;                              /* otherwise mark it found */          filePosition += chunkTemplate-&gt;instrument.ckSize + kChunkHeaderSize;        /* calculate next chunk's position */          err = noErr;        }        break;      case MIDIDataID:        if ((chunkFlags &amp; kMIDIData) == false) {                        /* see if this chunk already exists */          chunkFlags |= kMIDIData;                              /* otherwise mark it found */          filePosition += chunkTemplate-&gt;midiData.ckSize + kChunkHeaderSize;          /* calculate next chunk's position */          err = noErr;        }        break;      case AudioRecordingID:        if ((chunkFlags &amp; kAudioRecording) == false) {                      /* see if this chunk already exists */          chunkFlags |= kAudioRecording;                            /* otherwise mark it found */          filePosition += chunkTemplate-&gt;audioRecording.ckSize + kChunkHeaderSize;      /* calculate next chunk's position */          err = noErr;        }        break;      case ApplicationSpecificID:        if ((chunkFlags &amp; kApplicationSpecific) == false) {                    /* see if this chunk already exists */          chunkFlags |= kApplicationSpecific;                          /* otherwise mark it found */          filePosition += chunkTemplate-&gt;generic.ckSize + kChunkHeaderSize;          /* calculate next chunk's position */          err = noErr;        }        break;      case NameID:        if ((chunkFlags &amp; kName) == false) {                          /* see if this chunk already exists */          chunkFlags |= kName;                                /* otherwise mark it found */          filePosition += chunkTemplate-&gt;generic.ckSize + kChunkHeaderSize;          /* calculate next chunk's position */          err = noErr;        }        break;      case AuthorID:        if ((chunkFlags &amp; kAuthor) == false) {                          /* see if this chunk already exists */          chunkFlags |= kAuthor;                                /* otherwise mark it found */          filePosition += chunkTemplate-&gt;generic.ckSize + kChunkHeaderSize;          /* calculate next chunk's position */          err = noErr;        }        break;      case CopyrightID:        if ((chunkFlags &amp; kCopyright) == false) {                        /* see if this chunk already exists */          chunkFlags |= kCopyright;                              /* otherwise mark it found */          filePosition += chunkTemplate-&gt;generic.ckSize + kChunkHeaderSize;          /* calculate next chunk's position */          err = noErr;        }        break;      case AnnotationID:        if ((chunkFlags &amp; kAnnotation) == false) {                        /* see if this chunk already exists */          chunkFlags |= kAnnotation;                              /* otherwise mark it found */          filePosition += chunkTemplate-&gt;generic.ckSize + kChunkHeaderSize;          /* calculate next chunk's position */          err = noErr;        }        break;      default :                                          /* Unrecognized?? croak. */        DebugPrint (&quot;\pran into an undefined chunk!!&quot;);        filePosition += chunkTemplate-&gt;generic.ckSize + kChunkHeaderSize;          /* calculate next chunk's position */        err = noErr;        break;    }  /*  We're only done when the the FORM, FormatVersion, Common and Sound Data chunks.  This is only    true of this incarnation - your needs may vary, so you'll have to modify the following statement    accordingly...    I know, this clause is a pain in the ass:  what it really says is this:      As long as we have a FORM Chunk and we don't have all of the {Formatversion, Common, SoundData} chunks      keep going... AND we haven't gotten an error from the file system. */  } while (stillMoreDataToRead);  if (err != noErr) {    DebugPrint (&quot;\pError in ASoundGetAIFFHeader&quot;);  }  return err;}</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/QT_QDesign_decomp/listing7.html%3Fid%3DDTS10000911-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/QT_QDesign_decomp/listing7.html%3Fid%3DDTS10000911-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/QT_QDesign_decomp/listing7.html%3Fid%3DDTS10000911-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>