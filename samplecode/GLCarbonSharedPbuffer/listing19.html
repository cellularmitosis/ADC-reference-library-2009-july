<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>GLCarbonSharedPbuffer - /main.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/GraphicsImaging/index.html">Graphics & Imaging</a> &gt; <a href="../../samplecode/GraphicsImaging/idxOpenGL-date.html">OpenGL</a> &gt; <A HREF="javascript:location.replace('index.html');">GLCarbonSharedPbuffer</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">GLCarbonSharedPbuffer</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/main.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/camera.h</option>
<option value="listing2.html">/drawInfo.h</option>
<option value="listing3.html">/glCheck.c</option>
<option value="listing4.html">/glCheck.h</option>
<option value="listing5.html">/HID Support/HID_Config_Utilities.c</option>
<option value="listing6.html">/HID Support/HID_Config_Utilities.h</option>
<option value="listing7.html">/HID Support/HID_Error_Handler.c</option>
<option value="listing8.html">/HID Support/HID_Error_Handler.h</option>
<option value="listing9.html">/HID Support/HID_Name_Lookup.c</option>
<option value="listing10.html">/HID Support/HID_Name_Lookup.h</option>
<option value="listing11.html">/HID Support/HID_Queue_Utilities.c</option>
<option value="listing12.html">/HID Support/HID_Queue_Utilities.h</option>
<option value="listing13.html">/HID Support/HID_Utilities.c</option>
<option value="listing14.html">/HID Support/HID_Utilities.h</option>
<option value="listing15.html">/HID Support/HID_Utilities_External.h</option>
<option value="listing16.html">/HID Support/HID_Utilities_Internal.h</option>
<option value="listing17.html">/HID Support/HIDSupport.c</option>
<option value="listing18.html">/HID Support/HIDSupport.h</option>
<option value="listing19.html">/main.c</option>
<option value="listing20.html">/main.h</option>
<option value="listing21.html">/pbuffer.c</option>
<option value="listing22.html">/pbuffer.h</option>
<option value="listing23.html">/SurfaceGeometry.c</option>
<option value="listing24.html">/SurfaceGeometry.h</option>
<option value="listing25.html">/trackball.c</option>
<option value="listing26.html">/trackball.h</option></select>
				</p>
				</form>
				<p><strong><a href="GLCarbonSharedPbuffer.zip">Download Sample</a></strong> (&#147;GLCarbonSharedPbuffer.zip&#148;, 221.9K)<BR>
<strong><a href="GLCarbonSharedPbuffer.dmg">Download Sample</a></strong> (&#147;GLCarbonSharedPbuffer.dmg&#148;, 271.8K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*
 *  main.c
 *  Carbon OpenGL
 *
 *  Created by ggs on 13 Nov 2002

  Copyright:  Copyright &copy; 2002-2004 Apple Computer, Inc., All Rights Reserved

  Disclaimer:  IMPORTANT:  This Apple software is supplied to you by Apple Computer, Inc.
      (&quot;Apple&quot;) in consideration of your agreement to the following terms, and your
      use, installation, modification or redistribution of this Apple software
      constitutes acceptance of these terms.  If you do not agree with these terms,
      please do not use, install, modify or redistribute this Apple software.

      In consideration of your agreement to abide by the following terms, and subject
      to these terms, Apple grants you a personal, non-exclusive license, under Apple's
      copyrights in this original Apple software (the &quot;Apple Software&quot;), to use,
      reproduce, modify and redistribute the Apple Software, with or without
      modifications, in source and/or binary forms; provided that if you redistribute
      the Apple Software in its entirety and without modifications, you must retain
      this notice and the following text and disclaimers in all such redistributions of
      the Apple Software.  Neither the name, trademarks, service marks or logos of
      Apple Computer, Inc. may be used to endorse or promote products derived from the
      Apple Software without specific prior written permission from Apple.  Except as
      expressly stated in this notice, no other rights or licenses, express or implied,
      are granted by Apple herein, including but not limited to any patent rights that
      may be infringed by your derivative works or by other works in which the Apple
      Software may be incorporated.

      The Apple Software is provided by Apple on an &quot;AS IS&quot; basis.  APPLE MAKES NO
      WARRANTIES, EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION THE IMPLIED
      WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY AND FITNESS FOR A PARTICULAR
      PURPOSE, REGARDING THE APPLE SOFTWARE OR ITS USE AND OPERATION ALONE OR IN
      COMBINATION WITH YOUR PRODUCTS.

      IN NO EVENT SHALL APPLE BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL OR
      CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
      GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
      ARISING IN ANY WAY OUT OF THE USE, REPRODUCTION, MODIFICATION AND/OR DISTRIBUTION
      OF THE APPLE SOFTWARE, HOWEVER CAUSED AND WHETHER UNDER THEORY OF CONTRACT, TORT
      (INCLUDING NEGLIGENCE), STRICT LIABILITY OR OTHERWISE, EVEN IF APPLE HAS BEEN
      ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */
 

#include &lt;OpenGL/glu.h&gt;
#include &lt;OpenGL/glext.h&gt;

#include &quot;HIDSupport.h&quot;
#include &quot;glCheck.h&quot;
#include &quot;trackball.h&quot;
#include &quot;SurfaceGeometry.h&quot;
#include &quot;camera.h&quot;
#include &quot;pbuffer.h&quot;
#include &quot;main.h&quot;

// ==================================

recVec gOrigin = {0.0, 0.0, 0.0};

// single set of interaction flags and states
GLint gDollyPanStartPoint[2] = {0, 0};
GLfloat gTrackBallRotation [4] = {0.0f, 0.0f, 0.0f, 0.0f};
GLboolean gDolly = GL_FALSE;
GLboolean gPan = GL_FALSE;
GLboolean gTrackball = GL_FALSE;
AGLContext gTrackingContextInfo = NULL;

EventHandlerUPP gEvtHandler;      // main event handler
EventHandlerUPP gWinEvtHandler;      // window event handler

IBNibRef nibRef = NULL;

AbsoluteTime gStartTime;

char gErrorMessage[256] = &quot;&quot;; // buffer for error message output
float gErrorTime = 0.0;

// single pbuffer for offscreen rendering
pRecPbuffer gpPbuffer = NULL;
AGLContext gShareContext = NULL;

#pragma mark ---- OpenGL Capabilities ----

// GL configuration info globals
// see glcheck.h for more info
GLCaps * gDisplayCaps = NULL; // array of GLCaps
CGDisplayCount gNumDisplays = 0;
// related DM change notification:
DMExtendedNotificationUPP gConfigEDMUPP = NULL;

static void getCurrentCaps (void)
{
   // Check for existing opengl caps here
  // This can be called again with same display caps array when display configurations are changed and
  //   your info needs to be updated.  Note, if you are doing dynmaic allocation, the number of displays
  //   may change and thus you should always reallocate your display caps array.
  if (gDisplayCaps &amp;&amp; HaveOpenGLCapsChanged (gDisplayCaps, gNumDisplays)) { // see if caps have changed
    free (gDisplayCaps);
    gDisplayCaps = NULL;
  }
  if (!gDisplayCaps) { // if we do not have caps
    CheckOpenGLCaps (0, NULL, &amp;gNumDisplays); // will just update number of displays
    gDisplayCaps = (GLCaps*) malloc (sizeof (GLCaps) * gNumDisplays);
    CheckOpenGLCaps (gNumDisplays, gDisplayCaps, &amp;gNumDisplays);
  }
}

#pragma mark ---- Utilities ----

// return float elpased time in seconds since app start
static float getElapsedTime (void)
{  
  float deltaTime = (float) AbsoluteDeltaToDuration (UpTime(), gStartTime);
    if (0 &gt; deltaTime)  // if negative microseconds
    deltaTime /= -1000000.0;
    else        // else milliseconds
    deltaTime /= 1000.0;
  return deltaTime;
}

#pragma mark ---- Error Reporting ----

// C string to Pascal string
static void cstr2pstr (StringPtr outString, const char *inString)
{  
  unsigned short x = 0;
  do {
      outString [x + 1] = (unsigned char) inString [x];
    x++;
  } while ((inString [x] != 0)  &amp;&amp; (x &lt; 256));
  outString [0] = x;                  
}

// ---------------------------------

// error reporting as both window message and debugger string
void reportError (char * strError)
{
  Str255 strErr = &quot;\p&quot;;

  gErrorTime = getElapsedTime ();
  sprintf (gErrorMessage, &quot;Error: %s (at time: %0.1f secs)&quot;, strError, gErrorTime);
   
  // out as debug string
  cstr2pstr (strErr, gErrorMessage);
  DebugStr (strErr);
  fflush (stderr);
}

// ---------------------------------

// if error dump agl errors to debugger string, return error
OSStatus aglReportError (void)
{
  GLenum err = aglGetError();
  if (AGL_NO_ERROR != err) {
    char errStr[256];
    sprintf (errStr, &quot;AGL: %s&quot;,(char *) aglErrorString(err));
    reportError (errStr);
  }
  // ensure we are returning an OSStatus noErr if no error condition
  if (err == AGL_NO_ERROR)
    return noErr;
  else
    return (OSStatus) err;
}

// ---------------------------------

// if error dump gl errors to debugger string, return error
OSStatus glReportError (void)
{
  GLenum err = glGetError();
  if (GL_NO_ERROR != err) {
    char errStr[256];
    sprintf (errStr, &quot;GL: %s&quot;,(char *) gluErrorString(err));
    reportError (errStr);
  }
  // ensure we are returning an OSStatus noErr if no error condition
  if (err == GL_NO_ERROR)
    return noErr;
  else
    return (OSStatus) err;
}

#pragma mark ---- OpenGL Utilities ----

// C string drawing function
void drawCStringGL (char * cstrOut, GLuint fontList)
{
  GLint i = 0;
  while (cstrOut [i])
    glCallList (fontList + cstrOut[i++]);
}

// ---------------------------------

// AGL bitmpp font setup
GLuint buildFontGL (AGLContext ctx, GLint fontID, Style face, GLint size)
{
  GLuint listBase = glGenLists (256);
  if (aglUseFont (ctx, fontID , face, size, 0, 256, (long) listBase)) {
    glPixelStorei(GL_UNPACK_ROW_LENGTH, 0);
    glReportError ();
    return listBase;
  } else {
    reportError (&quot;aglUseFont failed\n&quot; );
    glPixelStorei(GL_UNPACK_ROW_LENGTH, 0);
    glDeleteLists (listBase, 256);
    return 0;
  }
}

// ---------------------------------

// delete font list passed in
void deleteFontGL (GLuint fontList)
{
  if (fontList)
    glDeleteLists (fontList, 256);
}

// ---------------------------------

// given a delta time in seconds and current roatation accel, velocity and position, update overall object rotation
void updateRotation (double deltaTime, GLfloat * fRot, GLfloat * fVel, GLfloat * fAccel, GLfloat * objectRotation )
{
  // update rotation based on vel and accel
  float rotation[4] = {0.0f, 0.0f, 0.0f, 0.0f};
  GLfloat fVMax = 2.0f;
  short i;
  // do velocities
  for (i = 0; i &lt; 3; i++) {
    fVel[i] += fAccel[i] * deltaTime * 30.0f;
    
    if (fVel[i] &gt; fVMax) {
      fAccel[i] *= -1.0f;
      fVel[i] = fVMax;
    } else if (fVel[i] &lt; -fVMax) {
      fAccel[i] *= -1.0f;
      fVel[i] = -fVMax;
    }
    
    fRot[i] += fVel[i] * deltaTime * 30.0f;
    
    while (fRot[i] &gt; 360.0f)
      fRot[i] -= 360.0f;
    while (fRot[i] &lt; -360.0f)
      fRot[i] += 360.0f;
  }
  rotation[0] = fRot[0];
  
  rotation[1] = 1.0f;
  addToRotationTrackball (rotation, objectRotation);
  rotation[0] = fRot[1];
  rotation[1] = 0.0f; rotation[2] = 1.0f;
  addToRotationTrackball (rotation, objectRotation);
  rotation[0] = fRot[2];
  rotation[2] = 0.0f; rotation[3] = 1.0f;
  addToRotationTrackball (rotation, objectRotation);
}

// ---------------------------------

#ifndef DTOR
  #define DTOR 0.0174532925
#endif

#ifndef MIN
  #define MIN(a, b) ((a) &lt; (b) ? (a) : (b))
#endif

// update the projection matrix based on camera and view info
// should be called when viewport size, eye z position, or camera aperture changes
// also call if far or near changes which is determined by shape size in this case
// current context should be set before calling
void updateProjection (GLdouble width, GLdouble height, GLdouble zPos, GLdouble aperture, GLdouble shapeSize)
{
  GLdouble xmin, xmax, ymin, ymax;
  // far frustum plane
  GLdouble zFar = -zPos + shapeSize * 0.5;
  // near frustum plane (clamped at 1.0)
  GLdouble zNear = MIN (-zPos - shapeSize * 0.5, 1.0);
  // view aspect ratio
  GLdouble aspect = width / height; 

  glMatrixMode (GL_PROJECTION);
  glLoadIdentity ();

  if (aspect &gt; 1.0) {
    ymax = zNear * tan (aperture * 0.5 * DTOR);
    ymin = -ymax;
    xmin = ymin * aspect;
    xmax = ymax * aspect;
  } else {
    xmax = zNear * tan (aperture * 0.5 * DTOR);
    xmin = -xmax;
    ymin = xmin / aspect;
    ymax = xmax / aspect;
  }
  glFrustum(xmin, xmax, ymin, ymax, zNear, zFar);
}

// ---------------------------------

// updates the contexts model view matrix for object and camera moves
// we will call this every draw loop for simplicity
// current context should be set before calling
void updateModelView (AGLContext aglContext, recCamera * pCamera, GLfloat * pSpinRot, GLfloat * pObjectRot, GLfloat * pWorldRot)
{
  // move view
  glMatrixMode (GL_MODELVIEW);
  glLoadIdentity ();
  gluLookAt (pCamera-&gt;viewPos.x, pCamera-&gt;viewPos.y, pCamera-&gt;viewPos.z,
         pCamera-&gt;viewPos.x + pCamera-&gt;viewDir.x,
         pCamera-&gt;viewPos.y + pCamera-&gt;viewDir.y,
         pCamera-&gt;viewPos.z + pCamera-&gt;viewDir.z,
         pCamera-&gt;viewUp.x, pCamera-&gt;viewUp.y ,pCamera-&gt;viewUp.z);
    
  if (pWorldRot) { // if we have a world rotation eval the track ball
    // if we have trackball rotation to map (this IS the test I want as it can be explicitly 0.0f)
    if ((gTrackingContextInfo == aglContext) &amp;&amp; gTrackBallRotation[0] != 0.0f) 
      glRotatef (gTrackBallRotation[0], gTrackBallRotation[1], gTrackBallRotation[2], gTrackBallRotation[3]);
    else {
    }
    // accumlated world rotation via trackball
    glRotatef (pWorldRot[0], pWorldRot[1], pWorldRot[2], pWorldRot[3]);
  }
  if (pObjectRot &amp;&amp; pSpinRot) {
    // object itself rotating applied after camera rotation
    glRotatef (pObjectRot[0], pObjectRot[1], pObjectRot[2], pObjectRot[3]);
    pSpinRot[0] = 0.0f; // reset animation rotations (do in all cases to prevent rotating while moving with trackball)
    pSpinRot[1] = 0.0f;
    pSpinRot[2] = 0.0f;
  }
}

// ---------------------------------

// handles resizing of GL need context update and if the window dimensions change, a
// a window dimension update, reseting of viewport and an update of the projection matrix
// this is a windowing system level routine so it handles setting context, etc.
// returns error if resize fails

OSStatus resizeGL (AGLContext aglContext, recCamera * pCamera, GLfloat shapeSize, CGRect viewRect)
{
    OSStatus err = noErr;

    if (!aglContext)
        return paramErr;

  // re-attach drawable to ensure context is updated
  if (!aglSetCurrentContext (aglContext))
    err = aglReportError ();
  if ((noErr == err) &amp;&amp; !aglUpdateContext (aglContext))
    err = aglReportError ();

// Must go directly to the stored value to proper check for differences with window size
// Note, it is likely a toss up as to whether blinding setting the viewport is faster than
// testing for changes
  if (noErr == err) {
    GLint aViewportDims[4];
    glGetIntegerv (GL_VIEWPORT, aViewportDims);
    if ((viewRect.size.width != aViewportDims[2]) ||
      (viewRect.size.height != aViewportDims[3])) {
      pCamera-&gt;viewOriginX = viewRect.origin.x;
      pCamera-&gt;viewOriginY = viewRect.origin.y;
      pCamera-&gt;viewWidth = viewRect.size.width;
      pCamera-&gt;viewHeight = viewRect.size.height;
      glViewport (0, 0, pCamera-&gt;viewWidth, pCamera-&gt;viewHeight);
    }
  }
    return err;
}

// ---------------------------------

// sets the camera data to initial conditions
void resetCamera (recCamera * pCamera)
{
   pCamera-&gt;aperture = 40;
   pCamera-&gt;rotPoint = gOrigin;

   pCamera-&gt;viewPos.x = 0.0;
   pCamera-&gt;viewPos.y = 0.0;
   pCamera-&gt;viewPos.z = -9.0;
   pCamera-&gt;viewDir.x = -pCamera-&gt;viewPos.x; 
   pCamera-&gt;viewDir.y = -pCamera-&gt;viewPos.y; 
   pCamera-&gt;viewDir.z = -pCamera-&gt;viewPos.z;

   pCamera-&gt;viewUp.x = 0;  
   pCamera-&gt;viewUp.y = 1; 
   pCamera-&gt;viewUp.z = 0;

  // will be set in resize once the target view size and position is known
  pCamera-&gt;viewOriginY = 0;
  pCamera-&gt;viewOriginX = 0;
  pCamera-&gt;viewHeight = 0;
  pCamera-&gt;viewWidth = 0;
}

// ---------------------------------

void SetLighting (unsigned int mode)
{
  GLfloat mat_specular[] = {1.0, 1.0, 1.0, 1.0};
  GLfloat mat_shininess[] = {90.0};

  GLfloat position[4] = {7.0,-7.0,12.0,0.0};
  GLfloat ambient[4]  = {0.2,0.2,0.2,1.0};
  GLfloat diffuse[4]  = {1.0,1.0,1.0,1.0};
  GLfloat specular[4] = {1.0,1.0,1.0,1.0};
  
  glMaterialfv (GL_FRONT_AND_BACK, GL_SPECULAR, mat_specular);
  glMaterialfv (GL_FRONT_AND_BACK, GL_SHININESS, mat_shininess);
  
  glEnable(GL_COLOR_MATERIAL);
  glColorMaterial(GL_FRONT_AND_BACK,GL_AMBIENT_AND_DIFFUSE);

  switch (mode) {
    case 0:
      break;
    case 1:
      glLightModeli(GL_LIGHT_MODEL_TWO_SIDE,GL_FALSE);
      glLightModeli(GL_LIGHT_MODEL_LOCAL_VIEWER,GL_FALSE);
      break;
    case 2:
      glLightModeli(GL_LIGHT_MODEL_TWO_SIDE,GL_FALSE);
      glLightModeli(GL_LIGHT_MODEL_LOCAL_VIEWER,GL_TRUE);
      break;
    case 3:
      glLightModeli(GL_LIGHT_MODEL_TWO_SIDE,GL_TRUE);
      glLightModeli(GL_LIGHT_MODEL_LOCAL_VIEWER,GL_FALSE);
      break;
    case 4:
      glLightModeli(GL_LIGHT_MODEL_TWO_SIDE,GL_TRUE);
      glLightModeli(GL_LIGHT_MODEL_LOCAL_VIEWER,GL_TRUE);
      break;
  }
  
  glLightfv(GL_LIGHT0,GL_POSITION,position);
  glLightfv(GL_LIGHT0,GL_AMBIENT,ambient);
  glLightfv(GL_LIGHT0,GL_DIFFUSE,diffuse);
  glLightfv(GL_LIGHT0,GL_SPECULAR,specular);
  glEnable(GL_LIGHT0);
}

#pragma mark ---- OpenGL Minimize Handler (thanks to Dan Herman) ----

void InvertGLImage( char *imageData, size_t imageSize, size_t rowBytes )
{
  long i, j;
  char *tBuffer = (char*) malloc (rowBytes);
  if (NULL == tBuffer) return;
    
  // Copy by rows through temp buffer
  for (i = 0, j = imageSize - rowBytes; i &lt; imageSize &gt;&gt; 1; i += rowBytes, j -= rowBytes) {
    memcpy( tBuffer, &amp;imageData[i], rowBytes );
    memcpy( &amp;imageData[i], &amp;imageData[j], rowBytes );
    memcpy( &amp;imageData[j], tBuffer, rowBytes );
  }
  free(tBuffer);
}

// ---------------------------------

void CompositeGLBufferIntoWindow (AGLContext ctx, Rect *bufferRect, WindowRef win)
{
  GWorldPtr pGWorld;
  QDErr err;
  // blit OpenGL content into window backing store
  // allocate buffer to hold pane image
  long width  = (bufferRect-&gt;right - bufferRect-&gt;left);
  long height  = (bufferRect-&gt;bottom - bufferRect-&gt;top);
  Rect src_rect = {0, 0, height, width};
  long rowBytes = width * 4;
  long imageSize = rowBytes * height;
  char *image = (char *) NewPtr (imageSize);
  if (!image) {
    printf(&quot;Out of memory in CompositeGLBufferIntoWindow()!&quot;);
    return;    // no harm in continuing
  }
  
  // pull GL content down to our image buffer
  aglSetCurrentContext( ctx );
  glReadPixels (0, 0, width, height, GL_BGRA, GL_UNSIGNED_INT_8_8_8_8_REV, image);

  // GL buffers are upside-down relative to QD buffers, so we need to flip it
  InvertGLImage( image, imageSize, rowBytes );

  // create a GWorld containing our image
  err = NewGWorldFromPtr (&amp;pGWorld, k32ARGBPixelFormat, &amp;src_rect, 0, 0, 0, image, rowBytes);
  if (err != noErr) {
    printf(&quot;WARNING: error in NewGWorldFromPtr, called from CompositeGLBufferIntoWindow()&quot;);
    free( image );
    return;
  }
  
  SetPort( GetWindowPort (win));
  CopyBits( GetPortBitMapForCopyBits (pGWorld), GetPortBitMapForCopyBits (GetWindowPort (win)), &amp;src_rect, bufferRect, srcCopy, 0 );

  DisposeGWorld( pGWorld );
  DisposePtr ( image );
}

#pragma mark ---- Display Manager Event Handling ----

// update our GL configuration info based on display change notification
void handleConfigDMEvent (void *userData, short theMessage, void *notifyData)
{
  if (kDMNotifyEvent == theMessage) { // post change notifications only
    getCurrentCaps ();
  }
}

// ---------------------------------

// handle display config changes meaing we need to update the GL context via the resize function and check for windwo dimension changes
// also note we redraw the content here as it could be lost in a display config change
void handleWindowDMEvent (void *userData, short theMessage, void *notifyData)
{
  if (kDMNotifyEvent == theMessage) { // post change notifications only
    pRecContext pContextInfo = NULL;
    WindowRef window = (WindowRef) userData;
    if (window)
      pContextInfo = GetCurrentContextInfo (window);
    if (pContextInfo) { // have a valid OpenGl window
      Rect rectPort;
      CGRect viewRect = {{0.0f, 0.0f}, {0.0f, 0.0f}};
#if DEBUG
      sprintf (pContextInfo-&gt;message, &quot;Event: Display Change at %0.1f secs&quot;, getElapsedTime ());
      pContextInfo-&gt;msgTime = getElapsedTime ();
#endif
      GetWindowPortBounds (window, &amp;rectPort);
      viewRect.size.width = (float) (rectPort.right - rectPort.left);
      viewRect.size.height = (float) (rectPort.bottom - rectPort.top);
      resizeGL (pContextInfo-&gt;aglContext, &amp;pContextInfo-&gt;camera, pContextInfo-&gt;shapeSize, viewRect);
      InvalWindowRect (window,  &amp;rectPort); // force redrow
    }
  }
}

#pragma mark ---- OpenGL Window ----

// intializes context conditions
static void initialConditions (pRecContext pContextInfo)
{
  BlockZero (pContextInfo, sizeof (recContext));
  resetCamera (&amp;pContextInfo-&gt;camera);
  pContextInfo-&gt;info = kInfoState;
  pContextInfo-&gt;drawHelp = 1;
  pContextInfo-&gt;timer = NULL;
}

// ---------------------------------

OSStatus buildGL (WindowRef window)
{
  OSStatus err = noErr;
#if kUseMultiSample
  GLint attrib[] = { AGL_RGBA, AGL_DOUBLEBUFFER, AGL_DEPTH_SIZE, 16, AGL_NO_RECOVERY, 
                     AGL_SAMPLE_BUFFERS_ARB, 1, AGL_SAMPLES_ARB, kSamples, AGL_NONE };
#else
  GLint attrib[] = { AGL_RGBA, AGL_DOUBLEBUFFER, AGL_DEPTH_SIZE, 16, AGL_NONE };
#endif
  ProcessSerialNumber psn = { 0, kCurrentProcess };

    pRecContext pContextInfo = GetCurrentContextInfo(window);    
    if (NULL == pContextInfo)
        return paramErr;
  if (pContextInfo-&gt;aglContext)
    return noErr; // already built
    
  // build context
  pContextInfo-&gt;aglContext = NULL;
  pContextInfo-&gt;aglPixFmt = aglChoosePixelFormat(NULL, 0, attrib);
  err = aglReportError ();
  if (pContextInfo-&gt;aglPixFmt) {
    pContextInfo-&gt;aglContext = aglCreateContext(pContextInfo-&gt;aglPixFmt, gShareContext);
    err = aglReportError ();
  }
#if kUseMultiSample
  // if multi-sample pixel format or context fails allocate a non-multi-sample one
  if ((noErr != err) || (NULL == pContextInfo-&gt;aglContext)) { // try non-multisample
    attrib[5] = attrib[6] = attrib[7] = attrib[8] = 0; // remove multi-sample attribs
    if (pContextInfo-&gt;aglPixFmt)
      aglDestroyPixelFormat (pContextInfo-&gt;aglPixFmt);
    pContextInfo-&gt;aglPixFmt = aglChoosePixelFormat (NULL, 0, attrib);
    err = aglReportError ();
    if (pContextInfo-&gt;aglPixFmt) {
      pContextInfo-&gt;aglContext = aglCreateContext (pContextInfo-&gt;aglPixFmt, gShareContext);
      err = aglReportError ();
    }
  }
#endif

  if (pContextInfo-&gt;aglContext) {
    Rect rectPort;
    short fNum;
    GLint swap = 1;
    CGRect viewRect = {{0.0f, 0.0f}, {0.0f, 0.0f}};

        GrafPtr portSave = NULL;
        GetPort (&amp;portSave);
        SetPort ((GrafPtr) GetWindowPort (window));

    if(!aglSetDrawable(pContextInfo-&gt;aglContext, GetWindowPort (window)))
      err = aglReportError ();
    if (!aglSetCurrentContext(pContextInfo-&gt;aglContext))
      err = aglReportError ();
    pContextInfo-&gt;currentVS = aglGetVirtualScreen (pContextInfo-&gt;aglContext);
      
    if (NULL == gShareContext)
      gShareContext = pContextInfo-&gt;aglContext; // share initial context created

    // ensure we know when display configs are changed
    pContextInfo-&gt;windowEDMUPP = NewDMExtendedNotificationUPP (handleWindowDMEvent); // for display change notification
    DMRegisterExtendedNotifyProc (pContextInfo-&gt;windowEDMUPP, (void *) window, NULL, &amp;psn);

    // VBL SYNC
    if (!aglSetInteger (pContextInfo-&gt;aglContext, AGL_SWAP_INTERVAL, &amp;swap))
      aglReportError ();

    // init GL stuff here
#if kUseMultiSample
    switch (pContextInfo-&gt;modeFSAA) {
      case kFSAAOff:
        glDisable (GL_MULTISAMPLE_ARB);
        break;
      case kFSAAFast:
        glEnable (GL_MULTISAMPLE_ARB);
        glHint (GL_MULTISAMPLE_FILTER_HINT_NV, GL_FASTEST);
        break;
      case kFSAANice:
        glEnable (GL_MULTISAMPLE_ARB);
        glHint (GL_MULTISAMPLE_FILTER_HINT_NV, GL_NICEST);
        break;
    }
#endif    
    glEnable(GL_DEPTH_TEST);
    glShadeModel(GL_SMOOTH);    
    glPolygonMode(GL_FRONT_AND_BACK,GL_FILL);
    glFrontFace(GL_CCW);
    glPolygonOffset (1.0, 1.0);
    glEnable (GL_ALPHA_TEST); 
    glAlphaFunc (GL_GREATER, 0.5);
    glEnable (GL_BLEND); // for text fading
    glBlendFunc (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA); // ditto
    glClearColor(0.0,0.0,0.0,0.0);

    pContextInfo-&gt;shapeSize = 11.0f; // max radius of of objects

    GetFNum (&quot;\pGeneva&quot;, &amp;fNum); // build font
    pContextInfo-&gt;boldFontList = buildFontGL (pContextInfo-&gt;aglContext, fNum, bold, 9);
    pContextInfo-&gt;regFontList = buildFontGL (pContextInfo-&gt;aglContext, fNum, normal, 9);

    // setup viewport and prespective
    GetWindowPortBounds (window, &amp;rectPort);
    viewRect.size.width = (float) (rectPort.right - rectPort.left);
    viewRect.size.height = (float) (rectPort.bottom - rectPort.top);
    pContextInfo-&gt;camera.viewOriginX = viewRect.origin.x;
    pContextInfo-&gt;camera.viewOriginY = viewRect.origin.y;
    pContextInfo-&gt;camera.viewWidth = viewRect.size.width;
    pContextInfo-&gt;camera.viewHeight = viewRect.size.height;
    glViewport (0, 0, pContextInfo-&gt;camera.viewWidth, pContextInfo-&gt;camera.viewHeight);
    
    // window geometry
#if kUseNonPowerOf2
    BuildGeometry (kCube, 0, 0, 0, &amp;pContextInfo-&gt;polyList, &amp;pContextInfo-&gt;lineList, &amp;pContextInfo-&gt;pointList, kPbufferWidth, kPbufferHeight);
#else    
    BuildGeometry (kCube, 0, 0, 0, &amp;pContextInfo-&gt;polyList, &amp;pContextInfo-&gt;lineList, &amp;pContextInfo-&gt;pointList, 0, 0);
#endif
        SetPort (portSave);
    }
    return err;
}

// ---------------------------------

// dump window data structures and OpenGL context and related data structures
OSStatus disposeGL (pRecContext pContextInfo)
{
  // release our data
    if ( pContextInfo != NULL )
    {
    if (pContextInfo-&gt;windowEDMUPP) { // dispose UPP for DM notifications
      DisposeDMExtendedNotificationUPP (pContextInfo-&gt;windowEDMUPP);
      pContextInfo-&gt;windowEDMUPP = NULL;
    }
    // do not need to dump pbuffer as it shared across all windows
    aglSetDrawable (pContextInfo-&gt;aglContext, NULL);
    aglSetCurrentContext (NULL);
    if (pContextInfo-&gt;aglContext) {
      aglDestroyContext (pContextInfo-&gt;aglContext);
      pContextInfo-&gt;aglContext = NULL;
    }
    if (pContextInfo-&gt;aglPixFmt) {
      aglDestroyPixelFormat (pContextInfo-&gt;aglPixFmt);
      pContextInfo-&gt;aglPixFmt = NULL;
    }
    if (pContextInfo-&gt;timer) {
      RemoveEventLoopTimer(pContextInfo-&gt;timer);
      pContextInfo-&gt;timer = NULL;
    }
    // dump font display list
    if (pContextInfo-&gt;boldFontList) {
      deleteFontGL (pContextInfo-&gt;boldFontList);
      pContextInfo-&gt;boldFontList = 0;
    }
    if (pContextInfo-&gt;regFontList) {
      deleteFontGL (pContextInfo-&gt;regFontList);
      pContextInfo-&gt;regFontList = 0;
    }
    }
    
    return noErr;
}

// ---------------------------------

#include &quot;drawInfo.h&quot; // source info for info output

// ---------------------------------

// draw text info
// note: this bitmap technique is not the speediest and one should use textures for font in performance critical code
static void drawInfo (pRecContext pContextInfo)
{  
  static float msgPresistance = 10.0f;
  char cstr [256];
  GLint matrixMode, line = 1;
  GLboolean depthTest = glIsEnabled (GL_DEPTH_TEST);
  GLfloat height, width;
  
  if (!pContextInfo)
    return;
  
  height = pContextInfo-&gt;camera.viewHeight;
  width = pContextInfo-&gt;camera.viewWidth;

  glDisable (GL_DEPTH_TEST); // ensure text is not remove by deoth buffer test.
  glEnable (GL_BLEND); // for text fading
  glBlendFunc (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA); // ditto
  
  // set orthograhic 1:1  pixel transform in local view coords
  glGetIntegerv (GL_MATRIX_MODE, &amp;matrixMode);
  glMatrixMode (GL_PROJECTION);
  glPushMatrix();
    glLoadIdentity ();
    glMatrixMode (GL_MODELVIEW);
    glPushMatrix();
      glLoadIdentity ();
      glScalef (2.0 / width, -2.0 /  height, 1.0);
      glTranslatef (-width / 2.0, -height / 2.0, 0.0);
      // output strings
      glColor3f (1.0, 1.0, 1.0);
      sprintf (cstr, &quot;Camera at (%0.1f, %0.1f, %0.1f) looking at (%0.1f, %0.1f, %0.1f) with %0.1f aperture&quot;, 
          pContextInfo-&gt;camera.viewPos.x, pContextInfo-&gt;camera.viewPos.y, pContextInfo-&gt;camera.viewPos.z,
          pContextInfo-&gt;camera.viewDir.x, pContextInfo-&gt;camera.viewDir.y, pContextInfo-&gt;camera.viewDir.z,
          pContextInfo-&gt;camera.aperture);
      glRasterPos3d (10, line++ * 12, 0); 
      drawCStringGL (cstr, pContextInfo-&gt;boldFontList);
      sprintf (cstr, &quot;World Rotation: (%0.1f, %0.2f, %0.2f, %0.2f)&quot;, 
               pContextInfo-&gt;worldRotation[0], pContextInfo-&gt;worldRotation[1], pContextInfo-&gt;worldRotation[2], pContextInfo-&gt;worldRotation[3]);
      glRasterPos3d (10, line++ * 12, 0); 
      drawCStringGL (cstr, pContextInfo-&gt;regFontList);
      sprintf (cstr, &quot;Vertices: %lu, Color Scheme: %lu&quot;, 
               gpPbuffer-&gt;subdivisions * gpPbuffer-&gt;xyRatio * gpPbuffer-&gt;subdivisions, gpPbuffer-&gt;colorScheme);
      glRasterPos3d (10, line++ * 12, 0); 
      drawCStringGL (cstr, pContextInfo-&gt;regFontList);
      {
        GLboolean twoSidedLighting, localViewer;
        glGetBooleanv (GL_LIGHT_MODEL_LOCAL_VIEWER, &amp;localViewer);
        glGetBooleanv (GL_LIGHT_MODEL_TWO_SIDE, &amp;twoSidedLighting);
        if (!gpPbuffer-&gt;lighting) {
          sprintf (cstr, &quot;-- Lighting off&quot;);
        } else {
          if (!twoSidedLighting)
            sprintf (cstr, &quot;-- Single Sided Lighting&quot;);
          else
            sprintf (cstr, &quot;-- Two Sided Lighting&quot;);
          if (localViewer)
            sprintf (cstr, &quot;%s: Local Viewer&quot;, cstr);
        }  
        glRasterPos3d (10, line++ * 12, 0); 
        drawCStringGL (cstr, pContextInfo-&gt;regFontList);
      }

      glRasterPos3d (10, line++ * 12, 0); 
#if kUseMultiSample
      switch (pContextInfo-&gt;modeFSAA) {
        case kFSAAOff:
          sprintf (cstr, &quot;-- %d x FSAA: Disabled&quot;, kSamples);
          break;
        case kFSAAFast:
          sprintf (cstr, &quot;-- %d x FSAA: Fastest hint&quot;, kSamples);
          break;
        case kFSAANice:
          sprintf (cstr, &quot;-- %d x FSAA: Nicest hint&quot;, kSamples);
          break;
      }
#else
      sprintf (cstr, &quot;-- FSAA: Not Used&quot;);
#endif
      drawCStringGL (cstr, pContextInfo-&gt;regFontList);

      // message string
      if (pContextInfo-&gt;message[0]) {
        float currDelta = getElapsedTime () - pContextInfo-&gt;msgTime;
        glColor4f (1.0, 1.0, 1.0, (msgPresistance - currDelta) * 0.1);
        glRasterPos3d (10, line++ * 12, 0); 
        drawCStringGL (pContextInfo-&gt;message, pContextInfo-&gt;boldFontList);
        if (currDelta &gt; msgPresistance)
          pContextInfo-&gt;message[0] = 0;
      }
      // global error message
      if (gErrorMessage[0]) {
        float currDelta = getElapsedTime () - gErrorTime;
        glColor4f (1.0, 0.2, 0.2, (msgPresistance - currDelta) * 0.1);
        glRasterPos3d (10, line++ * 12, 0); 
        drawCStringGL (gErrorMessage, pContextInfo-&gt;boldFontList);
        if (currDelta &gt; msgPresistance)
          gErrorMessage[0] = 0;
      }
      if (pContextInfo-&gt;showCredits) {
        char *strName, *strAuthor, *strX, *strY, *strZ, *strRange;
        GetStrings (gpPbuffer-&gt;surface, &amp;strName, &amp;strAuthor, &amp;strX, &amp;strY, &amp;strZ, &amp;strRange);
        line = 10;
        glColor3f (1.0f, 1.0f, 0.0f);
        glRasterPos3d (10, line++ * 12, 0); 
        drawCStringGL (strName, pContextInfo-&gt;boldFontList);
        glRasterPos3d (10, line++ * 12, 0); 
        drawCStringGL (strAuthor, pContextInfo-&gt;regFontList);
        glColor3f (0.7f, 0.7f, 0.0f);
        glRasterPos3d (10, line++ * 12, 0); 
        drawCStringGL (strX, pContextInfo-&gt;regFontList);
        glRasterPos3d (10, line++ * 12, 0); 
        drawCStringGL (strY, pContextInfo-&gt;regFontList);
        glRasterPos3d (10, line++ * 12, 0); 
        drawCStringGL (strZ, pContextInfo-&gt;regFontList);
        glRasterPos3d (10, line++ * 12, 0); 
        drawCStringGL (strRange, pContextInfo-&gt;regFontList);
      }
      if (pContextInfo-&gt;drawHelp) {
        line = 4;
        glColor3f (0.8f, 0.8f, 0.8f);
        glRasterPos3d (10, height - line++ * 12, 0); 
        drawCStringGL (&quot;\\: cycle surface type&quot;, pContextInfo-&gt;regFontList);
        glRasterPos3d (10, height - line++ * 12, 0); 
        drawCStringGL (&quot;; &amp; ': decrease/increase subdivisions&quot;, pContextInfo-&gt;regFontList);
        glRasterPos3d (10, height - line++ * 12, 0); 
        drawCStringGL (&quot;[ &amp; ]: cycle color scheme&quot;, pContextInfo-&gt;regFontList);
        glRasterPos3d (10, height - line++ * 12, 0); 
        drawCStringGL (&quot;'l': cycle lighting  'm': cycle full scene anti-aliasing&quot;, pContextInfo-&gt;regFontList);
        glRasterPos3d (10, height - line++ * 12, 0); 
        drawCStringGL (&quot;'p': toggle points   'w': toggle wireframe   'f': toggle fill&quot;, pContextInfo-&gt;regFontList);
        glRasterPos3d (10, height - line++ * 12, 0); 
        drawCStringGL (&quot;'?': toggle credits  'c': toggle OpenGL caps&quot;, pContextInfo-&gt;regFontList);
        glRasterPos3d (10, height - line++ * 12, 0); 
        drawCStringGL (&quot;Cmd-A: animate       Cmd-I: show info&quot;, pContextInfo-&gt;regFontList);
        glRasterPos3d (10, height - line++ * 12, 0); 
        drawCStringGL (&quot;Wheel: zoom camera&quot;, pContextInfo-&gt;boldFontList);
        glRasterPos3d (10, height - line++ * 12, 0); 
        drawCStringGL (&quot;Middle Button Drag: dolly object&quot;, pContextInfo-&gt;boldFontList);
        glRasterPos3d (10, height - line++ * 12, 0); 
        drawCStringGL (&quot;Right Button Drag: pan object&quot;, pContextInfo-&gt;boldFontList);
        glRasterPos3d (10, height - line++ * 12, 0); 
        drawCStringGL (&quot;Left Button Drag: rotate object&quot;, pContextInfo-&gt;boldFontList);
        glRasterPos3d (10, height - line++ * 12, 0); 
        drawCStringGL (&quot;-- Help ('h') --&quot;, pContextInfo-&gt;boldFontList);
      }

      glColor3f (1.0, 1.0, 1.0);
      glRasterPos3d (10, height - 27, 0); 
      sprintf (cstr, &quot;(%0.0f x %0.0f)&quot;, width, height);
      drawCStringGL (cstr, pContextInfo-&gt;boldFontList);
      // render and vendor info
      glRasterPos3d (10, height - 15, 0); 
      drawCStringGL ((char*) glGetString (GL_RENDERER), pContextInfo-&gt;boldFontList);
      glRasterPos3d (10, height - 3, 0); 
      drawCStringGL ((char*) glGetString (GL_VERSION), pContextInfo-&gt;regFontList);
      if (pContextInfo-&gt;drawCaps)
        drawCaps (pContextInfo);
    // reset orginal martices
    glPopMatrix(); // GL_MODELVIEW
    glMatrixMode (GL_PROJECTION);
  glPopMatrix();
  glMatrixMode (matrixMode);
  if (depthTest)
    glEnable (GL_DEPTH_TEST);
  glReportError ();
}

// ---------------------------------

// main OpenGL drawing function
void drawGL (WindowRef window, Boolean swap)
{
    pRecContext pContextInfo = NULL;
  Rect rectPort;
  CGRect viewRect = {{0.0f, 0.0f}, {0.0f, 0.0f}};
  
  if (window)
    pContextInfo = GetCurrentContextInfo (window);
  if (!pContextInfo)
        return;
  if (!pContextInfo-&gt;aglContext)
    buildGL(window);
   
  // update and draw pbuffer content
#pragma mark *** draw pbuffer content (if required) ***
  updatePbuffer (pContextInfo-&gt;aglContext, gpPbuffer);

  // set window as render target
  if (!aglSetCurrentContext (pContextInfo-&gt;aglContext))
    aglReportError ();
  if(!aglSetDrawable(pContextInfo-&gt;aglContext, GetWindowPort (window)))
    aglReportError ();

  GetWindowPortBounds (window, &amp;rectPort);
  viewRect.size.width = (float) (rectPort.right - rectPort.left);
  viewRect.size.height = (float) (rectPort.bottom - rectPort.top);
  resizeGL (pContextInfo-&gt;aglContext, &amp;pContextInfo-&gt;camera, pContextInfo-&gt;shapeSize, viewRect);
  updateProjection (pContextInfo-&gt;camera.viewWidth, pContextInfo-&gt;camera.viewHeight, pContextInfo-&gt;camera.viewPos.z,
            pContextInfo-&gt;camera.aperture, pContextInfo-&gt;shapeSize);
  updateModelView (pContextInfo-&gt;aglContext, &amp;pContextInfo-&gt;camera, 
                   NULL, NULL, pContextInfo-&gt;worldRotation);

  // clear our drawable
  glClear (GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
  
  glDisable(GL_LIGHTING);
#if kUseNonPowerOf2
  glEnable (GL_TEXTURE_RECTANGLE_EXT);
#else
  glEnable (GL_TEXTURE_2D);
#endif
  
#pragma mark *** bind to pbuffer for texturing ***
  bindPbuffer (pContextInfo-&gt;aglContext, gpPbuffer); // texture from Pbuffer
  glCallList (pContextInfo-&gt;polyList); // draws textured cube

#if kUseNonPowerOf2
  glDisable (GL_TEXTURE_RECTANGLE_EXT);
#else
  glDisable (GL_TEXTURE_2D);
#endif
  glReportError ();

    if (pContextInfo-&gt;info) 
    drawInfo (pContextInfo);

  if (swap)
    aglSwapBuffers (pContextInfo-&gt;aglContext);
  else
    glFlush();
}

#pragma mark ---- Carbon Timer ----

// per-window timer function, basic time based animation preformed here
static void timerContextCB (WindowRef window)
{
    pRecContext pContextInfo = NULL;
  if (window)
    pContextInfo = GetCurrentContextInfo (window);
  if (pContextInfo &amp;&amp; gpPbuffer-&gt;animate) { // if pbuffer is animating
    AbsoluteTime currTime = UpTime ();
    double deltaTime = (float) AbsoluteDeltaToDuration (currTime, pContextInfo-&gt;time);
    pContextInfo-&gt;time = currTime;  // reset for next time interval
    if (0 &gt; deltaTime)  // if negative microseconds
      deltaTime /= -1000000.0;
    else        // else milliseconds
      deltaTime /= 1000.0;
    if (deltaTime &lt; 10.0) { // skip large pauses
      drawGL (window, true); // required to do this directly to get animation during resize and drags
    }
  }
}

// ---------------------------------

// timer callback bottleneck
static pascal void timerCB (EventLoopTimerRef inTimer, void* userData)
{
  #pragma unused (inTimer)
    timerContextCB ((WindowRef) userData); // timer based update
}

// ---------------------------------

// get UPP for timer
static EventLoopTimerUPP getTimerUPP (void)
{
  static EventLoopTimerUPP  sTimerUPP = NULL;
  
  if (sTimerUPP == NULL)
    sTimerUPP = NewEventLoopTimerUPP (timerCB);
  
  return sTimerUPP;
}

#pragma mark ---- Carbon Event Handling ----

pRecContext GetCurrentContextInfo (WindowRef window)
{
  if (NULL == window)  // HID use this path
    window = FrontWindow ();
  if (window)
    return (pRecContext) GetWRefCon (window);
  else
    return NULL;
}

// ---------------------------------

// move camera in z axis
static void mouseDolly (HIPoint location, pRecContext pContextInfo)
{
  GLfloat dolly = (gDollyPanStartPoint[1] - location.y) * -pContextInfo-&gt;camera.viewPos.z / 300.0f;
  pContextInfo-&gt;camera.viewPos.z += dolly;
  if (pContextInfo-&gt;camera.viewPos.z == 0.0) // do not let z = 0.0
    pContextInfo-&gt;camera.viewPos.z = 0.0001;
  gDollyPanStartPoint[0] = location.x;
  gDollyPanStartPoint[1] = location.y;
}
  
// ---------------------------------
  
// move camera in x/y plane
static void mousePan (HIPoint location, pRecContext pContextInfo)
{
  GLfloat panX = (gDollyPanStartPoint[0] - location.x) / (900.0f / -pContextInfo-&gt;camera.viewPos.z);
  GLfloat panY = (gDollyPanStartPoint[1] - location.y) / (900.0f / -pContextInfo-&gt;camera.viewPos.z);
  pContextInfo-&gt;camera.viewPos.x -= panX;
  pContextInfo-&gt;camera.viewPos.y -= panY;
  gDollyPanStartPoint[0] = location.x;
  gDollyPanStartPoint[1] = location.y;
}

// ---------------------------------

// Handles global non-system mouse events for GL windows as follows:
// primary button = object tumble (trackball)
// secondary button (or cntl-primary) = pan
// tertiary button (or option-primary) = dolly
// wheel = aperture
  
static OSStatus handleWindowMouseEvents (EventHandlerCallRef myHandler, EventRef event)
{
    WindowRef      window = NULL;
    pRecContext     pContextInfo = NULL;
  OSStatus      result = eventNotHandledErr;
    UInt32         kind = GetEventKind (event);
  EventMouseButton  button = 0;
  HIPoint        location = {0.0f, 0.0f};
  UInt32        modifiers = 0;  
  long        wheelDelta = 0;    
  Rect         rectPort;

  // Mac OS X v10.1 and later
  // should this be front window???
  GetEventParameter(event, kEventParamWindowRef, typeWindowRef, NULL, sizeof(WindowRef), NULL, &amp;window);
  if (window)
    pContextInfo = GetCurrentContextInfo (window);
  if (!pContextInfo)
    return result; // not an application GLWindow so do not process (there is an exception)
  GetWindowPortBounds (window, &amp;rectPort);
    
  result = CallNextEventHandler(myHandler, event);  
  if (eventNotHandledErr == result) 
  { // only handle events not already handled (prevents wierd resize interaction)
    switch (kind) {
      // start trackball, pan, or dolly
      case kEventMouseDown:
        GetEventParameter(event, kEventParamMouseButton, typeMouseButton, NULL, sizeof(EventMouseButton), NULL, &amp;button);
        GetEventParameter(event, kEventParamWindowMouseLocation, typeHIPoint, NULL, sizeof(HIPoint), NULL, &amp;location);  // Mac OS X v10.1 and later
        GetEventParameter(event, kEventParamKeyModifiers, typeUInt32, NULL, sizeof(UInt32), NULL, &amp;modifiers);
        if ((button == kEventMouseButtonSecondary) || ((button == kEventMouseButtonPrimary) &amp;&amp; (modifiers &amp; controlKey))) { // pan
          if (gTrackball) { // if we are currently tracking, end trackball
            gTrackball = GL_FALSE;
            if (gTrackBallRotation[0] != 0.0)
              addToRotationTrackball (gTrackBallRotation, pContextInfo-&gt;worldRotation);
            gTrackBallRotation [0] = gTrackBallRotation [1] = gTrackBallRotation [2] = gTrackBallRotation [3] = 0.0f;
          } else if (gDolly) { // if we are currently dollying, end dolly
            gDolly = GL_FALSE;
          }
          gDollyPanStartPoint[0] = location.x;
          gDollyPanStartPoint[1] = location.y;
          gPan = GL_TRUE;
          gTrackingContextInfo = pContextInfo-&gt;aglContext;
        } else if ((button == kEventMouseButtonTertiary) || ((button == kEventMouseButtonPrimary) &amp;&amp; (modifiers &amp; optionKey))) { // dolly
          if (gTrackball) { // if we are currently tracking, end trackball
            gTrackball = GL_FALSE;
            if (gTrackBallRotation[0] != 0.0)
              addToRotationTrackball (gTrackBallRotation, pContextInfo-&gt;worldRotation);
            gTrackBallRotation [0] = gTrackBallRotation [1] = gTrackBallRotation [2] = gTrackBallRotation [3] = 0.0f;
          } else if (gPan) { // if we are currently panning, end pan
            gPan = GL_FALSE;
          }
          gDollyPanStartPoint[0] = location.x;
          gDollyPanStartPoint[1] = location.y;
          gDolly = GL_TRUE;
          gTrackingContextInfo = pContextInfo-&gt;aglContext;
        } else if (button == kEventMouseButtonPrimary)  { // trackball
          if (gDolly) { // if we are currently dollying, end dolly
            gDolly = GL_FALSE;
            gTrackingContextInfo = NULL;
          } else if (gPan) { // if we are currently panning, end pan
            gPan = GL_FALSE;
            gTrackingContextInfo = NULL;
          }
          startTrackball (location.x, location.y, 
                          pContextInfo-&gt;camera.viewOriginX, pContextInfo-&gt;camera.viewOriginY, 
                  pContextInfo-&gt;camera.viewWidth, pContextInfo-&gt;camera.viewHeight);
          gTrackball = GL_TRUE;
          gTrackingContextInfo = pContextInfo-&gt;aglContext;
        } 
        break;
      // stop trackball, pan, or dolly
      case kEventMouseUp:
        if (gDolly) { // end dolly
          gDolly = GL_FALSE;
        } else if (gPan) { // end pan
          gPan = GL_FALSE;
        } else if (gTrackball) { // end trackball
          gTrackball = GL_FALSE;
          if (gTrackBallRotation[0] != 0.0)
            addToRotationTrackball (gTrackBallRotation, pContextInfo-&gt;worldRotation);
          gTrackBallRotation [0] = gTrackBallRotation [1] = gTrackBallRotation [2] = gTrackBallRotation [3] = 0.0f;
        } 
        gTrackingContextInfo = NULL;
        break;
      // trackball, pan, or dolly
      case kEventMouseDragged:
        GetEventParameter(event, kEventParamWindowMouseLocation, typeHIPoint, NULL, sizeof(HIPoint), NULL, &amp;location);  // Mac OS X v10.1 and later
        if (gTrackball) {
          rollToTrackball (location.x, location.y, gTrackBallRotation);
          InvalWindowRect (window, &amp;rectPort);
        } else if (gDolly) {
          mouseDolly (location, pContextInfo);
          InvalWindowRect (window, &amp;rectPort);
        } else if (gPan) {
          mousePan (location, pContextInfo);
          InvalWindowRect (window, &amp;rectPort);
        }
        break;
      // aperature change
      case kEventMouseWheelMoved: 
        GetEventParameter(event, kEventParamMouseWheelDelta, typeLongInteger, NULL, sizeof(long), NULL, &amp;wheelDelta);
        if (wheelDelta)
        {
          GLfloat deltaAperture = wheelDelta * -pContextInfo-&gt;camera.aperture / 200.0f;
          pContextInfo-&gt;camera.aperture += deltaAperture;
          if (pContextInfo-&gt;camera.aperture &lt; 0.1) // do not let aperture &lt;= 0.1
            pContextInfo-&gt;camera.aperture = 0.1;
          if (pContextInfo-&gt;camera.aperture &gt; 179.9) // do not let aperture &gt;= 180
            pContextInfo-&gt;camera.aperture = 179.9;
          InvalWindowRect (window, &amp;rectPort);
        }
        break;
    }
    result = noErr;
  }  
  return result;
}

// ---------------------------------

// key input handler
static OSStatus handleKeyInput (EventHandlerCallRef myHandler, EventRef event, Boolean keyDown, void* userData)
{
  enum { kH = 0x04,   // toggle draw help
       kC = 0x08,   // toggle draw caps
       kLfSqBracket = 0x21,   // color scheme down
       kRtSqBracket = 0x1E,   // color scheme up
       kSemi = 0x29,   // decrease subdivisions
       kQuote = 0x27,   // increase subdivisions
       kF = 0x03,   // toggle fill
       kP = 0x23,   // toggle points
       kW = 0x0D,   // toggle wire
       kL = 0x25,   // next lighting model (wraps)
       kBackSlash = 0x2A,   // next shape (wraps)
       kQuestion = 0x2c,   // toggle credits
       kM = 0x2E  // cycle multi-sample
  };
  WindowRef window = (WindowRef) userData;
  OSStatus result = eventNotHandledErr;

  result = CallNextEventHandler(myHandler, event);  
  if (eventNotHandledErr == result) { 
    pRecContext pContextInfo = GetCurrentContextInfo (window);
    if (pContextInfo) {
      UInt32 keyCode;
      Rect rectPort = {0,0,0,0};
      GetEventParameter (event, kEventParamKeyCode, typeUInt32, NULL, sizeof(UInt32), NULL, &amp;keyCode);
#if DEBUG
      sprintf (pContextInfo-&gt;message, &quot;KeyCode: %lu (0x%lX)&quot;, keyCode, keyCode);
      pContextInfo-&gt;msgTime = getElapsedTime ();
#endif
      // handle keyboard input here
      if (keyDown) {
        switch (keyCode) {
          case kH:
            // toggle help
            pContextInfo-&gt;drawHelp = 1 - pContextInfo-&gt;drawHelp;
            GetWindowPortBounds (window, &amp;rectPort);
            InvalWindowRect (window, &amp;rectPort);
            result = noErr;
            break;
          case kC:
            // toggle caps
            pContextInfo-&gt;drawCaps = 1 - pContextInfo-&gt;drawCaps;
            GetWindowPortBounds (window, &amp;rectPort);
            InvalWindowRect (window, &amp;rectPort);
            result = noErr;
            break;
          case kQuestion: // credits
            pContextInfo-&gt;showCredits =  1 - pContextInfo-&gt;showCredits;
            GetWindowPortBounds (window, &amp;rectPort);
            InvalWindowRect (window, &amp;rectPort);
            break;
          case kF: // fill
            gpPbuffer-&gt;polygons =  1;
            gpPbuffer-&gt;lines = 0;
            gpPbuffer-&gt;points = 0;
            dirtyPbuffer (gpPbuffer);
            GetWindowPortBounds (window, &amp;rectPort);
            InvalWindowRect (window, &amp;rectPort);
            break;
          case kW: // lines
            gpPbuffer-&gt;polygons =  0;
            gpPbuffer-&gt;lines = 1;
            gpPbuffer-&gt;points = 0;
            dirtyPbuffer (gpPbuffer);
            GetWindowPortBounds (window, &amp;rectPort);
            InvalWindowRect (window, &amp;rectPort);
            break;
          case kP: // points
            gpPbuffer-&gt;polygons =  0;
            gpPbuffer-&gt;lines = 0;
            gpPbuffer-&gt;points = 1;
            dirtyPbuffer (gpPbuffer);
            GetWindowPortBounds (window, &amp;rectPort);
            InvalWindowRect (window, &amp;rectPort);
            break;
          case kL: // lighting
            gpPbuffer-&gt;lighting++;
            gpPbuffer-&gt;lighting %= 4;
            aglSetCurrentContext (gpPbuffer-&gt;aglContext);
            SetLighting (gpPbuffer-&gt;lighting);
            dirtyPbuffer (gpPbuffer);
            GetWindowPortBounds (window, &amp;rectPort);
            InvalWindowRect (window, &amp;rectPort);
            break;
          case kLfSqBracket: // next lower color scheme
            gpPbuffer-&gt;colorScheme -= 1;
            if (gpPbuffer-&gt;colorScheme &lt; 0)
              gpPbuffer-&gt;colorScheme = kColorSchemes - 1;
            aglSetCurrentContext (gpPbuffer-&gt;aglContext);
            BuildGeometry (gpPbuffer-&gt;surface, gpPbuffer-&gt;colorScheme, gpPbuffer-&gt;subdivisions, gpPbuffer-&gt;xyRatio,
                             &amp;(gpPbuffer-&gt;polyList), &amp;(gpPbuffer-&gt;lineList), &amp;(gpPbuffer-&gt;pointList), 0, 0);
            dirtyPbuffer (gpPbuffer);
            GetWindowPortBounds (window, &amp;rectPort);
            InvalWindowRect (window, &amp;rectPort);
            break;
          case kRtSqBracket: // next higher color scheme
            gpPbuffer-&gt;colorScheme += 1;
            if (gpPbuffer-&gt;colorScheme &gt; kColorSchemes)
              gpPbuffer-&gt;colorScheme = 0;
            aglSetCurrentContext (gpPbuffer-&gt;aglContext);
            BuildGeometry (gpPbuffer-&gt;surface, gpPbuffer-&gt;colorScheme, gpPbuffer-&gt;subdivisions, gpPbuffer-&gt;xyRatio,
                     &amp;(gpPbuffer-&gt;polyList), &amp;(gpPbuffer-&gt;lineList), &amp;(gpPbuffer-&gt;pointList), 0, 0);
            dirtyPbuffer (gpPbuffer);
            GetWindowPortBounds (window, &amp;rectPort);
            InvalWindowRect (window, &amp;rectPort);
            break;
          case kSemi: // next lower subdivision setting
            gpPbuffer-&gt;subdivisions = (GLuint) (gpPbuffer-&gt;subdivisions / 1.414213);
            if (gpPbuffer-&gt;subdivisions &lt; 8)
              gpPbuffer-&gt;subdivisions = 8;
            aglSetCurrentContext (gpPbuffer-&gt;aglContext);
            BuildGeometry (gpPbuffer-&gt;surface, gpPbuffer-&gt;colorScheme, gpPbuffer-&gt;subdivisions, gpPbuffer-&gt;xyRatio,
                             &amp;(gpPbuffer-&gt;polyList), &amp;(gpPbuffer-&gt;lineList), &amp;(gpPbuffer-&gt;pointList), 0, 0);
            dirtyPbuffer (gpPbuffer);
            GetWindowPortBounds (window, &amp;rectPort);
            InvalWindowRect (window, &amp;rectPort);
            break;
          case kQuote:
            gpPbuffer-&gt;subdivisions = (GLuint) (gpPbuffer-&gt;subdivisions * 1.414213);
            aglSetCurrentContext (gpPbuffer-&gt;aglContext);
            BuildGeometry (gpPbuffer-&gt;surface, gpPbuffer-&gt;colorScheme, gpPbuffer-&gt;subdivisions, gpPbuffer-&gt;xyRatio,
                             &amp;(gpPbuffer-&gt;polyList), &amp;(gpPbuffer-&gt;lineList), &amp;(gpPbuffer-&gt;pointList), 0, 0);
            dirtyPbuffer (gpPbuffer);
            GetWindowPortBounds (window, &amp;rectPort);
            InvalWindowRect (window, &amp;rectPort);
            break;
          case kBackSlash: // next higher surface
            gpPbuffer-&gt;surface += 1;
            gpPbuffer-&gt;surface %= kSurfaces;
            aglSetCurrentContext (gpPbuffer-&gt;aglContext);
            BuildGeometry (gpPbuffer-&gt;surface, gpPbuffer-&gt;colorScheme, gpPbuffer-&gt;subdivisions, gpPbuffer-&gt;xyRatio,
                             &amp;(gpPbuffer-&gt;polyList), &amp;(gpPbuffer-&gt;lineList), &amp;(gpPbuffer-&gt;pointList), 0, 0);
            dirtyPbuffer (gpPbuffer);
            GetWindowPortBounds (window, &amp;rectPort);
            InvalWindowRect (window, &amp;rectPort);
            break;
#if kUseMultiSample
          case kM: // multisample rotate
            pContextInfo-&gt;modeFSAA = (pContextInfo-&gt;modeFSAA + 1) % (kFSAANice + 1);
            switch (pContextInfo-&gt;modeFSAA) {
              case kFSAAOff:
                glDisable (GL_MULTISAMPLE_ARB);
                break;
              case kFSAAFast:
                glEnable (GL_MULTISAMPLE_ARB);
                glHint (GL_MULTISAMPLE_FILTER_HINT_NV, GL_FASTEST);
                break;
              case kFSAANice:
                glEnable (GL_MULTISAMPLE_ARB);
                glHint (GL_MULTISAMPLE_FILTER_HINT_NV, GL_NICEST);
                break;
            }
            GetWindowPortBounds (window, &amp;rectPort);
            InvalWindowRect (window, &amp;rectPort);
#endif
            break;
        }
      }
    }
  }
  return result;
}
  
// ---------------------------------

void createNewWindow (void)
{
    EventHandlerRef ref;
    EventTypeSpec list[] = { { kEventClassWindow, kEventWindowCollapsing },
               { kEventClassWindow, kEventWindowShown },
                             { kEventClassWindow, kEventWindowActivated },
                             { kEventClassWindow, kEventWindowClose },
                             { kEventClassWindow, kEventWindowDrawContent },
                             { kEventClassWindow, kEventWindowBoundsChanged },
                             { kEventClassWindow, kEventWindowZoomed },
                             { kEventClassKeyboard, kEventRawKeyDown },
                             { kEventClassKeyboard, kEventRawKeyUp } };
  
    WindowRef window = NULL;
  pRecContext pContextInfo = (pRecContext) NewPtrClear (sizeof (recContext)); // memory for window record
  initialConditions (pContextInfo);
  CreateWindowFromNib (nibRef, CFSTR(&quot;MainWindow&quot;), &amp;window); // build window
  if (window)
  {
    SetWRefCon (window, (long) pContextInfo); // point to the window record in the ref con of the window
    InstallWindowEventHandler (window, gWinEvtHandler, GetEventTypeCount (list), list, (void*)window, &amp;ref); // add event handler
    ShowWindow (window);
    if (!pContextInfo-&gt;timer) {
      pContextInfo-&gt;time = UpTime ();
      InstallEventLoopTimer (GetCurrentEventLoop(), 0, 0.01, getTimerUPP (), (void *) window, &amp;pContextInfo-&gt;timer);
    }
  }
}
  
// ---------------------------------

// window event handler
static pascal OSStatus windowEvtHndlr (EventHandlerCallRef myHandler, EventRef event, void* userData)
{
#pragma unused (userData)
  WindowRef      window = NULL;
    pRecContext      pContextInfo = NULL;
  Rect        rectPort = {0,0,0,0};
  CGRect         viewRect = {{0.0f, 0.0f}, {0.0f, 0.0f}};
    OSStatus      result = eventNotHandledErr;
    UInt32         class = GetEventClass (event);
    UInt32         kind = GetEventKind (event);

  switch (class) {
    case kEventClassKeyboard:
      switch (kind) {
        case kEventRawKeyDown:
          result = handleKeyInput  (myHandler, event, true, userData);
          break;
        case kEventRawKeyUp:
          result = handleKeyInput  (myHandler, event, false, userData);
          break;
      }
      break;
    case kEventClassWindow:
      GetEventParameter(event, kEventParamDirectObject, typeWindowRef, NULL, sizeof(WindowRef), NULL, &amp;window);
      switch (kind) {
        case kEventWindowCollapsing:
          pContextInfo = GetCurrentContextInfo (window);
          GetWindowPortBounds (window, &amp;rectPort);
          drawGL (window, false); // in this case just draw content
          CompositeGLBufferIntoWindow( pContextInfo-&gt;aglContext, &amp;rectPort, window);
          result = UpdateCollapsedWindowDockTile (window);
          break;
        case kEventWindowActivated: // called on click activation and initially
          // handle any differences between active and not active here
          break;
        case kEventWindowDrawContent: // will receive one prior to being shown...
          drawGL (window, true);
          break;
        case kEventWindowClose: // called when window is being closed (close box)
          HideWindow (window);
          pContextInfo = GetCurrentContextInfo (window);
          disposeGL (pContextInfo);
          DisposePtr ((Ptr) pContextInfo);
              SetWRefCon (window, NULL);
          break;
        case kEventWindowShown: // called on initial show (not on un-minimize)
          // draw content is received prior to this so if you handle that then not drawing required here
          if (window == FrontWindow ())
            SetUserFocusWindow (window);
          break;
        case kEventWindowBoundsChanged: // called for resize and moves (drag)
          pContextInfo = GetCurrentContextInfo (window);  
          if (pContextInfo) { // if we have a vlaid context
            GetWindowPortBounds (window, &amp;rectPort); // get the bounds and set the view rect
            viewRect.size.width = (float) (rectPort.right - rectPort.left);
            viewRect.size.height = (float) (rectPort.bottom - rectPort.top);
            if ((viewRect.size.height &lt; pContextInfo-&gt;camera.viewHeight) || // if we are shrinking the window
                (viewRect.size.width &lt; pContextInfo-&gt;camera.viewWidth)) {
              // resize prior to update
              resizeGL (pContextInfo-&gt;aglContext, &amp;pContextInfo-&gt;camera, pContextInfo-&gt;shapeSize, viewRect); // forces updateContext &amp; viewport update if required
              drawGL (window, true); // force immediate update to get live resize on shrink
            } else {
              // resize to update context virtual screen
              resizeGL (pContextInfo-&gt;aglContext, &amp;pContextInfo-&gt;camera, pContextInfo-&gt;shapeSize, viewRect); // forces updateContext &amp; viewport update if required
              if (pContextInfo-&gt;currentVS != aglGetVirtualScreen (pContextInfo-&gt;aglContext)) { // if virtual screen (i.e. renderer) changes
                pContextInfo-&gt;currentVS = aglGetVirtualScreen (pContextInfo-&gt;aglContext); // sync renderer
                drawGL (window, true); // force immediate update to get update on screen (renderer) switch
              }
            }
          }
          break;
        case kEventWindowZoomed: // called when user clicks on zoom button (occurs after the window has been zoomed)
          // use this if you need to some special here as you always get a kEventWindowBoundsChanged event
          break;
      }
      break;
  }
    return result;
}

// ---------------------------------

// application level event handler
static pascal OSStatus appEvtHndlr (EventHandlerCallRef myHandler, EventRef event, void* userData)
{
#pragma unused (myHandler, userData)
    OSStatus result = eventNotHandledErr;
    Rect rectPort;
    pRecContext pContextInfo = NULL;
    WindowRef window = FrontWindow ();
    UInt32 class = GetEventClass (event);
    UInt32 kind = GetEventKind (event);
    HICommand command;

    if (window) { // do we have a window?
        GetWindowPortBounds (window, &amp;rectPort); // get bounds for later inval
        pContextInfo = GetCurrentContextInfo (window);
    }
  
  switch (class) {
    case kEventClassMouse:
      handleWindowMouseEvents (myHandler, event);
      break;
    case kEventClassCommand:
      switch (kind) {
        case kEventProcessCommand:
          GetEventParameter (event, kEventParamDirectObject, kEventParamHICommand, NULL, sizeof(command), NULL, &amp;command); // get command
          switch (command.commandID) {
            case kHICommandNew:
              createNewWindow ();
              result = noErr;
              break;
            case kHICommandClose:
              if (window) {
                HideWindow (window);
                disposeGL (GetCurrentContextInfo(window));  // dump our structures
                DisposeWindow (window); // if it exists dump it
              }
              break;
            case kHICommandQuit:
              //memory will get dumped on exit, other callbacks/timers are for this process only
              break;
            case 'gogo':
              if (gpPbuffer) {  // have pbuffer info (global control)
                gpPbuffer-&gt;animate = 1 - gpPbuffer-&gt;animate;
              }
              break;
            case 'info':
              if (pContextInfo) {  // have window info
                pContextInfo-&gt;info = 1 - pContextInfo-&gt;info;
                GetWindowPortBounds (window, &amp;rectPort);
                InvalWindowRect (window, &amp;rectPort);
              }
              break;
          }
          break;
        case kEventCommandUpdateStatus: // menu updates
          GetEventParameter (event, kEventParamDirectObject, kEventParamHICommand, NULL, sizeof(command), NULL, &amp;command); // get command
          switch (command.commandID) {
            case kHICommandClose:
              if (pContextInfo)
                EnableMenuItem (GetMenuHandle (kMainMenu), kCloseMenuItem);
              else 
                DisableMenuItem (GetMenuHandle (kMainMenu), kCloseMenuItem);
              break;
            case 'gogo':
              if (pContextInfo) {
                EnableMenuItem (GetMenuHandle (kMainMenu), kAnimateMenuItem);
                CheckMenuItem (GetMenuHandle (kMainMenu), kAnimateMenuItem, gpPbuffer-&gt;animate);
              } else { 
                DisableMenuItem (GetMenuHandle (kMainMenu), kAnimateMenuItem);
                CheckMenuItem (GetMenuHandle (kMainMenu), kAnimateMenuItem, kAnimateState);
              }
              break;
            case 'info':
              if (pContextInfo) {
                EnableMenuItem (GetMenuHandle (kMainMenu), kInfoMenuItem);
                CheckMenuItem (GetMenuHandle (kMainMenu), kInfoMenuItem, pContextInfo-&gt;info);
              } else { 
                DisableMenuItem (GetMenuHandle (kMainMenu), kInfoMenuItem);
                CheckMenuItem (GetMenuHandle (kMainMenu), kInfoMenuItem, kInfoState);
              }
              break;
          }
          result = noErr;
          break;
      }
      break;
  }
    return result;
}

#pragma mark ==== main ====

int main(int argc, char* argv[])
{
    OSStatus    err;
    EventHandlerRef  ref;
    EventTypeSpec  list[] = { { kEventClassCommand, kEventProcessCommand },
                 { kEventClassCommand, kEventCommandUpdateStatus },
                 { kEventClassMouse, kEventMouseDown },// handle trackball functionality globaly because there is only a single user
                 { kEventClassMouse, kEventMouseUp }, 
                 { kEventClassMouse, kEventMouseDragged },
                 { kEventClassMouse, kEventMouseWheelMoved } };
  ProcessSerialNumber psn = { 0, kCurrentProcess };
  Boolean fPbufferSupport = true;
  long i;
  EventRef windowEvent;

  gStartTime = UpTime (); // get app start time
  
    // Create a Nib reference passing the name of the nib file (without the .nib extension)
    // CreateNibReference only searches into the application bundle.
    err = CreateNibReference(CFSTR(&quot;main&quot;), &amp;nibRef);
    require_noerr( err, CantGetNibRef );
    err = SetMenuBarFromNib(nibRef, CFSTR(&quot;MainMenu&quot;));
    require_noerr( err, CantSetMenuBar );
  gEvtHandler = NewEventHandlerUPP(appEvtHndlr);
    err = InstallApplicationEventHandler (gEvtHandler, GetEventTypeCount (list), list, 0, &amp;ref);
    gWinEvtHandler = NewEventHandlerUPP(windowEvtHndlr);
  
  getCurrentCaps ();
  
  // ensure we know when display configs are changed
  gConfigEDMUPP = NewDMExtendedNotificationUPP (handleConfigDMEvent); // for display change notification
  DMRegisterExtendedNotifyProc (gConfigEDMUPP, NULL, NULL, &amp;psn);
  
  StartHIDInput ();
  
#pragma mark *** check for pbuffer functionality ***
  for (i = 0; i &lt; gNumDisplays; i++) {
    // ensure pbuffer extension is supported (cover issue in 10.3 that Radeon 9000 did not report correct pbuffer support)
    // a previous version of this sample had the work around for the GeForce 4 that was incorrect
    if (!(gDisplayCaps[i].fPixelBuffer) &amp;&amp; (0 != strcmp(gDisplayCaps[i].strRendererName, &quot;ATI Radeon 9000 OpenGL Engine&quot;)))
      fPbufferSupport = false;
  }

    if (err == noErr) { // post new window event
     err = MacCreateEvent (nil, kEventClassCommand, kEventProcessCommand, 0, kEventAttributeNone, &amp;windowEvent);
    if (err == noErr) {
      HICommand command; // set HI command parameter...
      command.commandID = kHICommandNew; command.attributes = 0; 
      command.menu.menuRef = 0; command.menu.menuItemIndex = 0;
      err = SetEventParameter(windowEvent, kEventParamDirectObject, kEventParamHICommand, sizeof(command), &amp;command);
      if (err == noErr)
        err = PostEventToQueue (GetCurrentEventQueue(), windowEvent, kEventPriorityHigh);
      ReleaseEvent (windowEvent);
    }
  }

    // Call the event loop
  if (fPbufferSupport) {
    // alloc/init Pbuffer
#pragma mark *** allocate and initialize pbuffer structure ***
    gpPbuffer = (pRecPbuffer) NewPtr (sizeof (recPbuffer));
    initialConditionsPbuffer (gpPbuffer);
    if (noErr != buildPbuffer (gpPbuffer))
      reportError (&quot;buildPbuffer failed.&quot;);
    else // we are doing fine, good ahead and run application
      RunApplicationEventLoop();
  } else
    reportError (&quot;Pbuffers not supported, must use Mac OS X v10.3 or later, exiting&quot;);
  
  // Exiting...

  if (gConfigEDMUPP) { // dispose UPP for DM notifications
    DisposeDMExtendedNotificationUPP (gConfigEDMUPP);
    gConfigEDMUPP = NULL;
  }

  if (gDisplayCaps) { // dispose diaplsy capabilities info
    free (gDisplayCaps);
    gDisplayCaps = NULL;
  }  
#pragma mark *** dispose pbuffer ***
  if (gpPbuffer) {
    disposePbuffer (gpPbuffer);
    DisposePtr ((Ptr) gpPbuffer);
    gpPbuffer = NULL;
  }

  
//CantCreateWindow:
CantSetMenuBar:
CantGetNibRef:

    // We don't need the nib reference anymore.
    DisposeNibReference (nibRef);

  return err;
}

</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/GLCarbonSharedPbuffer/listing19.html%3Fid%3DDTS10003149-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/GLCarbonSharedPbuffer/listing19.html%3Fid%3DDTS10003149-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/GLCarbonSharedPbuffer/listing19.html%3Fid%3DDTS10003149-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>