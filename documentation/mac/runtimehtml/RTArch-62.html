<!-- Generated by Harlequin WebMaker 2.2.3 (30-Apr-1996)
Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->
<HTML> <HEAD>
<TITLE>Routine Calling Conventions</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING62></A>


<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="RTArch-61.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="RTArch-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="RTArch-147.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="RTArch-63.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="RTArch-2.html"><B>Mac OS Runtime Architectures</B></A> / <BR><DD><A HREF="RTArch-56.html"><B>Chapter 4 - PowerPC Runtime Conventions</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING62-0></A>
<H1><A NAME=MARKER-9-42></A>Routine Calling Conventions</H1>
 <A NAME=MARKER-2-23></A>This section details the process of passing parameters to a routine in the PowerPC runtime environment. <P>
<DL>
<DT><B>Note</B>
<DD>These parameter passing conventions are part of Apple's standard for procedural interfaces. Object-oriented languages may use different rules for their own method calls. For example, the conventions for C++ virtual function calls may be different from those for C functions.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
 <A NAME=MARKER-2-44></A>A routine can have a fixed or variable number of arguments. In an ANSI-style C syntax definition, a routine with a variable number of arguments typically appears with ellipsis points (...) at the end of its input parameter list.<P>
 A variable-argument routine may have several required (that is, fixed) parameters preceding the variable parameter portion. For example, the routine definition<P>
<PRE>
mooColor(number,[color1. . .])
</PRE>
 gives no restriction on the number of color arguments, but you must always precede them with a number argument. Therefore, number is a fixed parameter. <P>
 Typ<A NAME=MARKER-2-45></A>ically the calling routine passes parameters in registers. However, the compiler generates a parameter area in the caller's stack frame that is large enough to hold all parameters passed to the called routine, regardless of how many of the parameters are actually passed in registers. There are several reasons for this scheme:<P>
<UL>
<LI>It provides the callee with space to store a register-based parameter if it wants to use one of the parameter registers for some other purpose (for instance, to pass parameters to a subroutine). 
<LI>Routines with variable-length parameter lists must often access their parameters from RAM, not from registers. Such routines must reserve eight registers (32 bytes) in the parameter area to hold the parameter values. 
<LI>To simplify debugging, some compilers may write parameters from the parameter registers into the parameter area in the stack frame; this allows you to see all the parameters by looking only at that parameter area.<P>
</UL>
 <A NAME=MARKER-2-46></A>You can think of the parameter area as a data structure that has space to hold all the parameters in a given call. The parameters are placed in the structure from left to right according to the following rules:<P>
<UL>
<LI>All parameters are aligned on 4-byte (word) boundaries. 
<LI>Noncomposite parameters smaller than 4 bytes occupy the low order bytes of their word. 
<LI>Composite parameters (such as data structures) are followed by padding to make a multiple of 4 bytes, with the padding bytes being undefined.<P>
</UL>
 <A NAME=MARKER-2-47></A>For a routine with fixed parameters, the first 8 words (32 bytes) of the data structure, no matter the size of the individual parameters, are passed in registers according to the following rules:<P>
<UL>
<LI>The first 8 words are placed in GPR3 through GPR10 unless a floating-point parameter is encountered. 
<LI>Floating-point parameters are placed in the floating-point registers FPR1 through FPR13.
<LI>If a floating-point parameter appears before all the general-purpose registers are filled, the corresponding GPRs that match the size of the floating-point parameter are skipped. For example, a <CODE>float</CODE> item causes one (4-byte) GPR to be skipped, while an item of type <CODE>double</CODE> causes two GPRs to be skipped. 
<LI>If the number of parameters exceeds the number of usable registers, the calling routine writes the excess parameters into the parameter area of its stack frame. <P>
</UL>
<DL>
<DT><B>Note</B>
<DD>Currently the parameter area must be at least 8 words (32 bytes) in size.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
 For example, consider a routine <CODE>mooFunc</CODE> with this declaration:<P>
<PRE>
void mooFunc (SInt32 i1, float f1, double d1, SInt16 s1, double d2, 
            UInt8 c1, UInt16 s2, float f2, SInt32 i2);
</PRE>
 To see how the parameters of <CODE>mooFunc</CODE> are arranged in the parameter area on the stack, first convert the parameter list into a structure, as follows:<P>
<PRE>
struct params {
   SInt32            p_i1;
   float             p_f1;
   double            p_d1;
   SInt16            p_s1;
   double            p_d2;
   UInt8             p_c1;
   UInt16            p_s2;
   float             p_f2;
   SInt32            p_i2;
};
</PRE>
 <A NAME=MARKER-2-48></A>This structure serves as a template for constructing the parameter area on the stack. (Remember that, in actual practice, many of these variables are passed in registers; nonetheless, the compiler still allocates space for all of them on the stack, for the reasons just mentioned.)<P>
 The "top" position on the stack is for the field <CODE>pi_1</CODE> (the structure field corresponding to parameter <CODE>i1</CODE>). The floating-point field <CODE>p_f1</CODE> is assigned to the next word in the parameter area. The 64-bit double field <CODE>p_d1</CODE> is assigned to the next two words in the parameter area. Next, the short integer field <CODE>p_s1</CODE> is placed into the following 32-bit word; the original value of <CODE>p_s1</CODE> is in the lower half of the word, and the padding is in the upper half. The remaining fields of the <CODE>params</CODE> structure are assigned space on the stack in exactly the same way, with unsigned values being extended to fill each field to make it a 32-bit word. The final arrangement of the stack is illustrated in <A HREF=#MARKER-9-49>Figure 4-4</A>. (Because the stack grows down, it looks as though the fields of the <CODE>params</CODE> structure are upside down.)<P>
<B>Figure 4-4  <A NAME=MARKER-9-49></A>The organization of the parameter area of the stack</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/RUN-69.jpg"> <P>
 To see which parameters are passed in registers and which are passed on the stack, you need to map the stack, as illustrated in <A HREF=#MARKER-9-49>Figure 4-4</A>, to the available general-purpose and floating-point registers. Therefore, the parameter <CODE>i1</CODE> is passed in GPR3, the first available general-purpose register. The floating-point parameter <CODE>f1</CODE> is passed in FPR1, the first available floating-point register. This action causes GPR4 to be skipped. <P>
 The parameter <CODE>d1</CODE> is placed into FPR2 and the corresponding general-purpose registers GPR5 and GPR6 are unused. The parameter <CODE>s1</CODE> is placed into the next available general-purpose register, GPR7. Parameter <CODE>d2</CODE> is placed into FPR3, with GPR8 and GPR9 masked out. Parameter <CODE>c1</CODE> is placed into GPR10, which fills out the first 8 words of the data structure. Parameter <CODE>s2</CODE> is then passed in the parameter area of the stack. Parameter <CODE>f2</CODE> is passed in FPR4, since there are still floating-point registers available. Finally, parameter <CODE>i2</CODE> is passed on the stack. <A HREF=#MARKER-9-50>Figure 4-5</A> shows the final layout of the parameters in the registers and the parameter area. <P>
<B>Figure 4-5  <A NAME=MARKER-9-50></A>Parameter layout in registers and the parameter area</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/RUN-77.jpg"> <P>
 <A NAME=MARKER-2-51></A>If you have a C routine with a variable number of parameters (that is, one that does not have a fixed prototype), the compiler cannot know whether to pass a parameter in the variable portion of the routine in the general-purpose (that is, fixed-point) registers or in the floating-point registers. Therefore, the compiler passes the parameter in both the floating-point and the general-purpose registers, as shown in <A HREF=#MARKER-9-52>Figure 4-6</A>.<P>
<B>Figure 4-6  <A NAME=MARKER-9-52></A>Passing a variable number of parameters</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/RUN-80.jpg"> <P>
 The called routine can access parameters in the fixed portion of the routine definition as usual. However, in the variable-argument portion of the routine, the called routine must copy the GPRs to the parameter area and access the values from there. <A HREF=#MARKER-9-53>Listing 4-3</A> shows a routine that accesses values by walking through the stack.<P>
<B>Listing 4-3  <A NAME=MARKER-9-53></A>A variable-argument routine</B><P>
<PRE>
double dsum (int count, ...) 
{
   double sum = 0.0;
   double * arg = (double *) (&amp;count + 1 /* pointer arithmetic */);
   while (count &gt; 0 ) {
      sum += *arg;
      arg += 1;       /* pointer arithmetic */
      count -= 1;
   }
return sum;
}
</PRE>
<HR>
<B>Subtopics</B>
<B><!-- TOC --><DL>
<DL>
<DT><A HREF="RTArch-63.html#HEADING63-0">Function Return</A>
<DD>
<DT><A HREF="RTArch-64.html#HEADING64-0">Register Preservation </A>
<DD>
</DL>
</DL>
</B>
</BLOCKQUOTE>
<HR>
<center>
<A HREF="RTArch-61.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="RTArch-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="RTArch-147.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="RTArch-63.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="RTArch-3.html">&copy; Apple Computer, Inc.</A><br>11 MARCH 1997<P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML> 
