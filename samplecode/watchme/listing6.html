<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>watchme - /Common Files/MacFramework.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/QuickTime/index.html">QuickTime</a> &gt; <a href="../../samplecode/QuickTime/idxWiredMoviesandSprites-date.html">Wired Movies and Sprites</a> &gt; <A HREF="javascript:location.replace('index.html');">watchme</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">watchme</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/Common Files/MacFramework.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/Application Files/ComApplication.c</option>
<option value="listing2.html">/Application Files/ComApplication.h</option>
<option value="listing3.html">/Application Files/ComResource.h</option>
<option value="listing4.html">/Common Files/ComFramework.c</option>
<option value="listing5.html">/Common Files/ComFramework.h</option>
<option value="listing6.html">/Common Files/MacFramework.c</option>
<option value="listing7.html">/Common Files/MacFramework.h</option>
<option value="listing8.html">/Common Files/MacPrefix.h</option>
<option value="listing9.html">/Common Files/QTUtilities.c</option>
<option value="listing10.html">/Common Files/QTUtilities.h</option>
<option value="listing11.html">/Common Files/WinFramework.c</option>
<option value="listing12.html">/Common Files/WinFramework.h</option>
<option value="listing13.html">/Common Files/WinPrefix.h</option>
<option value="listing14.html">/WatchMe.c</option>
<option value="listing15.html">/WatchMe.h</option></select>
				</p>
				</form>
				<p><strong><a href="watchme.zip">Download Sample</a></strong> (&#147;watchme.zip&#148;, 129.8K)<BR>
<strong><a href="watchme.dmg">Download Sample</a></strong> (&#147;watchme.dmg&#148;, 203.8K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">//////////////  File:    MacFramework.c////  Contains:  Code for the QuickTime sample code framework that is specific to the Macintosh. //        This code handles windows, menus, events, and other low-level things. Put your//        application-specific code into the file ComApplication.c. ////  Written by:  Tim Monroe//        Based on the QTShell code written by Tim Monroe, which in turn was based on the MovieShell//        code written by Apple DTS (Kent Sandvik). This current version is now very far removed from//        MovieShell.////  Copyright:  &copy; 1999 by Apple Computer, Inc., all rights reserved.////  Change History (most recent first):////     &lt;13&gt;     02/01/01  rtm    fixed *Proc names to *UPP, to conform to Universal Headers 3.4b4//     &lt;12&gt;     08/11/00  rtm    revised event-handling so that QTFrame_HandleEvent passes event to//                  the movie controller//     &lt;11&gt;     07/06/00  rtm    made changes to support new parameter to QTFrame_AdjustMenus//     &lt;10&gt;     03/02/00  rtm    made changes to get things running under CarbonLib//     &lt;9&gt;     01/14/00  rtm    reworked window-dragging and -updating code to support graphics files//     &lt;8&gt;     12/23/99  rtm    tweaked mouseDown handling in QTFrame_StandardModalDialogEventFilter//     &lt;7&gt;     12/16/99  rtm    added gMouseClickTime global variable and code to set it in mouseUp//                  case in QTFrame_HandleEvent//     &lt;6&gt;     12/12/99  rtm    tweaked inDrag handling in QTFrame_HandleEvent//     &lt;5&gt;     11/30/99  rtm    option-click in close box now closes all open movie windows (per HIG)//     &lt;4&gt;     11/29/99  rtm    reworked QTFrame_DestroyMovieWindow to use NavAskSaveChanges//     &lt;3&gt;     11/16/99  rtm    factored QTFrame_HandleEvent out of QTFrame_MainEventLoop, so we can//                  handle events from other code, if necessary//     &lt;2&gt;     11/11/99  rtm    made some preliminary changes for Carbon; still some work to be done//     &lt;1&gt;     11/05/99  rtm    first file; based on earlier sample code//     //////////////////////// header files////////////#include &quot;MacFramework.h&quot;////////////// global variables////////////Boolean       gShuttingDown = false;        // are we shutting down?Boolean        gAppInForeground;          // is our application in the foreground?  Boolean        gHasNewDialogCalls;          // are the new Dialog Manager functions available?Str255         gWindowTitle = kDefaultWindowTitle;  // default name for created windowsRect         gWindowRect = kDefaultWindowRect;  // default rectangle for created windowsGrowZoneUPP      gAppGrowZoneUPP;          // UPP to our grow zone callbackModalFilterUPP    gModalFilterUPP;          // UPP to our custom dialog event filterUserItemUPP      gUserItemProcUPP;          // UPP to our custom dialog user item procedureHandle        gEmergencyMemory;          // handle to our emergency memory reserveshort         gAppResFile = kInvalidFileRefNum;  // file reference number for this application's resource fileFSSpec        gAppFSSpec;              // file specification for the application itselfStr255        gAppName;              // the name of this applicationlong        gMouseClickTime;          // for double-click calculationextern Handle     gValidFileTypes;          // the list of file types that our application can open////////////// main// The main function for this application.//// Set up the application's execution environment; make sure QuickTime (etc.) is installed,// then start handling events.////////////int main (void){  OSErr    myErr = noErr;    QTFrame_InitMacEnvironment(10L);    // make sure that QuickTime is available and that we can initialize it  if (!QTUtils_IsQuickTimeInstalled()) {    QTFrame_ShowWarning(&quot;\pQuickTime is not installed on this computer. Exiting.&quot;, 0);    ExitToShell();  }  myErr = EnterMovies();  if (myErr != noErr) {    QTFrame_ShowWarning(&quot;\pCould not initialize QuickTime. Exiting.&quot;, myErr);    ExitToShell();  }  // do any application-specific initialization  QTApp_Init(kInitAppPhase_BothPhases);  // get and process events until the user quits  QTFrame_MainEventLoop();    ExitMovies();  ExitToShell();    return(0);}////////////// QTFrame_InitMacEnvironment// Initialize the Macintosh runtime environment.////////////static void QTFrame_InitMacEnvironment (long theNumMoreMasters){#if TARGET_API_MAC_CARBON#pragma unused(theNumMoreMasters)#endif  short      myVRefNum;  long      myDirID;#if !TARGET_API_MAC_CARBON    long      myIndex;  // add more space to the stack  SetApplLimit((Ptr)(GetApplLimit() - kExtraStackSpaceSize));        // expand heap zone to its limit  MaxApplZone();    // allocate some additional master pointer blocks  for (myIndex = 0; myIndex &lt; theNumMoreMasters; myIndex++)    MoreMasters();  InitGraf(&amp;qd.thePort);  InitFonts();  InitWindows();  InitMenus();  TEInit();  InitDialogs(NULL);#endif  InitCursor();  // initialize and install the menu bar  QTFrame_InitMenuBar();#if !TARGET_API_MAC_CARBON  // install a grow zone procedure to handle low memory situations  gEmergencyMemory = NewHandle(kEmergencyMemorySize);  if (gEmergencyMemory != NULL) {    gAppGrowZoneUPP = NewGrowZoneUPP(QTFrame_GrowZoneProcedure);    SetGrowZone(gAppGrowZoneUPP);  }#endif    // initialize foreground/background state  gAppInForeground = true;  // see whether the new Dialog Manager functions are available#if TARGET_API_MAC_CARBON  gHasNewDialogCalls = true;#else  gHasNewDialogCalls = QTUtils_TrapAvailable(_DialogDispatch);#endif      // create modal dialog filter and user item UPPs  gModalFilterUPP = NewModalFilterUPP(QTFrame_StandardModalDialogEventFilter);  gUserItemProcUPP = NewUserItemUPP(QTFrame_StandardUserItemProcedure);  // get the application's resource file  gAppResFile = CurResFile();    // get the application's name from the resource file  GetIndString(gAppName, kAppNameResID, kAppNameResIndex);    // get the application's location and save it in gAppFSSpec  HGetVol(NULL, &amp;myVRefNum, &amp;myDirID);  FSMakeFSSpec(myVRefNum, myDirID, gAppName, &amp;gAppFSSpec);}////////////// QTFrame_GrowZoneProcedure// A grow zone procedure. This is straight out of IM: Memory (pp. 1-46ff)////////////PASCAL_RTN long QTFrame_GrowZoneProcedure (Size theBytesNeeded){#pragma unused(theBytesNeeded)  long    myA5;  Size    myBytesFreed;    // get current A5; we might get called at a time that A5 isn't valid  myA5 = SetCurrentA5();    if ((*gEmergencyMemory != NULL) &amp;&amp; (gEmergencyMemory != GZSaveHnd())) {    EmptyHandle(gEmergencyMemory);    myBytesFreed = kEmergencyMemorySize;  } else {    myBytesFreed = 0;            // no more memory to release    }        myA5 = SetA5(myA5);    return(myBytesFreed);}////////////// QTFrame_InitMenuBar// Set up the menu bar. This is straight out of IM: Macintosh Toolbox Essentials (pp. 3-50ff)////////////static Boolean QTFrame_InitMenuBar (void){  Handle    myMenuBar = NULL;  long    myResponse;  OSErr    myErr = noErr;  myMenuBar = GetNewMBar(kMenuBarResID);#if TARGET_API_MAC_CARBON    // to get the theme-savvy menu bar, we need to call RegisterAppearanceClient.  RegisterAppearanceClient();#endif  if (myMenuBar == NULL)    return(false);    SetMenuBar(myMenuBar);                  // install the menus  DisposeHandle(myMenuBar);    // see whether we are running under MacOS X;  // if so, remove the Quit menu item and its preceding separator line  myErr = Gestalt(gestaltSystemVersion, &amp;myResponse);  if (myErr == noErr)    if (myResponse &gt;= 0x00000A00) {      DeleteMenuItem(GetMenuHandle(kFileMenuResID), MENU_ITEM(IDM_EXIT));      DeleteMenuItem(GetMenuHandle(kFileMenuResID), MENU_ITEM(IDM_EXIT) - 1);  // the separator line    }    #if !TARGET_API_MAC_CARBON    AppendResMenu(GetMenuHandle(kAppleMenuResID), 'DRVR');  // add desk accessory names to Apple menu#endif  QTFrame_AdjustMenus(NULL, NULL, 0L);  DrawMenuBar();    return(true);}////////////// QTFrame_MainEventLoop// Retrieve and process events.////////////static void QTFrame_MainEventLoop (void){  EventRecord        myEvent;    while (!gShuttingDown) {#if !TARGET_API_MAC_CARBON      // make sure we've still got our memory reserve; reallocate it if it's been used    if ((gEmergencyMemory == NULL) || (*gEmergencyMemory == NULL))      ReallocateHandle(gEmergencyMemory, kEmergencyMemorySize);#endif      // get the next event in the queue    WaitNextEvent(everyEvent, &amp;myEvent, kWNEDefaultSleep, NULL);        // handle the event    QTFrame_HandleEvent(&amp;myEvent);      } // while (!gShuttingDown)}////////////// QTFrame_MainEventLoop// Retrieve and process events.////////////void QTFrame_HandleEvent (EventRecord *theEvent){  WindowPtr        myWindow = NULL;  WindowObject       myWindowObject = NULL;  short          myWindowPart;  Rect          myScreenRect;  Boolean          isEventHandled = false;  // first, perform any application-specific event handling  isEventHandled = QTApp_HandleEvent(theEvent);      // then, if this event hasn't been handled, let all movie controllers have access to the event  if (!isEventHandled)    isEventHandled = QTFrame_CheckMovieControllers(theEvent);  // then, if this event has been handled, return; otherwise, handle it here  if (isEventHandled)    return;      myWindow = FrontWindow();  switch (theEvent-&gt;what) {    case mouseUp:      gMouseClickTime = TickCount();    // for double-click calculation      break;    case mouseDown:          myWindowPart = FindWindow(theEvent-&gt;where, &amp;myWindow);      // menu bar and window-related events:            switch (myWindowPart) {        case inSysWindow:#if !TARGET_API_MAC_CARBON          // a mouse click in a window belonging to a desk accessory          SystemClick(theEvent, myWindow);#endif          break;                  case inMenuBar:          // a mouse click in the menu bar          QTFrame_AdjustMenus(FrontWindow(), NULL, (long)theEvent-&gt;modifiers);          QTFrame_HandleMenuCommand(MenuSelect(theEvent-&gt;where));          break;                  case inDrag: {          Rect         myRect;                    myWindowObject = QTFrame_GetWindowObjectFromWindow(myWindow);          if (myWindowObject != NULL) {                        if ((**myWindowObject).fMovie != NULL)              GetMovieBox((**myWindowObject).fMovie, &amp;myRect);                        if ((**myWindowObject).fGraphicsImporter != NULL)              GraphicsImportGetNaturalBounds((**myWindowObject).fGraphicsImporter, &amp;myRect);                        GetRegionBounds(GetGrayRgn(), &amp;myScreenRect);            DragAlignedWindow(myWindow, theEvent-&gt;where, &amp;myScreenRect, &amp;myRect, NULL);          } else {            GetRegionBounds(GetGrayRgn(), &amp;myScreenRect);            DragWindow(myWindow, theEvent-&gt;where, &amp;myScreenRect);          }                    break;                      }                  case inContent:          if (myWindow != FrontWindow()) {            SelectWindow(myWindow);            MacSetPort((GrafPtr)GetWindowPort(myWindow));          } else {            QTApp_HandleContentClick(myWindow, theEvent);          }                    break;                case inGoAway:          if (TrackGoAway(myWindow, theEvent-&gt;where)) {            // if the option key is down, close all open movie windows; otherwise, close just the frontmost            if (theEvent-&gt;modifiers &amp; optionKey)              QTFrame_CloseMovieWindows();            else              QTFrame_DestroyMovieWindow(myWindow);          }          break;      } // end switch(myWindowPart)      break;    // system-level events:    case updateEvt:      myWindow = (WindowPtr)theEvent-&gt;message;      if (myWindow != NULL) {        // if the window contains an image, draw it using GraphicsImportDraw        myWindowObject = QTFrame_GetWindowObjectFromWindow(myWindow);        if (myWindowObject != NULL)          if ((**myWindowObject).fGraphicsImporter != NULL)            GraphicsImportDraw((**myWindowObject).fGraphicsImporter);                // now do any application-specific drawing        QTApp_Draw(myWindow);      }      break;          case keyDown:    case autoKey:      QTFrame_HandleKeyPress(theEvent);      break;        case diskEvt: {#if !TARGET_API_MAC_CARBON      Point      myPoint = {100, 100};          if (HiWord(theEvent-&gt;message) != noErr)        (void)DIBadMount(myPoint, theEvent-&gt;message);#endif      break;    }        case activateEvt:      myWindow = (WindowReference)theEvent-&gt;message;             if (QTFrame_IsMovieWindow(myWindow))        QTFrame_ActivateController(myWindow, ((theEvent-&gt;modifiers &amp; activeFlag) != 0 ));      break;          case osEvt:      switch ((theEvent-&gt;message &gt;&gt; 24) &amp; 0x00ff) {    // get high byte of message        case suspendResumeMessage:                  // set the foreground/background state          gAppInForeground = (theEvent-&gt;message &amp; resumeFlag) != 0;                    // activate the front window, if there is one            if (myWindow != NULL)            QTFrame_ActivateController(myWindow, gAppInForeground);          break;                case mouseMovedMessage:          break;      }      break;        case kHighLevelEvent:      AEProcessAppleEvent(theEvent);      break;          case nullEvent:      // do idle-time processing for all open movie windows      myWindow = QTFrame_GetFrontMovieWindow();      while (myWindow != NULL) {        if (gAppInForeground)          QTApp_Idle(myWindow);                  myWindow = QTFrame_GetNextMovieWindow(myWindow);      }      break;  } // switch (theEvent-&gt;what)}    ////////////// QTFrame_HandleMenuCommand// Handle a menu selection.////////////void QTFrame_HandleMenuCommand (long theMenuResult){  short    myMenuID, myMenuItem;  Cursor    myArrow;    MacSetCursor(GetQDGlobalsArrow(&amp;myArrow));  myMenuID = HiWord(theMenuResult);  myMenuItem = LoWord(theMenuResult);    switch (myMenuID) {      case kAppleMenuResID:      switch (myMenuItem) {        case kAboutMenuItem:    // About box          QTFrame_ShowAboutBox();             break;                default:           // Apple menu handling#if !TARGET_API_MAC_CARBON          {            Str255    myDAName;                        GetMenuItemText(GetMenuHandle(kAppleMenuResID), myMenuItem, myDAName);            (void)OpenDeskAcc(myDAName);          }#endif          break;      }      break;    case kFileMenuResID:      QTFrame_HandleFileMenuItem(QTFrame_GetFrontMovieWindow(), MENU_IDENTIFIER(myMenuID, myMenuItem));      break;      case kEditMenuResID:      QTFrame_HandleEditMenuItem(QTFrame_GetFrontMovieWindow(), MENU_IDENTIFIER(myMenuID, myMenuItem));      break;    default:      // do any application-specific menu handling      QTApp_HandleMenu(MENU_IDENTIFIER(myMenuID, myMenuItem));      break;      } // switch (myMenuID)    HiliteMenu(0);}////////////// QTFrame_HandleKeyPress// Handle key presses. This is modelled on Inside Macintosh: Macintosh Toolbox Essentials, p. 3-78.////////////void QTFrame_HandleKeyPress (EventRecord *theEvent){  char    myKey;    myKey = theEvent-&gt;message &amp; charCodeMask;    if (theEvent-&gt;modifiers &amp; cmdKey) {    // if the command key is down, it must be a keyboard shortcut for a menu selection;    // adjust the menus and find the menu command that the shortcut picks out    QTFrame_AdjustMenus(FrontWindow(), NULL, (long)theEvent-&gt;modifiers);    QTFrame_HandleMenuCommand(MenuKey(myKey));  } else {    // otherwise, we'll assume it's meant for our application    QTApp_HandleKeyPress(myKey);  }}////////////// QTFrame_QuitFramework// Do any framework-specific shut-down.////////////void QTFrame_QuitFramework (void){  // set our global flag to indicate we're shutting down  gShuttingDown = true;    // do application-specific processing that must occur before movie windows are closed  QTApp_Stop(kStopAppPhase_BeforeDestroyWindows);    // close all open movie windows; note that the user can cancel the shutting down  QTFrame_CloseMovieWindows();      // test the quit flag; a call to QTFrame_DestroyMovieWindow may have reset it  if (!gShuttingDown)    return;    // do application-specific processing that must occur after movie windows are closed  QTApp_Stop(kStopAppPhase_AfterDestroyWindows);  // release our list of valid file types  if (gValidFileTypes != NULL)    DisposeHandle(gValidFileTypes);#if !TARGET_API_MAC_CARBON    // release the grow zone memory  DisposeHandle(gEmergencyMemory);#endif    // release any routine descriptors  DisposeGrowZoneUPP(gAppGrowZoneUPP);  DisposeModalFilterUPP(gModalFilterUPP);  DisposeUserItemUPP(gUserItemProcUPP);  }/////////////////////////////////////////////////////////////////////////////////////////////////////////////// Framework utilities.//// The framework uses the following functions to create movies and handle dialog boxes. You probably won't// need to use them directly./////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// QTFrame_CreateMovieWindow// Create a new window to display the movie in.////////////WindowReference QTFrame_CreateMovieWindow (void){  WindowReference      myWindow = NULL;    // create a new window to display the movie in  myWindow = NewCWindow(NULL,              &amp;gWindowRect,              gWindowTitle,              false,              noGrowDocProc,              (WindowPtr)-1L,              true,              0);  // create a new window object associated with the new window  QTFrame_CreateWindowObject(myWindow);  return(myWindow);}////////////// QTFrame_DestroyMovieWindow// Close the specified movie window.////////////void QTFrame_DestroyMovieWindow (WindowReference theWindow){  WindowObject    myWindowObject = NULL;  OSErr        myErr = noErr;    // get the window object associated with the specified window  myWindowObject = QTFrame_GetWindowObjectFromWindow(theWindow);  if (myWindowObject == NULL) {    // if the window passed in isn't a movie window, just dispose of it and return    if (theWindow != NULL) {      DisposeWindow(theWindow);      theWindow = NULL;    }    return;  }    // if the window's data is &quot;dirty&quot;, give the user a chance to save it  if ((**myWindowObject).fIsDirty) {    Str255            myString;    NavAskSaveChangesAction    myAction;    NavAskSaveChangesResult    myResult;    NavDialogOptions      myDialogOptions;    NavEventUPP          myEventUPP = NewNavEventUPP(QTFrame_HandleNavEvent);    // get the title of the window    GetWTitle(theWindow, myString);        // install the application and document names    NavGetDefaultDialogOptions(&amp;myDialogOptions);    BlockMoveData(gAppName, myDialogOptions.clientName, gAppName[0] + 1);    BlockMoveData(myString, myDialogOptions.savedFileName, myString[0] + 1);        // specify the action    myAction = gShuttingDown ? kNavSaveChangesQuittingApplication : kNavSaveChangesClosingDocument;        // display the &quot;Save changes&quot; dialog box    myErr = NavAskSaveChanges(&amp;myDialogOptions, myAction, &amp;myResult, myEventUPP, NULL);    if (myErr != noErr)      myResult = kNavAskSaveChangesCancel;          switch (myResult) {      case kNavAskSaveChangesSave:        // save the data in the window        QTFrame_UpdateMovieFile(theWindow);        break;              case kNavAskSaveChangesCancel:        // do not close the window, and do not quit the application        gShuttingDown = false;        return;              case kNavAskSaveChangesDontSave:        // discard any unsaved changes (that is, don't do anything)        break;    }    DisposeNavEventUPP(myEventUPP);  }  // if we got to this point, it's okay to close and destroy the window  QTFrame_CloseWindowObject(myWindowObject);  DisposeWindow(theWindow);}////////////// QTFrame_StandardUserItemProcedure// A standard user-item procedure to outline the OK button in a modal dialog.////////////PASCAL_RTN void QTFrame_StandardUserItemProcedure (DialogPtr theDialog, short theItem){#pragma unused(theItem)  short        myItemKind;      // for GetDialogItem  Handle        myItemHandle;    // for GetDialogItem  Rect        myItemRect;      // for GetDialogItem  if (!gHasNewDialogCalls) {    // no need to do any of this if the new Dialog Manager calls are available    GetDialogItem(theDialog, kStdOkItemIndex, &amp;myItemKind, &amp;myItemHandle, &amp;myItemRect);        MacInsetRect(&amp;myItemRect, -4, -4);    PenSize(3, 3);    FrameRoundRect(&amp;myItemRect, 16, 16);    PenSize(1, 1);  }}////////////// QTFrame_StandardModalDialogEventFilter// A standard modal dialog event filter. ////////////PASCAL_RTN Boolean QTFrame_StandardModalDialogEventFilter (DialogPtr theDialog, EventRecord *theEvent, short *theItemHit){  Boolean        myEventHandled = false;  short        myItemKind;      // for GetDialogItem  Handle        myItemHandle;    // for GetDialogItem  Rect        myItemRect;      // for GetDialogItem  unsigned long    myTicks;      // for Delay  char        myKey;      WindowReference    myWindow = NULL;  short        myPart;        switch (theEvent-&gt;what) {    case updateEvt:      // update the specified window, if it's behind the modal dialog box      myWindow = (WindowReference)theEvent-&gt;message;      if ((myWindow != NULL) &amp;&amp; (myWindow != GetDialogWindow(theDialog))) {        QTFrame_HandleEvent(theEvent);        myEventHandled = false;    // so sayeth IM      }      break;    case nullEvent:      // do idle-time processing for all open windows in our window list      if (gAppInForeground)         QTFrame_IdleMovieWindows();      myEventHandled = false;      break;          case keyDown:    case autoKey:      // if new Dialog Manager calls are NOT available, handle certain key presses      if (!gHasNewDialogCalls) {        // first, map Command-period to Escape key...        myKey = theEvent-&gt;message &amp; charCodeMask;        if (theEvent-&gt;modifiers &amp; cmdKey)          if (myKey == kPeriod)            myKey = kEscapeKey;                    // ...then, handle the standard keyboard equivalents of OK and Cancel buttons        switch (myKey) {          case kReturnKey:          case kEnterKey:            *theItemHit = kStdOkItemIndex;            GetDialogItem(theDialog, kStdOkItemIndex, &amp;myItemKind, &amp;myItemHandle, &amp;myItemRect);            HiliteControl((ControlHandle)myItemHandle, kControlButtonPart);            Delay(kMyButtonDelay, &amp;myTicks);            HiliteControl((ControlHandle)myItemHandle, kControlNoPart);            myEventHandled = true;            break;          case kEscapeKey:            *theItemHit = kStdCancelItemIndex;            GetDialogItem(theDialog, kStdCancelItemIndex, &amp;myItemKind, &amp;myItemHandle, &amp;myItemRect);            HiliteControl((ControlHandle)myItemHandle, kControlButtonPart);            Delay(kMyButtonDelay, &amp;myTicks);            HiliteControl((ControlHandle)myItemHandle, kControlNoPart);            myEventHandled = true;            break;          default:            break;        }      }      break;          case mouseDown:      myPart = FindWindow(theEvent-&gt;where, &amp;myWindow);      if ((myPart == inDrag) &amp;&amp; (myWindow == GetDialogWindow(theDialog))) {        Rect    myScreenRect;                GetRegionBounds(GetGrayRgn(), &amp;myScreenRect);        DragWindow(myWindow, theEvent-&gt;where, &amp;myScreenRect);        myEventHandled = true;      }      break;          default:      myEventHandled = false;      break;  }      // let the OS's standard filter proc handle the event, if it hasn't already been handled  if (gHasNewDialogCalls &amp;&amp; (myEventHandled == false))    myEventHandled = StdFilterProc(theDialog, theEvent, theItemHit);    return(myEventHandled);}////////////// QTFrame_CheckMovieControllers// Let all movie controllers have a chance to process the event.//// Returns true if the event was handled by some movie controller, false otherwise////////////static Boolean QTFrame_CheckMovieControllers (EventRecord *theEvent){    WindowPtr        myWindow = NULL;  MovieController      myMC = NULL;    myWindow = QTFrame_GetFrontMovieWindow();  while (myWindow != NULL) {    myMC = QTFrame_GetMCFromWindow(myWindow);    if (myMC != NULL)      if (MCIsPlayerEvent(myMC, theEvent))        return(true);        myWindow = QTFrame_GetNextMovieWindow(myWindow);  }    return(false);}////////////// QTFrame_ShowAboutBox// Display and manage the About dialog box.////////////void QTFrame_ShowAboutBox (void){  DialogPtr      myDialog = NULL;  short         myItem;  short         mySavedResFile;  GrafPtr        mySavedPort;  short        myItemKind;  Handle        myItemHandle;  Rect        myItemRect;    // get the current resource file and port  mySavedResFile = CurResFile();  GetPort(&amp;mySavedPort);    // set the application's resource file;  // otherwise, we'd get the dialog's resources from the current resource file,  // which might not be the correct one....  UseResFile(gAppResFile);    // deactivate any frontmost movie window  QTFrame_ActivateController(QTFrame_GetFrontMovieWindow(), false);    myDialog = GetNewDialog(kAboutBoxID, NULL, (WindowPtr)-1L);  if (myDialog == NULL)    goto bail;      SetPortDialogPort(myDialog);      if (gHasNewDialogCalls)    SetDialogDefaultItem(myDialog, kStdOkItemIndex);    // make sure that the OK button is outlined in bold, even if new Dialog Manager calls not available  GetDialogItem(myDialog, kOKButtonUserItem, &amp;myItemKind, &amp;myItemHandle, &amp;myItemRect);  SetDialogItem(myDialog, kOKButtonUserItem, myItemKind, (Handle)gUserItemProcUPP, &amp;myItemRect);  // display and handle events in the dialog box until the user clicks OK  do {    ModalDialog(gModalFilterUPP, &amp;myItem);  } while (myItem != kStdOkItemIndex);  bail:  // restore the previous resource file and port  MacSetPort(mySavedPort);  UseResFile(mySavedResFile);    if (myDialog != NULL)    DisposeDialog(myDialog);}////////////// QTFrame_ShowWarning// Display a warning box.////////////void QTFrame_ShowWarning (Str255 theMessage, OSErr theErr){  Str255        myString;  short         mySavedResFile;    // get the current resource file and set the application's resource file  mySavedResFile = CurResFile();  UseResFile(gAppResFile);  // insert argument into the message text template, to get the message text  NumToString(theErr, myString);  ParamText(&quot;\pWarning!&quot;, theMessage, theErr ? myString: NULL, NULL);  // display the dialog box  Alert(kAlertErrorID, gModalFilterUPP);    // restore the original resource file  UseResFile(mySavedResFile);}</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/watchme/listing6.html%3Fid%3DDTS10001080-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/watchme/listing6.html%3Fid%3DDTS10001080-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/watchme/listing6.html%3Fid%3DDTS10001080-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>