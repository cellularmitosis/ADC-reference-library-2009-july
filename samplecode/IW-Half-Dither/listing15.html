<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>IW-Half-Dither - /source/OldApp.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxGraphicsImaging-date.html">Graphics & Imaging</a> &gt; <A HREF="javascript:location.replace('index.html');">IW-Half-Dither</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/GraphicsImaging/index.html" target="_blank">Reference Library > Graphics & Imaging</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">IW-Half-Dither</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/source/OldApp.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/source/ChooserSupport.a</option>
<option value="listing2.html">/source/ChooserSupport.r</option>
<option value="listing3.html">/source/ChooserSupportLDEF.c</option>
<option value="listing4.html">/source/ChooserSupportPACK.c</option>
<option value="listing5.html">/source/ChooserSupportProtos.h</option>
<option value="listing6.html">/source/CommonDefines.h</option>
<option value="listing7.html">/source/DriverProtos.h</option>
<option value="listing8.html">/source/GXPrintingResEquates.r</option>
<option value="listing9.html">/source/GXPrintingResTypes.r</option>
<option value="listing10.html">/source/NewApp.a</option>
<option value="listing11.html">/source/NewApp.c</option>
<option value="listing12.html">/source/NewApp.r</option>
<option value="listing13.html">/source/NewDriverProtos.h</option>
<option value="listing14.html">/source/OldApp.a</option>
<option value="listing15.html">/source/OldApp.c</option>
<option value="listing16.html">/source/OldApp.r</option></select>
				</p>
				</form>
				<p><strong><a href="IW-Half-Dither.zip">Download Sample</a></strong> (&#147;IW-Half-Dither.zip&#148;, 91.3K)<BR>
<strong><a href="IW-Half-Dither.dmg">Download Sample</a></strong> (&#147;IW-Half-Dither.dmg&#148;, 159.7K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*  copyright &copy; 1992-1994 Apple Computer Inc.  All rights reserved.    OldApp.c  This file implements old application message overrides for the specific driver.    Included in this file is the old PrintRecord emulation.  Note that the ImageWriter  PrintRecord is a wonder of misdirection and special cases.  You'll have fun  figuring out the code - so unless you really want to exactly emulate the ImageWriter  pages, you shouldn't spend too much time looking at this code.    Modification history  7/23/92      TED        New file today  12/20/93    dmh        Sync'd with the shipping 1.0b3 GX driver.   8/26/94    dmh        Sync'd with the shipping 1.0.1 GX driver.*/// Include the standard Mac header files #include &lt;Errors.h&gt;#include &lt;ToolUtils.h&gt;#include &lt;StdIO.h&gt;#include &lt;StdLib.h&gt;#include &lt;String.h&gt;#include &lt;Strings.h&gt;#include &lt;Resources.h&gt;#include &lt;ToolUtils.h&gt;#include &lt;OSUtils.h&gt;#include &lt;Files.h&gt;#include &lt;Types.h&gt;#include &lt;Packages.h&gt;#include &lt;Memory.h&gt;#include &lt;Serial.h&gt;#include &lt;Devices.h&gt;#include &lt;Fonts.h&gt;#include &lt;Printing.h&gt;#include &lt;Script.h&gt;#include &lt;Events.h&gt;#include &lt;Dialogs.h&gt;#include &lt;FixMath.h&gt;#include &lt;Lists.h&gt;#include &lt;AppleTalk.h&gt;#include &lt;Menus.h&gt;#include &lt;Events.h&gt;#include &lt;Balloons.h&gt;#include &lt;Folders.h&gt;#include &lt;SCSI.h&gt;// Include the new QuickDraw GX graphics header files #include &lt;GXGraphics.h&gt;#include &lt;GXMath.h&gt;#include &lt;QDLibrary.h&gt;#include &lt;FontLibrary.h&gt;#include &lt;GXLayout.h&gt;#include &lt;GraphicsLibraries.h&gt;// Include the required Printing Manager header files #include &lt;GXPrinting.h&gt;#include &lt;GXPrinterDrivers.h&gt;#include &lt;CollectionLibrary.h&gt;#include &lt;JobFormatModeLibrary.h&gt;#include &lt;PaperTypeLibrary.h&gt;#include &lt;PicturesAndPICTLibrary.h&gt;#include &lt;Collections.h&gt;#include &lt;GXMessages.h&gt;#include &quot;CommonDefines.h&quot;      // things common to .r and .h files#include &quot;DriverProtos.h&quot;#if defined(__MWERKS__)  asm void __Startup__(void);  asm void __Startup__(void)  {    dc.l  0          // Reserved for owner count.    jmp    SD_ConvertPrintRecordTo    jmp    SD_ConvertPrintRecordFrom    jmp    SD_PrintRecordToJob    jmp    SD_PrValidate    jmp    SD_PrJobInit    RTS              // this is needed so __Startup__ symbol works  }#endif/* ----------------------------------------------------------------------------  *//* INTERNAL TYPEDEFS AND STRUCTURES                        *//* ----------------------------------------------------------------------------  */// ImageWriter wDev values#define kBest      0x01#define kPortrait    0x02#define kTallAdjusted  0x04#define k50Percent    0x08#define kNoGaps      0x10#define kSetResCalled  0x20// some ImageWriter constants#define kGapSize    60    // gap at top of page in 120ths of an inch#define kSmallPlaten  16    // platen width in half inches for small IW#define kBigPlaten    27    // platen width in half inches for the 15&quot; IW/* ----------------------------------------------------------------------------  *//* FORWARD DECLARES                                *//* ----------------------------------------------------------------------------  */OSErr SD_ConvertPrintRecordTo(THPrint hoPrint);OSErr SD_ConvertPrintRecordFrom(gxUniversalPrintRecordHdl huPrint);/* ----------------------------------------------------------------------------  *//* INTERNAL ROUTINES                              *//* ----------------------------------------------------------------------------  */OSErr  UpdatePrintRecord(THPrint hPrint){  OSErr            anErr;  gxUniversalPrintRecordHdl   huPrint = (gxUniversalPrintRecordHdl)hPrint;  gxUniversalPrintRecordPtr   puPrint;  short            devVRes, devHRes, appVRes, appHRes;  short            cPlaten;    // convert to universal format  anErr = SD_ConvertPrintRecordTo(hPrint);  if (anErr == noErr)    {    // determine application &amp; device resolutions, based upon quality mode, tall adjusted    // setting, and if the app called SetRsl:    //  draft - 80(h)*72(v)    //  faster - 80(h)*72(v)    //  best - 160(h)*144(v)    //    //  draft (tall adjusted) - 72*72    //  faster (tall adjusted) - 72*72    //  best (tall adjusted) - 144*144        puPrint = *huPrint;    if (puPrint-&gt;options &amp; gxPreciseBitmap)      switch(puPrint-&gt;qualityMode)        {        case gxDraftQuality:        case gxFasterQuality:          devVRes = devHRes = 72;          appVRes = appHRes = 72;          break;                  case gxBestQuality:          devVRes = devHRes = 144;          appVRes = appHRes = 72;          break;        }    else      switch(puPrint-&gt;qualityMode)        {        case gxDraftQuality:        case gxFasterQuality:          appVRes = devVRes = 72;          appHRes = devHRes = 80;          break;                  case gxBestQuality:          devVRes = 144;          devHRes = 160;          appVRes = 72;          appHRes = 80;          break;        }          // SetRsl was called?  Use the resolution specified by the application    if (puPrint-&gt;appVRes != 72)      {      appVRes = devVRes = puPrint-&gt;appVRes;      appHRes = devHRes = puPrint-&gt;appHRes;      }          // finally, store the app &amp; device resolutions    puPrint-&gt;devVRes = devVRes;    puPrint-&gt;devHRes = devHRes;    puPrint-&gt;appVRes = appVRes;    puPrint-&gt;appHRes = appHRes;        // here we do page size calculations    // Please note that this code is confusing - it's purpose is to emulate    // the existing ImageWriter driver's page size.  Most drivers would not    // do this - the existing in the system probably is good enough.    {    long    pageGap;        // gap at top of page    long    dvPaper, dhPaper;    // paper size at device res    long    dvPage, dhPage;      // page size at device res    long    scanLines, scanBits;  // # of scan lines or bits on page    long    maxH;          // maximum width    long    hOff, vOff;        // margins (horiz &amp; vert) to get paper rect from page rect        // gap at the top of the page in pixels    pageGap = (kGapSize * appVRes) / 120;    if (puPrint-&gt;options &amp; gxBiggerPages)      pageGap = 0;          // figure out paper size in application space pixels    dvPaper = (puPrint-&gt;pageV * appVRes) / 120;    dhPaper = (puPrint-&gt;pageH * appHRes) / 120;            // vertically, align to the head height of 8 pixels    scanLines = ((dvPaper - pageGap) &gt;&gt; 3) &lt;&lt; 3;        // horizontally, allow the biggest width we can handle    cPlaten = kSmallPlaten;    if (puPrint-&gt;pageH &gt; (9*120) )      cPlaten = kBigPlaten;          maxH = (cPlaten * appHRes) &gt;&gt; 1;    if (maxH &gt; dhPaper)      maxH = dhPaper;    scanBits = (maxH &gt;&gt; 4) &lt;&lt; 4;        if (puPrint-&gt;orientation == gxPortraitOrientation)      {      // portrait            dhPage = scanBits;      dvPage = scanLines;            hOff = (dhPage - dhPaper) &gt;&gt; 1;      vOff = -pageGap;      }    else      {      // landscape            dhPage = scanLines;      dvPage = scanBits;            // reverse the paper definition as well      {      long iTemp = dhPaper;      dhPaper = dvPaper;      dvPaper = iTemp;      }            hOff = -pageGap;      vOff = (dvPage - dvPaper) &gt;&gt; 1;      }          // 50% reduction?  scale everything by 2X    if (puPrint-&gt;options &amp; gxUserFlag0)      {      dhPage &lt;&lt;= 1;      dvPage &lt;&lt;= 1;      dhPaper &lt;&lt;= 1;      dvPaper &lt;&lt;= 1;      hOff &lt;&lt;= 1;      vOff &lt;&lt;= 1;      }          // set the page and paper in app space    puPrint-&gt;appPage.left     = puPrint-&gt;appPage.top = 0;    puPrint-&gt;appPage.right     = dhPage;    puPrint-&gt;appPage.bottom   = dvPage;        puPrint-&gt;appPaper.left     = hOff;    puPrint-&gt;appPaper.top     = vOff;    puPrint-&gt;appPaper.right   = dhPaper + hOff;    puPrint-&gt;appPaper.bottom   = dvPaper + vOff;            // from page, scale up to device space (in case some weenie decides to look at that)    puPrint-&gt;devPage.left     = puPrint-&gt;devPage.top = 0;    puPrint-&gt;devPage.right     = dhPage * devHRes / appHRes;    puPrint-&gt;devPage.bottom   = dvPage * devVRes / appVRes;    }        // convert back to non-universal format    anErr = SD_ConvertPrintRecordFrom((gxUniversalPrintRecordHdl) hPrint);    }      return(anErr);  } // UpdatePrintRecord//&lt;FF&gt;/* ----------------------------------------------------------------------------  *//* MESSAGE OVERRIDES                              *//* ----------------------------------------------------------------------------  */OSErr SD_ConvertPrintRecordTo(THPrint hoPrint)/*  This call takes a print record in old style (driver specific) format, and  converts it to the format of &quot;gxUniversalPrintRecordHdl&quot;*/{  TPPrint            poPrint;      // pointer to old style print record  gxUniversalPrintRecordHdl  huPrint = (gxUniversalPrintRecordHdl)hoPrint;  // handle to universal print record  gxUniversalPrintRecordPtr  puPrint;      // pointer to universal print record  short            qualityMode;    // cached quality mode  short            wDev;        // cached wDev    // cache pointers for size and speed  puPrint = *huPrint;  poPrint = *hoPrint;  wDev = poPrint-&gt;prStl.wDev;    // determine quality mode  if (poPrint-&gt;prJob.bJDocLoop == 0)    qualityMode = gxDraftQuality;  else    {    if (wDev &amp; kBest)      qualityMode = gxBestQuality;    else      qualityMode = gxFasterQuality;    }      // universal feed is the inverse of our feed  puPrint-&gt;feed      =  1-(poPrint-&gt;prStl.feed);    // wDev 0x02 means portrait, else landscape  if (wDev &amp; kPortrait)     puPrint-&gt;orientation  =  gxPortraitOrientation;  else    {    puPrint-&gt;orientation  =  gxLandscapeOrientation;        // landscape disabled draft, forces tall adjusted    if (qualityMode == gxDraftQuality)      qualityMode = gxFasterQuality;    wDev |= kTallAdjusted;    }      // copies are in iCopies field (wow.)  puPrint-&gt;actualCopies    =  poPrint-&gt;prJob.iCopies;    // store our flags  puPrint-&gt;options = 0;    // tall adjusted  if (wDev &amp; kTallAdjusted)     puPrint-&gt;options |= gxPreciseBitmap;      // 50% reduction  if (wDev &amp; k50Percent)     {    puPrint-&gt;options |= gxUserFlag0;    puPrint-&gt;reduction = 50;        // for 50% reduction, we always return faster to the application    qualityMode = gxFasterQuality;    }  else    puPrint-&gt;reduction = 100;      // no gaps  if (wDev &amp; kNoGaps)     puPrint-&gt;options |= gxBiggerPages;    // finally, store quality mode    puPrint-&gt;qualityMode = qualityMode;    // and we can't have any errors - because this code is too godlike.  return(noErr);  } // SD_ConvertPrintRecordTo//&lt;FF&gt;/* ----------------------------------------------------------------------------  */OSErr SD_ConvertPrintRecordFrom(gxUniversalPrintRecordHdl huPrint)/*  This call takes a print record in universal format and converts it  to old style (driver specific) format.    Note: for the ImageWriter, I'm filling in way more things than theoretically  I need to.  However, since the ImageWriter is one of the oldest print drivers,  there is much more of a chance that someone assumes something about one or  more of the fields.*/{  gxUniversalPrintRecordPtr  puPrint;      // pointer to universal print record  THPrint            hoPrint = (THPrint)huPrint;  // handle to old style print record  TPPrint            poPrint;      // pointer to old style print record  short            options;      // cached universal options  short            qualityMode;    // cached universal quality mode  short            actualCopies;    // cached universal copies    // cache pointers for size and speed  puPrint = *huPrint;  poPrint = *hoPrint;  // save away fields within the universal record that we'll be stomping over  // as we convert  options     = puPrint-&gt;options;  qualityMode   = puPrint-&gt;qualityMode;  actualCopies  = puPrint-&gt;actualCopies;    poPrint-&gt;iPrVersion      = 4;    // used to be 3, but this is                      // a new driver.  We support versions                      // 3 and 4  poPrint-&gt;prInfo.iDev    = 0;    // always zero for the ImageWriter    // skip remaining fields in prInfo because they are unchanged    // determine the wDev  {  short  wDev;    // this is the wDev value for the ImageWriter  wDev = 0x0100;    if (puPrint-&gt;orientation == gxPortraitOrientation)    wDev |= kPortrait;  else    {    // for landscape, disable draft and force tall adjusted    if (qualityMode == gxDraftQuality)      qualityMode = gxFasterQuality;          options |= gxPreciseBitmap;    }    // user options  if (options &amp; gxPreciseBitmap)    wDev |= kTallAdjusted;  if (options &amp; gxUserFlag0)    {    wDev |= k50Percent;    qualityMode = gxFasterQuality;    }  if (options &amp; gxBiggerPages)    wDev |= kNoGaps;      // if the application's resolution isn't 72 - then clearly SetRsl must have been called  // to change it.  if (poPrint-&gt;prInfo.iVRes != 72)    {    wDev |= kSetResCalled;    qualityMode = gxBestQuality;    }      if (qualityMode == gxBestQuality)    wDev |= kBest;          // and finally, save away that short value we worked so hard to determine  poPrint-&gt;prStl.wDev = wDev;  }  // other fields in prStl remain the same    poPrint-&gt;prStl.bPort   = 0;  poPrint-&gt;prStl.feed   = 1 - (puPrint-&gt;feed);  poPrint-&gt;prInfoPT.iDev   = (qualityMode == gxBestQuality) ? -768 : 0;  // other fields in prInfoPT remain the same  {  Rect  rPage = poPrint-&gt;prInfoPT.rPage;    // calculate some fields we don't use - in case someone really wants to look at  // them for some reason  poPrint-&gt;prXInfo.iRowBytes  = rPage.right &gt;&gt; 3;  poPrint-&gt;prXInfo.iBandV    = 32;  poPrint-&gt;prXInfo.iBandH    = poPrint-&gt;prXInfo.iRowBytes &lt;&lt; 3;  poPrint-&gt;prXInfo.iDevBytes  = poPrint-&gt;prXInfo.iRowBytes *                   poPrint-&gt;prXInfo.iBandV +                   poPrint-&gt;prXInfo.iBandH;  poPrint-&gt;prXInfo.iBands    = (rPage.bottom+(poPrint-&gt;prXInfo.iBandV-1)) / poPrint-&gt;prXInfo.iBandV;  poPrint-&gt;prXInfo.bPatScale   = (qualityMode == gxBestQuality) ? -2 : 0;  poPrint-&gt;prXInfo.bUlThick   = 1;  poPrint-&gt;prXInfo.bUlOffset   = 1;  poPrint-&gt;prXInfo.bUlShadow   = 1;  poPrint-&gt;prXInfo.scan    = (poPrint-&gt;prStl.wDev &amp; kPortrait) ? 0 : 2;  poPrint-&gt;prXInfo.bXInfoX  = 0;  }    // other fields in prJob remain the same  poPrint-&gt;prJob.iCopies    = actualCopies;  poPrint-&gt;prJob.bJDocLoop  = (qualityMode == gxDraftQuality) ? 0 : 1;    // this routine is so studly, there can be no errors  return(noErr);    } // SD_ConvertPrintRecordFrom//&lt;FF&gt;/* ----------------------------------------------------------------------------  */OSErr SD_PrintRecordToJob(THPrint hPrint, gxJob theJob)/*  We convert the &quot;tall adjusted&quot; setting into the correct rendering option for  the job collection.*/{  OSErr  anErr;  Handle   jobQualitySettingsHdl;      anErr = Forward_GXPrintRecordToJob(hPrint, theJob);  if (anErr == noErr)    {    long imagewriterOptions = kSuperRes;        if ((**hPrint).prStl.wDev &amp; kSetResCalled)      {      Collection      jobCollection = GXGetJobCollection(GXGetJob());      gxQualityInfo    *qualitySettings;        // get old info and replace it with final quality      jobQualitySettingsHdl = NewHandle(0);      anErr = MemError();      nrequire(anErr, FailedNewHandle);      anErr = GetCollectionItemHdl (   jobCollection,                          gxQualityTag,                           gxPrintingTagID,                         jobQualitySettingsHdl );      if (anErr == collectionItemNotFoundErr)         {        Str255      bestString, roughString;        Size      count1, count2;        Ptr        p;        short      curResFile = CurResFile();                UseResFile(GXGetMessageHandlerResFile());        GetIndString( bestString, kOldQualityID, kBestString);        GetIndString( roughString, kOldQualityID, kRoughString);        UseResFile(curResFile);        SetHandleSize(jobQualitySettingsHdl,(sizeof(gxQualityInfo) + bestString[0] + roughString[0] + 2 ));        anErr = MemError();        nrequire( anErr, FailedSetHandleSize );                    qualitySettings = *((gxQualityInfo **) jobQualitySettingsHdl);                qualitySettings-&gt;disableQuality = false;        qualitySettings-&gt;defaultQuality = 1;        qualitySettings-&gt;currentQuality = 1;        qualitySettings-&gt;qualityCount = 2;            count1 = bestString[0]+1;        p = qualitySettings-&gt;qualityNames;        BlockMove( bestString, p, count1 );            count2 = roughString[0]+1;        p += count1;        BlockMove( roughString, p, count2 );            }      else        qualitySettings = *((gxQualityInfo **) jobQualitySettingsHdl);      (qualitySettings-&gt;currentQuality = qualitySettings-&gt;qualityCount-1);      anErr = AddCollectionItemHdl (   jobCollection,                      gxQualityTag,                      gxPrintingTagID,                      jobQualitySettingsHdl );                               if (anErr == noErr)        (void) SetCollectionItemInfo(jobCollection, gxQualityTag, gxPrintingTagID, 0x0000FFFF, gxVolatileOutputDriverCategory);              DisposHandle(jobQualitySettingsHdl);      }    if ((**hPrint).prStl.wDev &amp; kTallAdjusted)      imagewriterOptions = 0;          if (anErr == noErr)      anErr = AddCollectionItem(GXGetJobCollection(theJob),             DriverCreator,            0,            sizeof(imagewriterOptions),            &amp;imagewriterOptions);    }FailedNewHandle:      return(anErr);FailedSetHandleSize:  DisposHandle(jobQualitySettingsHdl);  return(anErr);  } // SD_PrintRecordToJob//&lt;FF&gt;/* ----------------------------------------------------------------------------  */OSErr SD_PrValidate(  THPrint hPrint,         // old style print record            Boolean *wasChanged)      // was the print record changed?/*  This call validates the current print record.  It's fairly simplistic (as were  all of the old drivers) - the wDev or versions don't match the current, we call  PrintDefault.  Otherwise, we call UpdatePrintRecord - to allow the driver to sanity  check any internal fields.  */{  unsigned short  wDev;            // note: if this were signed, the shift below would fail            Boolean      recordIsInvalid = true;        OSErr      anErr = noErr;    // check the wDev.  The upper byte must be equal to our idea of the wDev      wDev =  (**hPrint).prStl.wDev;    wDev &gt;&gt;= 8;                // get just the device ID  // If the device id is equal, then check the version number of the print record.  //  Only if that is also equal to the current version, will we return false (valid).      if (   (wDev == 1)     &amp;&amp;      (      ( ((**hPrint).iPrVersion) == 3 ) ||      ( ((**hPrint).iPrVersion) == 4 )       )    )    recordIsInvalid = false;        // If the the print record is not valid, then return the default print record.  // Otherwise, update the print record, based on the application's calls  // to PrGeneral.      if (recordIsInvalid)    PrintDefault(hPrint);  else    anErr = UpdatePrintRecord(hPrint);      *wasChanged = recordIsInvalid;    return (anErr);  } // SD_PrValidate//&lt;FF&gt;/* ----------------------------------------------------------------------------  */OSErr SD_PrJobInit(THPrint hPrint, TPPrDlg * pDlg)/*  This routine is called to initialize the job dialog.  We take the default  behavior - and then disable some of the items based on settings the user  has made:    - 50% disables all items    - apps that call SetRsl disable all items    - landscape disables draft mode*/{  OSErr  anErr;    anErr = Forward_GXPrJobInit(hPrint, pDlg);  if (anErr == noErr)    {    Boolean  disableDraft   = false;    Boolean  disableAll     = false;    short  wDev       = (**hPrint).prStl.wDev;    short  idx;    Rect  box;    Handle  item;    short  type;        if (wDev &amp; k50Percent)      disableAll = true;          if (wDev &amp; kSetResCalled)      disableAll = true;          if (!(wDev &amp; kPortrait))      disableDraft = true;        // disable any controls we need to    for (idx = 6; idx &lt;= 8; ++idx)      {      GetDItem((DialogPtr) *pDlg, idx, &amp;type, &amp;item, &amp;box);            if ( (disableAll) || ((disableDraft) &amp;&amp; (idx == 8) ) )        HiliteControl((ControlHandle) item, 255);            }    }  return(anErr);  } // SD_PrJobInit</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/IW-Half-Dither/listing15.html%3Fid%3DDTS10000151-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/IW-Half-Dither/listing15.html%3Fid%3DDTS10000151-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/IW-Half-Dither/listing15.html%3Fid%3DDTS10000151-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>