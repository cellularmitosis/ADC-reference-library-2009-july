<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>I/O Kit Device Driver Design Guidelines: The libkern C++ Runtime</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="The libkern C++ Runtime"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP30000695" title="The libkern C++ Runtime"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../../HardwareDrivers/index.html#//apple_ref/doc/uid/TP30000440-TP40003576" target="_top">Hardware &amp; Drivers</a> &gt; <a href="../Introduction/Intro.html#//apple_ref/doc/uid/TP40002799-TPXREF101">I/O Kit Device Driver Design Guidelines</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../Introduction/Intro.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../ContainerClasses/Libkern_Classes.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP30000695-BAJIBFDE" title="The libkern C++ Runtime"></a><h1>The libkern C++ Runtime</h1><p>When they designed the Mac OS X kernel, Apple engineers decided upon a restricted form of C++ because they felt the excluded features—exceptions, multiple inheritance, templates, and runtime type information<a name="//apple_ref/doc/uid/TP30000695-DontLinkElementID_90"></a> (RTTI)—were either insufficient or not efficient enough for a high-performance, multithreaded kernel. But because some form of RTTI was required, Apple devised an enhanced runtime typing system<a name="//apple_ref/doc/uid/TP30000695-DontLinkElementID_91"></a>. This system, which is implemented by the libkern library, provides the following features:</p><ul class="ul"><li class="li"><p>Dynamic object allocation and object construction and destruction</p></li><li class="li"><p>Object introspection and dynamic casting of objects</p></li><li class="li"><p>Runtime object accounting (tracking the number of current instances per class)</p></li><li class="li"><p>Safeguards for binary compatibility</p></li></ul><p>The principal agent behind these features is libkern’s OSMetaClass<a name="//apple_ref/doc/uid/TP30000695-DontLinkElementID_92"></a> class. OSMetaClass is a peer class to OSObject—the class that all device drivers ultimately derive from—because both classes directly inherit from the same true root class, OSMetaClassBase<a name="//apple_ref/doc/uid/TP30000695-DontLinkElementID_93"></a>. This chapter explores in some depth the APIs and services of the OSMetaClass and OSMetaClassBase classes and discusses how you can best take advantage of them in your code. The APIs of OSMetaClass and OSMetaClassBase are defined in <code>OSMetaClass.h</code>.</p>
<!-- This template is being used for both PDF and HTML. -->

    
    <h4>In this section:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="CPlusPlusRuntime.html#//apple_ref/doc/uid/TP30000695-TPXREF101">Creation of the Runtime System</a>
				
			<br/>
			
        
			
			
				<a href="CPlusPlusRuntime.html#//apple_ref/doc/uid/TP30000695-BAJCCBGJ">Object Creation and Destruction</a>
				
			<br/>
			
        
			
			
				<a href="CPlusPlusRuntime.html#//apple_ref/doc/uid/TP30000695-TPXREF105">Object Introspection and Dynamic Casting</a>
				
			<br/>
			
        
			
			
				<a href="CPlusPlusRuntime.html#//apple_ref/doc/uid/TP30000695-TPXREF106">Binary Compatibility</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP30000695-TPXREF101" title="Creation of the Runtime System"></a><h2>Creation of the Runtime System</h2><p>The libkern library builds and updates its C++ runtime system whenever kernel extensions are loaded (or unloaded) from the kernel. Each class in the libkern or I/O Kit libraries is itself an object of type OSMetaClass. The OSMetaClass class<a name="//apple_ref/doc/uid/TP30000695-DontLinkElementID_94"></a> specifies four instance variables to characterize class instances:</p><ul class="ul"><li class="li"><p>Class name</p></li><li class="li"><p>Base class (pointer to)</p></li><li class="li"><p>Size of class</p></li><li class="li"><p>Current number of instances</p></li></ul><p>When the kernel loader loads a kernel extension (KEXT), it needs to register the first three bits of information with the runtime system. This system is actually a metaclass database consisting of two cross-indexed dictionaries. One dictionary—call it the class dictionary<a name="//apple_ref/doc/uid/TP30000695-DontLinkElementID_95"></a>—is indexed by class name; the other dictionary, known as the module dictionary<a name="//apple_ref/doc/uid/TP30000695-DontLinkElementID_96"></a>, is indexed by the name of the KEXT binary.</p><ul class="ul"><li class="li"><p>The class dictionary consists of class-name keys paired with OSMetaClass objects. It is essential to the dynamic creation of libkern objects, including driver instances.</p></li><li class="li"><p>The module dictionary consists of the KEXT-binary names paired with an array of the OSMetaClass objects in the binary. It is an essential part of the way KEXTs are safely unloaded from the kernel</p></li></ul><p><span class="content_text"><a href="CPlusPlusRuntime.html#//apple_ref/doc/uid/TP30000695-BAJHAHHJ">Figure 1-1</a></span> illustrates how the libkern runtime writes class information to these dictionaries when KEXTs are loaded into the kernel.</p><br/><div><a name="//apple_ref/doc/uid/TP30000695-BAJHAHHJ" title="Figure 1-1Registering metaclass information from a KEXT binary"></a><p><strong>Figure 1-1&nbsp;&nbsp;</strong>Registering metaclass information from a KEXT binary</p><img src = "../Art/load_class_info.gif" alt = "Registering metaclass information from a KEXT binary" width="390" height="205"></div><br/><p>There are three distinct phases to metaclass registration<a name="//apple_ref/doc/uid/TP30000695-DontLinkElementID_97"></a> that the loader performs when loading a kernel extension:</p><ol class="ol"><li class="li"><p><strong>Before Loading</strong> The loader calls the <a name="//apple_ref/doc/uid/TP30000695-DontLinkElementID_98"></a>OSMetaClass member function <code>preModLoad</code>. This function grabs a lock to guarantee single-threading during the loading of multiple kernel extensions. It also generates global information about classes in KEXT binaries in preparation for registration.</p></li><li class="li"><p><strong>Loading</strong> The loader calls each of the static constructors created by OSMetaClass<a name="//apple_ref/doc/uid/TP30000695-DontLinkElementID_99"></a> macros as part of a class definition (see<span class="content_text"><a href="CPlusPlusRuntime.html#//apple_ref/doc/uid/TP30000695-BAJCCBGJ">“Object Creation and Destruction”</a></span>). As a result, the OSMetaClass constructor for each class is invoked; the arguments for this constructor are three of the OSMetaClass data members: Class name, pointer to the base class, and class size. The loader updates the class and module dictionaries, using the KEXT-binary name and class names as keys and inserting the just-created OSMetaClass objects into those dictionaries. It also links up all base-class inheritance pointers. </p></li><li class="li"><p><strong>After Loading</strong> After all static constructors are called, the loader calls the OSMetaClass member function <code>postModLoad</code>. This function releases the lock and returns the result code from the loading. If this code indicates an error, such as a badly formed constructor, the load attempt is aborted.</p></li></ol><div class="notebox"><a name="//apple_ref/doc/uid/TP30000695-DontLinkElementID_9" title="Note"></a><p><strong>Note:</strong>&nbsp;Although the OSMetaClass member functions for registering metaclass information are given public scope, you should not call them in your code, particularly <code>preModLoad</code> and <code>postModLoad</code>.</p></div><p>Whenever kernel code creates an instance of an OSObject-derived class, the libkern runtime typing system increments the instance counter of the associated OSMetaClass object; it decrements the counter whenever an instance is freed. The runtime system uses this running tally of instances to prevent the unloading of kernel extensions having “live” objects in the system. (Of course, if code improperly retains and releases objects, this could lead to the retention of KEXTs that should be unloaded—and, consequently, memory leaks. And leaked object references lead to annoying and costly delays in the development cycle.)</p><p>When the instance count of all classes in a KEXT binary reaches zero, the kernel unloader waits a minute (to ensure that the binary won’t be used again soon) before unloading the binary from the kernel. Just before unloading, the unloader calls the static destructor of each class in the binary, which removes all references to that class from the runtime system.</p><a name="//apple_ref/doc/uid/TP30000695-BAJCCBGJ" title="Object Creation and Destruction"></a><h2>Object Creation and Destruction</h2><p>Because exceptions are excluded from the kernel’s restricted form of C++, you cannot implement “normal” C++ constructors and destructors without jeopardy. Constructors and destructors are typed to return no value (such as an error code). Normally, if they encounter a problem, they raise an exception. But because exceptions aren’t supported in the kernel’s C++ runtime, there is no way for you to know when an allocation or deallocation error has occurred.</p><p>This situation prompted a design feature of the libkern’s C++ runtime system that uses <a name="//apple_ref/doc/uid/TP30000695-DontLinkElementID_100"></a>OSMetaClass macros to specify the structure of a class—that is, the metaclass data structures and functional interfaces—for the runtime typing system. The macros also define the primary constructor and a destructor for a class. These macro-created constructors are guaranteed not to fail because they do not themselves perform any allocations. Instead, the runtime system defers the actual allocation of objects until their initialization (usually in the <code>init</code> member function). Because the <code>init</code> function is typed to return a <code>bool</code>, it makes it possible to return an error upon any failure.</p><a name="//apple_ref/doc/uid/TP30000695-TPXREF110" title="Using the OSMetaClass Constructor Macros"></a><h3>Using the OSMetaClass Constructor Macros</h3><p><a name="//apple_ref/doc/uid/TP30000695-DontLinkElementID_101"></a><a name="//apple_ref/doc/uid/TP30000695-DontLinkElementID_102"></a><a name="//apple_ref/doc/uid/TP30000695-DontLinkElementID_103"></a>When you create a C++ class based on OSObject, your code must call a matching pair of macros based upon the OSMetaClass class. The calls must be among the first statements in both the definition and implementation of the class. These macros are critical to your class because they enter metaclass information about it into the libkern <a name="//apple_ref/doc/uid/TP30000695-DontLinkElementID_104"></a><a name="//apple_ref/doc/uid/TP30000695-DontLinkElementID_105"></a><a name="//apple_ref/doc/uid/TP30000695-DontLinkElementID_106"></a>runtime typing facility and define the static <a name="//apple_ref/doc/uid/TP30000695-DontLinkElementID_107"></a>constructor and <a name="//apple_ref/doc/uid/TP30000695-DontLinkElementID_108"></a>destructor for your class.</p><p>For concrete (that is, non-abstract) classes, the first <a name="//apple_ref/doc/uid/TP30000695-DontLinkElementID_109"></a>macro, <code><!--a-->OSDeclareDefaultStructors<!--/a--></code> declares the C++ constructors; by convention you insert this macro as the first element of the class declaration in the header file. For example:</p><div class="codesample"><table><tr><td scope="row"><pre>class com_MyCompany_driver_MyDriver : public IOService<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    OSDeclareDefaultStructors(com_MyCompany_driver_MyDriver);<span></span></pre></td></tr><tr><td scope="row"><pre>    /* ... */<span></span></pre></td></tr><tr><td scope="row"><pre>};<span></span></pre></td></tr></table></div><p>Your class implementation must include the companion <a name="//apple_ref/doc/uid/TP30000695-DontLinkElementID_110"></a>“define” macro, <code>OSDefineMetaClassAndStructors</code>. This macro defines the constructor and destructor, implements the OSMetaClass allocation member function (<code>alloc</code>) for the class, and supplies the metaclass information for the runtime typing system. <code>OSDefineMetaClassAndStructors</code> takes as arguments the name of your driver’s class and the name of its base class. It uses these to generate code that allows your driver class to be loaded and instantiated while the kernel is running. It typically occurs as one of the first statements of the class implementation. For example, <code>MyDriver.cpp</code> might begin like this:</p><div class="codesample"><table><tr><td scope="row"><pre>#include "MyDriver.h"<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>// This convention makes it easy to invoke base class member functions.<span></span></pre></td></tr><tr><td scope="row"><pre>#define super    IOService<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>// You cannot use the "super" macro here, however, with the<span></span></pre></td></tr><tr><td scope="row"><pre>//  OSDefineMetaClassAndStructors macro.<span></span></pre></td></tr><tr><td scope="row"><pre>OSDefineMetaClassAndStructors(com_MyCompany_driver_MyDriver, IOService);<span></span></pre></td></tr></table></div><p>If the class you are defining is an abstract class intended only to be inherited from, use the <code><!--a-->OSDeclareAbstractStructors<!--/a--></code> and <code><!--a-->OSDefineMetaClassAndAbstractStructors<!--/a--></code> macros instead. These macros do the same things as their non-abstract counterparts except that they make the primary constructor private and define the <code>alloc</code> member function to return zero. </p><p>The <code>OSDefineMetaClassAndStructors</code> and <code><!--a-->OSDefineMetaClassAndAbstractStructors<!--/a--></code><a name="//apple_ref/doc/uid/TP30000695-DontLinkElementID_111"></a>macros are based on two other OSMetaClass macros: <code>OSDefineMetaClassAndStructorsWithInit</code> and <code><!--a-->OSDefineMetaClassAndAbstractStructorsWithInit<!--/a--></code>, respectively. These latter two macros are deprecated and should not be used directly.<a name="//apple_ref/doc/uid/TP30000695-DontLinkElementID_112"></a></p><a name="//apple_ref/doc/uid/TP30000695-BAJJDGIA" title="Allocating Objects Dynamically"></a><h3>Allocating Objects Dynamically</h3><p>The OSMetaClass plays an important role in the libkern C++ runtime by allocating objects based upon class type. Derived classes of OSMetaClass can do this dynamically by implementing the <code><!--a-->alloc<!--/a--></code><a name="//apple_ref/doc/uid/TP30000695-DontLinkElementID_113"></a>function; the class type is supplied by the OSMetaClass derived class itself. As mentioned in the previous section, <span class="content_text"><a href="CPlusPlusRuntime.html#//apple_ref/doc/uid/TP30000695-TPXREF103">“Object Scope and Constructor Invocation,”</a></span> the constructors created by the OSMetaClass macros implement <code>alloc</code> automatically for your class. </p><p>The container classes of libkern and the families of the I/O Kit provide various helper member functions for creating (allocating) objects, and these are what you use most of the time. But you can also directly allocate an instance of any libkern or I/O Kit class using two kinds of OSMetaClass calls: </p><ul class="spaceabove"><li class="li"><p>By calling one of the OSMetaClass <code><!--a-->allocClassWithName<!--/a--></code><a name="//apple_ref/doc/uid/TP30000695-DontLinkElementID_114"></a>functions, supplying an identification of class type (as an OSSymbol, OSString, or C-string)</p></li><li class="li"><p>By calling the macro <code><!--a-->OSTypeAlloc<!--/a--></code><a name="//apple_ref/doc/uid/TP30000695-DontLinkElementID_115"></a> (defined in the OSMetaClassBase class)</p></li></ul><p>Both the <code><!--a-->allocClassWithName<!--/a--></code> and the <code><!--a-->OSTypeAlloc<!--/a--></code> macro are similar in that they take some indication of type as the sole argument. However, there is an important difference. Because of a preprocessor artifact, the macro takes a type argument that is a compile-time symbol and not a string; thus the macro is more efficient than the dynamic allocation performed by the <code><!--a-->allocClassWithName<!--/a--></code> member functions, but it is not truly dynamic. The allocation member functions defer binding until runtime, whereas the macro will generate a link-time error if the kernel extension doesn’t properly specify the dependencies of the type argument. In addition, the macro, unlike the functions, casts the result to the appropriate type for you.</p><p>The <code><!--a-->OSTypeAlloc<!--/a--></code> macro is intended to replace the C++ <code>new</code> operator when you are creating objects derived from OSObject. The reason behind this change is binary compatibility: The <code>new<a name="//apple_ref/doc/uid/TP30000695-DontLinkElementID_116"></a></code> operator is fragile if you are creating an object that doesn’t exist in the same kernel extension as your code. By passing the size of a class as an argument to <code><!--a-->malloc<!--/a--></code>, C++ compiles the size value into the calling binary. But if there are any dependencies on that size and the class later becomes larger, the binary might break in sundry subtle ways, such as by writing over succeeding allocation blocks. The <code><!--a-->OSTypeAlloc<!--/a--></code> macro, on the other hand, allows the class doing the allocation to determine its own size.</p><p>Freshly allocated objects created with the allocation macro or functions have a retain count of one as their sole data member and are otherwise uninitialized. After allocation, you should immediately invoke the object’s initialization member function (typically <code><!--a-->init<!--/a--></code> or some variant of <code><!--a-->init<!--/a--></code>). The initialization code thus has the opportunity to test whether the object is valid and to return an appropriate error code if it isn’t.</p><a name="//apple_ref/doc/uid/TP30000695-TPXREF102" title="Global Initializers"></a><h3>Global Initializers</h3><p><a name="//apple_ref/doc/uid/TP30000695-DontLinkElementID_117"></a>Global constructors<a name="//apple_ref/doc/uid/TP30000695-DontLinkElementID_118"></a>—sometimes called global initializers—are a useful feature of the C++ language. For drivers, they permit the safe initialization and allocation of resources that must be available before the driver starts transferring data. To properly understand what global constructors are and why they are useful, let’s first review <em>when</em> C++ objects with various kinds of scope are constructed and destroyed.</p><a name="//apple_ref/doc/uid/TP30000695-TPXREF103" title="Object Scope and Constructor Invocation"></a><h4>Object Scope and Constructor Invocation</h4><p><a name="//apple_ref/doc/uid/TP30000695-DontLinkElementID_119"></a>C++ gives you four different ways to create an object. In each case, the object has a specific scope because the invocations of its constructor and destructor occur at specific times. Where the construction of the object occurs as a result of declaration (automatic local, static local, and global), only the default constructor is invoked.</p><ul class="spaceabove"><li class="li"><p><strong>Explicitly created objects</strong> Such objects are dynamically created through the <code>new</code> operator and are destroyed through the <code>delete</code> operator. The life time of the object is the period between <code>new</code> and <code>delete</code>, because that is when the constructor and destructor are called. OSMetaClass bases its mechanism for dynamic allocation of libkern objects on the <code>new</code> operator. All objects that inherit from OSObject can only be explicitly created objects. OSMetaClassBase’s <code>retain</code> and <code>release</code> calls implement a more sophisticated reference-counting mechanism—based on <code>new</code> and <code>delete</code>—for object persistence.</p></li><li class="li"><p><strong>Automatic local objects</strong> An automatic local object is created each time control pass through its declaration within a member function. Its destructor is called each time control passes back above the object’s declaration or out of the enclosing block. The following example illustrates the scope of automatic local objects (<code>IntArray</code> is a C++ class):</p><div class="codesample"><table><tr><td scope="row"><pre>void func() {<span></span></pre></td></tr><tr><td scope="row"><pre>    IntArray a1;                // a1 constructed here 1 time<span></span></pre></td></tr><tr><td scope="row"><pre>    int l = 2;<span></span></pre></td></tr><tr><td scope="row"><pre>    for (i=0; i &lt; 3; i++) {<span></span></pre></td></tr><tr><td scope="row"><pre>        IntArray a2;            // a2 constructed here 3 times<span></span></pre></td></tr><tr><td scope="row"><pre>        if (i == l) {<span></span></pre></td></tr><tr><td scope="row"><pre>            IntArray a3;        // a3 constructed here 1 time<span></span></pre></td></tr><tr><td scope="row"><pre>            // ...                 (when "if" is true)<span></span></pre></td></tr><tr><td scope="row"><pre>        }                       // a3 destroyed at exit of "if" block<span></span></pre></td></tr><tr><td scope="row"><pre>    }                           // a2 destroyed here 3 times<span></span></pre></td></tr><tr><td scope="row"><pre>}                               // a1 destroyed here 1 time<span></span></pre></td></tr></table></div></li><li class="li"><p><strong>Static local objects</strong> These objects are similar to automatic local objects, but with a few important differences. Static local objects are declared within a member function with a <code>static</code> keyword. Like an automatic local object, a static object’s constructor is called when control passes through the declaration, but only the first time. It won’t be constructed if control never passes through its declaration. A static local object’s destructor is called only when the executable exits normally (such as when <code><!--a-->main<!--/a--></code> returns or <code><!--a-->exit<!--/a--></code> is called or a kernel extension is unloaded).</p><div class="importantbox"><a name="//apple_ref/doc/uid/TP30000695-DontLinkElementID_10" title="Important:"></a><p><strong>Important:</strong>&nbsp;Because of implementation constraints, static local objects do not work as intended in the Darwin kernel. Therefore your code should not rely on them.</p><p></p></div></li><li class="li"><p><strong>Global objects</strong> A global object is declared outside of any function. It exists throughout the runtime life of an executable. The constructor of a global object is invoked before an executable’s entry point; the destructor is called after the program exits. Adding the keyword <code>static</code> to the declaration limits the scope of the object to the translation unit (typically an object file) in which it is defined<a name="//apple_ref/doc/uid/TP30000695-DontLinkElementID_120"></a>.</p></li></ul><div class="notebox"><a name="//apple_ref/doc/uid/TP30000695-DontLinkElementID_11" title="Note"></a><p><strong>Note:</strong>&nbsp;The descriptions and example above borrow liberally from <em>C++: The Core Language</em>, Gregory Satir and Doug Brown, O’Reilly &amp; Associates, Cambridge 1995.</p></div><p>For I/O Kit drivers, the scope of a global object entails a guarantee that two things will happen:</p><ul class="spaceabove"><li class="li"><p>The constructor is called before the invocation of its KEXT-binary’s functional entry point. For drivers, global constructors are called at load time; for other kernel extensions, global constructors are called before <code>MODULE_START</code>.</p></li><li class="li"><p>The code running in the constructor is single-threaded (per KEXT binary).</p></li></ul><p>Because of these guarantees, a global constructor—or, more descriptively, a global initializer—is an ideal programming locale for implementing locks (taking advantage of the single-threadedness) and for initializing global resources.</p><p>There are a couple of caveats to note about C++ objects with global scope. First, such objects cannot derive from OSObject; as noted earlier, libkern permits only the explicit creation of objects. Second, if your code has multiple global initializers in the same translation unit, they are invoked in the order of their definition. However, if you have multiple global initializers in different KEXT binaries, the order of their invocation between binaries is undefined. Because of this, it is good programming practice to avoid dependencies among global initializers.</p><a name="//apple_ref/doc/uid/TP30000695-TPXREF104" title="An Example of a Global Initializer"></a><h4>An Example of a Global Initializer</h4><p>As the previous section makes clear, global initializers are an ideal means for initializing global data structures and for setting up resources such as locks, typically to protect those data structures. Let’s look at how a global initializer might be used in driver writing.</p><p>The I/O Kit Serial family uses a global initializer to initialize global data structures. <span class="content_text"><a href="CPlusPlusRuntime.html#//apple_ref/doc/uid/TP30000695-BAJCFHDC">Listing 1-1</a></span> shows the definition of the (private) IOSerialBSDClientGlobals class. Following the definition is the declaration of a <code>static</code> variable of the class; this definition generates a single instance of the class and tells the compiler that this instance and its data are global in scope.</p><a name="//apple_ref/doc/uid/TP30000695-BAJCFHDC" title="Listing 1-1Definition of a class to be declared global"></a><p class="codesample"><strong>Listing 1-1&nbsp;&nbsp;</strong>Definition of a class to be declared global</p><div class="codesample"><table><tr><td scope="row"><pre>class IOSerialBSDClientGlobals {<span></span></pre></td></tr><tr><td scope="row"><pre>private:<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    unsigned int fMajor;<span></span></pre></td></tr><tr><td scope="row"><pre>    unsigned int fLastMinor;<span></span></pre></td></tr><tr><td scope="row"><pre>    IOSerialBSDClient **fClients;<span></span></pre></td></tr><tr><td scope="row"><pre>    OSDictionary *fNames;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>public:<span></span></pre></td></tr><tr><td scope="row"><pre>    IOSerialBSDClientGlobals();<span></span></pre></td></tr><tr><td scope="row"><pre>    ~IOSerialBSDClientGlobals();<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    inline bool isValid();<span></span></pre></td></tr><tr><td scope="row"><pre>    inline IOSerialBSDClient *getClient(dev_t dev);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    dev_t assign_dev_t();<span></span></pre></td></tr><tr><td scope="row"><pre>    bool registerTTY(dev_t dev, IOSerialBSDClient *tty);<span></span></pre></td></tr><tr><td scope="row"><pre>    const OSSymbol *getUniqueTTYSuffix<span></span></pre></td></tr><tr><td scope="row"><pre>        (const OSSymbol *inName, const OSSymbol *suffix, dev_t dev);<span></span></pre></td></tr><tr><td scope="row"><pre>    void releaseUniqueTTYSuffix(const OSSymbol *inName, const OSSymbol *suffix);<span></span></pre></td></tr><tr><td scope="row"><pre>};<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>static IOSerialBSDClientGlobals sBSDGlobals;<span></span></pre></td></tr></table></div><p>The declaration of the <code>sBSDGlobals</code> variable kicks off the constructor for the IOSerialBSDClientGlobals class (and other global initializers) at load time. The Serial family implements this constructor as shown in <span class="content_text"><a href="CPlusPlusRuntime.html#//apple_ref/doc/uid/TP30000695-BAJDGHDC">Listing 1-2</a></span>.</p><a name="//apple_ref/doc/uid/TP30000695-BAJDGHDC" title="Listing 1-2Implementation of a global constructor"></a><p class="codesample"><strong>Listing 1-2&nbsp;&nbsp;</strong>Implementation of a global constructor</p><div class="codesample"><table><tr><td scope="row"><pre>#define OSSYM(str) OSSymbol::withCStringNoCopy(str)<span></span></pre></td></tr><tr><td scope="row"><pre>IOSerialBSDClientGlobals::IOSerialBSDClientGlobals()<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    gIOSerialBSDServiceValue = OSSYM(kIOSerialBSDServiceValue);<span></span></pre></td></tr><tr><td scope="row"><pre>    gIOSerialBSDTypeKey      = OSSYM(kIOSerialBSDTypeKey);<span></span></pre></td></tr><tr><td scope="row"><pre>    gIOSerialBSDAllTypes     = OSSYM(kIOSerialBSDAllTypes);<span></span></pre></td></tr><tr><td scope="row"><pre>    gIOSerialBSDModemType    = OSSYM(kIOSerialBSDModemType);<span></span></pre></td></tr><tr><td scope="row"><pre>    gIOSerialBSDRS232Type    = OSSYM(kIOSerialBSDRS232Type);<span></span></pre></td></tr><tr><td scope="row"><pre>    gIOTTYDeviceKey          = OSSYM(kIOTTYDeviceKey);<span></span></pre></td></tr><tr><td scope="row"><pre>    gIOTTYBaseNameKey        = OSSYM(kIOTTYBaseNameKey);<span></span></pre></td></tr><tr><td scope="row"><pre>    gIOTTYSuffixKey          = OSSYM(kIOTTYSuffixKey);<span></span></pre></td></tr><tr><td scope="row"><pre>    gIOCalloutDeviceKey      = OSSYM(kIOCalloutDeviceKey);<span></span></pre></td></tr><tr><td scope="row"><pre>    gIODialinDeviceKey       = OSSYM(kIODialinDeviceKey);<span></span></pre></td></tr><tr><td scope="row"><pre>    gIOTTYWaitForIdleKey     = OSSYM(kIOTTYWaitForIdleKey);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    fMajor = (unsigned int) -1;<span></span></pre></td></tr><tr><td scope="row"><pre>    fNames = OSDictionary::withCapacity(4);<span></span></pre></td></tr><tr><td scope="row"><pre>    fLastMinor = 4;<span></span></pre></td></tr><tr><td scope="row"><pre>    fClients = (IOSerialBSDClient **)<span></span></pre></td></tr><tr><td scope="row"><pre>                IOMalloc(fLastMinor * sizeof(fClients[0]));<span></span></pre></td></tr><tr><td scope="row"><pre>    if (fClients &amp;&amp; fNames) {<span></span></pre></td></tr><tr><td scope="row"><pre>        bzero(fClients, fLastMinor * sizeof(fClients[0]));<span></span></pre></td></tr><tr><td scope="row"><pre>        fMajor = cdevsw_add(-1, &amp;IOSerialBSDClient::devsw);<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if (!isValid())<span></span></pre></td></tr><tr><td scope="row"><pre>        IOLog("IOSerialBSDClient didn't initialize");<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre>#undef OSSYM<span></span></pre></td></tr></table></div><p>This code creates OSSymbol objects for various attributes of the Serial family and allocates other global resources. One thing to note about this example code is the call to <code>isValid</code>; this member function simply verifies whether the global initialization succeeded. Because exceptions are excluded from the kernel’s restricted form of C++, you need to make some validation check like this either in the constructor itself or in the <code>start</code> member function. If the global initializer did not do its work, your driver should gracefully exit. </p><p>The destructor for the IOSerialBSDClientGlobals (see <span class="content_text"><a href="CPlusPlusRuntime.html#//apple_ref/doc/uid/TP30000695-BAJDBEEB">Listing 1-3</a></span>) class frees the global resources created by the constructor. A global destructor is called after the invocation of the <code>MODULE_STOP</code> member function or, in the case of drivers, at unload time.</p><a name="//apple_ref/doc/uid/TP30000695-BAJDBEEB" title="Listing 1-3Implementation of a global destructor"></a><p class="codesample"><strong>Listing 1-3&nbsp;&nbsp;</strong>Implementation of a global destructor</p><div class="codesample"><table><tr><td scope="row"><pre>IOSerialBSDClientGlobals::~IOSerialBSDClientGlobals()<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    SAFE_RELEASE(gIOSerialBSDServiceValue);<span></span></pre></td></tr><tr><td scope="row"><pre>    SAFE_RELEASE(gIOSerialBSDTypeKey);<span></span></pre></td></tr><tr><td scope="row"><pre>    SAFE_RELEASE(gIOSerialBSDAllTypes);<span></span></pre></td></tr><tr><td scope="row"><pre>    SAFE_RELEASE(gIOSerialBSDModemType);<span></span></pre></td></tr><tr><td scope="row"><pre>    SAFE_RELEASE(gIOSerialBSDRS232Type);<span></span></pre></td></tr><tr><td scope="row"><pre>    SAFE_RELEASE(gIOTTYDeviceKey);<span></span></pre></td></tr><tr><td scope="row"><pre>    SAFE_RELEASE(gIOTTYBaseNameKey);<span></span></pre></td></tr><tr><td scope="row"><pre>    SAFE_RELEASE(gIOTTYSuffixKey);<span></span></pre></td></tr><tr><td scope="row"><pre>    SAFE_RELEASE(gIOCalloutDeviceKey);<span></span></pre></td></tr><tr><td scope="row"><pre>    SAFE_RELEASE(gIODialinDeviceKey);<span></span></pre></td></tr><tr><td scope="row"><pre>    SAFE_RELEASE(gIOTTYWaitForIdleKey);<span></span></pre></td></tr><tr><td scope="row"><pre>    SAFE_RELEASE(fNames);<span></span></pre></td></tr><tr><td scope="row"><pre>    if (fMajor != (unsigned int) -1)<span></span></pre></td></tr><tr><td scope="row"><pre>        cdevsw_remove(fMajor, &amp;IOSerialBSDClient::devsw);<span></span></pre></td></tr><tr><td scope="row"><pre>    if (fClients)<span></span></pre></td></tr><tr><td scope="row"><pre>        IOFree(fClients, fLastMinor * sizeof(fClients[0]));<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>As shown in this example, the destructor should always check if initializations did occur before attempting to free resources.<a name="//apple_ref/doc/uid/TP30000695-DontLinkElementID_121"></a></p><a name="//apple_ref/doc/uid/TP30000695-TPXREF105" title="Object Introspection and Dynamic Casting"></a><h2>Object Introspection and Dynamic Casting</h2><p>Object introspection<a name="//apple_ref/doc/uid/TP30000695-DontLinkElementID_122"></a> is a major benefit that the libkern runtime typing facility brings to kernel programming. By querying this facility, the functions and macros of the <a name="//apple_ref/doc/uid/TP30000695-DontLinkElementID_123"></a>OSMetaClass and <a name="//apple_ref/doc/uid/TP30000695-DontLinkElementID_124"></a>OSMetaClassBase classes allow you to discover a range of information about arbitrary objects and classes:</p><ul class="ul"><li class="li"><p>The class of which an object is a member</p></li><li class="li"><p>Whether an object inherits from (directly or indirectly) a specified class</p></li><li class="li"><p>Whether one object is equal to another object</p></li><li class="li"><p>The current number of runtime instances for a class and its derived classes</p></li><li class="li"><p>The size, name, and base class of a particular class</p></li></ul><p><span class="content_text"><a href="CPlusPlusRuntime.html#//apple_ref/doc/uid/TP30000695-BAJIIFFA">Table 1-1</a></span> describes the introspection functions and macros.</p><a name="//apple_ref/doc/uid/TP30000695-BAJIIFFA" title="Table 1-1OSMetaClass and OSMetaClassBase introspection macros and member functions"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 1-1&nbsp;&nbsp;</strong>OSMetaClass and OSMetaClassBase introspection macros and member functions</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Member Function or Macro</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Description</p></th></tr><tr><td  scope="row"><p><code><!--a-->OSTypeID<!--/a--></code></p></td><td ><p>A macro that, given a class name (not quoted), returns the indicated OSMetaClass instance.</p></td></tr><tr><td  scope="row"><p><code><!--a-->OSTypeIDInst<!--/a--></code></p></td><td ><p>A macro that, given an instance of an OSObject derived class, returns the class of that object (as an OSMetaClass instance).</p></td></tr><tr><td  scope="row"><p><code><!--a-->OSCheckTypeInst<!--/a--></code></p></td><td ><p>A macro that determines whether a given object inherits directly or indirectly from the same class as a reference object (that is, an object whose class type is known).</p></td></tr><tr><td  scope="row"><p><code>isEqualTo</code></p></td><td ><p>Returns <code>true</code> if two objects are equivalent. What equivalence means depends upon the libkern or I/O Kit derived class overriding this member function. OSMetaClassBase implements this function as a shallow pointer comparison.</p></td></tr><tr><td  scope="row"><p><code>metaCast</code></p></td><td ><p>Determines whether an object inherits from a given class; variants of the member function let you specify the class as an OSMetaClass instance, an OSSymbol object, an OSString object, or a C-string. Defined by the OSMetaClassBase class.</p></td></tr><tr><td  scope="row"><p><code>checkMetaCastWithName</code></p></td><td ><p>Similar to <code>metaCast</code>, but implemented as a static member function of OSMetaClass.</p></td></tr><tr><td  scope="row"><p><code>getInstanceCount</code></p></td><td ><p>OSMetaClass accessor that returns the current number of instances for a given class (specified as an instance of OSMetaClass) and all derived classes of that class.</p></td></tr><tr><td  scope="row"><p><code>getSuperClass</code></p></td><td ><p>OSMetaClass accessor function that returns the base class of the specified class.</p></td></tr><tr><td  scope="row"><p><code>getClassName</code></p></td><td ><p>OSMetaClass accessor function that returns the name of the specified class.</p></td></tr><tr><td  scope="row"><p><code>getClassSize</code></p></td><td ><p>OSMetaClass accessor function that returns the size of the specified class.</p></td></tr></table></div><p>OSMetaClassBase also includes a useful macro named <code><!--a-->OSDynamicCast<!--/a--></code>. This macro does basically the same thing as the standard C++ <code>dynamic_cast&lt;</code><code></code><em>type</em><code> *>(</code><em>object</em><code>)</code> operator: It converts the class type of an object to another, compatible type. But before the <code><!--a-->OSDynamicCast<!--/a--></code> macro converts the type of the instance, it verifies that the cast is valid—that is, it checks if the given instance inherits from the given type. If it doesn’t, it returns zero. It also returns zero if either the class type or the instance specified as a parameter is zero. No type qualifiers, such as <code>const</code>, are allowed in the parameters<a name="//apple_ref/doc/uid/TP30000695-DontLinkElementID_125"></a><a name="//apple_ref/doc/uid/TP30000695-DontLinkElementID_126"></a>.</p><p><span class="content_text"><a href="CPlusPlusRuntime.html#//apple_ref/doc/uid/TP30000695-BAJJBGDA">Listing 1-4</a></span> illustrates how you might do some introspection tests and dynamic casts. </p><a name="//apple_ref/doc/uid/TP30000695-BAJJBGDA" title="Listing 1-4Code showing dynamic casting and introspection"></a><p class="codesample"><strong>Listing 1-4&nbsp;&nbsp;</strong>Code showing dynamic casting and introspection</p><div class="codesample"><table><tr><td scope="row"><pre>void testIntrospection() {<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    unsigned long long val = 11;<span></span></pre></td></tr><tr><td scope="row"><pre>    int count;<span></span></pre></td></tr><tr><td scope="row"><pre>    bool yup;<span></span></pre></td></tr><tr><td scope="row"><pre>    OSString *strObj = OSString::withCString("Darth Vader");<span></span></pre></td></tr><tr><td scope="row"><pre>    OSNumber *numObj = OSTypeAlloc(OSNumber);<span></span></pre></td></tr><tr><td scope="row"><pre>    numObj->init(val, 3);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    yup = OSCheckTypeInst(strObj, numObj);<span></span></pre></td></tr><tr><td scope="row"><pre>    IOLog("strObj %s the same as numObj\n", (yup ? "is" : "is not"));<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    count = (OSTypeIDInst(numObj))->getInstanceCount();<span></span></pre></td></tr><tr><td scope="row"><pre>    IOLog("There are %d instances of OSNumber\n", count);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if (OSDynamicCast(OSString, strObj)) {<span></span></pre></td></tr><tr><td scope="row"><pre>    IOLog("Could cast strObj to OSString");<span></span></pre></td></tr><tr><td scope="row"><pre>    } else {<span></span></pre></td></tr><tr><td scope="row"><pre>    IOLog("Couldn't cast strObj to OSString");<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP30000695-TPXREF106" title="Binary Compatibility"></a><h2>Binary Compatibility</h2><p>Something that has long plagued C++ library developers is the fragile base class problem. The libkern library and, more specifically, the OSMetaClass class offer ways to avoid the danger to backward <a name="//apple_ref/doc/uid/TP30000695-DontLinkElementID_127"></a>binary compatibility posed by fragile base classes. But before you learn about those APIs, you might find a summary of the fragile base class problem helpful. </p><div class="notebox"><a name="//apple_ref/doc/uid/TP30000695-DontLinkElementID_12" title="Note"></a><p><strong>Note:</strong>&nbsp;Also see the section <span class="content_text"><a href="CPlusPlusRuntime.html#//apple_ref/doc/uid/TP30000695-BAJJDGIA">“Allocating Objects Dynamically”</a></span> for a discussion of the use of the <code><!--a-->OSTypeAlloc<!--/a--></code> macro as a factor in binary compatibility.</p></div><a name="//apple_ref/doc/uid/TP30000695-TPXREF107" title="The Fragile Base Class Problem"></a><h3>The Fragile Base Class Problem</h3><p><a name="//apple_ref/doc/uid/TP30000695-DontLinkElementID_128"></a>The fragile base class problem affects only non-leaf classes, and then only when those classes are defined in different KEXTs. So if you never intend your libkern or I/O Kit class to be a base class, then fragile base classes won’t be an issue (and you have no need to read further). But if your class could be a base class to some other class, and you later change your class in certain ways, all external KEXTs with dependencies on your class are likely to experience problems that will cause them to break.</p><p>Not all changes to a non-leaf class make it a fragile base class. For instance, you can add non-virtual functions or even new classes to a kernel extension without peril. If you have a function that is a polymorphed version of a base class virtual function you won’t have a problem either. And you can always reimplement a member function, virtual or non-virtual. But there are certain additions and modifications that are almost certain to cause binary-compatibility<a name="//apple_ref/doc/uid/TP30000695-DontLinkElementID_129"></a> problems:</p><ul class="spaceabove"><li class="li"><p>New virtual member functions</p></li><li class="li"><p>Changes to the order of virtual-function declarations</p></li><li class="li"><p>New instance variables (data members)</p></li><li class="li"><p>Changes to the type or size of instance variables (for example, changing a <code>short</code> to a <code>long</code> or increasing the maximum size of an array)</p></li></ul><p>The reason these modifications to a non-leaf class introduce fragility is that KEXTs containing derived classes of that class incorporate knowledge of characteristics of the base class such as:</p><ul class="spaceabove"><li class="li"><p>The size of the object</p></li><li class="li"><p>Offsets to protected or public data</p></li><li class="li"><p>The size of your class’s virtual table (vtable) as well as the offsets in it </p></li></ul><p>Code that is dependent on these sizes and offsets will break if a size or offset subsequently changes. To look at it another way, each compiled C++ class is, internally, two structures. One structure holds the aggregate data members in an inheritance chain; the other structure contains the aggregate virtual tables<a name="//apple_ref/doc/uid/TP30000695-DontLinkElementID_130"></a> of the same inheritance chain. (An instance of the class holds <em>all</em> of the aggregate data members and contains a pointer to one instance of the aggregate virtual tables.) The C++ runtime uses the sizes and offsets created by these concatenated structures to locate data members and member functions. <span class="content_text"><a href="CPlusPlusRuntime.html#//apple_ref/doc/uid/TP30000695-BAJCBIDG">Figure 1-2</a></span> illustrates in an abstract way how these structures might be laid out internally.</p><br/><div><a name="//apple_ref/doc/uid/TP30000695-BAJCBIDG" title="Figure 1-2The aggregate data and vtable structures of a compiled class"></a><p><strong>Figure 1-2&nbsp;&nbsp;</strong>The aggregate data and vtable structures of a compiled class</p><img src = "../Art/class_internal_struct.gif" alt = "The aggregate data and vtable structures of a compiled class" width="286" height="344"></div><br/><p>The libkern C++ library has mechanisms that mitigate the fragile base class problem. Basically, these techniques let you create “pad slots” (that is, reserved fields) for both data members and virtual functions anticipated for future expansion. The following sections explain how to pad a class, and then how to adjust the padding whenever you add new data members or virtual functions<a name="//apple_ref/doc/uid/TP30000695-DontLinkElementID_131"></a><a name="//apple_ref/doc/uid/TP30000695-DontLinkElementID_132"></a>.</p><a name="//apple_ref/doc/uid/TP30000695-TPXREF108" title="Reserving Future Data Members"></a><h3>Reserving Future Data Members</h3><p><a name="//apple_ref/doc/uid/TP30000695-DontLinkElementID_133"></a>To prepare your non-leaf class for any future addition of data members, specify an empty <code>ExpansionData</code> structure and a <code>reserved</code> pointer to that structure. Then, when you add a field to this structure, allocate this additional data in the initialization member function for the class (typically <code>init</code>).</p><div class="notebox"><a name="//apple_ref/doc/uid/TP30000695-DontLinkElementID_13" title="Note"></a><p><strong>Note:</strong>&nbsp;The names <code>ExpansionData</code> and <code>reserved</code> are not defined in libkern but are conventions that Apple encourages you to follow to maintain consistency. Remember, there will be no name-space collisions because each <code>ExpansionData</code> is implicitly qualified by its class (for example, <code>com_acme_driver_MyDriverClass::ExpansionData</code>).</p></div><p>Enter the lines in <span class="content_text"><a href="CPlusPlusRuntime.html#//apple_ref/doc/uid/TP30000695-BAJFCJGA">Listing 1-5</a></span> into your class header file in a section with protected scope (as indicated).</p><a name="//apple_ref/doc/uid/TP30000695-BAJFCJGA" title="Listing 1-5Initial declarations of the ExpansionData structure and reserved pointer"></a><p class="codesample"><strong>Listing 1-5&nbsp;&nbsp;</strong>Initial declarations of the <code>ExpansionData</code> structure and <code>reserved</code> pointer</p><div class="codesample"><table><tr><td scope="row"><pre>protected:<span></span></pre></td></tr><tr><td scope="row"><pre>/*! @struct ExpansionData<span></span></pre></td></tr><tr><td scope="row"><pre>    @discussion This structure helps to expand the capabilities of<span></span></pre></td></tr><tr><td scope="row"><pre>    this class in the future.<span></span></pre></td></tr><tr><td scope="row"><pre>    */<span></span></pre></td></tr><tr><td scope="row"><pre>    struct ExpansionData { };<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/*! @var reserved<span></span></pre></td></tr><tr><td scope="row"><pre>    Reserved for future use.  (Internal use only)  */<span></span></pre></td></tr><tr><td scope="row"><pre>    ExpansionData *reserved;<span></span></pre></td></tr></table></div><p>Later, when you need to add new data members to your class, add the field or fields to the <code>ExpansionData</code> structure and define a preprocessor symbol for the field as referenced by the <code>reserved</code> pointer. <span class="content_text"><a href="CPlusPlusRuntime.html#//apple_ref/doc/uid/TP30000695-BAJDGCGJ">Listing 1-6</a></span> shows how you might do this.</p><a name="//apple_ref/doc/uid/TP30000695-BAJDGCGJ" title="Listing 1-6Adding a new field to the ExpansionData structure"></a><p class="codesample"><strong>Listing 1-6&nbsp;&nbsp;</strong>Adding a new field to the <code>ExpansionData</code> structure</p><div class="codesample"><table><tr><td scope="row"><pre>struct ExpansionData { int eBlastIForgot; };<span></span></pre></td></tr><tr><td scope="row"><pre>ExpansionData *reserved;<span></span></pre></td></tr><tr><td scope="row"><pre>#define fBlastIForgot ((com_acme_driver_MyDriverClass::ExpansionData *)<span></span></pre></td></tr><tr><td scope="row"><pre>            com_acme_driver_MyDriverClass::reserved)->eBlastIForgot)<span></span></pre></td></tr></table></div><p>Finally, at initialization time, allocate the newly expanded structure.</p><a name="//apple_ref/doc/uid/TP30000695-TPXREF109" title="Padding the Virtual Table"></a><h3>Padding the Virtual Table</h3><p><a name="//apple_ref/doc/uid/TP30000695-DontLinkElementID_134"></a>The first step toward padding the virtual table of your class is to estimate how many pad slots you’ll need—that is, how many virtual functions might be added to your class in the future. You don’t want to add too many, for that could unnecessarily bloat the memory footprint of your code, and you don’t want to add too few, for obvious reasons. A good estimation technique is the following: </p><ol class="ol"><li class="li"><p>Count the virtual functions in your class that are just polymorphed versions of a base class virtual function.</p></li><li class="li"><p>Subtract that value from the total number of virtual functions in your class.</p></li><li class="li"><p>Pick a number between the result of the subtraction and the total number of virtual functions. Your choice, of course, should be influenced by your sense of how much updating the API might undergo in the future.</p></li></ol><p>When you’ve determined how many reserved slots you’ll need for future expansion, specify the <code><!--a-->OSMetaClassDeclareReservedUnused<!--/a--></code> macro in your class header file for each slot. This macro takes two parameters: the class name and the index of the pad slot. <span class="content_text"><a href="CPlusPlusRuntime.html#//apple_ref/doc/uid/TP30000695-BAJCGGIG">Listing 1-7</a></span> shows how the IOHIDDevice class specifies the <code><!--a-->OSMetaClassDeclareReservedUnused<!--/a--></code> macro.</p><a name="//apple_ref/doc/uid/TP30000695-BAJCGGIG" title="Listing 1-7The initial padding of a class virtual table (header file)"></a><p class="codesample"><strong>Listing 1-7&nbsp;&nbsp;</strong>The initial padding of a class virtual table (header file)</p><div class="codesample"><table><tr><td scope="row"><pre>public:<span></span></pre></td></tr><tr><td scope="row"><pre>    // ...<span></span></pre></td></tr><tr><td scope="row"><pre>    OSMetaClassDeclareReservedUnused(IOHIDDevice,  0);<span></span></pre></td></tr><tr><td scope="row"><pre>    OSMetaClassDeclareReservedUnused(IOHIDDevice,  1);<span></span></pre></td></tr><tr><td scope="row"><pre>    OSMetaClassDeclareReservedUnused(IOHIDDevice,  2);<span></span></pre></td></tr><tr><td scope="row"><pre>    OSMetaClassDeclareReservedUnused(IOHIDDevice,  3);<span></span></pre></td></tr><tr><td scope="row"><pre>    OSMetaClassDeclareReservedUnused(IOHIDDevice,  4);<span></span></pre></td></tr><tr><td scope="row"><pre>    OSMetaClassDeclareReservedUnused(IOHIDDevice,  5);<span></span></pre></td></tr><tr><td scope="row"><pre>    OSMetaClassDeclareReservedUnused(IOHIDDevice,  6);<span></span></pre></td></tr><tr><td scope="row"><pre>    OSMetaClassDeclareReservedUnused(IOHIDDevice,  7);<span></span></pre></td></tr><tr><td scope="row"><pre>    OSMetaClassDeclareReservedUnused(IOHIDDevice,  8);<span></span></pre></td></tr><tr><td scope="row"><pre>    OSMetaClassDeclareReservedUnused(IOHIDDevice,  9);<span></span></pre></td></tr><tr><td scope="row"><pre>    OSMetaClassDeclareReservedUnused(IOHIDDevice, 10);<span></span></pre></td></tr><tr><td scope="row"><pre>    // ...<span></span></pre></td></tr></table></div><p>In your class implementation file, type the corresponding <code><!--a-->OSMetaClassDefineReservedUnused<!--/a--></code> macros. These macros also take the name of the class and the index of the pad slot as parameters. <span class="content_text"><a href="CPlusPlusRuntime.html#//apple_ref/doc/uid/TP30000695-BAJFBDJH">Listing 1-8</a></span> shows these macros as they appear in the <code>IOHIDDevice.cpp</code> file</p><a name="//apple_ref/doc/uid/TP30000695-BAJFBDJH" title="Listing 1-8The initial padding of a class virtual table (implementation file)"></a><p class="codesample"><strong>Listing 1-8&nbsp;&nbsp;</strong>The initial padding of a class virtual table (implementation file)</p><div class="codesample"><table><tr><td scope="row"><pre>// at end of function implementations<span></span></pre></td></tr><tr><td scope="row"><pre>OSMetaClassDefineReservedUnused(IOHIDDevice,  0);<span></span></pre></td></tr><tr><td scope="row"><pre>OSMetaClassDefineReservedUnused(IOHIDDevice,  1);<span></span></pre></td></tr><tr><td scope="row"><pre>OSMetaClassDefineReservedUnused(IOHIDDevice,  2);<span></span></pre></td></tr><tr><td scope="row"><pre>OSMetaClassDefineReservedUnused(IOHIDDevice,  3);<span></span></pre></td></tr><tr><td scope="row"><pre>OSMetaClassDefineReservedUnused(IOHIDDevice,  4);<span></span></pre></td></tr><tr><td scope="row"><pre>OSMetaClassDefineReservedUnused(IOHIDDevice,  5);<span></span></pre></td></tr><tr><td scope="row"><pre>OSMetaClassDefineReservedUnused(IOHIDDevice,  6);<span></span></pre></td></tr><tr><td scope="row"><pre>OSMetaClassDefineReservedUnused(IOHIDDevice,  7);<span></span></pre></td></tr><tr><td scope="row"><pre>OSMetaClassDefineReservedUnused(IOHIDDevice,  8);<span></span></pre></td></tr><tr><td scope="row"><pre>OSMetaClassDefineReservedUnused(IOHIDDevice,  9);<span></span></pre></td></tr><tr><td scope="row"><pre>OSMetaClassDefineReservedUnused(IOHIDDevice, 10);<span></span></pre></td></tr><tr><td scope="row"><pre>// ...<span></span></pre></td></tr></table></div><p>When you subsequently add a virtual function to your class, replace the <code><!--a-->OSMetaClassDeclareReservedUnused<!--/a--></code> macro having the lowest index in your class header file with an   <code><!--a-->OSMetaClassDeclareReservedUsed<!--/a--></code> macro; be sure to use the same index number. To document the replacement, have the macro immediately precede the declaration of the function. The IOHIDDevice class does this as shown in <span class="content_text"><a href="CPlusPlusRuntime.html#//apple_ref/doc/uid/TP30000695-BAJBGAJB">Listing 1-9</a></span>.</p><a name="//apple_ref/doc/uid/TP30000695-BAJBGAJB" title="Listing 1-9Adjusting the pad slots when adding new virtual functions&acirc;&#128;&#148;header file"></a><p class="codesample"><strong>Listing 1-9&nbsp;&nbsp;</strong>Adjusting the pad slots when adding new virtual functions—header file</p><div class="codesample"><table><tr><td scope="row"><pre>public:<span></span></pre></td></tr><tr><td scope="row"><pre>// ...<span></span></pre></td></tr><tr><td scope="row"><pre>    OSMetaClassDeclareReservedUsed(IOHIDDevice,  0);<span></span></pre></td></tr><tr><td scope="row"><pre>    virtual IOReturn updateElementValues(IOHIDElementCookie * cookies,<span></span></pre></td></tr><tr><td scope="row"><pre>                                        UInt32 cookieCount = 1);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>protected:<span></span></pre></td></tr><tr><td scope="row"><pre>    OSMetaClassDeclareReservedUsed(IOHIDDevice,  1);<span></span></pre></td></tr><tr><td scope="row"><pre>    virtual IOReturn postElementValues(IOHIDElementCookie * cookies,<span></span></pre></td></tr><tr><td scope="row"><pre>                                        UInt32 cookieCount = 1);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>public:<span></span></pre></td></tr><tr><td scope="row"><pre>    OSMetaClassDeclareReservedUsed(IOHIDDevice,  2);<span></span></pre></td></tr><tr><td scope="row"><pre>    virtual OSString * newSerialNumberString() const;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    OSMetaClassDeclareReservedUnused(IOHIDDevice,  3);<span></span></pre></td></tr><tr><td scope="row"><pre>    OSMetaClassDeclareReservedUnused(IOHIDDevice,  4);<span></span></pre></td></tr><tr><td scope="row"><pre>    OSMetaClassDeclareReservedUnused(IOHIDDevice,  5);<span></span></pre></td></tr><tr><td scope="row"><pre>    OSMetaClassDeclareReservedUnused(IOHIDDevice,  6);<span></span></pre></td></tr><tr><td scope="row"><pre>    OSMetaClassDeclareReservedUnused(IOHIDDevice,  7);<span></span></pre></td></tr><tr><td scope="row"><pre>    OSMetaClassDeclareReservedUnused(IOHIDDevice,  8);<span></span></pre></td></tr><tr><td scope="row"><pre>    OSMetaClassDeclareReservedUnused(IOHIDDevice,  9);<span></span></pre></td></tr><tr><td scope="row"><pre>    OSMetaClassDeclareReservedUnused(IOHIDDevice, 10);<span></span></pre></td></tr><tr><td scope="row"><pre>// ...<span></span></pre></td></tr></table></div><p>In the implementation file, replace the lowest-indexed <code><!--a-->OSMetaClassDefineReservedUnused<!--/a--></code> macro with a <code><!--a-->OSMetaClassDefineReservedUsed<!--/a--></code> macro for each new virtual function. Again, for clarity’s sake, consider putting the macro immediately before the function implementation. See <span class="content_text"><a href="CPlusPlusRuntime.html#//apple_ref/doc/uid/TP30000695-BAJJECCA">Listing 1-10</a></span> for an example.</p><a name="//apple_ref/doc/uid/TP30000695-BAJJECCA" title="Listing 1-10Adjusting the pad slots when adding new virtual functions&acirc;&#128;&#148;implementation file"></a><p class="codesample"><strong>Listing 1-10&nbsp;&nbsp;</strong>Adjusting the pad slots when adding new virtual functions—implementation file</p><a name="//apple_ref/doc/uid/TP30000695-DontLinkElementID_135"></a><a name="//apple_ref/doc/uid/TP30000695-DontLinkElementID_136"></a><div class="codesample"><table><tr><td scope="row"><pre>OSMetaClassDefineReservedUsed(IOHIDDevice,  0);<span></span></pre></td></tr><tr><td scope="row"><pre>IOReturn IOHIDDevice::updateElementValues(IOHIDElementCookie *cookies,<span></span></pre></td></tr><tr><td scope="row"><pre>                                        UInt32 cookieCount) {<span></span></pre></td></tr><tr><td scope="row"><pre>    // implementation code...<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>OSMetaClassDefineReservedUsed(IOHIDDevice,  1);<span></span></pre></td></tr><tr><td scope="row"><pre>IOReturn IOHIDDevice::postElementValues(IOHIDElementCookie * cookies,<span></span></pre></td></tr><tr><td scope="row"><pre>                                        UInt32 cookieCount) {<span></span></pre></td></tr><tr><td scope="row"><pre>    // implementation code...<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>OSMetaClassDefineReservedUsed(IOHIDDevice,  2);<span></span></pre></td></tr><tr><td scope="row"><pre>OSString * IOHIDDevice::newSerialNumberString() const<span></span></pre></td></tr><tr><td scope="row"><pre>{    // implementation code ...<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre>OSMetaClassDefineReservedUnused(IOHIDDevice,  3);<span></span></pre></td></tr><tr><td scope="row"><pre>OSMetaClassDefineReservedUnused(IOHIDDevice,  4);<span></span></pre></td></tr><tr><td scope="row"><pre>OSMetaClassDefineReservedUnused(IOHIDDevice,  5);<span></span></pre></td></tr><tr><td scope="row"><pre>OSMetaClassDefineReservedUnused(IOHIDDevice,  6);<span></span></pre></td></tr><tr><td scope="row"><pre>OSMetaClassDefineReservedUnused(IOHIDDevice,  7);<span></span></pre></td></tr><tr><td scope="row"><pre>OSMetaClassDefineReservedUnused(IOHIDDevice,  8);<span></span></pre></td></tr><tr><td scope="row"><pre>OSMetaClassDefineReservedUnused(IOHIDDevice,  9);<span></span></pre></td></tr><tr><td scope="row"><pre>OSMetaClassDefineReservedUnused(IOHIDDevice, 10);<span></span></pre></td></tr><tr><td scope="row"><pre>// ...<span></span></pre></td></tr></table></div>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../Introduction/Intro.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../ContainerClasses/Libkern_Classes.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2002, 2007 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2007-03-06<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/DeviceDrivers/Conceptual/WritingDeviceDriver/CPluPlusRuntime/CPlusPlusRuntime.html%3Fid%3DTP30000694-2.13&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/DeviceDrivers/Conceptual/WritingDeviceDriver/CPluPlusRuntime/CPlusPlusRuntime.html%3Fid%3DTP30000694-2.13&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/DeviceDrivers/Conceptual/WritingDeviceDriver/CPluPlusRuntime/CPlusPlusRuntime.html%3Fid%3DTP30000694-2.13&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>