/*	File:		PlayVideo.c	Contains:	PlayVideo demonstrates the usage of the RequestVideo sample library				to make Display Manager calls. With PlayVideo, you can explore the				RequestVideo API by changing bit depth and screen resolution on				multisync displays. The purpose of this code is to provide a sample of				how developers can change the bit depth and timing of multisync				displays under their own control. Game developers should love this!								After requesting a desired bit depth, horizontal, and vertical resolutions				using the RVRequestVideoSetting() call, we then make the RVSetVideoRequest()				call to do the deed. At exit, we call RVSetVideoAsScreenPrefs() to force the				world to look like that described in the screen prefs.						It is a good idea to reset the screen(s) to the original setting before exit				since the call to RVSetVideoAsScreenPrefs() may not do the right thing under				Display Manager 1.0 with certain video drivers.	Written by: Eric Anderson		Copyright:	Copyright © 1995-1999 by Apple Computer, Inc., All Rights Reserved.				You may incorporate this Apple sample source code into your program(s) without				restriction. This Apple sample source code has been provided "AS IS" and the				responsibility for its operation is yours. You are not permitted to redistribute				this Apple sample source code as "Apple sample source code" after having made				changes. If you're going to re-distribute the source, we require that you make				it clear in the source that the code was descended from Apple sample source				code, but that you've made changes.	Change History (most recent first):				7/15/1999	Karl Groethe	Updated for Metrowerks Codewarror Pro 2.1				1/28/97		ewa				Updated source for Metrowerks CodeWarrior 11				5/31/95		ewa				Added RVGetCurrentVideoSetting and RVConfirmVideoRequest routines											to make it easy to revert back to where you came from and to give											the user a chance to confirm the new setting if the new mode was											valid (ie: the card supports it) but not safe (the monitor may not).				*/#include "RequestVideo.h"#include <Memory.h>#include <StdIO.h>#include <stdlib.h>// routine definesunsigned long GetUserInputData (void);// routine implementationsvoid main(void){	VideoRequestRec requestRec;	VideoRequestRec originalRec;	short		currentDepth;	short		currentHorizontal;	short		currentVertical;	MaxApplZone();	printf("Welcome to ¥Guess That Video¥\n");	printf("\nIMPORTANT: WARNING WHEN CHANGING THE SCREEN RESOLUTION\n");	printf("IMPORTANT:       IN A MULTI-MONITOR ENVIRONMENT\n");	printf("IMPORTANT: Monitor gravitation (repositioning) is not suported under\n");	printf("IMPORTANT: Display Manager 1.0, and there is not currently any code\n");	printf("IMPORTANT: written in this sample library to provide even minimal\n");	printf("IMPORTANT: gravitate functionality.\n");	printf("IMPORTANT: Currently, changing the video settings on\n");	printf("IMPORTANT: multi-monitor systems under the Display Manager 1.0.\n");	printf("IMPORTANT: will result in only the bit depth being changed.\n");	do	{		requestRec.screenDevice = nil;		// any screen		printf("\nRequested bit depth (999 to end the game):");		requestRec.reqBitDepth = GetUserInputData ();		// bit depth request		if (requestRec.reqBitDepth != 999)		{			// fill in the request record			printf("Requested horizontal resolution:");			requestRec.reqHorizontal = GetUserInputData ();;	// H request			printf("Requested vertical resolution:");			requestRec.reqVertical = GetUserInputData ();;		// V request			requestRec.displayMode = nil;						// must init to nil			requestRec.depthMode = nil;							// must init to nil			requestRec.requestFlags = 1<<kAllValidModesBit;						// give me the HxV over bit depth, and only safe video modes			// make the request and set it if we have one....			RVRequestVideoSetting(&requestRec);			if (requestRec.screenDevice != nil)		// make sure we found a device...possible if there are no "safe" video modes			{				// Get current setting				originalRec.screenDevice = requestRec.screenDevice;		// this screen				RVGetCurrentVideoSetting(&originalRec);								// print out the current info				currentDepth = (*(*(requestRec.screenDevice))->gdPMap)->pixelSize;				currentHorizontal = abs ((*(*(requestRec.screenDevice))->gdPMap)->bounds.right - (*(*(requestRec.screenDevice))->gdPMap)->bounds.left);				currentVertical = abs ((*(*(requestRec.screenDevice))->gdPMap)->bounds.bottom - (*(*(requestRec.screenDevice))->gdPMap)->bounds.top);				printf ("\n");				printf ("Info for GDevice at: %d\n", requestRec.screenDevice);				printf ("Original depth:%d, horizontal:%d, vertical:%d\n", currentDepth, currentHorizontal, currentVertical);				printf ("Requested depth:%d, horizontal:%d, vertical:%d\n", requestRec.reqBitDepth, requestRec.reqHorizontal, requestRec.reqVertical);				printf ("Setting depth:%d, horizontal:%d, vertical:%d\n", requestRec.availBitDepth, requestRec.availHorizontal, requestRec.availVertical);							// Set/Confirm/Reset the request				RVSetVideoRequest (&requestRec);				if (noErr != RVConfirmVideoRequest (&requestRec))					RVSetVideoRequest (&originalRec);								// print out the new info							currentDepth = (*(*(requestRec.screenDevice))->gdPMap)->pixelSize;				currentHorizontal = abs ((*(*(requestRec.screenDevice))->gdPMap)->bounds.right - (*(*(requestRec.screenDevice))->gdPMap)->bounds.left);				currentVertical = abs ((*(*(requestRec.screenDevice))->gdPMap)->bounds.bottom - (*(*(requestRec.screenDevice))->gdPMap)->bounds.top);				printf ("New depth:%d, horizontal:%d, vertical:%d\n", currentDepth, currentHorizontal, currentVertical);			}		}	} while (requestRec.reqBitDepth != 999);	// our clue to bail	printf("\nThank you for playing ¥Guess That Video¥\n");	// attempt to reset the world to screen prefs setting (may not do anything with old video drivers)	RVSetVideoAsScreenPrefs ();}// Get user input of a numberunsigned long GetUserInputData (void){	long	tempLong = 0;					do scanf ("%ld", &tempLong); while (tempLong == 0);			return (tempLong);}