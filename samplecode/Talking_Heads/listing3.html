<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>Talking Heads - /Sources/ez_adsp &Alpha;/Talking Head.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxMacOS9Earlier-date.html">Mac OS 9 & Earlier</a> &gt; <A HREF="javascript:location.replace('index.html');">Talking Heads</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/index.html" target="_blank">Reference Library</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">Talking Heads</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/Sources/ez_adsp &Alpha;/Talking Head.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/Sources/ez_adsp ƒ/ez_adsp DRVR.c</option>
<option value="listing2.html">/Sources/ez_adsp ƒ/ez_adsp.h</option>
<option value="listing3.html">/Sources/ez_adsp ƒ/Talking Head.c</option></select>
				</p>
				</form>
				<p><strong><a href="Talking_Heads.zip">Download Sample</a></strong> (&#147;Talking_Heads.zip&#148;, 15.6K)<BR>
<strong><a href="Talking_Heads.dmg">Download Sample</a></strong> (&#147;Talking_Heads.dmg&#148;, 72.8K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/* &copy; 1989 Apple Computer, by Ricardo Batista */#include &quot;ez_ADSP.h&quot;#define    open        0#define    prime        1#define    control        2#define    status        3#define    close        4#define    GetZoneList    0x8000000#define    GetMyZone    0x7000000#define    okItem        1#define    cancelItem      2#define    _dName        &quot;\p.ez_adsp&quot;#define    busyDlg        0#define    notfoundDlg      1#define    optionsDlg      2#define    listDlg        3#define    notLoadedDlg    4#define    usersDlg      5#define    boldBegin      3#define    boldEnd        4#define    bell        5#define    MaxDataSize      700#define    charW        7#define    charH        10#define   modal_bit      (1&lt;&lt;7)long signature;int ez;char buffer[600];WindowPtr myWindow;WindowRecord w;Rect bounds;int conectionFlag, oldFlag;DCtlPtr dce;cntrlParam ez_control;ioParam  io;ControlHandle sendB, optionsB, connectB, disconnectB;Rect InBox, OutBox;char InData[MaxDataSize], OutData[MaxDataSize];int InIndex[30], OutIndex[30];int InLines, OutLines;Point whereIn, whereOut;int LineIn, LineOut;int endCharIn, endCharOut;RgnHandle dummyRgn;Boolean boldIn, boldOut;long ticks;Boolean visible;Boolean reentrance;int main(ioParam* param, DCtlPtr d, int call);void MakeWindow(void);int MyRsrcID (int rsrcID);void myClose(void);int DoCommand(int menuItem);void DoEvent(cntrlParam* p);void SendFile(void);void Options(void);void Connect(Boolean skipZone);void Disconnect(void);void DoUpdate(void);void AdjustControls(void);void ChackStatus(void);Boolean GetAZone(EntityName *name);Boolean GetAddress(EntityName *name,AddrBlock *address);void CheckStatus(void);void SendName(void);void ShowErr(int dialog);void DoCursor(Boolean clear);int main(param, d, call)ioParam *param;DCtlPtr d;int call;{  int err = 0;  cntrlParam *p;    if (d-&gt;dCtlStorage == 0L) {    if (call == open) {      SysBeep(1);      return(openErr);    }    return(openErr);  }  if ((call != open) &amp;&amp; (signature != 'RICK')) {    return(notOpenErr);  }  if (reentrance)    return(noErr);  reentrance = TRUE;  dce = d;  switch (call) {    case open:      d-&gt;dCtlFlags |= dNeedLock | dNeedTime | dNeedGoodBye | dCtlEnable;      d-&gt;dCtlDelay = 15;      InitCursor();      if (signature != 'RICK') {        signature = 'RICK';        err = OpenDriver(&quot;\p.MPP&quot;,&amp;ez);        if (!err)          err = OpenDriver(_dName,&amp;ez);        if (err) {          ShowErr(notLoadedDlg);          return(err);        }        boldIn = boldOut = FALSE;        conectionFlag = 0;        oldFlag = -1;        visible = FALSE;        ticks = TickCount() + 30L;        ez_control.ioRefNum = ez;        ez_control.ioCompletion = 0L;        ez_control.ioNamePtr = 0L;        ez_control.ioVRefNum = 0;        io.ioRefNum = ez;        io.ioCompletion = 0L;        io.ioNamePtr = 0L;        io.ioVRefNum = 0;        ez_control.csCode = autoFile;        ez_control.csParam[0] = TRUE;        err = PBControl(&amp;ez_control,FALSE);        ez_control.csCode = deskFlag;        ez_control.csParam[0] = FALSE;        err = PBControl(&amp;ez_control,FALSE);        ez_control.csCode = getBuf;        err = PBStatus(&amp;ez_control,FALSE);        conectionFlag = ez_control.csParam[2];        if (conectionFlag == 4)          SysBeep(1);        MakeWindow();      }      else        SelectWindow(myWindow);      break;    case prime:      break;    case control:      p = (cntrlParam*) param;      switch (p-&gt;csCode) {        case accRun:          CheckStatus();          DoCursor(FALSE);          break;        case accEvent:          CheckStatus();          DoEvent(p);          break;        case accMenu:          DoCommand(p-&gt;csParam[1]);          break;        case goodBye:          myClose();          break;        default:          break;      }      break;    case close:      myClose();      break;    default:      break;  }  reentrance = FALSE;  return(err);  asm {    dc.l '&copy; 19'    dc.l '89 A'    dc.l 'pple'    dc.l ' Com'    dc.l 'pute'    dc.l 'r, I'    dc.l 'nc. '    dc.l 'Rica'    dc.l 'rdo '    dc.l 'Bati'    dc.l 'sta.'  }}int DoCommand (menuItem)int menuItem;{  switch (menuItem)  {    case 1:      break;    default:      break;  }}void MakeWindow(){  Rect box;  register int c, middle;  GrafPtr savePort;  WindowPeek fw;    InitCursor();  bounds.top = 40;  bounds.left = 20;  bounds.right = 350;  bounds.bottom = 310;  GetPort(&amp;savePort);  fw = (WindowPeek) FrontWindow();  if (fw) {    if ((fw-&gt;windowKind == dialogKind) &amp;&amp; (fw-&gt;spareFlag &amp; modal_bit))      fw = 0L;    else      fw = (WindowPeek) -1L;  }  else    fw = (WindowPeek) -1L;  myWindow = NewWindow(&amp;w,&amp;bounds,&quot;\pTalking Head...&quot;,1,noGrowDocProc,fw,1,0L);  SetPort(myWindow);  bounds.bottom -= bounds.top;  bounds.right -= bounds.left;  box = bounds;  box.bottom -= 6;  box.top = box.bottom - 20;  box.left = 6;  c = bounds.right / 4;  box.right = c;  sendB = NewControl(myWindow,&amp;box,&quot;\pSend File&quot;,1,0,0,1,0,0L);  box.left = box.right + 10;  box.right = c * 2;  optionsB = NewControl(myWindow,&amp;box,&quot;\pOptions&quot;,1,0,0,1,0,0L);  box.left = box.right + 10;  box.right = c * 3;  connectB = NewControl(myWindow,&amp;box,&quot;\pConnect&quot;,1,0,0,1,0,0L);  box.left = box.right + 11;  box.right = c * 4 - 1;  disconnectB = NewControl(myWindow,&amp;box,&quot;\pDisconnect&quot;,1,0,0,1,0,0L);  DrawControls(myWindow);  PenSize(1,1);  TextSize(9);  TextFont(1);  middle = bounds.bottom - 40;  MoveTo(0,middle + 6);  LineTo(bounds.right,middle + 6);  middle /= 2;  InBox.top = 10;  InBox.left = OutBox.left = 3;  InBox.right = OutBox.right = bounds.right - 3;  InBox.bottom = middle - 10;  MoveTo(0,middle);  LineTo(bounds.right,middle);  middle += 2;  OutBox.top = middle + 10;  OutBox.bottom = bounds.bottom - 30;  MoveTo(0,middle);  LineTo(bounds.right,middle);  dce-&gt;dCtlWindow = myWindow;  w.windowKind = dce-&gt;dCtlRefNum;  InIndex[0] = OutIndex[0] = 0;  InIndex[1] = OutIndex[1] = -1;  InData[0] = OutData[0] = 0;  OutLines = OutBox.bottom - OutBox.top;  OutLines /= charH;  InLines = InBox.bottom - InBox.top;  InLines /= charH;  OutLines--;  whereIn.h = whereOut.h = 3;  whereIn.v = InBox.top;  whereOut.v = OutBox.top;  LineIn = LineOut = 0;  endCharIn = endCharOut = 0;  dummyRgn = NewRgn();  SetPort(savePort);}void DoEvent (p)cntrlParam *p;{  char theChar;  long len;  ControlHandle theControl;  int part;  WindowPtr window;  Rect box;  EventRecord *myEvent, evt;  register int c;  int err;  Rect square;  Boolean commandKey;  GrafPtr savePort;    BlockMove(&amp;(p-&gt;csParam[0]),&amp;myEvent,4L);  BlockMove(myEvent,&amp;evt,(long) sizeof(EventRecord));  switch (evt.what)  {    case mouseDown:      GetPort(&amp;savePort);      SetPort(myWindow);      GlobalToLocal(&amp;evt.where);      if (FindControl(evt.where,myWindow,&amp;theControl)) {        if (TrackControl(theControl,evt.where,0L)) {          if (theControl == sendB)            SendFile();          if (theControl == optionsB)            Options();          if (theControl == connectB) {            if (evt.modifiers &amp; cmdKey)              Connect(TRUE);            else              Connect(FALSE);          }          if (theControl == disconnectB)            Disconnect();        }      }      SetPort(savePort);      break;    case keyDown:     case autoKey:      GetPort(&amp;savePort);      SetPort(myWindow);      theChar = evt.message &amp; charCodeMask;      if (evt.modifiers &amp; cmdKey)        commandKey = TRUE;      else        commandKey = FALSE;      io.ioReqCount = 1L;      io.ioBuffer = &amp;theChar;      io.ioPosMode = 0;      io.ioPosOffset = 0;      if ((theChar &gt; 14) &amp;&amp; !commandKey) {        if (visible)          DoCursor(TRUE);        if (boldOut)          TextFace(bold);        else          TextFace(0);        MoveTo(whereOut.h,whereOut.v);        DrawChar(theChar);        whereOut.h += charW;      }      if (theChar == '\b') {        if (whereOut.h &gt; 3) {          if (visible)            DoCursor(TRUE);          whereOut.h -= charW;          square.top = whereOut.v - charH + 1;          square.bottom = whereOut.v + 3;          square.left = whereOut.h;          square.right = whereOut.h + charW;          EraseRect(&amp;square);        }      }      if (theChar == '\r') {        if (visible)          DoCursor(TRUE);        whereOut.h += charW;      }      if (commandKey) {        if ((theChar == 'B') || (theChar == 'b')) {          if (boldOut) {            boldOut = FALSE;            theChar = boldEnd;          }          else {            boldOut = TRUE;            theChar = boldBegin;          }        }        if ((theChar == 'G') || (theChar == 'g'))          theChar = bell;      }      err = PBWrite(&amp;io,FALSE);      OutData[endCharOut] = theChar;      endCharOut++;      if (endCharOut == MaxDataSize)        endCharOut = 0;      if (((whereOut.h + charW) &gt; OutBox.right) || (theChar == 13)) {        whereOut.v += charH;        whereOut.h = 3;        LineOut++;        if (LineOut &gt; OutLines) {          LineOut = OutLines;          OutBox.top -= charH - 2;          OutBox.bottom -= 4;          ScrollRect(&amp;OutBox,0,-charH,dummyRgn);          OutBox.top += charH - 2;          whereOut.v -= charH;          OutBox.bottom += 4;          for (c = 0; c &lt; OutLines; c++)            OutIndex[c] = OutIndex[c + 1];        }        OutIndex[LineOut + 1] = -1;        OutIndex[LineOut] = endCharOut;      }      SetPort(savePort);      break;    case updateEvt:      DoUpdate();      break;    case activateEvt:      ez_control.csCode = deskFlag;      ez_control.csParam[0] = FALSE;      err = PBControl(&amp;ez_control,FALSE);      break;    default:      break;  }}void myClose(){  int err;    CloseWindow(myWindow);  ez_control.csCode = deskFlag;  ez_control.csParam[0] = FALSE;  err = PBControl(&amp;ez_control,FALSE);  ez_control.csCode = autoFile;  err = PBControl(&amp;ez_control,FALSE);  if (conectionFlag == 4) {    ez_control.csCode = closeConn;    err = PBControl(&amp;ez_control,FALSE);  }  dce-&gt;dCtlWindow = 0L;  dce-&gt;dCtlMenu = 0L;}void DoUpdate(){  register int middle, counter, index;  Point oldOut, oldIn;  Rect square;  GrafPtr savePort;  Rect cRect;    oldIn = whereIn;  oldOut = whereOut;  GetPort(&amp;savePort);  SetPort(myWindow);  if (visible) {    cRect.bottom = whereOut.v + 1;    cRect.left = whereOut.h;    cRect.top = cRect.bottom - 8;    cRect.right = cRect.left + 2;    InvalRect(&amp;cRect);    visible = FALSE;  }  BeginUpdate(myWindow);  EraseRect(&amp;(w.port.portRect));  DrawControls(myWindow);  PenSize(1,1);  TextSize(9);  TextFont(4);  middle = bounds.bottom - 40;  MoveTo(0,middle + 6);  LineTo(bounds.right,middle + 6);  middle /= 2;  MoveTo(0,middle);  LineTo(bounds.right,middle);  middle += 2;  MoveTo(0,middle);  LineTo(bounds.right,middle);  whereIn.h = whereOut.h = 3;  whereIn.v = InBox.top;  whereOut.v = OutBox.top;  counter = 0;  while (InIndex[counter] != -1) {    whereIn.h = 3;    index = InIndex[counter];    while ((index != endCharIn) &amp;&amp; (index != InIndex[counter + 1])) {      if (InData[index] &gt; 14) {        MoveTo(whereIn.h,whereIn.v);        DrawChar(InData[index]);        whereIn.h += charW;      }      if (InData[index] == '\b') {        if (whereIn.h &gt; 3) {          whereIn.h -= charW;          square.top = whereIn.v - charH + 1;          square.bottom = whereIn.v + 3;          square.left = whereIn.h;          square.right = whereIn.h + charW;          EraseRect(&amp;square);        }      }      if (InData[index] == boldBegin)        TextFace(bold);      if (InData[index] == boldEnd);        TextFace(0);      if (InData[index] == '\r')        whereIn.h += charW;        index++;      if (index == MaxDataSize)        index = 0;    }    whereIn.v += charH;    counter++;  }  counter = 0;  while (OutIndex[counter] != -1) {    whereOut.h = 3;    index = OutIndex[counter];    while ((index != endCharOut) &amp;&amp; (index != OutIndex[counter + 1])) {      if (OutData[index] &gt; 14) {        MoveTo(whereOut.h,whereOut.v);        DrawChar(OutData[index]);        whereOut.h += charW;      }      if (OutData[index] == '\b') {        if (whereOut.h &gt; 3) {          whereOut.h -= charW;          square.top = whereOut.v - charH + 1;          square.bottom = whereOut.v + 3;          square.left = whereOut.h;          square.right = whereOut.h + charW;          EraseRect(&amp;square);        }      }      if (OutData[index] == '\r')        whereOut.h += charW;        if (OutData[index] == boldBegin)        TextFace(bold);      if (OutData[index] == boldEnd)        TextFace(0);      index++;      if (index == MaxDataSize)        index = 0;    }    whereOut.v += charH;    counter++;  }  EndUpdate(myWindow);  SetPort(savePort);  whereOut = oldOut;  whereIn = oldIn;}int MyRsrcID (rsrcID)int     rsrcID;{  return (0xC000 | ~(dce-&gt;dCtlRefNum) &lt;&lt; 5 | rsrcID);}void SendFile(){  SFReply reply;  Point where;  Ptr p;  int err;    where.h = where.v = 100;  SFGetFile(where,&quot;\pSelect a file:&quot;,0L,-1,0L,0L,&amp;reply);  if (reply.good) {    dce-&gt;dCtlFlags -= dNeedTime;    SetCursor(*GetCursor(watchCursor));    DoUpdate();    ez_control.csCode = sendFile;    p = (Ptr) &amp;reply.fName[0];    BlockMove(&amp;p,&amp;(ez_control.csParam[0]),4L);    ez_control.csParam[2] = reply.vRefNum;    err = PBControl(&amp;ez_control,FALSE);    InitCursor();    dce-&gt;dCtlFlags |= dNeedLock | dNeedTime | dNeedGoodBye | dCtlEnable;  }}void Options(){  GrafPtr savePort;  int id, item;  DialogPtr aDialog;  DialogRecord d;  ControlHandle H, answerControl;  Rect box;  int err;    GetPort(&amp;savePort);  id = MyRsrcID(optionsDlg);  aDialog = GetNewDialog(id,&amp;d,-1L);  SetPort(aDialog);  GetDItem(aDialog,1,&amp;item,&amp;H,&amp;box);  DrawDialog(aDialog);  PenSize(3,3);  InsetRect(&amp;box,-4,-4);  FrameRoundRect(&amp;box,16,16);  PenNormal();  GetDItem(aDialog,2,&amp;item,&amp;answerControl,&amp;box);  item = 0;  while (item != 1) {    ModalDialog(0L,&amp;item);    if (item == 2) {      if (GetCtlValue(answerControl))        SetCtlValue(answerControl,0);      else        SetCtlValue(answerControl,1);    }  }  if (GetCtlValue(answerControl))    ez_control.csCode = disable;  else    ez_control.csCode = enable;  err = PBControl(&amp;ez_control,FALSE);  CloseDialog(aDialog);  SetPort(savePort);}void Connect(skipZone)Boolean skipZone;{  AddrBlock address;  EntityName name;  int err;    name.objStr[0] = 1;  name.objStr[1] = '=';  name.zoneStr[0] = 1;  name.zoneStr[1] = '*';  BlockMove(&quot;\pTalking Head&quot;,&amp;(name.typeStr[0]),14L);  if (skipZone || GetAZone(&amp;name)) {    if (GetAddress(&amp;name,&amp;address)) {      ez_control.csCode = openConn;      BlockMove(&amp;address,&amp;(ez_control.csParam[0]),(long) sizeof(AddrBlock));      err = PBControl(&amp;ez_control,FALSE);      if (err)        ShowErr(busyDlg);      else {        SendName();        SetWTitle(myWindow,name.objStr);      }    }  }}void SendName(){  StringHandle str;  int temp;  int err;    str = (StringHandle) GetString(-16096);  if (str) {    HLock(str);    BlockMove(*str,&amp;buffer[0],34L);    HUnlock(str);    ReleaseResource(str);  }  else    BlockMove(&quot;\pUnidentified&quot;,&amp;buffer[0],20L);  io.ioReqCount = 1L;  io.ioBuffer = (Ptr) &amp;&quot;\001      &quot;;  io.ioPosMode = 0;  io.ioPosOffset = 0;  err = PBWrite(&amp;io,FALSE);  temp = buffer[0];  io.ioReqCount = temp + 1;  io.ioBuffer = &amp;buffer[0];  err = PBWrite(&amp;io,FALSE);}void Disconnect(){  int err;    ez_control.csCode = closeConn;  err = PBControl(&amp;ez_control,FALSE);}void AdjustControls(){  GrafPtr savePort;    GetPort(&amp;savePort);  SetPort(myWindow);  if ((conectionFlag == 2) || (conectionFlag == 6)) {    HiliteControl(connectB,0);    HiliteControl(disconnectB,255);    HiliteControl(optionsB,0);    HiliteControl(sendB,255);    SetWTitle(myWindow,&quot;\pTalking Head...&quot;);  }  if (conectionFlag == 4) {    HiliteControl(connectB,255);    HiliteControl(disconnectB,0);    HiliteControl(optionsB,0);    HiliteControl(sendB,0);  }  SetPort(savePort);  oldFlag = conectionFlag;}void CheckStatus(){  long len = 0L;  register int c, c2;  char name[40];  int limit;  int err;  Rect square;  GrafPtr savePort;    ez_control.csCode = getBuf;  err = PBStatus(&amp;ez_control,FALSE);  BlockMove(&amp;(ez_control.csParam[0]),&amp;len,4L);  conectionFlag = ez_control.csParam[2];  GetPort(&amp;savePort);  SetPort(myWindow);  if (conectionFlag != oldFlag)    AdjustControls();  if (len) {    if (len &gt; 512)      len = 512;    io.ioActCount = 0L;    io.ioReqCount = len;    io.ioBuffer = &amp;buffer[0];    io.ioPosMode = 0;    io.ioPosOffset = 0;    err = PBRead(&amp;io,FALSE);    len = io.ioActCount;    for (c = 0; c &lt; len; c++) {      if (buffer[c] == 1) {        c++;        limit = buffer[c] + 1;        for (c2 = 0; c2 &lt; limit; c2++, c++)          name[c2] = buffer[c];        SetWTitle(myWindow,name);        if (c == len)          return;      }      if ((buffer[c] != 13) &amp;&amp; (buffer[c] != '\b')) {        if (boldIn)          TextFace(bold);        else          TextFace(0);        MoveTo(whereIn.h,whereIn.v);        DrawChar(buffer[c]);        whereIn.h += charW;      }      if (buffer[c] == '\b') {        if (whereIn.h &gt; 3) {          whereIn.h -= charW;          square.top = whereIn.v - charH + 1;          square.bottom = whereIn.v + 3;          square.left = whereIn.h;          square.right = whereIn.h + charW;          EraseRect(&amp;square);        }      }      if (buffer[c] == boldBegin)        boldIn = TRUE;      if (buffer[c] == boldEnd)        boldIn = FALSE;      if (buffer[c] == bell)        SysBeep(1);      if (buffer[c] == '\r')        whereIn.h += charW;      InData[endCharIn] = buffer[c];      endCharIn++;      if (endCharIn == MaxDataSize)        endCharIn = 0;      if (((whereIn.h + charW) &gt; InBox.right) || (buffer[c] == 13)) {        whereIn.v += charH;        whereIn.h = 3;        LineIn++;        if (LineIn &gt; InLines) {          LineIn = InLines;          whereIn.v -= charH;          InBox.top -= charH - 2;          ScrollRect(&amp;InBox,0,-charH,dummyRgn);          InBox.top += charH - 2;          for (c2 = 0; c2 &lt; InLines; c2++)            InIndex[c2] = InIndex[c2 + 1];        }        InIndex[LineIn + 1] = -1;        InIndex[LineIn] = endCharIn;      }    }  }  SetPort(savePort);}Boolean GetAZone(name)EntityName *name;{  int abridge;  DialogPtr aDialog;  Point where;  ListHandle z;  int item,node,net,howMany,zones,err;  Rect zBox,bounds;  long ourData;  Point cell;  Handle H;  Boolean done = FALSE;  unsigned char dummy[4];  register int counter,index;  char aBuf[600];  int id, datalen;  Boolean doubleClick;  DialogRecord d;  Rect box;  GrafPtr savePort;  ATPParamBlock a;  BDSElement bds;    SetCursor(*GetCursor(watchCursor));  asm {    move.l 0x2D8,a0    clr.w abridge    move.b 0x19(a0),abridge+1    move.w 0x1A(a0),net    clr.w node    move.b (a0),node+1  }  if (abridge == 0)    return(TRUE);  GetPort(&amp;savePort);  id = MyRsrcID(listDlg);  aDialog = GetNewDialog(id,&amp;d,-1L);  SetPort(aDialog);  GetDItem(aDialog,4,&amp;item,&amp;H,&amp;zBox);  DrawDialog(aDialog);  SetRect(&amp;bounds,0,0,0,0);  zBox.right -= 15;  cell.h = cell.v = 0;  z = LNew(&amp;zBox,&amp;bounds,cell,0,aDialog,TRUE,FALSE,FALSE,TRUE);  (*z)-&gt;selFlags |= lNoNilHilite + lNoRect + lNoExtend + lNoDisjoint + lOnlyOne;  zBox.top--;  zBox.left--;  zBox.right++;  zBox.bottom++;  LActivate(TRUE,z);  LAutoScroll(z);  LAddColumn(1,0,z);  FrameRect(&amp;zBox);  howMany = zones = 0;  cell.v = cell.h = 0;  ourData = 0;  a.userData = GetZoneList;  a.atpFlags = 0;  a.addrBlock.aNode = abridge;  a.addrBlock.aNet = net;  a.addrBlock.aSocket = 6;  a.reqLength = 0;  a.reqPointer = 0L;  a.ATPnumOfBuffs = 1;  a.ATPtimeOutVal = 4;  a.ATPretryCount = 3;  a.bdsPointer = (Ptr) &amp;bds;  bds.buffSize = 600;  bds.dataSize = 0;  bds.userBytes = 0L;  bds.buffPtr = (Ptr) aBuf;  aBuf[0] = 0;  ourData = 1;  FrameRect(&amp;zBox);  zones = 0;  while (!done) {    ourData |= GetZoneList;    a.userData = ourData;    err = PSendRequest(&amp;a,FALSE);    if (err) {      done = TRUE;      zones = 0;    }    BlockMove(&amp;bds.userBytes,&amp;dummy[0],4L);    BlockMove(&amp;dummy[2],&amp;howMany,2L);    zones += howMany;    ourData = zones;    if (!done) {      if (howMany)        LAddRow(howMany,zones,z);      for (counter = 0, index = 0; counter &lt; howMany; counter++) {        LSetCell(&amp;aBuf[index + 1],(int) aBuf[index],cell,z);        cell.v++;        index += aBuf[index] + 1;      }      FrameRect(&amp;zBox);    }    if (!done)      done = dummy[0];  }  if (zones) {    a.userData = GetMyZone;    err = PSendRequest(&amp;a,FALSE);    cell.v = cell.h = 0;    datalen = aBuf[0];    LSearch(&amp;aBuf[1],datalen,0L,&amp;cell,z);    LSetSelect(TRUE,cell,z);    LAutoScroll(z);  }  GetDItem(aDialog,1,&amp;item,&amp;H,&amp;box);  if (zones) {    PenSize(3,3);    InsetRect(&amp;box,-4,-4);    FrameRoundRect(&amp;box,16,16);    PenNormal();  }  else    HiliteControl(H,255);  InitCursor();  item = cell.v = 0;  while ((item != okItem) &amp;&amp; (item != cancelItem)) {    ModalDialog(0L,&amp;item);    if (item == 4) {      cell.v = 0;      GetMouse(&amp;where);      doubleClick = LClick(where,0,z);      asm {        clr.l -(sp)        ; space for cell result        move.l z,-(sp)      ; push the list handle        move.w #64,-(sp)    ; push LLastClick selector        _Pack0          ; do it        move.l (sp)+,cell    ; put in cell      }      if (doubleClick &amp;&amp; (cell.v != -1))        item = 1;    }    if ((item == 1) &amp;&amp; zones) {      cell.v = cell.h = 0;      if (!LGetSelect(TRUE,&amp;cell,z)) {        name-&gt;zoneStr[0] = 1;        name-&gt;zoneStr[1] = '*';      }      else {        datalen = 33;        LGetCell(&amp;(name-&gt;zoneStr[1]),&amp;datalen,cell,z);        name-&gt;zoneStr[0] = datalen;      }    }    else {      if (item == 1)        item = 2;    }  }  LDispose(z);  CloseDialog(aDialog);  SetPort(savePort);  if (item == 2)    return(FALSE);  return(TRUE);}Boolean GetAddress(name,address)EntityName *name;AddrBlock *address;{  MPPParamBlock p;  int id, datalen;  Rect box;  char buffer[5000];  EntityName newName;  AddrBlock newAddress;  DialogPtr aDialog;  Point where;  ListHandle z;  int item,node,net,howMany,zones,err;  Rect zBox,bounds;  Point cell;  Handle H;  register int counter,index;  Boolean doubleClick;  DialogRecord d;  GrafPtr savePort;    SetCursor(*GetCursor(watchCursor));  GetPort(&amp;savePort);  id = MyRsrcID(listDlg);  aDialog = GetNewDialog(id,&amp;d,-1L);  SetPort(aDialog);  GetDItem(aDialog,4,&amp;item,&amp;H,&amp;zBox);  GetDItem(aDialog,3,&amp;item,&amp;H,&amp;box);  SetIText(H,&quot;\pPlease select a Talking Head :&quot;);  DrawDialog(aDialog);  SetRect(&amp;bounds,0,0,0,0);  zBox.right -= 15;  cell.h = cell.v = 0;  z = LNew(&amp;zBox,&amp;bounds,cell,0,aDialog,TRUE,FALSE,FALSE,TRUE);  (*z)-&gt;selFlags = lNoNilHilite + lNoRect + lNoExtend + lNoDisjoint + lOnlyOne;  zBox.top--;  zBox.left--;  zBox.right++;  zBox.bottom++;  LActivate(TRUE,z);  LAutoScroll(z);  LAddColumn(1,0,z);  FrameRect(&amp;zBox);  index = name-&gt;objStr[0] + 1;  BlockMove(&amp;(name-&gt;typeStr[0]),&amp;(name-&gt;objStr[index]),33L);  index += name-&gt;objStr[index] + 1;  BlockMove(&amp;(name-&gt;zoneStr[0]),&amp;(name-&gt;objStr[index]),33L);  p.NBPinterval = 5;  p.NBPcount = 5;  p.NBPentityPtr = (Ptr) name;  p.NBPretBuffPtr = buffer;  p.NBPretBuffSize = 5000;  p.NBPmaxToGet = 45;  err = PLookupName(&amp;p,FALSE);  howMany = p.NBPnumGotten;  cell.v = cell.h = 0;  LAddRow(howMany,0,z);  LAddColumn(1,0,z);  for (counter = 0; counter &lt; howMany; counter++) {    myNBPExtract(&amp;buffer[0],howMany,counter + 1,&amp;newName,&amp;newAddress);    datalen = newName.objStr[0];    cell.h = 0;    LSetCell(&amp;(newName.objStr[1]),datalen,cell,z);    datalen = 4;    cell.h = 1;    LSetCell(&amp;newAddress,datalen,cell,z);    cell.v++;  }  FrameRect(&amp;zBox);  GetDItem(aDialog,1,&amp;item,&amp;H,&amp;box);  if (howMany) {    cell.v = cell.h = 0;    LSetSelect(TRUE,cell,z);    PenSize(3,3);    InsetRect(&amp;box,-4,-4);    FrameRoundRect(&amp;box,16,16);    PenNormal();  }  else {    HiliteControl(H,255);  }  InitCursor();  item = cell.v = cell.h = 0;  while ((item != 1) &amp;&amp; (item != 2)) {    ModalDialog(0L,&amp;item);    if ((item == 4) &amp;&amp; howMany) {      cell.v = 0;      GetMouse(&amp;where);      doubleClick = LClick(where,0,z);      asm {        clr.l -(sp)        ; space for cell result        move.l z,-(sp)      ; push the list handle        move.w #64,-(sp)    ; push LLastClick selector        _Pack0          ; do it        move.l (sp)+,cell    ; put in cell      }      if (cell.v &lt; 0)        cell.v = cell.h = 0;      LSetSelect(TRUE,cell,z);      if (doubleClick)        item = 1;    }    if ((item == 1) &amp;&amp; howMany) {      cell.v = cell.h = 0;      LGetSelect(TRUE,&amp;cell,z);      datalen = 33;      cell.h = 1;      LGetCell(address,&amp;datalen,cell,z);      datalen = 33;      cell.h = 0;      LGetCell(&amp;(name-&gt;objStr[1]),&amp;datalen,cell,z);      name-&gt;objStr[0] = datalen;    }    else {      if (item == 1)        item = 2;    }  }  LDispose(z);  CloseDialog(aDialog);  SetPort(savePort);  if (item == 2)    return(FALSE);  return(TRUE);}void ShowErr(dialog)int dialog;{  GrafPtr savePort;  int id, item;  DialogPtr aDialog;  DialogRecord d;  ControlHandle H;  Rect box;    GetPort(&amp;savePort);  if (dialog == notLoadedDlg)    SysBeep(1);  id = MyRsrcID(dialog);  aDialog = GetNewDialog(id,&amp;d,-1L);  SetPort(aDialog);  DrawDialog(aDialog);  GetDItem(aDialog,1,&amp;item,&amp;H,&amp;box);  InsetRect(&amp;box,-4,-4);  PenSize(3,3);  FrameRoundRect(&amp;box,16,16);  PenNormal();  item = 0;  while (item != 1)    ModalDialog(0L,&amp;item);  CloseDialog(aDialog);  SetPort(savePort);}void DoCursor(clear)Boolean clear;{  Rect cRect;  GrafPtr savePort;  Boolean erase = FALSE;    if (clear || (ticks &lt; TickCount()))    ticks = TickCount() + 30L;  else    return;  if (visible)    visible = FALSE;  else    visible = TRUE;  GetPort(&amp;savePort);  SetPort(myWindow);  cRect.bottom = whereOut.v + 1;  cRect.left = whereOut.h;  cRect.top = cRect.bottom - 8;  cRect.right = cRect.left + 2;  InvertRect(&amp;cRect);  SetPort(savePort);}/*  This function extracts names and addresses out of a buffer filled by NBP*/int myNBPExtract(buffer,howMany,which,Name,Addr)char *buffer;int howMany;int which;EntityName *Name;AddrBlock *Addr;{  char *p;  register int index = 1, nameCounter = 0;    p = buffer;  while ((index &lt; which) &amp;&amp; (index &lt; howMany)) {    p += 5;  /* skip addr and enumerator */    p += (*p) + 1;  /* skip name */    p += (*p) + 1;  /* skip type */    p += (*p) + 1;  /* skip zone */    index++;  }  BlockMove(p,Addr,4L);  p += 5;  BlockMove(p,Name-&gt;objStr,33L);  p += (*p) + 1;  BlockMove(p,Name-&gt;typeStr,33L);  p += (*p) + 1;  BlockMove(p,Name-&gt;zoneStr,33L);  return(0);}</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/Talking_Heads/listing3.html%3Fid%3DDTS10000261-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/Talking_Heads/listing3.html%3Fid%3DDTS10000261-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/Talking_Heads/listing3.html%3Fid%3DDTS10000261-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>