<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>I/O Kit Device Driver Design Guidelines: Debugging Drivers</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Debugging Drivers"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP30000701" title="Debugging Drivers"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../../HardwareDrivers/index.html#//apple_ref/doc/uid/TP30000440-TP40003576" target="_top">Hardware &amp; Drivers</a> &gt; <a href="../Introduction/Intro.html#//apple_ref/doc/uid/TP40002799-TPXREF101">I/O Kit Device Driver Design Guidelines</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../InternationalizingDrivers/InternationalizingDrivers.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../DeployingDrivers/DeployingDrivers.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP30000701-BBCFBJJI" title="Debugging Drivers"></a><h1>Debugging Drivers</h1><p>The hardest part of debugging code—especially kernel code—is not learning how to use the tools but how to analyze the data generated by the tools. The success you have with your analysis depends to a large degree on the skills and experience you bring to it, and these can always be enhanced by learning from others who have “earned their stripes” debugging kernel code.</p><p>This chapter offers a collection of driver-debugging tips and techniques from Apple engineers. It starts by listing a few general suggestions for driver debugging and itemizing the tools at your disposal. It then discusses these general areas of driver debugging:</p><ul class="ul"><li class="li"><p>Debugging drivers during the matching and loading stages</p></li><li class="li"><p>Two-machine debugging, including the set-up procedure, the kernel debugging macros, and debugging panics and hangs</p></li><li class="li"><p>Logging, including custom event logging</p></li></ul><div class="notebox"><a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_14" title="Note"></a><p><strong>Note:</strong>&nbsp;For information on debugging a universal binary version of a device driver running on an Intel-based Macintosh, see <span class="content_text"><a href="../UBDeviceDriver/UBDeviceDriver.html#//apple_ref/doc/uid/TP40002800-SW2">“Debugging on an Intel-Based Macintosh.”</a></span></p></div>
<!-- This template is being used for both PDF and HTML. -->

    
    <h4>In this section:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="DebuggingDrivers.html#//apple_ref/doc/uid/TP30000701-TPXREF101">Some Debugging Basics</a>
				
			<br/>
			
        
			
			
				<a href="DebuggingDrivers.html#//apple_ref/doc/uid/TP30000701-TPXREF104">Debugging Matching and Loading Problems</a>
				
			<br/>
			
        
			
			
				<a href="DebuggingDrivers.html#//apple_ref/doc/uid/TP30000701-CJBHCEGD">Two-Machine Debugging</a>
				
			<br/>
			
        
			
			
				<a href="DebuggingDrivers.html#//apple_ref/doc/uid/TP30000701-TPXREF112">Logging</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP30000701-TPXREF101" title="Some Debugging Basics"></a><h2>Some Debugging Basics</h2><p>Before delving into the nitty-gritty of driver debugging, it might be worth your while to consider a few general debugging tips and to survey the debugging tools available to you.</p><a name="//apple_ref/doc/uid/TP30000701-TPXREF102" title="General Tips"></a><h3>General Tips</h3><p>To<a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_170"></a><a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_171"></a> help you get started, here are a few debugging tips based on the experiences of Apple kernel engineers.</p><ul class="spaceabove"><li class="li"><p>Develop in incremental steps. In other words, don’t write a big chunk of driver code before debugging it. And at each stage verify that the driver can unload as well as load; a driver that can’t unload suggests a memory leak (most likely caused by a missing <code><!--a-->release<!--/a--></code> somewhere).</p><p>As a suggestion, get driver matching and the basic driver life-cycle methods working first (especially <code>start</code>). Then begin talking with your hardware. Once you’re sure that’s working properly, then write the code that talks with the rest of the system.</p></li><li class="li"><p>Keep earlier versions of your code. If bugs start to appear in your code, you can “diff” the current version with the prior version to locate exactly which code is new (and thus the probable source of the problem).</p></li><li class="li"><p>Obtain the source code for all other parts of the kernel that your driver interacts with or depends on (directly or indirectly). Things go much easier when you have full source-level debugging.</p></li><li class="li"><p>Obtain symbols for each kernel extension that might affect, or be affected by, your driver. This would include your driver’s provider and its clients. For the full gamut of symbols, obtain a symboled kernel. In particular, a symboled kernel is required to use the kernel debugging macros (described in <span class="content_text"><a href="DebuggingDrivers.html#//apple_ref/doc/uid/TP30000701-CJBJIAHA">“Using the Kernel Debugging Macros”</a></span>).</p><p>See <span class="content_text"><a href="DebuggingDrivers.html#//apple_ref/doc/uid/TP30000701-BAJCBEIJ">“Setting Up for Two-Machine Debugging”</a></span> for instructions on generating symbol files for kernel extensions. To obtain a symboled kernel, you might have to build the Darwin kernel from the open source. See <span class="content_text"><a href="../../../../Darwin/Conceptual/KernelProgramming/build/build.html#//apple_ref/doc/uid/TP30000905-CH221" target="_top">Building and Debugging Kernels</a></span> in <em><a href="../../../../Darwin/Conceptual/KernelProgramming/index.html#//apple_ref/doc/uid/TP30000905" target="_top">Kernel Programming Guide</a></em> for details.</p></li><li class="li"><p>Learn <code>gdb</code> thoroughly. Start by reading <em><a href="../../../../DeveloperTools/gdb/gdb/gdb_toc.html#//apple_ref/doc/uid/TP40000996" target="_top">Debugging with GDB</a></em>, provided as part of <span class="content_text"><a href="../../../../DeveloperTools/index.html#//apple_ref/doc/uid/TP30000436" target="_top">Tools Documentation</a></span>.</p></li><li class="li"><p>Become familiar with how computer instructions look in assembler (see <span class="content_text"><a href="DebuggingDrivers.html#//apple_ref/doc/uid/TP30000701-BAJDCIAI">“Examining Computer Instructions”</a></span>).</p></li><li class="li"><p>Every now and then, single-step through every line of code to make sure your driver’s doing exactly what you want it to.</p></li><li class="li"><p>Don’t overly rely on calls to <code>IOLog</code> to provide you with debugging information (see <span class="content_text"><a href="DebuggingDrivers.html#//apple_ref/doc/uid/TP30000701-BAJHHHDA">“Using IOLog”</a></span>).</p></li><li class="li"><p>Make sure your KEXT includes only header files from <code>Kernel.framework</code>, in addition to the header files you define. If you include other headers, although their definitions may be in scope at compile time, the functions and services they define will not be available in the kernel environment.</p></li></ul><a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_1" title="Issues With 64-Bit Architectures"></a><h3>Issues With 64-Bit Architectures</h3><p><a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_172"></a>In Mac OS X version 10.3, Apple introduced some changes to support the new 64-bit architectures. Because the changes are implemented in the operating system itself, some drivers may be affected even if they aren’t running on a 64-bit computer. To better explain these changes, this section first provides a brief description of PCI address translation.</p><p><a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_173"></a>Hardware devices on the PCI bus can handle 32-bit addresses, which means that a PCI device has a 4-gigabyte window into main memory. When a PCI device performs a data transaction to or from main memory, the device driver prepares this memory for I/O. On systems where both the memory subsystem and the PCI device drivers use 32-bit addressing, there are no difficulties. On systems where the memory subsystem uses 64-bit addressing, however, a PCI device can see only four gigabytes of main memory at a time. To address this issue, Apple chose to implement address translation. In this scheme, blocks of memory are mapped into the 32-bit address space of PCI devices. The PCI device still has a 4-gigabyte window into main memory, but that window may contain noncontiguous blocks of main memory. The address translation is performed by a part of the memory controller called the DART (device address resolution table<a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_174"></a><a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_175"></a>). The DART keeps a table of translations to use when mapping between the physical addresses the processor sees and the addresses the PCI device sees (called I/O addresses).</p><p>If your driver adheres to documented, Apple-provided APIs, this address-translation process is transparent. For example, when your driver calls IOMemoryDescriptor’s <code>prepare</code> method, a mapping is automatically placed in the DART. Conversely, when your driver calls IOMemoryDescriptor’s <code>release</code> method, the mapping is removed. Although this has always been the recommended procedure, failure to do so may not have resulted in undesirable behavior in previous versions of Mac OS X. Beginning in Mac OS X version 10.3, however, failure to follow this procedure may result in random data corruption or panics.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_15" title="Note"></a><p><strong>Note:</strong>&nbsp;Be aware that the <code>release</code> method does not take the place of the IOMemoryDescriptor <code>complete</code> method. As always, every invocation of <code>prepare</code> must be balanced with an invocation of <code>complete</code>.</p></div><p>If your driver experiences difficulty on a Mac OS X version 10.3 or later system, you should check that you are following these guidelines:</p><ul class="spaceabove"><li class="li"><p>Always call <code>IOMemoryDescriptor::prepare</code> to prepare the physical memory for the I/O transfer (in Mac OS X version 10.3 and later, this also places a mapping into the DART).</p></li><li class="li"><p>Balance each call to <code>prepare</code> with a call to <code>complete</code> to unwire the memory.</p></li><li class="li"><p>Always call <code>IOMemoryDescriptor::release</code> to remove the mapping from the DART.</p></li><li class="li"><p>On hardware that includes a DART, pay attention to the DMA direction for reads and writes. On a 64-bit system, a driver that attempts to write to a memory region whose DMA direction is set up for reading will cause a kernel panic.</p></li></ul><p>A<a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_176"></a> side effect of the changes in the memory subsystem is that Mac OS X is much more likely to return physically contiguous page ranges in memory regions. In earlier versions of Mac OS X, the system returned multi-page memory regions in reverse order, beginning with the last page and going on towards the first page. Because of this, a multi-page memory region seldom contained a physically contiguous range of pages.</p><p>The greatly increased likelihood of seeing physically contiguous page ranges in memory regions might expose latent bugs in drivers that previously did not have to handle physically contiguous pages. If your driver is behaving incorrectly or panicking, be sure to investigate this possibility.</p><p>Another result of the memory-subsystem changes concerns the physical addresses some drivers obtain directly from the pmap layer. <a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_177"></a>Because there is not a one-to-one correspondence between physical addresses and I/O addresses, physical addresses obtained from the pmap layer have no purpose outside the virtual memory system itself. Drivers that use pmap calls to get such addresses (such as <code><!--a-->pmap_extract<!--/a--></code>) will fail to function on systems with a DART. To prevent the use of these calls, Mac OS X version 10.3 will refuse to load a kernel extension that uses them, even on systems without a DART<a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_178"></a>.<a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_179"></a></p><a name="//apple_ref/doc/uid/TP30000701-TPXREF103" title="Driver-Debugging Tools"></a><h3>Driver-Debugging Tools</h3><p><a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_180"></a><a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_181"></a>Apple provides a number of tools that you can use to debug I/O Kit device drivers. <span class="content_text"><a href="DebuggingDrivers.html#//apple_ref/doc/uid/TP30000701-CJBHCGDB">Table 7-1</a></span> presents some of the more important tools.</p><a name="//apple_ref/doc/uid/TP30000701-CJBHCGDB" title="Table 7-1Debugging aids for kernel extensions"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 7-1&nbsp;&nbsp;</strong>Debugging aids for kernel extensions</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Tool or API</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Description</p></th></tr><tr><td  scope="row"><p><code>gdb<a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_182"></a></code></p></td><td ><p>The GNU debugger<a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_183"></a>, used in two-machine kernel debugging. See <span class="content_text"><a href="DebuggingDrivers.html#//apple_ref/doc/uid/TP30000701-BAJFCFHD">“Tips on Using gdb”</a></span> for some useful information on <code>gdb</code>.</p></td></tr><tr><td  scope="row"><p>Kernel debugging macros</p></td><td ><p>Powerful macros designed for use in <code>gdb</code> while debugging the Darwin kernel. The macros are contained in the file <code>.gdbinit</code> in the Open Source directory location <code>/xnu/osfmk/</code>. See <span class="content_text"><a href="DebuggingDrivers.html#//apple_ref/doc/uid/TP30000701-CJBJIAHA">“Using the Kernel Debugging Macros”</a></span> for more information.</p></td></tr><tr><td  scope="row"><p><code>kextload<a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_184"></a></code></p></td><td ><p>A utility that does a variety of things with kernel extensions. It loads kernel extensions and, prior to loading, validates the extensions, providing diagnostic information related to file-permission and dependency errors. It also enables the debugging of kernel extensions (using <code>gdb</code>) during the matching and loading phases. See <span class="content_text"><a href="DebuggingDrivers.html#//apple_ref/doc/uid/TP30000701-BAJEGGID">“Loading Your Driver”</a></span> for more on <code>kextload</code> options.</p></td></tr><tr><td  scope="row"><p><code>kextstat</code><a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_185"></a></p></td><td ><p>A utility that prints columns of information about the kernel extensions that are currently loaded in a system. The information most useful to driver debugging is the driver’s load address, references held by the driver to other kernel extensions, the number of references other extensions have to it, and the version of a kernel extension. See <span class="content_text"><a href="DebuggingDrivers.html#//apple_ref/doc/uid/TP30000701-BAJCGDED">“Unloading Your Driver”</a></span> for more information.</p></td></tr><tr><td  scope="row"><p><code>ioreg</code></p></td><td ><p>Provides a snapshot of the I/O Registry, showing the hierarchical structure of client–provider relationships among current drivers and nubs in the system. With the necessary options, it shows the properties associated with each node in the registry. The I/O Registry Explorer shows the same information in a GUI interface. Both tool and application are particularly useful for debugging problems with matching. See <span class="content_text"><a href="DebuggingDrivers.html#//apple_ref/doc/uid/TP30000701-BJEGEEDF">“Debugging Matching Problems.”</a></span></p></td></tr><tr><td  scope="row"><p><code>ioalloccount</code> <code>ioclasscount</code></p></td><td ><p>The former tool displays a summary of memory allocation by allocator type (instance, container, and <code><!--a-->IOMalloc<!--/a--></code>). The latter tool shows the number of instances allocated for each specified class. Both tools are useful for tracking down memory leaks. See <span class="content_text"><a href="DebuggingDrivers.html#//apple_ref/doc/uid/TP30000701-BAJCGDED">“Unloading Your Driver”</a></span> for more information.</p></td></tr><tr><td  scope="row"><p><code>IOKitDebug.h</code></p></td><td ><p>Defines a set of values for the IOKitDebug property. When this property is defined, the system writes the status of various driver events, such as attaching, matching, and probing, to the system log. See <span class="content_text"><a href="DebuggingDrivers.html#//apple_ref/doc/uid/TP30000701-BJEGEEDF">“Debugging Matching Problems”</a></span> for further information.<a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_186"></a><a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_187"></a></p></td></tr></table></div><a name="//apple_ref/doc/uid/TP30000701-TPXREF104" title="Debugging Matching and Loading Problems"></a><h2>Debugging Matching and Loading Problems</h2><p>Before you begin debugging your driver’s hardware-specific functionality, you should first ensure that your KEXT is valid and that it loads, unloads, and matches properly. This section describes how to use Mac OS X tools, such as <code>kextload</code> and <code>kextstat</code>, to authenticate and validate your KEXT, resolve its dependencies, and test its matching.</p><a name="//apple_ref/doc/uid/TP30000701-TPXREF113" title="Driver Dependencies"></a><h3>Driver Dependencies</h3><p>Every driver<a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_188"></a> declares its dependencies on other loadable kernel extensions (such as an I/O Kit family), kernel subcomponents (such as <code>com.apple.kernel.iokit</code>), or KPIs (such as <code>com.apple.kpi.libkern</code>) in its<code> Info.plist</code> file. At the top level of the <code>Info.plist</code> file, a driver lists each dependency in the form of a key-value pair in the <code>OSBundleLibraries</code> dictionary; the key is the KEXT or kernel subcomponent name and the value is the KEXT’s or subcomponent’s version number.</p><p>In Mac OS X v10.2, declaring a dependency on the I/O Kit kernel subcomponent <code>com.apple.kernel.iokit</code> (version 6.x) implicitly allows your driver to access symbols in two other kernel subcomponents: <code>com.apple.kernel.mach</code> and <code>com.apple.kernel.bsd</code>. </p><p>In Mac OS X v10.3, a driver that declares a dependency on <code>com.apple.kernel.iokit</code> version 6.x (the 10.2 version) will still enjoy automatic access to Mach and BSD symbols. </p><div class="importantbox"><a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_16" title="Important:"></a><p><strong>Important:</strong>&nbsp;A driver that declares a dependency on version 7 of <code>com.apple.kernel.iokit</code> (the 10.3 version) will <em>not</em> have automatic access to Mach and BSD symbols. If a driver requires access to those symbols, it must explicitly declare dependencies on <code>com.apple.kernel.mach</code> and <code>com.apple.kernel.bsd</code>.</p><p></p></div><p>In Mac OS X v10.4, Apple introduced sustainable kernel programming interfaces, or KPIs. In particular, the KPIs support the development of NKEs (network kernel extensions), file-system KEXTs, and other non-I/O Kit KEXTs. KPIs are also recommended for pure I/O Kit KEXTs (KEXTs that use only I/O Kit-provided APIs) that target Mac OS X v10.4 and later. Be aware, however, that no KEXT can declare dependencies on a combination of both kernel subcomponents and KPIs. To learn more about KPIs, see <em><a href="../../../../Darwin/Reference/KPI_Reference/index.html#//apple_ref/doc/uid/TP40001274" target="_top">KPI Reference</a></em>; to find out how to declare dependencies on them, see <span class="content_text"><a href="../../../../Darwin/Conceptual/KEXTConcept/KEXTConceptDependencies/kext_dependencies.html#//apple_ref/doc/uid/20002370" target="_top">Kernel Extension Dependencies</a></span>.</p><a name="//apple_ref/doc/uid/TP30000701-BAJEDDDH" title="Using kextload,  kextunload, and  kextstat"></a><h3>Using kextload,  kextunload, and  kextstat</h3><p><a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_189"></a>During the development process, it’s a good idea to load and unload your driver regularly to catch problems in these processes before they become very difficult to find. The <code>kextload</code> tool allows you to load your driver at the command line and performs a wide range of authentication and validation tests. <code>kextload</code> also allows you to debug your driver’s <code>start</code> and <code>probe</code> routines before matching begins. The <code>kextunload</code> tool terminates and unregisters the I/O Kit objects associated with your KEXT and unloads the code and personalities for that KEXT. For complete information on <code>kextload</code>, <code>kextunload</code>, and <code>kextstat</code>, view the <code>man</code> pages for these tools in a Terminal window.</p><p>You can use <code>kextload</code> to load and start your KEXT with or without starting I/O Kit matching, but <code>kextload</code> provides no information about the matching process itself. If your driver isn’t matching properly, see <span class="content_text"><a href="DebuggingDrivers.html#//apple_ref/doc/uid/TP30000701-BJEGEEDF">“Debugging Matching Problems”</a></span> for more information.</p><a name="//apple_ref/doc/uid/TP30000701-BAJEGGID" title="Loading Your Driver"></a><h4>Loading Your Driver</h4><p><a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_190"></a>The <code>kextload</code> tool checks your driver’s <code>Info.plist</code> file thoroughly before it attempts to load your driver into the kernel. If required properties are missing or incorrectly identified, if your declared dependencies are missing or incompatible, or if your driver has the wrong permissions or ownership, <code>kextload</code> refuses to load your KEXT. To find out why your KEXT doesn’t load, run <code>kextload</code> with the <code>-t</code> or the<code> -tn</code> option. This tells <code>kextload</code> to perform all its tests on your KEXT and provide you with a dictionary of the errors it finds (the addition of the <code>-n</code> option prevents <code>kextload</code> from loading the KEXT even if it finds no errors). For example, <span class="content_text"><a href="DebuggingDrivers.html#//apple_ref/doc/uid/TP30000701-CHDECECJ">Listing 7-1</a></span> shows the <code>Info.plist</code> of a KEXT named BadKEXT, that contains three errors.</p><a name="//apple_ref/doc/uid/TP30000701-CHDECECJ" title="Listing 7-1Example Info.plist containing errors"></a><p class="codesample"><strong>Listing 7-1&nbsp;&nbsp;</strong>Example <code>Info.plist</code> containing errors</p><div class="codesample"><table><tr><td scope="row"><pre>&lt;key>IOKitPersonalities&lt;/key><span></span></pre></td></tr><tr><td scope="row"><pre>&lt;dict><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;key>BadKEXT&lt;/key><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;dict><span></span></pre></td></tr><tr><td scope="row"><pre>        &lt;key>CFBundleIdentifier&lt;/key><span></span></pre></td></tr><tr><td scope="row"><pre>        &lt;string>com.MySoftwareCompany.driver.BadKEXT&lt;/string><span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        &lt;key>IOClass>&lt;/key><span></span></pre></td></tr><tr><td scope="row"><pre>        &lt;string>com_MySoftwareCompany_driver_BadKEXT&lt;/string><span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        &lt;!-- No floating point numbers are allowed in the kernel. --><span></span></pre></td></tr><tr><td scope="row"><pre>        &lt;key>IOKitDebug&lt;/key><span></span></pre></td></tr><tr><td scope="row"><pre>        &lt;number>0.0&lt;/number><span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        &lt;key>IOMatchCategory&lt;/key><span></span></pre></td></tr><tr><td scope="row"><pre>        &lt;string>com_MySoftwareCompany_driver_BadKEXT&lt;/string><span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        &lt;key>IOResourceMatch&lt;/key><span></span></pre></td></tr><tr><td scope="row"><pre>        &lt;string>IOKit&lt;/string><span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        &lt;!-- The personality is missing its IOProviderClass key-value pair. --><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;/dict><span></span></pre></td></tr><tr><td scope="row"><pre>&lt;/dict><span></span></pre></td></tr><tr><td scope="row"><pre>&lt;key>Libraries&lt;/key><span></span></pre></td></tr><tr><td scope="row"><pre>&lt;dict><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;key>com.apple.kernel.iokit&lt;/key><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;string>1.1&lt;/string><span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;!-- com.apple.kernel.libkern is misspelled. --><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;key>com.apple.kernel.libker&lt;/key><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;string>1.1&lt;/string><span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;key>com.apple.kernel.mach&lt;/key><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;string>1.1&lt;/string><span></span></pre></td></tr><tr><td scope="row"><pre>&lt;/dict><span></span></pre></td></tr></table></div><p>In addition, BadKEXT has ownership<a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_191"></a> and permissions problems: It is owned by the user <code>user_name</code> and the group <code>staff</code> and its folders have permissions <code>rwxrwxr-x</code> (775 octal). For reasons of security, KEXTs must be owned by the root user and the wheel group. Further, no component of a KEXT may be writable by any user other than root. (For more information on the correct permissions and ownership of KEXTs, see <span class="content_text"><a href="../DeployingDrivers/DeployingDrivers.html#//apple_ref/doc/uid/TP30000702-BCIEEHFG">“Testing and Deploying Drivers”</a></span>). Assuming root privileges by using the <code>sudo</code> command and running <code>kextload -t</code> on BadKEXT provides the following information, shown in <span class="content_text"><a href="DebuggingDrivers.html#//apple_ref/doc/uid/TP30000701-CHDHCABJ">Listing 7-2</a></span>.</p><a name="//apple_ref/doc/uid/TP30000701-CHDHCABJ" title="Listing 7-2kextload -t outputs errors found in KEXT"></a><p class="codesample"><strong>Listing 7-2&nbsp;&nbsp;</strong><code>kextload -t</code> outputs errors found in KEXT</p><div class="codesample"><table><tr><td scope="row"><pre>[computer_name:] user_name% sudo kextload -t BadKEXT.kext<span></span></pre></td></tr><tr><td scope="row"><pre>Password:<span></span></pre></td></tr><tr><td scope="row"><pre>can't add kernel extension BadKEXT.kext (validation error) (run kextload<span></span></pre></td></tr><tr><td scope="row"><pre>                            on this kext with -t for diagnostic output)<span></span></pre></td></tr><tr><td scope="row"><pre>kernel extension BadKEXT.kext has problems:<span></span></pre></td></tr><tr><td scope="row"><pre>Validation failures<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    "Info dictionary missing required property/value" = {<span></span></pre></td></tr><tr><td scope="row"><pre>        "IOKitPersonalities:BadKEXT:IOProviderClass"<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    "Info dictionary property value is of illegal type" = {<span></span></pre></td></tr><tr><td scope="row"><pre>        "IOKitPersonalities:BadKEXT:IOKitDebug"<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre>Authentication failures<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    "File owner/permissions are incorrect" = {<span></span></pre></td></tr><tr><td scope="row"><pre>    "/Users/user_name/Projects/BadKEXT/build/BadKEXT.kext"<span></span></pre></td></tr><tr><td scope="row"><pre>    "/Users/user_name/Projects/BadKext/build/BadKEXT.kext/Contents/Info.plist"<span></span></pre></td></tr><tr><td scope="row"><pre>    "/Users/user_name/Projects/BadKext/build/BadKEXT.kext/Contents"<span></span></pre></td></tr><tr><td scope="row"><pre>    "/Users/user_name/Projects/BadKext/build/BadKEXT.kext/Contents/MacOS/BadKEXT"<span></span></pre></td></tr><tr><td scope="row"><pre>        "/Users/user_name/Projects/BadKext/build/BadKEXT.kext/Contents/MacOS"<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre>Missing dependencies<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    "com.apple.kernel.libker" =<span></span></pre></td></tr><tr><td scope="row"><pre>        "No valid version of this dependency can be found"<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p><a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_192"></a>The checks <code>kextload</code> performs are listed below.<a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_193"></a></p><ul class="spaceabove"><li class="li"><p><code>Info.plist</code> dictionary must be present and must be of type <code>dictionary</code>.</p></li><li class="li"><p><code>CFBundleIdentifier</code> property must be of type <code>string</code> and no longer than 63 characters.</p></li><li class="li"><p><code>CFBundleVersion</code> property must be a proper “vers” style <code>string</code>.</p></li><li class="li"><p>If the optional <code>OSBundleCompatibleVersion</code> property is present, it must be a proper “vers” style string with a value less than or equal to the <code>CFBundleVersion</code> value.</p></li><li class="li"><p><code>CFBundleExecutable</code> must be of type <code>string</code>.</p></li><li class="li"><p>If the <code>IOKitPersonalities</code> property is present (the <code>IOKitPersonalities</code> property is required for driver matching but isn’t required for the KEXT to be valid), all its values must be of type <code>dictionary</code>. <code>kextload</code> performs the following checks on the personalities.</p><ul class="nested"><li class="nested li"><p><code>IOClass</code> property must be of type <code>string</code>.</p></li><li class="nested li"><p><code>IOProviderClass</code> property must be of type <code>string</code>.</p></li><li class="nested li"><p><code>CFBundleIdentifier</code> must be of type <code>string</code>.</p></li><li class="nested li"><p><code>IOKitDebug</code> property, if present, must be of type <code>integer</code> (and <em>not</em> a floating-point number).</p></li><li class="nested li"><p>All property types must be valid for in-kernel use; for example, the <code>date</code> type is not allowed in the kernel.</p></li></ul></li><li class="li"><p><code>OSBundleLibraries</code> must be present and be of type <code>dict</code>. The <code>OSBundleLibraries</code> values must exist and have valid versions.</p></li><li class="li"><p>If all personalities have the <code>IOKitDebug</code> property set to a nonzero value, <code>kextload</code> marks the KEXT an ineligible for safe boot, even if the <code>OSBundleRequired</code> property is present and valid.</p></li></ul><p>If the <code>-t</code> option doesn’t provide you with enough information, you can tell <code>kextload</code> to give you a step-by-step account of its actions by using the <code>-v</code> option followed by a number from 1 to 6 indicating how much information you want. In this way, you can see at what point <code>kextload</code> fails.<a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_194"></a><a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_195"></a></p><a name="//apple_ref/doc/uid/TP30000701-BAJCGDED" title="Unloading Your Driver"></a><h4>Unloading Your Driver</h4><p>The <code>kextunload</code><a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_196"></a> tool simply tries to unload your driver’s code and personalities, terminating and unregistering all I/O Kit objects associated with your driver. Unfortunately, <code>kextunload</code> provides very little information about why your driver might fail to unload. It’s possible that the system log (which you can view at <code>/var/log/system.log</code>) will display some information about a failure to unload, but you’ll get the most useful information using the other methods and tools described in this section. </p><p><a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_197"></a>A driver that has a mismatched <code>retain</code> or <code>release</code>, one that is depended on by other kernel modules, or one that has a failing <code>stop</code> method will fail to unload. Whatever the cause, if your driver fails to unload, the debugging process becomes arduous because you are forced to restart the computer each time you need to load and unload your KEXT. </p><p>In general, you should make only incremental changes in your driver’s code, checking its ability to load and unload after every change, to narrow down the possible culprits if your driver suddenly refuses to unload. In this way, you can revert to a previous, unloadable version of your driver and examine the changes you’ve made to it.</p><p>You can determine if your driver cannot unload because another module is depending on it by using the <code>kextstat</code><a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_198"></a> tool to display information about all currently loaded KEXTs. <span class="content_text"><a href="DebuggingDrivers.html#//apple_ref/doc/uid/TP30000701-BJEJIGFD">Listing 7-3</a></span> shows a few lines of the output from <code>kextstat</code>.</p><a name="//apple_ref/doc/uid/TP30000701-BJEJIGFD" title="Listing 7-3Partial listing of kextstat output"></a><p class="codesample"><strong>Listing 7-3&nbsp;&nbsp;</strong>Partial listing of <code>kextstat</code> output</p><div class="codesample"><table><tr><td scope="row"><pre>Index Refs Address  Size    Wired Name          (Version) &lt;Linked Against><span></span></pre></td></tr><tr><td scope="row"><pre> 1   1   0x0        0x0     0x0  com.apple.kernel (6.0)<span></span></pre></td></tr><tr><td scope="row"><pre> 2   8   0x0        0x0     0x0  com.apple.kernel.bsd (6.0)<span></span></pre></td></tr><tr><td scope="row"><pre> 3  33   0x0        0x0     0x0  com.apple.kernel.iokit (6.0)<span></span></pre></td></tr><tr><td scope="row"><pre> 4  32   0x0        0x0     0x0  com.apple.kernel.libkern (6.0)<span></span></pre></td></tr><tr><td scope="row"><pre>// Some lines not shown...<span></span></pre></td></tr><tr><td scope="row"><pre>11   7   0xaadd000  0x9000  0x8000 com.apple.iokit.IOPCIFamily (1.2) &lt;4 3><span></span></pre></td></tr><tr><td scope="row"><pre>// Some lines not shown...<span></span></pre></td></tr><tr><td scope="row"><pre>26   6   0xb14c000  0x1a000 0x19000 com.apple.iokit.IOUSBFamily (1.2) &lt;4 3 2><span></span></pre></td></tr><tr><td scope="row"><pre>// Some lines not shown...<span></span></pre></td></tr></table></div><p>The first column of the <code>kextstat</code> output is the load index of the KEXT. <code>kextstat</code> uses this index in the last column to show which KEXTs a particular KEXT is linked against. For example, the IOPCIFamily KEXT, index 11 in <span class="content_text"><a href="DebuggingDrivers.html#//apple_ref/doc/uid/TP30000701-BJEJIGFD">Listing 7-3</a></span>, depends on both <code>com.apple.kernel.iokit</code> (index 3) and <code>com.apple.kernel.libkern</code> (index 4). </p><p>The second column is the sum of all the references to the selected KEXT by other currently loaded KEXTs. Check this column if your driver fails to unload: If its number of references is nonzero, <code>kextunload</code> cannot unload it.</p><p>If there are no other KEXTs depending on your driver yet it fails to unload, the problem is often a mismatched <code>retain</code> or <code>release</code> on an object instantiated from one of your classes. If you have multiple classes defined in your KEXT, you can use <code>ioclasscount</code><a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_199"></a> to find out which class has outstanding instances. In a Terminal window, type</p><div class="codesample"><table><tr><td scope="row"><pre>ioclasscount MyClassName<span></span></pre></td></tr></table></div><p>The <code>ioclasscount</code> tool outputs the instance count of the specified object, offset by the number of direct subclasses that have at least one instance allocated. With this information, you then go through your driver’s code looking for a <code>retain</code> on your object that’s not balanced with a <code>release</code>. A mismatched <code>retain</code> can be difficult to find because often it is not explicitly in your code, but in a container class you’ve put your object into, in a method you’ve called, or in a still-running user application that holds an <code>io_object_t</code> reference on the object. For example, calling</p><div class="codesample"><table><tr><td scope="row"><pre>addEventSource ( My_Event_Source_Object )<span></span></pre></td></tr></table></div><p>implicitly places a retain on My_Event_Source_Object that remains until you call<a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_200"></a></p><div class="codesample"><table><tr><td scope="row"><pre>removeEventSource ( My_Event_Source_Object )<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP30000701-TPXREF105" title="Debugging Your Driver&acirc;&#128;&#153;s  start and  probe Methods"></a><h4>Debugging Your Driver’s  start and  probe Methods</h4><p><a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_201"></a>When you’ve determined that your KEXT can load and unload successfully, you may want to debug your driver’s <code>start</code> and <code>probe</code> methods. To do this, you use <code><a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_202"></a>kextload</code>. This is because installing your KEXT in <code>/System/Library/Extensions</code> and allowing <code>kextd</code> to load it when needed does not present you with the opportunity to attach to the computer in a <code>gdb</code> session before your driver has already matched and started.</p><p>If you are developing an I/O Kit driver, you can use <code>kextload</code> with the <code>-l</code> option to load your KEXT binary on the target computer but to refrain from sending any personalities to the kernel. By separating loading from matching, <code>kextload -l</code> allows you to defer matching (and the calling of your driver’s <code>start</code> and <code>probe</code> methods) until after you set up a two-machine debugging session (for more information on how to set up such a session, see <span class="content_text"><a href="DebuggingDrivers.html#//apple_ref/doc/uid/TP30000701-BAJCBEIJ">“Setting Up for Two-Machine Debugging”</a></span>). </p><p>To avoid matching before you’re ready, you can invoke <code>kextunload<a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_203"></a></code> on your driver before using <code>kextload -l</code> to make sure none of your driver’s personalities remain in the kernel from an earlier debugging session. Be aware, however, that plugging in a new device after you’ve used <code>kextload -l</code> to load your KEXT binary may cause some other driver to match on the device. If this is not desirable, take care not to change your system’s configuration until you are ready. </p><p>After you’ve attached to the target computer and set breakpoints on the <code>start</code> and <code>probe</code> methods, you use <code>kextload</code> with the <code>-m</code> option to send the personalities to the kernel, which triggers matching. If your KEXT’s <code>start</code> and <code>probe</code> methods do not execute, a successful match did not occur and you should examine the driver personalities to find out why. See <span class="content_text"><a href="DebuggingDrivers.html#//apple_ref/doc/uid/TP30000701-BJEGEEDF">“Debugging Matching Problems”</a></span> for advice on how to debug matching problems.<a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_204"></a></p><p><a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_205"></a>If you are developing a non–I/O Kit KEXT, such as an NKE (network kernel extension) or a file system KEXT, you implement the <code>MODULE_START</code> method instead of the <code>start</code> method an I/O Kit driver implements. To debug the <code>MODULE_START</code> method, you use <code>kextload</code> with the <code>-i</code> or <code>-I</code> options to interactively load the KEXT and its dependencies, pausing after each step for your permission to continue.</p><p>Using the <code>-i</code> option tells <code>kextload</code> to automatically load your KEXT’s dependencies but to ask for permission to continue at each step in the process of loading the KEXT itself. The <code>-I</code> option causes <code>kextload</code> to pause for input at each step of every stage of loading, including the loading of dependencies. If you want to debug your KEXT’s <code>MODULE_START</code> method, you use <code>kextload -i</code> or <code>-I</code> to load your KEXT binary and then set up a two-machine debugging session before you give permission to invoke the <code>MODULE_START</code> method. <span class="content_text"><a href="DebuggingDrivers.html#//apple_ref/doc/uid/TP30000701-BJEJACJA">Listing 7-4</a></span> shows the loading of an example KEXT called MyKEXT using <code>kextload -i</code>.<a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_206"></a></p><a name="//apple_ref/doc/uid/TP30000701-BJEJACJA" title="Listing 7-4Using kextload -i for interactive KEXT loading"></a><p class="codesample"><strong>Listing 7-4&nbsp;&nbsp;</strong>Using <code>kextload -i</code> for interactive KEXT loading</p><div class="codesample"><table><tr><td scope="row"><pre>[computer_name:/tmp] user_name% sudo kextload -i MyKEXT.kext<span></span></pre></td></tr><tr><td scope="row"><pre>Password:<span></span></pre></td></tr><tr><td scope="row"><pre>Load extension MyKEXT.kext and its dependencies [Y/n]? y<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>Load module /tmp/MyKEXT.kext/Contents/MacOS/MyKEXT [Y/n]? y<span></span></pre></td></tr><tr><td scope="row"><pre>kextload: module com.MySoftwareCompany.driver.MyKEXT created as #70 at<span></span></pre></td></tr><tr><td scope="row"><pre>                                        address 0xaf5c000, size 8192<span></span></pre></td></tr><tr><td scope="row"><pre>kextload: You can now break to the debugger and set breakpoints for this<span></span></pre></td></tr><tr><td scope="row"><pre>                                                            extension.<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>Start module /tmp/MyKEXT.kext/Contents/MacOS/MyKEXT (answering no will abort<span></span></pre></td></tr><tr><td scope="row"><pre>                                                    the load) [Y/n]? y<span></span></pre></td></tr><tr><td scope="row"><pre>kextload: started module /tmp/MyKEXT.kext/Contents/MacOS/MyKEXT<span></span></pre></td></tr><tr><td scope="row"><pre>kextload: MyKEXT.kext loaded successfully<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>Send personality "MyKEXT" to the kernel [Y/n]? y<span></span></pre></td></tr><tr><td scope="row"><pre>kextload: matching started for MyKEXT.kext<span></span></pre></td></tr><tr><td scope="row"><pre>[computer_name:/tmp] user_name%<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP30000701-BJEGEEDF" title="Debugging Matching Problems"></a><h3>Debugging Matching Problems</h3><a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_207"></a><p><a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_208"></a><a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_209"></a><a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_210"></a>Getting your driver to match correctly can be one of the more challenging aspects of I/O Kit driver development. If your driver loads and unloads properly but does not match, the most important thing you can do is become thoroughly familiar with your family’s matching language. Although the I/O Kit implements driver matching in a three-phase, subtractive process (described in detail in<em><a href="../../IOKitFundamentals/index.html#//apple_ref/doc/uid/TP0000011" target="_top"> I/O Kit Fundamentals</a></em>), each I/O Kit family is free to define an arbitrarily complex matching language of its own.</p><p>After the I/O Kit discards drivers of the wrong class in the class-matching phase, the I/O Kit examines the remaining drivers for family-specific matching properties in the passive-matching phase. If the family implements family-specific matching, it considers the candidate driver’s personality and raises or lowers the driver’s <code>probe</code> score based on the matches it finds.</p><p>Although some families define no family-specific matching, instead preferring drivers to probe the device, many others exercise some control over the passive-matching phase. The USB family, for example, requires its drivers to use specific combinations of properties defined by the USB Common Class Specification. In order for your USB driver to match, you must include all the elements of exactly one property combination. Another example is the PCI family which defines a number of match keys whose values are the contents of various PCI configuration-space registers. A candidate PCI driver can then match on a single register value, a list of values, or even a partial register value indicated by a supplied bit mask.</p><p>If your driver does not match, first make sure the property values in your driver’s personality match the corresponding properties your device publishes in the I/O Registry. You can use the I/O Registry Explorer application (available at <code>/Developer/Applications</code>) or the command-line tool <code>ioreg</code> to view the properties your device publishes. If you use I/O Registry Explorer, select Find to search for your device name, follow the path to the object representing your device, and view its properties in the lower window. Alternately, to view the I/O Registry in a Terminal window, type</p><div class="codesample"><table><tr><td scope="row"><pre>ioreg -bl<span></span></pre></td></tr></table></div><p>The <code>-b</code> option displays the object names in bold and the <code>-l</code> option displays the object properties.</p><p>If there are no discrepancies between your device’s published properties and your driver’s matching properties, next make sure you know how your driver’s family implements matching. Families that define their own matching language do so by implementing the <code>matchPropertyTable</code> method. By viewing the code for this method, you can determine how your driver’s family uses the properties it finds in a driver’s personality dictionary to adjust the <code>probe</code> score.</p><p>In very rare cases, a driver might declare <code><a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_211"></a>IOResources</code> as the value of its <code>IOProviderClass</code> key. <code>IOResouces</code> is a special nub attached to the root of the I/O Registry that makes resources, such as the BSD kernel, available throughout the system. Traditionally, drivers of virtual devices match on <code>IOResources</code> because virtual devices do not publish nubs of their own. Another example of such a driver is the HelloIOKit KEXT (described in <span class="content_text"><a href="../../../../Darwin/Conceptual/KEXTConcept/KEXTConceptIOKit/hello_iokit.html#//apple_ref/doc/uid/20002366" target="_top">Hello I/O Kit: Creating a Device Driver With Xcode</a></span>) which matches on <code>IOResources</code> because it does not control any hardware.</p><div class="importantbox"><a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_17" title="Important:"></a><p><strong>Important:</strong>&nbsp;Any driver that declares <code>IOResources</code> as the value of its <code>IOProviderClass</code> key must also include in its personality the <code><a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_212"></a>IOMatchCategory</code> key and a private match category value. This prevents the driver from matching exclusively on the <code>IOResources</code> nub and thereby preventing other drivers from matching on it. It also prevents the driver from having to compete with all other drivers that need to match on <code>IOResources</code>. The value of the <code>IOMatchCategory</code> property should be identical to the value of the driver's <code>IOClass</code> property, which is the driver’s class name in reverse-DNS notation with underbars instead of dots, such as <code>com_MyCompany_driver_MyDriver</code>.</p><p></p></div><p>Finally, you can place the <code>IOKitDebug<a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_213"></a></code> property in your driver’s personality dictionary. When you give this property a non-zero value, it places the status of various events, such as attaching, matching, and probing, into the system log (available at <code>/var/log/system.log</code>). The value of the <code>IOKitDebug</code> property defines which events are logged; see <code>IOKitDebug.h</code> (available in <code>/System/Library/Frameworks/Kernel.framework/Headers/IOKit</code>) for the I/O Kit–defined values. Unless you are interested in only a single event or a particular set of events, set the value to <code>65535</code> to get information about all the events <code>IOKitDebug</code> covers. With this information, you can see which events occurred and whether they succeeded or failed, but not why they failed.</p><p>Although the <code>IOKitDebug</code> property can be useful during development, be sure to set its value to <code>0</code> (or remove the property altogether) before shipping your driver because a non-zero value will prevent your driver from loading during a safe-boot. For more information on safe booting, see the <span class="content_text"><a href="../../../../Darwin/Conceptual/KEXTConcept/KEXTConceptLoading/loading_kexts.html#//apple_ref/doc/uid/20002369-BABEJEIB" target="_top">Loading Kernel Extensions at Boot Time</a></span> section of <em><a href="../../../../Darwin/Conceptual/KEXTConcept/index.html#//apple_ref/doc/uid/TP40001063" target="_top">Kernel Extension Programming Topics</a></em>.<a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_214"></a><a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_215"></a><a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_216"></a></p><a name="//apple_ref/doc/uid/TP30000701-CJBHCEGD" title="Two-Machine Debugging"></a><h2>Two-Machine Debugging</h2><p><a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_217"></a><a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_218"></a>For debugging<a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_219"></a> a device driver or indeed any code that resides in the kernel, two computers are a necessity. Buggy kernel code has a nasty tendency to crash or hang a system, and so directly debugging that system is often impossible.</p><p>Two-machine debugging with <code>gdb</code> is the main pathway to finding bugs in driver code. This section takes you through the procedure for setting up two computers for debugging, offers a few tips on using <code>gdb</code> in kernel code, introduces you to the kernel debugging macros, and discusses techniques for finding bugs causing kernel panics and hangs. </p><a name="//apple_ref/doc/uid/TP30000701-BAJCBEIJ" title="Setting Up for Two-Machine Debugging"></a><h3>Setting Up for Two-Machine Debugging</h3><p><a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_220"></a>This section summarizes the steps required to set up two computers for kernel debugging. It draws heavily on the following documents, which you should refer to for more detailed information:</p><ul class="spaceabove"><li class="li"><p>The tutorial <span class="content_text"><a href="../../../../Darwin/Conceptual/KEXTConcept/KEXTConceptDebugger/hello_debugger.html#//apple_ref/doc/uid/20002367-CHDIHFDI" target="_top">Hello Debugger: Debugging a Device Driver with GDB</a></span>. (This tutorial is part of <em><a href="../../../../Darwin/Conceptual/KEXTConcept/index.html#//apple_ref/doc/uid/TP40001063" target="_top">Kernel Extension Programming Topics</a></em>.)</p></li><li class="li"><p>The “When Things Go Wrong” section of <span class="content_text"><a href="../../../../Darwin/Conceptual/KernelProgramming/build/build.html#//apple_ref/doc/uid/TP30000905-CH221" target="_top">Building and Debugging Kernels</a></span> in <em><a href="../../../../Darwin/Conceptual/KernelProgramming/index.html#//apple_ref/doc/uid/TP30000905" target="_top">Kernel Programming Guide</a></em>. (This document is available on-line in <span class="content_text"><a href="../../../../Darwin/index.html#//apple_ref/doc/uid/TP30000422" target="_top">Darwin Documentation</a></span>.)</p></li></ul><p>In two-machine debugging, one system is called the <em>target</em><a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_221"></a> computer and the other the <em>host</em> (or <em>development</em>) computer. The <a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_222"></a>host computer is the computer that actually runs <code>gdb</code>. It is typically the computer on which your driver is developed—hence, it’s also referred to as the development computer. The target computer is the system on which the driver to be debugged is run. Your host and target computers should be running the same version of the Darwin kernel, or as close as possible to same version. (Of course, if you’re debugging a panic-prone version of the kernel, you’ll want the host computer to run the most recent stable version of Darwin.) For optimal source-level debugging, the host computer should have the source code of the driver, any kernel extensions related to your driver (such as its client or provider), and perhaps even the kernel itself (<code>/xnu</code>). </p><p>In order for two-machine debugging to be feasible, the following must be true:</p><ul class="spaceabove"><li class="li"><p>For versions of Mac OS X before Mac OS X version 10.2, both computers must be on the same subnet.</p></li><li class="li"><p>You must have login access to both computers as an administrator (group <code>admin</code>), because you’ll need root privileges to load your KEXT (you can use the <code><a href="../../../../Darwin/Reference/ManPages/man8/sudo.8.html#//apple_ref/doc/man/8/sudo" target="_top">sudo(8)</a></code> command).</p></li><li class="li"><p>You must be able to copy files between the computers using FTP, <code>scp</code> (SSH), <code>rsync</code>, AFP, or similar protocol or tool.</p></li></ul><div class="notebox"><a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_18" title="Note"></a><p><strong>Note:</strong>&nbsp;The following steps include instructions on setting up a permanent network connection via ARP (step 3). This is unnecessary if you are running Mac OS X v. 10.2 or later on both machines and if you set the NVRAM <code>debug</code> variable to 0x144 (as in step 1). This configuration allows you to set up two-machine debugging on two computers that are not necessarily on the same subnet. If you are running an earlier version of Mac OS X, however, you do need to follow step 3 and both computers must be on the same subnet.</p></div><p>When all this is in place, complete the following steps:</p><ol class="ol"><li class="li"><p><strong>Target</strong> Set the NVRAM <code>debug</code> variable to <code>0x144</code>, which lets you drop into the debugger upon a non-maskable interrupt (NMI) and, if you’re running Mac OS X v. 10.2 or later, lets you debug two computers not on the same subnet. You can use <code>setenv</code> to set the flag within Open Firmware itself (on PowerPC-based Macintosh computers), or you can use the <code>nvram</code> utility. For the latter, enter the following as root at the command line:</p><ol class="ol"><li class="ol ol"><div class="codesample"><table><tr><td scope="row"><pre>nvram boot-args="debug=0x144"<span></span></pre></td></tr></table></div></li></ol><p>It’s a good idea to enter <code>nvram boot-args</code> (no argument) first to get any current NVRAM variables in effect; then include these variables along with the debug flag when you give the <code>nvram boot-args</code> command a second time. Reboot the system.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_19" title="Note"></a><p><strong>Note:</strong>&nbsp;If your target machine contains a PMU (for example, a PowerBook G4 or an early G5 desktop computer), you may find that it shuts down when you exit kernel debugging mode. One reason for this is that if a breakpoint causes kernel debugger entry in the middle of a PMU transaction, the PMU watchdog may trigger on a timeout and cause the machine to shut down. If you experience this, you may find that forcing the PMU driver to operate in polled mode fixes the problem. To do this, set the NVRAM variable <code>pmuflags</code> to <code>1</code>, as shown below:</p><code>nvram boot-args="pmuflags=1"</code></p>You can set the <code>pmuflags</code> variable separately, as shown above, or you can set it at the same time you set the <code>debug</code> variable, as shown below:</p><code>boot-args="debug=0x144 pmuflags=1"</code></p></div></li><li class="li"><p><strong>Host</strong> or <strong>Target</strong> Copy the driver (or any other kernel extension) to a working directory on the target computer.</p></li><li class="li"><p><strong>Host</strong> Set up a permanent network connection to the target computer via ARP. The following example assumes that your test computer is <code>target.goober.com</code>:</p><div class="codesample"><table><tr><td scope="row"><pre>$ ping -c 1 target.goober.com<span></span></pre></td></tr><tr><td scope="row"><pre>ping results: ....<span></span></pre></td></tr><tr><td scope="row"><pre>$ arp -an<span></span></pre></td></tr><tr><td scope="row"><pre>target.goober.com (10.0.0.69): 00:a0:13:12:65:31<span></span></pre></td></tr><tr><td scope="row"><pre>$ arp -s target.goober.com 00:a0:13:12:65:31<span></span></pre></td></tr><tr><td scope="row"><pre>$ arp -an<span></span></pre></td></tr><tr><td scope="row"><pre>target.goober.com (10.0.0.69) at00:a0:13:12:65:31 permanent<span></span></pre></td></tr></table></div><p>This sequence of commands establishes a connection to the target computer (via <code>ping</code>), displays the information on recent connections ARP knows about (<code>arp -an</code>), makes the connection to the target computer permanent by specifying the Ethernet hardware address (<code>arp -s</code>), and issues the <code>arp -an</code> command a second time to verify this. </p></li><li class="li"><p><strong>Target</strong> Create symbol files for the driver and any other kernel extensions it depends on. First create a directory to hold the symbols; then run the <code>kextload</code> command-line tool, specifying the directory as the argument of the <code>-s</code> option:</p><div class="codesample"><table><tr><td scope="row"><pre>$ kextload -l -s /tmp/symbols /tmp/MyDriver.kext<span></span></pre></td></tr></table></div><p><a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_223"></a>This command loads <code>MyDriver.kext</code> but, because of the <code>-l</code> option, doesn’t start the matching process yet (that happens in a later step). If you don’t want the driver to load just yet, specify the <code>-n</code> option along with the <code>-s</code> option. See <span class="content_text"><a href="DebuggingDrivers.html#//apple_ref/doc/uid/TP30000701-BAJEDDDH">“Using kextload,  kextunload, and  kextstat”</a></span> for the <code>kextload</code> procedure for debugging a driver’s start-up code.</p></li><li class="li"><p><strong>Target</strong> or <strong>Host</strong> Copy the symbol files to the host computer.</p></li><li class="li"><p><strong>Host</strong> Optionally, if you want to debug your driver with access to all the symbols in the kernel, obtain or build a symboled kernel. For further information, contact Apple Developer Technical support. You can find the instructions for building the Darwin kernel from the Open Source code in the <span class="content_text"><a href="../../../../Darwin/Conceptual/KernelProgramming/build/build.html#//apple_ref/doc/uid/TP30000905-CH221" target="_top">Building and Debugging Kernels</a></span> in <em><a href="../../../../Darwin/Conceptual/KernelProgramming/index.html#//apple_ref/doc/uid/TP30000905" target="_top">Kernel Programming Guide</a></em>.</p></li><li class="li"><p><strong>Host</strong> Run <code>gdb</code> on the <a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_224"></a>kernel.</p><div class="codesample"><table><tr><td scope="row"><pre>$ gdb /mach_kernel<span></span></pre></td></tr></table></div><p>If you have a symboled kernel<a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_225"></a><a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_226"></a>, specify the path to it rather than <code>/mach_kernel</code>. It is important that you run <code>gdb</code> on a kernel of the same version and build as the one that runs on the target computer. If the versions are different, you should obtain a symboled copy of the target’s kernel and use that.</p></li><li class="li"><p><strong>Host</strong> In <code>gdb</code>, add the symbol file of your driver.</p><div class="codesample"><table><tr><td scope="row"><pre>(gdb) add-symbol-file /tmp/symbols/com.acme.driver.MyDriver.sym<span></span></pre></td></tr></table></div><p>Add the symbol files<a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_227"></a> of the other kernel extensions in your driver’s dependency chain.</p></li><li class="li"><p><strong>Host</strong> Tell <code>gdb</code> that you will be debugging remotely.</p><div class="codesample"><table><tr><td scope="row"><pre>(gdb) target remote-kdp<span></span></pre></td></tr></table></div></li><li class="li"><p><strong>Target</strong> Break into kernel debugging mode. Depending on the model of your target system, either issue the appropriate keyboard command or press the programmer’s button. On USB keyboards, hold down the Command key and the Power button; on ADB keyboards, hold down the Control key and the Power button. If you’re running Mac OS X version 10.4 or later, hold down the following five keys: Command, Option, Control, Shift, and Escape.</p><p>You may have to hold down the keys or buttons for several seconds until you see the “Waiting for remote debugger connection” message.</p></li><li class="li"><p><strong>Host</strong> Attach to the target computer and set breakpoints.</p><div class="codesample"><table><tr><td scope="row"><pre>(gdb) attach target.goober.com<span></span></pre></td></tr><tr><td scope="row"><pre>(gdb) break 'MyDriverClass::WriteData(* char)'<span></span></pre></td></tr><tr><td scope="row"><pre>(gdb) continue<span></span></pre></td></tr></table></div><p>Be sure you give the <code>continue</code> command; otherwise the target computer is unresponsive.</p></li><li class="li"><p><strong>Target</strong> Start the driver running.</p><div class="codesample"><table><tr><td scope="row"><pre>$ kextload -m -t /tmp/MyDriver.kext<span></span></pre></td></tr></table></div><p><a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_228"></a>The<code> -m</code> option starts the matching process for the driver. The <code>-t</code> option, which tells <code>kextload</code> to conduct extensive validation checks, is really optional here; ideally, your driver should have passed these checks during an earlier stage of debugging (see <span class="content_text"><a href="DebuggingDrivers.html#//apple_ref/doc/uid/TP30000701-BAJEDDDH">“Using kextload,  kextunload, and  kextstat”</a></span>). After starting the driver, perform the actions necessary to trigger the breakpoint.</p></li><li class="li"><p><strong>Host</strong> When the breakpoint you set is triggered, you can begin debugging your driver using <code>gdb</code> commands. If you “source” the kernel debugging macros (see the following section, <span class="content_text"><a href="DebuggingDrivers.html#//apple_ref/doc/uid/TP30000701-CJBJIAHA">“Using the Kernel Debugging Macros”</a></span>), you can use those as well.<a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_229"></a><a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_230"></a><a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_231"></a><a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_232"></a></p></li></ol><a name="//apple_ref/doc/uid/TP30000701-CJBJIAHA" title="Using the Kernel Debugging Macros"></a><h3>Using the Kernel Debugging Macros</h3><p><a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_233"></a><a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_234"></a>Apple includes a set of kernel debugging macros as part of Darwin. They have been written by engineers with an intimate knowledge of how the Darwin kernel works. Although it is possible to debug driver code without these macros, they will make the task much easier.</p><p>The kernel debugging macros probe the internal structures of a running Mac OS X system in considerable depth. With them you can get summary and detailed snapshots of tasks and their threads in the kernel, including such information as thread priority, executable names, and invoked functions. The kernel debugging macros also yield information on the kernel stacks for all or selected thread activations, on IPC spaces and port rights, on virtual-memory maps and map entries, and on allocation zones. See <span class="content_text"><a href="DebuggingDrivers.html#//apple_ref/doc/uid/TP30000701-BAJBAIIF">Table 7-2</a></span> for a summary of the kernel debugging macros.</p><div class="importantbox"><a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_20" title="Important:"></a><p><strong>Important:</strong>&nbsp;The kernel debugging macros described in this section will not work unless you have a symboled kernel. You can either build the Darwin kernel from the open source (see the <span class="content_text"><a href="../../../../Darwin/Conceptual/KernelProgramming/build/build.html#//apple_ref/doc/uid/TP30000905-CH221" target="_top">Building and Debugging Kernels</a></span> in<em><a href="../../../../Darwin/Conceptual/KernelProgramming/index.html#//apple_ref/doc/uid/TP30000905" target="_top">Kernel Programming Guide</a></em> for details) or you can refer to the Kernel Debug Kit, available at <span class="content_text"><a href="http://developer.apple.com/sdk" target="_top">http://developer.apple.com/sdk</a></span>, which includes a copy of the kernel debug macros.</p><p></p></div><p><a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_235"></a>You can obtain the kernel debugging macros from the Darwin Open Source repository. They are in the <code>.gdbinit</code> file in the <code>/xnu/osfmk</code> branch of the source tree. Because <code>.gdbinit</code><a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_236"></a> is the standard name of the initialization file for <code>gdb</code>, you might already have your own <code>.gdbinit</code> file to set up your debugging sessions. If this is the case, you can combine the contents of the files or have a “source” statement in one <code>.gdbinit</code> file that references the other file. To include the macros in a <code>.gdbinit</code> file for a debugging session, specify the following <code>gdb</code> command shortly after running <code>gdb</code> on <code>mach_kernel</code>: </p><div class="codesample"><table><tr><td scope="row"><pre>(gdb) source /tmp/.gdbinit<span></span></pre></td></tr></table></div><p>(In this example, <code>/tmp</code> represents any directory that holds the copy of the <code>.gdbinit</code> file you obtained from the Open Source repository.) Because the kernel debugging macros can change between versions of the kernel, make sure that you use the macros that match as closely as possible the version of the kernel you’re debugging.</p><a name="//apple_ref/doc/uid/TP30000701-BAJBAIIF" title="Table 7-2Kernel debugging macros"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 7-2&nbsp;&nbsp;</strong>Kernel debugging macros</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Macro</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Description</p></th></tr><tr><td  scope="row"><p><code>showalltasks</code></p></td><td ><p>Displays a summary listing of tasks</p></td></tr><tr><td  scope="row"><p><code>showallacts</code></p></td><td ><p>Displays a summary listing of all activations</p></td></tr><tr><td  scope="row"><p><code>showallstacks</code></p></td><td ><p>Displays the kernel stacks for all activations</p></td></tr><tr><td  scope="row"><p><code>showallvm</code></p></td><td ><p>Displays a summary listing of all the VM maps</p></td></tr><tr><td  scope="row"><p><code>showallvme</code></p></td><td ><p>Displays a summary listing of all the VM map entries</p></td></tr><tr><td  scope="row"><p><code>showallipc</code></p></td><td ><p>Displays a summary listing of all the IPC spaces</p></td></tr><tr><td  scope="row"><p><code>showallrights</code></p></td><td ><p>Displays a summary listing of all the IPC rights</p></td></tr><tr><td  scope="row"><p><code>showallkmods</code></p></td><td ><p>Displays a summary listing of all the kernel extension binaries</p></td></tr><tr><td  scope="row"><p><code>showtask</code></p></td><td ><p>Displays status of the specified task</p></td></tr><tr><td  scope="row"><p><code>showtaskacts</code></p></td><td ><p>Displays the status of all activations in the task</p></td></tr><tr><td  scope="row"><p><code>showtaskstacks</code></p></td><td ><p>Displays all kernel stacks for all activations in the task</p></td></tr><tr><td  scope="row"><p><code>showtaskvm</code></p></td><td ><p>Displays status of the specified task's VM map</p></td></tr><tr><td  scope="row"><p><code>showtaskvme</code></p></td><td ><p>Displays a summary list of the task's VM map entries</p></td></tr><tr><td  scope="row"><p><code>showtaskipc</code></p></td><td ><p>Displays status of the specified task's IPC space</p></td></tr><tr><td  scope="row"><p><code>showtaskrights</code></p></td><td ><p>Displays a summary list of the task's IPC space entries</p></td></tr><tr><td  scope="row"><p><code>showact</code></p></td><td ><p>Displays status of the specified thread activation</p></td></tr><tr><td  scope="row"><p><code>showactstack</code></p></td><td ><p>Displays the kernel stack for the specified activation</p></td></tr><tr><td  scope="row"><p><code>showmap</code></p></td><td ><p>Displays the status of the specified VM map</p></td></tr><tr><td  scope="row"><p><code>showmapvme</code></p></td><td ><p>Displays a summary list of the specified VM map's entries</p></td></tr><tr><td  scope="row"><p><code>showipc</code></p></td><td ><p>Displays the status of the specified IPC space</p></td></tr><tr><td  scope="row"><p><code>showrights</code></p></td><td ><p>Displays a summary list of all the rights in an IPC space</p></td></tr><tr><td  scope="row"><p><code>showpid</code></p></td><td ><p>Displays the status of the process identified by PID</p></td></tr><tr><td  scope="row"><p><code>showproc</code></p></td><td ><p>Displays the status of the process identified by a proc pointer</p></td></tr><tr><td  scope="row"><p><code>showkmod</code></p></td><td ><p>Displays information about a kernel extension binary</p></td></tr><tr><td  scope="row"><p><code>showkmodaddr</code></p></td><td ><p>Given an address, displays the kernel extension binary and offset</p></td></tr><tr><td  scope="row"><p><code>zprint</code></p></td><td ><p>Displays zone information</p></td></tr><tr><td  scope="row"><p><code>paniclog</code></p></td><td ><p>Displays the panic log information</p></td></tr><tr><td  scope="row"><p><code>switchtoact</code></p></td><td ><p>Switch thread context</p></td></tr><tr><td  scope="row"><p><code>switchtoctx</code></p></td><td ><p>Switch context</p></td></tr><tr><td  scope="row"><p><code>resetctx</code></p></td><td ><p>Reset context</p></td></tr></table></div><p>A subset of the kernel debugging macros are particularly useful for driver writers: <code>showallstacks<a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_237"></a></code>, <code>switchtoact<a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_238"></a></code>, <code>showkmodaddr<a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_239"></a></code>, <code>showallkmods<a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_240"></a></code>, and <code>switchtoctx<a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_241"></a></code>. The output of <code>showallstacks</code> lists all tasks in the system and, for each task, the threads and the stacks associated with each thread. <span class="content_text"><a href="DebuggingDrivers.html#//apple_ref/doc/uid/TP30000701-BAJCEHCB">Listing 7-5</a></span> shows the information on a couple tasks as emitted by <code>showallstacks</code>.<a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_242"></a> </p><a name="//apple_ref/doc/uid/TP30000701-BAJCEHCB" title="Listing 7-5Example thread stacks shown by showallstacks"></a><p class="codesample"><strong>Listing 7-5&nbsp;&nbsp;</strong>Example thread stacks shown by <code>showallstacks</code></p><div class="codesample"><table><tr><td scope="row"><pre>(gdb) showallstacks<span></span></pre></td></tr><tr><td scope="row"><pre>...<span></span></pre></td></tr><tr><td scope="row"><pre>task        vm_map      ipc_space  #acts   pid  proc        command<span></span></pre></td></tr><tr><td scope="row"><pre>0x00c1e620  0x00a79a2c  0x00c10ce0    2     51  0x00d60760  kextd<span></span></pre></td></tr><tr><td scope="row"><pre>            activation  thread      pri  state  wait_queue  wait_event<span></span></pre></td></tr><tr><td scope="row"><pre>            0x00c2a1f8  0x00ccab0c   31  W      0x00c9fee8  0x30a10c &lt;ipc_mqueue_rcv><span></span></pre></td></tr><tr><td scope="row"><pre>                        continuation=0x1ef44 &lt;ipc_mqueue_receive_continue><span></span></pre></td></tr><tr><td scope="row"><pre>            activation  thread      pri  state  wait_queue  wait_event<span></span></pre></td></tr><tr><td scope="row"><pre>            0x00c29a48  0x00cca194   31  W      0x00310570  0x30a3a0 &lt;kmod_cmd_queue><span></span></pre></td></tr><tr><td scope="row"><pre>                kernel_stack=0x04d48000<span></span></pre></td></tr><tr><td scope="row"><pre>                stacktop=0x04d4bbe0<span></span></pre></td></tr><tr><td scope="row"><pre>                0x04d4bbe0  0xccab0c<span></span></pre></td></tr><tr><td scope="row"><pre>                0x04d4bc40  0x342d8 &lt;thread_invoke+1104><span></span></pre></td></tr><tr><td scope="row"><pre>                0x04d4bca0  0x344b4 &lt;thread_block_reason+212><span></span></pre></td></tr><tr><td scope="row"><pre>                0x04d4bd00  0x334e0 &lt;thread_sleep_fast_usimple_lock+56><span></span></pre></td></tr><tr><td scope="row"><pre>                0x04d4bd50  0x81ee0 &lt;kmod_control+248><span></span></pre></td></tr><tr><td scope="row"><pre>                0x04d4bdb0  0x45f1c &lt;_Xkmod_control+192><span></span></pre></td></tr><tr><td scope="row"><pre>                0x04d4be00  0x2aa70 &lt;ipc_kobject_server+276><span></span></pre></td></tr><tr><td scope="row"><pre>                0x04d4be50  0x253e4 &lt;mach_msg_overwrite_trap+2848><span></span></pre></td></tr><tr><td scope="row"><pre>                0x04d4bf20  0x257e0 &lt;mach_msg_trap+28><span></span></pre></td></tr><tr><td scope="row"><pre>                0x04d4bf70  0x92078 &lt;.L_syscall_return><span></span></pre></td></tr><tr><td scope="row"><pre>                0x04d4bfc0  0x10000000<span></span></pre></td></tr><tr><td scope="row"><pre>                stackbottom=0x04d4bfc0<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>task        vm_map      ipc_space  #acts   pid  proc        command<span></span></pre></td></tr><tr><td scope="row"><pre>0x00c1e4c0  0x00a79930  0x00c10c88    1     65  0x00d608c8  update<span></span></pre></td></tr><tr><td scope="row"><pre>            activation  thread      pri  state  wait_queue  wait_event<span></span></pre></td></tr><tr><td scope="row"><pre>            0x00ddaa50  0x00ddbe34   31  W      0x00310780  0xd608c8 &lt;rld_env+10471956><span></span></pre></td></tr><tr><td scope="row"><pre>                        continuation=0x1da528 &lt;_sleep_continue><span></span></pre></td></tr></table></div>	<p>The typical number of stacks revealed by <code>showallstacks</code> runs into the dozens. Most of the threads associated with these stacks are asleep, blocked on continuation (as is that for the second task shown in the above example). Stacks such as these you can usually ignore. The remaining stacks are significant because they reflect the activity going on in the system at a particular moment and context (as happens when an NMI or kernel panic occurs). </p><p>Thread activations and stacks in the kernel—including those of drivers—belong to the task named <code>kernel_task</code> (under the <code>command</code> column). When you’re debugging a driver, you look in the active stacks in <code>kernel_task</code> for any indication of your driver or its provider, client, or any other object it communicates with. If you add the symbol files for these driver objects before you begin the debugging session, the indication will be much clearer. <span class="content_text"><a href="DebuggingDrivers.html#//apple_ref/doc/uid/TP30000701-BAJCIDFD">Listing 7-6</a></span> shows an active driver-related thread in <code>kernel_task</code> in the context of adjacent threads.</p><a name="//apple_ref/doc/uid/TP30000701-BAJCIDFD" title="Listing 7-6Kernel thread stacks as shown by showallstacks"></a><p class="codesample"><strong>Listing 7-6&nbsp;&nbsp;</strong>Kernel thread stacks as shown by <code>showallstacks</code></p><div class="codesample"><table><tr><td scope="row"><pre>       activation  thread      pri  state  wait_queue  wait_event<span></span></pre></td></tr><tr><td scope="row"><pre>       0x0101ac38  0x010957e4   80  UW     0x00311510  0x10b371c &lt;rld_env+13953096><span></span></pre></td></tr><tr><td scope="row"><pre>                 continuation=0x2227d0 &lt;_ZN10IOWorkLoop22threadMainContinuationEv><span></span></pre></td></tr><tr><td scope="row"><pre>       activation  thread      pri  state  wait_queue  wait_event<span></span></pre></td></tr><tr><td scope="row"><pre>       0x0101aaf0  0x01095650   80  R<span></span></pre></td></tr><tr><td scope="row"><pre>             stack_privilege=0x07950000<span></span></pre></td></tr><tr><td scope="row"><pre>             kernel_stack=0x07950000<span></span></pre></td></tr><tr><td scope="row"><pre>             stacktop=0x07953b90<span></span></pre></td></tr><tr><td scope="row"><pre>             0x07953b90  0xdf239e4 &lt;com.apple.driver.AppleUSBProKeyboard + 0x19e4><span></span></pre></td></tr><tr><td scope="row"><pre>             0x07953be0  0xe546694 &lt;com.apple.iokit.IOUSBFamily + 0x2694><span></span></pre></td></tr><tr><td scope="row"><pre>             0x07953c40  0xe5a84b4 &lt;com.apple.driver.AppleUSBOHCI + 0x34b4><span></span></pre></td></tr><tr><td scope="row"><pre>             0x07953d00  0xe5a8640 &lt;com.apple.driver.AppleUSBOHCI + 0x3640><span></span></pre></td></tr><tr><td scope="row"><pre>             0x07953d60  0xe5a93bc &lt;com.apple.driver.AppleUSBOHCI + 0x43bc><span></span></pre></td></tr><tr><td scope="row"><pre>             0x07953df0  0x2239a8 &lt;_ZN22IOInterruptEventSource12checkForWorkEv+18><span></span></pre></td></tr><tr><td scope="row"><pre>             0x07953e40  0x222864 &lt;_ZN10IOWorkLoop10threadMainEv+104><span></span></pre></td></tr><tr><td scope="row"><pre>             0x07953e90  0x2227d0 &lt;_ZN10IOWorkLoop22threadMainContinuationEv><span></span></pre></td></tr><tr><td scope="row"><pre>             stackbottom=0x07953e90<span></span></pre></td></tr><tr><td scope="row"><pre>       activation  thread      pri  state  wait_queue  wait_event<span></span></pre></td></tr><tr><td scope="row"><pre>       0x0101b530  0x0101c328   80  UW     0x00311500  0x10b605c &lt;rld_env+13963656><span></span></pre></td></tr><tr><td scope="row"><pre>                 continuation=0x2227d0 &lt;_ZN10IOWorkLoop22threadMainContinuationEv><span></span></pre></td></tr></table></div>	<p>You can use <code>showallstacks</code> in debugging panics, hangs, and wedges. For instance, it might reveal a pair of threads that are deadlocked against each other or it might help to identify a thread that is not handling interrupts properly, thus causing a system hang.<a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_243"></a></p><p>Another common technique using the kernel debugging macros is to run the <code>showallstacks</code> macro and find the stack or stacks that are most of interest. Then run the <code>switchtoact</code> macro, giving it the address of a thread activation, to switch to the context of that thread and its stack. From there you can get a backtrace, inspect frames and variables, and so on. <span class="content_text"><a href="DebuggingDrivers.html#//apple_ref/doc/uid/TP30000701-BAJEBFCA">Listing 7-7</a></span> shows this technique.</p><a name="//apple_ref/doc/uid/TP30000701-BAJEBFCA" title="Listing 7-7Switching to thread activation and examining it"></a><p class="codesample"><strong>Listing 7-7&nbsp;&nbsp;</strong>Switching to thread activation and examining it</p><a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_244"></a><div class="codesample"><table><tr><td scope="row"><pre>(gdb) switchtoact 0x00c29a48<span></span></pre></td></tr><tr><td scope="row"><pre>(gdb) bt<span></span></pre></td></tr><tr><td scope="row"><pre>#0  0x00090448 in cswnovect ()<span></span></pre></td></tr><tr><td scope="row"><pre>#1  0x0008f84c in switch_context (old=0xcca194, continuation=0, new=0xccab0c) at<span></span></pre></td></tr><tr><td scope="row"><pre>/SourceCache/xnu/xnu-327/osfmk/ppc/pcb.c:235<span></span></pre></td></tr><tr><td scope="row"><pre>#2  0x000344b4 in thread_block_reason (continuation=0, reason=0) at<span></span></pre></td></tr><tr><td scope="row"><pre>/SourceCache/xnu/xnu-327/osfmk/kern/sched_prim.c:1629<span></span></pre></td></tr><tr><td scope="row"><pre>#3  0x000334e0 in thread_sleep_fast_usimple_lock (event=0xeec500, lock=0x30a3ac,<span></span></pre></td></tr><tr><td scope="row"><pre>interruptible=213844) at /SourceCache/xnu/xnu-327/osfmk/kern/sched_prim.c:626<span></span></pre></td></tr><tr><td scope="row"><pre>#4  0x00081ee0 in kmod_control (host_priv=0xeec500, id=4144, flavor=213844,<span></span></pre></td></tr><tr><td scope="row"><pre>data=0xc1202c, dataCount=0xc12048) at /SourceCache/xnu/xnu-327/osfmk/kern/kmod.c:602<span></span></pre></td></tr><tr><td scope="row"><pre>#5  0x00045f1c in _Xkmod_control (InHeadP=0xc12010, OutHeadP=0xc12110) at<span></span></pre></td></tr><tr><td scope="row"><pre>mach/host_priv_server.c:958<span></span></pre></td></tr><tr><td scope="row"><pre>#6  0x0002aa70 in ipc_kobject_server (request=0xc12000) at<span></span></pre></td></tr><tr><td scope="row"><pre>/SourceCache/xnu/xnu-327/osfmk/kern/ipc_kobject.c:309<span></span></pre></td></tr><tr><td scope="row"><pre>#7  0x000253e4 in mach_msg_overwrite_trap (msg=0xf0080dd0, option=3, send_size=60,<span></span></pre></td></tr><tr><td scope="row"><pre>rcv_size=60, rcv_name=3843, timeout=12685100, notify=172953600, rcv_msg=0x0,<span></span></pre></td></tr><tr><td scope="row"><pre>scatter_list_size=0) at /SourceCache/xnu/xnu-327/osfmk/ipc/mach_msg.c:1601<span></span></pre></td></tr><tr><td scope="row"><pre>#8  0x000257e0 in mach_msg_trap (msg=0xeec500, option=13410708, send_size=213844,<span></span></pre></td></tr><tr><td scope="row"><pre>rcv_size=4144, rcv_name=172953600, timeout=178377984, notify=256) at<span></span></pre></td></tr><tr><td scope="row"><pre>/SourceCache/xnu/xnu-327/osfmk/ipc/mach_msg.c:1853<span></span></pre></td></tr><tr><td scope="row"><pre>#9  0x00092078 in .L_syscall_return ()<span></span></pre></td></tr><tr><td scope="row"><pre>#10 0x10000000 in ?? ()<span></span></pre></td></tr><tr><td scope="row"><pre>Cannot access memory at address 0xf0080d10<span></span></pre></td></tr><tr><td scope="row"><pre>(gdb) f 4<span></span></pre></td></tr><tr><td scope="row"><pre>#4  0x00081ee0 in kmod_control (host_priv=0xeec500, id=4144, flavor=213844,<span></span></pre></td></tr><tr><td scope="row"><pre>data=0xc1202c, dataCount=0xc12048) at /SourceCache/xnu/xnu-327/osfmk/kern/kmod.c:602<span></span></pre></td></tr><tr><td scope="row"><pre>602                     res = thread_sleep_simple_lock((event_t)&amp;kmod_cmd_queue,<span></span></pre></td></tr><tr><td scope="row"><pre>(gdb) l<span></span></pre></td></tr><tr><td scope="row"><pre>597                 simple_lock(&amp;kmod_queue_lock);<span></span></pre></td></tr><tr><td scope="row"><pre>598<span></span></pre></td></tr><tr><td scope="row"><pre>599                 if (queue_empty(&amp;kmod_cmd_queue)) {<span></span></pre></td></tr><tr><td scope="row"><pre>600                     wait_result_t res;<span></span></pre></td></tr><tr><td scope="row"><pre>601<span></span></pre></td></tr><tr><td scope="row"><pre>602                     res = thread_sleep_simple_lock((event_t)&amp;kmod_cmd_queue,<span></span></pre></td></tr><tr><td scope="row"><pre>603                                        &amp;kmod_queue_lock,<span></span></pre></td></tr><tr><td scope="row"><pre>604                                        THREAD_ABORTSAFE);<span></span></pre></td></tr><tr><td scope="row"><pre>605                     if (queue_empty(&amp;kmod_cmd_queue)) {<span></span></pre></td></tr><tr><td scope="row"><pre>606                         // we must have been interrupted!<span></span></pre></td></tr></table></div>	<p>Remember that when use the <code><!--a-->switchtoact<!--/a--></code> that you’ve actually changed the value of the stack pointer. You are in a different context than before. If you want to return to the former context, use the <code>resetctx</code> macro. <a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_245"></a></p><p>The <code>showallkmods<a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_246"></a></code> and <code>showkmodaddr</code> macros are also useful in driver debugging. The former macro lists all loaded kernel extensions in a format similar to the <code>kextstat</code> command-line utility (<span class="content_text"><a href="DebuggingDrivers.html#//apple_ref/doc/uid/TP30000701-BAJJAIJB">Listing 7-8</a></span> shows a few lines of output). If you give the <code>showkmodaddr</code> macro the address of an “anonymous” frame in a stack, and if the frame belongs to a driver (or other kernel extension), the macro prints information about the kernel extension.</p><a name="//apple_ref/doc/uid/TP30000701-BAJJAIJB" title="Listing 7-8Sample output from the showallkmods macro"></a><p class="codesample"><strong>Listing 7-8&nbsp;&nbsp;</strong>Sample output from the <code>showallkmods</code> macro</p><div class="codesample"><table><tr><td scope="row"><pre>(gdb) showallkmods<span></span></pre></td></tr><tr><td scope="row"><pre>kmod        address     size        id      refs    version  name<span></span></pre></td></tr><tr><td scope="row"><pre>0x0ebc39f4  0x0eb7d000  0x00048000  71      0       3.2  com.apple.filesystems.afpfs<span></span></pre></td></tr><tr><td scope="row"><pre>0x0ea09480  0x0ea03000  0x00007000  70      0       2.1  com.apple.nke.asp_atp<span></span></pre></td></tr><tr><td scope="row"><pre>0x0e9e0c60  0x0e9d9000  0x00008000  69      0       3.0  com.apple.nke.asp_tcp<span></span></pre></td></tr><tr><td scope="row"><pre>0x0e22b13c  0x0e226000  0x00006000  68      0       1.2  com.apple.nke.IPFirewall<span></span></pre></td></tr><tr><td scope="row"><pre>0x0e225600  0x0e220000  0x00006000  67      0       1.2  com.apple.nke.SharedIP<span></span></pre></td></tr><tr><td scope="row"><pre>0x0df5d868  0x0df37000  0x00028000  62      0       1.2  com.apple.ATIRage128<span></span></pre></td></tr><tr><td scope="row"><pre>0x0de96454  0x0de79000  0x0001e000  55      3       1.3 com.apple.iokit.IOAudioFamily<span></span></pre></td></tr><tr><td scope="row"><pre>...<span></span></pre></td></tr></table></div>	<a name="//apple_ref/doc/uid/TP30000701-BAJFCFHD" title="Tips on Using gdb"></a><h3>Tips on Using gdb</h3><p><a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_247"></a><a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_248"></a><a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_249"></a><a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_250"></a><a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_251"></a>If you hope to become proficient at I/O Kit driver debugging, you’ll have to become proficient in the use of <code>gdb</code>. There’s no getting around this requirement. But even if you are already familiar with <code>gdb</code>, you can always benefit from insights garnered by other driver writers from their experience.</p><a name="//apple_ref/doc/uid/TP30000701-BAJDCIAI" title="Examining Computer Instructions"></a><h4>Examining Computer Instructions</h4><p><a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_252"></a><a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_253"></a><a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_254"></a>If you don’t have symbols for a driver binary—and even if you do—you should try examining the computer instructions in memory to get a detailed view of what is going on in that binary. You use the <code>gdb</code> command <code>x</code> to examine memory in the current context; usually, <code>x</code> is followed by a slash (“/”) and one to three parameters, one of which is <code>i</code>. The examine-memory parameters are: </p><ul class="spaceabove"><li class="li"><p>A repeat count</p></li><li class="li"><p>The display format: <code>s</code> (string), <code>x</code> (hexadecimal), or <code>i</code> (computer instruction)</p></li><li class="li"><p>The unit size: <code>b</code> (byte), <code>h</code> (halfword), <code>w</code> (word—four bytes), <code>g</code> (giant word—eight bytes)</p></li></ul><p>For example, if you want to examine 10 instructions before and 10 instructions after the current context (as described in <span class="content_text"><a href="DebuggingDrivers.html#//apple_ref/doc/uid/TP30000701-BAJDJDFH">“Tips on Debugging Panics”</a></span>), you could issue a command such as:</p><div class="codesample"><table><tr><td scope="row"><pre>(gdb) x/20i $pc -40<span></span></pre></td></tr></table></div><p>This command says “show me 20 instructions, but starting 40 bytes” (4 bytes per instruction) “before the current address in the program counter” (the <code>$pc</code> variable). Of course, you could be less elaborate and give a simple command such as:</p><div class="codesample"><table><tr><td scope="row"><pre>(gdb) x/10i 0x001c220c<span></span></pre></td></tr></table></div><p>which shows you 10 computer instructions starting at a specified address. <span class="content_text"><a href="DebuggingDrivers.html#//apple_ref/doc/uid/TP30000701-CJBDGAHE">Listing 7-9</a></span> shows you a typical block of instructions.</p><a name="//apple_ref/doc/uid/TP30000701-CJBDGAHE" title="Listing 7-9Typical output of the gdb &acirc;&#128;&#156;examine memory&acirc;&#128;&#157; command"></a><p class="codesample"><strong>Listing 7-9&nbsp;&nbsp;</strong>Typical output of the <code>gdb</code> “examine memory” command</p><div class="codesample"><table><tr><td scope="row"><pre>(gdb) x/20i $pc-40<span></span></pre></td></tr><tr><td scope="row"><pre>0x8257c &lt;kmod_control+124>:     addi    r3,r27,-19540<span></span></pre></td></tr><tr><td scope="row"><pre>0x82580 &lt;kmod_control+128>:     bl      0x8d980 &lt;get_cpu_data><span></span></pre></td></tr><tr><td scope="row"><pre>0x82584 &lt;kmod_control+132>:     addi    r0,r30,-19552<span></span></pre></td></tr><tr><td scope="row"><pre>0x82588 &lt;kmod_control+136>:     lwz     r31,-19552(r30)<span></span></pre></td></tr><tr><td scope="row"><pre>0x8258c &lt;kmod_control+140>:     cmpw    r31,r0<span></span></pre></td></tr><tr><td scope="row"><pre>0x82590 &lt;kmod_control+144>:     bne+    0x825c0 &lt;kmod_control+192><span></span></pre></td></tr><tr><td scope="row"><pre>0x82594 &lt;kmod_control+148>:     mr      r3,r31<span></span></pre></td></tr><tr><td scope="row"><pre>0x82598 &lt;kmod_control+152>:     addi    r4,r27,-19540<span></span></pre></td></tr><tr><td scope="row"><pre>0x8259c &lt;kmod_control+156>:     li      r5,2<span></span></pre></td></tr><tr><td scope="row"><pre>0x825a0 &lt;kmod_control+160>:     bl      0x338a8<span></span></pre></td></tr><tr><td scope="row"><pre>                                     &lt;thread_sleep_fast_usimple_lock><span></span></pre></td></tr><tr><td scope="row"><pre>0x825a4 &lt;kmod_control+164>:     lwz     r0,-19552(r30)<span></span></pre></td></tr><tr><td scope="row"><pre>0x825a8 &lt;kmod_control+168>:     cmpw    r0,r31<span></span></pre></td></tr><tr><td scope="row"><pre>0x825ac &lt;kmod_control+172>:     bne+    0x825c0 &lt;kmod_control+192><span></span></pre></td></tr><tr><td scope="row"><pre>0x825b0 &lt;kmod_control+176>:     addi    r3,r27,-19540<span></span></pre></td></tr><tr><td scope="row"><pre>0x825b4 &lt;kmod_control+180>:     bl      0x8da00 &lt;fast_usimple_lock+32><span></span></pre></td></tr><tr><td scope="row"><pre>0x825b8 &lt;kmod_control+184>:     li      r3,14<span></span></pre></td></tr><tr><td scope="row"><pre>0x825bc &lt;kmod_control+188>:     b       0x82678 &lt;kmod_control+376><span></span></pre></td></tr><tr><td scope="row"><pre>0x825c0 &lt;kmod_control+192>:     lis     r26,49<span></span></pre></td></tr><tr><td scope="row"><pre>0x825c4 &lt;kmod_control+196>:     li      r30,0<span></span></pre></td></tr><tr><td scope="row"><pre>0x825c8 &lt;kmod_control+200>:     lwz     r0,-19552(r26)<span></span></pre></td></tr></table></div><p>Needless to say, you need to know some assembler in order to make sense of the output of the examine-memory command. You don’t need to be an expert in assembler, just knowledgeable enough to recognize patterns. For example, it would be beneficial to know how pointer indirection with an object looks in computer instructions. With an object, there are two indirections really, one to get the data (and that could be null) and one to an object’s virtual table (the first field inside the object). If that field doesn’t point to either your code or kernel code, then there’s something that might be causing a null-pointer exception. If your assembler knowledge is rusty or non-existent, you can examine the computer instructions for your driver’s code that you know to be sound. By knowing how “healthy” code looks in assembler, you’ll be better prepared to spot divergences from the pattern<a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_255"></a><a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_256"></a><a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_257"></a>.</p><a name="//apple_ref/doc/uid/TP30000701-TPXREF106" title="Breakpoints"></a><h4>Breakpoints</h4><p><a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_258"></a><a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_259"></a><a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_260"></a>Using breakpoints to debug code inside the kernel can be a frustrating experience. Often kernel functions are called so frequently that, if you put a breakpoint on a function, it’s difficult to determine which particular case is the one with the problem. There are a few things you can do with breakpoints to ameliorate this.</p><ul class="spaceabove"><li class="li"><p><strong>Conditional breakpoints</strong>. A conditional breakpoint tells <code>gdb</code> to trigger a breakpoint only if a certain expression is true. The syntax is <code>cond</code><em>&lt;breakpoint index> &lt;expression>. </em>An example is the following:</p><div class="codesample"><table><tr><td scope="row"><pre>(gdb) cond 1 (num > 0)<span></span></pre></td></tr></table></div><p>However, conditional breakpoints are very slow in two-machine debugging. Unless you’re expecting the breakpoint expression to be evaluated only a couple dozen times or so, they are probably too tedious to rely on.</p></li><li class="li"><p><strong>Cooperative breakpoints</strong>. To speed things up you can use two breakpoints that cooperate with each other. One breakpoint is a conditional breakpoint set at the critical but frequently invoked function. The other breakpoint, which has a command list attached to it, is set at a point in the code which is only arrived at after a series of events has occurred. You initially disable the conditional breakpoint and the second breakpoint enables it at some point later where the context is more pertinent to the problem you’re investigating (and so you don’t mind the slowness of expression evaluation). The following series of <code>gdb</code> commands sets up both breakpoints:</p><div class="codesample"><table><tr><td scope="row"><pre>(gdb) cond 1 (num > 0)<span></span></pre></td></tr><tr><td scope="row"><pre>(gdb) disable 1<span></span></pre></td></tr><tr><td scope="row"><pre>(gdb) com 2<span></span></pre></td></tr><tr><td scope="row"><pre>    enable 1<span></span></pre></td></tr><tr><td scope="row"><pre>    continue<span></span></pre></td></tr><tr><td scope="row"><pre>end<span></span></pre></td></tr></table></div><p>If this debugging is something you do frequently, you can put breakpoint-setup commands into a macro and put that macro in your <code>.gdbinit</code> file.</p></li><li class="li"><p><strong>Breakpoints at dummy functions</strong>. You can use the previous two techniques on code that you do not own. However, if it’s your code that you’re debugging, the fastest way to trigger a breakpoint exactly when and where you want is to use dummy functions. Consider the follow stripped code snippet:</p><div class="codesample"><table><tr><td scope="row"><pre>void dummy() {<span></span></pre></td></tr><tr><td scope="row"><pre>    ;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>void myFunction() {<span></span></pre></td></tr><tr><td scope="row"><pre>    // ...<span></span></pre></td></tr><tr><td scope="row"><pre>    if (num > 0)<span></span></pre></td></tr><tr><td scope="row"><pre>        dummy();<span></span></pre></td></tr><tr><td scope="row"><pre>    // ...<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>The expression in <code>myFunction</code> is the same exact expression you would have in a conditional breakpoint. Just set a breakpoint on the dummy function. When the breakpoint is triggered, get a backtrace, switch frames, and you’re in the desired context.<a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_261"></a><a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_262"></a><a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_263"></a></p></li></ul><a name="//apple_ref/doc/uid/TP30000701-TPXREF107" title="Single-Stepping"></a><h4>Single-Stepping</h4><p>Single-stepping<a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_264"></a> through source code does not necessarily take you from one line to the next. You can bounce around in the source code quite a bit because the compiler does various things with the symbols to optimize them. </p><p>There are two things you can do to get around this. If it’s your code you’re stepping through, you can turn off optimizations. Or you can single-step through the computer instructions in assembler because one line of source code typically generates several consecutive lines of assembler. So, if you find it hard to figure things out by single-stepping through source, try single-stepping through assembler. </p><p>To single-step in <code>gdb</code>, use the <code>stepi</code> command (<code>si</code> for short). You can get a better view of your progress if you also use the <code>display</code> command, as in this example:</p><div class="codesample"><table><tr><td scope="row"><pre>(gdb) display/4i $pc<span></span></pre></td></tr></table></div><p>This displays the program counter and the next three instructions as you step.</p><a name="//apple_ref/doc/uid/TP30000701-TPXREF108" title="Debugging Kernel Panics"></a><h3>Debugging Kernel Panics</h3><p><a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_265"></a><a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_266"></a><a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_267"></a><a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_268"></a>You might be familiar with kernel panics: those unexpected events that cripple a system, leaving it completely unresponsive. When a panic<a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_269"></a> occurs on Mac OS X, the kernel prints information about the panic that you can analyze to find the cause of the panic. On pre-Jaguar systems, this information appears on the screen as a black and white text dump. Starting with the Jaguar release, a kernel panic causes the display of a message informing you that a problem occurred and requesting that you restart your computer. After rebooting, you can find the debug information on the panic in the file <code>panic.log</code> at <code>/Library/Logs/</code>.</p><p>If you’ve never seen it before, the information in <code>panic.log</code> might seem cryptic. <span class="content_text"><a href="DebuggingDrivers.html#//apple_ref/doc/uid/TP30000701-BAJHEFIE">Listing 7-10</a></span> shows a typical entry in the panic log.</p><a name="//apple_ref/doc/uid/TP30000701-BAJHEFIE" title="Listing 7-10Sample log entry for a kernel panic"></a><p class="codesample"><strong>Listing 7-10&nbsp;&nbsp;</strong>Sample log entry for a kernel panic</p><div class="codesample"><table><tr><td scope="row"><pre>Unresolved kernel trap(cpu 0): 0x300 - Data access DAR=0x00000058 PC=0x0b4255b4<span></span></pre></td></tr><tr><td scope="row"><pre>Latest crash info for cpu 0:<span></span></pre></td></tr><tr><td scope="row"><pre>   Exception state (sv=0x0AD86A00)<span></span></pre></td></tr><tr><td scope="row"><pre>      PC=0x0B4255B4; MSR=0x00009030; DAR=0x00000058; DSISR=0x40000000; LR=0x0B4255A0;<span></span></pre></td></tr><tr><td scope="row"><pre>      R1=0x04DE3B50; XCP=0x0000000C (0x300 - Data access)<span></span></pre></td></tr><tr><td scope="row"><pre>      Backtrace:<span></span></pre></td></tr><tr><td scope="row"><pre>         0x0B4255A0 0x000BA9F8 0x001D41F8 0x001D411C 0x001D6B90 0x0003ACCC<span></span></pre></td></tr><tr><td scope="row"><pre>         0x0008EC84 0x0003D69C 0x0003D4FC 0x000276E0 0x0009108C 0xFFFFFFFF<span></span></pre></td></tr><tr><td scope="row"><pre>      Kernel loadable modules in backtrace (with dependencies):<span></span></pre></td></tr><tr><td scope="row"><pre>         com.acme.driver.MyDriver(1.6)@0xb409000<span></span></pre></td></tr><tr><td scope="row"><pre>Proceeding back via exception chain:<span></span></pre></td></tr><tr><td scope="row"><pre>   Exception state (sv=0x0AD86A00)<span></span></pre></td></tr><tr><td scope="row"><pre>      previously dumped as "Latest" state. skipping...<span></span></pre></td></tr><tr><td scope="row"><pre>   Exception state (sv=0x0B2BBA00)<span></span></pre></td></tr><tr><td scope="row"><pre>      PC=0x90015BC8; MSR=0x0200F030; DAR=0x012DA94C; DSISR=0x40000000; LR=0x902498DC;<span></span></pre></td></tr><tr><td scope="row"><pre>      R1=0xBFFFE140; XCP=0x00000030 (0xC00 - System call)<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>Kernel version:<span></span></pre></td></tr><tr><td scope="row"><pre>Darwin Kernel Version 6.0:<span></span></pre></td></tr><tr><td scope="row"><pre>Wed May  1 01:04:14 PDT 2002; root:xnu/xnu-282.obj~4/RELEASE_PPC<span></span></pre></td></tr></table></div>	<p>This block of information has several different parts, each with its own significance for debugging the problem.</p><ul class="spaceabove"><li class="li"><p><strong>The first line</strong>. The single most important bit of information about a panic is the first line, which briefly describes the nature of the panic. In this case, the panic has something to do with a data access exception. The registers that appear on the same line as the message are the ones with the most pertinent data; in this case they are the DAR (Data Access Register<a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_270"></a>)<a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_271"></a> and the PC<a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_272"></a> (Program Counter<a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_273"></a>) registers. The registers shown on the first line vary according to the type of kernel trap. The hexadecimal code before the description, which is defined in <code>/xnu/osfmk/ppc_init.c</code>, indicates the exception type. <span class="content_text"><a href="DebuggingDrivers.html#//apple_ref/doc/uid/TP30000701-CJBCIDFA">Table 7-3</a></span> describes the possible types of exceptions<a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_274"></a>.</p></li></ul><a name="//apple_ref/doc/uid/TP30000701-CJBCIDFA" title="Table 7-3Types of kernel exceptions"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 7-3&nbsp;&nbsp;</strong>Types of kernel exceptions</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Trap Value</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Type of Kernel Trap</p></th></tr><tr><td  scope="row"><p><code>0x100</code></p></td><td ><p>System reset</p></td></tr><tr><td  scope="row"><p><code>0x200</code></p></td><td ><p>Computer check</p></td></tr><tr><td  scope="row"><p><code>0x300</code></p></td><td ><p>Data access</p></td></tr><tr><td  scope="row"><p><code>0x400</code></p></td><td ><p>Instruction access</p></td></tr><tr><td  scope="row"><p><code>0x500</code></p></td><td ><p>External interrupt</p></td></tr><tr><td  scope="row"><p><code>0x600</code></p></td><td ><p>Alignment exception</p></td></tr><tr><td  scope="row"><p><code>0x700</code></p></td><td ><p>Illegal instruction</p></td></tr></table></div><ul class="spaceabove"><li class="li"><p><strong>The registers</strong>. Under the first “Exception state” is a snapshot of the contents of the CPU registers when the panic occurred.</p></li><li class="li"><p><strong>The backtrace</strong>. Each hexadecimal address in the backtrace<a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_275"></a> indicates the state of program execution at a particular point leading up to the panic. Because each of these addresses is actually that of the function return pointer, you need to subtract four from this address to see the instruction that was executed.</p></li><li class="li"><p><strong>The kernel extensions</strong>. Under “Kernel loadable modules in backtrace” are the bundle identifiers (<code>CFBundleIdentifier</code> property) of all kernel extensions referenced in the backtrace and all other kernel extensions on which these extensions have dependencies. These are the kernel extensions for which you’ll probably want to generate symbol files prior to debugging the panic.</p></li><li class="li"><p><strong>The other exception states</strong>. Under “Proceeding back via exception chain:” are the previous exception states the kernel experienced, separated by snapshots of the contents of the CPU registers at the time the exceptions occurred. Most of the time, the first exception state (immediately following the first line of the panic log) gives you enough information to determine what caused the panic. Sometimes, however, the panic is the result of an earlier exception and you can examine the chain of exceptions for more information.</p></li><li class="li"><p><strong>The kernel version</strong>. The version of the Darwin kernel and, more importantly, the build version of the <code>xnu</code> project (the core part of the Darwin kernel). If you are debugging with a symboled kernel (as is recommended), you need to get or build the symboled kernel from this version of <code>xnu</code>.<a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_276"></a></p></li></ul><a name="//apple_ref/doc/uid/TP30000701-TPXREF109" title="General Procedure"></a><h4>General Procedure</h4><p><a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_277"></a>There are many possible ways to debug a kernel panic, but the following course of action has proven fruitful in practice.</p><ol class="ol"><li class="li"><p><strong>Get as many binaries with debugging symbols as possible.</strong></p><p>Make a note of all the kernel extensions listed under “Kernel loadable modules in backtrace”. If you don’t have debugging symbols for some of them, try to obtained a symboled version of them or get the source and build one with debugging symbols. This would include <code>mach_kernel</code>, the I/O Kit families, and other KEXTs that are part of the default install. You need to have the same version of the kernel and KEXT binaries that the panicked computer does, or the symbols won’t line up correctly.</p></li><li class="li"><p><strong>Generate and add symbol files for each kernel extension in the backtrace. </strong></p><p>Once you’ve got the kernel extension binaries with (or without) debugging symbols, generate relocated symbol files for each KEXT in the <a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_278"></a>backtrace. Use <code>kextload<a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_279"></a></code> with the <code>-s</code> and <code>-n</code> options to do this; kextload prompts you for the load address of each kernel extension, which you can get from the backtrace. Alternatively, you can specify the <code>-a</code> option with <code>-s</code> when using <code>kextload</code> to specify KEXTs and their load addresses. Although you don’t need to relocate symbol files for all kernel extensions, you can only decode stack frames in the kernel or in KEXTs that you have done this for. After you run <code>gdb</code> on <code>mach_kernel</code> (preferably symboled), use <code>gdb</code>’s <code>add-symbol-file</code> command for each relocatable symbol files you’ve generated; see <span class="content_text"><a href="DebuggingDrivers.html#//apple_ref/doc/uid/TP30000701-BAJCBEIJ">“Setting Up for Two-Machine Debugging”</a></span> for details.</p></li><li class="li"><p><strong>Decode the addresses in the panic log.</strong></p><p>Start with the PC register and possibly the LR<a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_280"></a> (Link Register<a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_281"></a>). (The contents of the LR should look like a valid text address, usually a little smaller than the PC-register address.) Then process each address in the backtrace, remembering to subtract four from each of the stack addresses to get the last instruction executed in that frame. One possible way to go about it is to use a pair of <code>gdb</code> commands for each address:</p><div class="codesample"><table><tr><td scope="row"><pre>(gdb) x/i &lt;address>-4<span></span></pre></td></tr><tr><td scope="row"><pre>...<span></span></pre></td></tr><tr><td scope="row"><pre>(gdb) info line *&lt;address>-4<span></span></pre></td></tr></table></div><p>You need the asterisk in front of the address in the <code>info</code> command because you are passing a raw address rather than the symbol <code>gdb</code> expects. The <code>x</code> command, on the other hand, expects a raw address so no asterisk is necessary.</p><p><span class="content_text"><a href="DebuggingDrivers.html#//apple_ref/doc/uid/TP30000701-CJBBGCCI">Listing 7-11</a></span> gives an example of a symbolic backtrace generated from <code>x/i &lt;address>-4</code>. You’ll know you’ve succeeded when all the stack frames decode to some sort of branch instruction in assembler. </p></li><li class="li"><p><strong>Interpret the results.</strong></p><p>Interpreting the results of the previous step is the hardest phase of debugging panics because it isn’t mechanical in nature. See the following section, <span class="content_text"><a href="DebuggingDrivers.html#//apple_ref/doc/uid/TP30000701-BAJDJDFH">“Tips on Debugging Panics,”</a></span> for some suggestions.</p></li></ol><a name="//apple_ref/doc/uid/TP30000701-CJBBGCCI" title="Listing 7-11Example of symbolic backtrace "></a><p class="codesample"><strong>Listing 7-11&nbsp;&nbsp;</strong>Example of symbolic backtrace </p><div class="codesample"><table><tr><td scope="row"><pre>(gdb) x/i 0x001c2200-4<span></span></pre></td></tr><tr><td scope="row"><pre>0x1c21fc &lt;IOService::PMstop(void)+320>: bctrl<span></span></pre></td></tr><tr><td scope="row"><pre>0xa538260 &lt;IODisplay::stop(IOService *)+36>:    bctrl<span></span></pre></td></tr><tr><td scope="row"><pre>0x1bbc34 &lt;IOService::actionStop(IOService *, IOService *)+160>: bctrl<span></span></pre></td></tr><tr><td scope="row"><pre>0x1ccda4 &lt;runAction__10IOWorkLoopPFP8OSObjectPvn3_iPB2Pvn3+92>: bctrl<span></span></pre></td></tr><tr><td scope="row"><pre>0x1bc434 &lt;IOService::terminateWorker(unsigned long)+1824>:      bctrl<span></span></pre></td></tr><tr><td scope="row"><pre>0x1bb1f0 &lt;IOService::terminatePhase1(unsigned long)+928>:       bl<span></span></pre></td></tr><tr><td scope="row"><pre>0x1bb20c &lt;IOService::scheduleTerminatePhase2(unsigned long)><span></span></pre></td></tr><tr><td scope="row"><pre>0x1edfcc &lt;IOADBController::powerStateWillChangeTo(unsigned long, unsigned long, IOService *)+88>:       bctrl<span></span></pre></td></tr><tr><td scope="row"><pre>0x1c54e8 &lt;IOService::inform(IOPMinformee *, bool)+204>: bctrl<span></span></pre></td></tr><tr><td scope="row"><pre>0x1c5118 &lt;IOService::notifyAll(bool)+84>:       bl<span></span></pre></td></tr><tr><td scope="row"><pre>0x1c541c &lt;IOService::inform(IOPMinformee *, bool)><span></span></pre></td></tr><tr><td scope="row"><pre>0x1c58b8 &lt;IOService::parent_down_05(void)+36>:  bl<span></span></pre></td></tr><tr><td scope="row"><pre>0x1c50c4 &lt;IOService::notifyAll(bool)><span></span></pre></td></tr><tr><td scope="row"><pre>0x1c8364 &lt;IOService::allowCancelCommon(void)+356>:      bl<span></span></pre></td></tr><tr><td scope="row"><pre>0x1c5894 &lt;IOService::parent_down_05(void)><span></span></pre></td></tr><tr><td scope="row"><pre>0x1c80a0 &lt;IOService::serializedAllowPowerChange2(unsigned long)+84>:    bl<span></span></pre></td></tr><tr><td scope="row"><pre>0x1c8200 &lt;IOService::allowCancelCommon(void)><span></span></pre></td></tr><tr><td scope="row"><pre>0x1ce198 &lt;IOCommandGate::runAction(int (*)(OSObject *, void *, void *, void *, void *), void *, void *, void *, void *)+184>: bctrl<span></span></pre></td></tr><tr><td scope="row"><pre>0x1c802c &lt;IOService::allowPowerChange(unsigned long)+72>:       bctrl<span></span></pre></td></tr><tr><td scope="row"><pre>0xa52e6c ????<span></span></pre></td></tr><tr><td scope="row"><pre>0x3dfe0 &lt;_call_thread_continue+440>:    bctrl<span></span></pre></td></tr><tr><td scope="row"><pre>0x333fc &lt;thread_continue+144>:  bctrl<span></span></pre></td></tr></table></div>	<a name="//apple_ref/doc/uid/TP30000701-BAJDJDFH" title="Tips on Debugging Panics"></a><h4>Tips on Debugging Panics</h4><a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_282"></a><p>The following tips might make debugging a panic easier for you.</p><ul class="spaceabove"><li class="li"><p>As noted previously, always pay attention to the first line of the panic message and the list of kernel extensions involved in the panic. The panic message provides the major clue to the problem. With the kernel extensions, generate relocated symbol files for the debugging session.</p></li><li class="li"><p>Don’t assume that the panic is not your driver’s fault just because it doesn’t show up in the backtrace. Passing a null pointer to an I/O Kit family or any other body of kernel code <em>will</em> cause a panic in that code. Because the kernel doesn’t have the resources to protect itself from null pointers, drivers must be extremely vigilant against passing them in.</p></li><li class="li"><p>The <code><!--a-->showallstacks<!--/a--></code> kernel debugging macro is very useful for debugging panics. See <span class="content_text"><a href="DebuggingDrivers.html#//apple_ref/doc/uid/TP30000701-CJBJIAHA">“Using the Kernel Debugging Macros”</a></span> for more information.</p></li><li class="li"><p>Use <code>gdb</code>’s <code>$pc</code> variable when debugging panics with <code>gdb</code>. The <code>$pc</code> variable holds the value of the program counter, which identifies the place where the panic exception was taken. If you want to examine the context of the panic, you could issue a command such as:</p><div class="codesample"><table><tr><td scope="row"><pre>(gdb) x/20i $pc -40<span></span></pre></td></tr></table></div><p>This displays 10 instructions in assembler before and after the point where the panic occurred. If you have the appropriate source code and symbols, you can enter:</p><div class="codesample"><table><tr><td scope="row"><pre>(gdb) l *$pc<span></span></pre></td></tr></table></div><p>This shows the particular line of code that took the panic.</p></li><li class="li"><p>If you have a panic caused by an Instruction Access Exception (<code>0x400</code>) and the PC register is zero, it means that something in the kernel branched to zero. The top frame in the stack is usually a jump through some function pointer that wasn’t initialized (or that somehow got “stomped”).</p></li><li class="li"><p>Panics caused by a Data Access Exception <code>0x300</code> are quite common. These types of panics typically involve indirection through zero (in other words, a dereferenced null pointer). Any time a null pointer is dereferenced, a panic results. When you get a Data Access Exception, first check the DAR register; if the value is less than about 1000 the panic is probably the result of indirection through a null pointer. This is because most classes are no larger than about 1000 bytes and when an offset is added to a null pointer, the result is about 1000 or less. If the result is much larger, it’s probable that the location of a pointer has been trashed (as opposed to its contents) and the contents of an unknown location is being used as a pointer in your code.</p><p>A null pointer implies the possibility of a race condition with a shutdown or completion value. When called, a completion routine starts to free resources and if your driver is referencing these resources after the routine is called, it will probably get null pointers back.</p></li><li class="li"><p>If you get a panic in <code><!--a-->kalloc<!--/a--></code>, <code>kmem</code>, or <code><!--a-->IOMalloc<!--/a--></code>, it suggests that you’re using a freed pointer. Even if your driver code doesn’t show up in the backtrace, your driver could be the culprit. Using a freed pointer is likely to break the kernel’s internal data structures for allocation.</p></li><li class="li"><p>Panics can also be caused by accidentally scribbling on someone else’s memory. These “land mines” can be notoriously hard to debug; a backtrace doesn’t show you much, except that something bad has happened. If the panic is reproducible, however, you have a chance to track down the offending code by using a “probe” macro. A probe macro helps to bracket exactly <em>where</em> in the code the scribbling happened. By definition, a scribble is a byte that does not have the expected contents (because they were altered by some other code). By knowing where the panic occurred and where the byte last held its expected value, you know where to look for the scribbling code.</p><p>Often it’s the case that your driver is the offending scribbler. To find your offending code (if any), define a probe macro that tests whether a memory address (<code>A</code> in the example below) has the expected value (<code>N</code>). (Note that <code>A</code> is the address in the DAR register of the original scribble panic.) If <code>A</code> doesn’t have the expected value, then cause a panic right then and there:</p><div class="codesample"><table><tr><td scope="row"><pre>Uint32 N = 123;<span></span></pre></td></tr><tr><td scope="row"><pre>Uint32 *A;<span></span></pre></td></tr><tr><td scope="row"><pre>A = &amp;N;<span></span></pre></td></tr><tr><td scope="row"><pre>// ...<span></span></pre></td></tr><tr><td scope="row"><pre>#define PROBE() do {<span></span></pre></td></tr><tr><td scope="row"><pre>    if (A &amp;&amp; *A != N)<span></span></pre></td></tr><tr><td scope="row"><pre>        *(Uint32)0 = 0;<span></span></pre></td></tr><tr><td scope="row"><pre>    } while (0)<span></span></pre></td></tr></table></div><p>By putting the probe macro in every function where <code>A</code> and <code>N</code> appear, you can narrow down the location of the scribble. If your driver is not the one doing the scribbling, it still might be indirectly responsible because it could be causing other code to scribble. For example, your driver might be asking some other code to write in your address space; if it’s passed them the wrong address, it might result in data being scribbled on inside it.<a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_283"></a><a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_284"></a><a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_285"></a><a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_286"></a></p></li></ul><a name="//apple_ref/doc/uid/TP30000701-TPXREF110" title="Debugging System Hangs"></a><h3>Debugging System Hangs</h3><p><a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_287"></a><a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_288"></a><a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_289"></a>System hangs are, after kernel panics, the most serious condition caused by badly behaved kernel code. A hung system may not be completely unresponsive, but it is unusable because you cannot effectively click the mouse button or type a key. You can categorize system hangs, and their probable cause, by the behavior of the mouse cursor<a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_290"></a>.</p><ul class="spaceabove"><li class="li"><p><strong>Cursor doesn’t spin and won’t move</strong>. This symptom indicates that a primary interrupt is not being delivered. The mouse doesn’t even spin because that behavior is on a primary interrupt; its not spinning indicates that the system is in a very tight loop. What has probably happened is that a driver object has disabled an interrupt, causing code somewhere in the driver stack to go into an infinite loop. In other words, a piece of hardware has raised an interrupt but the driver that should handle it is not handling it and so the hardware keeps raising it. The driver has probably caused this “ghost” interrupt, but is unaware it has and so is not clearing it.</p></li><li class="li"><p><strong>Cursor spins but won’t move</strong>. This symptom indicates that a high-priority thread such as a timer is spinning.</p></li><li class="li"><p><strong>Cursor spins and moves, but nothing else</strong>. This symptom suggests that the USB thread is still scheduled, thus indicating a deadlock in some driver object that is not related to USB or HI.</p></li></ul><p>For system hangs with the first symptom—the cursor doesn’t spin and won’t move—your first aim should be to find out what caused the interrupt. Why is the hardware controlled by your driver raising the interrupt? If your driver is using a filter interrupt event source (IOFilterInterruptEventSource), you might want to investigate that, too. With a filter event source a driver can ignore interrupts that it thinks aren’t its responsibility. </p><p>With any system hang, you should launch <code>gdb<a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_291"></a></code> on the kernel, attach to the hung system and run the <code>showallstacks<a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_292"></a></code> macro. Scan the output for threads that are deadlocked against each other. Or, if it’s an unhandled primary interrupt that you suspect, find the running thread; if it is the one that took the interrupt, it is probably the thread that’s gone into an infinite loop. If the driver is in an infinite loop, you can set a breakpoint in a frame of the thread’s stack that is the possible culprit; when you continue and hit the breakpoint almost immediately, you know you’re in an infinite loop. You can single-step from there to find the problem.<a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_293"></a><a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_294"></a><a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_295"></a></p><a name="//apple_ref/doc/uid/TP30000701-TPXREF111" title="Debugging Boot Drivers"></a><h3>Debugging Boot Drivers</h3><p><a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_296"></a><a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_297"></a><a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_298"></a>The Mac OS X BootX booter<a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_299"></a> copies drivers for hardware required in the boot process into memory for the kernel’s boot-time loading code to load. Because boot drivers are already loaded by the time the system comes up, you do not have as much control over them as you do over non-boot drivers. In addition, a badly behaving boot driver can cause your system to become unusable until you are able to unload it. For these reasons, debugging techniques for boot drivers vary somewhat from those for other drivers.</p><p>The most important step you can take is to treat your boot driver as a non-boot driver while you are in the development phase. Remove the <code>OSBundleRequired</code> property from your driver’s <code>Info.plist</code> file and use the techniques described in this chapter to make sure the driver is performing all its functions correctly before you declare it to be a boot driver.</p><p>After you’ve thoroughly tested your driver, add the <code>OSBundleRequired</code> property to its <code>Info.plist</code> (see the document <span class="content_text"><a href="../../../../Darwin/Conceptual/KEXTConcept/KEXTConceptLoading/loading_kexts.html#//apple_ref/doc/uid/20002369" target="_top">Loading Kernel Extensions at Boot Time</a></span> to determine which value your driver should declare). This will cause the BootX booter to load your driver into memory during the boot process.</p><p>If your boot driver does have bugs you were unable to find before, you cannot use <code>gdb</code> to debug it because it is not possible to attach to a computer while it is booting. Instead, you must rely on <code>IOLog</code> output to find out what is happening. <code>IOLog</code> is synchronous when you perform a verbose boot so you can use <code>IOLog</code> statements throughout your boot driver’s code to track down the bugs. See <span class="content_text"><a href="DebuggingDrivers.html#//apple_ref/doc/uid/TP30000701-BAJHHHDA">“Using IOLog”</a></span> for more information on this function.</p><p>To perform a verbose boot, reboot holding down both the <code>Command</code> and <code>V</code> keys. To get even more detail from the I/O Kit, you can set a <code>boot-args</code> flag before rebooting. Assuming <code>root</code> privileges with the <code>sudo</code> command, type the following on the command line</p><div class="codesample"><table><tr><td scope="row"><pre>%sudo nvram boot-args="io=0xffff"<span></span></pre></td></tr><tr><td scope="row"><pre>Password:<span></span></pre></td></tr><tr><td scope="row"><pre>%shutdown -r now<span></span></pre></td></tr></table></div><p>Although this technique produces voluminous output, it can be difficult to examine because it scrolls off the screen during the boot process. If your boot driver does not prevent the system from completing the boot process, you can view the information in its entirety in the system log at <code>/var/log/system.log</code>.<a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_300"></a><a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_301"></a><a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_302"></a></p><a name="//apple_ref/doc/uid/TP30000701-TPXREF112" title="Logging"></a><h2>Logging</h2><p><a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_303"></a><a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_304"></a><a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_305"></a>Logging, the capture and display of information at certain points in the code, is useful in some situations as a debugging tool because it provides a linear record of what happens during the execution of driver code. This section describes the I/O Kit’s primary logging function, <code><!--a-->IOLog<!--/a--></code>, and discusses ways you can go about creating your own logging facility.</p><a name="//apple_ref/doc/uid/TP30000701-BAJHHHDA" title="Using IOLog"></a><h3>Using IOLog</h3><p>It is natural to rely on <code>printf</code> statements to display what’s going on in your application code during the debugging phase. For in-kernel drivers, the I/O Kit equivalent to the <code>printf</code> statement is the <code><a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_306"></a>IOLog</code> function, defined in <code>/System/Library/Frameworks/Kernel.framework/Headers/IOKit/IOLib.h</code>. Unfortunately, <code><!--a-->IOLog<!--/a--></code> is only marginally useful for debugging kernel-resident drivers.</p><p>Because it executes inside the kernel, <code><!--a-->IOLog<!--/a--></code> is necessarily resource-frugal. The message buffer is not large and if you use <code><!--a-->IOLog<!--/a--></code> to log I/O activity, for example, the older messages are likely to be overwritten by newer ones, erasing the information you need for debugging. In general, you cannot successfully use <code><!--a-->IOLog<!--/a--></code> in any tight loop in your driver’s code, whether they are I/O loops or unintentional loops caused by errors in the code. The only way to ensure you get all the information you need in such a situation is to allocate your own buffer and create your own logging facility to write to it (for more information on this technique, see <span class="content_text"><a href="DebuggingDrivers.html#//apple_ref/doc/uid/TP30000701-BAJBAIJI">“Custom Event Logging ”</a></span>).</p><p>If your driver is causing a panic, <code><!--a-->IOLog<!--/a--></code> will not help much in determining the cause. Because the <code><!--a-->IOLog<!--/a--></code> function is asynchronous, when the computer panics, the last <code><!--a-->IOLog<!--/a--></code> message is still waiting to be scheduled for output so you will miss the message containing information about the cause of the panic.</p><p>You cannot call <code><!--a-->IOLog<!--/a--></code> from an interrupt context. When you create an IOFilterInterruptEventSource object, you send it a filter function and an action function. You cannot use <code><!--a-->IOLog<!--/a--></code> in your filter routine because it runs at primary (hardware) interrupt time when very little of the system is available. You can, however, call <code><!--a-->IOLog<!--/a--></code> in your action routine because it runs on the work loop the event source is attached to. Note that when you create an IOInterruptEventSource object, you send it an action function that runs on the event source’s work loop, but no filter function. As with the action function for an IOFilterInterruptEventSource object, you can call <code><!--a-->IOLog<!--/a--></code> in the action function for an IOInterruptEventSource object.</p><p>Although the <code><!--a-->IOLog<!--/a--></code> function is not well-suited for use in the debugging process, it is useful for logging normal status and error messages. For example, the PhantomAudioDevice class (contained in the PhantomAudioDriver project at <code>/Developer/Examples/Kernel/IOKit/Audio/PhantomAudioDriver</code>) uses <code><!--a-->IOLog<!--/a--></code> to log status in several of its methods. <span class="content_text"><a href="DebuggingDrivers.html#//apple_ref/doc/uid/TP30000701-CIHDADAC">Listing 7-12</a></span> shows partial listings of PhantomAudioDevice’s <code>createAudioEngines</code> and <code>volumeChanged</code> methods.</p><a name="//apple_ref/doc/uid/TP30000701-CIHDADAC" title="Listing 7-12Using IOLog in PhantomAudioDevice methods"></a><p class="codesample"><strong>Listing 7-12&nbsp;&nbsp;</strong>Using <code>IOLog</code> in PhantomAudioDevice methods</p><div class="codesample"><table><tr><td scope="row"><pre>bool PhantomAudioDevice::createAudioEngines()<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    ...<span></span></pre></td></tr><tr><td scope="row"><pre>    IOLog("PhantomAudioDevice[%p]::createAudioEngines()\n", this);<span></span></pre></td></tr><tr><td scope="row"><pre>    audioEngineArray = OSDynamicCast(OSArray,<span></span></pre></td></tr><tr><td scope="row"><pre>                                getProperty(AUDIO_ENGINES_KEY));<span></span></pre></td></tr><tr><td scope="row"><pre>    if (audioEngineArray) {<span></span></pre></td></tr><tr><td scope="row"><pre>        /* Create new audio engine with AudioEngine array in personality. */<span></span></pre></td></tr><tr><td scope="row"><pre>        ...<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    else {<span></span></pre></td></tr><tr><td scope="row"><pre>        IOLog("PhantomAudioDevice[%p]::createAudioEngines() - Error: no<span></span></pre></td></tr><tr><td scope="row"><pre>                            AudioEngine array in personality.\n", this);<span></span></pre></td></tr><tr><td scope="row"><pre>        goto Done;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    ...<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>IOReturn PhantomAudioDevice::volumeChanged(IOAudioControl *volumeControl,<span></span></pre></td></tr><tr><td scope="row"><pre>                                        SInt32 oldValue, SInt32 newValue)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    IOLog("PhantomAudioDevice[%p]::volumeChanged(%p, %ld, %ld)\n", this,<span></span></pre></td></tr><tr><td scope="row"><pre>                                    volumeControl, oldValue, newValue);<span></span></pre></td></tr><tr><td scope="row"><pre>...<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP30000701-BAJBAIJI" title="Custom Event Logging "></a><h3>Custom Event Logging </h3><a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_307"></a><a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_308"></a><p><a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_309"></a>You can pepper your code with <code><!--a-->IOLog<!--/a--></code> or <code><!--a-->printf<!--/a--></code> calls as a debugging technique, but, as noted in the previous section (<span class="content_text"><a href="DebuggingDrivers.html#//apple_ref/doc/uid/TP30000701-BAJHHHDA">“Using IOLog”</a></span>), this approach has its limitations. Some drivers are especially sensitive to any impact on performance, and require more reliable and finer-grained logging data. If your driver falls into this category, you can create your own logging facility.</p><p>There are various ways to implement a custom debug-logging solution that avoids the drawbacks of <code><!--a-->IOLog<!--/a--></code>. You would need to allocate your own buffer for you log entries, implement functions and macros for writing those entries to the buffer, and devise some means for examining the contents of the buffer.</p><p>For purposes of illustration, this section looks at the logging feature of the AppleGMACEthernet driver. You can find the source code for this driver (including the logging tools) in the Darwin source code for Mac OS X version 10.2.7 and above, available at <span class="content_text"><a href="http://www.opensource.apple.com/darwinsource/index.html" target="_blank">http://www.opensource.apple.com/darwinsource/index.html</a></span>. To find the source code, select a version of Mac OS X equal to or greater than v10.2.7 and click Source (choose the source for the PPC version, if there's a choice). This displays a new page, which lists the open source projects available for the version of Mac OS X you've chosen. Scroll down to AppleGMACEthernet and click it to view the source. Be prepared to supply your ADC member name and password.</p><p>The AppleGMACEthernet driver implements a kernel-resident logging infrastructure as well as a user-space tool to print the formatted contents of a log buffer. The tool used by this driver prints a report to the standard output that begins with header information followed by time-stamped log entries. You can redirect the output to a file and then add comments to the entries in the file. <span class="content_text"><a href="DebuggingDrivers.html#//apple_ref/doc/uid/TP30000701-CJBHHIHC">Listing 7-13</a></span> shows the first several seconds of the driver’s life (along with comments).</p><a name="//apple_ref/doc/uid/TP30000701-CJBHHIHC" title="Listing 7-13Sample output of a custom event log"></a><p class="codesample"><strong>Listing 7-13&nbsp;&nbsp;</strong>Sample output of a custom event log</p><div class="codesample"><table><tr><td scope="row"><pre> 0  1376a020  13779fe0  1376a020    [ffffffe0]<span></span></pre></td></tr><tr><td scope="row"><pre>  27   38e9000         0         1<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>  20:   39  291159         0         0  eNet<span></span></pre></td></tr><tr><td scope="row"><pre>  30:   39  291266   19aec90   181c200  Strt<span></span></pre></td></tr><tr><td scope="row"><pre>  40:   39  293857   19aec90   18a4000  KeyL<span></span></pre></td></tr><tr><td scope="row"><pre>  50:   39  293899       100       100  =txq<span></span></pre></td></tr><tr><td scope="row"><pre>  60:   39  293903       100       100  =txe<span></span></pre></td></tr><tr><td scope="row"><pre>  70:   39  293907        40        40  =rxe<span></span></pre></td></tr><tr><td scope="row"><pre>  80:   39  293908       100   1000040  parm<span></span></pre></td></tr><tr><td scope="row"><pre>  90:   39  307103      1000  135f0000  =TxR<span></span></pre></td></tr><tr><td scope="row"><pre>  a0:   39  307111       400   198b000  =RxR<span></span></pre></td></tr><tr><td scope="row"><pre>  b0:   39  307119   17f4400   19c8f00  arys<span></span></pre></td></tr><tr><td scope="row"><pre>  c0:   39  307120   19aec90         0  AttI<span></span></pre></td></tr><tr><td scope="row"><pre>  d0:   39  307232   19aec90         0  RwPM<span></span></pre></td></tr><tr><td scope="row"><pre>  e0:   39  307247   19aec90         2  mx4d<span></span></pre></td></tr><tr><td scope="row"><pre>  f0:   39  307249   19aec90         2  ip4d<span></span></pre></td></tr><tr><td scope="row"><pre> 100:   39  307316   19aec90         1  Pwr!<span></span></pre></td></tr><tr><td scope="row"><pre> 110:   39  307436   19aec90   198e400  cfig<span></span></pre></td></tr><tr><td scope="row"><pre> 120:   39  307465   19aec90         0  AttD<span></span></pre></td></tr><tr><td scope="row"><pre> 130:   39  307598   19aec90         0  powr<span></span></pre></td></tr><tr><td scope="row"><pre> 140:   39  307599   19aec90         0  RegS<span></span></pre></td></tr><tr><td scope="row"><pre> 150:   39  310366   19aec90         0  Exit    end of start method<span></span></pre></td></tr><tr><td scope="row"><pre> 160:   46  944895   191d400   198e400  NetE<span></span></pre></td></tr><tr><td scope="row"><pre> 170:   46  944899   191d400         0  Wake    wake up ethernet cell<span></span></pre></td></tr><tr><td scope="row"><pre> 180:   46  944938         0         0  +Clk<span></span></pre></td></tr><tr><td scope="row"><pre> 190:   46  945093   199a5c0  1ee21000  Adrs<span></span></pre></td></tr><tr><td scope="row"><pre> 1a0:   46  945096   19c8f00   198b000  IRxR<span></span></pre></td></tr><tr><td scope="row"><pre> 1b0:   46  946111   191d400  135f0000  ITxR<span></span></pre></td></tr><tr><td scope="row"><pre> 1c0:   46  946127         3      1010  wReg<span></span></pre></td></tr><tr><td scope="row"><pre> 1d0:   46  946135         0        ff  ChpI    chip initialization<span></span></pre></td></tr><tr><td scope="row"><pre> 1e0:   46  946136         4      9050<span></span></pre></td></tr></table></div><p>The report header consists of two lines. The first line identifies any flag in effect and gives the start, ending, and current addresses of the log buffer. The second line indicates the period (in seconds) spanned by the log entries, shows the physical address of the buffer, and tallies the numbers of alerts and buffer wrap-arounds since the driver started up.</p><p>Each log entry is identified by an offset (in hexadecimal) from the start of the buffer and a two-part time-stamp. The first part is the time in seconds since the driver started executing and the second is the time in microseconds (actually nanoseconds right-shifted by 10 to closely approximate microseconds). The final column contains four-character codes with special significance to the AppleGMACEthernet driver. The intermediate two columns show parameters whose value depends on the context indicated by the code.</p><p>The AppleGMACEthernet driver (in the UniEnet class) implements logging in a way that minimizes its effect on performance. The major steps it undertakes are the following:</p><ul class="spaceabove"><li class="li"><p>It allocates a 64 kilobyte wrap-around buffer to hold the logging data and defines global pointers to that buffer. </p></li><li class="li"><p>It implements two low-level functions to log events to the buffer, one for general events and the other for alerts; alerts are supersets of events which first perform the log, then the <code>IOLog</code>, and then whatever you customize it to do.</p></li><li class="li"><p>For convenience, it also defines macros built on these functions. </p></li><li class="li"><p>It inserts macro calls at critical points in the code. </p></li><li class="li"><p>It implements a user-space tool to format and print the contents of the log buffer. </p></li><li class="li"><p>It implements a user client to send the buffer data to the tool.</p></li></ul><p><span class="content_text"><a href="DebuggingDrivers.html#//apple_ref/doc/uid/TP30000701-CJBIICFH">Listing 7-14</a></span> shows the definitions of the event-log and alert functions and macros.</p><a name="//apple_ref/doc/uid/TP30000701-CJBIICFH" title="Listing 7-14Definition of logging macros and functions"></a><p class="codesample"><strong>Listing 7-14&nbsp;&nbsp;</strong>Definition of logging macros and functions</p><div class="codesample"><table><tr><td scope="row"><pre>#if USE_ELG /* (( */<span></span></pre></td></tr><tr><td scope="row"><pre>#define ELG(A,B,ASCI,STRING)    EvLog( (UInt32)(A), (UInt32)(B),<span></span></pre></td></tr><tr><td scope="row"><pre>                                        (UInt32)(ASCI), STRING )<span></span></pre></td></tr><tr><td scope="row"><pre>#define ALERT(A,B,ASCI,STRING)  Alert( (UInt32)(A), (UInt32)(B),<span></span></pre></td></tr><tr><td scope="row"><pre>                                        (UInt32)(ASCI), STRING )<span></span></pre></td></tr><tr><td scope="row"><pre>    void EvLog( UInt32 a, UInt32 b, UInt32 ascii, char* str );<span></span></pre></td></tr><tr><td scope="row"><pre>    void Alert( UInt32 a, UInt32 b, UInt32 ascii, char* str );<span></span></pre></td></tr><tr><td scope="row"><pre>#else /* ) not USE_ELG: (   */<span></span></pre></td></tr><tr><td scope="row"><pre>#define ELG(A,B,ASCI,S)<span></span></pre></td></tr><tr><td scope="row"><pre>#define ALERT(A,B,ASCI,STRING)  IOLog( "UniNEnet: %8x %8x " STRING "\n",<span></span></pre></td></tr><tr><td scope="row"><pre>                                (unsigned int)(A), (unsigned int)(B) )<span></span></pre></td></tr><tr><td scope="row"><pre>#endif /* USE_ELG )) */<span></span></pre></td></tr></table></div><p>If you’re curious, see the UniEnet class source for the implementations of <code><!--a-->EvLog<!--/a--></code> and <code><a href="../../../../Carbon/Reference/Dialog_Manager/Reference/reference.html#//apple_ref/doc/c_ref/Alert" target="_top">Alert</a></code>.</p><p>The AppleGMACEthernet driver calls the <code><!--a-->ELG<!--/a--></code> and <code><!--a-->ALERT<!--/a--></code> macros at appropriate points in the source code. In the example in <span class="content_text"><a href="DebuggingDrivers.html#//apple_ref/doc/uid/TP30000701-CJBEAGCC">Listing 7-15</a></span>, the <code><!--a-->ELG<!--/a--></code> macro is called just after the <code><!--a-->configureInterface<!--/a--></code> member function is invoked; the event code is <code><!--a-->‘cfig’<!--/a--></code> and the parameters are the addresses of the current thread and the IONetworkInterface object passed in. (The final string parameter is printed in alerts and via <code><!--a-->IOLog<!--/a--></code> if the custom debugging feature is disabled.)</p><a name="//apple_ref/doc/uid/TP30000701-CJBEAGCC" title="Listing 7-15Calling the logging macro"></a><p class="codesample"><strong>Listing 7-15&nbsp;&nbsp;</strong>Calling the logging macro</p><div class="codesample"><table><tr><td scope="row"><pre>bool UniNEnet::configureInterface( IONetworkInterface *netif ) {<span></span></pre></td></tr><tr><td scope="row"><pre>                                    IONetworkData *nd;<span></span></pre></td></tr><tr><td scope="row"><pre>    ELG( IOThreadSelf(), netif, 'cfig', "configureInterface" );<span></span></pre></td></tr><tr><td scope="row"><pre> // ...<span></span></pre></td></tr></table></div><p>The report shown in <span class="content_text"><a href="DebuggingDrivers.html#//apple_ref/doc/uid/TP30000701-CJBHHIHC">Listing 7-13</a></span> includes a log entry from this macro call, illustrating how it might appear (it’s the sixteenth one).</p><p>Although it might be convenient to have a tool that nicely prints the contents of the log buffer, there is considerable time and effort involved in developing this tool and the user-client object that must feed it the logging data. Instead of a user-space tool, you can examine the contents of the log buffer in <code>gdb</code>. The contents of the buffer, however, will require more effort on your part to interpret.<a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_310"></a><a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_311"></a><a name="//apple_ref/doc/uid/TP30000701-DontLinkElementID_312"></a></p>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../InternationalizingDrivers/InternationalizingDrivers.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../DeployingDrivers/DeployingDrivers.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2002, 2007 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2007-03-06<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/DeviceDrivers/Conceptual/WritingDeviceDriver/DebuggingDrivers/DebuggingDrivers.html%3Fid%3DTP30000694-2.13&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/DeviceDrivers/Conceptual/WritingDeviceDriver/DebuggingDrivers/DebuggingDrivers.html%3Fid%3DTP30000694-2.13&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/DeviceDrivers/Conceptual/WritingDeviceDriver/DebuggingDrivers/DebuggingDrivers.html%3Fid%3DTP30000694-2.13&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>