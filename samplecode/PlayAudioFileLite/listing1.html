<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>PlayAudioFileLite - /main.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxMusicAudio-date.html">Audio</a> &gt; <A HREF="javascript:location.replace('index.html');">PlayAudioFileLite</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Not Recommended Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>The information in this document is <strong>Not Recommended</strong> and should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/MusicAudio/index.html" target="_blank">Reference Library > Audio</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">PlayAudioFileLite</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/main.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/main.c</option></select>
				</p>
				</form>
				<p><strong><a href="PlayAudioFileLite.zip">Download Sample</a></strong> (&#147;PlayAudioFileLite.zip&#148;, 13.8K)<BR>
<strong><a href="PlayAudioFileLite.dmg">Download Sample</a></strong> (&#147;PlayAudioFileLite.dmg&#148;, 72.4K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*
*  File:    main.c
* 
*  Contains:  Demonstrates how to play an audio file using the Default Output Audio Unit
*  
*  Version:  1.1
* 
*  Created:  2004-01-23
* 
*  Disclaimer:  IMPORTANT:  This Apple software is supplied to you by Apple Computer, Inc. (&quot;Apple&quot;) in 
*        consideration of your agreement to the following terms, and your use, installation, modification 
*        or redistribution of this Apple software constitutes acceptance of these terms.  If you do 
*        not agree with these terms, please do not use, install, modify or redistribute this Apple 
*        software.
*
*        In consideration of your agreement to abide by the following terms, and subject to these terms, 
*        Apple grants you a personal, non-exclusive license, under Apple's copyrights in this 
*        original Apple software (the &quot;Apple Software&quot;), to use, reproduce, modify and redistribute the 
*        Apple Software, with or without modifications, in source and/or binary forms; provided that if you 
*        redistribute the Apple Software in its entirety and without modifications, you must retain this 
*        notice and the following text and disclaimers in all such redistributions of the Apple Software. 
*        Neither the name, trademarks, service marks or logos of Apple Computer, Inc. may be used to 
*        endorse or promote products derived from the Apple Software without specific prior written 
*        permission from Apple.  Except as expressly stated in this notice, no other rights or 
*        licenses, express or implied, are granted by Apple herein, including but not limited to any 
*        patent rights that may be infringed by your derivative works or by other works in which the 
*        Apple Software may be incorporated.
*
*        The Apple Software is provided by Apple on an &quot;AS IS&quot; basis.  APPLE MAKES NO WARRANTIES, EXPRESS OR 
*        IMPLIED, INCLUDING WITHOUT LIMITATION THE IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY 
*        AND FITNESS FOR A PARTICULAR PURPOSE, REGARDING THE APPLE SOFTWARE OR ITS USE AND OPERATION ALONE 
*        OR IN COMBINATION WITH YOUR PRODUCTS.
*
*        IN NO EVENT SHALL APPLE BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL OR CONSEQUENTIAL 
*        DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS 
*        OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) ARISING IN ANY WAY OUT OF THE USE, 
*        REPRODUCTION, MODIFICATION AND/OR DISTRIBUTION OF THE APPLE SOFTWARE, HOWEVER CAUSED AND WHETHER 
*        UNDER THEORY OF CONTRACT, TORT (INCLUDING NEGLIGENCE), STRICT LIABILITY OR OTHERWISE, EVEN 
*        IF APPLE HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*
*/
#include &lt;CoreServices/CoreServices.h&gt;
#include &lt;AudioUnit/AudioUnit.h&gt;
#include &lt;AudioToolbox/AudioToolbox.h&gt;

#include &lt;unistd.h&gt; //for usleep

AudioConverterRef converter;
void *gSourceBuffer;

AudioFileID *gSourceAudioFileID;
UInt64 gTotalPacketCount=0;
UInt64 gFileByteCount =0;
UInt32 gMaxPacketSize =0;
UInt64 gPacketOffset=0;

Boolean gIsPlaying = FALSE;


#define checkStatus( err) \
    if(err) {\
        printf(&quot;Error: %s -&gt;  %s: %d\n&quot;, (char *)&amp;err,__FILE__, __LINE__);\
        fflush(stdout);\
        return err; \
    }         
 
                                       
void PrintStreamDesc (AudioStreamBasicDescription *inDesc)
{
  if (!inDesc) {
    printf (&quot;Can't print a NULL desc!\n&quot;);
    return;
  }
  
  printf (&quot;- - - - - - - - - - - - - - - - - - - -\n&quot;);
  printf (&quot;  Sample Rate:%f\n&quot;, inDesc-&gt;mSampleRate);
  printf (&quot;  Format ID:%s\n&quot;, (char*)&amp;inDesc-&gt;mFormatID);
  printf (&quot;  Format Flags:%lX\n&quot;, inDesc-&gt;mFormatFlags);
  printf (&quot;  Bytes per Packet:%ld\n&quot;, inDesc-&gt;mBytesPerPacket);
  printf (&quot;  Frames per Packet:%ld\n&quot;, inDesc-&gt;mFramesPerPacket);
  printf (&quot;  Bytes per Frame:%ld\n&quot;, inDesc-&gt;mBytesPerFrame);
  printf (&quot;  Channels per Frame:%ld\n&quot;, inDesc-&gt;mChannelsPerFrame);
  printf (&quot;  Bits per Channel:%ld\n&quot;, inDesc-&gt;mBitsPerChannel);
  printf (&quot;- - - - - - - - - - - - - - - - - - - -\n&quot;);
}


OSStatus setupAudioUnit(AudioUnit *theOutputUnit){
        OSStatus err;

        //An Audio Unit is a OS component
        //The component description must be setup, then used to 
        //initialize an AudioUnit
  ComponentDescription desc;  


        desc.componentType = kAudioUnitType_Output;
        desc.componentSubType = kAudioUnitSubType_DefaultOutput;
        desc.componentManufacturer = kAudioUnitManufacturer_Apple;
  desc.componentFlags = 0;
  desc.componentFlagsMask = 0;
  
                  
  Component comp = FindNextComponent(NULL, &amp;desc);  //Finds an component that meets the desc spec's
    if (comp == NULL) exit (-1);
    
  err = OpenAComponent(comp, theOutputUnit);  //gains access to the services provided by the component
    if (err)  exit (-1);

  // Initialize AudioUnit 
  verify_noerr(AudioUnitInitialize(*theOutputUnit));


        return err;


}




OSStatus MatchAUFormats (AudioUnit *theUnit,AudioStreamBasicDescription *theDesc ,UInt32 theInputBus)
{
  UInt32 size = sizeof (AudioStreamBasicDescription);
        memset(theDesc, 0, size);
        Boolean             outWritable;                            
        
        //Gets the size of the Stream Format Property and if it is writable
        AudioUnitGetPropertyInfo(*theUnit,  
                                    kAudioUnitProperty_StreamFormat,
                                    kAudioUnitScope_Output, 
                                    0, 
                                    &amp;size, 
                                    &amp;outWritable);
        //Get the current stream format of the output
  OSStatus result = AudioUnitGetProperty (*theUnit,
              kAudioUnitProperty_StreamFormat,
              kAudioUnitScope_Output,
              0,
              theDesc,
              &amp;size);
  checkStatus(result);  
        //Set the stream format of the output to match the input
  result = AudioUnitSetProperty (*theUnit,
              kAudioUnitProperty_StreamFormat,
              kAudioUnitScope_Input,
              theInputBus,
              theDesc,
              size);
                                                        
  
  return result;
}


OSStatus MakeAUConverter( AudioFileID *musicFileID,AudioConverterRef *conv,AudioStreamBasicDescription *inASBD, AudioStreamBasicDescription *outASBD){
    OSStatus err;
    
    
    //To Do: Add some error checking to make sure the formats are valid
    
    err = AudioConverterNew( inASBD,outASBD , conv);
    checkStatus(err);
    
    //Get Magic Cookie info(if exists)  and pass it to converter
    //Not all files have magic cooke information so this step might
    //not be necessary depending on your audio file type (AIFF, MP3, etc.)
    UInt32  magicCookieSize = 0;
    err = AudioFileGetPropertyInfo(  *musicFileID,
                                        kAudioFilePropertyMagicCookieData,
                                        &amp;magicCookieSize,
                                        NULL); 
  
     if (err == noErr)
    {
        void   *magicCookie = calloc (1, magicCookieSize);
        if (magicCookie) 
        {
            //Get Magic Cookie data from Audio File
            err = AudioFileGetProperty (  *musicFileID, 
                                            kAudioFilePropertyMagicCookieData, 
                                            &amp;magicCookieSize, 
                                            magicCookie);       
                                        
            // Give the AudioConverter the magic cookie decompression params if there are any
            if (err == noErr)
            {
                err = AudioConverterSetProperty(  *conv, 
                                                    kAudioConverterDecompressionMagicCookie, 
                                                    magicCookieSize, 
                                                    magicCookie);
            }
             err = noErr;
            if (magicCookie) free(magicCookie);
        }
    }else //this is OK because some audio data doesn't need magic cookie data
        err = noErr;

    

    return err;
}

OSStatus getFileInfo(FSRef *fileRef, AudioFileID *fileID,  AudioStreamBasicDescription *fileASBD, const char *fileName){
    OSStatus err= noErr;
    UInt32 size;
    
    
     FSPathMakeRef ((const UInt8 *)fileName, fileRef, 0); //Obtain filesystem reference to the file
     err = AudioFileOpen(fileRef, fsRdPerm,0,fileID);   //Obtain AudioFileID
     
     
    gSourceAudioFileID = fileID;  //gloabal pointer to AudioFileID
     
     size = sizeof(AudioStreamBasicDescription);
     memset(fileASBD, 0, size);
     //Fetch the AudioStreamBasicDescription of the audio file.
     err = AudioFileGetProperty(*fileID, kAudioFilePropertyDataFormat, &amp;size, fileASBD); 
     checkStatus(err);

    printf(&quot;File format is:\n&quot;);
    PrintStreamDesc(fileASBD);
  
    //Get total packet count, byte count, and max packet size
    //Theses values will be used later when grabbing data from the audio file
  
    size = sizeof(gTotalPacketCount);
    err = AudioFileGetProperty(*fileID, kAudioFilePropertyAudioDataPacketCount, &amp;size, &amp;gTotalPacketCount);
    checkStatus(err);
    
    size = sizeof(gFileByteCount);
    err = AudioFileGetProperty(*fileID, kAudioFilePropertyAudioDataByteCount, &amp;size, &amp;gFileByteCount);
    checkStatus(err);
    
    size = sizeof(gMaxPacketSize);
    err = AudioFileGetProperty(*fileID, kAudioFilePropertyMaximumPacketSize, &amp;size, &amp;gMaxPacketSize);
    checkStatus(err);

    return err;
}




OSStatus ACComplexInputProc   (  AudioConverterRef                           inAudioConverter,
                                        UInt32                                      *ioNumberDataPackets,
                                        AudioBufferList                                     *ioData,
                                        AudioStreamPacketDescription  **outDataPacketDescription,
                                        void*                                               inUserData)
{
    OSStatus    err = noErr;
    
    
        //appGlobalsPtr    globals = (appGlobalsPtr) inUserData;
    UInt32          bytesReturned = 0;
    
    // initialize in case of failure
    ioData-&gt;mBuffers[0].mData = NULL;      
    ioData-&gt;mBuffers[0].mDataByteSize = 0;

    // if there are not enough packets to satisfy request, then read what's left
    if (gPacketOffset + *ioNumberDataPackets &gt; gTotalPacketCount)
        *ioNumberDataPackets = gTotalPacketCount - gPacketOffset;
            
    // do nothing if there are no packets available
    if (*ioNumberDataPackets)
    {
        if (gSourceBuffer != NULL) {
            free(gSourceBuffer);
            gSourceBuffer = NULL;
        }
        
        gSourceBuffer = (void *) calloc (1, *ioNumberDataPackets * gMaxPacketSize);        
        
        //read the amount of data needed(ioNumberDataPackets) from AudioFile
        err = AudioFileReadPackets (*gSourceAudioFileID, false, &amp;bytesReturned, NULL, gPacketOffset, 
                                    ioNumberDataPackets, gSourceBuffer);
        
        if(err){
              checkStatus(err);
              gIsPlaying =FALSE;   //end of data reached;
    
        }  
        
        gPacketOffset += *ioNumberDataPackets;  // keep track of where we want to read from next time
        
        ioData-&gt;mBuffers[0].mData = gSourceBuffer;    // tell the Audio Converter where it's source data is
        ioData-&gt;mBuffers[0].mDataByteSize = bytesReturned;    // tell the Audio Converter how much source data there is
    }  
    else
    {
        // there aren't any more packets to read at this time
        ioData-&gt;mBuffers[0].mData = NULL;      
        ioData-&gt;mBuffers[0].mDataByteSize = 0;
        gIsPlaying=FALSE;
    }  

    // it's not an error if we just read the remainder of the file
    if (err == eofErr &amp;&amp; *ioNumberDataPackets)
        err = noErr;
    
    
    
    return err;   

}


OSStatus fileRenderProc(void             *inRefCon, 
                                                                        AudioUnitRenderActionFlags    *inActionFlags,
                                                                        const AudioTimeStamp       *inTimeStamp, 
                                                                        UInt32                                  inBusNumber,
                                                                        UInt32                                  inNumFrames, 
                                                                        AudioBufferList                         *ioData)
{
    OSStatus err= noErr;
    void *inInputDataProcUserData=NULL;
    AudioStreamPacketDescription* outPacketDescription =NULL;
    err = AudioConverterFillComplexBuffer(converter, ACComplexInputProc ,inInputDataProcUserData , &amp;inNumFrames, ioData, outPacketDescription);

    /*Parameters for AudioConverterFillComplexBuffer()

    converter - the converter being used

    ACComplexInputProc() - input procedure to supply data to the Audio Converter

    inInputDataProcUserData - Used to hold any data that needs to be passed on.  Not needed in this example.
    
    inNumFrames - The amount of requested data.  On output, this
    number is the amount actually received.

    ioData - Buffer of the converted data recieved on return
    
    outPacketDescription - contains the format of the returned data.  Not used in this example.
    */

    checkStatus(err);

    return err;
}




OSStatus setupCallbacks(AudioUnit *theOutputUnit, AURenderCallbackStruct *renderCallback){  
OSStatus err= noErr;

    memset(renderCallback, 0, sizeof(AURenderCallbackStruct));
    
    renderCallback-&gt;inputProc = fileRenderProc;
    renderCallback-&gt;inputProcRefCon =0;
    
    //Sets the callback for the Audio Unit 
    err = AudioUnitSetProperty (*theOutputUnit, 
                            kAudioUnitProperty_SetRenderCallback, 
                            kAudioUnitScope_Input, 
                            0,
                            renderCallback, 
                            sizeof(AURenderCallbackStruct));

    checkStatus(err);

    return err;
}

void CleanUp(AudioUnit *theOutputUnit,AudioFileID *fileID){
        printf(&quot;finished playing\n&quot;);

        //Cleaning anything allocated.
        
        AudioFileClose(*fileID);
        
        if (gSourceBuffer != NULL) {
            free(gSourceBuffer);
            gSourceBuffer = NULL;
        }
        
        AudioConverterDispose(converter);
        AudioOutputUnitStop(*theOutputUnit);//you must stop the audio unit
        AudioUnitUninitialize (*theOutputUnit);
        CloseComponent(*theOutputUnit);
}

int main (int argc, const char * argv[]) {
    
    AudioUnit theOutputUnit;
    AURenderCallbackStruct  renderCallback;
    OSStatus err = noErr;
    
    AudioStreamBasicDescription fileASBD, outputASBD;
    AudioFileID musicFileID;
    FSRef fileRef;
    char *fileName =&quot;/System/Library/Sounds/Submarine.aiff&quot;;  //give full path of any properly formatted audio file
  
    if(argc == 2)
        fileName = (char *)argv[1];
        
    
    err = setupAudioUnit(&amp;theOutputUnit);
    checkStatus(err);    
        
    err = MatchAUFormats(&amp;theOutputUnit,&amp;outputASBD, 0); //&quot;0&quot; is the output bus, use &quot;1&quot; for the input bus
    checkStatus(err);
    
    err = getFileInfo(&amp;fileRef, &amp;musicFileID, &amp;fileASBD, fileName);
    checkStatus(err);    
    
    err = MakeAUConverter(&amp;musicFileID, &amp;converter,&amp;fileASBD, &amp;outputASBD );
    checkStatus(err);
    
    err = setupCallbacks(&amp;theOutputUnit, &amp;renderCallback);
    checkStatus(err);
    
    printf(&quot;\n\nOutput format of Audio is:\n&quot;);
    PrintStreamDesc(&amp;outputASBD);
    err =AudioOutputUnitStart(theOutputUnit);
    
    checkStatus(err);
    printf(&quot;\n\nPlay has started\n&quot;);
    
    gIsPlaying=TRUE;
    while (gIsPlaying) {
    usleep (250000);  //check every 1/4 of a second to see if audio is done playing
    }  

    
    CleanUp(&amp;theOutputUnit, &amp;musicFileID);
  
     
    return 0;
}
</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/PlayAudioFileLite/listing1.html%3Fid%3DDTS10000415-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/PlayAudioFileLite/listing1.html%3Fid%3DDTS10000415-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/PlayAudioFileLite/listing1.html%3Fid%3DDTS10000415-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>