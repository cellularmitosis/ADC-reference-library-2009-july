<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"			"http://www.w3.org/TR/REC-html40/loose.dtd"><html><head><LINK REL="stylesheet" HREF="../../adcstyle.css" TYPE="text/css"><LINK REL="stylesheet" HREF="../../style.css" TYPE="text/css"><title>Technical Note PT26: MPW 2.0.2 Bugs</title><meta name="categories" content="Platforms and Tools"><meta name="week-posted" content="Aug 1, 1988 - Aug 5, 1988"><LINK REL="stylesheet" HREF="../../css/adcstyle.css" TYPE="text/css"><script language="JavaScript" type="text/javascript" src="../../js/adc.js"></script></HEAD><BODY BGCOLOR="#FFFFFF"><a name="//apple_ref/doc/uid/DTS10002680" title="MPW 2.0.2 Bugs"></a><a name="top"></A><!-- top_of_header_marker_comment --><!-- begin_header_information --><!--#include virtual="/adcnavbar" --><p><a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../technicalnotes/index.html">Technical Notes</a> &gt; <a href="../../technicalnotes/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../technicalnotes/LegacyTechnologies/idxTools-date.html">Tools</a> &gt; </p><div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/Java/idxTools-date.html" target="_blank">Reference Library > Tools</a></li>
	</ul>
</div>




</div></div></div><!-- end_header_information --><!-- bottom_of_header_marker_comment --><!-- top_of_titles_marker_comment --><CENTER><table width="600" cellpadding="0" cellspacing="0" border="0">
<tr><td align="left" scope="row">
<h1>
<div id="pagehead">Technical Note PT26</div>
<div id="pageheadsub">MPW 2.0.2 Bugs</div>
</h1>
</td></tr></table></CENTER><!-- bottom_of_titles_marker_comment --><CENTER><TABLE BORDER=0 CELLSPACING=1 WIDTH=600><TR><td align="left"><!-- begin_header_box --><table width="600" cellpadding="0" cellspacing="0" border="0">    <tr>        <td width=300 valign="top" align=left scope="row">            <table border="0" width="300" cellpadding="0" cellspacing="0">			<tr>                        <td width=300 align=left> <img src="images/tnmenutop.gif" alt="" align="bottom" width=300 height=7></td>                </tr>                <tr bgcolor="#e6e6e6">                    <td background="images/tnmenubody.gif" width=300 align=left>                                         <span id="menutitle">                            CONTENTS                             <br>                            <br>                        </span>                    </td>                </tr>                <tr bgcolor="#e6e6e6">                    <td background="images/tnmenubody.gif" width=300 align=left>					<!-- begin_toc -->										<p id="menutext"><A HREF="#Section1">Introduction</A><BR><BR><A HREF="#Section2">C Language</A><BR><BR><A HREF="#Section3">Pascal Language</A><BR><BR><A HREF="#Section4">Assembly Language</A><BR><BR><A HREF="#Section5">Interface Libraries</A><BR><BR><A HREF="#References">References</A><BR><BR><A HREF="#Downloads">Downloadables</A></P>                   <!-- end_toc -->                  </td>                </tr>                <tr>                    <td width=300 align=left scope="row">                        <img src="images/tnmenubottom.gif" alt="" width=300 height=16>                    </td>                </tr>            </table>        </td>        <td width=300 valign="top" align=left><!-- begin_intro_text --><p id="introtext">This Technical Note describes latest information about bugs or unexpected"features" in the MPW C, Pascal, and Assembler products and the Toolbox and OSInterface Libraries.  We intend this Note to be a complete list of all knownbugs in these products, which will be updated as old bugs are fixed, or newones appear.  If you have encountered a bug or unexpected feature which is notdescribed here, be sure to let us know.  Specific code examples are useful.</p><!-- end_intro_text --><!-- begin_date --><h3 align=center>[Aug 01 1988]</h3><!-- end_date -->                </TD>             </TR>          </TABLE>          <!-- end_table_box --> <BR><BR>          <hr width=500 align=center>          <BR><BR>          <!-- begin_content --><a name=Section1></A><h2>Introduction</h2><p>The bugs described in the October 1 revision of this Note will be fixed in the3.0 release of MPW scheduled for Fall 1988.</p><a name="Section2"></a> <P><A HREF="#top">Back to top</A></p><h2>C Language</h2><p>The following information applies to the C compiler and its associatedlibraries shipped with the 2.0.2 version of MPW.</p><ol type="1" start="1">	<li>A series of bugs involving floating point array elements and the <code>+=</code>, <code>*=,</code> and <code>= </code>operators.  A similar bug was reported as fixed in MPW 2.0.2, unfortunately the fix did not apply to array elements. This bug ONLY occurs when using SANE in combination with <code>float</code> or <code>double</code> variables, it does not occur if the <code>-mc68881</code> compiler option is specified or if <code>extended</code> variables are used.  The following fragment illustrates the bugs:</li></ol><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>    main()    {        double x[2],y;  /* Also fails if x,y are declared float                    but succeeds if declared extended */        x[0] = 0.5;        y = 5.0;        x[0] += 2.0*y;        printf(&quot;x[0] = %f\n&quot;, x[0]);        x[0] = 0.5;        y = 5.0;        x[0] = x[0] + 2.0*y;        printf(&quot;x[0] = %f\n&quot;, x[0]);        x[0] = 0.5;        y = 5.0;        x[0] *= 2.0*y;        printf(&quot;x[0] = %f\n&quot;, x[0]);        x[0] = 0.5;        y = 5.0;        x[0] = x[0]*(2.0*y);    /* Succeeds if parenthesis are removed */        printf(&quot;x[0] = %f\n&quot;, x[0]);        exit(0);</pre>	</TD></TR></TABLE></CENTER><P>This code fragment returns the erroneous values 0.5, 0.5, 0.5, 0.5 (the correctvalues are 10.5,10.5, 5.0 and 5.0).</p><h3>Workaround:</h3>  If using SANE, use <code>extended</code> variables in thesesituations.<ol type="1" start="2">	<li>Taking the address of a floating point formal parameter (function argument) to a function fails.  This bug occurs when using either SANE or the <code>-mc68881</code> compiler option in combination with <code>float</code> or <code>double</code> function arguments, it does not occur if the function arguments are declared <code>extended</code>. The following fragment illustrates two instances of this bug:</li></ol><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>    #include &lt;Types.h&gt;    #include &lt;Math.h&gt;    #include &lt;stdio.h&gt;    #define real float    /* Fails with either float or double */    main()    {        Bug1(1.0, 2.0, 3.0);        Bug2(1.0, 2.0, 3.0);    }    Bug1 (x, y, z)        real x, y, z;    {        real *p, *q, *r;        /* Take address of arguments, assign directly */        p = &amp;x; q = &amp;y; r = &amp;z;        fprintf(stderr, &quot;Example 1: Before: %g, %g, %g\n&quot;, x, y, z);        *p = 11.0;        *q = 12.0;        *r = 13.0;        fprintf(stderr, &quot;Example 1: After:  %g, %g, %g\n&quot;, x, y, z);    }    Bug2(x, y, z)        real x, y, z;    {        fprintf(stderr, &quot;Example 2: Bug2 Before: %g, %g, %g\n&quot;,             x, y, z);        /* Take address of arguments, assign indirectly */        foo(&amp;x, &amp;y, &amp;z);        fprintf(stderr, &quot;Example 2: Bug2 After:  %g, %g, %g\n&quot;,             x, y, z);    }    foo(x, y, z)    real *x, *y, *z;    {        fprintf(stderr, &quot;Example 2: foo Before: %g, %g, %g\n&quot;,            *x, *y, *z);        *x = 11.0;        *y = 12.0;        *z = 13.0;        fprintf(stderr, &quot;Example 2: foo After:  %g, %g, %g\n&quot;,            *x, *y, *z);</pre>	</TD></TR></TABLE></CENTER><P>This is, in fact, a general problem with C compilers.  The underlying reasonfor this problem is related to the automatic <u>widening</u> and<u>narrowing</u> of basic types performed by C compilers. For instance in C, asdefined by K&amp;R (<i>The C Programming Language</i>, Kernighan &amp; Ritchie,1978, Appendix A Sec. 7.1, p. 186 and Sec. 10.1, P. 206), variables of type<code>char</code> and <code>short</code> are widened to <code>int</code> before beingpassed as function arguments and narrowed before use inside the function.Similarly, the floating point type <code>float</code> is automatically widened to<code>double</code> before being passed.  K&amp;R notes, however, that "C convertsall <code>float</code> actual parameters to <code>double</code>, so formal parametersdeclared <code>float</code> have their declarations <u>adjusted</u> to read<code>double</code>."  The value of such a formal parameter is <b>not</b> narrowedto the declared type of the parameter, instead the declared type is<b>adjusted</b> to match that of the widened value.  So, in fact, the samplecode above will fail if <code>real</code> is defined as <code>float</code>, even on abug free K&amp;R conforming compiler.</p><p>In MPW C, where <code>float</code> and <code>double</code> are widened to<code>extended</code>, the sample code fails for either <code>float</code> or<code>double</code> formal parameters.  This can, of course, lead to additionalproblems if you are porting code from an environment where <code>double</code> wasthe widened floating point type (where taking the address of a double formalparameter would work as expected).</p><h3>Workaround:</h3>  <p>Taking the address of a function argument is not recommended;you should make a local copy in a temporary variable and take the address ofthe copy. If you must take the address of a floating point function argument,make sure it is declared as type <code>extended</code>, and the pointer is of type<code>extended*</code>.</p><ol type="1" start="3">	<li>The shift operators <code>&gt;&gt;</code> and <code>&lt;&lt;</code> can sometimes produce unexpected results when applied to unsigned short and unsigned char operands.  The anomaly lies in the fact that the 680x0 <code>LSR.L</code> and <code>LSL.L</code> instructions are used instead of the <code>LSR.W</code> and <code>LSL.W</code> or the <code>LSR.B</code> and <code>LSL.B</code> instructions.  The following example illustrates this anomaly:</li></ol><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>    main()    {        unsigned short u, c;        short i, k;        u = 0xFFFF;        k = 8;        i = (u &lt;&lt; k)/256;        printf(&quot;unsigned short: i = %d, %#x\n&quot;, i, i);        c = 256;        i = (u &lt;&lt; k)/c;        printf(&quot;unsigned short: i = %d, %#x\n&quot;, i, i);</pre>	</TD></TR></TABLE></CENTER><p>This code fragment returns the values -1, 0xFFFFFFFF and -1, 0xFFFFFFFF, whichare the correct values as defined by the C language, however, you might beexpecting 255, 0xFF and 255, 0xFF.</p><ol type="1" start="4">	<li>The compiler optimization flags <code>-q</code> (sacrifice code size for speed) and <code>-q2</code> (memory locations won't change except by explicit stores) can produce incorrect code. We have several vague descriptions of problems, and are looking for more specific examples.  The following example illustrates a specific bug that occurs when using <u>enumerated types</u>:</li></ol><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>    badfunc(bool, i)        Boolean *bool;        int i;    {        while (true) {            if(i &lt; 3) {                *bool  = true;                if (func(1)) return;            }             if (func(i)) return;        }</pre>	</TD></TR></TABLE></CENTER><p>The enumerated type here is the type used to define the values <code>true</code>and <code>false</code> in the header file <code>Types.h</code>.  The optimizer isapparently confused by the fact that <code>true</code> has the <code>char</code> value<code>1</code>, which it thinks is the same as the <code>int</code> value <code>1</code> tobe passed to the function func(). The object code produced for the two calls tothe function <code>func()</code> is:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>    ...    MOVEQ    #$01,D3    ; Move the constant 1 into a register    ...    MOVE.B    D3,(A2)     ; Assign &quot;true&quot; to variable bool    MOVE.B    D3,-(A7)    ; Attempt to push integer 1 onto stack            ; ERROR should be MOVE.L !!!!!    JSR    *+$0002    ; JSR to func    ...    MOVE.L    D4,-(A7)     ; Correctly push integer variable i onto stack    JSR    *+$0002     ; JSR to func</pre>	</TD></TR></TABLE></CENTER><P>In the first function call, the <code>int</code> constant <code>1</code> is passed as abyte value! Since the stack is correctly adjusted after the first call thiserror may go undetected (except that the called function may spot the resultingnonsensical parameter).  This problem is, of course, not limited to theenumerated type defining <code>true</code> and <code>false</code>, but can occur as aside effect of any of the many enumerated types defined in the Toolbox headerfiles.</p><h3>Workaround:</h3>  <p>The best solution, for now, is to avoid using the optimizationflags <code>-q</code> and <code>-q2</code> altogether.</p><ol type="1" start="5">	<li>The compiler flag <code>-mc68020</code> (generate MC68020 instructions) generates inconsistent code when passing structures by value.  Specifically, structures larger than 4 bytes that are not a multiple of 4 bytes are padded out to the nearest 4 byte multiple before being pushed onto the stack by the calling routine.  Unfortunately, the called routine does not take this padding into account when accessing its function arguments. The following example illustrates this bug:</li></ol><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>    #include &lt;Types.h&gt;    #include &lt;strings.h&gt;    typedef struct         /* 6 byte long structure */    {      short Temp1;      short Temp2;      short Temp3;    } TestStruct;    main()    {      TestStruct reply;      foo(reply,&quot;Hello world.\n&quot;);    }    foo(tst ,str)      TestStruct tst;      char *str;    {      Debugger();    /* So we can look, before stepping off the cliff */      printf(&quot;%s&quot;,str);</pre>	</TD></TR></TABLE></CENTER><P>Since function arguments are pushed onto the stack in left to right order in C,the pointer to the string constant <code>"Hello</code> <code>world.\n"</code> is pushedonto the stack before the <u>padded</u> contents of the <code>reply</code>structure.  Thus when the called function, <code>foo()</code>, goes to fetch theargument <code>str</code>, it looks at the location just beyond where the argument<code>tst</code> is located. Unfortunately, since the called function does not knowthe structure argument was padded, it will not find the correct value for thesecond argument (or in the general case, any arguments following thestructure).</p><h3>Workaround:</h3>  When using the <code>-mc68020</code> compiler option, either don'tpass structures larger than 4 bytes by value, or make sure all structureslarger than 4 bytes are padded out to a multiple of 4 bytes.<ol type="1" start="6">	<li>Switch statements with non-integer controlling expressions can fail.  The following example illustrates the problem:</li></ol><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>    #include &lt;stdio.h&gt;    #include &lt;strings.h&gt;    main()    {        unsigned short w = 1;        printf(&quot;The following test fails in MPW\n&quot;);        printf(&quot;Should switch to 1; actually got to &quot;);        switch (w) {            case 1:                printf(&quot;1\n&quot;);                break;            case 5:                printf(&quot;5\n&quot;);                break;            case 32771:                printf(&quot;32771\n&quot;);                break;            case 32773:                printf(&quot;32773\n&quot;);                break;            default:                printf(&quot;default\n&quot;);                break;        }</pre>	</TD></TR></TABLE></CENTER><P>In this example, instead of reaching <code>case 1:</code> in the switch statement,the <code>default:</code> case is reached due to the fact that the compilergenerates comparison instructions based on word length values. The 1st Editionof K&amp;R (<i>The C Programming Language</i>, Kernighan &amp; Ritchie, 1978,Appendix A Sec. 9.7, p202) requires all case constants to have integer type andthe controlling expression to be coerced to integer type.  The  2nd Edition(ANSI) of K&amp;R (<i>The C Programming Language</i>, Kernighan &amp; Ritchie,1988, Appendix A Sec. 9.4, p223) requires that the controlling expression andall case constants undergo "integral promotion"--promotion to <code>int</code> (orto <code>unsigned int</code> if necessary).  MPW 2.0.2 C fails to promote eitherthe controlling expression or the case constants to type <code>int</code>.</p><h3>Workaround:</h3>  <P>If the controlling expression is manually coerced to type<code>int</code> this example functions correctly.</p><ol type="1" start="7">	<li>Variable declarations inside the body of switch statements, when combined with the <code>-g</code> compiler flag, can cause the compiler's code generator to abort with the message: "Code generator abort code 615."  The following example illustrates the problem:</li></ol><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>    foo(i)        int i;    {        switch (i) {            int j;   /* VARIABLE DECLARATION INSIDE BODY OF SWITCH */            case 0:                j = 22 +i;                printf(&quot;INSIDE: i=%d, j=%d\n&quot;, i, j);                break;            case 1:                j = 57 -i;                printf(&quot;INSIDE: i=%d, j=%d\n&quot;, i, j);                break;            default:                j = i;                printf(&quot;INSIDE: i=%d, j=%d\n&quot;, i, j);                break;        }</pre>	</TD></TR></TABLE></CENTER><P>While such a declaration is perfectly legal C, it is a bad practice (<i>The CProgramming Language</i>, Kernighan &amp; Ritchie, 1978, Appendix A Sec. 9.2,p201). K&amp;R go on to point out that if the declaration of the variablecontains an initializer, the initialization will NOT take place.  This is alsothe ANSI draft C standard's interpretation.</p><h3>Workaround:</h3>  <P>Since the <code>-g</code> option is a very useful debuggingoption, move the variable declaration outside the body of the switch statement.</p><ol type="1" start="8">	<li>Compatibility Note:  Local variable declarations of the form <code>char s[];</code> (as an array of unspecified length), may not behave as expected. Pre-ANSI compilers often expand such declarations into the equivalent of an extern declaration. MPW 2.0.2 C, and most modern compilers, treat this construct as the declaration of a <u>new </u>array, thus overriding any global declaration with the same name. In the following example:</li></ol><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>    /* From file foo.c */    char s[255];    main()    {        strcpy(s, &quot;This is one heck of a mess&quot;);        otherfunc();    }    /* From file bar.c */    otherfunc()    {        char s[];        printf(&quot;%s\n&quot;, s);</pre>	</TD></TR></TABLE></CENTER><P>garbage is printed.  As a local variable declaration, this declaration isincomplete since no length is specified or implied, so an ANSI C compiler willof course fail.  This is obviously not a recommended programming practice, butif you are porting old C code you may encounter this usage.</p><h3> Workaround:</h3>  ALWAYS use the declaration <code>extern char s[];</code> instead.<ol type="1" start="9">	<li>Another instance where declarations of the form <code>type s[];</code> (as an array of unspecified length) may not behave as expected, is as a member of a <code>struct</code> or <code>union</code>. Pre ANSI compilers often expand such declarations into the equivalent of a pointer declaration. This construct is explicitly prohibited in ANSI C structures and unions. MPW 2.0.2 C on the other hand, issues no warning and treats this construct as the declaration of an array of length zero, which occupies no space in the <code>struct</code>. In the following example:</li></ol><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>    typedef struct  ST1  {            int array1[];    /* Zero length array or Ptr to array? */            int array2[];            int array3[];    }ST1;    main()    {        ST1 s1;        int i1, i2, i3;        i1 = s1.array1[0];        i2 = s1.array2[0];        i3 = s1.array3[0];</pre>	</TD></TR></TABLE></CENTER><P>the three fields of the <code>struct</code> <code>ST1</code> are located at the samememory location, and the assignments shown will actually copy garbage into theintegers, since <u>no space</u> was allocated for even the first element of thearrays.  Unfortunately, structures containing an array of unspecified or zerolength as the final member are sometimes used to indicate a structurecontaining a variable length array. While this may be useful, it is nottolerated  by ANSI C and thus is not a recommended programming practice.However, if you are porting old C code you may encounter this usage.</p><h3>Workaround:</h3>  ALWAYS use the declarations of the form <code>type *s;</code>,<code>type (*s)[];</code>&nbsp;, or <code>type s[1]</code> (depending on the intendedmeaning) in structures and unions instead.<ol type="1" start="10">	<li>The routines <code>_SetUpA5</code> and <code>_RestoreA5</code> described in the OS Utilities Chapter of <i>Inside Macintosh</i>, Volume II, are missing.  Refer to M.OV.A5 for two new routines which solve this problem.</li>	<li>Hint:  Switch statements with large numbers of cases (over 100 or so) can trigger the appearance of the MPW Bulldozer cursor (signaling heap purging and compacting in progress), can cause "Out of memory" errors from the compiler, or at least take a <u>very long</u> time to compile.</li></ol><h3>    Workaround:</h3>  <p>Large switch statements can be split up into smaller onesto avoid these symptoms.</p><a name="Section3"></a> <P><A HREF="#top">Back to top</A></p><h2>Pascal Language</h2><p>The following information applies to the Pascal compiler and its associatedlibraries shipped with the 2.0.2 version of MPW.</p><ol type="1" start="1">	<li> The Pascal compiler generates incorrect code when accessing the elements of <code>packed Boolean</code> arrays with more than 32767 elements. The generated code contains an <code>ASR.W</code> instruction to compute the byte offset into the array, this of course fails for numbers larger than 32767 ($7FFF). The following example, which zeroes bits far beyond the end of the array itself, illustrates the error:</li></ol><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>    PROGRAM PackArrayBug;        VAR          MyBits:    packed array[0..33000] of Boolean;          PROCEDURE BadCode;          VAR            i: longint;          BEGIN            for i := 0 to 33000 do              MyBits[i] := false;          END;        BEGIN            BadCode</pre>	</TD></TR></TABLE></CENTER><h3>    Workaround:</h3>  <p>Don't use <code>packed Boolean</code> arrays with more than32767 elements.</p><ol type="1" start="2">	<li>The Pascal compiler fails to detect the situation where a procedure name is passed as an argument to a routine expecting a function as an argument. The following example  illustrates the error:</li></ol><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>    PROGRAM FuncArgBug;          PROCEDURE ExpectsFunc(x: integer; function Visit(y1: longint;                 y2: char;): Boolean);          VAR            result: Boolean;            yc: char;          BEGIN            yc := 'A';            result := Visit(x, yc);          END;          PROCEDURE FormalProc(y1: longint; y2: char;);          BEGIN            writeln(y1: 1, ' ', y2);          END;        BEGIN            ExpectsFunc(5, FormalProc);</pre>	</TD></TR></TABLE></CENTER>   <p> This type of problem typically leads to stack misalignment and spectacularcrashes.</p><h3>    Workaround:</h3>  <P>Make certain that Pascal routines expecting functions asarguments are indeed passed functions.</p><ol type="1" start="3">	<li>The <code>-mc68881</code> option causes the Pascal compiler to generate incorrect code when calling external C language routines with floating point <code>extended</code> arguments. Apparently the compiler miscalculates the size of the <code>extended</code> argument so that it incorrectly removes the arguments from the stack. The following example, which can corrupt the local variables of its caller, illustrates the error:</li></ol><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>    FUNCTION E2S(f: Str255; x: extended): Str255;       VAR        dummy: integer;        i:     integer;        t:     Str255;      FUNCTION sprintf(str: Ptr; fmt: Ptr; x: extended):            integer; C; EXTERNAL;      BEGIN        t[0] := chr(0);        f[ord(f[0]) +1] := chr(0);        dummy := sprintf(@t[1], @f[1], x);        i := 0;        repeat          i := i+1;        until ((t[i] = chr(0)) or (i &gt; 254));        t[0] := chr(i);        E2S := t;</pre>	</TD></TR></TABLE></CENTER>   <p> The relevant portions of the generated code are:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>    LINK       A6,#$FDF0    ; LINK for local vars    MOVEM.L    D6/D7,-(A7)    ; Save Registers used here    ...    ...    LEA        $FF00(A6),A0    ; Get address of extended var    MOVE.L     -(A0),-(A7)    ; Push extended onto stack    MOVE.L     -(A0),-(A7)    MOVE.L     -(A0),-(A7)    PEA        $FF01(A6)    ; Push address of format str    PEA        $FDF1(A6)    ; Push address of target str    JSR        *+$0002    ; JSR to sprintf    LEA        $0012(A7),A7    ; Pop args off stack        ; (SHOULD pop off $14 bytes!)    MOVE.W     D0,D6    ; Save function result    ...    ...    MOVEM.L    (A7)+,D6/D7    ; Restore registers used here        ;  (Now they've been corrupted!)    UNLK       A6    ; Correctly restores A7    MOVEA.L    (A7)+,A0    ADDQ.W     #$8,A7</pre>	</TD></TR></TABLE></CENTER><p>    Notice that this code would have succeeded if the routine had not used the<code>D6</code> and <code>D7</code> registers for storage, and then restored them(incorrectly) before returning.</p><h3>    Workaround:</h3>  <P>When calling such a routine with the <code>-mc68881</code>option, isolate the call in a small subroutine or function that has no localvariables, so that registers will not need to be saved and restored.</p><ol type="1" start="4">	<li>The <code>{$SC+}</code> compiler flag for short circuiting AND and OR operators can sometimes produce incorrect code. The following example does not work if <code>{$SC+}</code> has been used:</li></ol><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>    USES      Memtypes,QuickDraw,OSIntf,ToolIntf,PackIntf;    VAR      b1,b2,b3 : BOOLEAN;    Begin      b1 := false;      b2 := true;      b3 := true;      if not (b1 and b2) and b3 then          SysBeep(40);</pre>	</TD></TR></TABLE></CENTER><h3>    Workaround:</h3>  Don't use the <code>{$SC+}</code> compiler flag.<ol type="1" start="5">	<li>The Pascal compiler generates incorrect overflow checking code for <code>longint</code> valued arguments to the <code>Odd</code> function. The generated code contains a signed divide (<code>DIVS</code>) by 1 followed by a <code>TRAPV</code>, thus the overflow flag is set for values greater than $7FFF. The following example will fail with a <code>CHK</code> exception, unless the <code>{$OV+}</code> directive is removed:</li></ol><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>    {$OV+}    PROGRAM PascalOdd;        VAR            IsOdd:    Boolean;            longval: LONGINT;        BEGIN            longval := 123456;            IsOdd := Odd(longval);</pre>	</TD></TR></TABLE></CENTER><h3>    Workaround:</h3>  <p>Don't use the <code>{$OV+}</code> compiler flag if you pass<code>longint</code> values to the <code>Odd</code> function.</p><ol type="1" start="6">	<li>The Pascal compiler generates incorrect code when functions with <code>RECORD</code> type are used as the object of a <code>WITH</code> statement.  This will only occur if the function is called at a level below the main program, and if the length of the <code>RECORD</code> type is 4 bytes or less.  The generated code often contains an <code>LEA (A7)+,</code>an instruction, which is of course illegal. The following example demonstrates this unusual situation:</li></ol><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>    PROGRAM PasRecordValFuncBug;      TYPE        OurRecord   =          RECORD            a:    Integer;          END;      FUNCTION RecordValuedFunction: OurRecord;      BEGIN      END;      PROCEDURE ContainsBadCode;      BEGIN        WITH RecordValuedFunction DO BEGIN  { This usage bad code. }          a:=a;        END;      END;    BEGIN { PasRecordValFuncBug }      ContainsBadCode;      WITH RecordValuedFunction DO BEGIN  { This usage is okay. }        a:=a;      END;</pre>	</TD></TR></TABLE></CENTER><h3>    Workaround: </h3>Don't use <code>RECORD</code> valued functions as the object of<code>WITH</code> statements.<a name="Section4"></a> <P><A HREF="#top">Back to top</A></p><h2>Assembly Language</h2><p>The following information applies to the Assembler and its associated librariesshipped with the 2.0.2 version of MPW.</p><ol type="1" start="1">	<li>There are no known outstanding bugs in the MPW Assembler.</li></ol><a name="Section5"></a> <P><A HREF="#top">Back to top</A></p><h2>Interface Libraries</h2><p>The following information applies to the Toolbox and OS interface librariesshipped with the 2.0.2 version of MPW.</p><ol type="1" start="1">	<li>The glue for the Device Manager call <code>GetDCtlValue</code> [Not in ROM] described in <i>Inside Macintosh</i>, Volume III, is incorrect and will return an incorrect value for the handle to the driver's device control entry.  The following is a corrected version of the erroneous glue found in the library file <code>Interface.o</code>:</li></ol><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>    ;-----------------------------------------------------    ;FUNCTION GetDCtlEntry(refNum: Integer) : DCtlHandle;    ;-----------------------------------------------------    GetDCtlEntry PROC EXPORT        MOVEA.L    (SP)+,A0        ;Get the return address        MOVE.W    (SP)+,D0        ;Get the refNum        ADDQ.W    #$1,D0        ;Change to a        NEG.W    D0            ;  Unit Number    ;===&gt;    LSR.W    #$2,D0        ;==Shift in wrong direction!        LSL.W    #$2,D0        ;Times 4 bytes/entry        MOVEA.L    UTableBase,A1    ;Get address of unit table        MOVE.L    (A1,D0.W),(SP)    ;Get the DCtlHandle</pre>	</TD></TR></TABLE></CENTER>    <p>This error will affect C, Pascal, and assembly language users. </p><h3>    Workaround:</h3>  <p>Use the corrected glue for <code>GetDCtlValue</code>.</p><ol type="1" start="2">	<li>The glue for the register-based Vertical Retrace Manager calls <code>_SlotVInstall</code> and <code>_SlotVRemove</code> described in <i>Inside Macintosh</i>, Volume V, is incorrect. The following are corrected versions of the erroneous glue for these routines found in the library file <code>Interface.o</code>:</li></ol><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>    ;-----------------------------------------------------------------------    ;FUNCTION SlotVInstall(vblTaskPtr: QElemPtr; theSlot: Integer): OSErr;    ;-----------------------------------------------------------------------    SlotVInstall PROC EXPORT        MOVEA.L    (A7)+,A1    ; save return address        MOVE.W    (A7)+,D0    ; the slot number        MOVEA.L    (A7)+,A0    ; the VBL task ptr        _SlotVInstall        MOVE.W    D0,(A7)    ; save result code on stack        JMP     (A1)    ; return to caller        ENDPROC    ;----------------------------------------------------------------------    ;FUNCTION SlotVRemove(vblTaskPtr: QElemPtr; theSlot: Integer): OSErr;    ;----------------------------------------------------------------------    SlotVRemove PROC EXPORT        MOVEA.L    (A7)+,A1    ; save return address        MOVE.W    (A7)+,D0    ; the slot number        MOVEA.L    (A7)+,A0    ; the VBL task ptr        _SlotVRemove        MOVE.W    D0,(A7)    ; save result code on stack        JMP    (A1)    ; return to caller</pre>	</TD></TR></TABLE></CENTER>    <P>These errors will affect C, Pascal, and assembly language users. </p><h3>    Workaround:</h3>  <p>Use the corrected glue for <code>_SlotVInstall</code> and<code>_SlotVRemove</code>.</p><ol type="1" start="3">	<li>The glue for the register based Start Manager calls <code>_GetTimeout</code> and <code>_SetTimeout</code> described in <i>Inside Macintosh</i>, Volume V, is incorrect .  The following are corrected versions of the erroneous glue for these routines found in the library file <code>Interface.o</code>:</li></ol><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>    ;-----------------------------------------------------------------------    ;PROCEDURE GetTimeout(VAR count: INTEGER);    ;-----------------------------------------------------------------------    GetTimeout PROC EXPORT    ;===&gt;    CLR.W      -(A7)        ;===OOPS, selector in A0 not on stack        SUBA.L     A0,A0        ;Put selector in A0, i.e. 0        _InternalWait        MOVEA.L    (A7)+,A1    ;Pop return address into A1        MOVEA.L    (A7)+,A0    ;Pop location for VAR count        MOVE.W     D0,(A0)    ;Stuff returned value into count        JMP        (A1)        ;And go home    ;----------------------------------------------------------------------    ; PROCEDURE SetTimeout(count: INTEGER);    ;----------------------------------------------------------------------    SetTimeout PROC EXPORT        MOVEA.L    (A7)+,A1     ;Pop return address into A1        MOVE.W     (A7),D0    ;Move count parameter into D0    ;===&gt;    MOVE.W     #$0001,(A7) ;===OOPS, selector in A0 not on stack        MOVEA.W    #$0001,A0     ;Put selector in A0        _InternalWait</pre>	</TD></TR></TABLE></CENTER>  <p>  These errors will affect C, Pascal, and assembly language users.</p><h3>    Workaround:</h3>  <P>Use the corrected glue for <code>_GetTimeout</code> and<code>_SetTimeout</code>.</p><a name="References"></a> <P><A HREF="#top">Back to top</A></p><h2>References</h2><P>M.OV.A5</p>         <a name=Downloads></A>                   <P><A HREF="#top">Back to top</A></p><h2>Downloadables</H2>                  <TABLE BORDER=0 CELLPADDING=3 WIDTH="100%">            <TR>               <td width=50 align=left>                  <P ALIGN=center><img src="images/acrobatsmall.gif" width=22 height=23 align=middle alt="Acrobat gif"></P>               </TD>               <td align="left">                  <P>Acrobat version of this Note (K).</P>               </TD>               <td width=60 align=left>                  <P><A HREF="pdf/pt_26.pdf">Download</A></P>               </TD>            </TR>                    </TABLE>         <BR></TD></TR></table></center><!-- begin_footer_information -->	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/technotes/pt/pt_26.html%3Fid%3DDTS10002680-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/technotes/pt/pt_26.html%3Fid%3DDTS10002680-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/technotes/pt/pt_26.html%3Fid%3DDTS10002680-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>
<!--#include virtual="/includes/footer"--><!-- end_footer_information --></BODY></HTML>