<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>Programming With the Text Encoding Conversion Manager: Writing Custom Plug-Ins</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Writing Custom Plug-Ins"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP40000932-CH203" title="Writing Custom Plug-Ins"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../index.html#//apple_ref/doc/uid/TP30000440-TP30000420" target="_top">Carbon</a> &gt; <a href="../../../TextFonts-date.html#//apple_ref/doc/uid/TP30000440-TP30000420-TP30000461" target="_top">Text &amp; Fonts</a> &gt; <a href="../tecmgr_about/tecmgr_about.html#//apple_ref/doc/uid/TP40000932-CH201-DontLinkElementID_1">Programming With the Text Encoding Conversion Manager</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../tecmgr_concepts/tecmgr_concepts.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../tecmgr_encnames/tecmgr_encnames.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP40000932-CH203-DontLinkElementID_64" title="Writing Custom Plug-Ins"></a><h1><a name="//apple_ref/doc/uid/TP40000932-CH203-CJBHEDIA" title="Writing Custom Plug-Ins"></a>Writing Custom Plug-Ins</h1><p>This document provides information on writing plug-ins for text encoding conversion on Mac OS–based computers. </p><p>Text encoding conversion plug-ins, which provide conversion services between pairs of encodings, inform the Text Encoding Conversion Manager about their conversion and encoding analysis capabilities. The Text Encoding Conversion Manager sets up plug-ins and tears them down; the plug-ins perform conversions, handle caller options, and examine text encodings.</p><p>Support for new encodings is provided by writing new text encoding plug-ins. Plug-ins are implemented as Code Fragment Manager (CFM) libraries.</p><p>The number and kind of text encodings that the Text Encoding Conversion Manager supports depends on the conversion plug-ins that are currently installed in the system. Text encoding conversion plug-ins are installed in the Text Encodings folder within the System Folder.</p><p>Generally, plug-ins provide algorithmic conversions, although plug-ins can also provide mapping-table-based conversions. Mapping-table-based conversions provided by the Unicode Converter are available through a provided plug-in which calls the Unicode Converter.</p><p>The Text Encoding Conversion Manager provides mechanisms to create converter objects to communicate with the plug-ins.</p><p>Plug-ins are implemented as code fragments. The main export symbol of the code fragment is a routine that returns the address of a structure of type <code>TECPluginDispatchTable</code>. The structure is a plug-in dispatch table that contains a dispatch table format version number, a signature for the plug-in, and hooks for the methods each plug-in needs to support.</p><p>The filename of a plug-in does not affect the actual text conversion performed by the Text Encoding Conversion Manager.</p><p>Export symbols of the code fragment plug-in include the standard CFM initialization and termination routines as well as the main routine.</p><p>The initialization routine is called by the Text Encoding Conversion Manager when the plug-in is loaded. It must return <code>noErr</code> or the plug-in is not installed. For example,</p><div class="codesample"><table><tr><td scope="row"><pre>OSErr INIT_KoreanPlugin(InitBlockPtr initBlkPtr){<span></span></pre></td></tr><tr><td scope="row"><pre>return noErr;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>The termination routine performs cleanup before the plug-in is unloaded. For example,</p><div class="codesample"><table><tr><td scope="row"><pre>void TERM_KoreanPlugin(void)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>The main export symbol is the name of the routine that returns the address of the <code>TECPluginDispatchTable</code>. Because this is the main export symbol, the table is loaded after the plug-in has been installed by the Text Encoding Conversion Manager. For example,</p><div class="codesample"><table><tr><td scope="row"><pre>TECPluginDispatchTable *GetKoreanDispatchTable(void)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>return &amp;KoreanPluginDispatchTable;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>The table consists of a dispatch table format version number, a signature that uniquely identifies the plug-in, and routine pointers to the plug-in’s methods. The methods are discussed later in this appendix. The compatible version number is always less than or equal to the current version number.</p><div class="codesample"><table><tr><td scope="row"><pre>struct TECPluginDispatchTable {<span></span></pre></td></tr><tr><td scope="row"><pre>    /* version information */<span></span></pre></td></tr><tr><td scope="row"><pre>    TECPluginVersion                version;<span></span></pre></td></tr><tr><td scope="row"><pre>    TECPluginVersion                compatibleVersion;<span></span></pre></td></tr><tr><td scope="row"><pre>    TECPluginSignature              PluginID;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    /* converter hooks */<span></span></pre></td></tr><tr><td scope="row"><pre>    TECPluginNewEncodingConverterPtr                                        PluginNewEncodingConverter;<span></span></pre></td></tr><tr><td scope="row"><pre>    TECPluginClearContextInfoPtr                                        PluginClearContextInfo;<span></span></pre></td></tr><tr><td scope="row"><pre>    TECPluginConvertTextEncodingPtr                                         PluginConvertTextEncoding;<span></span></pre></td></tr><tr><td scope="row"><pre>    TECPluginFlushConversionPtr                                         PluginFlushConversion;<span></span></pre></td></tr><tr><td scope="row"><pre>    TECPluginDisposeEncodingConverterPtr                                        PluginDisposeEncodingConverter;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    /* sniffer hooks */<span></span></pre></td></tr><tr><td scope="row"><pre>    TECPluginNewEncodingSnifferPtr                                      PluginNewEncodingSniffer;<span></span></pre></td></tr><tr><td scope="row"><pre>    TECPluginClearSnifferContextInfoPtr                                         PluginClearSnifferContextInfo;<span></span></pre></td></tr><tr><td scope="row"><pre>    TECPluginSniffTextEncodingPtr                                       PluginSniffTextEncoding;<span></span></pre></td></tr><tr><td scope="row"><pre>    TECPluginDisposeEncodingSnifferPtr                                          PluginDisposeEncodingSniffer;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    /* Support encoding information. These hooks can be implemented as resources. */<span></span></pre></td></tr><tr><td scope="row"><pre>    TECPluginGetCountAvailableTextEncodingsPtr<span></span></pre></td></tr><tr><td scope="row"><pre>                                            PluginGetCountAvailableTextEncodings;<span></span></pre></td></tr><tr><td scope="row"><pre>    TECPluginGetCountAvailableTextEncodingPairsPtr<span></span></pre></td></tr><tr><td scope="row"><pre>                                            PluginGetCountAvailableTextEncodingPairs;<span></span></pre></td></tr><tr><td scope="row"><pre>    TECPluginGetCountDestinationTextEncodingsPtr<span></span></pre></td></tr><tr><td scope="row"><pre>                                            PluginGetCountDestinationTextEncodings;<span></span></pre></td></tr><tr><td scope="row"><pre>    TECPluginGetCountSubTextEncodingsPtr                                        PluginGetCountSubTextEncodings;<span></span></pre></td></tr><tr><td scope="row"><pre>    TECPluginGetCountAvailableSniffersPtr                                       PluginGetCountAvailableSniffers;<span></span></pre></td></tr><tr><td scope="row"><pre>    TECPluginGetCountWebEncodingsPtr                                        PluginGetCountWebTextEncodings;<span></span></pre></td></tr><tr><td scope="row"><pre>    TECPluginGetCountMailEncodingsPtr                                       PluginGetCountMailTextEncodings;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    TECPluginGetTextEncodingInternetNamePtr PluginGetTextEncodingInternetName;<span></span></pre></td></tr><tr><td scope="row"><pre>    TECPluginGetTextEncodingFromInternetNamePtr<span></span></pre></td></tr><tr><td scope="row"><pre>                                            PluginGetTextEncodingFromInternetName;<span></span></pre></td></tr><tr><td scope="row"><pre>};<span></span></pre></td></tr><tr><td scope="row"><pre>typedef struct TECPluginDispatchTable TECPluginDispatchTable;<span></span></pre></td></tr></table></div><p>Each plug-in must implement routines for creating the converter object, resetting the state of the converter object, encoding conversions, and disposing of the converter object. That is, the following routine pointers in the dispatch table should be valid for a basic plug-in:</p><div class="codesample"><table><tr><td scope="row"><pre>TECPluginNewEncodingConverterPtr<span></span></pre></td></tr><tr><td scope="row"><pre>TECPluginClearContextInfoPtr<span></span></pre></td></tr><tr><td scope="row"><pre>TECPluginConvertTextEncodingPtr<span></span></pre></td></tr><tr><td scope="row"><pre>TECPluginDisposeEncodingConverterPtr<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/* You can implement the following routine pointers or use their corresponding  resources. */<span></span></pre></td></tr><tr><td scope="row"><pre>TECPluginGetCountAvailableTextEncodingsPtr<span></span></pre></td></tr><tr><td scope="row"><pre>TECPluginGetCountAvailableTextEncodingPairsPtr<span></span></pre></td></tr><tr><td scope="row"><pre>TECPluginGetCountDestinationTextEncodingsPtr<span></span></pre></td></tr></table></div><p>Example:</p><div class="codesample"><table><tr><td scope="row"><pre>TECPluginDispatchTable KoreanPluginDispatchTable = {<span></span></pre></td></tr><tr><td scope="row"><pre>    kTECPluginDispatchTableCurrentVersion,<span></span></pre></td></tr><tr><td scope="row"><pre>    kTECPluginDispatchTableCurrentVersion,<span></span></pre></td></tr><tr><td scope="row"><pre>    kTECKoreanPluginSignature,<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>&amp;ConverterPluginNewEncodingConverter, &amp;ConverterPluginClearContextInfo,<span></span></pre></td></tr><tr><td scope="row"><pre>&amp;ConverterPluginConvertTextEncoding,<span></span></pre></td></tr><tr><td scope="row"><pre>&amp;ConverterPluginFlushConversion,<span></span></pre></td></tr><tr><td scope="row"><pre>&amp;ConverterPluginDisposeEncodingConverter,<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>&amp;ConverterPluginNewEncodingSniffer,<span></span></pre></td></tr><tr><td scope="row"><pre>&amp;ConverterPluginClearSnifferContextInfo,<span></span></pre></td></tr><tr><td scope="row"><pre>&amp;ConverterPluginSniffTextEncoding,<span></span></pre></td></tr><tr><td scope="row"><pre>&amp;ConverterPluginDisposeEncodingSniffer,<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>nil, // &amp;ConverterPluginGetAvailableTextEncodings,<span></span></pre></td></tr><tr><td scope="row"><pre>nil, // &amp;ConverterPluginGetAvailableTextEncodingPairs,<span></span></pre></td></tr><tr><td scope="row"><pre>nil, // &amp;ConverterPluginGetDestinationTextEncodings,<span></span></pre></td></tr><tr><td scope="row"><pre>nil, // PluginGetSubTextEncodings,<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>nil, // PluginGetSniffers;<span></span></pre></td></tr><tr><td scope="row"><pre>nil, // PluginGetWebTextEncodings;<span></span></pre></td></tr><tr><td scope="row"><pre>nil, // PluginGetMailTextEncodings;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>nil, // PluginGetTextEncodingMIMEName,<span></span></pre></td></tr><tr><td scope="row"><pre>nil, // PluginGetTextEncodingFromMIMEName,<span></span></pre></td></tr><tr><td scope="row"><pre>};<span></span></pre></td></tr></table></div><p>The Text Encoding Conversion Manager communicates with its plug-ins through structures of type <code>TECConverterContextRec</code>. Context structures are created and disposed of by the Text Encoding Conversion Manager. Plug-ins are called to construct and dispose of their own data. The Text Encoding Conversion Manager and plug-ins communicate with each other in the following ways:</p><ol class="ol"><li class="li"><p>The Text Encoding Conversion Manager supplies input and output buffers to plug-ins.</p></li><li class="li"><p>Plug-ins report back how much text they have converted.</p></li></ol><div class="notebox"><a name="//apple_ref/doc/uid/TP40000932-CH203-DontLinkElementID_65" title="Note"></a><p><strong>Note:</strong>&nbsp;<code>TECConverterContextRec</code> is used by encoding converter objects. <code>TECSnifferContextRec</code> is used by encoding sniffers. Encoding sniffers are discussed in later sections.</p></div><div class="codesample"><table><tr><td scope="row"><pre>struct TECConverterContextRec {<span></span></pre></td></tr><tr><td scope="row"><pre>    /* public - manipulated externally and within plug-in   */<span></span></pre></td></tr><tr><td scope="row"><pre>    Ptr pluginRec;<span></span></pre></td></tr><tr><td scope="row"><pre>    TextEncoding sourceEncoding;<span></span></pre></td></tr><tr><td scope="row"><pre>    TextEncoding destEncoding;<span></span></pre></td></tr><tr><td scope="row"><pre>    UInt32 reserved1;<span></span></pre></td></tr><tr><td scope="row"><pre>    UInt32 reserved2;<span></span></pre></td></tr><tr><td scope="row"><pre>    TECBufferContextRec bufferContext;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    /* private - manipulated only within plug-in */<span></span></pre></td></tr><tr><td scope="row"><pre>    UInt32 contextRefCon;<span></span></pre></td></tr><tr><td scope="row"><pre>    ProcPtr conversionProc;<span></span></pre></td></tr><tr><td scope="row"><pre>    ProcPtr flushProc;<span></span></pre></td></tr><tr><td scope="row"><pre>    ProcPtr clearContextInfoProc;<span></span></pre></td></tr><tr><td scope="row"><pre>    UInt32 options1;<span></span></pre></td></tr><tr><td scope="row"><pre>    UInt32 options2;<span></span></pre></td></tr><tr><td scope="row"><pre>    TECPluginStateRec pluginState; /* state information */<span></span></pre></td></tr><tr><td scope="row"><pre>};<span></span></pre></td></tr><tr><td scope="row"><pre>typedef struct TECConverterContextRec TECConverterContextRec;<span></span></pre></td></tr></table></div><p>Most of the public section of the <code>TECConverterContextRec</code> structure is maintained by the Text Encoding Conversion Manager and should not be modified by the plug-in. The <code>bufferContext</code> field is set up by the Text Encoding Conversion Manager to point to the input and output buffers before the conversion routine, pointed to by <code>PluginConvertTextEncoding</code> (a routine pointer defined in the plug-in dispatch table), is called. On exit from that routine, the plug-in should update this structure to indicate how much of the input buffer was consumed and how much text was placed in the output buffer.</p><div class="codesample"><table><tr><td scope="row"><pre>struct TECBufferContextRec {<span></span></pre></td></tr><tr><td scope="row"><pre>    TextPtr textInputBuffer;<span></span></pre></td></tr><tr><td scope="row"><pre>    TextPtr textInputBufferEnd;<span></span></pre></td></tr><tr><td scope="row"><pre>    TextPtr textOutputBuffer;<span></span></pre></td></tr><tr><td scope="row"><pre>    TextPtr textOutputBufferEnd;<span></span></pre></td></tr><tr><td scope="row"><pre>    TextPtr encodingInputBuffer;                        /* currently not used */<span></span></pre></td></tr><tr><td scope="row"><pre>    TextPtr encodingInputBufferEnd; /* currently not used */<span></span></pre></td></tr><tr><td scope="row"><pre>    TextPtr encodingOutputBuffer; /* currently not used */<span></span></pre></td></tr><tr><td scope="row"><pre>    TextPtr encodingOutputBufferEnd; /* currently not used */<span></span></pre></td></tr><tr><td scope="row"><pre>};<span></span></pre></td></tr><tr><td scope="row"><pre>typedef struct TECBufferContextRec TECBufferContextRec;<span></span></pre></td></tr></table></div><p>The private section of the <code>TECConverterContextRec</code> structure provides persistent storage for a plug-in between conversion routine calls. It isn’t modified by the Text Encoding Conversion Manager. For example, the private section can be used to store state information during a multi-pass encoding conversion. If a plug-in requires more space than is provided in this structure to keep its local data, it can maintain a pointer or a handle to its data in the <code>contextRefCon</code> field.</p><p>The fields in the private section can be used in any way a particular plug-in requires. All current Apple plug-ins set up these fields with the routine pointed to by <code>PluginNewEncodingConverter</code>, a routine pointer defined in the plug-in dispatch table, in the following way:</p><p>The <code>contextRefCon</code> field is set to <code>nil</code>. It can be used to store a handle to additional information handled by the plug-in.</p><p>The<code> conversionProc</code> field points to a routine within the plug-in that performs a specific conversion, for example, EUC to ISO-2022-JP. </p><p>The <code>flushProc </code>field points to a routine within the plug-in that flushes the output buffer with some text sequence in order to set the output buffer state to a certain text mode, such as ASCII mode. It is currently used in EUC to ISO-2022-JP conversion.</p><p>The <code>clearContextInfoProc</code> field points either to a generic routine that clears all state information in the private section or to custom routines that clear the conversion context for each specific conversion. </p><p>Only <code>state1</code>, <code>state2</code>, <code>state3</code>, and <code>state4</code> of the <code>TECPluginStateRec</code> structure are used for storing plug-in state information. But you can use the rest in any way you want.</p><div class="codesample"><table><tr><td scope="row"><pre>struct TECPluginStateRec {<span></span></pre></td></tr><tr><td scope="row"><pre>UInt8 state1;<span></span></pre></td></tr><tr><td scope="row"><pre>UInt8 state2;<span></span></pre></td></tr><tr><td scope="row"><pre>UInt8 state3;<span></span></pre></td></tr><tr><td scope="row"><pre>UInt8 state4;<span></span></pre></td></tr><tr><td scope="row"><pre>UInt32 longState1;<span></span></pre></td></tr><tr><td scope="row"><pre>UInt32 longState2;<span></span></pre></td></tr><tr><td scope="row"><pre>UInt32 longState3;<span></span></pre></td></tr><tr><td scope="row"><pre>UInt32 longState4;<span></span></pre></td></tr><tr><td scope="row"><pre>};<span></span></pre></td></tr><tr><td scope="row"><pre>typedef struct TECPluginStateRec TECPluginStateRec;<span></span></pre></td></tr></table></div><p>When a converter object is created, the creation routine pointed to by <code>PluginNewEncodingConverter</code>, a routine pointer defined in the plug-in dispatch table, is called by the Text Encoding Conversion Manager to allow the plug-in to set up its <code>TECConverterContextRec</code> structure. This creation routine sets up the conversion routine pointer, clear context information routine pointer, flush routine pointer, and the context reference value.</p><p>The <code>TECConverterContextRec</code> structure needs to contain all the information the plug-in required to perform conversions between the encodings specified in <code>inputEncoding</code> and <code>outputEncoding</code>.</p><p>Note that text encoding specifications (type <code>TextEncoding</code>) are considered private structures. They are defined as of type <code>UInt32</code> and can be passed by value. Text encoding specifications are persistent objects. For example,</p><div class="codesample"><table><tr><td scope="row"><pre>static OSStatus ConverterPluginNewEncodingConverter(<span></span></pre></td></tr><tr><td scope="row"><pre>    TECObjectRef *newEncodingConverter,<span></span></pre></td></tr><tr><td scope="row"><pre>    TECConverterContextRec *plugContext,<span></span></pre></td></tr><tr><td scope="row"><pre>    TextEncoding inputEncoding,<span></span></pre></td></tr><tr><td scope="row"><pre>    TextEncoding outputEncoding)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>#pragma unused( newEncodingConverter )<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    OSStatus status = noErr;<span></span></pre></td></tr><tr><td scope="row"><pre>    TextEncoding encodingKSC_5601_87 = CreateTextEncoding(kTextEncodingKSC_5601_87,<span></span></pre></td></tr><tr><td scope="row"><pre>            kTextEncodingDefaultVariant, kTextEncodingDefaultFormat);<span></span></pre></td></tr><tr><td scope="row"><pre>    TextEncoding encodingISO_2022_KR =<span></span></pre></td></tr><tr><td scope="row"><pre>         CreateTextEncoding(kTextEncodingISO_2022_KR,<span></span></pre></td></tr><tr><td scope="row"><pre>            kTextEncodingDefaultVariant, kTextEncodingDefaultFormat);<span></span></pre></td></tr><tr><td scope="row"><pre>    TextEncoding encodingEUC_KR = CreateTextEncoding(kTextEncodingEUC_KR,<span></span></pre></td></tr><tr><td scope="row"><pre>            kTextEncodingDefaultVariant, kTextEncodingDefaultFormat);<span></span></pre></td></tr><tr><td scope="row"><pre>    TextEncoding encodingMacKorean =<span></span></pre></td></tr><tr><td scope="row"><pre>         CreateTextEncoding(kTextEncodingMacKorean,<span></span></pre></td></tr><tr><td scope="row"><pre>            kTextEncodingDefaultVariant, kTextEncodingDefaultFormat);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    /* initialize private data in plugContext */<span></span></pre></td></tr><tr><td scope="row"><pre>    plugContext->conversionProc = nil;<span></span></pre></td></tr><tr><td scope="row"><pre>    plugContext->clearContextInfoProc = nil;<span></span></pre></td></tr><tr><td scope="row"><pre>    plugContext->flushProc = nil;<span></span></pre></td></tr><tr><td scope="row"><pre>    plugContext->contextRefCon = (unsigned long)nil;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    /* create the converter if possible */<span></span></pre></td></tr><tr><td scope="row"><pre>    if (inputEncoding == encodingKSC_5601_87) {<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        if (outputEncoding == encodingEUC_KR || outputEncoding == encodingMacKorean) {<span></span></pre></td></tr><tr><td scope="row"><pre>            plugContext->conversionProc = (ProcPtr) &amp;ConvertKSC_5601toEUC_KR;<span></span></pre></td></tr><tr><td scope="row"><pre>            plugContext->clearContextInfoProc = (ProcPtr) &amp;ClearConverterContext;<span></span></pre></td></tr><tr><td scope="row"><pre>        } else{<span></span></pre></td></tr><tr><td scope="row"><pre>            status = kTextUnsupportedEncodingErr;<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    } else if (inputEncoding ==  encodingISO_2022_KR) {<span></span></pre></td></tr><tr><td scope="row"><pre>        if (outputEncoding == encodingEUC_KR || outputEncoding == encodingMacKorean) {<span></span></pre></td></tr><tr><td scope="row"><pre>            plugContext->conversionProc = (ProcPtr) &amp;ConvertISO2022KRtoEUC_KR;<span></span></pre></td></tr><tr><td scope="row"><pre>            plugContext->clearContextInfoProc = (ProcPtr) &amp;ClearConverterContext;<span></span></pre></td></tr><tr><td scope="row"><pre>    } else {<span></span></pre></td></tr><tr><td scope="row"><pre>        status = kTextUnsupportedEncodingErr;<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>    } else if (inputEncoding ==  encodingEUC_KR ||<span></span></pre></td></tr><tr><td scope="row"><pre>                inputEncoding == encodingMacKorean) {<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if (outputEncoding == encodingKSC_5601_87) {<span></span></pre></td></tr><tr><td scope="row"><pre>        plugContext->conversionProc = (ProcPtr) &amp;ConvertEUC_KRtoKSC_5601;<span></span></pre></td></tr><tr><td scope="row"><pre>        plugContext->clearContextInfoProc = (ProcPtr) &amp;ClearConverterContext;<span></span></pre></td></tr><tr><td scope="row"><pre>    } else if (outputEncoding == encodingISO_2022_KR) {<span></span></pre></td></tr><tr><td scope="row"><pre>        plugContext->conversionProc = (ProcPtr) &amp;ConvertEUC_KRtoISO2022KR;<span></span></pre></td></tr><tr><td scope="row"><pre>        plugContext->clearContextInfoProc = (ProcPtr) &amp;ClearConverterContext;<span></span></pre></td></tr><tr><td scope="row"><pre>        plugContext->flushProc = (ProcPtr) &amp;FlushTextEUC_KRtoISO_2022_KR;<span></span></pre></td></tr><tr><td scope="row"><pre>    } else{status = kTextUnsupportedEncodingErr;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    } else {<span></span></pre></td></tr><tr><td scope="row"><pre>        status = kTextUnsupportedEncodingErr;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    return status;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr></table></div><p>The clear context routine pointed to by <code>PluginClearContextInfo</code>, a routine pointer defined in the plug-in dispatch table, is called to clear out the plug-in context or state information to prepare for a new conversion of the same type. It is always called by the Text Encoding Conversion Manager right after creating the converter object. For example,</p><div class="codesample"><table><tr><td scope="row"><pre>static OSStatus ConverterPluginClearContextInfo(<span></span></pre></td></tr><tr><td scope="row"><pre>TECObjectRef encodingConverter,<span></span></pre></td></tr><tr><td scope="row"><pre>TECConverterContextRec *plugContext)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>OSStatus status = noErr;<span></span></pre></td></tr><tr><td scope="row"><pre>status = (<span></span></pre></td></tr><tr><td scope="row"><pre>*((TECPluginClearContextInfoPtr) (plugContext->clearContextInfoProc))<span></span></pre></td></tr><tr><td scope="row"><pre>) (encodingConverter, plugContext);<span></span></pre></td></tr><tr><td scope="row"><pre>return status;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>The pointer <code>plugContext->clearContextInfoProc</code> points to a clear context routine. It is set up in the <code>ConverterPluginNewEncodingConverter</code> routine above when a converter object is created. For example,</p><div class="codesample"><table><tr><td scope="row"><pre>OSStatus ClearConverterContext(<span></span></pre></td></tr><tr><td scope="row"><pre>TECObjectRef encodingConverter,<span></span></pre></td></tr><tr><td scope="row"><pre>TECConverterContextRec *plugContext)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>#pragma unused (encodingConverter)<span></span></pre></td></tr><tr><td scope="row"><pre>OSStatus status = noErr;<span></span></pre></td></tr><tr><td scope="row"><pre>if (plugContext)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>// for normal state<span></span></pre></td></tr><tr><td scope="row"><pre>plugContext->pluginState.state1 = kASCIIState;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>// for shift in/out state<span></span></pre></td></tr><tr><td scope="row"><pre>plugContext->pluginState.state2 = kShiftInState;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>// for saved byte<span></span></pre></td></tr><tr><td scope="row"><pre>plugContext->pluginState.state3 = kNullSaveByte;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>// for pure KSC &lt;-> EUC conversion<span></span></pre></td></tr><tr><td scope="row"><pre>plugContext->pluginState.state4 = kKSC5601_92State;<span></span></pre></td></tr><tr><td scope="row"><pre>plugContext->pluginState.longState1 = 0;<span></span></pre></td></tr><tr><td scope="row"><pre>plugContext->pluginState.longState2 = 0;<span></span></pre></td></tr><tr><td scope="row"><pre>plugContext->pluginState.longState3 = 0;<span></span></pre></td></tr><tr><td scope="row"><pre>plugContext->pluginState.longState4 = 0;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>else<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>status = paramErr;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre>return status;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>Note that you may directly call a particular <code>ClearConverterContext</code> routine<code></code>in the <code>ConverterPluginClearContextInfo</code> routine for clearing the converter context if you don’t care what the conversion is. The Text Encoding Conversion Manager provides a convenient way, using the routine pointer <code>plugContext->clearContextInfoProc</code>, to call a clear context routine that is set up according to the input and output encodings when the converter object is created.</p><p>The conversion routine pointed to by <code>PluginConvertTextEncoding</code>, a routine pointer defined in the plug-in dispatch table, is called to perform the actual encoding conversion. </p><p>The <code>bufferContext</code> field of a structure of type <code>TECBufferContextRec</code>—used for the <code>TECConverterContextRec</code> parameter of the conversion routine—points to the beginning and end of the input and output buffers.</p><p>The plug-in should convert the text in the input buffer to the desired encoding and place it in the output buffer, deciding how much of the input text it can convert and fit in the output buffer. Upon exit, the plug-in needs to update the <code>inputBuffer</code> and <code>outputBuffer</code> pointers to reflect how much of the text was converted an how large the output was. The plug-in should save all necessary state information so that it can continue the conversion where it left off in the event that all of the input text could not fit, after conversion, in the output buffer. When converting the text, convert as much of the input text as you can and still fit the converted text in the output buffer. For example,</p><div class="codesample"><table><tr><td scope="row"><pre>static OSStatus ConverterPluginConvertTextEncoding(<span></span></pre></td></tr><tr><td scope="row"><pre>TECObjectRef encodingConverter, TECConverterContextRec *plugContext)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>OSStatus status = noErr;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>status =  (<span></span></pre></td></tr><tr><td scope="row"><pre>*((TECPluginConvertTextEncodingPtr) (plugContext->conversionProc)))<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>(encodingConverter, plugContext);<span></span></pre></td></tr><tr><td scope="row"><pre>return status;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr></table></div><p>The pointer <code>plugContext->conversionProc</code> points to a encoding conversion routine. It is setup in the <code>ConverterPluginNewEncodingConverter</code> routine above when a converter object is created. For example,</p><div class="codesample"><table><tr><td scope="row"><pre>OSStatus ConvertISO2022KRtoEUC_KR(<span></span></pre></td></tr><tr><td scope="row"><pre>TECObjectRef encodingConverter, TECConverterContextRec *plugContext)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>#pragma unused (encodingConverter)<span></span></pre></td></tr><tr><td scope="row"><pre>OSStatus status = noErr;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>if (plugContext) {<span></span></pre></td></tr><tr><td scope="row"><pre>BytePtr inBuf  = plugContext->bufferContext.textInputBuffer;<span></span></pre></td></tr><tr><td scope="row"><pre>BytePtr inEnd  = plugContext->bufferContext.textInputBufferEnd;<span></span></pre></td></tr><tr><td scope="row"><pre>BytePtr outBuf = plugContext->bufferContext.textOutputBuffer;<span></span></pre></td></tr><tr><td scope="row"><pre>BytePtr outEnd = plugContext->bufferContext.textOutputBufferEnd;<span></span></pre></td></tr><tr><td scope="row"><pre>Byte saveByte;<span></span></pre></td></tr><tr><td scope="row"><pre>UInt8 escState, shiftState;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/* get state information */<span></span></pre></td></tr><tr><td scope="row"><pre>escState = plugContext->pluginState.state1;<span></span></pre></td></tr><tr><td scope="row"><pre>shiftState = plugContext->pluginState.state2;<span></span></pre></td></tr><tr><td scope="row"><pre>saveByte = plugContext->pluginState.state3;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/* perform conversion */<span></span></pre></td></tr><tr><td scope="row"><pre>/* no error message yet if there is no input */<span></span></pre></td></tr><tr><td scope="row"><pre>while ((inBuf &lt; inEnd) &amp;&amp; (status == noErr))<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>status = HandleState(*inBuf, &amp;escState, &amp;shiftState,<span></span></pre></td></tr><tr><td scope="row"><pre>&amp;saveByte, &amp;outBuf, outEnd);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/* Check if the buffer full status is actually */<span></span></pre></td></tr><tr><td scope="row"><pre>/* a buffer below minimum size error. */<span></span></pre></td></tr><tr><td scope="row"><pre>/* And advance the input buffer if appropriate. */<span></span></pre></td></tr><tr><td scope="row"><pre>PostProcess(plugContext->bufferContext.textOutputBuffer,<span></span></pre></td></tr><tr><td scope="row"><pre>outBuf, &amp;inBuf, inEnd, &amp;escState, &amp;status);<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre>/* save state information */<span></span></pre></td></tr><tr><td scope="row"><pre>plugContext->pluginState.state1 = escState;<span></span></pre></td></tr><tr><td scope="row"><pre>plugContext->pluginState.state2 = shiftState;<span></span></pre></td></tr><tr><td scope="row"><pre>plugContext->pluginState.state3 = saveByte;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/* save new buffer positions */<span></span></pre></td></tr><tr><td scope="row"><pre>plugContext->bufferContext.textOutputBuffer = outBuf;<span></span></pre></td></tr><tr><td scope="row"><pre>plugContext->bufferContext.textInputBuffer  = inBuf;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>else<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>status = paramErr;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>return status;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>Note that you may not directly use the <code>ConverterPluginConvertTextEncoding</code> routine for converting the encodings because you don’t have the conversion information. The Text Encoding Conversion Manager provides a convenient way to call a conversion routine that is set up according to the input and output encodings.</p><p>The destruction routine pointed to by <code>PluginDisposeEncodingConverter</code>, a routine pointer defined in the plug-in dispatch table, is called for each plug-in referenced in a converter object when it is disposed of. The plug-in is responsible for disposing of any memory or other resources such as conversion tables it may have created or loaded from disk in the creation routine. For example,</p><div class="codesample"><table><tr><td scope="row"><pre>static OSStatus ConverterPluginDisposeEncodingConverter(<span></span></pre></td></tr><tr><td scope="row"><pre>TECObjectRef newEncodingConverter,<span></span></pre></td></tr><tr><td scope="row"><pre>TECConverterContextRec *plugContext)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>OSStatus status = noErr;<span></span></pre></td></tr><tr><td scope="row"><pre>return status;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>The flush routine pointed to by <code>PluginFlushConversion</code>, a routine pointer defined in the plug-in dispatch table, is called to flush the output buffer to certain mode. For example, this is needed in the <code>EUC_KR</code> to <code>ISO2022_KR</code> conversion because after an input buffer has been consumed, a shift in sequence may be needed to change back to ASCII mode in the output buffer.</p><div class="codesample"><table><tr><td scope="row"><pre>OSStatus FlushTextEUC_KRtoISO_2022_KR(<span></span></pre></td></tr><tr><td scope="row"><pre>TECObjectRef encodingConverter,<span></span></pre></td></tr><tr><td scope="row"><pre>TECConverterContextRec *plugContext)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>#pragma unused( encodingConverter )<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>OSStatus status = noErr;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>if (plugContext)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>BytePtr outBuf = plugContext->bufferContext.textOutputBuffer;<span></span></pre></td></tr><tr><td scope="row"><pre>BytePtr outEnd = plugContext->bufferContext.textOutputBufferEnd;<span></span></pre></td></tr><tr><td scope="row"><pre>UInt8 isoState, shiftState;<span></span></pre></td></tr><tr><td scope="row"><pre>Byte saveByte;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>isoState = plugContext->pluginState.state1;<span></span></pre></td></tr><tr><td scope="row"><pre>shiftState = plugContext->pluginState.state2;<span></span></pre></td></tr><tr><td scope="row"><pre>saveByte = plugContext->pluginState.state3;<span></span></pre></td></tr><tr><td scope="row"><pre>if (shiftState != kShiftInState) {<span></span></pre></td></tr><tr><td scope="row"><pre>/* Shift in sequence */<span></span></pre></td></tr><tr><td scope="row"><pre>status = OutputEscapeSequence(<span></span></pre></td></tr><tr><td scope="row"><pre>kShiftInState, &amp;outBuf, outEnd);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>if (status == noErr)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/* Remember to reset back to shift in mode if no error */<span></span></pre></td></tr><tr><td scope="row"><pre>isoState = kDesignationState;<span></span></pre></td></tr><tr><td scope="row"><pre>shiftState = kShiftInState;<span></span></pre></td></tr><tr><td scope="row"><pre>saveByte = kNullSaveByte;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/* Check if the buffer full status is actually */<span></span></pre></td></tr><tr><td scope="row"><pre>/* a buffer below minimum size error */<span></span></pre></td></tr><tr><td scope="row"><pre>if ((status == kTECOutputBufferFullStatus) &amp;&amp;<span></span></pre></td></tr><tr><td scope="row"><pre>(outBuf == plugContext->bufferContext.textOutputBuffer))<span></span></pre></td></tr><tr><td scope="row"><pre>status = kTECBufferBelowMinimumSizeErr;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/* Save state information &amp; new buffer positions */<span></span></pre></td></tr><tr><td scope="row"><pre>plugContext->pluginState.state1 = isoState;<span></span></pre></td></tr><tr><td scope="row"><pre>plugContext->pluginState.state2 = shiftState;<span></span></pre></td></tr><tr><td scope="row"><pre>plugContext->pluginState.state3 = saveByte;<span></span></pre></td></tr><tr><td scope="row"><pre>plugContext->bufferContext.textOutputBuffer = outBuf;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>else<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>status = paramErr;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>return status;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><div class="notebox"><a name="//apple_ref/doc/uid/TP40000932-CH203-DontLinkElementID_66" title="Note"></a><p><strong>Note:</strong>&nbsp;UTF7 maintains an internal bit buffer that needs to be flushed. </p></div><p>The following routines, defined in the plug-in dispatch table, provide information to the Text Encoding Conversion Manager to find out what services are available to it in each of its plug-ins. These services include which encodings the plug-in knows about and which conversions it can perform on those encodings.</p><p>Some routines may be replaced by resources. Resources are preferable. However, in some cases, you might want to use the routines—for example, for the Unicode plug-in, which needs to scan tables. </p><p>The routine pointed to by <code>PluginGetCountAvailableTextEncodings</code>, a routine pointer defined in the plug-in dispatch table, counts the actual number of available text encodings and fills in an array of type <code>TextEncoding</code> with the encodings supported by the plug-in. This is used by the <code>TECGetAvailableTextEncodings</code> routine in the Text Encoding Conversion Manager.</p><div class="codesample"><table><tr><td scope="row"><pre>typedef OSStatus (*TECPluginGetCountAvailableTextEncodingsPtr)<span></span></pre></td></tr><tr><td scope="row"><pre>(TextEncoding *availableEncodings,<span></span></pre></td></tr><tr><td scope="row"><pre>ItemCount maxAvailableEncodings,<span></span></pre></td></tr><tr><td scope="row"><pre>ItemCount *actualAvailableEncodings);<span></span></pre></td></tr></table></div><p></p><p>The routine pointed to by <code>PluginGetCountAvailableTextEncodingPairs</code>, a routine pointer defined in the plug-in dispatch table, counts the actual number of available text encoding conversions and fills in an array of type <code>TECConversionInfo</code> with the encoding conversions supported by the plug-in. This is used by the <code>TECGetAvailableTextEncodings</code> routine in the Text Encoding Conversion Manager.</p><div class="codesample"><table><tr><td scope="row"><pre>typedef OSStatus (*TECPluginGetCountAvailableTextEncodingPairsPtr)<span></span></pre></td></tr><tr><td scope="row"><pre>(TECConversionInfo *availableEncodings,<span></span></pre></td></tr><tr><td scope="row"><pre>ItemCount maxAvailableEncodings,<span></span></pre></td></tr><tr><td scope="row"><pre>ItemCount *actualAvailableEncodings);<span></span></pre></td></tr></table></div><p>A <code>TECConversionInfo</code> structure is used to describe conversion services available in a plug-in. Each plug-in is required to provide information about the actual encoding conversions in a given buffer. This is used by <code>TECGetDirectTextEncodingConversions</code> in the Text Encoding Conversion Manager.</p><div class="codesample"><table><tr><td scope="row"><pre>struct TECConversionInfo {<span></span></pre></td></tr><tr><td scope="row"><pre>TextEncoding sourceEncoding;<span></span></pre></td></tr><tr><td scope="row"><pre>TextEncoding destinationEncoding;<span></span></pre></td></tr><tr><td scope="row"><pre>UInt16 reserved1;<span></span></pre></td></tr><tr><td scope="row"><pre>UInt16 reserved2;<span></span></pre></td></tr><tr><td scope="row"><pre>};<span></span></pre></td></tr></table></div><p>Each structure contains a pair of source and destination encodings that describes the kind of conversion the plug-in can perform. An encoding is created by using the <code>CreateTextEncoding</code> function. For example,</p><div class="codesample"><table><tr><td scope="row"><pre>TextEncoding encodingKSC_5601_87 = CreateTextEncoding(<span></span></pre></td></tr><tr><td scope="row"><pre>kTextEncodingKSC_5601_87,<span></span></pre></td></tr><tr><td scope="row"><pre>kTextEncodingDefaultVariant,<span></span></pre></td></tr><tr><td scope="row"><pre>kTextEncodingDefaultFormat<span></span></pre></td></tr><tr><td scope="row"><pre>);<span></span></pre></td></tr></table></div><p>The variant and format are discussed in conjunction with the resource of type <code>kTECAvailableEncodingsResType</code> later in this appendix.</p><p>The routine pointed to by <code>PluginGetCountDestinationTextEncodings</code>, a routine pointer defined in the plug-in dispatch table, counts the actual number of available destination text encodings. The routine also fills in an array of type <code>TextEncoding</code> with all the text encodings that the parameter <code>inputEncoding</code> can be directly converted to in one step. This routine is used by the Text Encoding Conversion Manager to find and evaluate paths from one encoding to another.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40000932-CH203-DontLinkElementID_67" title="Note"></a><p><strong>Note:</strong>&nbsp;A conversion may go through many intermediate encodings.</p></div><div class="codesample"><table><tr><td scope="row"><pre>typedef OSStatus (*TECPluginGetCountDestinationTextEncodingsPtr)<span></span></pre></td></tr><tr><td scope="row"><pre>(TextEncoding inputEncoding,<span></span></pre></td></tr><tr><td scope="row"><pre>TextEncoding *destinationEncodings,<span></span></pre></td></tr><tr><td scope="row"><pre>ItemCount maxDestinationEncodings,<span></span></pre></td></tr><tr><td scope="row"><pre>ItemCount *actualDestinationEncodings<span></span></pre></td></tr><tr><td scope="row"><pre>);<span></span></pre></td></tr></table></div><p>The routine pointed to by <code>PluginGetCountSubTextEncodings</code>, a routine pointer defined in the plug-in dispatch table, finds out which subencodings are packaged within a text encoding. For example EUC-JP and ISO 2022-JP both contain JIS X0208, JIS X0212, JIS Roman, and half-width Katakana.</p><div class="codesample"><table><tr><td scope="row"><pre>typedef OSStatus (*TECPluginGetCountSubTextEncodingsPtr)<span></span></pre></td></tr><tr><td scope="row"><pre>(TextEncoding inputEncoding,<span></span></pre></td></tr><tr><td scope="row"><pre>TextEncoding subEncodings[],<span></span></pre></td></tr><tr><td scope="row"><pre>ItemCount maxSubEncodings,<span></span></pre></td></tr><tr><td scope="row"><pre>ItemCount *actualSubEncodings);<span></span></pre></td></tr></table></div><p>The routine pointed to by <code>PluginGetCountAvailableSniffers</code>, a routine pointer defined in the plug-in dispatch table, counts the actual number of available sniffers and fills in an array of type <code>TextEncoding</code> with the encodings that can be sniffed by the plug-in.</p><div class="codesample"><table><tr><td scope="row"><pre>typedef OSStatus (*TECPluginGetCountAvailableSniffersPtr)<span></span></pre></td></tr><tr><td scope="row"><pre>(TextEncoding *availableEncodings,<span></span></pre></td></tr><tr><td scope="row"><pre>ItemCount maxAvailableEncodings,<span></span></pre></td></tr><tr><td scope="row"><pre>ItemCount *actualAvailableEncodings);<span></span></pre></td></tr></table></div><p>The routine pointed to by <code>PluginGetTextEncodingInternetName</code>, a routine pointer defined in the plug-in dispatch table, finds the name of a text encoding as it would appear in a Multipurpose Internet Mail Extensions (MIME) header. The routine pointed to by <code>PluginGetTextEncodingFromInternetName </code>performs the inverse.</p><div class="codesample"><table><tr><td scope="row"><pre>typedef OSStatus (*TECPluginGetTextEncodingInternetNamePtr)<span></span></pre></td></tr><tr><td scope="row"><pre>(TextEncoding textEncoding,<span></span></pre></td></tr><tr><td scope="row"><pre>Str255 encodingName);<span></span></pre></td></tr><tr><td scope="row"><pre>typedef OSStatus (*TECPluginGetTextEncodingFromInternetNamePtr)<span></span></pre></td></tr><tr><td scope="row"><pre>(TextEncoding *textEncoding,<span></span></pre></td></tr><tr><td scope="row"><pre>ConstStr255Param encodingName);<span></span></pre></td></tr></table></div><p>The routine pointed to by <code>PluginGetCountWebTextEncodings</code>, a routine pointer defined in the plug-in dispatch table, counts the actual number of available Web encodings and fills in an array of type <code>TextEncoding</code> with the Web encodings. These encodings might appear in a Web browser encoding menu. </p><div class="codesample"><table><tr><td scope="row"><pre>typedef OSStatus (*TECPluginGetCountWebEncodingsPtr)<span></span></pre></td></tr><tr><td scope="row"><pre>(TextEncoding *availableEncodings,<span></span></pre></td></tr><tr><td scope="row"><pre>ItemCount maxAvailableEncodings,<span></span></pre></td></tr><tr><td scope="row"><pre>ItemCount *actualAvailableEncodings);<span></span></pre></td></tr></table></div><p>The routine pointed to by <code>PluginGetCountMailTextEncodings</code>, a routine pointer defined in the plug-in dispatch table, counts the actual number of available mail encodings and fills in an array of type <code>TextEncoding</code> with the mail encodings. These encodings might appear in an email transfer encoding menu. </p><div class="codesample"><table><tr><td scope="row"><pre>typedef OSStatus (*TECPluginGetCountMailEncodingsPtr)<span></span></pre></td></tr><tr><td scope="row"><pre>(TextEncoding *availableEncodings,<span></span></pre></td></tr><tr><td scope="row"><pre>ItemCount maxAvailableEncodings,<span></span></pre></td></tr><tr><td scope="row"><pre>ItemCount *actualAvailableEncodings);<span></span></pre></td></tr></table></div><p>To facilitate plug-in development, avoid duplicate code, and eventually avoid unnecessarily loading a plug-in, certain data access plug-in methods can be implemented as resources. If these resources are present, the corresponding routines are never called. If this information is not available until runtime, such as is the case with the Unicode plug-in, which needs to find out which conversion tables are available, then the plug-in is loaded and the corresponding routine is called instead. If all of these are implemented as resources, then initialization of the Text Encoding Conversion Manager occurs more quickly because you don’t need to load your plug-in fragment until it is required. </p><p>All resource IDs are <code>kTECResourceID</code>.</p><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Resource macro</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Replaces Routines</p></th></tr><tr><td  scope="row"><p><code>kTECAvailableEncodingsResType</code></p></td><td ><p><code>PluginGetCountAvailableTextEncodings</code></p></td></tr><tr><td  scope="row"><p><code>kTECConversionInfoResType</code></p></td><td ><p><code>PluginGetCountAvailableTextEncodingPairs</code></p></td></tr><tr><td  scope="row"><p></p></td><td ><p><code>PluginGetCountDestinationTextEncodings</code></p></td></tr><tr><td  scope="row"><p><code>kTECInternetNamesResType</code></p></td><td ><p><code>PluginGetTextEncodingInternetName PluginGetTextEncodingFromInternetName</code></p></td></tr><tr><td  scope="row"><p><code>kTECLocalizedNamesResType</code></p></td><td ><p><code>PluginGetTextEncodingLocalizedName</code></p></td></tr><tr><td  scope="row"><p><code>kTECAvailableSniffersResType</code></p></td><td ><p><code>PluginGetCountAvailableSniffers</code></p></td></tr><tr><td  scope="row"><p><code>kTECWebEncodingsResType</code></p></td><td ><p><code>PluginGetCountWebTextEncodings</code></p></td></tr><tr><td  scope="row"><p><code>kTECMailEncodingsResType</code></p></td><td ><p><code>PluginGetCountMailTextEncodings</code></p></td></tr><tr><td  scope="row"><p><code>kTECSubTextEncodingsResType</code></p></td><td ><p><code>PluginGetCountSubTextEncodings</code></p></td></tr></table></div><p>The above resources are discussed below.</p><p>The following resource type provides information that tells which encodings the plug-in knows about. </p><div class="codesample"><table><tr><td scope="row"><pre>/* supported encodings list */<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>type kTECAvailableEncodingsResType {<span></span></pre></td></tr><tr><td scope="row"><pre>    longint = $$CountOf (memberArray);<span></span></pre></td></tr><tr><td scope="row"><pre>    Array memberArray {<span></span></pre></td></tr><tr><td scope="row"><pre>        memberStart:<span></span></pre></td></tr><tr><td scope="row"><pre>        TECTextEncoding             /* encoding */<span></span></pre></td></tr><tr><td scope="row"><pre>        memberEnd:<span></span></pre></td></tr><tr><td scope="row"><pre>    };<span></span></pre></td></tr><tr><td scope="row"><pre>};<span></span></pre></td></tr></table></div><p>For example,</p><div class="codesample"><table><tr><td scope="row"><pre>resource kTECAvailableEncodingsResType (kTECResourceID) {<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>kTextEncodingKSC_5601_87, kTextEncodingDefaultVariant,<span></span></pre></td></tr><tr><td scope="row"><pre>kTextEncodingDefaultFormat,<span></span></pre></td></tr><tr><td scope="row"><pre>kTextEncodingISO_2022_KR, kTextEncodingDefaultVariant,<span></span></pre></td></tr><tr><td scope="row"><pre>kTextEncodingDefaultFormat,<span></span></pre></td></tr><tr><td scope="row"><pre>kTextEncodingMacKorean,<span></span></pre></td></tr><tr><td scope="row"><pre>kTextEncodingDefaultVariant,<span></span></pre></td></tr><tr><td scope="row"><pre>kTextEncodingDefaultFormat,<span></span></pre></td></tr><tr><td scope="row"><pre>kTextEncodingEUC_KR,<span></span></pre></td></tr><tr><td scope="row"><pre>kTextEncodingDefaultVariant,<span></span></pre></td></tr><tr><td scope="row"><pre>kTextEncodingDefaultFormat,<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre>};<span></span></pre></td></tr></table></div><p>The above example shows that there are four encodings, namely, <code>kTextEncodingKSC_5601_87</code>, <code>kTextEncodingISO_2022_KR</code>, <code>kTextEncodingMacKorean</code>, and <code>kTextEncodingEUC_KR</code>, that this plug-in knows about. Since the encodings do not have special variants and formats, default variants and formats are used. If a plug-in supports different variants and formats, the text encodings must appear in the list. </p><p>The first value in the resource entries above, <code>kTextEncodingKSC_5601_87 (0x0640)</code>, with type <code>TextEncodingBase</code> (<code>UInt32</code>), as defined in <code>TextCommon.h</code>, is the primary specification of the source or destination encoding. The values 0 through 32 (0x00 through 0x0020) correspond to Mac OS script codes.</p><p>The second value, with type <code>TextEncodingVariant</code> (<code>UInt32</code>), specifies the minor variant of the base encoding. For a given <code>TextEncodingBase</code>, the enumeration of variants always begins with 0. The value <code>kTextEncodingDefaultVariant</code> specifies the default variant of the base encoding.</p><p>The last value, with type <code>TextEncodingFormat</code> (<code>UInt32</code>), designates a particular way of algorithmically transforming a particular encoding, say for transmission through communication channels that may handle only 7-bit values. These transformations are not viewed as different encodings, but merely as different formats for representing the same encoding. The value <code>kTextEncodingDefaultFormat</code> specifies the default format of the base encoding.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40000932-CH203-DontLinkElementID_68" title="Note"></a><p><strong>Note:</strong>&nbsp;Only Unicode encodings can take non-zero formats currently.</p></div><p>The following resource type provides information identifying which encoding conversions the plug-in can perform.</p><div class="codesample"><table><tr><td scope="row"><pre>/* Conversion pairs */<span></span></pre></td></tr><tr><td scope="row"><pre>type kTECConversionInfoResType {<span></span></pre></td></tr><tr><td scope="row"><pre>    longint = $$CountOf (memberArray);<span></span></pre></td></tr><tr><td scope="row"><pre>    Array memberArray {<span></span></pre></td></tr><tr><td scope="row"><pre>        memberStart:<span></span></pre></td></tr><tr><td scope="row"><pre>        TECTextEncoding                     /* source encoding */<span></span></pre></td></tr><tr><td scope="row"><pre>        TECTextEncoding                     /* dest encoding */<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        longint res1;      /* reserved - free */<span></span></pre></td></tr><tr><td scope="row"><pre>        longint res2;      /* reserved - free   */<span></span></pre></td></tr><tr><td scope="row"><pre>        memberEnd:<span></span></pre></td></tr><tr><td scope="row"><pre>    };<span></span></pre></td></tr><tr><td scope="row"><pre>};<span></span></pre></td></tr></table></div><p>For example,</p><div class="codesample"><table><tr><td scope="row"><pre>resource kTECConversionInfoResType (kTECResourceID) {<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>/* Round trip KSC 5601 to MacKorean */<span></span></pre></td></tr><tr><td scope="row"><pre>kTextEncodingKSC_5601_87, kTextEncodingDefaultVariant,<span></span></pre></td></tr><tr><td scope="row"><pre>kTextEncodingDefaultFormat,<span></span></pre></td></tr><tr><td scope="row"><pre>kTextEncodingMacKorean, kTextEncodingDefaultVariant,<span></span></pre></td></tr><tr><td scope="row"><pre>kTextEncodingDefaultFormat, 0, 0, kTextEncodingMacKorean,<span></span></pre></td></tr><tr><td scope="row"><pre>kTextEncodingDefaultVariant, kTextEncodingDefaultFormat,<span></span></pre></td></tr><tr><td scope="row"><pre>kTextEncodingKSC_5601_87, kTextEncodingDefaultVariant,<span></span></pre></td></tr><tr><td scope="row"><pre>kTextEncodingDefaultFormat, 0, 0,<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/* Round trip ISO 2022 to MacKorean */<span></span></pre></td></tr><tr><td scope="row"><pre>kTextEncodingISO_2022_KR, kTextEncodingDefaultVariant,<span></span></pre></td></tr><tr><td scope="row"><pre>kTextEncodingDefaultFormat,<span></span></pre></td></tr><tr><td scope="row"><pre>kTextEncodingMacKorean, kTextEncodingDefaultVariant,<span></span></pre></td></tr><tr><td scope="row"><pre>kTextEncodingDefaultFormat, 0, 0, kTextEncodingMacKorean,<span></span></pre></td></tr><tr><td scope="row"><pre>kTextEncodingDefaultVariant, kTextEncodingDefaultFormat,<span></span></pre></td></tr><tr><td scope="row"><pre>kTextEncodingISO_2022_KR, kTextEncodingDefaultVariant,<span></span></pre></td></tr><tr><td scope="row"><pre>kTextEncodingDefaultFormat, 0, 0,<span></span></pre></td></tr><tr><td scope="row"><pre>...<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre>};<span></span></pre></td></tr></table></div><p>The following resource type provides the name of a text encoding as it would appear in a Multipurpose Internet Mail Extensions (MIME) header. Multiple encodings can map to one Internet MIME name, but an Internet MIME name maps only to the first encoding found.</p><div class="codesample"><table><tr><td scope="row"><pre>/* Internet names */<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>type kTECInternetNamesResType {<span></span></pre></td></tr><tr><td scope="row"><pre>    longint = $$CountOf (memberArray);<span></span></pre></td></tr><tr><td scope="row"><pre>    Array memberArray {<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    memberStart:<span></span></pre></td></tr><tr><td scope="row"><pre>    ListStart:<span></span></pre></td></tr><tr><td scope="row"><pre>    longint = (ListEnd[$$ArrayIndex(memberArray)] -<span></span></pre></td></tr><tr><td scope="row"><pre>        ListStart[$$ArrayIndex(memberArray)]) / 8 - 4;<span></span></pre></td></tr><tr><td scope="row"><pre>                                    /* offset to next item */<span></span></pre></td></tr><tr><td scope="row"><pre>    TECTextEncoding                                 /* text encoding of name */<span></span></pre></td></tr><tr><td scope="row"><pre>    pstring;                                        /* encoding name */<span></span></pre></td></tr><tr><td scope="row"><pre>    align long;                                 /* match size to C structure size */<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    ListEnd:<span></span></pre></td></tr><tr><td scope="row"><pre>    memberEnd:<span></span></pre></td></tr><tr><td scope="row"><pre>    };<span></span></pre></td></tr><tr><td scope="row"><pre>};<span></span></pre></td></tr></table></div><p>For example,</p><div class="codesample"><table><tr><td scope="row"><pre>resource kTECInternetNamesResType (kTECResourceID) {<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>kTextEncodingKSC_5601_87, kTextEncodingDefaultVariant,<span></span></pre></td></tr><tr><td scope="row"><pre>kTextEncodingDefaultFormat,<span></span></pre></td></tr><tr><td scope="row"><pre>"KS_C_5601-1987",<span></span></pre></td></tr><tr><td scope="row"><pre>kTextEncodingKSC_5601_87, kTextEncodingDefaultVariant,<span></span></pre></td></tr><tr><td scope="row"><pre>kTextEncodingDefaultFormat,<span></span></pre></td></tr><tr><td scope="row"><pre>"KSC_5601",<span></span></pre></td></tr><tr><td scope="row"><pre>kTextEncodingISO_2022_KR, kTextEncodingDefaultVariant,<span></span></pre></td></tr><tr><td scope="row"><pre>kTextEncodingDefaultFormat,<span></span></pre></td></tr><tr><td scope="row"><pre>"ISO-2022-KR",<span></span></pre></td></tr><tr><td scope="row"><pre>kTextEncodingEUC_KR,<span></span></pre></td></tr><tr><td scope="row"><pre>kTextEncodingDefaultVariant,<span></span></pre></td></tr><tr><td scope="row"><pre>kTextEncodingDefaultFormat,<span></span></pre></td></tr><tr><td scope="row"><pre>"EUC-KR”<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre>};<span></span></pre></td></tr></table></div><p>The above example shows that there are three encodings, namely, <code>kTextEncodingKSC_5601_87</code>, <code>kTextEncodingISO_2022KR</code>, and <code>kTextEncodingEUC_KR</code>, for which this plug-in knows the Internet names. Because the encodings do not have special variants and formats, default variants and formats are used. One of the encodings, <code>kTextEncodingKSC_5601_87</code>, has two Internet names, namely, <code>KS_C_5601-1987</code> and <code>KSC_5601</code>.</p><p>The following resource type provides information about the available sniffers.</p><div class="codesample"><table><tr><td scope="row"><pre>/* supported sniffers list */<span></span></pre></td></tr><tr><td scope="row"><pre>type kTECAvailableSniffersResType {<span></span></pre></td></tr><tr><td scope="row"><pre>    longint = $$CountOf (memberArray);<span></span></pre></td></tr><tr><td scope="row"><pre>    Array memberArray {<span></span></pre></td></tr><tr><td scope="row"><pre>    memberStart:<span></span></pre></td></tr><tr><td scope="row"><pre>    TECTextEncoding /* encoding */<span></span></pre></td></tr><tr><td scope="row"><pre>    memberEnd:<span></span></pre></td></tr><tr><td scope="row"><pre>    };<span></span></pre></td></tr><tr><td scope="row"><pre>};<span></span></pre></td></tr></table></div><p>For example,</p><div class="codesample"><table><tr><td scope="row"><pre>resource kTECAvailableSniffersResType (kTECResourceID) {<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>kTextEncodingKSC_5601_87, kTextEncodingDefaultVariant, kTextEncodingDefaultFormat, kTextEncodingISO_2022_KR, kTextEncodingDefaultVariant, kTextEncodingDefaultFormat,<span></span></pre></td></tr><tr><td scope="row"><pre>kTextEncodingEUC_KR, kTextEncodingDefaultVariant, kTextEncodingDefaultFormat,<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre>};<span></span></pre></td></tr></table></div><p>The following resource type provides information about the available Web encodings.</p><div class="codesample"><table><tr><td scope="row"><pre>/* Web encodings */<span></span></pre></td></tr><tr><td scope="row"><pre>type kTECWebEncodingsResType {<span></span></pre></td></tr><tr><td scope="row"><pre>    longint = $$CountOf (memberArray);                              /* number of sets in resource */<span></span></pre></td></tr><tr><td scope="row"><pre>    Array memberArray {<span></span></pre></td></tr><tr><td scope="row"><pre>        memberStart:<span></span></pre></td></tr><tr><td scope="row"><pre>        ListStart:<span></span></pre></td></tr><tr><td scope="row"><pre>        longint = (ListEnd[$$ArrayIndex(memberArray)] -<span></span></pre></td></tr><tr><td scope="row"><pre>            ListStart[$$ArrayIndex(memberArray)]) / 8 - 4;<span></span></pre></td></tr><tr><td scope="row"><pre>                                 /* offset to next item */<span></span></pre></td></tr><tr><td scope="row"><pre>        longint = $$CountOf (localesArray);<span></span></pre></td></tr><tr><td scope="row"><pre>                                 /* number of encodings in resource */<span></span></pre></td></tr><tr><td scope="row"><pre>        Array localesArray {<span></span></pre></td></tr><tr><td scope="row"><pre>            TECLocale                       /* search locales */<span></span></pre></td></tr><tr><td scope="row"><pre>        };<span></span></pre></td></tr><tr><td scope="row"><pre>        longint = $$CountOf (webEncodingsArray);<span></span></pre></td></tr><tr><td scope="row"><pre>                                /* number of encodings in resource *<span></span></pre></td></tr><tr><td scope="row"><pre>        Array webEncodingsArray {<span></span></pre></td></tr><tr><td scope="row"><pre>            TECTextEncoding                 /* Web encodings */<span></span></pre></td></tr><tr><td scope="row"><pre>        };<span></span></pre></td></tr><tr><td scope="row"><pre>        ListEnd:<span></span></pre></td></tr><tr><td scope="row"><pre>        memberEnd:<span></span></pre></td></tr><tr><td scope="row"><pre>        };<span></span></pre></td></tr><tr><td scope="row"><pre>    };<span></span></pre></td></tr></table></div><p>For example,</p><div class="codesample"><table><tr><td scope="row"><pre>resource kTECWebEncodingsResType (kTECResourceID) {<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/* Korean encodings */<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>verKorea, /* Korean Republic of Korea */<span></span></pre></td></tr><tr><td scope="row"><pre>},<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>kTextEncodingISO_2022_KR,<span></span></pre></td></tr><tr><td scope="row"><pre>kTextEncodingDefaultVariant,<span></span></pre></td></tr><tr><td scope="row"><pre>kTextEncodingDefaultFormat,<span></span></pre></td></tr><tr><td scope="row"><pre>kTextEncodingEUC_KR,<span></span></pre></td></tr><tr><td scope="row"><pre>kTextEncodingDefaultVariant,<span></span></pre></td></tr><tr><td scope="row"><pre>kTextEncodingDefaultFormat<span></span></pre></td></tr><tr><td scope="row"><pre>},<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre>};<span></span></pre></td></tr></table></div><p>The following resource type provides information about the available encodings for electronic mail (e-mail) by region.</p><div class="codesample"><table><tr><td scope="row"><pre>/* mail encodings */<span></span></pre></td></tr><tr><td scope="row"><pre>type kTECMailEncodingsResType {<span></span></pre></td></tr><tr><td scope="row"><pre>    longint = $$CountOf (memberArray); /* number of sets in resource */<span></span></pre></td></tr><tr><td scope="row"><pre>    Array memberArray {<span></span></pre></td></tr><tr><td scope="row"><pre>        memberStart:<span></span></pre></td></tr><tr><td scope="row"><pre>        ListStart:<span></span></pre></td></tr><tr><td scope="row"><pre>    longint = (ListEnd[$$ArrayIndex(memberArray)] -<span></span></pre></td></tr><tr><td scope="row"><pre>        ListStart[$$ArrayIndex(memberArray)]) / 8 - 4;<span></span></pre></td></tr><tr><td scope="row"><pre>                                    /* offset to next item */<span></span></pre></td></tr><tr><td scope="row"><pre>        longint = $$CountOf (localesArray);<span></span></pre></td></tr><tr><td scope="row"><pre>                                    /* number of encodings in resource */<span></span></pre></td></tr><tr><td scope="row"><pre>        Array localesArray {<span></span></pre></td></tr><tr><td scope="row"><pre>            TECLocale                           /* search locales */<span></span></pre></td></tr><tr><td scope="row"><pre>        };<span></span></pre></td></tr><tr><td scope="row"><pre>        longint = $$CountOf (mailEncodingsArray);<span></span></pre></td></tr><tr><td scope="row"><pre>                                    /* number of encodings in resource */<span></span></pre></td></tr><tr><td scope="row"><pre>        Array mailEncodingsArray {<span></span></pre></td></tr><tr><td scope="row"><pre>                TECTextEncoding                 /* mail encodings */<span></span></pre></td></tr><tr><td scope="row"><pre>        };<span></span></pre></td></tr><tr><td scope="row"><pre>        ListEnd:<span></span></pre></td></tr><tr><td scope="row"><pre>        memberEnd:<span></span></pre></td></tr><tr><td scope="row"><pre>    };<span></span></pre></td></tr><tr><td scope="row"><pre>};<span></span></pre></td></tr></table></div><p>For example,</p><div class="codesample"><table><tr><td scope="row"><pre>resource kTECMailEncodingsResType (kTECResourceID) {<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/* Korean encodings */<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>verKorea, /* Korean Republic of Korea */<span></span></pre></td></tr><tr><td scope="row"><pre>},<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>kTextEncodingMacKorean,<span></span></pre></td></tr><tr><td scope="row"><pre>kTextEncodingDefaultVariant,<span></span></pre></td></tr><tr><td scope="row"><pre>kTextEncodingDefaultFormat,<span></span></pre></td></tr><tr><td scope="row"><pre>kTextEncodingISO_2022_KR,<span></span></pre></td></tr><tr><td scope="row"><pre>kTextEncodingDefaultVariant,<span></span></pre></td></tr><tr><td scope="row"><pre>kTextEncodingDefaultFormat,<span></span></pre></td></tr><tr><td scope="row"><pre>kTextEncodingEUC_KR,<span></span></pre></td></tr><tr><td scope="row"><pre>kTextEncodingDefaultVariant,<span></span></pre></td></tr><tr><td scope="row"><pre>kTextEncodingDefaultFormat,<span></span></pre></td></tr><tr><td scope="row"><pre>kTextEncodingUnicodeV2_0,<span></span></pre></td></tr><tr><td scope="row"><pre>kTextEncodingDefaultVariant,<span></span></pre></td></tr><tr><td scope="row"><pre>kUnicodeUTF7Format,<span></span></pre></td></tr><tr><td scope="row"><pre>kTextEncodingUnicodeV2_0,<span></span></pre></td></tr><tr><td scope="row"><pre>kTextEncodingDefaultVariant,<span></span></pre></td></tr><tr><td scope="row"><pre>kUnicodeUTF8Format<span></span></pre></td></tr><tr><td scope="row"><pre>},<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre>};<span></span></pre></td></tr></table></div><p>The following resource type provides information about which subencodings are packaged within a text encoding. For example ISO 2022-JP and EUC-JP both contain JIS Roman, JIS X0208, JIS X0212, and half-width Katakana.</p><div class="codesample"><table><tr><td scope="row"><pre>/* subencodings */<span></span></pre></td></tr><tr><td scope="row"><pre>type kTECSubTextEncodingsResType {<span></span></pre></td></tr><tr><td scope="row"><pre>    longint = $$CountOf (memberArray);<span></span></pre></td></tr><tr><td scope="row"><pre>                        /* number of sets of subencodings in resource */<span></span></pre></td></tr><tr><td scope="row"><pre>    Array memberArray {<span></span></pre></td></tr><tr><td scope="row"><pre>        memberStart:<span></span></pre></td></tr><tr><td scope="row"><pre>        ListStart:<span></span></pre></td></tr><tr><td scope="row"><pre>    longint = (ListEnd[$$ArrayIndex(memberArray)] -<span></span></pre></td></tr><tr><td scope="row"><pre>            ListStart[$$ArrayIndex(memberArray)]) / 8 - 4;<span></span></pre></td></tr><tr><td scope="row"><pre>                        /* offset to next item */<span></span></pre></td></tr><tr><td scope="row"><pre>    TECTextEncoding                 /* search encoding */<span></span></pre></td></tr><tr><td scope="row"><pre>    longint = $$CountOf (subEncodingsArray);<span></span></pre></td></tr><tr><td scope="row"><pre>                         /* number of subencodings in resource */<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    Array subEncodingsArray {<span></span></pre></td></tr><tr><td scope="row"><pre>        TECTextEncoding             /* search encoding */<span></span></pre></td></tr><tr><td scope="row"><pre>    };<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    ListEnd:<span></span></pre></td></tr><tr><td scope="row"><pre>    memberEnd:<span></span></pre></td></tr><tr><td scope="row"><pre>    };<span></span></pre></td></tr><tr><td scope="row"><pre>};<span></span></pre></td></tr></table></div><p>For example,</p><div class="codesample"><table><tr><td scope="row"><pre>resource kTECSubTextEncodingsResType (kTECResourceID) {<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>kTextEncodingISO_2022_JP,<span></span></pre></td></tr><tr><td scope="row"><pre>kTextEncodingDefaultVariant,<span></span></pre></td></tr><tr><td scope="row"><pre>kTextEncodingDefaultFormat,<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>kTextEncodingISOLatin1,<span></span></pre></td></tr><tr><td scope="row"><pre>kTextEncodingDefaultVariant,<span></span></pre></td></tr><tr><td scope="row"><pre>kTextEncodingDefaultFormat,<span></span></pre></td></tr><tr><td scope="row"><pre>kTextEncodingJIS_X0208_90,<span></span></pre></td></tr><tr><td scope="row"><pre>kTextEncodingDefaultVariant,<span></span></pre></td></tr><tr><td scope="row"><pre>kTextEncodingDefaultFormat,<span></span></pre></td></tr><tr><td scope="row"><pre>kTextEncodingJIS_X0212_90,<span></span></pre></td></tr><tr><td scope="row"><pre>kTextEncodingDefaultVariant,<span></span></pre></td></tr><tr><td scope="row"><pre>kTextEncodingDefaultFormat,<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/* half-width katakana */<span></span></pre></td></tr><tr><td scope="row"><pre>kTextEncodingJIS_X0201_76,<span></span></pre></td></tr><tr><td scope="row"><pre>kTextEncodingDefaultVariant,<span></span></pre></td></tr><tr><td scope="row"><pre>kTextEncodingDefaultFormat,<span></span></pre></td></tr><tr><td scope="row"><pre>},<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>kTextEncodingEUC_JP,<span></span></pre></td></tr><tr><td scope="row"><pre>kTextEncodingDefaultVariant,<span></span></pre></td></tr><tr><td scope="row"><pre>kTextEncodingDefaultFormat,<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>kTextEncodingISOLatin1,<span></span></pre></td></tr><tr><td scope="row"><pre>kTextEncodingDefaultVariant,<span></span></pre></td></tr><tr><td scope="row"><pre>kTextEncodingDefaultFormat,<span></span></pre></td></tr><tr><td scope="row"><pre>kTextEncodingJIS_X0208_90,<span></span></pre></td></tr><tr><td scope="row"><pre>kTextEncodingDefaultVariant,<span></span></pre></td></tr><tr><td scope="row"><pre>kTextEncodingDefaultFormat,<span></span></pre></td></tr><tr><td scope="row"><pre>kTextEncodingJIS_X0212_90,<span></span></pre></td></tr><tr><td scope="row"><pre>kTextEncodingDefaultVariant,<span></span></pre></td></tr><tr><td scope="row"><pre>kTextEncodingDefaultFormat,<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/* half-width katakana */<span></span></pre></td></tr><tr><td scope="row"><pre>kTextEncodingJIS_X0201_76,<span></span></pre></td></tr><tr><td scope="row"><pre>kTextEncodingDefaultVariant,<span></span></pre></td></tr><tr><td scope="row"><pre>kTextEncodingDefaultFormat,<span></span></pre></td></tr><tr><td scope="row"><pre>...<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre>};<span></span></pre></td></tr></table></div><p>Sniffers allow the Text Encoding Conversion Manager to detect the encoding characteristics of a text stream. A context record of the sniffer is provided for plug-ins and Text Encoding Conversion Manager communication. A sniffer is created by the Text Encoding Conversion Manager and the routine pointed to by <code>PluginNewEncodingSniffer</code>, a routine pointer defined in the plug-in dispatch table, is called. All sniffer routines are defined in the plug-in dispatch table. They are discussed below.</p><p>The sniffer context structure <code>TECSnifferContextRec</code> is similar to <code>TECConverterContextRec</code>. Its public section contains information set up by the Text Encoding Conversion Manager and returns information to the caller. The private section is available for plug-in use. </p><div class="codesample"><table><tr><td scope="row"><pre>struct TECSnifferContextRec {<span></span></pre></td></tr><tr><td scope="row"><pre>/* public - manipulated externally and by plug-in */<span></span></pre></td></tr><tr><td scope="row"><pre>Ptr pluginRec;<span></span></pre></td></tr><tr><td scope="row"><pre>TextEncoding encoding;<span></span></pre></td></tr><tr><td scope="row"><pre>ItemCount maxErrors;<span></span></pre></td></tr><tr><td scope="row"><pre>ItemCount maxFeatures;<span></span></pre></td></tr><tr><td scope="row"><pre>TextPtr textInputBuffer;<span></span></pre></td></tr><tr><td scope="row"><pre>TextPtr textInputBufferEnd;<span></span></pre></td></tr><tr><td scope="row"><pre>ItemCount numFeatures;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/* will be output to caller */<span></span></pre></td></tr><tr><td scope="row"><pre>ItemCount numErrors;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/* private - manipulated only within plug-in */<span></span></pre></td></tr><tr><td scope="row"><pre>UInt32 contextRefCon;<span></span></pre></td></tr><tr><td scope="row"><pre>ProcPtr sniffProc;<span></span></pre></td></tr><tr><td scope="row"><pre>ProcPtr clearContextInfoProc;<span></span></pre></td></tr><tr><td scope="row"><pre>TECPluginStateRec pluginState; /* state information */<span></span></pre></td></tr><tr><td scope="row"><pre>};<span></span></pre></td></tr><tr><td scope="row"><pre>typedef struct TECSnifferContextRec TECSnifferContextRec;<span></span></pre></td></tr></table></div><p>When a sniffer object is created in the Text Encoding Conversion Manager, the routine pointed to by <code>PluginNewEncodingSniffer</code>, a routine pointer defined in the plug-in dispatch table, is called by the Text Encoding Conversion Manager to allow the plug-in to set up its sniffer context structure <code>TECSnifferContextRec</code>. </p><p>Example:</p><div class="codesample"><table><tr><td scope="row"><pre>OSStatus ConverterPluginNewEncodingSniffer(<span></span></pre></td></tr><tr><td scope="row"><pre>TECSnifferObjectRef *encodingSniffer,<span></span></pre></td></tr><tr><td scope="row"><pre>TECSnifferContextRec *snifContext,<span></span></pre></td></tr><tr><td scope="row"><pre>TextEncoding inputEncoding)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>#pragma unused (encodingSniffer)<span></span></pre></td></tr><tr><td scope="row"><pre>OSStatus status = noErr;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>TextEncoding encodingKSC_5601_87 =<span></span></pre></td></tr><tr><td scope="row"><pre>CreateTextEncoding(kTextEncodingKSC_5601_87,<span></span></pre></td></tr><tr><td scope="row"><pre>kTextEncodingDefaultVariant,<span></span></pre></td></tr><tr><td scope="row"><pre>kTextEncodingDefaultFormat);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>TextEncoding encodingISO_2022_KR =<span></span></pre></td></tr><tr><td scope="row"><pre>CreateTextEncoding( kTextEncodingISO_2022_KR,<span></span></pre></td></tr><tr><td scope="row"><pre>kTextEncodingDefaultVariant,<span></span></pre></td></tr><tr><td scope="row"><pre>kTextEncodingDefaultFormat);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>TextEncoding encodingEUC_KR =<span></span></pre></td></tr><tr><td scope="row"><pre>CreateTextEncoding( kTextEncodingEUC_KR,<span></span></pre></td></tr><tr><td scope="row"><pre>kTextEncodingDefaultVariant,<span></span></pre></td></tr><tr><td scope="row"><pre>kTextEncodingDefaultFormat);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>TextEncoding encodingMacKorean =<span></span></pre></td></tr><tr><td scope="row"><pre>CreateTextEncoding( kTextEncodingMacKorean,<span></span></pre></td></tr><tr><td scope="row"><pre>kTextEncodingDefaultVariant,<span></span></pre></td></tr><tr><td scope="row"><pre>kTextEncodingDefaultFormat);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>if (snifContext)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>if (inputEncoding == encodingKSC_5601_87)<span></span></pre></td></tr><tr><td scope="row"><pre>snifContext->sniffProc = (ProcPtr) SniffKSC_5601;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>else if (inputEncoding == encodingISO_2022_KR)<span></span></pre></td></tr><tr><td scope="row"><pre>snifContext->sniffProc = (ProcPtr) SniffISO2022KR;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>else if (inputEncoding == encodingEUC_KR ||<span></span></pre></td></tr><tr><td scope="row"><pre>inputEncoding == encodingMacKorean)<span></span></pre></td></tr><tr><td scope="row"><pre>snifContext->sniffProc = (ProcPtr) SniffEUC_KR;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>else<span></span></pre></td></tr><tr><td scope="row"><pre>status = kTextUnsupportedEncodingErr;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>else<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>status = paramErr;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>return status;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>The routine pointed to by <code>PluginClearSnifferContextInfo</code>, a routine pointer defined in the plug-in dispatch table, is called to clear the sniffer context state information for sniffing a new input buffer. This is always called by the Text Encoding Conversion Manager right after creating the sniffer.</p><p>Example:</p><div class="codesample"><table><tr><td scope="row"><pre>OSStatus ConverterPluginClearSnifferContextInfo(<span></span></pre></td></tr><tr><td scope="row"><pre>TECSnifferObjectRef encodingSniffer,<span></span></pre></td></tr><tr><td scope="row"><pre>TECSnifferContextRec *snifContext)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>#pragma unused (encodingSniffer)<span></span></pre></td></tr><tr><td scope="row"><pre>OSStatus status = noErr;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>if (snifContext) {<span></span></pre></td></tr><tr><td scope="row"><pre>snifContext->pluginState.state1 = kASCIIState;<span></span></pre></td></tr><tr><td scope="row"><pre>snifContext->pluginState.state2 = kShiftInState;<span></span></pre></td></tr><tr><td scope="row"><pre>snifContext->pluginState.state3 = 0;<span></span></pre></td></tr><tr><td scope="row"><pre>snifContext->pluginState.state4 = 0;<span></span></pre></td></tr><tr><td scope="row"><pre>snifContext->numFeatures = 0;<span></span></pre></td></tr><tr><td scope="row"><pre>snifContext->numErrors   = 0;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>else<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>status = paramErr;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>return status;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>The routine pointed to by <code>PluginSniffTextEncoding</code>, a routine pointer defined in the plug-in dispatch table, is called to perform the actual sniffing. To sniff text encodings, loop through the input buffer and count errors and features. The Text Encoding Conversion Manager looks at the number of errors and features to determine the encoding of the given text. The routine is pointed to by <code>snifContext->sniffProc</code> to <code>ConverterPluginNewEncodingSniffer</code>, which is also defined in the plug-in dispatch table, when the sniffer is created. For example,</p><div class="codesample"><table><tr><td scope="row"><pre>OSStatus SniffEUC_KR(<span></span></pre></td></tr><tr><td scope="row"><pre>TECSnifferObjectRef encodingSniffer,<span></span></pre></td></tr><tr><td scope="row"><pre>TECSnifferContextRec *snifContext)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>#pragma unused (encodingSniffer)<span></span></pre></td></tr><tr><td scope="row"><pre>OSStatus status = noErr;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>if (snifContext)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>BytePtr inputBuffer = snifContext->textInputBuffer;<span></span></pre></td></tr><tr><td scope="row"><pre>BytePtr inputBufferEnd = snifContext->textInputBufferEnd;<span></span></pre></td></tr><tr><td scope="row"><pre>ItemCount *numErrs = &amp;snifContext->numErrors;<span></span></pre></td></tr><tr><td scope="row"><pre>ItemCount maxErrs = snifContext->maxErrors;<span></span></pre></td></tr><tr><td scope="row"><pre>ItemCount *numFeatures = &amp;snifContext->numFeatures;<span></span></pre></td></tr><tr><td scope="row"><pre>ItemCount maxFeatures = snifContext->maxFeatures;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>if (inputBuffer &amp;&amp; inputBufferEnd)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>Byte c;<span></span></pre></td></tr><tr><td scope="row"><pre>UInt8 isoState = snifContext->pluginState.state1;<span></span></pre></td></tr><tr><td scope="row"><pre>ItemCount errs = *numErrs;<span></span></pre></td></tr><tr><td scope="row"><pre>ItemCount features = *numFeatures;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>while(errs &lt; maxErrs &amp;&amp; features &lt; maxFeatures &amp;&amp;<span></span></pre></td></tr><tr><td scope="row"><pre>inputBuffer &lt; inputBufferEnd)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>c = *inputBuffer++; /* count errors and features in encoding */<span></span></pre></td></tr><tr><td scope="row"><pre>/* set status when appropriate */<span></span></pre></td></tr><tr><td scope="row"><pre>...<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/* save state information */<span></span></pre></td></tr><tr><td scope="row"><pre>snifContext->pluginState.state1 = isoState;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/* save number of errors and features */<span></span></pre></td></tr><tr><td scope="row"><pre>*numErrs = errs;<span></span></pre></td></tr><tr><td scope="row"><pre>*numFeatures = features;<span></span></pre></td></tr><tr><td scope="row"><pre>} else {<span></span></pre></td></tr><tr><td scope="row"><pre>status = paramErr;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/* Initialization.  Just in case. */<span></span></pre></td></tr><tr><td scope="row"><pre>*numErrs = 0;<span></span></pre></td></tr><tr><td scope="row"><pre>*numFeatures= 0;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>else<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>status = paramErr;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>return status;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>The destruction routine pointed to by <code>PluginDisposeEncodingSniffer</code>, a routine pointer defined in the plug-in dispatch table, is called when the sniffer is disposed of. To dispose of the sniffer, simply dispose of any memory or resources that may have been allocated in the creation routine. </p><p>Example:</p><div class="codesample"><table><tr><td scope="row"><pre>OSStatus ConverterPluginDisposeEncodingSniffer(<span></span></pre></td></tr><tr><td scope="row"><pre>TECSnifferObjectRef encodingSniffer,<span></span></pre></td></tr><tr><td scope="row"><pre>TECSnifferContextRec *snifContext)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>#pragma unused (encodingSniffer, snifContext)<span></span></pre></td></tr><tr><td scope="row"><pre>/* nothing to do */<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>return noErr;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>All plug-in routines should return values with <code>OSStatus</code> type, except the three routines named by the plug-in library symbols.</p><p>Some common status and error codes that may be returned to the Text Encoding Conversion Manager using type <code>OSStatus</code> are listed below:</p><ul class="ul"><li class="li"><p><code>kTECOutputBufferFullStatus</code>—Output buffer is full before all text could be converted.</p></li><li class="li"><p><code>noErr</code>—No error occurred or status is normal.</p></li><li class="li"><p><code>paramErr</code>—One or more of the input parameters has an invalid value.</p></li><li class="li"><p><code>kTextUnsupportedEncodingErr</code>—The given encoding is not supported in the current plug-in.</p></li><li class="li"><p><code>kTECBufferBelowMinimumSizeErr</code>—The output text buffer is too small to allow processing of the first input text element.</p></li><li class="li"><p><code>kTECPartialCharErr</code>—The input text ends in the middle of a multi-byte character, conversion stopped. In this case, the plug-in code should save the state in its private space and the input pointer should back up to the beginning of the multi-byte character.</p></li><li class="li"><p><code>kTextMalformedInputErr</code>—The text input contained a sequence that is not legal in the specified encoding.</p></li></ul><p>The plug-in should have <code>'encv'</code> for file creator and '<code>ecpg</code>' for file type.</p><p>The <code>'cfrg'</code> resource serves to inform the Process Manager and Code Fragment Manager of code fragments. The resource ID must be zero.</p><p>Example:</p><div class="codesample"><table><tr><td scope="row"><pre>#ifdef PPC<span></span></pre></td></tr><tr><td scope="row"><pre>resource 'cfrg' (0) {<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>kPowerPC, /* instruction set architecture   */<span></span></pre></td></tr><tr><td scope="row"><pre>kFullLib, /* base-level library */<span></span></pre></td></tr><tr><td scope="row"><pre>kNoVersionNum, /* no implementation version number*/<span></span></pre></td></tr><tr><td scope="row"><pre>kNoVersionNum, /* no definition version number */<span></span></pre></td></tr><tr><td scope="row"><pre>kDefaultStackSize, /* use default stack size */<span></span></pre></td></tr><tr><td scope="row"><pre>kNoAppSubFolder, /* no library directory */<span></span></pre></td></tr><tr><td scope="row"><pre>kIsDropIn, /* fragment is a drop-in library */<span></span></pre></td></tr><tr><td scope="row"><pre>kOnDiskFlat, /* fragment is in the data fork */<span></span></pre></td></tr><tr><td scope="row"><pre>kZeroOffset, /* fragment starts at offset 0 */<span></span></pre></td></tr><tr><td scope="row"><pre>kWholeFork, /* fragment occupies entire fork */<span></span></pre></td></tr><tr><td scope="row"><pre>"KoreanPlugin" /* name of the library fragment */<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>};<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>#else<span></span></pre></td></tr><tr><td scope="row"><pre>resource 'cfrg' (0) {<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>kMotorola, /* instruction set architecture  */<span></span></pre></td></tr><tr><td scope="row"><pre>kFullLib, /* base-level library */<span></span></pre></td></tr><tr><td scope="row"><pre>kNoVersionNum, /* no implementation version number*/<span></span></pre></td></tr><tr><td scope="row"><pre>kNoVersionNum, /* no definition version number  */<span></span></pre></td></tr><tr><td scope="row"><pre>kDefaultStackSize, /* use default stack size */<span></span></pre></td></tr><tr><td scope="row"><pre>kNoAppSubFolder, /* no library directory */<span></span></pre></td></tr><tr><td scope="row"><pre>kIsDropIn, /* fragment is a drop-in library     */<span></span></pre></td></tr><tr><td scope="row"><pre>kOnDiskFlat, /* fragment is in the data fork */<span></span></pre></td></tr><tr><td scope="row"><pre>kZeroOffset, /* fragment starts at offset 0 */<span></span></pre></td></tr><tr><td scope="row"><pre>kWholeFork, /* fragment occupies entire fork */<span></span></pre></td></tr><tr><td scope="row"><pre>"KoreanPlugin" /* name of the library fragment */<span></span></pre></td></tr><tr><td scope="row"><pre>};<span></span></pre></td></tr><tr><td scope="row"><pre>#endif<span></span></pre></td></tr></table></div><p>The <code>'vers'</code> resource provides the version information. The resource ID must be 1. </p><p>Example:</p><div class="codesample"><table><tr><td scope="row"><pre>resource 'vers' (1, purgeable)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>0x01, 0x20, final, 0x00,<span></span></pre></td></tr><tr><td scope="row"><pre>verUS,<span></span></pre></td></tr><tr><td scope="row"><pre>"1.2",<span></span></pre></td></tr><tr><td scope="row"><pre>"1.2, Copyright Apple Computer, Inc. 1994-1997."<span></span></pre></td></tr><tr><td scope="row"><pre>};<span></span></pre></td></tr></table></div><p>Here is the URL of a Web site that gives useful encoding conversion information: </p><p><span class="content_text"><a href="http://www.ora.com/people/authors/lunde/cjk-char.html" target="_blank">http://www.ora.com/people/authors/lunde/cjk-char.html</a></span></p>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../tecmgr_concepts/tecmgr_concepts.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../tecmgr_encnames/tecmgr_encnames.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2005 Apple Computer, Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2005-07-07<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Carbon/Conceptual/ProgWithTECM/tecmgr_plugins/tecmgr_plugins.html%3Fid%3DTP40000932-2.1&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Carbon/Conceptual/ProgWithTECM/tecmgr_plugins/tecmgr_plugins.html%3Fid%3DTP40000932-2.1&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Carbon/Conceptual/ProgWithTECM/tecmgr_plugins/tecmgr_plugins.html%3Fid%3DTP40000932-2.1&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>