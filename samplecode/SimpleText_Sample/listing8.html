<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>SimpleText Sample - /GXFile.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxMacOS9Earlier-date.html">Mac OS 9 & Earlier</a> &gt; <A HREF="javascript:location.replace('index.html');">SimpleText Sample</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/index.html" target="_blank">Reference Library</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">SimpleText Sample</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/GXFile.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/AboutBox.c</option>
<option value="listing2.html">/AboutBox.h</option>
<option value="listing3.html">/AboutBox.r</option>
<option value="listing4.html">/AGFile.h</option>
<option value="listing5.html">/Clipboard.c</option>
<option value="listing6.html">/Clipboard.h</option>
<option value="listing7.html">/Clipboard.r</option>
<option value="listing8.html">/GXFile.c</option>
<option value="listing9.html">/GXFile.h</option>
<option value="listing10.html">/GXFile.r</option>
<option value="listing11.html">/Localize.r</option>
<option value="listing12.html">/MacIncludes.h</option>
<option value="listing13.html">/MovieFile.c</option>
<option value="listing14.html">/MovieFile.h</option>
<option value="listing15.html">/MovieFile.r</option>
<option value="listing16.html">/PICTFile.c</option>
<option value="listing17.html">/PICTFile.h</option>
<option value="listing18.html">/PICTFile.r</option>
<option value="listing19.html">/SimpleText.c</option>
<option value="listing20.html">/SimpleText.h</option>
<option value="listing21.html">/SimpleText.r</option>
<option value="listing22.html">/TextDrag.c</option>
<option value="listing23.html">/TextFile.a</option>
<option value="listing24.html">/TextFile.c</option>
<option value="listing25.html">/TextFile.h</option>
<option value="listing26.html">/TextFile.r</option>
<option value="listing27.html">/ThreeDMetafile.c</option>
<option value="listing28.html">/ThreeDMetafile.h</option>
<option value="listing29.html">/ThreeDMetafile.r</option></select>
				</p>
				</form>
				<p><strong><a href="SimpleText_Sample.zip">Download Sample</a></strong> (&#147;SimpleText_Sample.zip&#148;, 602.8K)<BR>
<strong><a href="SimpleText_Sample.dmg">Download Sample</a></strong> (&#147;SimpleText_Sample.dmg&#148;, 959.7K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*  File:    GXFile.c  Contains:  GX print file support for simple text application.  Version:  SimpleText 1.4 or later** Copyright 1993-1996 Apple Computer. All rights reserved.****  You may incorporate this sample code into your applications without**  restriction, though the sample code has been provided &quot;AS IS&quot; and the**  responsibility for its operation is 100% yours.  However, what you are**  not permitted to do is to redistribute the source as &quot;DSC Sample Code&quot;**  after having made changes. If you're going to re-distribute the source,**  we require that you make it clear in the source that the code was**  descended from Apple Sample Code, but that you've made changes.*/#include &quot;MacIncludes.h&quot;#include &quot;GXFile.h&quot;#pragma segment GXFile// --------------------------------------------------------------------------------------------------------------// PRIVATE TYPEDEFS AND DECLARES// --------------------------------------------------------------------------------------------------------------// items to the left of the horizontal scroll bar#define kScrollAreaWidth  120#define kPageControlsWidth  32#define kZoomControlsWidth  26#define kToolControlWidth  16// items in the pop up page selection window#define kPageSliderHeight  10#define kPageSliderMargins  7#define kPageThumbEdge    4#define kPageThumbHeight  (kPageSliderHeight + kPageThumbEdge*2)#define kPageThumbWidth    (kPageThumbHeight / 2)#define kPageThumbMargins  3#define kProxyHeight    150#define kProxyWidth      150#define kPopUpWindowHeightSmall  (kPageThumbHeight + kPageSliderMargins*2 + kPageThumbEdge*2)#define kPopUpWindowHeightLarge  (kPageThumbHeight + kPageSliderMargins*3 + kPageThumbEdge*2 + kProxyHeight)#define kMinGXDocSize    kMinDocSize// PICT proxies for the pages#define kProxyBaseID    (gxPrintingTagID)#define kProxyType      'prxy'// flattened GX shapes for annotations#define kAnnotationBaseID  (gxPrintingTagID)#define kAnnotationType    'anot'// table of pop up menu items and corosponding zoom factorstypedef struct  {  short  menuItem;  Fixed  zoomFactor;  } ZoomTableEntry;  typedef struct  {  short  theFont;  short  theSize;  } TextState;  typedef struct    {  gxSpoolBlock  spool;  long      reference;  long      position;  long      size;  void      *data;  void      *userField;  } userSpool;#define LONGALIGN(n)    (((n) + 3) &amp; ~3L)#define kAtomHeaderSize    (sizeof(Size) + sizeof(OSType))#define ABS(n)        (((n) &lt; 0) ? -(n) : (n))#if GENERATINGCFM  extern pascal OSErr SetImageDescriptionExtension(ImageDescriptionHandle desc, Handle extension, long idType);#endif// --------------------------------------------------------------------------------------------------------------// FORWARD DECLARES// --------------------------------------------------------------------------------------------------------------OSErr  GXGetDocumentRect(WindowRef pWindow, WindowDataPtr pData,       LongRect * documentRectangle, Boolean forGrow);OSErr  GXCommand(WindowRef pWindow, WindowDataPtr pData, short commandID, long menuResult);// --------------------------------------------------------------------------------------------------------------// LOCAL GLOBALS// --------------------------------------------------------------------------------------------------------------static ZoomTableEntry gZoomTable[] = {                {i50,   0x8000},                {i100,  ff(1)},                {i112,  0x00011EB8},                {i150,   0x00018000},                {i200,  ff(2)},                {i400,  ff(4)},                {0,0}};// --------------------------------------------------------------------------------------------------------------// PRIVATE ROUTINES// --------------------------------------------------------------------------------------------------------------static void GetCurrentPageAndPaper(WindowDataPtr pData, gxRectangle *pPageSize, gxRectangle *pPaperSize){  GXGetFormatDimensions( ((GXDataPtr)pData)-&gt;currentPageFormat, pPageSize, pPaperSize);    if (((GXDataPtr)pData)-&gt;dontShowMargins)    *pPaperSize = *pPageSize;    } // GetCurrentPageAndPaper// ------------------------------------------------------------------------------------------------------static void InitColorMatrix(Fixed m[5][4]){  register Fixed *x;  register short i;  x = &amp;m[0][0];  for(i = 19; i&gt;=0; i--)    *x++ = 0;  m[0][0] = m[1][1] = m[2][2] = m[3][3] = fixed1;       /* Identity matrix, for cleanliness */  } // InitColorMatrix// --------------------------------------------------------------------------------------------------------------static void RectangleToRect(const gxRectangle* gxr, Rect* qdr){  qdr-&gt;left = FixedRound(gxr-&gt;left);  qdr-&gt;top = FixedRound(gxr-&gt;top);  qdr-&gt;right = FixedRound(gxr-&gt;right);  qdr-&gt;bottom = FixedRound(gxr-&gt;bottom);  } // RectangleToRect// --------------------------------------------------------------------------------------------------------------#define allocationIncrement   1024     /* the storage handle is grown by this amount */static long HandleSpoolProc(gxSpoolCommand command,  userSpool *block){  gxGraphicsError  anErr = noErr;       switch (command)       {        case gxOpenReadSpool:           block-&gt;size = 0;           block-&gt;position = 0;          break;            case gxOpenWriteSpool:           block-&gt;data = NewHandle(allocationIncrement);           block-&gt;size = allocationIncrement;           block-&gt;position = 0;      anErr = MemError();          break;              case gxReadSpool:           BlockMoveData((*(char **) block-&gt;data) + block-&gt;position, block-&gt;spool.buffer, block-&gt;spool.count);           block-&gt;position += block-&gt;spool.count;          break;        case gxWriteSpool:          {        register long oldPosition;          oldPosition = block-&gt;position;          block-&gt;position += block-&gt;spool.count;          /* make sure there is at least enough room for one buffer size past current pointer */          if (block-&gt;position + block-&gt;spool.bufferSize &gt; block-&gt;size)                   {              block-&gt;size += block-&gt;spool.bufferSize;              HUnlock((Handle) block-&gt;data);              SetHandleSize((Handle) block-&gt;data, block-&gt;size);        anErr = MemError();              HLock((Handle) block-&gt;data);             }      if (anErr == noErr)             BlockMoveData(block-&gt;spool.buffer, (*(char **) block-&gt;data + oldPosition), block-&gt;spool.count);          }          break;              case gxCloseSpool:           SetHandleSize((Handle) block-&gt;data, block-&gt;position);          break;       }       return anErr;   } // HandleSpoolProc#if GENERATINGCFM  static RoutineDescriptor gHandleSpoolProcRD = BUILD_ROUTINE_DESCRIPTOR(uppgxSpoolProcInfo, HandleSpoolProc);  static gxSpoolUPP gHandleSpoolProc = &amp;gHandleSpoolProcRD;#else  static gxSpoolUPP gHandleSpoolProc = NewgxSpoolProc(HandleSpoolProc);#endif// --------------------------------------------------------------------------------------------------------------static long* AppendAtom(long stream[], Size size, OSType tag, const void* data){  *stream++  = size + kAtomHeaderSize;  *stream++  = tag;  BlockMoveData(data, (Ptr)stream, size);  return (long*)((char*)stream + size);  } // AppendAtom// --------------------------------------------------------------------------------------------------------------static Handle CreateQDGXStream(gxShape source, PicHandle proxie, Boolean forPrintingOnly, Boolean eraseBackground)/* *  See the comment on DecompressShape for an explaination of the parameters. *  This routine is used by both DecompressShape for embedding shapes in PICTs, *  and AddQDGXRecorderFrame for making gx movies.*/{  #define      gxForPrintingOnlyAtom  'fpto'  #define      gxEraseBackgroundAtom  'erbg'  long      atomCount, shapeSize, proxieSize, dataSize, fontListSize;  Handle      dataHdl, shapeHdl;  gxFlatFontList*  fontList;  gxTag      fontListTag;    userSpool     block;  block.spool.spoolProcedure = gHandleSpoolProc;  block.spool.buffer = nil;  block.spool.bufferSize = 0;  GXFlattenShape(source, gxFontListFlatten | gxFontGlyphsFlatten | gxFontVariationsFlatten, &amp;block.spool);  shapeHdl = (Handle) block.data;  if (shapeHdl == nil)    return nil;  if (proxie)    {      atomCount = 2;    proxieSize = LONGALIGN(GetHandleSize((Handle)proxie));    }  else    {      atomCount = 1;    proxieSize = 0;    }  shapeSize = LONGALIGN(GetHandleSize(shapeHdl));  if (forPrintingOnly)    ++atomCount;  if (eraseBackground)    ++atomCount;  fontListSize = 0;  fontList = nil;  GXIgnoreGraphicsWarning(count_out_of_range);  if (GXGetShapeTags(source, gxFlatFontListItemTag, 1, 1, &amp;fontListTag) &gt; 0)    {      fontListSize = GXGetTag(fontListTag, nil, nil);    if (fontListSize &gt; 0)      {        fontList = (gxFlatFontList*)NewPtr(fontListSize);      if (fontList != nil)        {          GXGetTag(fontListTag, nil, fontList);        fontListSize = LONGALIGN(fontListSize);        ++atomCount;        }      else        fontListSize = 0;      }    }  GXPopGraphicsWarning();    // count_out_of_range  dataSize = atomCount * kAtomHeaderSize + shapeSize + proxieSize + fontListSize + sizeof(long);  dataHdl = NewHandle(dataSize);  if (dataHdl == nil)    {      DisposeHandle(shapeHdl);    if (fontList)      DisposePtr((Ptr)fontList);    return nil;    }    {      long* p = (long*)*dataHdl;    if (forPrintingOnly)      p = AppendAtom(p, 0, gxForPrintingOnlyAtom, nil);    if (eraseBackground)      p = AppendAtom(p, 0, gxEraseBackgroundAtom, nil);    if (proxie)      p = AppendAtom(p, proxieSize, 'PICT', *proxie);    if (fontList)      p = AppendAtom(p, fontListSize, gxFlatFontListItemTag, fontList);    p = AppendAtom(p, shapeSize, 'qdgx', *shapeHdl);    *p++ = 0;    // end of the atom-list    DisposeHandle(shapeHdl);    if (fontList)      DisposePtr((Ptr)fontList);  }  return dataHdl;} // CreateQDGXStream// --------------------------------------------------------------------------------------------------------------static PicHandle DecompressShape(gxShape theShape, PicHandle proxie, Boolean forPrintingOnly, Boolean eraseBackground)/* *  This guy returns a Quickdraw picture containing an embedded shape, and a proxie *  of the shape, if proxie is not nil. This is called by ShapeToScrap and DragAndDropShape. * *  theShape      * the shape you want to embedd in a PICT *  proxie      * a PICT to be drawn if theShape cannot be drawn (optional but recommended) *  forPrintingOnly    * if TRUE, then the decompressor will always look for the proxie *          and theShape will only be used when printing. Use this setting if *          theShape might be too large or too slow when drawn from other apps. *          * If FALSE, then the decompressor will draw theShape unless it *          gets an error, in which case it will look for a proxie. *  eraseBackground  * if TRUE, the decompressor will always erase the background to WHITE *          before drawing the shape. This is slower, but needed if the shape does not *          fill its bounding rectangle. *          * if FALSE, the decompressor will just draw the shape. Use this setting *          if the shape entirely fills its bounding rectangle. * *  The shape [and proxie] is embedded by constructing a stream of atoms. Each atom begins *  with a size (long) and a type (OSType) and then the data for that type. After the last atom, *  there is a trailing zero (long) to mark the end of the stream. For embedded shapes, the type *  is 'qdgx', and for the proxie the type is 'PICT'. Note that the size fields are rounded up to *  a multiple of 4. Finally, to alert QuickTime that the data is in this parsable form with a *  possible PICT proxie, we add a 'prxy' extension to the ImageDescriptionHandle. * *  Picture of this form will draw the embedded shape when an application calls DrawPicture *  if GX is around, and if not, the proxie will be drawn. When printed, the shape or the proxie *  will be printed. This is meant to replace the PicComment described in GX 1.0 for embedding *  shapes in pictures. * *  If you want to include a flatFontList tag, be sure that theShape is a picture, otherwise GX will *  not return the tag after GXFlattenShape. The flatFontList tag makes certain printing conditions *  more efficient (i.e. font downloading to postscript printers). * *  Your shape must not contain a gxQuickDrawPictTag, meaning it contains embedded QD data, becuase *  this will potentially crash when it tries to print. To fix that, DecompressShape looks for occurrances *  of the tag, and converts them to real gx data by calling GXSetShapeType(shape, gxPictureType).*/{  PicHandle        thePicture;  ImageDescriptionHandle  descHdl;  ImageDescriptionPtr    descPtr;  Handle          dataHdl;  if (!gMachineInfo.haveQuickTime)    return nil;  /*   *  Move the shape's topLeft to 0,0 so that it draws neatly inside the picture frame.   *  Note that the qdgx movie library does not move the shape, since the shape may not   *  take up the whole frame.  */  {      gxRectangle  bounds;    GXGetShapeLocalBounds(theShape, &amp;bounds);    if (bounds.left || bounds.top)      GXMoveShape(theShape, -bounds.left, -bounds.top);    dataHdl = CreateQDGXStream(theShape, proxie, forPrintingOnly, eraseBackground);    if (bounds.left || bounds.top)      GXMoveShape(theShape, bounds.left, bounds.top);  }  if (dataHdl == nil)    return nil;  descHdl = (ImageDescriptionHandle)NewHandleClear(sizeof(ImageDescription));  if (descHdl)    {      Rect      shortBounds;    gxRectangle  bounds;    GXGetShapeLocalBounds(theShape, &amp;bounds);    RectangleToRect(&amp;bounds, &amp;shortBounds);    OffsetRect(&amp;shortBounds, -shortBounds.left, -shortBounds.top);  // set the topLeft of the src to 0,0    thePicture = OpenPicture(&amp;shortBounds);    descPtr = *descHdl;    descPtr-&gt;idSize = sizeof(ImageDescription);    descPtr-&gt;cType = 'qdgx';    descPtr-&gt;vendor = 'appl';    descPtr-&gt;temporalQuality = codecLosslessQuality;    descPtr-&gt;width = shortBounds.right;    descPtr-&gt;height = shortBounds.bottom;    descPtr-&gt;hRes = descPtr-&gt;vRes = ff(72);    descPtr-&gt;dataSize = GetHandleSize(dataHdl);    descPtr-&gt;frameCount = 1;    descPtr-&gt;depth = 32;    descPtr-&gt;clutID = -1;    //  If there is a PICT proxie, add an image extension to tell QuickTime, in case GX is not around.    if (proxie)      {        Handle prxyVersionHdl = NewHandle(sizeof(long));      if (prxyVersionHdl != nil)        {          *(long*)*prxyVersionHdl = 0;    // version number for 'prxy' extension        #if GENERATINGCFM          SetImageDescriptionExtension(descHdl, prxyVersionHdl, 'prxy');        #else          AddImageDescriptionExtension(descHdl, prxyVersionHdl, 'prxy');        #endif        }      }    HLock(dataHdl);    DecompressImage(*dataHdl, descHdl, ((CGrafPtr)qd.thePort)-&gt;portPixMap, &amp;shortBounds, &amp;shortBounds, srcCopy, nil);    DisposeHandle((Handle)descHdl);    ClosePicture();    }  else    thePicture = nil;  DisposeHandle(dataHdl);  return thePicture;  } // DecompressShape// --------------------------------------------------------------------------------------------------------------static PicHandle ShapeToPICT(gxShape source)/* *  This guy returns a Quickdraw picture containing a 1-bit bitmap of the shape. *  This is used by ShapeToScrap to create a proxie when calling DecompressShape. *  If you want to make the proxie prettier (and larger), change the bitmap to 8-bit. *  However, if you're using this in conjunction with DecompressShape to place a *  gxShape on the clipboard, 1-bit should be enough, since the actual shape will be *  drawn, rather than the proxie (unless forPrintingOnly is true).*/{  gxRectangle    bounds;  gxShape      bitShape;  gxBitmap    bitmap;  PicHandle    thePicture;  Rect      shortBounds;  /*   *  GetShapeLocalBounds doesn't accurately report the bounds of a gxQuickDrawPictTag.   *  but we should have none of them at this point anyway.  */  GXGetShapeLocalBounds(source, &amp;bounds);  RectangleToRect(&amp;bounds, &amp;shortBounds);  OffsetRect(&amp;shortBounds, -shortBounds.left, -shortBounds.top);  bitmap.width    = shortBounds.right;  bitmap.height    = shortBounds.bottom;  bitmap.rowBytes    = bitmap.width + 31 &gt;&gt; 5 &lt;&lt; 2;  bitmap.pixelSize  = 1;  bitmap.space    = gxIndexedSpace;  bitmap.set      = nil;  bitmap.profile    = nil;  bitmap.image    = NewPtrClear(bitmap.rowBytes * bitmap.height);  if (bitmap.image == nil)    return nil;  bitShape = GXNewBitmap(&amp;bitmap, nil);  if (bitShape != nil)    {      gxViewGroup group  = GXNewViewGroup();    gxViewDevice device  = GXNewViewDevice(group, bitShape);    gxViewPort port    = GXNewViewPort(group);    gxTransform trans  = GXCloneTransform(GXGetShapeTransform(source));    GXSetShapeAttributes(source, GXGetShapeAttributes(source) | gxMapTransformShape);    GXMoveShape(source, -bounds.left, -bounds.top);    GXSetViewPortDither(port, 4);    GXSetShapeViewPorts(source, 1, &amp;port);    GXDrawShape(source);    GXSetShapeTransform(source, trans);    GXDisposeTransform(trans);        GXDisposeViewGroup(group);  /* this disposes the gxViewPort and gxViewDevice */    GXDisposeShape(bitShape);    }  {      GrafPtr  thePort;    BitMap  srcBits;      GetPort(&amp;thePort);    srcBits.baseAddr = bitmap.image;    srcBits.rowBytes = bitmap.rowBytes;    srcBits.bounds = shortBounds;    thePicture = OpenPicture(&amp;shortBounds);    CopyBits(&amp;srcBits, &amp;thePort-&gt;portBits, &amp;shortBounds, &amp;shortBounds, srcOr, nil);    ClosePicture();  }    DisposePtr((Ptr)bitmap.image);    return thePicture;  } // ShapeToPICT// --------------------------------------------------------------------------------------------------------------static void GetRidOfAnyQDShapeTags(gxShape shape){  gxShapeType shapeType = GXGetShapeType(shape);  if (shapeType == gxPictureType)    {      long    index, count;    gxShape    contentShape;      count = GXGetPicture(shape, nil, nil, nil, nil);    for (index = 0; index &lt; count; index++)      {      GXGetPictureParts(shape, index+1, 1, &amp;contentShape, nil, nil, nil);      GetRidOfAnyQDShapeTags(contentShape);      }    }  else     {    if ( (shapeType == gxRectangleType) &amp;&amp; (GXGetShapeTags(shape, gxQuickDrawPictTag, 1, gxSelectToEnd, nil) &gt; 0) )      GXSetShapeType(shape, gxPictureType);    }      } // GetRidOfAnyQDShapeTags// --------------------------------------------------------------------------------------------------------------static void ShapeToScrap(gxShape source)/* *  This guy puts a Quickdraw picture on the clipboard containing an embedded shape *  and, if addProxie is true, a 1-bit bitmap of the shape. Call this in response to *  the user choosing &quot;Copy&quot; or &quot;Cut&quot; from the Edit menu. See comment for DecompressShape *  to explain forPrintingOnly.*/{  PicHandle  picture, proxy;    proxy = ShapeToPICT(source);  picture = DecompressShape(source, proxy, false, true);  if (proxy)    KillPicture(proxy);  if (picture)    {      HLock((Handle)picture);    ZeroScrap();    PutScrap(GetHandleSize((Handle)picture), 'PICT', (Ptr)*picture);    KillPicture(picture);    }    } // ShapeToScrap// --------------------------------------------------------------------------------------------------------------static void CullShape(gxShape shape, gxShape addToThis, gxRectangle *pCullRect, gxStyle cullStyle, gxInk cullInk, gxTransform cullTransform)/*  Add to &quot;addToThis&quot; the &quot;shape&quot;, only if the shape intersects the pCullRect.*/{  gxShapeType shapeType = GXGetShapeType(shape);  if (shapeType == gxPictureType)    {      long    index, count;    gxShape    contentShape;      count = GXGetPicture(shape, nil, nil, nil, nil);    for (index = 0; index &lt; count; index++)      {      GXGetPictureParts(shape, index+1, 1, &amp;contentShape, &amp;cullStyle, &amp;cullInk, &amp;cullTransform);      CullShape(contentShape, addToThis, pCullRect, cullStyle, cullInk, cullTransform);      }    }  else     {    gxRectangle  bounds;        GXGetShapeLocalBounds(shape, &amp;bounds);        if (IsSomewhereInRectangle(pCullRect, &amp;bounds))      {      if ( (shapeType == gxRectangleType) &amp;&amp; (GXGetShapeTags(shape, gxQuickDrawPictTag, 1, gxSelectToEnd, nil) &gt; 0) )        {        // convert shape and add -- but only if it goes okay        GXSetShapeType(shape, gxPictureType);        if (GXGetShapeType(shape) == gxPictureType)          CullShape(shape, addToThis, pCullRect, cullStyle, cullInk, cullTransform);        }      else        {        GXSetPictureParts(addToThis, 0, 0, 1, &amp;shape, &amp;cullStyle, &amp;cullInk, &amp;cullTransform);        }      }    }    } // CullShape// --------------------------------------------------------------------------------------------------------------static gxShape CullPicture(gxShape pictureShape, gxRectangle * pCullRect)/*  Returns a new shape that is all of the shapes inside of pictureShape  that intersect pCullRect.*/{  gxShape    newPicture = GXNewShape(gxPictureType);  gxShape   clipShape = GXNewRectangle(pCullRect);  gxMapping  mapping;  gxRectangle  clipRect;    // new shape as same mapping as old one  GXGetTransformMapping(GXGetShapeTransform(pictureShape), &amp;mapping);  GXSetShapeMapping(newPicture, &amp;mapping);    // clip also has the mapping, but inverted so that it's the right space  InvertMapping(&amp;mapping, &amp;mapping);  GXMapShape(clipShape, &amp;mapping);  GXGetShapeLocalBounds(clipShape, &amp;clipRect);    // clip to the selection  GXSetShapeClip(newPicture, clipShape);  GXDisposeShape(clipShape);  // add all shapes that intersect the clip area  CullShape(pictureShape, newPicture, &amp;clipRect, nil, nil, nil);      // new shape is zero based  GXMoveShape(newPicture, -pCullRect-&gt;left, -pCullRect-&gt;top);    return(newPicture);  } // CullPicture// --------------------------------------------------------------------------------------------------------------static gxShape GetSelectedShape(WindowDataPtr pData)/*  Returns a shape that represents all shapes on the current page  that are contained by the current selection rectangle.*/{  gxRectangle    cullRect;  gxShape      cullShape;  gxPoint      offset;  Fixed      zoomFactor = ((GXDataPtr)pData)-&gt;zoomFactor;    // calculate the actual coodinate space, removing margins  {  gxRectangle    pageSize, paperSize;    GetCurrentPageAndPaper(pData, &amp;pageSize, &amp;paperSize);  offset.y = FixedMultiply(-paperSize.top, zoomFactor);  offset.x = FixedMultiply(-paperSize.left, zoomFactor);  }    // calculate the actual coodinates to copy  cullRect.top  = FixedDivide(ff(((GXDataPtr)pData)-&gt;selectionRectangle.top) - offset.y, zoomFactor);  cullRect.left  = FixedDivide(ff(((GXDataPtr)pData)-&gt;selectionRectangle.left) - offset.x, zoomFactor);  cullRect.bottom  = FixedDivide(ff(((GXDataPtr)pData)-&gt;selectionRectangle.bottom) - offset.y, zoomFactor);  cullRect.right  = FixedDivide(ff(((GXDataPtr)pData)-&gt;selectionRectangle.right) - offset.x, zoomFactor);    // chop the data  cullShape = CullPicture(((GXDataPtr)pData)-&gt;currentPageShape, &amp;cullRect);    return(cullShape);  } // GetSelectedShape// --------------------------------------------------------------------------------------------------------------static pascal OSErr GXSendDataProc(FlavorType theType, void *dragSendRefCon,                ItemReference theItem, DragReference theDrag)/* *  The ItemReference is the gxShape to be sent. The dragSendRefCon is ignored.*/{#pragma unused (dragSendRefCon)  OSErr  result = noErr;  gxShape  shape = ((GXDataPtr)theItem)-&gt;tempDragShape;    // haven't made clipped version yet?  if (shape == nil)    {    shape = GetSelectedShape((WindowDataPtr) theItem);    ((GXDataPtr)theItem)-&gt;tempDragShape = shape;    }      switch (theType)     {    case 'qdgx':      {        Handle     flat;        userSpool   block;      block.spool.spoolProcedure = gHandleSpoolProc;      block.spool.buffer = nil;      block.spool.bufferSize = 0;      GXFlattenShape(shape, gxFontListFlatten | gxFontGlyphsFlatten | gxFontVariationsFlatten, &amp;block.spool);      flat = (Handle) block.data;        if (flat)        {          HLock(flat);        result = SetDragItemFlavorData(theDrag, theItem, 'qdgx', *flat, GetHandleSize(flat), 0);        DisposeHandle(flat);        }      }      break;          case 'PICT':      {        PicHandle proxie = ShapeToPICT(shape);      PicHandle pict = DecompressShape(shape, proxie, false, true);        if (proxie)        KillPicture(proxie);      if (pict)        {          HLock((Handle)pict);        result = SetDragItemFlavorData(theDrag, theItem, 'PICT', (Ptr)*pict, GetHandleSize((Handle)pict), 0);        KillPicture(pict);        }      }      break;          default:      result = badDragFlavorErr;      break;    }        return result;  } // GXSendDataProc#if GENERATINGCFM  static RoutineDescriptor gGXSendDataProcRD = BUILD_ROUTINE_DESCRIPTOR(uppDragSendDataProcInfo, GXSendDataProc);  static DragSendDataUPP gGXSendDataProc = &amp;gGXSendDataProcRD;#else  static DragSendDataUPP gGXSendDataProc = NewDragSendDataProc(GXSendDataProc);#endif// --------------------------------------------------------------------------------------------------------------static void ClearCurrentSelection(GXDataPtr pData){  pData-&gt;currentShapeIndex = 0;  pData-&gt;currentShapeStart = 0;  pData-&gt;currentShapeEnd = 0;  if (pData-&gt;currentSelectionShape)    {    GXDisposeShape(pData-&gt;currentSelectionShape);    pData-&gt;currentSelectionShape = nil;    }    } // ClearCurrentSelection// --------------------------------------------------------------------------------------------------------------static OSErr  GetCurrentPage(GXDataPtr pData, Boolean disposeOfSelection)/*  Disposes of previously loaded page information, and loads the  page information for the current page number.*/{  OSErr    anErr;  LongRect  oldRect, newRect;    if (pData-&gt;numberOfPages != 0)    {    // get rid of any previous format    if (pData-&gt;currentPageFormat)      {      GXDisposeFormat(pData-&gt;currentPageFormat);      pData-&gt;currentPageFormat = nil;      }          // get rid of any previous shape    if (pData-&gt;currentPageShape)      {      GXDisposeShape(pData-&gt;currentPageShape);      pData-&gt;currentPageShape = nil;      }          // get rid of selection, if desired    if (disposeOfSelection)      ClearCurrentSelection(pData);    GXGetDocumentRect((WindowRef)pData, (WindowDataPtr)pData, &amp;oldRect, false);        GXReadPrintFilePage(pData-&gt;thePrintFile,       pData-&gt;currentPage,       1, &amp;pData-&gt;childViewPort,       &amp;pData-&gt;currentPageFormat, &amp;pData-&gt;currentPageShape);    }      anErr = GXGetJobError(pData-&gt;w.hPrint);    if (anErr == noErr)    {    GXGetDocumentRect((WindowRef)pData,(WindowDataPtr) pData, &amp;newRect, false);        if   (      (oldRect.left != newRect.left) ||      (oldRect.top != newRect.top) ||      (oldRect.right != newRect.right) ||      (oldRect.bottom != newRect.bottom)      )      {      // if the resulting page is &lt; the current window size, we need to resize,      long newWidth   = newRect.right - newRect.left + kScrollBarSize;      long newHeight   = newRect.bottom - newRect.top + kScrollBarSize;      long oldWidth   = pData-&gt;w.theWindow.port.portRect.right - pData-&gt;w.theWindow.port.portRect.left;      long oldHeight   = pData-&gt;w.theWindow.port.portRect.bottom - pData-&gt;w.theWindow.port.portRect.top;            // but don't let it get too small!      if (newWidth &lt; pData-&gt;w.minHSize)        newWidth = pData-&gt;w.minHSize;      if (newHeight &lt; kMinGXDocSize)        newHeight = kMinGXDocSize;              if   (        (newWidth &lt; oldWidth) ||        (newHeight &lt; oldHeight)        )        {        if (newWidth &gt; oldWidth)          newWidth = oldWidth;        if (newHeight &gt; oldHeight)          newHeight = oldHeight;                  SizeWindow((WindowRef)pData, newWidth, newHeight, false);        }              // and in any case, the scroll bars should update      AdjustScrollBars((WindowRef)pData, true, true, nil);      }    }      return(anErr);  } // GetCurrentPage// --------------------------------------------------------------------------------------------------------------#define charBullet  '*'static void GetIntlTokenChar(short whichToken, short whichScript, char *bulletString)//// GetIntlTokenChar//// This routine gets a character out of the itl4 given a script and token\xC9//{  Handle  itl4H;  long  offset, len;  // default the value  bulletString[0] = 1;  bulletString[1] = charBullet;    // Look up the untoken table -- bail if we can't get it  GetIntlResourceTable(whichScript, iuUnTokenTable, &amp;itl4H, &amp;offset, &amp;len);  if (itl4H &amp;&amp; (offset &gt; 0) &amp;&amp; (len &gt;= 0))  {    char *sp = (*itl4H + offset);        // Point to start of untoken table    if (whichToken &lt;= ((short *)sp)[1])      // Check if token has valid index    {      sp += ((short *)sp)[2+whichToken];    // Add the string offset and voli\x87!      BlockMoveData(sp, bulletString, sp[0]+1);    }  }  } // GetIntlTokenChar// --------------------------------------------------------------------------------------------------------------// This code is required to change pop up menus to a different font size.  It would be// better to use the pop up control, but it doesn't allow multiple items to be marked.#define SysFontSize  0xBA8#define SysFontFam  0xBA6#define CurFMInput  0x988static void DoUseWFont(TextState *savedInfo, WindowRef owner,  Boolean saveIt)/*************************************************************  DoUseWFont    - Sets the font mgr low mem globals so            we can have Geneva 9 popups    savedInfo  - Fills it in if saveIt = true, else            it sets the port to those values    owner    - Where to get the original values    saveIt    - true for save**************************************************************/{  TextState    myState,          *theState;  short      aFont;  theState = savedInfo;  if (saveIt)     {    savedInfo-&gt;theFont = GetSysFont();  // save low memory globals    savedInfo-&gt;theSize = *((short *) SysFontSize);    myState.theFont = GetWindowPort(owner)-&gt;txFont;    myState.theSize = GetWindowPort(owner)-&gt;txSize;    theState = &amp;myState;    // if we stuff systemFont, it will screw up Script Mgr    if (GetWindowPort(owner)-&gt;txFont == systemFont)      goto dosizestuff;    }  // if we stuff applFont, this will also screw up Script Mgr  // instead we get the actual font  aFont = theState-&gt;theFont;  if (saveIt)    if (GetWindowPort(owner)-&gt;txFont == applFont)      aFont = GetAppFont();  *((short *) SysFontFam) = aFont;          // set/restore low memory globalsdosizestuff:  *((short *) SysFontSize) = theState-&gt;theSize;  *((long *) CurFMInput) = 0xFFFFFFFF;  } // DoUseWFont// --------------------------------------------------------------------------------------------------------------static void SetZoom(WindowRef pWindow, WindowDataPtr pData, Fixed newZoom)/*  Sets the new zoom factor for the window, causing an update for  the window if required.*/{  Fixed  scaleFactor;    // pin to max/min zoom factors  if (newZoom &gt; ff(32))    newZoom = ff(32);  if (newZoom &lt; 0x0800)    newZoom = 0x0800;    scaleFactor = FixedDivide(newZoom, ((GXDataPtr)pData)-&gt;zoomFactor);    if (scaleFactor != ff(1))    {    gxPoint    centerPoint;    GrafPtr    pPort = (GrafPtr)GetWindowPort(pWindow);        // zoom about the window center    centerPoint.x = ff(pPort-&gt;portRect.left + (RectWidth(pPort-&gt;portRect) &gt;&gt; 1));    centerPoint.y = ff(pPort-&gt;portRect.top + (RectHeight(pPort-&gt;portRect) &gt;&gt; 1));        // new zoom active    ((GXDataPtr)pData)-&gt;zoomFactor = newZoom;        // force update and recalc the size of window    InvalRect(&amp;pPort-&gt;portRect);    AdjustScrollBars(pWindow, true, true, nil);     // scale scroll values    SetControlValue(pData-&gt;hScroll, FixedToInt( FixedDivide(centerPoint.x, scaleFactor) + FixedMultiply(ff(GetControlValue(pData-&gt;hScroll)), scaleFactor) ) );    SetControlValue(pData-&gt;vScroll, FixedToInt( FixedDivide(centerPoint.y, scaleFactor) + FixedMultiply(ff(GetControlValue(pData-&gt;vScroll)), scaleFactor) ) );        // zoom the selection    ((GXDataPtr)pData)-&gt;selectionRectangle.left   = FixedToInt (FixedMultiply(ff(((GXDataPtr)pData)-&gt;selectionRectangle.left), scaleFactor) );    ((GXDataPtr)pData)-&gt;selectionRectangle.top     = FixedToInt (FixedMultiply(ff(((GXDataPtr)pData)-&gt;selectionRectangle.top), scaleFactor) );    ((GXDataPtr)pData)-&gt;selectionRectangle.right   = FixedToInt (FixedMultiply(ff(((GXDataPtr)pData)-&gt;selectionRectangle.right), scaleFactor) );    ((GXDataPtr)pData)-&gt;selectionRectangle.bottom   = FixedToInt (FixedMultiply(ff(((GXDataPtr)pData)-&gt;selectionRectangle.bottom), scaleFactor) );    }  } // SetZoom// --------------------------------------------------------------------------------------------------------------static void SetShapeGreyColorLevel(gxShape thisShape, unsigned long greyLevel){  gxColor thisColor;  thisColor.space = gxGraySpace;  thisColor.profile = nil;  thisColor.element.gray = greyLevel;  GXSetShapeColor(thisShape, &amp;thisColor);  } // SetShapeGreyColorLevel// --------------------------------------------------------------------------------------------------------------static void  CenterRect(Rect *source, Rect *against)/*  Centers &quot;source&quot; within or around &quot;against&quot;.*/{  // center picture if requested  short  height, width, pheight, pwidth;    height = (against-&gt;bottom - against-&gt;top) &gt;&gt; 1;  width = (against-&gt;right - against-&gt;left) &gt;&gt; 1;  pheight = (source-&gt;bottom - source-&gt;top) &gt;&gt; 1;  pwidth = (source-&gt;right - source-&gt;left) &gt;&gt; 1;    source-&gt;top = against-&gt;top + height - pheight;  source-&gt;bottom = against-&gt;bottom - height + pheight;  source-&gt;left = against-&gt;left + width - pwidth;  source-&gt;right = against-&gt;right - width + pwidth;} // CenterRect// --------------------------------------------------------------------------------------------------------------static gxShape FindNestedIndexedLayout(gxShape shape,           long searchIndex, long * pIndex, gxMapping *pConcatMapping)/*  Returns the shape represented by &quot;searchIndex&quot; shapes into the picture,  sequentially, including all nestings of pictures.  Uses pIndex as  work storage, which must be initialized to zero before the call.    Returns shape found, or NIL if the searchIndex is larger than  the number of shapes in the picture.  If NIL is returned,  then the contents of pIndex will contain the number of  shapes in the picture.*/{  gxShape    returnShape = nil;  gxShapeType shapeType = GXGetShapeType(shape);  // bail on negative index  if (searchIndex &lt; 0)    return(nil);      if (shapeType == gxPictureType)    {      long    index, count;    gxShape    contentShape;    gxTransform  contentTransform;    gxMapping  contentMapping;        count = GXGetPicture(shape, nil, nil, nil, nil);    for (index = 0; index &lt; count; index++)      {      GXGetPictureParts(shape, index+1, 1, &amp;contentShape, nil, nil, &amp;contentTransform);            returnShape = FindNestedIndexedLayout(contentShape, searchIndex, pIndex, pConcatMapping ? &amp;contentMapping : nil);      if (returnShape)        {        if (pConcatMapping)          {          if (!contentTransform)            contentTransform = GXGetShapeTransform(contentShape);          GXGetTransformMapping(contentTransform, &amp;contentMapping);          MapMapping(&amp;contentMapping, pConcatMapping);          *pConcatMapping = contentMapping;          }        break;        }      }    }  else     {    if ( (shapeType == gxLayoutType) || (shapeType == gxGlyphType) || (shapeType == gxTextType) )      {      (*pIndex)++;      if (searchIndex == *pIndex)        returnShape = shape;      }    }      return(returnShape);  } // FindNestedIndexedLayout// --------------------------------------------------------------------------------------------------------------static Boolean PerformNextFind(WindowRef pWindow, WindowDataPtr pData,        Str255 findString,        Boolean caseSensitive,        Boolean backwards,        Boolean wraparound){  Boolean  foundSomething = false;  long  searchIndex, workIndex;  gxShape  aShape;  long  direction;  long  oldPageNumber = ((GXDataPtr)pData)-&gt;currentPage;  long  endPageNumber;  Boolean  firstTime = true;  gxMapping  concatMapping;    // initialize direction of the walk  if (backwards)    direction = -1;  else    direction = 1;    // start searching where we last left off    searchIndex = ((GXDataPtr)pData)-&gt;currentShapeIndex;  if (searchIndex != 0)    searchIndex -= direction;    if (((GXDataPtr)pData)-&gt;numberOfPages == 1)    wraparound = false;  // end searching on a particular page  if (backwards)    endPageNumber = 0;  else    endPageNumber = ((GXDataPtr)pData)-&gt;numberOfPages + 1;    // can't search on qd shapes, so we get rid of them  GetRidOfAnyQDShapeTags(((GXDataPtr)pData)-&gt;currentPageShape);  do    {    // search for the next shape or prev shape    searchIndex += direction;        // initialize the working index so that we know traversal level    workIndex = 0;        // initialize the mapping to identity    ResetMapping(&amp;concatMapping);    GXGetShapeMapping(((GXDataPtr)pData)-&gt;currentPageShape, &amp;concatMapping);        // find the next layout in the page    aShape = FindNestedIndexedLayout(((GXDataPtr)pData)-&gt;currentPageShape, searchIndex, &amp;workIndex, &amp;concatMapping);    if (aShape)      {      gxShapeType shapeType = GXGetShapeType(aShape);      long      size;      Handle    aHandle;            // determine size and allocate storage for layout contents      switch (shapeType)        {        case gxTextType:          size = GXGetText(aShape, nil, nil, nil);          break;        case gxGlyphType:          size = GXGetGlyphs(aShape, nil, nil, nil,                  nil, nil, nil, nil, nil);          break;        case gxLayoutType:          size = GXGetLayout(aShape, nil,                  nil, nil, nil,   // styles                  nil, nil, nil,   // levels                  nil, nil);    // options/position          break;        }      aHandle = NewHandle(size);            if (aHandle)        {        long newStart, newEnd;                // grab the contents of the layout into the temp storage        HLock(aHandle);        switch (shapeType)          {          case gxTextType:            GXGetText(aShape, nil, (unsigned char*)*aHandle, nil);            break;          case gxGlyphType:            GXGetGlyphs(aShape, nil,  (unsigned char*)*aHandle, nil,                    nil, nil, nil, nil, nil);            break;          case gxLayoutType:            GXGetLayout(aShape,  (unsigned char*)*aHandle,                  nil, nil, nil,   // styles                  nil, nil, nil,   // levels                  nil, nil);    // options/position            break;          }        HUnlock(aHandle);                // search the handle for the string we're looking for,        // but don't wraparound because we handle that over layout        // ranges and pages ourselves        {        long offset;                if ((firstTime) &amp;&amp; (((GXDataPtr)pData)-&gt;currentSelectionShape))          {          // for shape that we have found something in before          // start at end of last point if forwards, start of last point          // if backwards          firstTime = false;          offset = backwards ? ((GXDataPtr)pData)-&gt;currentShapeStart : ((GXDataPtr)pData)-&gt;currentShapeEnd;          }        else          {          // for &quot;new&quot; shape we haven't hit before, start at          // begining for forwards, end for backwards          offset = backwards ? size : 0;          }                  foundSomething = PerformSearch(aHandle, offset, findString,               caseSensitive, backwards, false,              &amp;newStart, &amp;newEnd);        }                      // done with our temp storage        DisposeHandle(aHandle);                // got it?  then mark it and bail out        if (foundSomething)          {          // remember where we are in the page          ((GXDataPtr)pData)-&gt;currentShapeIndex = searchIndex;                    // what offsets the selection is          ((GXDataPtr)pData)-&gt;currentShapeStart = newStart;          ((GXDataPtr)pData)-&gt;currentShapeEnd = newEnd;                    // and the shape containing the selection          if (((GXDataPtr)pData)-&gt;currentSelectionShape)            GXDisposeShape(((GXDataPtr)pData)-&gt;currentSelectionShape);          ((GXDataPtr)pData)-&gt;currentSelectionShape = GXCloneShape(aShape);          ((GXDataPtr)pData)-&gt;currentSelectionMapping = concatMapping;          break;          } // found the string                  } // allocated the handle              } // found a shape    else      {      OSErr  anErr = noErr;            // didn't find it on this page, move on      ((GXDataPtr)pData)-&gt;currentPage += direction;                    // clamp to the ends of the range      if (backwards)        {        if (((GXDataPtr)pData)-&gt;currentPage &lt;= endPageNumber)          {          if (wraparound)            {            ((GXDataPtr)pData)-&gt;currentPage = ((GXDataPtr)pData)-&gt;numberOfPages;            endPageNumber = oldPageNumber;            wraparound = false;            }          else            anErr = paramErr;          }        }      else        {        if (((GXDataPtr)pData)-&gt;currentPage &gt;= endPageNumber)          {          if (wraparound)            {            ((GXDataPtr)pData)-&gt;currentPage = 1;            endPageNumber = oldPageNumber;            wraparound = false;            }          else            anErr = paramErr;          }        }              // fetch contents      if (anErr == noErr)        anErr = GetCurrentPage((GXDataPtr) pData, false);              // anything wrong?  then all done searching      if (anErr != noErr)        {        break;        }      else        {        GetRidOfAnyQDShapeTags(((GXDataPtr)pData)-&gt;currentPageShape);        if (backwards)          {          workIndex = 0;          (void) FindNestedIndexedLayout(((GXDataPtr)pData)-&gt;currentPageShape, 0x7FFFFFF, &amp;workIndex, nil);          searchIndex = workIndex;          }        else          searchIndex = 0;        }      }    } while (!foundSomething);    // if we found something, force and update.  If not, make sure  // that the current page is restored to the page we had when   // coming in.  if (foundSomething)    {    InvalRect(&amp;GetWindowPort(pWindow)-&gt;portRect);    }  else    {    if (oldPageNumber != ((GXDataPtr)pData)-&gt;currentPage)      {      ((GXDataPtr)pData)-&gt;currentPage = oldPageNumber;      GetCurrentPage((GXDataPtr) pData, false);      }    }  return(foundSomething);  } // PerformNextFind// --------------------------------------------------------------------------------------------------------------static gxShape GetCurrentSelectionHighlight(WindowDataPtr pData, Boolean mapIt){  gxShape    highlight;    highlight = GXGetLayoutHighlight(((GXDataPtr)pData)-&gt;currentSelectionShape,             ((GXDataPtr)pData)-&gt;currentShapeStart, ((GXDataPtr)pData)-&gt;currentShapeEnd,            gxHighlightAverageAngle, nil);                if (mapIt)    GXMapShape(highlight, &amp;((GXDataPtr)pData)-&gt;currentSelectionMapping);    // draw and dispose of the highlight  GXSetShapeViewPorts(highlight, 1, &amp;((GXDataPtr)pData)-&gt;childViewPort);  GXSetShapeFill(highlight, gxClosedFrameFill);  GXSetShapeClip(highlight, nil);  return(highlight);  } // GetCurrentSelectionHighlight// --------------------------------------------------------------------------------------------------------------static void ScrollFoundShapeIntoView(WindowRef pWindow, WindowDataPtr pData){  gxRectangle  bounds;  Point    scrollAmount;  Point    controlValues;  gxRectangle  windowBounds;  GrafPtr    pPort = (GrafPtr)GetWindowPort(pWindow);    if ( ! (((GXDataPtr)pData)-&gt;currentSelectionShape) )    return;      // cache scroll state  controlValues.h = GetControlValue(pData-&gt;hScroll);  controlValues.v = GetControlValue(pData-&gt;vScroll);    // calculate visible bounds of window  windowBounds.left     = ff(pPort-&gt;portRect.left + controlValues.h);  windowBounds.right     = ff(pPort-&gt;portRect.right - kScrollBarSize + controlValues.h);  windowBounds.top     = ff(pPort-&gt;portRect.top + controlValues.v);  windowBounds.bottom   = ff(pPort-&gt;portRect.bottom - kScrollBarSize + controlValues.v);          // grab the bounds of the shape, add on the margins, scale to zoom factor  {  gxRectangle    pageSize, paperSize;  gxShape      highlight = GetCurrentSelectionHighlight(pData, false);    GXGetShapeBounds(highlight, 0, &amp;bounds);  GXDisposeShape(highlight);  GetCurrentPageAndPaper(pData, &amp;pageSize, &amp;paperSize);  bounds.left   = FixedMultiply(bounds.left - paperSize.left, ((GXDataPtr)pData)-&gt;zoomFactor);  bounds.right   = FixedMultiply(bounds.right - paperSize.left, ((GXDataPtr)pData)-&gt;zoomFactor);  bounds.top     = FixedMultiply(bounds.top - paperSize.top, ((GXDataPtr)pData)-&gt;zoomFactor);  bounds.bottom   = FixedMultiply(bounds.bottom - paperSize.top, ((GXDataPtr)pData)-&gt;zoomFactor);  }  if   (    (bounds.bottom &lt;= windowBounds.top) ||    (bounds.top &gt;= windowBounds.bottom) ||    (bounds.right &lt;= windowBounds.left) ||    (bounds.left &gt;= windowBounds.right)     )    {    scrollAmount.h = controlValues.h - FixedToInt(bounds.left);    scrollAmount.v = controlValues.v - FixedToInt(bounds.top);        SetControlAndClipAmount(pData-&gt;hScroll, &amp;scrollAmount.h);    SetControlAndClipAmount(pData-&gt;vScroll, &amp;scrollAmount.v);    if ((scrollAmount.h) || (scrollAmount.v))      DoScrollContent(pWindow, pData, scrollAmount.h, scrollAmount.v);    }    } // ScrollFoundShapeIntoView// --------------------------------------------------------------------------------------------------------------static Boolean TrackIn(Rect *pTrackRect, Point clickPoint, Rect *pDrawRect, short inID, short outID){  Boolean  in = false;    if (PtInRect(clickPoint, pTrackRect))    {    in = true;        PlotIconID(pDrawRect, ttNone, ttNone, inID);    while (StillDown())      {      GetMouse(&amp;clickPoint);            if (PtInRect(clickPoint, pTrackRect))        {        if (!in)          {          in = true;          PlotIconID(pDrawRect, ttNone, ttNone, inID);          }        }      else        {        if (in)          {          in = false;          PlotIconID(pDrawRect, ttNone, ttNone, outID);          }        }      }    }      return(in);  } // TrackIn// --------------------------------------------------------------------------------------------------------------static void DrawPageSliderAndThumb(WindowRef pWindow, long currentValue, long maxValue){  Rect    pageSliderRect;  Rect    pageThumbRect;  long    pixelValue;  Str255    aString;  FontInfo  theInfo;  PicHandle  proxyHandle;  Rect    proxyRect;  GrafPtr    pPort = (GrafPtr)GetWindowPort(pWindow);    // calculate location of the slider  pageSliderRect.left   = kPageSliderMargins;  pageSliderRect.bottom   = pPort-&gt;portRect.bottom - kPageSliderMargins;  pageSliderRect.top     = pageSliderRect.bottom - kPageSliderHeight;  pageSliderRect.right   = pPort-&gt;portRect.right - kPageSliderMargins;      // then calculate the thumb within that slider  pixelValue = (currentValue-1)         *        (pageSliderRect.right - pageSliderRect.left - kPageThumbMargins*2 - kPageThumbWidth)         /        (maxValue-1);          pageThumbRect.left     = pageSliderRect.left + kPageThumbMargins + pixelValue;  pageThumbRect.right    = pageThumbRect.left + kPageThumbWidth;  pageThumbRect.top    = pageSliderRect.top - kPageThumbEdge;  pageThumbRect.bottom  = pageThumbRect.top + kPageThumbHeight;  // and finally, the location to draw the proxy (if any)  proxyRect.top      = kPageSliderMargins;  proxyRect.bottom    = proxyRect.top + kProxyHeight;  proxyRect.left      = pPort-&gt;portRect.left +                 ((pPort-&gt;portRect.right - pPort-&gt;portRect.left) &gt;&gt; 1) -                (kProxyWidth &gt;&gt; 1);  proxyRect.right      = proxyRect.left + kProxyWidth;  if (Count1Resources(kProxyType) == 0)    proxyRect.bottom = proxyRect.top;      // draw the slider area  FillRect(&amp;pageSliderRect, &amp;qd.gray);  FrameRect(&amp;pageSliderRect);  // erase areas above and below the slider (old thumb erase)  {  Rect  sliderEraseRect = pageSliderRect;    ForeColor(whiteColor);  sliderEraseRect.top = pageThumbRect.top;  sliderEraseRect.bottom = sliderEraseRect.top + kPageThumbEdge;  PaintRect(&amp;sliderEraseRect);  sliderEraseRect.bottom = pageThumbRect.bottom;  sliderEraseRect.top = sliderEraseRect.bottom - kPageThumbEdge;  PaintRect(&amp;sliderEraseRect);  }    // draw the thumb  ForeColor(blackColor);  FrameRect(&amp;pageThumbRect);  InsetRect(&amp;pageThumbRect, 1, 1);  ForeColor(whiteColor);  FrameRect(&amp;pageThumbRect);  InsetRect(&amp;pageThumbRect, 1, 1);  ForeColor(blackColor);  FrameRect(&amp;pageThumbRect);  // draw page string label  TextFace(bold);  TextFont(applFont);  TextSize(9);  TextMode(srcCopy);  GetFontInfo(&amp;theInfo);    MoveTo(pageSliderRect.left, pageThumbRect.top - kPageThumbEdge - theInfo.descent);  GetIndString(aString, kPageControlStrings, iGoToPageString);  DrawString(aString);  NumToString(currentValue, aString);  DrawString(aString);    // erase any trailing digits (pretty cheezy, but seems to work)  DrawString(&quot;\p       &quot;);    // draw the proxy, or erase the proxy area if no picture to draw  proxyHandle = (PicHandle) GetResource(kProxyType, kProxyBaseID + currentValue - 1);  if (proxyHandle)    {    Rect  drawRect;    Fixed  scaleFactor;        drawRect = (**proxyHandle).picFrame;        // compute aspect ratio preserving scale    if (RectHeight(drawRect) &gt; RectWidth(drawRect))      scaleFactor = FixRatio(RectHeight(proxyRect), RectHeight(drawRect));    else      scaleFactor = FixRatio(RectWidth(proxyRect), RectWidth(drawRect));    drawRect.bottom = drawRect.top +          ( FixMul( (RectHeight(drawRect) &lt;&lt; 16), scaleFactor) &gt;&gt; 16);    drawRect.right = drawRect.left +          ( FixMul( (RectWidth(drawRect) &lt;&lt; 16), scaleFactor) &gt;&gt; 16);    CenterRect(&amp;drawRect, &amp;proxyRect);        // erase the area outside of the picture, but inside of the     // total proxy area, because some pictures will leave whitespace on the edge    {    RgnHandle  rgn1 = NewRgn();    RgnHandle  rgn2 = NewRgn();        RectRgn(rgn1, &amp;proxyRect);    RectRgn(rgn2, &amp;drawRect);    DiffRgn(rgn1, rgn2, rgn1);    EraseRgn(rgn1);    DisposeRgn(rgn1);    DisposeRgn(rgn2);    }    // finally, we can draw and dispose of the picture    DrawPicture(proxyHandle, &amp;drawRect);    ReleaseResource((Handle) proxyHandle);        }  else    {    EraseRect(&amp;proxyRect);    }    } // DrawPageSliderAndThumb// --------------------------------------------------------------------------------------------------------------static OSErr  DoDrawingClick(WindowRef pWindow, WindowDataPtr pData, Point clickPoint, EventRecord *pEvent){#pragma unused (pEvent, pWindow)  OSErr  anErr = noErr;  Point  lastPoint = clickPoint;  Point  currentPoint;  Fixed  penSize;  gxInk  newInk = GXNewInk();  gxStyle newStyle = GXNewStyle();  gxShape  newShape = GXNewShape(gxPolygonType);  long  addPoly[] = {1, 1, 0, 0};    // set up the style for the shape  GXSetStylePen(newStyle, ff(10));    // and the ink for the shape  {  gxColor  redColor;  gxTransferMode mode;    // the color  redColor.space    = gxRGBSpace;  redColor.profile  = nil;  redColor.element.rgb.red  = 0xFFFF;  redColor.element.rgb.green  = 0x0000;  redColor.element.rgb.blue  = 0x0000;  GXSetInkColor(newInk, &amp;redColor);    // the transfer mode  mode.space     = gxHSVSpace;  mode.set    = nil;  mode.profile  = nil;  InitColorMatrix(mode.sourceMatrix);  InitColorMatrix(mode.deviceMatrix);  InitColorMatrix(mode.resultMatrix);  mode.flags    = 0;    mode.component[0].mode  = gxCopyMode;  mode.component[0].flags  = 0;  mode.component[0].sourceMinimum  = 0;  mode.component[0].sourceMaximum  = gxColorValue1;  mode.component[0].deviceMinimum  = 0;  mode.component[0].deviceMaximum  = gxColorValue1;  mode.component[0].clampMinimum  = 0;  mode.component[0].clampMaximum  = gxColorValue1;  mode.component[0].operand    = 0;  mode.component[1].mode  = gxCopyMode;  mode.component[1].flags  = 0;  mode.component[1].sourceMinimum  = 0;  mode.component[1].sourceMaximum  = gxColorValue1;  mode.component[1].deviceMinimum  = 0;  mode.component[1].deviceMaximum  = gxColorValue1;  mode.component[1].clampMinimum  = 0;  mode.component[1].clampMaximum  = gxColorValue1;  mode.component[1].operand    = 0;  mode.component[2].mode  = gxNoMode;  mode.component[2].flags  = 0;  mode.component[2].sourceMinimum  = 0;  mode.component[2].sourceMaximum  = gxColorValue1;  mode.component[2].deviceMinimum  = 0;  mode.component[2].deviceMaximum  = gxColorValue1;  mode.component[2].clampMinimum  = 0;  mode.component[2].clampMaximum  = gxColorValue1;  mode.component[2].operand    = 0;  GXSetInkTransfer(newInk, &amp;mode);  }    // set the style and ink of the shape  GXSetShapeStyle(newShape, newStyle);  GXSetShapeInk(newShape, newInk);  GXSetShapeFill(newShape, gxOpenFrameFill);    // initialize the first point in the shape  addPoly[2] = ff(lastPoint.h);  addPoly[3] = ff(lastPoint.v);  GXSetPolygonParts(newShape, gxSelectToEnd, 1, (gxPolygons*)addPoly, gxRemoveDuplicatePointsEdit);  // determine the amount we require the mouse to move before adding a new point  penSize = FixedDivide(GXGetStylePen(newStyle), ff(2));  if (penSize &lt; ff(1))    penSize = ff(1);  do    {    GetMouse(&amp;currentPoint);    if   (      (ff(ABS(currentPoint.h - lastPoint.h)) &gt; penSize) ||      (ff(ABS(currentPoint.v - lastPoint.v)) &gt; penSize)      )      {      // add the new point to the new shape      lastPoint = currentPoint;      addPoly[2] = ff(lastPoint.h);      addPoly[3] = ff(lastPoint.v);      GXSetPolygonParts(newShape, gxSelectToEnd, 1, (gxPolygons*)addPoly, gxRemoveDuplicatePointsEdit);      GXDrawShape(newShape);      }    } while (StillDown());    {  Fixed      zoomFactor = ((GXDataPtr)pData)-&gt;zoomFactor;  Fixed      shapeScale = FixedDivide(ff(1), zoomFactor);  gxRectangle    pageSize, paperSize;      // offset the shape by the scroll bars &amp; margins  GetCurrentPageAndPaper(pData, &amp;pageSize, &amp;paperSize);  GXMoveShape(newShape,         ff(GetControlValue(pData-&gt;hScroll)) + FixedMultiply(paperSize.left, zoomFactor),        ff(GetControlValue(pData-&gt;vScroll)) + FixedMultiply(paperSize.top, zoomFactor) );  // scale the shape to the current scale factor  GXScaleShape(newShape, shapeScale, shapeScale, 0, 0 );  GXSetShapePen(newShape, FixedMultiply(GXGetShapePen(newShape), shapeScale) );  }    // add shape to the page  {  gxShape    annotationShape = (*((GXDataPtr)pData)-&gt;pageAnnotations)[((GXDataPtr)pData)-&gt;currentPage-1];    if (!annotationShape)    {    annotationShape = GXNewShape(gxPictureType);    (*((GXDataPtr)pData)-&gt;pageAnnotations)[((GXDataPtr)pData)-&gt;currentPage-1] = annotationShape;    }  if (annotationShape)    GXSetPictureParts(annotationShape, 0, 0, 1, &amp;newShape, nil, nil, nil);  }  // all done with our copies of the shape, style, and ink    GXDisposeShape(newShape);  GXDisposeStyle(newStyle);  GXDisposeInk(newInk);    // we've touched the file  pData-&gt;changed = true;    return(anErr);  } // DoDrawingClick// --------------------------------------------------------------------------------------------------------------// Handle update/activate events behind Standard Filestatic pascal Boolean SaveDialogFilter(DialogPtr theDialog, EventRecord *theEvent,                    short *itemHit, void *myDataPtr){  #pragma unused(myDataPtr)  if (StdFilterProc(theDialog, theEvent, itemHit))    return true;  // Pass updates through (Activates are tricky...was mucking with Apple menu &amp; thereby  // drastically changing how the system handles the menu bar during our alert)  if (theEvent-&gt;what == updateEvt /* || theEvent-&gt;what == activateEvt */ )    {    HandleEvent(theEvent);    }  return false;} // SaveDialogFilter#if GENERATINGCFM  static RoutineDescriptor gSaveDialogFilterRD = BUILD_ROUTINE_DESCRIPTOR(uppModalFilterYDProcInfo, SaveDialogFilter);  static ModalFilterYDUPP gSaveDialogFilter = &amp;gSaveDialogFilterRD;#else  static ModalFilterYDUPP gSaveDialogFilter = NewModalFilterYDProc(SaveDialogFilter);#endif// --------------------------------------------------------------------------------------------------------------#define kLoadAnnotations  true#define kSaveAnnotations  falsestatic OSErr  LoadOrSaveAnnotations(WindowDataPtr pData, Boolean load){  OSErr        anErr = noErr;  short        i;  short        oldResFile = CurResFile();  userSpool       block;    block.spool.spoolProcedure = gHandleSpoolProc;    UseResFile(((GXDataPtr)pData)-&gt;printFileRefNum);  for (i = 0; i &lt; ((GXDataPtr)pData)-&gt;numberOfPages; ++i)    {    gxShape annotation = (*((GXDataPtr)pData)-&gt;pageAnnotations)[i];    Handle  annotationHandle;        block.spool.buffer = nil;    block.spool.bufferSize = 0;    if (load)      {      // load annotation, if any      annotationHandle = Get1Resource(kAnnotationType, kAnnotationBaseID + i-1);      if (annotationHandle)        {        block.data = annotationHandle;        annotation = GXUnflattenShape(&amp;block.spool, 0, nil);        ReleaseResource(annotationHandle);        }      else        {        annotation = nil;        }      }    else      {      // remove old annotation      annotationHandle = Get1Resource(kAnnotationType, kAnnotationBaseID + i-1);      if (annotationHandle)        RemoveResource(annotationHandle);              // add new annotation      if (annotation)        {        block.spool.spoolProcedure = gHandleSpoolProc;        block.spool.buffer = nil;        block.spool.bufferSize = 0;        GXFlattenShape(annotation, 0, &amp;block.spool);        annotationHandle = (Handle) block.data;        if (annotationHandle)          {          AddResource(annotationHandle, kAnnotationType, kAnnotationBaseID + i-1, &quot;\p&quot;);          ReleaseResource(annotationHandle);          }        }      }          (*((GXDataPtr)pData)-&gt;pageAnnotations)[i] = annotation;    }  UpdateResFile(CurResFile());  UseResFile(oldResFile);    return(anErr);  } // LoadOrSaveAnnotations// --------------------------------------------------------------------------------------------------------------static OSErr  GXSaveAs(WindowRef pWindow, WindowDataPtr pData){  OSErr        anErr = noErr;  StandardFileReply  sfReply;    // ask where and how to save this document  {  Str255  defaultName;  Point  where = {-1, -1};    // setup for the call  GetWTitle(pWindow, defaultName);  SetCursor(&amp;qd.arrow);    // find out where the user wants the file  CustomPutFile(&quot;\p&quot;, defaultName, &amp;sfReply,         sfPutDialogID, where,        nil, gSaveDialogFilter, nil, nil, nil);    // map the cancel button into a cancelling error  if (!sfReply.sfGood)    anErr = eUserCanceled;  }      // can't replace over other types    if (sfReply.sfReplacing)    {    FInfo  theInfo;        FSpGetFInfo(&amp;sfReply.sfFile, &amp;theInfo);        if (       (theInfo.fdType != 'sjob') &amp;&amp;       (theInfo.fdType != 'tjob') &amp;&amp;       (theInfo.fdType != 'rjob') &amp;&amp;       (theInfo.fdType != 'qjob')       )      anErr = eDocumentWrongKind;    }  nrequire(anErr, StandardPutFile);      GXSavePrintFile(((GXDataPtr)pData)-&gt;thePrintFile, &amp;sfReply.sfFile);  anErr = GXGetJobError(pData-&gt;hPrint);  // FALL THROUGH EXCEPTION HANDLINGStandardPutFile:  // if everything went okay  if (anErr == noErr)    {    // update the window title     SetWTitle(pWindow, sfReply.sfFile.name);      // save new location    BlockMoveData(&amp;sfReply.sfFile, &amp;pData-&gt;fileSpec, sizeof(FSSpec));    // update the refNum    ((GXDataPtr)pData)-&gt;printFileRefNum = CurResFile();        // and read in the current page    anErr = GetCurrentPage((GXDataPtr) pData, true);    }    // Return eUserCanceled so we can avoid closing/quitting if they cancel the SF dialog//  // don't propagate this error//  if (anErr == eUserCanceled)//    anErr = noErr;  return anErr;  } // GXSaveAs// --------------------------------------------------------------------------------------------------------------// OOP INTERFACE ROUTINES// --------------------------------------------------------------------------------------------------------------static OSErr  GXCloseWindow(WindowRef pWindow, WindowDataPtr pData){#pragma unused (pWindow)  if (((GXDataPtr)pData)-&gt;pageAnnotations)    {    short  i;        for (i = 0; i &lt; ((GXDataPtr)pData)-&gt;numberOfPages; ++i)      {      gxShape annotation = (*((GXDataPtr)pData)-&gt;pageAnnotations)[i];            if (annotation)        GXDisposeShape(annotation);      }    DisposeHandle((Handle) (((GXDataPtr)pData)-&gt;pageAnnotations) );    ((GXDataPtr)pData)-&gt;pageAnnotations = nil;    }    if (((GXDataPtr)pData)-&gt;currentSelectionShape)    {    GXDisposeShape(((GXDataPtr)pData)-&gt;currentSelectionShape);    ((GXDataPtr)pData)-&gt;currentSelectionShape = nil;    }              if (((GXDataPtr)pData)-&gt;currentPageShape)    {    GXDisposeShape(((GXDataPtr)pData)-&gt;currentPageShape);    ((GXDataPtr)pData)-&gt;currentPageShape = nil;    }  GXClosePrintFile( ((GXDataPtr)pData)-&gt;thePrintFile);  GXDisposeViewPort( ((GXDataPtr)pData)-&gt;parentViewPort);  GXDisposeViewPort( ((GXDataPtr)pData)-&gt;childViewPort);  return(noErr);  } // GXCloseWindow// --------------------------------------------------------------------------------------------------------------static OSErr  GXUpdateWindow(WindowRef pWindow, WindowDataPtr pData){  gxGraphicsError    anErr = noErr;    // draw informational area to the left of the horizontal scroll bar  {  FontInfo  theInfo;  Rect    infoArea;  RgnHandle  oldClip = NewRgn();  Handle    theString;  long    theStringSize;    // save old clip and clip to the label area  GetClip(oldClip);  infoArea.left = 0;  infoArea.right = pData-&gt;hScrollOffset-1;  infoArea.bottom = GetWindowPort(pWindow)-&gt;portRect.bottom;  infoArea.top = infoArea.bottom - kScrollBarSize;  ClipRect(&amp;infoArea);      // draw the label  TextFont(applFont);  TextSize(9);  GetFontInfo(&amp;theInfo);  theString = GetResource('LSTR', kLabelString);  if (theString)    {    Handle  inString = NewHandle(sizeof(Str255));    Str255  newString;    Rect  labelArea = infoArea;        // erase any old string we had there    labelArea.right -= kZoomControlsWidth + kToolControlWidth;    if (((GXDataPtr)pData)-&gt;numberOfPages &gt; 1)      labelArea.left += kPageControlsWidth;        EraseRect(&amp;labelArea);        // current page label    NumToString(((GXDataPtr)pData)-&gt;currentPage, newString);    SetHandleSize(inString, newString[0]);    BlockMoveData(&amp;newString[1], *inString, newString[0]);    ReplaceText(theString, inString, &quot;\p^0&quot;);    // total page count label    NumToString(((GXDataPtr)pData)-&gt;numberOfPages, newString);    SetHandleSize(inString, newString[0]);    BlockMoveData(&amp;newString[1], *inString, newString[0]);    ReplaceText(theString, inString, &quot;\p^1&quot;);    // scale factor label    NumToString(FixedToInt( FixedMultiply(((GXDataPtr)pData)-&gt;zoomFactor, ff(100)) ), newString);    SetHandleSize(inString, newString[0]);    BlockMoveData(&amp;newString[1], *inString, newString[0]);    ReplaceText(theString, inString, &quot;\p^2&quot;);    // done with replace string content    DisposeHandle(inString);        // draw the label    HLock(theString);    theStringSize = GetHandleSize(theString);    MoveTo(labelArea.left + ((labelArea.right - labelArea.left) &gt;&gt; 1) - (TextWidth(*theString, 0, theStringSize) &gt;&gt; 1),         labelArea.top + ((labelArea.bottom - labelArea.top)&gt;&gt;1) + ((theInfo.ascent + theInfo.descent) &gt;&gt; 1) - theInfo.descent);    DrawText(*theString, 0, theStringSize);    ReleaseResource(theString);    }      // draw the current tool    {    Rect    toolArea = infoArea;    CIconHandle  icon;        toolArea.left = toolArea.right - kToolControlWidth;    toolArea.right = toolArea.left + 32;    toolArea.bottom = toolArea.top + 32;    EraseRect(&amp;toolArea);    OffsetRect(&amp;toolArea, -8, -8);        icon = GetCIcon(kIconBase + ((GXDataPtr)pData)-&gt;contentClickMode);    if (icon)      {      PlotCIconHandle(&amp;toolArea, kAlignAbsoluteCenter, ttNone, icon);      DisposeCIcon(icon);      }    }  // draw the zoom controls    {    Rect  zoomArea = infoArea;    zoomArea.left = zoomArea.right - kZoomControlsWidth - kToolControlWidth;    zoomArea.right = zoomArea.left + 32;    zoomArea.bottom = zoomArea.top + 32;        PlotIconID(&amp;zoomArea, ttNone, ttNone, kZoomControlPlain);    }          // draw the left/right/page arrows  if (((GXDataPtr)pData)-&gt;numberOfPages &gt; 1)    {    Rect  arrowsRect;        // erase any old arrow bits, including around the edges of the icon    // needed when the window resizes    arrowsRect = infoArea;    arrowsRect.bottom = arrowsRect.top + 32;    arrowsRect.right = arrowsRect.left + 34;    EraseRect(&amp;arrowsRect);        // then draw the new arrows    arrowsRect.left = infoArea.left + 2;    arrowsRect.top = infoArea.top + 2;    arrowsRect.right = arrowsRect.left + kPageControlsWidth;    arrowsRect.bottom = arrowsRect.top + 32;    PlotIconID(&amp;arrowsRect, ttNone, ttNone, kPageControlPlain);    }    // frame the area  MoveTo(infoArea.left, infoArea.top);  LineTo(infoArea.right, infoArea.top);  // restore old clip value  SetClip(oldClip);  DisposeRgn(oldClip);  }  // then draw the page shape and things around it  {  gxRectangle      pageSize, paperSize;    gxShape        tempShape, pageShape;  gxMapping      thisMapping;  // clip to the content area  paperSize.left     = ff(pData-&gt;contentRect.left);  paperSize.top     = ff(pData-&gt;contentRect.top);  paperSize.right   = ff(pData-&gt;contentRect.right);  paperSize.bottom   = ff(pData-&gt;contentRect.bottom);  tempShape = GXNewRectangle(&amp;paperSize);  GXSetViewPortClip(((GXDataPtr)pData)-&gt;childViewPort, tempShape);  GXDisposeShape(tempShape);    // get the paper sizes, account for zoom factor  GetCurrentPageAndPaper(pData, &amp;pageSize, &amp;paperSize);  pageSize.left     = FixedMultiply(pageSize.left, ((GXDataPtr)pData)-&gt;zoomFactor);  pageSize.right     = FixedMultiply(pageSize.right, ((GXDataPtr)pData)-&gt;zoomFactor);  pageSize.top     = FixedMultiply(pageSize.top, ((GXDataPtr)pData)-&gt;zoomFactor);  pageSize.bottom   = FixedMultiply(pageSize.bottom, ((GXDataPtr)pData)-&gt;zoomFactor);  paperSize.left     = FixedMultiply(paperSize.left, ((GXDataPtr)pData)-&gt;zoomFactor);  paperSize.right   = FixedMultiply(paperSize.right, ((GXDataPtr)pData)-&gt;zoomFactor);  paperSize.top     = FixedMultiply(paperSize.top, ((GXDataPtr)pData)-&gt;zoomFactor);  paperSize.bottom   = FixedMultiply(paperSize.bottom, ((GXDataPtr)pData)-&gt;zoomFactor);    // offset by the scrolling amount    ResetMapping(&amp;thisMapping);  MoveMapping(&amp;thisMapping, Long2Fix(-GetControlValue(pData-&gt;hScroll)) - paperSize.left ,        Long2Fix(-GetControlValue(pData-&gt;vScroll)) - paperSize.top );  // make the paper shape  tempShape = GXNewShape(gxFullType);  GXSetTransformViewPorts(GXGetShapeTransform(tempShape), 1, &amp; ((GXDataPtr)pData)-&gt;childViewPort);  GXSetShapeFill(tempShape, gxEvenOddFill);  GXSetShapeMapping(tempShape, &amp;thisMapping);    // make the page shape  pageShape = GXNewRectangle(&amp;pageSize);  GXSetTransformViewPorts(GXGetShapeTransform(pageShape), 1, &amp; ((GXDataPtr)pData)-&gt;childViewPort);  GXSetShapeFill(pageShape, gxEvenOddFill);  GXSetShapeMapping(pageShape, &amp;thisMapping);    // remove the page shape from the paper shape  GXDifferenceShape(tempShape, pageShape);  // draw the paper shape, dispose of it  SetShapeGreyColorLevel(tempShape, 0xD000);  /* Set up light gray background */  GXDrawShape(tempShape);  GXDisposeShape(tempShape);    // draw white on the page shape  SetShapeGreyColorLevel(pageShape, 0xFFFF);  /* Set up white page */  GXSetShapeFill(pageShape, gxEvenOddFill);  GXDrawShape(pageShape);    // frame the page shape  SetShapeGreyColorLevel(pageShape, 0x8000);  /* Set up medium gray frame */  GXSetShapeFill(pageShape, gxClosedFrameFill);  GXDrawShape(pageShape);    // draw the scroll bars and grow box now to give a nice appearence  DrawControls(pWindow);  DrawGrowIcon(pWindow);  // draw the page data itself, clipped to the page  {  gxMapping  oldMapping, flipMapping;    // get the page shape's old mapping, and make a copy to work with  GXGetShapeMapping(((GXDataPtr)pData)-&gt;currentPageShape, &amp;oldMapping);  // run the clip through the inverse of the shape mapping to scale it properly  GXInsetShape(pageShape, ff(1));  ScaleMapping(&amp;oldMapping, ((GXDataPtr)pData)-&gt;zoomFactor, ((GXDataPtr)pData)-&gt;zoomFactor, 0, 0);  InvertMapping(&amp;flipMapping, &amp;oldMapping);  GXMapShape(pageShape, &amp;flipMapping);  GXSetShapeFill(pageShape, gxEvenOddFill);  GXSetShapeClip( ((GXDataPtr)pData)-&gt;currentPageShape, pageShape);    // move the shape into position by offseting the viewPort  GXGetViewPortMapping(((GXDataPtr)pData)-&gt;childViewPort, &amp;thisMapping);    GXGetViewPortMapping(((GXDataPtr)pData)-&gt;childViewPort, &amp;oldMapping);    ScaleMapping(&amp;thisMapping, ((GXDataPtr)pData)-&gt;zoomFactor, ((GXDataPtr)pData)-&gt;zoomFactor, 0, 0);  MoveMapping(&amp;thisMapping, Long2Fix(-GetControlValue(pData-&gt;hScroll)) - paperSize.left ,        Long2Fix(-GetControlValue(pData-&gt;vScroll)) - paperSize.top );  GXSetViewPortMapping(((GXDataPtr)pData)-&gt;childViewPort, &amp;thisMapping);    /*   *  Bracket the call to DrawShape with UseResFile, so that we put the   *  document's resfile on top, allowing the translator (for QDShapes)   *  to see our embedded fonts (if any) first.   */  {  short oldResFile = CurResFile();      UseResFile(((GXDataPtr)pData)-&gt;printFileRefNum);    GXDrawShape( ((GXDataPtr)pData)-&gt;currentPageShape);    UseResFile(oldResFile);  }    // Draw the selection, if any  {  gxShape  selectionShape =  ((GXDataPtr)pData)-&gt;currentSelectionShape;  gxShape  highlight;    if (selectionShape)    {        // better be a layout shape to get hilights    GXSetShapeType(selectionShape, gxLayoutType);        // get the highlight    highlight = GetCurrentSelectionHighlight(pData, true);    GXDrawShape(highlight);    GXDisposeShape(highlight);                }  }  // Draw the overlay, if any  {  gxShape  annotationShape =  (*((GXDataPtr)pData)-&gt;pageAnnotations)[((GXDataPtr)pData)-&gt;currentPage-1];    if (annotationShape)    {    GXSetShapeViewPorts(annotationShape, 1, &amp;((GXDataPtr)pData)-&gt;childViewPort);    GXDrawShape(annotationShape);    }    }  // restore viewPort's mapping (so we don't use it again next time)  GXSetViewPortMapping(((GXDataPtr)pData)-&gt;childViewPort, &amp;oldMapping);      }    // done with the page shape  GXDisposeShape(pageShape);  DrawSelection(pData, &amp;((GXDataPtr)pData)-&gt;selectionRectangle, &amp;((GXDataPtr)pData)-&gt;patternPhase, false);  GXGetGraphicsError(&amp;anErr);  }    return(anErr);  } // GXUpdateWindow// --------------------------------------------------------------------------------------------------------------static OSErr  GXContentClick(WindowRef pWindow, WindowDataPtr pData, EventRecord *pEvent){  OSErr      anErr = noErr;  Point      clickPoint = pEvent-&gt;where;  Rect      infoArea, labelArea, toolArea;  Rect      zoomOutRect, zoomInRect, zoomsRect;  RgnHandle    oldClip = NewRgn();  Boolean      somethingHit = false;    // convert to local space, calculate clickable areas    GlobalToLocal(&amp;clickPoint);  infoArea.left = 0;  infoArea.right = pData-&gt;hScrollOffset-1;  infoArea.bottom = GetWindowPort(pWindow)-&gt;portRect.bottom;  infoArea.top = infoArea.bottom - kScrollBarSize;  // clip to the info area  GetClip(oldClip);  ClipRect(&amp;infoArea);  // label area  labelArea = infoArea;  labelArea.right -= kZoomControlsWidth + kToolControlWidth;  if (((GXDataPtr)pData)-&gt;numberOfPages &gt; 1)    labelArea.left += kPageControlsWidth;      // the tool pop up  toolArea = infoArea;  toolArea.left = toolArea.right - kToolControlWidth;    // calculate the zoom in/out rects  zoomInRect = infoArea;  zoomInRect.right -= kToolControlWidth;  zoomInRect.left = zoomInRect.right - 13;  zoomOutRect = zoomInRect;  OffsetRect(&amp;zoomOutRect, -13, 0);  zoomsRect = zoomOutRect;  zoomsRect.bottom = zoomsRect.top + 32;  zoomsRect.right = zoomsRect.left + 32;  // deal with zoom in/out clicks  if (TrackIn(&amp;zoomInRect, clickPoint, &amp;zoomsRect, kZoomControlRight, kZoomControlPlain))    {    somethingHit = true;    SetZoom(pWindow, pData, FixedMultiply(((GXDataPtr)pData)-&gt;zoomFactor, ff(2)) );    PlotIconID(&amp;zoomsRect, ttNone, ttNone, kZoomControlPlain);    }  if (TrackIn(&amp;zoomOutRect, clickPoint, &amp;zoomsRect, kZoomControlLeft, kZoomControlPlain))    {    somethingHit = true;    SetZoom(pWindow, pData, FixedDivide(((GXDataPtr)pData)-&gt;zoomFactor, ff(2)) );    PlotIconID(&amp;zoomsRect, ttNone, ttNone, kZoomControlPlain);    }  // deal with the options pop up  if (PtInRect(clickPoint, &amp;labelArea))    {    MenuHandle  popupMenu = GetMenu(kGXPopUpMenu);    short    selectedItem;    TextState  textState;    Point    popPoint;    char    bulletString[3];        // figure out where to display the pop up    popPoint.v = labelArea.top;    popPoint.h = labelArea.left;    LocalToGlobal(&amp;popPoint);    somethingHit = true;    GetIntlTokenChar(tokenCenterDot, FontToScript(applFont), bulletString);        // set up menu to be small sized    TextFont(applFont);    TextSize(9);    DoUseWFont(&amp;textState, pWindow, true);        // set up the menu for selected items    SetItemMark(popupMenu, iDontShowMargins, (((GXDataPtr)pData)-&gt;dontShowMargins) ? bulletString[1] : noMark);    {    ZoomTableEntry *pEntry = &amp;gZoomTable[0];        while (pEntry-&gt;menuItem != 0)      {      SetItemMark(popupMenu, pEntry-&gt;menuItem, (((GXDataPtr)pData)-&gt;zoomFactor == pEntry-&gt;zoomFactor) ? bulletString[1] : noMark);      pEntry++;      }    }        // conduct the menu    InsertMenu(popupMenu, -1);    selectedItem = PopUpMenuSelect(popupMenu, popPoint.v, popPoint.h, CountMItems(popupMenu)+1) &amp; 0xFFFF;    // restore menu sizes    DoUseWFont(&amp;textState, nil, false);    DeleteMenu(kGXPopUpMenu);        switch (selectedItem)      {              // toggle show/hide margins      case iDontShowMargins:        // flip the boolean        ((GXDataPtr)pData)-&gt;dontShowMargins = 1 - ((GXDataPtr)pData)-&gt;dontShowMargins;                // force update and recalc the size of window        InvalRect(&amp;GetWindowPort(pWindow)-&gt;portRect);        AdjustScrollBars(pWindow, true, true, nil);        break;      // scale graphics to fit the window      case iScaleToFit:        {        gxRectangle    pageSize, paperSize;        Fixed      horizScale, vertScale;        GrafPtr      pPort = (GrafPtr)GetWindowPort(pWindow);                GetCurrentPageAndPaper(pData, &amp;pageSize, &amp;paperSize);                pageSize.left = pageSize.top = 0;        pageSize.right = ff(pPort-&gt;portRect.right - kScrollBarSize);        pageSize.bottom = ff(pPort-&gt;portRect.bottom - kScrollBarSize);                horizScale = FixedDivide(pageSize.right - pageSize.left, paperSize.right - paperSize.left);        vertScale = FixedDivide(pageSize.bottom - pageSize.top, paperSize.bottom - paperSize.top);        if (horizScale &gt; vertScale)          SetZoom(pWindow, pData, vertScale);        else          SetZoom(pWindow, pData, horizScale);        }        break;              // absolute set scale cases      default:        {        ZoomTableEntry *pEntry = &amp;gZoomTable[0];                while (pEntry-&gt;menuItem != 0)          {          if (selectedItem == pEntry-&gt;menuItem)            SetZoom(pWindow, pData, pEntry-&gt;zoomFactor);          pEntry++;          }        }        break;      }          }      // deal with the tool pop up  if (PtInRect(clickPoint, &amp;toolArea))    {    MenuHandle  popupMenu = GetMenu(kGXToolMenu);    short    selectedItem;    Point    popPoint;    short    i, numItems;        // figure out where to display the pop up    popPoint.v = toolArea.top;    popPoint.h = toolArea.left;    LocalToGlobal(&amp;popPoint);    // we've processed the mouse click    somethingHit = true;        // select our current item in the menu    numItems = CountMItems(popupMenu);    for (i = 1; i &lt;= numItems; ++i)      CheckItem(popupMenu, i, (i == ((GXDataPtr)pData)-&gt;contentClickMode) );        // conduct the menu    InsertMenu(popupMenu, -1);    selectedItem = PopUpMenuSelect(popupMenu, popPoint.v, popPoint.h, numItems+1) &amp; 0xFFFF;    DeleteMenu(kGXPopUpMenu);    // remember the item selected    if (selectedItem != 0)      ((GXDataPtr)pData)-&gt;contentClickMode = selectedItem;          // invalidation the tool picture    InvalRect(&amp;toolArea);        if (selectedItem != kSelectionTool)      {      // erase the old selection      DrawSelection(pData, &amp;((GXDataPtr)pData)-&gt;selectionRectangle, &amp;((GXDataPtr)pData)-&gt;patternPhase, false);        // clear the selection      ((GXDataPtr)pData)-&gt;selectionRectangle.top     = 0;      ((GXDataPtr)pData)-&gt;selectionRectangle.left    = 0;      ((GXDataPtr)pData)-&gt;selectionRectangle.bottom  = 0;      ((GXDataPtr)pData)-&gt;selectionRectangle.right  = 0;        // draw the new selection      DrawSelection(pData, &amp;((GXDataPtr)pData)-&gt;selectionRectangle, &amp;((GXDataPtr)pData)-&gt;patternPhase, true);      }    }      // deal with clicks in page controls  if (((GXDataPtr)pData)-&gt;numberOfPages &gt; 1)    {    Rect  leftArrowRect, rightArrowRect, arrowsRect;    Rect  gotoPageRect;        // calculate the minus one page arrow        leftArrowRect.top     = infoArea.top + 2;    leftArrowRect.bottom   = leftArrowRect.top + 32;    leftArrowRect.left     = infoArea.left + 2;    leftArrowRect.right   = leftArrowRect.left + 11;            // calculate the go to a particular page rect        gotoPageRect = leftArrowRect;    OffsetRect(&amp;gotoPageRect, 11, 0);    gotoPageRect.right --;    // calculate the plus one page arrow        rightArrowRect = gotoPageRect;    OffsetRect(&amp;rightArrowRect, 10, 0);        // calculate sum of all areas    arrowsRect = leftArrowRect;    arrowsRect.left   = infoArea.left + 2;    arrowsRect.right   = arrowsRect.left + kPageControlsWidth;              if (TrackIn(&amp;leftArrowRect, clickPoint, &amp;arrowsRect, kPageControlLeft, kPageControlPlain))      {      somethingHit = true;      if (((GXDataPtr)pData)-&gt;currentPage &gt; 1)         anErr = GXCommand(pWindow, pData, cPreviousPage, 0);      else        PlotIconID(&amp;arrowsRect, ttNone, ttNone, kPageControlPlain);      }    if (TrackIn(&amp;rightArrowRect, clickPoint, &amp;arrowsRect, kPageControlRight, kPageControlPlain))      {      somethingHit = true;      if (((GXDataPtr)pData)-&gt;currentPage &lt; ((GXDataPtr)pData)-&gt;numberOfPages)        anErr = GXCommand(pWindow, pData, cNextPage, 0);      else        PlotIconID(&amp;arrowsRect, ttNone, ttNone, kPageControlPlain);      }          if (PtInRect(clickPoint, &amp;gotoPageRect))      {      long  actualTicks;            somethingHit = true;      // pause, then check if the mouse is still down      Delay(20, &amp;actualTicks);            // if still down, track preview window      if (StillDown())        {        WindowRef  popWindow;        Rect    windowRect;        short    oldResFile = CurResFile();                // put the print file on top        UseResFile(((GXDataPtr)pData)-&gt;printFileRefNum);                // figure out where to place the pop up window, and then make it        windowRect.bottom   = arrowsRect.top - 2;        windowRect.left    = 2;        if (Count1Resources(kProxyType) &gt; 0)          windowRect.top = windowRect.bottom - kPopUpWindowHeightLarge;        else          windowRect.top = windowRect.bottom - kPopUpWindowHeightSmall;        windowRect.right   = windowRect.left + kScrollAreaWidth + kPageControlsWidth + kZoomControlsWidth + kToolControlWidth - 4;                  LocalToGlobal(&amp;TopLeft(windowRect));                LocalToGlobal(&amp;BotRight(windowRect));                        popWindow = (WindowRef) NewCWindow(nil, &amp;windowRect, &quot;\p&quot;, true, plainDBox, (WindowPtr)-1, false, 0);        if (popWindow)          {                long  oldValue = ((GXDataPtr)pData)-&gt;currentPage;          long  newValue = oldValue;          GrafPtr  popPort = (GrafPtr)GetWindowPort(popWindow);                    // draw initial location of the value          SetPort(popPort);          DrawPageSliderAndThumb(popWindow, oldValue, ((GXDataPtr)pData)-&gt;numberOfPages);                              // track the mouse, updating the value as we go          while (StillDown())            {            GetMouse(&amp;clickPoint);            if (PtInRect(clickPoint, &amp;popPort-&gt;portRect))              {              newValue =   clickPoint.h                      *                    ((GXDataPtr)pData)-&gt;numberOfPages                      /                    (popPort-&gt;portRect.right - popPort-&gt;portRect.left)                       + 1;                                  if (oldValue != newValue)                {                oldValue = newValue;                DrawPageSliderAndThumb(popWindow, oldValue, ((GXDataPtr)pData)-&gt;numberOfPages);                }              }            }                      // and done with the pop up window, return to main window          DisposeWindow(popWindow);          SetPort((GrafPtr)GetWindowPort(pWindow));                    // if we changed the value, make it so          if (newValue != ((GXDataPtr)pData)-&gt;currentPage)            {            ((GXDataPtr)pData)-&gt;currentPage = newValue;            anErr = GetCurrentPage((GXDataPtr) pData, true);            InvalRect(&amp;GetWindowPort(pWindow)-&gt;portRect);            }          }                  // restore resource chain        UseResFile(oldResFile);        }      else        {        // otherwise, do the goto dialog box        anErr = GXCommand(pWindow, pData, cGotoPage, 0);        }              } // if (click in goto page area)          } // if (&gt; 1 page)  // restore clip  SetClip(oldClip);  DisposeRgn(oldClip);    // nothing matched so far, deal with selecting the contents  if (!somethingHit)    {    Rect  selectionRect = ((GXDataPtr)pData)-&gt;selectionRectangle;            OffsetRect(&amp;selectionRect, -GetControlValue(pData-&gt;hScroll), -GetControlValue(pData-&gt;vScroll));    if ( (gMachineInfo.haveDragMgr) &amp;&amp; (PtInRect(clickPoint, &amp;selectionRect)) )      {      ((GXDataPtr)pData)-&gt;tempDragShape = nil;      DragAndDropArea(pWindow, pData, pEvent,                 &amp;selectionRect);                              if ( ((GXDataPtr)pData)-&gt;tempDragShape )        GXDisposeShape( ((GXDataPtr)pData)-&gt;tempDragShape );      }    else      {      LongRect    docRect;      Rect      contentRect;            contentRect = GetWindowPort(pWindow)-&gt;portRect;      contentRect.right -= kScrollBarSize;      contentRect.bottom -= kScrollBarSize;            if (PtInRect(clickPoint, &amp;contentRect))        {        switch (((GXDataPtr)pData)-&gt;contentClickMode)          {          case kSelectionTool:            GXGetDocumentRect(pWindow, pData, &amp;docRect, false);            contentRect.top   = docRect.top;            contentRect.left   = docRect.left;            contentRect.bottom   = docRect.bottom;            contentRect.right   = docRect.right;                        anErr = SelectContents(pWindow, pData, pEvent,                       &amp;((GXDataPtr)pData)-&gt;selectionRectangle, &amp;contentRect,                       &amp;((GXDataPtr)pData)-&gt;patternPhase);                    // existing text selection? clear the highlight            if (((GXDataPtr)pData)-&gt;currentSelectionShape)              {              InvalRect(&amp;GetWindowPort(pWindow)-&gt;portRect);                            ClearCurrentSelection((GXDataPtr)pData);              }            break;          case kRedMarkerTool:            DoDrawingClick(pWindow, pData, clickPoint, pEvent);            break;                      } // switch (mode)                  } // click in content rect      }    }      return(anErr);    } // GXContentClick// --------------------------------------------------------------------------------------------------------------static OSErr  GXAdjustMenus(WindowRef pWindow, WindowDataPtr pData){#pragma unused (pWindow)  OSErr anErr = noErr;    EnableCommand(cSaveAs);  if (((GXDataPtr)pData)-&gt;numberOfPages &gt; 1)    {    if (((GXDataPtr)pData)-&gt;currentPage &lt; ((GXDataPtr)pData)-&gt;numberOfPages)      EnableCommand(cNextPage);          if (((GXDataPtr)pData)-&gt;currentPage &gt; 1)      EnableCommand(cPreviousPage);        EnableCommand(cGotoPage);    }      if (!EmptyRect( &amp;((GXDataPtr)pData)-&gt;selectionRectangle) )    EnableCommand(cCopy);  {  LongRect    docRect;  Rect      shortDocRect;    // find out the size of the document        GXGetDocumentRect(pWindow, pData, &amp;docRect, false);  LongRectToRect(&amp;docRect, &amp;shortDocRect);  if   (EqualRect(&amp;shortDocRect, &amp;((GXDataPtr)pData)-&gt;selectionRectangle))    ChangeCommandName(cSelectAll, kMiscStrings, iSelectNoneCommand);  else    ChangeCommandName(cSelectAll, kMiscStrings, iSelectAllCommand);  }  EnableCommand(cSelectAll);    EnableCommand(cFind);  if (gFindString[0] != 0)    EnableCommand(cFindAgain);    return(anErr);  } // GXAdjustMenus// --------------------------------------------------------------------------------------------------------------OSErr  GXCommand(WindowRef pWindow, WindowDataPtr pData, short commandID, long menuResult){#pragma unused (menuResult)  OSErr  anErr = noErr;      switch (commandID)    {    case cSave:      GXSavePrintFile(((GXDataPtr)pData)-&gt;thePrintFile, nil);      anErr = GXGetJobError(pData-&gt;hPrint);      if (anErr == noErr)        anErr = LoadOrSaveAnnotations(pData, kSaveAnnotations);              // if everything went okay, then clear the changed bit      if (anErr == noErr)        pData-&gt;changed = false;      break;          case cSaveAs:      anErr = GXSaveAs(pWindow, pData);      if (anErr == noErr)        anErr = LoadOrSaveAnnotations(pData, kSaveAnnotations);      // if everything went okay, then clear the changed bit      if (anErr == noErr)        pData-&gt;changed = false;      break;          case cFind:      if (ConductFindOrReplaceDialog(kFindWindowID) == cancel)          break;            // start search at top of page      ((GXDataPtr)pData)-&gt;currentShapeIndex = 0;          // fall through from find    case cFindAgain:      {      Boolean  isBackwards = ((gEvent.modifiers &amp; shiftKey) != 0);            SetWatchCursor();      if (!PerformNextFind(pWindow, pData, gFindString, gCaseSensitive, isBackwards, gWrapAround))        SysBeep(1);      else        ScrollFoundShapeIntoView(pWindow, pData);              SetCursor(&amp;qd.arrow);      }      break;    case cCopy:      {      gxShape      cullShape = GetSelectedShape(pData);      if (cullShape)        {        // done with the shape now        ShapeToScrap(cullShape);        GXDisposeShape(cullShape);        }      }      break;        case cSelectAll:      {      LongRect    docRect;      Rect      shortDocRect;            // find out the size of the document            GXGetDocumentRect(pWindow, pData, &amp;docRect, false);      // erase the old selection      DrawSelection(pData, &amp;((GXDataPtr)pData)-&gt;selectionRectangle, &amp;((GXDataPtr)pData)-&gt;patternPhase, false);            LongRectToRect(&amp;docRect, &amp;shortDocRect);      if   (EqualRect(&amp;shortDocRect, &amp;((GXDataPtr)pData)-&gt;selectionRectangle))        {        ((GXDataPtr)pData)-&gt;selectionRectangle.top     = 0;        ((GXDataPtr)pData)-&gt;selectionRectangle.left    = 0;        ((GXDataPtr)pData)-&gt;selectionRectangle.bottom  = 0;        ((GXDataPtr)pData)-&gt;selectionRectangle.right  = 0;        }      else        {        ((GXDataPtr)pData)-&gt;selectionRectangle.top     = docRect.top;        ((GXDataPtr)pData)-&gt;selectionRectangle.left    = docRect.left;        ((GXDataPtr)pData)-&gt;selectionRectangle.bottom  = docRect.bottom;        ((GXDataPtr)pData)-&gt;selectionRectangle.right  = docRect.right;        }      // draw the new selection      DrawSelection(pData, &amp;((GXDataPtr)pData)-&gt;selectionRectangle, &amp;((GXDataPtr)pData)-&gt;patternPhase, true);      }      break;    case cPageSetup:      DoPageSetup(pWindow);      anErr = GetCurrentPage((GXDataPtr) pData, false);      InvalRect(&amp;GetWindowPort(pWindow)-&gt;portRect);      anErr = eActionAlreadyHandled;      break;          case cNextPage:      ((GXDataPtr)pData)-&gt;currentPage++;      anErr = GetCurrentPage((GXDataPtr) pData, true);      InvalRect(&amp;GetWindowPort(pWindow)-&gt;portRect);      if (anErr == noErr)        anErr = eActionAlreadyHandled;      break;        case cPreviousPage:      ((GXDataPtr)pData)-&gt;currentPage--;      anErr = GetCurrentPage((GXDataPtr) pData, true);      InvalRect(&amp;GetWindowPort(pWindow)-&gt;portRect);      if (anErr == noErr)        anErr = eActionAlreadyHandled;      break;        case cGotoPage:      switch (menuResult)        {        case cGotoFirst:          ((GXDataPtr)pData)-&gt;currentPage = 1;          anErr = GetCurrentPage((GXDataPtr) pData, true);          InvalRect(&amp;GetWindowPort(pWindow)-&gt;portRect);          break;        case cGotoLast:          ((GXDataPtr)pData)-&gt;currentPage = ((GXDataPtr)pData)-&gt;numberOfPages;          anErr = GetCurrentPage((GXDataPtr) pData, true);          InvalRect(&amp;GetWindowPort(pWindow)-&gt;portRect);          break;                  default:          {          DialogRef  dPtr;          short    hit;                    dPtr = GetNewDialog(kGotoPageDialogID, nil, (WindowRef)-1);          if (dPtr)            {            short  theType;            Handle  theHandle;            Rect  theRect;            Str255  theString;                        GetDialogItem(dPtr, 4, &amp;theType, &amp;theHandle, &amp;theRect);            NumToString(((GXDataPtr)pData)-&gt;currentPage, theString);            SetDialogItemText(theHandle, theString);            SelectDialogItemText(dPtr, 4, 0, 32767);            NumToString(((GXDataPtr)pData)-&gt;numberOfPages, theString);            ParamText(theString, &quot;\p&quot;, &quot;\p&quot;, &quot;\p&quot;);                        SetDialogDefaultItem(dPtr, ok);            SetDialogCancelItem(dPtr, cancel);            BeginMovableModal();                        do              {              MovableModalDialog(nil, &amp;hit);                            if (hit == ok)                {                long  tempLong;                                // convert to a page number, find and report errors                GetDialogItemText(theHandle, theString);                StringToNum(theString, &amp;tempLong);                if (tempLong &lt; 1)                   {                  SysBeep(1);                  tempLong = 1;                  hit = 0;                  }                if (tempLong &gt; ((GXDataPtr)pData)-&gt;numberOfPages)                  {                  tempLong = ((GXDataPtr)pData)-&gt;numberOfPages;                  hit = 0;                  }                                  // if we have an error, we try again, otherwise we go to the page                if (hit == 0)                  {                  SysBeep(1);                  NumToString(tempLong, theString);                  SetDialogItemText(theHandle, theString);                  SelectDialogItemText(dPtr, 4, 0, 32767);                  }                else                  {                  ((GXDataPtr)pData)-&gt;currentPage = tempLong;                  anErr = GetCurrentPage((GXDataPtr) pData, true);                  InvalRect(&amp;GetWindowPort(pWindow)-&gt;portRect);                  }                }              } while ((hit != ok) &amp;&amp; (hit != cancel));                          DisposeDialog(dPtr);            EndMovableModal();            }                      }          break;                  }      if (anErr == noErr)        anErr = eActionAlreadyHandled;      break;        }    return(anErr);  } // GXCommand// --------------------------------------------------------------------------------------------------------------static OSErr  GXFilePrintPage(WindowRef pWindow, WindowDataPtr pData,          Rect * pageRect, long *pageNum){#pragma unused (pWindow, pageRect)  OSErr    anErr = noErr;  gxShape   thisShape;  gxFormat   thisFormat;    GXReadPrintFilePage(((GXDataPtr)pData)-&gt;thePrintFile, *pageNum, 0, nil, &amp;thisFormat, &amp;thisShape);  anErr = GXGetJobError(pData-&gt;hPrint);  nrequire(anErr, ReadPrintFilePage);  GXPrintPage(pData-&gt;hPrint, *pageNum, thisFormat, thisShape);  anErr = GXGetJobError(pData-&gt;hPrint);  nrequire(anErr, PrintPage);  GXDisposeFormat(thisFormat);  GXDisposeShape(thisShape);// FALL THROUGH EXCEPTION HANDLINGPrintPage:ReadPrintFilePage:  // tell it to stop printing when we reach the end  if (*pageNum &gt;= ((GXDataPtr)pData)-&gt;numberOfPages)    *pageNum = -1;    return(anErr);  } // GXFilePrintPage// --------------------------------------------------------------------------------------------------------------OSErr  GXGetDocumentRect(WindowRef pWindow, WindowDataPtr pData,       LongRect * documentRectangle, Boolean forGrow){#pragma unused (pWindow, forGrow)  gxRectangle    pageSize, paperSize;    GetCurrentPageAndPaper(pData, &amp;pageSize, &amp;paperSize);  documentRectangle-&gt;left = 0;  documentRectangle-&gt;top = 0;  documentRectangle-&gt;bottom = FixedMultiply(paperSize.bottom - paperSize.top, ((GXDataPtr)pData)-&gt;zoomFactor) &gt;&gt; 16;  documentRectangle-&gt;right = FixedMultiply(paperSize.right - paperSize.left, ((GXDataPtr)pData)-&gt;zoomFactor) &gt;&gt; 16;      return(noErr);  } // GXGetDocumentRect// --------------------------------------------------------------------------------------------------------------static long GXCalculateIdleTime(WindowRef pWindow, WindowDataPtr pData){#pragma unused (pWindow)  if (!EmptyRect( &amp;((GXDataPtr)pData)-&gt;selectionRectangle))    return(0);  else    return(kMaxWaitTime);    } // GXCalculateIdleTime// --------------------------------------------------------------------------------------------------------------static Boolean  GXFilterEvent(WindowRef pWindow, WindowDataPtr pData, EventRecord *pEvent){  if   (    (!gMachineInfo.amInBackground) &amp;&amp;    (pEvent-&gt;what == nullEvent) &amp;&amp;    (pWindow == FrontWindow()) &amp;&amp;    (EmptyRgn( ((WindowPeek)pWindow)-&gt;updateRgn)) &amp;&amp;    (MOVESELECTION(pEvent-&gt;when) )    )    {    // erase the old    DrawSelection(pData, &amp;((GXDataPtr)pData)-&gt;selectionRectangle, &amp;((GXDataPtr)pData)-&gt;patternPhase, false);        // draw the new, moving onto the next pattern    DrawSelection(pData, &amp;((GXDataPtr)pData)-&gt;selectionRectangle, &amp;((GXDataPtr)pData)-&gt;patternPhase, true);    }      return(false);  } // GXFilterEvent// --------------------------------------------------------------------------------------------------------------static OSErr  GXDragAddFlavors(WindowRef pWindow, WindowDataPtr pData, DragReference theDragRef){#pragma unused (pWindow)  OSErr  anErr = noErr;    SetDragSendProc(theDragRef, gGXSendDataProc, nil);  AddDragItemFlavor(theDragRef, (unsigned long)pData, 'qdgx', nil, 0, 0);  AddDragItemFlavor(theDragRef, (unsigned long)pData, 'PICT', nil, 0, 0);    return(anErr);  } // GXDragAddFlavors// --------------------------------------------------------------------------------------------------------------static OSErr  GXAdjustCursor(WindowRef pWindow, WindowDataPtr pData, Point * localMouse, Rect * globalRect){#pragma unused (pWindow, globalRect)  OSErr      anErr = noErr;  Handle    theCursor;  Rect      selectionRect = ((GXDataPtr)pData)-&gt;selectionRectangle;    OffsetRect(&amp;selectionRect, -GetControlValue(pData-&gt;hScroll), -GetControlValue(pData-&gt;vScroll));  if (!PtInRect(*localMouse, &amp;selectionRect) )    {    short  cursorID;    Boolean  colorCursor;        cursorID = ((GXDataPtr)pData)-&gt;contentClickMode;    if (cursorID == kSelectionTool)      {      colorCursor = false;      cursorID = crossCursor;      }    else      {      colorCursor = true;      cursorID += kIconBase;      }          if (colorCursor)      theCursor = (Handle)GetCCursor(cursorID);    else      theCursor = (Handle)GetCursor(cursorID);    if (theCursor)      {      if (colorCursor)        {        SetCCursor((CCrsrHandle)theCursor);        DisposeCCursor((CCrsrHandle)theCursor);        }      else        {        char  oldState;                oldState = HGetState(theCursor);        HLock((Handle) theCursor);        SetCursor(*(CursHandle)theCursor);        HSetState(theCursor, oldState);        }      anErr = eActionAlreadyHandled;      }    }  return(anErr);  } // GXAdjustCursor// --------------------------------------------------------------------------------------------------------------static OSErr  GXMakeWindow(WindowRef pWindow, WindowDataPtr pData){  OSErr        anErr = noErr;    pData-&gt;pCloseWindow     = (CloseWindowProc)      GXCloseWindow;  pData-&gt;pAdjustMenus     = (AdjustMenusProc)      GXAdjustMenus;  pData-&gt;pCommand        = (CommandProc)        GXCommand;  pData-&gt;pUpdateWindow     = (UpdateWindowProc)    GXUpdateWindow;  pData-&gt;pContentClick     = (ContentClickProc)    GXContentClick;  pData-&gt;pGetDocumentRect   = (GetDocumentRectProc)    GXGetDocumentRect;  pData-&gt;pPrintPage       = (PrintPageProc)      GXFilePrintPage;  pData-&gt;pFilterEvent       = (FilterEventProc)      GXFilterEvent;  pData-&gt;pCalculateIdleTime  = (CalculateIdleTimeProc)  GXCalculateIdleTime;  pData-&gt;pAdjustCursor    = (AdjustCursorProc)    GXAdjustCursor;  pData-&gt;pDragAddFlavors    = (DragAddFlavorsProc)    GXDragAddFlavors;    pData-&gt;documentOutputsGX  = true;  pData-&gt;hasGrow        = true;  pData-&gt;minHSize        = kMinGXDocSize + kScrollAreaWidth + kZoomControlsWidth + kToolControlWidth;  pData-&gt;hScrollAmount    = 10;  pData-&gt;vScrollAmount    = 10;  pData-&gt;hScrollOffset    = kScrollAreaWidth + kZoomControlsWidth + kToolControlWidth;    // default the job info, which we need to have  anErr = DoDefault(pData);  nrequire(anErr, DoDefault);  ((GXDataPtr)pData)-&gt;thePrintFile = GXOpenPrintFile(pData-&gt;hPrint, &amp;pData-&gt;fileSpec, fsRdWrPerm);  anErr = GXGetJobError(pData-&gt;hPrint);  nrequire(anErr, OpenPrintFile);  /*   *  The assumption here is that the GXOpenPrintFile leaves the resfile on top.   *  We need this refnum so that any resource handles the translator gets will   *  match those that GXOpenPrintFile used for calls to GXNewFont.  See the call   *  to GXDrawShape in GXUpdateWindow   */  ((GXDataPtr)pData)-&gt;printFileRefNum = CurResFile();  // close down other paths to the file -- because we don't need them  if (pData-&gt;resRefNum != -1)    {    CloseResFile(pData-&gt;resRefNum);    pData-&gt;resRefNum = -1;    }  if (pData-&gt;dataRefNum != -1)    {    FSClose(pData-&gt;dataRefNum);    pData-&gt;dataRefNum = -1;    }      // default to normal printing -- so if the user prints, we go to normal mode at first  {  Collection  jobCollection = GXGetJobCollection(pData-&gt;hPrint);  gxJobInfo  theInfo;  long    theSize = sizeof(theInfo);    if (GetCollectionItem(jobCollection, gxJobTag, gxPrintingTagID, &amp;theSize, &amp;theInfo) == noErr)    {    theInfo.priority = gxPrintJobASAP;    AddCollectionItem(jobCollection, gxJobTag, gxPrintingTagID, theSize, &amp;theInfo);    }    }    // by default we have no pages  ((GXDataPtr)pData)-&gt;numberOfPages    = GXCountPrintFilePages(((GXDataPtr)pData)-&gt;thePrintFile);  ((GXDataPtr)pData)-&gt;currentPage      = 1;  ((GXDataPtr)pData)-&gt;zoomFactor      = ff(1);  ((GXDataPtr)pData)-&gt;contentClickMode  = kSelectionTool;  anErr = GXGetJobError(pData-&gt;hPrint);  if ( (anErr == noErr) &amp;&amp; (((GXDataPtr)pData)-&gt;numberOfPages == 0) )    anErr = eDocumentContainsNoPages;  nrequire(anErr, GXCountPrintFilePages);    if (((GXDataPtr)pData)-&gt;numberOfPages &gt; 1)    pData-&gt;hScrollOffset += kPageControlsWidth;      ((GXDataPtr)pData)-&gt;pageAnnotations = (gxShape**) NewHandleClear( (((GXDataPtr)pData)-&gt;numberOfPages * sizeof(gxShape)) );  anErr = MemError();  if (anErr == noErr)    anErr = LoadOrSaveAnnotations(pData, kLoadAnnotations);  nrequire(anErr, FailedToAllocateAnnotation);    // set up so we can draw inside of this window  ((GXDataPtr)pData)-&gt;parentViewPort = GXNewWindowViewPort((WindowPtr)pWindow);  ((GXDataPtr)pData)-&gt;childViewPort = GXNewViewPort(gxScreenViewDevices);  GXSetViewPortParent(((GXDataPtr)pData)-&gt;childViewPort, ((GXDataPtr)pData)-&gt;parentViewPort);  GXSetViewPortAttributes(((GXDataPtr)pData)-&gt;childViewPort, gxAlwaysGridPort);  GXSetViewPortDither(((GXDataPtr)pData)-&gt;childViewPort, 4);    // fetch the current page  anErr = GetCurrentPage((GXDataPtr) pData, true);  nrequire(anErr, GetCurrentPage);    // if this document contains PostScript do a warning  {  gxTranslatedDocumentInfo theInfo;  long theSize = sizeof(theInfo);    if   (    (GetCollectionItem(GXGetJobCollection(pData-&gt;hPrint),              gxTranslatedDocumentTag,              gxPrintingTagID,              &amp;theSize,              &amp;theInfo              ) == noErr) &amp;&amp;    (theInfo.translatorInfo &amp; gxContainsPostScript)    )    ConductErrorDialog(eDocumentContainsPS, cOpen, ok);  }    return(anErr);  // EXCEPTION HANDLINGGetCurrentPage:FailedToAllocateAnnotation:GXCountPrintFilePages:  GXClosePrintFile( ((GXDataPtr)pData)-&gt;thePrintFile);  OpenPrintFile:  GXDisposeJob(pData-&gt;hPrint);    DoDefault:  return(anErr);  } // GXMakeWindow// --------------------------------------------------------------------------------------------------------------OSErr  GXPreflightWindow(PreflightPtr pPreflightData){    pPreflightData-&gt;continueWithOpen   = true;  pPreflightData-&gt;wantVScroll      = true;  pPreflightData-&gt;wantHScroll      = true;  pPreflightData-&gt;doZoom        = true;  pPreflightData-&gt;makeProcPtr     = GXMakeWindow;  pPreflightData-&gt;storageSize     = sizeof(GXDataRecord);    return(noErr);  } // GXPreflightWindow// --------------------------------------------------------------------------------------------------------------void GXGetFileTypes(OSType * pFileTypes, OSType * pDocumentTypes, short * numTypes){  if (gMachineInfo.haveGX)    {    pFileTypes[*numTypes]     = 'sjob';    pDocumentTypes[*numTypes]   = kGXWindow;    (*numTypes)++;    pFileTypes[*numTypes]     = 'tjob';    pDocumentTypes[*numTypes]   = kGXWindow;    (*numTypes)++;    pFileTypes[*numTypes]     = 'rjob';    pDocumentTypes[*numTypes]   = kGXWindow;    (*numTypes)++;    pFileTypes[*numTypes]     = 'qjob';    pDocumentTypes[*numTypes]   = kGXWindow;    (*numTypes)++;    }    } // GXGetFileTypes</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/SimpleText_Sample/listing8.html%3Fid%3DDTS10000736-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/SimpleText_Sample/listing8.html%3Fid%3DDTS10000736-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/SimpleText_Sample/listing8.html%3Fid%3DDTS10000736-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>