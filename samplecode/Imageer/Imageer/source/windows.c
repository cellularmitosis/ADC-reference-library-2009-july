/****************************************************//*													*//*	File:		windows.c							*//*													*//*	Program:	Imageer								*//*													*//*	By:			Jason Hodges-Harris					*//*													*//*	Created:	26/10/95  00:00:00 AM				*//*													*//*	Version:	1.0.0d3								*//*													*//*	Copyright:	© 1995-96 Apple Computer, Inc.,		*/ /*					all rights reserved.			*/		/*													*//****************************************************//**** Macintosh Toolbox Headers *****/#ifndef __CONTROLS__#include <Controls.h>#endif#ifndef __DEVICES__#include <Devices.h>#endif#ifndef __DIALOGS__#include <Dialogs.h>#endif#ifndef __GXENVIRONMENT__#include <GXEnvironment.h>#endif#ifndef __GXGRAPHICS__#include <GXGraphics.h>#endif#ifndef __LOWMEM__#include<LowMem.h>#endif#ifndef __PALETTES__#include <Palettes.h>#endif#ifndef __QDOFFSCREEN__#include <QDOffscreen.h>#endif#ifndef __TEXTUTILS__#include <TextUtils.h>#endif#ifndef __TOOLUTILS__#include <ToolUtils.h>#endif#ifndef __WINDOWS__#include <Windows.h>#endif/****   Application headers and prototypes   ****/#ifndef __IMAGEERAPPHEADER__#include "Imageer.app.h"#endif#ifndef __IMAGEERPROTOSHEADER__#include "Imageer.protos.h"#endif/***** Global Variables *****/extern short			gNumOpenWindows;		//	number of open document windows /* The DisplayAlert() function is a generic modal dialog display function    which uses GetStdFilterProc() and SetDialogDefaultItem() to    automatically get the standard filter and outline the default DITL item.    These 'undocumented' functions are available in system 7.0 or later. */ #pragma segment windowslong	DisplayAlert(short dialogID,short errStrID,short StrIDindex){	GrafPtr			savePort = nil;	DialogPtr		myDialog = nil;	ModalFilterUPP	theFilter = nil;	Str255			theTextStr;	short			alertResponse;		myDialog = GetNewDialog(dialogID,nil,((WindowPtr)-1L));	// get dialog resource	GetPort(&savePort);	SetPort	(myDialog);	if (GetStdFilterProc(&theFilter) !=noErr)		DebugStr("\pFailed to get standard dialog filter.");	SetDialogDefaultItem(myDialog,1);	/* If the errStrID variable contains 0, the dialog doesn't	   require any text from a STR# resource */	if (errStrID!=0)		// get STR# resource text	{		GetIndString(theTextStr,errStrID,StrIDindex);		ParamText(theTextStr,(ConstStr255Param)kNull_Str,				  (ConstStr255Param)kNull_Str,(ConstStr255Param)kNull_Str);	}	do{		ModalDialog(theFilter,&alertResponse);	} while (alertResponse==0);	DisposeDialog(myDialog);//	dispose dialog mem allocation	SetPort(savePort);			return alertResponse;	// return dialog return value}// Drag the window from the position passed in the mouseLoc parameter #pragma segment windowsvoid DragSelWind(WindowPtr window,Point mouseLoc){	Rect	dragBounds;		dragBounds=(**GetGrayRgn()).rgnBBox;	DragWindow(window,mouseLoc,&dragBounds);}// Close the active window which had it's close box selected#pragma segment windowsvoid DoGoAwayWind(WindowPtr window,Point mouseLoc){	if(TrackGoAway(window,mouseLoc))	{		if (window!=nil)		{			// Test for a dialog window and hide if selected			if ((((WindowPeek)window)->windowKind)==2) 				HideWindow(window);			// Test for a Desk Accessory window and Close.			else if ((((WindowPeek)window)->windowKind)<0) 				CloseDeskAcc(((WindowPeek)window)->windowKind);			// Test for an application window.			else if ((((WindowPeek)window)->windowKind)==8)				{				// Handle application windows				DisposeImageWindow (window);			}		}	}}/**** create new image window	****/// Create a new window complete with scroll bar controls// position staggered at max possible size and resize to// be completely visible on the main screen.#pragma segment windowsOSErr	CreateImageWindow (ImageDocHndl theWindDocHndl){	ImageDocHndl	theWindowRefcon = nil;	PaletteHandle	theWPalette = nil;	CWindowPtr		theCWindow;	Point			theWindowOffset;	short			maxXsize,					maxYsize;	OSErr			error = noErr;						theCWindow = (CWindowPtr)GetNewCWindow(rGenWindow,nil,(WindowPtr)-1L);	SetWRefCon((WindowPtr)theCWindow,(long)theWindDocHndl);	// set window refcon to doc handle	SetWTitle((WindowPtr)theCWindow,(**theWindDocHndl).theImageFileReply.sfFile.name);	CalcMaxImageWindowSize(theWindDocHndl);	theWindowOffset	= CalcNextWindowPosition(theWindDocHndl);	SizeWindow((WindowPtr)theCWindow,		(**theWindDocHndl).theMaxWindowSize.right - (**theWindDocHndl).theMaxWindowSize.left,		(**theWindDocHndl).theMaxWindowSize.bottom - (**theWindDocHndl).theMaxWindowSize.top,false);	MoveWindow((WindowPtr)theCWindow,theWindowOffset.h,theWindowOffset.v,false);	(**theWindDocHndl).theVScrollBar = GetNewControl (rVScrollBar,(WindowPtr)theCWindow);	(**theWindDocHndl).theHScrollBar = GetNewControl (rHScrollBar,(WindowPtr)theCWindow);	(**theWindDocHndl).theColorsPalette = nil;	// not used by image window	(**theWindDocHndl).isColorsWindow = false;	if ((**theWindDocHndl).theVScrollBar == nil || (**theWindDocHndl).theHScrollBar == nil)	{		DisposeWindow((WindowPtr)theCWindow);		return kDefaultAppError;	}	MoveControl((**theWindDocHndl).theVScrollBar,				theCWindow->portRect.right - kScrollBarWidth,theCWindow->portRect.top - 1);	MoveControl((**theWindDocHndl).theHScrollBar,				theCWindow->portRect.left - 1,theCWindow->portRect.bottom - kScrollBarWidth);	SizeControl((**theWindDocHndl).theVScrollBar,16,				(theCWindow->portRect.bottom - theCWindow->portRect.top)-13);	SizeControl((**theWindDocHndl).theHScrollBar,				(theCWindow->portRect.right - theCWindow->portRect.left)-13,16);	theWPalette = 		NewPalette(256,(**(*(**theWindDocHndl).theImageWorld).portPixMap).pmTable,pmTolerant+pmExplicit,0);	NSetPalette((WindowPtr)theCWindow,theWPalette,pmAllUpdates);	ShowControl((**theWindDocHndl).theVScrollBar);	ShowControl((**theWindDocHndl).theHScrollBar);	SetControlMinimum((**theWindDocHndl).theVScrollBar,0);	SetControlMinimum((**theWindDocHndl).theHScrollBar,0);	maxXsize = (*theWindDocHndl)->theImageWorld->portRect.right - 				((theCWindow->portRect.right - kScrollBarWidth) - theCWindow->portRect.left);	maxYsize = (*theWindDocHndl)->theImageWorld->portRect.bottom - 				((theCWindow->portRect.bottom - kScrollBarWidth) - theCWindow->portRect.top);	SetControlMaximum((**theWindDocHndl).theVScrollBar,maxYsize);	SetControlMaximum((**theWindDocHndl).theHScrollBar,maxXsize);	SetControlValue((**theWindDocHndl).theVScrollBar,0);	SetControlValue((**theWindDocHndl).theHScrollBar,0);	ShowWindow((WindowPtr)theCWindow);	DrawGrowIcon((WindowPtr)theCWindow);	return error;}// Close an application window#pragma segment windowsvoid DisposeImageWindow (WindowPtr window){	ImageDocHndl		theDocRefCon;	MenuHandle			theMenu;	WindowPtr			theWindow;	Str255				theString;	short				count;		// check if the window to close is a valid Document window	if ((theDocRefCon=(ImageDocHndl)GetWRefCon(window)) != 0)	{		// dispose of the window document structure		if (!(**theDocRefCon).isColorsWindow)			DeleteDocNameFromMenu (theDocRefCon);		else		{			GetIndString (theString,rMenuItems,iShowColors);			SetMenuItemText (GetMHandle(mWindow),iColors,theString);			if ((**theDocRefCon).theColorsPalette)		// Direct color images have no palette				DisposePalette((**theDocRefCon).theColorsPalette);		}		if ((**theDocRefCon).theVScrollBar)		{			DisposeControl((**theDocRefCon).theVScrollBar);			DisposeControl((**theDocRefCon).theHScrollBar);		}		/****	Dispose QuickDraw specific document items	****/		if (!(**theDocRefCon).isUsingQDGX)		{			if ((**theDocRefCon).theImageWorld)				DisposeGWorld((**theDocRefCon).theImageWorld);			if ((**theDocRefCon).hasUndoTemp)				RemoveTempFile(theDocRefCon, true, false);			if ((**theDocRefCon).hasRedoTemp)				RemoveTempFile(theDocRefCon, false, true);		}					/****	Dispose of GX related objects	****/		if ((**theDocRefCon).isUsingQDGX)		{			GXDisposeShape((**theDocRefCon).theGXImageShape);			GXDisposeInk((**theDocRefCon).theInkShape);			GXDisposeViewPort((**theDocRefCon).theGxChildView);			GXDisposeViewPort((**theDocRefCon).theGXview);		}		DisposeHandle((Handle)theDocRefCon);		DisposeWindow(window);		theWindow = FrontWindow();		if (theWindow == nil || gNumOpenWindows == 0)		{			if (ColorWindowVisible())				DisposeColorsWindow();			theMenu = GetMHandle(mFile);			DisableItem(theMenu,iClose);			DisableItem(theMenu,iCloseAll);			DisableItem(theMenu,iSaveAs);			DisableItem(theMenu,iRevert);			DisableItem(GetMHandle(mWindow),iColors);			theMenu = GetMHandle(mFilters);			for (count = iSmoothFilter;count <= iHiPassFilter; ++count)				DisableItem(theMenu,count);			theMenu = GetMHandle(mEffects);			for (count = iInvert;count <= iRotate180; ++count)				DisableItem(theMenu,count);			/****	Reset undo menu item text	****/			SetUndoItemText(kCannotUndo);			ForceRestoreColors();		}		else		{			theDocRefCon=(ImageDocHndl)GetWRefCon(theWindow);			switch ((*theDocRefCon)->theUndoState)			{				case kCannotUndo:					SetUndoItemText(kCannotUndo);				break;				case kCanUndo:					SetUndoItemText(kCanUndo);				break;				case kCanRedo:					SetUndoItemText(kCanRedo);				break;			}		}	}}/*****	Perform update operation for image and colors windows for both imaging models	****/#pragma segment windowsvoid	DoWindowUpdate(WindowPtr theWindow){	PixMapHandle		thePixMapHndl = nil;	ImageDocHndl		theWindDocHndl;	WindowPtr			oldPort;		GetPort(&oldPort);	SetPort(theWindow);	BeginUpdate(theWindow);	theWindDocHndl = (ImageDocHndl)GetWRefCon(theWindow);	if (theWindDocHndl && (**theWindDocHndl).isColorsWindow == false && 						  (**theWindDocHndl).isUsingQDGX == false)	{		TransferImageToWindow(theWindDocHndl,theWindow);	// Color QD content region update		UpdateControls(theWindow,theWindow->visRgn);		DrawGrowIcon(theWindow);	}	else if (theWindDocHndl && 			(**theWindDocHndl).isColorsWindow == false && 			(**theWindDocHndl).isUsingQDGX)	{		UpdateGXObjectDisplay(theWindDocHndl, theWindow);		UpdateControls(theWindow,theWindow->visRgn);		DrawGrowIcon(theWindow);	}	else if ((**theWindDocHndl).isColorsWindow && 			 (**theWindDocHndl).isUsingQDGX == false)		DrawImageColors(theWindow);	EndUpdate(theWindow);	SetPort (oldPort);}/****	Create new Image Colors Window	****/#pragma segment windowsOSErr	CreateColorsWindow(void){	ImageDocHndl		theColorsDocHndl = nil,						theFoundDocHndl = nil;	CWindowPtr			theWindow;	WindowPtr			theFrontWindow;	Str255				theString;	OSErr				error = noErr;						theWindow = (CGrafPort*)GetNewCWindow(rColorsWindow,nil,(WindowPtr)-1L);	theColorsDocHndl = (ImageDocHndl)NewHandle(sizeof(ImageDoc));	// alloc new image document	if (theColorsDocHndl)	{		SetWRefCon((WindowPtr)theWindow,(long)theColorsDocHndl);	// set refcon to doc handle		(**theColorsDocHndl).theImageWorld = nil;		(**theColorsDocHndl).theVScrollBar = nil;		(**theColorsDocHndl).theHScrollBar = nil;		(**theColorsDocHndl).isColorsWindow = true;		(**theColorsDocHndl).theColorsPalette = nil;		// initialise to nil as direct images have no palette info		(**theColorsDocHndl).isUsingQDGX = false;		(**theColorsDocHndl).theUndoState = kCannotUndo;		(**theColorsDocHndl).hasUndoTemp = false;		(**theColorsDocHndl).hasRedoTemp = false;		theFrontWindow = FrontWindow();		theFoundDocHndl = (ImageDocHndl)GetWRefCon(theFrontWindow);		(**theColorsDocHndl).theImageDepth = (**theFoundDocHndl).theImageDepth;		SetWTitle((WindowPtr)theWindow,"\pImage Colors");		SizeWindow((WindowPtr)theWindow,128+32,32+32,false);		ShowWindow((WindowPtr)theWindow);		if ((**theFoundDocHndl).theImageDepth <= 8)	// create palette for indexed images		{			if (!(**theFoundDocHndl).isUsingQDGX)				(**theColorsDocHndl).theColorsPalette = 					NewPalette(256,							   (**(*(**theFoundDocHndl).theImageWorld).portPixMap).pmTable,							   pmTolerant+pmExplicit,0);			else				(**theColorsDocHndl).theColorsPalette = 					NewPalette((**theFoundDocHndl).theImageDepth,							   nil,pmTolerant+pmExplicit,0);			if ((**theColorsDocHndl).theColorsPalette)				 NSetPalette((WindowPtr)theWindow,(**theColorsDocHndl).theColorsPalette,pmAllUpdates);			else				return kFailMakePalette;		}		GetIndString (theString,rMenuItems,iHideColors);		SetMenuItemText (GetMHandle(mWindow),iColors,theString);		SetUndoItemText((*theColorsDocHndl)->theUndoState);	}	else		error = kDefaultAppError;	return error;}/****	Dispose of Current image Colors window	****/#pragma segment windowsOSErr	DisposeColorsWindow(void){	ImageDocHndl	theDocHndl = nil;	WindowPtr		theWindow,					theNextWindow;	OSErr			error = noErr;		theWindow = FrontWindow();	while (theWindow)	{		theDocHndl = (ImageDocHndl)GetWRefCon(theWindow);		if ((**theDocHndl).isColorsWindow)		{			DisposeImageWindow (theWindow);			return error;		}		theNextWindow = &((WindowPeek)theWindow)->nextWindow->port;		theWindow = theNextWindow;	}	return kDefaultAppError;}/****	determine maximum window size	****/#pragma segment windowsOSErr	CalcMaxImageWindowSize(ImageDocHndl theWindDocHndl){	GDHandle		theMainGDevHndl;	Rect			maxWindowSize,					theImageSize;	short			theMenuHeight;	OSErr			error = noErr;		SetRect(&theImageSize,0,0,(**theWindDocHndl).theImageXSize+kScrollBarWidth,							  (**theWindDocHndl).theImageYSize+kScrollBarWidth);	theMainGDevHndl = GetMainDevice();	maxWindowSize = (**theMainGDevHndl).gdRect;	theMenuHeight = GetMBarHeight();	maxWindowSize.bottom -=theMenuHeight+20;	maxWindowSize.right -= 20;	if (((**theWindDocHndl).theImageXSize+kScrollBarWidth) < (maxWindowSize.right - maxWindowSize.left) &&		((**theWindDocHndl).theImageYSize+kScrollBarWidth) < (maxWindowSize.bottom - maxWindowSize.top))	{		(**theWindDocHndl).theMaxWindowSize = theImageSize;			}	else	{		/**** Set max window size depth and width to not larger than main screen or image	****/		(**theWindDocHndl).theMaxWindowSize = maxWindowSize;		if (((**theWindDocHndl).theImageXSize+kScrollBarWidth) < (maxWindowSize.right - maxWindowSize.left))		{			(**theWindDocHndl).theMaxWindowSize.left = theImageSize.left;			(**theWindDocHndl).theMaxWindowSize.right = theImageSize.right;		}		if (((**theWindDocHndl).theImageYSize+kScrollBarWidth) < (maxWindowSize.bottom - maxWindowSize.top))		{			(**theWindDocHndl).theMaxWindowSize.top = theImageSize.top;			(**theWindDocHndl).theMaxWindowSize.bottom = theImageSize.bottom;		}	}	return error;}/****	position next open image window	staggered on main window to front most image window ****/#pragma segment windowsPoint	CalcNextWindowPosition(ImageDocHndl theDocHndl){	ImageDocHndl 	theWindDocHndl;	WindowPtr		theWindow,					theNextWindow,					oldPort;	Point			theWindowOffset;	short			theMenuHeight;		GetPort(&oldPort);	theMenuHeight = GetMBarHeight();	theWindow = FrontWindow();	if (!theWindow)	{		theWindowOffset.h = 0;		theWindowOffset.v = theMenuHeight+18;		return theWindowOffset;	}	theWindDocHndl = (ImageDocHndl)GetWRefCon(theWindow);	if (!(**theWindDocHndl).isColorsWindow)	{		SetPort(theWindow);		theWindowOffset.h = theWindow->portRect.left;		theWindowOffset.v = theWindow->portRect.top;		LocalToGlobal(&theWindowOffset);	}	else	{				do {			theNextWindow = &((WindowPeek)theWindow)->nextWindow->port;			theWindow = theNextWindow;			theWindDocHndl = (ImageDocHndl)GetWRefCon(theWindow);		} while (theWindow && (**theWindDocHndl).isColorsWindow);		if (theWindow)		{			SetPort(theWindow);			theWindowOffset.h = theWindow->portRect.left;			theWindowOffset.v = theWindow->portRect.top;			LocalToGlobal(&theWindowOffset);		}		else		{			theWindowOffset.h = 0;			theWindowOffset.v = 0;		}	}	theWindowOffset.h +=18;	theWindowOffset.v +=18;	TestWindowFitMainScrn(theDocHndl, &theWindowOffset);	SetPort(oldPort);	return theWindowOffset;}/****	Test for window fit main screen	****/#pragma segment windowsvoid	TestWindowFitMainScrn(ImageDocHndl theDocHndl, Point *windowOffset){	GDHandle		theMainGDevHndl;	Rect			mainScrnSize,					*maxWindowSize;	Point			theWindowOffset;	short			theMenuHeight;	theMainGDevHndl = GetMainDevice();	mainScrnSize = (**theMainGDevHndl).gdRect;	theMenuHeight = GetMBarHeight();	mainScrnSize.bottom -=theMenuHeight+20;	maxWindowSize = &(*theDocHndl)->theMaxWindowSize;	if ((maxWindowSize->right+windowOffset->h) > mainScrnSize.right)	{		windowOffset->h = 0;		if ((maxWindowSize->right+windowOffset->h) > mainScrnSize.right)			maxWindowSize->right = mainScrnSize.right - 20;	}	if ((maxWindowSize->bottom+windowOffset->v) > mainScrnSize.bottom)	{		windowOffset->v = theMenuHeight+18;		if ((maxWindowSize->bottom+windowOffset->v) > mainScrnSize.bottom)			maxWindowSize->bottom = mainScrnSize.bottom;	} }/****	Resize window	****/#pragma segment windowsvoid	HandleWindowReSize(WindowPtr theWindow,Point startPoint){	ImageDocHndl		theWindDocHndl;	WindowPtr			oldPort;	long				returnCoord;	Rect				resizeBounds;	short				windWidth,						windHeight,						maxXsize,						maxYsize;		GetPort(&oldPort);	theWindDocHndl = (ImageDocHndl)GetWRefCon((WindowPtr)theWindow);	SetRect(&resizeBounds,96,96,			(1+(**theWindDocHndl).theMaxWindowSize.right - (**theWindDocHndl).theMaxWindowSize.left),			(1+(**theWindDocHndl).theMaxWindowSize.bottom - (**theWindDocHndl).theMaxWindowSize.top));	returnCoord = GrowWindow(theWindow, startPoint, &resizeBounds);	windHeight   = HiWord(returnCoord);	windWidth = LoWord(returnCoord);	SizeWindow(theWindow, windWidth, windHeight, true);	MoveControl((**theWindDocHndl).theVScrollBar,				theWindow->portRect.right - kScrollBarWidth,theWindow->portRect.top - 1);	MoveControl((**theWindDocHndl).theHScrollBar,				theWindow->portRect.left - 1,theWindow->portRect.bottom-kScrollBarWidth);	SizeControl((**theWindDocHndl).theVScrollBar,16,				(theWindow->portRect.bottom - theWindow->portRect.top)-13);	SizeControl((**theWindDocHndl).theHScrollBar,				(theWindow->portRect.right - theWindow->portRect.left)-13,16);	maxXsize = (*theWindDocHndl)->theImageWorld->portRect.right - 				((theWindow->portRect.right - kScrollBarWidth) - theWindow->portRect.left);	maxYsize = (*theWindDocHndl)->theImageWorld->portRect.bottom - 				((theWindow->portRect.bottom - kScrollBarWidth) - theWindow->portRect.top);	SetControlMaximum((**theWindDocHndl).theVScrollBar,maxYsize);	SetControlMaximum((**theWindDocHndl).theHScrollBar,maxXsize);	SetPort(theWindow);	InvalRect(&theWindow->portRect);	SetPort(oldPort);}/****	Display Progres Bar Dialog	*****/#pragma segment windowsvoid	DisplayProgressBarDlog(short updateState, short controlValue, short theStrGroup, short theStrID){	static ControlHandle	theControl;	static GrafPtr			oldPort;	static CWindowPtr		theProgressWindow;	Str255					theProgressStr;						GetPort(&oldPort);	// Perform operations on dialog and progress control dependent on updateState parameter	switch (updateState)	{		 case kDisplayProgressWindow:			DisableAllMenus(true);			theProgressWindow = (CWindowPtr) GetNewCWindow(rProgressBarWindow,nil,((WindowPtr)-1L));			SetPort	((WindowPtr)theProgressWindow);			theControl=GetNewControl(rProgressCntl, (WindowPtr)theProgressWindow);			MoveControl(theControl,20,32);			ShowControl(theControl);			GetIndString (theProgressStr,theStrGroup,theStrID);			if (theStrGroup != 0)			{				MoveTo(20,64);				DrawString(theProgressStr);			}		break;		case kUpdateProgressWindow:			SetPort	((WindowPtr)theProgressWindow);			SetControlValue(theControl,controlValue);		break;		case kDisposeProgressWindow:			DisposeControl(theControl);			DisposeWindow((WindowPtr)theProgressWindow);			DisableAllMenus(false);		break;	}	SetPort(oldPort);}/****	Display Startup splash screen	*****/#pragma segment windowsvoid SplashScreen(short theDelayLength){	WindowPtr		theWindow,					oldPort;	PicHandle		thePict = nil;	signed long		currentTime,					delayTime;		GetPort(&oldPort);	thePict=GetPicture(rSplashPICT);	if (thePict==nil)		return;			theWindow=GetNewWindow(rSplashWindow,nil,(WindowPtr)-1L);	SetPort(theWindow);	HLock((Handle)thePict);	DrawPicture(thePict,&theWindow->portRect);	HUnlock((Handle)thePict);	DisposeHandle((Handle)thePict);	currentTime=LMGetTicks();	delayTime = currentTime+theDelayLength;	do	{		currentTime = LMGetTicks();	}while (currentTime < delayTime);	DisposeWindow((GrafPtr)theWindow);	SetPort(oldPort);}/****	Test for open colors window		****/#pragma segment windowsBoolean	ColorWindowVisible(void){	Str255		theItemString,				theResString;	Boolean		isVisible = false;	GetMenuItemText(GetMHandle(mWindow),iColors,theItemString);		GetIndString (theResString,rMenuItems,iHideColors);	if (EqualString(theItemString,theResString,true,true))		isVisible = true;	return isVisible;}