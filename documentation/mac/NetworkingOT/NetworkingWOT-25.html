<!-- Generated by Harlequin WebMaker 2.2.3 (30-Apr-1996)
Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->
<HTML> <HEAD>
<TITLE>Using Providers</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING25></A>
<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->

<!-- Main Body -->

<CENTER>
<P>
<A HREF="NetworkingWOT-24.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="NetworkingWOT-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="NetworkingWOT-491.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A>  <A HREF="NetworkingWOT-26.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html"><B>Inside Macintosh:</B></A> <A HREF="NetworkingWOT-2.html"><B>Networking With Open Transport </B></A> / <A HREF="NetworkingWOT-10.html"><B>Part 1 - Open Transport Essentials</B></A><BR><DD><A HREF="NetworkingWOT-23.html"><B>Chapter 3 - Providers</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING25-0></A>
<H1>Using Providers</H1>
 <A NAME=MARKER-13-49></A>This section explains how you obtain and change a provider's mode of operation; it provides a more detailed discussion of asynchronous processing and the use of notifier functions; and it explains how you close a provider.<P>
 In addition to the functions used to set a provider's mode of operation and to close a provider, general provider functions include the <CODE>OTIoctl</CODE> function, which you can use to communicate directly with a STREAMS module implementing a networking protocol. For more information, see the description of that function in Providers Reference<A HREF=NetworkingWOT-97.html#MARKER-9-19></A>.<P>
<A NAME=HEADING25-3></A>
<H2><A NAME=MARKER-9-50></A>Controlling a Provider's Modes of Operation</H2>
 A provider's mode of operation determines how provider functions execute and determines the behavior of provider functions that send and receive data. You can control a provider's mode of operation by calling general provider functions to specify whether provider functions execute synchronously or asynchronously, whether provider functions can block, and whether they can acknowledge sends. The following three sections provide additional information about how you can obtain a provider's current mode of operation and how you can change it.<P>
<A NAME=HEADING25-5></A>
<H3>Which Mode To Use</H3>
 Use the following guidelines in determining which mode to use:<P>
<UL>
<P><LI>For easiest programming,<P>
If you are using threads, use synchronous, blocking mode and call the function <CODE>OTUseSynchIdleEvents</CODE>.<P>
If you do not use threads, use synchronous, nonblocking and poll for events using the function <CODE>GetEndpointState</CODE>.<P>
Using providers in synchronous mode makes for very easy coding; however, if they are also blocking, this could severely affect performance. One way to manage this problem is to call the function <CODE>OTUseSyncIdleEvents </CODE><A HREF=NetworkingWOT-122.html#MARKER-9-130></A><CODE> </CODE>just after setting the provider's mode of operation. This function generates events of the type <CODE>kOTSyncIdleEvents</CODE> and sends them to your notifier while Open Transport is waiting to complete a synchronous call. On receipt of this event, your notifier should call the system function <CODE>YieldToAnyThread</CODE>; this transfers execution to another thread, thus allowing processing to continue while your synchronous operation waits to complete. You should avoid calling functions in synchronous mode at non-System-Task time.<A NAME=MARKER-13-51></A><P>
<P><LI>For best performance, use asynchronous blocking mode.<P>
Asynchronous processing requires some additional work: you must make sure that memory you have allocated for a function's output parameters is persistent and you must use some sort of mechanism to determine when the function has actually completed. These issues are taken up in the section <A HREF=#MARKER-9-70>"Using Notifier Functions to Handle Provider Events"</A>.<P>
<P><LI>Never use asynchronous nonblocking mode.<P>
</UL>
<A NAME=HEADING25-14></A>
<H3><A NAME=MARKER-9-49></A>Specifying How Provider Functions Execute</H3>
 <A NAME=MARKER-13-53></A>For each provider, you can control whether provider functions run synchronously or asynchronously. When you open a provider, you set its default mode of execution. For example, when you open an endpoint provider, you can use either the function <CODE>OTOpenEndpoint</CODE> or <CODE>OTAsyncOpenEndpoint</CODE>. If you open an endpoint provider using the <CODE>OTAsyncOpenEndpoint</CODE> function, Open Transport creates the provider and sets the default execution mode for all the provider's functions to asynchronous.<P>
 A provider's default mode of execution remains in effect until you change it by calling either the <A NAME=MARKER-13-72></A><CODE>OTSetSynchronous</CODE> function or the <A NAME=MARKER-13-76></A><CODE>OTSetAsynchronous</CODE> function. The new mode remains in effect until you change the mode again. A provider's mode of execution affects only that provider. If you use two or more providers, they need not operate in the same mode. <P>
 You should be aware that mixing synchronous and asynchronous calls can cause critical problems. Take the following sequence as an example:<P>
<OL>
<P><LI>Set asynchronous mode.
<P><LI>Call a function.
<P><LI>Set synchronous mode; call a function.
<P><LI>The function called in step 2 completes, and the notifier installed for that provider executes at deferred task time.<P>
</OL>
 The problem is that the notifier function, called in step 4, now executes with the provider in synchronous mode: the mode of execution is determined <I>when</I> a function is called. Thus any Open Transport function called in the notifier will execute synchronously. However, functions called from a notifier may not execute synchronously; therefore your system will return an error. To avoid this problem, make sure there are no outstanding asynchronous requests when switching to synchronous mode.<P>
 The return behavior of certain provider functions is controlled not only by a provider's mode of execution but also by the provider's blocking status, described in the following section. Changing a provider's mode of execution does not change its blocking status.<P>
<A NAME=HEADING25-24></A>
<H3><A NAME=MARKER-9-56></A>Setting a Provider's Blocking Status</H3>
 A newly created provider does not block, regardless of which Open Transport function created it. After a provider is created, you can change its blocking status as often as you like. A provider's blocking status affects only that provider.<A NAME=MARKER-13-57></A><P>
<UL>
<P><LI>You use the <A NAME=MARKER-13-89></A><CODE>OTSetBlocking</CODE> function to set a provider's mode of operation <BR>to blocking.
<P><LI>You use the <A NAME=MARKER-13-93></A><CODE>OTSetNonBlocking</CODE> function to set a provider's mode of operation to nonblocking.
<P><LI>You use the <A NAME=MARKER-13-97></A><CODE>OTIsNonBlocking</CODE> function to determine whether a <BR>provider blocks.<P>
</UL>
 If a provider is blocking and you call a function synchronously, all processing on the Macintosh is halted until the synchronous function completes. For information on how to handle this situation, see <A HREF=NetworkingWOT-39.html#MARKER-9-49>"Specifying How Provider Functions Execute"</A>.<P>
 If a provider is nonblocking, provider functions that cannot complete send or receive operations return an error indicating the reason. The result returned might be<P>
<UL>
<P><LI><CODE><A NAME=MARKER-15-38></A>kEAGAINErr</CODE> or <A NAME=MARKER-15-45></A><CODE>kEWOULDBLOCKErr</CODE>, indicating that the function would have to be queued before it could execute 
<P><LI><CODE><A NAME=MARKER-15-14></A>kOTNoDataErr</CODE>, indicating that data has not yet arrived
<P><LI><CODE><A NAME=MARKER-15-13></A><A NAME=MARKER-15-13></A>kOTFlowErr</CODE>, indicating that the provider is flow controlled.
<P><LI><CODE><A NAME=MARKER-15-39></A>KENOMEMErr</CODE>, indicating that there is not enough memory<P>
</UL>
 In many of these cases, you should call the function again.<P>
<A NAME=HEADING25-36></A>
<H3><A NAME=MARKER-9-67></A>Setting a Provider's Send-Acknowledgment Status</H3>
 You can control the behavior of provider functions that send data by specifying that the provider not make an internal copy of the data it is sending, but that it relies entirely upon the data being in the buffer you provide. Asking the provider not to make a copy is the same as asking it to acknowledge sends (the Open Transport phrasing). In the current version, you can only specify that <I>endpoint</I> providers acknowledge sends. For more detailed information about this mode of operation, see <A HREF=NetworkingWOT-47.html#MARKER-9-20>"Acknowledging Sends"</A>.<A NAME=MARKER-13-68></A><P>
<A NAME=HEADING25-38></A>
<H2><A NAME=MARKER-8-69></A><A NAME=MARKER-9-70></A>Using Notifier Functions to Handle Provider Events</H2>
 When provider functions execute asynchronously, you can continue processing without having to wait for a function to complete execution. In some cases, you might need to know when the function has finished executing, either because further processing depends on the results of that operation or because you need to use memory you have allocated for that function. In order to meet this need, the Open Transport architecture defines completion events, which are generated by a provider when an asynchronous function completes execution. To pass the event to your application as well as other information about the function that has completed, the provider calls a notifier function that you have written and installed for that provider. <P>
 The provider uses the notifier's parameters to pass the following information back to your application:<P>
<UL>
<P><LI>a context pointer for your use <P>
You define this pointer when you install the notifier function. When the provider calls the notifier, it passes this pointer back to you. <A NAME=MARKER-13-71></A>It is typically the <CODE>ProviderRef</CODE> or a data structure that contains the <CODE>ProviderRef</CODE>.<P>
<P><LI>an event code identifying the provider event
<P><LI>the function result if it's a completion event.
<P><LI>a pointer to additional information that the function is returning <P>
This parameter is called the <CODE>cookie</CODE> parameter. For example, when you call a function that assigns an address to an endpoint, you can request a particular address. When the function returns, it passes back the address that is actually assigned to the endpoint. If you call the function asynchronously, this information is referenced by the <CODE>cookie</CODE> parameter.<P>
</UL>
 If you open a provider in asynchronous mode, you install a notifier function by passing a pointer to it in one of the parameters to the function used to open the provider. If you open a provider in synchronous mode, you must install the notifier by calling the <A NAME=MARKER-13-114></A><CODE>OTInstallNotifier</CODE> function <A HREF=NetworkingWOT-118.html#MARKER-9-115></A>. If you want to change notifiers, you must first remove the old notifier by calling the <CODE>OTRemoveNotifier</CODE> function <A HREF=NetworkingWOT-119.html#MARKER-9-119></A> and then call the <CODE>OTInstallNotifier</CODE> function to install the new notifier.<A NAME=MARKER-13-73></A><P>
 You are responsible for the contents of a notifier function. Typically, such a function tests to see whether the function that just completed has returned an error. If it has not, it uses a <CODE>switch</CODE> statement to transfer control to different subroutines, depending on the event code passed to the notifier. In the notifier shown <A HREF=#MARKER-9-74>Listing 3-1</A> fatal errors all break out of the switch to the default case. The notifier sample is intended to give you a sense of how such code is structured. In general, the notifier does not need to handle every completion event, just those that you expect to happen and that have meaning for the provider you are opening. You should ignore any events you are not expecting.<P>
<B>Listing 3-1  <A NAME=MARKER-9-74></A>A notifier function <A NAME=MARKER-13-75></A></B><P>
<PRE>
<A NAME=MARKER-0-95></A>static pascal void Notifier(void* context, OTEventCode event, OTResult 
result, void* cookie)
{
   EPInfo* epi = (EPInfo*) context;

   switch (event)
   {
      case T_LISTEN:
      {
         DoListenAccept();
         return;
      }

      case T_ACCEPTCOMPLETE:
      {
         if (result != kOTNoError)
            DBAlert1(&quot;Notifier: T_ACCEPTCOMPLETE - result %d&quot;,
                                          result);
         return;
      }
      
      case T_PASSCON:
      {
         if (result != kOTNoError)
         {
            DBAlert1(&quot;Notifier: T_PASSCON result %d&quot;, result);
            return;
         }  
         OTAtomicAdd32(1, &amp;gCntrConnections);
         OTAtomicAdd32(1, &amp;gCntrTotalConnections);
         OTAtomicAdd32(1, &amp;gCntrIntervalConnects);
         if ( OTAtomicSetBit(&amp;epi-&gt;stateFlags, kPassconBit) != 0 )
         {
            ReadData(epi);
         }
         return;
      }
      
      case T_DATA:
      {
         if ( OTAtomicSetBit(&amp;epi-&gt;stateFlags, kPassconBit) != 0 )
         {
            ReadData(epi);
         }
         return;
      }
      
      case T_GODATA:
      {
         SendData(epi);
         return;
      }
      
      case T_DISCONNECT:
      {
         DoRcvDisconnect(epi);
         return;
      }
      
      case T_DISCONNECTCOMPLETE:
      {
         if (result != kOTNoError)
            DBAlert1(&quot;Notifier: T_DISCONNECT_COMPLETE result %d&quot;,
                        result);
         return;
      }
      
      case T_MEMORYRELEASED:
      {
         OTAtomicAdd32(-1, &amp;epi-&gt;outstandingSends);
         return;
      }
      
      default:
      {
         DBAlert1(&quot;Notifier: unknown event &lt;%x&gt;&quot;, event);
         return;
      }
   }
}
</PRE>
 You can use a notifier function to handle asynchronous events as well as completion events. A provider uses asynchronous events to inform your application that data has arrived or that a connection or disconnection request is pending.The method used is the same as for completion events. You must include <CODE>case</CODE> statements in the notifier that are pertinent to the asynchronous events you expect to receive.<A NAME=MARKER-13-77></A><P>
 The provider calls your notifier function at deferred task time or at system task time. This means that the routines called from your notifier <A NAME=MARKER-13-78></A><P>
<UL>
<P><LI>might need to be reentrant
<P><LI>cannot move or purge memory
<P><LI>cannot depend on the validity of handles to unlocked blocks
<P><LI>should not perform time-consuming tasks
<P><LI>should not make synchronous calls to Open Transport 
<P><LI>should not make synchronous Device Manager or File Manager calls<P>
</UL>
 The only exception to these rules occurs when you are responding to the event <CODE><A NAME=MARKER-13-55></A>kOTProviderWillClose</CODE>. See the event codes enumeration <A HREF=NetworkingWOT-100.html#MARKER-9-22></A> for additional information.<P>
 Open Transport might call a notification routine reentrantly. Open Transport attempts to queue calls to a notification routine to prevent reentrancy and to keep the processor stack from growing, but this behavior is not guaranteed. You should be prepared and write your notification routine defensively. For additional information, see <A HREF=NetworkingWOT-126.html#MARKER-9-142>"MyNotifierCallbackFunction"</A>.<P>
 If you execute provider functions asynchronously, you must also take special care about the duration of the function's variables. A function that is executed asynchronously returns immediately, and the stack frame of the function that called it might be torn down before you have had a chance to retrieve the information returned in the parameters to the asynchronous function (using the notifier function's <CODE>cookie</CODE> parameter). If these parameters are local variables in the calling function, the information passed back by the asynchronous function is lost. To avoid this situation, you need to write the function that calls the asynchronous function in such a way that the memory pointed to by its return parameters is not overwritten. For example, you could make these variables global or use the function <CODE>OTAllocMem</CODE> to allocate them.<P>
<A NAME=HEADING25-62></A>
<H2><A NAME=MARKER-13-80></A>Transferring a Provider's Ownership</H2>
 An Open Transport client is any task that calls the <CODE>InitOpenTransport</CODE> function. Open Transport keeps track of the owner of each provider, and when a client dies or quits without closing all of its outstanding providers, Open Transport attempts to close them on behalf of the client. Every shared library, code resource, or program that creates an endpoint, or uses one of the endpoint functions that allocate memory on behalf of the client, is a client of Open Transport. For ASLM shared libraries and applications, Open Transport can clean up after the library or application easily. For CFM shared libraries and code resources, however, the client <I>must</I> call <A NAME=MARKER-13-36></A><CODE>CloseOpenTransport</CODE> before terminating (this can be done by making <CODE>CloseOpenTransport</CODE> the termination procedure for the CFM library).<P>
 Although it's not a frequent occurrence, there may be times when it is not convenient for you to lose access to a provider. For example, if you are still using a provider created by a shared library when that shared library is unloaded or you are still using a provider reference passed by another application when that application quits, you will find yourself using invalid references unexpectedly.<P>
 In cases where you do not want Open Transport to close a given provider, you can define yourself as its new owner with the <A NAME=MARKER-13-61></A>OTTransferProviderOwnership function <A HREF=NetworkingWOT-103.html#MARKER-9-60></A>. You need to obtain the previous owner's client ID before the client terminates, and then pass it to Open Transport along with the provider reference for the provider. Open Transport allocates a new provider reference and returns the new reference to you. The old provider reference is then invalid and should not be used. <A NAME=MARKER-13-83></A><A HREF=#MARKER-9-84>Listing 3-2</A> furnishes an example of transferring a provider's ownership. In this example, an Open Transport client, the ProviderFactory library, creates an endpoint. It then passes the endpoint reference back to another Open Transport client, the TransferProvider application. The application is responsible for transferring the ownership of the endpoint from the library to itself before shutting down the library; it does so using the <CODE>GetProviderFromFactory</CODE> function.<P>
<B>Listing 3-2  <A NAME=MARKER-9-84></A>Transferring provider ownsership</B><P>
<PRE>
<A NAME=MARKER-0-95></A>static OSStatus GetProviderFromFactory(void)
{
   OSStatus err;
   EndpointRef originalEndpoint;
   OTClient originalOwner;
   EndpointRef newEndpoint;
   TEndpointInfo newEndpointInfo;

/* Use the factory library to create an endpoint.*/
   
   err = FactoryCreateEndpoint(&amp;originalEndpoint, &amp;originalOwner);
   
   if (err == noErr) {
   
/* Transfer the ownership of endpoint, so that OT knows we now own it */
      
      newEndpoint = OTTransferProviderOwnership(originalEndpoint,
                        originalOwner, &amp;err);

      if (err == noErr) {
         
/* We can now use newEndpoint as if we created it.  */
/* We call OTGetEndpointInfo as an example of an operation */
/* on the endpoint.*/

         err = OTGetEndpointInfo(newEndpoint, &amp;newEndpointInfo);
         
         if (err == noErr) {
            printf(&quot;Maximum size of endpoint address = %ld.\n&quot;,
                              newEndpointInfo.addr);
         }
         
         OTCloseProvider(newEndpoint);
      }
   }
   
   return err;
}

void main(void)
{/* initialize connection to Open Transport */
   OSStatus err;
   
   err = InitOpenTransport();
   if (err == noErr) {

/* initialize the provider factory library. */
      err = InitProviderFactory();
      
      if (err == noErr) {
      /* call GetProviderFromFactory to demonstrate */
      /* use of OTTransferProviderOwnership */
         err = GetProviderFromFactory();

         CloseProviderFactory();
      }
   
      CloseOpenTransport();
   }
   if (err == noErr) {
      printf(&quot;Success!\n&quot;);
   } else {
      printf(&quot;Failed with error %ld.\n&quot;, err);
   }
}
</PRE>
<A NAME=HEADING25-68></A>
<H2>Closing a Provider</H2>
 There are two instances in which you need to close a provider:<A NAME=MARKER-13-86></A><P>
<UL>
<P><LI>when you are through using the services offered by a provider<P>
You do this by calling the <A NAME=MARKER-13-64></A><CODE>OTCloseProvider</CODE> function and passing the provider reference of the provider you wish to close.<P>
<P><LI>in response to a <CODE>kOTProviderWillClose</CODE> event or a <CODE>kOTProviderIsClosed</CODE> event.<P>
If you get a <CODE>kOTProviderIsClosed</CODE> event, the service underlying your provider is already gone; closing the provider only frees up memory resources.<P>
</UL>
 Closing a provider deletes all memory reserved for it in the system heap, deletes its resources, and cancels any provider functions that are currently executing. <P>
 If you have opened a provider asynchronously (for example, by calling the <CODE>AsyncOpenEndpoint</CODE> function), it is not possible to close it before the call has completed. This might happen if the user quits the application before the provider has opened. For this reason, it is safer to open a provider synchronously and then to use the <CODE>OTSetAsynchronous</CODE> function to set the execution mode.<P>
 The blocking status of a provider governs what happens when the provider is closed. In non-blocking mode, closing the provider flushes all outgoing commands in the stream and immediately closes the provider. In blocking mode, the stream is given up to 15 seconds per module to allow outgoing commands and data to be processed before the stream is closed.<P>
 If you are closing a provider in response to a <CODE>kOTProviderWillClose</CODE> event, note that Open Transport issues this event only at system task time. Thus, you can set the endpoint to synchronous mode (from within the notifier function) and call functions synchronously to do whatever clean-up is necessary before you return from the notifier. <A NAME=MARKER-2-88></A><P>
<HR>
<B>Subtopics</B>
<B><!-- TOC --><DL>
<DT><A HREF="NetworkingWOT-25.html#HEADING25-3">Controlling a Provider's Modes of Operation</A>
<DD>
<DT><A HREF="NetworkingWOT-25.html#HEADING25-5">Which Mode To Use</A>
<DD>
<DT><A HREF="NetworkingWOT-25.html#HEADING25-14">Specifying How Provider Functions Execute</A>
<DD>
<DT><A HREF="NetworkingWOT-25.html#HEADING25-24">Setting a Provider's Blocking Status</A>
<DD>
<DT><A HREF="NetworkingWOT-25.html#HEADING25-36">Setting a Provider's Send-Acknowledgment Status</A>
<DD>
<DT><A HREF="NetworkingWOT-25.html#HEADING25-38">Using Notifier Functions to Handle Provider Events</A>
<DD>
<DT><A HREF="NetworkingWOT-25.html#HEADING25-62">Transferring a Provider's Ownership</A>
<DD>
<DT><A HREF="NetworkingWOT-25.html#HEADING25-68">Closing a Provider</A>
<DD>
</DL>
</B>
</BLOCKQUOTE>
<HR>
<center>
<A HREF="NetworkingWOT-24.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="NetworkingWOT-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="NetworkingWOT-491.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A>  <A HREF="NetworkingWOT-26.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="NetworkingWOT-4.html">&copy; Apple Computer, Inc.</A><br>15 JAN 1998<P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML> 
