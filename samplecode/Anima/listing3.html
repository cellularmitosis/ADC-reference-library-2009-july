<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>Anima - /SpriteMgr.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxGraphicsImaging-date.html">Graphics & Imaging</a> &gt; <A HREF="javascript:location.replace('index.html');">Anima</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/GraphicsImaging/index.html" target="_blank">Reference Library > Graphics & Imaging</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">Anima</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/SpriteMgr.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/AnimationTest.c</option>
<option value="listing2.html">/SpriteMgr.a</option>
<option value="listing3.html">/SpriteMgr.c</option>
<option value="listing4.html">/SpriteMgr.h</option></select>
				</p>
				</form>
				<p><strong><a href="Anima.zip">Download Sample</a></strong> (&#147;Anima.zip&#148;, 40.7K)<BR>
<strong><a href="Anima.dmg">Download Sample</a></strong> (&#147;Anima.dmg&#148;, 103.6K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*  &copy; Copyright 1991 Ricardo Batista,  All Rights Reserved.      Sprite Manager      04/20/91      HISTORY:  (Most Recent first)      04/20/91  rb  New today    */#include &lt;Types.h&gt;#include &lt;QuickDraw.h&gt;#include &lt;QDOffscreen.h&gt;#include &lt;Memory.h&gt;#include &lt;Resources.h&gt;#include &lt;OSUtils.h&gt;#include &lt;Retrace.h&gt;#include &lt;Windows.h&gt;#include &lt;ToolUtils.h&gt;#include &quot;SpriteMgr.h&quot;#define    desiredPixSize    8SpriteMgrRecPtr    Sprite_Mgr_Globals;    // global used to save our informationpascal short SetDepth(GDHandle gd, short newDepth, short whichFlags, short newFlags) =          {0x203C, 0x000A, 0x0013, 0xAAA2};pascal short HasDepth(GDHandle gd, short newDepth, short whichFlags, short newFlags) =          {0x203C, 0x000A, 0x0014, 0xAAA2};  /*    This routine initializes the sprite manager, it must be called after dialogs,    windows, resources, and quickdraw have been initialized.  This routine creates    a record to memory to keep the sprite manager globals, it also finds the best    monitor in which to display the color animation and sets the monitor to 4 bit    color after saving the previous color depth.  This routine also installs a small    vbl task used by the drawing routines.    if cTable is not nil the given color table is made the current color table and the    previous color table saved for later restoration.    returns 0 if no error occured. 1 if no color monitor present or not enough memory    to create memory record.  */short InitSpriteMgr(CTabHandle cTable){  short err;  GDHandle device;  PixMapHandle pixH;  Boolean done = false;  short oldPixelSize;  CTabHandle  colorTable = 0L;  short mode;    if (Sprite_Mgr_Globals)    return(0);  Sprite_Mgr_Globals = (SpriteMgrRecPtr) NewPtrClear(sizeof(SpriteMgrRec));  if (!Sprite_Mgr_Globals)    return(1);  device = GetDeviceList();  if (!device) {    DisposPtr((Ptr) Sprite_Mgr_Globals);    Sprite_Mgr_Globals = 0L;    return(1);  }  while (device &amp;&amp; !done) {    pixH = (**device).gdPMap;    oldPixelSize = (**pixH).pixelSize;    if (oldPixelSize == desiredPixSize) {      if (cTable) {        colorTable = (**pixH).pmTable;        (**pixH).pmTable = cTable;        GDeviceChanged(device);      }      done = true;    }    else {      mode = HasDepth(device, desiredPixSize, 1, 1);    /* color device */      if (mode) {        err = SetDepth(device, desiredPixSize, 1, 1);        if (cTable) {          colorTable = (**pixH).pmTable;          (**pixH).pmTable = cTable;          GDeviceChanged(device);        }        done = true;      }    }    if (!done)      device = (GDHandle) (**device).gdNextGD;  }  if (!done)    return(1);    Sprite_Mgr_Globals-&gt;originalCTable = colorTable;  Sprite_Mgr_Globals-&gt;currCTable = cTable;  Sprite_Mgr_Globals-&gt;originalDepth = oldPixelSize;  Sprite_Mgr_Globals-&gt;task.qType = vType;  Sprite_Mgr_Globals-&gt;task.vblAddr = (ProcPtr) VTASK;  Sprite_Mgr_Globals-&gt;task.vblCount = 1;  Sprite_Mgr_Globals-&gt;task.vblPhase = 0;  Sprite_Mgr_Globals-&gt;deviceUsed = device;  Sprite_Mgr_Globals-&gt;active = false;  Sprite_Mgr_Globals-&gt;changed = true;  Sprite_Mgr_Globals-&gt;updateRects = 0;    err = VInstall((QElemPtr) &amp;Sprite_Mgr_Globals-&gt;task.qLink);  return(err);}                      /*    This routine disposes of the window used by animation, destroys all of the graphic    worlds created and deinstalls the vbl task.  It also re-enables any applications    hidden by ActivateAnimation.    Restores the color table if it had been changed when InitSpriteMgr was called.    This routine should be called when the application quits.  */  void CloseSpriteMgr(void){  CTabHandle cTable;  GDHandle device;  short err;    VRemove((QElemPtr) &amp;Sprite_Mgr_Globals-&gt;task.qLink);  device = Sprite_Mgr_Globals-&gt;deviceUsed;  if (Sprite_Mgr_Globals-&gt;originalCTable) {    cTable = (**(**device).gdPMap).pmTable;    (**(**device).gdPMap).pmTable = Sprite_Mgr_Globals-&gt;originalCTable;    GDeviceChanged(device);    DisposHandle((Handle) cTable);  }  err = SetDepth(device, Sprite_Mgr_Globals-&gt;originalDepth, 1, 1);    while (Sprite_Mgr_Globals-&gt;backSprites)    KillSprite(Sprite_Mgr_Globals-&gt;backSprites-&gt;id);  while (Sprite_Mgr_Globals-&gt;normSprites)    KillSprite(Sprite_Mgr_Globals-&gt;normSprites-&gt;id);  while (Sprite_Mgr_Globals-&gt;foreSprites)    KillSprite(Sprite_Mgr_Globals-&gt;foreSprites-&gt;id);  while (Sprite_Mgr_Globals-&gt;backgrounds)    KillBackground(Sprite_Mgr_Globals-&gt;backgrounds-&gt;id);  while (Sprite_Mgr_Globals-&gt;foregrounds)    KillForeground(Sprite_Mgr_Globals-&gt;foregrounds-&gt;id);    if (Sprite_Mgr_Globals-&gt;animationWindow)    DisposeWindow((WindowPtr) Sprite_Mgr_Globals-&gt;animationWindow);  if (Sprite_Mgr_Globals-&gt;animationGWorld)    DisposeGWorld(Sprite_Mgr_Globals-&gt;animationGWorld);  if (Sprite_Mgr_Globals-&gt;currCTable)    DisposHandle((Handle) Sprite_Mgr_Globals-&gt;currCTable);  DisposPtr((Ptr) Sprite_Mgr_Globals);  Sprite_Mgr_Globals = 0L;}          /*    This routine creates a new background by creating a new graphics world and drawing    in it the picture with id pictID.  drawOrder is the background drawing priority     with 1 being the highest priority.  The highest priority gets drawn first.  copyMode    should be srcCopy for the highest priority element and transparent for the rest.    animationRect is the area within the animation screen where the background will be    drawn.  The size of the picture must be at least as big as the animationRect and can    be bigger if the area is to be scrolled later in the animation.  If the given pictID    is already in use by another graphic entity then graphics world will be shared instead    of creating a new graphics world.    id is returned if no errors occur.  Otherwise 0 if there was not enough memory for the    offscreen world or the picture could not be loaded.  */      short NewBackground(short pictID, short drawOrder, short copyMode, Rect *animationRect, short id){  return (NewScenery(pictID, drawOrder, copyMode, animationRect, id, true));}            /*    This routine creates a new foreground by creating a new graphics world and drawing    in it the picture with id pictID.  drawOrder is the foreground drawing priority     with 1 being the highest priority.  The highest priority gets drawn first.  copyMode    should be transparent in most cases.    animationRect is the area within the animation screen where the foreground will be    drawn.  The size of the picture must be at least as big as the animationRect and can    be bigger if the area is to be scrolled later in the animation.  If the given pictID    is already in use by another graphic entity then graphics world will be shared instead    of creating a new graphics world.    id is returned if no errors occur.  Otherwise 0 if there was not enough memory for the    offscreen world or the picture could not be loaded.  */  short NewForeground(short pictID, short drawOrder, short copyMode, Rect *animationRect, short id){  return (NewScenery(pictID, drawOrder, copyMode, animationRect, id, true));}              /*    This routine changes the offsets where the image is to be drawn in the animation    world and marks the background as changed so that is it redrawn again.  */void ScrollBackground(short id, short vOffset, short hOffset){  SceneryInfoRecPtr sc;    sc = Sprite_Mgr_Globals-&gt;backgrounds;  while (sc) {    if (sc-&gt;id == id) {      sc-&gt;scrollOffset.v += vOffset;      sc-&gt;scrollOffset.h += hOffset;      sc-&gt;changed = true;      return;    }    sc = (SceneryInfoRecPtr) sc-&gt;nextScenery;  }}  /*    This routine changes the offsets where the image is to be drawn in the animation    world and marks the foreground as changed so that is it redrawn again.  */void ScrollForeground(short id, short vOffset, short hOffset){  SceneryInfoRecPtr sc;    sc = Sprite_Mgr_Globals-&gt;foregrounds;  while (sc) {    if (sc-&gt;id == id) {      sc-&gt;scrollOffset.v += vOffset;      sc-&gt;scrollOffset.h += hOffset;      sc-&gt;changed = true;      return;    }    sc = (SceneryInfoRecPtr) sc-&gt;nextScenery;  }}  /*    This routine sets an auto scroll timer and amount for a background to    be scrolled automatically.  Autoscrolling has some limitations at the    time.  */void AutoScrollBackground(short id, short vOffset, short hOffset, long scrollTicks){  SceneryInfoRecPtr sc;    sc = Sprite_Mgr_Globals-&gt;backgrounds;  while (sc) {    if (sc-&gt;id == id) {      sc-&gt;nextTickCount = TickCount() + scrollTicks;      sc-&gt;scrollTicks = scrollTicks;      sc-&gt;autoScrollAmount.v = vOffset;      sc-&gt;autoScrollAmount.h = hOffset;      return;    }    sc = (SceneryInfoRecPtr) sc-&gt;nextScenery;  }}  /*    This routine sets an auto scroll timer and amount for a foreground to    be scrolled automatically.  Autoscrolling has some limitations at the    time.  */void AutoScrollForeground(short id, short vOffset, short hOffset, long scrollTicks){  SceneryInfoRecPtr sc;    sc = Sprite_Mgr_Globals-&gt;foregrounds;  while (sc) {    if (sc-&gt;id == id) {      sc-&gt;nextTickCount = TickCount() + scrollTicks;      sc-&gt;scrollTicks = scrollTicks;      sc-&gt;autoScrollAmount.v = vOffset;      sc-&gt;autoScrollAmount.h = hOffset;      return;    }    sc = (SceneryInfoRecPtr) sc-&gt;nextScenery;  }}  /*    This routine disposes of the graphics world used by the graphic entity with    id number id if the graphics world is not being shared by other graphic entities.    It also deletes any information about this entity from the Sprite Manager    animation record.  */void KillBackground(short id){  SceneryInfoRecPtr sc, sc2;    sc = Sprite_Mgr_Globals-&gt;backgrounds;  if (sc &amp;&amp; (sc-&gt;id == id)) {    Sprite_Mgr_Globals-&gt;backgrounds = (SceneryInfoRecPtr)          sc-&gt;nextScenery;    if (sc-&gt;shared) {      sc2 = FindTwinScenery(sc-&gt;pictID);      if (sc2)        sc-&gt;sceneryWorld = 0L;    }    if (sc-&gt;sceneryWorld)      DisposeGWorld(sc-&gt;sceneryWorld);    DisposPtr((Ptr) sc);    return;  }  sc2 = sc;  sc = (SceneryInfoRecPtr) sc2-&gt;nextScenery;  while (sc) {    if (sc-&gt;id == id) {      sc2-&gt;nextScenery = sc-&gt;nextScenery;      if (sc-&gt;shared) {        sc2 = FindTwinScenery(sc-&gt;pictID);        if (sc2)          sc-&gt;sceneryWorld = 0L;      }      if (sc-&gt;sceneryWorld)        DisposeGWorld(sc-&gt;sceneryWorld);      DisposPtr((Ptr) sc);      return;    }    sc2 = sc;    if (sc)      sc = (SceneryInfoRecPtr) sc-&gt;nextScenery;  }}  /*    This routine disposes of the graphics world used by the graphic entity with    id number id if the graphics world is not being shared by other graphic entities.    It also deletes any information about this entity from the Sprite Manager    animation record.  */void KillForeground(short id){  SceneryInfoRecPtr sc, sc2;    sc = Sprite_Mgr_Globals-&gt;foregrounds;  if (sc &amp;&amp; (sc-&gt;id == id)) {    Sprite_Mgr_Globals-&gt;foregrounds = (SceneryInfoRecPtr)        sc-&gt;nextScenery;    if (sc-&gt;shared) {      sc2 = FindTwinScenery(sc-&gt;pictID);      if (sc2)        sc-&gt;sceneryWorld = 0L;    }    if (sc-&gt;sceneryWorld)      DisposeGWorld(sc-&gt;sceneryWorld);    DisposPtr((Ptr) sc);    return;  }  sc2 = sc;  sc = (SceneryInfoRecPtr) sc2-&gt;nextScenery;  while (sc) {    if (sc-&gt;id == id) {      sc2-&gt;nextScenery = sc-&gt;nextScenery;      if (sc-&gt;shared) {        sc2 = FindTwinScenery(sc-&gt;pictID);        if (sc2)          sc-&gt;sceneryWorld = 0L;      }      if (sc-&gt;sceneryWorld)        DisposeGWorld(sc-&gt;sceneryWorld);      DisposPtr((Ptr) sc);      return;    }    sc2 = sc;    if (sc)      sc = (SceneryInfoRecPtr) sc-&gt;nextScenery;  }}    /*    This routine creates a graphics world for the new sprite.  If the same pictID is    shared by another sprite then the graphics world will be shared between all the    sprites that share the same picture.  Otherwise the picture range from pictID to    pictID + totalPicts will be drawn in the new graphics world.  copyMode should be    transparent in most cases but could be blend in some cases.  spriteProc is a    procedure pointer that if given can be called every ProcTicks ticks    (sixthieths of a second).  If ProcTicks is not zero and spriteProc is nil then    the Sprite Manager will automatically change the current face of the sprite     every ProcTicks ticks to the next face.  drawOrder is the priority in which the    sprite will be drawn with 1 being the highest priority.  collisionProc is a procedure    pointer that will be called when a collision with another sprite is detected only if    the parameter canColide is set to true and the collision occurs with another sprite.    id is the id number that will be used to identify this sprite.            Parameters to the collisionProc are the id of the sprite that collided with this    sprite.        pascal void CollisionProc(short spriteID);        Parameters to the sprite procedure are the id of the sprite and the rectangle which    encloses the sprite in the animation world.        pascal void SpriteProc(short spriteID, Rect *locationRect);  */short NewBackgroundSprite(short pictID, short totalPicts, short copyMode,            ProcPtr spriteProc, long ProcTicks, short drawOrder,            ProcPtr collisionProc, Boolean canColide, short id){  return (SMgrNewSprite(pictID, totalPicts, copyMode, spriteProc, ProcTicks, drawOrder,      collisionProc, canColide, id, 1));}    /*    This routine creates a graphics world for the new sprite.  If the same pictID is    shared by another sprite then the graphics world will be shared between all the    sprites that share the same picture.  Otherwise the picture range from pictID to    pictID + totalPicts will be drawn in the new graphics world.  copyMode should be    transparent in most cases but could be blend in some cases.  spriteProc is a    procedure pointer that if given can be called every ProcTicks ticks    (sixthieths of a second).  If ProcTicks is not zero and spriteProc is nil then    the Sprite Manager will automatically change the current face of the sprite     every ProcTicks ticks to the next face.  drawOrder is the priority in which the    sprite will be drawn with 1 being the highest priority.  collisionProc is a procedure    pointer that will be called when a collision with another sprite is detected only if    the parameter canColide is set to true and the collision occurs with another sprite.    id is the id number that will be used to identify this sprite.            Parameters to the collisionProc are the id of the sprite that collided with this    sprite.        pascal void CollisionProc(short spriteID);        Parameters to the sprite procedure are the id of the sprite and the rectangle which    encloses the sprite in the animation world.        pascal void SpriteProc(short spriteID, Rect *locationRect);  */  short NewSprite(short pictID, short totalPicts, short copyMode,            ProcPtr spriteProc, long ProcTicks, short drawOrder,            ProcPtr collisionProc, Boolean canColide, short id){  return (SMgrNewSprite(pictID, totalPicts, copyMode, spriteProc, ProcTicks, drawOrder,      collisionProc, canColide, id, 2));}        /*    This routine creates a graphics world for the new sprite.  If the same pictID is    shared by another sprite then the graphics world will be shared between all the    sprites that share the same picture.  Otherwise the picture range from pictID to    pictID + totalPicts will be drawn in the new graphics world.  copyMode should be    transparent in most cases but could be blend in some cases.  spriteProc is a    procedure pointer that if given can be called every ProcTicks ticks    (sixthieths of a second).  If ProcTicks is not zero and spriteProc is nil then    the Sprite Manager will automatically change the current face of the sprite     every ProcTicks ticks to the next face.  drawOrder is the priority in which the    sprite will be drawn with 1 being the highest priority.  collisionProc is a procedure    pointer that will be called when a collision with another sprite is detected only if    the parameter canColide is set to true and the collision occurs with another sprite.    id is the id number that will be used to identify this sprite.            Parameters to the collisionProc are the id of the sprite that collided with this    sprite.        pascal void CollisionProc(short spriteID);        Parameters to the sprite procedure are the id of the sprite and the rectangle which    encloses the sprite in the animation world.        pascal void SpriteProc(short spriteID, Rect *locationRect);  */short NewForegroundSprite(short pictID, short totalPicts, short copyMode,            ProcPtr spriteProc, long ProcTicks, short drawOrder,            ProcPtr collisionProc, Boolean canColide, short id){  return (SMgrNewSprite(pictID, totalPicts, copyMode, spriteProc, ProcTicks, drawOrder,      collisionProc, canColide, id, 3));}                      /*    This procedure creates a new animation world and creates a graphics world    for it.  animationRect is the rectangle which will be used for the animation    in a window to be created by this procedure.  The window will be created in the    graphics device which supports 4 bit color.  windowH is the width of the window    to be created and windowV is the height of the window.  wTitle is the title that    will be given to the window.  The window created will be centered in the graphics    device.  A color window pointer is returned to the caller so that the application    can use the areas outside the animationRect for purposes other than animation such    as scores.  */CWindowPtr NewAnimation(Rect *animationRect, short windowH, short windowV, Str255 wTitle){  Rect box;  short err;  GWorldPtr world = 0L;  CTabHandle cTable;  short offsetV, offsetH;  CGrafPtr savedGWorld;  GDHandle savedGD;    GetGWorld(&amp;savedGWorld, &amp;savedGD);  box = (**(Sprite_Mgr_Globals-&gt;deviceUsed)).gdRect;  offsetV = box.bottom - box.top - windowV;  offsetH = box.right - box.left - windowH;  if (offsetV &gt; 0)    offsetV /= 2;  else    offsetV = 0;  if (offsetH &gt; 0)    offsetH /= 2;  else    offsetH = 0;  box.right = box.left + windowH + offsetH;  box.bottom = box.top + windowV + offsetV;  box.top += offsetV;  box.left += offsetH;  Sprite_Mgr_Globals-&gt;animationWindow = (CWindowPtr) NewCWindow(0L, &amp;box, wTitle,        true, documentProc, (WindowPtr) -1L, false, 'Anim');  Sprite_Mgr_Globals-&gt;animationRect = *animationRect;  cTable = Sprite_Mgr_Globals-&gt;currCTable;  err = NewGWorld(&amp;world, desiredPixSize, animationRect, cTable, 0L, (long) useTempMem);  if (!err) {    SetGWorld(world, 0L);    EraseRect(animationRect);  }  Sprite_Mgr_Globals-&gt;animationGWorld = world;  if (!world) {    DisposeWindow((WindowPtr) Sprite_Mgr_Globals-&gt;animationWindow);    Sprite_Mgr_Globals-&gt;animationWindow = 0L;  }  SetGWorld(savedGWorld, savedGD);  return(Sprite_Mgr_Globals-&gt;animationWindow);}    /*    This procedure set the current face of the sprite with id number id to the    given index.  The changed flag is set to true so that drawing is performed in    the next chance by the Sprite Manager.  */void SetCurrentSpriteIndex(short id, short index){  SpriteInfoRecPtr p;    p = FindSprite(id);  if (p) {    p-&gt;changed = true;    p-&gt;currentFace = index;  }}                            /*    This procedure puts the sprite in the animation world at the location given    by top and left.  The changed flag is set to true so that drawing is performed    as soon as possible.  A sprite should only be &quot;put&quot; in the animation world    once unless it is first &quot;removed&quot; by calling RemoveSprite.  */  void PutSprite(short id, short top, short left){  SpriteInfoRecPtr p;    p = FindSprite(id);  if (p) {    p-&gt;changed = true;    p-&gt;animationRect = p-&gt;spriteRect;    p-&gt;animationRect.top += top;    p-&gt;animationRect.bottom += top;    p-&gt;animationRect.left += left;    p-&gt;animationRect.right += left;  }}          /*    This procedure removes a sprite from the animation world by setting its    animation rectangle to an empty rectangle and setting the sprite's changed    flag so that the animation world is updated correctly.  */  void RemoveSprite(short id){  SpriteInfoRecPtr p;    p = FindSprite(id);  if (p) {    p-&gt;changed = true;    p-&gt;animationRect.top = p-&gt;animationRect.left =          p-&gt;animationRect.bottom = p-&gt;animationRect.right = 0;  }}            /*    This procedure moves the sprite in the animation world first remembering the    sprite's old location for further updating.  The sprite's location is offset by    h and v.  A new face for the sprite can be given by newIndex if newIndex is not    zero.  Once a sprite is &quot;put&quot; in the animation world it should  */    void MoveSprite(short id, short h, short v, short newIndex){  SpriteInfoRecPtr p;    p = FindSprite(id);  if (p) {    p-&gt;changed = true;    p-&gt;oldAnimationRect = p-&gt;animationRect;    p-&gt;animationRect.top += v;    p-&gt;animationRect.left += h;    p-&gt;animationRect.bottom += v;    p-&gt;animationRect.right += h;    if (newIndex)      p-&gt;currentFace = newIndex;  }}                            /*    This procedure moves a sprite with the given id to the location specified by h    and v.  A new face for thr sprite may be given by specifying a newIndex other    than zero.  The old location of the sprite is recorded for further updating.  */  void MoveSpriteTo(short id, short h, short v, short newIndex){  SpriteInfoRecPtr p;    p = FindSprite(id);  if (p) {    p-&gt;changed = true;    p-&gt;oldAnimationRect = p-&gt;animationRect;    p-&gt;animationRect = p-&gt;spriteRect;    p-&gt;animationRect.top += v;    p-&gt;animationRect.left += h;    p-&gt;animationRect.bottom += v;    p-&gt;animationRect.right += h;    if (newIndex)      p-&gt;currentFace = newIndex;  }}      /*    This procedure makes visible or invisible a sprite based on the show parameter.    A &quot;hiden&quot; sprite is not drawn in the animation world but can still create    collisions if its collision attribute is enabled.  If the new visibility state    of the sprite is changed the &quot;changed&quot; attribute gets set to true so that the    animation world is updated correctly.  */      void ShowSprite(short id, Boolean show){  SpriteInfoRecPtr p;    p = FindSprite(id);  if (p) {    if (show != p-&gt;hidden) {      p-&gt;changed = true;      p-&gt;oldAnimationRect = p-&gt;animationRect;      p-&gt;hidden = show;    }  }}              /*    This procedure returns the current location of the given sprite in the animation    world or an empty rectangle if the sprite is not currently in the animation world.    More detailed information can be obtained by calling GetSpriteInfo.  */    void GetSpriteLocation(short id, Rect *location){  SpriteInfoRecPtr p;    p = FindSprite(id);  if (p) {    *location = p-&gt;animationRect;  }  else {    SetRect(location, 0, 0, 0, 0);  }}  /*    This procedure enables or disables collisions for a sprite based on the enable value.    Sprites with collisions enabled can only collide with other sprites which    have the collision attribute set to true.  */  void EnableSpriteCollisions(short id, Boolean enable){  SpriteInfoRecPtr p;    p = FindSprite(id);  if (p) {    p-&gt;canCollide = enable;  }}                        /*    This is a special purpose call which &quot;validates&quot; the old rectangle which ussed to    be occupied by a sprite.  Its purpose is to prevent redundant drawing from occuring    when an specific sprite and face moves into the position previously occupied by    an identical sprite and face.  */    void ValidateOldSpriteLocation(short id){  SpriteInfoRecPtr p;    p = FindSprite(id);  if (p) {    p-&gt;oldAnimationRect.top = p-&gt;oldAnimationRect.left = p-&gt;oldAnimationRect.bottom =        p-&gt;oldAnimationRect.right = 0;  }}            /*    This call allows the programmer to specify a collision area for a sprite other than    the sprite's own dimensions.  The collision rectangle is given in the sprite's    local coordinate system.  By using this call collisions can be limited to a certain    portion of th sprite's area.  */      void SetSpriteCollisionRect(short id, Rect *colRect){  SpriteInfoRecPtr p;    p = FindSprite(id);  if (p) {    p-&gt;collisionRect = *colRect;  }}      /*    This function returns a pointer to a sprite information record.  The pointer returned    is valid for the life of the sprite.  That is until is the sprite is &quot;killed&quot; with    a call to &quot;KillSprite&quot;.  The data structure returned by this call should be used mostly    for read-only purposes.  Altering values in the data structure could result in    animation errors.  */      SpriteInfoRecPtr GetSpriteInfo(short id){  SpriteInfoRecPtr p;    p = FindSprite(id);  if (p)    return(p);  return(0L);}              /*    This procedure destroys the graphics world used by the sprite with the given id    if such sprite is not currently sharing a graphics world with another sprite.    If the sprite is currently in the animaton screen its area is recorded so it    can be updated as soon as possible by the Sprite Manager.  */    void KillSprite(short id){  SpriteInfoRecPtr p, p2, twin1, twin2;  register short counter;    for (counter = 0; counter &lt; 3; counter++) {    if (counter == 0)      p = Sprite_Mgr_Globals-&gt;normSprites;    if (counter == 1)      p = Sprite_Mgr_Globals-&gt;backSprites;    if (counter == 2)      p = Sprite_Mgr_Globals-&gt;foreSprites;    if (p) {      if (p-&gt;id == id) {        if (counter == 0)          Sprite_Mgr_Globals-&gt;normSprites = (SpriteInfoRecPtr) p-&gt;nextSprite;        if (counter == 1)          Sprite_Mgr_Globals-&gt;backSprites = (SpriteInfoRecPtr) p-&gt;nextSprite;        if (counter == 2)          Sprite_Mgr_Globals-&gt;foreSprites = (SpriteInfoRecPtr) p-&gt;nextSprite;        if (p-&gt;sharedWorld) {          p-&gt;sharedWorld = false;          // mark as unshared so FindTwin wont give us ourselves          twin1 = FindTwinSprite(p-&gt;pictID);    // find a twin          if (!twin1)            DisposeGWorld(p-&gt;spriteWorld);    // no twins ! weird..          else {            twin1-&gt;sharedWorld = false;      // disable this one temporarily            twin2 = FindTwinSprite(p-&gt;pictID);  // are there any more ?            if (twin2)              twin1-&gt;sharedWorld = true;    // restore shared status since there are more sharing          }        }        else {          DisposeGWorld(p-&gt;spriteWorld);        }        DisposPtr((Ptr) p);        return;      }      p2 = p;      p = (SpriteInfoRecPtr) p-&gt;nextSprite;      while (p) {        if (p-&gt;id == id) {          if (p-&gt;sharedWorld) {            p-&gt;sharedWorld = false;          // mark as unshared so FindTwin wont give us ourselves            twin1 = FindTwinSprite(p-&gt;pictID);    // find a twin            if (!twin1)              DisposeGWorld(p-&gt;spriteWorld);    // no twins ! weird..            else {              twin1-&gt;sharedWorld = false;      // disable this one temporarily              twin2 = FindTwinSprite(p-&gt;pictID);  // are there any more ?              if (twin2)                twin1-&gt;sharedWorld = true;    // restore shared status since there are more sharing            }          }          else {            DisposeGWorld(p-&gt;spriteWorld);          }          p2-&gt;nextSprite = p-&gt;nextSprite;          DisposPtr((Ptr) p);          return;        }        p2 = p;        p = (SpriteInfoRecPtr) p-&gt;nextSprite;      }    }  }}                              /*    This routine activates the animation world so that animation will occur the next    time DoAnimation is called.  The deafult state after calling NewAnimation is to have    the animation world inactive.  All applications other than the current one are hidden    so that the processing time is dedicated to the animation application.  */        void ActivateAnimation(void){  Sprite_Mgr_Globals-&gt;active = true;}        /*    This routine prevents any animation from ocurring by deactivating the animation    world.  This is the deafult state after calling NewAnimation.  This procedure should    be called when the animation is to be suspended.  It also enabled all other applications    so that the user can swith applications.  */    void DeactivateAnimation(void){  Sprite_Mgr_Globals-&gt;active = true;}  /*    This is the main driver for the animation.  If the parameter update is set to    true then the animation world is simply redrawn.  Call DoAnimation with update    set to true when you receive an update event.  When an update event occurs the    application must bracket this call with BeginUpdate and EndUpdate and any    application specific drawing ouside the animation area must be redrawn as well.    When update is set to false this procedure animates the animation world by doing    several things.          1) Go trough the backgrounds updating the animation area as nessesary.      2) Detect sprite collisions and calling collision procedures if nessesary.      3) Check the tick counters and calling the tickle procedures if any.      4) Updating automatic tickling sprites.      5) Drawing any sprites that have changed their face.      6) Updating foregounds.      7) Updating foreground sprites that have changed.  */void DoAnimation(Boolean update){  GrafPtr g1, g2;  Rect sRect;  register short counter, total;  register Rect *boxPtr;  KeyMap keys;    if (update) {    g1 = (GrafPtr) Sprite_Mgr_Globals-&gt;animationGWorld;    g2 = (GrafPtr) Sprite_Mgr_Globals-&gt;animationWindow;    sRect = Sprite_Mgr_Globals-&gt;animationRect;    Sprite_Mgr_Globals-&gt;task.inVBL = 0;    while (Sprite_Mgr_Globals-&gt;task.inVBL == 0)      ;    CopyBits(&amp;(g1-&gt;portBits), &amp;(g2-&gt;portBits), &amp;sRect, &amp;sRect, srcCopy, 0L);    return;  }  if (Sprite_Mgr_Globals-&gt;active == false)    return;  Sprite_Mgr_Globals-&gt;changed = false;    // next: update only changed rectangles on sceneries  // Detect collisions      do {    Sprite_Mgr_Globals-&gt;redoCheck = false;    CheckChangedScenery(Sprite_Mgr_Globals-&gt;backgrounds);  // backgrounds    CheckChangedSprite(Sprite_Mgr_Globals-&gt;backSprites);  // back sprites    CheckChangedSprite(Sprite_Mgr_Globals-&gt;normSprites);  // sprites    CheckChangedScenery(Sprite_Mgr_Globals-&gt;foregrounds);  // foregrounds    CheckChangedSprite(Sprite_Mgr_Globals-&gt;foreSprites);  // fore sprites  } while (Sprite_Mgr_Globals-&gt;redoCheck);    Sprite_Mgr_Globals-&gt;updateRects = 0;  // nothing to update    UpdateScenery(Sprite_Mgr_Globals-&gt;backgrounds);  // changed backgrounds  UpdateSprite(Sprite_Mgr_Globals-&gt;backSprites);  UpdateSprite(Sprite_Mgr_Globals-&gt;normSprites);    // changed sprites  UpdateScenery(Sprite_Mgr_Globals-&gt;foregrounds);  // changed foregrounds  UpdateSprite(Sprite_Mgr_Globals-&gt;foreSprites);    if (Sprite_Mgr_Globals-&gt;changed == false)    return;  g1 = (GrafPtr) Sprite_Mgr_Globals-&gt;animationGWorld;  g2 = (GrafPtr) Sprite_Mgr_Globals-&gt;animationWindow;    GetKeys(&amp;keys[0]);  if ((keys[1] &amp; 0x4) == 0)    Sprite_Mgr_Globals-&gt;updateRects = kMaxUR;  if (Sprite_Mgr_Globals-&gt;updateRects == kMaxUR) {  // update full screen    sRect = Sprite_Mgr_Globals-&gt;animationRect;    Sprite_Mgr_Globals-&gt;task.inVBL = 0;    while (Sprite_Mgr_Globals-&gt;task.inVBL == 0)      ;    CopyBits(&amp;(g1-&gt;portBits), &amp;(g2-&gt;portBits), &amp;sRect, &amp;sRect, srcCopy, 0L);  }  else {    total = Sprite_Mgr_Globals-&gt;updateRects;    boxPtr = &amp;(Sprite_Mgr_Globals-&gt;changedRect[0]);    for (counter = 0; counter &lt; total; counter++) {      Sprite_Mgr_Globals-&gt;task.inVBL = 0;      while (Sprite_Mgr_Globals-&gt;task.inVBL == 0)        ;      CopyBits(&amp;(g1-&gt;portBits), &amp;(g2-&gt;portBits), boxPtr, boxPtr, srcCopy, 0L);      boxPtr++;    }    Sprite_Mgr_Globals-&gt;updateRects = 0;  }}    /*    This procedure changes the current animation pallete used in the animation world    to the new color table.  */void SetNewAnimationPallete(CTabHandle cTable){  GDHandle dev;    dev = Sprite_Mgr_Globals-&gt;deviceUsed;  cTable = (**(**dev).gdPMap).pmTable;  (**(**dev).gdPMap).pmTable = cTable;  DisposHandle((Handle) cTable);  GDeviceChanged(dev);}/************************************************************************************  P R I V A T E       R O U T I N E S  *************************************************************************************/  /*    This is the common routine to create sceneries, we use this routine because we want    to make things more readable for the programmer by providing &quot;specialized&quot; routines    that allow them to distinguish between foregrounds and backgrounds.    The basic process is to create the scenery data structure, fill in the default values,    create the graphics world, load the picture and copy it into the g world, then    the scenery data structure is inserted in the right place.    I suppose that later on we could insert them in the linked list in their priority    order.  */short NewScenery(short pictID, short drawOrder, short copyMode, Rect *animationRect,        short id, Boolean back){  SceneryInfoRecPtr sc, sc2, sc3;  short err;  PicHandle picH;  Rect box;  GWorldPtr world;  CGrafPtr CsavePort;  GDHandle gd;  PixMapHandle pixH;    sc = (SceneryInfoRecPtr) NewPtrClear(sizeof(SceneryInfoRec));  if (!sc)    return(0);  sc-&gt;id = id;  sc-&gt;pictID = pictID;  sc-&gt;drawOrder = drawOrder;  sc-&gt;copyMode = copyMode;  sc-&gt;animationRect = *animationRect;  sc-&gt;hidden = false;  sc-&gt;changed = true;  sc-&gt;shared = false;  sc2 = FindTwinScenery(pictID);  if (sc2) {    sc-&gt;shared = true;    sc2-&gt;shared = true;    sc-&gt;sceneryWorld = sc2-&gt;sceneryWorld;    sc-&gt;sceneryRect = sc2-&gt;sceneryRect;  }  else {    picH = GetPicture(pictID);    if (!picH) {      DisposPtr((Ptr) sc);      return(0);    }    LoadResource((Handle) picH);    HLock((Handle) picH);    box = (**picH).picFrame;    box.right = box.right - box.left;    box.bottom = box.bottom - box.top;    box.top = box.left = 0;    sc-&gt;sceneryRect = box;    GetGWorld(&amp;CsavePort, &amp;gd);    err = NewGWorld( &amp;world, desiredPixSize, &amp;box, 0L, 0L, 0L); // (long) useTempMem);    if (err || (world-&gt;portPixMap == 0L)) {      ReleaseResource((Handle) picH);      DisposPtr((Ptr) sc);      return(0);    }    pixH = world-&gt;portPixMap;    HLock((Handle) pixH);    LockPixels(pixH);    NoPurgePixels(pixH);    SetGWorld(world, 0L);    sc-&gt;sceneryWorld = world;    DrawPicture(picH, &amp;box);    ReleaseResource((Handle) picH);    SetGWorld(CsavePort, gd);  }  if (back)    sc2 = Sprite_Mgr_Globals-&gt;backgrounds;  else    sc2 = Sprite_Mgr_Globals-&gt;foregrounds;  if (sc2-&gt;id &gt; id) {    if (back)      Sprite_Mgr_Globals-&gt;backgrounds = sc;    else      Sprite_Mgr_Globals-&gt;foregrounds = sc;    sc-&gt;nextScenery = (Ptr) sc2;    return(id);  }  else {    if (back)      sc3 = sc2 = Sprite_Mgr_Globals-&gt;backgrounds;    else      sc3 = sc2 = Sprite_Mgr_Globals-&gt;foregrounds;    while (sc2 &amp;&amp; (sc2-&gt;id &lt; id)) {      sc3 = sc2;      sc2 = (SceneryInfoRecPtr) sc2-&gt;nextScenery;    }    if (sc2) {      sc3-&gt;nextScenery = (Ptr) sc;      sc-&gt;nextScenery = (Ptr) sc2;    }    else {      sc3-&gt;nextScenery = (Ptr) sc;    }  }  return(id);}    /*    This is the common routine to create sprites, we use this routine because we want    to make things more readable for the programmer by providing &quot;specialized&quot; routines    that allow them to distinguish between foreground, normal and background sprites.    The basic process is to create the sprite data structure, fill in the default values,    create the graphics world, load the pictures and copy them into the g world, then    the sprite data structure is inserted in the right place.    I suppose that later on we could insert them in the linked list in their priority    order.  */short SMgrNewSprite(short pictID, short totalPicts, short copyMode,            ProcPtr spriteProc, long ProcTicks, short drawOrder,            ProcPtr collisionProc, Boolean canCollide, short id, short sType){  SpriteInfoRecPtr p, p2, twin;  short err, h, v;  PicHandle picH;  Rect box;  GWorldPtr world;  CGrafPtr CsavePort;  GDHandle gd;  PixMapHandle pixH;  register short counter;    p = (SpriteInfoRecPtr) NewPtrClear(sizeof(SpriteInfoRec));  if (!p)    return(0);  p-&gt;id = id;  p-&gt;pictID = pictID;  p-&gt;drawOrder = drawOrder;  p-&gt;copyMode = copyMode;  p-&gt;oldAnimationRect = p-&gt;animationRect;  p-&gt;tickWait = ProcTicks;  p-&gt;currentFace = 1;  p-&gt;sharedWorld = false;  p-&gt;faces = totalPicts;  p-&gt;tickProc = spriteProc;  p-&gt;canCollide = canCollide;  p-&gt;collisionProc = collisionProc;  p-&gt;hidden = false;  p-&gt;changed = true;  twin = FindTwinSprite(pictID);  if (twin) {    twin-&gt;sharedWorld = true;    p-&gt;spriteRect = twin-&gt;spriteRect;    p-&gt;collisionRect = twin-&gt;collisionRect;    p-&gt;spriteWorld = twin-&gt;spriteWorld;    p-&gt;nextSprite = 0L;  }  else {    picH = GetPicture(pictID);    if (!picH) {      DisposPtr((Ptr) p);      return(0);    }    LoadResource((Handle) picH);    HLock((Handle) picH);    box = (**picH).picFrame;    h = box.right - box.left;    v = box.bottom - box.top;    box.right = h;    // make zero offset based    box.bottom = v;    box.top = box.left = 0;    p-&gt;spriteRect = box;    p-&gt;collisionRect = box;    box.right *= totalPicts;    GetGWorld(&amp;CsavePort, &amp;gd);    err = NewGWorld( &amp;world, desiredPixSize, &amp;box, 0L, 0L, 0L); // (long) useTempMem);    if (err || (world-&gt;portPixMap == 0L)) {      ReleaseResource((Handle) picH);      DisposPtr((Ptr) p);      return(0);    }    pixH = world-&gt;portPixMap;    HLock((Handle) pixH);    LockPixels(pixH);    NoPurgePixels(pixH);    SetGWorld(world, 0L);    EraseRect(&amp;world-&gt;portRect);    p-&gt;spriteWorld = world;    p-&gt;nextSprite = 0L;    for (counter = 0; counter &lt; totalPicts; counter++) {      picH = GetPicture(pictID + counter);      LoadResource((Handle) picH);      HLock((Handle) picH);      box = (**picH).picFrame;      box.right = box.right - box.left;      box.bottom = box.bottom - box.top;      box.left = box.top = 0;      box.right += h * counter;      box.left += h * counter;      DrawPicture(picH, &amp;box);      ReleaseResource((Handle) picH);    }    SetGWorld(CsavePort, gd);  }  if (sType == 1) {    p2 = Sprite_Mgr_Globals-&gt;backSprites;    Sprite_Mgr_Globals-&gt;backSprites = p;  }  if (sType == 2) {    p2 = Sprite_Mgr_Globals-&gt;normSprites;    Sprite_Mgr_Globals-&gt;normSprites = p;  }  if (sType == 3) {    p2 = Sprite_Mgr_Globals-&gt;foreSprites;    Sprite_Mgr_Globals-&gt;foreSprites = p;  }  p-&gt;nextSprite = (Ptr) p2;  return(id);}  /*    This is a common routine which is used to find a sprite by a given id, this routine    gets called by most of the sprite interface routines that allow the programmer to    change attributes on a sprite.  The lookup priority is by sprite, then foreground    sprite and finally background sprites.  If no sprite is found we return nil.  */SpriteInfoRecPtr FindSprite(short id){  SpriteInfoRecPtr p;    p = Sprite_Mgr_Globals-&gt;normSprites;  while (p) {    if (p-&gt;id == id)      return(p);    p = (SpriteInfoRecPtr) p-&gt;nextSprite;  }  p = Sprite_Mgr_Globals-&gt;foreSprites;  while (p) {    if (p-&gt;id == id)      return(p);    p = (SpriteInfoRecPtr) p-&gt;nextSprite;  }  p = Sprite_Mgr_Globals-&gt;backSprites;  while (p) {    if (p-&gt;id == id)      return(p);    p = (SpriteInfoRecPtr) p-&gt;nextSprite;  }  return(0L);}  /*    This routine is used to find a sprite that needs to share its gworld, since it    doesn't make sense to duplicate a gworld which is going to use the same as    another one.  This could happen in a &quot;shotter&quot; game for example.  */SpriteInfoRecPtr FindTwinSprite(short pictID){  SpriteInfoRecPtr p;    p = Sprite_Mgr_Globals-&gt;normSprites;  while (p) {    if (p-&gt;pictID == pictID)      return(p);    p = (SpriteInfoRecPtr) p-&gt;nextSprite;  }  p = Sprite_Mgr_Globals-&gt;foreSprites;  while (p) {    if (p-&gt;pictID == pictID)      return(p);    p = (SpriteInfoRecPtr) p-&gt;nextSprite;  }  p = Sprite_Mgr_Globals-&gt;backSprites;  while (p) {    if (p-&gt;pictID == pictID)      return(p);    p = (SpriteInfoRecPtr) p-&gt;nextSprite;  }  return(0L);}SceneryInfoRecPtr FindTwinScenery(short pictID){  SceneryInfoRecPtr sc;    sc = Sprite_Mgr_Globals-&gt;backgrounds;  while (sc) {    if (sc-&gt;pictID == pictID)      return(sc);    sc = (SceneryInfoRecPtr) sc-&gt;nextScenery;  }  sc = Sprite_Mgr_Globals-&gt;foregrounds;  while (sc) {    if (sc-&gt;pictID == pictID)      return(sc);    sc = (SceneryInfoRecPtr) sc-&gt;nextScenery;  }  return(0L);}void CheckChangedScenery(SceneryInfoRecPtr scenery){  SceneryInfoRecPtr sc = scenery;  Rect box, dRect;  while (sc) {    box = sc-&gt;sceneryWorld-&gt;portRect;    if (sc-&gt;scrollTicks) {      if (sc-&gt;nextTickCount &lt;= TickCount()) {        sc-&gt;scrollOffset.v += sc-&gt;autoScrollAmount.v;        sc-&gt;scrollOffset.h += sc-&gt;autoScrollAmount.h;        sc-&gt;nextTickCount = TickCount() + sc-&gt;scrollTicks;        sc-&gt;changed = true;        Sprite_Mgr_Globals-&gt;redoCheck = true;        if (sc-&gt;scrollOffset.v &gt;= box.bottom)          sc-&gt;scrollOffset.v = 0;        if (sc-&gt;scrollOffset.h &gt;= box.right)          sc-&gt;scrollOffset.h = 0;      // wrap around...      }    }    if (sc-&gt;changed &amp;&amp; (sc-&gt;hidden == false)) {            dRect = sc-&gt;animationRect;      MarkSpriteInRect(&amp;dRect, Sprite_Mgr_Globals-&gt;backSprites);      MarkSpriteInRect(&amp;dRect, Sprite_Mgr_Globals-&gt;normSprites);      MarkSpriteInRect(&amp;dRect, Sprite_Mgr_Globals-&gt;foreSprites);      MarkSceneryInRect(&amp;dRect, Sprite_Mgr_Globals-&gt;foregrounds);      MarkSceneryInRect(&amp;dRect, Sprite_Mgr_Globals-&gt;backgrounds);    }    sc = (SceneryInfoRecPtr) sc-&gt;nextScenery;  }}void CheckChangedSprite(SpriteInfoRecPtr sprite){  SpriteInfoRecPtr p = sprite;  Rect dRect;  while (p) {    if (p-&gt;tickWait) {      if (p-&gt;lastTick &lt;= TickCount()) {        p-&gt;currentFace++;        if (p-&gt;currentFace &gt; p-&gt;faces)          p-&gt;currentFace = 1;        p-&gt;lastTick = TickCount() + p-&gt;tickWait;        p-&gt;changed = true;        Sprite_Mgr_Globals-&gt;redoCheck = true;      }    }    if (p-&gt;changed &amp;&amp; (p-&gt;hidden == false)) {      dRect = p-&gt;animationRect;      MarkSceneryInRect(&amp;dRect, Sprite_Mgr_Globals-&gt;backgrounds);      MarkSceneryInRect(&amp;dRect, Sprite_Mgr_Globals-&gt;foregrounds);      MarkSpriteInRect(&amp;dRect, Sprite_Mgr_Globals-&gt;backSprites);      MarkSpriteInRect(&amp;dRect, Sprite_Mgr_Globals-&gt;normSprites);      MarkSpriteInRect(&amp;dRect, Sprite_Mgr_Globals-&gt;foreSprites);      if (p-&gt;oldAnimationRect.right != 0) {        dRect = p-&gt;oldAnimationRect;        MarkSceneryInRect(&amp;dRect, Sprite_Mgr_Globals-&gt;backgrounds);        MarkSceneryInRect(&amp;dRect, Sprite_Mgr_Globals-&gt;foregrounds);        MarkSpriteInRect(&amp;dRect, Sprite_Mgr_Globals-&gt;backSprites);        MarkSpriteInRect(&amp;dRect, Sprite_Mgr_Globals-&gt;normSprites);        MarkSpriteInRect(&amp;dRect, Sprite_Mgr_Globals-&gt;foreSprites);        p-&gt;oldAnimationRect.right = 0;      }    }    p = (SpriteInfoRecPtr) p-&gt;nextSprite;  }}void UpdateScenery(SceneryInfoRecPtr scenery){  SceneryInfoRecPtr sc = scenery;  Rect sRect, dRect;  WindowPtr g1, g2;  short h, v;  Boolean fits;  while (sc) {    if (sc-&gt;changed &amp;&amp; (sc-&gt;hidden == false)) {      sc-&gt;changed = false;      fits = true;      Sprite_Mgr_Globals-&gt;changed = true;            sRect = sc-&gt;sceneryRect;      dRect = sc-&gt;animationRect;      if (Sprite_Mgr_Globals-&gt;updateRects &lt; kMaxUR) {        Sprite_Mgr_Globals-&gt;changedRect[Sprite_Mgr_Globals-&gt;updateRects] = dRect;        Sprite_Mgr_Globals-&gt;updateRects++;      }      v = dRect.bottom - dRect.top;      h = dRect.right - dRect.left;      if (sRect.right &gt; h)         // is destination smaller ?        sRect.right = sRect.left + h;  // make source smaller      if (sRect.bottom &gt; v)        sRect.bottom = sRect.top + v;            sRect.top += sc-&gt;scrollOffset.v;      sRect.bottom += sc-&gt;scrollOffset.v;    // add scroll offsets      sRect.left += sc-&gt;scrollOffset.h;      sRect.right += sc-&gt;scrollOffset.h;      g1 = (GrafPtr) sc-&gt;sceneryWorld;      g2 = (GrafPtr) Sprite_Mgr_Globals-&gt;animationGWorld;            if ((sRect.bottom - sRect.top) &lt; v)        fits = false;      if ((sRect.right - sRect.left) &lt; h)        fits = false;      if (fits) {        CopyBits(&amp;(g1-&gt;portBits), &amp;(g2-&gt;portBits), &amp;sRect, &amp;dRect, sc-&gt;copyMode, 0L);      }      else {      // source has scrolled too much, so compensate        h -= sRect.right - sRect.left;        v -= sRect.bottom - sRect.top;    // get difference                dRect.right -= h;  // clip to area we already have        dRect.bottom -= v;        sRect.right -= h;        sRect.bottom -= v;        CopyBits(&amp;(g1-&gt;portBits), &amp;(g2-&gt;portBits), &amp;sRect, &amp;dRect, sc-&gt;copyMode, 0L);                if (h) {          dRect.right += h;  // now get residue at right          dRect.left = dRect.right - h;          sRect.left = sc-&gt;sceneryRect.left;          sRect.right = sRect.left + h;          CopyBits(&amp;(g1-&gt;portBits), &amp;(g2-&gt;portBits), &amp;sRect, &amp;dRect, sc-&gt;copyMode, 0L);        }        if (v) {          dRect.bottom += v;  // now get residue at bottom          dRect.top = dRect.bottom - v;          sRect.top = sc-&gt;sceneryRect.top;          sRect.bottom = sRect.top + v;          CopyBits(&amp;(g1-&gt;portBits), &amp;(g2-&gt;portBits), &amp;sRect, &amp;dRect, sc-&gt;copyMode, 0L);        }      }    }    sc = (SceneryInfoRecPtr) sc-&gt;nextScenery;  }}void UpdateSprite(SpriteInfoRecPtr sprite){  SpriteInfoRecPtr p = sprite;  Rect sRect, dRect;  WindowPtr g1, g2;  while (p) {    if (p-&gt;changed &amp;&amp; (p-&gt;hidden == false)) {      p-&gt;changed = false;      Sprite_Mgr_Globals-&gt;changed = true;            sRect = p-&gt;spriteRect;      sRect.left = sRect.right * (p-&gt;currentFace - 1);  // get the right face...      sRect.right *= p-&gt;currentFace;      dRect = p-&gt;animationRect;      if (Sprite_Mgr_Globals-&gt;updateRects &lt; kMaxUR) {        Sprite_Mgr_Globals-&gt;changedRect[Sprite_Mgr_Globals-&gt;updateRects] = dRect;        Sprite_Mgr_Globals-&gt;updateRects++;      }      g1 = (GrafPtr) p-&gt;spriteWorld;      g2 = (GrafPtr) Sprite_Mgr_Globals-&gt;animationGWorld;      CopyBits(&amp;(g1-&gt;portBits), &amp;(g2-&gt;portBits), &amp;sRect, &amp;dRect, p-&gt;copyMode, 0L);    }    p = (SpriteInfoRecPtr) p-&gt;nextSprite;  }}void MarkSceneryInRect(Rect *box, SceneryInfoRecPtr scenery){  SceneryInfoRecPtr sc;  Rect sRect;  Boolean dirty;  Point pixel;  sc = scenery;  while (sc) {    if (sc-&gt;changed == false) {      dirty = false;      sRect = sc-&gt;animationRect;            pixel.h = sRect.left;      pixel.v = sRect.top;      if (SMgrPtInRect(pixel, box))        dirty = true;      if (!dirty) {        pixel.h = sRect.left;        pixel.v = sRect.bottom;        if (SMgrPtInRect(pixel, box))          dirty = true;      }      if (!dirty) {        pixel.h = sRect.right;        pixel.v = sRect.bottom;        if (SMgrPtInRect(pixel, box))          dirty = true;      }      if (!dirty) {        pixel.h = sRect.right;        pixel.v = sRect.top;        if (SMgrPtInRect(pixel, box))          dirty = true;      }      if (!dirty) {        if (RectIntersect(&amp;sRect, box))          dirty = true;      }      if (dirty) {        sc-&gt;changed = true;        Sprite_Mgr_Globals-&gt;redoCheck = true;      }    }    sc = (SceneryInfoRecPtr) sc-&gt;nextScenery;  }}void MarkSpriteInRect(Rect *box, SpriteInfoRecPtr sprite){  SpriteInfoRecPtr p = sprite;  Rect sRect;  Boolean dirty;  Point pixel;  while (p) {    if (p-&gt;changed == false) {      dirty = false;      sRect = p-&gt;animationRect;      pixel.h = sRect.left;      pixel.v = sRect.top;      if (SMgrPtInRect(pixel, box))        dirty = true;      if (!dirty) {        pixel.h = sRect.left;        pixel.v = sRect.bottom;        if (SMgrPtInRect(pixel, box))          dirty = true;      }      if (!dirty) {        pixel.h = sRect.right;        pixel.v = sRect.bottom;        if (SMgrPtInRect(pixel, box))          dirty = true;      }      if (!dirty) {        pixel.h = sRect.right;        pixel.v = sRect.top;        if (SMgrPtInRect(pixel, box))          dirty = true;      }      if (!dirty) {        if (RectIntersect(&amp;sRect, box))          dirty = true;      }      if (dirty) {        p-&gt;changed = true;        Sprite_Mgr_Globals-&gt;redoCheck = true;      }    }    p = (SpriteInfoRecPtr) p-&gt;nextSprite;  }}void CopyGToScreen(void){  short id;  SpriteInfoRecPtr p = 0L;  SceneryInfoRecPtr sc = 0L;  Boolean done = false;  GrafPtr g1, g2;  Rect sRect, dRect;  short mode;    DebugStr(&quot;\pSet ID?&quot;);  id = 0;  p = FindSprite(id);  if (!p) {    sc = Sprite_Mgr_Globals-&gt;backgrounds;    while (sc &amp;&amp; !done) {      if (sc-&gt;id == id)        done = true;      else        sc = (SceneryInfoRecPtr) sc-&gt;nextScenery;    }    if (!sc) {      sc = Sprite_Mgr_Globals-&gt;foregrounds;      while (sc &amp;&amp; !done) {        if (sc-&gt;id == id)          done = true;        else          sc = (SceneryInfoRecPtr) sc-&gt;nextScenery;      }    }    if (!done)      return;  }  if (p) {    g1 = (GrafPtr) p-&gt;spriteWorld;    dRect = sRect = p-&gt;spriteRect;    mode = p-&gt;copyMode;  }  else {    g1 = (GrafPtr) sc-&gt;sceneryWorld;    dRect = sRect = sc-&gt;sceneryWorld-&gt;portRect;    mode = sc-&gt;copyMode;  }  g2 = (GrafPtr) Sprite_Mgr_Globals-&gt;animationWindow;  CopyBits(&amp;(g1-&gt;portBits), &amp;(g2-&gt;portBits), &amp;sRect, &amp;dRect, mode, 0L);}Boolean SMgrPtInRect(Point pixel, Rect *box){  if (pixel.h &lt; box-&gt;left)    return(false);  if (pixel.h &gt; box-&gt;right)    return(false);  if (pixel.v &lt; box-&gt;top)    return(false);  if (pixel.v &gt; box-&gt;bottom)    return(false);  return(true);}Boolean RectIntersect(Rect *r, Rect *box){  Rect inter; /* register short d;    d = 0;  if ((r-&gt;left &gt; box-&gt;left) &amp;&amp; (r-&gt;left &lt; box-&gt;right))    d = r-&gt;left;  if ((box-&gt;left &gt; r-&gt;left) &amp;&amp; (box-&gt;left &lt; r-&gt;right))    d = box-&gt;left;  if (d == 0)    return(false);    d = 0;  if ((r-&gt;top &gt; box-&gt;top) &amp;&amp; (r-&gt;top &lt; box-&gt;bottom))    d = r-&gt;top;  if ((box-&gt;top &gt; r-&gt;top) &amp;&amp; (box-&gt;top &lt; r-&gt;bottom))    d = box-&gt;top;  if (d == 0)    return(false);    d = 0;  if ((r-&gt;right &lt; box-&gt;right) &amp;&amp; (r-&gt;right &gt; box-&gt;left))    d = r-&gt;right;  if ((box-&gt;right &lt; r-&gt;right) &amp;&amp; (box-&gt;right &gt; r-&gt;left))    d = box-&gt;right;  if (d == 0)    return(false);    d = 0;  if ((r-&gt;bottom &lt; box-&gt;bottom) &amp;&amp; (r-&gt;bottom &gt; box-&gt;top))    d = r-&gt;bottom;  if ((box-&gt;bottom &lt; r-&gt;bottom) &amp;&amp; (box-&gt;bottom &gt; r-&gt;top))    d = box-&gt;bottom;  if (d == 0)    return(false); */    if (SectRect(r, box, &amp;inter))    // make my own    return(true);  return(false);}</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/Anima/listing3.html%3Fid%3DDTS10000065-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/Anima/listing3.html%3Fid%3DDTS10000065-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/Anima/listing3.html%3Fid%3DDTS10000065-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>