<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>GLSL Showpiece Lite - /GLSLShowpiece Lite/Viewer/Sources/Exhibit.m</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/GraphicsImaging/index.html">Graphics & Imaging</a> &gt; <a href="../../samplecode/GraphicsImaging/idxOpenGL-date.html">OpenGL</a> &gt; <A HREF="javascript:location.replace('index.html');">GLSL Showpiece Lite</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->


	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">GLSL Showpiece Lite</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/GLSLShowpiece Lite/Viewer/Sources/Exhibit.m</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/GLSLShowpiece Lite/Exhibits/3Dlabs-license.txt</option>
<option value="listing2.html">/GLSLShowpiece Lite/Exhibits/ATI-License.txt</option>
<option value="listing3.html">/GLSLShowpiece Lite/Exhibits/Cloud1/Cloud1.h</option>
<option value="listing4.html">/GLSLShowpiece Lite/Exhibits/Cloud1/Cloud1.m</option>
<option value="listing5.html">/GLSLShowpiece Lite/Exhibits/Cloud2/Cloud2.h</option>
<option value="listing6.html">/GLSLShowpiece Lite/Exhibits/Cloud2/Cloud2.m</option>
<option value="listing7.html">/GLSLShowpiece Lite/Exhibits/Earth/Earth.h</option>
<option value="listing8.html">/GLSLShowpiece Lite/Exhibits/Earth/Earth.m</option>
<option value="listing9.html">/GLSLShowpiece Lite/Exhibits/EnvMap/EnvMap.h</option>
<option value="listing10.html">/GLSLShowpiece Lite/Exhibits/EnvMap/EnvMap.m</option>
<option value="listing11.html">/GLSLShowpiece Lite/Exhibits/Eroded/Eroded.h</option>
<option value="listing12.html">/GLSLShowpiece Lite/Exhibits/Eroded/Eroded.m</option>
<option value="listing13.html">/GLSLShowpiece Lite/Exhibits/Fire/Fire.h</option>
<option value="listing14.html">/GLSLShowpiece Lite/Exhibits/Fire/Fire.m</option>
<option value="listing15.html">/GLSLShowpiece Lite/Exhibits/Fur/Fur.h</option>
<option value="listing16.html">/GLSLShowpiece Lite/Exhibits/Fur/Fur.m</option>
<option value="listing17.html">/GLSLShowpiece Lite/Exhibits/Glass/Glass.h</option>
<option value="listing18.html">/GLSLShowpiece Lite/Exhibits/Glass/Glass.m</option>
<option value="listing19.html">/GLSLShowpiece Lite/Exhibits/Gooch/Gooch.h</option>
<option value="listing20.html">/GLSLShowpiece Lite/Exhibits/Gooch/Gooch.m</option>
<option value="listing21.html">/GLSLShowpiece Lite/Exhibits/Granite/Granite.h</option>
<option value="listing22.html">/GLSLShowpiece Lite/Exhibits/Granite/Granite.m</option>
<option value="listing23.html">/GLSLShowpiece Lite/Exhibits/Inferno/Inferno.h</option>
<option value="listing24.html">/GLSLShowpiece Lite/Exhibits/Inferno/Inferno.m</option>
<option value="listing25.html">/GLSLShowpiece Lite/Exhibits/LightworkDesign-license.txt</option>
<option value="listing26.html">/GLSLShowpiece Lite/Exhibits/Marble/Marble.h</option>
<option value="listing27.html">/GLSLShowpiece Lite/Exhibits/Marble/Marble.m</option>
<option value="listing28.html">/GLSLShowpiece Lite/Exhibits/Plasma/Plasma.h</option>
<option value="listing29.html">/GLSLShowpiece Lite/Exhibits/Plasma/Plasma.m</option>
<option value="listing30.html">/GLSLShowpiece Lite/Exhibits/Toon/Toon.h</option>
<option value="listing31.html">/GLSLShowpiece Lite/Exhibits/Toon/Toon.m</option>
<option value="listing32.html">/GLSLShowpiece Lite/Exhibits/Toyball/Toyball.h</option>
<option value="listing33.html">/GLSLShowpiece Lite/Exhibits/Toyball/Toyball.m</option>
<option value="listing34.html">/GLSLShowpiece Lite/Exhibits/VertexNoise/VertexNoise.h</option>
<option value="listing35.html">/GLSLShowpiece Lite/Exhibits/VertexNoise/VertexNoise.m</option>
<option value="listing36.html">/GLSLShowpiece Lite/Exhibits/Wobble/Wobble.h</option>
<option value="listing37.html">/GLSLShowpiece Lite/Exhibits/Wobble/Wobble.m</option>
<option value="listing38.html">/GLSLShowpiece Lite/Exhibits/Wood1/Wood1.h</option>
<option value="listing39.html">/GLSLShowpiece Lite/Exhibits/Wood1/Wood1.m</option>
<option value="listing40.html">/GLSLShowpiece Lite/Exhibits/Wood2/Wood2.h</option>
<option value="listing41.html">/GLSLShowpiece Lite/Exhibits/Wood2/Wood2.m</option>
<option value="listing42.html">/GLSLShowpiece Lite/Exhibits/WoodShader/WoodShader.h</option>
<option value="listing43.html">/GLSLShowpiece Lite/Exhibits/WoodShader/WoodShader.m</option>
<option value="listing44.html">/GLSLShowpiece Lite/Extras/Noise3DTexture/Noise3DTexture.cpp</option>
<option value="listing45.html">/GLSLShowpiece Lite/Extras/Noise3DTexture/Noise3DTexture.h</option>
<option value="listing46.html">/GLSLShowpiece Lite/Models/Bunny/Bunny.c</option>
<option value="listing47.html">/GLSLShowpiece Lite/Models/Bunny/Bunny.h</option>
<option value="listing48.html">/GLSLShowpiece Lite/Models/Models/Models.h</option>
<option value="listing49.html">/GLSLShowpiece Lite/Models/Models/Models.m</option>
<option value="listing50.html">/GLSLShowpiece Lite/Models/Teapot/Teapot.c</option>
<option value="listing51.html">/GLSLShowpiece Lite/Models/Teapot/Teapot.h</option>
<option value="listing52.html">/GLSLShowpiece Lite/Surfaces/Constants/GeometryConstants.h</option>
<option value="listing53.html">/GLSLShowpiece Lite/Surfaces/Klein Surface/Headers/KleinSurface.h</option>
<option value="listing54.html">/GLSLShowpiece Lite/Surfaces/Klein Surface/Sources/KleinSurface.mm</option>
<option value="listing55.html">/GLSLShowpiece Lite/Surfaces/Surfaces/Headers/Surfaces.h</option>
<option value="listing56.html">/GLSLShowpiece Lite/Surfaces/Surfaces/Sources/Surfaces.mm</option>
<option value="listing57.html">/GLSLShowpiece Lite/Utilities/Numerics/Numerics.h</option>
<option value="listing58.html">/GLSLShowpiece Lite/Utilities/Numerics/Numerics.m</option>
<option value="listing59.html">/GLSLShowpiece Lite/Utilities/UniformData/UniformData.h</option>
<option value="listing60.html">/GLSLShowpiece Lite/Utilities/UniformData/UniformData.m</option>
<option value="listing61.html">/GLSLShowpiece Lite/Viewer/Headers/Exhibit.h</option>
<option value="listing62.html">/GLSLShowpiece Lite/Viewer/Headers/OpenGLView.h</option>
<option value="listing63.html">/GLSLShowpiece Lite/Viewer/Headers/UIController.h</option>
<option value="listing64.html">/GLSLShowpiece Lite/Viewer/Sources/Exhibit.m</option>
<option value="listing65.html">/GLSLShowpiece Lite/Viewer/Sources/main.m</option>
<option value="listing66.html">/GLSLShowpiece Lite/Viewer/Sources/OpenGLView.m</option>
<option value="listing67.html">/GLSLShowpiece Lite/Viewer/Sources/UIController.m</option>
<option value="listing68.html">/LessonGuide/GLSLPrereqs HTML/GLSLPrereqs.html</option>
<option value="listing69.html">/LessonGuide/GLSLPrereqs HTML/GLSLPrereqs_files/GLSLPrereqs.css</option>
<option value="listing70.html">/Textures/EarthImages.txt</option>
<option value="listing71.html">/Textures/envmaps.txt</option></select>
				</p>
				</form>
				<p><strong><a href="GLSLShowpieceLite.zip">Download Sample</a></strong> (&#147;GLSLShowpieceLite.zip&#148;, 2.30M)<BR>
<strong><a href="GLSLShowpieceLite.dmg">Download Sample</a></strong> (&#147;GLSLShowpieceLite.dmg&#148;, 2.57M)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">//-------------------------------------------------------------------------
//
//  File: Exhibit.m
//
//  Abstract: GLSL Exhibit base class.  Subclass this to create
//            your own additional exhibits
//        
//  Disclaimer: IMPORTANT:  This Apple software is supplied to you by
//  Apple Inc. (&quot;Apple&quot;) in consideration of your agreement to the
//  following terms, and your use, installation, modification or
//  redistribution of this Apple software constitutes acceptance of these
//  terms.  If you do not agree with these terms, please do not use,
//  install, modify or redistribute this Apple software.
//  
//  In consideration of your agreement to abide by the following terms, and
//  subject to these terms, Apple grants you a personal, non-exclusive
//  license, under Apple's copyrights in this original Apple software (the
//  &quot;Apple Software&quot;), to use, reproduce, modify and redistribute the Apple
//  Software, with or without modifications, in source and/or binary forms;
//  provided that if you redistribute the Apple Software in its entirety and
//  without modifications, you must retain this notice and the following
//  text and disclaimers in all such redistributions of the Apple Software. 
//  Neither the name, trademarks, service marks or logos of Apple Inc.
//  may be used to endorse or promote products derived from the Apple
//  Software without specific prior written permission from Apple.  Except
//  as expressly stated in this notice, no other rights or licenses, express
//  or implied, are granted by Apple herein, including but not limited to
//  any patent rights that may be infringed by your derivative works or by
//  other works in which the Apple Software may be incorporated.
//  
//  The Apple Software is provided by Apple on an &quot;AS IS&quot; basis.  APPLE
//  MAKES NO WARRANTIES, EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION
//  THE IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY AND FITNESS
//  FOR A PARTICULAR PURPOSE, REGARDING THE APPLE SOFTWARE OR ITS USE AND
//  OPERATION ALONE OR IN COMBINATION WITH YOUR PRODUCTS.
//  
//  IN NO EVENT SHALL APPLE BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL
//  OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
//  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
//  INTERRUPTION) ARISING IN ANY WAY OUT OF THE USE, REPRODUCTION,
//  MODIFICATION AND/OR DISTRIBUTION OF THE APPLE SOFTWARE, HOWEVER CAUSED
//  AND WHETHER UNDER THEORY OF CONTRACT, TORT (INCLUDING NEGLIGENCE),
//  STRICT LIABILITY OR OTHERWISE, EVEN IF APPLE HAS BEEN ADVISED OF THE
//  POSSIBILITY OF SUCH DAMAGE.
// 
//  Copyright (c) 2004-2007 Apple Inc., All rights reserved.
//
//-------------------------------------------------------------------------

//------------------------------------------------------------------------

//------------------------------------------------------------------------

#import &lt;Accelerate/Accelerate.h&gt;

//------------------------------------------------------------------------

#import &quot;Exhibit.h&quot;
#import &quot;Numerics.h&quot;

//------------------------------------------------------------------------

//------------------------------------------------------------------------

static const GLint kNoise3DTexSize = 64;

//------------------------------------------------------------------------

//------------------------------------------------------------------------

typedef struct
{
  GLint          imageBorder;
  GLint          imageLevel;
  GLenum         imageTarget;
  GLenum         imageInternalFormat;
  GLenum         imageFormat;
  GLenum         imageType;
  GLuint         imageBitsPerComponent;
  GLuint         imageSamplesPerPixel;
  GLuint         imageStorageSize;
  vImage_Buffer  imageBuffer;
} GLImageBitmap;

//------------------------------------------------------------------------

//------------------------------------------------------------------------

static GLvoid GLImageBitmapMemset( GLImageBitmap *imageBitmap )
{
  imageBitmap-&gt;imageBorder           = 0;
  imageBitmap-&gt;imageLevel            = 0;
  imageBitmap-&gt;imageTarget           = 0;
  imageBitmap-&gt;imageInternalFormat   = 0;
  imageBitmap-&gt;imageFormat           = 0;
  imageBitmap-&gt;imageType             = 0;
  imageBitmap-&gt;imageBitsPerComponent = 0;
  imageBitmap-&gt;imageSamplesPerPixel  = 0;
  imageBitmap-&gt;imageStorageSize      = 0;
  imageBitmap-&gt;imageBuffer.width     = 0;
  imageBitmap-&gt;imageBuffer.height    = 0;
  imageBitmap-&gt;imageBuffer.rowBytes  = 0;
  imageBitmap-&gt;imageBuffer.data      = NULL;
} // GLImageBitmapMemset

//------------------------------------------------------------------------

static BOOL GLImageBitmapMalloc( CGImageRef imageRef, GLImageBitmap *imageBitmap )
{
  BOOL  imageBitmapAllocated = NO;
  
  imageBitmap-&gt;imageBorder           = 0;
  imageBitmap-&gt;imageLevel            = 0;
  imageBitmap-&gt;imageTarget           = GL_TEXTURE_2D;
  imageBitmap-&gt;imageInternalFormat   = GL_RGBA8;
  imageBitmap-&gt;imageFormat           = GL_BGRA;
  imageBitmap-&gt;imageType             = GL_UNSIGNED_INT_8_8_8_8_REV;
  imageBitmap-&gt;imageBitsPerComponent = 8;
  imageBitmap-&gt;imageSamplesPerPixel  = 4;
  imageBitmap-&gt;imageBuffer.width     = CGImageGetWidth( imageRef );
  imageBitmap-&gt;imageBuffer.height    = CGImageGetHeight( imageRef );
  imageBitmap-&gt;imageBuffer.rowBytes  = imageBitmap-&gt;imageBuffer.width * imageBitmap-&gt;imageSamplesPerPixel;
  imageBitmap-&gt;imageStorageSize      = imageBitmap-&gt;imageBuffer.rowBytes * imageBitmap-&gt;imageBuffer.height;
  imageBitmap-&gt;imageBuffer.data      = (GLvoid *)malloc( imageBitmap-&gt;imageStorageSize );
  
  if ( imageBitmap-&gt;imageBuffer.data != NULL )
  {
    imageBitmapAllocated = YES;
  } // if
  else
  {
    GLImageBitmapMemset( imageBitmap );
  } // else
  
  return imageBitmapAllocated;
} // GLImageBitmapMalloc

//------------------------------------------------------------------------

static BOOL GLImageBitmapFree( GLImageBitmap *imageBitmap )
{
  BOOL  imageBitmapFreed = NO;
  
  if ( imageBitmap-&gt;imageBuffer.data != NULL )
  {
    free( imageBitmap-&gt;imageBuffer.data );
    
    imageBitmapFreed = YES;
  } // if
  
  GLImageBitmapMemset( imageBitmap );
  
  return imageBitmapFreed;
} // GLImageBitmapFree

//------------------------------------------------------------------------

static CGContextRef GLImageBitmapContexMalloc( GLImageBitmap *imageBitmap )
{
  CGContextRef     imageContextRef    = NULL;
  CGColorSpaceRef  imageColorSpaceRef = CGColorSpaceCreateWithName( kCGColorSpaceGenericRGB );

  if ( imageColorSpaceRef != NULL )
  {
    CGBitmapInfo  imageBitmapInfo = kCGImageAlphaPremultipliedFirst | kCGBitmapByteOrder32Host;

    imageContextRef = CGBitmapContextCreate( imageBitmap-&gt;imageBuffer.data, 
                         imageBitmap-&gt;imageBuffer.width, 
                         imageBitmap-&gt;imageBuffer.height, 
                         imageBitmap-&gt;imageBitsPerComponent,
                         imageBitmap-&gt;imageBuffer.rowBytes, 
                         imageColorSpaceRef, 
                          imageBitmapInfo 
                         );
    
    CGColorSpaceRelease( imageColorSpaceRef );
  } // if

  return  imageContextRef;
} // GLImageBitmapContexMalloc

//------------------------------------------------------------------------

static BOOL GLImageBitmapVerticalReflect( CGImageRef imageRef, GLImageBitmap *imageBitmap )
{
  BOOL          imageBitmapReflected = NO;
  CGContextRef  imageContextRef      = GLImageBitmapContexMalloc( imageBitmap );

  if ( imageContextRef != NULL )
  {
    CGRect imageRect = { { 0, 0 }, { imageBitmap-&gt;imageBuffer.width, imageBitmap-&gt;imageBuffer.height } };

    CGContextDrawImage( imageContextRef, imageRect, imageRef );
    
    vImageVerticalReflect_ARGB8888( &amp;(imageBitmap-&gt;imageBuffer), &amp;(imageBitmap-&gt;imageBuffer), kvImageNoFlags );

    CGContextRelease( imageContextRef );
    
    imageBitmapReflected = YES;
  } // if bitmap context
  
  return imageBitmapReflected;
} // GLImageBitmapVerticalReflect

//------------------------------------------------------------------------

static BOOL  GLImageBitmapFromImageFile( const NSString *imageFilePath, GLImageBitmap *imageBitmap )
{
  BOOL  imageBitmapVerticalReflected = NO;
  
  if ( imageFilePath != NULL )
  {
    CFURLRef imageURL = CFURLCreateWithFileSystemPath( NULL, (CFStringRef)imageFilePath, kCFURLPOSIXPathStyle, 0);
    
    if ( imageURL != NULL )
    {
      CGImageSourceRef imageSourceRef = CGImageSourceCreateWithURL( imageURL, NULL );
      
      if ( imageSourceRef != NULL )
      {
        CGImageRef imageRef = CGImageSourceCreateImageAtIndex( imageSourceRef, 0, NULL );

        if ( imageRef != NULL )
        {
          if ( GLImageBitmapMalloc( imageRef, imageBitmap ) )
          {
            if ( GLImageBitmapVerticalReflect( imageRef, imageBitmap ) )
            {
              imageBitmapVerticalReflected = YES;
            }
          } // if bitmap data
                      
          CGImageRelease( imageRef );
        } // if image
        
        CFRelease( imageSourceRef );      
      } // if image source
      
      CFRelease( imageURL );  
    } // if url
  } // if path
  
  return  imageBitmapVerticalReflected;
} // GLImageBitmapFromImageFile

//------------------------------------------------------------------------

static inline GLvoid GLImageBitmapGetTexImage2D( GLImageBitmap *imageBitmap )
{
  glTexImage2D( imageBitmap-&gt;imageTarget, 
          imageBitmap-&gt;imageLevel, 
          imageBitmap-&gt;imageInternalFormat, 
          imageBitmap-&gt;imageBuffer.width, 
          imageBitmap-&gt;imageBuffer.height, 
          imageBitmap-&gt;imageBorder, 
          imageBitmap-&gt;imageFormat, 
          imageBitmap-&gt;imageType, 
          imageBitmap-&gt;imageBuffer.data );
} // GLImageBitmapGetTexImage2D

//------------------------------------------------------------------------

//------------------------------------------------------------------------

static void CopyFramebufferToTexture(GLuint textureID)
{
  GLint viewport[4];
  
  glGetIntegerv(GL_VIEWPORT, viewport);
  glBindTexture(GL_TEXTURE_2D, textureID);
  
  glCopyTexImage2D
    (
      GL_TEXTURE_2D, 
      0, 
      GL_RGBA8, 
      viewport[0], 
      viewport[1], 
      NextHighestPowerOf2FromInt(viewport[2]), 
      NextHighestPowerOf2FromInt(viewport[3]), 
      0
    );
} // CopyFramebufferToTexture

//------------------------------------------------------------------------

//------------------------------------------------------------------------

static GLhandleARB LoadShader( GLenum shaderType, const GLcharARB **shader, GLint *shaderCompiled ) 
{
  GLhandleARB shaderObj = NULL;
  
  if ( shader != NULL ) 
  {
    GLint infoLogLength = 0;
    
    shaderObj = glCreateShaderObjectARB( shaderType );
    
    glShaderSourceARB( shaderObj, 1, shader, NULL );
    glCompileShaderARB( shaderObj );
    
    glGetObjectParameterivARB( shaderObj, GL_OBJECT_INFO_LOG_LENGTH_ARB, &amp;infoLogLength );
    
    if ( infoLogLength &gt; 0 ) 
    {
      GLcharARB *infoLog = (GLcharARB *)malloc( infoLogLength );
      
      if ( infoLog != NULL )
      {
        glGetInfoLogARB( shaderObj, infoLogLength, &amp;infoLogLength, infoLog );
        
        NSLog( @&quot;&gt;&gt; Shader compile log:\n%s\n&quot;, infoLog );
        
        free( infoLog );
      } // if
    } // if

    glGetObjectParameterivARB( shaderObj, GL_OBJECT_COMPILE_STATUS_ARB, shaderCompiled );
    
    if ( *shaderCompiled == 0 )
    {
      NSLog( @&quot;&gt;&gt; Failed to compile shader %s\n&quot;, shader );
    } // if
  } // if
  else 
  {
    *shaderCompiled = 1;
  } // else
  
  return shaderObj;
} // LoadShader

//------------------------------------------------------------------------

static void LinkProgram( GLhandleARB program, GLint *program_linked ) 
{
  GLint  infoLogLength = 0;
  
  glLinkProgramARB(program);
  
  glGetObjectParameterivARB( program, GL_OBJECT_INFO_LOG_LENGTH_ARB, &amp;infoLogLength );
  
  if ( infoLogLength &gt;  0) 
  {
    GLcharARB *infoLog = malloc( infoLogLength );
    
    if ( infoLog != NULL )
    {
      glGetInfoLogARB( program, infoLogLength, &amp;infoLogLength, infoLog );
      
      NSLog( @&quot;&gt;&gt; Program link log:\n%s\n&quot;, infoLog );
      
      free( infoLog );
    } // if
  } // if
  
  glGetObjectParameterivARB( program, GL_OBJECT_LINK_STATUS_ARB, program_linked );
  
  if ( *program_linked == 0 )
  {
    NSLog( @&quot;&gt;&gt; Failed to link program %d\n&quot;, (int)program );
  } // if
} // LinkProgram

//------------------------------------------------------------------------

//------------------------------------------------------------------------

@implementation OpenGLExhibit

//------------------------------------------------------------------------

- (id) init
{
  [super init];
  
  appBundle = [NSBundle mainBundle];
  
  gpuProcessingInit = NO;
  programObject     = NULL;

  return self;
} // init

//------------------------------------------------------------------------

- (void) initLazy
{
  // Subclass should put initialisation code that can be performed
  // lazily (on first frame render) here
  
  initialised = TRUE;
} // initLazy

//------------------------------------------------------------------------

- (void) dealloc
{
  [super dealloc];
} // dealloc

//------------------------------------------------------------------------

- (void) awakeFromNib
{
} // awakeFromNib

//------------------------------------------------------------------------

- (NSString *) name
{
  return @&quot;Unnamed OpenGLExhibit&quot;;
} // name

//------------------------------------------------------------------------

- (NSString *) descriptionFilename
{
  return nil;
} // descriptionFilename

//------------------------------------------------------------------------

- (GLint) getUniformLocation:(GLhandleARB)theProgramObject uniformName:(const GLcharARB *)theUniformName
{
  GLint uniformLoacation = glGetUniformLocationARB(theProgramObject, theUniformName);
  
  if (uniformLoacation == -1) 
  {
    NSLog( @&quot;&gt;&gt; WARNING: No such uniform named \&quot;%s\&quot;\n&quot;, theUniformName );
  } // if

  return uniformLoacation;
} // getUniformLocation

//------------------------------------------------------------------------

- (GLcharARB *) getShaderSourceFromResource:(NSString *)theShaderResourceName extension:(NSString *)theExtension
{
  NSString  *shaderTempSource  = [appBundle pathForResource:theShaderResourceName ofType:theExtension];
  GLcharARB *shaderSource      = NULL;
  
  shaderTempSource = [NSString stringWithContentsOfFile:shaderTempSource];
  shaderSource     = (GLcharARB *)[shaderTempSource cStringUsingEncoding:NSASCIIStringEncoding];
  
  return  shaderSource;
} // getShaderSourceFromResource

//------------------------------------------------------------------------

- (void) getFragmentShaderSourceFromResource:(NSString *)theFragmentShaderResourceName
{
  fragmentShaderSource = [self getShaderSourceFromResource:theFragmentShaderResourceName extension:@&quot;frag&quot; ];
} // getFragmentShaderSourceFromResource

//------------------------------------------------------------------------

- (void) getVertexShaderSourceFromResource:(NSString *)theVertexShaderResourceName
{
  vertexShaderSource = [self getShaderSourceFromResource:theVertexShaderResourceName extension:@&quot;vert&quot; ];
} // getVertexShaderSourceFromResource

//------------------------------------------------------------------------

- (GLhandleARB) loadShader:(GLenum)theShaderType shaderSource:(const GLcharARB **)theShaderSource
{
  GLint       shaderCompiled = 0;
  GLhandleARB shaderHandle   = LoadShader(theShaderType, theShaderSource, &amp;shaderCompiled);
  
  if (!shaderCompiled) 
  {
    if (shaderHandle) 
    {
      glDeleteObjectARB(shaderHandle);
      shaderHandle = NULL;
    } // if
  } // if
  
  return shaderHandle;
} // loadShader

//------------------------------------------------------------------------

- (BOOL) newProgramObject:(GLhandleARB)theVertexShader  fragmentShaderHandle:(GLhandleARB)theFragmentShader
{
  GLint programLinked = 0;

  // Create a program object and link both shaders
  
  programObject = glCreateProgramObjectARB();
  
  glAttachObjectARB(programObject, theVertexShader);
  glDeleteObjectARB(theVertexShader);   // Release
  
  glAttachObjectARB(programObject, theFragmentShader);
  glDeleteObjectARB(theFragmentShader); // Release
  
  LinkProgram(programObject, &amp;programLinked);

  if (!programLinked) 
  {
    glDeleteObjectARB(programObject);
    
    programObject = NULL;
    
    return NO;
  } // if
  
  return YES;
} // newProgramObject

//------------------------------------------------------------------------

- (BOOL) setProgramObject
{
  BOOL  programObjectSet = NO;
  
  // Load and compile both shaders
  
  GLhandleARB vertexShader = [self loadShader:GL_VERTEX_SHADER_ARB shaderSource:&amp;vertexShaderSource];
  
  // Ensure vertex shader compiled
  
  if (vertexShader != NULL)
  {
    GLhandleARB fragmentShader = [self loadShader:GL_FRAGMENT_SHADER_ARB shaderSource:&amp;fragmentShaderSource];
    
    // Ensure fragment shader compiled
    
    if (fragmentShader != NULL) 
    {
      // Create a program object and link both shaders
      
      programObjectSet = [self newProgramObject:vertexShader fragmentShaderHandle:fragmentShader];
    } // if
  } // if
  
  return  programObjectSet;
} // setProgramObject

//------------------------------------------------------------------------

- (BOOL) loadShadersFromResource:(NSString *)theShadersName
{
  BOOL  loadedShaders = NO;
  
  // Load vertex and fragment shader
  
  [self getVertexShaderSourceFromResource:theShadersName];
  
  if (vertexShaderSource != NULL)
  {
    [self getFragmentShaderSourceFromResource:theShadersName];

    if (fragmentShaderSource != NULL)
    {
      loadedShaders = [self setProgramObject];
      
      if (!loadedShaders)
      {
        NSLog(@&quot;&gt;&gt; Failed to load GLSL \&quot;%@\&quot; fragment &amp; vertex shaders!\n&quot;, theShadersName);
      } // if
    } // if
  } // if
  
  return  loadedShaders;
} // loadShadersFromResource

//------------------------------------------------------------------------

- (GLuint) loadNoiseTexture
{
  GLuint  textureID;
  
  glGenTextures(1, &amp;textureID);
  
  glBindTexture(GL_TEXTURE_3D, textureID);
  
  CreateNoise3D( kNoise3DTexSize );
  
  return textureID;
} // loadNoiseTexture

//------------------------------------------------------------------------

- (GLuint) loadTextureFromResource:(NSString *)textureResourceName
{
  GLuint     textureID       = 0;
  NSString  *texturePathname = [appBundle pathForResource:textureResourceName ofType: @&quot;jpg&quot;];
  
  if ( texturePathname != nil )
  {
    GLImageBitmap  imageBitmap;
    
    if( GLImageBitmapFromImageFile( texturePathname, &amp;imageBitmap ) )
    {
      glGenTextures(1, &amp;textureID);
      glBindTexture(GL_TEXTURE_2D, textureID);
      
      glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
      glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
      glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
      glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);  

      GLImageBitmapGetTexImage2D( &amp;imageBitmap );
      
      GLImageBitmapFree( &amp;imageBitmap );
    } // if
  } // if
  
  return textureID;
} // loadTextureFromResource

//------------------------------------------------------------------------

- (void) copyFramebufferToTexture:(GLuint)textureID
{
  CopyFramebufferToTexture( textureID );
} // copyFramebufferToTexture

//------------------------------------------------------------------------

- (GLuint) loadFrameBufferTexture:(GLint  *)viewport
{
  GLuint textureID;
  
  glGenTextures(1, &amp;textureID);
  glBindTexture(GL_TEXTURE_2D, textureID);
  
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
  glGetIntegerv(GL_VIEWPORT,viewport);
  
  CopyFramebufferToTexture(textureID);
  
  return textureID;
} // loadFrameBufferTexture

//------------------------------------------------------------------------

- (void) renderFrame
{
  if (!initialised)
  {
    [self initLazy];
  } // if
} // renderFrame

//------------------------------------------------------------------------

- (BOOL) gpuProcessingShaders:(BOOL)logResults
{
  GLint          fragmentGPUProcessing = 0;
  GLint          vertexGPUProcessing   = 0;
  BOOL           gpuProcessedShaders   = NO;
  CGLContextObj  currentCGContext      = CGLGetCurrentContext();
  
  CGLGetParameter( currentCGContext, kCGLCPGPUFragmentProcessing, &amp;fragmentGPUProcessing );
  CGLGetParameter( currentCGContext,   kCGLCPGPUVertexProcessing, &amp;vertexGPUProcessing   );

  if ( logResults )
  {
    NSLog(@&quot;&gt;&gt; Fragment Processing = %d, Vertex Processing = %d\n&quot;, fragmentGPUProcessing, vertexGPUProcessing );
  } //if
  
  gpuProcessedShaders = ( fragmentGPUProcessing &amp;&amp; vertexGPUProcessing ) ? YES : NO;
  
  return  gpuProcessedShaders;
} // gpuProcessingShaders

//------------------------------------------------------------------------

- (BOOL) isGPUProcessingShaders
{
  return [self gpuProcessingShaders:NO];
} // isGPUProcessingShaders

//------------------------------------------------------------------------

- (BOOL) isGPUProcessingShadersLogResults
{
  return [self gpuProcessingShaders:YES];
} // isGPUProcessingShaders

//------------------------------------------------------------------------

- (BOOL) reflect
{
  if( !gpuProcessingInit )
  {
    // Check if this will fall back to software rasterization or
    // software vertex processing and don't reflect if it is.

    gpuProcessingInit = YES;

    glPushAttrib(GL_VIEWPORT_BIT);
    
      glViewport(0,0,0,0);
      
      glPushMatrix();
      
        [self renderFrame];
      
      glPopMatrix();
      
      gpuProcessing = [self gpuProcessingShaders:NO];
    
    glPopAttrib();
  } // if

  return gpuProcessing;
} // reflect

//------------------------------------------------------------------------

@end

//------------------------------------------------------------------------

//------------------------------------------------------------------------
</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/GLSLShowpieceLite/listing64.html%3Fid%3DDTS10004295-1.1&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/GLSLShowpieceLite/listing64.html%3Fid%3DDTS10004295-1.1&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/GLSLShowpieceLite/listing64.html%3Fid%3DDTS10004295-1.1&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>