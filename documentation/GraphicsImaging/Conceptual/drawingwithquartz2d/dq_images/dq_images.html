<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>Quartz 2D Programming Guide: Bitmap Images and Image Masks</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Bitmap Images and Image Masks"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP30001066-CH212" title="Bitmap Images and Image Masks"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../index.html#//apple_ref/doc/uid/TP30000440-TP30000424" target="_top">Graphics &amp; Imaging</a> &gt; <a href="../../../Quartz-date.html#//apple_ref/doc/uid/TP30000440-TP30000424-TP30000559" target="_top">Quartz</a> &gt; <a href="../dq_intro/dq_intro.html#//apple_ref/doc/uid/TP30001066-CH201-TPXREF101">Quartz 2D Programming Guide</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../dq_data_mgr/dq_data_mgr.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../dq_layers/dq_layers.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP30001066-CH212-TPXREF101" title="Bitmap Images and Image Masks"></a><h1>Bitmap Images and Image Masks</h1><p>Bitmap images and image masks are like any drawing primitive in Quartz. Both images and image masks in Quartz are represented by the <code>CGImageRef</code> data type. As you’ll see later in this chapter, there are a variety of functions that you can use to create an image. Some of them require a data provider or an image source to supply bitmap data. Other functions create an image from an existing image either by copying the image or by applying an operation to the image. No matter how you create a bitmap image in Quartz, you can draw the image to any flavor of graphics context. Keep in mind that a bitmap image is an array of bits at a specific resolution. If you draw a bitmap image to a resolution-independent graphics context (such as a PDF graphics context) the bitmap is limited by the resolution at which you created it.</p><p>There is one way to create a Quartz image mask—by calling the function <code>CGImageMaskCreate</code>. You’ll see how to create one in <span class="content_text"><a href="dq_images.html#//apple_ref/doc/uid/TP30001066-CH212-CJBDIJEE">“Creating an Image Mask.”</a></span> Applying an image mask is not the only way to mask drawing. The sections <span class="content_text"><a href="dq_images.html#//apple_ref/doc/uid/TP30001066-CH212-CJBHCADE">“Masking an Image With Color,”</a></span> <span class="content_text"><a href="dq_images.html#//apple_ref/doc/uid/TP30001066-CH212-CJBHIJEB">“Masking an Image With an Image Mask,”</a></span> and <span class="content_text"><a href="dq_images.html#//apple_ref/doc/uid/TP30001066-CH212-CJBHDDBE">“Masking an Image by Clipping the Context”</a></span> discuss all the masking methods available in Quartz.</p>
<!-- This template is being used for both PDF and HTML. -->

    
    <h4>In this section:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="dq_images.html#//apple_ref/doc/uid/TP30001066-CH212-DontLinkElementID_5">About Bitmap Images and Image Masks</a>
				
			<br/>
			
        
			
			
				<a href="dq_images.html#//apple_ref/doc/uid/TP30001066-CH212-BBCJBICF">Bitmap Image Information</a>
				
			<br/>
			
        
			
			
				<a href="dq_images.html#//apple_ref/doc/uid/TP30001066-CH212-CJBBGCII">Creating Images</a>
				
			<br/>
			
        
			
			
				<a href="dq_images.html#//apple_ref/doc/uid/TP30001066-CH212-CJBDIJEE">Creating an Image Mask</a>
				
			<br/>
			
        
			
			
				<a href="dq_images.html#//apple_ref/doc/uid/TP30001066-CH212-CJBHBCGB">Masking Images</a>
				
			<br/>
			
        
			
			
				<a href="dq_images.html#//apple_ref/doc/uid/TP30001066-CH212-CJBIJEFG">Using Blend Modes With Images</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP30001066-CH212-DontLinkElementID_5" title="About Bitmap Images and Image Masks"></a><h2>About Bitmap Images and Image Masks</h2><p>A <strong>bitmap image</strong> (or sampled image) is an array of pixels (or samples). Each pixel represents a single point in the image. JPEG, TIFF, and PNG graphics files are examples of bitmap images. In Mac OS X, icons are bitmap images. Bitmap images are restricted to rectangular shapes. But with the use of alpha, they can appear to take on a variety of shapes and can be rotated and clipped, as shown in <span class="content_text">Figure 11-1</span>.</p><br/><div><a name="//apple_ref/doc/uid/TP30001066-CH212-BBCECIJG" title="Figure 11-1Bitmap images"></a><p><strong>Figure 11-1&nbsp;&nbsp;</strong>Bitmap images</p><img src = "../Art/images.gif" alt = "Bitmap images" width="306" height="270"></div><br/><p>Each sample in a bitmap contains one or more color components in a specified color space, plus one additional component that specifies the alpha value to indicate transparency. Each component can be from 1 to as many as 32 bits. Mac OS X v10.4 adds support for 128-bit floating-point components. ColorSync provides color space support for bitmap images.</p><p>Quartz also supports <strong>image masks</strong>. An image mask is a bitmap that specifies an area to paint, but not the color. In effect, an image mask acts as a stencil to specify where to place color on the page. Quartz uses the current fill color to paint an image mask. An image mask can have a depth of 1 to 8 bits.</p><a name="//apple_ref/doc/uid/TP30001066-CH212-BBCJBICF" title="Bitmap Image Information"></a><h2>Bitmap Image Information</h2><p>Quartz supports a wide variety of image formats and has built-in knowledge of several popular formats. In Mac OS X v10.1, Quartz provides a convenience function for working with bitmap images that use JPEG-encoded data. A similar function is available for working with PNG-encoded data starting with Mac OS X v10.2. Mac OS X v10.4 supports many formats, including JPEG, PNG, TIFF, GIF, and JPEG2000. Other bitmap image formats or proprietary formats require that you specify details about the image format to Quartz in order to ensure that images are interpreted correctly.</p><p>This section describes the information associated with a bitmap image. When you create and work with Quartz images (which use the <code>CGImageRef</code> data type), you’ll see that some Quartz image-creation functions require you to specify all this information, while other functions require a subset of this information. What you provide depends on the encoding used for the bitmap data, and whether the bitmap represents an image or an image mask.</p><p>Quartz uses the following information when it creates a bitmap image (<code>CGImageRef</code>):</p><ul class="ul"><li class="li"><p>A bitmap data source, which can be a Quartz data provider or a Quartz image source. <span class="content_text"><a href="../dq_data_mgr/dq_data_mgr.html#//apple_ref/doc/uid/TP30001066-CH216-TPXREF101">“Data Management”</a></span> describes both and discusses the functions that provide a source of bitmap data.</p></li><li class="li"><p>An optional <span class="content_text"><a href="dq_images.html#//apple_ref/doc/uid/TP30001066-CH212-CJBCCJCF">“Decode Array.”</a></span></p></li><li class="li"><p>An interpolation setting, which is a Boolean value that specifies whether Quartz should apply an interpolation algorithm when resizing the image.</p></li><li class="li"><p>A rendering intent that specifies how to map colors that are located within the destination color space of a graphics context. This information is not needed for image masks. See <span class="content_text"><a href="../dq_color/dq_color.html#//apple_ref/doc/uid/TP30001066-CH205-CJBBEEEI">“Setting Rendering Intent”</a></span> for more information.</p></li><li class="li"><p>The image dimensions.</p></li><li class="li"><p><span class="content_text"><a href="dq_images.html#//apple_ref/doc/uid/TP30001066-CH212-CJBECCFG">“Pixel Format,”</a></span> which includes bits per component, bits per pixel, and bytes per row.</p></li><li class="li"><p>For images, <span class="content_text"><a href="dq_images.html#//apple_ref/doc/uid/TP30001066-CH212-CJBHEGIB">“Color Spaces and Bitmap Layout”</a></span> information to describe the location of alpha and whether the bitmap uses floating-point values. Image masks don’t require this information.</p></li></ul><a name="//apple_ref/doc/uid/TP30001066-CH212-CJBCCJCF" title="Decode Array"></a><h3>Decode Array</h3><p>A decode array maps the image color values to other color values, which is useful for such tasks as desaturating an image or inverting the colors. The array contains a pair of numbers for each color component. When Quartz renders the image, it applies a linear transform to map the original component value to a relative number within the designated range appropriate for the destination color space. For example, the decode array for an image in the RGB color space contains six entries, one pair for each red, green, and blue color component.</p><a name="//apple_ref/doc/uid/TP30001066-CH212-CJBECCFG" title="Pixel Format"></a><h3>Pixel Format</h3><p>The pixel format consists of the following information:</p><ul class="spaceabove"><li class="li"><p>Bits per component, which is the number of bits in each individual color component in a pixel. For an image mask, this value is the number of significant masking bits in a source pixel. For example, if the source image is an 8-bit mask, specify 8 bits per component.</p></li><li class="li"><p>Bits per pixel, which is the total number of bits in a source pixel. This value must be at least the number of bits per component times the number of components per pixel.</p></li><li class="li"><p>Bytes per row. The number of bytes per horizontal row in the image.</p></li></ul><a name="//apple_ref/doc/uid/TP30001066-CH212-CJBHEGIB" title="Color Spaces and Bitmap Layout"></a><h3>Color Spaces and Bitmap Layout</h3><p>To ensure that Quartz correctly interprets the bits of each pixel, you must specify:</p><ul class="spaceabove"><li class="li"><p>Whether a bitmap contains an alpha channel. Quartz supports RGB, CMYK, and Gray color spaces. It also supports alpha, or transparency, although alpha information is not available in all bitmap image formats. When it is available, the alpha component can be located in either the most significant bits of a pixel or the least significant bits.</p></li><li class="li"><p>For bitmaps that have an alpha component, whether the color components are already multiplied by the alpha value. <strong>Premultiplied alpha</strong> describes a source color whose components are already multiplied by an alpha value. Premultiplying speeds up the rendering of an image by eliminating an extra multiplication operation per color component. For example, in an RGB color space, rendering an image with premultiplied alpha eliminates three multiplication operations (red times alpha, green times alpha, and blue times alpha) for each pixel in the image.</p></li><li class="li"><p>The data format of the samples—integer or floating-point values. Quartz supports floating-point formats starting in Mac OS X v10.4.</p></li></ul><p>When you create an image using the function <code><a href="../../../Reference/CGImage/Reference/reference.html#//apple_ref/doc/c_ref/CGImageCreate" target="_top">CGImageCreate</a></code>, you supply a <code>bitmapInfo</code> parameter, of type <code>CGImageBitmapInfo</code>, to specify bitmap layout information. The following constants specify the location of the alpha component and whether the color components are premultiplied:</p><ul class="spaceabove"><li class="li"><p><code>kCGImageAlphaLast</code>—the alpha component is stored in the least significant bits of each pixel, for example, RGBA.</p></li><li class="li"><p><code>kCGImageAlphaFirst</code>—the alpha component is stored in the most significant bits of each pixel, for example, ARGB.</p></li><li class="li"><p><code>kCGImageAlphaPremultipliedLast</code>—the alpha component is stored in the least significant bits of each pixel, and the color components have already been multiplied by this alpha value.</p></li><li class="li"><p><code>kCGImageAlphaPremultipliedFirst</code>—the alpha component is stored in the most significant bits of each pixel, and the color components have already been multiplied by this alpha value.</p></li><li class="li"><p><code><a href="../../../Reference/CGImage/Reference/reference.html#//apple_ref/doc/c_ref/kCGImageAlphaNoneSkipLast" target="_top">kCGImageAlphaNoneSkipLast</a></code>—there is no alpha channel. If the total size of the pixel is greater than the space required for the number of color components in the color space, the least significant bits are ignored.</p></li><li class="li"><p><code>kCGImageAlphaNoneSkipFirst</code>—there is no alpha channel. If the total size of the pixel is greater than the space required for the number of color components in the color space, the most significant bits are ignored.</p></li><li class="li"><p><code><a href="../../../Reference/CGImage/Reference/reference.html#//apple_ref/doc/c_ref/kCGImageAlphaNone" target="_top">kCGImageAlphaNone</a></code>—equivalent to <code><a href="../../../Reference/CGImage/Reference/reference.html#//apple_ref/doc/c_ref/kCGImageAlphaNoneSkipLast" target="_top">kCGImageAlphaNoneSkipLast</a></code>.</p></li></ul><p>You use the constant <code>kCGBitmapFloatComponents</code> to indicate a bitmap format that uses floating-point values. For floating-point formats, you logically <code>OR</code> this constant with the appropriate constant from the previous list. For example, for a 128 bits per pixel floating-point format that uses premultiplied alpha, with the alpha located in the least significant bits of each pixel, you supply the following information to Quartz:</p><p><code>kCGImageAlphaPremultipliedLast|kCGBitmapFloatComponents</code></p><p><span class="content_text">Figure 11-2</span> visually depicts how pixels are represented in CMYK and RGB color spaces that use 16- or 32-bit integer formats. The 32-bit integer pixel formats use 8 bits per component. The 16-bit integer format uses 5 bits per component. As of Mac OS X v10.4, Quartz 2D also supports 128-bit floating-point pixel formats that use 32 bits per component. The 128-bit formats are not shown in the figure.</p><br/><div><a name="//apple_ref/doc/uid/TP30001066-CH212-BCIBCJDG" title="Figure 11-216- and 32-bit pixel formats for CMYK and RGB color spaces in Quartz 2D"></a><p><strong>Figure 11-2&nbsp;&nbsp;</strong>16- and 32-bit pixel formats for CMYK and RGB color spaces in Quartz 2D</p><img src = "../Art/colorformatrgba32.gif" alt = "16- and 32-bit pixel formats for CMYK and RGB color spaces in Quartz 2D" width="480" height="356"></div><br/><a name="//apple_ref/doc/uid/TP30001066-CH212-CJBBGCII" title="Creating Images"></a><h2>Creating Images</h2><p>Quartz provides a variety of functions that create a CGImage object from a bitmap image. The choice of image creation function depends on the source of the image data and the version of the operating system your software needs to run in. The most flexible function is <code>CGImageCreate</code>. It creates an image from any kind of bitmap data and the function runs in all versions of Mac OS X. However, it’s the most complex function to use because you must specify all bitmap information. To use this function, you need to be familiar with the topics discussed in <span class="content_text"><a href="dq_images.html#//apple_ref/doc/uid/TP30001066-CH212-BBCJBICF">“Bitmap Image Information.”</a></span></p><p>Each version of the operating system introduces new image creation functions, as you’ll see by looking at <span class="content_text">Table 11-1</span>. If your application runs in Mac OS X v10.4 and later, and you want to create a CGImage object from an image file that uses a standard image format such as PNG or JPEG, the easiest solution is to call the function <code><a href="../../../Reference/CGImageSource/Reference/reference.html#//apple_ref/doc/c_ref/CGImageSourceCreateWithURL" target="_top">CGImageSourceCreateWithURL</a></code> to create an image source and then call the function <code><a href="../../../Reference/CGImageSource/Reference/reference.html#//apple_ref/doc/c_ref/CGImageSourceCreateImageAtIndex" target="_top">CGImageSourceCreateImageAtIndex</a></code> to create an image from the image data at a specific index in the image source. If the original image file contains only one image, then provide <code>0</code> as the index. If the image file format supports files that contain multiple images, you need to supply the index to the appropriate image, keeping in mind that the index values start at <code>0</code>.</p><p>If you’ve drawn content to a bitmap graphics context and want to capture that drawing to a CGImage, call the function <code><a href="../../../Reference/CGBitmapContext/Reference/reference.html#//apple_ref/doc/c_ref/CGBitmapContextCreateImage" target="_top">CGBitmapContextCreateImage</a></code>. This function, like many of the functions in <span class="content_text">Table 11-1</span>, is available only in Mac OS X v10.4. </p><p>Several functions are utilities that operate on existing images, either to make a copy, create a thumbnail, or create an image from a portion of a larger one. Regardless of how you create a CGImage object, you use the function <code><a href="../../../Reference/CGContext/Reference/reference.html#//apple_ref/doc/c_ref/CGContextDrawImage" target="_top">CGContextDrawImage</a></code> to draw the image to any “flavor” of graphics context. Keep in mind that CGImage objects are immutable. When you no longer need a CGImage object, release it by calling the function <code><a href="../../../Reference/CGImage/Reference/reference.html#//apple_ref/doc/c_ref/CGImageRelease" target="_top">CGImageRelease</a></code>.</p><a name="//apple_ref/doc/uid/TP30001066-CH212-CJBJDBEI" title="Table 11-1Functions for creating images"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 11-1&nbsp;&nbsp;</strong>Functions for creating images</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Function</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Description</p></th></tr><tr><td  scope="row"><p><code>CGImageCreate</code></p></td><td ><p>A flexible function for creating an image. You must specify all the bitmap information that is discussed in <span class="content_text"><a href="dq_images.html#//apple_ref/doc/uid/TP30001066-CH212-BBCJBICF">“Bitmap Image Information.”</a></span> Available in Mac OS X v10.0 and later.</p></td></tr><tr><td  scope="row"><p><code>CGImageCreateWithJPEGDataProvider</code></p></td><td ><p>Creates an image from a data provides that supplies JPEG-encoded data. See <span class="content_text"><a href="../dq_data_mgr/dq_data_mgr.html#//apple_ref/doc/uid/TP30001066-CH216-TPXREF101">“Data Management”</a></span> for information on creating a JPEG data provider. Available in Mac OS X v10.1 and later.</p></td></tr><tr><td  scope="row"><p><code>CGImageCreateWithPNGDataProvider</code></p></td><td ><p>Creates an image from a data provider that supplies PNG-encoded data. See <span class="content_text"><a href="../dq_data_mgr/dq_data_mgr.html#//apple_ref/doc/uid/TP30001066-CH216-TPXREF101">“Data Management”</a></span> for information on creating a PNG data provider. Available in Mac OS X v10.2 and later.</p></td></tr><tr><td  scope="row"><p><code>CGImageCreateWithImageInRect</code></p></td><td ><p>Creates an image from the data contained within a subrectangle of an image. Available in Mac OS X v10.4 and later.</p></td></tr><tr><td  scope="row"><p><code>CGImageSourceCreateImageAtIndex</code></p></td><td ><p>Creates an image from an image source. Image sources can contain more than one image. See <span class="content_text"><a href="../dq_data_mgr/dq_data_mgr.html#//apple_ref/doc/uid/TP30001066-CH216-TPXREF101">“Data Management”</a></span> for information on creating an image source. Available in Mac OS X v10.4 and later.</p></td></tr><tr><td  scope="row"><p><code>CGImageSourceCreateThumbnailAtIndex</code></p></td><td ><p>Creates a thumbnail image of an image that is associated with an image source. See <span class="content_text"><a href="../dq_data_mgr/dq_data_mgr.html#//apple_ref/doc/uid/TP30001066-CH216-TPXREF101">“Data Management”</a></span> for information on creating an image source. Available in Mac OS X v10.4 and later.</p></td></tr><tr><td  scope="row"><p><code>CGBitmapContextCreateImage</code></p></td><td ><p>Creates an image by copying the bits from a bitmap graphics context. Available in Mac OS X v10.4 and later.</p></td></tr><tr><td  scope="row"><p><code>CGImageCreateCopy</code></p></td><td ><p>A utility function that creates a copy of an image. Available in Mac OS X v10.4 and later.</p></td></tr><tr><td  scope="row"><p><code>CGImageCreateCopyWithColorSpace</code></p></td><td ><p>A utility function that creates a copy of an image and replaces its colorspace. Available in Mac OS X v10.3 and later.</p></td></tr></table></div><p>The sections that follow discuss how to create:</p><ul class="ul"><li class="li"><p>An image from a JPEG file using a data provider.</p></li><li class="li"><p>A subimage from an existing image.</p></li><li class="li"><p>An image from a bitmap graphics context.</p></li></ul><p>You can consult these sources for additional information:</p><ul class="ul"><li class="li"><p><span class="content_text"><a href="../dq_data_mgr/dq_data_mgr.html#//apple_ref/doc/uid/TP30001066-CH216-TPXREF101">“Data Management”</a></span> discusses data consumers, data providers, image sources, and image destinations, and how to use each to read and write image data.</p></li><li class="li"><p><em><a href="../../../Reference/CGImage/index.html#//apple_ref/doc/uid/TP30000956" target="_top">CGImage Reference</a></em>, <em><a href="../../../Reference/CGImageSource/index.html#//apple_ref/doc/uid/TP40001399" target="_top">CGImageSource Reference</a></em>, and <em><a href="../../../Reference/CGBitmapContext/index.html#//apple_ref/doc/uid/TP30000947" target="_top">CGBitmapContext Reference</a></em> for further information on the functions listed in <span class="content_text">Table 11-1</span> and their parameters.</p></li></ul><a name="//apple_ref/doc/uid/TP30001066-CH212-BCIBABEF" title="Creating an Image From a JPEG File"></a><h3>Creating an Image From a JPEG File</h3><p>The function <code>CGImageCreate</code> creates a CGImage object from bitmap image information that you supply (discussed in <span class="content_text"><a href="dq_images.html#//apple_ref/doc/uid/TP30001066-CH212-BBCJBICF">“Bitmap Image Information”</a></span>). If the bitmap image uses JPEG- or PNG-encoded data, it’s much easier to use the convenience functions <code>CGImageCreateWithJPEGDataProvider</code> or <code>CGImageCreateWithPNGDataProvider</code>. If your code runs in Mac OS X v10.4 and later, you also have the option of creating an image source from a URL using <code>CGImageSourceCreateWithURL</code> and then create an image from the image source by calling the function <code>CGImageSourceCreateImageAtIndex</code>. The image at the URL location can be one of any number of formats, including PNG, TIFF, JPEG, JPEG2000, and GIF.</p><p><span class="content_text">Listing 11-1</span> shows a function that creates a CGImage object with data that is supplied by a JPEG data provider, and then draws the image to a graphics context passed to the function. Quartz uses its knowledge of the JPEG file format to decode the file and create a CGImage object from it. The code in this listing works in Mac OS X v10.1 and later. A detailed explanation for each numbered line of code appears following the listing.</p><a name="//apple_ref/doc/uid/TP30001066-CH212-BBCHICCE" title="Listing 11-1A function that creates a CGImage object from a JPEG file"></a><p class="codesample"><strong>Listing 11-1&nbsp;&nbsp;</strong>A function that creates a CGImage object from a JPEG file</p><div class="codesample"><table><tr><td scope="row"><pre>void MyCreateAndDrawBitmapImage (CGContextRef myContext, <span>// 1</span></pre></td></tr><tr><td scope="row"><pre>                                CGRect myContextRect,<span></span></pre></td></tr><tr><td scope="row"><pre>                                const char *filename);<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    CGImageRef image;<span></span></pre></td></tr><tr><td scope="row"><pre>    CGDataProviderRef provider;<span></span></pre></td></tr><tr><td scope="row"><pre>    CFStringRef path;<span></span></pre></td></tr><tr><td scope="row"><pre>    CFURLRef url;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    path = CFStringCreateWithCString (NULL, filename,<span></span></pre></td></tr><tr><td scope="row"><pre>                        kCFStringEncodingUTF8);<span></span></pre></td></tr><tr><td scope="row"><pre>    url = CFURLCreateWithFileSystemPath (NULL, path, <span>// 2</span></pre></td></tr><tr><td scope="row"><pre>                            kCFURLPOSIXPathStyle, NULL);<span></span></pre></td></tr><tr><td scope="row"><pre>    CFRelease(path);<span></span></pre></td></tr><tr><td scope="row"><pre>    provider = CGDataProviderCreateWithURL (url);<span>// 3</span></pre></td></tr><tr><td scope="row"><pre>    CFRelease (url);<span></span></pre></td></tr><tr><td scope="row"><pre>    image = CGImageCreateWithJPEGDataProvider (provider,<span>// 4</span></pre></td></tr><tr><td scope="row"><pre>                                    NULL,<span></span></pre></td></tr><tr><td scope="row"><pre>                                    true,<span></span></pre></td></tr><tr><td scope="row"><pre>                                    kCGRenderingIntentDefault);<span></span></pre></td></tr><tr><td scope="row"><pre>    CGDataProviderRelease (provider);<span>// 5</span></pre></td></tr><tr><td scope="row"><pre>    CGContextDrawImage (myContext, myContextRect, image);<span>// 6</span></pre></td></tr><tr><td scope="row"><pre>    CGImageRelease (image);<span>// 7</span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>Here’s what the code does:</p><ol class="ol"><li class="li"><p>Takes as parameters a graphics context, the rectangle to draw into, and a filename. </p></li><li class="li"><p>Calls the Core Foundation function for creating a CFURL object that specifies the location of the file to open.</p></li><li class="li"><p>Creates a data provider object from the CFURL object. See <span class="content_text"><a href="../dq_data_mgr/dq_data_mgr.html#//apple_ref/doc/uid/TP30001066-CH216-TPXREF101">“Data Management”</a></span> for information on data providers.</p></li><li class="li"><p>Creates a CGImage object from the data provider. If you don’t need to map color component values to another range, you can pass <code>NULL</code> for the decode array, as in this example. In most cases, you should pass <code>true</code> to turn on interpolation. The constant <code>kCGRenderingIntentDefault</code> specifies that Quartz use the default for the graphics context.</p></li><li class="li"><p>Releases the data provider when it is no longer needed.</p></li><li class="li"><p>Draws the bitmap image to the graphics context supplied, drawing into the area specified by the <code>myContextRect</code> rectangle. </p></li><li class="li"><p>Releases the CGImage object when it is no longer needed.</p></li></ol><a name="//apple_ref/doc/uid/TP30001066-CH212-SW1" title="Creating an Image From Part of a Larger Image"></a><h3>Creating an Image From Part of a Larger Image</h3><p>The function <code>CGImageCreateWithImageInRect</code> lets you create a subimage from an existing Quartz image. <span class="content_text">Figure 11-3</span> illustrates extracting an image that contains the letter “A” from a larger image by supplying a rectangle that specifies the location of the letter “A”. </p><br/><div><a name="//apple_ref/doc/uid/TP30001066-CH212-CJBFCIFG" title="Figure 11-3A subimage created from a larger image"></a><p><strong>Figure 11-3&nbsp;&nbsp;</strong>A subimage created from a larger image</p><img src = "../Art/subimage.gif" alt = "A subimage created from a larger image" width="389" height="148"></div><br/><p>The image returned by the function <code>CGImageCreateWithImageInRect</code> retains a reference to the original image, which means you can release the original image after calling this function.</p><p><span class="content_text">Figure 11-4</span> shows another example of extracting a portion of an image to create another image. In this case, the rooster’s head is extracted from the larger image, and then drawn to a rectangle that’s larger than the subimage, effectively zooming-in on the image. </p><p><span class="content_text">Listing 11-2</span> shows code that creates and then draws the subimage. The rectangle that the function <code>CGContextDrawImage</code> draws the rooster’s head to has dimensions that are twice the dimensions of the extracted subimage. The listing is a code fragment. You’d need to declare the appropriate variables, create the rooster image, and dispose of the rooster image and the rooster head subimage. Because the code is a fragment, it does not show how to create a the graphics context that the image is drawn to. You can use an flavor of graphics context that you’d like. For examples of how to create a graphics context, see <span class="content_text"><a href="../dq_context/dq_context.html#//apple_ref/doc/uid/TP30001066-CH203-TPXREF101">“Graphics Contexts.”</a></span></p><br/><div><a name="//apple_ref/doc/uid/TP30001066-CH212-CJBDEGDI" title="Figure 11-4An image, a subimage taken from it and drawn so it&acirc;&#128;&#153;s enlarged"></a><p><strong>Figure 11-4&nbsp;&nbsp;</strong>An image, a subimage taken from it and drawn so it’s enlarged</p><img src = "../Art/rooster_image_zoom.gif" alt = "An image, a subimage taken from it and drawn so it’s enlarged" width="507" height="179"></div><br/><a name="//apple_ref/doc/uid/TP30001066-CH212-CJBFGBAE" title="Listing 11-2Code that creates a subimage and draws it enlarged"></a><p class="codesample"><strong>Listing 11-2&nbsp;&nbsp;</strong>Code that creates a subimage and draws it enlarged</p><div class="codesample"><table><tr><td scope="row"><pre>myImageArea = CGRectMake (rooster_head_x_origin, rooster_head_y_origin,<span></span></pre></td></tr><tr><td scope="row"><pre>                            myWidth, myHeight);<span></span></pre></td></tr><tr><td scope="row"><pre>mySubimage = CGImageCreateWithImageInRect (myRoosterImage, myImageArea);<span></span></pre></td></tr><tr><td scope="row"><pre>myRect = CGRectMake(0, 0, myWidth*2, myHeight*2);<span></span></pre></td></tr><tr><td scope="row"><pre>CGContextDrawImage(context, myRect, mySubimage);<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP30001066-CH212-SW2" title="Creating an Image From a Bitmap Graphics Context"></a><h3>Creating an Image From a Bitmap Graphics Context</h3><p>To create an image from an exiting bitmap graphics context, you call the function <code>CGBitmapContextCreateImage</code> as follows:</p><div class="codesample"><table><tr><td scope="row"><pre>CGImageRef myImage;<span></span></pre></td></tr><tr><td scope="row"><pre>myImage = CGBitmapContextCreateImage (myBitmapContext);<span></span></pre></td></tr></table></div><p>The CGImage object returned by the function is created by a copy operation. This means that any subsequent changes you make to the bitmap graphics context do not affect the contents of the returned CGImage. In some cases the copy operation actually follows copy-on-write semantics, so that the actual physical copy of the bits occurs only if the underlying data in the bitmap graphics context is modified. You may want to use the resulting image and release it before you perform additional drawing into the bitmap graphics context so that you can avoid the actual physical copy of the data.</p><p>For an example that shows how to create a bitmap graphics context, see<span class="content_text"><a href="../dq_context/dq_context.html#//apple_ref/doc/uid/TP30001066-CH203-CJBHBFFE">“Creating a Bitmap Graphics Context.”</a></span> </p><a name="//apple_ref/doc/uid/TP30001066-CH212-CJBDIJEE" title="Creating an Image Mask"></a><h2>Creating an Image Mask</h2><p>A Quartz bitmap image mask is used the same way an artist uses a silkscreen. A bitmap image mask determines how color is transferred, not which colors are used. Each sample value in the image mask specifies the amount that the current fill color is masked at a specific location. The sample value specifies the opacity of the mask. Larger values represent greater opacity and specify locations where Quartz paints less color. You can think of the sample value as an inverse alpha value. A value of <code>1</code> is transparent and <code>0</code> is opaque.</p><p>Image masks are 1, 2, 4, or 8 bits per component. For a 1-bit mask, a sample value of <code>1</code> specifies sections of the mask that block the current fill color. A sample value of <code>0</code> specifies sections of the mask that show the current fill color of the graphics state when the mask is painted. You can think of a 1-bit mask as black and white; samples either completely block paint or completely allow paint.</p><p>Image masks that have are 2, 4, or 8 bits per component represent grayscale values. Each component maps to a range of <code>0</code> to <code>1</code> using the following formula:</p><p><img src = "../Art/inline_equations.gif" alt = "One over two to the bits per component minus one." width="145" height="41"></p><p>For example, a 4-bit mask has values that range from <code>0</code> to <code>1</code> in increments of <code>1/15</code> . Component values that are <code>0</code> or <code>1</code> represent the extremes—completely block paint and completely allow paint. Values between <code>0</code> and <code>1</code> allow partial painting using the formula <code>1 – MaskSampleValue</code>. For example, if the sample value of an 8-bit mask scales to <code>0.7</code>, color is painted as if it has an alpha value of <code>(1 – 0.7)</code>, which is <code>0.3</code>.</p><p>The function <code>CGImageMaskCreate</code> creates a Quartz image mask from bitmap image information that you supply and that is discussed in <span class="content_text"><a href="dq_images.html#//apple_ref/doc/uid/TP30001066-CH212-BBCJBICF">“Bitmap Image Information.”</a></span> The information you supply to create an image mask is the same as what you supply to create an image, except that you do not supply colorspace information, a bitmap information constant, or a rendering intent, as you can see by looking at the function prototype in <span class="content_text">Listing 11-3</span>. </p><a name="//apple_ref/doc/uid/TP30001066-CH212-CJBGEBCF" title="Listing 11-3The prototype for the function CGImageMaskCreate "></a><p class="codesample"><strong>Listing 11-3&nbsp;&nbsp;</strong>The prototype for the function CGImageMaskCreate </p><div class="codesample"><table><tr><td scope="row"><pre>CGImageRef CGImageMaskCreate (<span></span></pre></td></tr><tr><td scope="row"><pre>        size_t width,<span></span></pre></td></tr><tr><td scope="row"><pre>        size_t height,<span></span></pre></td></tr><tr><td scope="row"><pre>        size_t bitsPerComponent,<span></span></pre></td></tr><tr><td scope="row"><pre>        size_t bitsPerPixel,<span></span></pre></td></tr><tr><td scope="row"><pre>        size_t bytesPerRow,<span></span></pre></td></tr><tr><td scope="row"><pre>        CGDataProviderRef provider,<span></span></pre></td></tr><tr><td scope="row"><pre>        const float decode[],<span></span></pre></td></tr><tr><td scope="row"><pre>        int shouldInterpolate<span></span></pre></td></tr><tr><td scope="row"><pre>);<span></span></pre></td></tr></table></div><p>Quartz image masks provide one way to control where and how Quartz paints color. <span class="content_text"><a href="dq_images.html#//apple_ref/doc/uid/TP30001066-CH212-CJBHBCGB">“Masking Images”</a></span> shows how to use a Quartz image mask to mask an image or to clip a graphics context. The section also shows how to use color and grayscale images to achieve masking effects.</p><a name="//apple_ref/doc/uid/TP30001066-CH212-CJBHBCGB" title="Masking Images"></a><h2>Masking Images</h2><p>Masking techniques can produce many interesting effects by controlling which parts of an image are painted. You can:</p><ul class="ul"><li class="li"><p>Apply an image mask to an image. You can also use an image as a mask to achieve an effect that’s opposite from applying an image mask.</p></li><li class="li"><p>Use color to mask parts of an image, which includes the technique referred to as chroma-key masking.</p></li><li class="li"><p>Clip a graphics context to an image or image mask, which effectively masks an image (or any kind of drawing) when Quartz draws the content to the clipped context. </p></li></ul><p>As you’ll see in the sections that follow, each approach gives a different effect. </p><a name="//apple_ref/doc/uid/TP30001066-CH212-CJBHIJEB" title="Masking an Image With an Image Mask"></a><h3>Masking an Image With an Image Mask</h3><p>The function <code>CGImageCreateWithMask</code> returns the image that’s created by applying an image mask to an image. This function, available in Mac OS X v10.4 and later, takes two parameters:</p><ul class="spaceabove"><li class="li"><p>The image you want to apply the mask to. This image can’t be an image mask or have a masking color (see <span class="content_text"><a href="dq_images.html#//apple_ref/doc/uid/TP30001066-CH212-CJBHCADE">“Masking an Image With Color”</a></span>) associated with it.</p></li><li class="li"><p>An image mask created by calling the function <code>CGImageMaskCreate</code>. It’s possible to provide an image instead of an image mask, but that gives a much different result. See <span class="content_text"><a href="dq_images.html#//apple_ref/doc/uid/TP30001066-CH212-CJBJCJCE">“Masking an Image With an Image.”</a></span></p></li></ul><p>Source samples of an image mask act as an inverse alpha value. An image mask sample value (<code>S</code>):</p><ul class="spaceabove"><li class="li"><p>Equal to <code>1</code> blocks painting the corresponding image sample.</p></li><li class="li"><p>Equal to <code>0</code> allows painting the corresponding image sample at full coverage.</p></li><li class="li"><p>Greater than <code>0</code> and less <code>1</code> allows painting the corresponding image sample at with an alpha value of <code>(1 – S).</code></p></li></ul><p><span class="content_text">Figure 11-5</span> shows an image created with one of the Quartz image-creation functions while <span class="content_text">Figure 11-6</span> shows an image mask created with the function <code><a href="../../../Reference/CGImage/Reference/reference.html#//apple_ref/c/func/CGImageMaskCreate" target="_top">CGImageMaskCreate</a></code>. <span class="content_text"><a href="dq_images.html#//apple_ref/doc/uid/TP30001066-CH212-CJBIJFJH">Figure 11-7</a></span> shows the image that results from calling the function <code>CGImageCreateWithMask</code> to apply the image mask to the image.</p><br/><div><a name="//apple_ref/doc/uid/TP30001066-CH212-CJBIDGCF" title="Figure 11-5The original image"></a><p><strong>Figure 11-5&nbsp;&nbsp;</strong>The original image</p><img src = "../Art/two_tigers.gif" alt = "The original image" width="507" height="246"></div><br/><br/><div><a name="//apple_ref/doc/uid/TP30001066-CH212-CJBEICBA" title="Figure 11-6An image mask"></a><p><strong>Figure 11-6&nbsp;&nbsp;</strong>An image mask</p><img src = "../Art/two_tiger_mask.gif" alt = "An image mask" width="506" height="245"></div><br/><p>Note that the areas in the original image that correspond to the black areas of the mask show through in the resulting image (<span class="content_text">Figure 11-7</span>). The areas that correspond to the white areas of the mask aren’t painted. The areas that correspond to the gray areas in the mask are painted using an intermediate alpha value that’s equal to <code>1</code> minus the image mask sample value.</p><br/><div><a name="//apple_ref/doc/uid/TP30001066-CH212-CJBIJFJH" title="Figure 11-7The image that results from applying the image mask to the original image"></a><p><strong>Figure 11-7&nbsp;&nbsp;</strong>The image that results from applying the image mask to the original image</p><img src = "../Art/image_create_w_mask.gif" alt = "The image that results from applying the image mask to the original image" width="505" height="245"></div><br/><a name="//apple_ref/doc/uid/TP30001066-CH212-CJBJCJCE" title="Masking an Image With an Image"></a><h3>Masking an Image With an Image</h3><p>You can use function <code>CGImageCreateWithMask</code> to mask an image with another image, rather than with an image mask. You would do this to achieve an effect opposite of what you get when you mask an image with an image mask. Instead of passing an image mask that’s created using the function <code><a href="../../../Reference/CGImage/Reference/reference.html#//apple_ref/c/func/CGImageMaskCreate" target="_top">CGImageMaskCreate</a></code>, you supply an image created from one of the Quartz image-creation functions. </p><p>Source samples of an image that is used as a mask (but is not a Quartz image mask) operate as alpha values. An image sample value (<code>S</code>):</p><ul class="spaceabove"><li class="li"><p>Equal to <code>1</code> allows painting the corresponding image sample at full coverage.</p></li><li class="li"><p>Equal to <code>0</code> blocks painting the corresponding image sample.</p></li><li class="li"><p>Greater than <code>0</code> and less <code>1</code> allows painting the corresponding image sample with an alpha value of <code>S</code>. </p></li></ul><p><span class="content_text"><a href="dq_images.html#//apple_ref/doc/uid/TP30001066-CH212-CJBBGDJE">Figure 11-8</a></span> shows the image that results from calling the function <code>CGImageCreateWithMask</code> to apply the image shown in <span class="content_text">Figure 11-6</span> to the image shown in <span class="content_text">Figure 11-5</span>. In this case, assume that the image shown in <span class="content_text">Figure 11-6</span> is created using one of the Quartz image-creation functions, such as <code>CGImageCreate</code>. Compare <span class="content_text">Figure 11-8</span> with <span class="content_text"><a href="dq_images.html#//apple_ref/doc/uid/TP30001066-CH212-CJBIJFJH">Figure 11-7</a></span> to see how the same sample values, when used as image samples instead of image mask samples, achieve the opposite effect.</p><p>The areas in the original image that correspond to the black areas of the image aren’t painted in the resulting image (<span class="content_text">Figure 11-8</span>). The areas that correspond to the white areas of are painted. The areas that correspond to the gray areas in the mask are painted using an intermediate alpha value that’s equal to the masking image sample value.</p><br/><div><a name="//apple_ref/doc/uid/TP30001066-CH212-CJBBGDJE" title="Figure 11-8The image that results from masking the original image with an image"></a><p><strong>Figure 11-8&nbsp;&nbsp;</strong>The image that results from masking the original image with an image</p><img src = "../Art/image_mask_image.gif" alt = "The image that results from masking the original image with an image" width="505" height="244"></div><br/><a name="//apple_ref/doc/uid/TP30001066-CH212-CJBHCADE" title="Masking an Image With Color"></a><h3>Masking an Image With Color</h3><p>The function <code>CGImageCreateWithMaskingColors</code> creates an image by masking one color or a range of colors in an image supplied to the function. Using this function, you can perform chroma key masking similar to what’s shown in <span class="content_text">Figure 11-9</span> or you can mask a range of colors, similar to what’s shown in <span class="content_text"><a href="dq_images.html#//apple_ref/doc/uid/TP30001066-CH212-CJBBFHEI">Figure 11-11</a></span>, <span class="content_text"><a href="dq_images.html#//apple_ref/doc/uid/TP30001066-CH212-CJBHEIGA">Figure 11-12</a></span>, and <span class="content_text"><a href="dq_images.html#//apple_ref/doc/uid/TP30001066-CH212-CJBBBJEG">Figure 11-13</a></span>. </p><p>The function <code>CGImageCreateWithMaskingColors</code> takes two parameters:</p><ul class="spaceabove"><li class="li"><p>An image that is not an image mask and that is not the result of applying an image mask or masking color to another image.</p></li><li class="li"><p>An array of color components that specify a color or a range of colors for the function to mask in the image.</p></li></ul><br/><div><a name="//apple_ref/doc/uid/TP30001066-CH212-CJBJAHJJ" title="Figure 11-9Chroma key masking"></a><p><strong>Figure 11-9&nbsp;&nbsp;</strong>Chroma key masking</p><img src = "../Art/chroma_key.gif" alt = "Chroma key masking" width="444" height="65"></div><br/><p>The number of elements in the color component array must be equal to twice the number of color components in the color space of the image. For each color component in the color space, supply a minimum value and a maximum value that specifies the range of colors to mask. To mask only one color, set the minimum value equal to the maximum value. The values in the color component array are supplied in the following order:</p><p><code>{min[1], max[1], ... min[N], max[N]}</code>, where <code>N</code> is the number of components.</p><p>If the image uses integer pixel components, each value in the color component array must be in the range [<code>0 .. 2^bitsPerComponent - 1]</code> . If the image uses floating-point pixel components, each value can be any floating-point number that is a valid color component.</p><p>An image sample is not painted if its color values fall in the range:</p><p><code>{c[1], ... c[N]}</code></p><p>where <code>min[i] &lt;= c[i] &lt;= max[i] for 1 &lt;= i &lt;= N </code></p><p>Anything underneath the unpainted samples, such as the current fill color or other drawing, shows through.</p><p>The image of two tigers, shown in <span class="content_text">Figure 11-10</span>, uses an RGB color space that has 8 bits per component. To mask a range of colors in this image, you supply minimum and maximum color component values in the range of <code>0</code> to <code>255</code>.</p><br/><div><a name="//apple_ref/doc/uid/TP30001066-CH212-CJBFIEJI" title="Figure 11-10The original image"></a><p><strong>Figure 11-10&nbsp;&nbsp;</strong>The original image</p><img src = "../Art/two_tigers1.gif" alt = "The original image" width="505" height="248"></div><br/><p><span class="content_text">Listing 11-4</span> shows a code fragment that sets up a color components array and supplies the array to the function <code>CGImageCreateWithMaskingColors</code> to achieve the result shown in <span class="content_text">Figure 11-11</span>.</p><a name="//apple_ref/doc/uid/TP30001066-CH212-CJBIAHFD" title="Listing 11-4A code fragment that masks light to mid-range brown colors in an image"></a><p class="codesample"><strong>Listing 11-4&nbsp;&nbsp;</strong>A code fragment that masks light to mid-range brown colors in an image</p><div class="codesample"><table><tr><td scope="row"><pre>CGImageRef myMaskedImage;<span></span></pre></td></tr><tr><td scope="row"><pre>const float myMaskingColors[6] = {124, 255,  68, 222, 0, 165};<span></span></pre></td></tr><tr><td scope="row"><pre>myColorMaskedImage = CGImageCreateWithMaskingColors (image,<span></span></pre></td></tr><tr><td scope="row"><pre>                                        myMaskingColors);<span></span></pre></td></tr><tr><td scope="row"><pre>CGContextDrawImage (context, myContextRect, myColorMaskedImage);<span></span></pre></td></tr></table></div><br/><div><a name="//apple_ref/doc/uid/TP30001066-CH212-CJBBFHEI" title="Figure 11-11An image with light to midrange brown colors masked out"></a><p><strong>Figure 11-11&nbsp;&nbsp;</strong>An image with light to midrange brown colors masked out</p><img src = "../Art/beige_brown_masking.gif" alt = "An image with light to midrange brown colors masked out" width="503" height="244"></div><br/><p><span class="content_text">Listing 11-5</span> shows another code fragment that operates on the image shown in <span class="content_text"><a href="dq_images.html#//apple_ref/doc/uid/TP30001066-CH212-CJBFIEJI">Figure 11-10</a></span> to get the results shown in <span class="content_text">Figure 11-12</span>. This example masks a darker range of colors.</p><a name="//apple_ref/doc/uid/TP30001066-CH212-CJBCHBIF" title="Listing 11-5A code fragment that masks shades of brown to black"></a><p class="codesample"><strong>Listing 11-5&nbsp;&nbsp;</strong>A code fragment that masks shades of brown to black</p><div class="codesample"><table><tr><td scope="row"><pre>CGImageRef myMaskedImage;<span></span></pre></td></tr><tr><td scope="row"><pre>const float myMaskingColors[6] = { 0, 124, 0, 68, 0, 0 };<span></span></pre></td></tr><tr><td scope="row"><pre>myColorMaskedImage = CGImageCreateWithMaskingColors (image,<span></span></pre></td></tr><tr><td scope="row"><pre>                                        myMaskingColors);<span></span></pre></td></tr><tr><td scope="row"><pre>CGContextDrawImage (context, myContextRect, myColorMaskedImage);<span></span></pre></td></tr></table></div><br/><div><a name="//apple_ref/doc/uid/TP30001066-CH212-CJBHEIGA" title="Figure 11-12A image after masking colors from dark brown to black"></a><p><strong>Figure 11-12&nbsp;&nbsp;</strong>A image after masking colors from dark brown to black</p><img src = "../Art/brown_black_masking_colors.gif" alt = "A image after masking colors from dark brown to black" width="506" height="248"></div><br/><p>You can mask colors in an image as well as set a fill color to achieve the effect shown in <span class="content_text">Figure 11-13</span> in which the masked areas are replaced with the fill color. <span class="content_text">Listing 11-6</span> shows the code fragment that generates the figure shown in <span class="content_text">Figure 11-13</span>.</p><a name="//apple_ref/doc/uid/TP30001066-CH212-CJBIEBHA" title="Listing 11-6Code that sets a fill color and masks a range of colors"></a><p class="codesample"><strong>Listing 11-6&nbsp;&nbsp;</strong>Code that sets a fill color and masks a range of colors</p><div class="codesample"><table><tr><td scope="row"><pre>CGImageRef myMaskedImage;<span></span></pre></td></tr><tr><td scope="row"><pre>const float myMaskingColors[6] = { 0, 124, 0, 68, 0, 0 };<span></span></pre></td></tr><tr><td scope="row"><pre>myColorMaskedImage = CGImageCreateWithMaskingColors (image,<span></span></pre></td></tr><tr><td scope="row"><pre>                                        myMaskingColors);<span></span></pre></td></tr><tr><td scope="row"><pre>CGContextSetRGBFillColor (myContext, 0.6373,0.6373, 0, 1);<span></span></pre></td></tr><tr><td scope="row"><pre>CGContextFillRect(context, rect);<span></span></pre></td></tr><tr><td scope="row"><pre>CGContextDrawImage(context, rect, myColorMaskedImage);<span></span></pre></td></tr></table></div><br/><div><a name="//apple_ref/doc/uid/TP30001066-CH212-CJBBBJEG" title="Figure 11-13An image drawn after masking a range of colors and setting a fill color"></a><p><strong>Figure 11-13&nbsp;&nbsp;</strong>An image drawn after masking a range of colors and setting a fill color</p><img src = "../Art/fill_color_with_mask.gif" alt = "An image drawn after masking a range of colors and setting a fill color" width="504" height="251"></div><br/><a name="//apple_ref/doc/uid/TP30001066-CH212-CJBHDDBE" title="Masking an Image by Clipping the Context"></a><h3>Masking an Image by Clipping the Context</h3><p>The function <code>CGContextClipToMask</code>, available in Mac OS X v10.4, maps a mask into a rectangle and intersects it with the current clipping area of the graphics context. You supply an the following parameters:</p><ul class="spaceabove"><li class="li"><p>The graphics context you want to clip.</p></li><li class="li"><p>A rectangle to apply the mask to.</p></li><li class="li"><p>An image mask created by calling the function <code>CGImageMaskCreate</code>. You can supply an image instead of an image mask to achieve an effect opposite of what you get by supplying an image mask. The image must be created with a Quartz image creation function, but it cannot be the result of applying a mask or masking color to another image. </p></li></ul><p>The resulting clipped area depends on whether you provide an image mask or an image to the function <code>CGContextClipToMask</code>. If you supply an image mask, you get results similar to those described in <span class="content_text"><a href="dq_images.html#//apple_ref/doc/uid/TP30001066-CH212-CJBHIJEB">“Masking an Image With an Image Mask,”</a></span> except that the graphics context is clipped. If you supply an image, the graphics context is clipped similar to what’s described in <span class="content_text"><a href="dq_images.html#//apple_ref/doc/uid/TP30001066-CH212-CJBJCJCE">“Masking an Image With an Image.”</a></span> </p><p>Take a look at <span class="content_text">Figure 11-14</span>. Assume it is an image mask created by calling the function <code>CGImageMaskCreate</code> and then the mask is supplied as a parameter to the function <code>CGContextClipToMask</code>. The resulting context allows painting to the black areas, does not allow painting to the white areas, and allows painting to the gray area with an alpha value of <code>1–S</code>, where <code>S</code> is the sample value of the image masks. If you draw an image to the clipped context using the function <code>CGContextDrawImage</code>, you’ll get a result similar to that shown in <span class="content_text">Figure 11-15</span>.</p><br/><div><a name="//apple_ref/doc/uid/TP30001066-CH212-CJBHEGHJ" title="Figure 11-14A masking image"></a><p><strong>Figure 11-14&nbsp;&nbsp;</strong>A masking image</p><img src = "../Art/the_mask.gif" alt = "A masking image" width="288" height="269"></div><br/><br/><div><a name="//apple_ref/doc/uid/TP30001066-CH212-CJBIIDHJ" title="Figure 11-15An image drawn to a context after clipping the content with an image mask"></a><p><strong>Figure 11-15&nbsp;&nbsp;</strong>An image drawn to a context after clipping the content with an image mask</p><img src = "../Art/mask_as_mask.gif" alt = "An image drawn to a context after clipping the content with an image mask" width="330" height="308"></div><br/><p>When the masking image is treated as an image, you get the opposite result, as shown in <span class="content_text">Figure 11-16</span>. </p><br/><div><a name="//apple_ref/doc/uid/TP30001066-CH212-CJBHGHAB" title="Figure 11-16An image drawn to a context after clipping the content with an image"></a><p><strong>Figure 11-16&nbsp;&nbsp;</strong>An image drawn to a context after clipping the content with an image</p><img src = "../Art/inverse_mask_clip.gif" alt = "An image drawn to a context after clipping the content with an image" width="335" height="309"></div><br/><a name="//apple_ref/doc/uid/TP30001066-CH212-CJBIJEFG" title="Using Blend Modes With Images"></a><h2>Using Blend Modes With Images</h2><p>You can use Quartz 2D blend modes (see <span class="content_text"><a href="../dq_paths/dq_paths.html#//apple_ref/doc/uid/TP30001066-CH211-BCIGICEF">“Setting Blend Modes”</a></span>) to composite two images or to composite an image over any content that’s already drawn to the graphic context. This section discusses compositing an image over a background drawing.</p><p>The general procedure for compositing an image over a background is as follows:</p><ol class="ol"><li class="li"><p>Draw the background. </p></li><li class="li"><p>Set the blend mode by calling the function <code><a href="../../../Reference/CGContext/Reference/reference.html#//apple_ref/c/func/CGContextSetBlendMode" target="_top">CGContextSetBlendMode</a></code> with one of the blend mode constants. This function and the constants are available in Mac OS X v10.4 and later. (The blend modes are based upon those defined in the PDF Reference.) </p></li><li class="li"><p>Draw the image you want to composite over the background by calling the function <code><a href="../../../Reference/CGContext/Reference/reference.html#//apple_ref/c/func/CGContextDrawImage" target="_top">CGContextDrawImage</a></code>. </p></li></ol><p><span class="content_text">Listing 11-7</span> shows a code fragment that composites one image over a background using the “darken” blend mode. </p><a name="//apple_ref/doc/uid/TP30001066-CH212-CJBFBDHC" title="Listing 11-7Code that sets the blend mode and draws an image"></a><p class="codesample"><strong>Listing 11-7&nbsp;&nbsp;</strong>Code that sets the blend mode and draws an image</p><div class="codesample"><table><tr><td scope="row"><pre>CGContextSetBlendMode (myContext, kCGBlendModeDarken);<span></span></pre></td></tr><tr><td scope="row"><pre>CGContextDrawImage (myContext, myRect, myImage2);<span></span></pre></td></tr></table></div><p>The rest of this section uses each of the blend modes available in Quartz to draw the image shown on the right side of <span class="content_text">Figure 11-17</span> over the background that consists of the painted rectangles shown on the left side of the figure. In all cases, the rectangles are first drawn to the graphics context. Then, a blend mode is set by calling the function <code><a href="../../../Reference/CGContext/Reference/reference.html#//apple_ref/doc/c_ref/CGContextSetBlendMode" target="_top">CGContextSetBlendMode</a></code>, passing the appropriate blend mode constant. Finally, the image of the jumper is drawn to the graphics context.</p><br/><div><a name="//apple_ref/doc/uid/TP30001066-CH212-CJBIICHE" title="Figure 11-17Background drawing (left) and foreground image (right)"></a><p><strong>Figure 11-17&nbsp;&nbsp;</strong>Background drawing (left) and foreground image (right)</p><img src = "../Art/both_images.jpg" alt = "Background drawing (left) and foreground image (right)" ></div><br/><a name="//apple_ref/doc/uid/TP30001066-CH212-CJBFCDFB" title="Normal Blend Mode"></a><h3>Normal Blend Mode</h3><p>Normal blend mode paints source image samples over background image samples. Normal blend mode is the default blend mode in Quartz. You only need to explicitly set normal blend mode if you are currently using another blend mode and want to switch to normal blend mode. You can set normal blend mode by passing the constant <code>kCGBlendModeNormal</code> to the function <code>CGContextSetBlendMode</code> or by restoring the graphics state (assuming the previous graphics state used normal blend mode) using the function <code><a href="../../../Reference/CGContext/Reference/reference.html#//apple_ref/doc/c_ref/CGContextRestoreGState" target="_top">CGContextRestoreGState</a></code>.</p><p><span class="content_text">Figure 11-19</span> shows the result of using normal blend mode to paint the image shown in <span class="content_text"><a href="dq_images.html#//apple_ref/doc/uid/TP30001066-CH212-CJBIICHE">Figure 11-17</a></span> over the rectangles shown in the same figure. In this example, the image is drawn using an alpha value of 1.0, so the background is completely obscured by the image.</p><br/><div><a name="//apple_ref/doc/uid/TP30001066-CH212-CJBBHJHE" title="Figure 11-18Drawing an image over a background using normal blend mode"></a><p><strong>Figure 11-18&nbsp;&nbsp;</strong>Drawing an image over a background using normal blend mode</p><img src = "../Art/normal_image.gif" alt = "Drawing an image over a background using normal blend mode" width="252" height="341"></div><br/><a name="//apple_ref/doc/uid/TP30001066-CH212-CJBFEGGI" title="Multiply Blend Mode"></a><h3>Multiply Blend Mode</h3><p>Multiply blend mode multiplies source image samples with background image samples. The colors in the resulting image are at least as dark as either of the two contributing sample colors. </p><p>You specify multiply blend mode by passing the constant <code>kCGBlendModeMultiply</code> to the function <code>CGContextSetBlendMode</code>. <span class="content_text">Figure 11-19</span> shows the result of using multiply blend mode to paint the image shown in <span class="content_text"><a href="dq_images.html#//apple_ref/doc/uid/TP30001066-CH212-CJBIICHE">Figure 11-17</a></span> over the rectangles shown in the same figure.</p><br/><div><a name="//apple_ref/doc/uid/TP30001066-CH212-CJBFBBGB" title="Figure 11-19Drawing an image over a background using multiply blend mode"></a><p><strong>Figure 11-19&nbsp;&nbsp;</strong>Drawing an image over a background using multiply blend mode</p><img src = "../Art/multiply_image.jpg" alt = "Drawing an image over a background using multiply blend mode" ></div><br/><a name="//apple_ref/doc/uid/TP30001066-CH212-CJBJEBHI" title="Screen Blend Mode"></a><h3>Screen Blend Mode</h3><p>Screen blend mode multiplies the inverse of the source image samples with the inverse of the background image samples to obtain colors that are at least as light as either of the two contributing sample colors. </p><p>You specify screen blend mode by passing the constant <code>kCGBlendModeScreen</code> to the function <code>CGContextSetBlendMode</code>. <span class="content_text">Figure 11-20</span> shows the result of using screen blend mode to paint the image shown in <span class="content_text"><a href="dq_images.html#//apple_ref/doc/uid/TP30001066-CH212-CJBIICHE">Figure 11-17</a></span> over the rectangles shown in the same figure.</p><br/><div><a name="//apple_ref/doc/uid/TP30001066-CH212-CJBFCCJB" title="Figure 11-20Drawing an image over a background using screen blend mode"></a><p><strong>Figure 11-20&nbsp;&nbsp;</strong>Drawing an image over a background using screen blend mode</p><img src = "../Art/screen_image.jpg" alt = "Drawing an image over a background using screen blend mode" ></div><br/><a name="//apple_ref/doc/uid/TP30001066-CH212-CJBEBCAA" title="Overlay Blend Mode"></a><h3>Overlay Blend Mode</h3><p>Overlay blend mode either multiplies or screens the source image samples with the background image samples, depending on the color of the background samples. The result is to overlay the existing image samples while preserving the highlights and shadows of the background. The background color mixes with the source image to reflect the lightness or darkness of the background. </p><p>You specify overlay blend mode by passing the constant <code>kCGBlendModeOverlay</code> to the function <code>CGContextSetBlendMode</code>. <span class="content_text">Figure 11-21</span> shows the result of using overlay blend mode to paint the image shown in <span class="content_text"><a href="dq_images.html#//apple_ref/doc/uid/TP30001066-CH212-CJBIICHE">Figure 11-17</a></span> over the rectangles shown in the same figure.</p><br/><div><a name="//apple_ref/doc/uid/TP30001066-CH212-CJBJGEAA" title="Figure 11-21Drawing an image over a background using overlay blend mode"></a><p><strong>Figure 11-21&nbsp;&nbsp;</strong>Drawing an image over a background using overlay blend mode</p><img src = "../Art/overlay_image.jpg" alt = "Drawing an image over a background using overlay blend mode" ></div><br/><a name="//apple_ref/doc/uid/TP30001066-CH212-CJBBFCGA" title="Darken Blend Mode"></a><h3>Darken Blend Mode</h3><p>Darken blend mode creates composite image samples by choosing the darker samples from the source image or the background. Source image samples that are darker than the background image samples replace the corresponding background samples.</p><p>You specify darken blend mode by passing the constant <code>kCGBlendModeDarken</code> to the function <code>CGContextSetBlendMode</code>. <span class="content_text">Figure 11-22</span> shows the result of using darken blend mode to paint the image shown in <span class="content_text"><a href="dq_images.html#//apple_ref/doc/uid/TP30001066-CH212-CJBIICHE">Figure 11-17</a></span> over the rectangles shown in the same figure.</p><br/><div><a name="//apple_ref/doc/uid/TP30001066-CH212-CJBJHGHA" title="Figure 11-22Drawing an image over a background using darken blend mode"></a><p><strong>Figure 11-22&nbsp;&nbsp;</strong>Drawing an image over a background using darken blend mode</p><img src = "../Art/darken_image.jpg" alt = "Drawing an image over a background using darken blend mode" ></div><br/><a name="//apple_ref/doc/uid/TP30001066-CH212-CJBGFGEH" title="Lighten Blend Mode"></a><h3>Lighten Blend Mode</h3><p>Lighten blend mode creates composite image samples by choosing the lighter samples from the source image or the background. Source image samples that are lighter than the background image samples replace the corresponding background samples.</p><p>You specify lighten blend mode by passing the constant <code>kCGBlendModeLighten</code> to the function <code>CGContextSetBlendMode</code>. <span class="content_text">Figure 11-23</span> shows the result of using lighten blend mode to paint the image shown in <span class="content_text"><a href="dq_images.html#//apple_ref/doc/uid/TP30001066-CH212-CJBIICHE">Figure 11-17</a></span> over the rectangles shown in the same figure.</p><br/><div><a name="//apple_ref/doc/uid/TP30001066-CH212-CJBFCAEE" title="Figure 11-23Drawing an image over a background using lighten blend mode"></a><p><strong>Figure 11-23&nbsp;&nbsp;</strong>Drawing an image over a background using lighten blend mode</p><img src = "../Art/lighten_image.jpg" alt = "Drawing an image over a background using lighten blend mode" ></div><br/><a name="//apple_ref/doc/uid/TP30001066-CH212-CJBJAHIJ" title="Color Dodge Blend Mode"></a><h3>Color Dodge Blend Mode</h3><p>Color dodge blend mode brightens background image samples to reflect the source image samples. Source image sample values that specify black remain unchanged. </p><p>You specify color dodge blend mode by passing the constant <code>kCGBlendModeColorDodge</code> to the function <code>CGContextSetBlendMode</code>. <span class="content_text">Figure 11-24</span> shows the result of using color dodge blend mode to paint the image shown in <span class="content_text"><a href="dq_images.html#//apple_ref/doc/uid/TP30001066-CH212-CJBIICHE">Figure 11-17</a></span> over the rectangles shown in the same figure.</p><br/><div><a name="//apple_ref/doc/uid/TP30001066-CH212-CJBEBBDA" title="Figure 11-24Drawing an image over a background using color dodge blend mode"></a><p><strong>Figure 11-24&nbsp;&nbsp;</strong>Drawing an image over a background using color dodge blend mode</p><img src = "../Art/color_dodge_image.jpg" alt = "Drawing an image over a background using color dodge blend mode" ></div><br/><a name="//apple_ref/doc/uid/TP30001066-CH212-CJBFCDDE" title="Color Burn Blend Mode"></a><h3>Color Burn Blend Mode</h3><p>Color burn blend mode darkens background image samples to reflect the source image samples. Source image sample values that specify white remain unchanged. </p><p>You specify color burn blend mode by passing the constant <code>kCGBlendModeColorBurn</code> to the function <code>CGContextSetBlendMode</code>. <span class="content_text">Figure 11-25</span> shows the result of using color burn blend mode to paint the image shown in <span class="content_text"><a href="dq_images.html#//apple_ref/doc/uid/TP30001066-CH212-CJBIICHE">Figure 11-17</a></span> over the rectangles shown in the same figure.</p><br/><div><a name="//apple_ref/doc/uid/TP30001066-CH212-CJBCHHEC" title="Figure 11-25Drawing an image over a background using color burn blend mode"></a><p><strong>Figure 11-25&nbsp;&nbsp;</strong>Drawing an image over a background using color burn blend mode</p><img src = "../Art/color_burn_image.jpg" alt = "Drawing an image over a background using color burn blend mode" ></div><br/><a name="//apple_ref/doc/uid/TP30001066-CH212-CJBEAEAJ" title="Soft Light Blend Mode"></a><h3>Soft Light Blend Mode</h3><p>Soft light blend mode either darkens or lightens colors, depending on the source image sample color. If the source image sample color is lighter than 50% gray, the background lightens, similar to dodging. If the source image sample color is darker than 50% gray, the background darkens, similar to burning. If the source image sample color is equal to 50% gray, the background does not change. </p><p>Image samples that are equal to pure black or pure white produce darker or lighter areas, but do not result in pure black or white. The overall effect is similar to what you achieve by shining a diffuse spotlight on the source image. </p><p>You specify soft light blend mode by passing the constant <code>kCGBlendModeSoftLight</code> to the function <code>CGContextSetBlendMode</code>. <span class="content_text">Figure 11-26</span> shows the result of using soft light blend mode to paint the image shown in <span class="content_text"><a href="dq_images.html#//apple_ref/doc/uid/TP30001066-CH212-CJBIICHE">Figure 11-17</a></span> over the rectangles shown in the same figure.</p><br/><div><a name="//apple_ref/doc/uid/TP30001066-CH212-CJBJAHEF" title="Figure 11-26Drawing an image over a background using soft light blend mode"></a><p><strong>Figure 11-26&nbsp;&nbsp;</strong>Drawing an image over a background using soft light blend mode</p><img src = "../Art/soft_light_image.jpg" alt = "Drawing an image over a background using soft light blend mode" ></div><br/><a name="//apple_ref/doc/uid/TP30001066-CH212-CJBHBFIC" title="Hard Light Blend Mode"></a><h3>Hard Light Blend Mode</h3><p>Hard light blend mode either multiplies or screens colors, depending on the source image sample color. If the source image sample color is lighter than 50% gray, the background is lightened, similar to screening. If the source image sample color is darker than 50% gray, the background is darkened, similar to multiplying. If the source image sample color is equal to 50% gray, the source image does not change. Image samples that are equal to pure black or pure white result in pure black or white. The overall effect is similar to what you achieve by shining a harsh spotlight on the source image. </p><p>You specify hard light blend mode by passing the constant <code>kCGBlendModeHardLight</code> to the function <code>CGContextSetBlendMode</code>. <span class="content_text">Figure 11-27</span> shows the result of using hard light blend mode to paint the image shown in <span class="content_text"><a href="dq_images.html#//apple_ref/doc/uid/TP30001066-CH212-CJBIICHE">Figure 11-17</a></span> over the rectangles shown in the same figure.</p><br/><div><a name="//apple_ref/doc/uid/TP30001066-CH212-CJBBJCBG" title="Figure 11-27Drawing an image over a background using hard light blend mode"></a><p><strong>Figure 11-27&nbsp;&nbsp;</strong>Drawing an image over a background using hard light blend mode</p><img src = "../Art/hard_light_image.jpg" alt = "Drawing an image over a background using hard light blend mode" ></div><br/><a name="//apple_ref/doc/uid/TP30001066-CH212-CJBDCFBH" title="Difference Blend Mode"></a><h3>Difference Blend Mode</h3><p>Difference blend mode subtracts either the source image sample color from the background image sample color, or the reverse, depending on which sample has the greater brightness value. Source image sample values that are black produce no change; white inverts the background color values. </p><p>You specify difference blend mode by passing the constant <code>kCGBlendModeDifference</code> to the function <code>CGContextSetBlendMode</code>. <span class="content_text">Figure 11-28</span> shows the result of using difference blend mode to paint the image shown in <span class="content_text"><a href="dq_images.html#//apple_ref/doc/uid/TP30001066-CH212-CJBIICHE">Figure 11-17</a></span> over the rectangles shown in the same figure.</p><br/><div><a name="//apple_ref/doc/uid/TP30001066-CH212-CJBBCAHC" title="Figure 11-28Drawing an image over a background using difference blend mode"></a><p><strong>Figure 11-28&nbsp;&nbsp;</strong>Drawing an image over a background using difference blend mode</p><img src = "../Art/difference_image.jpg" alt = "Drawing an image over a background using difference blend mode" ></div><br/><a name="//apple_ref/doc/uid/TP30001066-CH212-CJBDGFCD" title="Exclusion Blend Mode"></a><h3>Exclusion Blend Mode</h3><p>Exclusion blend mode produces a lower-contrast version of the difference blend mode. Source image sample values that are black don’t produce a change; white inverts the background color values. </p><p>You specify exclusion blend mode by passing the constant <code>kCGBlendModeExclusion</code> to the function <code>CGContextSetBlendMode</code>. <span class="content_text">Figure 11-29</span> shows the result of using exclusion blend mode to paint the image shown in <span class="content_text"><a href="dq_images.html#//apple_ref/doc/uid/TP30001066-CH212-CJBIICHE">Figure 11-17</a></span> over the rectangles shown in the same figure.</p><br/><div><a name="//apple_ref/doc/uid/TP30001066-CH212-CJBDACAH" title="Figure 11-29Drawing an image over a background using exclusion blend mode"></a><p><strong>Figure 11-29&nbsp;&nbsp;</strong>Drawing an image over a background using exclusion blend mode</p><img src = "../Art/exclusion_image.gif" alt = "Drawing an image over a background using exclusion blend mode" width="247" height="340"></div><br/><a name="//apple_ref/doc/uid/TP30001066-CH212-CJBFIIHG" title="Hue Blend Mode"></a><h3>Hue Blend Mode</h3><p>Hue blend mode uses the luminance and saturation values of the background with the hue of the source image. You specify hue blend mode by passing the constant <code>kCGBlendModeHue</code> to the function <code>CGContextSetBlendMode</code>. <span class="content_text">Figure 11-30</span> shows the result of using hue blend mode to paint the image shown in <span class="content_text"><a href="dq_images.html#//apple_ref/doc/uid/TP30001066-CH212-CJBIICHE">Figure 11-17</a></span> over the rectangles shown in the same figure.</p><br/><div><a name="//apple_ref/doc/uid/TP30001066-CH212-CJBBEHBJ" title="Figure 11-30Drawing an image over a background using hue blend mode"></a><p><strong>Figure 11-30&nbsp;&nbsp;</strong>Drawing an image over a background using hue blend mode</p><img src = "../Art/hue_image.jpg" alt = "Drawing an image over a background using hue blend mode" ></div><br/><a name="//apple_ref/doc/uid/TP30001066-CH212-CJBIGHIC" title="Saturation Blend Mode"></a><h3>Saturation Blend Mode</h3><p>Saturation blend mode uses the luminance and hue values of the background with the saturation of the source image. Pure gray areas don’t produce a change. You specify saturation blend mode by passing the constant <code>kCGBlendModeSaturation</code> to the function <code>CGContextSetBlendMode</code>. <span class="content_text">Figure 11-31</span> shows the result of using saturation blend mode to paint the image shown in <span class="content_text"><a href="dq_images.html#//apple_ref/doc/uid/TP30001066-CH212-CJBIICHE">Figure 11-17</a></span> over the rectangles shown in the same figure.</p><br/><div><a name="//apple_ref/doc/uid/TP30001066-CH212-CJBDDJJJ" title="Figure 11-31Drawing an image over a background using saturation blend mode"></a><p><strong>Figure 11-31&nbsp;&nbsp;</strong>Drawing an image over a background using saturation blend mode</p><img src = "../Art/saturation_image.jpg" alt = "Drawing an image over a background using saturation blend mode" ></div><br/><a name="//apple_ref/doc/uid/TP30001066-CH212-CJBFDHDC" title="Color Blend Mode"></a><h3>Color Blend Mode</h3><p>Color blend mode uses the luminance values of the background with the hue and saturation values of the source image. This mode preserves the gray levels in the image. You specify color blend mode by passing the constant <code>kCGBlendModeColor</code> to the function <code>CGContextSetBlendMode</code>. <span class="content_text">Figure 11-32</span> shows the result of using color blend mode to paint the image shown in <span class="content_text"><a href="dq_images.html#//apple_ref/doc/uid/TP30001066-CH212-CJBIICHE">Figure 11-17</a></span> over the rectangles shown in the same figure.</p><br/><div><a name="//apple_ref/doc/uid/TP30001066-CH212-CJBDADHF" title="Figure 11-32Drawing an image over a background using color blend mode"></a><p><strong>Figure 11-32&nbsp;&nbsp;</strong>Drawing an image over a background using color blend mode</p><img src = "../Art/color_image.jpg" alt = "Drawing an image over a background using color blend mode" ></div><br/><a name="//apple_ref/doc/uid/TP30001066-CH212-CJBGCGCE" title="Luminosity Blend Mode"></a><h3>Luminosity Blend Mode</h3><p>Luminosity blend mode uses the hue and saturation of the background with the luminance of the source image to creates an effect that is inverse to the effect created by the color blend mode. </p><p>You specify luminosity blend mode by passing the constant <code>kCGBlendModeLuminosity</code> to the function <code>CGContextSetBlendMode</code>. <span class="content_text">Figure 11-33</span> shows the result of using luminosity blend mode to paint the image shown in <span class="content_text"><a href="dq_images.html#//apple_ref/doc/uid/TP30001066-CH212-CJBIICHE">Figure 11-17</a></span> over the rectangles shown in the same figure.</p><br/><div><a name="//apple_ref/doc/uid/TP30001066-CH212-CJBIGBBC" title="Figure 11-33Drawing an image over a background using luminosity blend mode"></a><p><strong>Figure 11-33&nbsp;&nbsp;</strong>Drawing an image over a background using luminosity blend mode</p><img src = "../Art/luminosity_image.jpg" alt = "Drawing an image over a background using luminosity blend mode" ></div><br/>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../dq_data_mgr/dq_data_mgr.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../dq_layers/dq_layers.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2001, 2007 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2007-12-11<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/dq_images/dq_images.html%3Fid%3DTP30001066-7.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/dq_images/dq_images.html%3Fid%3DTP30001066-7.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/dq_images/dq_images.html%3Fid%3DTP30001066-7.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>