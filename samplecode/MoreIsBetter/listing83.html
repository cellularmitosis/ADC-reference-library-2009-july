<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>MoreIsBetter - /MIB-Libraries/MoreDebugging/MoreBacktrace.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxMacOS9Earlier-date.html">Mac OS 9 & Earlier</a> &gt; <A HREF="javascript:location.replace('index.html');">MoreIsBetter</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->


	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">MoreIsBetter</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/MIB-Libraries/MoreDebugging/MoreBacktrace.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/MIB-Clients/Demos/MoreOpenAndSaveDemo/AnswerShell.c</option>
<option value="listing2.html">/MIB-Clients/MacCVSProTool/MacCVSProTool.c</option>
<option value="listing3.html">/MIB-Clients/SampleSubmit/SampleSubmit.c</option>
<option value="listing4.html">/MIB-Documentation/index.html</option>
<option value="listing5.html">/MIB-Documentation/MoreDocumentation/0ReleaseNotes.html</option>
<option value="listing6.html">/MIB-Documentation/MoreDocumentation/0toc.html</option>
<option value="listing7.html">/MIB-Documentation/MoreDocumentation/banner.html</option>
<option value="listing8.html">/MIB-Documentation/MoreDocumentation/BuildingAndUsing.html</option>
<option value="listing9.html">/MIB-Documentation/MoreDocumentation/ContributingToMoreIsBetter.html</option>
<option value="listing10.html">/MIB-Documentation/MoreDocumentation/copyright.html</option>
<option value="listing11.html">/MIB-Documentation/MoreDocumentation/index.html</option>
<option value="listing12.html">/MIB-Documentation/MoreDocumentation/intro.html</option>
<option value="listing13.html">/MIB-Documentation/MoreDocumentation/MoreAppearance.html</option>
<option value="listing14.html">/MIB-Documentation/MoreDocumentation/MoreAppleEvents.html</option>
<option value="listing15.html">/MIB-Documentation/MoreDocumentation/MoreCDs.html</option>
<option value="listing16.html">/MIB-Documentation/MoreDocumentation/MoreCodeFragments.html</option>
<option value="listing17.html">/MIB-Documentation/MoreDocumentation/MoreControls.html</option>
<option value="listing18.html">/MIB-Documentation/MoreDocumentation/MoreDevices.html</option>
<option value="listing19.html">/MIB-Documentation/MoreDocumentation/MoreDialogs.html</option>
<option value="listing20.html">/MIB-Documentation/MoreDocumentation/MoreDisks.html</option>
<option value="listing21.html">/MIB-Documentation/MoreDocumentation/MoreErrors.html</option>
<option value="listing22.html">/MIB-Documentation/MoreDocumentation/MoreEvents.html</option>
<option value="listing23.html">/MIB-Documentation/MoreDocumentation/MoreInterfaceLib.html</option>
<option value="listing24.html">/MIB-Documentation/MoreDocumentation/MoreLists.html</option>
<option value="listing25.html">/MIB-Documentation/MoreDocumentation/MoreMemory.html</option>
<option value="listing26.html">/MIB-Documentation/MoreDocumentation/MoreMenus.html</option>
<option value="listing27.html">/MIB-Documentation/MoreDocumentation/MoreMultiprocessing.html</option>
<option value="listing28.html">/MIB-Documentation/MoreDocumentation/MoreNavigation.html</option>
<option value="listing29.html">/MIB-Documentation/MoreDocumentation/MoreNetworkSetup.html</option>
<option value="listing30.html">/MIB-Documentation/MoreDocumentation/MoreOpenAndSave.html</option>
<option value="listing31.html">/MIB-Documentation/MoreDocumentation/MoreOpenTransport.html</option>
<option value="listing32.html">/MIB-Documentation/MoreDocumentation/MoreOSL.html</option>
<option value="listing33.html">/MIB-Documentation/MoreDocumentation/MoreOSUtils.html</option>
<option value="listing34.html">/MIB-Documentation/MoreDocumentation/MorePatches.html</option>
<option value="listing35.html">/MIB-Documentation/MoreDocumentation/MorePreferences.html</option>
<option value="listing36.html">/MIB-Documentation/MoreDocumentation/MoreProcesses.html</option>
<option value="listing37.html">/MIB-Documentation/MoreDocumentation/MoreQuickDraw.html</option>
<option value="listing38.html">/MIB-Documentation/MoreDocumentation/MoreResources.html</option>
<option value="listing39.html">/MIB-Documentation/MoreDocumentation/MoreTextUtils.html</option>
<option value="listing40.html">/MIB-Documentation/MoreDocumentation/MoreToolbox.html</option>
<option value="listing41.html">/MIB-Documentation/MoreDocumentation/MoreWindows.html</option>
<option value="listing42.html">/MIB-Libraries/MIB_Carbon.h</option>
<option value="listing43.html">/MIB-Libraries/MIB_SourceHeader.txt</option>
<option value="listing44.html">/MIB-Libraries/MoreAppearance/MoreAppearance.cp</option>
<option value="listing45.html">/MIB-Libraries/MoreAppearance/MoreAppearance.h</option>
<option value="listing46.html">/MIB-Libraries/MoreAppleEvents/MoreAEDataModel.c</option>
<option value="listing47.html">/MIB-Libraries/MoreAppleEvents/MoreAEDataModel.h</option>
<option value="listing48.html">/MIB-Libraries/MoreAppleEvents/MoreAEObjects.c</option>
<option value="listing49.html">/MIB-Libraries/MoreAppleEvents/MoreAEObjects.h</option>
<option value="listing50.html">/MIB-Libraries/MoreAppleEvents/MoreAppleEvents.cp</option>
<option value="listing51.html">/MIB-Libraries/MoreAppleEvents/MoreAppleEvents.h</option>
<option value="listing52.html">/MIB-Libraries/MoreAppleEvents/MoreAppleEventsPlus.c</option>
<option value="listing53.html">/MIB-Libraries/MoreAppleEvents/MoreAppleEventsPlus.h</option>
<option value="listing54.html">/MIB-Libraries/MoreAppleEvents/MoreFinderEvents.c</option>
<option value="listing55.html">/MIB-Libraries/MoreAppleEvents/MoreFinderEvents.h</option>
<option value="listing56.html">/MIB-Libraries/MoreAppleEvents/MoreOSA.c</option>
<option value="listing57.html">/MIB-Libraries/MoreAppleEvents/MoreOSA.h</option>
<option value="listing58.html">/MIB-Libraries/MoreAppleEvents/ProductInfo.txt</option>
<option value="listing59.html">/MIB-Libraries/MoreAppleEvents/TestMoreAppleEvents/Carbon.r</option>
<option value="listing60.html">/MIB-Libraries/MoreAppleEvents/TestMoreAppleEvents/HelloWorld.c</option>
<option value="listing61.html">/MIB-Libraries/MoreAppleEvents/TestMoreAppleEvents/Info.plist.r</option>
<option value="listing62.html">/MIB-Libraries/MoreAppleEvents/TestMoreAppleEvents/TestMoreAppleEvents.c</option>
<option value="listing63.html">/MIB-Libraries/MoreAppleEvents/VersionInfo.r</option>
<option value="listing64.html">/MIB-Libraries/MoreCarbonEvents/MoreCarbonEvents.c</option>
<option value="listing65.html">/MIB-Libraries/MoreCarbonEvents/MoreCarbonEvents.h</option>
<option value="listing66.html">/MIB-Libraries/MoreCFQ/MoreCFQ.c</option>
<option value="listing67.html">/MIB-Libraries/MoreCFQ/MoreCFQ.h</option>
<option value="listing68.html">/MIB-Libraries/MoreCodeFragments/CFMLateImport/CallMachOFramework/CallMachOFramework.c</option>
<option value="listing69.html">/MIB-Libraries/MoreCodeFragments/CFMLateImport/CallMachOFramework/CallMachOFramework.r</option>
<option value="listing70.html">/MIB-Libraries/MoreCodeFragments/CFMLateImport/CallMachOFramework/Read Me CallMachOFramework.txt</option>
<option value="listing71.html">/MIB-Libraries/MoreCodeFragments/CFMLateImport/CallMachOFramework/System Framework Stub/Stub Library Read Me.txt</option>
<option value="listing72.html">/MIB-Libraries/MoreCodeFragments/CFMLateImport/CFMLateImport.c</option>
<option value="listing73.html">/MIB-Libraries/MoreCodeFragments/CFMLateImport/CFMLateImport.h</option>
<option value="listing74.html">/MIB-Libraries/MoreCodeFragments/CFMLateImport/LateImportTest/LateImportTest.c</option>
<option value="listing75.html">/MIB-Libraries/MoreCodeFragments/CFMLateImport/LateImportTest/TestLibrary/TestLibrary.h</option>
<option value="listing76.html">/MIB-Libraries/MoreCodeFragments/CFMLateImport/LateImportTest/TestLibrary/TestLibraryImpl.c</option>
<option value="listing77.html">/MIB-Libraries/MoreControls/MoreControls.cp</option>
<option value="listing78.html">/MIB-Libraries/MoreControls/MoreControls.h</option>
<option value="listing79.html">/MIB-Libraries/MoreCRC/MoreCRC.c</option>
<option value="listing80.html">/MIB-Libraries/MoreCRC/MoreCRC.h</option>
<option value="listing81.html">/MIB-Libraries/MoreDebugging/MoreAddrToSym.c</option>
<option value="listing82.html">/MIB-Libraries/MoreDebugging/MoreAddrToSym.h</option>
<option value="listing83.html">/MIB-Libraries/MoreDebugging/MoreBacktrace.c</option>
<option value="listing84.html">/MIB-Libraries/MoreDebugging/MoreBacktrace.h</option>
<option value="listing85.html">/MIB-Libraries/MoreDebugging/MoreBacktraceTest/MoreBacktraceTest.c</option>
<option value="listing86.html">/MIB-Libraries/MoreDebugging/MoreBBLog.c</option>
<option value="listing87.html">/MIB-Libraries/MoreDebugging/MoreBBLog.h</option>
<option value="listing88.html">/MIB-Libraries/MoreDevices/InterruptSafeDebug/GenerateFont/GenerateFont.c</option>
<option value="listing89.html">/MIB-Libraries/MoreDevices/InterruptSafeDebug/InterruptSafeDebug.c</option>
<option value="listing90.html">/MIB-Libraries/MoreDevices/InterruptSafeDebug/InterruptSafeDebug.h</option>
<option value="listing91.html">/MIB-Libraries/MoreDevices/InterruptSafeDebug/InterruptSafeDebug.s</option>
<option value="listing92.html">/MIB-Libraries/MoreDevices/InterruptSafeDebug/TestInterruptSafeDebug/TestInterruptSafeDebug.c</option>
<option value="listing93.html">/MIB-Libraries/MoreDevices/TradDriverLoaderLib/ReadMe.html</option>
<option value="listing94.html">/MIB-Libraries/MoreDevices/TradDriverLoaderLib/TestTradDriverLoaderLib/TestDriver/TestDriverMain.c</option>
<option value="listing95.html">/MIB-Libraries/MoreDevices/TradDriverLoaderLib/TestTradDriverLoaderLib/TestTradDriverLoader.c</option>
<option value="listing96.html">/MIB-Libraries/MoreDevices/TradDriverLoaderLib/TradDriverLoaderLib.c</option>
<option value="listing97.html">/MIB-Libraries/MoreDevices/TradDriverLoaderLib/TradDriverLoaderLib.h</option>
<option value="listing98.html">/MIB-Libraries/MoreDialogs/MoreDialogs.cp</option>
<option value="listing99.html">/MIB-Libraries/MoreDialogs/MoreDialogs.h</option>
<option value="listing100.html">/MIB-Libraries/MoreDisks/MoreCDs.c</option>
<option value="listing101.html">/MIB-Libraries/MoreDisks/MoreCDs.h</option>
<option value="listing102.html">/MIB-Libraries/MoreDisks/MoreDisks.c</option>
<option value="listing103.html">/MIB-Libraries/MoreDisks/MoreDisks.h</option>
<option value="listing104.html">/MIB-Libraries/MoreDisks/TestMoreDisks/TestMoreDisks.c</option>
<option value="listing105.html">/MIB-Libraries/MoreErrors/MoreErrors.c</option>
<option value="listing106.html">/MIB-Libraries/MoreErrors/MoreErrors.h</option>
<option value="listing107.html">/MIB-Libraries/MoreErrors/MoreErrors.r</option>
<option value="listing108.html">/MIB-Libraries/MoreEvents/MoreEvents.h</option>
<option value="listing109.html">/MIB-Libraries/MoreInterfaceLib/MoreInterfaceLib.c</option>
<option value="listing110.html">/MIB-Libraries/MoreInterfaceLib/MoreInterfaceLib.h</option>
<option value="listing111.html">/MIB-Libraries/MoreInterfaceLib/RemoteAccessInterface.h</option>
<option value="listing112.html">/MIB-Libraries/MoreInterfaceLib/TestMoreInterfaceLib/TestMoreInterfaceLib.c</option>
<option value="listing113.html">/MIB-Libraries/MoreIsBetter.h</option>
<option value="listing114.html">/MIB-Libraries/MoreLists/MoreLists.c</option>
<option value="listing115.html">/MIB-Libraries/MoreLists/MoreLists.h</option>
<option value="listing116.html">/MIB-Libraries/MoreMemory/MoreMemory.c</option>
<option value="listing117.html">/MIB-Libraries/MoreMemory/MoreMemory.h</option>
<option value="listing118.html">/MIB-Libraries/MoreMemory/TestMoreMemory/TestMoreMemory.c</option>
<option value="listing119.html">/MIB-Libraries/MoreMenus/MenuKeyGlyphs.h</option>
<option value="listing120.html">/MIB-Libraries/MoreMenus/MoreMenus.c</option>
<option value="listing121.html">/MIB-Libraries/MoreMenus/MoreMenus.h</option>
<option value="listing122.html">/MIB-Libraries/MoreMenus/MoreSystemMenus.c</option>
<option value="listing123.html">/MIB-Libraries/MoreMenus/MoreSystemMenus.h</option>
<option value="listing124.html">/MIB-Libraries/MoreMenus/TestMoreSystemMenus/TestMoreSystemMenus.c</option>
<option value="listing125.html">/MIB-Libraries/MoreMultiprocessing/MoreBlueActions.c</option>
<option value="listing126.html">/MIB-Libraries/MoreMultiprocessing/MoreBlueActions.h</option>
<option value="listing127.html">/MIB-Libraries/MoreMultiprocessing/MoreMPLog.c</option>
<option value="listing128.html">/MIB-Libraries/MoreMultiprocessing/MoreMPLog.h</option>
<option value="listing129.html">/MIB-Libraries/MoreNavigation/MoreNavigation.c</option>
<option value="listing130.html">/MIB-Libraries/MoreNavigation/MoreNavigation.h</option>
<option value="listing131.html">/MIB-Libraries/MoreOpenAndSave/MoreOpenAndSave.cp</option>
<option value="listing132.html">/MIB-Libraries/MoreOpenAndSave/MoreOpenAndSave.h</option>
<option value="listing133.html">/MIB-Libraries/MoreOpenTransport/MoreAutoPush.c</option>
<option value="listing134.html">/MIB-Libraries/MoreOpenTransport/MoreAutoPush.h</option>
<option value="listing135.html">/MIB-Libraries/MoreOpenTransport/MoreAutoPushTest/MoreAutoPushTest.c</option>
<option value="listing136.html">/MIB-Libraries/MoreOpenTransport/OTClassicContext.h</option>
<option value="listing137.html">/MIB-Libraries/MoreOpenTransport/OTClassicContextTest/OTClassicContextTest.c</option>
<option value="listing138.html">/MIB-Libraries/MoreOpenTransport/OTMP.c</option>
<option value="listing139.html">/MIB-Libraries/MoreOpenTransport/OTMP.h</option>
<option value="listing140.html">/MIB-Libraries/MoreOpenTransport/OTMPSimpleServerHTTP/OTMPSimpleServerHTTP.c</option>
<option value="listing141.html">/MIB-Libraries/MoreOpenTransport/OTMPSimpleServerHTTP/OTMPSimpleServerHTTP.h</option>
<option value="listing142.html">/MIB-Libraries/MoreOpenTransport/OTMPSimpleServerHTTP/OTMPSimpleServerHTTPTest.c</option>
<option value="listing143.html">/MIB-Libraries/MoreOpenTransport/OTMPSimpleServerHTTP/OTMPSimpleServerHTTPTest.r</option>
<option value="listing144.html">/MIB-Libraries/MoreOpenTransport/OTMPSimpleServerHTTP/Sample HTTP Source/index.html</option>
<option value="listing145.html">/MIB-Libraries/MoreOpenTransport/OTMPTest/OTMPTest.c</option>
<option value="listing146.html">/MIB-Libraries/MoreOpenTransport/Read_Me_About_OTMP.html</option>
<option value="listing147.html">/MIB-Libraries/MoreOpenTransport/ReadMeOTClassicContext.html</option>
<option value="listing148.html">/MIB-Libraries/MoreOSL/MoreOSL.c</option>
<option value="listing149.html">/MIB-Libraries/MoreOSL/MoreOSL.h</option>
<option value="listing150.html">/MIB-Libraries/MoreOSL/MoreOSLHelpers.c</option>
<option value="listing151.html">/MIB-Libraries/MoreOSL/MoreOSLHelpers.h</option>
<option value="listing152.html">/MIB-Libraries/MoreOSL/MoreOSLStringComp.applescript</option>
<option value="listing153.html">/MIB-Libraries/MoreOSL/MoreOSLStringCompare.c</option>
<option value="listing154.html">/MIB-Libraries/MoreOSL/MoreOSLStringCompare.h</option>
<option value="listing155.html">/MIB-Libraries/MoreOSL/MoreOSLTokens.c</option>
<option value="listing156.html">/MIB-Libraries/MoreOSL/MoreOSLTokens.h</option>
<option value="listing157.html">/MIB-Libraries/MoreOSL/ReadMe.html</option>
<option value="listing158.html">/MIB-Libraries/MoreOSL/TestMoreOSL/Test Script.applescript</option>
<option value="listing159.html">/MIB-Libraries/MoreOSL/TestMoreOSL/TestMoreOSL.c</option>
<option value="listing160.html">/MIB-Libraries/MoreOSL/TestMoreOSL/TestMoreOSLTerminology.h</option>
<option value="listing161.html">/MIB-Libraries/MoreOSL/TestMoreOSL/TestMoreOSLTerminology.r</option>
<option value="listing162.html">/MIB-Libraries/MoreOSUtils/MoreOSUtils.c</option>
<option value="listing163.html">/MIB-Libraries/MoreOSUtils/MoreOSUtils.h</option>
<option value="listing164.html">/MIB-Libraries/MoreOSUtils/TestMoreOSUtils/TestMoreOSUtils.c</option>
<option value="listing165.html">/MIB-Libraries/MorePatches/MoreCFMPatches/MoreCFMPatches.c</option>
<option value="listing166.html">/MIB-Libraries/MorePatches/MoreCFMPatches/MoreCFMPatches.h</option>
<option value="listing167.html">/MIB-Libraries/MorePatches/MoreCFMPatches/MoreCFMPatches.s</option>
<option value="listing168.html">/MIB-Libraries/MorePatches/MoreCFMPatches/MoreCFMPatchesTest/MoreCFMPatchesTest.c</option>
<option value="listing169.html">/MIB-Libraries/MorePreferences/MorePreferences.cp</option>
<option value="listing170.html">/MIB-Libraries/MorePreferences/MorePreferences.h</option>
<option value="listing171.html">/MIB-Libraries/MoreProcesses/MoreProcesses.cp</option>
<option value="listing172.html">/MIB-Libraries/MoreProcesses/MoreProcesses.h</option>
<option value="listing173.html">/MIB-Libraries/MoreProcesses/MoreScheduledExec.c</option>
<option value="listing174.html">/MIB-Libraries/MoreProcesses/MoreScheduledExec.h</option>
<option value="listing175.html">/MIB-Libraries/MoreProcesses/TestMoreScheduledExec/TestMoreScheduledExec.c</option>
<option value="listing176.html">/MIB-Libraries/MoreQuickDraw/MoreQuickDraw.cp</option>
<option value="listing177.html">/MIB-Libraries/MoreQuickDraw/MoreQuickDraw.h</option>
<option value="listing178.html">/MIB-Libraries/MoreResources/MoreResources.c</option>
<option value="listing179.html">/MIB-Libraries/MoreResources/MoreResources.h</option>
<option value="listing180.html">/MIB-Libraries/MoreSCF/MoreSCF.c</option>
<option value="listing181.html">/MIB-Libraries/MoreSCF/MoreSCF.h</option>
<option value="listing182.html">/MIB-Libraries/MoreSCF/MoreSCFCCLScanner.c</option>
<option value="listing183.html">/MIB-Libraries/MoreSCF/MoreSCFCCLScanner.h</option>
<option value="listing184.html">/MIB-Libraries/MoreSCF/MoreSCFDigest.c</option>
<option value="listing185.html">/MIB-Libraries/MoreSCF/MoreSCFDigest.h</option>
<option value="listing186.html">/MIB-Libraries/MoreSCF/MoreSCFHelpers.c</option>
<option value="listing187.html">/MIB-Libraries/MoreSCF/MoreSCFHelpers.h</option>
<option value="listing188.html">/MIB-Libraries/MoreSCF/MoreSCFPortScanner.c</option>
<option value="listing189.html">/MIB-Libraries/MoreSCF/MoreSCFPortScanner.h</option>
<option value="listing190.html">/MIB-Libraries/MoreSCF/MoreSCFTest/MoreSCFTest.c</option>
<option value="listing191.html">/MIB-Libraries/MoreSCF/ReadMeAboutMoreSCF.html</option>
<option value="listing192.html">/MIB-Libraries/MoreSecurity/MoreSecurity.c</option>
<option value="listing193.html">/MIB-Libraries/MoreSecurity/MoreSecurity.h</option>
<option value="listing194.html">/MIB-Libraries/MoreSecurity/MoreSecurityTest/MoreSecurityTest.c</option>
<option value="listing195.html">/MIB-Libraries/MoreSecurity/MoreSecurityTest/MoreSecurityTestCommon.h</option>
<option value="listing196.html">/MIB-Libraries/MoreSecurity/MoreSecurityTest/MoreSecurityTestTool.c</option>
<option value="listing197.html">/MIB-Libraries/MoreSecurity/ReadMeAboutMoreAuthSample.html</option>
<option value="listing198.html">/MIB-Libraries/MoreSetup.h</option>
<option value="listing199.html">/MIB-Libraries/MoreSetup.r</option>
<option value="listing200.html">/MIB-Libraries/MoreSound/MoreSound.cp</option>
<option value="listing201.html">/MIB-Libraries/MoreSound/MoreSound.h</option>
<option value="listing202.html">/MIB-Libraries/MoreTextUtils/MoreTextUtils.cp</option>
<option value="listing203.html">/MIB-Libraries/MoreTextUtils/MoreTextUtils.h</option>
<option value="listing204.html">/MIB-Libraries/MoreTextUtils/TestMoreTextUtils/TestMoreTextUtils.c</option>
<option value="listing205.html">/MIB-Libraries/MoreTextUtils/TestMoreTextUtils/TestMoreTextUtils.r</option>
<option value="listing206.html">/MIB-Libraries/MoreToolbox/MoreToolbox.cp</option>
<option value="listing207.html">/MIB-Libraries/MoreToolbox/MoreToolbox.h</option>
<option value="listing208.html">/MIB-Libraries/MoreUNIX/MoreUNIX.c</option>
<option value="listing209.html">/MIB-Libraries/MoreUNIX/MoreUNIX.h</option>
<option value="listing210.html">/MIB-Libraries/MoreWindows/MoreWindows.cp</option>
<option value="listing211.html">/MIB-Libraries/MoreWindows/MoreWindows.h</option>
<option value="listing212.html">/MIB-Libraries/NetworkSetup/MoreNetworkSetup.c</option>
<option value="listing213.html">/MIB-Libraries/NetworkSetup/MoreNetworkSetup.h</option>
<option value="listing214.html">/MIB-Libraries/NetworkSetup/Network Setup SDK Bits/ Read Me.txt</option>
<option value="listing215.html">/MIB-Libraries/NetworkSetup/Network Setup SDK Bits/NetworkSetupBigPicture.html</option>
<option value="listing216.html">/MIB-Libraries/NetworkSetup/NetworkSetupHelpers.c</option>
<option value="listing217.html">/MIB-Libraries/NetworkSetup/NetworkSetupHelpers.h</option>
<option value="listing218.html">/MIB-Libraries/NetworkSetup/NetworkSetupTest/NetworkSetupTest.c</option>
<option value="listing219.html">/MIB-Libraries/NetworkSetup/OldStyleAPI/OldOTConfigLib.h</option>
<option value="listing220.html">/MIB-Libraries/NetworkSetup/ReadMe.html</option>
<option value="listing221.html">/MIB-Libraries/PascalInterfaces/MoreSetup.p</option>
<option value="listing222.html">/MIB-Libraries/PascalInterfaces/TradDriverLoaderLib.p</option></select>
				</p>
				</form>
				<p><strong><a href="MoreIsBetter.zip">Download Sample</a></strong> (&#147;MoreIsBetter.zip&#148;, 1.61M)<BR>
<strong><a href="MoreIsBetter.dmg">Download Sample</a></strong> (&#147;MoreIsBetter.dmg&#148;, 2.04M)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*
  File:    MoreBacktrace.c

  Contains:  Code for generating backtraces.

  Written by:  Quinn

  Copyright:  Copyright (c) 2003 by Apple Computer, Inc., All Rights Reserved.

  Disclaimer:  IMPORTANT:  This Apple software is supplied to you by Apple Computer, Inc.
        (&quot;Apple&quot;) in consideration of your agreement to the following terms, and your
        use, installation, modification or redistribution of this Apple software
        constitutes acceptance of these terms.  If you do not agree with these terms,
        please do not use, install, modify or redistribute this Apple software.

        In consideration of your agreement to abide by the following terms, and subject
        to these terms, Apple grants you a personal, non-exclusive license, under Apple's
        copyrights in this original Apple software (the &quot;Apple Software&quot;), to use,
        reproduce, modify and redistribute the Apple Software, with or without
        modifications, in source and/or binary forms; provided that if you redistribute
        the Apple Software in its entirety and without modifications, you must retain
        this notice and the following text and disclaimers in all such redistributions of
        the Apple Software.  Neither the name, trademarks, service marks or logos of
        Apple Computer, Inc. may be used to endorse or promote products derived from the
        Apple Software without specific prior written permission from Apple.  Except as
        expressly stated in this notice, no other rights or licenses, express or implied,
        are granted by Apple herein, including but not limited to any patent rights that
        may be infringed by your derivative works or by other works in which the Apple
        Software may be incorporated.

        The Apple Software is provided by Apple on an &quot;AS IS&quot; basis.  APPLE MAKES NO
        WARRANTIES, EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION THE IMPLIED
        WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY AND FITNESS FOR A PARTICULAR
        PURPOSE, REGARDING THE APPLE SOFTWARE OR ITS USE AND OPERATION ALONE OR IN
        COMBINATION WITH YOUR PRODUCTS.

        IN NO EVENT SHALL APPLE BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL OR
        CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
        GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
        ARISING IN ANY WAY OUT OF THE USE, REPRODUCTION, MODIFICATION AND/OR DISTRIBUTION
        OF THE APPLE SOFTWARE, HOWEVER CAUSED AND WHETHER UNDER THEORY OF CONTRACT, TORT
        (INCLUDING NEGLIGENCE), STRICT LIABILITY OR OTHERWISE, EVEN IF APPLE HAS BEEN
        ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

  Change History (most recent first):

$Log: MoreBacktrace.c,v $
Revision 1.3  2003/04/09 22:48:11         
Added comments.

Revision 1.2  2003/04/09 22:30:14         
Lots of changes.  Rewrote the core to work properly.  We now handle leaf routines correctly in the common cases, and document the cases that we don't handle.  Also added lots of comments.

Revision 1.1  2003/04/04 15:03:04         
First checked in.  This code still has bugs, but I've written enough code that checking in is a good idea.


*/

/////////////////////////////////////////////////////////////////

// Our Prototypes

#include &quot;MoreBacktrace.h&quot;

// Mac OS Interfaces

#if ! MORE_FRAMEWORK_INCLUDES
  #include &lt;MachineExceptions.h&gt;
  #include &lt;MacErrors.h&gt;
  #include &lt;Gestalt.h&gt;
#endif

#include &lt;string.h&gt;

// MIB Prototypes

#include &quot;MoreCFQ.h&quot;
#include &quot;MoreOSUtils.h&quot;

/////////////////////////////////////////////////////////////////
#pragma mark ***** PowerPC Backtrace Core

/*  PowerPC Stack Frame Basics
  --------------------------
  
          Size  Purpose
          ----  -------
  low memory -&gt;  0x004  pointer to next frame
          0x004  place to save CR
          0x004  place to save LR
          0x008  reserved
  high memory -&gt;  0x004  place to save TOC (CFM only)
          
          To get from one frame to the next, you have to indirect 
          through an offset of 0 (kMoreBTPPCOffsetToSP).  To 
          extract the return address from a frame, you have to 
          indirect an offset of 8 (kMoreBTPPCOffsetToLR).
*/

enum {
  kMoreBTPPCOffsetToSP  = 0,
  kMoreBTPPCOffsetToLR   = 8
};

/*  PowerPC Signal Stack Frames
  ---------------------------
  In the current Mac OS X architecture, there is no guaranteed reliable 
  way to backtrace a signal stack frame.  The problem is that the kernel 
  pushes a variable amount of data on to the stack when it invokes the 
  user space signal trampoline (_sigtramp), and the only handle to the 
  information about how much data was pushed is passed in a register 
  parameter to _sigtramp.  _sigtramp stashes that value away in a 
  non-volatile register.  So, when _sigtramp calls the user-supplied 
  signal handler, there's no way to work out where that register 
  ends up being saved.
  
  Thus, we devolve into guesswork.  It turns out that the offset from 
  the stack of the kernel data to the information we need (the place 
  where the interrupted thread's SP was stored) is a constant for any 
  given system release.  So, we can just simply add the appropriate 
  offset to the frame pointer and grab the data we need.
  
  The problem is that this constant varies from release to release. 
  This code handles the two significant cases that I know about, 
  namely Mac OS X 10.1.x and Mac OS X 10.2.x.  There's no guarantee 
  that this offset won't change again in the future.

  When the kernel invokes the user space signal trampoline, it pushes 
  the following items on to the stack.
  
  Mac OS X 10.1.x
  ---------------
          Size  Purpose
          ----  -------
  low memory -&gt;  0x030   bytes for C linkage
          0x040   bytes for saving PowerPC parameters
          0x0c0  ppc_saved_state
          0x110  ppc_float_state
          0x018  struct sigcontext
  high memory -&gt;  0x0e0  red zone
  
          The previous frame's SP is at offset 0x00C within 
          ppc_saved_state, which makes 
          kMoreBTPPCOffsetToSignalSPTenOne equal to 
          0x030 + 0x040 + 0x00C, or 0x07C.
                                  
  Mac OS X 10.2.x
  ---------------
          Size  Purpose
          ----  -------
  low memory -&gt;  0x030   bytes for C linkage
          0x040   bytes for saving PowerPC parameters
          0x008  alignment padding
          0x408   struct mcontext, comprised of:
                 0x020 ppc_exception_state_t
                 0x0A0 ppc_thread_state_t
                 0x108 ppc_float_state_t
                 0x240 ppc_vector_state_t
          0x040  siginfo_t
          0x020  ucontext
  high memory -&gt;  0x0e0  red zone
  
          The previous frame's SP is at offset 0x00C within 
          ppc_thread_state_t, which makes 
          kMoreBTPPCOffsetToSignalSPTenTwo equal to 
          0x030 + 0x040 + 0x008 + 0x020 + 0x00C, or 0x0A4.
*/

enum {
  kMoreBTPPCOffsetToSignalSPTenOne = 0x07C,
  kMoreBTPPCOffsetToSignalSPTenTwo = 0x0A4
};

/*  PowerPC Signal Stack Frames (cont)
  ----------------------------------
  The only remotely reliable way to detect a signal stack frame is to 
  look at the return address to see whether it points within the 
  _sigtramp routine.  I can find the address of this routine via 
  the dynamic linker, but I don't have an easy way to determine it's 
  length.  So I just guess!  And here's the number I chose.  See 
  MoreBTPPCFindSigTrampAddress for more details on this.
*/

enum {
  kMoreBTPPCSigTrampSize  = 256
};

typedef struct MoreBTPPCContext MoreBTPPCContext;

typedef OSStatus (*MoreBTReadBytesProc)(MoreBTPPCContext *context, MoreBTPPCAddr src, void *dst, ByteCount size);
  // This function pointer is called by the core backtrace code 
  // when it needs to read memory.  The callback should do a safe 
  // read of size bytes from src into the buffer specified by 
  // dst.  By &quot;safe&quot; we mean that the routine should return an error 
  // if the read can't be done (typically because src is a pointer to 
  // unmapped memory).

// The MoreBTPPCContext structure is used by the core backtrace code 
// to maintain its state.

struct MoreBTPPCContext {

  // Internal parameters that are set up by the caller 
  // of the core backtrace code.
  
  ByteCount        offsetToSignalSP;
  MoreBTPPCAddr      sigTrampLowerBound;
  MoreBTPPCAddr      sigTrampUpperBound;
  MoreBTReadBytesProc   readBytes;
  void *          refCon;
  
  // Parameters from client.
  
  MoreBTPPCAddr  pc;
  MoreBTPPCAddr  r0;      // see MoreBTPPCCheckLeaf
  MoreBTPPCAddr  sp;
  MoreBTPPCAddr  lr;
  MoreBTPPCAddr  stackBottom;
  MoreBTPPCAddr  stackTop;
  MoreBTPPCFrame *frameArray;        // array contents filled out by core
  ItemCount     frameArrayCount;
  ItemCount     frameCountOut;      // returned by core
};

static OSStatus ReadPPCAddr(MoreBTPPCContext *context, MoreBTPPCAddr addr, MoreBTPPCAddr *value)
  // Reads a PowerPC address (ie a pointer) from the target task, 
  // returning an error if the memory is unmapped.
{
  return context-&gt;readBytes(context, addr, value, sizeof(*value));
}

static OSStatus ReadPPCInst(MoreBTPPCContext *context, MoreBTPPCAddr addr, MoreBTPPCInst *value)
  // Reads a PowerPC instruction from the target task, 
  // returning an error if the memory is unmapped.
{
  return context-&gt;readBytes(context, addr, value, sizeof(*value));
}

static OSStatus MoreBTPPCCheckLeaf(MoreBTPPCContext *context)
  // The top most frame may be in a weird state because of the 
  // possible variations in the routine prologue.  There are a 
  // variety of combinations, such as:
  //
  // 1. a normal routine, with its return address stored in 
  //    its caller's stack frame
  //
  // 2. a system call routine, which is a leaf routine with 
  //    no frame and the return address is in LR
  //
  // 3. a leaf routine with no frame, where the return address 
  //    is in LR
  //
  // 4. a leaf routine with no frame that accesses a global, where 
  //    the return address is in R0
  //
  // 5. a normal routine that was stopped midway through 
  //    constructing its prolog, where the return address is 
  //    typically in R0
  //
  // Of these, 1 and 2 are most common, and they're the cases I 
  // handle.  General support for all of the cases requires the 
  // ability to accurately determine the start of the routine 
  // which is not something that I can do with my current 
  // infrastructure.
  //
  // Note that don't handle any cases where the return address is 
  // in R0, although I do have a variable for R0 in the context 
  // in case I add that handling in the future.
{
  OSStatus    err;
  Boolean      isSystemCall;
  MoreBTPPCInst   inst;
  MoreBTPPCInst  pc;
  int        count;

  // Using the PC from the top frame (frame[0]), walk back through 
  // the code stream for 3 instructions looking for a &quot;sc&quot; instruction. 
  // If we find one, it's almost certain that we're in a system call 
  // frameless leaf routine.

  isSystemCall = false;
  count = 0;
  pc = context-&gt;pc;
  do {
    err = ReadPPCInst(context, pc, &amp;inst);
    if (err == noErr) {
      isSystemCall = (inst == 0x44000002);      // PPC &quot;sc&quot; instruction
    }
    if ( (err == noErr) &amp;&amp; ! isSystemCall ) {
      count += 1;
      pc -= sizeof(MoreBTPPCInst);
    }
  } while ( (err == noErr) &amp;&amp; ! isSystemCall &amp;&amp; (count &lt; 3) );
  err = noErr;
  
  // If we find that we're in a system call frameless leaf routine, 
  // te add a dummy stack frame (with no frame, because the frame actually 
  // belows to frameArray[1]).

  if (isSystemCall) {
    if ( (context-&gt;frameArray != NULL) &amp;&amp; (context-&gt;frameCountOut &lt; context-&gt;frameArrayCount) ) {
      MoreBTPPCFrame *  frameOutPtr;

      frameOutPtr = &amp;context-&gt;frameArray[context-&gt;frameCountOut];
      frameOutPtr-&gt;pc    = context-&gt;pc;
      frameOutPtr-&gt;sp    = 0;
      frameOutPtr-&gt;flags = kMoreBTFrameBadMask;
    }
    context-&gt;frameCountOut += 1;

    context-&gt;pc = context-&gt;lr;
  }

  return err;
}

static OSStatus MoreBacktracePPCCore(MoreBTPPCContext *context)
  // The core backtrace code.  This routine is called by all of the various 
  // exported routines.  It implements the core backtrace functionality. 
  // All of the parameters to this routine are contained within 
  // the context.  This routine traces back through the stack (using the 
  // readBytes callback in the context to actually read memory) creating 
  // a backtrace.
{
  OSStatus     err;
  MoreBTPPCAddr  thisPC;
  MoreBTPPCAddr  thisFrame;
  MoreBTPPCAddr  lowerBound;
  MoreBTPPCAddr  upperBound;
  Boolean      stopNow;
  
  assert(context != NULL);
  assert( (context-&gt;frameArrayCount == 0) || (context-&gt;frameArray != NULL) );
  // You're allowed a NULL frameArray if frameArrayCount is 0.
  assert( ((context-&gt;sigTrampLowerBound == 0) &amp;&amp; (context-&gt;sigTrampUpperBound == 0)) 
      || (context-&gt;sigTrampUpperBound &gt; context-&gt;sigTrampLowerBound) );
  assert( context-&gt;readBytes != NULL );
  
  lowerBound = context-&gt;stackBottom;
  upperBound = context-&gt;stackTop;
  if (upperBound == 0) {
    upperBound = (MoreBTPPCAddr) -1;
  }
  
  // If you supply bounds, they must make sense.
  
  assert(upperBound &gt; lowerBound);

  // Check the current PC and add a dummy frame if it points to 
  // a frameless leaf routine.
  
  context-&gt;frameCountOut = 0;
  err = MoreBTPPCCheckLeaf(context);
  
  // Handle the normal frames.
  
  if (err == noErr) {
    thisPC     = context-&gt;pc;
    thisFrame  = context-&gt;sp;
    
    stopNow = false;
    do {
      MoreBTPPCFrame *  frameOutPtr;
      MoreBTPPCFrame       tmpFrameOut;
      MoreBTPPCAddr     nextFrame;
      MoreBTPPCAddr     nextPC;
      MoreBTPPCInst    junkInst;
      
      // Output to a tmpFrameOut unless the client has supplied 
      // a buffer and there's sufficient space left in it.
      
      if ( (context-&gt;frameArray != NULL) &amp;&amp; (context-&gt;frameCountOut &lt; context-&gt;frameArrayCount) ) {
        frameOutPtr = &amp;context-&gt;frameArray[context-&gt;frameCountOut];
      } else {
        frameOutPtr = &amp;tmpFrameOut;
      }
      context-&gt;frameCountOut += 1;

      // Record this entry.
      
      frameOutPtr-&gt;pc    = thisPC;
      frameOutPtr-&gt;sp    = thisFrame;
      frameOutPtr-&gt;flags = 0;
      
      // Now set the flags to indicate the validity of specific information. 
      
      // Check the validity of the PC.  Don't set the err here; a bad PC value 
      // does not cause us to quit the backtrace.
      
      if ( (((int) thisPC) &amp; 0x03) || (ReadPPCInst(context, thisPC, &amp;junkInst) != noErr) ) {
        frameOutPtr-&gt;flags |= kMoreBTPCBadMask;
      } else {
        // The PC always points to the instruction after the call 
        // instruction, so step it back by one instruction.
        frameOutPtr-&gt;pc -= sizeof(MoreBTPPCInst);
      }
      
      // Check the validity of the frame pointer.  A bad frame pointer *does* 
      // cause us to stop tracing.
      
      if ( (thisFrame == NULL) || (((int) thisFrame) &amp; 0x03) || (thisFrame &lt; lowerBound) || (thisFrame &gt;= upperBound) ) {
        frameOutPtr-&gt;flags |= kMoreBTFrameBadMask;
        stopNow = true;
      }

      if (err == noErr &amp;&amp; ! stopNow) {
      
        // Read the next frame pointer.  Again, a failure here causes us to quit 
        // backtracing.  Note that we set kMoreBTFrameBadMask in frameOutPtr 
        // because, if we can't read the contents of the frame pointer, the 
        // frame pointer itself must be bad.
        
        err = ReadPPCAddr(context, thisFrame + kMoreBTPPCOffsetToSP, &amp;nextFrame);
        if (err != noErr) {
          frameOutPtr-&gt;flags |= kMoreBTFrameBadMask;
          // No need to set stopNow because err != noErr will 
          // terminate loop.
        }

        // If the next frame pointer indicates that this frame was called 
        // as a signal handler, handle the discontinuity in the stack.
        
        if (err == noErr) {
          // Extract the LR from the stack frame.    Note that we have to do 
          // this before we check for a signal frame because the PC of 
          // the frame that was interrupted by the signal is stored 
          // in this nextFrame, not in the one we'll get by delving 
          // into the signal handler stack block.
          
          if ( ReadPPCAddr(context, nextFrame + kMoreBTPPCOffsetToLR, &amp;nextPC) != noErr ) {
            nextPC = (MoreBTPPCAddr) -1;    // an odd value, to trigger above check on next iteration
          }
          
          // If this frame is running in _sigtramp, get nextFrame by 
          // delving into the signal handler stack block.
          
          if (      !(frameOutPtr-&gt;flags &amp; kMoreBTPCBadMask) 
              &amp;&amp; ( frameOutPtr-&gt;pc &gt;= context-&gt;sigTrampLowerBound ) 
              &amp;&amp; ( frameOutPtr-&gt;pc &lt;  context-&gt;sigTrampUpperBound ) ) {
            frameOutPtr-&gt;flags |= kMoreBTSignalHandlerMask;
            err = ReadPPCAddr(context, nextFrame + context-&gt;offsetToSignalSP, &amp;nextFrame);
          }
        }

        // Set up for the next iteration.
        
        if (err == noErr) {
          lowerBound = thisFrame;
          thisPC     = nextPC;
          thisFrame  = nextFrame;
        }
      }
    } while ( (err == noErr) &amp;&amp; ! stopNow );
  }
  
  return err;
}

static CFBundleRef gSystemFramework = NULL;

static OSStatus MoreBTPPCFindSigTrampAddress(MoreBTPPCContext *context)
  // This routine finds the address of _sigtramp routine and 
  // initialises the sigTrampLowerBound and sigTrampUpperBound 
  // fields of the context appropriately.  We need this information 
  // to backtrace through signals properly.
  //
  // IMPORTANT:
  // This code makes the assumption that _sigtramp is mapped 
  // in the target task at the same location as it is in the 
  // current task.  That may not be the case.   For example, 
  // if MoreBacktrace is running inside an application using a 
  // non-debug version of System framework while the target 
  // application is using a debug version of System framework.  
  // What I need to do (and what vmutils framework does) is grab 
  // the address of _sigtramp from the target task.  However, 
  // the technology to do this is tricky.  For the moment I 
  // have to live with this simplifying assumption.  Fortunately, 
  // the consequences of getting it wrong are not terribly: a 
  // backtrace will not navigate a signal stack frame correctly.
  //
  // Another limitation of this routine is that it simply guesses 
  // the size of _sigtramp (kMoreBTPPCSigTrampSize) rather than 
  // finding the end of the routine properly.  Again, I'm missing 
  // a fundamental piece of technology and I have to live with the 
  // consequences.  Fortunately, this is rarely a problem.
{
  OSStatus err;
  const void *sigTrampAddr;
  
  // Connect to &quot;System.framework&quot; and get a pointer to the _sigtramp routine.
  
  err = noErr;
  if (gSystemFramework == NULL) {
    err = CFQBundleCreateFromFrameworkName(CFSTR(&quot;System.framework&quot;), &amp;gSystemFramework);
  }
  assert( (err != noErr) || (gSystemFramework != NULL) );
  if (err == noErr) {
    sigTrampAddr = CFBundleGetFunctionPointerForName(gSystemFramework, CFSTR(&quot;_sigtramp&quot;));
    err = CFQError(sigTrampAddr);
  }

  // Set sigTrampLowerBound and sigTrampUpperBound.
  
  if (err == noErr) {
  
    // If we're CFM then CFBundle returns a TVector pointer rather than 
    // a straight function pointer.  We have to undo that in the CFM case.
    
    #if TARGET_RT_MAC_CFM
      context-&gt;sigTrampLowerBound = *((MoreBTPPCAddr *) sigTrampAddr);
    #else
      context-&gt;sigTrampLowerBound = (MoreBTPPCAddr) sigTrampAddr;
    #endif

    // We can't actually determine the size of _sigtramp with our current 
    // technology, so we just guess at the upper bound.
    
    context-&gt;sigTrampUpperBound = context-&gt;sigTrampLowerBound + kMoreBTPPCSigTrampSize;
  }
  
  // We know the actual locations of _sigtramp on 10.1.x and 10.2.x so, just 
  // for debugging, sanity check our numbers.  Of course, if we run with the 
  // _debug libraries, these numbers are not valid, so only do the check in 
  // that case.
  
  #if MORE_DEBUG
    #if TARGET_RT_MAC_MACHO
      if (err == noErr) {
        const char *imageSuffix;
        
        imageSuffix = getenv(&quot;DYLD_IMAGE_SUFFIX&quot;);
        if ( (imageSuffix != NULL) &amp;&amp; (strcmp(imageSuffix, &quot;_debug&quot;) != 0) ) {
          if ( (MoreGetSystemVersion() &amp; 0x0FFF0) == 0x01010 ) {
            assert( (0x7000ee8c &gt;= context-&gt;sigTrampLowerBound) &amp;&amp; (0x7000ee8c &lt; context-&gt;sigTrampUpperBound) );
          } else if ( (MoreGetSystemVersion() &amp; 0x0FFF0) == 0x01020 ) {
            assert( (0x9000fa8c &gt;= context-&gt;sigTrampLowerBound) &amp;&amp; (0x9000fa8c &lt; context-&gt;sigTrampUpperBound) );
            assert( (0x9000fa9c &gt;= context-&gt;sigTrampLowerBound) &amp;&amp; (0x9000fa9c &lt; context-&gt;sigTrampUpperBound) );
          }
        }
      }
    #endif
  #endif
  
  return err;
}

static OSStatus InitMoreBTPPCContext(MoreBTPPCContext *context,
                  MoreBTPPCAddr stackBottom, MoreBTPPCAddr stackTop,
                  MoreBTPPCFrame *frameArray, ItemCount frameArrayCount)
  // Initialises a MoreBTPPCContext to appropriate default values.
{
  OSStatus err;
    
  memset(context, 0, sizeof(context));
  
  // We don't check the input parameters here.  Instead the 
  // check is done by the backtrace core.
  
  context-&gt;stackBottom     = stackBottom;
  context-&gt;stackTop        = stackTop;
  context-&gt;frameArray      = frameArray;
  context-&gt;frameArrayCount = frameArrayCount;
  
  // Some system version specific parameters:
  //
  // o _sigtramp is irrelevant on traditional Mac OS.
  // o We don't support Mac OS X 10.0.x.
  // o offsetToSignalSP changed between 10.1.x and 10.2.x.
  
  err = noErr;
  if ( MoreGetSystemVersion() &lt; 0x01000 ) {
    context-&gt;offsetToSignalSP   = 0;
    context-&gt;sigTrampLowerBound = NULL;
    context-&gt;sigTrampUpperBound = NULL;
  } else if ( MoreGetSystemVersion() &lt; 0x01010 ) {
    err = unimpErr;
  } else {
    if ( MoreGetSystemVersion() &lt; 0x01020 ) {
      context-&gt;offsetToSignalSP = kMoreBTPPCOffsetToSignalSPTenOne;
    } else {
      context-&gt;offsetToSignalSP = kMoreBTPPCOffsetToSignalSPTenTwo;
    }
    
    err = MoreBTPPCFindSigTrampAddress(context);
  }
  
  return err;
}

/////////////////////////////////////////////////////////////////
#pragma mark ***** Carbon Interface

// The Carbon interface assumes that you are running within 
// the process is being backtraced.  Thus, it's only available 
// if TARGET_CPU_PPC.

#if TARGET_CPU_PPC

  static ExceptionHandlerTPP gMoreBTReadBytesCarbonExceptionHandlerUPP;    // -&gt; MoreBTReadBytesCarbonExceptionHandler

  static SInt32 gExceptionCount = NULL;

  static OSStatus MoreBTReadBytesCarbonExceptionHandler(ExceptionInformation * theException)
    // This is a Carbon exception handler established by MoreBTReadBytesCarbon.
    // We increment gExceptionCount and then, if the exception is memory related, 
    // we simply step over the offending instruction.
  {
    OSStatus err;
    
    gExceptionCount += 1;
    
    switch (theException-&gt;theKind) {
      case kAccessException:
      case kUnmappedMemoryException:
      case kExcludedMemoryException:
      case kReadOnlyMemoryException:
      case kUnresolvablePageFaultException:
        theException-&gt;machineState-&gt;PC.lo += 4;    // skip over load instruction
        err = noErr;
        break;
      default:
        err = -1;
        break;
    }

    return err;
  }

  static OSStatus MoreBTReadBytesCarbon(MoreBTPPCContext *context, MoreBTPPCAddr src, void *dst, ByteCount size)
    // A memory read callback for Carbon (see MoreBTReadBytesProc). 
    // This uses the Carbon exception handler mechanism to detect 
    // whether we've hit bad memory.  It's this routine that makes 
    // the Carbon calls not thread safe.  The exception handler 
    // installed by InstallExceptionHandler is global to the 
    // entire process.
    //
    // *** Maybe I could use an MP exception handler here?
  {
    OSStatus       err;
    ExceptionHandlerTPP oldHandler;
    UInt32        tmp;
    #pragma unused(context)

    if (gMoreBTReadBytesCarbonExceptionHandlerUPP == NULL) {
      gMoreBTReadBytesCarbonExceptionHandlerUPP = NewExceptionHandlerUPP(MoreBTReadBytesCarbonExceptionHandler);
    }
    assert(gMoreBTReadBytesCarbonExceptionHandlerUPP != NULL);
    
    // Right now we only support word reads on a word boundary.
    // I could lift this restriction if necessary, but the current 
    // core code doesn't require that so why bother.
    
    err = noErr;
    if ( (size != sizeof(UInt32)) || (((int) src) &amp; 0x03) ) {
      err = paramErr;
    }
    
    if (err == noErr) {
      SInt32 previousExceptionCount;
      
      previousExceptionCount = gExceptionCount;
      
      oldHandler = InstallExceptionHandler(gMoreBTReadBytesCarbonExceptionHandlerUPP);
      
      tmp = *((volatile UInt32 *)src);
      
      (void) InstallExceptionHandler(oldHandler);
      
      // If gExceptionCount didn't increment, we succesfully read the 
      // memory.
      
      if ( gExceptionCount == previousExceptionCount ) {
        *((UInt32 *)dst) = tmp;
      } else {
        err = noHardwareErr;
      }
    }
    
    return err;
  }

  extern pascal OSStatus MoreBacktracePPCCarbon(MoreBTPPCAddr pc, MoreBTPPCAddr sp, 
                        MoreBTPPCAddr stackBottom, MoreBTPPCAddr stackTop,
                        MoreBTPPCFrame *frameArray, ItemCount frameArrayCount, ItemCount *frameCount)
    // See comments in header.
  {
    OSStatus       err;
    MoreBTPPCContext   context;
    
    err = InitMoreBTPPCContext(&amp;context, stackBottom, stackTop, frameArray, frameArrayCount);
    if (err == noErr) {
      context.pc = pc;
      context.sp = sp;
      context.readBytes = MoreBTReadBytesCarbon;
      context.refCon    = NULL;
      
      err = MoreBacktracePPCCore(&amp;context);
    }
    if (frameCount != NULL) {
      *frameCount = context.frameCountOut;
    }
    return err;
  }

#endif    // TARGET_CPU_PPC

/////////////////////////////////////////////////////////////////
#pragma mark ***** Mach Interface

// The Mach interface works accesses all backtrace memory via 
// Mach VM calls, and thus there's the potential for it to execute 
// on a instruction set architecture other than the one being 
// backtraced.  Hence, there's no requirement for TARGET_CPU_PPC here.

#if TARGET_RT_MAC_MACHO

  static OSStatus MoreBTReadBytesMach(MoreBTPPCContext *context, MoreBTPPCAddr src, void *dst, ByteCount size)
    // A memory read callback for Mach (see MoreBTReadBytesProc). 
    // This simply calls through to the Mach vm_read_overwrite 
    // primitive, which does exactly what we want.
  {
    OSStatus   err;
    vm_size_t   sizeRead;
    
    sizeRead = size;
    err = vm_read_overwrite( (thread_t) context-&gt;refCon, (vm_address_t) src, size, (vm_address_t) dst, &amp;sizeRead);
    if ( (err == noErr) &amp;&amp; (sizeRead != size) ) {
      assert(false);
      err = -1;
    }
    return err;
  }

  extern pascal OSStatus MoreBacktracePPCMach(task_t task, MoreBTPPCAddr pc, MoreBTPPCAddr sp,
                        MoreBTPPCAddr stackBottom, MoreBTPPCAddr stackTop,
                        MoreBTPPCFrame *frameArray, ItemCount frameArrayCount, ItemCount *frameCount)
    // See comments in header.
  {
    OSStatus       err;
    MoreBTPPCContext   context;
    
    err = InitMoreBTPPCContext(&amp;context, stackBottom, stackTop, frameArray, frameArrayCount);
    if (err == noErr) {
      context.pc = pc;
      context.sp = sp;
      context.readBytes = MoreBTReadBytesMach;
      context.refCon    = (void *) task;
      
      err = MoreBacktracePPCCore(&amp;context);
    }
    if (frameCount != NULL) {
      *frameCount = context.frameCountOut;
    }
    return err;
  }

  extern pascal OSStatus MoreBacktracePPCMachThread(task_t task, thread_t thread,
                        MoreBTPPCAddr stackBottom, MoreBTPPCAddr stackTop,
                        MoreBTPPCFrame *frameArray, ItemCount frameArrayCount, ItemCount *frameCount)
    // See comments in header.
    //
    // This doesn't call through to MoreBacktracePPCMach because 
    // there is more context information beyond the pc and sp.
  {
    OSStatus         err;
    ppc_thread_state_t     state;
    mach_msg_type_number_t   stateCount; 
    MoreBTPPCContext     context;
    
    err = InitMoreBTPPCContext(&amp;context, stackBottom, stackTop, frameArray, frameArrayCount);
    
    // Get the state of the target thread and use that to initialise the 
    // backtrace context.

    if (err == noErr) {
      stateCount = PPC_THREAD_STATE_COUNT;
      
      err = thread_get_state(thread, PPC_THREAD_STATE, (thread_state_t) &amp;state, &amp;stateCount);
    }
    if (err == noErr) {
      assert(stateCount == PPC_THREAD_STATE_COUNT);

      context.pc = state.srr0;
      context.r0 = state.r0;
      context.sp = state.r1;
      context.lr = state.lr;

      context.readBytes = MoreBTReadBytesMach;
      context.refCon    = (void *) task;

      err = MoreBacktracePPCCore(&amp;context);
    }
    if (frameCount != NULL) {
      *frameCount = context.frameCountOut;
    }
    return err;
  }

#endif    // TARGET_RT_MAC_MACHO

/////////////////////////////////////////////////////////////////
#pragma mark ***** Assembly Stuff

// The following is an inline assembly abstraction layer that isolates 
// the rest of the code from the specific compiler's flavour of assembly. 
// Note that this is not as clean as I'd like it to be.  Specifically, 
// MoreBTPPCGetProgramCounter is a nice function definition, but 
// MoreBTPPCGetStackPointer is a macro.  If I define MoreBTPPCGetStackPointer 
// as a function, I have problems because GCC insists on building a 
// stack from in non-optimised builds but no stack frame in optimised 
// builds.  That makes things tricky.  So, instead, I use a macro that 
// expands inside the function itself.  This causes other issues.  
// For example, in MoreBacktracePPCCarbonSelf I had to name the local 
// variable &quot;mySP&quot; and not &quot;sp&quot;, because otherwise the CodeWarrior 
// inline assembler can't distinguish between the variable and the 
// register.  Also, mySP has to qualified as &quot;register&quot; for the sake 
// of the CodeWarrior inline assembler.  Fortunately, these changes 
// do not cause problems for GCC.

// Obviously the &quot;Self&quot; calls require TARGET_CPU_PPC.

#if TARGET_CPU_PPC

  #if defined(__MWERKS__)

        #define MoreBTPPCGetStackPointer(result)            \
                asm {  addi  result,sp,0    }

    asm static MoreBTPPCAddr MoreBTPPCGetProgramCounter(void)
    {
      mflr    r3
      blr
    }
  
  #elif defined(__GNUC__) &amp;&amp; ( defined(__APPLE_CPP__) || defined(__APPLE_CC__) || defined(__MACOS_CLASSIC__) )

        #define MoreBTPPCGetStackPointer(result)            \
                __asm__ volatile(&quot;mr    %0,r1&quot; : &quot;=r&quot; (result));

        static MoreBTPPCAddr MoreBTPPCGetProgramCounter(void)
    {
            MoreBTPPCAddr result;
            __asm__ volatile(&quot;mflr    %0&quot; : &quot;=r&quot; (result));
            return result;
    }

  #else
    #error MoreBacktrace: What compiler are you using?
  #endif

  extern pascal OSStatus MoreBacktracePPCCarbonSelf(
                        MoreBTPPCAddr stackBottom, MoreBTPPCAddr stackTop,
                        MoreBTPPCFrame *frameArray, ItemCount frameArrayCount, ItemCount *frameCount)
    // See comments in header.
  {
    register MoreBTPPCAddr mySP;
    MoreBTPPCAddr myPC;
    
    // For more information about these inline assembly routines, 
    // see the &quot;***** Assembly Stuff&quot; comment above.
    
    MoreBTPPCGetStackPointer(mySP);
    myPC = MoreBTPPCGetProgramCounter();
    
    return MoreBacktracePPCCarbon(myPC, mySP, stackBottom, stackTop, frameArray, frameArrayCount, frameCount);
  }

  #if TARGET_RT_MAC_MACHO

    extern pascal OSStatus MoreBacktracePPCMachSelf(
                          MoreBTPPCAddr stackBottom, MoreBTPPCAddr stackTop,
                          MoreBTPPCFrame *frameArray, ItemCount frameArrayCount, ItemCount *frameCount)
      // See comments in header.
    {
      register MoreBTPPCAddr mySP;
      MoreBTPPCAddr myPC;
      
      // For more information about these inline assembly routines, 
      // see the &quot;***** Assembly Stuff&quot; comment above.

      MoreBTPPCGetStackPointer(mySP);
      myPC = MoreBTPPCGetProgramCounter();
      
      return MoreBacktracePPCMach(mach_task_self(), myPC, mySP, stackBottom, stackTop, frameArray, frameArrayCount, frameCount);
    }

  #endif    // TARGET_RT_MAC_MACHO

#endif    // TARGET_CPU_PPC
</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/MoreIsBetter/listing83.html%3Fid%3DDTS10000732-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/MoreIsBetter/listing83.html%3Fid%3DDTS10000732-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/MoreIsBetter/listing83.html%3Fid%3DDTS10000732-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>