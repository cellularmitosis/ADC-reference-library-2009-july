<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>OT Virtual Server - /OTVirtualClient/OTVirtualClient.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/Carbon/index.html">Carbon</a> &gt; <a href="../../samplecode/Carbon/idxNetworking-date.html">Networking</a> &gt; <A HREF="javascript:location.replace('index.html');">OT Virtual Server</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Not Recommended Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>The information in this document is <strong>Not Recommended</strong> and should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/Carbon/idxNetworking-date.html" target="_blank">Carbon > Networking</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">OT Virtual Server</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/OTVirtualClient/OTVirtualClient.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/OTVirtualClient/OTVirtualClient.c</option>
<option value="listing2.html">/OTVirtualServer/OTVirtualServer.c</option></select>
				</p>
				</form>
				<p><strong><a href="OT_Virtual_Server.zip">Download Sample</a></strong> (&#147;OT_Virtual_Server.zip&#148;, 101.9K)<BR>
<strong><a href="OT_Virtual_Server.dmg">Download Sample</a></strong> (&#147;OT_Virtual_Server.dmg&#148;, 184.4K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*  File:    OTVirtualClient.c  Contains:  This is an OpenTransport sample client application which can be used         to exercise and test the OpenTransport Virtual Server sample.        It also demonstrates coding techniques for OT client applications.          You are welcome to use this code in any way to create you own        OpenTransport applications.   For more information on this program,        please review the document &quot;About OTVirtual Server&quot;.  Written by: Eric Okholm    Copyright:  Copyright &copy; 1999 by Apple Computer, Inc., All Rights Reserved.        You may incorporate this Apple sample source code into your program(s) without        restriction. This Apple sample source code has been provided &quot;AS IS&quot; and the        responsibility for its operation is yours. You are not permitted to redistribute        this Apple sample source code as &quot;Apple sample source code&quot; after having made        changes. If you're going to re-distribute the source, we require that you make        it clear in the source that the code was descended from Apple sample source        code, but that you've made changes.  Change History (most recent first):        7/22/1999  Karl Groethe  Updated for Metrowerks Codewarror Pro 2.1        */#define DoAlert(x)      { sprintf(gProgramErr, x); gProgramState = kProgramError; }    #define DoAlert1(x, y)    { sprintf(gProgramErr, x, y); gProgramState = kProgramError; }    #define DoAlert2(x, y, z)  { sprintf(gProgramErr, x, y, z); gProgramState = kProgramError;}  ////  Program mode////  Before compiling, //  set kDebugLevel to 0 for production//              or 1 for debug code.////  In production mode, the code attempts to recover cleanly from any problems in encounters.//  In debug mode, the unexplained phenomenon cause an alert box highlighting the situation//  to be delivered and then the program exits.//#define kDebugLevel  1#if kDebugLevel &gt; 0#define DBAlert(x)      DoAlert(x)    #define DBAlert1(x, y)    DoAlert1(x, y)    #define DBAlert2(x, y, z)  DoAlert2(x, y, z)  #else#define DBAlert(x)      { }#define DBAlert1(x, y)    { }#define DBAlert2(x, y, z)  { }#endif////  Include files//#include &lt;Dialogs.h&gt;#include &lt;Events.h&gt;#include &lt;Fonts.h&gt;#include &lt;GestaltEqu.h&gt;#include &lt;Memory.h&gt;#include &lt;Menus.h&gt;#include &lt;QuickDraw.h&gt;#include &lt;SegLoad.h&gt;#include &lt;stdio.h&gt;#include &lt;StdLib.h&gt;#include &lt;String.h&gt;#include &lt;strings.h&gt;#include &lt;ToolUtils.h&gt;#include &lt;Windows.h&gt;#include &lt;OpenTptInternet.h&gt;    // includes OpenTransport.h#include &lt;OpenTptClient.h&gt;      // needed for OTReleaseBuffer()////  Defines, enums, resource IDs//#define kInFront          (WindowPtr) -1#define  kWindowResID        128  // Apple Menu#define kAppleMenuResID        128#define  kAppleMenuAbout        1  // File Menu#define kFileMenuResID        129#define kFileMenuOpen        1#define  kFileMenuClose        2#define  kFileMenuQuit        4  // Edit Menu#define kEditMenuResID        130        // Edit menu is disabled  // Client Menu#define kClientMenuResID      131#define kClientMenuTCPPrefs      1  // Alerts, etc.#define kAlertExitResID        128#define kAboutBoxResID        130  // TCP Prefs Dialog#define kTCPPrefsDlogResID      129#define  kServerAddrDItem      2#define kServerPortDItem      4#define  kMaxConnectionsDItem    6#define kStartStopDItem        7  // Overall program statesenum{  kProgramRunning    = 0,  kProgramDone    = 1,  kProgramError    = 2};  // Server statesenum{  kClientStopped    = 0,  kClientRunning    = 1,  kClientShuttingDown  = 2};  // Bit numbers in EPInfo stateFlags fieldsenum{  kOpenInProgressBit        = 0};  // Misc stuffenum{  kTimerIntervalInSeconds    = 3,  kTimerInterval        = (kTimerIntervalInSeconds * 1000),  kServerRequestSize      = 128,  kOTVersion111        = 0x01110000};  // Endpoint Info Structurestruct EPInfo{  EndpointRef    erf;        //  actual endpoint  struct EPInfo*  next;        //  used to link all acceptor's EPInfos (not atomic)  OTLink      link;        //  link into an OT LIFO (atomic)  UInt8      stateFlags;      //  various status fields};typedef struct EPInfo EPInfo;////  Globals//EPInfo*        gDNS            = NULL;EPInfo*       gConnectors          = NULL;InetHostInfo    gServerHostInfo;Boolean        gWaitForServerAddr;int          gClientState        = kClientStopped;int          gProgramState        = kProgramRunning;char        gProgramErr[128];DialogPtr      gDialogPtr          = NULL;WindowPtr      gWindowPtr          = NULL;long        gSleepTicks          = 60;Str255        gServerAddrStr        = &quot;\p17.202.32.195&quot;;long        gServerAddr          = 0;Str255        gServerPortStr        = &quot;\p2001&quot;;long        gServerPort          = 0;Str255        gMaxConnectionsStr      = &quot;\p100&quot;;long        gMaxConnections        = 0;Boolean        gClientRunning        = false;Str255        gStartStr          = &quot;\pStart&quot;;Str255        gStopStr          = &quot;\pStop&quot;;SInt32        gCntrEndpts          = 0;SInt32        gCntrIdleEPs        = 0;SInt32        gCntrBrokenEPs        = 0;SInt32        gCntrPending        = 0;SInt32        gCntrConnections      = 0;SInt32        gCntrTotalConnections    = 0;SInt32        gCntrBytesRcvd        = 0;SInt32        gCntrTotalBytesRcvd      = 0;SInt32        gCntrDiscon          = 0;OTLIFO        gIdleEPLIFO;OTLIFO*        gIdleEPs          = &amp;gIdleEPLIFO;OTLIFO        gBrokenEPLIFO;OTLIFO*        gBrokenEPs          = &amp;gBrokenEPLIFO;OTConfiguration*  gCfgMaster          = NULL;Boolean        gWaitForEventLoop      = false;long        gTimerTask          = 0;SInt32        gCntrIntervalConnects    = 0;SInt32        gCntrIntervalBytes      = 0;SInt32        gConnectsPerSecond      = 0;SInt32        gConnectsPerSecondMax    = 0;SInt32        gKBytesPerSecond      = 0;SInt32        gKBytesPerSecondMax      = 0;SInt32        gCntrIntervalEventLoop    = 0;SInt32        gEventsPerSecond      = 1;SInt32        gEventsPerSecondMax      = 1;Boolean        gDoWindowUpdate        = true;unsigned char     gServerRequest[kServerRequestSize];OSType        gOTVersionSelector      = 'otvr';UInt32        gOTVersion;////  OpenTransport Networking Code Prototypes//static void      DoConnect(EPInfo*);static Boolean     EPClose(EPInfo*);static Boolean    EPOpen(EPInfo*, OTConfiguration* cfg);static void      NetEventLoop(void);static void      NetInit(void);static void      NetShutdown(void);static pascal void  Notifier(void*, OTEventCode, OTResult, void*);static void      ReadData(EPInfo*);static void      Recycle(void);static void     SendRequest(EPInfo*);static void     StartClient(void);static void     StopClient(void);static void      TimerInit();static void      TimerDestroy();static pascal void  TimerRun(void*);////  Macintosh Program Wrapper Prototypes //static void      AboutBox(void);static void      AlertExit(char* );static void      DialogClose(void);static Boolean     EventDialog(EventRecord*);static void      EventDrag(WindowPtr, Point);static void      EventGoAway(WindowPtr, Point);static void      EventKeyDown(EventRecord*);static void      EventLoop(void);static void      EventMouseDown(EventRecord*);static void     MacInit(void);static void     MacInitROM(void);static void      MyC2PStr(char*, Str255);static void      MyP2CStr(Str255, char*);static void     MenuDispatch(long);static void     SetupMenus(void);static void     TCPPrefsDialog(void);static void      TCPPrefsReset(void);static void     WindowClose(void);static void     WindowOpen(void);static void      WindowUpdate(void);//////////////////////////////////////////////////////////////////////////////////////////  OpenTransport Networking Code////  The code in this section provides the networking portions of the //  OpenTransport Virtual Client.////////////////////////////////////////////////////////////////////////////////////////////  DoBind////  This routine requests a wildcard port binding from the transport protocol.//  Since the program doesn't care what port is returned, it passes in NULL//  for the bind return parameter.  The bind request structure is ephemeral//  and can be a local stack variable since OT is done with it when the call returns.//  The bind is done when the notifier receives a T_BINDCOMPLETE event.//static void DoBind(EPInfo* epi){  OSStatus err;  TBind bindReq;  InetAddress  inAddr;    //  //  Bind the endpoint to a wildcard address   //  (assign us a port, we don't care which one).  //  OTInitInetAddress(&amp;inAddr, 0, 0);  bindReq.addr.len = sizeof(InetAddress);  bindReq.addr.buf = (unsigned char*) &amp;inAddr;  bindReq.qlen = 0;    err = OTBind(epi-&gt;erf, &amp;bindReq, NULL);  if (err != kOTNoError)  {    DBAlert1(&quot;DoBind: OTBind error %d&quot;, err);    return;  }}////  DoConnect////  This routine attempts establish a new connection to the globally known//  server address and port.   If the program is still trying to use the//  DNR to resolve the server's host name into an IP address, the endpoint//  is queued for later connection.   //static void DoConnect(EPInfo* epi){  OSStatus err;  TCall sndCall;  InetAddress inAddr;  OTLink* link;    //  Don't want new connections if already shutting down.  if (gProgramState != kProgramRunning || gClientState != kClientRunning)    return;      if (gWaitForServerAddr || gWaitForEventLoop)  {    if (epi != NULL)    {      OTLIFOEnqueue(gIdleEPs, &amp;epi-&gt;link);      OTAtomicAdd32(1, &amp;gCntrIdleEPs);    }    return;  }      //  If we weren't passed a specific EPInfo, try to get an idle one.  if (epi == NULL)  {    link = OTLIFODequeue(gIdleEPs);    if (link == NULL)      return;    OTAtomicAdd32(-1, &amp;gCntrIdleEPs);    epi = OTGetLinkObject(link, EPInfo, link);  }  OTInitInetAddress(&amp;inAddr, gServerPort, gServerAddr);  OTMemzero(&amp;sndCall, sizeof(TCall));  sndCall.addr.len   = sizeof(InetAddress);          sndCall.addr.buf  = (unsigned char*) &amp;inAddr;    OTAtomicAdd32(1, &amp;gCntrPending);  err = OTConnect(epi-&gt;erf, &amp;sndCall, NULL);  if (err != kOTNoDataErr)  {    OTAtomicAdd32(-1, &amp;gCntrPending);    DBAlert2(&quot;DoConnect: OTConnect error %d state %d&quot;, err, OTGetEndpointState(epi-&gt;erf));    return;  }    //  //  If OTConnect didn't return an error, this thread will   //  resume when the notifier gets a T_CONNECT event...  //}////  EPClose////  This routine is a front end to OTCloseProvider.   //  Centralizing closing of endpoints makes debugging and instrumentation easier.  //static Boolean EPClose(EPInfo* epi){  OSStatus err;    //  //  If an endpoint is still being opened, we can't close it yet.  //  There is no way to cancel an OTAsyncOpenEndpoint, so we just  //  have to wait for the T_OPENCOMPLETE event at the notifier.  //  if ( OTAtomicTestBit(&amp;epi-&gt;stateFlags, kOpenInProgressBit) )    return false;      err = OTCloseProvider(epi-&gt;erf);  epi-&gt;erf = NULL;  if (err)    DBAlert1(&quot;EPClose: OTCloseProvider error %d&quot;, err);  if (epi != gDNS)    OTAtomicAdd32(-1, &amp;gCntrEndpts);  return true;  }////  EPOpen:////  A front end to OTAsyncOpenEndpoint.//  A status bit is set so we know there is an open in progress.//  It is cleared when the notifier gets a T_OPENCOMPLETE where the context//  pointer is this EPInfo.  Until that happens, this EPInfo can't be cleaned//  up and released.//static Boolean EPOpen(EPInfo* epi, OTConfiguration* cfg){  OSStatus err;    OTAtomicSetBit(&amp;epi-&gt;stateFlags, kOpenInProgressBit);  err = OTAsyncOpenEndpoint(cfg, 0, NULL, &amp;Notifier, epi);  if (err != kOTNoError)  {    OTAtomicClearBit(&amp;epi-&gt;stateFlags, kOpenInProgressBit);    DBAlert1(&quot;EPOpen: OTAsyncOpenEndpoint error %d&quot;, err);    return false;  }  return true;}////  NetEventLoop////  This routine is called once during each pass through the program's event loop.//  If the program is running on OT 1.1.2 or an earlier release, this is where//  outbound orderly releases are started (see comments in DoSndOrderlyRelease //  for more information on that).   This is also where endpoints are &quot;fixed&quot; by//  closing them and opening a new one to replace them.   This is rarely necessary,//  but works around some timing issues in OTUnbind().  Having passed through the //  event loop once, we assume it is safe to turn off throttle-back.  And, finally,//  if we have deferred handing of a T_LISTEN, here we start it up again.//static void NetEventLoop(){  Recycle();  gWaitForEventLoop = false;  DoConnect(NULL);}////  NetInit:////  This is nothing but a front end to InitOpenTransport.//  The only reason for having this routine is to get the call to InitOpenTransport//  up into the &quot;networking&quot; section of the program and out of the //  &quot;macintosh program wrapper&quot; section of the program.//static void NetInit(){  OSStatus err;    err = InitOpenTransport();  if (err)  {    DBAlert1(&quot;NetInit: InitOpenTransport error %d&quot;, err);    return;  }  err = Gestalt(gOTVersionSelector, (long*) &amp;gOTVersion);  if (err || (gOTVersion &lt; kOTVersion111))  {    DoAlert(&quot;Please install Open Transport 1.1.1 or later&quot;);    return;  }  TimerInit();}////  NetShutdown:////  Ditto...//static void NetShutdown(){  TimerDestroy();  CloseOpenTransport();}  ////  Notifier:////  Most of the interesting networking code in this program resides inside //  this notifier.   In order to run asynchronously and as fast as possible,//  things are done inside the notifier whenever possible.  Since almost//  everything is done inside the notifier, there was little need for specical//  synchronization code.////  Note: The DNR events are combined with normal endpoint events in this notifier.//  The only events which are expected from the DNR are T_DNRSTRINGTOADDRCOMPLETE//  and T_OPENCOMPLETE.////  IMPORTANT NOTE:  Normal events defined by XTI (T_LISTEN, T_CONNECT, etc)//  and OT completion events (T_OPENCOMPLETE, T_BINDCOMPLETE, etc.) are not//  reentrant.  That is, whenever our notifier is invoked with such an event,//  the notifier will not be called again by OT for another normal or completion//  event until we have returned out of the notifier - even if we make OT calls//  from inside the notifier.   This is a useful synchronization tool.//  However, there are two kinds of events which will cause the notifier to //  be reentered.   One is T_MEMORYRELEASED, which always happens instantly.//  The other are state change events like kOTProviderWillClose.//static pascal void Notifier(void* context, OTEventCode event, OTResult result, void* cookie){  OSStatus err;  OTResult epState;  EPInfo* epi = (EPInfo*) context;  //  //  Once the program is shutting down, most events would be uninteresting.  //  However, we still need T_OPENCOMPLETE and T_MEMORYRELEASED events since  //  we can't call CloseOpenTransport until all OTAsyncOpenEndpoints and  //  OTSends with AckSends have completed.   So those specific events  //  are still accepted.  //  if (gProgramState != kProgramRunning)  {    if (event != T_OPENCOMPLETE)      return;  }    //  //  This really isn't necessary, it's just a sanity check which should be removed  //  once a program is debugged.   It's just making sure we don't get event notifications  //  after all of our endpoints have been closed.  //  if (gClientState == kClientStopped)  {    DBAlert1(&quot;Notifier: got event %d when client not running!&quot;, event);    return;  }    //  //  Within the notifier, all action is based on the event code.  //  In this notifier, fatal errors all break out of the switch to the bottom.  //  As long as everything goes as expected, the case returns rather than breaks.  //  switch (event)  {    //    //  T_BINDCOMPLETE:    //    //  This event is returned when an endpoint has been bound to a wildcard addr.    //  No errors are expected.   The program immediately attempts to establish    //  a connection from this endpoint to the server.    //    case T_BINDCOMPLETE:    {      if (result != kOTNoError)      {        DBAlert1(&quot;Notifier: T_BINDCOMPLETE result %d&quot;, result);        return;      }      DoConnect(epi);      // resumes at T_CONNECT      return;    }        //    //  T_CONNECT:    //    //  This event is returned when a connection is established to the server.    //  The program must call OTRcvConnect() to get the conenction information    //  and clear the T_CONNECT event from the stream.  Since OTRcvConnect()    //  returns immediately (rather than via a completion event to the notifier)    //  we can use local stack structures for parameters.    //    case T_CONNECT:    {      TCall call;      InetAddress caddr;            if (result != kOTNoError)      {        DBAlert1(&quot;Notifier: T_CONNECT result %d&quot;, result);        return;      }            call.addr.maxlen = sizeof(InetAddress);      call.addr.buf = (unsigned char*) &amp;caddr;      call.opt.maxlen = 0;      call.opt.buf = NULL;      call.udata.maxlen = 0;      call.udata.buf = NULL;            err = OTRcvConnect(epi-&gt;erf, &amp;call);      if (err != kOTNoError)      {        DBAlert1(&quot;Notifier: T_CONNECT - OTRcvConnect err %d&quot;, err);        return;      }      OTAtomicAdd32(-1, &amp;gCntrPending);      OTAtomicAdd32(1, &amp;gCntrConnections);      OTAtomicAdd32(1, &amp;gCntrTotalConnections);      OTAtomicAdd32(1, &amp;gCntrIntervalConnects);            SendRequest(epi);      //      //  Since we won't be sending any data,       //  might as well send along the orderly release now.      //      err = OTSndOrderlyDisconnect(epi-&gt;erf);      if (err != kOTNoError)      {        if (err != kOTLookErr)        {          DBAlert1(&quot;Notifier: T_CONNECT: OTSndOrderlyDisconnect error %d&quot;, err);        }      }      return;        // Wait for a T_DATA...    }        //    //  T_DATA:    //    //  The main rule for processing T_DATA's is to remember that once you have    //  a T_DATA, you won't get another one until you have read to a kOTNoDataErr.    //  The advanced rule is to remember that you could get another T_DATA    //  during an OTRcv() which will eventually return kOTNoDataErr, presenting    //  the application with a synchronization issue to be most careful about.    //      //  In this application, since an OTRcv() calls are made from inside the notifier,    //  this particular synchronization issue doesn't become a problem.    //    case T_DATA:    {      ReadData(epi);      return;    }        //    //  T_DNRSTRINGTOADDRCOMPLETE:    //    //  This event occurs when the DNR has finished an attempt to translate    //  the server's name into an IP address we can use to connect to.    //    case T_DNRSTRINGTOADDRCOMPLETE:    {      if (result != kOTNoError)      {        DBAlert1(&quot;Notifier: T_DNRSTRINGTOADDRCOMPLETE result %d&quot;, result);        return;      }      gServerAddr = gServerHostInfo.addrs[0];      gWaitForServerAddr = false;      return;    }            //    //  T_DISCONNECT:    //    //  An inbound T_DISCONNECT event usually indicates that the other side of the    //  connection did an abortive disconnect (as opposed to an orderly release).    //  It also can be generated by the transport provider on the system (e.g. tcp)    //  when it decides that a connection is no longer in existance.    //    //  We receive the disconnect, but this program ignores the associated reason (NULL param).    //  It is possible to get back a kOTNoDisconnectErr from the OTRcvDisconnect call.    //  This can happen when either (1) the disconnect on the stream is hidden by a     //  higher priority message, or (2) something has flushed or reset the disconnect    //  event in the meantime.   This is not fatal, and the appropriate thing to do is    //  to pretend the T_DISCONNECT event never happened.   Any other error is unexpected    //  and needs to be reported so we can fix it.  Next, unbind the endpoint so we can    //  reuse it for a new inbound connection.    //      //  It is possible to get an error on the unbind due to a bug in OT 1.1.1 and earlier.    //  The best thing to do for that is close the endpoint and open a new one to replace it.    //  We do this back in the main thread so we don't have to deal with synchronization problems.    //    case T_DISCONNECT:    {      epState = OTGetEndpointState(epi-&gt;erf);      if (epState == T_OUTCON)      {        OTAtomicAdd32(-1, &amp;gCntrPending);      }      OTAtomicAdd32(1, &amp;gCntrDiscon);      err = OTRcvDisconnect(epi-&gt;erf, NULL);      if (err != kOTNoError)      {        if (err == kOTNoDisconnectErr)          return;        DBAlert1(&quot;Notifier: T_DISCONNECT - OTRcvDisconnect error %d&quot;, err);        return;      }            err = OTUnbind(epi-&gt;erf);      if (err != kOTNoError)      {        OTLIFOEnqueue(gBrokenEPs, &amp;epi-&gt;link);        OTAtomicAdd32(1, &amp;gCntrBrokenEPs);      }      return;    }        //    //  T_GODATA:    //    //  Because of the complexity involved in the implementation of OT flow control,    //  it is sometimes possible to receive a T_GODATA even when we aren't subject     //  to flow control - normally only at the start of a program.   If this happens,    //  ignoring it is the correct thing to do.    //    case T_GODATA:    {      return;    }        //    //  T_OPENCOMPLETE:    //    //  This event occurs when an OTAsyncOpenEndpoint() completes.   Note that this event,    //  just like any other async call made from outside the notifier, can occur during    //  the call to OTAsyncOpenEndpoint().  That is, in the main thread the program did    //  the OTAsyncOpenEndpoint(), and the notifier is invoked before control is returned    //  to the line of code following the call to OTAsyncOpenEndpoint().   This is one    //  event we need to keep track of even if we are shutting down the program since there    //  is no way to cancel outstanding OTAsyncOpenEndpoint() calls.    //    case T_OPENCOMPLETE:    {      char serverCString[256];            OTAtomicClearBit(&amp;epi-&gt;stateFlags, kOpenInProgressBit);      if (result == kOTNoError)        epi-&gt;erf = (EndpointRef) cookie;      else        {        DBAlert1(&quot;Notifier: T_OPENCOMPLETE result %d&quot;, result);        return;      }      if (gProgramState != kProgramRunning)        return;            if (epi == gDNS)      {        MyP2CStr(gServerAddrStr, serverCString);        err = OTInetStringToAddress((InetSvcRef)epi-&gt;erf, serverCString, &amp;gServerHostInfo);        if (err != kOTNoError)        {          //          //  Can't translate the server address string          //          DBAlert1(&quot;Notifier: T_OPENCOMPLETE - OTInetStringToAddress error %d&quot;, err);        }        return;    // DNS resumes at T_DNRSTRINGTOADDRCOMPLETE      }      else      {        OTAtomicAdd32(1, &amp;gCntrEndpts);                //        //  Set to blocking mode so we don't have to deal with kEAGAIN errors.        //  Async/blocking is the best mode to write an OpenTransport application in.        //        err = OTSetBlocking(epi-&gt;erf);        if (err != kOTNoError)        {          DBAlert1(&quot;Notifier: T_OPENCOMPLETE - OTSetBlocking error %d&quot;, err);          return;        }                DoBind(epi);        return;      // resumes at T_BINDCOMPLETE      }    }        //    //  T_ORDREL:    //    //  This event occurs when an orderly release has been received on the stream.    //    case T_ORDREL:    {      err = OTRcvOrderlyDisconnect(epi-&gt;erf);      if (err != kOTNoError)      {        DBAlert1(&quot;Notifier: T_ORDREL - OTRcvOrderlyDisconnect error %d&quot;, err);        return;      }      epState = OTGetEndpointState(epi-&gt;erf);      if (epState != T_IDLE)        return;      OTAtomicAdd32(-1, &amp;gCntrConnections);      err = OTUnbind(epi-&gt;erf);      if (err != kOTNoError)      {        OTLIFOEnqueue(gBrokenEPs, &amp;epi-&gt;link);        OTAtomicAdd32(1, &amp;gCntrBrokenEPs);      }      return;    }        //    //  T_UNBINDCOMPLETE:    //    //  This event occurs on completion of an OTUnbind().    //  The endpoint is ready for reuse on a new inbound connection.    //  Put it back into the queue of idle endpoints.    //  Note that the OTLIFO structure has atomic queue and dequeue,    //  which can be helpful for synchronization protection.      //    case T_UNBINDCOMPLETE:    {      if (result != kOTNoError)      {        //        //  Unbind errors can occur as a result of a bug in OT 1.1.1 and earlier        //  versions.   The best recovery is to put the endpoint in the broken        //  list for recycling with a clean, new endpoint.        //        OTLIFOEnqueue(gBrokenEPs, &amp;epi-&gt;link);        OTAtomicAdd32(1, &amp;gCntrBrokenEPs);        return;      }      DoBind(epi);      return;    }            //    //  default:    //    //  There are events which we don't handle, but we don't expect to see    //  any of them.   When running in debugging mode while developing a program,    //  we exit with an informational alert.   Later, in the production version    //  of the program, we ignore the event and try to keep running.    //    default:    {      DBAlert1(&quot;Notifier: unknown event &lt;%x&gt;&quot;, event);      return;    }  }}////  ReadData:////  This routine attempts to read all available data from an endpoint.//  Since this routine is only called from inside the notifier in the current//  version of OTVirtualClient, it is not necessary to program to handle//  getting back a T_DATA notification DURING an OTRcv() call, as would be//  the case if we read from outside the notifier.   We must read until we//  get a kOTNoDataErr in order to clear the T_DATA event so we will get//  another notification of T_DATA in the future.////  Currently this application uses no-copy receives to get data.  This obligates//  the program to return the buffers to OT asap.  Since this program does nothing//  with data other than count it, that's easy.  Future, more complex versions//  of this program will do more interesting things with regards to that.//static void ReadData(EPInfo* epi){  OTBuffer* bp;  OTResult  res;  OTFlags    flags;    while (true)  {    res = OTRcv(epi-&gt;erf, &amp;bp, kOTNetbufDataIsOTBufferStar, &amp;flags);        if (res &gt; 0)    {      OTAtomicAdd32(res, &amp;gCntrBytesRcvd);      OTAtomicAdd32(res, &amp;gCntrTotalBytesRcvd);      OTAtomicAdd32(res, &amp;gCntrIntervalBytes);      OTReleaseBuffer(bp);      continue;    }    if (res == kOTNoDataErr)    {      //      //  Since ReadData is only called from inside the notifier      //  we don't have to worry about having missed a T_DATA       //  during the OTRcv.      //      return;    }    if (res &lt;= 0)    {      if (res == kOTLookErr)      {        res = OTLook(epi-&gt;erf);        if (res == T_ORDREL)          return;        if (res == T_GODATA)        {          //          //  This isn't expected, but it has happened occasionally.          //  The correct way to proceed is to ignore it.          //          continue;         }        else        {          DBAlert1(&quot;ReadData: OTRcv got OTLookErr 0x%08x&quot;, res);        }      }      else      {        DBAlert1(&quot;ReadData: OTRcv error %d&quot;, res);      }    }  } }////  Recycle:////  This routine shouldn't be necessary, but it is helpful to work around both//  problems in OpenTransport and bugs in this program.   Basicly, whenever an//  unexpected error occurs which shouldn't be fatal to the program, the EPInfo//  is queued on the BrokenEP queue.  When recycle is called, once per pass around//  the event loop, it will attempt to close the associated endpoint and open//  a new one to replace it using the same EPInfo structure.   This process of//  closing an errant endpoint and opening a replacement is probably the most//  reliable way to make sure that this program and OpenTransport can recover//  from unexpected happenings in a clean manner.//static void Recycle(){  OTLink*   list = OTLIFOStealList(gBrokenEPs);  OTLink*    link;  EPInfo*    epi;  while ( (link = list) != NULL )  {    list = link-&gt;fNext;    epi = OTGetLinkObject(link, EPInfo, link);    if (!EPClose(epi))    {      OTLIFOEnqueue(gBrokenEPs, &amp;epi-&gt;link);      continue;    }    OTAtomicAdd32(-1, &amp;gCntrBrokenEPs);    EPOpen(epi, OTCloneConfiguration(gCfgMaster));  }}////  SendRequest:////  Tell the OT Virtual Server we want it to send us some data.//  For demonstration purposes, the server will wait for a 128 byte//  &quot;request&quot; to come in before sending us data.   It doesn't care//  what the request looks like, it just allows us to better simulate//  true client/server interactions.//static void SendRequest(EPInfo* epi){  OTResult res;    res = OTSnd(epi-&gt;erf, gServerRequest, kServerRequestSize, 0);    //  //  This is bogus and needs to add flow control.  //  The only reason we get away with it here is because flow control  //  will never happen in the first 128 bytes sent, and that is all  //  we are sending.  //  if (res != kServerRequestSize)  {    DBAlert1(&quot;SendRequest: got result %d&quot;, res);  }  OTAtomicAdd32(res, &amp;gCntrIntervalBytes);}////  StartClient:////  Open one InetServices (DNS) object,//  and as many connection endpoints as the program will use.//  Start making connections as soon as the server's name is translated//  to an IP address.//static void StartClient(){  int i;  EPInfo* epi;  OSStatus err;    gCntrEndpts        = 0;  gCntrPending      = 0;  gCntrConnections    = 0;  gCntrBrokenEPs        = 0;  gCntrTotalConnections  = 0;  gIdleEPs-&gt;fHead      = NULL;  gBrokenEPs-&gt;fHead     = NULL;  gClientState       = kClientRunning;  TCPPrefsReset();  gWaitForServerAddr     = true;    //  //  Open an InternetServices so we have access to the DNR  //  to translate the server's name into an IP address (if necessary).  //  gDNS = (EPInfo*) NewPtr(sizeof(EPInfo));  if (gDNS == NULL)  {    DBAlert(&quot;StartClient: NewPtr cannot get memory for EPInfo&quot;);    return;  }  OTMemzero(gDNS, sizeof(EPInfo));  OTAtomicSetBit(&amp;gDNS-&gt;stateFlags, kOpenInProgressBit);  err = OTAsyncOpenInternetServices(kDefaultInternetServicesPath, 0, Notifier, gDNS);  if (err != kOTNoError)  {    OTAtomicClearBit(&amp;gDNS-&gt;stateFlags, kOpenInProgressBit);    DBAlert1(&quot;OTAsyncOpenInternetServices error %d&quot;, err);    return;  }    //  //  Get memory for EPInfo structures  //  for (i = 0; i &lt; gMaxConnections; i++)          {    epi = (EPInfo*) NewPtr(sizeof(EPInfo));    if (epi == NULL)    {      DBAlert(&quot;StartClient: NewPtr cannot get memory for EPInfo&quot;);      return;    }    OTMemzero(epi, sizeof(EPInfo));    epi-&gt;next = gConnectors;    gConnectors = epi;  }    //  //  Open endpoints which can be used for outbound   //  connections to the server.  //  gCfgMaster = OTCreateConfiguration(&quot;tcp&quot;);  if (gCfgMaster == NULL)  {    DBAlert(&quot;StartClient: OTCreateConfiguration returned NULL&quot;);    return;  }  for (epi = gConnectors; epi != NULL; epi = epi-&gt;next)  {    if (!EPOpen(epi, OTCloneConfiguration(gCfgMaster)))      break;  }}////  StopClient:////  This is where the client is shut down, either because the user clicked//  the stop button, or because the program is exiting (error or quit).//  The tricky part is that we can't quit while there are outstanding//  OTAsyncOpenEndpoint calls (which can't be cancelled, by the way).//static void StopClient(){  EPInfo *epi, *last;    gClientState = kClientShuttingDown;    //  //  First, make sure the DNS is closed.  //  if (gDNS != NULL)  {    if (!EPClose(gDNS))      return;    DisposePtr((char*)gDNS);    gDNS = NULL;  }    //  //  Start closing connector endpoints.  //  While we could be rude and just close the endpoints,   //  we try to be polite and wait for all outstanding connections  //  to finish before closing the endpoints.   The is a bit easier  //  on the server which won't end up keeping around control blocks  //  for dead connections which it doesn't know are dead.  Alternately,  //  we could just send a disconnect, but this seems cleaner.  //  epi = gConnectors;  last = NULL;  while (epi != NULL)  {    if (!EPClose(epi))    {      //  Can't close this endpoint yet, so skip it.      last = epi;      epi = epi-&gt;next;      continue;    }    else    {      if (last != NULL)      {        last-&gt;next = epi-&gt;next;        DisposePtr((char*)epi);        epi = last-&gt;next;      }      else      {        gConnectors = epi-&gt;next;        DisposePtr((char*)epi);        epi = gConnectors;      }    }  }    //  //  If the list is empty now, then all endpoints have been successfully closed,  //  so the client is stopped now.   At this point we can either restart it or  //  exit the program safely.  //  if (gConnectors == NULL)  {    gClientState       = kClientStopped;    gCntrEndpts        = 0;    gCntrIdleEPs        = 0;    gCntrPending      = 0;    gCntrConnections    = 0;    gCntrBrokenEPs        = 0;    gCntrTotalConnections  = 0;    gIdleEPs-&gt;fHead      = NULL;    gBrokenEPs-&gt;fHead     = NULL;    OTDestroyConfiguration(gCfgMaster);  }}////  TimerInit////  Start up a regular timer to do housekeeping.   Strictly speaking,//  this isn't necessary, but having a regular heartbeat allows us to//  detect if we are so busy with network notifier processing that the//  program's event loop isn't ever firing.   We want to know this so//  we can at least allow the user to quit the program if they want to.//static void TimerInit(){  gTimerTask = OTCreateTimerTask(&amp;TimerRun, 0);  if (gTimerTask == 0)  {    sprintf(gProgramErr, &quot;TimerInit: OTCreateTimerTask returned 0&quot;);    gProgramState = kProgramError;    return;  }  OTScheduleTimerTask(gTimerTask, kTimerInterval);}////  TimerDestroy//static void TimerDestroy(){  if (gTimerTask != 0)  {    OTCancelTimerTask(gTimerTask);    OTDestroyTimerTask(gTimerTask);    gTimerTask = 0;  }}////  TimerRun////  Fires every N seconds, no matter how busy the system is.//  We use this to detect if the program's main event loop is getting no time,//  in which case we can slow the client down by doing a throttle-back until//  the event loop can run at least once.  It also is a convenient statistics //  gathering point.  //static pascal void TimerRun(void*){  gConnectsPerSecond = (gCntrIntervalConnects / kTimerIntervalInSeconds);  gKBytesPerSecond = (gCntrIntervalBytes / (kTimerIntervalInSeconds * 1024));  gEventsPerSecond = (gCntrIntervalEventLoop / kTimerIntervalInSeconds);  if (gCntrIntervalEventLoop == 0)    gWaitForEventLoop = true;    if (gConnectsPerSecond &gt; gConnectsPerSecondMax)    gConnectsPerSecondMax = gConnectsPerSecond;  if (gKBytesPerSecond &gt; gKBytesPerSecondMax)    gKBytesPerSecondMax = gKBytesPerSecond;  if (gEventsPerSecond &gt; gEventsPerSecondMax)    gEventsPerSecondMax = gEventsPerSecond;      gCntrIntervalConnects  = 0;  gCntrIntervalBytes    = 0;  gCntrIntervalEventLoop  = 0;  gDoWindowUpdate      = true;  gCntrConnections     = gCntrEndpts - gCntrPending - gCntrBrokenEPs;    OTScheduleTimerTask(gTimerTask, kTimerInterval);}  //////////////////////////////////////////////////////////////////////////////////////////  Macintosh Program Wrapper////  The code from here down deals with the Macintosh environment, events,//  menus, command keys, etc.   Networking code is in the section above.//  Since this code is fairly basic, and since this isn't really intended//  to be a &quot;sample Macintosh application&quot; (just a sample OpenTransport application)//  this section isn't heavily commented.   There are much better Macintosh//  application samples for handling mouse, keyboard, event loops, etc.////////////////////////////////////////////////////////////////////////////////////////static void AboutBox(){  Alert(kAboutBoxResID, NULL);}static Boolean EventDialog(EventRecord* event){  DialogPtr   dp;  short    item;  short    itemType;  Handle    itemHandle;  Rect    itemRect;    if (event-&gt;modifiers &amp; cmdKey)  {    EventKeyDown(event);    // this allows menu commands while dialog is active window    return false;        // note if I add cut/paste I will have to rework this.  }  if ((DialogSelect(event, &amp;dp, &amp;item)) &amp;&amp; (dp == gDialogPtr))  {    GetDialogItem(gDialogPtr, item, &amp;itemType, &amp;itemHandle, &amp;itemRect);    switch (item)    {      case kServerAddrDItem:        GetDialogItemText(itemHandle, gServerAddrStr);        return true;            case kServerPortDItem:        GetDialogItemText(itemHandle, gServerPortStr);        return true;            case kMaxConnectionsDItem:        GetDialogItemText(itemHandle, gMaxConnectionsStr);        return true;            case kStartStopDItem:        GetDialogItem(gDialogPtr, kStartStopDItem, &amp;itemType, &amp;itemHandle, &amp;itemRect);        if (gClientRunning)        {          StopClient();                  SetControlTitle((ControlHandle)itemHandle, gStartStr);          gClientRunning = false;        }        else        {          StartClient();          SetControlTitle((ControlHandle)itemHandle, gStopStr);          gClientRunning = true;        }        DrawDialog(gDialogPtr);        return true;    }  }  return false;}static void TCPPrefsReset(){  StringToNum(gServerPortStr, &amp;gServerPort);  StringToNum(gMaxConnectionsStr, &amp;gMaxConnections);}static void TCPPrefsDialog(){  short  itemType;  Handle  itemHandle;  Rect  itemRect;    gDialogPtr = GetNewDialog(kTCPPrefsDlogResID, NULL, kInFront);  SetWTitle(gDialogPtr, &quot;\pTCP Preferences&quot;);    GetDialogItem(gDialogPtr, kServerAddrDItem, &amp;itemType, &amp;itemHandle, &amp;itemRect);  SetDialogItemText(itemHandle, gServerAddrStr);    GetDialogItem(gDialogPtr, kServerPortDItem, &amp;itemType, &amp;itemHandle, &amp;itemRect);  SetDialogItemText(itemHandle, gServerPortStr);    GetDialogItem(gDialogPtr, kMaxConnectionsDItem, &amp;itemType, &amp;itemHandle, &amp;itemRect);  SetDialogItemText(itemHandle, gMaxConnectionsStr);    GetDialogItem(gDialogPtr, kStartStopDItem, &amp;itemType, &amp;itemHandle, &amp;itemRect);  if (gClientRunning)    SetControlTitle((ControlHandle)itemHandle, gStopStr);  else    SetControlTitle((ControlHandle)itemHandle, gStartStr);  DrawDialog(gDialogPtr);}static void DialogClose(){  DisposeDialog(gDialogPtr);  gDialogPtr = NULL;  TCPPrefsReset();}static void MenuDispatch(long menu){  short menuID;  short cmdID;    menuID = HiWord(menu);  cmdID  = LoWord(menu);  switch(menuID)  {    case kAppleMenuResID:    {      switch (cmdID)      {        case kAppleMenuAbout:          AboutBox();          break;                  default:          break;      }      break;    }          case kFileMenuResID:    {      switch (cmdID)      {        case kFileMenuQuit:          gProgramState = kProgramDone;          break;                  case kFileMenuOpen:          WindowOpen();          break;                  case kFileMenuClose:          WindowClose();          break;                  default:          break;      }      break;    }        case kEditMenuResID:      break;        case kClientMenuResID:    {      switch (cmdID)      {        case kClientMenuTCPPrefs:          TCPPrefsDialog();          break;                  default:          break;      }      break;    }  }    }static void EventDrag(WindowPtr wp, Point loc){  Rect dragBounds;    dragBounds = qd.screenBits.bounds;  DragWindow(wp, loc, &amp;dragBounds);}static void EventGoAway(WindowPtr wp, Point loc){  if (TrackGoAway(wp, loc))  {    if (wp == gWindowPtr)      WindowClose();    else if (wp == gDialogPtr)      DialogClose();  }}  static void EventMouseDown(EventRecord* event){  short    part;  WindowPtr  wp;  long     menu;    part = FindWindow(event-&gt;where, &amp;wp);  switch (part)  {    case inMenuBar:      menu = MenuSelect(event-&gt;where);      HiliteMenu(0);      MenuDispatch(menu);      break;          case inDrag:      EventDrag(wp, event-&gt;where);      break;        case inGoAway:      EventGoAway(wp, event-&gt;where);      break;        case inContent:          SelectWindow(wp);      break;          case inGrow:    // no grow box    case inZoomIn:    // no zoom box    case inZoomOut:    // no zoom box    case inSysWindow:    case inDesk:    default:      break;  }}static void EventKeyDown(EventRecord* event){  char    c;  long    menu;    c = event-&gt;message &amp; charCodeMask;  if (event-&gt;modifiers &amp; cmdKey)  {    // cmd key    menu = MenuKey(c);    HiliteMenu(0);    if (menu != 0)      MenuDispatch(menu);  }  else  {    // normal keystroke  }}static void EventLoop(){  EventRecord event;    while ((gProgramState == kProgramRunning) || (gClientState != kClientStopped))  {    OTAtomicAdd32(1, &amp;gCntrIntervalEventLoop);    if (WaitNextEvent(everyEvent, &amp;event, gSleepTicks, 0))     {      if ((gDialogPtr != NULL) &amp;&amp; (IsDialogEvent(&amp;event)))      {        if (EventDialog(&amp;event))          continue;      }      switch (event.what)      {        case keyDown:          EventKeyDown(&amp;event);          break;                  case mouseDown:          EventMouseDown(&amp;event);          break;                  case updateEvt:          // redraw window now          break;                case activateEvt:          // activate or deactivate window controls          break;                case mouseUp:        case keyUp:        case autoKey:        case diskEvt:        case app4Evt:        default:          break;      }    }        if (((gProgramState == kProgramRunning) &amp;&amp; (gClientState == kClientShuttingDown)) ||      ((gProgramState != kProgramRunning) &amp;&amp; (gClientState != kClientStopped)))      StopClient();    else if ((gProgramState == kProgramRunning) &amp;&amp; (gClientState == kClientRunning))      NetEventLoop();    WindowUpdate();  }}static void WindowClose(){  if (gWindowPtr == NULL)    return;  DisposeWindow(gWindowPtr);  gWindowPtr = NULL;}static void WindowOpen(){  if (gWindowPtr != NULL)    return;  gWindowPtr = GetNewWindow(kWindowResID, NULL, kInFront);  SetWTitle(gWindowPtr, &quot;\pOTVirtualClient&quot;);}static void WindowUpdate(){  char gStrBuf[128];  int len;    if (gWindowPtr == NULL)    return;  if (gDoWindowUpdate == false)    return;  gDoWindowUpdate = false;      SetPort(gWindowPtr);  EraseRgn(gWindowPtr-&gt;visRgn);    gCntrConnections = gCntrEndpts - gCntrIdleEPs - gCntrPending - gCntrBrokenEPs;    MoveTo(20, 20);  sprintf(gStrBuf, &quot;EPs: total %d idle %d&quot;, gCntrEndpts, gCntrIdleEPs);  len = strlen(gStrBuf) ;  DrawText(gStrBuf, 0, len);    MoveTo(20, 40);  sprintf(gStrBuf, &quot;Connects: current %d total %d&quot;, gCntrConnections, gCntrTotalConnections);  len = strlen(gStrBuf) ;  DrawText(gStrBuf, 0, len);  MoveTo(20, 60);  sprintf(gStrBuf, &quot;Pending connections %d&quot;, gCntrPending);  len = strlen(gStrBuf) ;  DrawText(gStrBuf, 0, len);  MoveTo(20, 80);  sprintf(gStrBuf, &quot;KBytes received %d&quot;, (gCntrTotalBytesRcvd / 1024));  len = strlen(gStrBuf) ;  DrawText(gStrBuf, 0, len);      MoveTo(20, 100);  sprintf(gStrBuf, &quot;Conn/sec: current %d max %d&quot;, gConnectsPerSecond, gConnectsPerSecondMax);  len = strlen(gStrBuf) ;  DrawText(gStrBuf, 0, len);    MoveTo(20, 120);  sprintf(gStrBuf, &quot;KBy/sec: current %d max %d&quot;, gKBytesPerSecond, gKBytesPerSecondMax);  len = strlen(gStrBuf) ;  DrawText(gStrBuf, 0, len);    MoveTo(20, 140);  sprintf(gStrBuf, &quot;Events/sec: %d/%d&quot;, gEventsPerSecond, gEventsPerSecondMax);  len = strlen(gStrBuf) ;  DrawText(gStrBuf, 0, len);    MoveTo(20, 160);  sprintf(gStrBuf, &quot;Running at %d%% of capacity.&quot;,       (100 - ((100 * gEventsPerSecond)/gEventsPerSecondMax)));  len = strlen(gStrBuf) ;  DrawText(gStrBuf, 0, len);    MoveTo(20, 180);  sprintf(gStrBuf, &quot;Disconnects %d&quot;, gCntrDiscon);  len = strlen(gStrBuf) ;  DrawText(gStrBuf, 0, len);  }static void SetupMenus(){  MenuHandle mh;  mh = GetMenu(kAppleMenuResID);  AppendResMenu( mh, 'DRVR' );      /* Add DA list */  InsertMenu(mh, 0);  mh = GetMenu(kFileMenuResID);  InsertMenu(mh, 0);  mh = GetMenu(kEditMenuResID);  InsertMenu(mh, 0);  mh = GetMenu(kClientMenuResID);  InsertMenu(mh, 0);  DrawMenuBar();}static void MyC2PStr(char* cstr, Str255 pstr){  //  //  Converts a C string to a Pascal string.  //  Truncates the string if longer than 254 bytes.  //  int i, j;    i = strlen(cstr);  if (i &gt; 254)    i = 254;  pstr[0] = i;  for (j = 1; j &lt;= i; j++)    pstr[j] = cstr[j-1];}static void MyP2CStr(Str255 pstr, char* cstr){  int i;    for (i = 0; i &lt; pstr[0]; i++)    cstr[i] = pstr[i+1];  cstr[i] = 0;}static void AlertExit(char* err){  Str255 pErr;    MyC2PStr(err, pErr);  ParamText(pErr, NULL, NULL, NULL);  Alert(kAlertExitResID, NULL);  ExitToShell();  }static void MacInitROM(){  MaxApplZone();  MoreMasters();  InitGraf(&amp;qd.thePort);  InitCursor();  InitFonts();  InitWindows();  InitMenus();  TEInit();  InitDialogs(NULL);  FlushEvents(everyEvent, 0);}static void MacInit(){  MacInitROM();  WindowOpen();  SetupMenus();}static void MiscInit(){  int i;    //  This is just so the data is a little better than random for tracing  for (i = 0; i &lt; kServerRequestSize; i++)    gServerRequest[i] = i;}void main(){  MacInit();  NetInit();  MiscInit();  EventLoop();  NetShutdown();  if (gProgramState == kProgramError)    AlertExit(gProgramErr);}</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/OT_Virtual_Server/listing1.html%3Fid%3DDTS10000706-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/OT_Virtual_Server/listing1.html%3Fid%3DDTS10000706-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/OT_Virtual_Server/listing1.html%3Fid%3DDTS10000706-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>