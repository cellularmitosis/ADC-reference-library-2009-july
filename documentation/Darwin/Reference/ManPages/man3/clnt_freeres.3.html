<html><head><title>Mac OS X
 Manual Page For clnt_freeres(3)</title>
<style type="text/css"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { font-size: 1px; background: #ffffff; color: #ffffff; } --></style>
<style type="text/css" media="print, aural, braille, embossed, projection, tty"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { display: none; } --></style>
</head><body bgcolor="white">
<a name="//apple_ref/doc/man/3/clnt_freeres" title="Mac OS X
 Manual Page for clnt_freeres(3)"><!-- headerDoc=man; indexgroup=Section 3; uid="//apple_ref/doc/man/3/clnt_freeres"; name=clnt_freeres(3) --></a>
<!--#include virtual="/includes/framesetheader"-->
<table width=600><tr><td scope="row">
<!-- begin breadcrumb insert request --><font face="Geneva,Helvetica,Arial" size="1">
 <a target="_top" href="http://developer.apple.com">ADC Home</a> <b>&gt;</b> <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> <b>&gt;</b> <a href="../../../../../reference/index.html#//apple_ref/doc/uid/TP30001281" target="_top">Reference</a> <b>&gt;</b> <!-- a href="" target="_top" -->Mac OS X<!-- /a --> <b>&gt;</b> <a href="../index.html#//apple_ref/doc/framework/manpages" target="_top">Mac OS X Man Pages</a></font>
<!-- end breadcrumb insert request -->
<p>&nbsp;</p>
</td></tr></table>
<!-- end of header -->
<table border="0"  cellpadding="2" cellspacing="2" width="630pt"><tr><td valign="top" height="12" colspan="5" scope="row">
<p style='text-align:justify;'>This document is a Mac OS X manual page.  Manual pages are a command-line technology
for providing documentation.  You can view these manual pages locally using the
<a href="../man1/man.1.html#//apple_ref/doc/man/1/man">man(1)</a> command.
These manual pages come from many different sources, and thus, have a variety of writing
styles.</p>
<p style='text-align:justify;'>For more information about the manual page format, see the manual page for 
<a href="../man5/manpages.5.html#//apple_ref/doc/man/5/manpages">manpages(5)</a>.</p>
</td></tr></table>
<hr />
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row"><pre class="manpages"><tt>
RPC(3N)                                                                                              <!-- a -->RPC(3N)<!-- /a -->



<b>NAME</b>
       rpc - library routines for remote procedure calls

<b>SYNOPSIS</b> <b>AND</b> <b>DESCRIPTION</b>
       These routines allow C programs to make procedure calls on other machines across the network.  First,
       the client calls a procedure to send a data packet to the server.  Upon receipt of  the  packet,  the
       server  calls  a  dispatch  routine  to  perform  the requested service, and then sends back a reply.
       Finally, the procedure call returns to the client.

       Routines that are used for Secure RPC (DES authentication) are described in  <!-- a --><b>rpc_secure</b>(3N)<!-- /a -->.   Secure
       RPC can be used only if DES encryption is available.

       <b>#include</b> <b>&lt;rpc/rpc.h&gt;</b>

       <b>void</b>
       <b>auth_destroy(auth)</b>
       <b>AUTH</b> <b>*auth;</b>

              A  macro  that destroys the authentication information associated with <u>auth</u>.  Destruction usu-<font color="#ffffff" class="whiteout">ally&nbsp;usually</font>
              ally involves deallocation of private data structures. The use  of  <u>auth</u>  is  undefined  after
              calling <b>auth_destroy()</b>.

       <b>AUTH</b> <b>*</b>
       <b>authnone_create()</b>

              Create  and returns an RPC authentication handle that passes nonusable authentication informa-<font color="#ffffff" class="whiteout">tion&nbsp;information</font>
              tion with each remote procedure call. This is the default authentication used by RPC.

       <b>AUTH</b> <b>*</b>
       <b>authunix_create(host,</b> <b>uid,</b> <b>gid,</b> <b>len,</b> <b>aup_gids)</b>
       <b>char</b> <b>*host;</b>
       <b>int</b> <b>uid,</b> <b>gid,</b> <b>len,</b> <b>*aup.gids;</b>

              Create and return an RPC authentication handle that contains authentication information.   The
              parameter  <u>host</u>  is  the  name of the machine on which the information was created; <u>uid</u> is the
              user's user ID ; <u>gid</u> is the user's current group ID ; <u>len</u> and  <u>aup</u><b>_</b><u>gids</u>  refer  to  a  counted
              array of groups to which the user belongs.  It is easy to impersonate a user.

       <b>AUTH</b> <b>*</b>
       <b>authunix_create_default()</b>

              Calls <b>authunix_create()</b> with the appropriate parameters.

       <b>callrpc(host,</b> <b>prognum,</b> <b>versnum,</b> <b>procnum,</b> <b>inproc,</b> <b>in,</b> <b>outproc,</b> <b>out)</b>
       <b>char</b> <b>*host;</b>
       <b>u_long</b> <b>prognum,</b> <b>versnum,</b> <b>procnum;</b>
       <b>char</b> <b>*in,</b> <b>*out;</b>
       <b>xdrproc_t</b> <b>inproc,</b> <b>outproc;</b>

              Call  the remote procedure associated with <u>prognum</u>, <u>versnum</u>, and <u>procnum</u> on the machine, <u>host</u>.
              The parameter <u>in</u> is the address of the procedure's <!-- a -->argument(s)<!-- /a -->, and  <u>out</u>  is  the  address  of
              where to place the <!-- a -->result(s)<!-- /a -->; <u>inproc</u> is used to encode the procedure's parameters, and <u>outproc</u>
              is used to decode the procedure's results.  This routine returns zero if it succeeds,  or  the
              value  of  <b>enum</b>  <b>clnt_stat</b> cast to an integer if it fails.  The routine <b>clnt_perrno()</b> is handy
              for translating failure statuses into messages.

              Warning: calling remote  procedures  with  this  routine  uses  UDP/IP  as  a  transport;  see
              <b>clntudp_create()</b>  for  restrictions.   You  do  not have control of timeouts or authentication
              using this routine.

       <b>enum</b> <b>clnt_stat</b>
       <b>clnt_broadcast(prognum,</b> <b>versnum,</b> <b>procnum,</b> <b>inproc,</b> <b>in,</b> <b>outproc,</b> <b>out,</b> <b>eachresult)</b>
       <b>u_long</b> <b>prognum,</b> <b>versnum,</b> <b>procnum;</b>
       <b>char</b> <b>*in,</b> <b>*out;</b>
       <b>xdrproc_t</b> <b>inproc,</b> <b>outproc;</b>
       <b>resultproc_t</b> <b>eachresult;</b>

              Like <b>callrpc()</b>, except the call message is broadcast to all locally connected broadcast  nets.
              Each time it receives a response, this routine calls <b>eachresult()</b>, whose form is:

                 <b>eachresult(out,</b> <b>addr)</b>
                 <b>char</b> <b>*out;</b>
                 <b>struct</b> <b>sockaddr_in</b> <b>*addr;</b>

              where  <u>out</u>  is  the same as <u>out</u> passed to <b>clnt_broadcast()</b>, except that the remote procedure's
              output is decoded there; <u>addr</u> points to the address of the machine that sent the results.   If
              <b>eachresult()</b>  returns zero, <b>clnt_broadcast()</b> waits for more replies; otherwise it returns with
              appropriate status.

              Warning: broadcast sockets are limited in size to the maximum transfer unit of the data  link.
              For ethernet, this value is 1500 bytes.

       <b>enum</b> <b>clnt_stat</b>
       <b>clnt_call(clnt,</b> <b>procnum,</b> <b>inproc,</b> <b>in,</b> <b>outproc,</b> <b>out,</b> <b>tout)</b>
       <b>CLIENT</b> <b>*clnt;</b>
       <b>u_long</b>
       <b>procnum;</b>
       <b>xdrproc_t</b> <b>inproc,</b> <b>outproc;</b>
       <b>char</b> <b>*in,</b> <b>*out;</b>
       <b>struct</b> <b>timeval</b> <b>tout;</b>

              A macro that calls the remote procedure <u>procnum</u> associated with the client handle, <u>clnt</u>, which
              is obtained with an RPC client creation routine such as <b>clnt_create()</b>.  The  parameter  <u>in</u>  is
              the  address  of  the  procedure's  <!-- a -->argument(s)<!-- /a -->,  and <u>out</u> is the address of where to place the
              <!-- a -->result(s)<!-- /a -->; <u>inproc</u> is used to encode the procedure's parameters, and <u>outproc</u> is used to  decode
              the procedure's results; <u>tout</u> is the time allowed for results to come back.

       <b>clnt_destroy(clnt)</b>
       <b>CLIENT</b> <b>*clnt;</b>

              A  macro  that  destroys the client's RPC handle. Destruction usually involves deallocation of
              private data structures, including <u>clnt</u> itself.   Use  of  <u>clnt</u>  is  undefined  after  calling
              <b>clnt_destroy()</b>.  If the RPC library opened the associated socket, it will close it also.  Oth-<font color="#ffffff" class="whiteout">erwise,&nbsp;Otherwise,</font>
              erwise, the socket remains open.

       <b>CLIENT</b> <b>*</b>
       <b>clnt_create(host,</b> <b>prog,</b> <b>vers,</b> <b>proto)</b>
       <b>char</b> <b>*host;</b>
       <b>u_long</b> <b>prog,</b> <b>vers;</b>
       <b>char</b> <b>*proto;</b>

              Generic client creation routine.  <u>host</u> identifies the name of the remote host where the server
              is  located.  <u>proto</u> indicates which kind of transport protocol to use. The currently supported
              values for this field are "udp" and "tcp".  Default timeouts are  set,  but  can  be  modified
              using <b>clnt_control()</b>.

              Warning:  Using  UDP has its shortcomings.  Since UDP-based RPC messages can only hold up to 8
              Kbytes of encoded data, this transport cannot be used for procedures that take large arguments
              or return huge results.

       <b>bool_t</b>
       <b>clnt_control(cl,</b> <b>req,</b> <b>info)</b>
       <b>CLIENT</b> <b>*cl;</b>
       <b>char</b> <b>*info;</b>

              A  macro  used to change or retrieve various information about a client object.  <u>req</u> indicates
              the type of operation, and <u>info</u> is a pointer to the information. For both  UDP  and  TCP,  the
              supported values of <u>req</u> and their argument types and what they do are:

              CLSET_TIMEOUT       struct timeval      set total timeout
              CLGET_TIMEOUT       struct timeval      get total timeout

              Note: if you set the timeout using <b>clnt_control()</b>, the timeout parameter passed to <b>clnt_call()</b>
              will be ignored in all future calls.

              CLGET_SERVER_ADDR   struct sockaddr_in  get server's address

              The following operations are valid for UDP only:

              CLSET_RETRY_TIMEOUT                     struct timeval      set the retry timeout
              CLGET_RETRY_TIMEOUT                     struct timeval      get the retry timeout

              The retry timeout is the time that UDP RPC waits for the server to reply before retransmitting
              the request.

       <b>clnt_freeres(clnt,</b> <b>outproc,</b> <b>out)</b>
       <b>CLIENT</b> <b>*clnt;</b>
       <b>xdrproc_t</b> <b>outproc;</b>
       <b>char</b> <b>*out;</b>

              A  macro that frees any data allocated by the RPC/XDR system when it decoded the results of an
              RPC call.  The parameter <u>out</u> is the address of the results, and <u>outproc</u>  is  the  XDR  routine
              describing  the results.  This routine returns one if the results were successfully freed, and
              zero otherwise.

       <b>void</b>
       <b>clnt_geterr(clnt,</b> <b>errp)</b>
       <b>CLIENT</b> <b>*clnt;</b>
       <b>struct</b> <b>rpc_err</b> <b>*errp;</b>

              A macro that copies the error structure out of the client handle to the structure  at  address
              <u>errp</u>.

       <b>void</b>
       <!-- a --><b>clnt_pcreateerror(s)</b><!-- /a --><b></b>
       <b>char</b> <b>*s;</b>

              Print  a  message  to  standard error indicating why a client RPC handle could not be created.
              The message is prepended with string <u>s</u> and a colon.  Used when a  <b>clnt_create()</b>,  <b>clntraw_cre</b>-<font color="#ffffff" class="whiteout">ate(),&nbsp;clntraw_create(),</font>
              <b>ate()</b>, <b>clnttcp_create()</b>, or <b>clntudp_create()</b> call fails.

       <b>void</b>
       <b>clnt_perrno(stat)</b>
       <b>enum</b> <b>clnt_stat</b> <b>stat;</b>

              Print  a  message  to  standard  error corresponding to the condition indicated by <u>stat</u>.  Used
              after <b>callrpc()</b>.

       <b>clnt_perror(clnt,</b> <b>s)</b>
       <b>CLIENT</b> <b>*clnt;</b>
       <b>char</b> <b>*s;</b>

              Print a message to standard error indicating why an RPC call failed; <u>clnt</u> is the  handle  used
              to  do the call.  The message is prepended with string <u>s</u> and a colon.  Used after <b>clnt_call()</b>.

       <b>char</b> <b>*</b>
       <b>clnt_spcreateerror</b>
       <b>char</b> <b>*s;</b>

              Like <b>clnt_pcreateerror()</b>, except that it returns a string instead of printing to the  standard
              error.

              Bugs: returns pointer to static data that is overwritten on each call.

       <b>char</b> <b>*</b>
       <b>clnt_sperrno(stat)</b>
       <b>enum</b> <b>clnt_stat</b> <b>stat;</b>

              Take  the  same  arguments  as <b>clnt_perrno()</b>, but instead of sending a message to the standard
              error indicating why an RPC call failed, return a pointer to a string which contains the  mes-<font color="#ffffff" class="whiteout">sage.&nbsp;message.</font>
              sage.  The string ends with a NEWLINE.

              <b>clnt_sperrno()</b>  is used instead of <b>clnt_perrno()</b> if the program does not have a standard error
              (as a program running as a server quite likely does not), or if the programmer does  not  want
              the  message to be output with <b>printf</b>, or if a message format different than that supported by
              <b>clnt_perrno()</b> is to be used.  Note: unlike <b>clnt_sperror()</b> and <b>clnt_spcreaterror()</b>,  <b>clnt_sper</b>-<font color="#ffffff" class="whiteout">rno()&nbsp;clnt_sperrno()</font>
              <b>rno()</b> returns pointer to static data, but the result will not get overwritten on each call.

       <b>char</b> <b>*</b>
       <b>clnt_sperror(rpch,</b> <b>s)</b>
       <b>CLIENT</b> <b>*rpch;</b>
       <b>char</b> <b>*s;</b>

              Like  <b>clnt_perror()</b>, except that (like <b>clnt_sperrno()</b>) it returns a string instead of printing
              to standard error.

              Bugs: returns pointer to static data that is overwritten on each call.

       <b>CLIENT</b> <b>*</b>
       <b>clntraw_create(prognum,</b> <b>versnum)</b>
       <b>u_long</b> <b>prognum,</b> <b>versnum;</b>

              This routine creates a toy RPC client for the remote program <u>prognum</u>,  version  <u>versnum</u>.   The
              transport  used  to  pass  messages  to  the service is actually a buffer within the process's
              address space, so the corresponding RPC server should live in  the  same  address  space;  see
              <b>svcraw_create()</b>.   This  allows  simulation  of  RPC and acquisition of RPC overheads, such as
              round trip times, without any kernel interference. This routine returns NULL if it fails.

       <b>CLIENT</b> <b>*</b>
       <b>clnttcp_create(addr,</b> <b>prognum,</b> <b>versnum,</b> <b>sockp,</b> <b>sendsz,</b> <b>recvsz)</b>
       <b>struct</b> <b>sockaddr_in</b> <b>*addr;</b>
       <b>u_long</b> <b>prognum,</b> <b>versnum;</b>
       <b>int</b> <b>*sockp;</b>
       <b>u_int</b> <b>sendsz,</b> <b>recvsz;</b>

              This routine creates an RPC client for the remote program <u>prognum</u>, version <u>versnum</u>; the client
              uses  TCP/IP  as  a  transport.  The  remote program is located at Internet address <u>*addr</u>.  If
              <b>addr-&gt;sin_port</b> is zero, then it is set to the actual port that the remote program is listening
              on  (the  remote  <b>portmap</b> service is consulted for this information). The parameter <u>sockp</u> is a
              socket; if it is <b>RPC_ANYSOCK</b>, then this routine opens a new one and sets  <u>sockp</u>.   Since  TCP-<font color="#ffffff" class="whiteout">based&nbsp;TCPbased</font>
              based  RPC  uses  buffered I/O , the user may specify the size of the send and receive buffers
              with the parameters <u>sendsz</u> and <u>recvsz</u>; values of zero choose suitable defaults.  This  routine
              returns NULL if it fails.

       <b>CLIENT</b> <b>*</b>
       <b>clntudp_create(addr,</b> <b>prognum,</b> <b>versnum,</b> <b>wait,</b> <b>sockp)</b>
       <b>struct</b> <b>sockaddr_in</b> <b>*addr;</b>
       <b>u_long</b> <b>prognum,</b> <b>versnum;</b>
       <b>struct</b> <b>timeval</b> <b>wait;</b>
       <b>int</b> <b>*sockp;</b>

              This routine creates an RPC client for the remote program <u>prognum</u>, version <u>versnum</u>; the client
              uses use UDP/IP as a transport. The remote program is located at Internet  address  <u>addr</u>.   If
              <b>addr-&gt;sin_port</b>  is zero, then it is set to actual port that the remote program is listening on
              (the remote <b>portmap</b> service is consulted for this  information).  The  parameter  <u>sockp</u>  is  a
              socket;  if  it  is  <b>RPC_ANYSOCK</b>,  then  this routine opens a new one and sets <u>sockp</u>.  The UDP
              transport resends the call message in intervals of <b>wait</b> time until a response is  received  or
              until  the  call  times  out.   The  total  time  for  the  call  to  time out is specified by
              <b>clnt_call()</b>.

              Warning: since UDP-based RPC messages can only hold up to  8  Kbytes  of  encoded  data,  this
              transport cannot be used for procedures that take large arguments or return huge results.

       <b>CLIENT</b> <b>*</b>
       <b>clntudp_bufcreate(addr,</b> <b>prognum,</b> <b>versnum,</b> <b>wait,</b> <b>sockp,</b> <b>sendsize,</b> <b>recosize)</b>
       <b>struct</b> <b>sockaddr_in</b> <b>*addr;</b>
       <b>u_long</b> <b>prognum,</b> <b>versnum;</b>
       <b>struct</b> <b>timeval</b> <b>wait;</b>
       <b>int</b> <b>*sockp;</b>
       <b>unsigned</b> <b>int</b> <b>sendsize;</b>
       <b>unsigned</b> <b>int</b> <b>recosize;</b>

              This routine creates an RPC client for the remote program <u>prognum</u>, on <u>versnum</u>; the client uses
              use UDP/IP as a transport. The remote  program  is  located  at  Internet  address  <u>addr</u>.   If
              <b>addr-&gt;sin_port</b>  is zero, then it is set to actual port that the remote program is listening on
              (the remote <b>portmap</b> service is consulted for this  information).  The  parameter  <u>sockp</u>  is  a
              socket;  if  it  is  <b>RPC_ANYSOCK</b>,  then  this routine opens a new one and sets <b>sockp</b>.  The UDP
              transport resends the call message in intervals of <b>wait</b> time until a response is  received  or
              until  the  call  times  out.   The  total  time  for  the  call  to  time out is specified by
              <b>clnt_call()</b>.

              This allows the user to specify the maximun packet size for sending  and  receiving  UDP-based
              RPC messages.

       <b>void</b>
       <b>get_myaddress(addr)</b>
       <b>struct</b> <b>sockaddr_in</b> <b>*addr;</b>

              Stuff  the  machine's IP address into <u>*addr</u>, without consulting the library routines that deal
              with <b>/etc/hosts</b>.  The port number is always set to <b>htons(PMAPPORT)</b>.

       <b>struct</b> <b>pmaplist</b> <b>*</b>
       <b>pmap_getmaps(addr)</b>
       <b>struct</b> <b>sockaddr_in</b> <b>*addr;</b>

              A user interface to the <b>portmap</b> service, which returns a list of the current  RPC  program-to-<font color="#ffffff" class="whiteout">port&nbsp;program-toport</font>
              port  mappings  on  the host located at IP address <u>*addr</u>.  This routine can return NULL .  The
              command `<b>rpcinfo</b> <b>-p</b>' uses this routine.

       <b>u_short</b>
       <b>pmap_getport(addr,</b> <b>prognum,</b> <b>versnum,</b> <b>protocol)</b>
       <b>struct</b> <b>sockaddr_in</b> <b>*addr;</b>
       <b>u_long</b> <b>prognum,</b> <b>versnum,</b> <b>protocol;</b>

              A user interface to the <b>portmap</b> service, which returns the port number on which waits  a  ser-<font color="#ffffff" class="whiteout">vice&nbsp;service</font>
              vice  that supports program number <u>prognum</u>, version <u>versnum</u>, and speaks the transport protocol
              associated with <u>protocol</u>.  The value of <u>protocol</u> is most likely <b>IPPROTO_UDP</b> or <b>IPPROTO_TCP</b>.  A
              return  value of zero means that the mapping does not exist or that the RPC system failured to
              contact the remote <b>portmap</b> service.  In the latter case, the global  variable  <b>rpc_createerr()</b>
              contains the RPC status.

       <b>enum</b> <b>clnt_stat</b>
       <b>pmap_rmtcall(addr,</b> <b>prognum,</b> <b>versnum,</b> <b>procnum,</b> <b>inproc,</b> <b>in,</b> <b>outproc,</b> <b>out,</b> <b>tout,</b> <b>portp)</b>
       <b>struct</b> <b>sockaddr_in</b> <b>*addr;</b>
       <b>u_long</b> <b>prognum,</b> <b>versnum,</b> <b>procnum;</b>
       <b>char</b> <b>*in,</b> <b>*out;</b>
       <b>xdrproc_t</b> <b>inproc,</b> <b>outproc;</b>
       <b>struct</b> <b>timeval</b> <b>tout;</b>
       <b>u_long</b> <b>*portp;</b>

              A  user  interface  to  the <b>portmap</b> service, which instructs <b>portmap</b> on the host at IP address
              <u>*addr</u> to make an RPC call on your behalf to a procedure on that host.   The  parameter  <u>*portp</u>
              will  be  modified  to the program's port number if the procedure succeeds. The definitions of
              other parameters are discussed in <b>callrpc()</b> and <b>clnt_call()</b>.  This procedure  should  be  used
              for a "ping" and nothing else.  See also <b>clnt_broadcast()</b>.

       <b>pmap_set(prognum,</b> <b>versnum,</b> <b>protocol,</b> <b>port)</b>
       <b>u_long</b> <b>prognum,</b> <b>versnum,</b> <b>protocol;</b>
       <b>u_short</b> <b>port;</b>

              A  user  interface  to  the  <b>portmap</b>  service,  which establishes a mapping between the triple
              [<u>prognum</u>,<u>versnum</u>,<u>protocol</u>] and <u>port</u> on the machine's <b>portmap</b> service. The value of <u>protocol</u> is
              most  likely <b>IPPROTO_UDP</b> or <b>IPPROTO_TCP</b>.  This routine returns one if it succeeds, zero other-<font color="#ffffff" class="whiteout">wise.&nbsp;otherwise.</font>
              wise.  Automatically done by <b>svc_register()</b>.

       <b>pmap_unset(prognum,</b> <b>versnum)</b>
       <b>u_long</b> <b>prognum,</b> <b>versnum;</b>

              A user interface to the <b>portmap</b>  service,  which  destroys  all  mapping  between  the  triple
              [<u>prognum</u>,<u>versnum</u>,<u>*</u>] and <b>ports</b> on the machine's <b>portmap</b> service. This routine returns one if it
              succeeds, zero otherwise.

       <b>registerrpc(prognum,</b> <b>versnum,</b> <b>procnum,</b> <b>procname,</b> <b>inproc,</b> <b>outproc)</b>
       <b>u_long</b> <b>prognum,</b> <b>versnum,</b> <b>procnum;</b>
       <b>char</b> <b>*(*procname)</b> <b>()</b> <b>;</b>
       <b>xdrproc_t</b> <b>inproc,</b> <b>outproc;</b>

              Register procedure <u>procname</u> with the RPC service package.  If a request  arrives  for  program
              <u>prognum</u>,  version  <u>versnum</u>,  and  procedure  <u>procnum</u>, <u>procname</u> is called with a pointer to its
              <!-- a -->parameter(s)<!-- /a -->; <u>progname</u> should return a pointer to its static  <!-- a -->result(s)<!-- /a -->;  <u>inproc</u>  is  used  to
              decode  the parameters while <u>outproc</u> is used to encode the results.  This routine returns zero
              if the registration succeeded, -1 otherwise.

              Warning: remote procedures registered in this form are accessed using  the  UDP/IP  transport;
              see <b>svcudp_create()</b> for restrictions.

       <b>struct</b> <b>rpc_createerr</b>     <b>rpc_createerr;</b>

              A global variable whose value is set by any RPC client creation routine that does not succeed.
              Use the routine <b>clnt_pcreateerror()</b> to print the reason why.

       <b>svc_destroy(xprt)</b>
       <b>SVCXPRT</b> <b>*</b>
       <b>xprt;</b>

              A macro that destroys the RPC service transport handle, <u>xprt</u>.   Destruction  usually  involves
              deallocation  of  private  data  structures,  including <u>xprt</u> itself.  Use of <u>xprt</u> is undefined
              after calling this routine.

       <b>fd_set</b> <b>svc_fdset;</b>

              A global variable reflecting the RPC service side's read file descriptor bit mask; it is suit-<font color="#ffffff" class="whiteout">able&nbsp;suitable</font>
              able as a parameter to the <b>select</b> system call. This is only of interest if a service implemen-<font color="#ffffff" class="whiteout">tor&nbsp;implementor</font>
              tor does not call <b>svc_run()</b>, but rather does his  own  asynchronous  event  processing.   This
              variable  is  read-only (do not pass its address to <b>select</b>!), yet it may change after calls to
              <b>svc_getreqset()</b> or any creation routines.

       <b>int</b> <b>svc_fds;</b>

              Similar to <b>svc_fedset()</b>, but limited  to  32  descriptors.  This  interface  is  obsoleted  by
              <b>svc_fdset()</b>.

       <b>svc_freeargs(xprt,</b> <b>inproc,</b> <b>in)</b>
       <b>SVCXPRT</b> <b>*xprt;</b>
       <b>xdrproc_t</b> <b>inproc;</b>
       <b>char</b> <b>*in;</b>

              A macro that frees any data allocated by the RPC/XDR system when it decoded the arguments to a
              service procedure using <b>svc_getargs()</b>.  This routine returns 1 if the  results  were  success-<font color="#ffffff" class="whiteout">fully&nbsp;successfully</font>
              fully freed, and zero otherwise.

       <b>svc_getargs(xprt,</b> <b>inproc,</b> <b>in)</b>
       <b>SVCXPRT</b> <b>*xprt;</b>
       <b>xdrproc_t</b> <b>inproc;</b>
       <b>char</b> <b>*in;</b>

              A macro that decodes the arguments of an RPC request associated with the RPC service transport
              handle, <u>xprt</u>.  The parameter <u>in</u> is the address where the arguments will be placed;  <u>inproc</u>  is
              the  XDR routine used to decode the arguments.  This routine returns one if decoding succeeds,
              and zero otherwise.

       <b>struct</b> <b>sockaddr_in</b> <b>*</b>
       <b>svc_getcaller(xprt)</b>
       <b>SVCXPRT</b> <b>*xprt;</b>

              The approved way of getting the network address of the caller of a procedure  associated  with
              the RPC service transport handle, <u>xprt</u>.

       <b>svc_getreqset(rdfds)</b>
       <b>fd_set</b> <b>*rdfds;</b>

              This routine is only of interest if a service implementor does not call <b>svc_run()</b>, but instead
              implements custom asynchronous event processing.  It is called when the <b>select</b> system call has
              determined that an RPC request has arrived on some RPC <!-- a --><b>socket(s)</b><!-- /a --><b></b> <b>;</b> <u>rdfds</u> is the resultant read
              file descriptor bit mask.  The routine returns when all sockets associated with the  value  of
              <u>rdfds</u> have been serviced.

       <b>svc_getreq(rdfds)</b>
       <b>int</b> <b>rdfds;</b>

              Similar  to  <b>svc_getreqset()</b>,  but  limited  to 32 descriptors. This interface is obsoleted by
              <b>svc_getreqset()</b>.

       <b>svc_register(xprt,</b> <b>prognum,</b> <b>versnum,</b> <b>dispatch,</b> <b>protocol)</b>
       <b>SVCXPRT</b> <b>*xprt;</b>
       <b>u_long</b> <b>prognum,</b> <b>versnum;</b>
       <b>void</b> <b>(*dispatch)</b> <b>();</b>
       <b>u_long</b> <b>protocol;</b>

              Associates <u>prognum</u> and <u>versnum</u> with the service dispatch procedure, <u>dispatch</u>.  If <u>protocol</u>  is
              zero, the service is not registered with the <b>portmap</b> service.  If <u>protocol</u> is non-zero, then a
              mapping of the triple [<u>prognum</u>,<u>versnum</u>,<u>protocol</u>] to  <b>xprt-&gt;xp_port</b>  is  established  with  the
              local  <b>portmap</b>  service (generally <u>protocol</u> is zero, <b>IPPROTO_UDP</b> or <b>IPPROTO_TCP</b> ).  The proce-<font color="#ffffff" class="whiteout">dure&nbsp;procedure</font>
              dure <u>dispatch</u> has the following form:
                 <b>dispatch(request,</b> <b>xprt)</b>
                 <b>struct</b> <b>svc_req</b> <b>*request;</b>
                 <b>SVCXPRT</b> <b>*xprt;</b>

              The <b>svc_register()</b> routine returns one if it succeeds, and zero otherwise.

       <b>svc_run()</b>

              This routine never returns. It waits for RPC requests to arrive,  and  calls  the  appropriate
              service procedure using <b>svc_getreq()</b> when one arrives. This procedure is usually waiting for a
              <b>select()</b> system call to return.

       <b>svc_sendreply(xprt,</b> <b>outproc,</b> <b>out)</b>
       <b>SVCXPRT</b> <b>*xprt;</b>
       <b>xdrproc_t</b> <b>outproc;</b>
       <b>char</b> <b>*out;</b>

              Called by an RPC service's dispatch routine to send the results of a  remote  procedure  call.
              The  parameter  <u>xprt</u>  is the request's associated transport handle; <u>outproc</u> is the XDR routine
              which is used to encode the results; and <u>out</u> is the address  of  the  results.   This  routine
              returns one if it succeeds, zero otherwise.

       <b>void</b>
       <b>svc_unregister(prognum,</b> <b>versnum)</b>
       <b>u_long</b> <b>prognum,</b> <b>versnum;</b>

              Remove  all  mapping  of  the double [<u>prognum</u>,<u>versnum</u>] to dispatch routines, and of the triple
              [<u>prognum</u>,<u>versnum</u>,<u>*</u>] to port number.

       <b>void</b>
       <b>svcerr_auth(xprt,</b> <b>why)</b>
       <b>SVCXPRT</b> <b>*xprt;</b>
       <b>enum</b> <b>auth_stat</b> <b>why;</b>

              Called by a service dispatch routine that refuses to perform a remote procedure call due to an
              authentication error.

       <b>void</b>
       <b>svcerr_decode(xprt)</b>
       <b>SVCXPRT</b> <b>*xprt;</b>

              Called  by a service dispatch routine that cannot successfully decode its parameters. See also
              <b>svc_getargs()</b>.

       <b>void</b>
       <b>svcerr_noproc(xprt)</b>
       <b>SVCXPRT</b> <b>*xprt;</b>

              Called by a service dispatch routine that does not implement the  procedure  number  that  the
              caller requests.

       <b>void</b>
       <b>svcerr_noprog(xprt)</b>
       <b>SVCXPRT</b> <b>*xprt;</b>

              Called  when  the desired program is not registered with the RPC package. Service implementors
              usually do not need this routine.

       <b>void</b>
       <b>svcerr_progvers(xprt)</b>
       <b>SVCXPRT</b> <b>*xprt;</b>

              Called when the desired version of a program is not registered with the RPC  package.  Service
              implementors usually do not need this routine.

       <b>void</b>
       <b>svcerr_systemerr(xprt)</b>
       <b>SVCXPRT</b> <b>*xprt;</b>

              Called by a service dispatch routine when it detects a system error not covered by any partic-<font color="#ffffff" class="whiteout">ular&nbsp;particular</font>
              ular protocol.  For example, if a service can no longer allocate storage,  it  may  call  this
              routine.

       <b>void</b>
       <b>svcerr_weakauth(xprt)</b>
       <b>SVCXPRT</b> <b>*xprt;</b>

              Called  by  a  service dispatch routine that refuses to perform a remote procedure call due to
              insufficient authentication parameters.  The routine calls <b>svcerr_auth(xprt,</b> <b>AUTH_TOOWEAK)</b>.

       <b>SVCXPRT</b> <b>*</b>
       <b>svcraw_create()</b>

              This routine creates a toy RPC service transport, to which it returns a pointer.   The  trans-<font color="#ffffff" class="whiteout">port&nbsp;transport</font>
              port  is  really  a buffer within the process's address space, so the corresponding RPC client
              should live in the same address space; see <b>clntraw_create()</b>.  This routine  allows  simulation
              of  RPC and acquisition of RPC overheads (such as round trip times), without any kernel inter-<font color="#ffffff" class="whiteout">ference.&nbsp;interference.</font>
              ference.  This routine returns NULL if it fails.

       <b>SVCXPRT</b> <b>*</b>
       <b>svctcp_create(sock,</b> <b>send_buf_size,</b> <b>recv_buf_size)</b>
       <b>int</b> <b>sock;</b>
       <b>u_int</b> <b>send_buf_size,</b> <b>recv_buf_size;</b>

              This routine creates a TCP/IP-based RPC service transport, to which it returns a pointer.  The
              transport  is  associated  with the socket <u>sock</u>, which may be <b>RPC_ANYSOCK</b>, in which case a new
              socket is created.  If the socket is not bound to a local TCP port, then this routine binds it
              to  an  arbitrary  port.  Upon completion, <b>xprt-&gt;xp_sock</b> is the transport's socket descriptor,
              and <b>xprt-&gt;xp_port</b> is the transport's port number.  This routine  returns  NULL  if  it  fails.
              Since  TCP-based RPC uses buffered I/O , users may specify the size of buffers; values of zero
              choose suitable defaults.

       <b>SVCXPRT</b> <b>*</b>
       <b>svcfd_create(fd,</b> <b>sendsize,</b> <b>recvsize)</b>
       <b>int</b> <b>fd;</b>
       <b>u_int</b> <b>sendsize;</b>
       <b>u_int</b> <b>recvsize;</b>

              Create a service on top of any open descriptor. Typically,  this  descriptor  is  a  connected
              socket  for  a stream protocol such as TCP.  <u>sendsize</u> and <u>recvsize</u> indicate sizes for the send
              and receive buffers.  If they are zero, a reasonable default is chosen.

       <b>SVCXPRT</b> <b>*</b>
       <b>svcudp_bufcreate(sock,</b> <b>sendsize,</b> <b>recosize)</b>
       <b>int</b> <b>sock;</b>

              This routine creates a UDP/IP-based RPC service transport, to which it returns a pointer.  The
              transport  is  associated with the socket <u>sock</u>, which may be <b>RPC_ANYSOCK</b> <b>,</b> in which case a new
              socket is created.  If the socket is not bound to a local UDP port, then this routine binds it
              to an arbitrary port. Upon completion, <b>xprt-&gt;xp_sock</b> is the transport's socket descriptor, and
              <b>xprt-&gt;xp_port</b> is the transport's port number.  This routine returns NULL if it fails.

              This allows the user to specify the maximun packet size for sending  and  receiving  UDP-based
              RPC messages.

       <b>xdr_accepted_reply(xdrs,</b> <b>ar)</b>
       <b>XDR</b> <b>*xdrs;</b>
       <b>struct</b> <b>accepted_reply</b> <b>*ar;</b>

              Used  for  encoding  RPC reply messages. This routine is useful for users who wish to generate
              RPC-style messages without using the RPC package.

       <b>xdr_authunix_parms(xdrs,</b> <b>aupp)</b>
       <b>XDR</b> <b>*xdrs;</b>
       <b>struct</b> <b>authunix_parms</b> <b>*aupp;</b>

              Used for describing UNIX credentials. This routine is useful for users who  wish  to  generate
              these credentials without using the RPC authentication package.

       <b>void</b>
       <b>xdr_callhdr(xdrs,</b> <b>chdr)</b>
       <b>XDR</b> <b>*xdrs;</b>
       <b>struct</b> <b>rpc_msg</b> <b>*chdr;</b>

              Used  for  describing  RPC call header messages.  This routine is useful for users who wish to
              generate RPC-style messages without using the RPC package.

       <b>xdr_callmsg(xdrs,</b> <b>cmsg)</b>
       <b>XDR</b> <b>*xdrs;</b>
       <b>struct</b> <b>rpc_msg</b> <b>*cmsg;</b>

              Used for describing RPC call messages.  This routine is useful for users who wish to  generate
              RPC-style messages without using the RPC package.

       <b>xdr_opaque_auth(xdrs,</b> <b>ap)</b>
       <b>XDR</b> <b>*xdrs;</b>
       <b>struct</b> <b>opaque_auth</b> <b>*ap;</b>

              Used for describing RPC authentication information messages.  This routine is useful for users
              who wish to generate RPC-style messages without using the RPC package.

       <b>xdr_pmap(xdrs,</b> <b>regs)</b>
       <b>XDR</b> <b>*xdrs;</b>
       <b>struct</b> <b>pmap</b> <b>*regs;</b>

              Used for describing parameters to various <b>portmap</b> procedures,  externally.   This  routine  is
              useful for users who wish to generate these parameters without using the <b>pmap</b> interface.

       <b>xdr_pmaplist(xdrs,</b> <b>rp)</b>
       <b>XDR</b> <b>*xdrs;</b>
       <b>struct</b> <b>pmaplist</b> <b>**rp;</b>

              Used for describing a list of port mappings, externally.  This routine is useful for users who
              wish to generate these parameters without using the <b>pmap</b> interface.

       <b>xdr_rejected_reply(xdrs,</b> <b>rr)</b>
       <b>XDR</b> <b>*xdrs;</b>
       <b>struct</b> <b>rejected_reply</b> <b>*rr;</b>

              Used for describing RPC reply messages.  This routine is useful for users who wish to generate
              RPC-style messages without using the RPC package.

       <b>xdr_replymsg(xdrs,</b> <b>rmsg)</b>
       <b>XDR</b> <b>*xdrs;</b>
       <b>struct</b> <b>rpc_msg</b> <b>*rmsg;</b>

              Used for describing RPC reply messages.  This routine is useful for users who wish to generate
              RPC style messages without using the RPC package.

       <b>void</b>
       <b>xprt_register(xprt)</b>
       <b>SVCXPRT</b> <b>*xprt;</b>

              After RPC service transport handles are created, they should register themselves with the  RPC
              service  package.   This routine modifies the global variable <b>svc_fds()</b>.  Service implementors
              usually do not need this routine.

       <b>void</b>
       <b>xprt_unregister(xprt)</b>
       <b>SVCXPRT</b> <b>*xprt;</b>

              Before an RPC service transport handle is destroyed, it should unregister itself with the  RPC
              service  package.   This routine modifies the global variable <b>svc_fds()</b>.  Service implementors
              usually do not need this routine.

<b>SEE</b> <b>ALSO</b>
       <!-- a --><b>rpc_secure</b>(3N)<!-- /a -->, <a href="xdr.3.html#//apple_ref/doc/man/3/xdr"><b>xdr</b>(3N)</a>
       The following manuals:
              <u>Remote</u> <u>Procedure</u> <u>Calls:</u> <u>Protocol</u> <u>Specification</u>
              <u>Remote</u> <u>Procedure</u> <u>Call</u> <u>Programming</u> <u>Guide</u>
              <u>rpcgen</u> <u>Programming</u> <u>Guide</u>
       <u>RPC:</u> <u>Remote</u> <u>Procedure</u> <u>Call</u> <u>Protocol</u> <u>Specification</u>, RFC1050, Sun Microsystems, Inc., USC-ISI.




                                              16 February 1988                                       <!-- a -->RPC(3N)<!-- /a -->
</tt></pre>
</td></tr></table>
	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Darwin/Reference/ManPages/man3/clnt_freeres.3.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Darwin/Reference/ManPages/man3/clnt_freeres.3.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Darwin/Reference/ManPages/man3/clnt_freeres.3.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

</body></html>
