<html><head><title>Mac OS X
 Manual Page For BerkeleyDB(3pm)</title>
<style type="text/css"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { font-size: 1px; background: #ffffff; color: #ffffff; } --></style>
<style type="text/css" media="print, aural, braille, embossed, projection, tty"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { display: none; } --></style>
</head><body bgcolor="white">
<a name="//apple_ref/doc/man/3pm/BerkeleyDB" title="Mac OS X
 Manual Page for BerkeleyDB(3pm)"><a name="//apple_ref/doc/man/3/BerkeleyDB" title="Mac OS X
 Manual Page for BerkeleyDB(3pm)"><!-- headerDoc=man; indexgroup=Section 3pm; uid="//apple_ref/doc/man/3pm/BerkeleyDB"; name=BerkeleyDB(3pm) --></a>
<!--#include virtual="/includes/framesetheader"-->
<table width=600><tr><td scope="row">
<!-- begin breadcrumb insert request --><font face="Geneva,Helvetica,Arial" size="1">
 <a target="_top" href="http://developer.apple.com">ADC Home</a> <b>&gt;</b> <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> <b>&gt;</b> <a href="../../../../../reference/index.html#//apple_ref/doc/uid/TP30001281" target="_top">Reference</a> <b>&gt;</b> <!-- a href="" target="_top" -->Mac OS X<!-- /a --> <b>&gt;</b> <a href="../index.html#//apple_ref/doc/framework/manpages" target="_top">Mac OS X Man Pages</a></font>
<!-- end breadcrumb insert request -->
<p>&nbsp;</p>
</td></tr></table>
<!-- end of header -->
<table border="0"  cellpadding="2" cellspacing="2" width="630pt"><tr><td valign="top" height="12" colspan="5" scope="row">
<p style='text-align:justify;'>This document is a Mac OS X manual page.  Manual pages are a command-line technology
for providing documentation.  You can view these manual pages locally using the
<a href="../man1/man.1.html#//apple_ref/doc/man/1/man">man(1)</a> command.
These manual pages come from many different sources, and thus, have a variety of writing
styles.</p>
<p style='text-align:justify;'>For more information about the manual page format, see the manual page for 
<a href="../man5/manpages.5.html#//apple_ref/doc/man/5/manpages">manpages(5)</a>.</p>
</td></tr></table>
<hr />
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row"><pre class="manpages"><tt>
BerkeleyDB(3)                        User Contributed Perl Documentation                       BerkeleyDB(3)



<b>NAME</b>
       BerkeleyDB - Perl extension for Berkeley DB version 2, 3 or 4

<b>SYNOPSIS</b>
         use BerkeleyDB;

         $env = new BerkeleyDB::Env [OPTIONS] ;

         $db  = tie %hash, 'BerkeleyDB::Hash', [OPTIONS] ;
         $db  = new BerkeleyDB::Hash [OPTIONS] ;

         $db  = tie %hash, 'BerkeleyDB::Btree', [OPTIONS] ;
         $db  = new BerkeleyDB::Btree [OPTIONS] ;

         $db  = tie @array, 'BerkeleyDB::Recno', [OPTIONS] ;
         $db  = new BerkeleyDB::Recno [OPTIONS] ;

         $db  = tie @array, 'BerkeleyDB::Queue', [OPTIONS] ;
         $db  = new BerkeleyDB::Queue [OPTIONS] ;

         $db  = new BerkeleyDB::Unknown [OPTIONS] ;

         $status = BerkeleyDB::db_remove [OPTIONS]
         $status = BerkeleyDB::db_rename [OPTIONS]
         $status = BerkeleyDB::db_verify [OPTIONS]

         $hash{$key} = $value ;
         $value = $hash{$key} ;
         each %hash ;
         keys %hash ;
         values %hash ;

         $status = $db-&gt;db_get()
         $status = $db-&gt;db_put() ;
         $status = $db-&gt;db_del() ;
         $status = $db-&gt;db_sync() ;
         $status = $db-&gt;db_close() ;
         $status = $db-&gt;db_pget()
         $hash_ref = $db-&gt;db_stat() ;
         $status = $db-&gt;db_key_range();
         $type = $db-&gt;type() ;
         $status = $db-&gt;status() ;
         $boolean = $db-&gt;byteswapped() ;
         $status = $db-&gt;truncate($count) ;
         $status = $db-&gt;compact($start, $stop, $c_data, $flags, $end);

         $bool = $env-&gt;cds_enabled();
         $bool = $db-&gt;cds_enabled();
         $lock = $db-&gt;cds_lock();
         $lock-&gt;cds_unlock();

         ($flag, $old_offset, $old_length) = $db-&gt;partial_set($offset, $length) ;
         ($flag, $old_offset, $old_length) = $db-&gt;partial_clear() ;

         $cursor = $db-&gt;db_cursor([$flags]) ;
         $newcursor = $cursor-&gt;c_dup([$flags]);
         $status = $cursor-&gt;c_get() ;
         $status = $cursor-&gt;c_put() ;
         $status = $cursor-&gt;c_del() ;
         $status = $cursor-&gt;c_count() ;
         $status = $cursor-&gt;c_pget() ;
         $status = $cursor-&gt;status() ;
         $status = $cursor-&gt;c_close() ;

         $cursor = $db-&gt;db_join() ;
         $status = $cursor-&gt;c_get() ;
         $status = $cursor-&gt;c_close() ;

         $status = $env-&gt;txn_checkpoint()
         $hash_ref = $env-&gt;txn_stat()
         $status = $env-&gt;setmutexlocks()
         $status = $env-&gt;set_flags()

         $txn = $env-&gt;txn_begin() ;
         $db-&gt;Txn($txn);
         $txn-&gt;Txn($db1, $db2,...);
         $status = $txn-&gt;txn_prepare()
         $status = $txn-&gt;txn_commit()
         $status = $txn-&gt;txn_abort()
         $status = $txn-&gt;txn_id()
         $status = $txn-&gt;txn_discard()

         $status = $env-&gt;set_lg_dir();
         $status = $env-&gt;set_lg_bsize();
         $status = $env-&gt;set_lg_max();

         $status = $env-&gt;set_data_dir() ;
         $status = $env-&gt;set_tmp_dir() ;
         $status = $env-&gt;set_verbose() ;
         $db_env_ptr = $env-&gt;DB_ENV() ;

         $BerkeleyDB::Error
         $BerkeleyDB::db_version

         # DBM Filters
         $old_filter = $db-&gt;filter_store_key  ( sub { ... } ) ;
         $old_filter = $db-&gt;filter_store_value( sub { ... } ) ;
         $old_filter = $db-&gt;filter_fetch_key  ( sub { ... } ) ;
         $old_filter = $db-&gt;filter_fetch_value( sub { ... } ) ;

         # deprecated, but supported
         $txn_mgr = $env-&gt;TxnMgr();
         $status = $txn_mgr-&gt;txn_checkpoint()
         $hash_ref = $txn_mgr-&gt;txn_stat()
         $txn = $txn_mgr-&gt;txn_begin() ;

<b>DESCRIPTION</b>
       <b>NOTE:</b> <b>This</b> <b>document</b> <b>is</b> <b>still</b> <b>under</b> <b>construction.</b> <b>Expect</b> <b>it</b> <b>to</b> <b>be</b> <b>incomplete</b> <b>in</b> <b>places.</b>

       This Perl module provides an interface to most of the functionality available in Berkeley DB versions
       2, 3 and 4. In general it is safe to assume that the interface provided here to be identical to the
       Berkeley DB interface. The main changes have been to make the Berkeley DB API work in a Perl way.
       Note that if you are using Berkeley DB 2.x, the new features available in Berkeley DB 3.x or DB 4.x
       are not available via this module.

       The reader is expected to be familiar with the Berkeley DB documentation. Where the interface
       provided here is identical to the Berkeley DB library and the... TODO

       The <b>db_appinit</b>, <b>db_cursor</b>, <b>db_open</b> and <b>db_txn</b> man pages are particularly relevant.

       The interface to Berkeley DB is implemented with a number of Perl classes.

<b>The</b> <b>BerkeleyDB::Env</b> <b>Class</b>
       The <b>BerkeleyDB::Env</b> class provides an interface to the Berkeley DB function <b>db_appinit</b> in Berkeley DB
       2.x or <b>db_env_create</b> and <b>DBENV-&gt;open</b> in Berkeley DB 3.x/4.x. Its purpose is to initialise a number of
       sub-systems that can then be used in a consistent way in all the databases you make use of in the
       environment.

       If you don't intend using transactions, locking or logging, then you shouldn't need to make use of
       <b>BerkeleyDB::Env</b>.

       Note that an environment consists of a number of files that Berkeley DB manages behind the scenes for
       you. When you first use an environment, it needs to be explicitly created. This is done by including
       "DB_CREATE" with the "Flags" parameter, described below.

       <b>Synopsis</b>

           $env = new BerkeleyDB::Env
                    [ -Home         =&gt; $path, ]
                    [ -Server       =&gt; $name, ]
                    [ -CacheSize    =&gt; $number, ]
                    [ -Config       =&gt; { name =&gt; value, name =&gt; value }, ]
                    [ -ErrFile      =&gt; filename, ]
                    [ -ErrPrefix    =&gt; "string", ]
                    [ -Flags        =&gt; number, ]
                    [ -SetFlags     =&gt; bitmask, ]
                    [ -LockDetect   =&gt; number, ]
                    [ -SharedMemKey =&gt; number, ]
                    [ -Verbose      =&gt; boolean, ]
                    [ -Encrypt      =&gt; { Password =&gt; "string",
                                         Flags    =&gt; number }, ]

       All the parameters to the BerkeleyDB::Env constructor are optional.

       -Home
            If present, this parameter should point to an existing directory. Any files that <u>aren't</u>
            specified with an absolute path in the sub-systems that are initialised by the BerkeleyDB::Env
            class will be assumed to live in the <b>Home</b> directory.

            For example, in the code fragment below the database "fred.db" will be opened in the directory
            "/home/databases" because it was specified as a relative path, but "joe.db" will be opened in
            "/other" because it was part of an absolute path.

                $env = new BerkeleyDB::Env
                         -Home         =&gt; "/home/databases"
                ...

                $db1 = new BerkeleyDB::Hash
                         -Filename = "fred.db",
                         -Env =&gt; $env
                ...

                $db2 = new BerkeleyDB::Hash
                         -Filename = "/other/joe.db",
                         -Env =&gt; $env
                ...

       -Server
            If present, this parameter should be the hostname of a server that is running the Berkeley DB
            RPC server. All databases will be accessed via the RPC server.

       -Encrypt
            If present, this parameter will enable encryption of  all data before it is written to the
            database. This parameters must be given a hash reference. The format is shown below.

                -Encrypt =&gt; { -Password =&gt; "abc", Flags =&gt; DB_ENCRYPT_AES }

            Valid values for the Flags are 0 or "DB_ENCRYPT_AES".

            This option requires Berkeley DB 4.1 or better.

       -Cachesize
            If present, this parameter sets the size of the environments shared memory buffer pool.

       -SharedMemKey
            If present, this parameter sets the base segment ID for the shared memory region used by
            Berkeley DB.

            This option requires Berkeley DB 3.1 or better.

            Use "$env-&gt;get_shm_key($id)" to find out the base segment ID used once the environment is open.

       -Config
            This is a variation on the "-Home" parameter, but it allows finer control of where specific
            types of files will be stored.

            The parameter expects a reference to a hash. Valid keys are: <b>DB_DATA_DIR</b>, <b>DB_LOG_DIR</b> and
            <b>DB_TMP_DIR</b>

            The code below shows an example of how it can be used.

                $env = new BerkeleyDB::Env
                         -Config =&gt; { DB_DATA_DIR =&gt; "/home/databases",
                                      DB_LOG_DIR  =&gt; "/home/logs",
                                      DB_TMP_DIR  =&gt; "/home/tmp"
                                    }
                ...

       -ErrFile
            Expects a filename or filenhandle. Any errors generated internally by Berkeley DB will be logged
            to this file. A useful debug setting is to open environments with either

                -ErrFile =&gt; *STDOUT

            or

                -ErrFile =&gt; *STDERR

       -ErrPrefix
            Allows a prefix to be added to the error messages before they are sent to <b>-ErrFile</b>.

       -Flags
            The <b>Flags</b> parameter specifies both which sub-systems to initialise, as well as a number of
            environment-wide options.  See the Berkeley DB documentation for more details of these options.

            Any of the following can be specified by OR'ing them:

            <b>DB_CREATE</b>

            If any of the files specified do not already exist, create them.

            <b>DB_INIT_CDB</b>

            Initialise the Concurrent Access Methods

            <b>DB_INIT_LOCK</b>

            Initialise the Locking sub-system.

            <b>DB_INIT_LOG</b>

            Initialise the Logging sub-system.

            <b>DB_INIT_MPOOL</b>

            Initialise the ...

            <b>DB_INIT_TXN</b>

            Initialise the ...

            <b>DB_MPOOL_PRIVATE</b>

            Initialise the ...

            <b>DB_INIT_MPOOL</b> is also specified.

            Initialise the ...

            <b>DB_NOMMAP</b>

            Initialise the ...

            <b>DB_RECOVER</b>

            <b>DB_RECOVER_FATAL</b>

            <b>DB_THREAD</b>

            <b>DB_TXN_NOSYNC</b>

            <b>DB_USE_ENVIRON</b>

            <b>DB_USE_ENVIRON_ROOT</b>

       -SetFlags
            Calls ENV-&gt;set_flags with the supplied bitmask. Use this when you need to make use of
            DB_ENV-&gt;set_flags before DB_ENV-&gt;open is called.

            Only valid when Berkeley DB 3.x or better is used.

       -LockDetect
            Specifies what to do when a lock conflict occurs. The value should be one of

            <b>DB_LOCK_DEFAULT</b>

            <b>DB_LOCK_OLDEST</b>

            <b>DB_LOCK_RANDOM</b>

            <b>DB_LOCK_YOUNGEST</b>

       -Verbose
            Add extra debugging information to the messages sent to <b>-ErrFile</b>.

       <b>Methods</b>

       The environment class has the following methods:

       $env-&gt;errPrefix("string") ;
            This method is identical to the <b>-ErrPrefix</b> flag. It allows the error prefix string to be changed
            dynamically.

       $env-&gt;set_flags(bitmask, 1|0);
       $txn = $env-&gt;<u>TxnMgr()</u>
            Constructor for creating a <b>TxnMgr</b> object.  See "TRANSACTIONS" for more details of using
            transactions.

            This method is deprecated. Access the transaction methods using the <b>txn_</b> methods below from the
            environment object directly.

       $env-&gt;<u>txn</u><b>_</b><u>begin()</u>
            TODO

       $env-&gt;<u>txn</u><b>_</b><u>stat()</u>
            TODO

       $env-&gt;<u>txn</u><b>_</b><u>checkpoint()</u>
            TODO

       $env-&gt;<u>status()</u>
            Returns the status of the last BerkeleyDB::Env method.

       $env-&gt;<u>DB</u><b>_</b><u>ENV()</u>
            Returns a pointer to the underlying DB_ENV data structure that Berkeley DB uses.

       $env-&gt;get_shm_key($id)
            Writes the base segment ID for the shared memory region used by the Berkeley DB environment into
            $id. Returns 0 on success.

            This option requires Berkeley DB 4.2 or better.

            Use the "-SharedMemKey" option when opening the environemt to set the base segment ID.

       $env-&gt;<u>status()</u>
            Returns the status of the last BerkeleyDB::Env method.

       <b>Examples</b>

       TODO.

<b>Global</b> <b>Classes</b>
         $status = BerkeleyDB::db_remove [OPTIONS]
         $status = BerkeleyDB::db_rename [OPTIONS]
         $status = BerkeleyDB::db_verify [OPTIONS]

<b>THE</b> <b>DATABASE</b> <b>CLASSES</b>
       <b>BerkeleyDB</b> supports the following database formats:

       <b>BerkeleyDB::Hash</b>
            This database type allows arbitrary key/value pairs to be stored in data files. This is
            equivalent to the functionality provided by other hashing packages like DBM, NDBM, ODBM, GDBM,
            and SDBM. Remember though, the files created using <b>BerkeleyDB::Hash</b> are not compatible with any
            of the other packages mentioned.

            A default hashing algorithm, which will be adequate for most applications, is built into
            BerkeleyDB. If you do need to use your own hashing algorithm it is possible to write your own in
            Perl and have <b>BerkeleyDB</b> use it instead.

       <b>BerkeleyDB::Btree</b>
            The Btree format allows arbitrary key/value pairs to be stored in a B+tree.

            As with the <b>BerkeleyDB::Hash</b> format, it is possible to provide a user defined Perl routine to
            perform the comparison of keys. By default, though, the keys are stored in lexical order.

       <b>BerkeleyDB::Recno</b>
            TODO.

       <b>BerkeleyDB::Queue</b>
            TODO.

       <b>BerkeleyDB::Unknown</b>
            This isn't a database format at all. It is used when you want to open an existing Berkeley DB
            database without having to know what type is it.

       Each of the database formats described above is accessed via a corresponding <b>BerkeleyDB</b> class. These
       will be described in turn in the next sections.

<b>BerkeleyDB::Hash</b>
       Equivalent to calling <b>db_open</b> with type <b>DB_HASH</b> in Berkeley DB 2.x and calling <b>db_create</b> followed by
       <b>DB-&gt;open</b> with type <b>DB_HASH</b> in Berkeley DB 3.x or greater.

       Two forms of constructor are supported:

           $db = new BerkeleyDB::Hash
                       [ -Filename      =&gt; "filename", ]
                       [ -Subname       =&gt; "sub-database name", ]
                       [ -Flags         =&gt; flags,]
                       [ -Property      =&gt; flags,]
                       [ -Mode          =&gt; number,]
                       [ -Cachesize     =&gt; number,]
                       [ -Lorder        =&gt; number,]
                       [ -Pagesize      =&gt; number,]
                       [ -Env           =&gt; $env,]
                       [ -Txn           =&gt; $txn,]
                       [ -Encrypt       =&gt; { Password =&gt; "string",
                                             Flags    =&gt; number }, ],
                       # BerkeleyDB::Hash specific
                       [ -Ffactor       =&gt; number,]
                       [ -Nelem         =&gt; number,]
                       [ -Hash          =&gt; code reference,]
                       [ -DupCompare    =&gt; code reference,]

       and this

           [$db =] tie %hash, 'BerkeleyDB::Hash',
                       [ -Filename      =&gt; "filename", ]
                       [ -Subname       =&gt; "sub-database name", ]
                       [ -Flags         =&gt; flags,]
                       [ -Property      =&gt; flags,]
                       [ -Mode          =&gt; number,]
                       [ -Cachesize     =&gt; number,]
                       [ -Lorder        =&gt; number,]
                       [ -Pagesize      =&gt; number,]
                       [ -Env           =&gt; $env,]
                       [ -Txn           =&gt; $txn,]
                       [ -Encrypt       =&gt; { Password =&gt; "string",
                                             Flags    =&gt; number }, ],
                       # BerkeleyDB::Hash specific
                       [ -Ffactor       =&gt; number,]
                       [ -Nelem         =&gt; number,]
                       [ -Hash          =&gt; code reference,]
                       [ -DupCompare    =&gt; code reference,]

       When the "tie" interface is used, reading from and writing to the database is achieved via the tied
       hash. In this case the database operates like a Perl associative array that happens to be stored on
       disk.

       In addition to the high-level tied hash interface, it is possible to make use of the underlying
       methods provided by Berkeley DB

       <b>Options</b>

       In addition to the standard set of options (see "COMMON OPTIONS") <b>BerkeleyDB::Hash</b> supports these
       options:

       -Property
            Used to specify extra flags when opening a database. The following flags may be specified by
            bitwise OR'ing together one or more of the following values:

            <b>DB_DUP</b>

            When creating a new database, this flag enables the storing of duplicate keys in the database.
            If <b>DB_DUPSORT</b> is not specified as well, the duplicates are stored in the order they are created
            in the database.

            <b>DB_DUPSORT</b>

            Enables the sorting of duplicate keys in the database. Ignored if <b>DB_DUP</b> isn't also specified.

       -Ffactor
       -Nelem
            See the Berkeley DB documentation for details of these options.

       -Hash
            Allows you to provide a user defined hash function. If not specified, a default hash function is
            used. Here is a template for a user-defined hash function

                sub hash
                {
                    my ($data) = shift ;
                    ...
                    # return the hash value for $data
                    return $hash ;
                }

                tie %h, "BerkeleyDB::Hash",
                    -Filename =&gt; $filename,
                    -Hash     =&gt; \&amp;hash,
                    ...

            See "" for an example.

       -DupCompare
            Used in conjunction with the <b>DB_DUPOSRT</b> flag.

                sub compare
                {
                    my ($key, $key2) = @_ ;
                    ...
                    # return  0 if $key1 eq $key2
                    #        -1 if $key1 lt $key2
                    #         1 if $key1 gt $key2
                    return (-1 , 0 or 1) ;
                }

                tie %h, "BerkeleyDB::Hash",
                    -Filename   =&gt; $filename,
                    -Property   =&gt; DB_DUP|DB_DUPSORT,
                    -DupCompare =&gt; \&amp;compare,
                    ...

       <b>Methods</b>

       <b>BerkeleyDB::Hash</b> only supports the standard database methods.  See "COMMON DATABASE METHODS".

       <b>A</b> <b>Simple</b> <b>Tied</b> <b>Hash</b> <b>Example</b>

           use strict ;
           use BerkeleyDB ;
           use vars qw( %h $k $v ) ;

           my $filename = "fruit" ;
           unlink $filename ;
           tie %h, "BerkeleyDB::Hash",
                       -Filename =&gt; $filename,
                       -Flags    =&gt; DB_CREATE
               or die "Cannot open file $filename: $! $BerkeleyDB::Error\n" ;

           # Add a few key/value pairs to the file
           $h{"apple"} = "red" ;
           $h{"orange"} = "orange" ;
           $h{"banana"} = "yellow" ;
           $h{"tomato"} = "red" ;

           # Check for existence of a key
           print "Banana Exists\n\n" if $h{"banana"} ;

           # Delete a key/value pair.
           delete $h{"apple"} ;

           # print the contents of the file
           while (($k, $v) = each %h)
             { print "$k -&gt; $v\n" }

           untie %h ;

       here is the output:

           Banana Exists

           orange -&gt; orange
           tomato -&gt; red
           banana -&gt; yellow

       Note that the like ordinary associative arrays, the order of the keys retrieved from a Hash database
       are in an apparently random order.

       <b>Another</b> <b>Simple</b> <b>Hash</b> <b>Example</b>

       Do the same as the previous example but not using tie.

           use strict ;
           use BerkeleyDB ;

           my $filename = "fruit" ;
           unlink $filename ;
           my $db = new BerkeleyDB::Hash
                       -Filename =&gt; $filename,
                       -Flags    =&gt; DB_CREATE
               or die "Cannot open file $filename: $! $BerkeleyDB::Error\n" ;

           # Add a few key/value pairs to the file
           $db-&gt;db_put("apple", "red") ;
           $db-&gt;db_put("orange", "orange") ;
           $db-&gt;db_put("banana", "yellow") ;
           $db-&gt;db_put("tomato", "red") ;

           # Check for existence of a key
           print "Banana Exists\n\n" if $db-&gt;db_get("banana", $v) == 0;

           # Delete a key/value pair.
           $db-&gt;db_del("apple") ;

           # print the contents of the file
           my ($k, $v) = ("", "") ;
           my $cursor = $db-&gt;db_cursor() ;
           while ($cursor-&gt;c_get($k, $v, DB_NEXT) == 0)
             { print "$k -&gt; $v\n" }

           undef $cursor ;
           undef $db ;

       <b>Duplicate</b> <b>keys</b>

       The code below is a variation on the examples above. This time the hash has been inverted. The key
       this time is colour and the value is the fruit name.  The <b>DB_DUP</b> flag has been specified to allow
       duplicates.

           use strict ;
           use BerkeleyDB ;

           my $filename = "fruit" ;
           unlink $filename ;
           my $db = new BerkeleyDB::Hash
                       -Filename =&gt; $filename,
                       -Flags    =&gt; DB_CREATE,
                       -Property  =&gt; DB_DUP
               or die "Cannot open file $filename: $! $BerkeleyDB::Error\n" ;

           # Add a few key/value pairs to the file
           $db-&gt;db_put("red", "apple") ;
           $db-&gt;db_put("orange", "orange") ;
           $db-&gt;db_put("green", "banana") ;
           $db-&gt;db_put("yellow", "banana") ;
           $db-&gt;db_put("red", "tomato") ;
           $db-&gt;db_put("green", "apple") ;

           # print the contents of the file
           my ($k, $v) = ("", "") ;
           my $cursor = $db-&gt;db_cursor() ;
           while ($cursor-&gt;c_get($k, $v, DB_NEXT) == 0)
             { print "$k -&gt; $v\n" }

           undef $cursor ;
           undef $db ;

       here is the output:

           orange -&gt; orange
           yellow -&gt; banana
           red -&gt; apple
           red -&gt; tomato
           green -&gt; banana
           green -&gt; apple

       <b>Sorting</b> <b>Duplicate</b> <b>Keys</b>

       In the previous example, when there were duplicate keys, the values are sorted in the order they are
       stored in. The code below is identical to the previous example except the <b>DB_DUPSORT</b> flag is
       specified.

           use strict ;
           use BerkeleyDB ;

           my $filename = "fruit" ;
           unlink $filename ;
           my $db = new BerkeleyDB::Hash
                       -Filename =&gt; $filename,
                       -Flags    =&gt; DB_CREATE,
                       -Property  =&gt; DB_DUP | DB_DUPSORT
               or die "Cannot open file $filename: $! $BerkeleyDB::Error\n" ;

           # Add a few key/value pairs to the file
           $db-&gt;db_put("red", "apple") ;
           $db-&gt;db_put("orange", "orange") ;
           $db-&gt;db_put("green", "banana") ;
           $db-&gt;db_put("yellow", "banana") ;
           $db-&gt;db_put("red", "tomato") ;
           $db-&gt;db_put("green", "apple") ;

           # print the contents of the file
           my ($k, $v) = ("", "") ;
           my $cursor = $db-&gt;db_cursor() ;
           while ($cursor-&gt;c_get($k, $v, DB_NEXT) == 0)
             { print "$k -&gt; $v\n" }

           undef $cursor ;
           undef $db ;

       Notice that in the output below the duplicate values are sorted.

           orange -&gt; orange
           yellow -&gt; banana
           red -&gt; apple
           red -&gt; tomato
           green -&gt; apple
           green -&gt; banana

       <b>Custom</b> <b>Sorting</b> <b>Duplicate</b> <b>Keys</b>

       Another variation

       TODO

       <b>Changing</b> <b>the</b> <b>hash</b>

       TODO

       <b>Using</b> <b>db_stat</b>

       TODO

<b>BerkeleyDB::Btree</b>
       Equivalent to calling <b>db_open</b> with type <b>DB_BTREE</b> in Berkeley DB 2.x and calling <b>db_create</b> followed by
       <b>DB-&gt;open</b> with type <b>DB_BTREE</b> in Berkeley DB 3.x or greater.

       Two forms of constructor are supported:

           $db = new BerkeleyDB::Btree
                       [ -Filename      =&gt; "filename", ]
                       [ -Subname       =&gt; "sub-database name", ]
                       [ -Flags         =&gt; flags,]
                       [ -Property      =&gt; flags,]
                       [ -Mode          =&gt; number,]
                       [ -Cachesize     =&gt; number,]
                       [ -Lorder        =&gt; number,]
                       [ -Pagesize      =&gt; number,]
                       [ -Env           =&gt; $env,]
                       [ -Txn           =&gt; $txn,]
                       [ -Encrypt       =&gt; { Password =&gt; "string",
                                             Flags    =&gt; number }, ],
                       # BerkeleyDB::Btree specific
                       [ -Minkey        =&gt; number,]
                       [ -Compare       =&gt; code reference,]
                       [ -DupCompare    =&gt; code reference,]
                       [ -Prefix        =&gt; code reference,]

       and this

           [$db =] tie %hash, 'BerkeleyDB::Btree',
                       [ -Filename      =&gt; "filename", ]
                       [ -Subname       =&gt; "sub-database name", ]
                       [ -Flags         =&gt; flags,]
                       [ -Property      =&gt; flags,]
                       [ -Mode          =&gt; number,]
                       [ -Cachesize     =&gt; number,]
                       [ -Lorder        =&gt; number,]
                       [ -Pagesize      =&gt; number,]
                       [ -Env           =&gt; $env,]
                       [ -Txn           =&gt; $txn,]
                       [ -Encrypt       =&gt; { Password =&gt; "string",
                                             Flags    =&gt; number }, ],
                       # BerkeleyDB::Btree specific
                       [ -Minkey        =&gt; number,]
                       [ -Compare       =&gt; code reference,]
                       [ -DupCompare    =&gt; code reference,]
                       [ -Prefix        =&gt; code reference,]

       <b>Options</b>

       In addition to the standard set of options (see "COMMON OPTIONS") <b>BerkeleyDB::Btree</b> supports these
       options:

       -Property
            Used to specify extra flags when opening a database. The following flags may be specified by
            bitwise OR'ing together one or more of the following values:

            <b>DB_DUP</b>

            When creating a new database, this flag enables the storing of duplicate keys in the database.
            If <b>DB_DUPSORT</b> is not specified as well, the duplicates are stored in the order they are created
            in the database.

            <b>DB_DUPSORT</b>

            Enables the sorting of duplicate keys in the database. Ignored if <b>DB_DUP</b> isn't also specified.

       Minkey
            TODO

       Compare
            Allow you to override the default sort order used in the database. See "Changing the sort order"
            for an example.

                sub compare
                {
                    my ($key, $key2) = @_ ;
                    ...
                    # return  0 if $key1 eq $key2
                    #        -1 if $key1 lt $key2
                    #         1 if $key1 gt $key2
                    return (-1 , 0 or 1) ;
                }

                tie %h, "BerkeleyDB::Hash",
                    -Filename   =&gt; $filename,
                    -Compare    =&gt; \&amp;compare,
                    ...

       Prefix
                sub prefix
                {
                    my ($key, $key2) = @_ ;
                    ...
                    # return number of bytes of $key2 which are
                    # necessary to determine that it is greater than $key1
                    return $bytes ;
                }

                tie %h, "BerkeleyDB::Hash",
                    -Filename   =&gt; $filename,
                    -Prefix     =&gt; \&amp;prefix,
                    ...
            =item DupCompare

                sub compare
                {
                    my ($key, $key2) = @_ ;
                    ...
                    # return  0 if $key1 eq $key2
                    #        -1 if $key1 lt $key2
                    #         1 if $key1 gt $key2
                    return (-1 , 0 or 1) ;
                }

                tie %h, "BerkeleyDB::Hash",
                    -Filename   =&gt; $filename,
                    -DupCompare =&gt; \&amp;compare,
                    ...

       <b>Methods</b>

       <b>BerkeleyDB::Btree</b> supports the following database methods.  See also "COMMON DATABASE METHODS".

       All the methods below return 0 to indicate success.

       $status = $db-&gt;db_key_range($key, $less, $equal, $greater [, $flags])
            Given a key, $key, this method returns the proportion of keys less than $key in $less, the
            proportion equal to $key in $equal and the proportion greater than $key in $greater.

            The proportion is returned as a double in the range 0.0 to 1.0.

       <b>A</b> <b>Simple</b> <b>Btree</b> <b>Example</b>

       The code below is a simple example of using a btree database.

           use strict ;
           use BerkeleyDB ;

           my $filename = "tree" ;
           unlink $filename ;
           my %h ;
           tie %h, 'BerkeleyDB::Btree',
                       -Filename   =&gt; $filename,
                       -Flags      =&gt; DB_CREATE
             or die "Cannot open $filename: $! $BerkeleyDB::Error\n" ;

           # Add a key/value pair to the file
           $h{'Wall'} = 'Larry' ;
           $h{'Smith'} = 'John' ;
           $h{'mouse'} = 'mickey' ;
           $h{'duck'}  = 'donald' ;

           # Delete
           delete $h{"duck"} ;

           # Cycle through the keys printing them in order.
           # Note it is not necessary to sort the keys as
           # the btree will have kept them in order automatically.
           foreach (keys %h)
             { print "$_\n" }

           untie %h ;

       Here is the output from the code above. The keys have been sorted using Berkeley DB's default sorting
       algorithm.

           Smith
           Wall
           mouse

       <b>Changing</b> <b>the</b> <b>sort</b> <b>order</b>

       It is possible to supply your own sorting algorithm if the one that Berkeley DB used isn't suitable.
       The code below is identical to the previous example except for the case insensitive compare function.

           use strict ;
           use BerkeleyDB ;

           my $filename = "tree" ;
           unlink $filename ;
           my %h ;
           tie %h, 'BerkeleyDB::Btree',
                       -Filename   =&gt; $filename,
                       -Flags      =&gt; DB_CREATE,
                       -Compare    =&gt; sub { lc $_[0] cmp lc $_[1] }
             or die "Cannot open $filename: $!\n" ;

           # Add a key/value pair to the file
           $h{'Wall'} = 'Larry' ;
           $h{'Smith'} = 'John' ;
           $h{'mouse'} = 'mickey' ;
           $h{'duck'}  = 'donald' ;

           # Delete
           delete $h{"duck"} ;

           # Cycle through the keys printing them in order.
           # Note it is not necessary to sort the keys as
           # the btree will have kept them in order automatically.
           foreach (keys %h)
             { print "$_\n" }

           untie %h ;

       Here is the output from the code above.

           mouse
           Smith
           Wall

       There are a few point to bear in mind if you want to change the ordering in a BTREE database:

       1.   The new compare function must be specified when you create the database.

       2.   You cannot change the ordering once the database has been created. Thus you must use the same
            compare function every time you access the database.

       <b>Using</b> <b>db_stat</b>

       TODO

<b>BerkeleyDB::Recno</b>
       Equivalent to calling <b>db_open</b> with type <b>DB_RECNO</b> in Berkeley DB 2.x and calling <b>db_create</b> followed by
       <b>DB-&gt;open</b> with type <b>DB_RECNO</b> in Berkeley DB 3.x or greater.

       Two forms of constructor are supported:

           $db = new BerkeleyDB::Recno
                       [ -Filename      =&gt; "filename", ]
                       [ -Subname       =&gt; "sub-database name", ]
                       [ -Flags         =&gt; flags,]
                       [ -Property      =&gt; flags,]
                       [ -Mode          =&gt; number,]
                       [ -Cachesize     =&gt; number,]
                       [ -Lorder        =&gt; number,]
                       [ -Pagesize      =&gt; number,]
                       [ -Env           =&gt; $env,]
                       [ -Txn           =&gt; $txn,]
                       [ -Encrypt       =&gt; { Password =&gt; "string",
                                             Flags    =&gt; number }, ],
                       # BerkeleyDB::Recno specific
                       [ -Delim           =&gt; byte,]
                       [ -Len             =&gt; number,]
                       [ -Pad             =&gt; byte,]
                       [ -Source          =&gt; filename,]

       and this

           [$db =] tie @arry, 'BerkeleyDB::Recno',
                       [ -Filename      =&gt; "filename", ]
                       [ -Subname       =&gt; "sub-database name", ]
                       [ -Flags         =&gt; flags,]
                       [ -Property      =&gt; flags,]
                       [ -Mode          =&gt; number,]
                       [ -Cachesize     =&gt; number,]
                       [ -Lorder        =&gt; number,]
                       [ -Pagesize      =&gt; number,]
                       [ -Env           =&gt; $env,]
                       [ -Txn           =&gt; $txn,]
                       [ -Encrypt       =&gt; { Password =&gt; "string",
                                             Flags    =&gt; number }, ],
                       # BerkeleyDB::Recno specific
                       [ -Delim           =&gt; byte,]
                       [ -Len             =&gt; number,]
                       [ -Pad             =&gt; byte,]
                       [ -Source          =&gt; filename,]

       <b>A</b> <b>Recno</b> <b>Example</b>

       Here is a simple example that uses RECNO (if you are using a version of Perl earlier than 5.004_57
       this example won't work -- see "Extra RECNO Methods" for a workaround).

           use strict ;
           use BerkeleyDB ;

           my $filename = "text" ;
           unlink $filename ;

           my @h ;
           tie @h, 'BerkeleyDB::Recno',
                       -Filename   =&gt; $filename,
                       -Flags      =&gt; DB_CREATE,
                       -Property   =&gt; DB_RENUMBER
             or die "Cannot open $filename: $!\n" ;

           # Add a few key/value pairs to the file
           $h[0] = "orange" ;
           $h[1] = "blue" ;
           $h[2] = "yellow" ;

           push @h, "green", "black" ;

           my $elements = scalar @h ;
           print "The array contains $elements entries\n" ;

           my $last = pop @h ;
           print "popped $last\n" ;

           unshift @h, "white" ;
           my $first = shift @h ;
           print "shifted $first\n" ;

           # Check for existence of a key
           print "Element 1 Exists with value $h[1]\n" if $h[1] ;

           untie @h ;

       Here is the output from the script:

           The array contains 5 entries
           popped black
           shifted white
           Element 1 Exists with value blue
           The last element is green
           The 2nd last element is yellow

<b>BerkeleyDB::Queue</b>
       Equivalent to calling <b>db_create</b> followed by <b>DB-&gt;open</b> with type <b>DB_QUEUE</b> in Berkeley DB 3.x or
       greater. This database format isn't available if you use Berkeley DB 2.x.

       Two forms of constructor are supported:

           $db = new BerkeleyDB::Queue
                       [ -Filename      =&gt; "filename", ]
                       [ -Subname       =&gt; "sub-database name", ]
                       [ -Flags         =&gt; flags,]
                       [ -Property      =&gt; flags,]
                       [ -Mode          =&gt; number,]
                       [ -Cachesize     =&gt; number,]
                       [ -Lorder        =&gt; number,]
                       [ -Pagesize      =&gt; number,]
                       [ -Env           =&gt; $env,]
                       [ -Txn           =&gt; $txn,]
                       [ -Encrypt       =&gt; { Password =&gt; "string",
                                             Flags    =&gt; number }, ],
                       # BerkeleyDB::Queue specific
                       [ -Len             =&gt; number,]
                       [ -Pad             =&gt; byte,]
                       [ -ExtentSize    =&gt; number, ]

       and this

           [$db =] tie @arry, 'BerkeleyDB::Queue',
                       [ -Filename      =&gt; "filename", ]
                       [ -Subname       =&gt; "sub-database name", ]
                       [ -Flags         =&gt; flags,]
                       [ -Property      =&gt; flags,]
                       [ -Mode          =&gt; number,]
                       [ -Cachesize     =&gt; number,]
                       [ -Lorder        =&gt; number,]
                       [ -Pagesize      =&gt; number,]
                       [ -Env           =&gt; $env,]
                       [ -Txn           =&gt; $txn,]
                       [ -Encrypt       =&gt; { Password =&gt; "string",
                                             Flags    =&gt; number }, ],
                       # BerkeleyDB::Queue specific
                       [ -Len             =&gt; number,]
                       [ -Pad             =&gt; byte,]

<b>BerkeleyDB::Unknown</b>
       This class is used to open an existing database.

       Equivalent to calling <b>db_open</b> with type <b>DB_UNKNOWN</b> in Berkeley DB 2.x and calling <b>db_create</b> followed
       by <b>DB-&gt;open</b> with type <b>DB_UNKNOWN</b> in Berkeley DB 3.x or greater.

       The constructor looks like this:

           $db = new BerkeleyDB::Unknown
                       [ -Filename      =&gt; "filename", ]
                       [ -Subname       =&gt; "sub-database name", ]
                       [ -Flags         =&gt; flags,]
                       [ -Property      =&gt; flags,]
                       [ -Mode          =&gt; number,]
                       [ -Cachesize     =&gt; number,]
                       [ -Lorder        =&gt; number,]
                       [ -Pagesize      =&gt; number,]
                       [ -Env           =&gt; $env,]
                       [ -Txn           =&gt; $txn,]
                       [ -Encrypt       =&gt; { Password =&gt; "string",
                                             Flags    =&gt; number }, ],

       <b>An</b> <b>example</b>


<b>COMMON</b> <b>OPTIONS</b>
       All database access class constructors support the common set of options defined below. All are
       optional.

       -Filename
            The database filename. If no filename is specified, a temporary file will be created and removed
            once the program terminates.

       -Subname
            Specifies the name of the sub-database to open.  This option is only valid if you are using
            Berkeley DB 3.x or greater.

       -Flags
            Specify how the database will be opened/created. The valid flags are:

            <b>DB_CREATE</b>

            Create any underlying files, as necessary. If the files do not already exist and the <b>DB_CREATE</b>
            flag is not specified, the call will fail.

            <b>DB_NOMMAP</b>

            Not supported by BerkeleyDB.

            <b>DB_RDONLY</b>

            Opens the database in read-only mode.

            <b>DB_THREAD</b>

            Not supported by BerkeleyDB.

            <b>DB_TRUNCATE</b>

            If the database file already exists, remove all the data before opening it.

       -Mode
            Determines the file protection when the database is created. Defaults to 0666.

       -Cachesize
       -Lorder
       -Pagesize
       -Env When working under a Berkeley DB environment, this parameter

            Defaults to no environment.

       -Encrypt
            If present, this parameter will enable encryption of  all data before it is written to the
            database. This parameters must be given a hash reference. The format is shown below.

                -Encrypt =&gt; { -Password =&gt; "abc", Flags =&gt; DB_ENCRYPT_AES }

            Valid values for the Flags are 0 or "DB_ENCRYPT_AES".

            This option requires Berkeley DB 4.1 or better.

       -Txn TODO.

<b>COMMON</b> <b>DATABASE</b> <b>METHODS</b>
       All the database interfaces support the common set of methods defined below.

       All the methods below return 0 to indicate success.

       <b>$status</b> = $db-&gt;db_get($key, $value [, $flags])

       Given a key ($key) this method reads the value associated with it from the database. If it exists,
       the value read from the database is returned in the $value parameter.

       The <b>$flags</b> parameter is optional. If present, it must be set to <b>one</b> of the following values:

       <b>DB_GET_BOTH</b>
            When the <b>DB_GET_BOTH</b> flag is specified, <b>db_get</b> checks for the existence of <b>both</b> the $key <b>and</b>
            $value in the database.

       <b>DB_SET_RECNO</b>
            TODO.

       In addition, the following value may be set by bitwise OR'ing it into the <b>$flags</b> parameter:

       <b>DB_RMW</b>
            TODO

       <b>$status</b> = $db-&gt;db_put($key, $value [, $flags])

       Stores a key/value pair in the database.

       The <b>$flags</b> parameter is optional. If present it must be set to <b>one</b> of the following values:

       <b>DB_APPEND</b>
            This flag is only applicable when accessing a <b>BerkeleyDB::Recno</b> database.

            TODO.

       <b>DB_NOOVERWRITE</b>
            If this flag is specified and $key already exists in the database, the call to <b>db_put</b> will
            return <b>DB_KEYEXIST</b>.

       <b>$status</b> = $db-&gt;db_del($key [, $flags])

       Deletes a key/value pair in the database associated with $key.  If duplicate keys are enabled in the
       database, <b>db_del</b> will delete <b>all</b> key/value pairs with key $key.

       The <b>$flags</b> parameter is optional and is currently unused.

       <b>$status</b> = $db-&gt;<u>db</u><b>_</b><u>sync()</u>

       If any parts of the database are in memory, write them to the database.

       <b>$cursor</b> = $db-&gt;db_cursor([$flags])

       Creates a cursor object. This is used to access the contents of the database sequentially. See
       CURSORS for details of the methods available when working with cursors.

       The <b>$flags</b> parameter is optional. If present it must be set to <b>one</b> of the following values:

       <b>DB_RMW</b>
            TODO.

       <b>($flag,</b> <b>$old_offset</b>, $old_length) = $db-&gt;partial_set($offset, $length) ;

       TODO

       <b>($flag,</b> <b>$old_offset</b>, $old_length) = $db-&gt;<u>partial</u><b>_</b><u>clear()</u> <u>;</u>

       TODO

       <b>$db</b>-&gt;<u>byteswapped()</u>

       TODO

       <b>$db</b>-&gt;<u>type()</u>

       Returns the type of the database. The possible return code are <b>DB_HASH</b> for a <b>BerkeleyDB::Hash</b>
       database, <b>DB_BTREE</b> for a <b>BerkeleyDB::Btree</b> database and <b>DB_RECNO</b> for a <b>BerkeleyDB::Recno</b> database.
       This method is typically used when a database has been opened with <b>BerkeleyDB::Unknown</b>.

       <b>$bool</b> = $env-&gt;<u>cds</u><b>_</b><u>enabled();</u>

       Returns true if the Berkeley DB environment $env has been opened on CDS mode.

       <b>$bool</b> = $db-&gt;<u>cds</u><b>_</b><u>enabled();</u>

       Returns true if the database $db has been opened on CDS mode.

       <b>$lock</b> = $db-&gt;<u>cds</u><b>_</b><u>lock();</u>

       Creates a CDS write lock object $lock.

       It is a fatal error to attempt to create a cds_lock if the Berkeley DB environment has not been
       opened in CDS mode.

       <b>$lock</b>-&gt;<u>cds</u><b>_</b><u>unlock();</u>

       Removes a CDS lock. The destruction of the CDS lock object automatically calls this method.

       Note that if multiple CDS lock objects are created, the underlying write lock will not be released
       until all CDS lock objects are either explictly unlocked with this method, or the CDS lock objects
       have been destroyed.

       <b>$ref</b> = $db-&gt;<u>db</u><b>_</b><u>stat()</u>

       Returns a reference to an associative array containing information about the database. The keys of
       the associative array correspond directly to the names of the fields defined in the Berkeley DB
       documentation. For example, in the DB documentation, the field <b>bt_version</b> stores the version of the
       Btree database. Assuming you called <b>db_stat</b> on a Btree database the equivalent field would be
       accessed as follows:

           $version = $ref-&gt;{'bt_version'} ;

       If you are using Berkeley DB 3.x or better, this method will work will all database formats. When DB
       2.x is used, it only works with <b>BerkeleyDB::Btree</b>.

       <b>$status</b> = $db-&gt;<u>status()</u>

       Returns the status of the last $db method called.

       <b>$status</b> = $db-&gt;truncate($count)

       Truncates the datatabase and returns the number or records deleted in $count.

       <b>$status</b> = $db-&gt;compact($start, $stop, $c_data, $flags, $end);

       Compacts the database $db.

       All the parameters are optional - if only want to make use of some of them, use "undef" for those you
       don't want.  Trailing unusused parameters can be omitted. For example, if you only want to use the
       $c_data parameter to set the "compact_fillpercent", write you code like this

           my %hash;
           $hash{compact_fillpercent} = 50;
           $db-&gt;commit(undef, undef, \%hash);

       The parameters operate identically to the C equivalent of this method.  The $c_data needs a bit of
       explanation - it must be a hash reference.  The values of the following keys can be set before
       calling "compact" and will affect the operation of the compaction.

       The following keys, along with associated values, will be created in the hash reference if the
       "compact" operation was successful.

           compact_deadlock =item * compact_levels =item * compact_pages_free =item * compact_pages_examine
            =item * compact_pages_truncated

       You need to be running Berkeley DB 4.4 or better if you wan to make use of "compact".

<b>CURSORS</b>
       A cursor is used whenever you want to access the contents of a database in sequential order.  A
       cursor object is created with the "db_cursor"

       A cursor object has the following methods available:

       <b>$newcursor</b> = $cursor-&gt;c_dup($flags)

       Creates a duplicate of $cursor. This method needs Berkeley DB 3.0.x or better.

       The $flags parameter is optional and can take the following value:

       DB_POSITION
            When present this flag will position the new cursor at the same place as the existing cursor.

       <b>$status</b> = $cursor-&gt;c_get($key, $value, $flags)

       Reads a key/value pair from the database, returning the data in $key and $value. The key/value pair
       actually read is controlled by the $flags parameter, which can take <b>one</b> of the following values:

       <b>DB_FIRST</b>
            Set the cursor to point to the first key/value pair in the database. Return the key/value pair
            in $key and $value.

       <b>DB_LAST</b>
            Set the cursor to point to the last key/value pair in the database. Return the key/value pair in
            $key and $value.

       <b>DB_NEXT</b>
            If the cursor is already pointing to a key/value pair, it will be incremented to point to the
            next key/value pair and return its contents.

            If the cursor isn't initialised, <b>DB_NEXT</b> works just like <b>DB_FIRST</b>.

            If the cursor is already positioned at the last key/value pair, <b>c_get</b> will return <b>DB_NOTFOUND</b>.

       <b>DB_NEXT_DUP</b>
            This flag is only valid when duplicate keys have been enabled in a database.  If the cursor is
            already pointing to a key/value pair and the key of the next key/value pair is identical, the
            cursor will be incremented to point to it and their contents returned.

       <b>DB_PREV</b>
            If the cursor is already pointing to a key/value pair, it will be decremented to point to the
            previous key/value pair and return its contents.

            If the cursor isn't initialised, <b>DB_PREV</b> works just like <b>DB_LAST</b>.

            If the cursor is already positioned at the first key/value pair, <b>c_get</b> will return <b>DB_NOTFOUND</b>.

       <b>DB_CURRENT</b>
            If the cursor has been set to point to a key/value pair, return their contents.  If the
            key/value pair referenced by the cursor has been deleted, <b>c_get</b> will return <b>DB_KEYEMPTY</b>.

       <b>DB_SET</b>
            Set the cursor to point to the key/value pair referenced by <b>$key</b> and return the value in <b>$value</b>.

       <b>DB_SET_RANGE</b>
            This flag is a variation on the <b>DB_SET</b> flag. As well as returning the value, it also returns the
            key, via <b>$key</b>.  When used with a <b>BerkeleyDB::Btree</b> database the key matched by <b>c_get</b> will be the
            shortest key (in length) which is greater than or equal to the key supplied, via <b>$key</b>. This
            allows partial key searches.  See ??? for an example of how to use this flag.

       <b>DB_GET_BOTH</b>
            Another variation on <b>DB_SET</b>. This one returns both the key and the value.

       <b>DB_SET_RECNO</b>
            TODO.

       <b>DB_GET_RECNO</b>
            TODO.

       In addition, the following value may be set by bitwise OR'ing it into the <b>$flags</b> parameter:

       <b>DB_RMW</b>
            TODO.

       <b>$status</b> = $cursor-&gt;c_put($key, $value, $flags)

       Stores the key/value pair in the database. The position that the data is stored in the database is
       controlled by the $flags parameter, which must take <b>one</b> of the following values:

       <b>DB_AFTER</b>
            When used with a Btree or Hash database, a duplicate of the key referenced by the current cursor
            position will be created and the contents of <b>$value</b> will be associated with it - <b>$key</b> is
            ignored.  The new key/value pair will be stored immediately after the current cursor position.
            Obviously the database has to have been opened with <b>DB_DUP</b>.

            When used with a Recno ... TODO

       <b>DB_BEFORE</b>
            When used with a Btree or Hash database, a duplicate of the key referenced by the current cursor
            position will be created and the contents of <b>$value</b> will be associated with it - <b>$key</b> is
            ignored.  The new key/value pair will be stored immediately before the current cursor position.
            Obviously the database has to have been opened with <b>DB_DUP</b>.

            When used with a Recno ... TODO

       <b>DB_CURRENT</b>
            If the cursor has been initialised, replace the value of the key/value pair stored in the
            database with the contents of <b>$value</b>.

       <b>DB_KEYFIRST</b>
            Only valid with a Btree or Hash database. This flag is only really used when duplicates are
            enabled in the database and sorted duplicates haven't been specified.  In this case the
            key/value pair will be inserted as the first entry in the duplicates for the particular key.

       <b>DB_KEYLAST</b>
            Only valid with a Btree or Hash database. This flag is only really used when duplicates are
            enabled in the database and sorted duplicates haven't been specified.  In this case the
            key/value pair will be inserted as the last entry in the duplicates for the particular key.

       <b>$status</b> = $cursor-&gt;c_del([$flags])

       This method deletes the key/value pair associated with the current cursor position. The cursor
       position will not be changed by this operation, so any subsequent cursor operation must first
       initialise the cursor to point to a valid key/value pair.

       If the key/value pair associated with the cursor have already been deleted, <b>c_del</b> will return
       <b>DB_KEYEMPTY</b>.

       The <b>$flags</b> parameter is not used at present.

       <b>$status</b> = $cursor-&gt;c_count($cnt [, $flags])

       Stores the number of duplicates at the current cursor position in <b>$cnt</b>.

       The <b>$flags</b> parameter is not used at present. This method needs Berkeley DB 3.1 or better.

       <b>$status</b> = $cursor-&gt;<u>status()</u>

       Returns the status of the last cursor method as a dual type.

       <b>$status</b> = $cursor-&gt;<u>c</u><b>_</b><u>pget()</u> <u>;</u>

       TODO

       <b>$status</b> = $cursor-&gt;<u>c</u><b>_</b><u>close()</u>

       Closes the cursor <b>$cursor</b>.

       <b>Cursor</b> <b>Examples</b>

       TODO

       Iterating from first to last, then in reverse.

       examples of each of the flags.

<b>JOIN</b>
       Join support for BerkeleyDB is in progress. Watch this space.

       TODO

<b>TRANSACTIONS</b>
       TODO.

<b>CDS</b> <b>Mode</b>
       The Berkeley Db Concurrent Data Store is a lightweight locking mechanism that is useful in scenarios
       where transactions are overkill. See the accompanying document .. for details of using this module in
       CDS mode.

<b>DBM</b> <b>Filters</b>
       A DBM Filter is a piece of code that is be used when you <u>always</u> want to make the same transformation
       to all keys and/or values in a DBM database. All of the database classes (BerkeleyDB::Hash,
       BerkeleyDB::Btree and BerkeleyDB::Recno) support DBM Filters.

       There are four methods associated with DBM Filters. All work identically, and each is used to install
       (or uninstall) a single DBM Filter. Each expects a single parameter, namely a reference to a sub.
       The only difference between them is the place that the filter is installed.

       To summarise:

       <b>filter_store_key</b>
            If a filter has been installed with this method, it will be invoked every time you write a key
            to a DBM database.

       <b>filter_store_value</b>
            If a filter has been installed with this method, it will be invoked every time you write a value
            to a DBM database.

       <b>filter_fetch_key</b>
            If a filter has been installed with this method, it will be invoked every time you read a key
            from a DBM database.

       <b>filter_fetch_value</b>
            If a filter has been installed with this method, it will be invoked every time you read a value
            from a DBM database.

       You can use any combination of the methods, from none, to all four.

       All filter methods return the existing filter, if present, or "undef" in not.

       To delete a filter pass "undef" to it.

       <b>The</b> <b>Filter</b>

       When each filter is called by Perl, a local copy of $_ will contain the key or value to be filtered.
       Filtering is achieved by modifying the contents of $_. The return code from the filter is ignored.

       <b>An</b> <b>Example</b> <b>--</b> <b>the</b> <b>NULL</b> <b>termination</b> <b>problem.</b>

       Consider the following scenario. You have a DBM database that you need to share with a third-party C
       application. The C application assumes that <u>all</u> keys and values are NULL terminated. Unfortunately
       when Perl writes to DBM databases it doesn't use NULL termination, so your Perl application will have
       to manage NULL termination itself. When you write to the database you will have to use something like
       this:

           $hash{"$key\0"} = "$value\0" ;

       Similarly the NULL needs to be taken into account when you are considering the length of existing
       keys/values.

       It would be much better if you could ignore the NULL terminations issue in the main application code
       and have a mechanism that automatically added the terminating NULL to all keys and values whenever
       you write to the database and have them removed when you read from the database. As I'm sure you have
       already guessed, this is a problem that DBM Filters can fix very easily.

           use strict ;
           use BerkeleyDB ;

           my %hash ;
           my $filename = "filt.db" ;
           unlink $filename ;

           my $db = tie %hash, 'BerkeleyDB::Hash',
                       -Filename   =&gt; $filename,
                       -Flags      =&gt; DB_CREATE
             or die "Cannot open $filename: $!\n" ;

           # Install DBM Filters
           $db-&gt;filter_fetch_key  ( sub { s/\0$//    } ) ;
           $db-&gt;filter_store_key  ( sub { $_ .= "\0" } ) ;
           $db-&gt;filter_fetch_value( sub { s/\0$//    } ) ;
           $db-&gt;filter_store_value( sub { $_ .= "\0" } ) ;

           $hash{"abc"} = "def" ;
           my $a = $hash{"ABC"} ;
           # ...
           undef $db ;
           untie %hash ;

       Hopefully the contents of each of the filters should be self-explanatory. Both "fetch" filters remove
       the terminating NULL, and both "store" filters add a terminating NULL.

       <b>Another</b> <b>Example</b> <b>--</b> <b>Key</b> <b>is</b> <b>a</b> <b>C</b> <b>int.</b>

       Here is another real-life example. By default, whenever Perl writes to a DBM database it always
       writes the key and value as strings. So when you use this:

           $hash{12345} = "something" ;

       the key 12345 will get stored in the DBM database as the 5 byte string "12345". If you actually want
       the key to be stored in the DBM database as a C int, you will have to use "pack" when writing, and
       "unpack" when reading.

       Here is a DBM Filter that does it:

           use strict ;
           use BerkeleyDB ;
           my %hash ;
           my $filename = "filt.db" ;
           unlink $filename ;


           my $db = tie %hash, 'BerkeleyDB::Btree',
                       -Filename   =&gt; $filename,
                       -Flags      =&gt; DB_CREATE
             or die "Cannot open $filename: $!\n" ;

           $db-&gt;filter_fetch_key  ( sub { $_ = unpack("i", $_) } ) ;
           $db-&gt;filter_store_key  ( sub { $_ = pack ("i", $_) } ) ;
           $hash{123} = "def" ;
           # ...
           undef $db ;
           untie %hash ;

       This time only two filters have been used -- we only need to manipulate the contents of the key, so
       it wasn't necessary to install any value filters.

<b>Using</b> <b>BerkeleyDB</b> <b>with</b> <b>MLDBM</b>
       Both BerkeleyDB::Hash and BerkeleyDB::Btree can be used with the MLDBM module. The code fragment
       below shows how to open associate MLDBM with BerkeleyDB::Btree. To use BerkeleyDB::Hash just replace
       BerkeleyDB::Btree with BerkeleyDB::Hash.

           use strict ;
           use BerkeleyDB ;
           use MLDBM qw(BerkeleyDB::Btree) ;
           use Data::Dumper;

           my $filename = 'testmldbm' ;
           my %o ;

           unlink $filename ;
           tie %o, 'MLDBM', -Filename =&gt; $filename,
                            -Flags    =&gt; DB_CREATE
                           or die "Cannot open database '$filename: $!\n";

       See the MLDBM documentation for information on how to use the module and for details of its
       limitations.

<b>EXAMPLES</b>
       TODO.

<b>HINTS</b> <b>&amp;</b> <b>TIPS</b>
       <b>Sharing</b> <b>Databases</b> <b>With</b> <b>C</b> <b>Applications</b>

       There is no technical reason why a Berkeley DB database cannot be shared by both a Perl and a C
       application.

       The vast majority of problems that are reported in this area boil down to the fact that C strings are
       NULL terminated, whilst Perl strings are not. See "An Example -- the NULL termination problem." in
       the DBM FILTERS section for a generic way to work around this problem.

       <b>The</b> <b>untie</b> <b>Gotcha</b>

       TODO

<b>COMMON</b> <b>QUESTIONS</b>
       This section attempts to answer some of the more common questions that I get asked.

       <b>Relationship</b> <b>with</b> <b>DB_File</b>

       Before Berkeley DB 2.x was written there was only one Perl module that interfaced to Berkeley DB.
       That module is called <b>DB_File</b>. Although <b>DB_File</b> can be build with Berkeley DB 1.x, 2.x, 3.x or 4.x,
       it only provides an interface to the functionality available in Berkeley DB 1.x. That means that it
       doesn't support transactions, locking or any of the other new features available in DB 2.x or better.

       <b>How</b> <b>do</b> <b>I</b> <b>store</b> <b>Perl</b> <b>data</b> <b>structures</b> <b>with</b> <b>BerkeleyDB?</b>

       See "Using BerkeleyDB with MLDBM".

<b>HISTORY</b>
       See the Changes file.

<b>AVAILABILITY</b>
       The most recent version of <b>BerkeleyDB</b> can always be found on CPAN (see "CPAN" in perlmod for
       details), in the directory <u>modules/by-module/BerkeleyDB</u>.

       The official web site for Berkeley DB is <a href="http://www.sleepycat.com"><u>http://www.sleepycat.com</u></a>

<b>COPYRIGHT</b>
       Copyright (c) 1997-2004 Paul Marquess. All rights reserved. This program is free software; you can
       redistribute it and/or modify it under the same terms as Perl itself.

       Although <b>BerkeleyDB</b> is covered by the Perl license, the library it makes use of, namely Berkeley DB,
       is not. Berkeley DB has its own copyright and its own license. Please take the time to read it.

       Here are few words taken from the Berkeley DB FAQ (at <a href="http://www.sleepycat.com)"><u>http://www.sleepycat.com</u>)</u></a><u> regarding the
       license:

           Do I have to license DB to use it in Perl scripts?

           No. The Berkeley DB license requires that software that uses
           Berkeley DB be freely redistributable. In the case of Perl, that
           software is Perl, and not your scripts. Any Perl scripts that you
           write are your property, including scripts that make use of Berkeley
           DB. Neither the Perl license nor the Berkeley DB license
           place any restriction on what you may do with them.

       If you are in any doubt about the license situation, contact either the Berkeley DB authors or the
       author of BerkeleyDB.  See "AUTHOR" for details.

<b>AUTHOR</b>
       Paul Marquess &lt;pmqs@cpan.org&gt;.

       Questions about Berkeley DB may be addressed to &lt;db@sleepycat.com&gt;.

<b>SEE</b> <b>ALSO</b>
       <a href="../man1/perl.1.html#//apple_ref/doc/man/1/perl"><u>perl</u>(1)</a>, DB_File, Berkeley DB.



perl v5.8.8                                      2006-07-02                                    BerkeleyDB(3)
</tt></pre>
</td></tr></table>
	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Darwin/Reference/ManPages/man3/BerkeleyDB.3pm.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Darwin/Reference/ManPages/man3/BerkeleyDB.3pm.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Darwin/Reference/ManPages/man3/BerkeleyDB.3pm.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

</body></html>
