<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>Device File Access Guide for Serial Devices: Working With a Serial Device</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Working With a Serial Device"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP30000384" title="Working With a Serial Device"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../../HardwareDrivers/index.html#//apple_ref/doc/uid/TP30000440-TP40003576" target="_top">Hardware &amp; Drivers</a> &gt; <a href="../../../../HardwareDrivers/Serial-date.html#//apple_ref/doc/uid/TP30000440-TP40003576-TP30001045" target="_top">Serial</a> &gt; <a href="../WWSerial_Intro/WWSerial_Intro.html#//apple_ref/doc/uid/TP40002730-BABGJCGG">Device File Access Guide for Serial Devices</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../WWSerial_Intro/WWSerial_Intro.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../WWSerial_RevHistory/WWSerial_RevHistory.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP30000384-BAJDAJDJ" title="Working With a Serial Device"></a><h1>Working With a Serial Device</h1><p>This chapter provides sample code that demonstrates how to use the device-file mechanism to find and communicate with a serial device that explicitly claims to be a modem<a name="//apple_ref/doc/uid/TP30000384-DontLinkElementID_3"></a>, such as a built-in or USB modem. Because there is no safe, programmatic way to determine if a device attached to a serial port is indeed a modem, the sample code in this chapter does not find modems on the other side of a serial port.</p><p>The code snippets in this chapter are from the sample application <code>SerialPortSample</code>, available in its entirety at <span class="content_text"><a href="../../../../../samplecode/SerialPortSample/index.html" target="_top">http://developer.apple.com/samplecode/SerialPortSample</a></span>.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP30000384-SW1" title="Note"></a><p><strong>Note:</strong>&nbsp;If you choose to develop a Cocoa application that accesses a serial modem, be aware that Objective-C does not provide interfaces for I/O Kit or POSIX functions. However, because the I/O Kit and POSIX APIs are C APIs, you can call them from a Cocoa application.</p></div><p>Although the sample code in this chapter has been compiled and tested to some degree, Apple does not recommend that you directly incorporate this code into a commercial application. For example, only limited error handling is shown—you should develop your own techniques for detecting and handling errors.</p><div class="importantbox"><a name="//apple_ref/doc/uid/TP30000384-DontLinkElementID_2" title="Important:"></a><p><strong>Important:</strong>&nbsp;The sample code in this chapter is written to run in Mac OS X v10.0 or later.</p><p></p></div>
<!-- This template is being used for both PDF and HTML. -->

    
    <h4>In this section:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="SerialDevices.html#//apple_ref/doc/uid/TP30000384-SW2">Serial Device Access in an Intel-Based Macintosh</a>
				
			<br/>
			
        
			
			
				<a href="SerialDevices.html#//apple_ref/doc/uid/TP30000384-TPXREF119">Accessing a Serial Device</a>
				
			<br/>
			
        
			
			
				<a href="SerialDevices.html#//apple_ref/doc/uid/TP30000384-BABDBDDE">Including Header Files and Defining Macros and Constants</a>
				
			<br/>
			
        
			
			
				<a href="SerialDevices.html#//apple_ref/doc/uid/TP30000384-CIHJJIFA">Setting Up a Main Function</a>
				
			<br/>
			
        
			
			
				<a href="SerialDevices.html#//apple_ref/doc/uid/TP30000384-CIHEFFEF">Finding All Modems</a>
				
			<br/>
			
        
			
			
				<a href="SerialDevices.html#//apple_ref/doc/uid/TP30000384-CIHGEAFD">Getting the Path to the Device File for a Modem</a>
				
			<br/>
			
        
			
			
				<a href="SerialDevices.html#//apple_ref/doc/uid/TP30000384-CIHIAAFF">Opening the Serial Port</a>
				
			<br/>
			
        
			
			
				<a href="SerialDevices.html#//apple_ref/doc/uid/TP30000384-CIHHIIGA">Communicating With the Modem</a>
				
			<br/>
			
        
			
			
				<a href="SerialDevices.html#//apple_ref/doc/uid/TP30000384-CIHBIBBF">Closing the Serial Port</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP30000384-SW2" title="Serial Device Access in an Intel-Based Macintosh"></a><h2>Serial Device Access in an Intel-Based Macintosh</h2><p>This section briefly outlines some of the issues related to developing a universal binary version of a Mac OS X application that uses device files to access a serial device. Before you read this section, be sure to read <em><a href="../../../../MacOSX/Conceptual/universal_binary/index.html#//apple_ref/doc/uid/TP40002217" target="_top">Universal Binary Programming Guidelines, Second Edition</a></em>.  That document covers architectural differences and byte-ordering formats and provides comprehensive guidelines for code modification and building universal binaries. The guidelines in that document apply to all types of applications, including those that access hardware.</p><p>Before you build your application as a universal binary, make sure that:</p><ul class="ul"><li class="li"><p>You port your project to GCC 4 (Xcode uses GCC 4 to target Intel-based Macintosh computers)</p></li><li class="li"><p>You install the Mac OS X v10.4 universal SDK</p></li><li class="li"><p>You develop your project in Xcode 2.1 or later</p></li></ul><p>If your application uses the POSIX API in a standard manner, you should have no trouble developing a universal binary version of your application. As with any device-access application, however, if you read multibyte integer data (instead of or in addition to character streams) you need to be aware of potential differences in endian format.</p><p>If you determine that byte swapping is necessary, keep the following guidelines in mind: </p><ul class="ul"><li class="li"><p>Avoid unconditional byte-swapping code that always swaps from one endian format to the other. Instead, use the conditional byte-swapping macros defined in <code>libkern/OSByteOrder.h</code>. Even though this header file is in the Kernel framework, the macros are available to applications. Using these macros means the compiler optimizes your code so the routines are executed only if they are necessary for the architecture in which your application is running.</p></li><li class="li"><p>Be consistent about when you swap bytes. You might choose to perform the appropriate byte swap on the data after it's read into a buffer and perform the opposite byte swap on the data that is ready to be written out to the device. Or, you might choose to perform all byte swapping on the data as it's being read into or written out from the buffer. The first option means the data in the buffer is in the correct endian format for the device and the second option means the data in the buffer is in the correct endian format for the architecture in which your application is running. Whichever alternative you choose, implement it consistently throughout your application.</p></li></ul><a name="//apple_ref/doc/uid/TP30000384-TPXREF119" title="Accessing a Serial Device"></a><h2>Accessing a Serial Device</h2><p>To communicate with a serial device from your Mac OS X application, use I/O Kit functions to obtain a path to the device file for that device. Then, implement traditional UNIX serial port access using the POSIX <code>termios</code> API. Your application can read and write data using the device file.</p><p><a name="//apple_ref/doc/uid/TP30000384-DontLinkElementID_4"></a>Specifically, the sample code in this chapter demonstrates how to:</p><ul class="ul"><li class="li"><p>Find all serial devices that claim to be modems</p></li><li class="li"><p>Obtain the path to the device file of the first modem found</p></li><li class="li"><p>Use the POSIX API to initialize the modem and communicate with it through the device file</p></li></ul><p>The sample code shown in this chapter is from an Xcode “CoreFoundation Tool” project. The project builds a tool that has no user interface and sends its output to the console. You can view the output either by running the tool within Xcode or by running the Console utility, which you can find at <code>/Applications/Utilities/Console</code>. You can, of course, write similar code without these restrictions. For detailed documentation on using Xcode, see <span class="content_text"><a href="../../../../../referencelibrary/DeveloperTools/index.html" target="_top">http://developer.apple.com/referencelibrary/DeveloperTools/index.html</a></span>.</p><p>Many functions, data types, and constants used in the sample code in this chapter are defined in header files in <code>Kernel.framework</code>, <code>System.framework</code>, or in the directory <code>/usr/include</code> (whose contents you can examine using the Terminal application, located in <code>/Applications/Utilities/Terminal</code>). Specific header files are noted where appropriate. Some functions and data types, such as those for working with the <code><a href="../../../../CoreFoundation/Reference/CFStringRef/Reference/reference.html#//apple_ref/c/tdef/CFStringRef" target="_top">CFStringRef</a></code> type, are defined in header files in <code>CoreFoundation.framework</code>.</p><p>Some functions and data types used in this chapter are described in UNIX man pages. To view the reference documentation for these, see <em><a href="../../../../Darwin/Reference/ManPages/index.html#//apple_ref/doc/uid/TP40000894" target="_top">Mac OS X Man Pages</a></em>. Alternatively, you can view the documentation by typing <code>man</code><em>function_name</em> (for example, <code>man tcsetattr</code>) in a Terminal window. Many of the code snippets in this chapter refer to specific man pages in the code comments.</p><a name="//apple_ref/doc/uid/TP30000384-BABDBDDE" title="Including Header Files and Defining Macros and Constants"></a><h2>Including Header Files and Defining Macros and Constants</h2><p><span class="content_text">Listing 1-1</span> shows the header files you’ll need to include in your main file for the sample code in this chapter. (Some of these headers include others; a shorter list is possible.) Except for <code>CoreFoundation.h</code>, these headers are generally part of <code>IOKit.framework</code> or <code>Kernel.framework</code></p><a name="//apple_ref/doc/uid/TP30000384-TPXREF111" title="Listing 1-1Header files to include for the serial port modem sample code"></a><p class="codesample"><strong>Listing 1-1&nbsp;&nbsp;</strong>Header files to include for the serial port modem sample code</p><div class="codesample"><table><tr><td scope="row"><pre>#include &lt;stdio.h><span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;string.h><span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;unistd.h><span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;fcntl.h><span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;sys/ioctl.h><span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;errno.h><span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;paths.h><span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;termios.h><span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;sysexits.h><span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;sys/param.h><span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;sys/select.h><span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;sys/time.h><span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;time.h><span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;CoreFoundation/CoreFoundation.h><span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;IOKit/IOKitLib.h><span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;IOKit/serial/IOSerialKeys.h><span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;IOKit/IOBSD.h><span></span></pre></td></tr></table></div><p>By default, Apple internal modems define<code> local echo</code> to be “on”. If you’re using the sample code in this chapter to find and communicate with another type of modem, you should undefine the macro shown in <span class="content_text">Listing 1-2</span>.</p><a name="//apple_ref/doc/uid/TP30000384-CHDICJAF" title="Listing 1-2Macro to define appropriate modem-response string"></a><p class="codesample"><strong>Listing 1-2&nbsp;&nbsp;</strong>Macro to define appropriate modem-response string</p><div class="codesample"><table><tr><td scope="row"><pre>#define LOCAL_ECHO<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>#ifdef LOCAL_ECHO<span></span></pre></td></tr><tr><td scope="row"><pre>#define kOKResponseString "AT\r\r\nOK\r\n"<span></span></pre></td></tr><tr><td scope="row"><pre>#else<span></span></pre></td></tr><tr><td scope="row"><pre>#define kOKResponseString "\r\nOK\r\n"<span></span></pre></td></tr></table></div><p>The sample code also defines the constants shown in <span class="content_text">Listing 1-3</span>.</p><a name="//apple_ref/doc/uid/TP30000384-TPXREF112" title="Listing 1-3Constants used in the serial port modem sample code"></a><p class="codesample"><strong>Listing 1-3&nbsp;&nbsp;</strong>Constants used in the serial port modem sample code</p><div class="codesample"><table><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>#define kATCommandString        "AT\r"<span></span></pre></td></tr><tr><td scope="row"><pre>#define kMyErrReturn            -1<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>enum<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    kNumRetries = 3<span></span></pre></td></tr><tr><td scope="row"><pre>};<span></span></pre></td></tr></table></div><p>Serial port attributes, such as timeouts and baud rates are stored in the <code>termios</code> structure. The sample code defines a global static structure to store the device’s current attributes so it can restore them after changing them.</p><div class="codesample"><table><tr><td scope="row"><pre>static struct termios gOriginalTTYAttrs;<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP30000384-CIHJJIFA" title="Setting Up a Main Function"></a><h2>Setting Up a Main Function</h2><p><span class="content_text"><a href="SerialDevices.html#//apple_ref/doc/uid/TP30000384-CHDGEDIA">Listing 1-4</a></span> shows a <code><!--a-->main<!--/a--></code> function that uses I/O Kit functions to find a modem and POSIX functions to access it. The <code><!--a-->main<!--/a--></code> function accomplishes its work by calling the following functions, which are shown in other sections:</p><ul class="ul"><li class="li"><p><code>MyFindModems</code> (<span class="content_text"><a href="SerialDevices.html#//apple_ref/doc/uid/TP30000384-CIHEFFEF">“Finding All Modems”</a></span>)</p></li><li class="li"><p><code>MyGetModemPath</code> (<span class="content_text"><a href="SerialDevices.html#//apple_ref/doc/uid/TP30000384-CIHGEAFD">“Getting the Path to the Device File for a Modem”</a></span>)</p></li><li class="li"><p><code>MyOpenSerialPort</code> (<span class="content_text"><a href="SerialDevices.html#//apple_ref/doc/uid/TP30000384-CIHIAAFF">“Opening the Serial Port”</a></span>)</p></li><li class="li"><p><code>MyInitializeModem</code> (<span class="content_text"><a href="SerialDevices.html#//apple_ref/doc/uid/TP30000384-CIHHIIGA">“Communicating With the Modem”</a></span>)</p></li><li class="li"><p><code>MyCloseSerialPort</code> (<span class="content_text"><a href="SerialDevices.html#//apple_ref/doc/uid/TP30000384-CIHBIBBF">“Closing the Serial Port”</a></span>)</p></li></ul><p>The types <code>io_iterator_t</code> and <code>kern_return_t</code> are defined in the header files <code>IOTypes.h</code> and <code>std_types.h</code>, respectively.</p><p>The constants <code>EX_UNAVAILABLE</code>, <code>EX_IOERR</code>, and <code>EX_OK</code> are defined in the header file <code>sysexits.h</code>.</p><a name="//apple_ref/doc/uid/TP30000384-CHDGEDIA" title="Listing 1-4Setting up a main function for finding and accessing a modem"></a><p class="codesample"><strong>Listing 1-4&nbsp;&nbsp;</strong>Setting up a main function for finding and accessing a modem</p><div class="codesample"><table><tr><td scope="row"><pre>int main(void)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    int         fileDescriptor;<span></span></pre></td></tr><tr><td scope="row"><pre>    kern_return_t   kernResult;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    io_iterator_t   serialPortIterator;<span></span></pre></td></tr><tr><td scope="row"><pre>    char        deviceFilePath[MAXPATHLEN];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    kernResult = MyFindModems(&amp;serialPortIterator);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    kernResult = MyGetModemPath(serialPortIterator, deviceFilePath,<span></span></pre></td></tr><tr><td scope="row"><pre>                     sizeof(deviceFilePath));<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    IOObjectRelease(serialPortIterator);    // Release the iterator.<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Open the modem port, initialize the modem, then close it.<span></span></pre></td></tr><tr><td scope="row"><pre>    if (!deviceFilePath[0])<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        printf("No modem port found.\n");<span></span></pre></td></tr><tr><td scope="row"><pre>        return EX_UNAVAILABLE;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    fileDescriptor = OpenSerialPort(deviceFilePath);<span></span></pre></td></tr><tr><td scope="row"><pre>    if (fileDescriptor == kMyErrReturn)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        return EX_IOERR;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if (MyInitializeModem(fileDescriptor))<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        printf("Modem initialized successfully.\n");<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    else {<span></span></pre></td></tr><tr><td scope="row"><pre>        printf("Could not initialize modem.\n");<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    MyCloseSerialPort(fileDescriptor);<span></span></pre></td></tr><tr><td scope="row"><pre>    printf("Modem port closed.\n");<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    return EX_OK;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>The <code>main</code> function releases the iterator returned by the <code>MyFindModems</code> function, which also releases the iterator’s objects.</p><a name="//apple_ref/doc/uid/TP30000384-CIHEFFEF" title="Finding All Modems"></a><h2>Finding All Modems</h2><p><a name="//apple_ref/doc/uid/TP30000384-DontLinkElementID_5"></a><a name="//apple_ref/doc/uid/TP30000384-DontLinkElementID_6"></a><a name="//apple_ref/doc/uid/TP30000384-DontLinkElementID_7"></a><a name="//apple_ref/doc/uid/TP30000384-DontLinkElementID_8"></a><a name="//apple_ref/doc/uid/TP30000384-DontLinkElementID_9"></a><a name="//apple_ref/doc/uid/TP30000384-DontLinkElementID_10"></a><a name="//apple_ref/doc/uid/TP30000384-DontLinkElementID_11"></a>The <code>MyFindModems</code> function, shown in <span class="content_text"><a href="SerialDevices.html#//apple_ref/doc/uid/TP30000384-TPXREF114">Listing 1-5</a></span>, establishes a connection to the I/O Kit by calling the <code><a href="../../../../Darwin/Reference/IOKit/IOKitLib_h/index.html#//apple_ref/c/func/IOMasterPort" target="_top">IOMasterPort</a></code> function, which returns a Mach port. It then creates a matching dictionary by calling <code><a href="../../../../Darwin/Reference/IOKit/IOKitLib_h/index.html#//apple_ref/c/func/IOServiceMatching" target="_top">IOServiceMatching</a></code>, passing the constant <code><!--a  -->kIOSerialBSDServiceValue<!--/a--></code>. This sets up a dictionary that matches all devices with a provider class of IOSerialBSDClient.</p><p>A matching dictionary is a dictionary of key-value pairs that describes the properties of an I/O Kit device or other service. Each serial device object in the I/O Registry has a property with key <code><!--a  -->kIOSerialBSDTypeKey<!--/a--></code>. The possible values of this key are:</p><ul class="ul"><li class="li"><p><code><!--a  -->kIOSerialBSDAllTypes<!--/a--></code></p></li><li class="li"><p><code><!--a  -->kIOSerialBSDModemType<!--/a--></code></p></li><li class="li"><p><code><!--a  -->kIOSerialBSDRS232Type<!--/a--></code></p></li></ul><p>This sample project is interested only in modems, so the <code><!--a-->MyFindModems<!--/a--></code> function refines the matching dictionary by calling <code><a href="../../../../CoreFoundation/Reference/CFMutableDictionaryRef/Reference/reference.html#//apple_ref/c/func/CFDictionarySetValue" target="_top">CFDictionarySetValue</a></code> to add the key <code><!--a  -->kIOSerialBSDTypeKey<!--/a--></code> and value <code><!--a  -->kIOSerialBSDModemType<!--/a--></code>. (Remember, if there are modems on the other side of a serial port, this sample code will not find them.)</p><p>If you want to modify the sample code to find a different type of serial device, you can give the <code><!--a  -->kIOSerialBSDTypeKey<!--/a--></code> key one of the other values. The comments following the call to <code><a href="../../../../CoreFoundation/Reference/CFMutableDictionaryRef/Reference/reference.html#//apple_ref/c/func/CFDictionarySetValue" target="_top">CFDictionarySetValue</a></code> in <span class="content_text">Listing 1-5</span> describe how to do this.</p><p>Finally, <code>MyFindModems</code> passes the dictionary to the I/O Kit function <code><a href="../../../../Darwin/Reference/IOKit/IOKitLib_h/index.html#//apple_ref/c/func/IOServiceGetMatchingServices" target="_top">IOServiceGetMatchingServices</a></code> to obtain an iterator object that identifies all modem devices in the I/O Registry. If successful, <code>MyFindModems</code> uses its pointer parameter to return the iterator object. The calling function is responsible for releasing this object.</p><p>Constants such as <code><!--a  -->kIOSerialBSDTypeKey<!--/a--></code> and <code><!--a  -->kIOSerialBSDModemType<!--/a--></code> are defined in the header file <code>IOSerialKeys.h</code>. If you need more information on the process of finding devices in the I/O Registry, see <em><a href="../../AccessingHardware/index.html#//apple_ref/doc/uid/TP30000376" target="_top">Accessing Hardware From Applications</a></em>.</p><p>The constant <code>KERN_SUCCESS</code> is defined in the header file <code>kern_return.h</code>.</p><a name="//apple_ref/doc/uid/TP30000384-TPXREF114" title="Listing 1-5Finding all serial port modems in the current system"></a><p class="codesample"><strong>Listing 1-5&nbsp;&nbsp;</strong>Finding all serial port modems in the current system</p><a name="//apple_ref/doc/uid/TP30000384-DontLinkElementID_12"></a><a name="//apple_ref/doc/uid/TP30000384-DontLinkElementID_13"></a><a name="//apple_ref/doc/uid/TP30000384-DontLinkElementID_14"></a><a name="//apple_ref/doc/uid/TP30000384-DontLinkElementID_15"></a><a name="//apple_ref/doc/uid/TP30000384-DontLinkElementID_16"></a><a name="//apple_ref/doc/uid/TP30000384-DontLinkElementID_17"></a><div class="codesample"><table><tr><td scope="row"><pre>static kern_return_t MyFindModems(io_iterator_t *matchingServices)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    kern_return_t       kernResult;<span></span></pre></td></tr><tr><td scope="row"><pre>    mach_port_t         masterPort;<span></span></pre></td></tr><tr><td scope="row"><pre>    CFMutableDictionaryRef  classesToMatch;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    kernResult = IOMasterPort(MACH_PORT_NULL, &amp;masterPort);<span></span></pre></td></tr><tr><td scope="row"><pre>    if (KERN_SUCCESS != kernResult)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        printf("IOMasterPort returned %d\n", kernResult);<span></span></pre></td></tr><tr><td scope="row"><pre>    goto exit;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Serial devices are instances of class IOSerialBSDClient.<span></span></pre></td></tr><tr><td scope="row"><pre>    classesToMatch = IOServiceMatching(kIOSerialBSDServiceValue);<span></span></pre></td></tr><tr><td scope="row"><pre>    if (classesToMatch == NULL)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        printf("IOServiceMatching returned a NULL dictionary.\n");<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    else {<span></span></pre></td></tr><tr><td scope="row"><pre>        CFDictionarySetValue(classesToMatch,<span></span></pre></td></tr><tr><td scope="row"><pre>                             CFSTR(kIOSerialBSDTypeKey),<span></span></pre></td></tr><tr><td scope="row"><pre>                             CFSTR(kIOSerialBSDModemType));<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        // Each serial device object has a property with key<span></span></pre></td></tr><tr><td scope="row"><pre>        // kIOSerialBSDTypeKey and a value that is one of<span></span></pre></td></tr><tr><td scope="row"><pre>        // kIOSerialBSDAllTypes, kIOSerialBSDModemType,<span></span></pre></td></tr><tr><td scope="row"><pre>        // or kIOSerialBSDRS232Type. You can change the<span></span></pre></td></tr><tr><td scope="row"><pre>        // matching dictionary to find other types of serial<span></span></pre></td></tr><tr><td scope="row"><pre>        // devices by changing the last parameter in the above call<span></span></pre></td></tr><tr><td scope="row"><pre>        // to CFDictionarySetValue.<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    kernResult = IOServiceGetMatchingServices(masterPort, classesToMatch, matchingServices);<span></span></pre></td></tr><tr><td scope="row"><pre>    if (KERN_SUCCESS != kernResult)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        printf("IOServiceGetMatchingServices returned %d\n", kernResult);<span></span></pre></td></tr><tr><td scope="row"><pre>    goto exit;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>exit:<span></span></pre></td></tr><tr><td scope="row"><pre>    return kernResult;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP30000384-CIHGEAFD" title="Getting the Path to the Device File for a Modem"></a><h2>Getting the Path to the Device File for a Modem</h2><p><a name="//apple_ref/doc/uid/TP30000384-DontLinkElementID_18"></a><a name="//apple_ref/doc/uid/TP30000384-DontLinkElementID_19"></a><a name="//apple_ref/doc/uid/TP30000384-DontLinkElementID_20"></a><span class="content_text"><a href="SerialDevices.html#//apple_ref/doc/uid/TP30000384-TPXREF115">Listing 1-6</a></span> shows the <code>MyGetModemPath</code> function. The caller of this function passes an iterator to a list of modems, a pointer to storage for the device file path, and the maximum size of the path. The function returns, in the <code>deviceFilePath</code> parameter, the path to the device file (including filename) for the first modem it finds in the iterator.</p><p>The main body of <code>MyGetModemPath</code> consists of a <code>while</code> loop that iterates over all the modem objects in the passed iterator. Until it finds a modem, the code in the <code>while</code> loop examines each iterator object, performing the following operations:</p><ol class="ol"><li class="li"><p>It calls the I/O Kit function <code><a href="../../../../Darwin/Reference/IOKit/IOKitLib_h/index.html#//apple_ref/c/func/IORegistryEntryCreateCFProperty" target="_top">IORegistryEntryCreateCFProperty</a></code>, passing the key <code><!--a  -->kIOCalloutDeviceKey<!--/a--></code>, to obtain a <code>CFTypeRef</code> to the modem device file.</p></li><li class="li"><p>If successful in obtaining the modem’s device file, it calls <code><a href="../../../../CoreFoundation/Reference/CFStringRef/Reference/reference.html#//apple_ref/c/func/CFStringGetCString" target="_top">CFStringGetCString</a></code> to obtain the full path to the device file as a C string, pointed to by the <code>deviceFilePath</code> parameter.</p></li><li class="li"><p>If it finds the name, it prints it, then releases the <code>CFTypeRef</code>. For example, the file path may be <code>/dev/cu.modem</code>.</p></li></ol><p>The <code>while</code> loop in <code>MyGetModemPath</code> releases each iterator object it obtains while looking for a serial port modem, because the <code><a href="../../../../Darwin/Reference/IOKit/IOKitLib_h/index.html#//apple_ref/c/func/IOIteratorNext" target="_top">IOIteratorNext</a></code> function retains each object it returns. The calling function (in this sample, <code><!--a-->main<!--/a--></code>) is responsible for releasing the iterator itself, which also releases the iterator’s objects.</p><p>Finally, <code>MyGetModemPath</code> returns a result value that indicates whether the function successfully obtained a device path for a modem.</p><a name="//apple_ref/doc/uid/TP30000384-TPXREF115" title="Listing 1-6Returning the device file path for the first modem in a passed iterator"></a><p class="codesample"><strong>Listing 1-6&nbsp;&nbsp;</strong>Returning the device file path for the first modem in a passed iterator</p><div class="codesample"><table><tr><td scope="row"><pre>static kern_return_t MyGetModemPath(io_iterator_t serialPortIterator, char *deviceFilePath, CFIndex maxPathSize)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    io_object_t     modemService;<span></span></pre></td></tr><tr><td scope="row"><pre>    kern_return_t   kernResult = KERN_FAILURE;<span></span></pre></td></tr><tr><td scope="row"><pre>    Boolean     modemFound = false;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Initialize the returned path<span></span></pre></td></tr><tr><td scope="row"><pre>    *deviceFilePath = '\0';<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Iterate across all modems found. In this example, we exit after<span></span></pre></td></tr><tr><td scope="row"><pre>    // finding the first modem.<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    while !modemFound) &amp;&amp; ((modemService = IOIteratorNext(serialPortIterator))<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        CFTypeRef   deviceFilePathAsCFString;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Get the callout device's path (/dev/cu.xxxxx).<span></span></pre></td></tr><tr><td scope="row"><pre>    // The callout device should almost always be<span></span></pre></td></tr><tr><td scope="row"><pre>    // used. You would use the dialin device (/dev/tty.xxxxx) when<span></span></pre></td></tr><tr><td scope="row"><pre>    // monitoring a serial port for<span></span></pre></td></tr><tr><td scope="row"><pre>    // incoming calls, for example, a fax listener.<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    deviceFilePathAsCFString = IORegistryEntryCreateCFProperty(modemService,<span></span></pre></td></tr><tr><td scope="row"><pre>                            CFSTR(kIOCalloutDeviceKey),<span></span></pre></td></tr><tr><td scope="row"><pre>                            kCFAllocatorDefault,<span></span></pre></td></tr><tr><td scope="row"><pre>                            0);<span></span></pre></td></tr><tr><td scope="row"><pre>        if (deviceFilePathAsCFString)<span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>            Boolean result;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        // Convert the path from a CFString to a NULL-terminated C string<span></span></pre></td></tr><tr><td scope="row"><pre>        // for use with the POSIX open() call.<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        result = CFStringGetCString(deviceFilePathAsCFString,<span></span></pre></td></tr><tr><td scope="row"><pre>                                        deviceFilePath,<span></span></pre></td></tr><tr><td scope="row"><pre>                                        maxPathSize,<span></span></pre></td></tr><tr><td scope="row"><pre>                                        kCFStringEncodingASCII);<span></span></pre></td></tr><tr><td scope="row"><pre>            CFRelease(deviceFilePathAsCFString);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>            if (result)<span></span></pre></td></tr><tr><td scope="row"><pre>            {<span></span></pre></td></tr><tr><td scope="row"><pre>                printf("BSD path: %s", deviceFilePath);<span></span></pre></td></tr><tr><td scope="row"><pre>                modemFound = true;<span></span></pre></td></tr><tr><td scope="row"><pre>                kernResult = KERN_SUCCESS;<span></span></pre></td></tr><tr><td scope="row"><pre>            }<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        printf("\n");<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        // Release the io_service_t now that we are done with it.<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    (void) IOObjectRelease(modemService);<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    return kernResult;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP30000384-CIHIAAFF" title="Opening the Serial Port"></a><h2>Opening the Serial Port</h2><p><a name="//apple_ref/doc/uid/TP30000384-DontLinkElementID_21"></a><a name="//apple_ref/doc/uid/TP30000384-DontLinkElementID_22"></a><a name="//apple_ref/doc/uid/TP30000384-DontLinkElementID_23"></a><a name="//apple_ref/doc/uid/TP30000384-DontLinkElementID_24"></a><a name="//apple_ref/doc/uid/TP30000384-DontLinkElementID_25"></a><a name="//apple_ref/doc/uid/TP30000384-DontLinkElementID_26"></a>To open a serial port, the <code>MyOpenSerialPort</code> function, shown in <span class="content_text"><a href="SerialDevices.html#//apple_ref/doc/uid/TP30000384-TPXREF116">Listing 1-7</a></span>, calls the <code><!--a-->open<!--/a--></code> function, passing the device file path, as well as the following constants:</p><ul class="ul"><li class="li"><p><code>O_RDWR</code>: open for reading and writing</p></li><li class="li"><p><code>O_NOCTTY</code>: don’t assign a controlling terminal</p></li><li class="li"><p><code>O_NONBLOCK</code>: allow subsequent I/O on the device to be nonblocking</p></li></ul><p>These constants and the <code>open</code> and <code>fcntl</code> functions are defined in <code>fcntl.h</code>.</p><p>If <code>open</code> returns a valid file descriptor, <code>MyOpenSerialPort</code> performs the following additional steps:</p><ol class="ol"><li class="li"><p>It calls the <code><!--a-->ioctl<!--/a--></code> function, passing <code>TIOCEXCL</code>, to prevent additional opens on the device, except from a root-owned process.</p></li><li class="li"><p>It calls the <code><!--a-->fcntl<!--/a--></code> function, passing the value <code>F_SETFL</code> to clear the <code>O_NONBLOCK</code> flag so subsequent I/O will block.</p></li><li class="li"><p>It calls the <code>tcgetattr</code> function to save the current file settings in the global static structure <code>gOriginalTTYAttrs</code>, of type <code>termios</code>. These values will be restored later by the <code>MyCLoseSerialPort</code> function (<span class="content_text"><a href="SerialDevices.html#//apple_ref/doc/uid/TP30000384-TPXREF118">Listing 1-10</a></span>). The <code>termios</code> structure and the <code>tcgetattr</code> and <code>tcsetattr</code> functions are defined in the header <code>termios.h</code>.</p></li><li class="li"><p>It sets some fields of <code>options</code>, a local <code>termios</code> structure, using values defined in the header <code>termios.h</code>. These options specify, among other things, raw input mode, a one second timeout value for blocking reads, and input and output baud rates. <code>MyOpenSerialPort</code> then passes the <code>options</code> structure to the <code>tcsetattr</code> function to set new values for the serial port (the changes won’t take effect until the call to <code><!--a-->tcsetattr<!--/a--></code>). The constant <code>TCSANOW</code> is also defined in <code>termios.h</code>, and indicates that the change should be made immediately.</p></li><li class="li"><p>Finally, it returns the file descriptor obtained from the call to <code>open</code>.</p></li></ol><p>You can find the headers mentioned in this section in header files in <code>Kernel.framework</code>, <code>System.framework</code>, or the directory <code>/usr/include</code>.<a name="//apple_ref/doc/uid/TP30000384-DontLinkElementID_27"></a></p><a name="//apple_ref/doc/uid/TP30000384-TPXREF116" title="Listing 1-7Opening the serial port specified by the passed device file"></a><p class="codesample"><strong>Listing 1-7&nbsp;&nbsp;</strong>Opening the serial port specified by the passed device file</p><div class="codesample"><table><tr><td scope="row"><pre>static int MyOpenSerialPort(const char *deviceFilePath)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    int         fileDescriptor = -1;<span></span></pre></td></tr><tr><td scope="row"><pre>    int         handshake;<span></span></pre></td></tr><tr><td scope="row"><pre>    struct termios  options;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Open the serial port read/write, with no controlling terminal,<span></span></pre></td></tr><tr><td scope="row"><pre>    // and don't wait for a connection.<span></span></pre></td></tr><tr><td scope="row"><pre>    // The O_NONBLOCK flag also causes subsequent I/O on the device to<span></span></pre></td></tr><tr><td scope="row"><pre>    // be non-blocking.<span></span></pre></td></tr><tr><td scope="row"><pre>    // See open(2) ("man 2 open") for details.<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    fileDescriptor = open(deviceFilePath, O_RDWR | O_NOCTTY | O_NONBLOCK);<span></span></pre></td></tr><tr><td scope="row"><pre>    if (fileDescriptor == -1)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        printf("Error opening serial port %s - %s(%d).\n",<span></span></pre></td></tr><tr><td scope="row"><pre>               deviceFilePath, strerror(errno), errno);<span></span></pre></td></tr><tr><td scope="row"><pre>        goto error;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Note that open() follows POSIX semantics: multiple open() calls to<span></span></pre></td></tr><tr><td scope="row"><pre>    // the same file will succeed unless the TIOCEXCL ioctl is issued.<span></span></pre></td></tr><tr><td scope="row"><pre>    // This will prevent additional opens except by root-owned processes.<span></span></pre></td></tr><tr><td scope="row"><pre>    // See tty(4) ("man 4 tty") and ioctl(2) ("man 2 ioctl") for details.<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if (ioctl(fileDescriptor, TIOCEXCL) == kMyErrReturn)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        printf("Error setting TIOCEXCL on %s - %s(%d).\n",<span></span></pre></td></tr><tr><td scope="row"><pre>            deviceFilePath, strerror(errno), errno);<span></span></pre></td></tr><tr><td scope="row"><pre>        goto error;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Now that the device is open, clear the O_NONBLOCK flag so<span></span></pre></td></tr><tr><td scope="row"><pre>    // subsequent I/O will block.<span></span></pre></td></tr><tr><td scope="row"><pre>    // See fcntl(2) ("man 2 fcntl") for details.<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if (fcntl(fileDescriptor, F_SETFL, 0) == kMyErrReturn)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        printf("Error clearing O_NONBLOCK %s - %s(%d).\n",<span></span></pre></td></tr><tr><td scope="row"><pre>            deviceFilePath, strerror(errno), errno);<span></span></pre></td></tr><tr><td scope="row"><pre>        goto error;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Get the current options and save them so we can restore the<span></span></pre></td></tr><tr><td scope="row"><pre>    // default settings later.<span></span></pre></td></tr><tr><td scope="row"><pre>    if (tcgetattr(fileDescriptor, &amp;gOriginalTTYAttrs) == kMyErrReturn)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        printf("Error getting tty attributes %s - %s(%d).\n",<span></span></pre></td></tr><tr><td scope="row"><pre>            deviceFilePath, strerror(errno), errno);<span></span></pre></td></tr><tr><td scope="row"><pre>        goto error;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // The serial port attributes such as timeouts and baud rate are set by<span></span></pre></td></tr><tr><td scope="row"><pre>    // modifying the termios structure and then calling tcsetattr to<span></span></pre></td></tr><tr><td scope="row"><pre>    // cause the changes to take effect. Note that the<span></span></pre></td></tr><tr><td scope="row"><pre>    // changes will not take effect without the tcsetattr() call.<span></span></pre></td></tr><tr><td scope="row"><pre>    // See tcsetattr(4) ("man 4 tcsetattr") for details.<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    options = gOriginalTTYAttrs;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Print the current input and output baud rates.<span></span></pre></td></tr><tr><td scope="row"><pre>    // See tcsetattr(4) ("man 4 tcsetattr") for details.<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    printf("Current input baud rate is %d\n", (int) cfgetispeed(&amp;options));<span></span></pre></td></tr><tr><td scope="row"><pre>    printf("Current output baud rate is %d\n", (int) cfgetospeed(&amp;options));<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Set raw input (non-canonical) mode, with reads blocking until either<span></span></pre></td></tr><tr><td scope="row"><pre>    // a single character has been received or a one second timeout expires.<span></span></pre></td></tr><tr><td scope="row"><pre>    // See tcsetattr(4) ("man 4 tcsetattr") and termios(4) ("man 4 termios")<span></span></pre></td></tr><tr><td scope="row"><pre>    // for details.<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    cfmakeraw(&amp;options);<span></span></pre></td></tr><tr><td scope="row"><pre>    options.c_cc[VMIN] = 1;<span></span></pre></td></tr><tr><td scope="row"><pre>    options.c_cc[VTIME] = 10;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // The baud rate, word length, and handshake options can be set as follows:<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    cfsetspeed(&amp;options, B19200);   // Set 19200 baud<span></span></pre></td></tr><tr><td scope="row"><pre>    options.c_cflag |= (CS7        |// Use 7 bit words<span></span></pre></td></tr><tr><td scope="row"><pre>            PARENB     |        // Enable parity (even parity if PARODD<span></span></pre></td></tr><tr><td scope="row"><pre>                                // not also set)<span></span></pre></td></tr><tr><td scope="row"><pre>            CCTS_OFLOW |        // CTS flow control of output<span></span></pre></td></tr><tr><td scope="row"><pre>            CRTS_IFLOW);        // RTS flow control of input<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Print the new input and output baud rates.<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    printf("Input baud rate changed to %d\n", (int) cfgetispeed(&amp;options));<span></span></pre></td></tr><tr><td scope="row"><pre>    printf("Output baud rate changed to %d\n", (int) cfgetospeed(&amp;options));<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Cause the new options to take effect immediately.<span></span></pre></td></tr><tr><td scope="row"><pre>    if (tcsetattr(fileDescriptor, TCSANOW, &amp;options) == kMyErrReturn)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        printf("Error setting tty attributes %s - %s(%d).\n",<span></span></pre></td></tr><tr><td scope="row"><pre>            deviceFilePath, strerror(errno), errno);<span></span></pre></td></tr><tr><td scope="row"><pre>        goto error;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // To set the modem handshake lines, use the following ioctls.<span></span></pre></td></tr><tr><td scope="row"><pre>    // See tty(4) ("man 4 tty") and ioctl(2) ("man 2 ioctl") for details.<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if (ioctl(fileDescriptor, TIOCSDTR) == kMyErrReturn)<span></span></pre></td></tr><tr><td scope="row"><pre>    // Assert Data Terminal Ready (DTR)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        printf("Error asserting DTR %s - %s(%d).\n",<span></span></pre></td></tr><tr><td scope="row"><pre>            deviceFilePath, strerror(errno), errno);<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if (ioctl(fileDescriptor, TIOCCDTR) == kMyErrReturn)<span></span></pre></td></tr><tr><td scope="row"><pre>    // Clear Data Terminal Ready (DTR)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        printf("Error clearing DTR %s - %s(%d).\n",<span></span></pre></td></tr><tr><td scope="row"><pre>            deviceFilePath, strerror(errno), errno);<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    handshake = TIOCM_DTR | TIOCM_RTS | TIOCM_CTS | TIOCM_DSR;<span></span></pre></td></tr><tr><td scope="row"><pre>    // Set the modem lines depending on the bits set in handshake.<span></span></pre></td></tr><tr><td scope="row"><pre>    if (ioctl(fileDescriptor, TIOCMSET, &amp;handshake) == kMyErrReturn)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        printf("Error setting handshake lines %s - %s(%d).\n",<span></span></pre></td></tr><tr><td scope="row"><pre>            deviceFilePath, strerror(errno), errno);<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // To read the state of the modem lines, use the following ioctl.<span></span></pre></td></tr><tr><td scope="row"><pre>    // See tty(4) ("man 4 tty") and ioctl(2) ("man 2 ioctl") for details.<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if (ioctl(fileDescriptor, TIOCMGET, &amp;handshake) == kMyErrReturn)<span></span></pre></td></tr><tr><td scope="row"><pre>    // Store the state of the modem lines in handshake.<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        printf("Error getting handshake lines %s - %s(%d).\n",<span></span></pre></td></tr><tr><td scope="row"><pre>            deviceFilePath, strerror(errno), errno);<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    printf("Handshake lines currently set to %d\n", handshake);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Success:<span></span></pre></td></tr><tr><td scope="row"><pre>    return fileDescriptor;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Failure:<span></span></pre></td></tr><tr><td scope="row"><pre>error:<span></span></pre></td></tr><tr><td scope="row"><pre>    if (fileDescriptor != kMyErrReturn)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        close(fileDescriptor);<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    return -1;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP30000384-CIHHIIGA" title="Communicating With the Modem"></a><h2>Communicating With the Modem</h2><p><a name="//apple_ref/doc/uid/TP30000384-DontLinkElementID_28"></a><span class="content_text"><a href="SerialDevices.html#//apple_ref/doc/uid/TP30000384-TPXREF117">Listing 1-8</a></span> shows a simple modem initialization function, <code>MyInitializeModem</code>. The caller of this function passes the file descriptor for a modem’s device file. The modem serial port is assumed to be open. <code>MyInitializeModem</code> function performs the following steps:</p><ol class="ol"><li class="li"><p>It sends an “AT” command to the modem, using the <code><!--a-->write<!--/a--></code> function defined in <code>unistd.h</code>.</p></li><li class="li"><p>It attempts to read a response from the modem, using the <code><!--a-->read<!--/a--></code> command, checking it against the desired response of “OK”.</p></li></ol><p>The definitions for the constants kOKResponseString, <code>kATCommandString</code>, and <code>kMyErrReturn</code> are shown in <span class="content_text"><a href="SerialDevices.html#//apple_ref/doc/uid/TP30000384-TPXREF112">Listing 1-3</a></span> and <span class="content_text"><a href="SerialDevices.html#//apple_ref/doc/uid/TP30000384-TPXREF112">Listing 1-3</a></span>.</p><p>Throughout, the <code><!--a-->MyInitializeModem<!--/a--></code> function uses the <code><!--a-->MyLogString<!--/a--></code> function (shown in <span class="content_text"><a href="SerialDevices.html#//apple_ref/doc/uid/TP30000384-CHDFIBCA">Listing 1-9</a></span>) to replace with printable equivalents the unprintable characters in the modem-command strings and in the data received from the modem. </p><a name="//apple_ref/doc/uid/TP30000384-TPXREF117" title="Listing 1-8Initializing a serial port modem by writing to and reading from its device file"></a><p class="codesample"><strong>Listing 1-8&nbsp;&nbsp;</strong>Initializing a serial port modem by writing to and reading from its device file</p><div class="codesample"><table><tr><td scope="row"><pre>static Boolean MyInitializeModem(int fileDescriptor)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    char    buffer[256];    // Input buffer<span></span></pre></td></tr><tr><td scope="row"><pre>    char    *bufPtr;        // Current char in buffer<span></span></pre></td></tr><tr><td scope="row"><pre>    ssize_t numBytes;       // Number of bytes read or written<span></span></pre></td></tr><tr><td scope="row"><pre>    int     tries;          // Number of tries so far<span></span></pre></td></tr><tr><td scope="row"><pre>    Boolean result = false;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    for (tries = 1; tries &lt;= kNumRetries; tries++)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        printf("Try #%d\n", tries);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        // Send an AT command to the modem<span></span></pre></td></tr><tr><td scope="row"><pre>        numBytes = write(fileDescriptor, kATCommandString,<span></span></pre></td></tr><tr><td scope="row"><pre>                         strlen(kATCommandString));<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if (numBytes == kMyErrReturn)<span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>            printf("Error writing to modem - %s(%d).\n", strerror(errno),<span></span></pre></td></tr><tr><td scope="row"><pre>                        errno);<span></span></pre></td></tr><tr><td scope="row"><pre>            continue;<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>    else {<span></span></pre></td></tr><tr><td scope="row"><pre>        printf("Wrote %d bytes \"%s\"\n", numBytes,<span></span></pre></td></tr><tr><td scope="row"><pre>                        MyLogString(kATCommandString));<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if (numBytes &lt; strlen(kATCommandString))<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>            continue;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        printf("Looking for \"%s\"\n", MyLogString(kOKResponseString));<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Read characters into our buffer until we get a CR or LF.<span></span></pre></td></tr><tr><td scope="row"><pre>        bufPtr = buffer;<span></span></pre></td></tr><tr><td scope="row"><pre>        do<span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>            numBytes = read(fileDescriptor, bufPtr, &amp;buffer[sizeof(buffer)]<span></span></pre></td></tr><tr><td scope="row"><pre>                        - bufPtr - 1);<span></span></pre></td></tr><tr><td scope="row"><pre>            if (numBytes == kMyErrReturn)<span></span></pre></td></tr><tr><td scope="row"><pre>            {<span></span></pre></td></tr><tr><td scope="row"><pre>                printf("Error reading from modem - %s(%d).\n", strerror(errno),<span></span></pre></td></tr><tr><td scope="row"><pre>                        errno);<span></span></pre></td></tr><tr><td scope="row"><pre>            }<span></span></pre></td></tr><tr><td scope="row"><pre>            else if (numBytes > 0)<span></span></pre></td></tr><tr><td scope="row"><pre>            {<span></span></pre></td></tr><tr><td scope="row"><pre>                bufPtr += numBytes;<span></span></pre></td></tr><tr><td scope="row"><pre>                if (*(bufPtr - 1) == '\n' || *(bufPtr - 1) == '\r')<span></span></pre></td></tr><tr><td scope="row"><pre>                {<span></span></pre></td></tr><tr><td scope="row"><pre>                    break;<span></span></pre></td></tr><tr><td scope="row"><pre>                }<span></span></pre></td></tr><tr><td scope="row"><pre>            }<span></span></pre></td></tr><tr><td scope="row"><pre>            else {<span></span></pre></td></tr><tr><td scope="row"><pre>                printf("Nothing read.\n");<span></span></pre></td></tr><tr><td scope="row"><pre>            }<span></span></pre></td></tr><tr><td scope="row"><pre>        } while (numBytes > 0);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        // NULL terminate the string and see if we got a response of OK.<span></span></pre></td></tr><tr><td scope="row"><pre>        *bufPtr = '\0';<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        printf("Read \"%s\"\n", MyLogString(buffer));<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        if (strncmp(buffer, kOKResponseString, strlen(kOKResponseString)) == 0)<span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>            result = true;<span></span></pre></td></tr><tr><td scope="row"><pre>            break;<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    return result;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>The <code><!--a-->MyInitializeModem<!--/a--></code> function uses a utility function called <code><!--a-->MyLogString<!--/a--></code> that replaces unprintable characters with printable equivalents, using the ‘\’ character. <span class="content_text">Listing 1-9</span> shows the <code><!--a-->MyLogString<!--/a--></code> function.</p><a name="//apple_ref/doc/uid/TP30000384-CHDFIBCA" title="Listing 1-9Enabling printing of data traffic"></a><p class="codesample"><strong>Listing 1-9&nbsp;&nbsp;</strong>Enabling printing of data traffic</p><div class="codesample"><table><tr><td scope="row"><pre>static char *MyLogString(char *str)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    static char     buf[2048];<span></span></pre></td></tr><tr><td scope="row"><pre>    char            *ptr = buf;<span></span></pre></td></tr><tr><td scope="row"><pre>    int             i;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    *ptr = '\0';<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    while (*str)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        if (isprint(*str))<span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>            *ptr++ = *str++;<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>        else {<span></span></pre></td></tr><tr><td scope="row"><pre>            switch(*str)<span></span></pre></td></tr><tr><td scope="row"><pre>            {<span></span></pre></td></tr><tr><td scope="row"><pre>            case ' ':<span></span></pre></td></tr><tr><td scope="row"><pre>                *ptr++ = *str;<span></span></pre></td></tr><tr><td scope="row"><pre>                break;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>            case 27:<span></span></pre></td></tr><tr><td scope="row"><pre>                *ptr++ = '\\';<span></span></pre></td></tr><tr><td scope="row"><pre>                *ptr++ = 'e';<span></span></pre></td></tr><tr><td scope="row"><pre>                break;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>            case '\t':<span></span></pre></td></tr><tr><td scope="row"><pre>                *ptr++ = '\\';<span></span></pre></td></tr><tr><td scope="row"><pre>                *ptr++ = 't';<span></span></pre></td></tr><tr><td scope="row"><pre>                break;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>            case '\n':<span></span></pre></td></tr><tr><td scope="row"><pre>                *ptr++ = '\\';<span></span></pre></td></tr><tr><td scope="row"><pre>                *ptr++ = 'n';<span></span></pre></td></tr><tr><td scope="row"><pre>                break;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>            case '\r':<span></span></pre></td></tr><tr><td scope="row"><pre>                *ptr++ = '\\';<span></span></pre></td></tr><tr><td scope="row"><pre>                *ptr++ = 'r';<span></span></pre></td></tr><tr><td scope="row"><pre>                break;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>            default:<span></span></pre></td></tr><tr><td scope="row"><pre>                i = *str;<span></span></pre></td></tr><tr><td scope="row"><pre>                (void)sprintf(ptr, "\\%03o", i);<span></span></pre></td></tr><tr><td scope="row"><pre>                ptr += 4;<span></span></pre></td></tr><tr><td scope="row"><pre>                break;<span></span></pre></td></tr><tr><td scope="row"><pre>            }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>            str++;<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>        *ptr = '\0';<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    return buf;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP30000384-CIHBIBBF" title="Closing the Serial Port"></a><h2>Closing the Serial Port</h2><p><a name="//apple_ref/doc/uid/TP30000384-DontLinkElementID_29"></a><span class="content_text"><a href="SerialDevices.html#//apple_ref/doc/uid/TP30000384-TPXREF118">Listing 1-10</a></span> shows the <code>MyCloseSerialPort</code> function. This function performs the following steps:</p><ol class="ol"><li class="li"><p>It blocks until all output has been sent from the device.</p></li><li class="li"><p>It restores the previous state of the serial port, using values that were saved in a static structure of type <code>termios</code> by the <code>MyOpenSerialPort</code> function (<span class="content_text"><a href="SerialDevices.html#//apple_ref/doc/uid/TP30000384-TPXREF116">Listing 1-7</a></span>). The <code>termios</code> structure is defined in the header <code>termios.h</code> in <code>System.framework</code>.</p></li><li class="li"><p>To close the serial port, <code><!--a-->MyCloseSerialPort<!--/a--></code> calls the <code><!--a-->close<!--/a--></code> function (defined in <code>unistd.h</code>), passing the file descriptor for the serial port device file (obtained by the <code>MyOpenSerialPort</code> function).</p></li></ol><a name="//apple_ref/doc/uid/TP30000384-TPXREF118" title="Listing 1-10Closing the serial port specified by the passed file descriptor"></a><p class="codesample"><strong>Listing 1-10&nbsp;&nbsp;</strong>Closing the serial port specified by the passed file descriptor</p><div class="codesample"><table><tr><td scope="row"><pre>void MyCloseSerialPort(int fileDescriptor)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    // Block until all written output has been sent from the device.<span></span></pre></td></tr><tr><td scope="row"><pre>    // Note that this call is simply passed on to the serial device driver.<span></span></pre></td></tr><tr><td scope="row"><pre>    // See tcsendbreak(3) ("man 3 tcsendbreak") for details.<span></span></pre></td></tr><tr><td scope="row"><pre>    if (tcdrain(fileDescriptor) == kMyErrReturn)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        printf("Error waiting for drain - %s(%d).\n",<span></span></pre></td></tr><tr><td scope="row"><pre>            strerror(errno), errno);<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // It is good practice to reset a serial port back to the state in<span></span></pre></td></tr><tr><td scope="row"><pre>    // which you found it. This is why we saved the original termios struct<span></span></pre></td></tr><tr><td scope="row"><pre>    // The constant TCSANOW (defined in termios.h) indicates that<span></span></pre></td></tr><tr><td scope="row"><pre>    // the change should take effect immediately.<span></span></pre></td></tr><tr><td scope="row"><pre>    if (tcsetattr(fileDescriptor, TCSANOW, &amp;gOriginalTTYAttrs) ==<span></span></pre></td></tr><tr><td scope="row"><pre>                    kMyErrReturn)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        printf("Error resetting tty attributes - %s(%d).\n",<span></span></pre></td></tr><tr><td scope="row"><pre>                    strerror(errno), errno);<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    close(fileDescriptor);<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../WWSerial_Intro/WWSerial_Intro.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../WWSerial_RevHistory/WWSerial_RevHistory.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2003, 2005 Apple Computer, Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2005-12-06<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/DeviceDrivers/Conceptual/WorkingWSerial/WWSerial_SerialDevs/SerialDevices.html%3Fid%3DTP40000972-1.3&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/DeviceDrivers/Conceptual/WorkingWSerial/WWSerial_SerialDevs/SerialDevices.html%3Fid%3DTP40000972-1.3&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/DeviceDrivers/Conceptual/WorkingWSerial/WWSerial_SerialDevs/SerialDevices.html%3Fid%3DTP40000972-1.3&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>