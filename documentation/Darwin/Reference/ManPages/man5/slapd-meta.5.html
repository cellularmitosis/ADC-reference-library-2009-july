<html><head><title>Mac OS X
 Manual Page For slapd-meta(5)</title>
<style type="text/css"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { font-size: 1px; background: #ffffff; color: #ffffff; } --></style>
<style type="text/css" media="print, aural, braille, embossed, projection, tty"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { display: none; } --></style>
</head><body bgcolor="white">
<a name="//apple_ref/doc/man/5/slapd-meta" title="Mac OS X
 Manual Page for slapd-meta(5)"><!-- headerDoc=man; indexgroup=Section 5; uid="//apple_ref/doc/man/5/slapd-meta"; name=slapd-meta(5) --></a>
<!--#include virtual="/includes/framesetheader"-->
<table width=600><tr><td scope="row">
<!-- begin breadcrumb insert request --><font face="Geneva,Helvetica,Arial" size="1">
 <a target="_top" href="http://developer.apple.com">ADC Home</a> <b>&gt;</b> <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> <b>&gt;</b> <a href="../../../../../reference/index.html#//apple_ref/doc/uid/TP30001281" target="_top">Reference</a> <b>&gt;</b> <!-- a href="" target="_top" -->Mac OS X<!-- /a --> <b>&gt;</b> <a href="../index.html#//apple_ref/doc/framework/manpages" target="_top">Mac OS X Man Pages</a></font>
<!-- end breadcrumb insert request -->
<p>&nbsp;</p>
</td></tr></table>
<!-- end of header -->
<table border="0"  cellpadding="2" cellspacing="2" width="630pt"><tr><td valign="top" height="12" colspan="5" scope="row">
<p style='text-align:justify;'>This document is a Mac OS X manual page.  Manual pages are a command-line technology
for providing documentation.  You can view these manual pages locally using the
<a href="../man1/man.1.html#//apple_ref/doc/man/1/man">man(1)</a> command.
These manual pages come from many different sources, and thus, have a variety of writing
styles.</p>
<p style='text-align:justify;'>For more information about the manual page format, see the manual page for 
<a href="manpages.5.html#//apple_ref/doc/man/5/manpages">manpages(5)</a>.</p>
</td></tr></table>
<hr />
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row"><pre class="manpages"><tt>
SLAPD-META(5)                                                                                  SLAPD-META(5)



<b>NAME</b>
       slapd-meta - metadirectory backend

<b>SYNOPSIS</b>
       /etc/openldap/slapd.conf

<b>DESCRIPTION</b>
       The  <b>meta</b>  backend  to  <a href="../man8/slapd.8.html#//apple_ref/doc/man/8/slapd"><b>slapd</b>(8)</a>  performs  basic  LDAP proxying with respect to a set of remote LDAP
       servers, called "targets".  The information contained in these servers can be presented as  belonging
       to a single Directory Information Tree (DIT).

       A basic knowledge of the functionality of the <a href="slapd-ldap.5.html#//apple_ref/doc/man/5/slapd-ldap"><b>slapd-ldap</b>(5)</a> backend is recommended.  This backend has
       been designed as an enhancement of the ldap backend.  The two backends share many features  (actually
       they  also  share portions of code).  While the <b>ldap</b> backend is intended to proxy operations directed
       to a single server, the <b>meta</b> backend is mainly intended for proxying of multiple servers and possibly
       naming context masquerading.  These features, although useful in many scenarios, may result in exces-<font color="#ffffff" class="whiteout">sive&nbsp;excessive</font>
       sive overhead for some applications, so its use should be carefully considered.  In the examples sec-<font color="#ffffff" class="whiteout">tion,&nbsp;section,</font>
       tion, some typical scenarios will be discussed.


       Note: When looping back to the same instance of <a href="../man8/slapd.8.html#//apple_ref/doc/man/8/slapd"><b>slapd</b>(8)</a>, each connection requires a new thread; as a
       consequence, <a href="../man8/slapd.8.html#//apple_ref/doc/man/8/slapd"><b>slapd</b>(8)</a> must be compiled with thread support, and the <b>threads</b> parameter may  need  some
       tuning; in those cases, unless the multiple target feature is required, one may consider using <a href="slapd-relay.5.html#//apple_ref/doc/man/5/slapd-relay"><b>slapd</b></a>-<font color="#ffffff" class="whiteout">relay(5)&nbsp;slapdrelay(5)</font>
       <a href="slapd-relay.5.html#//apple_ref/doc/man/5/slapd-relay"><b>relay</b>(5)</a> instead, which performs the relayed operation internally and thus reuses  the  same  connec-<font color="#ffffff" class="whiteout">tion.&nbsp;connection.</font>
       tion.


<b>EXAMPLES</b>
       There are examples in various places in this document, as well as in the slapd/back-meta/data/ direc-<font color="#ffffff" class="whiteout">tory&nbsp;directory</font>
       tory in the OpenLDAP source tree.

<b>CONFIGURATION</b>
       These <b>slapd.conf</b> options apply to the META backend database.  That is, they must follow  a  "database
       meta"  line and come before any subsequent "backend" or "database" lines.  Other database options are
       described in the <a href="slapd.conf.5.html#//apple_ref/doc/man/5/slapd.conf"><b>slapd.conf</b>(5)</a> manual page.

       Note: In early versions of back-ldap and back-meta it was recommended to always set

              lastmod  off

       for every <b>ldap</b> and <b>meta</b> database.  This is because operational attributes related to  entry  creation
       and  modification should not be proxied, as they could be mistakenly written to the target <!-- a -->server(s)<!-- /a -->,
       generating an error.  The current implementation automatically sets lastmod to off,  so  its  use  is
       redundant and should be omitted, because the lastmod directive will be deprecated in the future.


<b>SPECIAL</b> <b>CONFIGURATION</b> <b>DIRECTIVES</b>
       Target  configuration starts with the "uri" directive.  All the configuration directives that are not
       specific to targets should be defined first for clarity, including those that are common to all back-<font color="#ffffff" class="whiteout">ends.&nbsp;backends.</font>
       ends.  They are:


       <b>default-target</b> <b>none</b>
              This directive forces the backend to reject all those operations that must resolve to a single
              target in case none or multiple targets are selected.  They include: add, delete, modify, mod-<font color="#ffffff" class="whiteout">rdn;&nbsp;modrdn;</font>
              rdn;  compare  is not included, as well as bind since, as they don't alter entries, in case of
              multiple matches an attempt is made to perform the operation on any candidate target, with the
              constraint  that  at  most  one must succeed.  This directive can also be used when processing
              targets to mark a specific target as default.


       <b>dncache-ttl</b> <b>{DISABLED|forever|&lt;ttl&gt;}</b>
              This directive sets the time-to-live of the DN cache.  This caches the  target  that  holds  a
              given  DN  to speed up target selection in case multiple targets would result from an uncached
              search; forever means cache never expires; disabled means no DN caching; otherwise a valid ( &gt;
              0 ) ttl is required, in the format illustrated for the <b>idle-timeout</b> directive.


       <b>conn-ttl</b> <b>&lt;time&gt;</b>
              This  directive  causes  a  cached  connection  to  be dropped an recreated after a given ttl,
              regardless of being idle or not.


       <b>onerr</b> <b>{CONTINUE|stop}</b>
              This directive allows to select the behavior in case an error is returned by one target during
              a  search.   The  default, <b>continue</b>, consists in continuing the operation, trying to return as
              much data as possible.  If this statement is set to <b>stop</b>, the search is terminated as soon  as
              an error is returned by one target, and the error is immediately propagated to the client.


       <b>protocol-version</b> <b>{0,2,3}</b>
              This  directive indicates what protocol version must be used to contact the remote server.  If
              set to 0 (the default), the proxy uses the same protocol version used by the client, otherwise
              the  requested protocol is used.  The proxy returns <u>unwillingToPerform</u> if an operation that is
              incompatible with the requested protocol is attempted.  If set before  any  target  specifica-<font color="#ffffff" class="whiteout">tion,&nbsp;specification,</font>
              tion, it affects all targets, unless overridden by any per-target directive.


       <b>pseudoroot-bind-defer</b> <b>{NO|yes}</b>
              This  directive,  when  set  to  <b>yes</b>, causes the authentication to the remote servers with the
              pseudo-root identity to be deferred until actually needed by subsequent operations.


       <b>rebind-as-user</b> <b>{NO|yes}</b>
              If this option is given, the client's bind credentials are remembered for rebinds when chasing
              referrals.


<b>TARGET</b> <b>SPECIFICATION</b>
       Target specification starts with a "uri" directive:


       <b>uri</b> <b>&lt;protocol&gt;://[&lt;host&gt;[:&lt;port&gt;]]/&lt;naming</b> <b>context&gt;</b>
              The  "server"  directive  that  was allowed in the LDAP backend (although deprecated) has been
              completely discarded in the Meta backend.  The &lt;protocol&gt; part can be  anything  <!-- a --><b>ldap_initial</b><!-- /a -->-<font color="#ffffff" class="whiteout">ize(3)&nbsp;ldap_initialize(3)</font>
              <!-- a --><b>ize</b>(3)<!-- /a --> accepts ({ldap|ldaps|ldapi} and variants); &lt;host&gt; and &lt;port&gt; may be omitted, defaulting
              to whatever is set in <a href="ldap.conf.5.html#//apple_ref/doc/man/5/ldap.conf"><b>ldap.conf</b>(5)</a>.  The &lt;naming context&gt; part is mandatory.  It must end with
              one of the naming contexts defined for the backend, e.g.:

              suffix "<b>dc=foo,dc=com</b>"
              uri    "ldap://x.foo.com/dc=x,<b>dc=foo,dc=com</b>"

              The  &lt;naming context&gt; part doesn't need to be unique across the targets; it may also match one
              of the values of the "suffix" directive.  Multiple URIs may be defined in a  single  argument.
              The  URIs  must  be separated by TABs (e.g. '\t'; commas or spaces, unlike back-ldap, will not
              work, because they are legal in the &lt;naming context&gt;, and we don't  want  to  use  URL-encoded
              &lt;naming  context&gt;s),  and the additional URIs must have no &lt;naming context&gt; part.  This causes
              the underlying library to contact the first server of the list that responds.  For example, if
              <u>l1.foo.com</u> and <u>l2.foo.com</u> are shadows of the same server, the directive

              suffix "<b>dc=foo,dc=com</b>"
              uri    "ldap://l1.foo.com/<b>dc=foo,dc=com</b> ldap://l2.foo.com/"

              causes <u>l2.foo.com</u> to be contacted whenever <u>l1.foo.com</u> does not respond.


       <b>acl-authcDN</b> <b>&lt;administrative</b> <b>DN</b> <b>for</b> <b>access</b> <b>control</b> <b>purposes&gt;</b>
              DN  which  is  used to query the target server for acl checking, as in the LDAP backend; it is
              supposed to have read access on the target server to attributes used  on  the  proxy  for  acl
              checking.   There  is  no risk of giving away such values; they are only used to check permis-<font color="#ffffff" class="whiteout">sions.&nbsp;permissions.</font>
              sions.  <b>The</b> <b>acl-authcDN</b> <b>identity</b> <b>is</b> <b>by</b> <b>no</b> <b>means</b> <b>implicitly</b> <b>used</b> <b>by</b> <b>the</b> <b>proxy</b> <b>when</b>  <b>the</b>  <b>client</b>
              <b>connects</b> <b>anonymously.</b>


       <b>acl-passwd</b> <b>&lt;password&gt;</b>
              Password used with the <b>acl-authcDN</b> above.


       <b>bind-timeout</b> <b>&lt;microseconds&gt;</b>
              This  directive  defines the timeout, in microseconds, used when polling for response after an
              asynchronous bind connection.  The initial call to <a href="../man3/ldap_result.3.html#//apple_ref/doc/man/3/ldap_result">ldap_result(3)</a> is performed with  a  trade-<font color="#ffffff" class="whiteout">off&nbsp;tradeoff</font>
              off  timeout  of  100000  us;  if that results in a timeout exceeded, subsequent calls use the
              value provided with <b>bind-timeout</b>.  The default value is used  also  for  subsequent  calls  if
              <b>bind-timeout</b>  is  not  specified.  If set before any target specification, it affects all tar-<font color="#ffffff" class="whiteout">gets,&nbsp;targets,</font>
              gets, unless overridden by any per-target directive.


       <b>chase-referrals</b> <b>{YES|no}</b>
              enable/disable automatic referral chasing, which is delegated to the underlying libldap,  with
              rebinding  eventually  performed  if  the <b>rebind-as-user</b> directive is used.  The default is to
              chase referrals.  If set before any target specification, it affects all targets, unless over-<font color="#ffffff" class="whiteout">ridden&nbsp;overridden</font>
              ridden by any per-target directive.


       <b>default-target</b> <b>[&lt;target&gt;]</b>
              The  "default-target"  directive  can also be used during target specification.  With no argu-<font color="#ffffff" class="whiteout">ments&nbsp;arguments</font>
              ments it marks the current target as the default.  The optional number marks  target  &lt;target&gt;
              as the default one, starting from 1.  Target &lt;target&gt; must be defined.


       <b>idle-timeout</b> <b>&lt;time&gt;</b>
              This  directive  causes  a cached connection to be dropped an recreated after it has been idle
              for the specified time.  The value can be specified as

              [&lt;d&gt;d][&lt;h&gt;h][&lt;m&gt;m][&lt;s&gt;[s]]

              where &lt;d&gt;, &lt;h&gt;, &lt;m&gt; and &lt;s&gt; are respectively treated as days, hours, minutes and seconds.   If
              set before any target specification, it affects all targets, unless overridden by any per-tar-<font color="#ffffff" class="whiteout">get&nbsp;per-target</font>
              get directive.


       <b>map</b> <b>{attribute|objectclass}</b> <b>[&lt;local</b> <b>name&gt;|*]</b> <b>{&lt;foreign</b> <b>name&gt;|*}</b>
              This maps object classes and attributes as in the LDAP backend.  See <a href="slapd-ldap.5.html#//apple_ref/doc/man/5/slapd-ldap"><b>slapd-ldap</b>(5)</a>.


       <b>nretries</b> <b>{forever|never|&lt;nretries&gt;}</b>
              This directive defines how many times a bind should be retried in case of temporary failure in
              contacting  a  target.   If defined before any target specification, it applies to all targets
              (by default, <b>3</b> times); the global value can be overridden by redefinitions inside each  target
              specification.


       <b>pseudorootdn</b> <b>&lt;substitute</b> <b>DN</b> <b>in</b> <b>case</b> <b>of</b> <b>rootdn</b> <b>bind&gt;</b>
              This directive, if present, sets the DN that will be substituted to the bind DN if a bind with
              the backend's "rootdn" succeeds.  The true "rootdn" of the target server ought not be used; an
              arbitrary administrative DN should used instead.


       <b>pseudorootpw</b> <b>&lt;substitute</b> <b>password</b> <b>in</b> <b>case</b> <b>of</b> <b>rootdn</b> <b>bind&gt;</b>
              This  directive  sets  the  credential  that  will  be  used in case a bind with the backend's
              "rootdn" succeeds, and the bind is propagated to the target using the "pseudorootdn" DN.

              Note: cleartext credentials must be  supplied  here;  as  a  consequence,  using  the  pseudo-<font color="#ffffff" class="whiteout">rootdn/pseudorootpw&nbsp;pseudorootdn/pseudorootpw</font>
              rootdn/pseudorootpw directives is inherently unsafe.


       <b>rewrite*</b> <b>...</b>
              The rewrite options are described in the "REWRITING" section.


       <b>subtree-exclude</b> <b>&lt;DN&gt;</b>
              This directive instructs back-meta to ignore the current target for operations whose requestDN
              is subordinate to <b>DN</b>.  There may be multiple occurrences of the <b>subtree-exclude</b> directive  for
              each of the targets.


       <b>suffixmassage</b> <b>&lt;virtual</b> <b>naming</b> <b>context&gt;</b> <b>&lt;real</b> <b>naming</b> <b>context&gt;</b>
              All  the directives starting with "rewrite" refer to the rewrite engine that has been added to
              slapd.  The "suffixmassage" directive was introduced in the LDAP backend to allow suffix  mas-<font color="#ffffff" class="whiteout">saging&nbsp;massaging</font>
              saging while proxying.  It has been obsoleted by the rewriting tools.  However, both for back-<font color="#ffffff" class="whiteout">ward&nbsp;backward</font>
              ward compatibility and for ease of configuration when simple suffix massage  is  required,  it
              has  been preserved.  It wraps the basic rewriting instructions that perform suffix massaging.
              See the "REWRITING" section for a detailed list of the rewrite rules it implies.


       <b>t-f-support</b> <b>{NO|yes|discover}</b>
              enable if the  remote  server  supports  absolute  filters  (see  <u>draft-zeilenga-ldap-t-f</u>  for
              details).   If  set  to <b>discover</b>, support is detected by reading the remote server's root DSE.
              If set before any target specification, it affects all targets, unless overridden by any  per-<font color="#ffffff" class="whiteout">target&nbsp;pertarget</font>
              target directive.


       <b>timeout</b> <b>[{add|delete|modify|modrdn}=]&lt;seconds&gt;</b> <b>[...]</b>
              This directive allows to set per-database, per-target and per-operation timeouts.  If no oper-<font color="#ffffff" class="whiteout">ation&nbsp;operation</font>
              ation is specified, it affects all.  Currently, only write operations are  addressed,  because
              searches  can  already  be  limited  by  means  of the <b>limits</b> directive (see <a href="slapd.conf.5.html#//apple_ref/doc/man/5/slapd.conf"><b>slapd.conf</b>(5)</a> for
              details), and other operations are not supposed to incur into the need for timeouts.  Note: if
              the timelimit is exceeded, the operation is abandoned; the protocol does not provide any means
              to rollback the operation, so the client will not know if the operation  eventually  succeeded
              or  not.  If set before any target specification, it affects all targets, unless overridden by
              any per-target directive.


       <b>tls</b> <b>{[try-]start|[try-]propagate}</b>
              execute the StartTLS extended operation when the connection is initialized; only works if  the
              URI  directive  protocol scheme is not <b>ldaps://</b>.  <b>propagate</b> issues the StartTLS operation only
              if the original connection did.  The <b>try-</b> prefix instructs the proxy to continue operations if
              the  StartTLS operation failed; its use is highly deprecated.  If set before any target speci-<font color="#ffffff" class="whiteout">fication,&nbsp;specification,</font>
              fication, it affects all targets, unless overridden by any per-target directive.


<b>SCENARIOS</b>
       A powerful (and in some sense dangerous) rewrite engine has been added to  both  the  LDAP  and  Meta
       backends.   While the former can gain limited beneficial effects from rewriting stuff, the latter can
       become an amazingly powerful tool.

       Consider a couple of scenarios first.

       1)  Two  directory  servers  share  two  levels  of  naming  context;  say  "dc=a,dc=foo,dc=com"  and
       "dc=b,dc=foo,dc=com".  Then, an unambiguous Meta database can be configured as:

              database meta
              suffix   "<b>dc=foo,dc=com</b>"
              uri      "ldap://a.foo.com/dc=a,<b>dc=foo,dc=com</b>"
              uri      "ldap://b.foo.com/dc=b,<b>dc=foo,dc=com</b>"

       Operations  directed  to  a  specific target can be easily resolved because there are no ambiguities.
       The only operation that may resolve to multiple targets is a search  with  base  "dc=foo,dc=com"  and
       scope at least "one", which results in spawning two searches to the targets.

       2a)  Two  directory servers don't share any portion of naming context, but they'd present as a single
       DIT [Caveat: uniqueness of (massaged) entries among the two servers is assumed; integrity checks risk
       to  incur  in  excessive  overhead  and  have not been implemented].  Say we have "dc=bar,dc=org" and
       "o=Foo,c=US", and we'd like them to appear as branches of "dc=foo,dc=com",  say  "dc=a,dc=foo,dc=com"
       and "dc=b,dc=foo,dc=com".  Then we need to configure our Meta backend as:

              database      meta
              suffix        "dc=foo,dc=com"

              uri           "ldap://a.bar.com/<b>dc=a,dc=foo,dc=com</b>"
              suffixmassage "<b>dc=a,dc=foo,dc=com</b>" "dc=bar,dc=org"

              uri           "ldap://b.foo.com/<b>dc=b,dc=foo,dc=com</b>"
              suffixmassage "<b>dc=b,dc=foo,dc=com</b>" "o=Foo,c=US"

       Again,  operations  can  be  resolved without ambiguity, although some rewriting is required.  Notice
       that the virtual naming context of each target is a branch of the database's naming  context;  it  is
       rewritten  back  and  forth when operations are performed towards the target servers.  What "back and
       forth" means will be clarified later.

       When a search with base "dc=foo,dc=com" is attempted, if the scope is "base" it fails with  "no  such
       object";  in  fact,  the  common root of the two targets (prior to massaging) does not exist.  If the
       scope is "one", both targets are contacted with the base replaced by each target's base; the scope is
       derated  to "base".  In general, a scope "one" search is honored, and the scope is derated, only when
       the incoming base is at most one level lower of a target's naming context (prior to massaging).

       Finally, if the scope is "sub" the incoming base is replaced by each target's unmassaged naming  con-<font color="#ffffff" class="whiteout">text,&nbsp;context,</font>
       text, and the scope is not altered.

       2b) Consider the above reported scenario with the two servers sharing the same naming context:

              database      meta
              suffix        "<b>dc=foo,dc=com</b>"

              uri           "ldap://a.bar.com/<b>dc=foo,dc=com</b>"
              suffixmassage "<b>dc=foo,dc=com</b>" "dc=bar,dc=org"

              uri           "ldap://b.foo.com/<b>dc=foo,dc=com</b>"
              suffixmassage "<b>dc=foo,dc=com</b>" "o=Foo,c=US"

       All  the previous considerations hold, except that now there is no way to unambiguously resolve a DN.
       In this case, all the operations that require an unambiguous target selection will fail unless the DN
       is  already cached or a default target has been set.  Practical configurations may result as a combi-<font color="#ffffff" class="whiteout">nation&nbsp;combination</font>
       nation of all the above scenarios.

<b>ACLs</b>
       Note on ACLs: at present you may add whatever ACL rule you desire to to the Meta (and LDAP) backends.
       However,  the  meaning of an ACL on a proxy may require some considerations.  Two philosophies may be
       considered:

       a) the remote server dictates the permissions; the proxy simply passes back what  it  gets  from  the
       remote server.

       b) the remote server unveils "everything"; the proxy is responsible for protecting data from unautho-<font color="#ffffff" class="whiteout">rized&nbsp;unauthorized</font>
       rized access.

       Of course the latter sounds unreasonable, but it is not.  It is  possible  to  imagine  scenarios  in
       which  a  remote  host discloses data that can be considered "public" inside an intranet, and a proxy
       that connects it to the internet may impose additional  constraints.   To  this  purpose,  the  proxy
       should  be able to comply with all the ACL matching criteria that the server supports.  This has been
       achieved with regard to all the criteria supported by slapd except a special subtle case (please drop
       me a note if you can find other exceptions: &lt;ando@openldap.org&gt;).  The rule

              access to dn="&lt;dn&gt;" attr=&lt;attr&gt;
                     by dnattr=&lt;dnattr&gt; read
                     by * none

       cannot  be  matched  iff  the  attribute  that  is  being requested, &lt;attr&gt;, is NOT &lt;dnattr&gt;, and the
       attribute that determines membership, &lt;dnattr&gt;, has not been requested (e.g. in a search)

       In fact this ACL is resolved by slapd using the portion of entry it retrieved from the remote  server
       without requiring any further intervention of the backend, so, if the &lt;dnattr&gt; attribute has not been
       fetched, the match cannot be assessed because the attribute is not  present,  not  because  no  value
       matches the requirement!

       Note  on  ACLs and attribute mapping: ACLs are applied to the mapped attributes; for instance, if the
       attribute locally known as "foo" is mapped to "bar" on a remote server,  then  local  ACLs  apply  to
       attribute "foo" and are totally unaware of its remote name.  The remote server will check permissions
       for "bar", and the local server will possibly enforce additional restrictions to "foo".

<b>REWRITING</b>
       A string is rewritten according to a set of rules, called a `rewrite context'.  The rules  are  based
       on POSIX (''extended'') regular expressions (regex) with substring matching; basic variable substitu-<font color="#ffffff" class="whiteout">tion&nbsp;substitution</font>
       tion and map resolution of substrings is allowed by specific mechanisms detailed  in  the  following.
       The behavior of pattern matching/substitution can be altered by a set of flags.

       The underlying concept is to build a lightweight rewrite module for the slapd server (initially dedi-<font color="#ffffff" class="whiteout">cated&nbsp;dedicated</font>
       cated to the LDAP backend).

<b>Passes</b>
       An incoming string is matched against a set of rules.  Rules are made of a  regex  match  pattern,  a
       substitution  pattern  and  a set of actions, described by a set of flags.  In case of match a string
       rewriting is performed according to the substitution pattern  that  allows  to  refer  to  substrings
       matched  in  the incoming string.  The actions, if any, are finally performed.  The substitution pat-<font color="#ffffff" class="whiteout">tern&nbsp;pattern</font>
       tern allows map resolution of substrings.  A map is a generic object that maps a substitution pattern
       to  a  value.  The flags are divided in "Pattern matching Flags" and "Action Flags"; the former alter
       the regex match pattern behavior while the latter alter the action that is taken after  substitution.

<b>Pattern</b> <b>Matching</b> <b>Flags</b>
       <b>`C'</b>    honors case in matching (default is case insensitive)

       <b>`R'</b>    use POSIX ''basic'' regular expressions (default is ''extended'')

       <b>`M{n}'</b> allow  no more than <b>n</b> recursive passes for a specific rule; does not alter the max total count
              of passes, so it can only enforce a stricter limit for a specific rule.

<b>Action</b> <b>Flags</b>
       <b>`:'</b>    apply the rule once only (default is recursive)

       <b>`@'</b>    stop applying rules in case of match; the current rule is still applied  recursively;  combine
              with `:' to apply the current rule only once and then stop.

       <b>`#'</b>    stop current operation if the rule matches, and issue an `unwilling to perform' error.

       <b>`G{n}'</b> jump <b>n</b> rules back and forth (watch for loops!).  Note that `G{1}' is implicit in every rule.

       <b>`I'</b>    ignores  errors  in  rule;  this  means,  in case of error, e.g. issued by a map, the error is
              treated as a missed match.  The `unwilling to perform' is not overridden.

       <b>`U{n}'</b> uses <b>n</b> as return code if the rule matches; the flag does not alter the recursive  behavior  of
              the  rule,  so,  to have it performed only once, it must be used in combination with `:', e.g.
              <b>`:U{16}'</b> returns the value `16' after exactly one  execution  of  the  rule,  if  the  pattern
              matches.   As a consequence, its behavior is equivalent to `@', with the return code set to <b>n</b>;
              or, in other words, `@' is equivalent to `U{0}'.  By convention, the  freely  available  codes
              are above 16 included; the others are reserved.

       The ordering of the flags can be significant.  For instance: `IG{2}' means ignore errors and jump two
       lines ahead both in case of match and in case of error, while `G{2}I' means ignore errors,  but  jump
       two lines ahead only in case of match.

       More flags (mainly Action Flags) will be added as needed.

<b>Pattern</b> <b>matching:</b>
       See <!-- a --><b>regex</b>(7)<!-- /a --> and/or <a href="../man7/re_format.7.html#//apple_ref/doc/man/7/re_format"><b>re_format</b>(7)</a>.

<b>Substitution</b> <b>Pattern</b> <b>Syntax:</b>
       Everything starting with `%' requires substitution;

       the only obvious exception is `%%', which is left as is;

       the  basic  substitution is `%d', where `d' is a digit; 0 means the whole string, while 1-9 is a sub-<font color="#ffffff" class="whiteout">match;&nbsp;submatch;</font>
       match;

       a `%' followed by a `{' invokes an advanced substitution.  The pattern is:

              `%' `{' [ &lt;op&gt; ] &lt;name&gt; `(' &lt;substitution&gt; `)' `}'

       where &lt;name&gt; must be a legal name for the map, i.e.

              &lt;name&gt; ::= [a-z][a-z0-9]* (case insensitive)
              &lt;op&gt; ::= `&gt;' `|' `&amp;' `&amp;&amp;' `*' `**' `$'

       and &lt;substitution&gt; must be a legal substitution pattern, with no limits on the nesting level.

       The operators are:

       <b>&gt;</b>      sub context invocation; &lt;name&gt; must be a legal, already defined rewrite context name

       <b>|</b>      external command invocation; &lt;name&gt; must refer to a legal, already defined command  name  (NOT
              IMPL.)

       <b>&amp;</b>      variable assignment; &lt;name&gt; defines a variable in the running operation structure which can be
              dereferenced later; operator <b>&amp;</b> assigns a variable in the rewrite context  scope;  operator  <b>&amp;&amp;</b>
              assigns a variable that scopes the entire session, e.g. its value can be dereferenced later by
              other rewrite contexts

       <b>*</b>      variable dereferencing; &lt;name&gt; must refer to a variable that is defined and assigned  for  the
              running operation; operator <b>*</b> dereferences a variable scoping the rewrite context; operator <b>**</b>
              dereferences a variable scoping the whole session, e.g. the value  is  passed  across  rewrite
              contexts

       <b>$</b>      parameter  dereferencing; &lt;name&gt; must refer to an existing parameter; the idea is to make some
              run-time parameters set by the system available to the rewrite  engine,  as  the  client  host
              name, the bind DN if any, constant parameters initialized at config time, and so on; no param-<font color="#ffffff" class="whiteout">eter&nbsp;parameter</font>
              eter is currently set by either <b>back-ldap</b> or <b>back-meta</b>, but constant parameters can be defined
              in the configuration file by using the <b>rewriteParam</b> directive.

       Substitution  escaping  has  been delegated to the `%' symbol, which is used instead of `\' in string
       substitution patterns because `\' is already escaped by slapd's low level parsing routines; as a con-<font color="#ffffff" class="whiteout">sequence,&nbsp;consequence,</font>
       sequence,  regex  escaping  requires  two  `\'  symbols,  e.g.  `<b>.*\.foo\.bar</b>'  must  be  written  as
       `<b>.*\\.foo\\.bar</b>'.

<b>Rewrite</b> <b>context:</b>
       A rewrite context is a set of rules which are applied in sequence.  The basic  idea  is  to  have  an
       application  initialize  a  rewrite  engine (think of Apache's mod_rewrite ...) with a set of rewrite
       contexts; when string rewriting is required, one invokes the appropriate  rewrite  context  with  the
       input string and obtains the newly rewritten one if no errors occur.

       Each  basic server operation is associated to a rewrite context; they are divided in two main groups:
       client -&gt; server and server -&gt; client rewriting.

       client -&gt; server:

              (default)            if defined and no specific context
                                   is available
              bindDN               bind
              searchBase           search
              searchFilter         search
              searchFilterAttrDN   search
              compareDN            compare
              compareAttrDN        compare AVA
              addDN                add
              addAttrDN            add AVA
              modifyDN             modify
              modifyAttrDN         modify AVA
              modrDN               modrdn
              newSuperiorDN        modrdn
              deleteDN             delete
              exopPasswdDN         password modify extended operation DN if proxy

       server -&gt; client:

              searchResult         search (only if defined; no default;
                                   acts on DN and DN-syntax attributes
                                   of search results)
              searchAttrDN         search AVA
              matchedDN            all ops (only if applicable)


<b>Basic</b> <b>configuration</b> <b>syntax</b>
       <b>rewriteEngine</b> <b>{</b> <b>on</b> <b>|</b> <b>off</b> <b>}</b>
              If `on', the requested rewriting is performed; if `off', no rewriting takes place (an easy way
              to stop rewriting without altering too much the configuration file).

       <b>rewriteContext</b> <b>&lt;context</b> <b>name&gt;</b> <b>[</b> <b>alias</b> <b>&lt;aliased</b> <b>context</b> <b>name&gt;</b> <b>]</b>
              &lt;Context  name&gt; is the name that identifies the context, i.e. the name used by the application
              to refer to the set of rules it contains.  It is used also to reference sub contexts in string
              rewriting.  A context may alias another one.  In this case the alias context contains no rule,
              and any reference to it will result in accessing the aliased one.

       <b>rewriteRule</b> <b>&lt;regex</b> <b>match</b> <b>pattern&gt;</b> <b>&lt;substitution</b> <b>pattern&gt;</b> <b>[</b> <b>&lt;flags&gt;</b> <b>]</b>
              Determines how a string can be rewritten if a  pattern  is  matched.   Examples  are  reported
              below.

<b>Additional</b> <b>configuration</b> <b>syntax:</b>
       <b>rewriteMap</b> <b>&lt;map</b> <b>type&gt;</b> <b>&lt;map</b> <b>name&gt;</b> <b>[</b> <b>&lt;map</b> <b>attrs&gt;</b> <b>]</b>
              Allows  to  define  a map that transforms substring rewriting into something else.  The map is
              referenced inside the substitution pattern of a rule.

       <b>rewriteParam</b> <b>&lt;param</b> <b>name&gt;</b> <b>&lt;param</b> <b>value&gt;</b>
              Sets a value with global scope, that can be dereferenced by the command `%{$paramName}'.

       <b>rewriteMaxPasses</b> <b>&lt;number</b> <b>of</b> <b>passes&gt;</b> <b>[&lt;number</b> <b>of</b> <b>passes</b> <b>per</b> <b>rule&gt;]</b>
              Sets the maximum number of total rewriting passes that can be performed in  a  single  rewrite
              operation  (to  avoid  loops).  A safe default is set to 100; note that reaching this limit is
              still treated as a success; recursive invocation of rules is simply  interrupted.   The  count
              applies  to  the  rewriting operation as a whole, not to any single rule; an optional per-rule
              limit can be set.  This limit is overridden by  setting  specific  per-rule  limits  with  the
              `M{n}' flag.

<b>Configuration</b> <b>examples:</b>
       # set to `off' to disable rewriting
       rewriteEngine on

       # the rules the "suffixmassage" directive implies
       rewriteEngine on
       # all dataflow from client to server referring to DNs
       rewriteContext default
       rewriteRule "(.*)&lt;virtualnamingcontext&gt;$" "%1&lt;realnamingcontext&gt;" ":"
       # empty filter rule
       rewriteContext searchFilter
       # all dataflow from server to client
       rewriteContext searchResult
       rewriteRule "(.*)&lt;realnamingcontext&gt;$" "%1&lt;virtualnamingcontext&gt;" ":"
       rewriteContext searchAttrDN alias searchResult
       rewriteContext matchedDN alias searchResult

       # Everything defined here goes into the `default' context.
       # This rule changes the naming context of anything sent
       # to `dc=home,dc=net' to `dc=OpenLDAP, dc=org'

       rewriteRule "(.*)dc=home,[ ]?dc=net"
                   "%1dc=OpenLDAP, dc=org"  ":"

       # since a pretty/normalized DN does not include spaces
       # after rdn separators, e.g. `,', this rule suffices:

       rewriteRule "(.*)dc=home,dc=net"
                   "%1dc=OpenLDAP,dc=org"  ":"

       # Start a new context (ends input of the previous one).
       # This rule adds blanks between DN parts if not present.
       rewriteContext  addBlanks
       rewriteRule     "(.*),([^ ].*)" "%1, %2"

       # This one eats blanks
       rewriteContext  eatBlanks
       rewriteRule     "(.*),[ ](.*)" "%1,%2"

       # Here control goes back to the default rewrite
       # context; rules are appended to the existing ones.
       # anything that gets here is piped into rule `addBlanks'
       rewriteContext  default
       rewriteRule     ".*" "%{&gt;addBlanks(%0)}" ":"

       # Rewrite the search base according to `default' rules.
       rewriteContext  searchBase alias default

       # Search results with OpenLDAP DN are rewritten back with
       # `dc=home,dc=net' naming context, with spaces eaten.
       rewriteContext  searchResult
       rewriteRule     "(.*[^ ]?)[ ]?dc=OpenLDAP,[ ]?dc=org"
                       "%{&gt;eatBlanks(%1)}dc=home,dc=net"    ":"

       # Bind with email instead of full DN: we first need
       # an ldap map that turns attributes into a DN (the
       # argument used when invoking the map is appended to
       # the URI and acts as the filter portion)
       rewriteMap ldap attr2dn "ldap://host/dc=my,dc=org?dn?sub"

       # Then we need to detect DN made up of a single email,
       # e.g. `mail=someone@example.com'; note that the rule
       # in case of match stops rewriting; in case of error,
       # it is ignored.  In case we are mapping virtual
       # to real naming contexts, we also need to rewrite
       # regular DNs, because the definition of a bindDn
       # rewrite context overrides the default definition.
       rewriteContext bindDN
       rewriteRule "^mail=[^,]+@[^,]+$" "%{attr2dn(%0)}" ":@I"

       # This is a rather sophisticated example. It massages a
       # search filter in case who performs the search has
       # administrative privileges.  First we need to keep
       # track of the bind DN of the incoming request, which is
       # stored in a variable called `binddn' with session scope,
       # and left in place to allow regular binding:
       rewriteContext  bindDN
       rewriteRule     ".+" "%{&amp;&amp;binddn(%0)}%0" ":"

       # A search filter containing `uid=' is rewritten only
       # if an appropriate DN is bound.
       # To do this, in the first rule the bound DN is
       # dereferenced, while the filter is decomposed in a
       # prefix, in the value of the `uid=&lt;arg&gt;' AVA, and
       # in a suffix. A tag `&lt;&gt;' is appended to the DN.
       # If the DN refers to an entry in the `ou=admin' subtree,
       # the filter is rewritten OR-ing the `uid=&lt;arg&gt;' with
       # `cn=&lt;arg&gt;'; otherwise it is left as is. This could be
       # useful, for instance, to allow apache's auth_ldap-1.4
       # module to authenticate users with both `uid' and
       # `cn', but only if the request comes from a possible
       # `cn=Web auth,ou=admin,dc=home,dc=net' user.
       rewriteContext searchFilter
       rewriteRule "(.*\\()uid=([a-z0-9_]+)(\\).*)"
         "%{**binddn}&lt;&gt;%{&amp;prefix(%1)}%{&amp;arg(%2)}%{&amp;suffix(%3)}"
         ":I"
       rewriteRule "[^,]+,ou=admin,dc=home,dc=net"
         "%{*prefix}|(uid=%{*arg})(cn=%{*arg})%{*suffix}" ":@I"
       rewriteRule ".*&lt;&gt;" "%{*prefix}uid=%{*arg}%{*suffix}" ":"

       # This example shows how to strip unwanted DN-valued
       # attribute values from a search result; the first rule
       # matches DN values below "ou=People,dc=example,dc=com";
       # in case of match the rewriting exits successfully.
       # The second rule matches everything else and causes
       # the value to be rejected.
       rewriteContext searchResult
       rewriteRule ".*,ou=People,dc=example,dc=com" "%0" ":@"
       rewriteRule ".*" "" "#"

<b>LDAP</b> <b>Proxy</b> <b>resolution</b> <b>(a</b> <b>possible</b> <b>evolution</b> <b>of</b> <a href="slapd-ldap.5.html#//apple_ref/doc/man/5/slapd-ldap"><b>slapd-ldap(5)</b></a><b>):</b>
       In case the rewritten DN is an LDAP URI, the operation is initiated towards the host[:port] indicated
       in the uri, if it does not refer to the local server.  E.g.:

         rewriteRule '^cn=root,.*' '%0'                     'G{3}'
         rewriteRule '^cn=[a-l].*' 'ldap://ldap1.my.org/%0' ':@'
         rewriteRule '^cn=[m-z].*' 'ldap://ldap2.my.org/%0' ':@'
         rewriteRule '.*'          'ldap://ldap3.my.org/%0' ':@'

       (Rule 1 is simply there to illustrate the `G{n}' action; it could have been written:

         rewriteRule '^cn=root,.*' 'ldap://ldap3.my.org/%0' ':@'

       with the advantage of saving one rewrite pass ...)


<b>ACCESS</b> <b>CONTROL</b>
       The <b>meta</b> backend does not honor all ACL semantics  as  described  in  <a href="slapd.access.5.html#//apple_ref/doc/man/5/slapd.access"><b>slapd.access</b>(5)</a>.   In  general,
       access  checking  is  delegated  to the remote <!-- a -->server(s)<!-- /a -->.  Only <b>read</b> <b>(=r)</b> access to the <b>entry</b> pseudo-<font color="#ffffff" class="whiteout">attribute&nbsp;pseudoattribute</font>
       attribute and to the other attribute values of the entries returned by the <b>search</b> operation  is  hon-<font color="#ffffff" class="whiteout">ored,&nbsp;honored,</font>
       ored, which is performed by the frontend.


<b>PROXY</b> <b>CACHE</b> <b>OVERLAY</b>
       The  proxy  cache  overlay allows caching of LDAP search requests (queries) in a local database.  See
       <a href="slapo-pcache.5.html#//apple_ref/doc/man/5/slapo-pcache"><b>slapo-pcache</b>(5)</a> for details.

<b>FILES</b>
       /etc/openldap/slapd.conf
              default slapd configuration file

<b>SEE</b> <b>ALSO</b>
       <a href="slapd.conf.5.html#//apple_ref/doc/man/5/slapd.conf"><b>slapd.conf</b>(5)</a>, <a href="slapd-ldap.5.html#//apple_ref/doc/man/5/slapd-ldap"><b>slapd-ldap</b>(5)</a>, <a href="slapo-pcache.5.html#//apple_ref/doc/man/5/slapo-pcache"><b>slapo-pcache</b>(5)</a>, <a href="../man8/slapd.8.html#//apple_ref/doc/man/8/slapd"><b>slapd</b>(8)</a>, <!-- a --><b>regex</b>(7)<!-- /a -->, <a href="../man7/re_format.7.html#//apple_ref/doc/man/7/re_format"><b>re_format</b>(7)</a>.

<b>AUTHOR</b>
       Pierangelo Masarati, based on back-ldap by Howard Chu



OpenLDAP 2.3.27                                  2006/08/19                                    SLAPD-META(5)
</tt></pre>
</td></tr></table>
	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Darwin/Reference/ManPages/man5/slapd-meta.5.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Darwin/Reference/ManPages/man5/slapd-meta.5.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Darwin/Reference/ManPages/man5/slapd-meta.5.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

</body></html>
