<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>Bitblitz - /Source/BlendUtils.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxGraphicsImaging-date.html">Graphics & Imaging</a> &gt; <A HREF="javascript:location.replace('index.html');">Bitblitz</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/GraphicsImaging/index.html" target="_blank">Reference Library > Graphics & Imaging</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">Bitblitz</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/Source/BlendUtils.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/LibHeaders/AlertDlogUtils.h</option>
<option value="listing2.html">/LibHeaders/AlrtDlogTools.h</option>
<option value="listing3.html">/LibHeaders/AutoCursor.h</option>
<option value="listing4.html">/LibHeaders/ColorTools.h</option>
<option value="listing5.html">/LibHeaders/MacHeaders.h</option>
<option value="listing6.html">/LibHeaders/MainUtils.h</option>
<option value="listing7.html">/LibHeaders/PictUtils.h</option>
<option value="listing8.html">/LibHeaders/WCenter.h</option>
<option value="listing9.html">/Resources/AlertDlogUtils.r</option>
<option value="listing10.html">/Resources/BitBlitz.r</option>
<option value="listing11.html">/Source/BitBlitz.c</option>
<option value="listing12.html">/Source/BitBlitz.h</option>
<option value="listing13.html">/Source/BlendUtils.c</option>
<option value="listing14.html">/Source/BlendUtils.h</option>
<option value="listing15.html">/Source/MainStuff.c</option>
<option value="listing16.html">/Source/MainStuff.h</option>
<option value="listing17.html">/Source/OffscreenUtils.c</option>
<option value="listing18.html">/Source/OffscreenUtils.h</option></select>
				</p>
				</form>
				<p><strong><a href="Bitblitz.zip">Download Sample</a></strong> (&#147;Bitblitz.zip&#148;, 92.9K)<BR>
<strong><a href="Bitblitz.dmg">Download Sample</a></strong> (&#147;Bitblitz.dmg&#148;, 169.3K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*--------------------------------------------------------------------------------------////  File:      BlendProcs.c////  Contents:  Procedures that render blended fills.//////  By Georgiann (&quot;George&quot;) Delaney//  &copy;\xCA1989 - 1990, Apple Computer, Inc.////--------------------------------------------------------------------------------------*/#pragma segment BlendSeg#include &quot;MacHeaders.h&quot;/*--------------------------------------------------------------------------------------*//*  Constants  */#define  kGrayPatternRsrc  50#define  kNumGrayPatterns  50/*--------------------------------------------------------------------------------------*//*  Macro definitions  */#define  RECT_BLEND_BAND_COUNT(span,bandWidth)      (((span-bandWidth)/2)/bandWidth)#define  RECT_BLEND_BAND_INC(span,bandCount,bandWidth)  (((span-bandWidth)/2)/bandCount)#define  RECT_BLEND_STEP(span,bandWidth)        (65535/(((span/2)-(bandWidth/2))/bandWidth))#define  LINEAR_BLEND_BAND_COUNT(span,bandWidth)    (span/bandWidth)#define  LINEAR_BLEND_STEP(span,bandWidth)        (65535/(span/bandWidth))#define  MIN(x,y)    (((x) &lt; (y)) ? (x) : (y))#define  MAX(x,y)    (((x) &gt; (y)) ? (x) : (y))/*--------------------------------------------------------------------------------------*/void  HLSRectBlend(Rect *boundRect, short saturation)/*  //  This procedure fills the specified rect with a concentric rectangular HLS blend //  at the specified saturation.  The band size used for this fill is 1 pixel.  It is //  assumed that the desired port as well as any desired clipping has already been set.*/{  RGBColor  holdRGB,theRGB;  HSVColor  theHSV;  short    blendStep;  short    i;  short    span;  Rect    tempRect;     tempRect  = *boundRect;          /*  calculate the diameter of the specified rect  */  span      = MIN((tempRect.right-tempRect.left)/2, (tempRect.bottom - tempRect.top)/2);        /*  calculate the color increment for each band  */  blendStep = 65536 / span;          /*  save off the current RGB  */  GetForeColor(&amp;holdRGB);          /*  set the initial color  */  theHSV.value     = 65535;  theHSV.saturation   = saturation;  theHSV.hue       =  0;          /*  Generate the blend by converting the hls (hsv in mac terms) to           its RGB equivalent.  Set the forecolor to this RGB value.  Paint          the rect.  Then increment the HLS value and band rect for the next          iteration          */  for (i=0; i&lt;span; i++)  {    HSV2RGB(&amp;theHSV,&amp;theRGB);    RGBForeColor(&amp;theRGB);    PaintRect(&amp;tempRect);    theHSV.hue += blendStep;    tempRect.top    +=1;    tempRect.left   +=1;    tempRect.right  -=1;    tempRect.bottom -=1;    }            /*  restore the original RGB  */  RGBForeColor(&amp;holdRGB);}/*--------------------------------------------------------------------------------------*/void  HLSVLinearBlend(Rect *boundRect, short saturation)/*  //  This procedure fills the specified rect with a vertical HLS blend //  at the specified saturation.  The band size used for this fill is 1 pixel.  It is //  assumed that the desired port as well as any desired clipping has already been set.*/{  RGBColor  holdRGB,theRGB;  HSVColor  theHSV;  short    blendStep;  short    height;  Rect    tempRect;  short    i;     tempRect = *boundRect;              /*  calculate the vertical distance the blend is to cover  */  height   = tempRect.bottom - tempRect.top;          /*  calculate the color increment for each band  */  blendStep = 65535 / height;                /*  save off the current RGB  */  GetForeColor(&amp;holdRGB);        /*  set the initial color  */  theHSV.value     = 65535;  theHSV.saturation   = saturation;  theHSV.hue       =  0;          /*  Initialize the rectangle that specifies the first band of the blend   */  tempRect.bottom = tempRect.top + 1;          /*  Generate the blend by converting the hls (hsv in mac terms) to           its RGB equivalent.  Set the forecolor to this RGB value.  Paint          the rect.  Then increment the HLS value and offset the band rect for           the next iteration        */  for (i=0; i&lt;height; i++)  {    HSV2RGB(&amp;theHSV,&amp;theRGB);    RGBForeColor(&amp;theRGB);    PaintRect(&amp;tempRect);    theHSV.hue += blendStep;    tempRect.top    +=1;    tempRect.bottom +=1;    }        /*  restore the original RGB  */  RGBForeColor(&amp;holdRGB);}/*--------------------------------------------------------------------------------------*/void  HLSHLinearBlend(Rect *boundRect, short saturation)/*  //  This procedure fills the specified rect with a horizontal HLS blend //  at the specified saturation.  The band size used for this fill is 1 pixel.  It is //  assumed that the desired port as well as any desired clipping has already been set.*/{  RGBColor  holdRGB,theRGB;  HSVColor  theHSV;  short    blendStep;  short    width;  Rect    tempRect;  short    i;     tempRect = *boundRect;          /*  calculate the horizontal distance the blend is to cover  */  width   = tempRect.right-tempRect.left;          /*  calculate the color increment for each band  */  blendStep = 65535 / width;                /*  save off the current RGB  */  GetForeColor(&amp;holdRGB);        /*  set the initial color  */  theHSV.value     = 65535;  theHSV.saturation   = saturation;  theHSV.hue       =  0;          /*  Initialize the rectangle that specifies the first band of the blend   */  tempRect.right = tempRect.left + 1;          /*  Generate the blend by converting the hls (hsv in mac terms) to           its RGB equivalent.  Set the forecolor to this RGB value.  Paint          the rect.  Then increment the HLS value and offset the band rect for           the next iteration        */  for (i=0; i&lt;width; i++)  {    HSV2RGB(&amp;theHSV,&amp;theRGB);    RGBForeColor(&amp;theRGB);    PaintRect(&amp;tempRect);    theHSV.hue      += blendStep;    tempRect.left  +=1;    tempRect.right +=1;    }        /*  restore the original RGB  */  RGBForeColor(&amp;holdRGB);}/*--------------------------------------------------------------------------------------*/void  GrayRectBlend(Rect *boundRect)/*  //  This procedure fills the specified rect with a concentric rectangular gray scale blend //  from black to white.  The band size used for this fill is 1 pixel.  It is //  assumed that the desired port as well as any desired clipping has already been set.*/{  RGBColor  holdRGB,theRGB;  short    blendStep;  short    i;  short    span;  Rect    tempRect;     tempRect   = *boundRect;          /*  calculate the diameter of the specified rect  */  span      = MIN((tempRect.right-tempRect.left)/2, (tempRect.bottom - tempRect.top)/2);        /*  calculate the color increment for each band  */  blendStep = 65536 / span;          /*  save off the current RGB color  */  GetForeColor(&amp;holdRGB);          /*  set the initial color  */  theRGB.red = theRGB.green = theRGB.blue = 0;          /*  Generate the blend by seting the forecolor to the RGB value.  Paint          the rect.  Then increment the RGB value and band rect for the next          iteration        */  for (i=0; i&lt;span; i++)  {    RGBForeColor(&amp;theRGB);    PaintRect(&amp;tempRect);    theRGB.red = theRGB.green = theRGB.blue = theRGB.red + blendStep;    tempRect.top    +=1;    tempRect.left   +=1;    tempRect.right  -=1;    tempRect.bottom -=1;    }            /*  restore the original RGB  */  RGBForeColor(&amp;holdRGB);}/*--------------------------------------------------------------------------------------*/void  GrayVLinearBlend(Rect *boundRect)/*    //  This procedure fills the specified rect with a vertical gray scale blend //  from black to white.  The band size used for this fill is 1 pixel.  It is //  assumed that the desired port as well as any desired clipping has already been set.*/{  RGBColor  holdRGB,theRGB;  short    blendStep;  short    i;  short    height;  Rect    tempRect;     tempRect  = *boundRect;        /*  calculate the vertical distance the blend is to cover  */  height    = tempRect.bottom - tempRect.top;        /*  calculate the color increment for each band  */  blendStep = 65535 / height;          /*  save off the current RGB color  */  GetForeColor(&amp;holdRGB);        /*  set the initial color  */  theRGB.red = theRGB.green = theRGB.blue = 0;          /*  Initialize the rectangle that specifies the first band of the blend   */  tempRect.bottom = tempRect.top + 1;          /*  Generate the blend by setting the forecolor to this RGB value.  Paint          the rect.  Then increment the RGB value and offset the band rect for           the next iteration        */  for (i=0; i&lt;height; i++)  {    RGBForeColor(&amp;theRGB);    PaintRect(&amp;tempRect);    theRGB.red = theRGB.green = theRGB.blue = theRGB.red + blendStep;    tempRect.top    +=1;    tempRect.bottom +=1;    }        /*  restore the original RGB  */  RGBForeColor(&amp;holdRGB);}/*--------------------------------------------------------------------------------------*/void  GrayHLinearBlend(Rect *boundRect)/*  //  This procedure fills the specified rect with a horizontal gray scale blend //  from black to white.  The band size used for this fill is 1 pixel.  It is //  assumed that the desired port as well as any desired clipping has already been set.*/{  RGBColor  holdRGB,theRGB;  short    blendStep;  short    i;  short    width;  Rect    tempRect;     tempRect  = *boundRect;        /*  calculate the horizontal distance the blend is to cover  */  width     = tempRect.right-tempRect.left;        /*  calculate the color increment for each band  */  blendStep = 65535 / width;          /*  save off the current RGB color  */  GetForeColor(&amp;holdRGB);        /*  set the initial color  */  theRGB.red = theRGB.green = theRGB.blue = 0;          /*  Initialize the rectangle that specifies the first band of the blend   */  tempRect.right = tempRect.left + 1;          /*  Generate the blend by setting the forecolor to this RGB value.  Paint          the rect.  Then increment the RGB value and offset the band rect for           the next iteration        */  for (i=0; i&lt;width; i++)  {    RGBForeColor(&amp;theRGB);    PaintRect(&amp;tempRect);    theRGB.red = theRGB.green = theRGB.blue = theRGB.red + blendStep;    tempRect.left  +=1;    tempRect.right +=1;    }        /*  restore the original RGB  */  RGBForeColor(&amp;holdRGB);}/*--------------------------------------------------------------------------------------*/void  GrayPatRectBlend(Rect *boundRect)/*  //  This procedure fills the specified rect with a concentric rectangular gray scale pattern blend//  from black to white.  The band size used for this fill is calculated by dividing the shorter //  the horizontal and vertical diameters of the specified rect by the number of gray patterns in //  the gray pattern resource.  It is assumed that the desired port as well as any desired clipping//  has already been set.*/{  register  i;  double    bandWidth;  double    distance;  Rect    origRect,tempRect;  Pattern    thePat;        origRect = tempRect  = *boundRect;          /*  calculate the width of each band  */  bandWidth = (double)(MIN((tempRect.right-tempRect.left)/2, (tempRect.bottom-tempRect.top)/2)) / (double)(kNumGrayPatterns+1);    distance  = bandWidth;          /*  There is a pattern resource consisting of 64 shades of gray in MacLib.rsrc         //  that gives a pretty good approximation of a gray ramp from white to black.        //  The following loop performs the actual imaging of the ramp's 64 gray bands.        */  for (i=kNumGrayPatterns; i&gt;=1; i--)  {    GetIndPattern(&amp;thePat, kGrayPatternRsrc, i);      FillRect(&amp;tempRect,thePat);        distance  += bandWidth;    tempRect.top    = origRect.top    + distance;    tempRect.left   = origRect.left   + distance;    tempRect.right  = origRect.right  - distance;    tempRect.bottom = origRect.bottom - distance;    }}/*--------------------------------------------------------------------------------------*/void  GrayPatVLinearBlend(Rect *boundRect)/*  //  This procedure fills the specified rect with a vertical gray scale pattern blend//  from black to white.  The band size used for this fill is calculated by dividing the width//  of the specified blend by the number of gray patterns in the gray pattern resource.  It is //  assumed that the desired port as well as any desired clipping has already been set.*/{  register  i;  double    theTop;  double    bandHeight;  double    distance;  Rect    tempRect;  Pattern    thePat;     tempRect  = *boundRect;          /*  silly, but saves a pointer dereference in the blend loop  */  theTop    = (double)tempRect.top;            /*  calculate the width of each band  */  bandHeight = ((double)(tempRect.bottom-tempRect.top)) / (double)kNumGrayPatterns;          /*  Initialize the rectangle that specifies the first band of the blend   */  tempRect.bottom = tempRect.top + bandHeight;  distance      = bandHeight;          /*  There is a pattern resource consisting of 64 shades of gray in MacLib.rsrc         //  that gives a pretty good approximation of a gray ramp from white to black.        //  The following loop performs the actual imaging of the ramp's 64 gray bands.        */  for (i=kNumGrayPatterns; i&gt;1; i--)  {    GetIndPattern(&amp;thePat, kGrayPatternRsrc, i);      FillRect(&amp;tempRect,thePat);    distance       += bandHeight;    tempRect.top     = tempRect.bottom;    tempRect.bottom  = (short)(theTop + distance);    }  tempRect.bottom  = boundRect-&gt;bottom;  GetIndPattern(&amp;thePat,kGrayPatternRsrc,1);  FillRect(&amp;tempRect,thePat);}/*--------------------------------------------------------------------------------------*/void  GrayPatHLinearBlend(Rect *boundRect)/*  //  This procedure fills the specified rect with a horizontal gray scale pattern blend//  from black to white.  The band size used for this fill is calculated by dividing the width//  of the specified blend by the number of gray patterns in the gray pattern resource.  It is //  assumed that the desired port as well as any desired clipping has already been set.*/{  register  i;  double    farLeft;  double    bandWidth;  double    distance;  Rect    tempRect;  Pattern    thePat;     tempRect  = *boundRect;          /*  silly, but saves a pointer dereference in the blend loop  */  farLeft    = (double)tempRect.left;            /*  calculate the width of each band  */  bandWidth = ((double)(tempRect.right-tempRect.left)) / (double)kNumGrayPatterns;          /*  Initialize the rectangle that specifies the first band of the blend   */  tempRect.right = tempRect.left + bandWidth;  distance     = bandWidth;          /*  There is a pattern resource consisting of 64 shades of gray in MacLib.rsrc         //  that gives a pretty good approximation of a gray ramp from white to black.        //  The following loop performs the actual imaging of the ramp's 64 gray bands.        */  for (i=kNumGrayPatterns; i&gt;1; i--)  {    GetIndPattern(&amp;thePat, kGrayPatternRsrc, i);      FillRect(&amp;tempRect,thePat);    distance      += bandWidth;    tempRect.left   = tempRect.right;    tempRect.right  = (short)(farLeft + distance);    }  tempRect.right  = boundRect-&gt;right;  GetIndPattern(&amp;thePat,kGrayPatternRsrc,1);  FillRect(&amp;tempRect,thePat);}</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/Bitblitz/listing13.html%3Fid%3DDTS10000066-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/Bitblitz/listing13.html%3Fid%3DDTS10000066-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/Bitblitz/listing13.html%3Fid%3DDTS10000066-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>