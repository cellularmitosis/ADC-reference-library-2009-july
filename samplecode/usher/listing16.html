<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>usher - /sources/UsherBroadcast.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxQuickTime-date.html">QuickTime</a> &gt; <A HREF="javascript:location.replace('index.html');">usher</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/QuickTime/index.html" target="_blank">Reference Library > QuickTime</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">usher</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/sources/UsherBroadcast.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/notes/usingusher.htm</option>
<option value="listing2.html">/sources/AppSupport.c</option>
<option value="listing3.html">/sources/AppSupport.h</option>
<option value="listing4.html">/sources/MovieSourcing.c</option>
<option value="listing5.html">/sources/MovieSourcing.h</option>
<option value="listing6.html">/sources/PresInfoWindow.c</option>
<option value="listing7.html">/sources/PresInfoWindow.h</option>
<option value="listing8.html">/sources/PresinfoWindow.r</option>
<option value="listing9.html">/sources/QTSSampleCodeUtils.c</option>
<option value="listing10.html">/sources/QTSSampleCodeUtils.h</option>
<option value="listing11.html">/sources/SimplePres.c</option>
<option value="listing12.html">/sources/SimplePres.h</option>
<option value="listing13.html">/sources/SourcingSupport.c</option>
<option value="listing14.html">/sources/SourcingSupport.h</option>
<option value="listing15.html">/sources/usher.r</option>
<option value="listing16.html">/sources/UsherBroadcast.c</option>
<option value="listing17.html">/sources/UsherBroadcast.h</option>
<option value="listing18.html">/sources/UsherCarbon.r</option>
<option value="listing19.html">/sources/UsherCommands.h</option>
<option value="listing20.html">/sources/UsherMinWindow.c</option>
<option value="listing21.html">/sources/UsherMinWindow.h</option>
<option value="listing22.html">/sources/UsherMinWindow.r</option>
<option value="listing23.html">/sources/UsherNew.c</option>
<option value="listing24.html">/sources/UsherNew.h</option>
<option value="listing25.html">/sources/usherRezDefines.h</option>
<option value="listing26.html">/sources/WindowSupport.c</option>
<option value="listing27.html">/sources/WindowSupport.h</option>
<option value="listing28.html">/UsherReleaseNotes.txt</option></select>
				</p>
				</form>
				<p><strong><a href="usher.zip">Download Sample</a></strong> (&#147;usher.zip&#148;, 212.3K)<BR>
<strong><a href="usher.dmg">Download Sample</a></strong> (&#147;usher.dmg&#148;, 293.2K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*  File:    UsherBroadcast.c  Copyright:  &copy; 2000-2001 by Apple Computer, Inc., all rights reserved.*/#include &lt;ConditionalMacros.h&gt;#include &lt;Files.h&gt;#include &lt;Resources.h&gt;#include &lt;ToolUtils.h&gt;#include &lt;string.h&gt;#include &lt;QuicktimeComponents.h&gt;#include &lt;MoviesFormat.h&gt;#include &lt;Movies.h&gt;#include &lt;QuickTimeStreaming.h&gt;#include &lt;QTStreamingComponents.h&gt;#include &quot;AppSupport.h&quot;#include &quot;QTSSampleCodeUtils.h&quot;#include &quot;SimplePres.h&quot;#include &quot;SourcingSupport.h&quot;#include &quot;WindowSupport.h&quot;#include &quot;UsherBroadcast.h&quot;#include &quot;UsherRezDefines.h&quot;#include &quot;UsherCommands.h&quot;  // ---------------------------------------------------------------------------//    D E F I N I T I O N S// ---------------------------------------------------------------------------// ---------------------------------------------------------------------------//    P R O T O T Y P E S// ---------------------------------------------------------------------------static void UsherBroadcastPriv_SetNameFromFile(UsherBroadcast *inBroadcast, const FSSpec *inFileSpec);// ----- commands -----static OSErr UsherBroadcastPriv_GetBroadcastName(UsherBroadcast *inBroadcast, UsherBroadcastStringParams *inParams);static OSErr UsherBroadcastPriv_GetStateString(UsherBroadcast *inBroadcast, UsherBroadcastStringParams *inParams);static OSErr UsherBroadcastPriv_GetBroadcastTime(UsherBroadcast *inBroadcast, UsherBroadcastTimeParams *inTimeParams);// ----- notifications -----static ComponentResult _UsherBroadcastNotification(ComponentResult inErr, OSType inNotificationType,                void *inNotificationParams, void *inRefCon);static ComponentResult UsherBroadcastPriv_HandleErrorNotification(UsherBroadcast *inBroadcast,      ComponentResult inErr, QTSErrorParams *inErrorParams);// ----- infrastructure support -----static void UsherBroadcastPriv_AddToList(UsherBroadcast *inBroadcast);static void UsherBroadcastPriv_RemoveFromList(UsherBroadcast *inBroadcast);static void UsherBroadcastPriv_SendMessage(UsherBroadcast *inBroadcast, long inMessage, void *inMessageParams);// ---------------------------------------------------------------------------//    U P P   S T U F F// ---------------------------------------------------------------------------static QTSNotificationUPP sUsherBroadcastNotificationUPP = NULL;// ---------------------------------------------------------------------------//    G L O B A L S// ---------------------------------------------------------------------------static UsherBroadcast  *sUsherPresList = NULL;static Boolean      sUsherPresShuttingDown = false;#pragma mark -// ---------------------------------------------------------------------------//    UsherBroadcast_NewFromFile// ---------------------------------------------------------------------------OSErr UsherBroadcast_NewFromFile(const FSSpec *inFileSpec, GWorldPtr inGWorld, GDHandle inGD,            const Rect *inPresBox, UsherBroadcast **outBroadcast){  OSErr          err = noErr;  UsherBroadcast      *broadcast = NULL;  char          tempString[255];    broadcast = (UsherBroadcast*)QTSNewPtrClear(sizeof(UsherBroadcast));  EXITIFERR( err = MemError() );  broadcast-&gt;signature = kUsherBroadcastSignature;    UsherBroadcastPriv_AddToList(broadcast);    EXITIFERR( err = SimplePres_NewFromFile(inFileSpec, inGWorld, inGD, inPresBox, &amp;broadcast-&gt;simplePres) );    EXITIFERR( err = QTSPresGetTimeBase(SimplePres_GetPresentation(broadcast-&gt;simplePres), &amp;broadcast-&gt;presTimeBase) );  EXITIFERR( err = QTSPresGetTimeScale(SimplePres_GetPresentation(broadcast-&gt;simplePres), &amp;broadcast-&gt;presTimeScale) );    if (sUsherBroadcastNotificationUPP == NULL)  {    sUsherBroadcastNotificationUPP = (QTSNotificationUPP)NewQTSNotificationUPP(_UsherBroadcastNotification);  }  SimplePres_SetOwnerNotification(broadcast-&gt;simplePres, sUsherBroadcastNotificationUPP, (void*)broadcast);      UsherBroadcastPriv_SetNameFromFile(broadcast, inFileSpec);  if (outBroadcast != NULL)  {    *outBroadcast = broadcast;  }exit:  CopyPToCStr(inFileSpec-&gt;name, tempString);  if (err != noErr)  {    ProcessUserMessage(kProcessMessageFlag_Log | kProcessMessageFlag_ShowDialog,        &quot;UsherBroadcast_NewFromFile err %ld creating '%s'&quot;, err, tempString);    if (broadcast != NULL)  {      UsherBroadcast_Dispose(broadcast);    }  }  else  {    ProcessUserMessage(kProcessMessageFlag_Log,        &quot;New broadcast created from '%s'&quot;, tempString);  }  return err;}// ---------------------------------------------------------------------------//    UsherBroadcastPriv_SetNameFromFile// ---------------------------------------------------------------------------static void UsherBroadcastPriv_SetNameFromFile(UsherBroadcast *inBroadcast, const FSSpec *inFileSpec){  int            length;  const unsigned char    *current;  // strip off any extensions  length = inFileSpec-&gt;name[0];  current = &amp;(inFileSpec-&gt;name[length-1]);  while (current &gt; inFileSpec-&gt;name) {    if (current[0] == '.')  {      break;    }    --current;  }  if (current &gt; inFileSpec-&gt;name)  {    CopyPToCStrn(inFileSpec-&gt;name, inBroadcast-&gt;presName, current - inFileSpec-&gt;name - 1);  }  else  {    CopyPToCStr(inFileSpec-&gt;name, inBroadcast-&gt;presName);  }}// ---------------------------------------------------------------------------//    UsherBroadcast_Dispose// ---------------------------------------------------------------------------void UsherBroadcast_Dispose(UsherBroadcast *inBroadcast){  SInt32        i;  if (inBroadcast != NULL)  {        if (inBroadcast-&gt;disposing)  {      goto exit;    }    inBroadcast-&gt;disposing = true;    for (i=0; i&lt;inBroadcast-&gt;numSourceHandlers; ++i)  {      SourcingSupport_DisposeHandler(inBroadcast-&gt;sourceHandlers[i].handler);      inBroadcast-&gt;sourceHandlers[i].handler = 0;    }    inBroadcast-&gt;numSourceHandlers = 0;    for (i=0; i&lt;inBroadcast-&gt;numWindows; ++i)  {      //@@@ should ask if the window wants to be closed...        WindowSupport_CloseWindow(inBroadcast-&gt;windowList[i]);    }    inBroadcast-&gt;numWindows = 0;            if (inBroadcast-&gt;simplePres != NULL)  {      SimplePres_Dispose(inBroadcast-&gt;simplePres);    }    UsherBroadcastPriv_RemoveFromList(inBroadcast);    DisposePtr((Ptr)inBroadcast);  }exit:  return;}#pragma mark -// ---------------------------------------------------------------------------//    UsherBroadcast_GetMenuCommand// ---------------------------------------------------------------------------long UsherBroadcast_GetMenuCommand(UsherBroadcast *inBroadcast, long inMenuResult, void **outCommandParams){#pragma unused(inBroadcast, outCommandParams)  short          menuID, menuItem;  SInt32          command = kCommand_Nothing;  menuID = MYHIWORD(inMenuResult);  menuItem = MYLOWORD(inMenuResult);  switch (menuID)  {    case rMenu_File:      switch (menuItem)  {        case rMenuItem_Export:          command = kCommand_PresExport;          break;        default:          break;      }      break;    case rMenu_Presentation:      switch (menuItem)  {        case rMenuItem_SettingsDialog:          command = kCommand_PresSettingsDialog;          break;        default:          break;      }      break;    default:      break;  }  exit:  return command;}// ---------------------------------------------------------------------------//    UsherBroadcast_DoCommand// ---------------------------------------------------------------------------OSErr UsherBroadcast_DoCommand(UsherBroadcast *inBroadcast, long inCommand, void *ioCommandParams){  OSErr        err = noErr;    switch (inCommand)  {          case kCommand_PresSettingsDialog:      err = SimplePres_SettingsDialog(inBroadcast-&gt;simplePres);      break;    case kCommand_PresExport:      err = SimplePres_ExportToFile(inBroadcast-&gt;simplePres, AppGlobals_GetAppSignature());      break;    case kCommand_GetBroadcastName:      err = UsherBroadcastPriv_GetBroadcastName(inBroadcast, (UsherBroadcastStringParams*)ioCommandParams);      break;        case kCommand_GetBroadcastStateString:      err = UsherBroadcastPriv_GetStateString(inBroadcast, (UsherBroadcastStringParams*)ioCommandParams);      break;    case kCommand_GetBroadcastTime:      err = UsherBroadcastPriv_GetBroadcastTime(inBroadcast, (UsherBroadcastTimeParams*)ioCommandParams);      break;    default:    {      long    i;            err = kErr_AppUnhandledCommand;      // ask the handlers      for (i=0; i&lt;inBroadcast-&gt;numSourceHandlers; ++i)  {        err = SourcingSupport_DoCommand(inBroadcast-&gt;sourceHandlers[i].handler, inCommand, ioCommandParams);        if (err != kErr_AppUnhandledCommand)  {          break;        }            }      break;    }  }exit:  return err;}// ---------------------------------------------------------------------------//    UsherBroadcastPriv_GetBroadcastName// ---------------------------------------------------------------------------static OSErr UsherBroadcastPriv_GetBroadcastName(UsherBroadcast *inBroadcast,          UsherBroadcastStringParams *inParams){  OSErr    err = noErr;  UInt32    length;  if (inParams == NULL)  {    DEBUGF((&quot;UsherBroadcastPriv_GetBroadcastName $%.8x-null params&quot;, inBroadcast));    EXITERR( err = paramErr );  }  if (inParams-&gt;ioString == NULL)  {    DEBUGF((&quot;UsherBroadcastPriv_GetBroadcastName $%.8x-null string param&quot;, inBroadcast));    EXITERR( err = paramErr );  }  length = strlen(inBroadcast-&gt;presName);  if (length &gt; inParams-&gt;inMaxLength)  {    length = inParams-&gt;inMaxLength;  }  BlockMoveData(inBroadcast-&gt;presName, inParams-&gt;ioString, length);  inParams-&gt;ioString[length] = '\0';  inParams-&gt;returnedStringLength = length;exit:  return err;}// ---------------------------------------------------------------------------//    UsherBroadcastPriv_GetStateString// ---------------------------------------------------------------------------static OSErr UsherBroadcastPriv_GetStateString(UsherBroadcast *inBroadcast,          UsherBroadcastStringParams *inParams){  OSErr        err = noErr;  UInt32        length;  Str255        tempString;  SimplePresState    state;  if (inParams == NULL)  {    DEBUGF((&quot;UsherBroadcastPriv_GetStateString $%.8x-null params&quot;, inBroadcast));    EXITERR( err = paramErr );  }  if (inParams-&gt;ioString == NULL)  {    DEBUGF((&quot;UsherBroadcastPriv_GetStateString $%.8x-null string param&quot;, inBroadcast));    EXITERR( err = paramErr );  }  state = SimplePres_GetState(inBroadcast-&gt;simplePres);  if (state == 0)  {    DEBUGF((&quot;UsherBroadcastPriv_GetStateString $%.8x-state==0&quot;, inBroadcast));    EXITERR( err = paramErr );  }  GetIndString(tempString, rStringList_PresState, state);  length = tempString[0];  if (length &gt; inParams-&gt;inMaxLength)  {    length = inParams-&gt;inMaxLength;  }  BlockMoveData(&amp;(tempString[1]), inParams-&gt;ioString, length);  inParams-&gt;ioString[length] = '\0';  inParams-&gt;returnedStringLength = length;exit:  return err;}// ---------------------------------------------------------------------------//    UsherBroadcastPriv_GetBroadcastTime// ---------------------------------------------------------------------------static OSErr UsherBroadcastPriv_GetBroadcastTime(UsherBroadcast *inBroadcast,          UsherBroadcastTimeParams *inTimeParams){  OSErr    err = noErr;  if (inTimeParams-&gt;timeScale == 0)  {    inTimeParams-&gt;timeScale = inBroadcast-&gt;presTimeScale;  }  QTSGetTimeBaseTime64(inBroadcast-&gt;presTimeBase, inTimeParams-&gt;timeScale, &amp;inTimeParams-&gt;returnedTime);exit:  return err;}#pragma mark -// ---------------------------------------------------------------------------//    UsherBroadcast_Idle// ---------------------------------------------------------------------------void UsherBroadcast_Idle(UsherBroadcast *inBroadcast){  long    i;  Boolean    playing = false;  if (inBroadcast != NULL)  {    if (inBroadcast-&gt;simplePres != NULL)  {      SimplePres_Idle(inBroadcast-&gt;simplePres);      playing = (SimplePres_GetState(inBroadcast-&gt;simplePres) == kSimplePresState_Playing);    }    for (i=0; i&lt;inBroadcast-&gt;numSourceHandlers; ++i)  {      SourcingSupport_Idle(inBroadcast-&gt;sourceHandlers[i].handler, playing);    }    // idle all the windows    for (i=0; i&lt;inBroadcast-&gt;numWindows; ++i)  {      WindowSupport_Idle(inBroadcast-&gt;windowList[i]);    }  }}// ---------------------------------------------------------------------------//    UsherBroadcast_Start// ---------------------------------------------------------------------------OSErr UsherBroadcast_Start(UsherBroadcast *inBroadcast){  OSErr      err = noErr;  if (inBroadcast-&gt;simplePres == NULL)  {    DEBUGF((&quot;UsherBroadcast_Start $%.8x - null presentation&quot;, inBroadcast));    EXITERR( err = qtsBadStateErr );  }    err = SimplePres_Start(inBroadcast-&gt;simplePres);      exit:  if (err == noErr)  {    ProcessUserMessage(kProcessMessageFlag_Log,        &quot;Broadcast '%s' started&quot;, inBroadcast-&gt;presName);  }  else  {    ProcessUserMessage(kProcessMessageFlag_Log | kProcessMessageFlag_ShowDialog,        &quot;Error (%ld) starting broadcast '%s'&quot;, err, inBroadcast-&gt;presName);  }  return err;}// ---------------------------------------------------------------------------//    UsherBroadcast_Stop// ---------------------------------------------------------------------------OSErr UsherBroadcast_Stop(UsherBroadcast *inBroadcast){  OSErr      err = noErr;  if (inBroadcast-&gt;simplePres == NULL)  {    DEBUGF((&quot;UsherBroadcast_Stop $%.8x - null presentation&quot;, inBroadcast));    EXITERR( err = qtsBadStateErr );  }  err = SimplePres_Stop(inBroadcast-&gt;simplePres);exit:  ProcessUserMessage(kProcessMessageFlag_Log,        &quot;Broadcast '%s' stopped&quot;, inBroadcast-&gt;presName);  return err;}#pragma mark -// ---------------------------------------------------------------------------//    _UsherBroadcastNotification// ---------------------------------------------------------------------------static ComponentResult _UsherBroadcastNotification(ComponentResult inErr, OSType inNotificationType,                void *inNotificationParams, void *inRefCon){  UsherBroadcast    *broadcast = (UsherBroadcast*)inRefCon;  ComponentResult    err = noErr;    switch (inNotificationType)  {      case kQTSPrerollAckNotification:    case kQTSStartAckNotification:    case kQTSStopAckNotification:      // apps should put up some nice ui about the error      if (inErr != NULL)  {        //DEBUGF((&quot;_UsherBroadcastNotification $%.8x type $%.8x, err %ld&quot;, broadcast, inNotificationType, inErr));      }      UsherBroadcastPriv_SendMessage(broadcast, kMessage_SendPresStateChanged, (void*) SimplePres_GetState(broadcast-&gt;simplePres));      break;            case kQTSErrorNotification:      //err = UsherBroadcastPriv_HandleErrorNotification(broadcast, inErr, (QTSErrorParams*)inNotificationParams);      break;      default:      // it's ok to get a notification you don't know about      // just silently ignore it      break;  }    if (broadcast-&gt;someHandlerWantsNotifications)  {    long    i;        for (i=0; i&lt;broadcast-&gt;numSourceHandlers; ++i)  {      if (broadcast-&gt;sourceHandlers[i].handlerWantsNotifications)  {        SourcingSupport_HandleNotification(broadcast-&gt;sourceHandlers[i].handler, inNotificationType, inNotificationParams);      }    }  }    return err;}// ---------------------------------------------------------------------------//    UsherBroadcastPriv_HandleErrorNotification// ---------------------------------------------------------------------------static ComponentResult UsherBroadcastPriv_HandleErrorNotification(UsherBroadcast *inBroadcast,      ComponentResult inErr, QTSErrorParams *inErrorParams){#pragma unused(inBroadcast, inErrorParams)  // tell the user in some nice way  // inErrorParams can be NULL  if (inErrorParams == NULL)  {    ProcessUserMessage(kProcessMessageFlag_Log | kProcessMessageFlag_ShowDialog,        &quot;Error (%ld) in broadcast&quot;, inErr);  }  else  {    ProcessUserMessage(kProcessMessageFlag_Log | kProcessMessageFlag_ShowDialog,        &quot;Error (%ld) in broadcast '%s'&quot;, inErr, inErrorParams-&gt;errorString);  }  return noErr;}#pragma mark -// ---------------------------------------------------------------------------//    UsherBroadcast_GetStatusParams// ---------------------------------------------------------------------------QTSStatusParams *UsherBroadcast_GetStatusParams(UsherBroadcast *inBroadcast){  QTSStatusParams    *statusParams = NULL;    if (inBroadcast != NULL)  {    statusParams = &amp;inBroadcast-&gt;statusParams;  }    return statusParams;  }// ---------------------------------------------------------------------------//    UsherBroadcast_GetQTSPresentation// ---------------------------------------------------------------------------QTSPresentation UsherBroadcast_GetQTSPresentation(UsherBroadcast *inBroadcast){  QTSPresentation    presentation = kQTSInvalidPresentation;    if (inBroadcast-&gt;simplePres != NULL)  {    presentation = SimplePres_GetPresentation(inBroadcast-&gt;simplePres);  }    return presentation;  }// ---------------------------------------------------------------------------//    UsherBroadcast_GetInfo// ---------------------------------------------------------------------------OSErr UsherBroadcast_GetInfo(UsherBroadcast *inBroadcast, OSType inSelector, void *ioParams){  OSErr      err = noErr;  Boolean      sendToPres = false;  long      i;    switch (inSelector)  {    case kQTSInfo_SourcerTiming:    {      for (i=0; i&lt;inBroadcast-&gt;numSourceHandlers; ++i)  {        err = SourcingSupport_GetInfo(inBroadcast-&gt;sourceHandlers[i].handler, inSelector, ioParams);        if (err == noErr)  {          break;        }      }      break;    }    default:      sendToPres = true;      err = qtsBadSelectorErr;      break;  }  if (sendToPres  &amp;&amp;  (inBroadcast-&gt;simplePres != NULL))  {    err = SimplePres_GetInfo(inBroadcast-&gt;simplePres, inSelector, ioParams);  }  else  {    if (inBroadcast-&gt;simplePres == NULL)  {      DEBUGF((&quot;UsherBroadcast_GetInfo $%.8x - info $%.8x no presentation&quot;, inBroadcast, inSelector));    }  }  return err;}// ---------------------------------------------------------------------------//    UsherBroadcast_SetInfo// ---------------------------------------------------------------------------OSErr UsherBroadcast_SetInfo(UsherBroadcast *inBroadcast, OSType inSelector, void *ioParams){  OSErr      err = noErr;  Boolean      sendToPres = false;  switch (inSelector)  {    default:      sendToPres = true;      err = qtsBadSelectorErr;      break;  }  if (inBroadcast-&gt;simplePres != NULL)  {    err = SimplePres_SetInfo(inBroadcast-&gt;simplePres, inSelector, ioParams);  }  else  {    DEBUGF((&quot;UsherBroadcast_SetInfo $%.8x - info $%.8x no presentation&quot;, inBroadcast, inSelector));  }  return err;}#pragma mark -#pragma mark .----- infrastructure support -----// ---------------------------------------------------------------------------//    UsherBroadcast_GetNumBroadcasts// ---------------------------------------------------------------------------long UsherBroadcast_GetNumBroadcasts(void){  long        numBroadcasts = 0;  UsherBroadcast    *current;  current = sUsherPresList;  while (current != NULL)  {    ++numBroadcasts;    current = current-&gt;next;  }  return numBroadcasts;}// ---------------------------------------------------------------------------//    UsherBroadcast_IdleAll// ---------------------------------------------------------------------------void UsherBroadcast_IdleAll(void){  UsherBroadcast    *current;  current = sUsherPresList;  while (current != NULL)  {    UsherBroadcast_Idle(current);    current = current-&gt;next;  }}// ---------------------------------------------------------------------------//    UsherBroadcast_CleanUp// ---------------------------------------------------------------------------void UsherBroadcast_CleanUp(void){  // for every presentation in the list, get rid of it  UsherBroadcast    *current;  UsherBroadcast    *next;    sUsherPresShuttingDown = true;  current = sUsherPresList;  sUsherPresList = NULL;  while (current != NULL)  {    next = current-&gt;next;    UsherBroadcast_Dispose(current);    current = next;  }  sUsherPresShuttingDown = false;}// ---------------------------------------------------------------------------//    UsherBroadcastPriv_AddToList// ---------------------------------------------------------------------------static void UsherBroadcastPriv_AddToList(UsherBroadcast *inBroadcast){  inBroadcast-&gt;next = sUsherPresList;  sUsherPresList = inBroadcast;}// ---------------------------------------------------------------------------//    UsherBroadcastPriv_RemoveFromList// ---------------------------------------------------------------------------static void UsherBroadcastPriv_RemoveFromList(UsherBroadcast *inBroadcast){  UsherBroadcast    *current;  UsherBroadcast    *prev = NULL;  if (!sUsherPresShuttingDown)  {    current = sUsherPresList;    while (current != NULL)  {      if (current == inBroadcast)  {        if (prev != NULL)  {          prev-&gt;next = current-&gt;next;        }  else  {          sUsherPresList = current-&gt;next;        }        break;      }      prev = current;      current = current-&gt;next;    }  }}// ---------------------------------------------------------------------------//    UsherBroadcast_AddSourceHandler// ---------------------------------------------------------------------------OSErr UsherBroadcast_AddSourceHandler(UsherBroadcast *inBroadcast, void *inSourceHandler){  OSErr      err = noErr;  Boolean      wantsNotifications = false;    if (inBroadcast-&gt;numSourceHandlers &gt;= kUsherBroadcastMaxSourceHandlers)  {    DEBUGF((&quot;UsherBroadcast_AddSourceHandler $%.8x - already have max %ld handlers&quot;, inBroadcast, kUsherBroadcastMaxSourceHandlers));    EXITERR( err = qtsBadStateErr );  }    inBroadcast-&gt;sourceHandlers[inBroadcast-&gt;numSourceHandlers].handler = inSourceHandler;  SourcingSupport_HasCharacteristic(inSourceHandler, kCharacteristic_WantsPresNotifications, &amp;wantsNotifications);  inBroadcast-&gt;sourceHandlers[inBroadcast-&gt;numSourceHandlers].handlerWantsNotifications = wantsNotifications;  if (wantsNotifications)  {    inBroadcast-&gt;someHandlerWantsNotifications = true;  }  ++(inBroadcast-&gt;numSourceHandlers);exit:  return err;}// ---------------------------------------------------------------------------//    UsherBroadcast_AddWindow// ---------------------------------------------------------------------------OSErr UsherBroadcast_AddWindow(UsherBroadcast *inBroadcast, WindowPtr inWindow){  OSErr      err = noErr;    if (inBroadcast-&gt;numWindows &gt;= kUsherBroadcastMaxWindows)  {    DEBUGF((&quot;UsherBroadcast_AddWindow $%.8x - already have max %ld windows&quot;, inBroadcast, kUsherBroadcastMaxWindows));    EXITERR( err = qtsBadStateErr );  }    inBroadcast-&gt;windowList[inBroadcast-&gt;numWindows] = inWindow;  ++(inBroadcast-&gt;numWindows);exit:  return err;}// ---------------------------------------------------------------------------//    UsherBroadcast_RemoveWindow// ---------------------------------------------------------------------------void UsherBroadcast_RemoveWindow(UsherBroadcast *inBroadcast, WindowPtr inWindow){  SInt32      i;    for (i=0; i&lt;inBroadcast-&gt;numWindows; ++i)  {    if  (inWindow == inBroadcast-&gt;windowList[i])  {      // move the other windows up      if (i&lt;inBroadcast-&gt;numWindows-1)  {        BlockMoveData(&amp;(inBroadcast-&gt;windowList[i+1]),              &amp;(inBroadcast-&gt;windowList[i]), (inBroadcast-&gt;numWindows-1-i));      }      --(inBroadcast-&gt;numWindows);      break;    }  }  if (inBroadcast-&gt;numWindows == 0)  {    UsherBroadcast_Dispose(inBroadcast);  }  }// ---------------------------------------------------------------------------//    UsherBroadcastPriv_SendMessage// ---------------------------------------------------------------------------static void UsherBroadcastPriv_SendMessage(UsherBroadcast *inBroadcast, long inMessage, void *inMessageParams){  long      i;  // tell all the windows  for (i=0; i&lt;inBroadcast-&gt;numWindows; ++i)  {    WindowSupport_HandleMessage(inBroadcast-&gt;windowList[i], inMessage, inMessageParams);  }}</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/usher/listing16.html%3Fid%3DDTS10001057-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/usher/listing16.html%3Fid%3DDTS10001057-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/usher/listing16.html%3Fid%3DDTS10001057-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>