<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>USB Device Interface Guide: USB Device Overview</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="USB Device Overview"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP40002644" title="USB Device Overview"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../../HardwareDrivers/index.html#//apple_ref/doc/uid/TP30000440-TP40003576" target="_top">Hardware &amp; Drivers</a> &gt; <a href="../../../../HardwareDrivers/USB-date.html#//apple_ref/doc/uid/TP30000440-TP40003576-TP30000583" target="_top">USB</a> &gt; <a href="../USBIntro/USBIntro.html#//apple_ref/doc/uid/TP40002643-TPXREF101">USB Device Interface Guide</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../USBIntro/USBIntro.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../USBDeviceInterfaces/USBDevInterfaces.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP40002644-TPXREF101" title="USB Device Overview"></a><h1>USB Device Overview</h1><p>This chapter provides a summary of USB device architecture and describes how USB devices are represented in Mac OS X. It also presents a few specific guidelines for working with USB devices in an application.For details on the USB specification, see <span class="content_text"><a href="http://www.usb.org" target="_blank">http://www.usb.org</a></span>.</p>
<!-- This template is being used for both PDF and HTML. -->

    
    <h4>In this section:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="USBOverview.html#//apple_ref/doc/uid/TP40002644-BBIDHAFI">USB Device Types and Bus Speeds</a>
				
			<br/>
			
        
			
			
				<a href="USBOverview.html#//apple_ref/doc/uid/TP40002644-TPXREF102">USB Device Architecture and Terminology</a>
				
			<br/>
			
        
			
			
				<a href="USBOverview.html#//apple_ref/doc/uid/TP40002644-BBIJFFDC">USB Devices on Mac OS X</a>
				
			<br/>
			
        
			
			
				<a href="USBOverview.html#//apple_ref/doc/uid/TP40002644-DontLinkElementID_4">Tasks and Caveats</a>
				
			<br/>
			
        
			
			
				<a href="USBOverview.html#//apple_ref/doc/uid/TP40002644-DontLinkElementID_7">USB Device Access in an Intel-Based Macintosh</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP40002644-BBIDHAFI" title="USB Device Types and Bus Speeds"></a><h2>USB Device Types and Bus Speeds</h2><p>The USB specification supports a wide selection of devices that range from lower-speed devices such as keyboards, mice, and joysticks to higher-speed devices such as scanners and digital cameras. The specification lists a number of device classes that each define a set of expected device behaviors. <span class="content_text"><a href="USBOverview.html#//apple_ref/doc/uid/TP40002644-BBIGIEDH">Table 1-1</a></span> lists some examples of USB devices, categorized by class.</p><a name="//apple_ref/doc/uid/TP40002644-BBIGIEDH" title="Table 1-1Examples of USB devices"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 1-1&nbsp;&nbsp;</strong>Examples of USB devices</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>USB device class</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>USB devices in class</p></th></tr><tr><td  scope="row"><p>Audio class</p></td><td ><p>Speakers, microphones</p></td></tr><tr><td  scope="row"><p>Chip Card Interface Device Class</p></td><td ><p>Smart cards, chip cards</p></td></tr><tr><td  scope="row"><p>Communication class</p></td><td ><p>Speakerphone, modem</p></td></tr><tr><td  scope="row"><p>Composite class</p></td><td ><p>A device in which all class-specific information is embedded in its interfaces</p></td></tr><tr><td  scope="row"><p>HID class</p></td><td ><p>Keyboards, mice, joysticks, drawing tablets</p></td></tr><tr><td  scope="row"><p>Hub class</p></td><td ><p>Hubs provide additional attachment points for USB devices</p></td></tr><tr><td  scope="row"><p>Mass storage class</p></td><td ><p>Hard drives, flash memory readers, CD Read/Write drives, digital cameras, and high-end media players</p></td></tr><tr><td  scope="row"><p>Printing class</p></td><td ><p>Printers</p></td></tr><tr><td  scope="row"><p>Vendor specific</p></td><td ><p>A device that doesn’t fit into any other predefined class or one that doesn’t use the standard protocols for an existing class</p></td></tr><tr><td  scope="row"><p>Video class</p></td><td ><p>Digital camcorders, webcams, digital still cameras that support video streaming</p></td></tr></table></div><p>Version 1.1 of the USB specification supports two bus speeds:</p><ul class="ul"><li class="li"><p>Low speed (1.5 Mbps)</p></li><li class="li"><p>Full speed (12 Mbps)</p></li></ul><p>Version 2.0 of the specification adds another bus speed to this list:</p><ul class="ul"><li class="li"><p>High speed (480 Mbps)</p></li></ul><p>The USB 2.0 specification is fully compatible with low-speed and full-speed USB devices and even supports the use of cables and connectors made to meet earlier versions of the specification. Apple provides USB 2.0 ports on all new Macintosh computers and fully supports the new specification with Enhanced Host Controller Interface (EHCI) controllers and built-in, low-level USB drivers. </p><p>For the most part, you do not have to change existing applications to support the faster data rate because the speed increase and other enhancements are implemented at such a low level. The exceptions to this are some differences in isochronous transfers. For information on how the USB 2.0 specification affects isochronous transfers, see <span class="content_text"><a href="USBOverview.html#//apple_ref/doc/uid/TP40002644-BBCCGGAJ">“USB 2.0 and Isochronous Transfers.”</a></span></p><a name="//apple_ref/doc/uid/TP40002644-TPXREF102" title="USB Device Architecture and Terminology"></a><h2>USB Device Architecture and Terminology</h2><p>The architecture of a generic USB device is multi-layered. A device consists of one or more configurations, each of which describes a possible setting the device can be programmed into. Such settings can include the power characteristics of the configuration (for example, the maximum power consumed by the configuration and whether it is self-powered or not) and whether the configuration supports remote wake-up.</p><p>Each configuration contains one or more interfaces that are accessible after the configuration is set. An interface provides the definitions of the functions available within the device and may even contain alternate settings within a single interface. For example, an interface for an audio device may have different settings you can select for different bandwidths.</p><p>Each interface contains zero or more endpoints. An endpoint is a uniquely identifiable portion of a USB device that is the source or sink of information in a communication flow between the host and the device. Each endpoint has characteristics that describe the communication it supports, such as transfer type (control, isochronous, interrupt, or bulk, described in <span class="content_text"><a href="USBOverview.html#//apple_ref/doc/uid/TP40002644-BBIHAIAG">“USB Transfer Types”</a></span>), maximum packet size, and transfer direction (input or output).</p><p>Communication with a USB device is accomplished through a pipe, a logical association between an endpoint and software running on the host. Endpoint and pipe are often used synonymously although an endpoint is a component of a USB device and a pipe is a logical abstraction of the communications link between endpoint and host.</p><a name="//apple_ref/doc/uid/TP40002644-TPXREF103" title="USB Device Component Descriptors"></a><h3>USB Device Component Descriptors</h3><p>Each layer of a USB device provides information about its attributes and resource requirements in its descriptor, a data structure accessible through device interface functions. By examining the descriptors at each layer, you can determine exactly which endpoint you need to communicate successfully with a particular device.</p><p>At the top layer is the device descriptor, which has fields associated with information such as the device’s class and subclass, vendor and product numbers, and number of configurations. Each configuration in turn has a configuration descriptor containing fields that describe the number of interfaces it supports and the power characteristics of the device when it is in that configuration, along with other information. Each interface supported by a configuration has its own descriptor with fields for information such as the interface class, subclass, and protocol, and the number of endpoints in that interface. At the bottom layer are the endpoint descriptors that specify attributes such as transfer type and maximum packet size.</p><p>The USB specification defines a name for each descriptor field, such as the <code>bDeviceClass</code> field in the device descriptor and the <code>bNumInterfaces</code> field in the configuration descriptor, and each field is associated with a value. For a complete listing of all descriptor fields, see the USB specification at <span class="content_text"><a href="http://www.usb.org" target="_blank">www.usb.org</a></span>. The USB family defines structures that represent the descriptors defined by the USB specification. For the definitions of these structures, see <code>USB</code> in <em><a href="../../../../Darwin/Reference/KernelIOKitFramework/index.html#//apple_ref/doc/uid/TP30000816" target="_top">Kernel Framework Reference</a></em>.</p><a name="//apple_ref/doc/uid/TP40002644-DontLinkElementID_1" title="USB Composite Class Devices"></a><h3>USB Composite Class Devices</h3><p>The USB specification defines a composite class device as a device whose device-descriptor fields for device class (<code>bDeviceClass</code>) and device subclass (<code>bDeviceSubClass</code>) both have the value <code>0</code>. A composite class device appears to the system as a USB device using a single bus address that may present multiple interfaces, each of which represents a separate function. A good example of a composite class device is a multifunction device, such as a device that performs printing, scanning, and faxing. In such a device, each function is represented by a separate interface. In Mac OS X, the I/O Kit loads the <code>AppleUSBComposite</code> device driver for composite class devices that do not already have vendor-specific device drivers to drive them. The <code>AppleUSBComposite</code> driver configures the device and causes drivers to be loaded for each USB interface.</p><p>Although most multifunction USB devices are composite class devices, not all composite class devices are multifunction devices. The manufacturer of a single-function USB device is at liberty to classify the device as a composite class device as long as the device meets the USB specifications. For more information on how Mac OS X represents USB devices and interfaces, see <span class="content_text"><a href="USBOverview.html#//apple_ref/doc/uid/TP40002644-BBIJFFDC">“USB Devices on Mac OS X.”</a></span> </p><a name="//apple_ref/doc/uid/TP40002644-BBIHAIAG" title="USB Transfer Types"></a><h3>USB Transfer Types</h3><p>The USB specification defines four types of pipe transfer:</p><ul class="spaceabove"><li class="li"><p><strong>Control</strong>—intended to support configuration, command, and status communication between the host software and the device. Control transfers support error detection and retry.</p></li><li class="li"><p><strong>Interrupt</strong>—used to support small, limited-latency transfers to or from a device such as coordinates from a pointing device or status changes from a modem. Interrupt transfers support error detection and retry.</p></li><li class="li"><p><strong>Isochronous</strong>—used for periodic, continuous communication between the host and the device, usually involving time-relevant information such as audio or video data streams. Isochronous transfers do not support error detection or retry.</p></li><li class="li"><p><strong>Bulk</strong>—intended for non-periodic, large-packet communication with relaxed timing constraints such as between the host software and a printer or scanner. Bulk transfers support error detection and retry.</p></li></ul><p>Pipes also have a transfer direction associated with them. A control pipe can support bidirectional communication but all other pipes are strictly uni-directional. Therefore, two-way communication requires two pipes, one for input and one for output.</p><p>Every USB device is required to implement a default control pipe that provides access to the device’s configuration, status, and control information. This pipe, implemented in the <code>IOUSBDevice</code> nub object (described in <span class="content_text"><a href="USBOverview.html#//apple_ref/doc/uid/TP40002644-BBIJFFDC">“USB Devices on Mac OS X”</a></span>), is used when a driver such as the <code>AppleUSBComposite</code> driver configures the device or when device-specific control and status information is needed. For example, your application would use the default control pipe if it needs to set or choose a configuration for the device. The default control pipe is connected to the default endpoint (endpoint 0). Note that endpoint 0 does not provide an endpoint descriptor and it is never counted in the total number of endpoints in an interface.</p><p>The interfaces associated with a configuration can contain any combination of the three remaining pipe types (interrupt, isochronous, and bulk), implemented in the <code>IOUSBInterface</code> nub objects (described in <span class="content_text"><a href="USBOverview.html#//apple_ref/doc/uid/TP40002644-BBIJFFDC">“USB Devices on Mac OS X”</a></span>). Your application can query the interface descriptors of a device to select the pipe most suited to its needs.</p><a name="//apple_ref/doc/uid/TP40002644-BBCEGDEE" title="Stalls and Halts "></a><h3>Stalls and Halts </h3><p>Although a stall and a halt are different, they are closely related in their effect on data transmission. Halt is a feature of an endpoint and it can be set by either the host or the device itself in response to an error. A stall is a type of handshake packet an endpoint returns when it is unable to transmit or receive data or when its halt feature is set (the host never sends a stall packet). When an endpoint sends a stall packet, the host can halt the endpoint.</p><p>Depending on the precise circumstances and on how compliant the device is, the halt feature must be cleared in the host, the endpoint, or both before data transmission can resume. When the halt is cleared the data toggle bit, used to synchronize data transmission, is also reset (see <span class="content_text"><a href="USBOverview.html#//apple_ref/doc/uid/TP40002644-BBCHJHIF">“Data Synchronization in Non-Isochronous Transfers”</a></span> for more information about the data toggle). For information on how to handle these conditions in your application, see <span class="content_text"><a href="USBOverview.html#//apple_ref/doc/uid/TP40002644-BBCFBCFB">“Handling Stalls, Halts, and Data Toggle Resynchronization.”</a></span></p><a name="//apple_ref/doc/uid/TP40002644-BBCHJHIF" title="Data Synchronization in Non-Isochronous Transfers"></a><h3>Data Synchronization in Non-Isochronous Transfers</h3><p>The USB specification defines a simple protocol to provide data synchronization across multiple packets for non-isochronous transfers (recall that isochronous transfers do not support error recovery or retry). The protocol is implemented by means of a data toggle bit in both the host and the endpoint which is synchronized at the start of a transaction (or when a reset occurs). The precise synchronization mechanism varies with the type of transfer; see the USB specification for details. </p><p>Both the host and the endpoint begin a transaction with their data toggle bits set to zero. In general, the entity receiving data toggles its data toggle bit when it is able to accept the data and it receives an error-free data packet with the correct identification. The entity sending the data toggles its data toggle bit when it receives a positive acknowledgement from the receiver. In this way, the data toggle bits stay synchronized until, for example, a packet with an incorrect identification is received. When this happens, the receiver ignores the packet and does not increment its data toggle bit. When the data toggle bits get out of synchronization (for this or any other reason), you will probably notice that alternate transactions are not getting through in your application. The solution to this is to resynchronize the data toggle bits. For information on how to do this, see <span class="content_text"><a href="USBOverview.html#//apple_ref/doc/uid/TP40002644-BBCFBCFB">“Handling Stalls, Halts, and Data Toggle Resynchronization.”</a></span></p><a name="//apple_ref/doc/uid/TP40002644-BBCCGGAJ" title="USB 2.0 and Isochronous Transfers"></a><h3>USB 2.0 and Isochronous Transfers</h3><p>The USB 2.0 specification supports the same four transfer types as earlier versions of the specification. In addition to supporting a higher transfer rate, the new specification defines an improved protocol for high-speed transfers and new ways of handling transactions for low-speed and full-speed devices. For details on the protocols and transaction-handling methods, see the specification at <span class="content_text"><a href="http://www.usb.org" target="_blank">http://www.usb.org</a></span>.</p><p>For the most part, these enhancements are implemented at the host software level and do not require changes to your code. For isochronous transfers, however, you should be aware of the following differences:</p><ul class="spaceabove"><li class="li"><p>Earlier versions of the specification divide bus time into 1-millisecond frames, each of which can carry multiple transactions to multiple destinations. (A transaction contains two or more packets: a token packet and one or more data packets, a handshake packet, or both.) The USB 2.0 specification divides the 1-millisecond frame into eight, 125-microsecond microframes, each of which can carry multiple transactions to multiple destinations.</p></li><li class="li"><p>The maximum amount of data allowed in a transaction is increased to 3 KB.</p></li><li class="li"><p>Any isochronous endpoints in a device’s default interface must have a maximum packet size of zero. (This means that the default setting for an interface containing isochronous pipes is alternate setting zero and the maximum packet size for that interface’s isochronous endpoints must be zero.) This ensures that the host can configure the device no matter how busy the bus is.</p></li></ul><p>For a summary of how these differences affect the Mac OS X USB API, see <span class="content_text"><a href="USBOverview.html#//apple_ref/doc/uid/TP40002644-BBCBIDFD">“Changes in Isochronous Functions to Support USB 2.0.”</a></span></p><a name="//apple_ref/doc/uid/TP40002644-BBIJFFDC" title="USB Devices on Mac OS X"></a><h2>USB Devices on Mac OS X</h2><p>When a USB device is plugged in, the Mac OS X USB family abstracts the contents of the device descriptor into an I/O Kit nub object called an <code>IOUSBDevice</code>. This nub object is attached to the <code>IOService</code> plane of the I/O Registry as a child of the driver for the USB controller. The <code>IOUSBDevice</code> nub object is then registered for matching with the I/O Kit.</p><p>If the device is a composite class device with no vendor-specific driver to match against it, the <code>AppleUSBComposite</code> driver matches against it and starts as its provider. The <code>AppleUSBComposite</code> driver then configures the device by setting the configuration in the device’s list of configuration descriptors with the maximum power usage that can be satisfied by the port to which the device is attached. This allows a device with a low power and a high power configuration to be configured differently depending on whether it’s attached to a bus-powered hub or a self-powered hub. In addition, if the <code>IOUSBDevice</code> nub object has the “Preferred Configuration” property, the <code>AppleUSBComposite</code> driver will always use that value when it attempts to configure the device. </p><p>The configuration of the device causes the USB family to abstract each interface descriptor in the chosen configuration into an <code>IOUSBInterface</code> nub object. These nub objects are attached to the I/O Registry as children of the original <code>IOUSBDevice</code> nub object and are registered for matching with the I/O Kit.</p><div class="importantbox"><a name="//apple_ref/doc/uid/TP40002644-DontLinkElementID_10" title="Important:"></a><p><strong>Important:</strong>&nbsp;Because a composite class device is configured by the <code>AppleUSBComposite</code> driver, setting the configuration again from your application will result in the destruction of the <code>IOUSBInterface</code> nub objects and the creation of new ones. In general, the only reason to set the configuration of a composite class device that’s matched by the <code>AppleUSBComposite</code> driver is to choose a configuration other than the first one.</p><p></p></div><p>For non-composite class devices or composite class devices with vendor-specific drivers that match against them, there is no guarantee that any configuration will be set and you may have to perform this task within your application.</p><p>It's important to be mindful of the difference between a USB device (represented in the I/O Registry by an <code>IOUSBDevice</code> nub object) and its interfaces (each represented by an <code>IOUSBInterface</code> nub object). A multifunction USB device, for example, is represented in the I/O Registry by one <code>IOUSBDevice</code> object and one <code>IOUSBInterface</code> object for each interface.</p><p>The distinction between interface and device is important because it determines which object your application must find in the I/O Registry and which type of device interface to get. For example, if your application needs to communicate with a specific interface in a multifunction USB device, it must find that interface and get an <code>IOUSBInterfaceInterface</code> to communicate with it. An application that needs to communicate with the USB device as a whole, on the other hand, would need to find the device in the I/O Registry and get an <code>IOUSBDeviceInterface</code> to communicate with it. For more information on finding devices and interfaces in the I/O Registry, see <span class="content_text"><a href="USBOverview.html#//apple_ref/doc/uid/TP40002644-BBIDGCHB">“Finding USB Devices and Interfaces”</a></span>; for more information on how to get the proper device interface to communicate with a device or interface, see <span class="content_text"><a href="../USBDeviceInterfaces/USBDevInterfaces.html#//apple_ref/doc/uid/TP40002645-BBIHCIHB">“Using USB Device Interfaces.”</a></span></p><a name="//apple_ref/doc/uid/TP40002644-BBIDGCHB" title="Finding USB Devices and Interfaces"></a><h3>Finding USB Devices and Interfaces</h3><p>To find a USB device or interface, use the keys defined in the <em>Universal Serial Bus Common Class Specification, Revision 1.0</em> (available for download from <span class="content_text"><a href="http://www.usb.org/developers/devclass_docs/usbccs10.pdf" target="_blank">http://www.usb.org/developers/devclass_docs/usbccs10.pdf</a></span>) to create a matching dictionary that defines a particular search. If you are unfamiliar with the concept of device matching, see the section “Finding Devices in the I/O Registry” in <em><a href="../../AccessingHardware/index.html#//apple_ref/doc/uid/TP30000376" target="_top">Accessing Hardware From Applications</a></em>.</p><p>The keys defined in the specification are listed in the tables below. Each key consists of a specific combination of elements in a device or interface descriptor. In the tables below, the elements in a key are separated by the ‘+’ character to emphasize the requirement that all a key’s elements must appear together in your matching dictionary. Both tables present the keys in order of specificity: the first key in each table defines the most specific search and the last key defines the broadest search. </p><p>Before you build a matching dictionary, be sure you know whether your application needs to communicate with a device or a specific interface in a device. It’s especially important to be aware of this distinction when working with multifunction devices. A multifunction device is often a composite class device that defines a separate interface for each function. If, for example, your application needs to communicate with the scanning function of a device that does scanning, faxing, and printing, you need to build a dictionary to match on only the scanning interface (an IOUSBInterface object), not the device as a whole (an IOUSBDevice object). In this situation, you would use the keys defined for interface matching (those shown in <span class="content_text"><a href="USBOverview.html#//apple_ref/doc/uid/TP40002644-BBCEACAJ">Table 1-3</a></span>), not the keys for device matching.</p><p><span class="content_text"><a href="USBOverview.html#//apple_ref/doc/uid/TP40002644-BBCCGEEF">Table 1-2</a></span> lists the keys you can use to find devices (not interfaces). Each key element is a piece of information contained in the device descriptor for a USB device. </p><a name="//apple_ref/doc/uid/TP40002644-BBCCGEEF" title="Table 1-2Keys for finding a USB device"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 1-2&nbsp;&nbsp;</strong>Keys for finding a USB device</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Key</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Notes</p></th></tr><tr><td  scope="row"><p><code>idVendor</code> + <code>idProduct</code> + <code>bcdDevice</code></p></td><td ><p><code>bcdDevice</code> contains the release number of the device</p></td></tr><tr><td  scope="row"><p><code>idVendor</code> + <code>idProduct</code></p></td><td ><p></p></td></tr><tr><td  scope="row"><p><code>idVendor</code> + <code>bDeviceSubClass</code> + <code>bDeviceProtocol</code></p></td><td ><p>Use this key only if the device’s <code>bDeviceClass</code> is $FF</p></td></tr><tr><td  scope="row"><p><code>idVendor</code> + <code>bDeviceSubClass</code></p></td><td ><p>Use this key only if the device’s <code>bDeviceClass</code> is $FF</p></td></tr><tr><td  scope="row"><p><code>bDeviceClass</code> + <code>bDeviceSubClass</code> + <code>bDeviceProtocol</code></p></td><td ><p>Use this key only if the device’s <code>bDeviceClass</code> is <em>not</em> $FF</p></td></tr><tr><td  scope="row"><p><code>bDeviceClass</code> + <code>bDeviceSubClass</code></p></td><td ><p>Use this key only if the device’s <code>bDeviceClass</code> is <em>not</em> $FF</p></td></tr></table></div><p><span class="content_text"><a href="USBOverview.html#//apple_ref/doc/uid/TP40002644-BBCEACAJ">Table 1-3</a></span> lists the keys you can use to find interfaces (not devices). Each key element is a piece of information contained in an interface descriptor for a USB device.</p><a name="//apple_ref/doc/uid/TP40002644-BBCEACAJ" title="Table 1-3Keys for finding a USB interface"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 1-3&nbsp;&nbsp;</strong>Keys for finding a USB interface</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Key</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Notes</p></th></tr><tr><td  scope="row"><p><code>idVendor</code> + <code>idProduct</code> + <code>bcdDevice</code> + <code>bConfigurationValue</code> + <code>bInterfaceNumber</code></p></td><td ><p></p></td></tr><tr><td  scope="row"><p><code>idVendor</code> + <code>idProduct</code> + <code>bConfigurationValue</code> + <code>bInterfaceNumber</code></p></td><td ><p></p></td></tr><tr><td  scope="row"><p><code>idVendor</code> + <code>bInterfaceSubClass</code> + <code>bInterfaceProtocol</code></p></td><td ><p>Use this key only if <code>bInterfaceClass</code> is $FF</p></td></tr><tr><td  scope="row"><p><code>idVendor</code> + <code>bInterfaceSubClass</code></p></td><td ><p>Use this key only if <code>bInterfaceSubClass</code> is $FF</p></td></tr><tr><td  scope="row"><p><code>bInterfaceClass</code> + <code>bInterfaceSubClass</code> + <code>bInterfaceProtocol</code></p></td><td ><p>Use this key only if <code>bInterfaceSubClass</code> is <em>not</em> $FF</p></td></tr><tr><td  scope="row"><p><code>bInterfaceClass</code> + <code>bInterfaceSubClass</code></p></td><td ><p>Use this key only if <code>bInterfaceSubClass</code> is <em>not</em> $FF</p></td></tr></table></div><p>For a successful search, you must add the elements of exactly one key to your matching dictionary. If your matching dictionary contains a combination of elements not defined by any key, the search will be unsuccessful. For example, if you create a matching dictionary containing values representing a device’s vendor, product, and protocol, the search will be unsuccessful even if a device with those precise values in its device descriptor is currently represented by an <code>IOUSBDevice</code> nub in the I/O Registry. This is because there is no key in <span class="content_text"><a href="USBOverview.html#//apple_ref/doc/uid/TP40002644-BBCCGEEF">Table 1-2</a></span> that combines the <code>idVendor</code>, <code>idProduct</code>, and <code>bDeviceProtocol</code> elements.</p><a name="//apple_ref/doc/uid/TP40002644-DontLinkElementID_2" title="USB Family Error Codes"></a><h3>USB Family Error Codes</h3><p>As you develop an application to access a USB device or interface, you will probably encounter error codes specific to the Mac OS X USB family. If you are using Xcode, you can search for information about these error codes in the Xcode documentation window.</p><p>To find error code documentation, select Documentation from the Xcode Help menu. Select Full-Text Search from the pull-down menu associated with the search field (click the magnifying glass icon to reveal the menu). Select Reference Library in the Search Groups pane at the left of the window. Type an error code number in the search field, such as 0xe0004057, and press Return. Select the most relevant entry in the search results to display the document in the lower portion of the window. Use the Find command (press Command-F) to find the error code in this document. Using the example of error code 0xe0004057, you’ll see that this error is returned when the endpoint has not been found.</p><p>For help with deciphering I/O Kit error codes in general, see Technical Q&amp;A QA1075, “<span class="content_text"><a href="../../../../../qa/qa2001/qa1075.html" target="_top">Making sense of I/O Kit error codes</a></span>.”</p><a name="//apple_ref/doc/uid/TP40002644-DontLinkElementID_3" title="Determining Which Interface Version to Use"></a><h3>Determining Which Interface Version to Use</h3><p>As described in <span class="content_text"><a href="USBOverview.html#//apple_ref/doc/uid/TP40002644-BBIJFFDC">“USB Devices on Mac OS X,”</a></span> the Mac OS X USB family provides an <code>IOUSBDeviceInterface</code> object you use to communicate with a USB device as a whole and an <code>IOUSBInterfaceInterface</code> object you use to communicate with an interface in a USB device. There are a number of different versions of the USB family, however, some of which provide new versions of these interface objects. (One way to find the version of the USB family installed in your computer is to view the Finder preview information for the <code>IOUSBFamily.kext</code> located in <code>/System/Library/Extensions</code>.) This section describes how to make sure you use the correct interface object and how to view the documentation for the interface objects. </p><p>The first version of the USB family was introduced in Mac OS X v10.0 and contains the first versions of the interface objects <code>IOUSBDeviceInterface</code> and <code>IOUSBInterfaceInterface</code>. When new versions of the USB family introduce new functions for an interface object, a new version of the interface object is created, which gives access to both the new functions and all functions defined in all previous versions of that interface object. For example, the <code>IOUSBDeviceInterface197</code> object provides two new functions you can use with version 1.9.7 of the USB family (available in Mac OS X v10.2.3 and later), in addition to all functions available in the previous device interface objects <code>IOUSBDeviceInterface187</code>, <code>IOUSBDeviceInterface182</code>, and <code>IOUSBDeviceInterface</code>.</p><p>As you develop an application that accesses a USB device or interface, you should use the latest version of the interface object that is available in the earliest version of Mac OS X that you want to support. For example, if your application must run in Mac OS X v10.0, you must use the <code>IOUSBDeviceInterface</code> and <code>IOUSBInterfaceInterface</code> objects. If, however, you develop an application to run in Mac OS X v10.4 and later, you use the <code>IOUSBDeviceInterface197</code> object to access the device as a whole and the <code>IOUSBInterfaceInterface220</code> object to access an interface in it. This is because <code>IOUSBDeviceInterface197</code> is available in Mac OS X version 10.2.3 and later and <code>IOUSBInterfaceInterface220</code> is available in Mac OS X v10.4 and later. </p><div class="notebox"><a name="//apple_ref/doc/uid/TP40002644-DontLinkElementID_11" title="Note"></a><p><strong>Note:</strong>&nbsp;When you view the documentation for these interface objects, notice that each version is documented separately. For example, the documentation for <code><a href="../../../../Darwin/Reference/IOKit/IOUSBLib_h/Classes/IOUSBDeviceInterface197/index.html#//apple_ref/c/cl/IOUSBDeviceInterface197" target="_top">IOUSBDeviceInterface197</a></code> contains information about the two new functions introduced in this version, but does not repeat the documentation for the functions introduced in <code><a href="../../../../Darwin/Reference/IOKit/IOUSBLib_h/Classes/IOUSBDeviceInterface187/index.html#//apple_ref/c/cl/IOUSBDeviceInterface187" target="_top">IOUSBDeviceInterface187</a></code>, <code><a href="../../../../Darwin/Reference/IOKit/IOUSBLib_h/Classes/IOUSBDeviceInterface182/index.html#//apple_ref/c/cl/IOUSBDeviceInterface182" target="_top">IOUSBDeviceInterface182</a></code>, and <code><a href="../../../../Darwin/Reference/IOKit/IOUSBLib_h/Classes/IOUSBDeviceInterface/index.html#//apple_ref/c/cl/IOUSBDeviceInterface" target="_top">IOUSBDeviceInterface</a></code>.</p></div><a name="//apple_ref/doc/uid/TP40002644-DontLinkElementID_4" title="Tasks and Caveats"></a><h2>Tasks and Caveats</h2><p>This section presents some specific tasks your application might need to perform, along with some caveats related to USB 2.0 support of which you should be aware.</p><a name="//apple_ref/doc/uid/TP40002644-BBCFBCFB" title="Handling Stalls, Halts, and Data Toggle Resynchronization"></a><h3>Handling Stalls, Halts, and Data Toggle Resynchronization</h3><p>As described in <span class="content_text"><a href="USBOverview.html#//apple_ref/doc/uid/TP40002644-BBCEGDEE">“Stalls and Halts ,”</a></span> stalls and halts are closely related in their effect on data transmission. To simplify the API, the USB family uses the pipe stall terminology in the names of the functions that handle these conditions:</p><ul class="spaceabove"><li class="li"><p><code><!--a-->ClearPipeStall<!--/a--></code></p></li><li class="li"><p><code><!--a-->ClearPipeStallBothEnds<!--/a--></code></p></li></ul><p>The <code><!--a-->ClearPipeStall<!--/a--></code> function operates exclusively on the host controller side, clearing the halt feature and resetting the data toggle bit to zero. If the endpoint’s halt feature and data toggle bit must be reset as well, your application must do so explicitly, using one of the <code><!--a-->ControlRequest<!--/a--></code> functions to send the appropriate device request. See the documentation for the <code>USB.h</code> header file in <em><a href="../../../../Darwin/Reference/IOKit/index.html#//apple_ref/doc/uid/TP30000815" target="_top">I/O Kit Framework Reference</a></em> for more information about standard device requests.</p><p>In Mac OS X version 10.2 and later, you can use the <code><!--a-->ClearPipeStallBothEnds<!--/a--></code> function which, as its name suggests, clears the halt and resets the data toggle bit on both sides at the same time.</p><a name="//apple_ref/doc/uid/TP40002644-DontLinkElementID_5" title="Using the Low Latency Isochronous Functions"></a><h3>Using the Low Latency Isochronous Functions</h3><p>In Mac OS X, the time between when an isochronous transaction completes on the USB bus and when you receive your callback can stretch to tens of milliseconds. This is because the callback happens on the USB family work loop, which runs at a lower priority than some other threads in the system. In most cases, you can work around this delay by queuing read and write requests so that the next transaction is scheduled and ready to start before you receive the callback from the current transaction. In fact, this scheme is a good way to achieve higher performance whether or not low latency is a requirement of your application.</p><p>In a few cases, however, queuing isochronous transactions to keep the pipe busy is not enough to prevent a latency problem that a user might notice. Consider an application that performs audio processing on some USB input (from a musical instrument, for example) before sending the processed data out to USB speakers. In this scenario, a user hears both the raw, unprocessed output of the instrument and the processed output of the speakers. Of course, some small delay between the time the instrument creates the raw sound waves and the time the speaker emits the processed sound waves is unavoidable. If this delay is greater than about 8 milliseconds, however, the user will notice.</p><p>In Mac OS X version 10.2.3 (version 1.9.2 of the USB family) the USB family solves this problem by taking advantage of the predictability of isochronous data transfers. By definition, isochronous mode guarantees the delivery of some amount of data every frame or microframe. In earlier versions of Mac OS X, however, it was not possible to find out the exact amount of data that was transferred by a given time. This meant that an application could not begin processing the data until it received the callback associated with the transaction, telling it the transfer status and the actual amount of data that was transferred. </p><p>Version 1.9.2 of the USB family introduced the <code><!--a-->LowLatencyReadIsochPipeAsync<!--/a--></code> and <code><!--a-->LowLatencyWriteIsochPipeAsync<!--/a--></code> functions. These functions update the frame list information (including the transfer status and the number of bytes actually transferred) at primary interrupt time. Using these functions, an application can request that the frame list information be updated as frequently as every millisecond. This means an application can retrieve and begin processing the number of bytes actually transferred once a millisecond, without waiting for the entire transaction to complete.</p><div class="importantbox"><a name="//apple_ref/doc/uid/TP40002644-DontLinkElementID_12" title="Important:"></a><p><strong>Important:</strong>&nbsp;Because these functions cause processing at primary interrupt time, it is essential you use them only if it is absolutely necessary. Overuse of these functions can cause degradation of system performance.</p><p></p></div><p>To support the low latency isochronous read and write functions, the USB family also introduced functions to create and destroy the buffers that hold the frame list information and the data. Although you can choose to create a single data buffer and a single frame list buffer or multiple buffers of each type, you must use the <code><!--a-->LowLatencyCreateBuffer<!--/a--></code> function to create them. Similarly, you must use the <code><!--a-->LowLatencyDestroyBuffer<!--/a--></code> function to destroy the buffers after you are finished with them. This restricts all necessary communication with kernel entities to the USB family.</p><p>For reference documentation on the low latency isochronous functions, see the <code>IOUSBLib.h</code> documentation in <em><a href="../../../../Darwin/Reference/IOKit/index.html#//apple_ref/doc/uid/TP30000815" target="_top">I/O Kit Framework Reference</a></em>.</p><a name="//apple_ref/doc/uid/TP40002644-DontLinkElementID_6" title="Errors Reported by the EHCI Hub"></a><h3>Errors Reported by the EHCI Hub</h3><p>The EHCI hub that supports high-speed devices (as well as low-speed and full-speed devices) provides coarser-grained error reporting than the OHCI hub does. For example, with an OHCI hub, you might receive an “endpoint timed out” error if you unplug the device while it is active. If you perform the same action with an EHCI hub, you might receive a “pipe stalled” error instead.</p><p>The Apple EHCI hub driver cannot get more detailed error information from the hub, so it alternates between reporting “device not responding” and “pipe stalled” regardless of the actual error reported by the device. To avoid problems with your code, be sure your application does not rely on other, more specific errors to make important decisions. </p><a name="//apple_ref/doc/uid/TP40002644-BBCBIDFD" title="Changes in Isochronous Functions to Support USB 2.0"></a><h3>Changes in Isochronous Functions to Support USB 2.0</h3><p>Recall that the USB 2.0 specification divides the 1-millisecond frame into eight, 125-microsecond microframes. The USB family handles this by reinterpreting some function parameters (where appropriate) and adding a couple of new functions. This section summarizes these changes; for reference documentation, see documentation for <code>IOUSBLib.h</code> in <em><a href="../../../../Darwin/Reference/IOKit/index.html#//apple_ref/doc/uid/TP30000815" target="_top">I/O Kit Framework Reference</a></em>.</p><p>The functions you use to read from and write to isochronous endpoints are <code><!--a target="_top" -->ReadIsochPipeAsync<!--/a--></code> and <code><!--a target="_top" -->WriteIsochPipeAsync<!--/a--></code>. Both functions include the following two parameters:</p><ul class="spaceabove"><li class="li"><p><em>numFrames</em>—The number of frames for which to transfer data</p></li><li class="li"><p><em>frameList</em>—A pointer to an array of structures that describe the frames</p></li></ul><p>If you need to handle high-speed isochronous transfers, you can think of these parameters as referring to “transfer opportunities” instead of frames. In other words, <em>numFrames</em> can refer to a number of frames for full-speed devices or to a number of microframes for high-speed devices. Similarly, <em>frameList</em> specifies the list of transfers you want to occur, whether they are in terms of frames or microframes.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40002644-DontLinkElementID_13" title="Note"></a><p><strong>Note:</strong>&nbsp;The <code><!--a-->ReadIsochPipeAsync<!--/a--></code> and <code><!--a-->WriteIsochPipeAsync<!--/a--></code> functions also have the <em>frameStart</em> parameter in common, but it does not get reinterpreted. This is because all isochronous transactions, including high-speed isochronous transactions, start on a frame boundary, not a microframe boundary.</p></div><p>To help you determine whether a device is functioning in full-speed or high-speed mode, the USB family added the <code><!--a-->GetFrameListTime<!--/a--></code> function, which returns the number of microseconds in a frame. By examining the result (<code><!--a  -->kUSBFullSpeedMicrosecondsInFrame<!--/a--></code> or <code><!--a  -->kUSBHighSpeedMicrosecondsInFrame<!--/a--></code>) you can tell in which mode the device is operating.</p><p>The USB family also added the <code><!--a-->GetBusMicroFrameNumber<!--/a--></code> function which is similar to the <code><!--a-->GetBusFrameNumber<!--/a--></code> function, except that it returns both the current frame and microframe number and includes the time at which that information was retrieved.</p><p>To handle the new specification’s requirement that isochronous endpoints in a device’s default interface have a maximum packet size of zero, the USB family added functions that allow you to balance bandwidth allocations among isochronous endpoints. A typical scenario is this:</p><ol class="ol"><li class="li"><p>Call <code><!--a-->GetBandwidthAvailable<!--/a--></code> (available in Mac OS X version 10.2 and later) to determine how much bandwidth is currently available for allocation to isochronous endpoints.</p></li><li class="li"><p>Call <code><!--a-->GetEndpointProperties<!--/a--></code> (available in Mac OS X version 10.2 and later) to examine the alternate settings of an interface and find one that uses an appropriate amount of bandwidth.</p></li><li class="li"><p>Call <code><!--a-->SetAlternateInterface<!--/a--></code> (available in Mac OS X version 10.0 and later) to create the desired interface and allocate the pipe objects.</p></li><li class="li"><p>Call <code><!--a-->GetPipeProperties<!--/a--></code> (available in Mac OS X version 10.0 and later) on the chosen isochronous endpoint. This is a very important step because <code><!--a-->SetAlternateInterface<!--/a--></code> will succeed, even if there is not enough bandwidth for the endpoints. Also, another device might have claimed the bandwidth that was available at the time the <code><!--a-->GetBandwidthAvailable<!--/a--></code> function returned. If this happens, the maximum packet size for your chosen endpoint (contained in the <code>maxPacketSize</code> field) is now zero, which means that the bandwidth is no longer available.</p></li></ol><p>In addition, in Mac OS X version 10.2, the USB family added the <code><!--a-->SetPipePolicy<!--/a--></code> function, which allows you to relinquish bandwidth that might have been specified in an alternate setting.</p><a name="//apple_ref/doc/uid/TP40002644-DontLinkElementID_7" title="USB Device Access in an Intel-Based Macintosh"></a><h2>USB Device Access in an Intel-Based Macintosh</h2><p>This section provides an overview of some of the issues related to developing a universal binary version of an application that accesses a USB device. Before you read this section, be sure to read <em><a href="../../../../MacOSX/Conceptual/universal_binary/index.html#//apple_ref/doc/uid/TP40002217" target="_top">Universal Binary Programming Guidelines, Second Edition</a></em>. That document covers architectural differences and byte-ordering formats and provides comprehensive guidelines for code modification and building universal binaries. The guidelines in that document apply to all types of applications, including those that access hardware.</p><p>Before you build your application as a universal binary, make sure that:</p><ul class="ul"><li class="li"><p>You port your project to GCC 4 (Xcode uses GCC 4 to target Intel-based Macintosh computers)</p></li><li class="li"><p>You install the Mac OS X v10.4 universal SDK</p></li><li class="li"><p>You develop your project in Xcode 2.1 or later</p></li></ul><p>The USB bus is a little-endian bus. Structured data appears on the bus in the little-endian format regardless of the native endian format of the computer an application is running in. If you've developed a USB device-access application to run in a PowerPC-based Macintosh, you probably perform some byte swapping on data you read from the USB bus because the PowerPC processor uses the big-endian format. For example, the USB configuration descriptor structure contains a two-byte field that holds the descriptor length. If your PowerPC application reads this structure from the USB bus (instead of receiving it from a USB device interface function), you need to swap the value from the USB bus format (little endian) to the PowerPC format (big endian).</p><p>The USB family provides several swapping macros that swap from USB to host and from host to USB (for more information on these macros, see <span class="content_text"><a href="../../../../../documentation/Darwin/Reference/IOKit/USB/index.html" target="_top">USB.h</a></span>). The Kernel framework also provides byte-swapping macros and functions you can use in high-level applications (see the <code>OSByteOrder.h</code> header file in <code>libkern</code>). If you use these macros in your application, you shouldn't have any trouble developing a universal binary version of your application. This is because these macros determine at compile time if a swap is necessary. If, however, your application uses hard-coded swaps from little endian to big endian, your application will not run correctly in an Intel-based Macintosh. As you develop a universal binary version of your application, therefore, be sure to use the USB family swapping macros or the macros in <code>libkern/OSByteOrder.h</code> for all byte swapping.</p><p>Although you may need to perform byte swapping on values your application reads from the USB bus, you do not need to perform any byte swapping on values you pass in arguments to functions in the USB family API. You should pass argument values in the computer's host format. Likewise, any values you receive from the USB family functions will be in the computer's host format.</p>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../USBIntro/USBIntro.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../USBDeviceInterfaces/USBDevInterfaces.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2002, 2007 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2007-09-04<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/DeviceDrivers/Conceptual/USBBook/USBOverview/USBOverview.html%3Fid%3DTP40000973-4.7&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/DeviceDrivers/Conceptual/USBBook/USBOverview/USBOverview.html%3Fid%3DTP40000973-4.7&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/DeviceDrivers/Conceptual/USBBook/USBOverview/USBOverview.html%3Fid%3DTP40000973-4.7&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>