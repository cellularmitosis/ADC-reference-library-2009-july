/****************************************************//*													*//*	File:		imageFilter.c						*//*													*//*	Program:	Imageer								*//*													*//*	By:			Jason Hodges-Harris					*//*													*//*	Created:	26/10/95  00:00:00 AM				*//*													*//*	Version:	1.0.0d3								*//*													*//*	Copyright:	© 1995-96 Apple Computer, Inc.,		*/ /*					all rights reserved.			*/		/*													*//****************************************************//**** Macintosh Toolbox Headers *****/#ifndef __CURSORCTL__#include <CursorCtl.h>#endif#ifndef __OSUTILS__#include <OSUtils.h>#endif#ifndef __TOOLUTILS__#include <ToolUtils.h>#endif/****   Application headers and prototypes   ****/#ifndef __IMAGEERAPPHEADER__#include "Imageer.app.h"#endif#ifndef __IMAGEERPROTOSHEADER__#include "Imageer.protos.h"#endif/****	Default RGB Colors	****/static const RGBColor 	kRGBBlack = {0x0000, 0x0000, 0x0000};static const RGBColor	kRGBWhite = {0xFFFF, 0xFFFF, 0xFFFF};/****	Smoothing filter	****/#pragma segment filtersOSErr ImageSmoothFilter (ImageDocHndl	theDocHndl, WindowPtr theWindow){	PixMapHandle	thePixMapHndl = nil;	CursHandle		watchCrsr;	Ptr				theGWorldBaseAddr = nil,					currentAddr = nil,					lineBufferPtr = nil;	GrafPtr			oldPort;	long			spinCounter = 0,					imageRowSize,					xSize,					ySize,					xCount,					yCount,					xBounds,					yBounds;	unsigned short	smoothValueRed,					smoothValueGreen,					smoothValueBlue,					smoothValue,					currentBufferLine,					counter;	OSErr			error = noErr;		thePixMapHndl = GetGWorldPixMap((*theDocHndl)->theImageWorld);	if (PixMap32Bit(thePixMapHndl))					// if 32bit mode needed == true		SaveSetMMUMode(true);	if (!LockPixels(thePixMapHndl))		error = kFailedLockPixels;	if (!error)	{		currentAddr = theGWorldBaseAddr = GetPixBaseAddr(thePixMapHndl);		// *GWorld base Addr		xBounds = xSize = (**thePixMapHndl).bounds.right-(**thePixMapHndl).bounds.left;		yBounds = ySize = (**thePixMapHndl).bounds.bottom-(**thePixMapHndl).bounds.top;		xBounds--;	// reduce filter map bounds to stop overflow Using 3*3 matrix		yBounds--;		imageRowSize = (**thePixMapHndl).rowBytes & 0x3FFF;	// get rowbytes size for image		switch ((*(*theDocHndl)->theImageWorld->portPixMap)->pixelSize)		{			case 1:		// B/W 1bit depth			case 2:		// 4 color 2 bit depth			case 4:		// 16 color 4 bit depth				DisplayAlert (rGenWarning,rErrMessages,iNotImplemented);			break;			case 8:		// 256 color 8 bit depth				lineBufferPtr = NewPtr(3*xSize);				if (!lineBufferPtr)					error = kPtrNotCreated;				if (!error)				{					watchCrsr = GetCursor(watchCursor);					SetCursor(*watchCrsr);					currentBufferLine = 0;					counter = 1;					for (yCount=0;yCount<yBounds;yCount++)					{						RotateCursor(spinCounter+=2);						for (xCount=0;xCount<xBounds;xCount++)						{							smoothValue = 0;	// reset smoothing accumulator							// unrolled loop to smooth 3x3 pixel area							smoothValue+=(unsigned char)currentAddr[0];							smoothValue+=(unsigned char)currentAddr[1];							smoothValue+=(unsigned char)currentAddr[2];							smoothValue+=(unsigned char)currentAddr[0+imageRowSize];							smoothValue+=(unsigned char)currentAddr[1+imageRowSize];							smoothValue+=(unsigned char)currentAddr[2+imageRowSize];							smoothValue+=(unsigned char)currentAddr[0+imageRowSize+imageRowSize];							smoothValue+=(unsigned char)currentAddr[1+imageRowSize+imageRowSize];							smoothValue+=(unsigned char)currentAddr[2+imageRowSize+imageRowSize];							// centre pixel of 3x3 grid smoothed Equivalent of smoothValue							lineBufferPtr[counter] = smoothValue * 0.11111111; // same as /9 but faster!							counter++;							currentAddr++;	// new pixel block to smooth						}						counter++;			// correct offset to next line						currentAddr=theGWorldBaseAddr+(imageRowSize*(yCount+1)); // set addr to start next line						currentBufferLine++;						if (currentBufferLine == 3)						{							BlockMoveData(&lineBufferPtr[1],&theGWorldBaseAddr[((yCount-1)*imageRowSize)+1],xBounds-1);							BlockMoveData(&lineBufferPtr[xSize+1],&theGWorldBaseAddr[(yCount*imageRowSize)+1],xBounds-1);							BlockMoveData(&lineBufferPtr[(xSize*2)+1],&lineBufferPtr[1],xBounds-1);							currentBufferLine = 1;							counter = xSize+1;						}												}					while (currentBufferLine>0)					{						BlockMoveData(&lineBufferPtr[(xSize*currentBufferLine)+1],							&theGWorldBaseAddr[((yCount-(currentBufferLine))*imageRowSize)+1],xBounds-1);						currentBufferLine--;					}					SetCursor(&qd.arrow);					GetPort(&oldPort);					SetPort(theWindow);					InvalRect(&theWindow->portRect);					SetPort(oldPort);				}			break;			case 16:		// 32k colors 16 bit depth				DisplayAlert (rGenWarning,rErrMessages,iNotImplemented);			break;			case 32:		// 16.7m color 32 bit depth				lineBufferPtr = NewPtr(3*(xSize*4));				if (!lineBufferPtr)					error = kPtrNotCreated;				if (!error)				{					watchCrsr = GetCursor(watchCursor);					SetCursor(*watchCrsr);					currentBufferLine = 0;					counter = 4;					for (yCount=0;yCount<yBounds;yCount++)					{						RotateCursor(spinCounter+=2);						for (xCount=0;xCount<xBounds;xCount++)						{							smoothValueRed = 0;							smoothValueGreen = 0;							smoothValueBlue = 0;	// reset smoothing accumulators							// unrolled loop to smooth 3x3 pixel area							smoothValueRed+=(unsigned char)currentAddr[1];							smoothValueGreen+=(unsigned char)currentAddr[2];							smoothValueBlue+=(unsigned char)currentAddr[3];							smoothValueRed+=(unsigned char)currentAddr[5];							smoothValueGreen+=(unsigned char)currentAddr[6];							smoothValueBlue+=(unsigned char)currentAddr[7];							smoothValueRed+=(unsigned char)currentAddr[9];							smoothValueGreen+=(unsigned char)currentAddr[10];							smoothValueBlue+=(unsigned char)currentAddr[11];							smoothValueRed+=(unsigned char)currentAddr[1+imageRowSize];							smoothValueGreen+=(unsigned char)currentAddr[2+imageRowSize];							smoothValueBlue+=(unsigned char)currentAddr[3+imageRowSize];							smoothValueRed+=(unsigned char)currentAddr[5+imageRowSize];							smoothValueGreen+=(unsigned char)currentAddr[6+imageRowSize];							smoothValueBlue+=(unsigned char)currentAddr[7+imageRowSize];							smoothValueRed+=(unsigned char)currentAddr[9+imageRowSize];							smoothValueGreen+=(unsigned char)currentAddr[10+imageRowSize];							smoothValueBlue+=(unsigned char)currentAddr[11+imageRowSize];							smoothValueRed+=(unsigned char)currentAddr[1+imageRowSize+imageRowSize];							smoothValueGreen+=(unsigned char)currentAddr[2+imageRowSize+imageRowSize];							smoothValueBlue+=(unsigned char)currentAddr[3+imageRowSize+imageRowSize];							smoothValueRed+=(unsigned char)currentAddr[5+imageRowSize+imageRowSize];							smoothValueGreen+=(unsigned char)currentAddr[6+imageRowSize+imageRowSize];							smoothValueBlue+=(unsigned char)currentAddr[7+imageRowSize+imageRowSize];							smoothValueRed+=(unsigned char)currentAddr[9+imageRowSize+imageRowSize];							smoothValueGreen+=(unsigned char)currentAddr[10+imageRowSize+imageRowSize];							smoothValueBlue+=(unsigned char)currentAddr[11+imageRowSize+imageRowSize];							// top left of 3x3 grid smoothed Equivalent of smoothValue							lineBufferPtr[counter+1] = smoothValueRed * 0.11111111;							lineBufferPtr[counter+2] = smoothValueGreen * 0.11111111;							lineBufferPtr[counter+3] = smoothValueBlue * 0.11111111;							counter+=4;							currentAddr+=4; // new pixel block to smooth						} 						counter+=4;			// correct offset to next line						currentAddr=theGWorldBaseAddr+(imageRowSize*(yCount+1)); // set addr to start next line						currentBufferLine++;						if (currentBufferLine == 3)						{							BlockMoveData(&lineBufferPtr[4],&theGWorldBaseAddr[((yCount-1)*imageRowSize)+4],(xBounds*4)-4);							BlockMoveData(&lineBufferPtr[(xSize*4)+4],&theGWorldBaseAddr[(yCount*imageRowSize)+4],(xBounds*4)-4);							BlockMoveData(&lineBufferPtr[(xSize*8)+4],&lineBufferPtr[4],(xBounds*4)-4);							currentBufferLine = 1;							counter = (xSize*4)+4;						}					}					while (currentBufferLine>0)					{						BlockMoveData(&lineBufferPtr[(xSize*currentBufferLine*4)+1],							&theGWorldBaseAddr[((yCount-(currentBufferLine))*imageRowSize)+1],xBounds-1);						currentBufferLine--;					}				}				SetCursor(&qd.arrow);				GetPort(&oldPort);				SetPort(theWindow);				InvalRect(&theWindow->portRect);				SetPort(oldPort);			break;		}	}	UnlockPixels(thePixMapHndl);			// unlock GWorld	SaveSetMMUMode(false);	return error;}/****	Edge Detection / High Pass filter	****/#pragma segment filtersOSErr ImageHiPassFilter (ImageDocHndl	theDocHndl, WindowPtr theWindow){	PixMapHandle	thePixMapHndl = nil;	CursHandle		watchCrsr;	Ptr				theGWorldBaseAddr = nil,					currentAddr = nil,					lineBufferPtr = nil;	GrafPtr			oldPort;	long			spinCounter = 0,					imageRowSize,					xSize,					ySize,					xCount,					yCount,					xBounds,					yBounds;	short			currentBufferLine,					counter;	signed short	matrixValueRed,					matrixValueGreen,					matrixValueBlue,					matrixValue;	OSErr			error = noErr;	signed char		theAddrMode = true32b;	Boolean			swapModeNeeded = false;		thePixMapHndl = GetGWorldPixMap((*theDocHndl)->theImageWorld);	if (PixMap32Bit(thePixMapHndl))					// if 32bit mode needed == true		SaveSetMMUMode(true);	if (!LockPixels(thePixMapHndl))		error = kFailedLockPixels;	if (!error)	{		currentAddr = theGWorldBaseAddr = GetPixBaseAddr(thePixMapHndl);		// *GWorld base Addr		xBounds = xSize = (**thePixMapHndl).bounds.right-(**thePixMapHndl).bounds.left;		yBounds = ySize = (**thePixMapHndl).bounds.bottom-(**thePixMapHndl).bounds.top;		xBounds--;	// reduce filter map bounds to stop overflow Using 3*3 matrix		yBounds--;		imageRowSize = (**thePixMapHndl).rowBytes & 0x3FFF;	// get rowbytes size for image		switch ((*(*theDocHndl)->theImageWorld->portPixMap)->pixelSize)		{			case 1:		// B/W 1bit depth			case 2:		// 4 color 2 bit depth			case 4:		// 16 color 4 bit depth				DisplayAlert (rGenWarning,rErrMessages,iNotImplemented);			break;			case 8:		// 256 color 8 bit depth				lineBufferPtr = NewPtr(3*xSize);				if (!lineBufferPtr)					error = kPtrNotCreated;				if (!error)				{					watchCrsr = GetCursor(watchCursor);					SetCursor(*watchCrsr);					currentBufferLine = 0;					counter = 1;					for (yCount=0;yCount<yBounds;yCount++)					{						RotateCursor(spinCounter+=2);						for (xCount=0;xCount<xBounds;xCount++)						{							matrixValue = 0;	// reset smoothing accumulator							// unrolled loop to smooth 3x3 pixel area							// Line 1, 2nd matrix pixel only used							matrixValue-=(unsigned char)currentAddr[1]; // create smoothed pixel							// line 2, all 3 matrix pixels used							matrixValue-=(unsigned char)currentAddr[0+imageRowSize]; // create smoothed pixel							// 2nd pixel rolled out 4 times							matrixValue+=(unsigned char)currentAddr[1+imageRowSize]; // create smoothed pixel							matrixValue+=(unsigned char)currentAddr[1+imageRowSize]; // create smoothed pixel							matrixValue+=(unsigned char)currentAddr[1+imageRowSize]; // create smoothed pixel							matrixValue+=(unsigned char)currentAddr[1+imageRowSize]; // create smoothed pixel							matrixValue-=(unsigned char)currentAddr[2+imageRowSize]; // create smoothed pixel							// Line 3, 2nd pixel only used							matrixValue-=(unsigned char)currentAddr[1+imageRowSize+imageRowSize]; // create smoothed pixel							lineBufferPtr[counter] = matrixValue;							counter++;							currentAddr++;	// new pixel block to smooth						}						counter++;			// correct offset to next line						currentAddr=theGWorldBaseAddr+(imageRowSize*(yCount+1)); // set addr to start next line						currentBufferLine++;						if (currentBufferLine == 3)						{							BlockMoveData(&lineBufferPtr[1],&theGWorldBaseAddr[((yCount-1)*imageRowSize)+1],xBounds-1);							BlockMoveData(&lineBufferPtr[xSize+1],&theGWorldBaseAddr[(yCount*imageRowSize)+1],xBounds-1);							BlockMoveData(&lineBufferPtr[(xSize*2)+1],&lineBufferPtr[1],xBounds-1);							currentBufferLine = 1;							counter = xSize+1;						}												}					while (currentBufferLine>0)					{						BlockMoveData(&lineBufferPtr[(xSize*currentBufferLine)+1],							&theGWorldBaseAddr[((yCount-(currentBufferLine))*imageRowSize)+1],xBounds-1);						currentBufferLine--;					}					SetCursor(&qd.arrow);					GetPort(&oldPort);					SetPort(theWindow);					InvalRect(&theWindow->portRect);					SetPort(oldPort);				}			break;			case 16:		// 32k colors 16 bit depth				DisplayAlert (rGenWarning,rErrMessages,iNotImplemented);			break;			case 32:		// 16.7m color 32 bit depth				lineBufferPtr = NewPtr(3*(xSize*4));				if (!lineBufferPtr)					error = kPtrNotCreated;				if (!error)				{					watchCrsr = GetCursor(watchCursor);					SetCursor(*watchCrsr);					currentBufferLine = 0;					counter = 4;					for (yCount=0;yCount<yBounds;yCount++)					{						RotateCursor(spinCounter+=2);						for (xCount=0;xCount<xBounds;xCount++)						{							matrixValueRed = 0;							matrixValueGreen = 0;							matrixValueBlue = 0;	// reset smoothing accumulators							// unrolled loop to smooth 3x3 pixel area							// Line 1, 2nd matrix pixel only used							matrixValueRed-=(unsigned char)currentAddr[5];							matrixValueGreen-=(unsigned char)currentAddr[6];							matrixValueBlue-=(unsigned char)currentAddr[7];							// line 2, all 3 matrix pixels used							matrixValueRed-=(unsigned char)currentAddr[1+imageRowSize];							matrixValueGreen-=(unsigned char)currentAddr[2+imageRowSize];							matrixValueBlue-=(unsigned char)currentAddr[3+imageRowSize];							// 2nd pixel rolled out 4 times							matrixValueRed+=(unsigned char)currentAddr[5+imageRowSize];							matrixValueGreen+=(unsigned char)currentAddr[6+imageRowSize];							matrixValueBlue+=(unsigned char)currentAddr[7+imageRowSize];							matrixValueRed+=(unsigned char)currentAddr[5+imageRowSize];							matrixValueGreen+=(unsigned char)currentAddr[6+imageRowSize];							matrixValueBlue+=(unsigned char)currentAddr[7+imageRowSize];							matrixValueRed+=(unsigned char)currentAddr[5+imageRowSize];							matrixValueGreen+=(unsigned char)currentAddr[6+imageRowSize];							matrixValueBlue+=(unsigned char)currentAddr[7+imageRowSize];							matrixValueRed+=(unsigned char)currentAddr[5+imageRowSize];							matrixValueGreen+=(unsigned char)currentAddr[6+imageRowSize];							matrixValueBlue+=(unsigned char)currentAddr[7+imageRowSize];							matrixValueRed-=(unsigned char)currentAddr[9+imageRowSize];							matrixValueGreen-=(unsigned char)currentAddr[10+imageRowSize];							matrixValueBlue-=(unsigned char)currentAddr[11+imageRowSize];							// Line 3, 2nd pixel only used							matrixValueRed-=(unsigned char)currentAddr[5+imageRowSize+imageRowSize];							matrixValueGreen-=(unsigned char)currentAddr[6+imageRowSize+imageRowSize];							matrixValueBlue-=(unsigned char)currentAddr[7+imageRowSize+imageRowSize];							// top left of 3x3 grid smoothed Equivalent of matrixValue							matrixValueRed = matrixValueRed > 255 ? 255 : matrixValueRed;							matrixValueRed = matrixValueRed < 0 ? 0 : matrixValueRed;							matrixValueGreen = matrixValueGreen > 255 ? 255 : matrixValueGreen;							matrixValueGreen = matrixValueGreen < 0 ? 0 : matrixValueGreen;							matrixValueBlue = matrixValueBlue > 255 ? 255 : matrixValueBlue;							matrixValueBlue = matrixValueBlue < 0 ? 0 : matrixValueBlue;							// top left of 3x3 grid smoothed Equivalent of smoothValue							lineBufferPtr[counter+1] = matrixValueRed;							lineBufferPtr[counter+2] = matrixValueGreen;							lineBufferPtr[counter+3] = matrixValueBlue;							counter+=4;							currentAddr+=4; // new pixel block to smooth						} 						counter+=4;			// correct offset to next line						currentAddr=theGWorldBaseAddr+(imageRowSize*(yCount+1)); // set addr to start next line						currentBufferLine++;						if (currentBufferLine == 3)						{							BlockMoveData(&lineBufferPtr[4],&theGWorldBaseAddr[((yCount-1)*imageRowSize)+4],(xBounds*4)-4);							BlockMoveData(&lineBufferPtr[(xSize*4)+4],&theGWorldBaseAddr[(yCount*imageRowSize)+4],(xBounds*4)-4);							BlockMoveData(&lineBufferPtr[(xSize*8)+4],&lineBufferPtr[4],(xBounds*4)-4);							currentBufferLine = 1;							counter = (xSize*4)+4;						}					}					while (currentBufferLine>0)					{						BlockMoveData(&lineBufferPtr[(xSize*currentBufferLine*4)+1],							&theGWorldBaseAddr[((yCount-(currentBufferLine))*imageRowSize)+1],xBounds-1);						currentBufferLine--;					}				}				SetCursor(&qd.arrow);				GetPort(&oldPort);				SetPort(theWindow);				InvalRect(&theWindow->portRect);				SetPort(oldPort);			break;		}	}	UnlockPixels(thePixMapHndl);	SaveSetMMUMode(false);	return error;}/**** custom color proc to invert direct color image	****/#pragma segment filterspascal Boolean InvertDirectColor(RGBColor *color,long *position){	color->red = 0xFFFF - color->red;	color->green = 0xFFFF - color->green;	color->blue = 0xFFFF - color->blue;	return false;}/****	directly manipulate index image color table to invert colors	****/#pragma segment filtersOSErr InvertColorTable (ImageDocHndl	theDocHndl){	CTabPtr		theColorTabPtr;	short		numberColors,				count;	OSErr		error = noErr;		numberColors = 1 << (*(*theDocHndl)->theImageWorld->portPixMap)->pixelSize;	HLock((Handle)(**(**theDocHndl).theImageWorld->portPixMap).pmTable);	theColorTabPtr = *(**(**theDocHndl).theImageWorld->portPixMap).pmTable;	for (count = 0;count < numberColors;count++)	{		theColorTabPtr->ctTable[count].rgb.red = 0xFFFF - theColorTabPtr->ctTable[count].rgb.red;		theColorTabPtr->ctTable[count].rgb.green = 0xFFFF - theColorTabPtr->ctTable[count].rgb.green;		theColorTabPtr->ctTable[count].rgb.blue = 0xFFFF - theColorTabPtr->ctTable[count].rgb.blue;	}	CTabChanged((**(**theDocHndl).theImageWorld->portPixMap).pmTable);	HUnlock((Handle)(**(**theDocHndl).theImageWorld->portPixMap).pmTable);	return error;}/****	function to action color inversion	****/#pragma segment filtersOSErr	ColorImageInverter (ImageDocHndl	theDocHndl, WindowPtr theWindow){	PixMapHandle	thePixMapHndl = nil;	ColorSearchUPP	theInvertColorSearchUPP;	CGrafPtr		oldPort;	GDHandle		oldGDev;	RGBColor		oldForeColor,					oldBackColor;	OSErr			error = noErr;		GetGWorld(&oldPort,&oldGDev);	thePixMapHndl = GetGWorldPixMap((**theDocHndl).theImageWorld);	if (PixMap32Bit(thePixMapHndl))		SaveSetMMUMode(true);	if (!LockPixels(thePixMapHndl))		error = kFailedLockPixels;	if (!error)	{		switch ((*(*theDocHndl)->theImageWorld->portPixMap)->pixelSize)		{			case 1:			case 2:			case 4:			case 8:				SaveTempImageFile(theDocHndl, kColorTableOp);				InvertColorTable(theDocHndl);			break;			case 16:			case 32:				SaveTempImageFile(theDocHndl, kPixMapOp);				SetGWorld((**theDocHndl).theImageWorld,nil);				GetForeColor(&oldForeColor);				GetBackColor(&oldBackColor);				RGBForeColor(&kRGBBlack);				RGBBackColor(&kRGBWhite);				theInvertColorSearchUPP = NewColorSearchProc(InvertDirectColor);				AddSearch((ColorSearchUPP)theInvertColorSearchUPP);				CopyBits((BitMap*)(*thePixMapHndl),					 (BitMap*)(*thePixMapHndl),					 &(**theDocHndl).theImageWorld->portRect,					 &(**theDocHndl).theImageWorld->portRect,srcCopy,nil);				DelSearch((ColorSearchUPP)theInvertColorSearchUPP);				DisposeRoutineDescriptor((UniversalProcPtr)theInvertColorSearchUPP);				RGBForeColor(&oldForeColor);				RGBBackColor(&oldBackColor);						break;		}	}	UnlockPixels(thePixMapHndl);	SaveSetMMUMode(false);	SetGWorld((CGrafPtr)theWindow,oldGDev);	InvalRect(&theWindow->portRect);	// Invalidate current window contents to force update	SetGWorld(oldPort,oldGDev);	return error;}/****	mirror image through the y axis	****/#pragma segment filtersOSErr MirrorImageVertical(ImageDocHndl	theDocHndl, WindowPtr theWindow){	PixMapHandle	thePixMapHndl = nil;	Ptr				lineBufferPtr = nil,					imageLinePtr;	CGrafPtr		oldPort;	GDHandle		oldGDev;	OSErr			error = noErr;	short			imageRowSize,					thePixMapRowBytes,					xCount,					yCount,					xSize,					ySize,					count;		GetGWorld(&oldPort,&oldGDev);	thePixMapHndl = GetGWorldPixMap((**theDocHndl).theImageWorld);	if (PixMap32Bit(thePixMapHndl))		SaveSetMMUMode(true);	if (!LockPixels(thePixMapHndl))		error = kFailedLockPixels;	else	{		imageRowSize = (**theDocHndl).theImageXSize;		switch ((**theDocHndl).theImageDepth)		{			case 1:				DisplayAlert(rGenAlert,rErrMessages,iNotImplemented);				error = kNotSupported;			break;			case 2:				DisplayAlert(rGenAlert,rErrMessages,iNotImplemented);				error = kNotSupported;			break;			case 4:				DisplayAlert(rGenAlert,rErrMessages,iNotImplemented);				error = kNotSupported;			break;			case 8:				//	1 byte per pixel so no additional calc needed			break;			case 16:				imageRowSize *= 2;			break;			case 32:				imageRowSize *= 4;			break;		}		if (!error)			lineBufferPtr = NewPtr(imageRowSize);		if (!lineBufferPtr)			error = kPtrNotCreated;	}	if (!error)	{		imageLinePtr = GetPixBaseAddr(thePixMapHndl);	// base addr of image GWorld PixMap		thePixMapRowBytes = (**thePixMapHndl).rowBytes & 0x3FFF;		xSize = (**theDocHndl).theImageXSize;		ySize = (**theDocHndl).theImageYSize;		for (yCount = 0;yCount<ySize;yCount++)		{			BlockMoveData(imageLinePtr,lineBufferPtr,imageRowSize);				switch ((**theDocHndl).theImageDepth)			{				case 8:					count = 0;					for (xCount = xSize-1;xCount>=0;xCount--)					{						BlockMoveData(&(lineBufferPtr[xCount]),&imageLinePtr[count++],1);						}				break;				case 16:					count = 0;					for (xCount = (xSize*2)-2;xCount>=0;xCount-=2)					{						BlockMoveData(&(lineBufferPtr[xCount]),&imageLinePtr[count],2);						count+=2;					}				break;				case 32:					count = 0;					for (xCount = (xSize*4)-4;xCount>=0;xCount-=4)					{						BlockMoveData(&(lineBufferPtr[xCount]),&imageLinePtr[count],4);						count+=4;					}				break;			}			imageLinePtr += thePixMapRowBytes;		}	}	UnlockPixels(thePixMapHndl);	SaveSetMMUMode(false);	SetGWorld((CGrafPtr)theWindow,oldGDev);	InvalRect(&theWindow->portRect);	SetGWorld(oldPort,oldGDev);	DisposePtr(lineBufferPtr);	return error;}/****	mirror image through the x axis	****/#pragma segment filtersOSErr MirrorImageHorizontal(ImageDocHndl	theDocHndl, WindowPtr theWindow){	PixMapHandle	thePixMapHndl = nil;	Ptr				lineBufferPtr = nil,					basePixMapAddr,					imageLinePtr;	CGrafPtr		oldPort;	GDHandle		oldGDev;	OSErr			error = noErr;	short			imageRowSize,					thePixMapRowBytes,					yCount,					yMidValue,					destinationLine,					xSize,					ySize;		GetGWorld(&oldPort,&oldGDev);	thePixMapHndl = GetGWorldPixMap((**theDocHndl).theImageWorld);	if (PixMap32Bit(thePixMapHndl))		SaveSetMMUMode(true);	if (!LockPixels(thePixMapHndl))		error = kFailedLockPixels;	else	{		imageRowSize = (**theDocHndl).theImageXSize;		switch ((**theDocHndl).theImageDepth)		{			case 1:				DisplayAlert(rGenAlert,rErrMessages,iNotImplemented);				error = kNotSupported;			break;			case 2:				DisplayAlert(rGenAlert,rErrMessages,iNotImplemented);				error = kNotSupported;			break;			case 4:				DisplayAlert(rGenAlert,rErrMessages,iNotImplemented);				error = kNotSupported;			break;			case 8:				//	1 byte per pixel so no additional calc needed			break;			case 16:				imageRowSize *= 2;			break;			case 32:				imageRowSize *= 4;			break;		}		if (!error)			lineBufferPtr = NewPtr(imageRowSize);		if (!lineBufferPtr)			error = kPtrNotCreated;	}	if (!error)	{		basePixMapAddr = imageLinePtr = GetPixBaseAddr(thePixMapHndl);		thePixMapRowBytes = (**thePixMapHndl).rowBytes & 0x3FFF;		xSize = (**theDocHndl).theImageXSize;		ySize = (**theDocHndl).theImageYSize;		yMidValue = ySize * 0.5;		destinationLine = ySize-1;		for (yCount = 0;yCount<yMidValue;yCount++)		{			BlockMoveData(imageLinePtr,lineBufferPtr,imageRowSize);				switch ((**theDocHndl).theImageDepth)			{				case 8:						BlockMoveData(&basePixMapAddr[thePixMapRowBytes*destinationLine],imageLinePtr,imageRowSize);							BlockMoveData(lineBufferPtr,&basePixMapAddr[thePixMapRowBytes*destinationLine],imageRowSize);					break;				case 16:						BlockMoveData(&basePixMapAddr[thePixMapRowBytes*destinationLine],imageLinePtr,imageRowSize);							BlockMoveData(lineBufferPtr,&basePixMapAddr[thePixMapRowBytes*destinationLine],imageRowSize);					break;				case 32:						BlockMoveData(&basePixMapAddr[thePixMapRowBytes*destinationLine],imageLinePtr,imageRowSize);							BlockMoveData(lineBufferPtr,&basePixMapAddr[thePixMapRowBytes*destinationLine],imageRowSize);					break;			}			imageLinePtr += thePixMapRowBytes;			destinationLine--;		}	}	UnlockPixels(thePixMapHndl);	SaveSetMMUMode(false);	SetGWorld((CGrafPtr)theWindow,oldGDev);	InvalRect(&theWindow->portRect);	SetGWorld(oldPort,oldGDev);	DisposePtr(lineBufferPtr);	return error;}/****	Rotate image through 180û	****/#pragma segment filtersOSErr RotateImage180(ImageDocHndl	theDocHndl, WindowPtr theWindow){	PixMapHandle	thePixMapHndl = nil;	Ptr				lineBufferPtr = nil,					basePixMapAddr,					imageLinePtr;	CGrafPtr		oldPort;	GDHandle		oldGDev;	OSErr			error = noErr;	short			imageRowSize,					thePixMapRowBytes,					xCount,					yCount,					yMidValue,					destinationLine,					xSize,					ySize,					count;		GetGWorld(&oldPort,&oldGDev);	thePixMapHndl = GetGWorldPixMap((**theDocHndl).theImageWorld);	if (PixMap32Bit(thePixMapHndl))					// if 32bit mode needed == true		SaveSetMMUMode(true);	if (!LockPixels(thePixMapHndl))		error = kFailedLockPixels;	else	{		imageRowSize = (**theDocHndl).theImageXSize;		switch ((**theDocHndl).theImageDepth)		{			case 1:				DisplayAlert(rGenAlert,rErrMessages,iNotImplemented);				error = kNotSupported;			break;			case 2:				DisplayAlert(rGenAlert,rErrMessages,iNotImplemented);				error = kNotSupported;			break;			case 4:				DisplayAlert(rGenAlert,rErrMessages,iNotImplemented);				error = kNotSupported;			break;			case 8:				//	1 byte per pixel so no additional calc needed			break;			case 16:				imageRowSize *= 2;			break;			case 32:				imageRowSize *= 4;			break;		}		if (!error)			lineBufferPtr = NewPtr(imageRowSize);		if (!lineBufferPtr)			error = kPtrNotCreated;	}	if (!error)	{		basePixMapAddr = imageLinePtr = GetPixBaseAddr(thePixMapHndl);	// base addr of image GWorld PixMap		thePixMapRowBytes = (**thePixMapHndl).rowBytes & 0x3FFF;		xSize = (**theDocHndl).theImageXSize;		ySize = (**theDocHndl).theImageYSize;		yMidValue = ySize * 0.5;		destinationLine = ySize-1;		for (yCount = 0;yCount<yMidValue;yCount++)		{			BlockMoveData(imageLinePtr,lineBufferPtr,imageRowSize);				switch ((**theDocHndl).theImageDepth)			{				case 8:					count = 0;					for (xCount = xSize-1;xCount>=0;xCount--)					{						BlockMoveData(&basePixMapAddr[thePixMapRowBytes*destinationLine+xCount],&imageLinePtr[count],1);							BlockMoveData(&lineBufferPtr[count],&basePixMapAddr[thePixMapRowBytes*destinationLine+xCount],1);						count++;					}				break;				case 16:					count = 0;					for (xCount = (xSize*2)-2;xCount>=0;xCount-=2)					{						BlockMoveData(&basePixMapAddr[thePixMapRowBytes*destinationLine+xCount],&imageLinePtr[count],2);							BlockMoveData(&lineBufferPtr[count],&basePixMapAddr[thePixMapRowBytes*destinationLine+xCount],2);						count+=2;					}				break;				case 32:					count = 0;					for (xCount = (xSize*4)-4;xCount>=0;xCount-=4)					{						BlockMoveData(&basePixMapAddr[thePixMapRowBytes*destinationLine+xCount],&imageLinePtr[count],4);							BlockMoveData(&lineBufferPtr[count],&basePixMapAddr[thePixMapRowBytes*destinationLine+xCount],4);						count+=4;					}				break;			}			imageLinePtr += thePixMapRowBytes;			destinationLine--;		}		if (yMidValue*2 != ySize)		{			imageLinePtr = basePixMapAddr+(thePixMapRowBytes*yMidValue);			BlockMoveData(imageLinePtr,lineBufferPtr,imageRowSize);				switch ((**theDocHndl).theImageDepth)			{				case 8:					count = 0;					for (xCount = xSize-1;xCount>=0;xCount--)						BlockMoveData(&lineBufferPtr[count++],&imageLinePtr[xCount],1);				break;				case 16:					count = 0;					for (xCount = (xSize*2)-2;xCount>=0;xCount-=2)					{						BlockMoveData(&lineBufferPtr[count],&imageLinePtr[xCount],2);						count+=2;					}				break;				case 32:					count = 0;					for (xCount = (xSize*4)-4;xCount>=0;xCount-=4)					{						BlockMoveData(&lineBufferPtr[count],&imageLinePtr[xCount],4);						count+=4;					}				break;			}		}	}	UnlockPixels(thePixMapHndl);		// unlock GWorld	SaveSetMMUMode(false);	SetGWorld((CGrafPtr)theWindow,oldGDev);	InvalRect(&theWindow->portRect);	// Invalidate current window contents to force update	SetGWorld(oldPort,oldGDev);	DisposePtr(lineBufferPtr);	return error;}/****	Image brightness control	****/#pragma segment filtersOSErr	ImageBrightness(ImageDocHndl theDocHndl, WindowPtr theWindow, Boolean isBrighter){	PixMapHandle	thePixMapHndl = nil;	ColorSearchUPP	theBrightnessColorSearchUPP;	CGrafPtr		oldPort;	GDHandle		oldGDev;	RGBColor		oldForeColor,					oldBackColor;	OSErr			error = noErr;		GetGWorld(&oldPort,&oldGDev);	thePixMapHndl = GetGWorldPixMap((**theDocHndl).theImageWorld);	if (PixMap32Bit(thePixMapHndl))					// if 32bit mode needed == true		SaveSetMMUMode(true);	if (!LockPixels(thePixMapHndl))		error = kFailedLockPixels;	if (!error)	{		switch ((*(*theDocHndl)->theImageWorld->portPixMap)->pixelSize)		{			case 1:		// B/W 1bit depth			case 2:			case 4:			case 8:				SaveTempImageFile(theDocHndl, kColorTableOp);				BrightnessColorTable(theDocHndl, isBrighter);			break;			case 16:			case 32:				SaveTempImageFile(theDocHndl, kPixMapOp);				SetGWorld((**theDocHndl).theImageWorld,nil);				GetForeColor(&oldForeColor);				GetBackColor(&oldBackColor);				RGBForeColor(&kRGBBlack);				RGBBackColor(&kRGBWhite);				if (isBrighter)					theBrightnessColorSearchUPP = NewColorSearchProc(DirectColorBrightenProc); // create routine descriptor				else					theBrightnessColorSearchUPP = NewColorSearchProc(DirectColorDarkenProc); // create routine descriptor				AddSearch((ColorSearchUPP)theBrightnessColorSearchUPP);		// add color search				CopyBits((BitMap*)(*thePixMapHndl),					 (BitMap*)(*thePixMapHndl),					 &(**theDocHndl).theImageWorld->portRect,					 &(**theDocHndl).theImageWorld->portRect,srcCopy,nil);				DelSearch((ColorSearchUPP)theBrightnessColorSearchUPP);		// remove search				DisposeRoutineDescriptor((UniversalProcPtr)theBrightnessColorSearchUPP);				RGBForeColor(&oldForeColor);				RGBBackColor(&oldBackColor);						break;		}	}	UnlockPixels(thePixMapHndl);		// unlock GWorld	SaveSetMMUMode(false);	SetGWorld((CGrafPtr)theWindow,oldGDev);	InvalRect(&theWindow->portRect);	// Invalidate current window contents to force update	SetGWorld(oldPort,oldGDev);	return error;}/****	Image contrast control	****/#pragma segment filtersOSErr	ImageContrast(ImageDocHndl theDocHndl, WindowPtr theWindow, Boolean isGreater){	PixMapHandle	thePixMapHndl = nil;	ColorSearchUPP	theContrastColorSearchUPP;	CGrafPtr		oldPort;	GDHandle		oldGDev;	RGBColor		oldForeColor,					oldBackColor;	OSErr			error = noErr;		GetGWorld(&oldPort,&oldGDev);	thePixMapHndl = GetGWorldPixMap((**theDocHndl).theImageWorld);	if (PixMap32Bit(thePixMapHndl))					// if 32bit mode needed == true		SaveSetMMUMode(true);	if (!LockPixels(thePixMapHndl))		error = kFailedLockPixels;	if (!error)	{		switch ((*(*theDocHndl)->theImageWorld->portPixMap)->pixelSize)		{			case 1:		// B/W 1bit depth			case 2:			case 4:			case 8:				SaveTempImageFile(theDocHndl, kColorTableOp);				ContrastColorTable(theDocHndl, isGreater);			break;			case 16:			case 32:				SaveTempImageFile(theDocHndl, kPixMapOp);				SetGWorld((**theDocHndl).theImageWorld,nil);				GetForeColor(&oldForeColor);				GetBackColor(&oldBackColor);				RGBForeColor(&kRGBBlack);				RGBBackColor(&kRGBWhite);				if (isGreater)					theContrastColorSearchUPP = NewColorSearchProc(DirectColorIncContrastProc); // create routine descriptor				else					theContrastColorSearchUPP = NewColorSearchProc(DirectColorDecContrastProc); // create routine descriptor				AddSearch((ColorSearchUPP)theContrastColorSearchUPP);		// add color search				CopyBits((BitMap*)(*thePixMapHndl),					 (BitMap*)(*thePixMapHndl),					 &(**theDocHndl).theImageWorld->portRect,					 &(**theDocHndl).theImageWorld->portRect,srcCopy,nil);				DelSearch((ColorSearchUPP)theContrastColorSearchUPP);		// remove search				DisposeRoutineDescriptor((UniversalProcPtr)theContrastColorSearchUPP);				RGBForeColor(&oldForeColor);				RGBBackColor(&oldBackColor);						break;		}	}	UnlockPixels(thePixMapHndl);	SaveSetMMUMode(false);	SetGWorld((CGrafPtr)theWindow,oldGDev);	InvalRect(&theWindow->portRect);	SetGWorld(oldPort,oldGDev);	return error;}/****	Direct color Brighten color search	****/#pragma segment filterspascal Boolean DirectColorBrightenProc(RGBColor *color,long *position){	long	tempColorRed = color->red,			tempColorGreen = color->green,			tempColorBlue = color->blue;		tempColorRed = (tempColorRed+0x1600) > 0xFFFF ? 0xFFFF : tempColorRed+0x1600;	tempColorGreen = (tempColorGreen+0x1600) > 0xFFFF ? 0xFFFF : tempColorGreen+0x1600;	tempColorBlue = (tempColorBlue+0x1600) > 0xFFFF ? 0xFFFF : tempColorBlue+0x1600;	color->red = tempColorRed;	color->green = tempColorGreen;	color->blue = tempColorBlue;	return false;}/****	Direct color Darken color search	****/#pragma segment filterspascal Boolean DirectColorDarkenProc(RGBColor *color,long *position){	long	tempColorRed = color->red,			tempColorGreen = color->green,			tempColorBlue = color->blue;		tempColorRed = (tempColorRed-0x1600) < 0x0000 ? 0x0000 : tempColorRed-0x1600;	tempColorGreen = (tempColorGreen-0x1600) < 0x0000 ? 0x0000 : tempColorGreen-0x1600;	tempColorBlue = (tempColorBlue-0x1600) < 0x0000 ? 0x0000 : tempColorBlue-0x1600;	color->red = tempColorRed;	color->green = tempColorGreen;	color->blue = tempColorBlue;	return false;}/****	Indexed color image brightness	****/#pragma segment filtersvoid	BrightnessColorTable(ImageDocHndl theDocHndl,Boolean isBrighter){	CTabPtr		theColorTabPtr;	long		tempColorRed,				tempColorGreen,				tempColorBlue;	short		numberColors,				count;	OSErr		error = noErr;		numberColors = 1 << (*(*theDocHndl)->theImageWorld->portPixMap)->pixelSize;	HLock((Handle)(**(**theDocHndl).theImageWorld->portPixMap).pmTable);	theColorTabPtr = *(**(**theDocHndl).theImageWorld->portPixMap).pmTable;	for (count = 0;count < numberColors;count++)	{		tempColorRed = theColorTabPtr->ctTable[count].rgb.red;		tempColorGreen = theColorTabPtr->ctTable[count].rgb.green;		tempColorBlue = theColorTabPtr->ctTable[count].rgb.blue;		if (isBrighter)		{			tempColorRed = (tempColorRed+0x1600) > 0xFFFF ? 0xFFFF : tempColorRed+0x1600;			tempColorGreen = (tempColorGreen+0x1600) > 0xFFFF ? 0xFFFF : tempColorGreen+0x1600;			tempColorBlue = (tempColorBlue+0x1600) > 0xFFFF ? 0xFFFF : tempColorBlue+0x1600;		}		else		{			tempColorRed = (tempColorRed-0x1600) < 0x0000 ? 0x0000 : tempColorRed-0x1600;			tempColorGreen = (tempColorGreen-0x1600) < 0x0000 ? 0x0000 : tempColorGreen-0x1600;			tempColorBlue = (tempColorBlue-0x1600) < 0x0000 ? 0x0000 : tempColorBlue-0x1600;		}		theColorTabPtr->ctTable[count].rgb.red = tempColorRed;		theColorTabPtr->ctTable[count].rgb.green = tempColorGreen;		theColorTabPtr->ctTable[count].rgb.blue = tempColorBlue;	}	CTabChanged((**(**theDocHndl).theImageWorld->portPixMap).pmTable);	HUnlock((Handle)(**(**theDocHndl).theImageWorld->portPixMap).pmTable);}/****	Direct color increase contrast color search	****/#pragma segment filterspascal Boolean DirectColorIncContrastProc(RGBColor *color,long *position){	long	tempColorRed = color->red,			tempColorGreen = color->green,			tempColorBlue = color->blue;		tempColorRed = tempColorRed >= 0x8100 ? tempColorRed+0x1600 : tempColorRed;	tempColorRed = tempColorRed <= 0x7F00 ? tempColorRed-0x01600 : tempColorRed;	tempColorRed = tempColorRed > 0xFFFF ? 0xFFFF : tempColorRed;	tempColorRed = tempColorRed < 0x0000 ? 0x0000 : tempColorRed;	tempColorGreen = tempColorGreen >= 0x8100 ? tempColorGreen+0x1600 : tempColorGreen;	tempColorGreen = tempColorGreen <= 0x7F00 ? tempColorGreen-0x1600 : tempColorGreen;	tempColorGreen = tempColorGreen > 0xFFFF ? 0xFFFF : tempColorGreen;	tempColorGreen = tempColorGreen < 0x0000 ? 0x0000 : tempColorGreen;	tempColorBlue = tempColorBlue >= 0x8100 ? tempColorBlue+0x1600 : tempColorBlue;	tempColorBlue = tempColorBlue <= 0x7F00 ? tempColorBlue-0x1600 : tempColorBlue;	tempColorBlue = tempColorBlue > 0xFFFF ? 0xFFFF : tempColorBlue;	tempColorBlue = tempColorBlue < 0x0000 ? 0x0000 : tempColorBlue;	color->red = tempColorRed;	color->green = tempColorGreen;	color->blue = tempColorBlue;	return false;}/****	Direct color reduce Contrast color search	****/#pragma segment filterspascal Boolean DirectColorDecContrastProc(RGBColor *color,long *position){	long	tempColorRed = color->red,			tempColorGreen = color->green,			tempColorBlue = color->blue;	tempColorRed = (tempColorRed > 0x8000 && tempColorRed < 0x9600) ? 0x8000 : tempColorRed;	tempColorRed = tempColorRed >= 0x9600 ? tempColorRed-0x1600 : tempColorRed;	tempColorRed = (tempColorRed > 0x6A00 && tempColorRed < 0x8000) ? 0x8000 : tempColorRed;	tempColorRed = tempColorRed <= 0x6A00 ? tempColorRed+0x1600 : tempColorRed;	tempColorRed = tempColorRed > 0xFFFF ? 0xFFFF : tempColorRed;	tempColorRed = tempColorRed < 0x0000 ? 0x0000 : tempColorRed;	tempColorGreen = (tempColorGreen > 0x8000 && tempColorGreen < 0x9600) ? 0x8000 : tempColorGreen;	tempColorGreen = tempColorGreen >= 0x9600 ? tempColorGreen-0x1600 : tempColorGreen;	tempColorGreen = (tempColorGreen > 0x6A00 && tempColorGreen < 0x8000) ? 0x8000 : tempColorGreen;	tempColorGreen = tempColorGreen <= 0x6A00 ? tempColorGreen+0x1600 : tempColorGreen;	tempColorGreen = tempColorGreen > 0xFFFF ? 0xFFFF : tempColorGreen;	tempColorGreen = tempColorGreen < 0x0000 ? 0x0000 : tempColorGreen;	tempColorBlue = (tempColorBlue > 0x8000 && tempColorBlue < 0x9600) ? 0x8000 : tempColorBlue;	tempColorBlue = tempColorBlue >= 0x9600 ? tempColorBlue-0x1600 : tempColorBlue;	tempColorBlue = (tempColorBlue > 0x6A00 && tempColorBlue < 0x8000) ? 0x8000 : tempColorBlue;	tempColorBlue = tempColorBlue <= 0x6A00 ? tempColorBlue+0x1600 : tempColorBlue;	tempColorBlue = tempColorBlue > 0xFFFF ? 0xFFFF : tempColorBlue;	tempColorBlue = tempColorBlue < 0x0000 ? 0x0000 : tempColorBlue;	color->red = tempColorRed;	color->green = tempColorGreen;	color->blue = tempColorBlue;	return false;}/****	Indexed color image Contrast	****/#pragma segment filtersvoid	ContrastColorTable(ImageDocHndl theDocHndl,Boolean isGreater){	CTabPtr		theColorTabPtr;	signed long	tempColorRed,				tempColorGreen,				tempColorBlue;	short		numberColors,				count;	OSErr		error = noErr;		numberColors = 1 << (*(*theDocHndl)->theImageWorld->portPixMap)->pixelSize;	HLock((Handle)(**(**theDocHndl).theImageWorld->portPixMap).pmTable);	theColorTabPtr = *(**(**theDocHndl).theImageWorld->portPixMap).pmTable;	for (count = 0;count < numberColors;count++)	{		tempColorRed = theColorTabPtr->ctTable[count].rgb.red;		tempColorGreen = theColorTabPtr->ctTable[count].rgb.green;		tempColorBlue = theColorTabPtr->ctTable[count].rgb.blue;		if (isGreater)		{			tempColorRed = tempColorRed > 0x8000 ? tempColorRed+0x1600 : tempColorRed;			tempColorRed = tempColorRed < 0x8000 ? tempColorRed-0x1600 : tempColorRed;			tempColorRed = tempColorRed > 0xFFFF ? 0xFFFF : tempColorRed;			tempColorRed = tempColorRed < 0x0000 ? 0x0000 : tempColorRed;			tempColorGreen = tempColorGreen > 0x8000 ? tempColorGreen+0x1600 : tempColorGreen;			tempColorGreen = tempColorGreen < 0x8000 ? tempColorGreen-0x1600 : tempColorGreen;			tempColorGreen = tempColorGreen > 0xFFFF ? 0xFFFF : tempColorGreen;			tempColorGreen = tempColorGreen < 0x0000 ? 0x0000 : tempColorGreen;			tempColorBlue = tempColorBlue > 0x8000 ? tempColorBlue+0x1600 : tempColorBlue;			tempColorBlue = tempColorBlue < 0x8000 ? tempColorBlue-0x1600 : tempColorBlue;			tempColorBlue = tempColorBlue > 0xFFFF ? 0xFFFF : tempColorBlue;			tempColorBlue = tempColorBlue < 0x0000 ? 0x0000 : tempColorBlue;		}		else		{			tempColorRed = (tempColorRed > 0x8000 && tempColorRed < 0x9600) ? 0x8000 : tempColorRed;			tempColorRed = tempColorRed >= 0x9600 ? tempColorRed-0x1600 : tempColorRed;			tempColorRed = (tempColorRed >= 0x6A00 && tempColorRed < 0x8000) ? 0x8000 : tempColorRed;			tempColorRed = tempColorRed < 0x6A00 ? tempColorRed+0x1600 : tempColorRed;			tempColorRed = tempColorRed > 0xFFFF ? 0xFFFF : tempColorRed;			tempColorRed = tempColorRed < 0x0000 ? 0x0000 : tempColorRed;			tempColorGreen = (tempColorGreen > 0x8000 && tempColorGreen < 0x9600) ? 0x8000 : tempColorGreen;			tempColorGreen = tempColorGreen >= 0x9600 ? tempColorGreen-0x1600 : tempColorGreen;			tempColorGreen = (tempColorGreen >= 0x6A00 && tempColorGreen < 0x8000) ? 0x8000 : tempColorGreen;			tempColorGreen = tempColorGreen < 0x6A00 ? tempColorGreen+0x1600 : tempColorGreen;			tempColorGreen = tempColorGreen > 0xFFFF ? 0xFFFF : tempColorGreen;			tempColorGreen = tempColorGreen < 0x0000 ? 0x0000 : tempColorGreen;			tempColorBlue = (tempColorBlue > 0x8000 && tempColorBlue < 0x9600) ? 0x8000 : tempColorBlue;			tempColorBlue = tempColorBlue >= 0x9600 ? tempColorBlue-0x1600 : tempColorBlue;			tempColorBlue = (tempColorBlue >= 0x6A00 && tempColorBlue < 0x8000) ? 0x8000 : tempColorBlue;			tempColorBlue = tempColorBlue < 0x6A00 ? tempColorBlue+0x1600 : tempColorBlue;			tempColorBlue = tempColorBlue > 0xFFFF ? 0xFFFF : tempColorBlue;			tempColorBlue = tempColorBlue < 0x0000 ? 0x0000 : tempColorBlue;		}		theColorTabPtr->ctTable[count].rgb.red = tempColorRed;		theColorTabPtr->ctTable[count].rgb.green = tempColorGreen;		theColorTabPtr->ctTable[count].rgb.blue = tempColorBlue;	}	CTabChanged((**(**theDocHndl).theImageWorld->portPixMap).pmTable);	HUnlock((Handle)(**(**theDocHndl).theImageWorld->portPixMap).pmTable);}/****	Remove Color component from image controller	****/#pragma segment filtersOSErr	RemoveColorComponent(ImageDocHndl theDocHndl, WindowPtr theWindow, short theColorComponent){	PixMapHandle	thePixMapHndl = nil;	ColorSearchUPP	theRemoveColorCompSearchUPP;	CGrafPtr		oldPort;	GDHandle		oldGDev;	RGBColor		oldForeColor,					oldBackColor;	OSErr			error = noErr;		GetGWorld(&oldPort,&oldGDev);	thePixMapHndl = GetGWorldPixMap((**theDocHndl).theImageWorld);	if (PixMap32Bit(thePixMapHndl))		SaveSetMMUMode(true);	if (!LockPixels(thePixMapHndl))		error = kFailedLockPixels;	if (!error)	{		switch ((*(*theDocHndl)->theImageWorld->portPixMap)->pixelSize)		{			case 1:			case 2:			case 4:			case 8:				SaveTempImageFile(theDocHndl, kColorTableOp);				RemoveComponentColorTable(theDocHndl, theColorComponent);			break;			case 16:			case 32:				SaveTempImageFile(theDocHndl, kPixMapOp);				SetGWorld((**theDocHndl).theImageWorld,nil);				GetForeColor(&oldForeColor);				GetBackColor(&oldBackColor);				RGBForeColor(&kRGBBlack);				RGBBackColor(&kRGBWhite);				if (kRedComp == theColorComponent)					theRemoveColorCompSearchUPP = NewColorSearchProc(RemoveRedCompProc); 				else if (kGreenComp == theColorComponent)					theRemoveColorCompSearchUPP = NewColorSearchProc(RemoveGreenCompProc);				else if (kBlueComp == theColorComponent)					theRemoveColorCompSearchUPP = NewColorSearchProc(RemoveBlueCompProc);				AddSearch((ColorSearchUPP)theRemoveColorCompSearchUPP);				CopyBits((BitMap*)(*thePixMapHndl),					 (BitMap*)(*thePixMapHndl),					 &(**theDocHndl).theImageWorld->portRect,					 &(**theDocHndl).theImageWorld->portRect,srcCopy,nil);				DelSearch((ColorSearchUPP)theRemoveColorCompSearchUPP);				DisposeRoutineDescriptor((UniversalProcPtr)theRemoveColorCompSearchUPP);				RGBForeColor(&oldForeColor);				RGBBackColor(&oldBackColor);						break;		}	}	UnlockPixels(thePixMapHndl);	SaveSetMMUMode(false);	SetGWorld((CGrafPtr)theWindow,oldGDev);	InvalRect(&theWindow->portRect);	SetGWorld(oldPort,oldGDev);	return error;}/****	Color search to remove Red Color component	****/#pragma segment filterspascal Boolean RemoveRedCompProc(RGBColor *color,long *position){	color->red = 0;	return false;}/****	Color search to remove Red Color component	****/#pragma segment filterspascal Boolean RemoveGreenCompProc(RGBColor *color,long *position){	color->green = 0;	return false;}/****	Color search to remove Red Color component	****/#pragma segment filterspascal Boolean RemoveBlueCompProc(RGBColor *color,long *position){	color->blue = 0;	return false;}/****	Indexed color remove color component	****/#pragma segment filtersvoid	RemoveComponentColorTable(ImageDocHndl theDocHndl,short theColorComponent){	CTabPtr		theColorTabPtr;	short		numberColors,				count;	OSErr		error = noErr;		numberColors = 1 << (*(*theDocHndl)->theImageWorld->portPixMap)->pixelSize;	HLock((Handle)(**(**theDocHndl).theImageWorld->portPixMap).pmTable);	theColorTabPtr = *(**(**theDocHndl).theImageWorld->portPixMap).pmTable;	for (count = 0;count < numberColors;count++)	{		if (kRedComp == theColorComponent)			theColorTabPtr->ctTable[count].rgb.red = 0;		else if (kGreenComp == theColorComponent)			theColorTabPtr->ctTable[count].rgb.green = 0;		else if (kBlueComp == theColorComponent)			theColorTabPtr->ctTable[count].rgb.blue = 0;	}	CTabChanged((**(**theDocHndl).theImageWorld->portPixMap).pmTable);	HUnlock((Handle)(**(**theDocHndl).theImageWorld->portPixMap).pmTable);}