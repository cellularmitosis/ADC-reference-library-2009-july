<html>	<head>		<meta http-equiv="content-type" content="text/html;charset=iso-8859-1">		<meta name="generator" content="GoLive CyberStudio 3">		<title>EOControl Introduction</title>	</head>	<body bgcolor="white">		<!-- start of header -->		<!--#include virtual="/includes/framesetheader" -->		<!-- end of header --><!-- start of path --><table cellspacing=0 border=0 width=600 valign="left"><tr><td scope="row"><font face="Geneva,Helvetica,Arial" size="1"><b>PATH<spacer type="horizontal" size="5">&nbsp;</b><a href="../../../index.html" target="_top">Documentation</a> <b>></b> <a href="../../webobjects.html" target="_top">WebObjects</a></font></td></tr></table><br><!-- end of path -->		<a href="EOControlTOC.html"><img src="Art/up.gif" border="0" alt="Table of Contents"></a> <br>		<h1><font color="#000066">The EOControl Framework</font></h1>		<p><br>		<blockquote>			<b>Package: </b>com.webobjects.eocontrol</blockquote>		<p>		<hr size="4">		<br>		<h2>Introduction</h2>		<p>The EOControl framework defines one of the layers of the Enterprise Objects Framework architecture-the control layer. It provides an infrastructure for enterprise objects that is independent of your application's user interface and its storage mechanism. The control layer dynamically manages the interaction between enterprise objects, the access layer, and the interface layer by:</p>		<ul>			<li>Tracking changes to enterprise objects 			<li>Prompting the user interface to change when object values change 			<li>Prompting the database to change when changes to objects are committed 			<li>Managing undo in the object graph 			<li>Managing uniquing (the mechanism by which Enterprise Objects Framework uniquely identifies enterprise objects and maintains their mapping to stored data in the database) 		</ul>		<p>The control layer's major areas of responsibility and the key classes involved are described in the following table:</p>		<p><br>		<table border="1">			<tr>				<td scope="row"><b>Responsibility</b></td>				<td><b>Classes</b></td>			</tr>			<tr>				<td scope="row"><a href="#BIADGEAG">&quot;Tracking Enterprise Objects Changes&quot;</a></td>				<td>EOObserverCenter EODelayedObserverQueue EODelayedObserver EOObserverProxy EOObserving (interface)</td>			</tr>			<tr>				<td scope="row"><a href="#BIACAIJE">&quot;Object Storage Abstraction&quot;</a></td>				<td>EOObjectStore EOCooperatingObjectStore EOObjectStoreCoordinator EOGlobalID EOKeyGlobalID EOTemporaryGlobalID</td>			</tr>			<tr>				<td scope="row">Query specification</td>				<td>EOFetchSpecification EOQualifier EOSortOrdering</td>			</tr>			<tr>				<td scope="row">Interaction with enterprise objects</td>				<td>EOEnterpriseObject (basic enterprise object behavior) EOClassDescription (validation support) EOGenericRecord EOCustomObject</td>			</tr>			<tr>				<td scope="row">Simple source of objects (for display groups)</td>				<td>EODataSource EODetailDataSource</td>			</tr>		</table><br>		<p>The following sections describe each responsibility in greater detail.</p>		<p><br>		<a name="BIADGEAG"></a>		<h2>Tracking Enterprise Objects Changes</h2>		<p>EOControl provides four classes and an interface that form an efficient, specialized mechanism for tracking changes to enterprise objects and for managing the notification of those changes to interested observers. EOObserverCenter is the central manager of change notification. It records observers and the objects they observe, and it distributes notifications when the observable objects change. Observers implement the EOObserving interface, which defines one method, objectWillChange. Observable objects (generally enterprise objects) invoke their willChange method before altering their state, which causes all observers to receive an objectWillChange message.</p>		<p>The other three classes add to the basic observation mechanism. EODelayedObserverQueue alters the basic, synchronous change notification mechanism by offering different priority levels, which allows observers to specify the order in which they're notified of changes. EODelayedObserver is an abstract superclass for objects that observe other objects (such as the EOInterface layer's EOAssociation classes). Finally, EOObserverProxy is a subclass of EODelayedObserver that forwards change messages to a target object, allowing objects that don't inherit from EODelayedObserver to take advantage of this mechanism. </p>		<p>The major observer in Enterprise Objects Framework is EOEditingContext, which implements its objectWillChange method to record a snapshot for the object about to change, register undo operations in an NSUndoManager, and record the changes needed to update objects in its EOObjectStore. Because some of these actions-such as examining the object's new state-can only be performed after the object has changed, an EOEditingContext sets up a delayed message to itself, which it gets at the end of the run loop. Observers that only need to examine an object after it has changed can use the delayed observer mechanism, described in the EODelayedObserver and EODelayedObserverQueue class specifications.</p>		<p><br>		<a name="BIACAIJE"></a>		<h2>Object Storage Abstraction</h2>		<p>The control layer provides an infrastructure that's independent of your application's storage mechanism (typically a database) by defining an API for an &quot;intelligent&quot; repository of objects, whether it's based on external data or whether it manages objects entirely in memory. EOObjectStore is an abstract class that defines that basic API, setting up the framework for constructing and registering enterprise objects, servicing object faults, and committing changes made in an EOEditingContext. Subclasses of EOObjectStore implement the API in terms of their specific storage mechanism.</p>		<p><br>		<h3>Subclasses of EOObjectStore</h3>		<p>EOEditingContext is the principal subclass of EOObjectStore and is used for managing objects in memory. For stores based on external data, there are several subclasses. EOCooperatingObjectStore defines stores that work together to manage data from several distinct sources (such as different databases). The access layer's EODatabaseContext is actually a subclass of this class. A group of cooperating stores is managed by another subclass of EOObjectStore, EOObjectStoreCoordinator. If you're defining a subclass of EOObjectStore, it's probably one based on an external data repository, and it should therefore inherit from EOCooperatingObjectStore so as to work well with an EOObjectStoreCoordinator-though this isn't required.</p>		<p>EODatabaseContext provides objects from relational databases and is therefore provided by Enterprise Objects Framework's access layer. It is the class that defines the interaction between the control and access layers. Database contexts and other object stores based on external data are often shared by several editing contexts to conserve database connections.</p>		<p>Object store subclasses cooperate with one another as illustrated in the following:</p>		<center>			<p><img src="Classes/Art/DBasic2.GIF" alt="[image: Classes/Art/DBasic2.GIF]"> </center>		<p><br>		<table border="0" bgcolor="#e6e6e6">			<tr>				<td scope="row"><b>Note: </b>Note that EOCooperatingObjectStore, EOObjectStoreCoordinator, and EODatabaseContext are not provided by Java Client</td>			</tr>		</table><br>		<br>		<h3>Registering Enterprise Objects</h3>		<p>An object store identifies its objects in two ways:</p>		<ul>			<li>By reference for identification within a specific editing context 			<li>By global ID for universal identification of the same record among multiple stores. 		</ul>		<p>A global ID is defined by three classes: EOGlobalID, EOKeyGlobalID, and EOTemporaryGlobalID. EOGlobalID is an abstract class that forms the basis for uniquing in Enterprise Objects Framework. EOKeyGlobalID is a concrete subclass of EOGlobalID whose instances represent persistent IDs based on the access layer's EOModel information: an entity and the primary key values for the object being identified. An EOTemporaryGlobalID object is used to identify a newly created enterprise object before it's saved to an external store. For more information, see the EOGlobalID class specification.</p>		<p><br>		<h3>Servicing Faults</h3>		<p>For external repositories, an object store might delay fetching an object's data, instead creating an empty enterprise object (called a fault). When a fault is accessed (sent a message), it triggers its object store to fetch its data and fill the fault with its data. This preserves both the object's reference and its EOGlobalID, while saving the cost of fetching data that might not be used. Faults are typically created for the destinations of relationships for objects that are explicitly fetched. See the EOFaultHandler class specification for more information.</p>		<p>&copy; 2001 Apple Computer, Inc. (Last Published April 19, 2001)</p>		<p><br>		<a href="EOControlTOC.html"><img src="Art/up.gif" border="0" alt="Table of Contents"></a> <!-- start of footer -->		<!--#include virtual="/includes/framesetfooter" -->		<!-- end of footer -->	</body></html>