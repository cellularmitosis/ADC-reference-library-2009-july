// buffered window shell App.  This file creates a window and attaches a GWorld to it, created// from information contained in the source picture.  You can open a picture and display it// in the window.  This is a shell for testing developer questions about offscreens.//// There are two good references for the offscreen stuff.  Inside Macintosh: Imaging with Quickdraw// and Scott Knaster & Keith Rollin'sbook: Macintosh Programming Secrets.  Both of these are available from // Addison Wesley.//// Nick Thompson - June 6th 1994/* Constant Declarations */#include <Fonts.h>#include <Processes.h>#include <Dialogs.h>#include <Resources.h>#include <menus.h>#include <PictUtil.h>#include <QDOffScreen.h>#include <DiskInit.h>#include <StandardFile.h>#include <Devices.h>#define	WWIDTH		470#define	WHEIGHT		330#define WLEFT		(((screenBits.bounds.right - screenBits.bounds.left) - WWIDTH) / 2)#define WTOP		(((screenBits.bounds.bottom - screenBits.bounds.top) - WHEIGHT) / 2)#define HiWrd(aLong)	(((aLong) >> 16) & 0xFFFF)#define LoWrd(aLong)	((aLong) & 0xFFFF)enum {	mApple = 128,	mFile,	mEffects} ;enum {	iAbout = 1} ;enum {	iOpen = 1,	iClose,	iUnused1,	iQuit = 4} ;enum {	iUsePictPalette = 1} ;static Boolean gQuitFlag = false ;static Point gStaggerPos = {50,50} ;static Boolean gUsePictPalette = true ;// function prototypesvoid InitToolbox( void ) ;void MainEventLoop( void ) ;void HandleKeyPress(EventRecord *event) ;void HandleOSEvent(EventRecord *event) ;void HandleMenuCommand(long menuResult) ;PicHandle DoReadPICT( short theRef, OSErr *theErr ) ;OSErr DoCreateWindow( PicHandle thePicture ) ;void AdjustMenus( void ) ;void ColorizeImage( WindowPtr imageToColorize ) ;const RGBColor	kRGBBlack = {0, 0, 0};const RGBColor	kRGBWhite = {0xFFFF, 0xFFFF, 0xFFFF};void main(void){	InitToolbox() ;		MainEventLoop();}void InitToolbox(){	/*OSErr 		retCode;*/	/*long 		gestResponse;*/	Handle		menuBar = nil;	/*EventRecord event;*/	/*short		count;*/	InitGraf((Ptr) &qd.thePort);	InitFonts();	InitWindows();	InitMenus();	TEInit();	InitDialogs((long)nil);	InitCursor();	// initialize application globals		gQuitFlag = false;			menuBar = GetNewMBar(128);				// Read menus into menu bar, MBAR res id is 128		if ( menuBar == nil )		 ExitToShell();						// if we dont have it then quit - your app 		 									// needs a dialog here 	SetMenuBar(menuBar);					// Install menus	DisposeHandle(menuBar);		AppendResMenu(GetMenuHandle(mApple), 'DRVR');	// Add DA names to Apple menu, ID 128	DrawMenuBar();}void MainEventLoop(){	EventRecord 	event;	WindowPtr   	window;	short       	thePart;	Rect        	screenRect;	Point			aPoint = {100, 100};	GWorldPtr		theNewWorld ;	PixMapHandle	offPixMap ;	GrafPtr			oldPort ;	while( !gQuitFlag )	{		if (WaitNextEvent( everyEvent, &event, 0, nil ))		{			AdjustMenus() ;			switch (event.what) {				case mouseDown:									thePart = FindWindow( event.where, &window );										switch( thePart ) {						case inMenuBar: 							HandleMenuCommand(MenuSelect(event.where));							break;												case inDrag:												screenRect = (**GetGrayRgn()).rgnBBox;							DragWindow( window, event.where, &screenRect );							break ;											case inContent:												if (window != FrontWindow())								SelectWindow( window );							break ;											case inGoAway:							if (TrackGoAway( window, event.where )) {								DisposeWindow ( window );							}							break ;													default:							break ;					}					break ;																	case updateEvt:									window = (WindowPtr)event.message;					GetPort(&oldPort ) ;						SetPort( window );										BeginUpdate( window );										// get the GWorld from the window refcon					theNewWorld = (GWorldPtr)GetWRefCon ( window );					offPixMap = GetGWorldPixMap( theNewWorld ) ;					(void) LockPixels( offPixMap ) ;					CopyBits( &((GrafPtr)theNewWorld)->portBits,							  &window->portBits,							  &window->portRect,							  &window->portRect,							  srcCopy,							  nil ) ;					(void) UnlockPixels( offPixMap ) ;					EndUpdate( window );					SetPort( oldPort ) ;					break ;									case keyDown:				case autoKey:					HandleKeyPress(&event);					break;									case diskEvt:					if ( HiWrd(event.message) != noErr ) 						(void) DIBadMount(aPoint, event.message);					break;									case osEvt:				case activateEvt:					break;			}		}	}}void HandleKeyPress(EventRecord *event){	char	key;	key = event->message & charCodeMask;		// just check to see if we want to quit...		if ( event->modifiers & cmdKey ) {		/* Command key down? */		HandleMenuCommand(MenuKey(key));	} }void HandleMenuCommand(long menuResult){	short		menuID;	short		menuItem;	Str255		daName;	DialogPtr	theDialog ; 	short		itemHit ;	SFTypeList	myTypes = { 'PICT' } ;	/*FSSpec		theFSSpec ;*/	PicHandle	thePicture ;	OSErr		err ;	short		theRef ;		StandardFileReply	theSFReply ;	menuID = HiWrd(menuResult);	menuItem = LoWrd(menuResult);	switch ( menuID ) {		case mApple:			switch ( menuItem ) {				ModalFilterUPP 		theProc ;				case iAbout:									theDialog = GetNewDialog ( 128, nil, (WindowPtr)-1 );										// these two lil' snappers are system 7 only					// so if you use them, check before!!					GetStdFilterProc( &theProc ) ;					SetDialogDefaultItem(theDialog, ok) ;															do {						ModalDialog ( theProc, &itemHit );					} while( itemHit != ok ) ;					DisposeDialog ( theDialog );					break;									default:					GetMenuItemText(GetMenuHandle(mApple), menuItem, daName);					(void) OpenDeskAcc((ConstStr255Param)daName);					break;			}			break;		case mFile:			switch ( menuItem ) {				case iOpen:					// Get the file name to open					StandardGetFile( nil, 1, myTypes, &theSFReply ) ;										// did the user cancel?					if(!theSFReply.sfGood)						break ;										// open the file					err = FSpOpenDF( &theSFReply.sfFile, fsRdPerm, &theRef ) ;										if( err != noErr )						break ; 	// should handle this properly											thePicture = DoReadPICT( theRef, &err ) ;										if( err != noErr )						break ; 	// should handle this properly									// display the contents					err = DoCreateWindow( thePicture ) ;										break ;									case iClose:					DisposeWindow ( FrontWindow() );					break ;				case iQuit:					gQuitFlag = true;					break;			}			break;								case 131:			if( menuItem == 1 )				if( FrontWindow() != nil )					ColorizeImage( FrontWindow() ) ;			break; 	}	HiliteMenu(0);		// Unhighlight whatever MenuSelect or MenuKey hilited}void AdjustMenus( void ) {	WindowPtr	theWindow ;	theWindow = FrontWindow() ;	if( theWindow != nil ) {		EnableItem ( GetMenuHandle ( mFile ), iClose );	}	else {		DisableItem ( GetMenuHandle ( mFile ), iClose );	}}PicHandle DoReadPICT( short theRef, OSErr *theErr ) {	long		theFileSize ;	PicHandle	thePicture ;		// pict files have a 512 byte header at the front - we dont care about this	// we can find the size of the pict by subtracting 512 bytes from the length	// of the file.  We then want to resize the handle to that and read the data	// into the resized handle.		if(( *theErr = GetEOF( theRef, &theFileSize )) != noErr ) {		FSClose( theRef ) ;		return nil ; 	}		if(( *theErr = SetFPos( theRef, fsFromStart, 512)) != noErr ) {		FSClose( theRef ) ;		return nil ; 	}	theFileSize -= 512 ;		thePicture = (PicHandle)NewHandle( theFileSize ) ;	if( thePicture == nil ) {		FSClose( theRef ) ;		*theErr = MemError() ;		return nil ; 		// what ever the mem manager error was	}		HLock( (Handle)thePicture ) ;	*theErr = FSRead( theRef, &theFileSize, (Ptr)*thePicture ) ;	HUnlock(  (Handle)thePicture ) ;		if( *theErr != noErr ) {		FSClose( theRef ) ;		return nil ; 	}	return thePicture ;	}OSErr DoCreateWindow( PicHandle thePicture ){	Rect		theRect ;	OSErr		theErr ;	GWorldPtr	theNewWorld ;	CGrafPtr	savedPort ;	/*GWorldPtr	savedGWorld ;*/	WindowPtr	theWindow ;	GDHandle	oldDevice ;		/*PictInfo		thePictInfo ;*/	PaletteHandle	thePictPalette = nil ;	CTabHandle		thePictCTab = nil ;		// make an offscreen environment and image the pict into this	// Make a window the size of the pict	// store a reference to the GWorld in the Refcon of the window	// invalidate the window content area.		theRect.top = (**thePicture).picFrame.top ;	theRect.left = (**thePicture).picFrame.left ;	theRect.bottom = (**thePicture).picFrame.bottom ;	theRect.right = (**thePicture).picFrame.right ;		// create a gWorld 8 bits deep		theErr = NewGWorld( &theNewWorld, 8, &theRect, thePictCTab, nil, 0L ) ;		if( theErr != noErr ) 		return theErr ;		// save the world	GetGWorld( &savedPort, &oldDevice ) ;	SetGWorld( theNewWorld, nil ) ;			RGBForeColor( &kRGBBlack ) ;		// ensure the fg and bg colors are 	RGBBackColor( &kRGBWhite ) ;		// as anticipated		EraseRect( &theRect ) ;				// clear the area for the pict	PenMode( srcCopy ) ;				// ensure the t/f mode is as expected	// render the image into the offscreen buffer	DrawPicture( thePicture, &theRect ) ;		SetGWorld( savedPort, oldDevice ) ;		// create the window	OffsetRect( &theRect, gStaggerPos.h, gStaggerPos.v) ;	gStaggerPos.h += 16 ;	gStaggerPos.v += 16 ;		// heh - should roll these around, but you wont 								// create more than a couple of windows, will you  :-)								 	theWindow  = NewCWindow( nil, &theRect, "\pplayTime", true, 								documentProc, (WindowPtr)-1, true, (long)theNewWorld );							// make sure it is visible	ShowWindow( theWindow ) ;		SetGWorld( (CGrafPtr)theWindow, nil ) ;		// invalidate the content region of the window - we don't do any drawing to it here.	InvalRect ( &theRect );		SetGWorld( savedPort, oldDevice ) ;	return theErr;}