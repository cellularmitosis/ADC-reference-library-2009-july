<html><head><title>Mac OS X Developer Tools
 Manual Page For Tcl_DuplicateObj(3tcl)</title>
<style type="text/css"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { font-size: 1px; background: #ffffff; color: #ffffff; } --></style>
<style type="text/css" media="print, aural, braille, embossed, projection, tty"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { display: none; } --></style>
</head><body bgcolor="white">
<a name="//apple_ref/doc/man/3tcl/Tcl_DuplicateObj" title="Mac OS X Developer Tools
 Manual Page for Tcl_DuplicateObj(3tcl)"><a name="//apple_ref/doc/man/3/Tcl_DuplicateObj" title="Mac OS X Developer Tools
 Manual Page for Tcl_DuplicateObj(3tcl)"><!-- headerDoc=man; indexgroup=Section 3tcl; uid="//apple_ref/doc/man/3tcl/Tcl_DuplicateObj"; name=Tcl_DuplicateObj(3tcl) --></a>
<!--#include virtual="/includes/framesetheader"-->
<table width=600><tr><td scope="row">
<!-- begin breadcrumb insert request --><font face="Geneva,Helvetica,Arial" size="1">
 <a target="_top" href="http://developer.apple.com">ADC Home</a> <b>&gt;</b> <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> <b>&gt;</b> <a href="../../../../../reference/index.html#//apple_ref/doc/uid/TP30001281" target="_top">Reference</a> <b>&gt;</b> <!-- a href="" target="_top" -->Mac OS X<!-- /a --> <b>&gt;</b> <a href="../index.html#//apple_ref/doc/framework/manpages" target="_top">Mac OS X Man Pages</a></font>
<!-- end breadcrumb insert request -->
<p>&nbsp;</p>
</td></tr></table>
<!-- end of header -->
<table border="0"  cellpadding="2" cellspacing="2" width="630pt"><tr><td valign="top" height="12" colspan="5" scope="row">
<p style='text-align:justify;'>This document is a Mac&nbsp;OS&nbsp;X manual page.  Manual pages are a command-line technology
for providing documentation.  You can view these manual pages locally using the
<a href="../man1/man.1.html#//apple_ref/doc/man/1/man">man(1)</a> command.
These manual pages come from many different sources, and thus, have a variety of writing
styles.</p>

<p style='text-align:justify;'>This manual page is associated with the Mac&nbsp;OS&nbsp;X
developer tools.  The software or headers described may not be present on your
Mac&nbsp;OS&nbsp;X installation until you install the developer tools
package.  This package is available on your Mac&nbsp;OS&nbsp;X installation DVD,
and the latest versions can be downloaded from
<a href="http://developer.apple.com/tools/download/">developer.apple.com</a>.</p>

<p style='text-align:justify;'>For more information about the manual page format, see the manual page for 
<a href="../man5/manpages.5.html#//apple_ref/doc/man/5/manpages">manpages(5)</a>.</p>
</td></tr></table>
<hr />
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row"><pre class="manpages"><tt>
Tcl_Obj(3)                                 Tcl Library Procedures                                 <!-- a -->Tcl_Obj(3)<!-- /a -->



____________________________________________________________________________________________________________

<b>NAME</b>
       Tcl_NewObj,   Tcl_DuplicateObj,   Tcl_IncrRefCount,  Tcl_DecrRefCount,  Tcl_IsShared,  Tcl_Invalidat-<font color="#ffffff" class="whiteout">eStringRep&nbsp;Tcl_InvalidateStringRep</font>
       eStringRep - manipulate Tcl objects

<b>SYNOPSIS</b>
       <b>#include</b> <b>&lt;tcl.h&gt;</b>

       Tcl_Obj *
       <b>Tcl_NewObj</b>()

       Tcl_Obj *
       <b>Tcl_DuplicateObj</b>(<u>objPtr</u>)

       <b>Tcl_IncrRefCount</b>(<u>objPtr</u>)

       <b>Tcl_DecrRefCount</b>(<u>objPtr</u>)

       int
       <b>Tcl_IsShared</b>(<u>objPtr</u>)

       <b>Tcl_InvalidateStringRep</b>(<u>objPtr</u>)

<b>ARGUMENTS</b>
       Tcl_Obj   <u>*objPtr</u>   (in)      Points to an object; must have been the result of a  previous  call  to
                                     <b>Tcl_NewObj</b>.
____________________________________________________________________________________________________________


<b>INTRODUCTION</b>
       This  man  page presents an overview of Tcl objects and how they are used.  It also describes generic
       procedures for managing Tcl objects.  These procedures are used  to  create  and  copy  objects,  and
       increment  and  decrement  the count of references (pointers) to objects.  The procedures are used in
       conjunction with ones that operate on  specific  types  of  objects  such  as  <b>Tcl_GetIntFromObj</b>  and
       <b>Tcl_ListObjAppendElement</b>.   The  individual  procedures  are described along with the data structures
       they manipulate.

       Tcl's <u>dual-ported</u> objects provide a general-purpose mechanism for storing and exchanging Tcl  values.
       They largely replace the use of strings in Tcl.  For example, they are used to store variable values,
       command arguments, command results, and scripts.  Tcl objects behave like strings but  also  hold  an
       internal  representation  that  can  be manipulated more efficiently.  For example, a Tcl list is now
       represented as an object that holds the list's string representation as well as an array of  pointers
       to the objects for each list element.  Dual-ported objects avoid most runtime type conversions.  They
       also improve the speed of many operations since an appropriate representation is  immediately  avail-<font color="#ffffff" class="whiteout">able.&nbsp;available.</font>
       able.  The compiler itself uses Tcl objects to cache the instruction bytecodes resulting from compil-<font color="#ffffff" class="whiteout">ing&nbsp;compiling</font>
       ing scripts.

       The two representations are a cache of each other and are computed lazily.  That is, each representa-<font color="#ffffff" class="whiteout">tion&nbsp;representation</font>
       tion  is  only  computed when necessary, it is computed from the other representation, and, once com-<font color="#ffffff" class="whiteout">puted,&nbsp;computed,</font>
       puted, it is saved.  In addition, a change in one representation invalidates the other  one.   As  an
       example,  a  Tcl  program  doing  integer  calculations can operate directly on a variable's internal
       machine integer representation without having to constantly convert  between  integers  and  strings.
       Only  when  it  needs  a  string representing the variable's value, say to print it, will the program
       regenerate the string representation from the integer.  Although objects contain an  internal  repre-<font color="#ffffff" class="whiteout">sentation,&nbsp;representation,</font>
       sentation,  their  semantics  are  defined  in  terms  of strings: an up-to-date string can always be
       obtained, and any change to the object will be reflected in that string when the object's string rep-<font color="#ffffff" class="whiteout">resentation&nbsp;representation</font>
       resentation  is fetched.  Because of this representation invalidation and regeneration, it is danger-<font color="#ffffff" class="whiteout">ous&nbsp;dangerous</font>
       ous for extension writers to access <b>Tcl_Obj</b> fields directly.  It is better to access Tcl_Obj informa-<font color="#ffffff" class="whiteout">tion&nbsp;information</font>
       tion using procedures like <b>Tcl_GetStringFromObj</b> and <b>Tcl_GetString</b>.

       Objects  are  allocated  on  the  heap and are referenced using a pointer to their <b>Tcl_Obj</b> structure.
       Objects are shared as much as possible.  This significantly reduces storage requirements because some
       objects  such  as long lists are very large.  Also, most Tcl values are only read and never modified.
       This is especially true for procedure arguments, which can be  shared  between  the  caller  and  the
       called  procedure.   Assignment  and  argument  binding  is done by simply assigning a pointer to the
       value.  Reference counting is used to determine when it is safe to reclaim an object's storage.

       Tcl objects are typed.  An object's internal representation is controlled by its type.   Seven  types
       are  predefined in the Tcl core including integer, double, list, and bytecode.  Extension writers can
       extend the set of types by using the procedure <b>Tcl_RegisterObjType</b> .


<b>THE</b> <b>TCL_OBJ</b> <b>STRUCTURE</b>
       Each Tcl object is represented by a <b>Tcl_Obj</b> structure which is defined as follows.
              typedef struct Tcl_Obj {
                int <u>refCount</u>;
                char *<u>bytes</u>;
                int <u>length</u>;
                Tcl_ObjType *<u>typePtr</u>;
                union {
                   long <u>longValue</u>;
                   double <u>doubleValue</u>;
                   VOID *<u>otherValuePtr</u>;
                   struct {
                     VOID *<u>ptr1</u>;
                     VOID *<u>ptr2</u>;
                   } <u>twoPtrValue</u>;
                } <u>internalRep</u>;
              } Tcl_Obj;
       The <u>bytes</u> and the <u>length</u> members together hold an object's UTF-8 string representation,  which  is  a |
       <u>counted</u>  <u>string</u>  not  containing  null  bytes  (UTF-8 null characters should be encoded as a two byte |
       sequence: 192, 128.)  <u>bytes</u> points to the first byte of the string representation.  The <u>length</u> member |
       gives  the number of bytes.  The byte array must always have a null byte after the last data byte, at |
       offset <u>length</u>; this allows string representations to be treated  as  conventional  null-terminated  C |
       strings.  C programs use <b>Tcl_GetStringFromObj</b> and <b>Tcl_GetString</b> to get an object's string representa-<font color="#ffffff" class="whiteout">tion.&nbsp;representation.</font>
       tion.  If <u>bytes</u> is NULL, the string representation is invalid.

       An object's type manages its internal representation.  The member <u>typePtr</u> points to  the  Tcl_ObjType
       structure that describes the type.  If <u>typePtr</u> is NULL, the internal representation is invalid.

       The  <u>internalRep</u>  union  member  holds  an object's internal representation.  This is either a (long)
       integer, a double-precision floating point number, a pointer to a value containing additional  infor-<font color="#ffffff" class="whiteout">mation&nbsp;information</font>
       mation needed by the object's type to represent the object, or two arbitrary pointers.

       The  <u>refCount</u> member is used to tell when it is safe to free an object's storage.  It holds the count
       of active references to the object.  Maintaining the correct reference count is a key  responsibility
       of  extension  writers.   Reference  counting is discussed below in the section <b>STORAGE</b> <b>MANAGEMENT</b> <b>OF</b>
       <b>OBJECTS</b>.

       Although extension writers can directly access the members of a Tcl_Obj structure, it is much  better
       to  use  the  appropriate procedures and macros.  For example, extension writers should never read or
       update <u>refCount</u> directly; they should use macros such as <b>Tcl_IncrRefCount</b> and <b>Tcl_IsShared</b> instead.

       A key property of Tcl objects is that they hold two representations.  An object typically starts  out
       containing  only a string representation: it is untyped and has a NULL <u>typePtr</u>.  An object containing
       an empty string or a copy of a specified string  is  created  using  <b>Tcl_NewObj</b>  or  <b>Tcl_NewStringObj</b>
       respectively.   An  object's  string  value  is gotten with <b>Tcl_GetStringFromObj</b> or <b>Tcl_GetString</b> and
       changed with <b>Tcl_SetStringObj</b>.  If the object is later passed to a procedure  like  <b>Tcl_GetIntFromObj</b>
       that  requires a specific internal representation, the procedure will create one and set the object's
       <u>typePtr</u>.  The internal representation is computed from the string representation.   An  object's  two
       representations  are  duals of each other: changes made to one are reflected in the other.  For exam-<font color="#ffffff" class="whiteout">ple,&nbsp;example,</font>
       ple, <b>Tcl_ListObjReplace</b> will modify an object's internal representation and the next call to <b>Tcl_Get</b>-<font color="#ffffff" class="whiteout">StringFromObj&nbsp;Tcl_GetStringFromObj</font>
       <b>StringFromObj</b> or <b>Tcl_GetString</b> will reflect that change.

       Representations  are recomputed lazily for efficiency.  A change to one representation made by a pro-<font color="#ffffff" class="whiteout">cedure&nbsp;procedure</font>
       cedure such as <b>Tcl_ListObjReplace</b> is not reflected immediately in the other representation.  Instead,
       the  other  representation  is  marked  invalid so that it is only regenerated if it is needed later.
       Most C programmers never have to be concerned with how this is done and simply use procedures such as
       <b>Tcl_GetBooleanFromObj</b>  or  <b>Tcl_ListObjIndex</b>.   Programmers that implement their own object types must
       check for invalid representations and mark representations invalid  when  necessary.   The  procedure
       <b>Tcl_InvalidateStringRep</b>  is  used  to  mark an object's string representation invalid and to free any
       storage associated with the old string representation.

       Objects usually remain one type over their life, but occasionally an object must  be  converted  from
       one  type  to  another.   For example, a C program might build up a string in an object with repeated
       calls to <b>Tcl_AppendToObj</b>, and then call <b>Tcl_ListObjIndex</b> to extract a list element from  the  object.
       The  same object holding the same string value can have several different internal representations at
       different times.  Extension writers can also force an object to be converted from one type to another
       using the <b>Tcl_ConvertToType</b> procedure.  Only programmers that create new object types need to be con-<font color="#ffffff" class="whiteout">cerned&nbsp;concerned</font>
       cerned about how this is done.  A procedure defined as part of the object type's implementation  cre-<font color="#ffffff" class="whiteout">ates&nbsp;creates</font>
       ates  a  new  internal  representation  for  an object and changes its <u>typePtr</u>.  See the man page for
       <b>Tcl_RegisterObjType</b> to see how to create a new object type.


<b>EXAMPLE</b> <b>OF</b> <b>THE</b> <b>LIFETIME</b> <b>OF</b> <b>AN</b> <b>OBJECT</b>
       As an example of the lifetime of an object, consider the following sequence of commands:
              <b>set</b> <b>x</b> <b>123</b>
       This assigns to <u>x</u> an untyped object whose <u>bytes</u> member points to <b>123</b> and <u>length</u>  member  contains  3.
       The object's <u>typePtr</u> member is NULL.
              <b>puts</b> <b>"x</b> <b>is</b> <b>$x"</b>
       <u>x</u>'s string representation is valid (since <u>bytes</u> is non-NULL) and is fetched for the command.
              <b>incr</b> <b>x</b>
       The  <b>incr</b> command first gets an integer from <u>x</u>'s object by calling <b>Tcl_GetIntFromObj</b>.  This procedure
       checks whether the object is already an integer object.  Since it is not, it converts the  object  by
       setting the object's <u>internalRep.longValue</u> member to the integer <b>123</b> and setting the object's <u>typePtr</u>
       to point to the integer Tcl_ObjType structure.  Both representations are now valid.  <b>incr</b>  increments
       the  object's  integer internal representation then invalidates its string representation (by calling
       <b>Tcl_InvalidateStringRep</b>) since the string representation no longer corresponds to the internal repre-<font color="#ffffff" class="whiteout">sentation.&nbsp;representation.</font>
       sentation.
              <b>puts</b> <b>"x</b> <b>is</b> <b>now</b> <b>$x"</b>
       The  string  representation  of <u>x</u>'s object is needed and is recomputed.  The string representation is
       now <b>124</b>.  and both representations are again valid.


<b>STORAGE</b> <b>MANAGEMENT</b> <b>OF</b> <b>OBJECTS</b>
       Tcl objects are allocated on the heap and are shared as much as possible to reduce  storage  require-<font color="#ffffff" class="whiteout">ments.&nbsp;requirements.</font>
       ments.   Reference counting is used to determine when an object is no longer needed and can safely be
       freed.  An object just created by <b>Tcl_NewObj</b> or <b>Tcl_NewStringObj</b> has <u>refCount</u> 0.  The macro <b>Tcl_Incr</b>-<font color="#ffffff" class="whiteout">RefCount&nbsp;Tcl_IncrRefCount</font>
       <b>RefCount</b>  increments  the  reference  count when a new reference to the object is created.  The macro
       <b>Tcl_DecrRefCount</b> decrements the count when a reference is no longer needed and, if the object's  ref-<font color="#ffffff" class="whiteout">erence&nbsp;reference</font>
       erence count drops to zero, frees its storage.  An object shared by different code or data structures
       has <u>refCount</u> greater than 1.  Incrementing an object's reference count ensures that it won't be freed
       too early or have its value change accidently.

       As an example, the bytecode interpreter shares argument objects between calling and called Tcl proce-<font color="#ffffff" class="whiteout">dures&nbsp;procedures</font>
       dures to avoid having to copy objects.  It assigns the call's argument  objects  to  the  procedure's
       formal  parameter variables.  In doing so, it calls <b>Tcl_IncrRefCount</b> to increment the reference count
       of each argument since there is now a new reference to it from the formal parameter.  When the called
       procedure  returns,  the  interpreter  calls  <b>Tcl_DecrRefCount</b> to decrement each argument's reference
       count.  When an object's reference count drops less than or equal to zero, <b>Tcl_DecrRefCount</b>  reclaims
       its storage.  Most command procedures do not have to be concerned about reference counting since they
       use an object's value immediately and don't retain a pointer to the object after they  return.   How-<font color="#ffffff" class="whiteout">ever,&nbsp;However,</font>
       ever, if they do retain a pointer to an object in a data structure, they must be careful to increment
       its reference count since the retained pointer is a new reference.

       Command procedures that directly modify objects such as those for <b>lappend</b> and <b>linsert</b> must be careful
       to  copy  a  shared object before changing it.  They must first check whether the object is shared by
       calling <b>Tcl_IsShared</b>.  If the object is shared they must copy the object by  using  <b>Tcl_DuplicateObj</b>;
       this  returns  a  new  duplicate  of  the  original object that has <u>refCount</u> 0.  If the object is not
       shared, the command procedure "owns" the object and can safely modify it directly.  For example,  the
       following code appears in the command procedure that implements <b>linsert</b>.  This procedure modifies the
       list object passed to it in <u>objv[1]</u> by inserting <u>objc-3</u> new elements before <u>index</u>.
              listPtr = objv[1];
              if (Tcl_IsShared(listPtr)) {
                listPtr = Tcl_DuplicateObj(listPtr);
              }
              result = Tcl_ListObjReplace(interp, listPtr, index, 0, (objc-3), &amp;(objv[3]));
       As another example, <b>incr</b>'s command procedure must check  whether  the  variable's  object  is  shared
       before  incrementing the integer in its internal representation.  If it is shared, it needs to dupli-<font color="#ffffff" class="whiteout">cate&nbsp;duplicate</font>
       cate the object in order to avoid accidently changing values in other data structures.


<b>SEE</b> <b>ALSO</b>
       Tcl_ConvertToType, Tcl_GetIntFromObj, Tcl_ListObjAppendElement, Tcl_ListObjIndex, Tcl_ListObjReplace,
       Tcl_RegisterObjType


<b>KEYWORDS</b>
       internal representation, object, object creation, object type, reference counting, string representa-<font color="#ffffff" class="whiteout">tion,&nbsp;representation,</font>
       tion, type conversion



Tcl                                                  8.1                                          <!-- a -->Tcl_Obj(3)<!-- /a -->
</tt></pre>
</td></tr></table>
	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Darwin/Reference/ManPages/man3/Tcl_DuplicateObj.3tcl.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Darwin/Reference/ManPages/man3/Tcl_DuplicateObj.3tcl.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Darwin/Reference/ManPages/man3/Tcl_DuplicateObj.3tcl.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

</body></html>
