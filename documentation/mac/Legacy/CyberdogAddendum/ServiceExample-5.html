<!-- Generated by Harlequin WebMaker 2.2.3 (30-Apr-1996)
Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->
<HTML> <HEAD>
<TITLE>Implementing Your Cyberdog Stream Class</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING5></A>


<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->




<!-- Main Body -->

<CENTER>
<P>
<A HREF="ServiceExample-4.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="ServiceExample-1.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="ServiceExample-7.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="ServiceExample-6.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../../macos8/mac8.html"><B>Inside Macintosh:</B></A>  / <BR><DD><A HREF="ServiceExample-1.html"><B> Creating a Cyberdog Service</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING5-0></A>
<H1>Implementing Your Cyberdog Stream Class</H1>
 <A NAME=MARKER-2-67></A>Your Cyberdog stream class implements your service's protocol. Your subclass must override nearly all of the methods defined in the <A NAME=MARKER-2-68></A><CODE>CyberStream</CODE> class. <A HREF=#MARKER-9-69>Listing 20</A> shows the SOM class definition for the stream associated with the Finger service.<P>
<B>Listing 20  <A NAME=MARKER-9-69></A>The SOM class definition of the Finger service stream</B><P>
<PRE>
module AppleCyberdog
{
   interface FingerStream : CyberStream
   {
      void FingerStream(in char* url);
      
   #ifdef __SOMIDL__
      implementation
      {
      functionprefix = FingerStream__;
   
      override:
         somInit,
         somUninit,
         GetStreamStatus,
         GetTotalDataSize,
         GetStreamError,
         GetStatusString,
         GetLastModTime,
         IsTotalDataSizeAvailable,
         IsLastModTimeAvailable,
         Open,
         GetBuffer,
         ReleaseBuffer,
         Abort;
         
      releaseorder:
         IFingerStream;
   
      #ifdef __PRIVATE__
                           
         FingerStreamDatafData;

      #endif
      };
   #endif
   };
};
</PRE>
 The following sections describe these methods.<P>
<A NAME=HEADING5-5></A>
<H2>Initializing the Service's Stream Object</H2>
 Your Cyberdog stream class maintains data needed to implement the service's protocol and data about the status of download operations. <A HREF=#MARKER-9-70>Listing 21</A> shows the data structure for the Finger service's stream. The structure includes accessor functions that are called by methods of the stream's class.<P>
<B>Listing 21  <A NAME=MARKER-9-70></A>The data structure of the Finger service stream</B><P>
<PRE>
struct CFingerStreamData
{
            CFingerStreamData();
   virtual  ~CFingerStreamData();
   
   Boolean   fAborting;
   
   StreamStatus fStatus;
   StringPtr fStatusString;
   OSErr     fError;
   ThreadID  fThreadID;
   Ptr       fResultsBuffer;
   long      fResultsBufferSize;
   tcp_endpoint* fTCP;
   char      fHost[256];
   char      fUser[256];
   short     fPort;
   
   void SetStatusString(StringPtr str);
   void SetError(OSErr err);
   void SetResultsBuffer(Ptr buffer, long bufferLen);
   void GetResultsBuffer(Ptr* buffer, long* bufferLen);
};
</PRE>
 <A HREF=#MARKER-9-71>Listing 22</A> shows the <CODE>IFingerStream</CODE> method of the Finger service stream. This method creates the structure and initializes the structure's fields. You call this method immediately after you create a Finger service stream object.<P>
<B>Listing 22  <A NAME=MARKER-9-71></A>The <CODE>IFingerStream</CODE> method of the Finger service stream</B><P>
<PRE>
SOM_Scope void  SOMLINK FingerStream__IFingerStream
            (AppleCyberdog_FingerStream *somSelf, Environment *ev,
             char* url)
{
   ...
   CFingerStreamData* data = new CFingerStreamData;
   
   if(data)
      ParseFingerURL(url, data-&gt;fHost, data-&gt;fUser, &amp; data-&gt;fPort);
   
   somThis-&gt;fData = data;
}
</PRE>
<A NAME=HEADING5-12></A>
<H2>Opening the Stream</H2>
 <A NAME=MARKER-2-72></A>You must override your Cyberdog stream's <A NAME=MARKER-2-73></A><CODE>Open</CODE> method to initiate the download. <A HREF=#MARKER-9-74>Listing 23</A> shows the <CODE>Open</CODE> method of the Finger service stream. This method creates a cooperative Thread Manager thread to handle the download. <P>
<B>Listing 23  <A NAME=MARKER-9-74></A>The <CODE>Open</CODE> method of the Finger service stream</B><P>
<PRE>
SOM_Scope void  SOMLINK FingerStream__Open
            (AppleCyberdog_FingerStream *somSelf, Environment *ev)
{
   ,,,
   CFingerStreamData* data = (CFingerStreamData*) somThis-&gt;fData;
    
    static ThreadEntryProcPtr gFingerThread = nil;
    const Size kThreadStackSize = 8 * 1024;
    
    if(gFingerThread == nil)
      gFingerThread = NewThreadEntryProc(FingerThread);
    
    OSErr err = NewThread(kCooperativeThread, gFingerThread, data,
         kThreadStackSize, kCreateIfNeeded, nil, &amp; data-&gt;fThreadID);
   
}
</PRE>
 The thread looks up the host's address and establishes a TCP connection with it. The thread then sends a Finger request for the user specified in the URL. When data is returned, it is placed in a buffer. The buffer is retrieved when the stream's <CODE>GetBuffer</CODE> method is called. See <A HREF=#MARKER-9-77>"Getting and Releasing Buffers" (page 33)</A>.<P>
 The thread yields control whenever it waits for a response from the host. <A HREF=#MARKER-9-75>Listing 24</A> shows the loop in the thread that allocates a buffer and reads data into the buffer from the TCP stream.<P>
<B>Listing 24  <A NAME=MARKER-9-75></A>The thread of the Finger service stream</B><P>
<PRE>
pascal void* FingerThread(CFingerStreamData* data)
{
...
   while(tcp-&gt;IsOpen() &amp;&amp; !tcp-&gt;IsRemoteClosed() &amp;&amp; !data-&gt;fAborting)
   {
      if(tcp-&gt;IsDataAvail() &amp;&amp; (data-&gt;fResultsBuffer == nil))
      {
         data-&gt;SetStatusString(gReadingStr);
         
         // Allocate a buffer to read the data into.
         amt = tcp-&gt;AmtDataAvailable();
         buffer = (Ptr) ODNewPtr(amt);
         if(!buffer) {err = memFullErr; goto x_Exit;}
         
         // Read the data.
         err = tcp-&gt;Read(buffer, amt, kDefaultTimeout, TCP_Yielder);
         
         // Place the buffer into the streams data structure.
         data-&gt;SetResultsBuffer(buffer, amt);
         
         CHECK_FOR_ERR;
      }
      YieldToAnyThread();
   }
   CHECK_FOR_ERR;
   
   data-&gt;fStatus |= kCDDownloadComplete;
...
}
</PRE>
 The thread updates the error, status, and status string fields as it executes. When the download operation is complete, the thread applies a logical OR operation on the status field with the <CODE>kCDDownloadComplete</CODE> constant. <P>
 <A HREF=#MARKER-9-76>Listing 25</A> shows the <CODE>SetResultsBuffer</CODE> function, which sets the status to indicate that data is available.<P>
<B>Listing 25  <A NAME=MARKER-9-76></A>The <CODE>SetResultsBuffer</CODE> function of the Finger stream data structure</B><P>
<PRE>
void CFingerStreamData::SetResultsBuffer(Ptr buffer, long bufferLen)
{
   fResultsBuffer = buffer;
   fResultsBufferSize = bufferLen;
   fStatus |= kCDDataAvailable;
}
</PRE>
<A NAME=HEADING5-24></A>
<H2><A NAME=MARKER-9-77></A>Getting and Releasing Buffers</H2>
 <A NAME=MARKER-2-78></A>You must override your Cyberdog stream's <A NAME=MARKER-2-79></A><CODE>GetBuffer</CODE> and <A NAME=MARKER-2-80></A><CODE>ReleaseBuffer</CODE> methods, respectively, to retrieve and release buffers. The <CODE>GetBuffer</CODE> method of the Finger service stream (not shown) obtains a reference to the stream's data structure and calls the structure's GetResultsBuffer function to update the buffer address and size. The GetResultsBuffer function also resets the fields and sets the status to indicate that data is no longer available after the data has been retrieved.<P>
<B>Listing 26  The <CODE>GetResultsBuffer</CODE> function of the Finger stream data structure</B><P>
<PRE>
void CFingerStreamData::GetResultsBuffer(Ptr* buffer, long* bufferLen)
{
   *buffer = fResultsBuffer;
   *bufferLen =  fResultsBufferSize;
   
   fResultsBuffer = nil;
   fResultsBufferSize = 0;
   
   fStatus &amp;= ~kCDDataAvailable;
}
</PRE>
 The <CODE>ReleaseBuffer</CODE> method of the Finger service stream (not shown) releases the storage held by the buffer.<P>
<A NAME=HEADING5-29></A>
<H2>Terminating a Stream</H2>
 <A NAME=MARKER-2-81></A>You must override your Cyberdog stream's <A NAME=MARKER-2-82></A><CODE>Abort</CODE> method to specify the actions to take when the download operation is terminated. <A HREF=#MARKER-9-83>Listing 27</A> shows the <CODE>Abort</CODE> method of the Finger service stream. The method terminates the TCP connection.<P>
<B>Listing 27  <A NAME=MARKER-9-83></A>The <CODE>Abort</CODE> method of the Finger service stream</B><P>
<PRE>
SOM_Scope void  SOMLINK FingerStream__Abort
            (AppleCyberdog_FingerStream *somSelf, Environment *ev)
{
   ...
   CFingerStreamData* data = (CFingerStreamData*) somThis-&gt;fData;
    
    if(!data-&gt;fAborting)
    {
      data-&gt;SetStatusString(gCancellingStr);
      data-&gt;fAborting = true;
      if(data-&gt;fTCP)
         data-&gt;fTCP-&gt;Abort(TCP_Yielder);
   }
}
</PRE>
<A NAME=HEADING5-33></A>
<H2>Providing Stream Status Information</H2>
 Your stream class must override methods that provide status information about the stream, as follows:<P>
<UL>
<LI>Override the <A NAME=MARKER-2-84></A><CODE>IsLastModTimeAvailable</CODE> method to return whether or not the time the data was last placed in the stream is available. The <CODE>IsLastModTimeAvailable</CODE> method of the Finger service stream returns <CODE>kODFalse</CODE>, indicating the time is not available.
<LI>Override the <A NAME=MARKER-2-85></A><CODE>GetLastModTime</CODE> method to return the last time that data was placed in the stream. The <CODE>GetLastModTime</CODE> method of the Finger service stream returns <CODE>kCDLastModTimeUnknowable</CODE>, indicating that the time is not known.
<LI>Override the <A NAME=MARKER-2-86></A><CODE>IsTotalDataSizeAvailable</CODE> method to return whether or not the total size of the stream data is available. The <CODE>IsTotalDataSizeAvailable</CODE> method of the Finger service stream returns <CODE>kODFalse</CODE>, indicating the size is not available.
<LI>Override the <A NAME=MARKER-2-87></A><CODE>GetTotalDataSize</CODE> method to return the number of bytes available for downloading. The <CODE>GetTotalDataSize</CODE> method of the Finger service stream returns <CODE>kCDTotalDataSizeUnknowable</CODE>, indicating that the stream's size is unknown. 
<LI>Override the <A NAME=MARKER-2-88></A><CODE>GetStreamError</CODE> method to return nontrivial errors during stream operations. The <CODE>GetStreamError</CODE> method of the Finger service stream returns the <CODE>fError</CODE> field of the CFingerStreamData structure (see <A HREF=#MARKER-9-70>Listing 21</A>), which is set by the stream's thread.
<LI>Override the <A NAME=MARKER-2-89></A><CODE>GetStreamStatus</CODE> method to return the current flags associated with the stream. The <CODE>GetStreamStatus</CODE> method of the Finger service stream returns the <CODE>fStatus</CODE> field of the CFingerStreamData structure (see <A HREF=#MARKER-9-70>Listing 21</A>), which is updated by the stream's thread.
<LI>Override the <A NAME=MARKER-2-90></A><CODE>GetStatusString</CODE> method to specify the current status of the stream. The <CODE>GetStatusString</CODE> method of the Finger service stream, shown in <A HREF=#MARKER-9-91>Listing 28</A>, copies the fStatusString field of the CFingerStreamData structure (see <A HREF=#MARKER-9-70>Listing 21</A>), which is updated by the stream's thread, to the message output parameter. The method also clears the kCDStatusStringChanged flag so that subsequent calls to <CODE>GetStatusString</CODE> will not indicate a change. (The flag is set whenever the string is set.)<P>
</UL>
<B>Listing 28  <A NAME=MARKER-9-91></A>The <CODE>GetStatusString</CODE> method of the Finger service stream</B><P>
<PRE>
SOM_Scope void  SOMLINK FingerStream__GetStatusString
            (AppleCyberdog_FingerStream *somSelf, Environment *ev,
             Str255 message)
{
   ...
   CFingerStreamData* data = (CFingerStreamData*) somThis-&gt;fData;
   
   if(data-&gt;fStatusString)
      pstrcpy(message, data-&gt;fStatusString);
   else
      message[0] = 0;
   data-&gt;fStatus &amp;= ~kCDStatusStringChanged;
}
</PRE>
</BLOCKQUOTE>
<HR>
<center>
<A HREF="ServiceExample-4.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="ServiceExample-1.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="ServiceExample-7.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="ServiceExample-6.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<P>
<FONT SIZE="-1">
<center><font size=-1><A HREF="ServiceExample-1A.html">&copy; Apple Computer, Inc.</A><br>1 JUNE 1996</center></font><P>
<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->
</BODY>
</HTML> 
