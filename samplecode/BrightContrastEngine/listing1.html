<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>BrightContrastEngine - /BCDemo.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxGraphicsImaging-date.html">Graphics & Imaging</a> &gt; <A HREF="javascript:location.replace('index.html');">BrightContrastEngine</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/GraphicsImaging/idxCarbon-date.html" target="_blank">Graphics & Imaging > Carbon</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">BrightContrastEngine</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/BCDemo.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/BCDemo.c</option>
<option value="listing2.html">/BCEngine.h</option>
<option value="listing3.html">/BCEngine.i.c</option></select>
				</p>
				</form>
				<p><strong><a href="BrightContrastEngine.zip">Download Sample</a></strong> (&#147;BrightContrastEngine.zip&#148;, 24.5K)<BR>
<strong><a href="BrightContrastEngine.dmg">Download Sample</a></strong> (&#147;BrightContrastEngine.dmg&#148;, 85.0K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">//****************************************************************************************// Brightness/Contrast Demo//// Written by Jack Fu, 09/1999// Copyright 1999 by Apple Computer, Inc.//----------------------------------------------------------------------------------------//----------------------------------------------------------------------------------------// Includes//----------------------------------------------------------------------------------------#include &lt;AVComponents.h&gt;#include &quot;BCEngine.h&quot;//----------------------------------------------------------------------------------------// Includes//----------------------------------------------------------------------------------------#define  SUPPORT_OLD_BC_ENGINES  1//----------------------------------------------------------------------------------------// Private Defines//----------------------------------------------------------------------------------------#define kSleepTime      10    // in ticks#define kMBARResID      128#define kAppleMenuResID    128#define kFileMenuResID    129#define kEditMenuResID    130enum  // menu items for MENU kFileMenuResID{  kQuitMenuItem = 1};enum  // menu items for MENU kEditMenuResID{  kUndoMenuItem = 1};#define kDialogID        128#define kComponentAlertID    129#define kComponentOpenAlertID  130#define kComponentTargetAlertID  131#define kComponentMiscAlertID  132#define kDMAlertID        133enum  // dialog items for DITL (ID = kDialogID ){  kContrastTextItem = 1,  kContrastSliderItem,  kBrightnessTextItem,  kBrightnessSliderItem,  kContrast0PctTextItem,  kContrast100PctTextItem,  kBrightness0PctTextItem,  kBrightness100PctTextItem};//----------------------------------------------------------------------------------------// Private Prototypes//----------------------------------------------------------------------------------------typedef struct OurDMNotifyData {  ComponentInstance  engine;  DialogPtr      dp;  ControlHandle    brightnessCtl;  ControlHandle    contrastCtl;} OurDMNotifyData, *OurDMNotifyDataPtr, **OurDMNotifyDataHdl;//----------------------------------------------------------------------------------------// Private Prototypes//----------------------------------------------------------------------------------------OSErr     InitializeApp        (void);void     CleanUpApp          (OurDMNotifyDataPtr dataP);DialogPtr   SetupDialog          (ComponentInstance engine, OurDMNotifyDataPtr dataP);OSErr     RunEventLoop        (DialogPtr dp, ComponentInstance engine);OSErr     HandleMouseDown        (EventRecord* theEvent, DialogPtr dp, ComponentInstance engine, Boolean *handled);OSErr     HandleMenuSelect      (EventRecord* theEvent, ComponentInstance engine, Boolean *handled);OSErr     OpenEngine          (ComponentInstance *engine);OSErr     FindBCEngine        (AVIDType displayID, Component *theEnginePtr);OSErr     ResetSettings        (ComponentInstance engine, short brightness, short contrast);OSErr     UpdateSliders        (OurDMNotifyDataPtr dataP);static pascal void BCTargetIterator    (void* userData, DMListIndexType itemIndex, DMComponentListEntryPtr listInfo);pascal OSErr AEOpenHandler        (AppleEvent *messagein, AppleEvent *reply, long refln);pascal OSErr AEQuitHandler        (AppleEvent *messagein, AppleEvent *reply, long refIn);pascal void ContrastActionProc      (ControlHandle theControl, short partCode);pascal void BrightnessActionProc    (ControlHandle theControl, short partCode);pascal void BrightnessContrastNotify  (void* userData, short theMessage, void* notifyData);//----------------------------------------------------------------------------------------// Globals//----------------------------------------------------------------------------------------Boolean            gTimeToQuit       = false;ControlActionUPP      gBrightnessSliderUPP   = NULL;    ControlActionUPP      gContrastSliderUPP     = NULL;    DMExtendedNotificationUPP  gDMNotifyUPP      = NULL;DisplayIDType        gOurDisplayID;short            gInitialBrightness;short            gInitialContrast;//****************************************************************************************// main////----------------------------------------------------------------------------------------int main (void){  OSErr        result     = noErr;  DialogPtr      myDialog   = NULL;  ComponentInstance  engine;  OurDMNotifyData    data;      result = InitializeApp();    //--- First, we must be able to find a brightness/contrast engine ---  if ( result == noErr )    result = OpenEngine( &amp;engine );    //--- Store the initial engine settings in case we want to undo later ---  if ( result == noErr )  {    result = ContrastEngineGetBrightness( engine, &amp;gInitialBrightness );    if ( result == noErr )      result = ContrastEngineGetContrast( engine, &amp;gInitialContrast );  }    if ( result == noErr )  {    //--- Bring up our dialog window ----------------------------------    myDialog = SetupDialog( engine, &amp;data );          //--- Do the main loop -------------------------------------------    if ( myDialog != NULL )      result = RunEventLoop( myDialog, engine );  }    CleanUpApp( &amp;data );    return result;  }//****************************************************************************************// InitializeApp////----------------------------------------------------------------------------------------OSErr InitializeApp (void){  OSErr    result       = noErr;  Handle    myMenu       = NULL;  MenuHandle  appleMenuHandle = NULL;        //--- Initialize all needed managers ---------------------------------  InitGraf(&amp;qd.thePort);  InitFonts();  InitWindows();  InitMenus();  TEInit();  InitDialogs(nil);  InitCursor();  //--- Required Suite -------------------------------------------------  result = AEInstallEventHandler( kCoreEventClass, kAEOpenApplication, NewAEEventHandlerProc(AEOpenHandler), 0L, false );  if ( result == noErr )    result = AEInstallEventHandler( kCoreEventClass, kAEOpenDocuments, NewAEEventHandlerProc(AEOpenHandler), 0L, false );  if ( result == noErr )    result = AEInstallEventHandler( kCoreEventClass, kAEPrintDocuments, NewAEEventHandlerProc(AEOpenHandler), 0L, false );  if ( result == noErr )    result = AEInstallEventHandler( kCoreEventClass, kAEQuitApplication, NewAEEventHandlerProc(AEQuitHandler), 0L, false );      //--- Initialize the Menu Bar ----------------------------------------  if ( result == noErr )  {    myMenu = GetNewMBar( kMBARResID );    SetMenuBar( myMenu );    appleMenuHandle = GetMenuHandle( kAppleMenuResID );    AppendResMenu( appleMenuHandle, 'DRVR' );          //--- When all is said and done, draw the menu ------------    DrawMenuBar();  }    return result;}//****************************************************************************************// CleanUpApp////----------------------------------------------------------------------------------------void CleanUpApp (OurDMNotifyDataPtr dataP){  ProcessSerialNumber  currentPSN;  //--- Remove Display Manager's notification proc -------------  GetCurrentProcess( &amp;currentPSN );  DMRemoveExtendedNotifyProc( gDMNotifyUPP, (void*) dataP, &amp;currentPSN, (unsigned short) NULL);  DisposeRoutineDescriptor( gDMNotifyUPP );    //--- Dispose the other routine descriptors ------------------  DisposeRoutineDescriptor( gBrightnessSliderUPP );  DisposeRoutineDescriptor( gContrastSliderUPP );    return;}//****************************************************************************************// AEOpenHandler////  - used to handle opendoc, openapp, and printdoc AE events//----------------------------------------------------------------------------------------pascal OSErr AEOpenHandler (AppleEvent *messagein, AppleEvent *reply, long refIn){#pragma unused (messagein, refIn, reply)        return noErr;}//****************************************************************************************// AEQuitHandler////  //----------------------------------------------------------------------------------------pascal OSErr AEQuitHandler (AppleEvent *messagein, AppleEvent *reply, long refIn){#pragma unused (messagein, refIn, reply)    gTimeToQuit = true;  return noErr;}//****************************************************************************************#pragma mark -#pragma mark * Event Handling Routines#pragma mark -//****************************************************************************************//****************************************************************************************// RunEventLoop////  //----------------------------------------------------------------------------------------OSErr RunEventLoop (DialogPtr dp, ComponentInstance engine){  OSErr      err     = noErr;  Boolean      handled   = false;  EventRecord    theEvent;  short      itemHit;    while ( err == noErr &amp;&amp; !gTimeToQuit )  {    if ( WaitNextEvent(everyEvent, &amp;theEvent, kSleepTime, NULL) )    {      //--- Handle events ------------------------------------      switch (theEvent.what)      {        case updateEvt:              case activateEvt:                case mouseDown:                if ( IsDialogEvent(&amp;theEvent) )            DialogSelect(&amp;theEvent, &amp;dp, &amp;itemHit);          else            err = HandleMouseDown( &amp;theEvent, dp, engine, &amp;handled );          break;              case keyDown:        case autoKey:          //--- We only care about Command-key shortcuts -----          if ( theEvent.modifiers &amp; cmdKey )            err = HandleMenuSelect( &amp;theEvent, engine, &amp;handled );          break;                          case kHighLevelEvent:          err = AEProcessAppleEvent( &amp;theEvent );          handled = true;          break;                  case diskEvt:        case osEvt:                  default:          break;      }    }  }      return err;}//****************************************************************************************// HandleMouseDown////----------------------------------------------------------------------------------------OSErr HandleMouseDown (EventRecord* theEvent, DialogPtr dp, ComponentInstance engine, Boolean *handled){  OSErr      result     = noErr;  Boolean      wasActive   = true;  WindowPtr    theWindow;  short      partCode;    //--- Figure out which window was hit -------------------------  partCode = FindWindow( theEvent-&gt;where, &amp;theWindow );  //--- Figure out where the window was hit ---------------------    switch( partCode )  {    case inMenuBar:      result = HandleMenuSelect( theEvent, engine, handled );      break;          case inSysWindow:      SystemClick( theEvent, theWindow );      *handled = true;      break;          case inDrag:      {        //--- Allow the user to drag our window around --------        RgnHandle screenbounds = GetGrayRgn();        DragWindow( (WindowPtr)dp, theEvent-&gt;where, &amp;(*screenbounds)-&gt;rgnBBox );      }      break;              case inDesk:    case inGrow:    case inContent:    case inGoAway:    case inZoomIn:    case inZoomOut:      break;        }  return result;}//****************************************************************************************// HandleMenuSelect////----------------------------------------------------------------------------------------OSErr HandleMenuSelect (EventRecord* theEvent, ComponentInstance engine, Boolean *handled){  OSErr  result = noErr;  long  menuVal;    //--- Translate event to something useful -------------------  if ( theEvent-&gt;modifiers &amp; cmdKey )    menuVal = MenuKey( theEvent-&gt;message &amp; charCodeMask );  else    menuVal = MenuSelect( theEvent-&gt;where );    if ( HiWord( menuVal ) == kFileMenuResID &amp;&amp; LoWord( menuVal ) == kQuitMenuItem )  {    //--- The user has hit Command-Q -----------------------    gTimeToQuit = true;    *handled = true;  }  else if ( HiWord( menuVal ) == kEditMenuResID &amp;&amp; LoWord( menuVal ) == kUndoMenuItem )  {    //--- The user has hit Command-Z to undo: reset the contrast/brightness     //--- settings to what we started with    result = ResetSettings( engine, gInitialBrightness, gInitialContrast );  }  //--- Un-hilite the menu bar --------------------------------  HiliteMenu( 0 );      return result;}//****************************************************************************************// UpdateSliders////  //----------------------------------------------------------------------------------------OSErr UpdateSliders (OurDMNotifyDataPtr dataP){  OSErr  result = noErr;  short  value;  //--- Get the current brightness and set the brightness slider control ----  result = ContrastEngineGetBrightness( dataP-&gt;engine, &amp;value );  if ( result == noErr )  {    SetControlValue( dataP-&gt;brightnessCtl, value );        //--- Get the current contrast and set the contrast slider control -----    result = ContrastEngineGetContrast( dataP-&gt;engine, &amp;value );    if ( result == noErr )      SetControlValue( dataP-&gt;contrastCtl, value );     }        return result;}//****************************************************************************************#pragma mark -#pragma mark * Engine Routines#pragma mark -//****************************************************************************************//****************************************************************************************// OpenEngine////  //----------------------------------------------------------------------------------------OSErr OpenEngine (ComponentInstance *engine){  OSErr      result     = noErr;  GDHandle    aGDevice   = NULL;  DisplayIDType  displayID   = kInvalidDisplayID;  Component    bcEngine;    //--- In the demo, we only mess with the main GDevice. In general, one could  //--- use a combination of DMGetFirstScreenDevice and DMGetNextScreenDevice  //--- (see Displays.h) to go through the exhaustive list of displays.  aGDevice = GetMainDevice();  if ( aGDevice != NULL )  {    //--- Get the DisplayID for this GDevice --------------------    result = DMGetDisplayIDByGDevice( aGDevice, &amp;displayID, false );  }    //--- Check for Display Manager errors  if ( aGDevice == NULL || result != noErr )  {    StopAlert( kDMAlertID, NULL );    return -1;  }    //--- Find an engine for this DisplayID -------------------------------  gOurDisplayID = displayID;  result = FindBCEngine( displayID, &amp;bcEngine );  if ( result != noErr )  {    StopAlert( kComponentAlertID, NULL );    return -2;  }    //--- Open the engine --------------------------------------------------  *engine = OpenComponent( bcEngine );  if ( *engine == NULL )  {    StopAlert( kComponentOpenAlertID, NULL );    return -3;  }    //--- Tell the engine which display device we want it to control ----------  result = AVEngineComponentTargetDevice( *engine, displayID );  if ( result != noErr )  {    StopAlert( kComponentTargetAlertID, NULL );    return -4;  }          return result;  }//****************************************************************************************// SetupDialog////  //----------------------------------------------------------------------------------------DialogPtr SetupDialog (ComponentInstance engine, OurDMNotifyDataPtr dataP){  OSErr          result           = noErr;  DialogPtr        dp             = NULL;  ControlHandle      brightnessSliderCtl;  ControlHandle      contrastSliderCtl;  ProcessSerialNumber    currentPSN;  //--- Grab our dialog from resource -------------------------  dp = GetNewDialog( kDialogID, NULL, (WindowPtr) -1 );    if ( ResError() == noErr &amp;&amp; dp != NULL )  {    short       itemType;    Rect      itemRect;    Handle      itemHdl;    short      min, max, value;      SetPort( (GrafPtr) dp );    //--- Set up contrast slider ------------------------------    gContrastSliderUPP = NewControlActionProc( ContrastActionProc );    GetDialogItem( dp, kContrastSliderItem, &amp;itemType, &amp;itemHdl, &amp;itemRect );    result = ContrastEngineGetContrastRange( engine, &amp;min, &amp;max );    if ( result == noErr )    {      result = ContrastEngineGetContrast( engine, &amp;value);      if ( result == noErr )      {                //--- Get and use the system slider procs - this is for 8.0 and later only.        contrastSliderCtl = NewControl ( dp,                          &amp;itemRect,                          &quot;\p&quot;,                          false,                          value,                         min,                          max,                          kControlSliderProc + kControlSliderLiveFeedback + kControlSliderNonDirectional,                          0);            //--- Associate this control with our dialog and set up the control action proc        SetDialogItem( dp, kContrastSliderItem, ctrlItem, (Handle) contrastSliderCtl, &amp;itemRect );        SetControlReference( contrastSliderCtl, (long) engine );        SetControlAction( contrastSliderCtl, gContrastSliderUPP );        ShowControl( contrastSliderCtl );      }    }    if ( result != noErr )    {      StopAlert( kComponentMiscAlertID, NULL );      return NULL;    }        //--- Set up brightness slider ------------------------------    gBrightnessSliderUPP = NewControlActionProc( BrightnessActionProc );    GetDialogItem( dp, kBrightnessSliderItem, &amp;itemType, &amp;itemHdl, &amp;itemRect );    result = ContrastEngineGetBrightnessRange( engine, &amp;min, &amp;max );    if ( result == noErr )    {      result = ContrastEngineGetBrightness( engine, &amp;value);      if ( result == noErr )      {                //--- Get and use the system slider procs - this is for 8.0 and later only.        brightnessSliderCtl = NewControl ( dp,                            &amp;itemRect,                            &quot;\p&quot;,                            false,                            value,                              min,                               max,                               kControlSliderProc + kControlSliderLiveFeedback + kControlSliderNonDirectional,                               0);            //--- Associate this control with our dialog and set up the control action proc        SetDialogItem( dp, kBrightnessSliderItem, ctrlItem, (Handle) brightnessSliderCtl, &amp;itemRect);        SetControlReference( brightnessSliderCtl, (long) engine );        SetControlAction( brightnessSliderCtl, gBrightnessSliderUPP );        ShowControl( brightnessSliderCtl );      }    }    if ( result != noErr )    {      StopAlert( kComponentMiscAlertID, NULL );      return NULL;    }        //--- Set up some stuff used by the notification function (i.e. when Display Mgr calls us)    dataP-&gt;engine       = engine;    dataP-&gt;dp         = dp;    dataP-&gt;brightnessCtl   = brightnessSliderCtl;    dataP-&gt;contrastCtl     = contrastSliderCtl;    //----------------------------------------------------------------------    // Register for notification with the Display Manager so we can update    // the sliders if brightness or contrast changes outside of our demo app.    // Display Mgr will call us whenever brightness or contrast change so    // we can update our sliders to reflect the actual values.    //----------------------------------------------------------------------    GetCurrentProcess( &amp;currentPSN );    gDMNotifyUPP = NewDMExtendedNotificationProc( BrightnessContrastNotify );    DMRegisterExtendedNotifyProc( gDMNotifyUPP, (void*) dataP, (unsigned short) NULL, &amp;currentPSN );        //--- show our dialog box ---------------------------------    ShowWindow( (WindowPtr) dp );      }    return dp;}//****************************************************************************************// ResetSettings////  //----------------------------------------------------------------------------------------OSErr ResetSettings (ComponentInstance engine, short brightness, short contrast){  OSErr  result = noErr;    //--- Call the engine to reset the values for brightness and contrast.  //--- We won't redraw the sliders here: Display Mgr will notify us later  //--- so we can update the sliders later.  result = ContrastEngineSetBrightness( engine, brightness );  if ( result == noErr )    result = ContrastEngineSetContrast( engine, contrast );      if ( result != noErr )    StopAlert( kComponentMiscAlertID, NULL );      return result;}//****************************************************************************************// FindBCEngine////  //----------------------------------------------------------------------------------------OSErr FindBCEngine (AVIDType displayID, Component *theEnginePtr){  ComponentResult        result;  DMListType          engineList       = NULL;  DMListIndexType        engineCount     = 0;  DMComponentListIteratorUPP  theListIteratorUPP;  //--- Pre-init the returned engine ptr ------------------------------  *theEnginePtr = NULL;  #if SUPPORT_OLD_BC_ENGINES  //-------------------------------------------------------------------  // Currently, there are two types of brightness/contrast engines:  //  //   kContrastEngineComponentSubType  //   kOldContrastEngineComponentSubType  //  // The first engine type is more general and can handle all apple  // displays. The second engine type is meant to be used only with   // macs that have built-in displays (like the iMac or the all-in-one  // PowerMac G3). Currently, the former engine type cannot control  // brightness/contrast on the built-in monitors.  //  // However, the latter is being phased out, and in a little while  // we will provide a single engine type (i.e. kContrastEngineComponentSubType)  // that can handle all apple displays -- built-in or otherwise. At that  // point in time, one would only need to ask for and use one single  // engine type.  //  // In the meantime, we can find an appropriate engine to use with  // any given GDevice by looking for kOldContrastEngineComponentSubType  // first. If an engine is returned by DMNewAVEngineList, we'll know  // that the given GDevice is a built-in display. If no engines are  // returned, then we know that we need to look for the more general  // kContrastEngineComponentSubType engine type.   //  // Note that Apple's brightness/contrast engines do not work with  // third-party displays.  //-------------------------------------------------------------------  result = DMNewAVEngineList( displayID,                              kOldContrastEngineComponentSubType,                kMinimumFidelity,                          0,                0,                &amp;engineCount,                &amp;engineList );#endif  //-------------------------------------------------------------------  // DMNewAVEngineList()  //  //   DMNewAVEngineList is a Display Manager call that can be used to  //   find engines that will work with a particular display. For example,  //   in this demo app we are interested in finding a brightness/contrast  //   engine that will work with the main GDevice.   //  //   Display Manager will only return engines matching the caller's  //   requirements. Here are some brief descriptions of each parameter:  //  //  //  DMNewAVEngineList ( DisplayIDType     displayID,  //               ResType       engineType,  //               DMFidelityType     minimumFidelity,  //             unsigned long    engineListFlags,  //             unsigned long    reserved,  //             DMListIndexType *  engineCount,  //             DMListType *    engineList )  //  //  //  displayID - the display ID of the display that we want an engine for.  //  //  engineType - the type of engine that we are interested in. For  //               brightness/contrast engines, use the constant  //         &quot;kContrastEngineComponentSubType&quot;, which will return  //         engines that can talk to Apple's displays. Currently,  //         you'll need to specify &quot;kOldContrastEngineComponentSubType&quot;  //         if you want an engine to control built-in displays like  //         on the iMac or the all-in-one PowerMac G3. In the near  //         future, one will be able to specify just one constant  //         (kContrastEngineComponentSubType) and get the best   //         brightness/contrast engine that'll work with the given  //         display ID without using two constants.  //  //  minimumFidelity - an arbitrary number used by engines to tell Display  //            Manager how well each engine works with the given  //            display. Display Manager will not return any engine  //            that has a lower fidelity than specified in this  //            parameter. In general, use &quot;kMinimumFidelity&quot;.  //  //  engineListFlags - set to 0.  //  //  reserved - set to 0.  //  //  engineCount - returns the number of engines found.  //  //  engineList - a list of engines that match the requirements. The first  //         engine will be the best one to use. See code below for  //         grabbing the first engine.  //  //-------------------------------------------------------------------    if ( engineCount &lt;= 0 )  {      //--- We couldn't find any old brightness/contrast engines. So    //--- we'll just look for and use the normal one.    //--- Clean up the engine list if necessary    if ( engineList != NULL )      DMDisposeList( engineList );        //--- Ask DisplayMgr for a list of brightness/contrast engines ------    //--- NOTE: DM _only_ returns engines for the given displayID -------    result = DMNewAVEngineList( displayID,                   kContrastEngineComponentSubType,                  kMinimumFidelity,                   0,                   0,                   &amp;engineCount,                   &amp;engineList);  }  //--- Did we get an engine? -----------------------------------------  if ( result == noErr &amp;&amp; engineCount &gt; 0 )  {    theListIteratorUPP = NewDMComponentListIteratorProc(BCTargetIterator);        //--- Get the first engine in list ------------------------------    result = DMGetIndexedComponentFromList( engineList, 0, 0, theListIteratorUPP, theEnginePtr );    //--- Get rid of the list routine descriptor    DisposeRoutineDescriptor(theListIteratorUPP);  }  else  {    result = -1;  }  //--- Dispose of the list --------------------------------------------  if ( engineList != NULL )    DMDisposeList( engineList );  return result;}//****************************************************************************************// BCTargetIterator////  //----------------------------------------------------------------------------------------static pascal void BCTargetIterator (void* userData, DMListIndexType itemIndex, DMComponentListEntryPtr listInfo){  #pragma unused(itemIndex)    *(Component *)userData = listInfo-&gt;itemComponent;}//****************************************************************************************// BrightnessActionProc////  //----------------------------------------------------------------------------------------pascal void BrightnessActionProc (ControlHandle theControl, short partCode){#pragma unused (partCode)  ComponentInstance   engine     = (ComponentInstance) GetControlReference( theControl);  short        brightness   = GetControlValue( theControl );    //--- Set the brightness. Since we can't pass back errors, just ignore any error  ContrastEngineSetBrightness( engine, brightness );    return;}//****************************************************************************************// ContrastActionProc////  //----------------------------------------------------------------------------------------pascal void ContrastActionProc (ControlHandle theControl, short partCode){#pragma unused (partCode)  ComponentInstance   engine     = (ComponentInstance) GetControlReference( theControl);  short        contrast   = GetControlValue( theControl );    //--- Set the contrast. Since we can't pass back errors, just ignore any error  ContrastEngineSetContrast( engine, contrast );    return;}                             //****************************************************************************************// BrightnessContrastNotify////  This function is registered with Display Mgr (see SetupDialog) and is called//  by Display Mgr whenever the contrast or the brightness changes on any display.//  All we have to do is update our brightness and contrast sliders to//  reflect this change. This way, if some other app changes the brightness/contrast//  behind our backs (e.g. Monitors control panel), our sliders will pick up these//  changes while the demo app is running.////----------------------------------------------------------------------------------------pascal void BrightnessContrastNotify (void* userData, short theMessage, void* notifyData){  OurDMNotifyDataPtr    dataP = (OurDMNotifyDataPtr) userData;  DependentNotifyPtr     dependentNotifyData = NULL;    //--- If it's not a dependent notification, we don't care ------------  if ( theMessage != kDMNotifyDependents )    return;    //--- We need the notification data for further analysis -------------  dependentNotifyData = (DependentNotifyPtr)notifyData;  if ( dependentNotifyData == NULL )    return;    //--- If it's not the display that we are interested in, we don't care  if ( dependentNotifyData-&gt;notifyPortID != gOurDisplayID )    return;  //--- If it's not a brightness/contrast change or device reset, we don't care  if ( dependentNotifyData-&gt;notifyType != kContrastChanged &amp;&amp;      dependentNotifyData-&gt;notifyType != kBrightnessChanged &amp;&amp;     dependentNotifyData-&gt;notifyType != kAVNotifyDeviceReset )  {    return;  }    //--- Update the sliders to reflect any changes. We have enough information  //--- to only update either the brightness or the contrast slider, but  //--- we'll be lazy and update both.  UpdateSliders( dataP );    return;}</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/BrightContrastEngine/listing1.html%3Fid%3DDTS10000067-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/BrightContrastEngine/listing1.html%3Fid%3DDTS10000067-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/BrightContrastEngine/listing1.html%3Fid%3DDTS10000067-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>