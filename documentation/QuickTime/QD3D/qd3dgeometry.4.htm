<HTML><HEAD><META NAME="GENERATOR" CONTENT="Adobe FrameMaker 5.5/HTML Export Filter"><script language="JavaScript" src="frametest.js"></script><TITLE> Polyhedral Primitives</TITLE></HEAD><BODY BGCOLOR="#ffffff"><!-- start of header --><!--#include virtual="/includes/framesetheader" --><!-- end of header --><!-- path goes here --><H1 CLASS="H2.Heading2"><A NAME="pgfId=31048"> </A><A NAME="19232"> </A>Polyhedral Primitives</H1><P CLASS="T1.Text1"><A NAME="pgfId=31408"> </A>QuickDraw&nbsp;3D provides four basic <B CLASS="bold">polyhedral primitives,</B> three-dimensional surfaces composed of polygonal faces that share edges and vertices with other faces. These are the mesh, the trimesh, the trigrid, and the polyhedron. Although you can use each of these primitives to represent the same sorts of shapes, there are important differences in their memory use, ease of definition, flexibility, and other features. This section describes the four polyhedral primitives individually. Then it compares their strengths and weaknesses (in <A HREF="qd3dgeometry.4.htm#22045" CLASS="XRef">&quot;Comparison of the Polyhedral Primitives&quot;</A>). See <A HREF="qd3dgeometry.7.htm#12575" CLASS="XRef">&quot;Using Geometric Objects&quot;</A> for code samples that show how to construct several different polyhedral primitives.</P><DIV><H2 CLASS="H3.Heading3"><A NAME="pgfId=31098"> </A><A NAME="37165"> </A>Meshes</H2><P CLASS="T1.Text1"><A NAME="pgfId=31050"> </A><A NAME="marker=31049"> </A>A <B CLASS="bold">mesh</B> is a collection of vertices, faces, and edges that represents a topological polyhedron (that is, a solid figure composed of polygonal faces). The polyhedra represented by QuickDraw&nbsp;3D meshes do not need to be closed, so that the meshes may have boundaries. <A HREF="qd3dgeometry.4.htm#26661" CLASS="XRef">Figure&nbsp;5</A> illustrates a mesh.<A NAME="marker=31057"> </A></P><P CLASS="Fg.Figure"><A NAME="pgfId=3154"> </A>Figure&nbsp;5<A NAME="26661"> </A>A mesh</P><DIV><IMG SRC="qd3dgeometry-1.gif"></DIV><P CLASS="T1.Text1"><A NAME="pgfId=3155"> </A>A <B CLASS="bold">mesh face</B> is a polygonal figure that forms part of the surface of the mesh. QuickDraw&nbsp;3D does not require mesh faces to be planar, but you can obtain unexpected results when rendering nonplanar mesh faces with a filled style. In&nbsp;addition, a mesh face can contain holes, as shown in <A HREF="qd3dgeometry.4.htm#22767" CLASS="XRef">Figure&nbsp;6</A>.<A NAME="marker=3162"> </A></P><P CLASS="Fg.Figure"><A NAME="pgfId=3167"> </A>Figure&nbsp;6<A NAME="22767"> </A>A mesh face with a hole</P><DIV><IMG SRC="qd3dgeometry-2.gif"></DIV><P CLASS="T1.Text1"><A NAME="pgfId=3168"> </A>A mesh face is defined by a list of <B CLASS="bold">mesh vertices.</B> The ordering of the vertices is unimportant; you can list the vertices of a mesh face in either clockwise or counterclockwise order. QuickDraw&nbsp;3D internally attempts to maintain a consistent ordering of the vertices of all the faces of a mesh.<A NAME="marker=3172"> </A></P><P CLASS="T1.Text1"><A NAME="pgfId=3176"> </A>Because of their potential complexity, QuickDraw&nbsp;3D treats meshes differently than it treats all other basic geometric objects. Usually, you create a basic geometric object by filling in a public data structure that completely specifies that object (for example, a structure of type <TT CLASS="cv">TQ3TriangleData</TT>) and then by passing that structure to the appropriate object-creating routine (for example, <TT CLASS="cv">Q3Triangle_New</TT>). To create a mesh, however, you first create a new empty mesh (by calling <TT CLASS="cv">Q3Mesh_New</TT>), and then you explicitly add vertices and faces to the mesh (by calling <TT CLASS="cv">Q3Mesh_VertexNew</TT> and <TT CLASS="cv">Q3Mesh_FaceNew</TT>).</P><P CLASS="Note"><A NAME="pgfId=3177"> </A>Although you can manipulate an edge in a mesh (for instance, assign an attribute set to it), you cannot explicitly add an edge to a mesh. Mesh edges are implicitly created or destroyed when the faces containing them are created or destroyed. <A NAME="marker=21333"> </A></P><P CLASS="T1.Text1"><A NAME="pgfId=3181"> </A>Because you can dynamically add or remove faces and vertices in a mesh, a mesh is always a retained object (that is, QuickDraw&nbsp;3D maintains the mesh data internally) and never an immediate object. As a result, QuickDraw&nbsp;3D does not supply routines to submit or write meshes in immediate mode. QuickDraw&nbsp;3D builds an internal data structure that records the topology of a mesh (that is, the edge connections between all the faces and vertices in the mesh). For large models, this might require a large amount of memory. If your application does not need to use the topological information maintained by QuickDraw&nbsp;3D (which you access by calling mesh iterator functions), you might want to use a trigrid or polyhedron (or a number of triangles, or a number of simple or general polygons) to represent a large number of interconnected polygons.<A NAME="marker=12865"> </A></P><P CLASS="Note"><A NAME="pgfId=12854"> </A>See <A HREF="qd3dgeometry.41.htm#30340" CLASS="XRef">&quot;Traversing Mesh Components, Vertices, Faces, and Edges&quot;</A>, for information on the mesh iterator functions. </P><P CLASS="T1.Text1"><A NAME="pgfId=3188"> </A>As you've seen, a face of a mesh can contain one or more holes. A hole is defined by a <B CLASS="bold">contour,</B> which is just a list of vertices. You create a contour in a mesh face by creating a face that contains the vertices in the contour (by calling <TT CLASS="cv">Q3Mesh_FaceNew</TT>) and then by converting the face into a contour (by calling <TT CLASS="cv">Q3Mesh_FaceToContour</TT>). For optimal results, the face that contains the contour (called the <B CLASS="bold">container face</B>) and the contour itself should be coplanar. In addition, the contour should lie entirely within the container face.<A NAME="marker=3189"> </A><A NAME="marker=3190"> </A></P><P CLASS="Note"><A NAME="pgfId=3194"> </A>See <A HREF="qd3dgeometry.b.htm#11337" CLASS="XRef">&quot;Creating a Mesh&quot;</A> for sample code that creates a mesh. </P><P CLASS="T1.Text1"><A NAME="pgfId=3198"> </A>The geometric structure of a mesh is completely defined by its faces, vertices, edges, and contours. For purposes of shading and picking, QuickDraw&nbsp;3D defines several other parts of a mesh: corners, mesh parts, and components. A&nbsp;<B CLASS="bold">mesh corner</B> (or a <B CLASS="bold">corner</B>) is specified by a mesh face together with one of its vertices. (A face with five vertices therefore has five corners.) You can associate a set of attributes with each corner. The attributes in a corner override any existing attributes of the associated vertex. For example, you can use corners to achieve special shading effects, such as hard edges when applying a smooth shading to a mesh. When a face is being shaded smoothly, the normals used to determine the amount of shading are the normals of the face's vertices. Because a vertex and its normal may be associated with several faces, the light intensity computed by a shading algorithm is the same for all points around that vertex. As a result, the edges between appear smooth. To get a hard edge, you can assign different normals to the corners on opposite sides of the edge.<A NAME="marker=12885"> </A></P><P CLASS="T1.Text1"><A NAME="pgfId=3203"> </A>A <B CLASS="bold">mesh part object</B> (or, more briefly, a <B CLASS="bold">mesh part</B>) is a single distinguishable part of a mesh. You can use mesh parts to handle user picking in a mesh. When, for example, the user clicks on a mesh, you can interpret the click as a click on the entire mesh, on a face of a mesh, on an edge of the mesh, or on a vertex of the mesh. QuickDraw&nbsp;3D signals your application that the user clicked on a mesh part by putting a reference to that mesh part in the <TT CLASS="cv">shapePart</TT> field of a hit data structure. (Mesh parts are currently the only types of shape part objects.) You can then call QuickDraw&nbsp;3D routines to get the mesh face, edge, or vertex that corresponds to the selected mesh part. See the chapter <A HREF="qd3dpicking.htm#15462" CLASS="XRef">&quot;Pick Objects&quot;</A> for complete details about mesh parts.<A NAME="marker=3213"> </A></P><P CLASS="T1.Text1"><A NAME="pgfId=12440"> </A>A <B CLASS="bold">mesh component</B> (or a <B CLASS="bold">component</B>) is a collection of connected vertices. (Two vertices are considered to be <B CLASS="bold">connected</B> if an unbroken path of edges exists linking one vertex to the other.) For each mesh, QuickDraw&nbsp;3D maintains information about the components in the mesh and updates that information whenever a face or vertex is added to or removed from a mesh. You can use QuickDraw&nbsp;3D routines to iterate through the components in a mesh, and you can call <TT CLASS="cv">Q3MeshPart_GetComponent</TT> to get the component in a mesh that was selected during picking. Mesh components cannot have attributes.<A NAME="marker=12447"> </A><A NAME="marker=12448"> </A></P><P CLASS="T1.Text1"><A NAME="pgfId=12456"> </A>Mesh components are transient; that is, they are created and destroyed dynamically as the topology of the mesh changes. Whenever you change the topology (for example, by adding or deleting a vertex or face), QuickDraw&nbsp;3D needs to update its internal list of mesh components. You can turn off this updating by calling the <TT CLASS="cv">Q3Mesh_DelayUpdates</TT> function, and you can resume this updating by calling the <TT CLASS="cv">Q3Mesh_ResumeUpdates</TT> function. For performance reasons, it's useful to delay updates while adding or deleting a large number of vertices or faces.</P><P CLASS="T1.Text1"><A NAME="pgfId=12485"> </A>Note, however, that you cannot rely on some mesh functions to return accurate results if you call them while mesh updating is delayed. For instance, the <TT CLASS="cv">Q3Mesh_GetNumComponents</TT> function is not guaranteed to return accurate results if mesh updating is delayed.</P><P CLASS="T1.Text1"><A NAME="pgfId=12496"> </A>Note also that a vertex, edge, or face might be shifted from one component to another during a change in the topology of the mesh. To be safe, you should bracket all changes to the mesh topology by calls to <TT CLASS="cv">Q3Mesh_DelayUpdates</TT> and <TT CLASS="cv">Q3Mesh_ResumeUpdates</TT>, and you should not assume that mesh component functions will return reliable results until after you've called <TT CLASS="cv">Q3Mesh_ResumeUpdates</TT>.</P><P CLASS="Note"><A NAME="pgfId=12449"> </A>You can duplicate a mesh by calling <TT CLASS="cv">Q3Object_Duplicate</TT>. The&nbsp;duplicate mesh, however, might not preserve the ordering of components, faces, or vertices of the original mesh. <A NAME="marker=12453"> </A></P></DIV><DIV><H2 CLASS="H3.Heading3"><A NAME="pgfId=31418"> </A>Trigrids</H2><P CLASS="T1.Text1"><A NAME="pgfId=31434"> </A><A NAME="marker=31433"> </A>A <B CLASS="bold">trigrid</B> is a rectangular grid composed of triangular facets. A trigrid, like most other QuickDraw&nbsp;3D primitives, is defined using a public data structure, the <TT CLASS="cv">TQ3TriGridData</TT> data type:</P><CODE CLASS="Cv.Code"><A NAME="pgfId=39368"> </A>typedef struct TQ3TriGridData {<BR>&nbsp;&nbsp;&nbsp;&nbsp;unsigned long&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;numRows;<BR>&nbsp;&nbsp;&nbsp;&nbsp;unsigned long&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;numColumns;<BR>&nbsp;&nbsp;&nbsp;&nbsp;TQ3Vertex3D&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*vertices;<BR>&nbsp;&nbsp;&nbsp;&nbsp;TQ3AttributeSet&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*facetAttributeSet;<BR>&nbsp;&nbsp;&nbsp;&nbsp;TQ3AttributeSet&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;triGridAttributeSet;<BR>} TQ3TriGridData;<BR></CODE><P CLASS="T1.Text1"><A NAME="pgfId=31445"> </A>Once it's defined, a trigrid has a fixed topology defined by the number of rows and columns. You can alter the position of any individual vertex, but you cannot add vertices to (or remove vertices from) a trigrid. In addition, a trigrid can model only rectangular objects, not arbitrary three-dimensional surfaces. Nevertheless, trigrids use memory extremely efficiently and are therefore good choices for modeling rectangular objects.</P></DIV><DIV><H2 CLASS="H3.Heading3"><A NAME="pgfId=31520"> </A>Polyhedra</H2><P CLASS="T1.Text1"><A NAME="pgfId=31522"> </A><A NAME="marker=31521"> </A>A <B CLASS="bold">polyhedron</B> is a polyhedral primitive, all of whose faces are triangular. (As you'll see below, however, it's possible to render non-triangular faces by selecting which edges of each triangular face are drawn.) The faces of a polyhedron are defined indirectly, using indices into an array of vertices. This indirection makes it easy for faces to share vertices and attribute sets, which thereby reduces both the memory required to define the polyhedron and the time required to render the polyhedron.</P><P CLASS="I.Important"><A NAME="pgfId=31538"> </A>The polyhedron is the preferred polyhedral primitive for general-purpose modeling of three-dimensional surfaces. Unlike a trigrid, a polyhedron can represent any surface, not just rectangular ones. In addition, you can use both immediate and retained modes with polyhedra. </P><P CLASS="T1.Text1"><A NAME="pgfId=31548"> </A>To define a polyhedron, you first need to create an array of three-dimensional points (of type <TT CLASS="cv">TQ3Point3D</TT>). Then you need to define an array of triangles, each of which specifies three of the points in the point array and some additional information about which edges of the triangle to draw and what attributes, if any, the triangle has.</P><P CLASS="T1.Text1"><A NAME="pgfId=31562"> </A>You specify a point in the array of points using a vertex specified by its index into the array of three-dimensional points.</P><P CLASS="T1.Text1"><A NAME="pgfId=31564"> </A>An individual triangular face of a polyhedron is defined by the <TT CLASS="cv">TQ3PolyhedronTriangleData</TT> data type.</P><CODE CLASS="Cv.Code"><A NAME="pgfId=39374"> </A>typedef struct TQ3PolyhedronTriangleData {<BR>&nbsp;&nbsp;&nbsp;&nbsp;unsigned long&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vertexIndices[3];<BR>&nbsp;&nbsp;&nbsp;&nbsp;TQ3PolyhedronEdge&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;edgeFlag;<BR>&nbsp;&nbsp;&nbsp;&nbsp;TQ3AttributeSet&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;triangleAttributeSet;<BR>} TQ3PolyhedronTriangleData;<BR></CODE><P CLASS="T1.Text1"><A NAME="pgfId=31580"> </A>The <TT CLASS="cv">edgeFlag</TT> field specifies which edges of the triangle are to be drawn; see below for more details.</P><P CLASS="T1.Text1"><A NAME="pgfId=36694"> </A>Finally, once you've created the array of points in the array and defined one or more triangular faces for the polyhedron, you can define a polyhedron using the <TT CLASS="cv">TQ3PolyhedronData</TT> data type:</P><CODE CLASS="Cv.Code"><A NAME="pgfId=39380"> </A>typedef struct TQ3PolyhedronData {<BR>&nbsp;&nbsp;&nbsp;&nbsp;unsigned long&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;numPoints;<BR>&nbsp;&nbsp;&nbsp;&nbsp;TQ3Vertex3D&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*vertices;<BR>&nbsp;&nbsp;&nbsp;&nbsp;unsigned long&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;numEdges;<BR>&nbsp;&nbsp;&nbsp;&nbsp;TQ3PolyhedronEdgeData&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*edges;<BR>&nbsp;&nbsp;&nbsp;&nbsp;unsigned long&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;numTriangles;<BR>&nbsp;&nbsp;&nbsp;&nbsp;TQ3PolyhedronTriangleData&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*triangles;<BR>&nbsp;&nbsp;&nbsp;&nbsp;TQ3AttributeSet&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;polyhedronAttributeSet;<BR>} TQ3PolyhedronData;<BR></CODE><P CLASS="T1.Text1"><A NAME="pgfId=31597"> </A>This structure specifies the number of points in the polyhedron, the points array, the number of triangles in the polyhedron, and the triangles array. These fields contain the minimum data you need to define a polyhedron.</P><P CLASS="T1.Text1"><A NAME="pgfId=31618"> </A>The polyhedron data structure also contains information about the edges in the polyhedron. You can specify edge information either using the <TT CLASS="cv">edgeFlag</TT> field of each individual triangle, or you can do so using the <TT CLASS="cv">numEdges</TT> and <TT CLASS="cv">edges</TT> fields of the polyhedron data structure. See <A HREF="qd3dgeometry.2c.htm#22139" CLASS="XRef">&quot;Polyhedra&quot;</A> for more information on specifying polyhedron edges.<A NAME="marker=36830"> </A></P></DIV><DIV><H2 CLASS="H3.Heading3"><A NAME="pgfId=31129"> </A><A NAME="13430"> </A>Trimeshes</H2><P CLASS="T1.Text1"><A NAME="pgfId=31133"> </A>Trimeshes are similar to polyhedra in that they are defined indirectly, using indices into an array of points. In addition, a trimesh has an optional edge array that defines the edges that are to be drawn. However, trimeshes handle attributes quite differently from all other QuickDraw&nbsp;3D geometric primitives. You do not store attributes for a trimesh (or for any part of a trimesh) in a set of type <TT CLASS="cv">TQ3AttributeSet</TT>. Instead, you must use a structure of type <TT CLASS="cv">TQ3TriMeshAttributeData</TT>, which stores attribute data contiguously in a single block of memory.</P><P CLASS="T1.Text1"><A NAME="pgfId=31657"> </A>More importantly, attributes associated with a trimesh must conform to this restriction: if any single vertex (or edge, or face) has an attribute of a specific non-custom type, then <I CLASS="italics">every</I> vertex (or edge, or face) in the trimesh must also have an attribute of that type. (There are, therefore, no shared attributes.) This restriction can deleteriously affect the memory requirements of a large trimesh.</P><P CLASS="T1.Text1"><A NAME="pgfId=31651"> </A>The trimesh is not suitable for general-purpose use representing polyhedral models. The restrictions on attribute storage can result in very large memory requirements, even though only a few faces might need attributes assigned to them. In addition, there are no functions provided by QuickDraw&nbsp;3D that allow you to change the geometric or topological configuration of a trimesh object. Trimeshes are designed for immediate mode rendering, and are most suitable for surfaces in which all the component triangles have the same types of attributes.</P></DIV><DIV><H2 CLASS="H3.Heading3"><A NAME="pgfId=31170"> </A><A NAME="22045"> </A>Comparison of the Polyhedral Primitives</H2><P CLASS="T1.Text1"><A NAME="pgfId=31741"> </A>You can use the four polyhedral primitives--the polyhedron, trimesh, mesh, and trigrid--to create similar shapes. However, these primitives offer important differences in their generality, flexibility, style of programming, performance, and compliance with the overall design goal of treating retained and immediate mode programming as equivalent. <A HREF="qd3dgeometry.4.htm#25059" CLASS="XRef">Table 3-1</A> provides an overview of their chracteristics, which are discussed in greater detail in <A HREF="qd3dgeometry.7.htm#12575" CLASS="XRef">&quot;Using Geometric Objects&quot;</A>.</P><TABLE><CAPTION><P CLASS="TbF.TblFull"><A NAME="pgfId=31771"> </A>Table 3-1	<A NAME="25059"> </A>Characteristics of polyhedral primitives&nbsp;</P></CAPTION><TR><TH ROWSPAN="1" COLSPAN="1"><P CLASS="TbH.TblHd"><A NAME="pgfId=32082"> </A>Characteristic</P></TH><TH ROWSPAN="1" COLSPAN="1"><P CLASS="TbH.TblHd"><A NAME="pgfId=32084"> </A>Polyhedron</P></TH><TH ROWSPAN="1" COLSPAN="1"><P CLASS="TbH.TblHd"><A NAME="pgfId=32086"> </A>Trimesh</P></TH><TH ROWSPAN="1" COLSPAN="1"><P CLASS="TbH.TblHd"><A NAME="pgfId=32088"> </A>Mesh</P></TH><TH ROWSPAN="1" COLSPAN="1"><P CLASS="TbH.TblHd"><A NAME="pgfId=32090"> </A>Trigrid</P></TH></TR><TR><TD ROWSPAN="1" COLSPAN="1"><P CLASS="TbT.TblText"><A NAME="pgfId=32092"> </A>Memory usage</P></TD><TD ROWSPAN="1" COLSPAN="1"><P CLASS="TbT.TblText"><A NAME="pgfId=32094"> </A>Very good</P></TD><TD ROWSPAN="1" COLSPAN="1"><P CLASS="TbT.TblText"><A NAME="pgfId=32096"> </A>Fair to very good</P></TD><TD ROWSPAN="1" COLSPAN="1"><P CLASS="TbT.TblText"><A NAME="pgfId=32098"> </A>Poor</P></TD><TD ROWSPAN="1" COLSPAN="1"><P CLASS="TbT.TblText"><A NAME="pgfId=32100"> </A>Very good</P></TD></TR><TR><TD ROWSPAN="1" COLSPAN="1"><P CLASS="TbT.TblText"><A NAME="pgfId=32102"> </A>File space usage</P></TD><TD ROWSPAN="1" COLSPAN="1"><P CLASS="TbT.TblText"><A NAME="pgfId=32104"> </A>Very good</P></TD><TD ROWSPAN="1" COLSPAN="1"><P CLASS="TbT.TblText"><A NAME="pgfId=32106"> </A>Fair to very good</P></TD><TD ROWSPAN="1" COLSPAN="1"><P CLASS="TbT.TblText"><A NAME="pgfId=32108"> </A>Very good</P></TD><TD ROWSPAN="1" COLSPAN="1"><P CLASS="TbT.TblText"><A NAME="pgfId=32110"> </A>Very good</P></TD></TR><TR><TD ROWSPAN="1" COLSPAN="1"><P CLASS="TbT.TblText"><A NAME="pgfId=32112"> </A>Rendering speed</P></TD><TD ROWSPAN="1" COLSPAN="1"><P CLASS="TbT.TblText"><A NAME="pgfId=32114"> </A>Good to very good</P></TD><TD ROWSPAN="1" COLSPAN="1"><P CLASS="TbT.TblText"><A NAME="pgfId=32116"> </A>Good to very good</P></TD><TD ROWSPAN="1" COLSPAN="1"><P CLASS="TbT.TblText"><A NAME="pgfId=32118"> </A>Fair to good</P></TD><TD ROWSPAN="1" COLSPAN="1"><P CLASS="TbT.TblText"><A NAME="pgfId=32120"> </A>Good to very good</P></TD></TR><TR><TD ROWSPAN="1" COLSPAN="1"><P CLASS="TbT.TblText"><A NAME="pgfId=32122"> </A>Geometric object editing</P></TD><TD ROWSPAN="1" COLSPAN="1"><P CLASS="TbT.TblText"><A NAME="pgfId=32124"> </A>Very good</P></TD><TD ROWSPAN="1" COLSPAN="1"><P CLASS="TbT.TblText"><A NAME="pgfId=32126"> </A>Impossible (no API calls)</P></TD><TD ROWSPAN="1" COLSPAN="1"><P CLASS="TbT.TblText"><A NAME="pgfId=32128"> </A>Very good</P></TD><TD ROWSPAN="1" COLSPAN="1"><P CLASS="TbT.TblText"><A NAME="pgfId=32130"> </A>Very good</P></TD></TR><TR><TD ROWSPAN="1" COLSPAN="1"><P CLASS="TbT.TblText"><A NAME="pgfId=32132"> </A>Topological object editing</P></TD><TD ROWSPAN="1" COLSPAN="1"><P CLASS="TbT.TblText"><A NAME="pgfId=32134"> </A>Poor</P></TD><TD ROWSPAN="1" COLSPAN="1"><P CLASS="TbT.TblText"><A NAME="pgfId=32136"> </A>Impossible (no API calls)</P></TD><TD ROWSPAN="1" COLSPAN="1"><P CLASS="TbT.TblText"><A NAME="pgfId=32138"> </A>Very good</P></TD><TD ROWSPAN="1" COLSPAN="1"><P CLASS="TbT.TblText"><A NAME="pgfId=32140"> </A>Impossible (fixed topology)</P></TD></TR><TR><TD ROWSPAN="1" COLSPAN="1"><P CLASS="TbT.TblText"><A NAME="pgfId=32142"> </A>Geometric data structure editing</P></TD><TD ROWSPAN="1" COLSPAN="1"><P CLASS="TbT.TblText"><A NAME="pgfId=32144"> </A>Very good</P></TD><TD ROWSPAN="1" COLSPAN="1"><P CLASS="TbT.TblText"><A NAME="pgfId=32146"> </A>Very good</P></TD><TD ROWSPAN="1" COLSPAN="1"><P CLASS="TbT.TblText"><A NAME="pgfId=32148"> </A>Impossible (no data structure)</P></TD><TD ROWSPAN="1" COLSPAN="1"><P CLASS="TbT.TblText"><A NAME="pgfId=32150"> </A>Very good</P></TD></TR><TR><TD ROWSPAN="1" COLSPAN="1"><P CLASS="TbT.TblText"><A NAME="pgfId=32152"> </A>Topological data structure editing</P></TD><TD ROWSPAN="1" COLSPAN="1"><P CLASS="TbT.TblText"><A NAME="pgfId=32154"> </A>Fair</P></TD><TD ROWSPAN="1" COLSPAN="1"><P CLASS="TbT.TblText"><A NAME="pgfId=32156"> </A>Fair</P></TD><TD ROWSPAN="1" COLSPAN="1"><P CLASS="TbT.TblText"><A NAME="pgfId=32158"> </A>Impossible (no data structure)</P></TD><TD ROWSPAN="1" COLSPAN="1"><P CLASS="TbT.TblText"><A NAME="pgfId=32160"> </A>Impossible (fixed topology)</P></TD></TR><TR><TD ROWSPAN="1" COLSPAN="1"><P CLASS="TbT.TblText"><A NAME="pgfId=32251"> </A>I/O speed</P></TD><TD ROWSPAN="1" COLSPAN="1"><P CLASS="TbT.TblText"><A NAME="pgfId=32253"> </A>Good to very good</P></TD><TD ROWSPAN="1" COLSPAN="1"><P CLASS="TbT.TblText"><A NAME="pgfId=32255"> </A>Fair to very good</P></TD><TD ROWSPAN="1" COLSPAN="1"><P CLASS="TbT.TblText"><A NAME="pgfId=32257"> </A>Fair</P></TD><TD ROWSPAN="1" COLSPAN="1"><P CLASS="TbT.TblText"><A NAME="pgfId=32259"> </A>Good to very good</P></TD></TR><TR><TD ROWSPAN="1" COLSPAN="1"><P CLASS="TbT.TblText"><A NAME="pgfId=32261"> </A>Flexibility and generality</P></TD><TD ROWSPAN="1" COLSPAN="1"><P CLASS="TbT.TblText"><A NAME="pgfId=32263"> </A>Good</P></TD><TD ROWSPAN="1" COLSPAN="1"><P CLASS="TbT.TblText"><A NAME="pgfId=32265"> </A>Poor</P></TD><TD ROWSPAN="1" COLSPAN="1"><P CLASS="TbT.TblText"><A NAME="pgfId=32267"> </A>Very good</P></TD><TD ROWSPAN="1" COLSPAN="1"><P CLASS="TbT.TblText"><A NAME="pgfId=32269"> </A>Poor (fixed topology)</P></TD></TR><TR><TD ROWSPAN="1" COLSPAN="1"><P CLASS="TbT.TblText"><A NAME="pgfId=32271"> </A>Suitability for general model representation and distribution</P></TD><TD ROWSPAN="1" COLSPAN="1"><P CLASS="TbT.TblText"><A NAME="pgfId=32273"> </A>Very good</P></TD><TD ROWSPAN="1" COLSPAN="1"><P CLASS="TbT.TblText"><A NAME="pgfId=32275"> </A>Fair</P></TD><TD ROWSPAN="1" COLSPAN="1"><P CLASS="TbT.TblText"><A NAME="pgfId=32277"> </A>Fair</P></TD><TD ROWSPAN="1" COLSPAN="1"><P CLASS="TbT.TblText"><A NAME="pgfId=32279"> </A>Poor</P></TD></TR></TABLE></DIV><hr>&#169; 1997 Apple Computer, Inc.</DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV><!-- start of footer --><!--#include virtual="/includes/framesetfooter" --><!-- end of footer --></BODY></HTML>