/* © 1989 Apple Computer, by Ricardo Batista */#include "ez_ADSP.h"#define		open				0#define		prime				1#define		control				2#define		status				3#define		close				4#define		GetZoneList		0x8000000#define		GetMyZone		0x7000000#define		okItem				1#define		cancelItem			2#define		_dName				"\p.ez_adsp"#define		busyDlg				0#define		notfoundDlg			1#define		optionsDlg			2#define		listDlg				3#define		notLoadedDlg		4#define		usersDlg			5#define		boldBegin			3#define		boldEnd				4#define		bell				5#define		MaxDataSize			700#define		charW				7#define		charH				10#define 	modal_bit			(1<<7)long signature;int ez;char buffer[600];WindowPtr myWindow;WindowRecord w;Rect bounds;int conectionFlag, oldFlag;DCtlPtr dce;cntrlParam ez_control;ioParam	io;ControlHandle sendB, optionsB, connectB, disconnectB;Rect InBox, OutBox;char InData[MaxDataSize], OutData[MaxDataSize];int InIndex[30], OutIndex[30];int InLines, OutLines;Point whereIn, whereOut;int LineIn, LineOut;int endCharIn, endCharOut;RgnHandle dummyRgn;Boolean boldIn, boldOut;long ticks;Boolean visible;Boolean reentrance;int main(ioParam* param, DCtlPtr d, int call);void MakeWindow(void);int MyRsrcID (int rsrcID);void myClose(void);int DoCommand(int menuItem);void DoEvent(cntrlParam* p);void SendFile(void);void Options(void);void Connect(Boolean skipZone);void Disconnect(void);void DoUpdate(void);void AdjustControls(void);void ChackStatus(void);Boolean GetAZone(EntityName *name);Boolean GetAddress(EntityName *name,AddrBlock *address);void CheckStatus(void);void SendName(void);void ShowErr(int dialog);void DoCursor(Boolean clear);int main(param, d, call)ioParam *param;DCtlPtr d;int call;{	int err = 0;	cntrlParam *p;		if (d->dCtlStorage == 0L) {		if (call == open) {			SysBeep(1);			return(openErr);		}		return(openErr);	}	if ((call != open) && (signature != 'RICK')) {		return(notOpenErr);	}	if (reentrance)		return(noErr);	reentrance = TRUE;	dce = d;	switch (call) {		case open:			d->dCtlFlags |= dNeedLock | dNeedTime | dNeedGoodBye | dCtlEnable;			d->dCtlDelay = 15;			InitCursor();			if (signature != 'RICK') {				signature = 'RICK';				err = OpenDriver("\p.MPP",&ez);				if (!err)					err = OpenDriver(_dName,&ez);				if (err) {					ShowErr(notLoadedDlg);					return(err);				}				boldIn = boldOut = FALSE;				conectionFlag = 0;				oldFlag = -1;				visible = FALSE;				ticks = TickCount() + 30L;				ez_control.ioRefNum = ez;				ez_control.ioCompletion = 0L;				ez_control.ioNamePtr = 0L;				ez_control.ioVRefNum = 0;				io.ioRefNum = ez;				io.ioCompletion = 0L;				io.ioNamePtr = 0L;				io.ioVRefNum = 0;				ez_control.csCode = autoFile;				ez_control.csParam[0] = TRUE;				err = PBControl(&ez_control,FALSE);				ez_control.csCode = deskFlag;				ez_control.csParam[0] = FALSE;				err = PBControl(&ez_control,FALSE);				ez_control.csCode = getBuf;				err = PBStatus(&ez_control,FALSE);				conectionFlag = ez_control.csParam[2];				if (conectionFlag == 4)					SysBeep(1);				MakeWindow();			}			else				SelectWindow(myWindow);			break;		case prime:			break;		case control:			p = (cntrlParam*) param;			switch (p->csCode) {				case accRun:					CheckStatus();					DoCursor(FALSE);					break;				case accEvent:					CheckStatus();					DoEvent(p);					break;				case accMenu:					DoCommand(p->csParam[1]);					break;				case goodBye:					myClose();					break;				default:					break;			}			break;		case close:			myClose();			break;		default:			break;	}	reentrance = FALSE;	return(err);	asm {		dc.l '© 19'		dc.l '89 A'		dc.l 'pple'		dc.l ' Com'		dc.l 'pute'		dc.l 'r, I'		dc.l 'nc. '		dc.l 'Rica'		dc.l 'rdo '		dc.l 'Bati'		dc.l 'sta.'	}}int DoCommand (menuItem)int menuItem;{	switch (menuItem)	{		case 1:			break;		default:			break;	}}void MakeWindow(){	Rect box;	register int c, middle;	GrafPtr savePort;	WindowPeek fw;		InitCursor();	bounds.top = 40;	bounds.left = 20;	bounds.right = 350;	bounds.bottom = 310;	GetPort(&savePort);	fw = (WindowPeek) FrontWindow();	if (fw) {		if ((fw->windowKind == dialogKind) && (fw->spareFlag & modal_bit))			fw = 0L;		else			fw = (WindowPeek) -1L;	}	else		fw = (WindowPeek) -1L;	myWindow = NewWindow(&w,&bounds,"\pTalking Head...",1,noGrowDocProc,fw,1,0L);	SetPort(myWindow);	bounds.bottom -= bounds.top;	bounds.right -= bounds.left;	box = bounds;	box.bottom -= 6;	box.top = box.bottom - 20;	box.left = 6;	c = bounds.right / 4;	box.right = c;	sendB = NewControl(myWindow,&box,"\pSend File",1,0,0,1,0,0L);	box.left = box.right + 10;	box.right = c * 2;	optionsB = NewControl(myWindow,&box,"\pOptions",1,0,0,1,0,0L);	box.left = box.right + 10;	box.right = c * 3;	connectB = NewControl(myWindow,&box,"\pConnect",1,0,0,1,0,0L);	box.left = box.right + 11;	box.right = c * 4 - 1;	disconnectB = NewControl(myWindow,&box,"\pDisconnect",1,0,0,1,0,0L);	DrawControls(myWindow);	PenSize(1,1);	TextSize(9);	TextFont(1);	middle = bounds.bottom - 40;	MoveTo(0,middle + 6);	LineTo(bounds.right,middle + 6);	middle /= 2;	InBox.top = 10;	InBox.left = OutBox.left = 3;	InBox.right = OutBox.right = bounds.right - 3;	InBox.bottom = middle - 10;	MoveTo(0,middle);	LineTo(bounds.right,middle);	middle += 2;	OutBox.top = middle + 10;	OutBox.bottom = bounds.bottom - 30;	MoveTo(0,middle);	LineTo(bounds.right,middle);	dce->dCtlWindow = myWindow;	w.windowKind = dce->dCtlRefNum;	InIndex[0] = OutIndex[0] = 0;	InIndex[1] = OutIndex[1] = -1;	InData[0] = OutData[0] = 0;	OutLines = OutBox.bottom - OutBox.top;	OutLines /= charH;	InLines = InBox.bottom - InBox.top;	InLines /= charH;	OutLines--;	whereIn.h = whereOut.h = 3;	whereIn.v = InBox.top;	whereOut.v = OutBox.top;	LineIn = LineOut = 0;	endCharIn = endCharOut = 0;	dummyRgn = NewRgn();	SetPort(savePort);}void DoEvent (p)cntrlParam *p;{	char theChar;	long len;	ControlHandle theControl;	int part;	WindowPtr window;	Rect box;	EventRecord *myEvent, evt;	register int c;	int err;	Rect square;	Boolean commandKey;	GrafPtr savePort;		BlockMove(&(p->csParam[0]),&myEvent,4L);	BlockMove(myEvent,&evt,(long) sizeof(EventRecord));	switch (evt.what)	{		case mouseDown:			GetPort(&savePort);			SetPort(myWindow);			GlobalToLocal(&evt.where);			if (FindControl(evt.where,myWindow,&theControl)) {				if (TrackControl(theControl,evt.where,0L)) {					if (theControl == sendB)						SendFile();					if (theControl == optionsB)						Options();					if (theControl == connectB) {						if (evt.modifiers & cmdKey)							Connect(TRUE);						else							Connect(FALSE);					}					if (theControl == disconnectB)						Disconnect();				}			}			SetPort(savePort);			break;		case keyDown: 		case autoKey:			GetPort(&savePort);			SetPort(myWindow);			theChar = evt.message & charCodeMask;			if (evt.modifiers & cmdKey)				commandKey = TRUE;			else				commandKey = FALSE;			io.ioReqCount = 1L;			io.ioBuffer = &theChar;			io.ioPosMode = 0;			io.ioPosOffset = 0;			if ((theChar > 14) && !commandKey) {				if (visible)					DoCursor(TRUE);				if (boldOut)					TextFace(bold);				else					TextFace(0);				MoveTo(whereOut.h,whereOut.v);				DrawChar(theChar);				whereOut.h += charW;			}			if (theChar == '\b') {				if (whereOut.h > 3) {					if (visible)						DoCursor(TRUE);					whereOut.h -= charW;					square.top = whereOut.v - charH + 1;					square.bottom = whereOut.v + 3;					square.left = whereOut.h;					square.right = whereOut.h + charW;					EraseRect(&square);				}			}			if (theChar == '\r') {				if (visible)					DoCursor(TRUE);				whereOut.h += charW;			}			if (commandKey) {				if ((theChar == 'B') || (theChar == 'b')) {					if (boldOut) {						boldOut = FALSE;						theChar = boldEnd;					}					else {						boldOut = TRUE;						theChar = boldBegin;					}				}				if ((theChar == 'G') || (theChar == 'g'))					theChar = bell;			}			err = PBWrite(&io,FALSE);			OutData[endCharOut] = theChar;			endCharOut++;			if (endCharOut == MaxDataSize)				endCharOut = 0;			if (((whereOut.h + charW) > OutBox.right) || (theChar == 13)) {				whereOut.v += charH;				whereOut.h = 3;				LineOut++;				if (LineOut > OutLines) {					LineOut = OutLines;					OutBox.top -= charH - 2;					OutBox.bottom -= 4;					ScrollRect(&OutBox,0,-charH,dummyRgn);					OutBox.top += charH - 2;					whereOut.v -= charH;					OutBox.bottom += 4;					for (c = 0; c < OutLines; c++)						OutIndex[c] = OutIndex[c + 1];				}				OutIndex[LineOut + 1] = -1;				OutIndex[LineOut] = endCharOut;			}			SetPort(savePort);			break;		case updateEvt:			DoUpdate();			break;		case activateEvt:			ez_control.csCode = deskFlag;			ez_control.csParam[0] = FALSE;			err = PBControl(&ez_control,FALSE);			break;		default:			break;	}}void myClose(){	int err;		CloseWindow(myWindow);	ez_control.csCode = deskFlag;	ez_control.csParam[0] = FALSE;	err = PBControl(&ez_control,FALSE);	ez_control.csCode = autoFile;	err = PBControl(&ez_control,FALSE);	if (conectionFlag == 4) {		ez_control.csCode = closeConn;		err = PBControl(&ez_control,FALSE);	}	dce->dCtlWindow = 0L;	dce->dCtlMenu = 0L;}void DoUpdate(){	register int middle, counter, index;	Point oldOut, oldIn;	Rect square;	GrafPtr savePort;	Rect cRect;		oldIn = whereIn;	oldOut = whereOut;	GetPort(&savePort);	SetPort(myWindow);	if (visible) {		cRect.bottom = whereOut.v + 1;		cRect.left = whereOut.h;		cRect.top = cRect.bottom - 8;		cRect.right = cRect.left + 2;		InvalRect(&cRect);		visible = FALSE;	}	BeginUpdate(myWindow);	EraseRect(&(w.port.portRect));	DrawControls(myWindow);	PenSize(1,1);	TextSize(9);	TextFont(4);	middle = bounds.bottom - 40;	MoveTo(0,middle + 6);	LineTo(bounds.right,middle + 6);	middle /= 2;	MoveTo(0,middle);	LineTo(bounds.right,middle);	middle += 2;	MoveTo(0,middle);	LineTo(bounds.right,middle);	whereIn.h = whereOut.h = 3;	whereIn.v = InBox.top;	whereOut.v = OutBox.top;	counter = 0;	while (InIndex[counter] != -1) {		whereIn.h = 3;		index = InIndex[counter];		while ((index != endCharIn) && (index != InIndex[counter + 1])) {			if (InData[index] > 14) {				MoveTo(whereIn.h,whereIn.v);				DrawChar(InData[index]);				whereIn.h += charW;			}			if (InData[index] == '\b') {				if (whereIn.h > 3) {					whereIn.h -= charW;					square.top = whereIn.v - charH + 1;					square.bottom = whereIn.v + 3;					square.left = whereIn.h;					square.right = whereIn.h + charW;					EraseRect(&square);				}			}			if (InData[index] == boldBegin)				TextFace(bold);			if (InData[index] == boldEnd);				TextFace(0);			if (InData[index] == '\r')				whereIn.h += charW;				index++;			if (index == MaxDataSize)				index = 0;		}		whereIn.v += charH;		counter++;	}	counter = 0;	while (OutIndex[counter] != -1) {		whereOut.h = 3;		index = OutIndex[counter];		while ((index != endCharOut) && (index != OutIndex[counter + 1])) {			if (OutData[index] > 14) {				MoveTo(whereOut.h,whereOut.v);				DrawChar(OutData[index]);				whereOut.h += charW;			}			if (OutData[index] == '\b') {				if (whereOut.h > 3) {					whereOut.h -= charW;					square.top = whereOut.v - charH + 1;					square.bottom = whereOut.v + 3;					square.left = whereOut.h;					square.right = whereOut.h + charW;					EraseRect(&square);				}			}			if (OutData[index] == '\r')				whereOut.h += charW;				if (OutData[index] == boldBegin)				TextFace(bold);			if (OutData[index] == boldEnd)				TextFace(0);			index++;			if (index == MaxDataSize)				index = 0;		}		whereOut.v += charH;		counter++;	}	EndUpdate(myWindow);	SetPort(savePort);	whereOut = oldOut;	whereIn = oldIn;}int MyRsrcID (rsrcID)int     rsrcID;{	return (0xC000 | ~(dce->dCtlRefNum) << 5 | rsrcID);}void SendFile(){	SFReply reply;	Point where;	Ptr p;	int err;		where.h = where.v = 100;	SFGetFile(where,"\pSelect a file:",0L,-1,0L,0L,&reply);	if (reply.good) {		dce->dCtlFlags -= dNeedTime;		SetCursor(*GetCursor(watchCursor));		DoUpdate();		ez_control.csCode = sendFile;		p = (Ptr) &reply.fName[0];		BlockMove(&p,&(ez_control.csParam[0]),4L);		ez_control.csParam[2] = reply.vRefNum;		err = PBControl(&ez_control,FALSE);		InitCursor();		dce->dCtlFlags |= dNeedLock | dNeedTime | dNeedGoodBye | dCtlEnable;	}}void Options(){	GrafPtr savePort;	int id, item;	DialogPtr aDialog;	DialogRecord d;	ControlHandle H, answerControl;	Rect box;	int err;		GetPort(&savePort);	id = MyRsrcID(optionsDlg);	aDialog = GetNewDialog(id,&d,-1L);	SetPort(aDialog);	GetDItem(aDialog,1,&item,&H,&box);	DrawDialog(aDialog);	PenSize(3,3);	InsetRect(&box,-4,-4);	FrameRoundRect(&box,16,16);	PenNormal();	GetDItem(aDialog,2,&item,&answerControl,&box);	item = 0;	while (item != 1) {		ModalDialog(0L,&item);		if (item == 2) {			if (GetCtlValue(answerControl))				SetCtlValue(answerControl,0);			else				SetCtlValue(answerControl,1);		}	}	if (GetCtlValue(answerControl))		ez_control.csCode = disable;	else		ez_control.csCode = enable;	err = PBControl(&ez_control,FALSE);	CloseDialog(aDialog);	SetPort(savePort);}void Connect(skipZone)Boolean skipZone;{	AddrBlock address;	EntityName name;	int err;		name.objStr[0] = 1;	name.objStr[1] = '=';	name.zoneStr[0] = 1;	name.zoneStr[1] = '*';	BlockMove("\pTalking Head",&(name.typeStr[0]),14L);	if (skipZone || GetAZone(&name)) {		if (GetAddress(&name,&address)) {			ez_control.csCode = openConn;			BlockMove(&address,&(ez_control.csParam[0]),(long) sizeof(AddrBlock));			err = PBControl(&ez_control,FALSE);			if (err)				ShowErr(busyDlg);			else {				SendName();				SetWTitle(myWindow,name.objStr);			}		}	}}void SendName(){	StringHandle str;	int temp;	int err;		str = (StringHandle) GetString(-16096);	if (str) {		HLock(str);		BlockMove(*str,&buffer[0],34L);		HUnlock(str);		ReleaseResource(str);	}	else		BlockMove("\pUnidentified",&buffer[0],20L);	io.ioReqCount = 1L;	io.ioBuffer = (Ptr) &"\001      ";	io.ioPosMode = 0;	io.ioPosOffset = 0;	err = PBWrite(&io,FALSE);	temp = buffer[0];	io.ioReqCount = temp + 1;	io.ioBuffer = &buffer[0];	err = PBWrite(&io,FALSE);}void Disconnect(){	int err;		ez_control.csCode = closeConn;	err = PBControl(&ez_control,FALSE);}void AdjustControls(){	GrafPtr savePort;		GetPort(&savePort);	SetPort(myWindow);	if ((conectionFlag == 2) || (conectionFlag == 6)) {		HiliteControl(connectB,0);		HiliteControl(disconnectB,255);		HiliteControl(optionsB,0);		HiliteControl(sendB,255);		SetWTitle(myWindow,"\pTalking Head...");	}	if (conectionFlag == 4) {		HiliteControl(connectB,255);		HiliteControl(disconnectB,0);		HiliteControl(optionsB,0);		HiliteControl(sendB,0);	}	SetPort(savePort);	oldFlag = conectionFlag;}void CheckStatus(){	long len = 0L;	register int c, c2;	char name[40];	int limit;	int err;	Rect square;	GrafPtr savePort;		ez_control.csCode = getBuf;	err = PBStatus(&ez_control,FALSE);	BlockMove(&(ez_control.csParam[0]),&len,4L);	conectionFlag = ez_control.csParam[2];	GetPort(&savePort);	SetPort(myWindow);	if (conectionFlag != oldFlag)		AdjustControls();	if (len) {		if (len > 512)			len = 512;		io.ioActCount = 0L;		io.ioReqCount = len;		io.ioBuffer = &buffer[0];		io.ioPosMode = 0;		io.ioPosOffset = 0;		err = PBRead(&io,FALSE);		len = io.ioActCount;		for (c = 0; c < len; c++) {			if (buffer[c] == 1) {				c++;				limit = buffer[c] + 1;				for (c2 = 0; c2 < limit; c2++, c++)					name[c2] = buffer[c];				SetWTitle(myWindow,name);				if (c == len)					return;			}			if ((buffer[c] != 13) && (buffer[c] != '\b')) {				if (boldIn)					TextFace(bold);				else					TextFace(0);				MoveTo(whereIn.h,whereIn.v);				DrawChar(buffer[c]);				whereIn.h += charW;			}			if (buffer[c] == '\b') {				if (whereIn.h > 3) {					whereIn.h -= charW;					square.top = whereIn.v - charH + 1;					square.bottom = whereIn.v + 3;					square.left = whereIn.h;					square.right = whereIn.h + charW;					EraseRect(&square);				}			}			if (buffer[c] == boldBegin)				boldIn = TRUE;			if (buffer[c] == boldEnd)				boldIn = FALSE;			if (buffer[c] == bell)				SysBeep(1);			if (buffer[c] == '\r')				whereIn.h += charW;			InData[endCharIn] = buffer[c];			endCharIn++;			if (endCharIn == MaxDataSize)				endCharIn = 0;			if (((whereIn.h + charW) > InBox.right) || (buffer[c] == 13)) {				whereIn.v += charH;				whereIn.h = 3;				LineIn++;				if (LineIn > InLines) {					LineIn = InLines;					whereIn.v -= charH;					InBox.top -= charH - 2;					ScrollRect(&InBox,0,-charH,dummyRgn);					InBox.top += charH - 2;					for (c2 = 0; c2 < InLines; c2++)						InIndex[c2] = InIndex[c2 + 1];				}				InIndex[LineIn + 1] = -1;				InIndex[LineIn] = endCharIn;			}		}	}	SetPort(savePort);}Boolean GetAZone(name)EntityName *name;{	int abridge;	DialogPtr aDialog;	Point where;	ListHandle z;	int item,node,net,howMany,zones,err;	Rect zBox,bounds;	long ourData;	Point cell;	Handle H;	Boolean done = FALSE;	unsigned char dummy[4];	register int counter,index;	char aBuf[600];	int id, datalen;	Boolean doubleClick;	DialogRecord d;	Rect box;	GrafPtr savePort;	ATPParamBlock a;	BDSElement bds;		SetCursor(*GetCursor(watchCursor));	asm {		move.l 0x2D8,a0		clr.w abridge		move.b 0x19(a0),abridge+1		move.w 0x1A(a0),net		clr.w node		move.b (a0),node+1	}	if (abridge == 0)		return(TRUE);	GetPort(&savePort);	id = MyRsrcID(listDlg);	aDialog = GetNewDialog(id,&d,-1L);	SetPort(aDialog);	GetDItem(aDialog,4,&item,&H,&zBox);	DrawDialog(aDialog);	SetRect(&bounds,0,0,0,0);	zBox.right -= 15;	cell.h = cell.v = 0;	z = LNew(&zBox,&bounds,cell,0,aDialog,TRUE,FALSE,FALSE,TRUE);	(*z)->selFlags |= lNoNilHilite + lNoRect + lNoExtend + lNoDisjoint + lOnlyOne;	zBox.top--;	zBox.left--;	zBox.right++;	zBox.bottom++;	LActivate(TRUE,z);	LAutoScroll(z);	LAddColumn(1,0,z);	FrameRect(&zBox);	howMany = zones = 0;	cell.v = cell.h = 0;	ourData = 0;	a.userData = GetZoneList;	a.atpFlags = 0;	a.addrBlock.aNode = abridge;	a.addrBlock.aNet = net;	a.addrBlock.aSocket = 6;	a.reqLength = 0;	a.reqPointer = 0L;	a.ATPnumOfBuffs = 1;	a.ATPtimeOutVal = 4;	a.ATPretryCount = 3;	a.bdsPointer = (Ptr) &bds;	bds.buffSize = 600;	bds.dataSize = 0;	bds.userBytes = 0L;	bds.buffPtr = (Ptr) aBuf;	aBuf[0] = 0;	ourData = 1;	FrameRect(&zBox);	zones = 0;	while (!done) {		ourData |= GetZoneList;		a.userData = ourData;		err = PSendRequest(&a,FALSE);		if (err) {			done = TRUE;			zones = 0;		}		BlockMove(&bds.userBytes,&dummy[0],4L);		BlockMove(&dummy[2],&howMany,2L);		zones += howMany;		ourData = zones;		if (!done) {			if (howMany)				LAddRow(howMany,zones,z);			for (counter = 0, index = 0; counter < howMany; counter++) {				LSetCell(&aBuf[index + 1],(int) aBuf[index],cell,z);				cell.v++;				index += aBuf[index] + 1;			}			FrameRect(&zBox);		}		if (!done)			done = dummy[0];	}	if (zones) {		a.userData = GetMyZone;		err = PSendRequest(&a,FALSE);		cell.v = cell.h = 0;		datalen = aBuf[0];		LSearch(&aBuf[1],datalen,0L,&cell,z);		LSetSelect(TRUE,cell,z);		LAutoScroll(z);	}	GetDItem(aDialog,1,&item,&H,&box);	if (zones) {		PenSize(3,3);		InsetRect(&box,-4,-4);		FrameRoundRect(&box,16,16);		PenNormal();	}	else		HiliteControl(H,255);	InitCursor();	item = cell.v = 0;	while ((item != okItem) && (item != cancelItem)) {		ModalDialog(0L,&item);		if (item == 4) {			cell.v = 0;			GetMouse(&where);			doubleClick = LClick(where,0,z);			asm {				clr.l -(sp)				; space for cell result				move.l z,-(sp)			; push the list handle				move.w #64,-(sp)		; push LLastClick selector				_Pack0					; do it				move.l (sp)+,cell		; put in cell			}			if (doubleClick && (cell.v != -1))				item = 1;		}		if ((item == 1) && zones) {			cell.v = cell.h = 0;			if (!LGetSelect(TRUE,&cell,z)) {				name->zoneStr[0] = 1;				name->zoneStr[1] = '*';			}			else {				datalen = 33;				LGetCell(&(name->zoneStr[1]),&datalen,cell,z);				name->zoneStr[0] = datalen;			}		}		else {			if (item == 1)				item = 2;		}	}	LDispose(z);	CloseDialog(aDialog);	SetPort(savePort);	if (item == 2)		return(FALSE);	return(TRUE);}Boolean GetAddress(name,address)EntityName *name;AddrBlock *address;{	MPPParamBlock p;	int id, datalen;	Rect box;	char buffer[5000];	EntityName newName;	AddrBlock newAddress;	DialogPtr aDialog;	Point where;	ListHandle z;	int item,node,net,howMany,zones,err;	Rect zBox,bounds;	Point cell;	Handle H;	register int counter,index;	Boolean doubleClick;	DialogRecord d;	GrafPtr savePort;		SetCursor(*GetCursor(watchCursor));	GetPort(&savePort);	id = MyRsrcID(listDlg);	aDialog = GetNewDialog(id,&d,-1L);	SetPort(aDialog);	GetDItem(aDialog,4,&item,&H,&zBox);	GetDItem(aDialog,3,&item,&H,&box);	SetIText(H,"\pPlease select a Talking Head :");	DrawDialog(aDialog);	SetRect(&bounds,0,0,0,0);	zBox.right -= 15;	cell.h = cell.v = 0;	z = LNew(&zBox,&bounds,cell,0,aDialog,TRUE,FALSE,FALSE,TRUE);	(*z)->selFlags = lNoNilHilite + lNoRect + lNoExtend + lNoDisjoint + lOnlyOne;	zBox.top--;	zBox.left--;	zBox.right++;	zBox.bottom++;	LActivate(TRUE,z);	LAutoScroll(z);	LAddColumn(1,0,z);	FrameRect(&zBox);	index = name->objStr[0] + 1;	BlockMove(&(name->typeStr[0]),&(name->objStr[index]),33L);	index += name->objStr[index] + 1;	BlockMove(&(name->zoneStr[0]),&(name->objStr[index]),33L);	p.NBPinterval = 5;	p.NBPcount = 5;	p.NBPentityPtr = (Ptr) name;	p.NBPretBuffPtr = buffer;	p.NBPretBuffSize = 5000;	p.NBPmaxToGet = 45;	err = PLookupName(&p,FALSE);	howMany = p.NBPnumGotten;	cell.v = cell.h = 0;	LAddRow(howMany,0,z);	LAddColumn(1,0,z);	for (counter = 0; counter < howMany; counter++) {		myNBPExtract(&buffer[0],howMany,counter + 1,&newName,&newAddress);		datalen = newName.objStr[0];		cell.h = 0;		LSetCell(&(newName.objStr[1]),datalen,cell,z);		datalen = 4;		cell.h = 1;		LSetCell(&newAddress,datalen,cell,z);		cell.v++;	}	FrameRect(&zBox);	GetDItem(aDialog,1,&item,&H,&box);	if (howMany) {		cell.v = cell.h = 0;		LSetSelect(TRUE,cell,z);		PenSize(3,3);		InsetRect(&box,-4,-4);		FrameRoundRect(&box,16,16);		PenNormal();	}	else {		HiliteControl(H,255);	}	InitCursor();	item = cell.v = cell.h = 0;	while ((item != 1) && (item != 2)) {		ModalDialog(0L,&item);		if ((item == 4) && howMany) {			cell.v = 0;			GetMouse(&where);			doubleClick = LClick(where,0,z);			asm {				clr.l -(sp)				; space for cell result				move.l z,-(sp)			; push the list handle				move.w #64,-(sp)		; push LLastClick selector				_Pack0					; do it				move.l (sp)+,cell		; put in cell			}			if (cell.v < 0)				cell.v = cell.h = 0;			LSetSelect(TRUE,cell,z);			if (doubleClick)				item = 1;		}		if ((item == 1) && howMany) {			cell.v = cell.h = 0;			LGetSelect(TRUE,&cell,z);			datalen = 33;			cell.h = 1;			LGetCell(address,&datalen,cell,z);			datalen = 33;			cell.h = 0;			LGetCell(&(name->objStr[1]),&datalen,cell,z);			name->objStr[0] = datalen;		}		else {			if (item == 1)				item = 2;		}	}	LDispose(z);	CloseDialog(aDialog);	SetPort(savePort);	if (item == 2)		return(FALSE);	return(TRUE);}void ShowErr(dialog)int dialog;{	GrafPtr savePort;	int id, item;	DialogPtr aDialog;	DialogRecord d;	ControlHandle H;	Rect box;		GetPort(&savePort);	if (dialog == notLoadedDlg)		SysBeep(1);	id = MyRsrcID(dialog);	aDialog = GetNewDialog(id,&d,-1L);	SetPort(aDialog);	DrawDialog(aDialog);	GetDItem(aDialog,1,&item,&H,&box);	InsetRect(&box,-4,-4);	PenSize(3,3);	FrameRoundRect(&box,16,16);	PenNormal();	item = 0;	while (item != 1)		ModalDialog(0L,&item);	CloseDialog(aDialog);	SetPort(savePort);}void DoCursor(clear)Boolean clear;{	Rect cRect;	GrafPtr savePort;	Boolean erase = FALSE;		if (clear || (ticks < TickCount()))		ticks = TickCount() + 30L;	else		return;	if (visible)		visible = FALSE;	else		visible = TRUE;	GetPort(&savePort);	SetPort(myWindow);	cRect.bottom = whereOut.v + 1;	cRect.left = whereOut.h;	cRect.top = cRect.bottom - 8;	cRect.right = cRect.left + 2;	InvertRect(&cRect);	SetPort(savePort);}/*	This function extracts names and addresses out of a buffer filled by NBP*/int myNBPExtract(buffer,howMany,which,Name,Addr)char *buffer;int howMany;int which;EntityName *Name;AddrBlock *Addr;{	char *p;	register int index = 1, nameCounter = 0;		p = buffer;	while ((index < which) && (index < howMany)) {		p += 5;	/* skip addr and enumerator */		p += (*p) + 1;	/* skip name */		p += (*p) + 1;	/* skip type */		p += (*p) + 1;	/* skip zone */		index++;	}	BlockMove(p,Addr,4L);	p += 5;	BlockMove(p,Name->objStr,33L);	p += (*p) + 1;	BlockMove(p,Name->typeStr,33L);	p += (*p) + 1;	BlockMove(p,Name->zoneStr,33L);	return(0);}