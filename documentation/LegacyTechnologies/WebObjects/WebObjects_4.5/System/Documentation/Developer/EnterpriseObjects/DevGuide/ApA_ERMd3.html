<html><head><title>Relationships</title></head><body bgcolor="#ffffff"><!--start of banner --><!--#include virtual="/includes/framesetheader" --><!-- end of banner --><!--start of path --><font face="Geneva,Helvetica,Arial" size="1"><b>PATH<spacer type="horizontal" size="5">&nbsp;</b> <a href="../../../../../../index.html" target="_top">Documentation</a> <b>&gt;</b> <a href="../../../../../webobjects.html" target="_top">WebObjects 4.5</a> <b>&gt;</b>EOF Developer's Guide</font><br><br><!--end of path --> <a href="ApA_ERMd.html"><IMG SRC="ArrowUp.gif">Table of Contents</a> <a href="ApA_ERMd2.html"><IMG SRC="ArrowLeft.gif">Previous Section</a><P> <a name="419"><h1> Relationships</h1></a><a name="420">Your employee database might have, in addition to the Employee entity, a JobTitle entity that identifies the various job titles that an employee can have and whether each title represents a salaried or an hourly position. A &#32;<em>relationship</em> between the Employee entity and the JobTitle entity expresses the affinity between employees and titles, and allows you to &#32;access the title information for a given employee. Graphically, a relationship can be shown as a named arrow that points from one entity (the <em>source entity</em>) to another (the <em>destination entity</em>); the Employee-JobTitle relationship (which is named toJobTitle) is depicted in <a href="ApA_ERMd3.html#3173">Figure &#32;57</a>.<p></a><a name="534"><B>Note: </B> To support the toJobTitle relationship, the Employee entity has been altered-the titleID attribute has been added to it. This is explained in the section<a href="ApA_ERMd3.html#426"> "Relationship Keys"</a>.<p></a><a name="405">The table that's represented by the source entity is referred to as the <em>source table</em>; the source table contains <em>source records</em>. Similarly, the table that's represented by the destination entity is referred to as the <em>destination table</em>; it contains <em>destination records</em>.<p></a><a name="3895">Be aware that you can't just randomly create relationships between your entities. Relationships that you add to your entities must reflect real relationships between the tables in the database. For more information, see the section<a href="ApA_ERMd3.html#426"> "Relationship Keys"</a>.<p></a><a name="3902"><p><img src="ApA_ERMd2.gif"><p></a><a name="3173"><p>Figure 57.	  The toJobTitle Relationship<p></a><a name="403"><h2> Relationship Directionality</h2></a><a name="5059">Relationships are <em>unidirectional</em>. In a unidirectional relationship, the path &#32;that leads from the source to the destination can't be traveled in &#32;the &#32;opposite direction-you can't use a relationship to go from the &#32;destination to the source. For example, although you can use the &#32;toJobTitle relationship to find the title for a particular employee, you &#32;can't use it to get a list of the employees that share a particular title.<p></a><a name="422">Unidirectionality is enforced by the way a relationship is resolved. Specifically, the source record is a given. Resolving a relationship means finding the correct destination record (or records) given a specific source record. <p></a><a name="429">Bidirectional relationships-in which you can look up records in either direction-can be created by adding a separate "return-trip" relationship. This is demonstrated in the section<a href="ApA_ERMd3.html#3276"> "Bidirectional Relationships"</a>.<p></a><a name="450"><h2> Naming Relationships</h2></a><a name="459">Most of the relationships described in this manual use a simple naming convention: relationships are named after the destination entity. For example, a Movie entity can have a studio relationship to a Studio entity, and a roles relationship to a MovieRoles entity. Note that singular names are typically used for to-one relationships, and plural names are used for to-many relationships. However, you're not bound by this convention-EOModeler lets you give relationships any names you like.<p></a><a name="598">In the figures throughout this book, the entity that is adjacent to the relationship's label is said to <em>own</em> the relationship. For example, in <a href="ApA_ERMd3.html#3902">Figure &#32;57</a> the Employee entity owns the toJobTitle relationship, as indicated by the proximity of the "toJobTitle" label to the entity.<p></a><a name="423"><h3> Relationships and the Data Dictionary</h3></a><a name="453">Unlike entities and attributes, relationships don't correspond to names in &#32;the server's data dictionary.  In general, most servers don't define structural elements for relationships, so their data dictionaries don't contain names to which E-R relationships can correspond.  But relationships aren't completely disassociated from the data dictionary:  A &#32;relationship's definition, as explained in the next section, depends on the existence of particular entities and attributes (which, as described earlier, must correspond to data dictionary names). <p></a><a name="426"><h2> Relationship Keys</h2></a><a name="424">The construction of a relationship involves more than just two entities. You also have to designate at least one attribute from each entity as a &#32;<em>relationship key</em>. In the toJobTitle relationship, for instance, the Employee.titleID and JobTitle.titleID are so designated; this is indicated in &#32;<a href="ApA_ERMd3.html#3902">Figure &#32;57</a> as the two attributes that lie at either end of the relationship arrow. Just as the tables are called source and destination tables, so are the relationship keys named. In the source entity, the relationship key is called the <em>source key</em>. The destination entity's relationship key is called the &#32;<em>destination key</em>.<p></a><a name="457"><B>Note: </B> As in the case of the toJobTitle relationship, the source and destination keys often have the same name, although this isn't a requirement of model design. <p></a><a name="535">The reason you need to designate relationship keys is so the relationship can be used to create cross-references between specific instances of the related entities (this is called "resolving" the relationship). For example, let's say you fetch an employee object. The Enterprise Objects Framework takes the value for the employee's titleID attribute and compares it to the value for titleID in each JobTitle instance. A match locates the desired job title record. <p></a><a name="385">For this cross-referencing scheme to work, the source and destination keys must characterize the same data-you couldn't find an employee's job title by comparing, for example, Employee.empID to JobTitle.titleID. This is why the titleID attribute was added to the Employee entity.<p></a><a name="390"><h3> An Example with Data</h3></a><a name="468">To further illustrate how a relationship is resolved, consider the "EMPLOYEE" and "JOB_TITLE" tables presented in <a href="ApA_ERMd3.html#404">Figure &#32;58</a> (for the purpose of this example, only the essential columns are shown).<p></a><a name="441">Here we see that the value for the titleID attribute for James Winton is 1. Looking in the "JOB_TITLE" table, we see that 1 is the ID of the President. Thus, James Winton is the company president. Similarly, we can determine that Kai Veasey is a manager.<p></a><a name="404"><p><img src="ApA_ERMd9.gif"><p></a><a name="675"><p>Figure 58.	  The "EMPLOYEE" and "JOB_TITLE" Tables<p></a><a name="434"><h3> Choosing Relationship Keys</h3></a><a name="481">Any attribute can be used as a relationship key, but some are better suited than others. In general, of the two relationship keys for a particular relationship, the destination key will be a primary key for its entity (or, otherwise, an attribute that characterizes unique data) and the source key is manufactured to emulate the destination key. In traditional E-R modeling, the emulating attribute is called a <em>foreign key</em>. The toJobTitle relationship demonstrates this: The destination key in the JobTitle entity is titleID, the primary key for that entity. The titleID attribute is added to Employee as foreign key. <p></a><a name="536">Note that if empID had been used as the relationship key for the toJobTitle relationship, a given title could only be assigned to a single employee. <p></a><a name="538"><h3> Compound Relationship Keys</h3></a><a name="406">A relationship's keys needn't be single attributes from the related entities; any number of attributes can be paired as relationship keys within the same relationship to form a <em>compound relationship key</em>. A &#32;relationship that designates more than one pair of keys is called a &#32;<em>compound relationship</em>.<p></a><a name="398">For example, consider an entity (empPhoto) containing the employee's picture that uses the attributes firstName and lastName as a compound relationship key. (Using people's names for unique identification is generally a bad idea, but it serves the purpose for illustration. In actual practice, this relationship would likely use empID as its relationship key.) This relationship is depicted in <a href="ApA_ERMd3.html#476">Figure &#32;59</a>.<p></a><a name="476"><p><img src="ApA_ERMd6.gif"><p></a><a name="474"><p>Figure 59.	  A Compound Relationship<p></a><a name="537">The algorithm used to resolve a compound relationship is similar to that for a simple relationship. The only difference is the number of pairs of relationship key values that are compared. For two records to correspond, all of the comparisons must be successful.<p></a><a name="596"><B>Note: </B> The keys in a compound relationship can be a combination of <em>any</em> &#32;attributes-not just a compound primary key (or foreign keys to a &#32;compound primary key). Conversely, you can use a single attribute from a compound primary key as a relationship key in a simple <br>(non-compound) relationship. <p></a><a name="371"><h3> Joins</h3></a><a name="478">Relationships are made up of source-destination key pairs. A <em>join</em> is the pairing of one source attribute and one destination attribute for purposes of establishing a relationship. Thus, simple relationships consist of one join. Compound relationships are composed of two or more joins. In <a href="ApA_ERMd3.html#474">Figure &#32;59</a>, for example, the toEmpPhoto relationship is composed of two joins: one linking Employee.lastName to EmpPhoto.lastName, and one linking Employee.firstName to EmpPhoto.firstName. <p></a><a name="513">The Enterprise Objects Framework requires you to declare the join in a relationship as either an <em>inner join</em>, a <em>right outer join</em>, a <em>left outer join</em>, or a <em>full outer join</em>. These four <em>join semantics</em> are defined as follows:<p></a><ul><a name="467"><p><li>In an inner join, if a destination record can't be found for a given source record, that source record isn't included in the result of the join. Destination records that don't match up to any records in the source table are not included in the result of an inner join, either.</a><a name="479"><p><li>In a right outer join, destination records for which no source record can be found are included, but not the reverse. </a><a name="482"><p><li>In a left outer join, source records for which no destination record can be found are included, but not the reverse. </a><a name="485"><p><li>In a full outer join, <em>all</em> source records from both tables are included in the result of the join.</a></ul><a name="514"><h2> Relationship Cardinality</h2></a><a name="408">Every relationship has a <em>cardinality</em>; the cardinality tells you how many destination records can (potentially) resolve the relationship. The Enterprise Objects Framework defines two cardinalities, <em>to-one</em> and <br><em>to-many</em>:<p></a><ul><a name="454"><p><li>In a to-one relationship, for each source record there's <em>exactly one</em> corresponding destination record. </a><a name="428"><p><li>In a to-many relationship, for each source record there may be zero, one, or more corresponding destination records.   </a></ul><a name="456">The toJobTitle relationship is an example of a to-one relationship: An &#32;employee can only have one title. The converse relationship, from JobTitle to Employee, would be to-many: a single title can be shared by more than one employee, or there may be no employees with a given title. This relationship, which is owned by JobTitle and called toEmployee, is shown in <a href="ApA_ERMd3.html#447">Figure &#32;60</a> (for clarity, the source and destination components are pointed out). That the relationship is to-many is indicated by the double arrowhead.<p></a><a name="552">Notice that the relationship keys for the toEmployee relationship are the &#32;same as for toJobTitle. However, the source and destination key assignments are reversed. In other words, whereas Employee.titleID is the &#32;source key for the toJobTitle relationship, it's the destination key for toEmployee; similarly, JobTitle.titleID changes destination and source key roles between the two relationships.<p></a><a name="577">This switch does more than demonstrate that the same attributes can &#32;be &#32;used as relationship keys in more than one relationship; it also exemplifies the typical orientation of the primary key with regard to the &#32;relationship keys in to-one and to-many relationships:<p></a><ul><a name="553"><p><li>In a to-one relationship, the destination key is always the primary key for its entity.</a><a name="554"><p><li>In a to-many relationship, the source key is usually a primary key.</a><a name="447"><p><img src="ApA_ERMd3.gif"><p></a><a name="539"><p>Figure 60.	  A To-Many Relationship<p></a></ul><a name="3276"><h2> Bidirectional Relationships</h2></a><a name="492">Since relationships, as defined by the Enterprise Objects Framework, are &#32;unidirectional, it's natural to assume that to simulate a bidirectional relationship-in other words, to express the natural relationship between two entities without regard for direction-all you need is two relationships: One that leads from entity A to entity B, and one that leads &#32;from entity B to entity A. Unfortunately, it isn't always that easy.<p></a><a name="493">Consider, for example, the actual relationship between employees and projects. A project can involve many employees, and a single employee can contribute to more than one project.<p></a><a name="435"><p><img src="ApA_ERMd13.gif"><p></a><a name="449"><p>Figure 61.	  The Project Entity<p></a><a name="443">Forming a to-many relationship between Employee and Project (toProject) and a to-many relationship between Project and Employee (toEmployee) doesn't work, because it's impossible to assign relationship keys that would support this set-up. For example, in the toProject relationship you can't use the empID attribute as a source key because the &#32;destination key, Project.empID (added as a foreign key), wouldn't be &#32;atomic (since a project may consist of more than one employee). Importing projectID as a foreign key into Employee has the same problem: The attribute wouldn't be atomic (since an employee may be involved with more than one project).<p></a><a name="495">The most common way to establish this "many-to-many" relationship (as &#32;it's called in traditional E-R modeling) is to insert an auxiliary entity between Employee and Project, and form a network of relationships to and from it. This is depicted in <a href="ApA_ERMd3.html#444">Figure &#32;62</a>.<p></a><a name="444"><p><img src="ApA_ERMd12.gif"><p></a><a name="599"><p>Figure 62.	  A Many-to-Many Relationship<p></a><a name="2525">The compound primary key used in EmpProject indicates that the entity characterizes unique combinations of employees and projects. The table that the entity represents would hold a different record for each employee of every project. For example, if three employees were involved with a single project, there would be three EmpProject instances with the same value for the projectID attribute, but each record would have a different value for its empID attribute.<p></a><a name="2514"><h3> The Tables Behind the Many-to-Many Model</h3></a><a name="586">To better understand how the many-to-many model works, it helps to see an example of the tables that store the data. Sample "EMPLOYEE" and "PROJECT" tables that are filled with this information are shown in <a href="ApA_ERMd3.html#430">Figure &#32;63</a> (for clarity, only relevant attributes are shown).<p></a><a name="430"><p><img src="ApA_ERMd14.gif"><p></a><a name="591"><p>Figure 63.	  "EMPLOYEE" and "PROJECT" Tables<p></a><a name="592">The "EMP_PROJECT" table is shown in <a href="ApA_ERMd3.html#594">Figure &#32;64</a> (for clarity, the last names and project names are shown in the margins).<p></a><a name="438"><p><img src="ApA_ERMd10.gif"><p></a><a name="594"><p>Figure 64.	  The "EMP_PROJECT" Table<p></a><a name="401">As expected, some values appear more than once for the empID attribute; similarly, some values for projectID are repeated. But since empID and projectID form a compound primary key for the EmpProject entity, no two records may possess the same combination of values for these two attributes. This fact-that no two records can have the same empID and the same ProjectID-signifies that a given employee cannot be assigned to a single project more than once.<p></a><a name="395"><h2> Reflexive Relationships</h2></a><a name="427">The source and destination entities in a relationship needn't be different. Where the entities in a relationship are the same, a <em>reflexive relationship</em> is created. Reflexive relationships are important in characterizing a system in which an instance of an entity points to another instance of the same entity.<p></a><a name="460">For example, to show who a given employee reports to, you could create a separate Manager entity. It would be easier, however, to just create a reflexive relationship, as shown in <a href="ApA_ERMd3.html#469">Figure &#32;65</a>.<p></a><a name="469"><p><img src="ApA_ERMd4.gif"><p></a><a name="475"><p>Figure 65.	  A Reflexive Relationship<p></a><a name="477"><B>Note: </B> The name of the relationship, managerOf, doesn't follow the relationship naming convention suggested earlier in this chapter. However, it follows from the meaning of the relationship, and meaning takes precedence over form.<p></a><a name="511">The managerID attribute acts as the relationship's source key; empID is the destination key. Where an employee's managerID matches another employee's empID, the first employee reports to the second. If an employee doesn't have a manager, the value for the managerID attribute is NULL in that employee's record.<p></a><a name="512">Reflexive relationships can represent arbitrarily deep recursions. Thus, from the model above, an employee can report to another employee who reports to yet another employee, and so on. This could go on until an employee who's managerID is NULL is reached, denoting an employee who reports to no one (probably the company president!). <p></a><a name="517"><h2> Flattened Attributes</h2></a><a name="433">At the beginning of this chapter, it was stated that an entity maps to a &#32;table in the database. This is not strictly true, however, because the Enterprise Objects Framework allows you to add <em>flattened attributes</em> (and &#32;<em>flattened relationships</em>) to your entity, effectively extending the entity's mapping to more than one table in a database.<p></a><a name="436">A flattened attribute is an attribute that you effectively add from one entity to another by traversing a relationship. You can't add arbitrary attributes from various entities, however. To add an attribute from one entity to another, there must be a to-one relationship between those entities.<p></a><a name="547">For example, by traversing the toJobTitle relationship, you can determine a given employee's title. If you add the title attribute from the JobTitle entity to the Employee entity as a flattened attribute, the Enterprise Objects Framework will automatically traverse the relationship and locate the employee's title when the employee is fetched from the database.<p></a><a name="372">To your code, the flattened attribute looks like any other. After adding the title attribute to the Employee entity as a flattened attribute (which has no effect on the "EMPLOYEE" table in the database), for instance, your application's view of the Employee table would look like <a href="ApA_ERMd3.html#440">Figure &#32;66</a>:<p></a><a name="440"><p><img src="ApA_ERMd11.gif"><p></a><a name="578"><p>Figure 66.	  A View of the "EMPLOYEE" Table After Adding a Flattened Attribute<p></a><a name="432">You are not limited to flattening attributes across a single relationship; any number of relationship traversals can be employed. Thus, if there was a relationship between the JobTitle entity and a SalaryRange entity, you could include an employee's maximum salary with the rest of the employee information by flattening a toJobTitle.toSalaryRange.maxSalary attribute into the Employee entity.<p></a><a name="505"><h3> Flattened Relationships</h3></a><a name="506">Just as you can flatten an attribute to add it to another entity, so can you flatten a relationship. This gives a source entity access to relationships that a destination entity has with other entities. It is equivalent to performing a multi-table join.<p></a><a name="437">As an example, suppose you need department information for corporate assets that are assigned to employees, using the entities and relationships shown in <a href="ApA_ERMd3.html#519">Figure &#32;67</a>. One way to obtain the needed information is to flatten the relevant attributes (deptName and location, perhaps) across the toEmployee and toDepartment relationships. A simpler way would be to flatten the toDepartment relationship itself, so that it appears to your code as if the Department entity is a part of the Equipment entity.<p></a><a name="519"><p><img src="ApA_ERMd.gif"><p></a><a name="518"><p>Figure 67.	  Equipment Allocated by Department<p></a><a name="480"><a href="ApA_ERMd3.html#483">Figure &#32;68</a> shows how the Equipment entity might look after the flattened relationship had been added. In it, toDepartment is a relationship defined as toEmployee.toDepartment. When your code asks an Equipment object for the value of its <strong>toDepartment</strong> property, it receives the corresponding Department object. Your code can then query the Department object for the needed properties.<p></a><a name="483"><p><img src="ApA_ERMd15.gif"><p></a><a name="484"><p>Figure 68.	  A Flattened Relationship<p></a><a name="581">While the entities involved in a flattened relationship must be related, those relationships can either be to-one or to-many. If any of the relationships are to-many and your code requests the value for a flattened relationship, it will receive an array of objects corresponding to the flattened relationship's destination entity.<p></a><a name="2519"><h1></h1></a><hr><p><P> </body></html>