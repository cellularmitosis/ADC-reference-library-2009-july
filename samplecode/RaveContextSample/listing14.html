<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>RaveContextSample - /Source/QD3D_Support.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxGraphicsImaging-date.html">Graphics & Imaging</a> &gt; <A HREF="javascript:location.replace('index.html');">RaveContextSample</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/GraphicsImaging/index.html" target="_blank">Reference Library > Graphics & Imaging</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">RaveContextSample</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/Source/QD3D_Support.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/Headers/3dmf.h</option>
<option value="listing2.html">/Headers/misc.h</option>
<option value="listing3.html">/Headers/myevents.h</option>
<option value="listing4.html">/Headers/MyGlobals.h</option>
<option value="listing5.html">/Headers/mymenus.h</option>
<option value="listing6.html">/Headers/process.h</option>
<option value="listing7.html">/Headers/QD3D_Support.h</option>
<option value="listing8.html">/Source/3DMF.c</option>
<option value="listing9.html">/Source/Events.c</option>
<option value="listing10.html">/Source/Main.c</option>
<option value="listing11.html">/Source/Menus.c</option>
<option value="listing12.html">/Source/Misc.c</option>
<option value="listing13.html">/Source/Process.c</option>
<option value="listing14.html">/Source/QD3D_Support.c</option></select>
				</p>
				</form>
				<p><strong><a href="RaveContextSample.zip">Download Sample</a></strong> (&#147;RaveContextSample.zip&#148;, 51.0K)<BR>
<strong><a href="RaveContextSample.dmg">Download Sample</a></strong> (&#147;RaveContextSample.dmg&#148;, 112.6K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/****************************//*     QD3D SUPPORT.C      *//* By Brian Greenstone      *//****************************//****************************//*    EXTERNALS             *//****************************/#include &lt;NumberFormatting.h&gt;#include &lt;Resources.h&gt;#include &lt;QD3D.h&gt;#include &lt;QD3DGroup.h&gt;#include &lt;QD3DLight.h&gt;#include &lt;QD3DTransform.h&gt;#include &lt;QD3DStorage.h&gt;#include &lt;QD3DMath.h&gt;#include &lt;QD3DErrors.h&gt;#include &lt;Rave.h&gt;#include &lt;ImageCompression.h&gt;#include &lt;timer.h&gt;#include &quot;myglobals.h&quot;#include &quot;misc.h&quot;#include &quot;qd3d_support.h&quot;extern  EventRecord      gTheEvent;extern  WindowPtr      gModelWindow;/****************************//*    PROTOTYPES            *//****************************/static void CreateDrawContext(QD3DViewDefType *viewDefPtr);static void SetStyles(QD3DStyleDefType *styleDefPtr);static void CreateCamera(QD3DCameraDefType *cameraDefPtr);static void CreateLights(QD3DLightDefType *lightDefPtr);static void CreateView(QD3DSetupInputType *setupDefPtr);static void CreateTexturePixmap(PicHandle pict,unsigned long mapSizeX,               unsigned long mapSizeY, TQ3StoragePixmap *bMap);static void GWorldToBMap(GWorldPtr pGWorld, TQ3StoragePixmap *bMap);static void DrawPICTIntoPixmap(PicHandle pict,unsigned long width, unsigned long height, TQ3StoragePixmap *bMap);static TQ3SurfaceShaderObject  QD3D_PICTToTexture(PicHandle picture);static TQ3SurfaceShaderObject  QD3D_GWorldToTexture(GWorldPtr theGWorld);/****************************//*    CONSTANTS             *//****************************//*********************//*    VARIABLES      *//*********************/static TQ3CameraObject      gQD3D_CameraObject;static TQ3GroupObject      gQD3D_LightGroup;static TQ3ViewObject      gQD3D_ViewObject;static TQ3DrawContextObject    gQD3D_DrawContext;static TQ3RendererObject    gQD3D_RendererObject;static TQ3ShaderObject      gQD3D_ShaderObject;static  TQ3StyleObject      gQD3D_BackfacingStyle;static  TQ3StyleObject      gQD3D_FillStyle;static  TQ3StyleObject      gQD3D_InterpolationStyle;float  gFramesPerSecond = DEFAULT_FPS;        // this is used to maintain a constant timing velocity as frame rates differ//=======================================================================================================//=============================== VIEW WINDOW SETUP STUFF ===============================================//=======================================================================================================/************** SETUP QD3D WINDOW *******************/void QD3D_SetupWindow(QD3DSetupInputType *setupDefPtr, QD3DSetupOutputType *outputPtr){  CreateView(setupDefPtr);  Q3InteractiveRenderer_SetDoubleBufferBypass(gQD3D_RendererObject,kQ3True);    // let hardware go fast    CreateCamera(&amp;setupDefPtr-&gt;camera);                    // create new CAMERA object  CreateLights(&amp;setupDefPtr-&gt;lights);  SetStyles(&amp;setupDefPtr-&gt;styles);            /* DISPOSE OF EXTRA REFERENCES */          Q3Object_Dispose(gQD3D_RendererObject);        // (is contained w/in gQD3D_ViewObject)          /* PASS BACK INFO */          outputPtr-&gt;viewObject = gQD3D_ViewObject;  outputPtr-&gt;interpolationStyle = gQD3D_InterpolationStyle;  outputPtr-&gt;fillStyle = gQD3D_FillStyle;  outputPtr-&gt;backfacingStyle = gQD3D_BackfacingStyle;  outputPtr-&gt;shaderObject = gQD3D_ShaderObject;  outputPtr-&gt;cameraObject = gQD3D_CameraObject;  outputPtr-&gt;lightGroup = gQD3D_LightGroup;  outputPtr-&gt;drawContext = gQD3D_DrawContext;  outputPtr-&gt;window = setupDefPtr-&gt;view.displayWindow;    // remember which window  outputPtr-&gt;paneClip = setupDefPtr-&gt;view.paneClip;}/***************** QD3D_DisposeWindowSetup ***********************///// Disposes of all data created by QD3D_SetupWindow//void QD3D_DisposeWindowSetup(QD3DSetupOutputType *data){  Q3Object_Dispose(data-&gt;viewObject);  Q3Object_Dispose(data-&gt;interpolationStyle);  Q3Object_Dispose(data-&gt;backfacingStyle);  Q3Object_Dispose(data-&gt;fillStyle);  Q3Object_Dispose(data-&gt;cameraObject);  Q3Object_Dispose(data-&gt;lightGroup);  Q3Object_Dispose(data-&gt;drawContext);  Q3Object_Dispose(data-&gt;shaderObject);}/******************* CREATE GAME VIEW *************************/static void CreateView(QD3DSetupInputType *setupDefPtr){TQ3Status  myErr;unsigned long  hints;        /* CREATE NEW VIEW OBJECT */          gQD3D_ViewObject = Q3View_New();  if (gQD3D_ViewObject == nil)    DoFatalAlert(&quot;\pQ3View_New failed!&quot;);      /* CREATE &amp; SET DRAW CONTEXT */    CreateDrawContext(&amp;setupDefPtr-&gt;view);                 // init draw context    myErr = Q3View_SetDrawContext(gQD3D_ViewObject, gQD3D_DrawContext);      // assign context to view  if (myErr == kQ3Failure)    DoFatalAlert(&quot;\pQ3View_SetDrawContext Failed!&quot;);      /* CREATE &amp; SET RENDERER */  gQD3D_RendererObject = Q3Renderer_NewFromType(setupDefPtr-&gt;view.rendererType);  // create new RENDERER object  if (gQD3D_RendererObject == nil)  {    QD3D_ShowError(&quot;\pQ3Renderer_NewFromType Failed!&quot;, true);    CleanQuit();  }  myErr = Q3View_SetRenderer(gQD3D_ViewObject, gQD3D_RendererObject);        // assign renderer to view  if (myErr == kQ3Failure)    DoFatalAlert(&quot;\pQ3View_SetRenderer Failed!&quot;);    /* SET RENDERER FEATURES */      Q3InteractiveRenderer_GetRAVEContextHints(gQD3D_RendererObject, &amp;hints);  hints &amp;= ~kQAContext_NoZBuffer;         // Z buffer is on   hints &amp;= ~kQAContext_DeepZ;           // Z buffer is not deep, ergo it's shallow   hints |= kQAContext_NoDither;           // No Dither   Q3InteractiveRenderer_SetRAVEContextHints(gQD3D_RendererObject, hints);      Q3InteractiveRenderer_SetRAVETextureFilter(gQD3D_RendererObject,kQATextureFilter_Mid);  // fast texturing  Q3InteractiveRenderer_SetDoubleBufferBypass(gQD3D_RendererObject,kQ3True);}/**************** CREATE SKELETON DRAW CONTEXT *********************/static void CreateDrawContext(QD3DViewDefType *viewDefPtr){TQ3DrawContextData    drawContexData;TQ3MacDrawContextData  myMacDrawContextData;Rect          r;  r = viewDefPtr-&gt;displayWindow-&gt;portRect;      /* FILL IN DRAW CONTEXT DATA */  drawContexData.clearImageMethod = kQ3ClearMethodWithColor;        // how to clear  drawContexData.clearImageColor = viewDefPtr-&gt;clearColor;        // color to clear to  drawContexData.pane.min.x = r.left+viewDefPtr-&gt;paneClip.left;      // set bounds?  drawContexData.pane.max.x = r.right-viewDefPtr-&gt;paneClip.right;  drawContexData.pane.min.y = r.top+viewDefPtr-&gt;paneClip.top;  drawContexData.pane.max.y = r.bottom-viewDefPtr-&gt;paneClip.bottom;  drawContexData.paneState = kQ3True;                    // use bounds?  drawContexData.maskState = kQ3False;                  // no mask  drawContexData.doubleBufferState = kQ3True;                // double buffering  myMacDrawContextData.drawContextData = drawContexData;          // set MAC specifics  myMacDrawContextData.window = (CWindowPtr)viewDefPtr-&gt;displayWindow;  // assign window to draw to  myMacDrawContextData.library = kQ3Mac2DLibraryNone;            // use standard QD libraries (no GX crap!)  myMacDrawContextData.viewPort = nil;                  // (for GX only)  myMacDrawContextData.grafPort = (CWindowPtr)viewDefPtr-&gt;displayWindow;  // assign grafport      /* CREATE DRAW CONTEXT */  gQD3D_DrawContext = Q3MacDrawContext_New(&amp;myMacDrawContextData);  if (gQD3D_DrawContext == nil)    DoFatalAlert(&quot;\pQ3MacDrawContext_New Failed!&quot;);}/**************** SET STYLES ****************///// Creates style objects which define how the scene is to be rendered.// It also sets the shader object.//static void SetStyles(QD3DStyleDefType *styleDefPtr){        /* SET INTERPOLATION (FOR SHADING) */            gQD3D_InterpolationStyle = Q3InterpolationStyle_New(styleDefPtr-&gt;interpolation);  if (gQD3D_InterpolationStyle == nil)    DoFatalAlert(&quot;\pQ3InterpolationStyle_New Failed!&quot;);          /* SET BACKFACING */  gQD3D_BackfacingStyle = Q3BackfacingStyle_New(styleDefPtr-&gt;backfacing);  if (gQD3D_BackfacingStyle == nil )    DoFatalAlert(&quot;\pQ3BackfacingStyle_New Failed!&quot;);        /* SET POLYGON FILL STYLE */              gQD3D_FillStyle = Q3FillStyle_New(styleDefPtr-&gt;fill);  if ( gQD3D_FillStyle == nil )    DoFatalAlert(&quot;\p Q3FillStyle_New Failed!&quot;);          /* SET THE SHADER TO USE */  switch(styleDefPtr-&gt;illuminationType)  {    case  kQ3IlluminationTypePhong:        gQD3D_ShaderObject = Q3PhongIllumination_New();        if ( gQD3D_ShaderObject == nil )          DoFatalAlert(&quot;\p Q3PhongIllumination_New Failed!&quot;);        break;            case  kQ3IlluminationTypeLambert:        gQD3D_ShaderObject = Q3LambertIllumination_New();        if ( gQD3D_ShaderObject == nil )          DoFatalAlert(&quot;\p Q3LambertIllumination_New Failed!&quot;);        break;            case  kQ3IlluminationTypeNULL:        gQD3D_ShaderObject = Q3NULLIllumination_New();        if ( gQD3D_ShaderObject == nil )          DoFatalAlert(&quot;\p Q3NullIllumination_New Failed!&quot;);        break;  }  }/****************** CREATE CAMERA *********************/static void CreateCamera(QD3DCameraDefType *cameraDefPtr){TQ3CameraData          myCameraData;TQ3ViewAngleAspectCameraData  myViewAngleCameraData;TQ3Area              pane;TQ3Status            status;TQ3Status  myErr;  status = Q3DrawContext_GetPane(gQD3D_DrawContext,&amp;pane);        // get window pane info  if (status == kQ3Failure)    DoFatalAlert(&quot;\pQ3DrawContext_GetPane Failed!&quot;);        /* FILL IN CAMERA DATA */          myCameraData.placement.cameraLocation = cameraDefPtr-&gt;from;      // set camera coords  myCameraData.placement.pointOfInterest = cameraDefPtr-&gt;to;      // set target coords  myCameraData.placement.upVector = cameraDefPtr-&gt;up;          // set a vector that's &quot;up&quot;  myCameraData.range.hither = cameraDefPtr-&gt;hither;          // set frontmost Z dist  myCameraData.range.yon = cameraDefPtr-&gt;yon;              // set farthest Z dist  myCameraData.viewPort.origin.x = -1.0;                // set view origins?  myCameraData.viewPort.origin.y = 1.0;  myCameraData.viewPort.width = 2.0;  myCameraData.viewPort.height = 2.0;  myViewAngleCameraData.cameraData = myCameraData;  myViewAngleCameraData.fov = cameraDefPtr-&gt;fov;            // larger = more fisheyed  myViewAngleCameraData.aspectRatioXToY =        (pane.max.x-pane.min.x)/(pane.max.y-pane.min.y);  gQD3D_CameraObject = Q3ViewAngleAspectCamera_New(&amp;myViewAngleCameraData);   // create new camera  if (gQD3D_CameraObject == nil)    DoFatalAlert(&quot;\pQ3ViewAngleAspectCamera_New failed!&quot;);      myErr = Q3View_SetCamera(gQD3D_ViewObject, gQD3D_CameraObject);    // assign camera to view  if (myErr == kQ3Failure)    DoFatalAlert(&quot;\pQ3View_SetCamera Failed!&quot;);}/********************* CREATE LIGHTS ************************/static void CreateLights(QD3DLightDefType *lightDefPtr){TQ3GroupPosition    myGroupPosition;TQ3LightData      myLightData;TQ3DirectionalLightData  myDirectionalLightData;TQ3LightObject      myLight;short          i;TQ3Status  myErr;      /* CREATE NEW LIGHT GROUP */        gQD3D_LightGroup = Q3LightGroup_New();            // make new light group  if ( gQD3D_LightGroup == nil )    DoFatalAlert(&quot;\p Q3LightGroup_New Failed!&quot;);  myLightData.isOn = kQ3True;                  // light is ON        /************************/      /* CREATE AMBIENT LIGHT */      /************************/  if (lightDefPtr-&gt;ambientBrightness != 0)            // see if ambient exists  {    myLightData.color = lightDefPtr-&gt;ambientColor;        // set color of light    myLightData.brightness = lightDefPtr-&gt;ambientBrightness;  // set brightness value    myLight = Q3AmbientLight_New(&amp;myLightData);          // make it    if ( myLight == nil )      DoFatalAlert(&quot;\pQ3AmbientLight_New Failed!&quot;);    myGroupPosition = Q3Group_AddObject(gQD3D_LightGroup, myLight);  // add to group    if ( myGroupPosition == 0 )      DoFatalAlert(&quot;\p Q3Group_AddObject Failed!&quot;);    Q3Object_Dispose(myLight);                  // dispose of light  }      /**********************/      /* CREATE FILL LIGHTS */      /**********************/        for (i=0; i &lt; lightDefPtr-&gt;numFillLights; i++)  {        myLightData.color = lightDefPtr-&gt;fillColor[i];            // set color of light    myLightData.brightness = lightDefPtr-&gt;fillBrightness[i];      // set brightness    myDirectionalLightData.lightData = myLightData;            // refer to general light info    myDirectionalLightData.castsShadows = kQ3False;            // no shadows    myDirectionalLightData.direction =  lightDefPtr-&gt;fillDirection[i];  // set fill vector    myLight = Q3DirectionalLight_New(&amp;myDirectionalLightData);      // make it    if ( myLight == nil )      DoFatalAlert(&quot;\p Q3DirectionalLight_New Failed!&quot;);    myGroupPosition = Q3Group_AddObject(gQD3D_LightGroup, myLight);    // add to group    if ( myGroupPosition == 0 )      DoFatalAlert(&quot;\p Q3Group_AddObject Failed!&quot;);    Q3Object_Dispose(myLight);                      // dispose of light  }        /* ASSIGN LIGHT GROUP TO VIEW */        myErr = Q3View_SetLightGroup(gQD3D_ViewObject, gQD3D_LightGroup);    // assign light group to view  if (myErr == kQ3Failure)    DoFatalAlert(&quot;\pQ3View_SetLightGroup Failed!&quot;);    }/******************** QD3D CHANGE DRAW SIZE *********************///// Changes size of stuff to fit new window size.//void QD3D_ChangeDrawSize(QD3DSetupOutputType *setupInfo){Rect      r;TQ3Area      pane;TQ3ViewAngleAspectCameraData  cameraData;      /* CHANGE DRAW CONTEXT PANE SIZE */        r = setupInfo-&gt;window-&gt;portRect;              // get size of window  pane.min.x = r.left+setupInfo-&gt;paneClip.left;                    // set pane size  pane.max.x = r.right-setupInfo-&gt;paneClip.right;  pane.min.y = r.top+setupInfo-&gt;paneClip.top;  pane.max.y = r.bottom-setupInfo-&gt;paneClip.bottom;  Q3DrawContext_SetPane(setupInfo-&gt;drawContext,&amp;pane);    // update pane in draw context        /* CHANGE CAMERA ASPECT RATIO */          Q3ViewAngleAspectCamera_GetData(setupInfo-&gt;cameraObject,&amp;cameraData);      // get camera data  cameraData.aspectRatioXToY = (pane.max.x-pane.min.x)/(pane.max.y-pane.min.y);  // set new aspect ratio  Q3ViewAngleAspectCamera_SetData(setupInfo-&gt;cameraObject,&amp;cameraData);      // set new camera data}/******************* QD3D DRAW SCENE *********************/void QD3D_DrawScene(QD3DSetupOutputType *setupInfo, void (*drawRoutine)(QD3DSetupOutputType *)){TQ3Status        myStatus;TQ3ViewStatus      myViewStatus;      /* START RENDERING */  myStatus = Q3View_StartRendering(setupInfo-&gt;viewObject);        if ( myStatus == kQ3Failure )  {    DoFatalAlert(&quot;\p Q3View_StartRendering Failed!&quot;);  }        /***************/      /* RENDER LOOP */      /***************/  do  {        /* DRAW STYLES */            myStatus = Q3Style_Submit(setupInfo-&gt;interpolationStyle,setupInfo-&gt;viewObject);    if ( myStatus == kQ3Failure )      DoFatalAlert(&quot;\p Q3Style_Submit Failed!&quot;);          myStatus = Q3Style_Submit(setupInfo-&gt;backfacingStyle,setupInfo-&gt;viewObject);    if ( myStatus == kQ3Failure )      DoFatalAlert(&quot;\p Q3Style_Submit Failed!&quot;);          myStatus = Q3Style_Submit(setupInfo-&gt;fillStyle, setupInfo-&gt;viewObject);    if ( myStatus == kQ3Failure )      DoFatalAlert(&quot;\p Q3Style_Submit Failed!&quot;);    myStatus = Q3Shader_Submit(setupInfo-&gt;shaderObject, setupInfo-&gt;viewObject);    if ( myStatus == kQ3Failure )      DoFatalAlert(&quot;\p Q3Shader_Submit Failed!&quot;);      /* CALL INPUT DRAW FUNCTION */    drawRoutine(setupInfo);    myViewStatus = Q3View_EndRendering(setupInfo-&gt;viewObject);      } while ( myViewStatus == kQ3ViewStatusRetraverse );  }//=======================================================================================================//=============================== MISC ==================================================================//=======================================================================================================/************** QD3D CALC FRAMES PER SECOND *****************/float  QD3D_CalcFramesPerSecond(void){UnsignedWide  wide;unsigned long  now;static  unsigned long then = 0;  Microseconds(&amp;wide);  now = wide.lo;  if (then != 0)  {    gFramesPerSecond = (float)1000000.0/(float)(now-then);    if (gFramesPerSecond &lt; DEFAULT_FPS)      // (avoid divide by 0's later)      gFramesPerSecond = DEFAULT_FPS;    }  else    gFramesPerSecond = DEFAULT_FPS;      then = now;                // remember time      return(gFramesPerSecond);}#pragma mark ========== error stuff ===========/******************* QD3D: SHOW ERROR *************************///// Returns true if Error, false if just a warning.//Boolean QD3D_ShowError(Str255 errString, Boolean showWarnings){TQ3Error  err;TQ3Warning  warning;Str255    numStr;    /* DO ERRORS */      err = Q3Error_Get(nil);  if (err != 0)  {    DoAlert(errString);    switch(err)    {      case  kQ3ErrorViewNotStarted:          DoFatalAlert(&quot;\pError:kQ3ErrorViewNotStarted&quot;);          break;                case  kQ3ErrorOutOfMemory:          DoFatalAlert(&quot;\pError:kQ3ErrorOutOfMemory&quot;);          break;                default:          ShowSystemErr(err);    }    return(true);  }      /* DO WARNINGS */  else  {    if (!showWarnings)      return(false);        DoAlert(errString);    warning = Q3Warning_Get(nil);    switch(warning)    {      case  kQ3WarningFunctionalityNotSupported:          DoAlert(&quot;\pWarning: kQ3WarningFunctionalityNotSupported&quot;);          break;                default:          NumToString(err, numStr);          DoAlert (numStr);    }    return(false);  }    }/************ QD3D: SHOW RECENT ERROR *******************/void QD3D_ShowRecentError(void){TQ3Error  q3Err;Str255    s;    q3Err = Q3Error_Get(nil);  if (q3Err == kQ3ErrorOutOfMemory)    QD3D_DoMemoryError();  else  if (q3Err == kQ3ErrorMacintoshError)    DoFatalAlert(&quot;\pkQ3ErrorMacintoshError&quot;);  else  if (q3Err != 0)  {    NumToString(q3Err,s);    DoFatalAlert(s);  }}/***************** QD3D: DO MEMORY ERROR **********************/void QD3D_DoMemoryError(void){  InitCursor();  NoteAlert(129,nil);  CleanQuit();}#pragma mark =========== textures =================/**************** QD3D GET TEXTURE MAP ***********************///// Loads a PICT resource and returns a shader object which is// based on the PICT converted to a texture map.//// INPUT: textureRezID = resource ID of texture PICT to get.//      myFSSpec != nil if want to load PICT from file instead//// OUTPUT: TQ3ShaderObject = shader object for texture map.//TQ3SurfaceShaderObject  QD3D_GetTextureMap(long  textureRezID, FSSpec *myFSSpec){PicHandle      picture;TQ3SurfaceShaderObject    shader;long        pictSize,headerSize;OSErr        iErr;short        fRefNum;char        pictHeader[512];  if (myFSSpec == nil)  {          /* LOAD PICT REZ */        picture = GetPicture (textureRezID);    if (picture == nil)      DoFatalAlert(&quot;\pUnable to load texture PICT resource&quot;);  }  else  {        /* LOAD PICT FROM FILE */      iErr = FSpOpenDF(myFSSpec,fsCurPerm,&amp;fRefNum);    if (iErr)      DoFatalAlert(&quot;\pError reading PICT file!&quot;);    if  (GetEOF(fRefNum,&amp;pictSize) != noErr)    // get size of file          DoFatalAlert(&quot;\pError reading PICT file!&quot;);            headerSize = 512;          // check the header              if (FSRead(fRefNum,&amp;headerSize,pictHeader) != noErr)      DoFatalAlert(&quot;\pError reading PICT file!&quot;);    if ((pictSize -= 512) &lt;= 0)      DoFatalAlert(&quot;\pError reading PICT file!&quot;);          if ((picture = (PicHandle)NewHandle(pictSize)) == nil)      DoFatalAlert(&quot;\pNot enough memory to read PICT file!&quot;);    HLock((Handle)picture);          if (FSRead(fRefNum,&amp;pictSize,*picture) != noErr)      DoFatalAlert(&quot;\pError reading PICT file!&quot;);          FSClose(fRefNum);      }      shader = QD3D_PICTToTexture(picture);      if (myFSSpec == nil)    ReleaseResource ((Handle) picture);  else    DisposeHandle((Handle)picture);  return(shader);  }/**************** QD3D PICT TO TEXTURE ***********************/////// INPUT: picture = handle to PICT.//// OUTPUT: TQ3ShaderObject = shader object for texture map.//static TQ3SurfaceShaderObject  QD3D_PICTToTexture(PicHandle picture){TQ3StoragePixmap   pixmap;TQ3TextureObject  texture;TQ3SurfaceShaderObject    shader;      /* MAKE INTO STORAGE PIXMAP */    pixmap.image = nil;  CreateTexturePixmap (picture,        (**picture).picFrame.right  - (**picture).picFrame.left,        (**picture).picFrame.bottom - (**picture).picFrame.top,        &amp;pixmap);        /* MAKE NEW PIXMAP TEXTURE */        texture = Q3PixmapTexture_New (&amp;pixmap);  if (texture == nil)    DoFatalAlert(&quot;\pError calling Q3PixmapTexture_New!&quot;);      shader = Q3TextureShader_New (texture);  if (shader == nil)    DoFatalAlert(&quot;\pError calling Q3TextureShader_New!&quot;);  Q3Object_Dispose (texture);  Q3Object_Dispose (pixmap.image);      // disposes of extra reference to storage obj from CreateTexturePixmap  return(shader);  }/**************** QD3D GWORLD TO TEXTURE ***********************///// INPUT: picture = handle to PICT.//// OUTPUT: TQ3ShaderObject = shader object for texture map.//static TQ3SurfaceShaderObject  QD3D_GWorldToTexture(GWorldPtr theGWorld){TQ3StoragePixmap       pixmap;TQ3TextureObject      texture;TQ3SurfaceShaderObject    shader;  GWorldToBMap(theGWorld,&amp;pixmap);      /* MAKE NEW PIXMAP TEXTURE */        texture = Q3PixmapTexture_New (&amp;pixmap);  if (texture == nil)    DoFatalAlert(&quot;\pError calling Q3PixmapTexture_New!&quot;);  shader = Q3TextureShader_New(texture);  if (shader == nil)    DoFatalAlert(&quot;\pError calling Q3TextureShader_New!&quot;);  Q3Object_Dispose (texture);  Q3Object_Dispose (pixmap.image);      // possible memory leak if dont call this?!?!  return(shader);  }/******************** CREATE TEXTURE PIXMAP ********************/static void CreateTexturePixmap(PicHandle pict,unsigned long mapSizeX,               unsigned long mapSizeY, TQ3StoragePixmap *bMap){  bMap-&gt;image = NULL;    if (mapSizeY &gt; 512)    mapSizeY = 512;  if (mapSizeX &gt; 512)    mapSizeX = 512;    DrawPICTIntoPixmap (pict, mapSizeX, mapSizeY, bMap);}/******************** DRAW PICT INTO PIXMAP ********************///// OUTPUT: bMap = new bitmap holding texture image//static void DrawPICTIntoPixmap(PicHandle pict,unsigned long width, unsigned long height, TQ3StoragePixmap *bMap){  #define  k80K    (80000)Rect           rectGW;GWorldPtr         pGWorld;PixMapHandle       hPixMap;OSErr          myErr;GDHandle        oldGD;GWorldPtr        oldGW;long          bytesNeeded;  GetGWorld(&amp;oldGW, &amp;oldGD);                    // save current port        /* CREATE A GWORLD TO DRAW INTO */  SetRect(&amp;rectGW, 0, 0, width, height);            // set dimensions  bytesNeeded = (width * height * 4) + k80K;  if (bytesNeeded &lt; MaxBlock())    myErr = NewGWorld(&amp;pGWorld, 16, &amp;rectGW, 0, 0, 0L);      // make gworld  else    myErr = -43;  if (myErr)    DoFatalAlert(&quot;\pError making texture GWorld!&quot;);    hPixMap = GetGWorldPixMap(pGWorld);              // calc addr &amp; rowbytes      /* DRAW PICTURE INTO GWORLD */        SetGWorld(pGWorld, nil);    LockPixels(hPixMap);  EraseRect(&amp;rectGW);  DrawPicture(pict, &amp;rectGW);      /* MAKE A PIXMAP FROM GWORLD */        GWorldToBMap(pGWorld,bMap);    SetGWorld (oldGW, oldGD);  UnlockPixels (hPixMap);  DisposeGWorld (pGWorld);}/******************** GWORLD TO BMAP ********************///// Creates a TQ3StoragePixmap from an existing GWorld//// NOTE: Assumes that GWorld is 16bit!!!!//// OUTPUT: bMap = new bitmap holding texture image//static void GWorldToBMap(GWorldPtr pGWorld, TQ3StoragePixmap *bMap){unsigned long       pictMapAddr;PixMapHandle       hPixMap;unsigned long       pictRowBytes;long          width, height;TQ3Status        status;    hPixMap = GetGWorldPixMap(pGWorld);                // calc addr &amp; rowbytes    if ((**hPixMap).pixelSize != 16)                  // verify bitdepth    DoFatalAlert(&quot;\pGworlds must be 16bit when converting to textures!&quot;);    pictMapAddr = (unsigned long )GetPixBaseAddr(hPixMap);  pictRowBytes = (unsigned long)(**hPixMap).rowBytes &amp; 0x3fff;  width = ((**hPixMap).bounds.right - (**hPixMap).bounds.left);  height = ((**hPixMap).bounds.bottom - (**hPixMap).bounds.top);        /* SET MORE PIXELMAP INFO */  if (bMap-&gt;image != NULL)  {    DoAlert(&quot;\pReplacing PixelMap : (remove this Alert if I want this&quot;);    status = Q3MemoryStorage_Set (bMap-&gt;image, (unsigned char *) pictMapAddr,               pictRowBytes * height);    if (status == kQ3Failure)      DoFatalAlert(&quot;\pQ3MemoryStorage_Set Failed!&quot;);  }  else  {    bMap-&gt;image = Q3MemoryStorage_New ((unsigned char *) pictMapAddr, pictRowBytes * height);    if (bMap-&gt;image == nil)      DoFatalAlert(&quot;\pQ3MemoryStorage_New Failed!&quot;);  }  bMap-&gt;width   = width;  bMap-&gt;height  = height;  bMap-&gt;rowBytes   = pictRowBytes;  bMap-&gt;pixelSize = 16;  bMap-&gt;pixelType  = kQ3PixelTypeRGB16;  bMap-&gt;bitOrder  = kQ3EndianBig;  bMap-&gt;byteOrder  = kQ3EndianBig;  }</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/RaveContextSample/listing14.html%3Fid%3DDTS10000156-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/RaveContextSample/listing14.html%3Fid%3DDTS10000156-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/RaveContextSample/listing14.html%3Fid%3DDTS10000156-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>