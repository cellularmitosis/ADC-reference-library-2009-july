<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>Search Kit Programming Guide: Search Kit Concepts</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Search Kit Concepts"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP40002844" title="Search Kit Concepts"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../index.html#//apple_ref/doc/uid/TP30000440-TP30000437" target="_top">User Experience</a> &gt; <a href="../../../Carbon-date.html#//apple_ref/doc/uid/TP30000440-TP30000437-TP30000494" target="_top">Carbon</a> &gt; <a href="../searchKit_intro/searchKit_intro.html#//apple_ref/doc/uid/TP40002842-TPXREF101">Search Kit Programming Guide</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../searchKit_basics/searchKit_basics.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../searchKit_tasks/searchKit_tasks.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP40002844-TPXREF101" title="Search Kit Concepts"></a><h1>Search Kit Concepts</h1><p>In this chapter you learn about Search Kit’s capabilities, architecture, workflow, and internal workings. Before reading it you should understand the terms and ideas covered in <span class="content_text"><a href="../searchKit_basics/searchKit_basics.html#//apple_ref/doc/uid/TP40002843-TPXREF101">“Search Basics.”</a></span></p><p>Apple designed Search Kit as a highly flexible information retrieval framework. When using Search Kit, a "document" is any text container as understood by your application. You are not limited to searching files on disk but can search any body of textual information—pages distributed across a network, live database content, or custom, application-defined data. Similarly, your application can define what counts as a "term" for Search Kit. For Japanese text, Search Kit parses terms using Apple’s Japanese language analysis technology.</p><p>Search Kit uses <strong>document URL objects</strong>, similar to CFURL objects, to refer to documents. Using document URL objects, your application can define any sort of <strong>document object hierarchy</strong> and location scheme.</p><p>The first two sections of this chapter—<span class="content_text"><a href="searchKit_concepts.html#//apple_ref/doc/uid/TP40002844-BABGEGGF">“Search Kit Architecture”</a></span> and <span class="content_text"><a href="searchKit_concepts.html#//apple_ref/doc/uid/TP40002844-mrj-SW1">“Search Kit Application Workflow”</a></span>—provide a high-level understanding. The meat of this chapter is in the final section, <span class="content_text"><a href="searchKit_concepts.html#//apple_ref/doc/uid/TP40002844-BAJFJGFF">“How Search Kit Works.”</a></span></p><a name="//apple_ref/doc/uid/TP40002844-BABGEGGF" title="Search Kit Architecture"></a><h2>Search Kit Architecture</h2><p>The Search Kit API is a C language framework within the Core Services umbrella framework. As such, it employs memory-management and error-handling conventions from Apple's Core Foundation technology and makes use of Core Foundation data types.</p><p>This section is a brief tour through Search Kit's architecture, providing just enough context to understand how Search Kit's pieces fit together. To dig deeper into any of the topics presented in this section, refer to <span class="content_text"><a href="searchKit_concepts.html#//apple_ref/doc/uid/TP40002844-BAJFJGFF">“How Search Kit Works”</a></span> and <span class="content_text"><a href="../searchKit_tasks/searchKit_tasks.html#//apple_ref/doc/uid/TP40001071-CH204-SW1">“Search Kit Tasks.”</a></span></p><a name="//apple_ref/doc/uid/TP40002844-DontLinkElementID_10" title="Indexes, Documents, and Terms"></a><h3>Indexes, Documents, and Terms</h3><p>Search Kit uses a simple information containment hierarchy to allow your application to manage the content, or corpus, it is responsible for. <span class="content_text">Figure 2-1</span> illustrates this hierarchy by zooming in successively from left to right.</p><br/><div><a name="//apple_ref/doc/uid/TP40002844-BABJEHBA" title="Figure 2-1The Search Kit containment hierarchy"></a><p><strong>Figure 2-1&nbsp;&nbsp;</strong>The Search Kit containment hierarchy</p><img src = "../art/containment_hery.gif" alt = "Search Kit's containment hierarchy" width="458" height="164"></div><br/><p>At the outermost level, as shown in the figure on the left, an application typically works with a group of indexes. An individual index, depicted in the figure under the heading "Index" and represented in Search Kit as an <code>SKIndexRef</code> opaque type, contains representations of one or more documents.</p><p>A document representation in an index is a key/value pair. The key is a lightweight, unique identifier of type <code>SKDocumentID</code>. The corresponding value includes a document URL object of type <code>SKDocumentRef</code>. Zooming in on one such document representation, the figure depicts an individual term associated with one document.</p><p>A Search Kit index associates each document with the terms extracted from it. A term is also represented as a key/value pair in an index. A term's key, like a document's key, is a lightweight, unique identifier. A term ID is of type <code>CFIndex</code>. The value for a term includes the term string itself. Given a term ID, your application can get the term by calling the <code>SKIndexCopyTermStringForTermID</code> function.</p><p>Index groups, as shown on the left in <span class="content_text">Figure 2-1</span>, are not explicitly supported in Search Kit but have many uses. You implement them in your application for such things as:</p><ul class="spaceabove"><li class="li"><p>Simultaneously searching multiple fields in documents such as emails, where you have one index for the body content, another for the “To” header, and so on</p></li><li class="li"><p>Simultaneously searching multiple corpora, such as multiple email mailboxes</p></li></ul><a name="//apple_ref/doc/uid/TP40002844-DontLinkElementID_11" title="Index Types"></a><h3>Index Types</h3><p>You’ll typically create disk-based (persistent) indexes using the <code><a href="../../../Reference/SearchKit/Reference/reference.html#//apple_ref/doc/c_ref/SKIndexCreateWithURL" target="_top">SKIndexCreateWithURL</a></code> function, which creates an index in a file. One index file can hold any number of Search Kit indexes. The choice to put one or more than one index in a file has implications regarding how an application manages searches, as described later in this chapter.</p><p>Search Kit supports memory-based indexes as well, with its <code><a href="../../../Reference/SearchKit/Reference/reference.html#//apple_ref/doc/c_ref/SKIndexCreateWithMutableData" target="_top">SKIndexCreateWithMutableData</a></code> function.</p><p>Whether it is file or memory based, you set an index’s capabilities when you create it. There are two aspects to consider.</p><ul class="spaceabove"><li class="li"><p><em>Index type</em> determines whether the index will be optimized for query searching or similarity searching.</p></li><li class="li"><p>An index’s <em>text analysis properties dictionary</em> determines whether the index will support phrase-based searches. It also sets various index attributes that bear on index size and search efficiency.</p></li></ul><a name="//apple_ref/doc/uid/TP40002844-DontLinkElementID_12" title="Indexes and Search Objects"></a><h3>Indexes and Search Objects</h3><p>A new Search Kit index is empty, ready to accept documents. Search Kit provides functions for creating document URL objects, for adding them and their associated text to indexes, and for reindexing documents that change or move.</p><p>To find documents, your application creates and then queries a <strong>search object</strong>. The search object, upon its creation, initiates search and then acts as a dynamic repository for results. Your application can query the search object immediately after its creation and then repeatedly to get additional results.</p><p>Each search object is associated with exactly one index. By creating multiple search objects, you can perform searches on multiple indexes sequentially or in parallel, according to the requirements of your application.</p><a name="//apple_ref/doc/uid/TP40002844-mrj-SW1" title="Search Kit Application Workflow"></a><h2>Search Kit Application Workflow</h2><p>Performing a search is a straightforward, two-step process:</p><ol class="ol"><li class="li"><p>Create a searchable corpus.</p></li><li class="li"><p>Using the user's query, perform a search and display the results.</p></li></ol><a name="//apple_ref/doc/uid/TP40002844-DontLinkElementID_13" title="Create a Searchable Corpus"></a><h3>Create a Searchable Corpus</h3><p>You make textual content searchable by indexing it. To do this, you:</p><ol class="ol"><li class="li"><p>Create an empty index using the <code><a href="../../../Reference/SearchKit/Reference/reference.html#//apple_ref/doc/c_ref/SKIndexCreateWithURL" target="_top">SKIndexCreateWithURL</a></code> function for a file-based index, or with the <code><a href="../../../Reference/SearchKit/Reference/reference.html#//apple_ref/doc/c_ref/SKIndexCreateWithMutableData" target="_top">SKIndexCreateWithMutableData</a></code> function for a memory-based index.</p></li><li class="li"><p>Create document URL objects to add to the index by calling the <code><a href="../../../Reference/SearchKit/Reference/reference.html#//apple_ref/doc/c_ref/SKDocumentCreateWithURL" target="_top">SKDocumentCreateWithURL</a></code> or the <code><a href="../../../Reference/SearchKit/Reference/reference.html#//apple_ref/doc/c_ref/SKDocumentCreate" target="_top">SKDocumentCreate</a></code> function, depending on how your application wants to manage your corpus.</p></li><li class="li"><p>Add document URL objects and text to the index with the <code><a href="../../../Reference/SearchKit/Reference/reference.html#//apple_ref/doc/c_ref/SKIndexAddDocumentWithText" target="_top">SKIndexAddDocumentWithText</a></code> or <code><a href="../../../Reference/SearchKit/Reference/reference.html#//apple_ref/doc/c_ref/SKIndexAddDocument" target="_top">SKIndexAddDocument</a></code> functions. In the general case, your application takes responsibility for getting text out of a document, using other Mac OS X frameworks, and then hands the text to an index in the form of a CFString object using the <code><a href="../../../Reference/SearchKit/Reference/reference.html#//apple_ref/doc/c_ref/SKIndexAddDocumentWithText" target="_top">SKIndexAddDocumentWithText</a></code> function. Alternatively, the <code><a href="../../../Reference/SearchKit/Reference/reference.html#//apple_ref/doc/c_ref/SKIndexAddDocument" target="_top">SKIndexAddDocument</a></code> function makes use of the Spotlight text importers to get the text from a local, file-based document.</p></li></ol><a name="//apple_ref/doc/uid/TP40002844-DontLinkElementID_14" title="Perform a Search and Display the Results"></a><h3>Perform a Search and Display the Results</h3><p>A user’s request for information includes a query along with a specification of where to search. The query comprises words and perhaps <strong>operators</strong>, such as “<code>&amp;</code>”, representing a logical <code>AND</code>, or “*”, the <strong>wildcard character</strong>. The specification of where to search—that is, which indexes to use—may be supplied by your application or supplied by the user. As an example of a user-supplied search location, the set of mailboxes a user selects in Mail becomes the active set of locations for search.</p><p>Different types of indexes support different types of search, so you may want your application to guide users appropriately in regard to query type. For example, if an index doesn't support phrase searching, your application could provide appropriate feedback if a user enters a query with a double-quote-delimited text string.</p><p>As preparation for a search, your application should use the <code><a href="../../../Reference/SearchKit/Reference/reference.html#//apple_ref/doc/c_ref/SKIndexFlush" target="_top">SKIndexFlush</a></code> function to update and flush to disk the indexes specified in the query. Updating and flushing ensure that you invoke the search on fresh data.</p><p>However, if the information in the corpus changes rarely, or if the corpus is so large that the time consumed by updating the indexes would frustrate user expectations, you may want to update more strategically. For instance, if your application controls when documents change, you can update an index incrementally each time a document changes. Mac OS X does this for file system searches that use Spotlight by way of file system notifications.</p><p>You create a search object with the asynchronous <code><a href="../../../Reference/SearchKit/Reference/reference.html#//apple_ref/doc/c_ref/SKSearchCreate" target="_top">SKSearchCreate</a></code> function. You then query it with the <code>SKSearchFindMatches</code> function, which provides results as an array of document IDs and a parallel array, if requested, of relevance scores. Your application can get document locations for these IDs, in the form of document URL objects, by calling the <code>SKIndexCopyDocumentURLsForDocumentIDs</code> function. Finally, your application can display these document locations as search results using other Mac OS X frameworks.</p><a name="//apple_ref/doc/uid/TP40002844-BABHDDAE" title="Additional Workflows"></a><h2>Additional Workflows</h2><p>In addition to query-based searches, Search Kit supports similarity searching and summarization. This section briefly describes these workflows as well as index maintenance in terms of removing and reindexing documents.</p><a name="//apple_ref/doc/uid/TP40002844-BABJGGHA" title="Similarity Searching"></a><h3>Similarity Searching</h3><p>In a <strong>similarity search</strong>, a user looks for documents similar to an example document. The workflow is nearly identical to the workflow for a query search, with these differences:</p><ul class="spaceabove"><li class="li"><p>When creating a search object with the <code><a href="../../../Reference/SearchKit/Reference/reference.html#//apple_ref/doc/c_ref/SKSearchCreate" target="_top">SKSearchCreate</a></code> function, use the <code><a href="../../../Reference/SearchKit/Reference/reference.html#//apple_ref/doc/c_ref/kSKSearchOptionFindSimilar" target="_top">kSKSearchOptionFindSimilar</a></code> flag in the <em>inSearchOptions</em> parameter.</p></li><li class="li"><p>Provide a string representing a document, or a portion of a document, to the <code><a href="../../../Reference/SearchKit/Reference/reference.html#//apple_ref/doc/c_ref/SKSearchCreate" target="_top">SKSearchCreate</a></code> function’s <em>inQuery</em> parameter.</p></li></ul><a name="//apple_ref/doc/uid/TP40002844-BABCCFCJ" title="Using Summarization"></a><h3>Using Summarization</h3><p>Starting with Mac OS X v10.4, Search Kit supplants the summarization functionality previously available in Apple’s Find By Content technology. You can use summarization independently of search or as an adjunct to your application’s display of search results. Find By Content remains available in Mac OS X for backward compatibility only.</p><p>To perform summarization you create a <strong>summarization object</strong> of type <code>SKSummaryRef</code> by passing a text string to the <code><a href="../../../Reference/SearchKit/Reference/reference.html#//apple_ref/doc/c_ref/SKSummaryCreateWithString" target="_top">SKSummaryCreateWithString</a></code> function. You then use the <code><a href="../../../Reference/SearchKit/Reference/reference.html#//apple_ref/doc/c_ref/SKSummaryCopySentenceSummaryString" target="_top">SKSummaryCopySentenceSummaryString</a></code> or <code><a href="../../../Reference/SearchKit/Reference/reference.html#//apple_ref/doc/c_ref/SKSummaryCopyParagraphSummaryString" target="_top">SKSummaryCopyParagraphSummaryString</a></code> functions to generate a sentence- or paragraph-based summary of the size you want. Each of these functions has a parameter that lets you specify summary length as an integer number of sentences or paragraphs.</p><p>You can see summarization in action by selecting a block of text in a Mac OS X application and then choosing the Summarize service from the Services submenu in the application menu.</p><p>For additional control over summarization, Search Kit supplies other functions that let you work with individual sentences and paragraphs from the summarization object. For more information, refer to <em><a href="../../../Reference/SearchKit/index.html#//apple_ref/doc/uid/TP30000904" target="_top">Search Kit Reference</a></em>.</p><a name="//apple_ref/doc/uid/TP40002844-DontLinkElementID_15" title="Index Maintenance"></a><h3>Index Maintenance</h3><p>To reindex a document that has changed but whose location is the same, you simply replace it in the index. If a document has moved, or moved and changed, you remove the old version and then add the new version. For details refer to <span class="content_text"><a href="../searchKit_tasks/searchKit_tasks.html#//apple_ref/doc/uid/TP40001071-CH204-SW1">“Search Kit Tasks.”</a></span></p><a name="//apple_ref/doc/uid/TP40002844-BAJFJGFF" title="How Search Kit Works"></a><h2>How Search Kit Works</h2><p>Here you learn how Search Kit works with documents as abstract objects, how it indexes content, and how it manages queries and results.</p><a name="//apple_ref/doc/uid/TP40002844-BABDBJGC" title="How Search Kit Works With Documents"></a><h3>How Search Kit Works With Documents</h3><p>Search Kit works with any collection of textual information as a document object hierarchy. This approach gives your application a great deal of flexibility in how it defines and manages documents.</p><p>There are two ways Search Kit can manage a document object hierarchy. One is specifically for documents that are disk-based files—those whose URLs use the <code>file</code>  <strong>scheme</strong>. The other is general; it works with any sort of document, whether it is file based, memory based, or application defined.</p><ul class="spaceabove"><li class="li"><p>If your application works with documents that are disk-based files, you can use the file-system hierarchy directly. With this option you let Search Kit find documents and get their contents. Document URL objects in this approach are equivalent to file-system paths.</p></li><li class="li"><p>If your documents are not disk-based files or you want more control over the document object hierarchy, use Search Kit’s general approach. In this approach, your application specifies, using a flexible URL format, how to refer to documents. Your application takes responsibility for locating documents, and during indexing, your application hands the textual content of a document to Search Kit in the form of a CFString object.</p></li></ul><p>With either approach, when you create a document URL object, you give Search Kit the information needed to find the document. This may be a file-system URL, an Internet URL, a SQL statement, an ID number, and so on—the format is up to your application. During a search, when Search Kit identifies a document in response to a user’s query, your application can ask for the location information and use it to get the associated document.</p><a name="//apple_ref/doc/uid/TP40002844-DontLinkElementID_16" title="Working With Documents and Document URL Objects"></a><h4>Working With Documents and Document URL Objects</h4><p>Using Search Kit, the definition of “document” is largely up to your application. A document, to Search Kit, is simply a locatable chunk of text. The chunking depends on your application which serves as an intermediary between Search Kit and the information you want to search.</p><p>An email client, for example, might use a single plaintext file (such as in the Unix <code>mbox</code> format) to hold multiple documents—namely, the set of mail messages in a mailbox. Another application might employ a one-to-one correspondence between files and documents. Or an application might consider all the files within a folder to be a single, multipart document—in this case, a search hit in any of the referenced files might direct the user to the containing folder or bundle. It’s up to your application.</p><p>To Search Kit, a document is atomic in that it defines the granularity of a search. Using Search Kit, your application can find documents—as your application understands them—but cannot locate the position of a term within a document. If you want to locate matches for a user’s query within a found document, use the MLTE <code><a href="../../../../Carbon/Reference/Multilingual_Text_Engine/Reference/reference.html#//apple_ref/doc/c_ref/TXNFind" target="_top">TXNFind</a></code> function in Carbon or the <code>NSString</code><code>rangeOfCharacterFromSet:options:</code> method in Cocoa.</p><p>To Search Kit, a document’s structure is irrelevant in that Search Kit indexes don’t know anything about paragraphs, subtitles, tagging, or fields of information within a document. Search Kit sees a document’s content simply as a bag of terms. If you want to let users search by various attributes of documents, you create an index for each attribute.</p><p>Search Kit is concerned only with textual content, so it does not keep track of file-system attributes such as modification timestamps. In Carbon, use the <code><!--a-->PBCatSearch<!--/a--></code> function to search by file-system attributes. In Cocoa, use the <code><a href="../../../../Cocoa/Reference/Foundation/Classes/NSFileManager_Class/Reference/Reference.html#//apple_ref/doc/c_ref/NSFileManager" target="_top">NSFileManager</a></code> class. You can also use the Spotlight API to search for documents according to file-system attributes or other metadata.</p><a name="//apple_ref/doc/uid/TP40002844-BABEAHAH" title="Using Document Locations"></a><h4>Using Document Locations</h4><p>As described above, Search Kit’s notion of document location is encapsulated in something called a document URL object. Document URL objects correspond to the simple data type <code>SKDocumentRef</code>. A document URL object is similar to a CFURL object but lets you use any format that you like to represent a document’s location. It’s up to your application to interpret the location to retrieve the document.</p><p>There are multiple ways to create document URL objects. You can create them by converting CFURL objects using the <code><a href="../../../Reference/SearchKit/Reference/reference.html#//apple_ref/doc/c_ref/SKDocumentCreateWithURL" target="_top">SKDocumentCreateWithURL</a></code> function. Alternatively, you can give this function a URL directly. In this case you can use any URL scheme you like, including standard schemes such as <code>file</code>, <code>http</code> and <code>ftp</code>; or nonstandard schemes of your own design, such as <code>data</code>.</p><p>Yet another way to build document URL objects is to construct a document object hierarchy node by node. Search Kit supports the building of document object hierarchies with its <code><a href="../../../Reference/SearchKit/Reference/reference.html#//apple_ref/doc/c_ref/SKDocumentCreate" target="_top">SKDocumentCreate</a></code> function. This function, rather than taking a complete URL as <code><a href="../../../Reference/SearchKit/Reference/reference.html#//apple_ref/doc/c_ref/SKDocumentCreateWithURL" target="_top">SKDocumentCreateWithURL</a></code> does, builds a URL for you from a triple of information that you hand it: the document <strong>name</strong>, the <strong>parent document URL object</strong>, and an optional <strong>scheme</strong>.</p><p><span class="content_text">Figure 2-2</span> illustrates these components as they appear in a URL. If you want to take advantage of Search Kit’s ability to locate and read local, file-based documents, the Name portion should match the document filename. If your application manages the documents in its corpora, the Name portion may match the document filename or not, according to the application's needs.</p><br/><div><a name="//apple_ref/doc/uid/TP40002844-BABDJBFJ" title="Figure 2-2A Search Kit document URL"></a><p><strong>Figure 2-2&nbsp;&nbsp;</strong>A Search Kit document URL</p><img src = "../art/non_file_system_path.gif" alt = "Search Kit document URL" width="312" height="98"></div><br/><p>The full URL is the location information in the document URL object. The portion to the left of the Name, up to but not including the final slash, is the location information in the document URL object for the parent. To tell the <code><a href="../../../Reference/SearchKit/Reference/reference.html#//apple_ref/doc/c_ref/SKDocumentCreate" target="_top">SKDocumentCreate</a></code> function the scheme for the document URL object, use the text starting from the left and up to, but not including, the colon.</p><p>A document object hierarchy can be flat, tree-based, or more complex. Your application defines and uses it.</p><p>You can determine document URLs by assembling them piece by piece if you want, using the functions <code><a href="../../../Reference/SearchKit/Reference/reference.html#//apple_ref/doc/c_ref/SKDocumentGetName" target="_top">SKDocumentGetName</a></code>, <code><a href="../../../Reference/SearchKit/Reference/reference.html#//apple_ref/doc/c_ref/SKDocumentGetParent" target="_top">SKDocumentGetParent</a></code>, and <code><a href="../../../Reference/SearchKit/Reference/reference.html#//apple_ref/doc/c_ref/SKDocumentGetSchemeName" target="_top">SKDocumentGetSchemeName</a></code> to query document URL objects. Start at the leaf document and traverse upward, parent to parent. This works with all document URL objects—those created by converting CFURL objects, those created from URLs directly, and those created by using name, parent, and scheme.</p><p>The parent-child-based control of document object hierarchies you get by using the <code><a href="../../../Reference/SearchKit/Reference/reference.html#//apple_ref/doc/c_ref/SKDocumentCreate" target="_top">SKDocumentCreate</a></code> function can be useful when you want to attach information to nondocument nodes in a hierarchy. For example, you may want to record when the documents in a folder were last indexed; you can associate that information with the document URL object of the enclosing folder. This can also be useful when the documents in your corpus do not correspond to disk-based files—for example, when they are database records or tagged chunks of text within an enclosing file. In cases like these, a nondocument node is a good place to store metainformation about subordinate documents.</p><p>A side effect of Search Kit’s powerful generality in handling document object hierarchies is that when you create a document URL object from a multipart URL, Search Kit creates a series of document URL objects, one for each element in the path. Use these if you want, as just described, or ignore them if they’re not useful.</p><p>In the special case of <code>file</code> URLs, Search Kit knows how to find documents for you. It also knows how to harvest the content of local files, as described in <span class="content_text"><a href="searchKit_concepts.html#//apple_ref/doc/uid/TP40002844-BABFIBHG">“Terms, From Documents to Indexes.”</a></span> In every other case, your application manages a document object hierarchy and interprets document locations from document URL objects.</p><p>You can get the URL itself from a document URL object by passing the object to the <code><a href="../../../Reference/SearchKit/Reference/reference.html#//apple_ref/doc/c_ref/SKDocumentCopyURL" target="_top">SKDocumentCopyURL</a></code> function.</p><a name="//apple_ref/doc/uid/TP40002844-DontLinkElementID_17" title="Document Properties"></a><h4>Document Properties</h4><p>You can associate information with each document in an index by way of a properties dictionary, using the <code><a href="../../../Reference/SearchKit/Reference/reference.html#//apple_ref/doc/c_ref/SKIndexSetDocumentProperties" target="_top">SKIndexSetDocumentProperties</a></code> function. The format of this optional dictionary can be as simple or as complex as you want. For example, an email program could include a property dictionary for each mailbox, describing metainformation such as number of read and unread messages, the file-system location of the mailbox, and so on.</p><p>You can use this property information as context for the user or for your application but you cannot directly search it. Retrieve property information using the <code><a href="../../../Reference/SearchKit/Reference/reference.html#//apple_ref/doc/c_ref/SKIndexCopyDocumentProperties" target="_top">SKIndexCopyDocumentProperties</a></code> function.</p><a name="//apple_ref/doc/uid/TP40002844-BABDBFDC" title="How Search Kit Extracts Terms From Documents"></a><h3>How Search Kit Extracts Terms From Documents</h3><p><strong>Terms</strong> are the currency of information retrieval. In a search, you provide a query consisting of terms, perhaps including operators, and Search Kit matches the query with indexed terms that have been extracted from documents. Here you learn how terms get from documents into indexes. You also learn about the Search Kit index types and about how they support various types of searching.</p><p>You may want to first review <span class="content_text"><a href="../searchKit_basics/searchKit_basics.html#//apple_ref/doc/uid/TP40002843-BEIFGBIC">“Constructing Indexes”</a></span> in the Search Basics chapter, which provides an implementation-independent introduction to indexes.</p><a name="//apple_ref/doc/uid/TP40002844-BABFIBHG" title="Terms, From Documents to Indexes"></a><h4>Terms, From Documents to Indexes</h4><p>Terms get from documents into Search Kit indexes through a three-step process:</p><ol class="ol"><li class="li"><p>You ask Search Kit to create a new, empty index if you need one. Otherwise, get the reference for an existing index.</p></li><li class="li"><p>You create a document URL object for each of the documents you want to index.</p></li><li class="li"><p>You add the document URL objects and textual content to the index.</p></li></ol><p><span class="content_text">Figure 2-3</span> depicts this process.</p><br/><div><a name="//apple_ref/doc/uid/TP40002844-BABICAAA" title="Figure 2-3Adding documents to a new index"></a><p><strong>Figure 2-3&nbsp;&nbsp;</strong>Adding documents to a new index</p><img src = "../art/create_empty_index.gif" alt = "Adding documents to a new index" width="509" height="169"></div><br/><p>In the general case and for documents that do not correspond to on-disk files—webpages, database records, tag-delimited subsets of files, data in memory, or custom, application-specific content—use the <code><a href="../../../Reference/SearchKit/Reference/reference.html#//apple_ref/doc/c_ref/SKIndexAddDocumentWithText" target="_top">SKIndexAddDocumentWithText</a></code> function. Your application explicitly sends document text in the form of a CFString object to the function and provides the document location as a document URL object. You can also use this function for on-disk, file-based documents when you want more control over the indexing process. You might do this, for example, for an XML document when your application understands the tagging semantics.</p><p>To ask Search Kit to get textual content for you from an on-disk file using Spotlight importers, use the <code><a href="../../../Reference/SearchKit/Reference/reference.html#//apple_ref/doc/c_ref/SKIndexAddDocument" target="_top">SKIndexAddDocument</a></code> function. This function converts a file-system path to a document URL object, and (with help from the Spotlight importers) gets the text to be placed in the index.</p><p> If your application relies on Spotlight importers, when your program launches, tell Search Kit to load them by calling the <code><a href="../../../Reference/SearchKit/Reference/reference.html#//apple_ref/doc/c_ref/SKLoadDefaultExtractorPlugIns" target="_top">SKLoadDefaultExtractorPlugIns</a></code> function.</p><p>In either case, the “add-document” functions—<code><a href="../../../Reference/SearchKit/Reference/reference.html#//apple_ref/doc/c_ref/SKIndexAddDocument" target="_top">SKIndexAddDocument</a></code> and <code><a href="../../../Reference/SearchKit/Reference/reference.html#//apple_ref/doc/c_ref/SKIndexAddDocumentWithText" target="_top">SKIndexAddDocumentWithText</a></code>—parse textual content into terms before placing it into an index. If your application is reading Japanese text, Search Kit uses Apple’s Japanese language analysis technology.</p><p>Each term in a Search Kit index has a unique ID and is associated with a list of document URL objects, as illustrated in the Search Basics chapter in <span class="content_text"><a href="../searchKit_basics/searchKit_basics.html#//apple_ref/doc/uid/TP40002843-BEIIGHGH">Figure 1-2</a></span>. Various Search Kit functions let you convert between terms and IDs, determine which documents contain a term, get the number of times a term appears in a document, and so on. </p><a name="//apple_ref/doc/uid/TP40002844-BABGJGCH" title="Index Types"></a><h4>Index Types</h4><p>Three types of Search Kit indexes handle various functionality and efficiency requirements:</p><ul class="spaceabove"><li class="li"><p><em>Inverted indexes</em> map terms to documents. Use an inverted index to allow users to discover which documents match their queries. This is the preferred index type for most applications.</p></li><li class="li"><p><em>Vector indexes</em> map documents to terms. Use a vector index to let users find documents based on a similar, specified document—that is, to perform similarity searching.</p></li><li class="li"><p><em>Inverted-vector indexes</em> combine the characteristics and capabilities of inverted and vector indexes. They consume more memory and file space than either of their constituent types.</p></li></ul><p>When you create an index, you specify one of these three index types using the <em>inIndexType</em> parameter in either the <code><a href="../../../Reference/SearchKit/Reference/reference.html#//apple_ref/doc/c_ref/SKIndexCreateWithURL" target="_top">SKIndexCreateWithURL</a></code> or <code><a href="../../../Reference/SearchKit/Reference/reference.html#//apple_ref/doc/c_ref/SKIndexCreateWithMutableData" target="_top">SKIndexCreateWithMutableData</a></code> function. The type determines how each added document will be indexed and indirectly determines which sorts of searches your users can perform. For example, a vector index does not support Boolean queries or phrase-based searching. <span class="content_text">Figure 2-4</span> lists the various index types and the search capabilities for each.</p><br/><div><a name="//apple_ref/doc/uid/TP40002844-BABIIGAD" title="Figure 2-4Index types and their available search types"></a><p><strong>Figure 2-4&nbsp;&nbsp;</strong>Index types and their available search types</p><img src = "../art/indextypes.gif" alt = "Searches available for each index type" width="401" height="229"></div><br/><p><strong>Inverted indexes</strong> are optimized for fast query-based searches and for minimal index size. They map terms to document. That is, terms are the keys in the key-value pairs in inverted indexes.</p><p>Use an inverted index unless your application’s primary use is similarity searching. Although inverted indexes work for similarity searching, performance is slower than when searching by similarity using a vector index.</p><p>A Search Kit inverted index lists each constituent term exactly once—no matter how many of the documents contained in the index include the term and no matter how frequently the term appears in any of the documents. The value in a term's (key, value) pair in an inverted index includes a number indicating how many of the index's documents contain the term, IDs of the documents that use the term, and how often the term appears in each document.</p><p>If you specify proximity-searching support when you create an index, the index also tracks the position of each instance of the term in each document.</p><p></p><p><strong>Vector indexes</strong> map documents to terms. That is, documents are the keys in the (key, value) pairs in vector indexes. Their primary use is fast similarity searching.</p><p>The value in a document's (key, value) pair in a vector index includes a number indicating how many terms the document contains, IDs of the terms in the document, and how often each term appears in the document.</p><p>Vector indexes do not support Boolean or phrase-based searching. These limitations, along with their relatively large size, make them a bad choice unless your primary need is fast similarity searching.</p><p><strong>Inverted-vector indexes</strong> support every type of Search Kit query but are larger still than vector indexes. Their only practical application is to support Boolean, phrase-based, and fast similarity searching on the same index, and when index size will not be an issue.</p><a name="//apple_ref/doc/uid/TP40002844-DontLinkElementID_18" title="Text Analysis Properties"></a><h5>Text Analysis Properties</h5><p>In addition to having a type, each Search Kit index has a <strong>text analysis properties dictionary</strong> that defines a variety of index characteristics and capabilities. Among these are phrase-based searching, synonyms, words to exclude from an index (“stopwords”), and so on.</p><p> You specify the text analysis properties dictionary for an index using the <em>inAnalysisProperties</em> parameter in either the <code><a href="../../../Reference/SearchKit/Reference/reference.html#//apple_ref/doc/c_ref/SKIndexCreateWithURL" target="_top">SKIndexCreateWithURL</a></code> or <code><a href="../../../Reference/SearchKit/Reference/reference.html#//apple_ref/doc/c_ref/SKIndexCreateWithMutableData" target="_top">SKIndexCreateWithMutableData</a></code> function. The available keys for the dictionary are defined in the <span class="content_text"><a href="../../../Reference/SearchKit/Reference/reference.html#//apple_ref/doc/constant_group/Text_Analysis_Keys" target="_top">Text Analysis Keys</a></span> constants, described in <em><a href="../../../Reference/SearchKit/index.html#//apple_ref/doc/uid/TP30000904" target="_top">Search Kit Reference</a></em>.</p><p>You must ensure that the set of attributes you confer on an index makes sense. For example, because Vector indexes do not support phrase-based searching, do not use a <code>kCFBooleanTrue</code> value for the  <code><a href="../../../Reference/SearchKit/Reference/reference.html#//apple_ref/doc/c_ref/kSKProximityIndexing" target="_top">kSKProximityIndexing</a></code> key in a Vector index's text analysis properties dictionary.</p><a name="//apple_ref/doc/uid/TP40002844-DontLinkElementID_19" title="Designing Index Architecture"></a><h4>Designing Index Architecture</h4><p>To design the index architecture for your application, begin by answering these questions:</p><ul class="spaceabove"><li class="li"><p>Which documents should be in a given index?</p></li><li class="li"><p>Should the indexes be persistent or memory based?</p></li><li class="li"><p>Which sorts of queries should the indexes support?</p></li><li class="li"><p>Do you want to filter the content as it is added to the index (using stopwords or a minimum term length)?</p></li><li class="li"><p>Do you need a list of term substitutions?</p></li></ul><p>Your answers to these questions will guide your choice of index type and text analysis properties.</p><a name="//apple_ref/doc/uid/TP40002844-DontLinkElementID_20" title="Flushing and Compacting Indexes"></a><h4>Flushing and Compacting Indexes</h4><p>When your application adds or removes a document URL object from an index, the on-disk or memory-based representation of the index becomes stale. A search on an index in such a state won’t have access to the nonflushed updates. The solution is to call the <code><a href="../../../Reference/SearchKit/Reference/reference.html#//apple_ref/doc/c_ref/SKIndexFlush" target="_top">SKIndexFlush</a></code> function before searching. <code><a href="../../../Reference/SearchKit/Reference/reference.html#//apple_ref/doc/c_ref/SKIndexFlush" target="_top">SKIndexFlush</a></code> flushes index-update information and commits memory-based index caches to disk, in the case of an on-disk index, or to a memory object, in the case of a memory-based index. In both cases, calling this function makes the state of an index consistent.</p><p>Indexes can develop <strong>fragmentation</strong> (that is, they can become bloated with unused text) as your application adds and removes document URL objects. Search Kit <strong>compacts</strong> an index, if needed, when your application calls the <code><a href="../../../Reference/SearchKit/Reference/reference.html#//apple_ref/doc/c_ref/SKIndexCompact" target="_top">SKIndexCompact</a></code> function. Because this function typically takes significant time to do its work, call it only when you find that an index is significantly fragmented.</p><p>To check for bloat you can take advantage of the way Search Kit allocates document IDs. It does so starting at 1 and without reusing previously allocated IDs for an index. Simply compare the highest document ID, found with the <code><a href="../../../Reference/SearchKit/Reference/reference.html#//apple_ref/doc/c_ref/SKIndexGetMaximumDocumentID" target="_top">SKIndexGetMaximumDocumentID</a></code> function, with the current document count, found with the <code><a href="../../../Reference/SearchKit/Reference/reference.html#//apple_ref/doc/c_ref/SKIndexGetDocumentCount" target="_top">SKIndexGetDocumentCount</a></code> function.</p><a name="//apple_ref/doc/uid/TP40002844-BABIDFFB" title="How Search Kit Performs Searches"></a><h3>How Search Kit Performs Searches</h3><p>Once you have a searchable corpus in the form of populated indexes, you’re ready to search. Searching is a multistep process:</p><ol class="ol"><li class="li"><p>Get the user’s query, including, if applicable, their specification of where to search.</p></li><li class="li"><p>Create (or reuse) an appropriate index group.</p></li><li class="li"><p>Update the indexes to query, as necessary.</p></li><li class="li"><p>Invoke the search.</p></li><li class="li"><p>Display results based on information from the returned search object, and continue to update the results as appropriate by continuing to query the search object.</p></li></ol><p>This section describes working with indexes and focuses on the general case of searching multiple indexes. It also describes the various types of query available in Search Kit and briefly describes working with search results. </p><a name="//apple_ref/doc/uid/TP40002844-BABHBCEF" title="Searching Multiple Indexes"></a><h4>Searching Multiple Indexes</h4><p>In many cases, applications need to invoke a search over multiple indexes. For example, say a car buyer wants to learn about cars from America, Germany, and Japan. Your application might manage its automobile data by using a separate index for each country of manufacture. In this case, you'd include indexes from the specified countries in the user's search.</p><p>As a slightly more complex example, say you have a large set of static webpages (not generated on demand from a database) composing an online catalog. Each page lists several products. Each product, in turn, might be a member of one or more product categories—sports equipment, home and garden, sale items, and so on. Say you’d like your users to be able to search by product name, price, and category.</p><p>One strategy for providing search on such a website would be to define and appropriately tag each individual product description as a document. Recall that, when using Search Kit, a "document" is anything your application defines it to be. You would include tagging within each product description indicating product name, price, and a list of categories the product belongs to.</p><p>You could then create a separate index across the website for each such field of information, along with an index of all the visible text content. A user's search could specify which fields to search on, and your application would add the corresponding indexes to the index group used for the search.</p><p>Search Kit's asynchronous architecture lets you search multiple indexes in sequence or in parallel, depending on your application's needs and on the structure of your information.</p><ul class="spaceabove"><li class="li"><p>If your application is searching multiple indexes in a single file or in separate files but all on the same physical disk, Apple recommends that you search the indexes in sequence for best performance.</p></li><li class="li"><p>When an index group is distributed across multiple disks or across a network, or when the indexes are all in memory, search the indexes in parallel.</p></li></ul><p>For a parallel search, your application can use a separate thread for each index to be searched. Alternatively, you can create a search object for each index in a group, then repeatedly query the search objects in turn by making use of the timeout option in the <code><a href="../../../Reference/SearchKit/Reference/reference.html#//apple_ref/doc/c_ref/SKSearchFindMatches" target="_top">SKSearchFindMatches</a></code> function.</p><a name="//apple_ref/doc/uid/TP40002844-BABIHICA" title="Queries"></a><h4>Queries</h4><p>Search Kit responds to a query by interpreting the query's terms, the explicit and implicit operators, and the order of the query's terms and operators. Using an enhanced, Google-like syntax, Search Kit supports a variety of types of query as well as arbitrary combinations of these types. For example, the following query includes Boolean, prefix, and suffix searching:</p><p><code>appl* OR *ing</code></p><p>Using the asterisk (<code>*</code>) wildcard operator and the Boolean <code>OR</code> operator, this query returns documents containing words that begin with “appl” as well as documents that contain words that end with “ing”. </p><div class="notebox"><a name="//apple_ref/doc/uid/TP40002844-DontLinkElementID_36" title="Note"></a><p><strong>Note:</strong>&nbsp;In versions of Mac OS X prior to version 10.4, Tiger, Search Kit used the now-deprecated <code><a href="../../../Reference/SearchKit/DeprecationAppendix/AppendixADeprecatedAPI.html#//apple_ref/doc/c_ref/SKSearchResultsCreateWithQuery" target="_top">SKSearchResultsCreateWithQuery</a></code> function. That function required explicit setting of search type by way of a search type parameter. Refer to <em><a href="../../../Reference/SearchKit/index.html#//apple_ref/doc/uid/TP30000904" target="_top">Search Kit Reference</a></em> for more information.</p></div><p>The following table lists the operators for nonsimilarity searches. (Similarity searches do not respond to operators.) Synonyms, separated by commas here, all have the same order of evaluation.</p><a name="//apple_ref/doc/uid/TP40002844-SW1" title="Table 2-1Query operators in Search Kit, from highest to lowest precedence"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><a name="//apple_ref/doc/uid/TP40002844-BABDHJDC" title="Table 2-1Query operators in Search Kit, from highest to lowest precedence"></a><strong>Table 2-1&nbsp;&nbsp;</strong>Query operators in Search Kit, from highest to lowest precedence</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Operator†</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Meaning</p></th></tr><tr><td  scope="row"><p><code>"</code></p></td><td ><p>Opening and closing delimiter for phrase-based searching.</p></td></tr><tr><td  scope="row"><p><code>(</code>, <code>)</code></p></td><td ><p>Opening and closing delimiters for logical grouping.</p></td></tr><tr><td  scope="row"><p><code>!</code>, <code>NOT</code></p></td><td ><p>Boolean <code>NOT</code>.</p></td></tr><tr><td  scope="row"><p><code>&amp;</code>, <code>AND</code>, <code>&lt;space></code></p></td><td ><p>Boolean <code>AND</code>. The <code>&lt;space></code> character represents a Boolean operator when there are terms to both sides of the <code>&lt;space></code> character. In this case, <code>&lt;space></code> represents a Boolean <code>AND</code> by default, or a Boolean <code>OR</code> if specified by <code><a href="../../../Reference/SearchKit/Reference/reference.html#//apple_ref/doc/c_ref/kSKSearchOptionSpaceMeansOR" target="_top">kSKSearchOptionSpaceMeansOR</a></code>.</p></td></tr><tr><td  scope="row"><p><code>|</code></p></td><td ><p>Boolean inclusive <code>OR</code>.</p></td></tr><tr><td  scope="row"><p><code>*</code></p></td><td ><p>Wildcard for prefix or suffix; surround term with wildcard characters for substring search. Ignored in phrase-based searches.</p></td></tr></table></div><p>A Search Kit query can be as complex as you want, combining all the various operator types. For the purposes of explanation, this section discusses each query type separately.</p><p>The simplest sort of query consists of:</p><ul class="spaceabove"><li class="li"><p>One or more terms</p></li><li class="li"><p>No operators other than the <code>&lt;space></code> character between the terms</p></li><li class="li"><p>The default, <code>AND</code>-based behavior for &lt;space></p></li></ul><p>Such a <strong>simple search</strong> looks for documents in the targeted set of indexes that contain all of the terms entered in the query string. Indexed terms match the query only if they match exactly. For example, if you search for “fooba” and a document contains “foobar” but not “fooba,” you don’t get a hit. <span class="content_text">Figure 2-5</span> depicts the behavior of a simple search.</p><br/><div><a name="//apple_ref/doc/uid/TP40002844-BABIGIIB" title="Figure 2-5A simple search"></a><p><strong>Figure 2-5&nbsp;&nbsp;</strong>A simple search</p><img src = "../art/exactmatchsearch_results.jpg" alt = "An exact-match search" ></div><br/><p>If you specify the "space means <code>OR</code>" option using the <code><a href="../../../Reference/SearchKit/Reference/reference.html#//apple_ref/doc/c_ref/kSKSearchOptionSpaceMeansOR" target="_top">kSKSearchOptionSpaceMeansOR</a></code> constant in the <code><a href="../../../Reference/SearchKit/Reference/reference.html#//apple_ref/doc/c_ref/SKSearchCreate" target="_top">SKSearchCreate</a></code> function, Search Kit finds not only documents that contain all of the query terms. It also finds documents that contain some, but not all, of the query terms; it ranks such documents lower than documents that contain all the query terms.</p><p>A <strong>prefix search</strong> looks for documents represented in the targeted set of indexes that contain terms beginning with the characters in a query. This is especially useful for the sort of live searching you see in Mail and Xcode. As the user types each successive character, the found set narrows. See <span class="content_text">Figure 2-6</span>.</p><br/><div><a name="//apple_ref/doc/uid/TP40002844-BABCBCFF" title="Figure 2-6A prefix search"></a><p><strong>Figure 2-6&nbsp;&nbsp;</strong>A prefix search</p><img src = "../art/prefixsearch_results.jpg" alt = "A prefix search" ></div><br/><p>Prefix searching looks at each term in the query separately, <code>AND</code>ing multiple terms by default, and matches on the beginnings of terms in the currently targeted set of indexes. In <span class="content_text">Figure 2-6</span>, the word “bar” in the circled document is the only term that begins with the same characters as in the query, “ba.”</p><p>To invoke a prefix search directly, a user would append the asterisk (*) character to the end of each term to be used as a prefix. An application can implicitly add the trailing asterisk to query terms before sending the query on to Search Kit. </p><p>Here’s another example of prefix searching. If you have mail messages from Billy Bob, Billy Joe, and Big Chief, you could enter “<code>Bo*</code>” to find all of Billy Bob’s messages, or “<code>Jo*</code>” to find Billy Joe’s messages. Entering “<code>Bi*</code>” would match messages from all three friends. “<code>Bi* OR Ch*</code>” would match Big Chief with the highest relevance but would also match Billy Bob and Billy Joe because they each contain one term matched by one of the query terms. The query “<code>illy*</code>” wouldn’t match any of the mail messages.</p><p>Very similar to a prefix query is a <strong>suffix search</strong>. Suffix searching looks at each term in the query separately, <code>AND</code>ing multiple terms by default, and matches on the <em>ends</em> of terms in the currently targeted set of indexes. Again the wildcard character is the asterisk, but placed before the term as in "<code>*illy</code>". And again you can design your application so that users explicitly type the asterisk before terms, or you can add the asterisk implicitly before handing the query off to Search Kit.</p><p>A <strong>Boolean search</strong> offers full Boolean search functionality using the operators described in <span class="content_text">Table 2-1</span>. You can design your application's interface so that users type the operators directly, or you can provide an alternate interface—converting the query to use the Search Kit standard operator syntax before handing off the query to the <code><a href="../../../Reference/SearchKit/Reference/reference.html#//apple_ref/doc/c_ref/SKSearchCreate" target="_top">SKSearchCreate</a></code> function.</p><p>The Boolean search in <span class="content_text">Figure 2-7</span> employs grouping operators as well as Boolean operators.</p><br/><div><a name="//apple_ref/doc/uid/TP40002844-BABEGBEB" title="Figure 2-7A Boolean search"></a><p><strong>Figure 2-7&nbsp;&nbsp;</strong>A Boolean search</p><img src = "../art/booleansearch_results.jpg" alt = "A Boolean search" ></div><br/><p>In the figure, the query in the search field indicates a request for documents that contain the exact term "foobar" as well as documents that contain both the term "foo" and the term "bar".</p><p>A <strong>phrase search</strong> works in inverted (and inverted-vector) indexes that were created with a true value for the <code><!--a  -->kSKPromimityIndexing<!--/a--></code> key in the text analysis properties dictionary. Such an index stores the position of each term in each document, along with the information otherwise stored in an inverted (or an inverted-vector) index.</p><p>Despite the name of the <code><!--a  -->kSKPromimityIndexing<!--/a--></code> text analysis properties key, Search Kit does not currently support arbitrary proximity searching. That is, you cannot search for documents in which two words are near each other but not adjacent. Search Kit supports only phrase searching.</p><p>When a user enters "Apple pie" as a query—including the surrounding quotation marks—Search Kit tries to find documents containing this exact phrase. See <span class="content_text"><a href="searchKit_concepts.html#//apple_ref/doc/uid/TP40002844-SW2">Figure 2-8</a></span> for an illustration of phrase searching.</p><br/><div><a name="//apple_ref/doc/uid/TP40002844-SW2" title="Figure 2-8A phrase-based search"></a><p><strong>Figure 2-8&nbsp;&nbsp;</strong>A phrase-based search</p><img src = "../art/phrasesearch_results.jpg" alt = "A Boolean search" ></div><br/><a name="//apple_ref/doc/uid/TP40002844-DontLinkElementID_21" title="Search Results"></a><h4>Search Results</h4><p>Immediately upon invocation of a query—that is, upon creation of a search object—Search Kit asynchronous searching accumulates results into the search object. Using the <code><a href="../../../Reference/SearchKit/Reference/reference.html#//apple_ref/c/func/SKSearchFindMatches" target="_top">SKSearchFindMatches</a></code> function, your application retrieves results from the search object as they come in.</p><p>A search does not return documents per se. It returns document IDs. Your application, in turn, uses the document IDs to get document URL objects from the indicated indexes. The document URL objects, in turn, refer to the documents that satisfy the query.</p><p>The Search Kit framework does not provide display functionality. Instead, your application uses other Mac OS X frameworks to present the basic result data in the way you determine to be most useful. Tables are a popular way to display results, but you could just as well present search hits in outline form, as a graph, or as audible feedback.</p>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../searchKit_basics/searchKit_basics.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../searchKit_tasks/searchKit_tasks.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2004, 2005 Apple Computer, Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2005-12-06<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/UserExperience/Conceptual/SearchKitConcepts/searchKit_concepts/searchKit_concepts.html%3Fid%3DTP40001071-2.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/UserExperience/Conceptual/SearchKitConcepts/searchKit_concepts/searchKit_concepts.html%3Fid%3DTP40001071-2.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/UserExperience/Conceptual/SearchKitConcepts/searchKit_concepts/searchKit_concepts.html%3Fid%3DTP40001071-2.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>