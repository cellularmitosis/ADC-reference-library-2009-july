<!-- Generated by Harlequin WebMaker 2.2.3 (30-Apr-1996)
Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->
<HTML> <HEAD>
<TITLE>The Direct Data Area Switching Method</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING34></A>


<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="RTArch-33.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="RTArch-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="RTArch-147.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="RTArch-35.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="RTArch-2.html"><B>Mac OS Runtime Architectures</B></A> / <BR><DD><A HREF="RTArch-27.html"><B>Chapter 2 - Indirect Addressing in the CFM-Based Architecture</B></A> / <A HREF="RTArch-32.html"><B>CFM-68K Implementation</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING34-0></A>
<H2>The Direct Data Area Switching Method</H2>
 In the CFM-68K runtime environment, the standard direct data area switching procedure takes the following steps.<P>
<OL>
<LI>The program uses the transition vector to jump to the external entry point of the procedure. At this point, the A1 register points to the second word of the transition vector, which contains the address of the direct data area.
<LI>The external entry point loads the A5 register with the new direct data area address (using the register A1) and then enters the internal entry point.
<LI>The function's prolog code is executed, part of which saves a copy of A5 in case the function must in turn make other indirect or cross-fragment calls. 
<LI>The program executes the function. If the routine makes any indirect or cross-fragment calls, it restores the saved value of A5 after each such call. 
<LI>After executing the function, the program then runs the epilog and throws away its local variables (including the saved copy of A5). 
<LI>After running the epilog, the program returns to the calling fragment. <P>
</OL>
 Direct callers and indirect callers can enter the procedure at different locations, so you can set up slightly different prolog sequences depending on the type of call.<P>
 <A HREF=#MARKER-9-54>Listing 2-3</A> illustrates glue code surrounding a simple function call.<P>
<B>Listing 2-3  <A NAME=MARKER-9-54></A>Glue code for a simple function</B><P>
<PRE>
MOVE.L         (A1), A5          ; set up A5 from A1
LINK           A6, #LOCALS       ; (this is the internal entry point)
MOVEM.L        &lt;REGSET/A5&gt;,-(A7) ; save new A5

&lt;body of function  here&gt;

MOVEM.L        (A7)+, &lt;REGSET&gt;   ; note A5 not restored here
UNLK           A6
RTD            #PARAM_CT
</PRE>
 If the function itself makes indirect or cross-fragment calls, you must save the A5 value before the call and restore it after each return. <A HREF=#MARKER-9-56>Listing 2-4</A> shows how to handle an indirect call within an indirectly called function:<A NAME=MARKER-9-55></A><P>
<B>Listing 2-4  <A NAME=MARKER-9-56></A>Making an indirect call from within an indirectly called function</B><P>
<PRE>
MOVE.L         (A1), A5          ; set up A5 from A1
LINK           A6, #LOCALS       ; the reserved space
MOVEM.L        D7/D6/A5, -(A7)   ; save new A5 at -12(A6)

...

                                 ; now making cross-fragment call to
                                 ; the imported function mooCall
MOVE.L         _@mooCall(A5), A1 ; load transition vector into A1 via
                                 ;  the pointer to the transition vector
MOVE.L         (A1)+,A0          ; get code address
JSR            (A0)              ; call function
MOVE.L         -12(A6), A5       ; restore A5 from saved location

...

                                 ; no A5 restore here (but pop saved
MOVEM.L        (A7)+, D7/D6      ; data registers)
UNLK           A6                ; UNLK compensates for unbalanced stack
RTD            #PARAM_CT
</PRE>
<DL>
<DT><B>Note</B>
<DD>You do not have to save your A5 value on the stack. In some cases (such as when you know the called procedure will make a lot of indirect calls) it may be advantageous to save your A5 value in a data register, or even another address register.<EM></EM><EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
 In certain cases, you may omit some of the switching steps to optimize your code. Three different optimization possibilities exist:<P>
<UL>
<LI>You can choose to not save A5 in the prolog. This choice is useful only when you are certain that the routine you are calling will never make any indirect or cross-fragment calls and thus will never need to restore A5. Routines using this optimization may still use A5, however.
<LI>You can remove the external entry point and transition vector. This choice removes the initial <CODE>MOVE.L (A1), A5</CODE> instruction and is equivalent to tagging the routine as <CODE>internal</CODE> during a compile. You should use this optimization only if you are sure that the routine will never be called indirectly or from another fragment.
<LI>You can remove the <CODE>MOVE.L (A1), A5</CODE> instruction but keep the transition vector. This optimization works only for calling routines that never use the A5 register during execution (for example, a leaf routine that doesn't access global variables). Note that all the following actions do use A5 and disqualify routines from using this option: <P>
<UL>
<LI>Direct (in-fragment) calls, because the called procedure may use A5, or the call may have to go through the jump table (which uses A5). Note that segmented shared libraries use the jump table if calling direct between two code segments. 
<LI>Any cross-fragment call or access to an imported data item, because the CFM-68K code uses the A5 register to access such data items indirect<A NAME=MARKER-2-50></A>ly. <A NAME=MARKER-2-58></A><P>
</UL>
</UL>
 <P>
</BLOCKQUOTE>
<HR>
<center>
<A HREF="RTArch-33.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="RTArch-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="RTArch-147.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="RTArch-35.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="RTArch-3.html">&copy; Apple Computer, Inc.</A><br>11 MARCH 1997<P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML> 
