/*	File:		StreamLogWatcher.c	Contains:	A program to display information logged to the STREAMS log module.	Written by:	Quinn "The Eskimo!"	Copyright:	© 1998 by Apple Computer, Inc., all rights reserved.	Change History (most recent first):	You may incorporate this sample code into your applications without	restriction, though the sample code has been provided "AS IS" and the	responsibility for its operation is 100% yours.  However, what you are	not permitted to do is to redistribute the source as "DSC Sample Code"	after having made changes. If you're going to re-distribute the source,	we require that you make it clear in the source that the code was	descended from Apple Sample Code, but that you've made changes.*/#define qDebug 1/////////////////////////////////////////////////////////////////////// Pick up the standard C stuff.#include <stdio.h>#include <string.h>/////////////////////////////////////////////////////////////////////// Pick up standard OT APIs.#include <OpenTransportProviders.h>#include <OpenTransportProtocol.h>/////////////////////////////////////////////////////////////////////// Pick up the log engine prototypes.#include "OTMemoryReserve.h"#include "LogEngine.h"/////////////////////////////////////////////////////////////////////// OTDebugStr is defined in a wacky OT library.  Let's just use // lowercase debugstr instead.#define OTDebugStr debugstr/////////////////////////////////////////////////////////////////////// Previouly this file used to include "OpenTptModule.h" to get to // strlog.  However, with the conversion over to Universal Interfaces // for OT it is no longer possible to include both "OpenTransportKernel.h" // and "OpenTransport.h"  This is generally a good thing because it // prevents folks from doing what we’re doing, namely linking to kernel // interfaces in client code.  However, this is just a test program so, // while not technically legal, it is reasonable to do this here.  Rather // than try to #define our way out of trouble when including // "OpenTransportKernel.h", I just extracted the prototype for strlog // and included it here.EXTERN_API_C( OTInt32 )strlog                          (OTInt32                mid,                                 OTInt32                sid,                                 OTInt32                level,                                 OTUInt32               flags,                                 char *                 fmt,                                 ...);// IMPORTANT:// This linking to both client and kernel libraries is also the cause // of the 99 duplicate symbol link warnings when you link this project. // For the link to work correct you have to ensure that the Link Order // panel has the OpenTransportLib listed before OpenTptModuleLib./////////////////////////////////////////////////////////////////////static pascal void PrintLogEntry(LogEntryPtr thisEntry, void *refCon){	#pragma unused(refCon)	#pragma unused(thisEntry)		printf("••• got message “%s”\n", ((char *) thisEntry) + sizeof(LogEntry));}/////////////////////////////////////////////////////////////////////// This code was stolen directly from "OTStreamLogViewer.c".  See that // module for an explanation of what’s going on here.enum {	kBytesReservedForToolboxInApplicationZone = 100L * 1024L,	kOTMemoryReserveChunkSize = 128L * 1024L,	kOTMemoryReserveMinChunks = 6,	kOTMemoryReserveMaxChunks = 100};static OSStatus InitOpenTransportWithMemoryLimit(void){	OSStatus err;	OTClientContextPtr junkClientContext;		err = InitOpenTransportInContext(kInitOTForApplicationMask, &junkClientContext);	if (err == noErr) {		err = InitOTMemoryReserve(kBytesReservedForToolboxInApplicationZone, kOTMemoryReserveChunkSize, 										   kOTMemoryReserveMinChunks, kOTMemoryReserveMaxChunks,										   nil);		if (err != noErr) {			CloseOpenTransportInContext(nil);		}	}	return err;}static void PrintHelp(void){	printf("s) start/stop logging\n");	printf("l) log something\n");	printf("L) log 10 somethings\n");	printf("i) idle the kernel (don't ask why you have to do this!)\n");	printf("p) print new log entries\n");	printf("q) quit\n");	printf("?) print help\n");	printf("\n");}extern void main(void){	OSStatus err;	Boolean quitNow;	char command[256];	int i;		printf("Hello Cruel World\n");		err = InitOpenTransportWithMemoryLimit();	if (err == noErr) {			PrintHelp();		quitNow = false;		do {			printf("Enter command:\n");			gets(command);			switch (command[0]) {				case '?':					PrintHelp();					break;				case 's':					if ( ! LoggingActive() ) {						printf("StartLogging\n");						fflush(stdout);						err = StartLogging(true, 0, nil);						if (err != noErr) {							printf("Error starting logging %ld\n", err);							err = noErr;						}					} else {						printf("StopLogging\n");						fflush(stdout);						StopLogging();					}					break;				case 'i':					OTIdle();					break;				case 'p':					ForEachNewLogEntry(PrintLogEntry, nil);					break;				case 'q':					quitNow = true;					break;				case 'l':					printf("Calling strlog\n");					strlog(1, 2, 3, SL_TRACE | SL_ERROR, "Hello Cruel World!");					break;				case 'L':					for (i = 0; i < 10; i++) {						printf("Calling strlog\n");						strlog(1, 2, 3, SL_TRACE | SL_ERROR, "Hello Cruel World!");					}					break;				case '!':					for (i = 0; i < 32000; i++) {						// OTIdle();						strlog(1, 2, 3, SL_TRACE | SL_ERROR, "Hello Cruel World!");						if ( (i % 100) == 0) {							printf(".");							fflush(stdout);						}					}					break;				default:					printf("Huh?\n");					break;			}		} while ( ! quitNow );			if ( LoggingActive() ) {			printf("StopLogging\n");			fflush(stdout);			StopLogging();		}			TermOTMemoryReserve();		CloseOpenTransportInContext(nil);	}		if (err == noErr) {		printf("Success!\n");	} else {		printf("Failed with error %ld.\n", err);	}}