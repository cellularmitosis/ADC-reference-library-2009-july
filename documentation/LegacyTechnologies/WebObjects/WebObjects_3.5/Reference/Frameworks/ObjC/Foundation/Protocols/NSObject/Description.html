<html><head><title></title></head>

<body bgcolor="#ffffff">

 

 

<a name="82"></a>

<h1>

<FONT COLOR="#000066">

 <a name="//apple_ref/occ/intf/NSObject">NSObject</a>

</FONT>

</h1>

<p><B>Adopted By:	</B><BR>

NSObject



<p><B>Declared In:	</B><BR>

Foundation/NSObject.h



<p><a name="112">

<a name="description"></a>

<H2>Protocol Description

</H2>

</a>The NSObject protocol groups methods that are fundamental to all Objective-C objects. If an object conforms to this protocol, it can be considered a first-class object in NEXTSTEP. Such an object can be asked about its: <p>

<ul><li>Class, and the place of its class in the inheritance hierarchy <br>

<li>Conformance to protocols<br>

<li>Ability to respond to a particular message<br>

</ul>In addition, objects that conform to this protocol-with its retain, release, and autorelease methods-can also integrate with the object-management and deallocation scheme defined in the Foundation Kit. (See the introduction to the Foundation Kit for more information.) Thus, an object that conforms to the NSObject protocol can be managed by container objects like those defined by NSArray and NSDictionary.<p>

NEXTSTEP's root class, NSObject, adopts this protocol, so virtually all objects in NEXTSTEP have the features described by this protocol.<p>

<a name="119">

<HR WIDTH=50% ALIGN=LEFT>

<h2>Method Types

</h2>

</a><dl>

<dt>Identifying classes<dd><dl><dd><dl><dd><dl><dd><dl>

<dt><a href="#//apple_ref/occ/intfm/NSObject/class">- class</a><dt><a href="#//apple_ref/occ/intfm/NSObject/superclass">- superclass</a></dl></dd>

</dl></dd></dl></dd></dl></dd><dt>Identifying and comparing objects<dd><dl><dd><dl><dd><dl><dd><dl>

<dt><a href="#//apple_ref/occ/intfm/NSObject/isEqual:">- isEqual:</a><dt><a href="#//apple_ref/occ/intfm/NSObject/hash">- hash</a><dt><a href="#//apple_ref/occ/intfm/NSObject/self">- self</a></dl></dd>

</dl></dd></dl></dd></dl></dd><dt>Determining allocation zones<dd><dl><dd><dl><dd><dl><dd><dl>

<dt><a href="#//apple_ref/occ/intfm/NSObject/zone">- zone</a></dl></dd>

</dl></dd></dl></dd></dl></dd><dt>Managing reference counts<dd><dl><dd><dl><dd><dl><dd><dl>

<dt><a href="#//apple_ref/occ/intfm/NSObject/retain">- retain</a><dt><a href="#//apple_ref/occ/intfm/NSObject/release">- release</a><dt><a href="#//apple_ref/occ/intfm/NSObject/autorelease">- autorelease</a><dt><a href="#//apple_ref/occ/intfm/NSObject/retainCount">- retainCount</a></dl></dd>

</dl></dd></dl></dd></dl></dd><dt>Testing class functionality<dd><dl><dd><dl><dd><dl><dd><dl>

<dt><a href="#//apple_ref/occ/intfm/NSObject/respondsToSelector:">- respondsToSelector:</a></dl></dd>

</dl></dd></dl></dd></dl></dd><dt>Testing inheritance relationships<dd><dl><dd><dl><dd><dl><dd><dl>

<dt><a href="#//apple_ref/occ/intfm/NSObject/isKindOfClass:">- isKindOfClass:</a><dt><a href="#//apple_ref/occ/intfm/NSObject/isMemberOfClass:">- isMemberOfClass:</a></dl></dd>

</dl></dd></dl></dd></dl></dd><dt>Testing protocol conformance<dd><dl><dd><dl><dd><dl><dd><dl>

<dt><a href="#//apple_ref/occ/intfm/NSObject/conformsToProtocol:">- conformsToProtocol:</a></dl></dd>

</dl></dd></dl></dd></dl></dd><dt>Describing objects<dd><dl><dd><dl><dd><dl><dd><dl>

<dt><a href="#//apple_ref/occ/intfm/NSObject/description">- description</a></dl></dd>

</dl></dd></dl></dd></dl></dd><dt>Sending messages<dd><dl><dd><dl><dd><dl><dd><dl>

<dt><a href="#//apple_ref/occ/intfm/NSObject/performSelector:">- performSelector:</a><dt><a href="#//apple_ref/occ/intfm/NSObject/performSelector:withObject:">- performSelector:withObject:</a><dt><a href="#//apple_ref/occ/intfm/NSObject/performSelector:withObject:withObject:">- performSelector:withObject:withObject:</a></dl></dd>

</dl></dd></dl></dd></dl></dd><dt>Identifying proxies<dd><dl><dd><dl><dd><dl><dd><dl>

<dt><a href="#//apple_ref/occ/intfm/NSObject/isProxy">- isProxy</a></dl></dd>

</dl></dd></dl></dd></dl></dd></dl>

<HR WIDTH=50% ALIGN=LEFT>

<a name="instm"></a>

<h2>Instance Methods</h2>  





<a name="150"></a>

<h3>

 <a name="//apple_ref/occ/intfm/NSObject/autorelease">autorelease</a>

</h3>

- (id)<code>autorelease

</code>

<P>Adds the receiver to the current autorelease pool and returns <code>self</code>. You add an object to an autorelease pool so that it will receive a <code>release</code> message-and thus might be deallocated-when the pool is destroyed. For more information on the autorelease mechanism, see the NSAutoreleasePool class specification.<p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/intfm/NSObject/retain">- retain</a></code>, <a href="#//apple_ref/occ/intfm/NSObject/retainCount"><code>- retainCount</a>

</code><p><hr WIDTH=25% ALIGN=LEFT>

<a name="154"></a>

<h3> <a name="//apple_ref/occ/intfm/NSObject/class">class</a></h3>

- (Class)<code>class

</code>

<P>Returns the class object for the receiver's class.<p>

<B>See also: </B>  

<code><a href="../../Classes/NSObject/NSObject.html#//apple_ref/occ/clm/NSObject/class" target="_top">+ clas</code><code>s</code> (NSObject class)</a>

<p><hr WIDTH=25% ALIGN=LEFT>

<a name="158"></a>

<h3> <a name="//apple_ref/occ/intfm/NSObject/conformsToProtocol:">conformsToProtocol:</a></h3>

- (BOOL)<code>conformsToProtocol:</code>(Protocol *)<em>aProtocol

</em>

<P>Returns YES if the receiving class conforms to <em>aProtocol</em>, NO otherwise.  This method works identically to the <code>conformsToProtocol:</code> class method declared in NSObject.  It's provided as a convenience so that you don't need to get the class object to find out whether an instance can respond to a given set of messages.<p>

<B>See also: </B>  

<code><a href="../../Classes/NSObject/NSObject.html#//apple_ref/occ/clm/NSObject/conformsToProtocol:" target="_top">+ conformsToProtocol</code><code>:</code> (NSObject class)</a>

<p><hr WIDTH=25% ALIGN=LEFT>

<a name="162"></a>

<h3> <a name="//apple_ref/occ/intfm/NSObject/description">description</a></h3>

- (NSString *)<code>description

</code>

<P>Returns an NSString object that describes the contents of the receiver.  The debugger's <code>print-object</code> command indirectly invokes this method to produce a textual description of an object.<p>

<hr WIDTH=25% ALIGN=LEFT>

<a name="165"></a>

<h3> <a name="//apple_ref/occ/intfm/NSObject/hash">hash</a></h3>

- (unsigned)<code>hash

</code>

<P>Returns an integer that can be used as a table address in a hash table structure.  If two objects are equal (as determined by the <code>isEqual:</code> method), they must have the same hash value. This last point is particularly important if you define <code>hash</code> in a subclass and intend to put instances of that subclass into a collection.<p>

If a mutable object is added to a collection that uses hash values to determine the object's position in the collection, the value returned by the <code>hash</code> method of the object must not change while the object is in the collection. To accomplish this, either the <code>hash</code> method must not rely on any of the object's internal state information or you must make sure that the object's internal state information does not change while the object is in the collection. (Note that it can be difficult to know whether or not a given object is in a collection.)<p>

<hr WIDTH=25% ALIGN=LEFT>

<a name="169"></a>

<h3> <a name="//apple_ref/occ/intfm/NSObject/isEqual:">isEqual:</a></h3>

- (BOOL)<code>isEqual:</code>(id)<em>anObject

</em>

<P>Returns YES if the receiver and <em>anObject</em> are equal, NO otherwise.  This method defines what it means for an instance to be equal.  For example, a container object might define two containers as equal if their corresponding objects all respond YES to an <code>isEqual:</code> request.  See the NSData, NSDictionary, NSArray, and NSString class specifications for examples of the use of this method.<p>

<hr WIDTH=25% ALIGN=LEFT>

<a name="172"></a>

<h3> <a name="//apple_ref/occ/intfm/NSObject/isKindOfClass:">isKindOfClass:</a></h3>

- (BOOL)<code>isKindOfClass:</code>(Class)<em>aClass

</em>

<P>Returns YES if the receiver is an instance of <em>aClass</em> or an instance of any class that inherits from <em>aClass</em>, NO otherwise.  For example, in this code, <code>isKindOfClass:</code> would return YES because, in the Foundation Kit, the NSArchiver class inherits from NSCoder:<p>

<blockquote><pre>NSMutableData *myData = [NSMutableData dataWithCapacity:30];<br>id anArchiver = [[NSArchiver alloc] initForWritingWithMutableData:myData];<br>if ( [anArchiver isKindOfClass:[NSCoder class]] )<br>    ...

</pre></blockquote><p>Because instance methods defined in the root class can be sent to class objects, when the receiver is a class object, this method returns YES if <em>aClass</em> is NSObject, NO otherwise.<p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/intfm/NSObject/isMemberOfClass:">- isMemberOfClass:</a>

</code><p><hr WIDTH=25% ALIGN=LEFT>

<a name="178"></a>

<h3> <a name="//apple_ref/occ/intfm/NSObject/isMemberOfClass:">isMemberOfClass:</a></h3>

- (BOOL)<code>isMemberOfClass:</code>(Class)<em>aClass

</em>

<P>Returns YES if the receiver is an instance of <em>aClass</em>, NO otherwise.  For example, in this code, <code>isMemberOfClass:</code> would return NO:<p>

<blockquote><pre>NSMutableData *myData = [NSMutableData dataWithCapacity:30];<br>id anArchiver = [[NSArchiver alloc] initForWritingWithMutableData:myData];<br>if ([anArchiver isMemberOfClass:[NSCoder class]])<br>    ...

</pre></blockquote><p>When the receiver is a class object, this method returns NO.  Class objects are not "members of" any class.<p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/intfm/NSObject/isKindOfClass:">- isKindOfClass:</a>

</code><p><hr WIDTH=25% ALIGN=LEFT>

<a name="184"></a>

<h3> <a name="//apple_ref/occ/intfm/NSObject/isProxy">isProxy</a></h3>

- (BOOL)<code>isProxy

</code>

<P>Returns NO if the receiver really descends from NSObject, YES otherwise. This method is necessary because sending isKindOfClass: or isMemberOfClass: to an NSProxy object will test the object that the proxy stands-in for, not itself. Use this method to test if the receiver is a proxy (or a member of some other root class).<p>

<hr WIDTH=25% ALIGN=LEFT>

<a name="187"></a>

<h3> <a name="//apple_ref/occ/intfm/NSObject/performSelector:">performSelector:</a></h3>

- (id)<code>performSelector:</code>(SEL)<em>aSelector

</em>

<P>Sends an <em>aSelector</em> message to the receiver and returns the result of the message.  If <em>aSelector</em> is NULL, an NSInvalidArgumentException is raised.<p>

<code>performSelector:</code> is equivalent to sending an <em>aSelector</em> message directly to the receiver.  For example, all three of the following messages do the same thing:<p>

<blockquote><pre>id myClone = [anObject copy];<br>id myClone = [anObject performSelector:@selector(copy)];<br>id myClone = [anObject performSelector:sel_getUid("copy")];

</pre></blockquote><p>However, the <code>performSelector:</code> method allows you to send messages that aren't determined until run time.  A variable selector can be passed as the argument:<p>

<blockquote><pre>SEL myMethod = findTheAppropriateSelectorForTheCurrentSituation();<br>[anObject performSelector:myMethod];

</pre></blockquote><p><em>aSelector</em> should identify a method that takes no arguments.  For methods that return anything other than an object, use NSInvocation.<p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/intfm/NSObject/performSelector:withObject:">- performSelector:withObject:</a></code>, <a href="#//apple_ref/occ/intfm/NSObject/performSelector:withObject:withObject:"><code>- performSelector:withObject:withObject:</a>

</code><p><hr WIDTH=25% ALIGN=LEFT>

<a name="196"></a>

<h3> <a name="//apple_ref/occ/intfm/NSObject/performSelector:withObject:">performSelector:withObject:</a></h3>

- (id)<code>performSelector:</code>(SEL)<em>aSelector</em> <code>withObject:</code>(id)<em>anObject

</em>

<P>Sends an <em>aSelector</em> message to the receiver with <em>anObject</em> as the argument.  If <em>aSelector</em> is NULL, an NSInvalidArgumentException is raised.<p>

This method is the same as <code>performSelector:</code> except that you can supply an argument for  <em>aSelector</em>.  <em>aSelector</em> should identify a method that takes a single argument of type <code>id</code>. For methods with other argument types and return values, use NSInvocation.<p>

<B>See also: </B>  

 <a href="#//apple_ref/occ/intfm/NSObject/performSelector:withObject:withObject:"><code>- performSelector:withObject:withObject:</a></code>, <code><a href="../../Classes/NSObject/NSObject.html#//apple_ref/occ/instm/NSObject/methodForSelector:" target="_top">- methodForSelector</code><code>:</code> (NSObject class)</a>

<p><hr WIDTH=25% ALIGN=LEFT>

<a name="201"></a>

<h3> <a name="//apple_ref/occ/intfm/NSObject/performSelector:withObject:withObject:">performSelector:withObject:withObject:</a></h3>

- (id)<code>performSelector:</code>(SEL)<em>aSelector<br>

</em><code>withObject:</code>(id)<em>anObject<br>

</em><code>withObject:</code>(id)<em>anotherObject

</em>

<P>Sends the receiver an <em>aSelector</em> message with <em>anObject</em> and <em>anotherObject</em> as arguments. If <em>aSelector</em> is NULL, an NSInvalidArgumentException is raised. This method is the same as <code>performSelector:</code> except that you can supply two arguments for  <em>aSelector</em>. <em>aSelector</em> should identify a method that can take two arguments of type <code>id</code>. For methods with other argument types and return values use NSInvocation.<p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/intfm/NSObject/performSelector:withObject:">- performSelector:withObject:</a></code>, <code><a href="../../Classes/NSObject/NSObject.html#//apple_ref/occ/instm/NSObject/methodForSelector:" target="_top">- methodForSelector</code><code>:</code> (NSObject class)</a>

<p><hr WIDTH=25% ALIGN=LEFT>

<a name="205"></a>

<h3> <a name="//apple_ref/occ/intfm/NSObject/release">release</a></h3>

- (oneway void)<code>release

</code>

<P>Decrements the receivers's reference count, and sends it a dealloc message when its reference count reaches 0.<p>

You send release messages only to objects that you "own."  By definition, you own objects that you create using one of the alloc... or copy... methods.  These methods return objects with an implicit reference count of one.  You also own (or perhaps share ownership in) an object that you send a retain message to because retain increments the object's reference count.  Each retain message you send an object should be balanced eventually with a release or autorelease message, so that the object can be deallocated.  For more information on the automatic deallocation mechanism, see the introduction to the Foundation Kit.<p>

You would only implement this method to define your own reference-counting scheme.  Such implementations should not invoke the inherited method; that is, they should not include a release message to super.<p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/intfm/NSObject/retainCount">- retainCount</a>

</code><p><hr WIDTH=25% ALIGN=LEFT>

<a name="211"></a>

<h3> <a name="//apple_ref/occ/intfm/NSObject/respondsToSelector:">respondsToSelector:</a></h3>

- (BOOL)<code>respondsToSelector:</code>(SEL)<em>aSelector

</em>

<P>Returns YES if the receiver implements or inherits a method that can respond to <em>aSelector</em> messages,  NO otherwise.  The application is responsible for determining whether a NO response should be considered an error.<p>

Note that if the receiver is able to forward <em>aSelector</em> messages to another object, it will be able to respond to the message, albeit indirectly, even though this method returns NO.<p>

<B>See also: </B>  

<code><a href="../../Classes/NSObject.html#//apple_ref/occ/instm/NSObject/forwardInvocation:" target="_top">- forwardInvocation</code><code>:</code> (NSObject class)</a>, <code><a href="../../Classes/NSObject/NSObject.html#//apple_ref/occ/clm/NSObject/instancesRespondToSelector:" target="_top">+ instancesRespondToSelecto</code><code>r:</code>(NSObject class)</a>

<p><hr WIDTH=25% ALIGN=LEFT>

<a name="216"></a>

<h3> <a name="//apple_ref/occ/intfm/NSObject/retain">retain</a></h3>

- (id)<code>retain

</code>

<P>Increments the receiver's reference count.  You send an object a retain message when you want to prevent it from being deallocated without your express permission.<p>

An object is deallocated automatically when its reference count reaches 0.  retain messages increment the reference count, and release messages decrement it.  For more information on this mechanism, see the introduction to the Foundation Kit.<p>

As a convenience, retain returns self because it is often used in nested expressions:<p>

<blockquote><pre>NSString *headerDir = [[NSString <br>    stringWithCString:"/LocalLibrary/Headers"] retain];

</pre></blockquote><p>You would only implement this method if you were defining your own reference-counting scheme.  Such implementations must return self and should not invoke the inherited method by sending a retain message to super.<p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/intfm/NSObject/autorelease">- autorelease</a>, <a href="#//apple_ref/occ/intfm/NSObject/release">- release</a></code>, <a href="#//apple_ref/occ/intfm/NSObject/retainCount"><code>- retainCount</a>

</code><p><hr WIDTH=25% ALIGN=LEFT>

<a name="224"></a>

<h3> <a name="//apple_ref/occ/intfm/NSObject/retainCount">retainCount</a></h3>

- (unsigned)<code>retainCount

</code>

<P>Returns the receiver's reference count for debugging purposes.  You rarely send a retainCount message; however, you might implement this method in a class to implement your own reference-counting scheme.  For objects that never get released (that is, their release method does nothing), this method should return UINT_MAX, as defined in &lt;limits.h&gt;.<p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/intfm/NSObject/autorelease">- autorelease</a></code>, <a href="#//apple_ref/occ/intfm/NSObject/retain"><code>- retain</a>

</code><p><hr WIDTH=25% ALIGN=LEFT>

<a name="228"></a>

<h3> <a name="//apple_ref/occ/intfm/NSObject/self">self</a></h3>

- (id)<code>self

</code>

<P>Returns the receiver.<p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/intfm/NSObject/class">- class</a>

</code><p><hr WIDTH=25% ALIGN=LEFT>

<a name="232"></a>

<h3> <a name="//apple_ref/occ/intfm/NSObject/superclass">superclass</a></h3>

- (Class)<code>superclass

</code>

<P>Returns the class object for the receiver's superclass.<p>

<B>See also: </B>  

<code><a href="../../Classes/NSObject/NSObject.html#//apple_ref/occ/clm/NSObject/superclass" target="_top">+ superclas</code><code>s</code> (NSObject class)</a>

<p><hr WIDTH=25% ALIGN=LEFT>

<a name="236"></a>

<h3> <a name="//apple_ref/occ/intfm/NSObject/zone">zone</a></h3>

- (NSZone *)<code>zone

</code>

<P>Returns a pointer to the zone from which the receiver was allocated. Objects created without specifying a zone are allocated from the default zone.<p>

<B>See also: </B>  

<code><a href="../../Classes/NSObject/NSObject.html#//apple_ref/occ/clm/NSObject/allocWithZone:" target="_top">+ allocWithZone</code><code>:</code> (NSObject class)</a>

<p>

 







<i>Copyright &#169; 1997, Apple Computer, Inc.   All rights

reserved.</i>



<!-- Last updated: 06/17/97 16:33:04 -->



</body>

</html>

