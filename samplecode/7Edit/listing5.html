<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>7Edit - /Source/SVAEAccessors.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxMacOS9Earlier-date.html">Mac OS 9 & Earlier</a> &gt; <A HREF="javascript:location.replace('index.html');">7Edit</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/Carbon/idxInterapplicationCommunication-date.html" target="_blank">Carbon > Interapplication Communication</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">7Edit</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/Source/SVAEAccessors.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/Source/DebugUtils.c</option>
<option value="listing2.html">/Source/DebugUtils.h</option>
<option value="listing3.html">/Source/Offscreen.c</option>
<option value="listing4.html">/Source/Offscreen.h</option>
<option value="listing5.html">/Source/SVAEAccessors.c</option>
<option value="listing6.html">/Source/SVAEAccessors.h</option>
<option value="listing7.html">/Source/SVAEClone.c</option>
<option value="listing8.html">/Source/SVAEClone.h</option>
<option value="listing9.html">/Source/SVAEClose.c</option>
<option value="listing10.html">/Source/SVAEClose.h</option>
<option value="listing11.html">/Source/SVAECoercions.c</option>
<option value="listing12.html">/Source/SVAECoercions.h</option>
<option value="listing13.html">/Source/SVAECompare.c</option>
<option value="listing14.html">/Source/SVAECompare.h</option>
<option value="listing15.html">/Source/SVAECopy.c</option>
<option value="listing16.html">/Source/SVAECopy.h</option>
<option value="listing17.html">/Source/SVAECountElements.c</option>
<option value="listing18.html">/Source/SVAECountElements.h</option>
<option value="listing19.html">/Source/SVAECreate.c</option>
<option value="listing20.html">/Source/SVAECreate.h</option>
<option value="listing21.html">/Source/SVAECut.c</option>
<option value="listing22.html">/Source/SVAECut.h</option>
<option value="listing23.html">/Source/SVAEDelete.c</option>
<option value="listing24.html">/Source/SVAEDelete.h</option>
<option value="listing25.html">/Source/SVAEGetData.c</option>
<option value="listing26.html">/Source/SVAEGetData.h</option>
<option value="listing27.html">/Source/SVAEGetDataSize.c</option>
<option value="listing28.html">/Source/SVAEGetDataSize.h</option>
<option value="listing29.html">/Source/SVAEMove.c</option>
<option value="listing30.html">/Source/SVAEMove.h</option>
<option value="listing31.html">/Source/SVAEObjectsExist.c</option>
<option value="listing32.html">/Source/SVAEObjectsExist.h</option>
<option value="listing33.html">/Source/SVAEPaste.c</option>
<option value="listing34.html">/Source/SVAEPaste.h</option>
<option value="listing35.html">/Source/SVAERecording.c</option>
<option value="listing36.html">/Source/SVAERecording.h</option>
<option value="listing37.html">/Source/SVAERevert.c</option>
<option value="listing38.html">/Source/SVAERevert.h</option>
<option value="listing39.html">/Source/SVAESave.c</option>
<option value="listing40.html">/Source/SVAESave.h</option>
<option value="listing41.html">/Source/SVAESelect.c</option>
<option value="listing42.html">/Source/SVAESelect.h</option>
<option value="listing43.html">/Source/SVAESetData.c</option>
<option value="listing44.html">/Source/SVAESetData.h</option>
<option value="listing45.html">/Source/SVAETextUtils.c</option>
<option value="listing46.html">/Source/SVAETextUtils.h</option>
<option value="listing47.html">/Source/SVAEWindowUtils.c</option>
<option value="listing48.html">/Source/SVAEWindowUtils.h</option>
<option value="listing49.html">/Source/SVAppleEvents.c</option>
<option value="listing50.html">/Source/SVAppleEvents.h</option>
<option value="listing51.html">/Source/SVDrag.c</option>
<option value="listing52.html">/Source/SVDrag.h</option>
<option value="listing53.html">/Source/SVEditAEUtils.c</option>
<option value="listing54.html">/Source/SVEditAEUtils.h</option>
<option value="listing55.html">/Source/SVEditFile.c</option>
<option value="listing56.html">/Source/SVEditFile.h</option>
<option value="listing57.html">/Source/SVEditGlobals.c</option>
<option value="listing58.html">/Source/SVEditGlobals.h</option>
<option value="listing59.html">/Source/SVEditMain.c</option>
<option value="listing60.html">/Source/SVEditMain.h</option>
<option value="listing61.html">/Source/SVEditPrinting.c</option>
<option value="listing62.html">/Source/SVEditPrinting.h</option>
<option value="listing63.html">/Source/SVEditUtils.c</option>
<option value="listing64.html">/Source/SVEditUtils.h</option>
<option value="listing65.html">/Source/SVEditWindow.c</option>
<option value="listing66.html">/Source/SVEditWindow.h</option>
<option value="listing67.html">/Source/SVToken.h</option></select>
				</p>
				</form>
				<p><strong><a href="7Edit.zip">Download Sample</a></strong> (&#147;7Edit.zip&#148;, 205.9K)<BR>
<strong><a href="7Edit.dmg">Download Sample</a></strong> (&#147;7Edit.dmg&#148;, 251.7K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*  File:    SVAEAccessors.c  Contains:    Written by: Original version by Jon Lansdell and Nigel Humphreys.        3.1 updates by Greg Sutton.  Copyright:  Copyright &copy; 1995-1999 by Apple Computer, Inc., All Rights Reserved.        You may incorporate this Apple sample source code into your program(s) without        restriction. This Apple sample source code has been provided &quot;AS IS&quot; and the        responsibility for its operation is yours. You are not permitted to redistribute        this Apple sample source code as &quot;Apple sample source code&quot; after having made        changes. If you're going to re-distribute the source, we require that you make        it clear in the source that the code was descended from Apple sample source        code, but that you've made changes.  Change History (most recent first):        7/20/1999  Karl Groethe  Updated for Metrowerks Codewarror Pro 2.1        */#include &quot;SVAEAccessors.h&quot;#include &lt;Menus.h&gt;#include &lt;PLStringFuncs.h&gt;#include &lt;Scrap.h&gt;#include &lt;TextEdit.h&gt;#include &lt;AEObjects.h&gt;#include &lt;AEPackObject.h&gt;#include &lt;AERegistry.h&gt;#include &quot;SVEditGlobals.h&quot;#include &quot;SVEditUtils.h&quot;#include &quot;SVEditAEUtils.h&quot;#include &quot;SVEditWindow.h&quot;#include &quot;SVEditFile.h&quot;#include &quot;SVAppleEvents.h&quot;#include &quot;SVToken.h&quot;#include &quot;SVAETextUtils.h&quot;#include &quot;SVAEWindowUtils.h&quot;#pragma segment AppleEvent// Install accessors that are used when AEResolve is called to convert// object specifiers into internal representations (tokens).OSErr  InstallAccessors(void){  OSErr  err;  err = AEInstallObjectAccessor(cApplication, typeNull,      NewOSLAccessorProc(ApplicationFromNullAccessor), 0, false);  err = AEInstallObjectAccessor(cWindow,      typeNull,      NewOSLAccessorProc(WindowFromNullAccessor), 0, false);  err = AEInstallObjectAccessor(cDocument,    typeNull,      NewOSLAccessorProc(WindowFromNullAccessor), 0, false);  err = AEInstallObjectAccessor(cProperty,    typeNull,       NewOSLAccessorProc(PropertyFromNullAccessor), 0, false);  err = AEInstallObjectAccessor(cWindow,      typeMyAppl,      NewOSLAccessorProc(WindowFromNullAccessor), 0, false);  err = AEInstallObjectAccessor(cDocument,    typeMyAppl,      NewOSLAccessorProc(WindowFromNullAccessor), 0, false);  err = AEInstallObjectAccessor(cProperty,    typeMyAppl,     NewOSLAccessorProc(PropertyFromApplAccessor), 0, false);      // Handle text from a window      // e.g. some character of last window  err = AEInstallObjectAccessor(cInsertionPoint,typeMyWndw,    NewOSLAccessorProc(TextElemFromTextAccessor), 0, false);  err = AEInstallObjectAccessor(cChar,    typeMyWndw,      NewOSLAccessorProc(TextElemFromTextAccessor), 0, false);  err = AEInstallObjectAccessor(cText,     typeMyWndw,      NewOSLAccessorProc(TextElemFromTextAccessor), 0, false);  err = AEInstallObjectAccessor(cWord,    typeMyWndw,      NewOSLAccessorProc(TextElemFromTextAccessor), 0, false);  err = AEInstallObjectAccessor(cParagraph,  typeMyWndw,      NewOSLAccessorProc(TextElemFromTextAccessor), 0, false);  err = AEInstallObjectAccessor(cProperty,  typeMyWndw,      NewOSLAccessorProc(PropertyFromWndwAccessor), 0, false);      // Handle text items within text items      // e.g. last word of first paragraph of front window  err = AEInstallObjectAccessor(cInsertionPoint,typeMyText,    NewOSLAccessorProc(TextElemFromTextAccessor), 0, false);  err = AEInstallObjectAccessor(cChar,    typeMyText,      NewOSLAccessorProc(TextElemFromTextAccessor), 0, false);  err = AEInstallObjectAccessor(cText,     typeMyText,      NewOSLAccessorProc(TextElemFromTextAccessor), 0, false);  err = AEInstallObjectAccessor(cWord,    typeMyText,      NewOSLAccessorProc(TextElemFromTextAccessor), 0, false);  err = AEInstallObjectAccessor(cParagraph,  typeMyText,      NewOSLAccessorProc(TextElemFromTextAccessor), 0, false);  err = AEInstallObjectAccessor(cProperty,  typeMyText,      NewOSLAccessorProc(PropertyFromTextAccessor), 0, false);      // Handle text items from lists (of hopefully text items) also      // e.g. every word of every paragraph of front window      // or even - every word of every character of every paragraph of front window  err = AEInstallObjectAccessor(cInsertionPoint,typeAEList,    NewOSLAccessorProc(TextElemFromTextAccessor), 0, false);  err = AEInstallObjectAccessor(cChar,     typeAEList,      NewOSLAccessorProc(TextElemFromTextAccessor), 0, false);  err = AEInstallObjectAccessor(cText,     typeAEList,      NewOSLAccessorProc(TextElemFromTextAccessor), 0, false);  err = AEInstallObjectAccessor(cWord,    typeAEList,      NewOSLAccessorProc(TextElemFromTextAccessor), 0, false);  err = AEInstallObjectAccessor(cParagraph,  typeAEList,      NewOSLAccessorProc(TextElemFromTextAccessor), 0, false);  err = AEInstallObjectAccessor(cProperty,    typeAEList,     NewOSLAccessorProc(PropertyFromListAccessor), 0, false);      // This is for 'select insertion point before contents of document 1'  err = AEInstallObjectAccessor(cInsertionPoint,   typeMyWindowProp,  NewOSLAccessorProc(TextElemFromTextAccessor), 0, false);      // This accessor is for getting properties of window properties      // e.g. font of contents of window 1      // Relies on ability to coerce from a window property to text      // for certain properties.  err = AEInstallObjectAccessor(cProperty,     typeMyWindowProp,  NewOSLAccessorProc(PropertyFromTextAccessor), 0, false);  return(err);}// Given selectionData of formAbsolutePosition for a window this routine returns// a WindowToken descriptor for specified window.//// e.g.  tell application '7Edit'//      window 1//      --first document//      --some window//      --every window//    end tellOSErr  WindowFormAbsolutePosition(const AEDesc  *selectionData, AEDesc* result){  AEDesc  itemDesc = {typeNull, NULL};  short  windowCount,      index;  OSErr  err;  windowCount = CountWindows();    if (! windowCount)    return(errAEIllegalIndex);    if (typeAbsoluteOrdinal == selectionData-&gt;descriptorType)  {    switch (*(DescType *)*selectionData-&gt;dataHandle)    {      case kAEFirst:        index = 1;        break;        case kAELast:        index = windowCount;        break;        case kAEMiddle:        index = (windowCount + 1) / 2;        break;        case kAEAny:        index = (Random() % windowCount) + 1;        break;        case kAEAll:        err = AECreateList(NULL, 0 , false, result);        if (noErr != err) goto done;                for (index = 1; index &lt;= windowCount; index++)        {          err = GetDescOfNthWindow(index, &amp;itemDesc);          if (noErr != err) goto done;                    err = AEPutDesc(result, 0, &amp;itemDesc);          if (noErr != err) goto done;                    if (itemDesc.dataHandle)            AEDisposeDesc(&amp;itemDesc);        }                goto done;    // We have created our list descriptor        break;      // so we can just tidy up and return.              default:        err = errAETypeError;    }  }  else    err = GetIntegerFromDescriptor(selectionData, &amp;index);  if (noErr != err) goto done;    if (index &lt; 0)    // Handle negative indexes    index = windowCount + index + 1;      if (index &gt; windowCount || index &lt;= 0)    err = errAEIllegalIndex;  else    err = GetDescOfNthWindow(index, result);done:    if (itemDesc.dataHandle)    AEDisposeDesc(&amp;itemDesc);  return(err);} // WindowFormAbsolutePosition// Given a formName descriptor in selectionData, this routine returns a// WindowToken descriptor for the window with that name.//// e.g.  tell application '7Edit'//      document &quot;Untitled&quot;//    end tellOSErr  WindowFormName(const AEDesc  *selectionData, AEDesc* result){  Str255    name;  OSErr    err;          // This tries to coerce it first  err = GetPStringFromDescriptor(selectionData, name);  if (noErr != err) goto done;  err = GetDescOfNamedWindow(name, result);done:  return(err);}// Get a WindowToken descriptor for a window or document object specifier// from NULL (or the application). Only handles formAbsolutePosition and formName//// e.g.  tell application '7Edit'//      window 1//      --first document//      --document &quot;Untitled&quot;//      --every window//    end tellpascal OSErr  WindowFromNullAccessor(DescType      wantClass,                    const AEDesc  *container,                    DescType      containerClass,                    DescType    form,                     const AEDesc  *selectionData,                    AEDesc      *value,                    long      theRefCon){#pragma unused (container,theRefCon)  OSErr       err;      // Can only handle cWindow and cDocument  if (wantClass != cWindow &amp;&amp; wantClass != cDocument)    return(errAEWrongDataType);        // Can only handle typeNull and typeMyAppl  if (containerClass != typeNull &amp;&amp; containerClass != typeMyAppl)    return(errAENoSuchObject);    switch (form)  {    case formAbsolutePosition:      err = WindowFormAbsolutePosition(selectionData, value);      break;          case formName:      err = WindowFormName(selectionData, value);      break;          default:      err = errAEBadTestKey;  }        return(err);} // WindowFromNullAccessorpascal OSErr   ApplicationFromNullAccessor(DescType    wantClass,                      const AEDesc  *container,                      DescType    containerClass,                      DescType    form,                       const AEDesc  *selectionData,                      AEDesc      *value,                      long      theRefCon){#pragma unused(container,selectionData,theRefCon)  OSErr    myErr;  AppToken theApp;  AEDesc   resultDesc;    value-&gt;dataHandle     = nil;  resultDesc.dataHandle = nil;    /*     should only be called with wantClass = cWindow and    with containerClass = typeNull.    Currently accept as either formName or formAbsolutePosition  */    if ((wantClass != cApplication) || (containerClass != typeNull) ||      !((form == formName) || (form == formAbsolutePosition)))    return(errAEWrongDataType);    if ((form == formName) || (form == formAbsolutePosition))  {    theApp.highLongOfPSN = 0;    theApp.lowLongOfPSN  = kCurrentProcess;  }      myErr = AECreateDesc(typeMyAppl, (Ptr)&amp;theApp, sizeof(theApp), value);        return(myErr);}  /* ApplicationFromNullAccessor */// Given a formAbsolutePosition selectionData descriptor and a TextToken from// which to index from. This routine returns a TextToken descriptor for the// text specified.//// e.g.  tell application '7Edit'//      first word of window 1  -- window one will be dealt with in//                  -- WindowFromNullAccessor().//      --some character of middle paragraph of last document//                  -- container token will be a paragraph//    end tellOSErr  TextFormAbsolutePosition(TextToken* containerToken, AEDesc* selectionData,                          DescType wantClass, AEDesc* result){  DPtr    docPtr;  short    elementCount;  AEDesc    aDesc = {typeNull, NULL};  long    index;  OSErr    err;    docPtr = DPtrFromWindowPtr(containerToken-&gt;tokenWindow);  if (! docPtr)  {    err = errAENoSuchObject;    goto done;  }  err = CountTextElements(docPtr-&gt;theText, containerToken-&gt;tokenOffset,                containerToken-&gt;tokenLength, wantClass, &amp;elementCount);  if (noErr != err) goto done;  if (typeAbsoluteOrdinal == selectionData-&gt;descriptorType)  {    switch (*(DescType *)*selectionData-&gt;dataHandle)    {      case kAEFirst:        index = 1;        break;        case kAELast:        index = elementCount;        break;        case kAEMiddle:        index = (elementCount + 1) / 2;        break;        case kAEAny:        index = (Random() % elementCount) + 1;        break;        case kAEAll:        err = AECreateList(NULL, 0 , false, result);                for (index = 1; index &lt;= elementCount; index++)        {          if (noErr == (err = GetDescOfNthTextElement(index, wantClass,                                containerToken, &amp;aDesc)))          {            err = AEPutDesc(result, 0, &amp;aDesc);            AEDisposeDesc(&amp;aDesc);          }        }        goto done;    // Created our result - clean up and return        break;        default:        err = errAETypeError;    }  }  else    // Try and get an index out of the descriptor    err = GetLongIntFromDescriptor(selectionData, &amp;index);    if (noErr != err) goto done;          // kAEAll has already created it's list  err = GetDescOfNthTextElement(index, wantClass,      // Checks for negatives and                containerToken, result);  // out of range.                    done:  if (aDesc.dataHandle)    AEDisposeDesc(&amp;aDesc);  return(err);}// Given a TextToken container and a formRange descriptor. This routine// creates a TextToken descriptor starting at the the beginning of the// first item in the range and ending at the end of the last item in the range.//// e.g.  tell application '7Edit'//      paragraphs 2 thru 3 of document 1//    end tellOSErr  TextFormRange(TextToken* containerToken, AEDesc* selectionData,                          DescType wantClass, AEDesc* result){#pragma unused(wantClass)  AEDesc    selectionRecord = {typeNull, NULL};  TextToken  startToken,        stopToken;  DescType  returnedType;  Size    actualSize;  OSErr    err;    // coerce the selection data into an AERecord  err = AECoerceDesc(selectionData, typeAERecord, &amp;selectionRecord);  if (noErr != err) goto done;      // get the start object as a text token this will reenter    // TextElemFromTextAccessor() but as formAbsolutePosition via     // our installed coercion handler CoerceObjToAnything()    // because the keyAERangeStart parameter is actually an object specifier.  err = AEGetKeyPtr(&amp;selectionRecord, keyAERangeStart, typeMyText,              &amp;returnedType, (Ptr)&amp;startToken, sizeof(startToken), &amp;actualSize);  if (noErr != err) goto done;      // now do the same for the stop object  err = AEGetKeyPtr(&amp;selectionRecord, keyAERangeStop, typeMyText,              &amp;returnedType, (Ptr)&amp;stopToken, sizeof(stopToken), &amp;actualSize);  if (noErr != err) goto done;    if (containerToken-&gt;tokenWindow != startToken.tokenWindow      || containerToken-&gt;tokenWindow != stopToken.tokenWindow)  {    err = errAECorruptData;    // or whatever    goto done;  }        // Use startToken to create result descriptor  startToken.tokenLength = stopToken.tokenOffset + stopToken.tokenLength - startToken.tokenOffset;                               err = AECreateDesc(typeMyText, (Ptr)&amp;startToken, sizeof(startToken), result);done:  if (selectionRecord.dataHandle)    AEDisposeDesc(&amp;selectionRecord);  return(err);}// Given a container TextToken and a formRelativePosition selectionData descriptor// this routine returns a TextToken descriptor to the reative wantClass object// specified.// This routine currently only handles relative positions for a wantClass// of cInsertionPoint.//// e.g.  tell application '7Edit'//      insertion point after word 5 of document 1//    end tellOSErr  TextFormRelativePosition(TextToken* containerToken, AEDesc* selectionData,                          DescType wantClass, AEDesc* result){  TextToken  aTextToken;  DescType   aPosition;  OSErr    err;    aTextToken.tokenWindow = containerToken-&gt;tokenWindow;  switch (wantClass)  {    case cInsertionPoint:      err = GetEnumeratedFromDescriptor(selectionData, &amp;aPosition);            switch (aPosition)      {        case kAEPrevious:        case kAEBefore:        case kAEBeginning:          // No change to offset - just 0 length now          // containerToken.tokenOffset = containerToken.tokenOffset;          aTextToken.tokenOffset = containerToken-&gt;tokenOffset;          aTextToken.tokenLength = 0;          break;              case kAENext:        case kAEAfter:        case kAEEnd:          aTextToken.tokenOffset = containerToken-&gt;tokenOffset + containerToken-&gt;tokenLength;          aTextToken.tokenLength = 0;          break;                  default:          err = errAEIllegalIndex;      }      break;          default:      err = errAEWrongDataType;  // Could do cChar, cWord\xC9 but this is only a sample  }    if (noErr != err) goto done;  err = AECreateDesc(typeMyText, (Ptr)&amp;aTextToken, sizeof(aTextToken), result);done:  return(err);}// Tries to create a TextToken descriptor given a container which may// be a TextToken descriptor or a WindowToken descriptor. A// selectionData descriptor which can be of formAbsolutePosition,// formRange or formRelativePosition, and a wantClass which should// be cInsertionPoint, cChar, cText, cWord or cParagraph.//// e.g.  tell application '7Edit'//      first word of document 1 -- document 1 will go through WindowFromNullAccessor()//                   -- which will return a WindowToken descriptor. This//                   -- descriptor will then be coerced to a TextToken//                   -- descriptor and used as the container.//    end tellpascal OSErr  TextElemFromTextAccessor(DescType      wantClass,                      AEDesc      *container,                      DescType    containerClass,                      DescType    form,                      AEDesc      *selectionData,                      AEDesc      *value,                      long      theRefCon){#pragma unused(containerClass)  TextToken   containerToken;  long        index;  long    itemCount;  AEDesc    aDesc = {typeNull, NULL},        resultDesc = {typeNull, NULL};  DescType  returnedType;  Size    actualSize;  OSErr       myErr;          // If it's a list then we need to call this accessor for every        // item within the list (which could of course be more lists).  if (typeAEList == container-&gt;descriptorType)  {    myErr = AECreateList(NULL, 0 , false, value);  // Result will also be a list of items    if (noErr != myErr) goto done;    myErr = AECountItems(container, &amp;itemCount);    if (noErr != myErr) goto done;    for (index = 1; index &lt;= itemCount; index++)  // Do in forward order    {      myErr = AEGetNthDesc(container, index, typeWildCard, &amp;returnedType, &amp;aDesc);      if (noErr == myErr)    // Call this function recursively if necessary        myErr = TextElemFromTextAccessor(wantClass, &amp;aDesc, returnedType,                      form, selectionData, &amp;resultDesc, theRefCon);            if (noErr == myErr)    // Add item to the end of our list        myErr = AEPutDesc(value, 0, &amp;resultDesc);            if (aDesc.dataHandle)        AEDisposeDesc(&amp;aDesc);      if (resultDesc.dataHandle)        AEDisposeDesc(&amp;resultDesc);    }  }  else  {        // We have a coercion handler from window to text    myErr = AECoerceDesc(container, typeMyText, &amp;aDesc);    if (noErr != myErr) goto done;        // Get the containing TextToken    GetRawDataFromDescriptor(&amp;aDesc, (Ptr)&amp;containerToken, sizeof(containerToken), &amp;actualSize);        switch (form)    {      case formAbsolutePosition:        myErr = TextFormAbsolutePosition(&amp;containerToken, selectionData,                                  wantClass, value);        break;                                  case formRange:        myErr = TextFormRange(&amp;containerToken, selectionData,                              wantClass, value);        break;              case formRelativePosition:        myErr = TextFormRelativePosition(&amp;containerToken, selectionData,                                wantClass, value);        break;              default:        myErr = errAEBadKeyForm;    }  }done:  if (aDesc.dataHandle)    AEDisposeDesc(&amp;aDesc);      return(myErr);}  // TextElemFromTextAccessor// Given a TextToken descriptor as a container convert this into // a TextPropToken descriptor for the property.pascal OSErr  PropertyFromTextAccessor(DescType      wantClass,                      const AEDesc  *container,                      DescType    containerClass,                      DescType    form,                       const AEDesc  *selectionData,                      AEDesc      *value,                      long      theRefCon){#pragma unused (theRefCon, containerClass)  AEDesc      textDesc = {typeNull, NULL},          propertyDesc = {typeNull, NULL};  Size      actualSize;  TextToken    aTextToken;  TextPropToken  aTextPropToken;  DescType    aProperty;  OSErr      err;    if (cProperty != wantClass || formPropertyID != form)    return(errAEWrongDataType);            // Try and coerce to a TextToken descriptor  err = AECoerceDesc(container, typeMyText, &amp;textDesc);  if (noErr != err) goto done;          // Get the TextToken  GetRawDataFromDescriptor(&amp;textDesc, (Ptr)&amp;aTextToken,              sizeof(aTextToken), &amp;actualSize);              // Make sure the selection data is typeType  err = AECoerceDesc(selectionData, typeType, &amp;propertyDesc);  if (noErr != err) goto done;        // Get the property  GetRawDataFromDescriptor(&amp;propertyDesc, (Ptr)&amp;aProperty,                  sizeof(aProperty),  &amp;actualSize);              //  Combine the two into single token  aTextPropToken.tokenTextToken = aTextToken;  aTextPropToken.tokenProperty  = aProperty;    err = AECreateDesc(typeMyTextProp, (Ptr)&amp;aTextPropToken,                sizeof(aTextPropToken), value);done:      if (textDesc.dataHandle)    AEDisposeDesc(&amp;textDesc);  if (propertyDesc.dataHandle)    AEDisposeDesc(&amp;propertyDesc);      return(err);} // PropertyFromTextAccessor// Given a WindowToken descriptor as a container convert this into // a WindowPropToken descriptor for the property.pascal OSErr  PropertyFromWndwAccessor(DescType      wantClass,                      AEDesc      *container,                      DescType    containerClass,                      DescType    form,                       AEDesc      *selectionData,                      AEDesc      *value,                      long      theRefCon){#pragma unused(containerClass)  long        itemCount,            index;  AEDesc        resultDesc = {typeNull, NULL},            windowDesc = {typeNull, NULL},            propDesc = {typeNull, NULL};  Size              actualSize;  DescType          returnedType;  WindowToken       theWindowToken;  WindowPropToken   myWindowProp;  OSErr             err;    if (typeAEList == container-&gt;descriptorType)  {    err = AECreateList(NULL, 0 , false, value);    // Result will also be a list of items    if (noErr != err) goto done;    err = AECountItems(container, &amp;itemCount);    if (noErr != err) goto done;      for (index = 1; index &lt;= itemCount; index++)  // Do in forward order    {      err = AEGetNthDesc(container, index, typeWildCard, &amp;returnedType, &amp;windowDesc);        if (noErr == err)              // Recursively call this routine                            // - could be another list.        err = PropertyFromWndwAccessor(wantClass, &amp;windowDesc, windowDesc.descriptorType,                            form, selectionData, &amp;resultDesc, theRefCon);            if (noErr == err)              // Add item to the end of our list        err = AEPutDesc(value, 0, &amp;resultDesc);            if (windowDesc.dataHandle)        AEDisposeDesc(&amp;windowDesc);      if (resultDesc.dataHandle)        AEDisposeDesc(&amp;resultDesc);    }  }  else  {    // get the window token - it's the container        err = AECoerceDesc(container, typeMyWndw, &amp;windowDesc);    GetRawDataFromDescriptor(&amp;windowDesc, (Ptr)&amp;theWindowToken,                    sizeof(theWindowToken), &amp;actualSize);                                    // Check the window exists        if (theWindowToken.tokenWindow == NULL)      err = errAEIllegalIndex;    else    {    // get the property - it's in the selection data            err = AECoerceDesc(selectionData, typeType, &amp;propDesc);      GetRawDataFromDescriptor(&amp;propDesc, (Ptr)&amp;returnedType,                      sizeof(returnedType), &amp;actualSize);              // Combine the two into single token      myWindowProp.tokenWindowToken = theWindowToken;      myWindowProp.tokenProperty    = returnedType;            err = AECreateDesc(typeMyWindowProp, (Ptr)&amp;myWindowProp,                        sizeof(myWindowProp), value);    }  }  done:  if (windowDesc.dataHandle)    AEDisposeDesc(&amp;windowDesc);  if (propDesc.dataHandle)    AEDisposeDesc(&amp;propDesc);  if (resultDesc.dataHandle)    AEDisposeDesc(&amp;resultDesc);      return(err);} // PropertyFromWndwAccessorpascal OSErr  PropertyFromNullAccessor(DescType      wantClass,                      AEDesc      *container,                      DescType    containerClass,                      DescType    form,                       AEDesc      *selectionData,                      AEDesc      *value,                      long      theRefCon){#pragma unused (container, containerClass)  AEDesc    aDesc = {typeNull, NULL};  OSErr    err;  if ((wantClass != cProperty) || (form != formPropertyID))    return(errAEWrongDataType);  switch (*(DescType *)*selectionData-&gt;dataHandle)  {    case pSelection:  // The selection defaults to the front window              // selection.      err = GetDescOfNthWindow(1, &amp;aDesc);  // Disposed of at end      if (noErr != err) goto done;      err = PropertyFromWndwAccessor(wantClass, &amp;aDesc, typeMyWndw, form,                           selectionData, value, theRefCon);      break;          default:      // Otherwise try an application property - it is fron NULL      err = PropertyFromApplAccessor(wantClass, &amp;aDesc, typeMyWndw, form,                           selectionData, value, theRefCon);  }  done:  if (aDesc.dataHandle)    AEDisposeDesc(&amp;aDesc);    return(err);}// Convert a list of Token descriptors to a list of Property Token descriptors.// Only TextTokens and WindowTokens are supported in this version.OSErr  TokenListToPropertyList(AEDesc* tokenList, DescType aProperty, AEDesc* result){  AEDesc        aDesc = {typeNull, NULL},            resultDesc = {typeNull, NULL};  DescType      returnedType;  long        itemCount,            index;  WindowPropToken    aWindowPropToken;  TextPropToken    aTextPropToken;  Size        actualSize;  OSErr        err;  err = AECreateList(NULL, 0 , false, result);    // Result will also be a list of items  if (noErr != err) goto done;  err = AECountItems(tokenList, &amp;itemCount);    // Will return an error if not of type typeAEList  if (noErr != err) goto done;  for (index = 1; index &lt;= itemCount; index++)  // Do in forward order  {    err = AEGetNthDesc(tokenList, index, typeWildCard, &amp;returnedType, &amp;aDesc);    if (noErr == err)              // Create appropriate property token      switch (aDesc.descriptorType)      {        case typeMyWndw:          GetRawDataFromDescriptor(&amp;aDesc, (Ptr)&amp;aWindowPropToken,                          sizeof(WindowToken), &amp;actualSize);          aWindowPropToken.tokenProperty = aProperty;          err = AECreateDesc(typeMyWindowProp, (Ptr)&amp;aWindowPropToken,                          sizeof(aWindowPropToken), &amp;resultDesc);          break;                  case typeMyText:          GetRawDataFromDescriptor(&amp;aDesc, (Ptr)&amp;aTextPropToken,                          sizeof(TextToken), &amp;actualSize);          aTextPropToken.tokenProperty = aProperty;          err = AECreateDesc(typeMyTextProp, (Ptr)&amp;aTextPropToken,                          sizeof(aTextPropToken), &amp;resultDesc);          break;                  case typeAEList:          // Recursive call if a list          err = TokenListToPropertyList(&amp;aDesc, aProperty, &amp;resultDesc);          break;                  default:    // May already be a property token          err = errAEBadListItem;      }        if (noErr == err)    // Add item to the end of our list      err = AEPutDesc(result, 0, &amp;resultDesc);        if (aDesc.dataHandle)      AEDisposeDesc(&amp;aDesc);    if (resultDesc.dataHandle)      AEDisposeDesc(&amp;resultDesc);          err = noErr;      // Try and do all the items we can in the list  }      done:  return(err);}// Given a container that is a list of Token descriptors, this routine// returns a list of PropToken descriptors.pascal OSErr  PropertyFromListAccessor(DescType      wantClass,                      AEDesc      *container,                      DescType    containerClass,                      DescType    form,                       AEDesc      *selectionData,                      AEDesc      *value,                      long      theRefCon){#pragma unused(containerClass, theRefCon)  OSErr    err;    if (wantClass != cProperty &amp;&amp; form != formPropertyID)    return(errAEBadKeyForm);    err = TokenListToPropertyList(container, *(DescType *)*selectionData-&gt;dataHandle, value);  return(err);}// Given a AppToken descriptor as a container convert this into // a WindowPropToken descriptor for the property.pascal OSErr  PropertyFromApplAccessor(DescType      wantClass,                      const AEDesc  *container,                      DescType    containerClass,                      DescType    form,                       const AEDesc  *selectionData,                      AEDesc      *value,                      long      theRefCon){#pragma unused (theRefCon, containerClass)  OSErr         myErr;  OSErr         ignoreErr;  AppToken      theApplToken;  DescType      theProperty;  AEDesc        applDesc;  AEDesc        propDesc;  Size          actualSize;  ApplPropToken myApplProp;      value-&gt;dataHandle     = nil;  applDesc.dataHandle   = nil;  propDesc.dataHandle   = nil;    if ((wantClass != cProperty) ||      (form != formPropertyID))    {      return(errAEWrongDataType);    }    /* get the application token - it's the container */    myErr = AECoerceDesc(container, typeMyAppl, &amp;applDesc);  GetRawDataFromDescriptor(&amp;applDesc,                           (Ptr)&amp;theApplToken,                           sizeof(theApplToken),                           &amp;actualSize);        /* get the property - it's in the selection data */    myErr = AECoerceDesc(selectionData, typeType, &amp;propDesc);  GetRawDataFromDescriptor(&amp;propDesc,                           (Ptr)&amp;theProperty,                           sizeof(theProperty),                           &amp;actualSize);  /*    Combine the two into single token  */  myApplProp.tokenApplToken    = theApplToken;  myApplProp.tokenApplProperty = theProperty;    myErr = AECreateDesc(typeMyApplProp,                       (Ptr)&amp;myApplProp,                       sizeof(myApplProp),                       value);      if (applDesc.dataHandle)    ignoreErr = AEDisposeDesc(&amp;applDesc);      if (propDesc.dataHandle)    ignoreErr = AEDisposeDesc(&amp;propDesc);      return(myErr);} // PropertyFromApplAccessorpascal OSErr  PropertyFromWinPropertyAccessor(DescType    wantClass,                        const AEDesc  *container,                        DescType    containerClass,                        DescType    form,                         const AEDesc  *selectionData,                        AEDesc      *value,                        long      theRefCon){#pragma unused(wantClass, containerClass, form, theRefCon)  OSErr           myErr;  OSErr           ignoreErr;  WindowPropToken theWindowPropToken;  AEDesc          newDesc, propDesc;  Size            tokenSize;  DPtr            theDocument;  TextToken       theTextToken;  DescType        theProperty;  Size            actualSize;  TextPropToken   myTextProp;    /* the container is a window property token. Get the token for this */  /* and check that it is valid to get a property of this property */    myErr = AECoerceDesc(container, typeMyWindowProp, &amp;newDesc);    if (myErr)   return(myErr);  GetRawDataFromDescriptor(&amp;newDesc,                           (Ptr)&amp;theWindowPropToken,                           sizeof(theWindowPropToken),                           &amp;tokenSize);                             /* if the property is pSelection, we then want to convert this to a text token */  /* and then return a text property token */    if (theWindowPropToken.tokenProperty == pSelection)     {      theDocument = DPtrFromWindowPtr(theWindowPropToken.tokenWindowToken.tokenWindow);            /* build a text token to represent the selection */      theTextToken.tokenOffset = (**(theDocument-&gt;theText)).selStart + 1;      theTextToken.tokenLength = ((**(theDocument-&gt;theText)).selEnd -                                 (**(theDocument-&gt;theText)).selStart) -1;      theTextToken.tokenWindow = theWindowPropToken.tokenWindowToken.tokenWindow;                /* now get the property- it's in the selection data */      myErr = AECoerceDesc(selectionData, typeType, &amp;propDesc);      GetRawDataFromDescriptor(&amp;propDesc,                               (Ptr)&amp;theProperty,                               sizeof(theProperty),                               &amp;actualSize);            /* Combine the two into single token */      myTextProp.tokenTextToken = theTextToken;      myTextProp.tokenProperty  = theProperty;            myErr = AECreateDesc(typeMyTextProp,(Ptr)&amp;myTextProp,                       sizeof(myTextProp),value);                                                    if (propDesc.dataHandle) ignoreErr = AEDisposeDesc(&amp;propDesc);      if (newDesc.dataHandle)  ignoreErr = AEDisposeDesc(&amp;newDesc);      return myErr;                                                        }    if (newDesc.dataHandle)  ignoreErr = AEDisposeDesc(&amp;newDesc);    return errAEWrongDataType;}</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/7Edit/listing5.html%3Fid%3DDTS10000200-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/7Edit/listing5.html%3Fid%3DDTS10000200-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/7Edit/listing5.html%3Fid%3DDTS10000200-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>