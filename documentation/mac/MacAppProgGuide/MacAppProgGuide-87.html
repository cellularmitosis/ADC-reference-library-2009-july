<!-- Generated by Harlequin WebMaker 2.2.3 (30-Apr-1996)
Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->
<HTML> <HEAD>
<TITLE>Recipes--Menus  (MacApp PG)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING87></A>


<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="MacAppProgGuide-86.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="MacAppProgGuide-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="MacAppProgGuide-158.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="MacAppProgGuide-88.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="MacAppProgGuide-2.html"><B>Programmer's Guide to MacApp</B></A> / <A HREF="MacAppProgGuide-78.html"><B>Part 2 - Working With MacApp</B></A><BR><DD><A HREF="MacAppProgGuide-85.html"><B>Chapter 12 - Working With Menus</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING87-0></A>
<H1><A NAME=MARKER-2-73></A>Recipes--Menus </H1>
 The recipes and sample code in this section summarize how to work with menu commands and demonstrate how to add a menu command to a menu, how to create a hierarchical menu, how to create a pop-up menu from a resource template, and how to add a menu item to the help menu. Some of the classes and methods you use to work with menus are shown in <A HREF=#MARKER-9-74>Figure 12-5</A>.<P>
<B>Figure 12-5  <A NAME=MARKER-9-74></A><A NAME=MARKER-2-75></A>Classes, methods, and global routines for working with menus</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/MacApp_PG-L-008.gif"><P>
<A NAME=HEADING87-4></A>
<H2><A NAME=MARKER-2-76></A><A NAME=MARKER-9-30></A>Working With Menus--A General Outline</H2>
 This outline describes the steps most MacApp applications take to work with menus. MacApp uses resources to specify menus and menu items. To add menu commands to your application, you add items to your resource file definitions and add code to enable and respond to those items.<P>
 To add a menu command to your application, you perform these steps:<P>
<OL>
<LI>Define a command number constant for the menu item.
<LI>Add the menu item to your resource file.
<LI>Except for very simple commands, define a command class with a <CODE>DoIt</CODE> method that performs the command operation. If the command is undoable, implement <CODE>UndoIt</CODE> and <CODE>RedoIt</CODE> methods as well.
<LI>Decide which of your event-handling classes will handle the command. Override its <CODE>DoSetupMenus</CODE> method to enable the menu item when appropriate.
<LI>Override the <CODE>DoMenuCommand</CODE> method to handle the menu command:<P>
<UL>
<LI>For a very simple command, perform the command action.
<LI>For a more complicated command, create and post a command object to perform the command operation.
<LI>If the command is recordable or can be handled by an attached script, set the <CODE>fUseAppleEvent</CODE> field to <CODE>TRUE</CODE> and override the <CODE>MakeAppleEvent</CODE> method to create an Apple event that describes the action.<A NAME=MARKER-2-78></A><P>
</UL>
</OL>
 The next recipe in this chapter demonstrates the steps for adding a menu command to a menu, enabling it, and responding when a user chooses that command. <A HREF=MacAppProgGuide-93.html#MARKER-9-32>"Recipe--Defining a Recordable Command Class," beginning on page 353</A>, shows how to implement a similar command that is recordable and supports handling by attached scripts.<P>
<A NAME=HEADING87-16></A>
<H2><A NAME=MARKER-2-79></A><A NAME=MARKER-9-28></A>Recipe--Adding, Enabling, and Responding to a Menu Command</H2>
 This recipe shows how to add the Invert Icon menu command to the Icon menu in the IconEdit sample application. To add a menu command, enable it, and respond to it, you perform these steps:<P>
<OL>
<LI>Define a command number constant for the menu item.
<LI>Add the menu command to the <CODE>'CMNU'</CODE> resource for the menu.
<LI>Enable the menu command in a <CODE>DoSetupMenus</CODE> method.
<LI>Respond to the menu command in a <CODE>DoMenuCommand</CODE> method.<P>
</OL>
 The sample code shown in this recipe is from the IconEdit application.<P>
<A NAME=HEADING87-23></A>
<H3>Define a Command-Number Constant for the Menu Item</H3>
 You define a command-number constant for the menu item in your resource file and in your code file. In the IconEdit application, the definitions are, in the file <CODE>IconEdit.r</CODE>,<P>
<PRE>
#define cInvert1002
</PRE>
 and, in the file <CODE>UIconEdit.cp</CODE>,<P>
<PRE>
const CommandNumber cInvert = 1002; // Invert menu command.
</PRE>
 Make sure the definitions match--otherwise, your application will be unable to respond correctly to the menu choice.<P>
<A NAME=HEADING87-29></A>
<H3>Add the Menu Command to the 'CMNU' Resource</H3>
 The <CODE>'CMNU'</CODE> resource for the Icon menu is defined in the file <CODE>IconEdit.r</CODE>. The following line from that resource specifies the Invert menu item:<P>
<PRE>
/* [4] */&quot;Invert&quot;, noIcon, &quot;I&quot;, noMark, plain, cInvert;
</PRE>
 This line specifies that the item's name is Invert, that it has no icon drawn beside it in the menu, that it can be specified by the Command-I keyboard equivalent, that the item is not checked, and that it is displayed in plain text.<P>
 When a user chooses this menu command, MacApp passes the <CODE>cInvert</CODE> value to the <CODE>DoMenuCommand</CODE> method of objects in the target chain.<P>
<A NAME=HEADING87-34></A>
<H3>Enable the Menu Command in a DoSetupMenus Method</H3>
 You normally enable a menu command in the <CODE>DoSetupMenus</CODE> method of the event handler that will handle the command. The <CODE>DoSetupMenus</CODE> method is called only for objects in the target chain, so a menu command will be enabled only if an object in the target chain is ready to handle that menu command.<P>
 The IconEdit application handles the Invert command in the <CODE>TIconDocument</CODE> class, since whenever a document is open its icon can be inverted. The <CODE>DoSetupMenus</CODE> method of the <CODE>TIconDocument</CODE> class contains the following line to enable the Invert menu command:<P>
<PRE>
Enable(cInvert, TRUE); // The icon can always be inverted.
</PRE>
<A NAME=HEADING87-38></A>
<H3>Respond to the Menu Command in a DoMenuCommand Method</H3>
 When a user chooses this menu command, MacApp passes the <CODE>cInvert</CODE> value to the <CODE>DoMenuCommand</CODE> method of objects in the target chain. For a very simple command, <CODE>DoMenuCommand</CODE> may respond by performing an action directly. It is usually better style to perform the action with a command object. Using a command object helps factor your application and makes it easier to support recording and attached scripts. This is what IconEdit does in the <CODE>DoMenuCommand</CODE> method of the <CODE>TIconDocument</CODE> class:<P>
<PRE>
void TIconDocument::DoMenuCommand (CommandNumber aCommandNumber) 
{
   switch (aCommandNumber)
      {
      case cInvert:
            TInvertCommand *anInvertCommand = new TInvertCommand;
            anInvertCommand-&gt;IInvertCommand(this);
            anInvertCommand-&gt;fUseAppleEvent = TRUE;
            PostCommand(anInvertCommand);
         break;
   .
   .
   .
      default:
         Inherited::DoMenuCommand(aCommandNumber);  
         break;  
      }
}
</PRE>
 The DoMenuCommand method sets the invert command object's <CODE>fUseAppleEvent</CODE> field to <CODE>TRUE</CODE> because the invert command supports recording and allows attached scripts to respond to the command. <A HREF=MacAppProgGuide-93.html#MARKER-9-32>"Recipe--Defining a Recordable Command Class," beginning on page 353</A>, provides more detail about adding scripting support to a command class.<A NAME=MARKER-2-81></A><P>
<A NAME=HEADING87-42></A>
<H2><A NAME=MARKER-2-82></A><A NAME=MARKER-9-83></A>Recipe--Using a Hierarchical Menu</H2>
 This recipe is based on the hierarchical Format menu in the DemoText sample application. That menu has hierarchical submenus for style, size, font, and color. For brevity, this recipe concentrates on the Color submenu. Refer to the DemoText source files for details regarding the other Format submenus.<P>
 To create a hierarchical menu, you perform these steps:<P>
<OL>
<LI>Define constants for the hierarchical menu and menu items.
<LI>Define a menu-bar resource that includes the name of your hierarchical menu.
<LI>Define a menu-bar resource with the items on your hierarchical menu.
<LI>Define a <CODE>'CMNU'</CODE> resource for your hierarchical menu.
<LI>Define a <CODE>'CMNU'</CODE> resource for each submenu.
<LI>Enable your hierarchical menu items in a <CODE>DoSetupMenuCommand</CODE> method.
<LI>Respond to hierarchical menu choices in a <CODE>DoMenuCommand</CODE> method.<P>
</OL>
 The sample code shown in this recipe is from the DemoText application.<P>
<A NAME=HEADING87-53></A>
<H3>Define Constants for the Hierarchical Menu and Menu Items</H3>
 The DemoText application defines menu constants in its resource definition file <CODE>DemoText.r</CODE>:<P>
<PRE>
// Menu IDs.
#define mFormat   5

// Hierarchical submenus.
#define mStyle    8           
#define mSize     9
#define mFont     10
#define mColor    11

// Byte values of hierarchical submenus to use in 'CMNU' resource.
#define hmStyle   &quot;\0x08&quot;
#define hmSize    &quot;\0x09&quot;
#define hmFont    &quot;\0x0A&quot;
#define hmColor   &quot;\0x0B&quot;

// Command numbers.
#define cColorText761
#define cColorBackground 762
</PRE>
 The definition of mFormat is used in the application's <CODE>'MBAR'</CODE> resource <A HREF=#MARKER-9-84>(page 318)</A>.<P>
 The definitions of <CODE>mStyle</CODE>, mSize, mFont, and mColor are used in the <CODE>'MBAR'</CODE> resource for the hierarchical submenus <A HREF=#MARKER-9-85>(page 319)</A>.<P>
 The definitions of hmStyle, hmSize, hmFont, and hmColor are used in the <CODE>'CMNU'</CODE> resource that defines the Format menu <A HREF=#MARKER-9-86>(page 319)</A>. Note that these values must be defined in byte format.<P>
 The definitions of cColorText and cColorBackground are used in the <CODE>'CMNU'</CODE> resource that defines the Color menu <A HREF=#MARKER-9-87>(page 320)</A>.<P>
<A NAME=HEADING87-60></A>
<H3><A NAME=MARKER-9-84></A>Define a Menu-Bar Resource That Includes Your Hierarchical Menu</H3>
 The following <CODE>'MBAR'</CODE> resource, defined with the MacApp constant kMBarDisplayed, specifies the menus for the application's menu bar.<P>
<PRE>
/* Menus displayed in the menu bar, including hierarchical menus. */
resource 'MBAR' (kMBarDisplayed,
#if qNames
&quot;kHierDisplayedMBar&quot;,
#endif
nonpurgeable) {
   {
      mApple; mFile; mEdit; mText; mFormat
   }
};
</PRE>
<DL>
<DT><B>Note</B>
<DD>You can build a version of the DemoText application that supports PowerTalk mailers. References to PowerTalk are omitted from this recipe but are described in the recipes in <A HREF=MacAppProgGuide-139.html#MARKER-9-19>Chapter 29, "Working With PowerTalk Mailers."</A><EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
<A NAME=HEADING87-64></A>
<H3><A NAME=MARKER-9-85></A>Define a Menu-Bar Resource With Your Menu Items</H3>
 The following <CODE>'MBAR'</CODE> resource, defined with the MacApp constant kMBarHierarchical, specifies the menu items to appear on the Format hierarchical menu.<P>
<PRE>
/* Hierarchial Submenus */
resource 'MBAR' (kMBarHierarchical,
#if qNames
&quot;kMBarHierarchical&quot;,
#endif
nonpurgeable) {
   {mStyle; mSize; mFont; mColor}
};
</PRE>
<A NAME=HEADING87-67></A>
<H3><A NAME=MARKER-9-86></A>Define a 'CMNU' Resource for Your Hierarchical Menu</H3>
 You need to tell MacApp which submenus will appear in your hierarchical menu. You do that by creating a <CODE>'CMNU'</CODE> resource for the menu. The following is the <CODE>'CMNU'</CODE> resource for the Format menu in the DemoText application:<P>
<PRE>
// Hierarchical Format menu with style, size, and font submenus.
resource 'CMNU' (mFormat,
#if qNames
&quot;mFormat&quot;,
#endif
nonpurgeable) {
   mFormat,
   textMenuProc,
   EnablingManagedByMacApp,
   enabled,
   &quot;Format&quot;,
    {
/* [ 1] */&quot;Style&quot;,noIcon, kHierarchicalMenu, hmStyle, plain, cStyle;
/* [ 2] */&quot;Size&quot;,noIcon, kHierarchicalMenu, hmSize, plain, cSize;
/* [ 3] */&quot;Font&quot;,noIcon, kHierarchicalMenu, hmFont, plain, cFont;
/* [ 4] */&quot;Color&quot;,noIcon, kHierarchicalMenu, hmColor, plain, cColor
   }
};
</PRE>
 For each menu item, the MacApp constant kHierarchicalMenu appears in the position where you would normally specify a Command-key equivalent. kHierarchicalMenu specifies that these items represent hierarchical menus; for each such menu item there is a corresponding <CODE>'CMNU'</CODE> resource.<P>
<A NAME=HEADING87-71></A>
<H3><A NAME=MARKER-9-87></A>Define a 'CMNU' Resource for Each Submenu</H3>
 The DemoText application supplies a <CODE>'CMNU'</CODE> resource for each submenu in the hierarchical Format menu. Shown here is the resource for the Color submenu:<P>
<PRE>
resource 'CMNU' (mColor,
#if qNames
&quot;mColor&quot;,
#endif
nonpurgeable) {
   mColor,
   textMenuProc,
   EnablingManagedByMacApp,
   enabled,
   &quot;Color&quot;,
   {
/* [ 1] */&quot;Set text color...&quot;,noIcon,&quot;T&quot;,noMark,plain,cColorText;
/* [ 2] */&quot;Set background color...&quot;,
                     noIcon,&quot;K&quot;,noMark,plain,cColorBackground
   }
};
</PRE>
 This menu contains items for setting the text color and the background color.<P>
<A NAME=HEADING87-75></A>
<H3>Enable Hierarchical Menu Items in a DoSetupMenus Method</H3>
 You enable menu items on a hierarchical menu just as you do other menu items, in the <CODE>DoSetupMenus</CODE> method of the event-handler object responsible for handling the menu commands. The DemoText application enables Format menu items in the TTEDocument class:<P>
<PRE>
void TTEDocument::DoSetupMenus() 
{
   .
   .
   .
   Enable(cColorText, (qNeedsColorQD || HasColorQD()));
   Enable(cColorBackground, (qNeedsColorQD || HasColorQD()));
   .
   .
   .
}
</PRE>
 Both items in the Color menu are enabled if the application requires Color QuickDraw (qNeedsColorQD) and if Color QuickDraw is available (HasColorQD()).<P>
<A NAME=HEADING87-79></A>
<H3>Respond to Hierarchical Menu Choices in a DoMenuCommand Method</H3>
 Your application responds to user menu choices from a hierarchical menu just as it does to other user menu choices, in the DoMenuCommand method of the event-handler object responsible for handling the menu commands. The DemoText application handles Format menu items in the TTEDocument class:<P>
<PRE>
void TTEDocument::DoMenuCommand(CommandNumber aCommandNumber) 
{
   .
   .
   .
   switch (aCommandNumber)
   {
   .
   .
   .
      case cColorText:
         this-&gt;DoColTextChange();
         break;
   
      case cColorBackground:
         this-&gt;DoColBackChange();
         break;
   .
   .
   .
   }  // End switch.
   .
   .
   .
}
</PRE>
 Note that the DoMenuCommand method calls other document methods to handle the Color menu commands. For a very simple command, these methods might perform the command action. In fact, DoColBackChange does just that to change the background color, while DoColTextChange creates an undoable command to change the text color.<A NAME=MARKER-2-88></A><P>
<A NAME=HEADING87-83></A>
<H2><A NAME=MARKER-2-89></A>Recipe--Creating a Pop-up Menu From a Resource Template</H2>
 You can define a pop-up menu in your resource file and use a view-editing application to insert the pop-up menu into a view. You can then create your pop-up menu with MacApp's global view server object. This recipe shows how the DemoDialogs application inserts a baud rate pop-up menu into the window created by the "Views by Templates" menu command.<P>
 To create a pop-up menu from a resource template, you perform these steps:<P>
<OL>
<LI>Define a menu-number constant for the pop-up menu.
<LI>Define command-number constants for the pop-up menu items, if desired.
<LI>Define a <CODE>'CMNU'</CODE> resource for the pop-up menu.
<LI>Define a <CODE>'View'</CODE> resource for the window or view to contain the <BR>pop-up menu.
<LI>Use MacApp's global view server object to create the pop-up menu.<P>
</OL>
 The sample code shown in this recipe is from the DemoDialogs application.<P>
<A NAME=HEADING87-92></A>
<H3>Define a Menu-Number Constant for the Pop-up Menu</H3>
 You define a menu-number constant for the pop-up menu item in your resource file. The DemoDialogs application does so in the file <CODE>DemoDialogs.r</CODE>:<P>
<PRE>
#define kBaudPopup 236
</PRE>
<A NAME=HEADING87-95></A>
<H3>Define Command-Number Constants for the Pop-up Menu Items</H3>
 Assign command-number constants to your pop-up menu items only if you wish to respond to user pop-up menu choices based on the command number of the chosen item rather than on its position in the menu. The DemoDialogs application creates the Baud Rate pop-up menu only for display, so it uses the MacApp-defined constant <CODE>nocommand</CODE> (see the <CODE>'CMNU'</CODE> resource in the next section).<P>
 <A HREF=MacAppProgGuide-86.html#MARKER-9-70>"Responding to a User Menu Choice," beginning on page 311</A>, shows how your application can respond to a menu command specified by a pop-up menu choice.<P>
<A NAME=HEADING87-98></A>
<H3><A NAME=MARKER-9-90></A>Define a 'CMNU' Resource for the Pop-up</H3>
 The DemoDialogs application defines the following <CODE>'CMNU'</CODE> resource in the file <CODE>DemoDialogs.r</CODE>.<P>
<PRE>
resource 'CMNU' (kBaudPopup) {
   kBaudPopup,
   textMenuProc,
   allEnabled,
   enabled,
   &quot;Baud:&quot;,
   {
/* [1] */&quot;300&quot;, noIcon, noKey, noMark, plain, nocommand;
/* [2] */&quot;1200&quot;, noIcon, noKey, noMark, plain, nocommand;
/* [3] */&quot;2400&quot;, noIcon, noKey, noMark, plain, nocommand;
/* [4] */&quot;9600&quot;, noIcon, noKey, noMark, plain, nocommand;
/* [5] */&quot;14400&quot;,noIcon, noKey, noMark, plain, nocommand
   }
};
</PRE>
 This menu defines menu items for setting the baud rate to values between 300 and 14,400. No command numbers are associated with the menu items.<P>
<A NAME=HEADING87-102></A>
<H3>Define a 'View' Resource for the View to Contain the Pop-up</H3>
 The DemoText application defines a <CODE>'View'</CODE> resource with a window and view hierarchy for displaying various types of subviews. It also defines a <CODE>'View'</CODE> resource for a view containing several pop-up menus. The next section describes how the application uses these resources. Both of these resources are too lengthy to reproduce here, but you can examine them in the file <CODE>DemoDialogs.r</CODE>. The window and view hierarchy is a <CODE>'View'</CODE> resource with ID <CODE>cTemplateViews</CODE>, while the view with the pop-up menus is a <CODE>'View'</CODE> resource with ID <CODE>cPopupExample</CODE>.<P>
 For information on how to create a view resource, see <A HREF=MacAppProgGuide-101.html#MARKER-9-58>"Working With View Resource Templates," beginning on page 425</A>.<P>
<A NAME=HEADING87-105></A>
<H3>Use the Global View Server Object to Create the Pop-up</H3>
 To initialize its main window from a template, the DemoDialogs application calls the <CODE>NewTemplateWindow</CODE> method of the <CODE>gViewServer</CODE> object. It then calls the <CODE>DoCreateViews</CODE> method to create a view object for the pop-up subview, specifying a dialog view from the main window as the pop-up view's superview. As a result, the view containing several sample pop-up menus, including the Baud Rate menu, becomes a subview of the main window.<P>
<PRE>
void TTestApplication::MakeTemplateViews(CommandNumber aCommandNumber)
{
   TWindow *aWindow;
   TDialogView *aDialogView;
   TPopup *aPopup;

   // Create a main window and view.
   aWindow = gViewServer-&gt;NewTemplateWindow(
                              (short)aCommandNumber, NULL);
   FailNIL(aWindow);
   // Get a reference to a dialog view in the window.
   aDialogView = (TDialogView *)(aWindow-&gt;FindSubView('DLOG'));
   FailNIL(aDialogView);
   .
   .
   .
   // Create a subview containing several pop-up menus; specify
   // the dialog view as its superview.
   aPopup = (TPopup *)(gViewServer-&gt;DoCreateViews(
                  NULL, aDialogView, cPopupExample, gZeroVPt)));
   FailNIL(aPopup);
   .
   .
   .
   aWindow-&gt;Open();
}
</PRE>
<A NAME=HEADING87-108></A>
<H2><A NAME=MARKER-2-91></A>Recipe--Adding an Item to the Help Menu</H2>
 The Help menu appears near the right side of the menu bar and displays help-related menu items such as Show Balloons/Hide Balloons. Many programs add an item to this menu to provide application-specific help. MacApp provides a mechanism to add Help menu items and respond to them, though you must supply the code to actually provide help. <P>
 To add a menu item to the Help menu and respond when that item is chosen, you perform the following steps:<P>
<OL>
<LI>Define a command-number constant for the item.
<LI>Override the <CODE>AddHelpMenuItems</CODE> method in your application class and call the <CODE>gMenuBarManager-&gt;AddHelpMenuItem</CODE> method for the item.
<LI>Override the <CODE>DoMenuCommand</CODE> method in an appropriate command-handler class to respond to your command number.<P>
</OL>
 The sample code shown in this recipe is built on the IconEdit application.<P>
<A NAME=HEADING87-115></A>
<H3>Define a Command-Number Constant</H3>
 To identify your Help menu item, you define a command-number constant, as shown in previous recipes, using code like the following:<P>
<PRE>
const CommandNumber cIconHelpMenuItem = 10009;
</PRE>
 Choose a command number outside the range used by MacApp (negative numbers and positive numbers up to 999). Make sure the command number is unique within your application.<P>
<A NAME=HEADING87-119></A>
<H3>Override AddHelpMenuItems in Your Application Class</H3>
 The version of InstallHelpMenuItems in <CODE>TApplication</CODE> does nothing. You override this method by adding a line like the following to the header file for your application class:<P>
<PRE>
virtual void InstallHelpMenuItems(); // Override.
</PRE>
 Then you create a version of InstallHelpMenuItems that adds your menu item to the Help menu. For the IconEdit application, the InstallHelpMenuItems method could look like the following:<P>
<PRE>
void TIconEditApplication::InstallHelpMenuItems() // Override.
{
   // Call a method of the global menu bar manager to install
   // a Help menu item with our defined menu constant.
   gMenuBarManager-&gt;AddHelpMenuItem( &quot;^0 Help&quot;, cIconHelpMenuItem );
}
</PRE>
 The <CODE>AddHelpMenuItem</CODE> method looks for the characters <CODE>^0</CODE> within the passed string and replaces them with the  application's runtime name. The resulting Help menu item text is "IconEdit Help" (if the application name is IconEdit). <CODE>AddHelpMenuItem</CODE> calls the <CODE>TApplication::GetApplicationName</CODE> method, which calls the Toolbox <CODE>GetProcessInformation</CODE> routine to obtain the application's name.<P>
<A NAME=HEADING87-125></A>
<H3>Override DoMenuCommand</H3>
 When a user chooses the Help command, the command number you defined is dispatched to the DoMenuCommand method of the current target object. To handle the command, your application should override the DoMenuCommand method in a command-handling class that is normally part of the target chain--the application class is a good candidate. The IconEdit application might handle the cIconHelpMenuItem command by overriding DoMenuCommand as follows:<P>
<PRE>
void TIconEditApplication::DoMenuCommand (CommandNumber aCommandNumber) 
{

   switch (aCommandNumber)
      {
      
      // Respond to our constant for the Help menu item.
      case cIconHelpMenuItem:
            this-&gt;DoApplicationHelp();
         break;
      .
      .
      .
      }  // End switch.
}
</PRE>
 You implement the DoApplicationHelp method to display application-specific help.<A NAME=MARKER-2-92></A><P>
</BLOCKQUOTE>
<HR>
<center>
<A HREF="MacAppProgGuide-86.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="MacAppProgGuide-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="MacAppProgGuide-158.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="MacAppProgGuide-88.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="MacAppProgGuide-3.html">&copy; Apple Computer, Inc.</A><br>25 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>  
