/*This is a simple application which demonstrates some of the basics, and a little more advancedfeatures of using the new Speech Recognition Manager version 1.5.Because version 1.5 is only for PowerPC, this sample is only for PowerPC.One of the things this sample tries to show is a little of the flexibility of the creation ofphrases that the Mac will listen for.To make a flexible formatted language that I could build a Speech Manager language model from Idecided to make my own custom resource type (and template).  I call this the LANG resource.Basically all it does is specify what you can say, and what to do when you say what you said.The nice thing about these resources means that I can change them and then re-run the app, Idon't have to use any other application to compile a language model.  The bad part is that thelanguage model is simpler (therefore a little more cumbersome and less powerfull), a goodtradeoff I think.The 'LANG' resource is a way of specifying a simple BNF language.  Let me attempt to explainhow it works.1)	'LANG' 128 is read in, this resource must exist.2)	The "Only sub path" flag is checked and if it is non-zero the entire resource is skipped	(because sub paths will be read at another time).3)	The first entry of the 'LANG' resource is read and its flags are checked.3a)	If the flags are all zero then the word is its own path (it's a complete phrase by itself)	and the "Type" and "ID" fields say what to do if this phrase is recognized.3b)	If the flags == 1 then the word is the first part of phrase and the "Type" and "ID" fields	specify the resource to read to get next phrase in the phrase which is being built up.4)	The "Phrase" field is read and is installed as a word for the Mac to listen for.5)	The above steps are repeated until every 'LANG' entry in the current resource has been	entered into the current language.6)	The next 'LANG' resource is processed into its own language until there are no more 'LANG'	resources left to process.An example seems to be in order...  OK, let's take a simple case, 'LANG' 128, the first entryis:Flags  $00000000Type   LANGID     129Phrase VideoWhen the computer recognizes "Video" the program will call the routine which dispatches actionswith 'LANG' and 129 as arguments.  This will cause the program to switch to the language whichwas built from 'LANG' resource #129.  Simple, right?So let's look at 'LANG' 129.  We see that it's fourth entry has its Flags set to 1, which meansthat the Phrase is the beginning of the phrase to be listened for.  Its Type and ID specify'LANG' 142 for the rest of the phrases, so we look there and we find that the three entries areclassified as being "Only sub path" which means that saying these words by themselves meansnothing.So, if the user were to say "Video" the computer is now listening for the various videocommands, one of which is volume XXXXX where XXXXX is either mute, down, or up.  So you can say"volume up", or "volume mute", or "volume down".  Once you say "volume up" the dispatchroutine is called with arguments of 'vol ' and 2 which it knows means to turn up the volume.There are a few commands which are built from three different phrases.  You can build quitecomplicated languages using just this simple model, and this is only a fraction of thecapability of the Speech Recognition Manager.You should look through the 'LANG' resources to get a feel for what you can say, or just throwthem away and create your own language.This example was built around the idea of home automation, but most of the commands do nothingbut beep back at you (signaling they were carried out), since I haven't got around to gettingthe home automation hardware...I have used this framework to add functions to a few simple applications.  I hope you find itusefull as well.I believe that this code works just fine, sometimes it goes to the wrong places in the languagetree, but so far that has been because it mis-understood me.  Probably a poor choice of wordson my part.  Sometimes it just doesn't understand me, again this probably a poor choice of wordson my part.If you find any real bugs (not understanding you, or hearing the wrong word isn't somethingI can fix), please let me know.Mark Cookson, mcookson@apple.comDeveloper Technical SupportApple Computer, Inc.*/