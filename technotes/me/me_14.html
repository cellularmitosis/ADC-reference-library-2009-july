<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"            "http://www.w3.org/TR/REC-html40/loose.dtd"><html><head><LINK REL="stylesheet" HREF="../../adcstyle.css" TYPE="text/css"><LINK REL="stylesheet" HREF="../../style.css" TYPE="text/css"><title>Technical Note ME14: The New Memory Manager and You</title><meta name="keywords" content="Macintosh OS 8 Memory Manager PowerPC Bus error handlers memWZErr"><meta name="Description" content="Technical Note ME14: This Technical Note describes changesin the Modern Memory Manager that you need to be aware of.Changes discussed pertain to bus error protection (bus errorhandlers), Bus error return values, problems with free blocks,A5 World problems, and  Heap Callback procedures."><meta name="categories" content="Memory"><meta name="week-posted" content="Nov 29, 1993 - Dec 3, 1993"><LINK REL="stylesheet" HREF="../../css/adcstyle.css" TYPE="text/css"><script language="JavaScript" type="text/javascript" src="../../js/adc.js"></script></HEAD><BODY BGCOLOR="#FFFFFF" TEXT="#000000"><a name="//apple_ref/doc/uid/DTS10002539" title="The New Memory Manager and You"></a><a name="top"></a><!-- top_of_header_marker_comment --><!-- begin_header_information --><!--#include virtual="/adcnavbar" --><p><a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../technicalnotes/index.html">Technical Notes</a> &gt; <a href="../../technicalnotes/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../technicalnotes/LegacyTechnologies/idxMacOS9Earlier-date.html">Mac OS 9 & Earlier</a> &gt; </p><div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="../../referencelibrary/index.html" target="_blank">Reference Library</a></li>
	</ul>
</div>




</div></div></div><!-- end_header_information --><!-- bottom_of_header_marker_comment --><!-- top_of_titles_marker_comment --><CENTER><table width="600" cellpadding="0" cellspacing="0" border="0">
<tr><td align="left" scope="row">
<h1>
<div id="pagehead">Technical Note ME14</div>
<div id="pageheadsub">The New Memory Manager and You</div>
</h1>
</td></tr></table></CENTER><!-- bottom_of_titles_marker_comment --><CENTER><TABLE BORDER=0 CELLSPACING=1 WIDTH=600><TR><td align="left"><!-- begin_header_box --><table width="600" cellpadding="0" cellspacing="0" border="0">    <tr>        <td width=300 valign="top" align=left scope="row">            <table border="0" width="300" cellpadding="0" cellspacing="0">			<tr>                        <td width=300 align=left> <img src="images/tnmenutop.gif" alt="" align="bottom" width=300 height=7></td>                </tr>                <tr bgcolor="#e6e6e6">                    <td background="images/tnmenubody.gif" width=300 align=left>                                         <span id="menutitle">                            CONTENTS                             <br>                            <br>                        </span>                    </td>                </tr>                <tr bgcolor="#e6e6e6">                    <td background="images/tnmenubody.gif" width=300 align=left>					<!-- begin_toc -->										<p id="menutext"><A HREF="#Section1">Introduction</a><BR><BR> <A HREF="#Section2">Bus Error Return Values</a><BR><BR> <A HREF="#Section3">Free Block Miscellanea</a><BR><BR> <A HREF="#Section4">A5 World Problems and Heap Callback Procedures</a><BR><BR> <A HREF="#Section5">Conclusion</a><BR><BR>  <A HREF="#References">References</A><BR><BR> <A HREF="#Downloads">Downloadables</A></P>                   <!-- end_toc -->                  </td>                </tr>                <tr>                    <td width=300 align=left scope="row">                        <img src="images/tnmenubottom.gif" alt="" width=300 height=16>                    </td>                </tr>            </table>        </td>        <td width=300 valign="top" align=left><!-- begin_intro_text --><P id = "introtext">This Technical Note describes changes in the Modern Memory Manager that youneed to be aware of.  Specifically take note of the changes to the bus errorhandlers in the first section.</p><!-- end_intro_text --><!-- begin_date --><h3 align=center>[Dec 01 1993]</h3><!-- end_date -->                </TD>             </TR>          </TABLE>          <!-- end_table_box --> <BR><BR><hr width=500 align=center><BR><BR><!-- begin_content --><a name="Section1"></a><h2>Introduction</h2><p>The introduction of the PowerPC Macintosh also introduces a new Memory Manager.Many of the splendid features of this new implementation have already beendiscussed in tech note Memory 13.  Weary travelers may have noted some strangebehavior though, and this note attempts to answer most of the remaining bigquestions you may have about it.</p> <P><A HREF="#top">Back to top</A></P><h2>Bus Error Handlers</h2><p>When 32-bit QuickDraw was introduced around the Macintosh IIci, it becameimmediately possible that frame buffers would exceed the maximum address spaceavailable within a Macintosh NuBus slot with 24-bit addressing.  (As you mayremember, NuBus slots have only 1/16th of the addressable space when accessedin 24-bit mode).  This problem was initially solved by making a 32-bitaddressing mode that could be enabled via <code>_SwapMMUMode</code>.  The swapwould allow the entire frame buffer to be accessed, but would also cause the24-bit Memory Manager and application clients to crash when they tried to use24-bit clean master pointers.  In order to minimize MMU swapping, bus errorhandlers were installed in the Memory Manager to catch rouge addresses that maybe propagated by QuickDraw.  If a 24-bit clean handle was passed by QuickDrawto the Memory Manager when the MMU was swapped to 32-bit mode, the ensuing buserror would fire the bus error handler, which would run the address thru<code>_SwapMMUMode</code> and try again, failing only after trying once.</p><p>When the 32-bit clean Memory Manager was introduced, a (then-helpful) sideeffect of the bus error handlers was to filter bad addresses and gracefullyreturn an error code instead of crashing.  Unfortunately, bus error handlersare still there watching out for 24-bit handles.  Programmers may not bepassing in bad handles any more, but the bus error handlers watch to make surethat all the major dereferences to find the zone do not fail.  Because thehandlers were there protecting you from yourself (much like the USA does withseat belt laws), you didn't notice some faulty address calculations in yourcode actually cause a bus error in the Memory Manager.  All your code wouldhave seen is a -111, <code>memWZErr</code>, or -113, <code>memAZErr</code>.  If youweren't checking these (for instance after an <code>_HLock</code>), your code would have made it through Quality Assurance and you would have shipped.</p><p>Commonly, these faulty calculations come from assuming the size and shapes ofblock and heap headers.  This is a bad thing.  The sizes of block and heapheaders have both changed with the Modern Memory Manager, and are bound tochange again in the future.  Don't rely on undocumented features, includingfeatures such as structure sizes that you deduced from the documentation butwere not explicitly documented.  If you have concerns whether you will break inthe future, it is best to contact DTS now.</p><h3>What Was Done</h3><p>Unfortunately, the bus error protection provided by the Memory Manager was verytime consuming, and with the introduction of future operating systems thatprotect these vectors, it was not going to get any faster.  Most importantly,now that addresses are always real logical addresses, the handlers are justextra baggage.  The best option was to completely remove the handlers, and thiswas tried unsuccessfully in early versions of the Modern Memory Managershipping with PowerPC.  Unfortunately, there are still too many importantclients that rely on the side effects provided to simply remove them.</p><p>Out of the ashes of this came a happy medium.  On the PowerPC machines with theModern Memory Manager, bus error handlers are installed, but the first stop onthe exception journey is to the PowerPC debugger, not directly to the MemoryManager exception handler.  Should you be one of the lucky abusers of theMemory Manager, you will see the debugger stop in the Memory Manager code withan "Access Fault."  Unlike using <code>EvenBetterBusError</code> though, you are able torecover from this.  In the 'Control' menu of the PowerPC debugger, there is a"Propagate Exception" item.  If the debugger host is not connected to the nub,the nub will eventually time out and propagate the exception on it's own,resulting in an apparent 'freeze' every so often as the nub times out beforepassing on the exception.</p><p>Remember when you propagate the exception, your chance to debug the problem islost.  Fixing these problems in your own source early on is the best way tofeel confident that late in testing you will not have to propagate exceptions,only to find that it wasn't the Memory Manager, and that there was no exceptionhandler to catch your fall. </p><p>There are some lessons to be learned here.  The first is if you administratesystems as a hobby or know of someone who does, be sure that they do not putthe PowerPC Debugger Nub on end-user PowerPC machines.  Users will be confusedas their machines freeze for 15-30 seconds at a time, then suddenly continue atthe blazing speed PowerPC's are known and loved for.  The second lesson is thatif you are developing on a PowerPC and you see an access fault, try to trackdown who it is.  If it is in your code, fix it.  If it is in someone else'scode, try to contact them and get them to fix it.  If you like the set ofExtensions, Control Panels, and Applications you are currently using and theycause access faults, you will be mighty unhappy when the safety net is removedand they don't all work in the next release.  Your letter or phone call to thedeveloper might make the difference.  And if it is your code, it is puresuicide not to test at this point on a PowerPC.</p><p>The bus error handlers, even though they are implemented better than theirancestors, are not cheap.  They <i>will</i> be removed at the next speedrelease. </p> <P><A HREF="#top">Back to top</A></P><a name="Section2"></a><h2>Bus Error Return Values</h2><p>On the subject of the bus error handlers, the Modern Memory Manager no longerreturns both -111, <code>memWZErr</code> and -113, <code>memAZErr</code>.  Only -111,<code>memWZErr</code> is returned, no matter whether the bus exception occurred inthe dereference of a zone or memory address.</p><p>The difference between these errors was the by product of the need to know whichaddress needed to be passed to <code>_StripAddress</code>.  Depending on the error,either the heap or memory reference would be stripped, and the entire operationwould be repeated.  Since the Modern Memory Manager only works on 32-bit cleansystems, this is not an issue.  While the old behavior could have beenimplemented, the cost to install separate handlers as different code paths areentered is prohibitive.  As such, the more commonly returned error, -111,<code>memWZErr</code> is always returned when a bus error happens in the MemoryManager, at least until the next release when the handlers are removed and thesystem will simply crash.</p> <P><A HREF="#top">Back to top</A></P><a name="Section3"></a><h2>Free Block Miscellanea</h2><p>While on the subject of the new Memory Manager, it is important to remind youthat disposing blocks is hazardous to their integrity.  Random data scattered throughout the newly freed block are targets for our gratuitous and spiteful clobbering. This has been documented before but it never hurts to mention it again.</p><p>While this point was undoubtedly well taken, only top scorers on KON &amp;BAL's Puzzle Page figured out that there are other side effects that will bringthis behavior to life.  While this is no attempt to list all of them, thegeneral ideas here will be enough to seed your imagination, and maybe even geta better score on the next Puzzle Page.</p><p>The first is closing out a resource file while the data in the resourcesbelonging to that file are still in use.  Inside Mac tells you that<code>_CloseResFile</code>, among other things, walks the resource map and "foreach resource in the resource file, releases the memory it occupies by callingthe <code>_ReleaseResource</code> procedure".  <code>_ReleaseResource</code> of coursecalls <code>_DisposeHandle</code>.  We all know what <code>_DisposeHandle</code> doesto your data by now; data integrity was not in the list.  The moral is that youshouldn't close out a resource file until you are done with all of theresources that were contained in it, unless you explicitly call<code>_DetachResource</code> on each resource you intend to keep using before youclose the file.</p><p>A similar situation occurs when there is a purgeable handle (includingpurgeable resources) around and you expect to use it after calling somethingthat allocates memory.  This has always been a problem, but can be a problem indifferent ways now that the integrity of freed blocks is guaranteed nil and thedynamics of the memory manager are different, including different algorithmsand different block sizes causing the different algorithms to act differently(see, things really are different).  One bug we saw recently was that <code>_AddResource</code> was being called on a purgeable handle.  If <code>_AddResource</code> decides that the resource map for the file needs to be grown, the heap may well be compacted, thereby purging the resource.  This will clobber the data in the block, causing the data that was added to be mangled.</p><p>You can find these pretty easily though.  Using the <code>ZapHandles</code> extension, youwould immediately fail in any attempt to use a disposed block because the <code>_DisposeHandle</code> and <code>_DisposePtr</code> get head patched to clobber the data in the block. No waiting around with this extension, your program will crash very soon after the block is used again.  Other problems with purgeable blocks, among other things, can be found with Heap Scramble, a feature of your favorite debugger.  Be sure to get a debugger that is compatible with the new Memory Manager; old versions are a shining example of why not to rely on the structure of blocks (they have an excuse though).  This will tend to blast away blocks that don't have a permanent home. Shipping aproduct without trying Heap Scramble first usually ends up as an exercise in embarrassment.</p> <P><A HREF="#top">Back to top</A></P><a name="Section4"></a><h2>A5 World Problems and Heap Callback Procedures</h2><p>Many Memory Manager savvy applications use Grow Zone and Purge procedures toindicate when they should clean up or release memory so that the system cancontinue to function.  A common technique is to register a grow zone procedure(using <code>_SetGrowZone</code> or the like) that is called upon to release orresize smaller a block of memory allocated when memory is plentiful, often atapplication launch.  Applications commonly track space that can be freed inglobal pointers or structures that are accessible through the A5 world.  Assuch, the A5 world must be set up by the Memory Manager before the grow zoneprocedure is called.  This is commonly done by calling <code>_CurrentA5</code>, andsetting the 680x0 register accordingly.</p><p>Unfortunately, <code>_CurrentA5</code> may not always reflect the correct A5 valuefor the heap that is being operated on.  This is true in rare cases such as anapplication in the background that is both critically low on memory and whoseupdate or visible regions need to be changed to reflect changes that theforeground applications are making to the screen.  Because updates to thescreen do not actually cause the Process Manager to do a minor switch,<code>_CurrentA5</code> will not be properly set.  If the region of the backgroundapplication that is critically low on memory needs to grow <u>and</u> theapplication has a grow zone procedure registered which relies on the parentapplications A5 world <u>and</u> the grow zone needs to be called to free upmemory, the grow zone procedure will be called with the frontmost application'sA5 value, since it comes from <code>_CurrentA5</code> .  This will of course causeall hell to break loose as the grow zone procedure tries to use data it thoughtwas at a specific offset off A5, when in fact that data is some otherapplication's different use of the offset.</p><p>Since this problem is so rare, we did not come across it until just recently.Options for those truly stuck by this or not interested in finding this is aproblem later include tracking your own A5 via <code>_Gestalt</code> or some otherglobal registration scheme.</p> <P><A HREF="#top">Back to top</A></P><a name="Section5"></a><h2>Conclusion</h2><p>With the exception of the Heap Callback problems, the gray area of whereprograms work but are not really correct in the eyes of the Memory Manager isgetting smaller.  This may seem like a burden, but all of these points areproblems waiting to happen, whether you are using the Traditional or ModernMemory Manager.  Correcting them now will ensure that as the rules getstricter, you are not left in the compatibility doghouse with your customers.</p><P><A HREF="#top">Back to top</A></P><a name="References"></a><h2>References</h2><p><i>Inside Macintosh</i>, Designing Cards and Drivers for Macintosh</p><p>Technical Note <u><A HREF = "me_13.html">Memory #13</a></u></p> <P><A HREF="#top">Back to top</A></P>                           <P><A NAME=Downloads></A></P>                  <h2>Downloadables</h2>                  <TABLE BORDER=0 CELLPADDING=3 WIDTH="100%">            <TR>               <td width=50 align=left>                  <P ALIGN=center><img src="images/acrobatsmall.gif" width=22 height=23 align=middle alt="Acrobat gif"></P>               </TD>               <td align="left">                  <P>Acrobat version of this Note (46K)</P>               </TD>               <td width=60 align=left>                  <P><A HREF="pdf/me_14.pdf">Download</A></P>               </TD>            </TR>                     </TABLE>         <BR>                  <P><A HREF="#top">Back to top</A></P></TD></TR></TABLE></CENTER><!-- end_content --><!-- begin_footer_information -->	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/technotes/me/me_14.html%3Fid%3DDTS10002539-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/technotes/me/me_14.html%3Fid%3DDTS10002539-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/technotes/me/me_14.html%3Fid%3DDTS10002539-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>
<!--#include virtual="/includes/footer"--><!-- end_footer_information --></BODY></HTML>