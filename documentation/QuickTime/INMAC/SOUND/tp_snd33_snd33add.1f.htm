<!-- legacy work start --><!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"        "http://www.w3.org/TR/html4/loose.dtd"><!-- legacy work end --><HTML><HEAD><META NAME="GENERATOR" CONTENT="Adobe FrameMaker 5.5/HTML Export Filter"><TITLE> Sound Manager Routines (deprecated)</title><!-- legacy work start -->        <META NAME="Generator" CONTENT="manual">        <META http-equiv="content-type" CONTENT="text/html;charset=utf-8">        <META NAME = "Copyright" CONTENT="Copyright 2007 Apple Inc. All Rights Reserved.">        <META NAME="IndexTitle" CONTENT="Sound Input Manager (Not Recommended)">        <meta name="xcode-display" content="render">        <LINK REL="stylesheet" TYPE="text/css" HREF="../../../Resources/CSS/frameset_styles.css"> <!-- before submitting, globally replace ".." with "developer.apple.com" -->        <script type="text/javascript" language="JavaScript" src="../../../Resources/JavaScript/page.js"></script><!-- legacy work end --></HEAD><BODY BGCOLOR="#ffffff"><!-- start of header --><!--#include virtual="/includes/framesetheader" --><!-- end of header --><!-- path goes here --><!-- QTnavbar start --><P><I>Mac OS Sound</I><P>| <A target="doc" HREF="tp_snd33_snd33add.1e.htm">Previous</A> | <A target="doc" HREF="tp_snd33_snd33add.1.htm">Chapter Contents</A> | <A target="doc" HREF="tp_snd33_snd33add.htm">Chapter Top</A> | <!-- QTnavbar end --><!-- legacy work start --><script type="text/javascript"> placeWatermark()</script><div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox" style="position: relative;"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b><i>Sound Input Manager</i> is deprecated as of Mac OS X v10.5. For new audio development in Mac OS X, use Core Audio. See the <a href="http://developer.apple.com/referencelibrary/MusicAudio/" target="_top">Audio</a> page in the ADC Reference Library.</p></div></div></div><!-- legacy work end --><H1 CLASS="H1.Heading1"><A NAME="pgfId=18623"> </A>Sound Manager Routines</H1><P CLASS="T1.Text1"><A NAME="pgfId=18624"> </A>The following are new Sound Manager routines added since the release of Sound Manager 3.0.</P><DIV><H3 CLASS="RoH.RoutineHeading"><A NAME="pgfId=18626"> </A><A NAME="marker=18625"> </A>SndGetInfo and SndSetInfo</H3><CODE CLASS="RD.RoutineDeclare"><A NAME="pgfId=83975"> </A>extern pascal OSErr SndGetInfo(<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SndChannelPtr chan, OSType selector, <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void *infoPtr);<BR></CODE><CODE CLASS="RD.RoutineDeclare"><A NAME="pgfId=83979"> </A>extern pascal OSErr SndSetInfo(<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SndChannelPtr chan, OSType selector, <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const void *infoPtr);<BR></CODE><P CLASS="T1.Text1"><A NAME="pgfId=18629"> </A>The two new routines <TT CLASS="cv">SndGetInfo</TT> and <TT CLASS="cv">SndSetInfo</TT> are used to get and set information about the sound environment. Both routines use a selector based interface similar to the <TT CLASS="cv">SPBGetDeviceInfo</TT> and <TT CLASS="cv">SPBSetDeviceInfo</TT> routines found in the Sound Input Manager, and in fact they use the same sound information selectors.</P><P CLASS="T1.Text1"><A NAME="pgfId=18630"> </A><TT CLASS="cv">SndGetInfo</TT> and <TT CLASS="cv">SndSetInfo</TT> operate on an open Sound Manager channel, and can be used to retrieve and change information about the channel, including hardware settings. These routines should be used instead of attempting to communicate directly with sound components.</P><P CLASS="T1.Text1"><A NAME="pgfId=18631"> </A>These new calls are only available with Sound Manager version 3.1 or later. Check for this by calling <TT CLASS="cv">SndSoundManagerVersion</TT> for the installed version. Note that you can always open a sound channel for the hardware device that you desire by passing <TT CLASS="cv">kUseOptionalOutputDevice</TT> as the synth parameter and the component reference as the init parameter.</P><CODE CLASS="Cv.Code"><A NAME="pgfId=83983"> </A>OSErr OpenChannel(OSType myType)<BR>{<BR>&nbsp;&nbsp;&nbsp;&nbsp;ComponentDescription  &nbsp;&nbsp;searching;<BR>&nbsp;&nbsp;&nbsp;&nbsp;Component  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outputDevice;<BR>&nbsp;&nbsp;&nbsp;&nbsp;OSErr  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;err;<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;// search for a sound output device component<BR>&nbsp;&nbsp;&nbsp;&nbsp;searching.componentType = kSoundOutputDeviceType;<BR>&nbsp;&nbsp;&nbsp;&nbsp;searching.componentSubType = myType;<BR>&nbsp;&nbsp;&nbsp;&nbsp;searching.componentManufacturer = kAnyComponentManufacturer;<BR>&nbsp;&nbsp;&nbsp;&nbsp;searching.componentFlags = 0;<BR>&nbsp;&nbsp;&nbsp;&nbsp;searching.componentFlagsMask = kAnyComponentFlagsMask;<BR>&nbsp;&nbsp;&nbsp;&nbsp;outputDevice = nil;<BR>&nbsp;&nbsp;&nbsp;&nbsp;outputDevice = FindNextComponent(outputDevice, &amp;searching);<BR><BR>&nbsp;&nbsp;&nbsp;&nbsp;if (outputDevice == nil)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;err = cantFindHandler; /*component not found*/<BR>&nbsp;&nbsp;&nbsp;&nbsp;else<BR>&nbsp;&nbsp;&nbsp;&nbsp;{<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gChan = nil;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;err = SndNewChannel(&amp;gChan, kUseOptionalOutputDevice,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(long)outputDevice, nil);<BR>&nbsp;&nbsp;&nbsp;&nbsp;}<BR>&nbsp;&nbsp;&nbsp;&nbsp;return (err);<BR>}<BR></CODE><P CLASS="T1.Text1"><A NAME="pgfId=18633"> </A>For example, to determine the current hardware sampling rate of the given sound channel you may use this code:</P><CODE CLASS="Cv.Code"><A NAME="pgfId=83987"> </A>UnsignedFixed sampleRate;<BR>err = SndGetInfo(gChan, siSampleRate, &amp;sampleRate);<BR>GetSoundOutputInfo() and SetSoundOutputInfo()<BR>pascal OSErr GetSoundOutputInfo(Component outputDevice, OSType selector,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void *infoPtr);<BR>pascal OSErr SetSoundOutputInfo(Component outputDevice, OSType selector,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const void *infoPtr);<BR></CODE><P CLASS="T1.Text1"><A NAME="pgfId=18635"> </A>These two routines get and set information about the sound environment: <TT CLASS="cv">GetSoundOutputInfo</TT> and <TT CLASS="cv">SetSoundOutputInfo</TT>. Both routines use a selector based interface similar to the <TT CLASS="cv">SPBGetDeviceInfo</TT> and <TT CLASS="cv">SPBSetDeviceInfo</TT> routines found in the Sound Input Manager, and in fact they use the same sound info selectors.</P><P CLASS="T1.Text1"><A NAME="pgfId=18636"> </A><TT CLASS="cv">GetSoundOutputInfo</TT> and <TT CLASS="cv">SetSoundOutputInfo</TT> operate directly on a sound output device, and can be used to retrieve and change information about the hardware settings. These routines should be used instead of attempting to communicate directly with sound output components. Setting the output device parameter to nil causes the default output device to be used. These calls are similar to <TT CLASS="cv">GetSndInfo</TT> and <TT CLASS="cv">SetSndInfo</TT> but do not require an opened sound channel. For example, to determine the sampling rate of the sound hardware on the default output device, you could use this code:</P><CODE CLASS="Cv.Code"><A NAME="pgfId=83991"> </A>OSErr GetCurrentSampleRate(UnsignedFixed *sampleRate)<BR>&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;<BR></CODE><CODE CLASS="Cv.Code"><A NAME="pgfId=83995"> </A>OSErr err;<BR>&nbsp;&nbsp;&nbsp;&nbsp;err = GetSoundOutputInfo(nil, siSampleRate, sampleRate);<BR>return (err);<BR>}<BR></CODE></DIV><DIV><H3 CLASS="RoH.RoutineHeading"><A NAME="pgfId=18640"> </A><A NAME="marker=18639"> </A>ParseAIFFHeader</H3><CODE CLASS="RD.RoutineDeclare"><A NAME="pgfId=83999"> </A>pascal OSErr ParseAIFFHeader(<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;short fRefNum, SoundComponentData *sndInfo,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned long *numFrames, <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned long *dataOffset);<BR></CODE><P CLASS="T1.Text1"><A NAME="pgfId=18642"> </A>The <TT CLASS="cv">ParseAIFFHeader</TT> routine returns information describing the audio data in the given AIFF file. The <TT CLASS="cv">fRefNum</TT> parameter specifies the open AIFF file to use. The <TT CLASS="cv">sndInfo</TT> parameter is a <TT CLASS="cv">SoundComponentData</TT> structure that returns the following information about the format of the sound in the AIFF file:</P><P CLASS="DT.DefinitionTerm"><A NAME="pgfId=23957"> </A><TT CLASS="cv">flags</TT> </P><BLOCKQUOTE CLASS="DD.DefinitionDef"><A NAME="pgfId=18643"> </A>Always returns 0</BLOCKQUOTE><P><P CLASS="DT.DefinitionTerm"><A NAME="pgfId=23966"> </A><TT CLASS="cv">format</TT> </P><BLOCKQUOTE CLASS="DD.DefinitionDef"><A NAME="pgfId=18644"> </A>The sound format (i.e., 'raw', 'twos', 'MAC3', etc.)</BLOCKQUOTE><P><P CLASS="DT.DefinitionTerm"><A NAME="pgfId=23975"> </A><TT CLASS="cv">numChannels</TT> </P><BLOCKQUOTE CLASS="DD.DefinitionDef"><A NAME="pgfId=18645"> </A>The number of channels (i.e., 1 = mono, 2 = stereo)</BLOCKQUOTE><P><P CLASS="DT.DefinitionTerm"><A NAME="pgfId=23984"> </A><TT CLASS="cv">sampleSize</TT> </P><BLOCKQUOTE CLASS="DD.DefinitionDef"><A NAME="pgfId=18646"> </A>The sample size (i.e., 8 = 8-bit, 16 = 16-bit)</BLOCKQUOTE><P><P CLASS="DT.DefinitionTerm"><A NAME="pgfId=23993"> </A><TT CLASS="cv">sampleRate</TT></P><BLOCKQUOTE CLASS="DD.DefinitionDef"><A NAME="pgfId=18647"> </A>The sampling rate (in samples/second)</BLOCKQUOTE><P><P CLASS="DT.DefinitionTerm"><A NAME="pgfId=24002"> </A><TT CLASS="cv">sampleCount</TT> </P><BLOCKQUOTE CLASS="DD.DefinitionDef"><A NAME="pgfId=18648"> </A>The number of audio samples in the file</BLOCKQUOTE><P><P CLASS="DT.DefinitionTerm"><A NAME="pgfId=24011"> </A><TT CLASS="cv">buffer</TT> </P><BLOCKQUOTE CLASS="DD.DefinitionDef"><A NAME="pgfId=18649"> </A>Always returns 0</BLOCKQUOTE><P><P CLASS="DT.DefinitionTerm"><A NAME="pgfId=24020"> </A><TT CLASS="cv">reserved</TT> </P><BLOCKQUOTE CLASS="DD.DefinitionDef"><A NAME="pgfId=18650"> </A>Always returns 0</BLOCKQUOTE><P><P CLASS="T1.Text1"><A NAME="pgfId=18651"> </A>The <TT CLASS="cv">numFrames</TT> parameter returns the number of frames of audio data in the file, and the <TT CLASS="cv">dataOffset</TT> parameter returns the byte offset of the first audio sample in the file.</P></DIV><DIV><H3 CLASS="RoH.RoutineHeading"><A NAME="pgfId=18653"> </A><A NAME="marker=18652"> </A>ParseSndHeader</H3><CODE CLASS="RD.RoutineDeclare"><A NAME="pgfId=84003"> </A>pascal OSErr ParseSndHeader(<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SndListHandle sndHandle,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SoundComponentData *sndInfo, <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned long *numFrames,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned long *dataOffset);<BR></CODE><P CLASS="T1.Text1"><A NAME="pgfId=18655"> </A>The <TT CLASS="cv">ParseSndHeader</TT> routine returns information describing the audio data in the given <TT CLASS="cv">'snd '</TT> resource handle. The <TT CLASS="cv">sndHandle</TT> parameter specifies the sound handle to use. The <TT CLASS="cv">sndInfo</TT> parameter is a <TT CLASS="cv">SoundComponentData</TT> structure that returns the following information about the format of the sound in the handle:</P><P CLASS="DT.DefinitionTerm"><A NAME="pgfId=24033"> </A><TT CLASS="cv">flags</TT> </P><BLOCKQUOTE CLASS="DD.DefinitionDef"><A NAME="pgfId=18656"> </A>Always returns 0</BLOCKQUOTE><P><P CLASS="DT.DefinitionTerm"><A NAME="pgfId=24042"> </A><TT CLASS="cv">format</TT> </P><BLOCKQUOTE CLASS="DD.DefinitionDef"><A NAME="pgfId=18657"> </A>The sound format (i.e., 'raw', 'twos', 'MAC3', etc.)</BLOCKQUOTE><P><P CLASS="DT.DefinitionTerm"><A NAME="pgfId=24051"> </A><TT CLASS="cv">numChannels</TT> </P><BLOCKQUOTE CLASS="DD.DefinitionDef"><A NAME="pgfId=18658"> </A>The number of channels (i.e., 1 = mono, 2 = stereo)</BLOCKQUOTE><P><P CLASS="DT.DefinitionTerm"><A NAME="pgfId=24060"> </A><TT CLASS="cv">sampleSize</TT> </P><BLOCKQUOTE CLASS="DD.DefinitionDef"><A NAME="pgfId=18659"> </A>The sample size (i.e., 8 = 8-bit, 16 = 16-bit)</BLOCKQUOTE><P><P CLASS="DT.DefinitionTerm"><A NAME="pgfId=24069"> </A><TT CLASS="cv">sampleRate</TT></P><BLOCKQUOTE CLASS="DD.DefinitionDef"><A NAME="pgfId=18660"> </A>The sampling rate (in samples/second)</BLOCKQUOTE><P><P CLASS="DT.DefinitionTerm"><A NAME="pgfId=24078"> </A><TT CLASS="cv">sampleCount</TT> </P><BLOCKQUOTE CLASS="DD.DefinitionDef"><A NAME="pgfId=18661"> </A>The number of audio samples in the file</BLOCKQUOTE><P><P CLASS="DT.DefinitionTerm"><A NAME="pgfId=24087"> </A><TT CLASS="cv">buffer</TT> </P><BLOCKQUOTE CLASS="DD.DefinitionDef"><A NAME="pgfId=18662"> </A>Always returns 0</BLOCKQUOTE><P><P CLASS="DT.DefinitionTerm"><A NAME="pgfId=24096"> </A><TT CLASS="cv">reserved</TT> </P><BLOCKQUOTE CLASS="DD.DefinitionDef"><A NAME="pgfId=18663"> </A>Always returns 0</BLOCKQUOTE><P><P CLASS="T1.Text1"><A NAME="pgfId=18664"> </A>The <TT CLASS="cv">numFrames</TT> parameter returns the number of frames of audio data in the handle, and the <TT CLASS="cv">dataOffset</TT> parameter returns the byte offset of the first audio sample in the handle.</P></DIV><DIV><H3 CLASS="RoH.RoutineHeading"><A NAME="pgfId=18666"> </A><A NAME="marker=18665"> </A>GetCompressionInfo</H3><CODE CLASS="RD.RoutineDeclare"><A NAME="pgfId=84007"> </A>pascal OSErr GetCompressionInfo(<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;short compressionID, OSType format,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;short numChannels, short sampleSize, CompressionInfoPtr cp);<BR></CODE><P CLASS="T1.Text1"><A NAME="pgfId=18668"> </A>For a given AIFF file or snd resource, the information contained within it might be used to determine basic characteristics of the sound such as its duration.</P><CODE CLASS="Cv.Code"><A NAME="pgfId=84011"> </A>duration = numSampleFrames / sampleRate<BR></CODE><P CLASS="T1.Text1"><A NAME="pgfId=18670"> </A>Note that this is a valid calculation for an uncompressed sound. But this calculation returns an incorrect result for a compressed sound. The problem here is that each sample frame in a compressed sound is composed of one or more packets rather than sample points (see <A target="doc" HREF="imsoundmgr.6.htm#pgfId=3091">&quot;Sampled-Sound Data&quot;</A>), and each packet in that compressed sound can itself represent several sample points. We therefore need a way to determine the number of samples in a packet in order to get an accurate calculation.</P><P CLASS="T1.Text1"><A NAME="pgfId=18674"> </A>The compressionID parameter defines the compression algorithm used on the sample. The AIFF-C Extended Common Chunk does not contain a <TT CLASS="cv">compressionID</TT> field. In this case (and when using snd resources where the <TT CLASS="cv">OSType</TT> describing the compression format is known) you should always pass the constant <TT CLASS="cv">fixedCompression</TT> in this parameter and the <TT CLASS="cv">OSType</TT> in the format parameter. The format field will then contain the <TT CLASS="cv">OSType</TT> representing the compression format. If you set the <TT CLASS="cv">compressionID</TT> field in a compressed sound header to any value other than <TT CLASS="cv">fixedCompression</TT>, then the format field is set to zero. The format parameter is the <TT CLASS="cv">OSType</TT> describing the format of the compressed sound data. If you pass the constant <TT CLASS="cv">fixedCompression</TT> in the <TT CLASS="cv">compressionID</TT> parameter you will need to pass a valid compression type here. Some of the valid format types are:</P><CODE CLASS="Cv.Code"><A NAME="pgfId=84015"> </A>NONE - sound is not compressed<BR></CODE><CODE CLASS="Cv.Code"><A NAME="pgfId=84019"> </A>MAC3 - compression format is MACE 3:1<BR></CODE><CODE CLASS="Cv.Code"><A NAME="pgfId=84023"> </A>MAC6 - compression format is MACE 6:1<BR></CODE><CODE CLASS="Cv.Code"><A NAME="pgfId=84027"> </A>ima4 - compression format is IMA 4:1<BR></CODE><P CLASS="T1.Text1"><A NAME="pgfId=18679"> </A>There are some snd resources that do not store an <TT CLASS="cv">OSType</TT> in the format field of the compressed sound header describing the compression format. You can still use <TT CLASS="cv">GetCompressionInfo</TT> in this case by passing in the <TT CLASS="cv">compressionID</TT> and passing 0 in the format parameter. The correct <TT CLASS="cv">OSType</TT> will be returned in the <TT CLASS="cv">format</TT> field of the <TT CLASS="cv">CompressionInfo</TT> structure. Using the appropriate fields from an AIFF-C Extended Common Chunk or our <TT CLASS="cv">snd</TT> resource compressed sound header, we can make the call to <TT CLASS="cv">GetCompressionInfo</TT>:</P></DIV><DIV><H3 CLASS="RH3.RoutineHd3"><A NAME="pgfId=18680"> </A>Example Extended Common Chunk</H3><CODE CLASS="Cv.Code"><A NAME="pgfId=84031"> </A>&nbsp;&nbsp;&nbsp;&nbsp;myExtendedCommonChunk.ckID = 'COMM';<BR>&nbsp;&nbsp;&nbsp;&nbsp;myExtendedCommonChunk.ckSize = 34;<BR>&nbsp;&nbsp;&nbsp;&nbsp;myExtendedCommonChunk.numChannels = 1;<BR>&nbsp;&nbsp;&nbsp;&nbsp;myExtendedCommonChunk.numSampleFrames = 7633;<BR>&nbsp;&nbsp;&nbsp;&nbsp;myExtendedCommonChunk.sampleSize = 8;<BR>&nbsp;&nbsp;&nbsp;&nbsp;myExtendedCommonChunk.sampleRate = 22254.54545;<BR>&nbsp;&nbsp;&nbsp;&nbsp;myExtendedCommonChunk.compressionType = MAC3;<BR>&nbsp;&nbsp;&nbsp;&nbsp;myExtendedCommonChunk.compressionName = &quot;MACE 3-to-1&quot;;<BR></CODE></DIV><DIV><H3 CLASS="RH3.RoutineHd3"><A NAME="pgfId=18682"> </A>Example Compressed Sound Header</H3><CODE CLASS="Cv.Code"><A NAME="pgfId=84035"> </A>&nbsp;&nbsp;&nbsp;&nbsp;myCompressedSoundHeader.samplePtr = nil;<BR>&nbsp;&nbsp;&nbsp;&nbsp;myCompressedSoundHeader.numChannels = 1;<BR>&nbsp;&nbsp;&nbsp;&nbsp;myCompressedSoundHeader.sampleRate = rate22khz;<BR>&nbsp;&nbsp;&nbsp;&nbsp;myCompressedSoundHeader.encode = cmpSH;<BR>&nbsp;&nbsp;&nbsp;&nbsp;myCompressedSoundHeader.numFrames = 7633<BR>&nbsp;&nbsp;&nbsp;&nbsp;myCompressedSoundHeader.format = 0;<BR>&nbsp;&nbsp;&nbsp;&nbsp;myCompressedSoundHeader.compressionID = threeToOne;<BR>&nbsp;&nbsp;&nbsp;&nbsp;myCompressedSoundHeader.packetSize = threeToOnePacketSize;<BR>&nbsp;&nbsp;&nbsp;&nbsp;myCompressedSoundHeader.snthID = 0;<BR>&nbsp;&nbsp;&nbsp;&nbsp;myCompressedSoundHeader.sampleSize = 8;<BR><BR>// fill in the CompressionInfo from our Extended Common Chunk<BR><BR>OSErr &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;err;<BR>CompressionInfo cmpInfo;<BR><BR><BR>err = GetCompressionInfo(fixedCompression,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(OSType)(myExtendedCommonChunk.compressionType),<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;myExtendedCommonChunk.numChannels,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;myExtendedCommonChunk.sampleSize,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;cmpInfo);<BR><BR>// fill in the CompressionInfo from our Compressed Sound Header<BR><BR>OSErr &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;err;<BR>CompressionInfo cmpInfo;<BR><BR>err = GetCompressionInfo(myCmpSoundHeader-&gt;compressionID,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;myCmpSoundHeader-&gt;format,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;myCmpSoundHeader-&gt;numChannels,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;myCmpSoundHeader-&gt;sampleSize,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;cmpInfo);<BR></CODE><P CLASS="T1.Text1"><A NAME="pgfId=18684"> </A>Note that this call will work for all sound formats, compressed or uncompressed.</P><P CLASS="T1.Text1"><A NAME="pgfId=18685"> </A>Using <TT CLASS="cv">GetCompressionInfo</TT>, the Sound Manager will do the right thing. You get back the information you need in the <TT CLASS="cv">CompressionInfo</TT> struct, with no special casing needed. Upon returning from the call to <TT CLASS="cv">GetCompressionInfo</TT>, you have a filled <TT CLASS="cv">CompressionInfo</TT> struct.</P><CODE CLASS="Cv.Code"><A NAME="pgfId=84039"> </A>recordSize = 20<BR>format = MAC3<BR>compressionID = threeToOne<BR>samplesPerPacket = 6<BR>bytesPerPacket = 2<BR>bytesPerFrame = 2<BR>bytesPerSample = 1<BR></CODE><P CLASS="T1.Text1"><A NAME="pgfId=18687"> </A>Now you can use this information to determine the duration of our sound.</P><CODE CLASS="Cv.Code"><A NAME="pgfId=84043"> </A>duration = (numSampleFrames * samplesPerPacket) / sampleRate<BR></CODE><P CLASS="T1.Text1"><A NAME="pgfId=18689"> </A>By substituting the data given from the example above, you get the following results.</P><CODE CLASS="Cv.Code"><A NAME="pgfId=84047"> </A>2.06 seconds = (7633 * 6) / 22254.54545<BR></CODE><P CLASS="T1.Text1"><A NAME="pgfId=18691"> </A>By including the <TT CLASS="cv">CompressionInfo</TT> struct you should never need to special case code for compressed vs. uncompressed sounds--and all sound data calculations should be correct. </P><P CLASS="T1.Text1"><A NAME="pgfId=18692"> </A>The following is a list of useful calculations that can be made using the data returned in the struct, along with data from our Extended Common Chunk or Compressed Sound Header:</P><CODE CLASS="Cv.Code"><A NAME="pgfId=84051"> </A>seconds = (numFrames * samplesPerPacket) / sampleRate;<BR>samples = numFrames * samplesPerPacket;<BR>bytes = numFrames * bytesPerFrame;<BR>compressionRatio = (samplesPerPacket * bytesPerSample) / bytesPerPacket;<BR></CODE></DIV><DIV><H3 CLASS="RoH.RoutineHeading"><A NAME="pgfId=18695"> </A><A NAME="marker=18694"> </A>GetCompressionName</H3><CODE CLASS="RD.RoutineDeclare"><A NAME="pgfId=84055"> </A>pascal OSErr GetCompressionName(<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OSType compressionType, <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Str255 compressionName);<BR></CODE><P CLASS="T1.Text1"><A NAME="pgfId=18697"> </A>The <TT CLASS="cv">GetCompressionName</TT> routine returns a string describing the given compression format in a string that can be displayed to the user. The <TT CLASS="cv">compressionType</TT> parameter specifies the compression format, and the name is returned in <TT CLASS="cv">compressionName</TT>.</P><P CLASS="T1.Text1"><A NAME="pgfId=18698"> </A>This string can be used in pop-up menus and other user interface elements to allow the user to select a compression format.</P></DIV><DIV><H3 CLASS="RoH.RoutineHeading"><A NAME="pgfId=18700"> </A><A NAME="marker=18699"> </A>SoundConverterGetBufferSizes </H3><CODE CLASS="RD.RoutineDeclare"><A NAME="pgfId=84059"> </A>pascal OSErr SoundConverterGetBufferSizes(<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SoundConverter sc,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned long targetBytes, <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned long *inputFrames,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned long *inputBytes, <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned long *outputBytes);<BR></CODE><P CLASS="T1.Text1"><A NAME="pgfId=18702"> </A><TT CLASS="cv">SoundConverterGetBufferSizes </TT>is used to determine the input and output buffer sizes for a given target size. This is so you can make sure your buffers will fit the conversion parameters established with <TT CLASS="cv">SoundConverterOpen</TT>.</P><P CLASS="T1.Text1"><A NAME="pgfId=18703"> </A>The <TT CLASS="cv">targetBytes</TT> parameter is the approximate number of bytes you would like both your input and output buffers to be. The <TT CLASS="cv">inputFrames</TT> and <TT CLASS="cv">inputBytes</TT> parameters return the actual size you should make your input buffer, in frames and bytes, respectively. The <TT CLASS="cv">outputBytes</TT> parameter returns the size in bytes for your output buffer.</P><P CLASS="Note"><A NAME="pgfId=18704"> </A>The returned input and output buffer sizes can be larger than your target size settings. This is because they are rounded up depending on the format, but they will be very close to the target settings. Also note that the input and output sizes may be very different, depending on the input and output formats given in <TT CLASS="cv">SoundConverterOpen</TT>. The sizes are calculated assuming you will convert all data in the input buffer to the output buffer. </P></DIV><DIV><H3 CLASS="RoH.RoutineHeading"><A NAME="pgfId=18706"> </A><A NAME="marker=18705"> </A>SoundConverterBeginConversion</H3><CODE CLASS="RD.RoutineDeclare"><A NAME="pgfId=84063"> </A>pascal OSErr SoundConverterBeginConversion(SoundConverter sc);<BR></CODE><P CLASS="T1.Text1"><A NAME="pgfId=18708"> </A><TT CLASS="cv">SoundConverterBeginConversion</TT> starts a conversion. All state information is reset to default values in preparation for a new input buffer.</P><P CLASS="T1.Text1"><A NAME="pgfId=18709"> </A>This routine can be called at interrupt time.</P></DIV><DIV><H3 CLASS="RoH.RoutineHeading"><A NAME="pgfId=18711"> </A><A NAME="marker=18710"> </A>SoundConverterConvertBuffer</H3><CODE CLASS="RD.RoutineDeclare"><A NAME="pgfId=84067"> </A>pascal OSErr SoundConverterConvertBuffer(<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SoundConverter sc,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const void *inputPtr, unsigned long inputFrames,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void *outputPtr, unsigned long *outputFrames,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned long *outputBytes);<BR></CODE><P CLASS="T1.Text1"><A NAME="pgfId=18713"> </A><TT CLASS="cv">SoundConverterConvertBuffer</TT> converts a buffer of data from the input format to the output format. The <TT CLASS="cv">inputPtr</TT> parameter points to the input data, and <TT CLASS="cv">inputFrames</TT> gives the number of frames in that buffer. The <TT CLASS="cv">outputPtr</TT> parameter specifies where the output data should be placed. The <TT CLASS="cv">outputFrames</TT> and <TT CLASS="cv">outputBytes</TT> parameters return the number of frames and bytes placed in the output buffer respectively.</P><P CLASS="T1.Text1"><A NAME="pgfId=18714"> </A>This routine will consume all the data in the input buffer. Depending on the complexity of the conversion, however, not all the converted data may be put in the output buffer right away. The <TT CLASS="cv">SoundConverterEndConversion</TT> routine is used to flush out all this remaining data before a conversion session is closed.</P><P CLASS="T1.Text1"><A NAME="pgfId=18715"> </A>If you are using this routine in conjunction with <TT CLASS="cv">SoundConverterGetBufferSizes</TT>, it is very important that you do not pass in a value in <TT CLASS="cv">inputFrames</TT> larger than the frames value returned by <TT CLASS="cv">SoundConverterGetBufferSizes</TT>, or you will overflow your output buffer. The <TT CLASS="cv">SoundConverterConvertBuffer</TT> calls converts ALL the input data! This routine can be called at interrupt time.</P></DIV><DIV><H3 CLASS="RoH.RoutineHeading"><A NAME="pgfId=18717"> </A><A NAME="marker=18716"> </A>SoundConverterEndConversion</H3><CODE CLASS="RD.RoutineDeclare"><A NAME="pgfId=84071"> </A>pascal OSErr SoundConverterEndConversion(<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SoundConverter sc, <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void  *outputPtr, <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned long *outputFrames, <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unsigned long  *outputBytes);<BR></CODE><P CLASS="T1.Text1"><A NAME="pgfId=18719"> </A><TT CLASS="cv">SoundConverterEndConversion</TT> ends a conversion. Any data remaining in the converters is flushed out and returned here.</P><P CLASS="T1.Text1"><A NAME="pgfId=18720"> </A>This routine can be called at interrupt time.</P><P CLASS="T1.Text1"><A NAME="pgfId=18546"> </A>&nbsp;</P></DIV><hr>&#169; 1999 Apple Computer, Inc.<!-- QTnavbar start --><P><I>Mac OS Sound</I><P>| <A target="doc" HREF="tp_snd33_snd33add.1e.htm">Previous</A> | <A target="doc" HREF="tp_snd33_snd33add.1.htm">Chapter Contents</A> | <A target="doc" HREF="tp_snd33_snd33add.htm">Chapter Top</A> | <!-- QTnavbar end --><!-- legacy work start --><script type="text/javascript"> placeWatermark()</script><div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox" style="position: relative;"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b><i>Sound Input Manager</i> is deprecated as of Mac OS X v10.5. For new audio development in Mac OS X, use Core Audio. See the <a href="http://developer.apple.com/referencelibrary/MusicAudio/" target="_top">Audio</a> page in the ADC Reference Library.</p></div></div></div><!-- legacy work end --></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV><!-- start of footer --><!--#include virtual="/includes/framesetfooter" --><!-- end of footer --></BODY></HTML>