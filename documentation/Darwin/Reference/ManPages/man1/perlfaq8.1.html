<html><head><title>Mac OS X
 Manual Page For perlfaq8(1)</title>
<style type="text/css"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { font-size: 1px; background: #ffffff; color: #ffffff; } --></style>
<style type="text/css" media="print, aural, braille, embossed, projection, tty"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { display: none; } --></style>
</head><body bgcolor="white">
<a name="//apple_ref/doc/man/1/perlfaq8" title="Mac OS X
 Manual Page for perlfaq8(1)"><!-- headerDoc=man; indexgroup=Section 1; uid="//apple_ref/doc/man/1/perlfaq8"; name=perlfaq8(1) --></a>
<!--#include virtual="/includes/framesetheader"-->
<table width=600><tr><td scope="row">
<!-- begin breadcrumb insert request --><font face="Geneva,Helvetica,Arial" size="1">
 <a target="_top" href="http://developer.apple.com">ADC Home</a> <b>&gt;</b> <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> <b>&gt;</b> <a href="../../../../../reference/index.html#//apple_ref/doc/uid/TP30001281" target="_top">Reference</a> <b>&gt;</b> <!-- a href="" target="_top" -->Mac OS X<!-- /a --> <b>&gt;</b> <a href="../index.html#//apple_ref/doc/framework/manpages" target="_top">Mac OS X Man Pages</a></font>
<!-- end breadcrumb insert request -->
<p>&nbsp;</p>
</td></tr></table>
<!-- end of header -->
<table border="0"  cellpadding="2" cellspacing="2" width="630pt"><tr><td valign="top" height="12" colspan="5" scope="row">
<p style='text-align:justify;'>This document is a Mac OS X manual page.  Manual pages are a command-line technology
for providing documentation.  You can view these manual pages locally using the
<a href="man.1.html#//apple_ref/doc/man/1/man">man(1)</a> command.
These manual pages come from many different sources, and thus, have a variety of writing
styles.</p>
<p style='text-align:justify;'>For more information about the manual page format, see the manual page for 
<a href="../man5/manpages.5.html#//apple_ref/doc/man/5/manpages">manpages(5)</a>.</p>
</td></tr></table>
<hr />
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row"><pre class="manpages"><tt>
PERLFAQ8(1)                           Perl Programmers Reference Guide                           PERLFAQ8(1)



<b>NAME</b>
       perlfaq8 - System Interaction ($Revision: 1.27 $, $Date: 2005/12/31 00:54:37 $)

<b>DESCRIPTION</b>
       This section of the Perl FAQ covers questions involving operating system interaction.  Topics include
       interprocess communication (IPC), control over the user-interface (keyboard, screen and pointing
       devices), and most anything else not related to data manipulation.

       Read the FAQs and documentation specific to the port of perl to your operating system (eg, perlvms,
       perlplan9, ...).  These should contain more detailed information on the vagaries of your perl.

       <b>How</b> <b>do</b> <b>I</b> <b>find</b> <b>out</b> <b>which</b> <b>operating</b> <b>system</b> <b>I'm</b> <b>running</b> <b>under?</b>

       The $^O variable ($OSNAME if you use English) contains an indication of the name of the operating
       system (not its release number) that your perl binary was built for.

       <b>How</b> <b>come</b> <u>exec()</u> <b>doesn't</b> <b>return?</b>

       Because that's what it does: it replaces your currently running program with a different one.  If you
       want to keep going (as is probably the case if you're asking this question) use <u>system()</u> instead.

       <b>How</b> <b>do</b> <b>I</b> <b>do</b> <b>fancy</b> <b>stuff</b> <b>with</b> <b>the</b> <b>keyboard/screen/mouse?</b>

       How you access/control keyboards, screens, and pointing devices ("mice") is system-dependent.  Try
       the following modules:

       Keyboard
                   Term::Cap               Standard perl distribution
                   Term::ReadKey           CPAN
                   Term::ReadLine::Gnu     CPAN
                   Term::ReadLine::Perl    CPAN
                   Term::Screen            CPAN

       Screen
                   Term::Cap               Standard perl distribution
                   Curses                  CPAN
                   Term::ANSIColor         CPAN

       Mouse
                   Tk                      CPAN

       Some of these specific cases are shown as examples in other answers in this section of the perlfaq.

       <b>How</b> <b>do</b> <b>I</b> <b>print</b> <b>something</b> <b>out</b> <b>in</b> <b>color?</b>

       In general, you don't, because you don't know whether the recipient has a color-aware display device.
       If you know that they have an ANSI terminal that understands color, you can use the Term::ANSIColor
       module from CPAN:

           use Term::ANSIColor;
           print color("red"), "Stop!\n", color("reset");
           print color("green"), "Go!\n", color("reset");

       Or like this:

           use Term::ANSIColor qw(:constants);
           print RED, "Stop!\n", RESET;
           print GREEN, "Go!\n", RESET;

       <b>How</b> <b>do</b> <b>I</b> <b>read</b> <b>just</b> <b>one</b> <b>key</b> <b>without</b> <b>waiting</b> <b>for</b> <b>a</b> <b>return</b> <b>key?</b>

       Controlling input buffering is a remarkably system-dependent matter.  On many systems, you can just
       use the <b>stty</b> command as shown in "getc" in perlfunc, but as you see, that's already getting you into
       portability snags.

           open(TTY, "+&lt;/dev/tty") or die "no tty: $!";
           system "stty  cbreak &lt;/dev/tty &gt;/dev/tty 2&gt;&amp;1";
           $key = getc(TTY);           # perhaps this works
           # OR ELSE
           sysread(TTY, $key, 1);      # probably this does
           system "stty -cbreak &lt;/dev/tty &gt;/dev/tty 2&gt;&amp;1";

       The Term::ReadKey module from CPAN offers an easy-to-use interface that should be more efficient than
       shelling out to <b>stty</b> for each key.  It even includes limited support for Windows.

           use Term::ReadKey;
           ReadMode('cbreak');
           $key = ReadKey(0);
           ReadMode('normal');

       However, using the code requires that you have a working C compiler and can use it to build and
       install a CPAN module.  Here's a solution using the standard POSIX module, which is already on your
       systems (assuming your system supports POSIX).

           use HotKey;
           $key = readkey();

       And here's the HotKey module, which hides the somewhat mystifying calls to manipulate the POSIX
       termios structures.

           # HotKey.pm
           package HotKey;

           @ISA = qw(Exporter);
           @EXPORT = qw(cbreak cooked readkey);

           use strict;
           use POSIX qw(:termios_h);
           my ($term, $oterm, $echo, $noecho, $fd_stdin);

           $fd_stdin = fileno(STDIN);
           $term     = POSIX::Termios-&gt;new();
           $term-&gt;getattr($fd_stdin);
           $oterm     = $term-&gt;getlflag();

           $echo     = ECHO | ECHOK | ICANON;
           $noecho   = $oterm &amp; ~$echo;

           sub cbreak {
               $term-&gt;setlflag($noecho);  # ok, so i don't want echo either
               $term-&gt;setcc(VTIME, 1);
               $term-&gt;setattr($fd_stdin, TCSANOW);
           }

           sub cooked {
               $term-&gt;setlflag($oterm);
               $term-&gt;setcc(VTIME, 0);
               $term-&gt;setattr($fd_stdin, TCSANOW);
           }

           sub readkey {
               my $key = '';
               cbreak();
               sysread(STDIN, $key, 1);
               cooked();
               return $key;
           }

           END { cooked() }

           1;

       <b>How</b> <b>do</b> <b>I</b> <b>check</b> <b>whether</b> <b>input</b> <b>is</b> <b>ready</b> <b>on</b> <b>the</b> <b>keyboard?</b>

       The easiest way to do this is to read a key in nonblocking mode with the Term::ReadKey module from
       CPAN, passing it an argument of -1 to indicate not to block:

           use Term::ReadKey;

           ReadMode('cbreak');

           if (defined ($char = ReadKey(-1)) ) {
               # input was waiting and it was $char
           } else {
               # no input was waiting
           }

           ReadMode('normal');                  # restore normal tty settings

       <b>How</b> <b>do</b> <b>I</b> <b>clear</b> <b>the</b> <b>screen?</b>

       If you only have do so infrequently, use "system":

           system("clear");

       If you have to do this a lot, save the clear string so you can print it 100 times without calling a
       program 100 times:

           $clear_string = `clear`;
           print $clear_string;

       If you're planning on doing other screen manipulations, like cursor positions, etc, you might wish to
       use Term::Cap module:

           use Term::Cap;
           $terminal = Term::Cap-&gt;Tgetent( {OSPEED =&gt; 9600} );
           $clear_string = $terminal-&gt;Tputs('cl');

       <b>How</b> <b>do</b> <b>I</b> <b>get</b> <b>the</b> <b>screen</b> <b>size?</b>

       If you have Term::ReadKey module installed from CPAN, you can use it to fetch the width and height in
       characters and in pixels:

           use Term::ReadKey;
           ($wchar, $hchar, $wpixels, $hpixels) = GetTerminalSize();

       This is more portable than the raw "ioctl", but not as illustrative:

           require 'sys/ioctl.ph';
           die "no TIOCGWINSZ " unless defined &amp;TIOCGWINSZ;
           open(TTY, "+&lt;/dev/tty")                     or die "No tty: $!";
           unless (ioctl(TTY, &amp;TIOCGWINSZ, $winsize='')) {
               die sprintf "$0: ioctl TIOCGWINSZ (%08x: $!)\n", &amp;TIOCGWINSZ;
           }
           ($row, $col, $xpixel, $ypixel) = unpack('S4', $winsize);
           print "(row,col) = ($row,$col)";
           print "  (xpixel,ypixel) = ($xpixel,$ypixel)" if $xpixel || $ypixel;
           print "\n";

       <b>How</b> <b>do</b> <b>I</b> <b>ask</b> <b>the</b> <b>user</b> <b>for</b> <b>a</b> <b>password?</b>

       (This question has nothing to do with the web.  See a different FAQ for that.)

       There's an example of this in "crypt" in perlfunc).  First, you put the terminal into "no echo" mode,
       then just read the password normally.  You may do this with an old-style <u>ioctl()</u> function, POSIX ter-
       minal control (see POSIX or its documentation the Camel Book), or a call to the <b>stty</b> program, with
       varying degrees of portability.

       You can also do this for most systems using the Term::ReadKey module from CPAN, which is easier to
       use and in theory more portable.

           use Term::ReadKey;

           ReadMode('noecho');
           $password = ReadLine(0);

       <b>How</b> <b>do</b> <b>I</b> <b>read</b> <b>and</b> <b>write</b> <b>the</b> <b>serial</b> <b>port?</b>

       This depends on which operating system your program is running on.  In the case of Unix, the serial
       ports will be accessible through files in /dev; on other systems, device names will doubtless differ.
       Several problem areas common to all device interaction are the following:

       lockfiles
           Your system may use lockfiles to control multiple access.  Make sure you follow the correct pro-<font color="#ffffff" class="whiteout">tocol.&nbsp;protocol.</font>
           tocol.  Unpredictable behavior can result from multiple processes reading from one device.

       open mode
           If you expect to use both read and write operations on the device, you'll have to open it for
           update (see "open" in perlfunc for details).  You may wish to open it without running the risk of
           blocking by using <u>sysopen()</u> and "O_RDWR|O_NDELAY|O_NOCTTY" from the Fcntl module (part of the
           standard perl distribution).  See "sysopen" in perlfunc for more on this approach.

       end of line
           Some devices will be expecting a "\r" at the end of each line rather than a "\n".  In some ports
           of perl, "\r" and "\n" are different from their usual (Unix) ASCII values of "\012" and "\015".
           You may have to give the numeric values you want directly, using octal ("\015"), hex ("0x0D"), or
           as a control-character specification ("\cM").

               print DEV "atv1\012";       # wrong, for some devices
               print DEV "atv1\015";       # right, for some devices

           Even though with normal text files a "\n" will do the trick, there is still no unified scheme for
           terminating a line that is portable between Unix, DOS/Win, and Macintosh, except to terminate <u>ALL</u>
           line ends with "\015\012", and strip what you don't need from the output.  This applies espe-<font color="#ffffff" class="whiteout">cially&nbsp;especially</font>
           cially to socket I/O and autoflushing, discussed next.

       flushing output
           If you expect characters to get to your device when you <u>print()</u> them, you'll want to autoflush
           that filehandle.  You can use <u>select()</u> and the $| variable to control autoflushing (see "$|" in
           perlvar and "select" in perlfunc, or perlfaq5, "How do I flush/unbuffer an output filehandle?
           Why must I do this?"):

               $oldh = select(DEV);
               $| = 1;
               select($oldh);

           You'll also see code that does this without a temporary variable, as in

               select((select(DEV), $| = 1)[0]);

           Or if you don't mind pulling in a few thousand lines of code just because you're afraid of a lit-<font color="#ffffff" class="whiteout">tle&nbsp;little</font>
           tle $| variable:

               use IO::Handle;
               DEV-&gt;autoflush(1);

           As mentioned in the previous item, this still doesn't work when using socket I/O between Unix and
           Macintosh.  You'll need to hard code your line terminators, in that case.

       non-blocking input
           If you are doing a blocking <u>read()</u> or <u>sysread()</u>, you'll have to arrange for an alarm handler to
           provide a timeout (see "alarm" in perlfunc).  If you have a non-blocking open, you'll likely have
           a non-blocking read, which means you may have to use a 4-arg <u>select()</u> to determine whether I/O is
           ready on that device (see "select" in perlfunc.

       While trying to read from his caller-id box, the notorious Jamie Zawinski &lt;jwz@netscape.com&gt;, after
       much gnashing of teeth and fighting with sysread, sysopen, POSIX's tcgetattr business, and various
       other functions that go bump in the night, finally came up with this:

           sub open_modem {
               use IPC::Open2;
               my $stty = `/bin/stty -g`;
               open2( \*MODEM_IN, \*MODEM_OUT, "cu -l$modem_device -s2400 2&gt;&amp;1");
               # starting cu hoses /dev/tty's stty settings, even when it has
               # been opened on a pipe...
               system("/bin/stty $stty");
               $_ = &lt;MODEM_IN&gt;;
               chomp;
               if ( !m/^Connected/ ) {
                   print STDERR "$0: cu printed `$_' instead of `Connected'\n";
               }
           }

       <b>How</b> <b>do</b> <b>I</b> <b>decode</b> <b>encrypted</b> <b>password</b> <b>files?</b>

       You spend lots and lots of money on dedicated hardware, but this is bound to get you talked about.

       Seriously, you can't if they are Unix password files--the Unix password system employs one-way
       encryption.  It's more like hashing than encryption.  The best you can check is whether something
       else hashes to the same string.  You can't turn a hash back into the original string.  Programs like
       Crack can forcibly (and intelligently) try to guess passwords, but don't (can't) guarantee quick suc-<font color="#ffffff" class="whiteout">cess.&nbsp;success.</font>
       cess.

       If you're worried about users selecting bad passwords, you should proactively check when they try to
       change their password (by modifying <a href="passwd.1ssl.html#//apple_ref/doc/man/1/passwd"><u>passwd</u>(1)</a>, for example).

       <b>How</b> <b>do</b> <b>I</b> <b>start</b> <b>a</b> <b>process</b> <b>in</b> <b>the</b> <b>background?</b>

       Several modules can start other processes that do not block your Perl program.  You can use
       IPC::Open3, Parallel::Jobs, IPC::Run, and some of the POE modules.  See CPAN for more details.

       You could also use

           system("cmd &amp;")

       or you could use fork as documented in "fork" in perlfunc, with further examples in perlipc.  Some
       things to be aware of, if you're on a Unix-like system:

       STDIN, STDOUT, and STDERR are shared
           Both the main process and the backgrounded one (the "child" process) share the same STDIN, STDOUT
           and STDERR filehandles.  If both try to access them at once, strange things can happen.  You may
           want to close or reopen these for the child.  You can get around this with "open"ing a pipe (see
           "open" in perlfunc) but on some systems this means that the child process cannot outlive the par-<font color="#ffffff" class="whiteout">ent.&nbsp;parent.</font>
           ent.

       Signals
           You'll have to catch the SIGCHLD signal, and possibly SIGPIPE too.  SIGCHLD is sent when the
           backgrounded process finishes.  SIGPIPE is sent when you write to a filehandle whose child
           process has closed (an untrapped SIGPIPE can cause your program to silently die).  This is not an
           issue with "system("cmd&amp;")".

       Zombies
           You have to be prepared to "reap" the child process when it finishes.

               $SIG{CHLD} = sub { wait };

               $SIG{CHLD} = 'IGNORE';

           You can also use a double fork. You immediately <u>wait()</u> for your first child, and the init daemon
           will <u>wait()</u> for your grandchild once it exits.

                   unless ($pid = fork) {
                           unless (fork) {
                       exec "what you really wanna do";
                       die "exec failed!";
                           }
                   exit 0;
                   }
               waitpid($pid,0);

           See "Signals" in perlipc for other examples of code to do this.  Zombies are not an issue with
           "system("prog &amp;")".

       <b>How</b> <b>do</b> <b>I</b> <b>trap</b> <b>control</b> <b>characters/signals?</b>

       You don't actually "trap" a control character.  Instead, that character generates a signal which is
       sent to your terminal's currently foregrounded process group, which you then trap in your process.
       Signals are documented in "Signals" in perlipc and the section on "Signals" in the Camel.

       You can set the values of the %SIG hash to be the functions you want to handle the signal.  After
       perl catches the signal, it looks in %SIG for a key with the same name as the signal, then calls the
       subroutine value for that key.

               # as an anonymous subroutine

               $SIG{INT} = sub { syswrite(STDERR, "ouch\n", 5 ) };

               # or a reference to a function

               $SIG{INT} = \&amp;ouch;

               # or the name of the function as a string

               $SIG{INT} = "ouch";

       Perl versions before 5.8 had in its C source code signal handlers which would catch the signal and
       possibly run a Perl function that you had set in %SIG.  This violated the rules of signal handling at
       that level causing perl to dump core. Since version 5.8.0, perl looks at %SIG *after* the signal has
       been caught, rather than while it is being caught.  Previous versions of this answer were incorrect.

       <b>How</b> <b>do</b> <b>I</b> <b>modify</b> <b>the</b> <b>shadow</b> <b>password</b> <b>file</b> <b>on</b> <b>a</b> <b>Unix</b> <b>system?</b>

       If perl was installed correctly and your shadow library was written properly, the getpw*() functions
       described in perlfunc should in theory provide (read-only) access to entries in the shadow password
       file.  To change the file, make a new shadow password file (the format varies from system to sys-<font color="#ffffff" class="whiteout">tem--see&nbsp;system--see</font>
       tem--see passwd for specifics) and use <a href="../man8/pwd_mkdb.8.html#//apple_ref/doc/man/8/pwd_mkdb"><u>pwd</u><b>_</b><u>mkdb</u>(8)</a> to install it (see pwd_mkdb for more details).

       <b>How</b> <b>do</b> <b>I</b> <b>set</b> <b>the</b> <b>time</b> <b>and</b> <b>date?</b>

       Assuming you're running under sufficient permissions, you should be able to set the system-wide date
       and time by running the <a href="date.1.html#//apple_ref/doc/man/1/date"><u>date</u>(1)</a> program.  (There is no way to set the time and date on a per-process
       basis.)  This mechanism will work for Unix, MS-DOS, Windows, and NT; the VMS equivalent is "set
       time".

       However, if all you want to do is change your time zone, you can probably get away with setting an
       environment variable:

           $ENV{TZ} = "MST7MDT";                  # unixish
           $ENV{'SYS$TIMEZONE_DIFFERENTIAL'}="-5" # vms
           system "trn comp.lang.perl.misc";

       <b>How</b> <b>can</b> <b>I</b> <u>sleep()</u> <b>or</b> <u>alarm()</u> <b>for</b> <b>under</b> <b>a</b> <b>second?</b>

       If you want finer granularity than the 1 second that the <u>sleep()</u> function provides, the easiest way
       is to use the <u>select()</u> function as documented in "select" in perlfunc.  Try the Time::HiRes and the
       BSD::Itimer modules (available from CPAN, and starting from Perl 5.8 Time::HiRes is part of the stan-<font color="#ffffff" class="whiteout">dard&nbsp;standard</font>
       dard distribution).

       <b>How</b> <b>can</b> <b>I</b> <b>measure</b> <b>time</b> <b>under</b> <b>a</b> <b>second?</b>

       In general, you may not be able to.  The Time::HiRes module (available from CPAN, and starting from
       Perl 5.8 part of the standard distribution) provides this functionality for some systems.

       If your system supports both the <u>syscall()</u> function in Perl as well as a system call like <a href="../man2/gettimeofday.2.html#//apple_ref/doc/man/2/gettimeofday"><u>gettimeof</u></a>-<font color="#ffffff" class="whiteout">day(2),&nbsp;gettimeofday(2),</font>
       <a href="../man2/gettimeofday.2.html#//apple_ref/doc/man/2/gettimeofday"><u>day</u>(2)</a>, then you may be able to do something like this:

           require 'sys/syscall.ph';

           $TIMEVAL_T = "LL";

           $done = $start = pack($TIMEVAL_T, ());

           syscall(&amp;SYS_gettimeofday, $start, 0) != -1
                      or die "gettimeofday: $!";

              ##########################
              # DO YOUR OPERATION HERE #
              ##########################

           syscall( &amp;SYS_gettimeofday, $done, 0) != -1
                  or die "gettimeofday: $!";

           @start = unpack($TIMEVAL_T, $start);
           @done  = unpack($TIMEVAL_T, $done);

           # fix microseconds
           for ($done[1], $start[1]) { $_ /= 1_000_000 }

           $delta_time = sprintf "%.4f", ($done[0]  + $done[1]  )
                                                   -<font color="#ffffff" class="whiteout">($start[0]&nbsp;)($start[0]</font>
                                        ($start[0] + $start[1] );

       <b>How</b> <b>can</b> <b>I</b> <b>do</b> <b>an</b> <u>atexit()</u> <b>or</b> <u>setjmp()</u><b>/</b><u>longjmp()</u><b>?</b> <b>(Exception</b> <b>handling)</b>

       Release 5 of Perl added the END block, which can be used to simulate <u>atexit()</u>.  Each package's END
       block is called when the program or thread ends (see perlmod manpage for more details).

       For example, you can use this to make sure your filter program managed to finish its output without
       filling up the disk:

           END {
               close(STDOUT) || die "stdout close failed: $!";
           }

       The END block isn't called when untrapped signals kill the program, though, so if you use END blocks
       you should also use

               use sigtrap qw(die normal-signals);

       Perl's exception-handling mechanism is its <u>eval()</u> operator.  You can use <u>eval()</u> as setjmp and <u>die()</u>
       as longjmp.  For details of this, see the section on signals, especially the time-out handler for a
       blocking <u>flock()</u> in "Signals" in perlipc or the section on "Signals" in the Camel Book.

       If exception handling is all you're interested in, try the exceptions.pl library (part of the stan-<font color="#ffffff" class="whiteout">dard&nbsp;standard</font>
       dard perl distribution).

       If you want the <u>atexit()</u> syntax (and an <u>rmexit()</u> as well), try the AtExit module available from CPAN.

       <b>Why</b> <b>doesn't</b> <b>my</b> <b>sockets</b> <b>program</b> <b>work</b> <b>under</b> <b>System</b> <b>V</b> <b>(Solaris)?</b>  <b>What</b> <b>does</b> <b>the</b> <b>error</b> <b>message</b> <b>"Protocol</b>
       <b>not</b> <b>supported"</b> <b>mean?</b>

       Some Sys-V based systems, notably Solaris 2.X, redefined some of the standard socket constants.
       Since these were constant across all architectures, they were often hardwired into perl code.  The
       proper way to deal with this is to "use Socket" to get the correct values.

       Note that even though SunOS and Solaris are binary compatible, these values are different.  Go fig-<font color="#ffffff" class="whiteout">ure.&nbsp;figure.</font>
       ure.

       <b>How</b> <b>can</b> <b>I</b> <b>call</b> <b>my</b> <b>system's</b> <b>unique</b> <b>C</b> <b>functions</b> <b>from</b> <b>Perl?</b>

       In most cases, you write an external module to do it--see the answer to "Where can I learn about
       linking C with Perl? [h2xs, xsubpp]".  However, if the function is a system call, and your system
       supports <u>syscall()</u>, you can use the syscall function (documented in perlfunc).

       Remember to check the modules that came with your distribution, and CPAN as well---someone may
       already have written a module to do it. On Windows, try Win32::API.  On Macs, try Mac::Carbon.  If no
       module has an interface to the C function, you can inline a bit of C in your Perl source with
       Inline::C.

       <b>Where</b> <b>do</b> <b>I</b> <b>get</b> <b>the</b> <b>include</b> <b>files</b> <b>to</b> <b>do</b> <u>ioctl()</u> <b>or</b> <u>syscall()</u><b>?</b>

       Historically, these would be generated by the h2ph tool, part of the standard perl distribution.
       This program converts <a href="cpp.1.html#//apple_ref/doc/man/1/cpp"><u>cpp</u>(1)</a> directives in C header files to files containing subroutine definitions,
       like &amp;SYS_getitimer, which you can use as arguments to your functions.  It doesn't work perfectly,
       but it usually gets most of the job done.  Simple files like <u>errno.h</u>, <u>syscall.h</u>, and <u>socket.h</u> were
       fine, but the hard ones like <u>ioctl.h</u> nearly always need to hand-edited.  Here's how to install the
       *.ph files:

           1.  become super-user
           2.  cd /usr/include
           3.  h2ph *.h */*.h

       If your system supports dynamic loading, for reasons of portability and sanity you probably ought to
       use h2xs (also part of the standard perl distribution).  This tool converts C header files to Perl
       extensions.  See perlxstut for how to get started with h2xs.

       If your system doesn't support dynamic loading, you still probably ought to use h2xs.  See perlxstut
       and ExtUtils::MakeMaker for more information (in brief, just use <b>make</b> <b>perl</b> instead of a plain <b>make</b> to
       rebuild perl with a new static extension).

       <b>Why</b> <b>do</b> <b>setuid</b> <b>perl</b> <b>scripts</b> <b>complain</b> <b>about</b> <b>kernel</b> <b>problems?</b>

       Some operating systems have bugs in the kernel that make setuid scripts inherently insecure.  Perl
       gives you a number of options (described in perlsec) to work around such systems.

       <b>How</b> <b>can</b> <b>I</b> <b>open</b> <b>a</b> <b>pipe</b> <b>both</b> <b>to</b> <b>and</b> <b>from</b> <b>a</b> <b>command?</b>

       The IPC::Open2 module (part of the standard perl distribution) is an easy-to-use approach that inter-<font color="#ffffff" class="whiteout">nally&nbsp;internally</font>
       nally uses <u>pipe()</u>, <u>fork()</u>, and <u>exec()</u> to do the job.  Make sure you read the deadlock warnings in its
       documentation, though (see IPC::Open2).  See "Bidirectional Communication with Another Process" in
       perlipc and "Bidirectional Communication with Yourself" in perlipc

       You may also use the IPC::Open3 module (part of the standard perl distribution), but be warned that
       it has a different order of arguments from IPC::Open2 (see IPC::Open3).

       <b>Why</b> <b>can't</b> <b>I</b> <b>get</b> <b>the</b> <b>output</b> <b>of</b> <b>a</b> <b>command</b> <b>with</b> <u>system()</u><b>?</b>

       You're confusing the purpose of <u>system()</u> and backticks (``).  <u>system()</u> runs a command and returns
       exit status information (as a 16 bit value: the low 7 bits are the signal the process died from, if
       any, and the high 8 bits are the actual exit value).  Backticks (``) run a command and return what it
       sent to STDOUT.

           $exit_status   = system("mail-users");
           $output_string = `ls`;

       <b>How</b> <b>can</b> <b>I</b> <b>capture</b> <b>STDERR</b> <b>from</b> <b>an</b> <b>external</b> <b>command?</b>

       There are three basic ways of running external commands:

           system $cmd;                # using system()
           $output = `$cmd`;           # using backticks (``)
           open (PIPE, "cmd |");       # using open()

       With <u>system()</u>, both STDOUT and STDERR will go the same place as the script's STDOUT and STDERR,
       unless the <u>system()</u> command redirects them.  Backticks and <u>open()</u> read <b>only</b> the STDOUT of your com-<font color="#ffffff" class="whiteout">mand.&nbsp;command.</font>
       mand.

       You can also use the <u>open3()</u> function from IPC::Open3.  Benjamin Goldberg provides some sample code:

       To capture a program's STDOUT, but discard its STDERR:

           use IPC::Open3;
           use File::Spec;
           use Symbol qw(gensym);
           open(NULL, "&gt;", File::Spec-&gt;devnull);
           my $pid = open3(gensym, \*PH, "&gt;&amp;NULL", "cmd");
           while( &lt;PH&gt; ) { }
           waitpid($pid, 0);

       To capture a program's STDERR, but discard its STDOUT:

           use IPC::Open3;
           use File::Spec;
           use Symbol qw(gensym);
           open(NULL, "&gt;", File::Spec-&gt;devnull);
           my $pid = open3(gensym, "&gt;&amp;NULL", \*PH, "cmd");
           while( &lt;PH&gt; ) { }
           waitpid($pid, 0);

       To capture a program's STDERR, and let its STDOUT go to our own STDERR:

           use IPC::Open3;
           use Symbol qw(gensym);
           my $pid = open3(gensym, "&gt;&amp;STDERR", \*PH, "cmd");
           while( &lt;PH&gt; ) { }
           waitpid($pid, 0);

       To read both a command's STDOUT and its STDERR separately, you can redirect them to temp files, let
       the command run, then read the temp files:

           use IPC::Open3;
           use Symbol qw(gensym);
           use IO::File;
           local *CATCHOUT = IO::File-&gt;new_tmpfile;
           local *CATCHERR = IO::File-&gt;new_tmpfile;
           my $pid = open3(gensym, "&gt;&amp;CATCHOUT", "&gt;&amp;CATCHERR", "cmd");
           waitpid($pid, 0);
           seek $_, 0, 0 for \*CATCHOUT, \*CATCHERR;
           while( &lt;CATCHOUT&gt; ) {}
           while( &lt;CATCHERR&gt; ) {}

       But there's no real need for *both* to be tempfiles... the following should work just as well, with-<font color="#ffffff" class="whiteout">out&nbsp;without</font>
       out deadlocking:

           use IPC::Open3;
           use Symbol qw(gensym);
           use IO::File;
           local *CATCHERR = IO::File-&gt;new_tmpfile;
           my $pid = open3(gensym, \*CATCHOUT, "&gt;&amp;CATCHERR", "cmd");
           while( &lt;CATCHOUT&gt; ) {}
           waitpid($pid, 0);
           seek CATCHERR, 0, 0;
           while( &lt;CATCHERR&gt; ) {}

       And it'll be faster, too, since we can begin processing the program's stdout immediately, rather than
       waiting for the program to finish.

       With any of these, you can change file descriptors before the call:

           open(STDOUT, "&gt;logfile");
           system("ls");

       or you can use Bourne shell file-descriptor redirection:

           $output = `$cmd 2&gt;some_file`;
           open (PIPE, "cmd 2&gt;some_file |");

       You can also use file-descriptor redirection to make STDERR a duplicate of STDOUT:

           $output = `$cmd 2&gt;&amp;1`;
           open (PIPE, "cmd 2&gt;&amp;1 |");

       Note that you <u>cannot</u> simply open STDERR to be a dup of STDOUT in your Perl program and avoid calling
       the shell to do the redirection.  This doesn't work:

           open(STDERR, "&gt;&amp;STDOUT");
           $alloutput = `cmd args`;  # stderr still escapes

       This fails because the <u>open()</u> makes STDERR go to where STDOUT was going at the time of the <u>open()</u>.
       The backticks then make STDOUT go to a string, but don't change STDERR (which still goes to the old
       STDOUT).

       Note that you <u>must</u> use Bourne shell <a href="sh.1.html#//apple_ref/doc/man/1/sh">(<u>sh</u>(1)</a>) redirection syntax in backticks, not <a href="csh.1.html#//apple_ref/doc/man/1/csh"><u>csh</u>(1)</a>!  Details on
       why Perl's <u>system()</u> and backtick and pipe opens all use the Bourne shell are in the <u>versus/csh.whynot</u>
       article in the "Far More Than You Ever Wanted To Know" collection in <a href="http://www.cpan.org/misc/olddoc/FMTEYEWTK.tgz">http://www.cpan.org/misc/old-</a>
       <a href="http://www.cpan.org/misc/olddoc/FMTEYEWTK.tgz">doc/FMTEYEWTK.tgz</a> .  To capture a command's STDERR and STDOUT together:

           $output = `cmd 2&gt;&amp;1`;                       # either with backticks
           $pid = open(PH, "cmd 2&gt;&amp;1 |");              # or with an open pipe
           while (&lt;PH&gt;) { }                            #    plus a read

       To capture a command's STDOUT but discard its STDERR:

           $output = `cmd 2&gt;/dev/null`;                # either with backticks
           $pid = open(PH, "cmd 2&gt;/dev/null |");       # or with an open pipe
           while (&lt;PH&gt;) { }                            #    plus a read

       To capture a command's STDERR but discard its STDOUT:

           $output = `cmd 2&gt;&amp;1 1&gt;/dev/null`;           # either with backticks
           $pid = open(PH, "cmd 2&gt;&amp;1 1&gt;/dev/null |");  # or with an open pipe
           while (&lt;PH&gt;) { }                            #    plus a read

       To exchange a command's STDOUT and STDERR in order to capture the STDERR but leave its STDOUT to come
       out our old STDERR:

           $output = `cmd 3&gt;&amp;1 1&gt;&amp;2 2&gt;&amp;3 3&gt;&amp;-`;        # either with backticks
           $pid = open(PH, "cmd 3&gt;&amp;1 1&gt;&amp;2 2&gt;&amp;3 3&gt;&amp;-|");# or with an open pipe
           while (&lt;PH&gt;) { }                            #    plus a read

       To read both a command's STDOUT and its STDERR separately, it's easiest to redirect them separately
       to files, and then read from those files when the program is done:

           system("program args 1&gt;program.stdout 2&gt;program.stderr");

       Ordering is important in all these examples.  That's because the shell processes file descriptor
       redirections in strictly left to right order.

           system("prog args 1&gt;tmpfile 2&gt;&amp;1");
           system("prog args 2&gt;&amp;1 1&gt;tmpfile");

       The first command sends both standard out and standard error to the temporary file.  The second com-
       mand sends only the old standard output there, and the old standard error shows up on the old stan-
       dard out.

       <b>Why</b> <b>doesn't</b> <u>open()</u> <b>return</b> <b>an</b> <b>error</b> <b>when</b> <b>a</b> <b>pipe</b> <b>open</b> <b>fails?</b>

       If the second argument to a piped <u>open()</u> contains shell metacharacters, perl <u>fork()</u>s, then <u>exec()</u>s a
       shell to decode the metacharacters and eventually run the desired program.  If the program couldn't
       be run, it's the shell that gets the message, not Perl. All your Perl program can find out is whether
       the shell itself could be successfully started.  You can still capture the shell's STDERR and check
       it for error messages.  See "How can I capture STDERR from an external command?" elsewhere in this
       document, or use the IPC::Open3 module.

       If there are no shell metacharacters in the argument of <u>open()</u>, Perl runs the command directly, with-
       out using the shell, and can correctly report whether the command started.

       <b>What's</b> <b>wrong</b> <b>with</b> <b>using</b> <b>backticks</b> <b>in</b> <b>a</b> <b>void</b> <b>context?</b>

       Strictly speaking, nothing.  Stylistically speaking, it's not a good way to write maintainable code.
       Perl has several operators for running external commands.  Backticks are one; they collect the output
       from the command for use in your program.  The "system" function is another; it doesn't do this.

       Writing backticks in your program sends a clear message to the readers of your code that you wanted
       to collect the output of the command.  Why send a clear message that isn't true?

       Consider this line:

           `cat /etc/termcap`;

       You forgot to check $? to see whether the program even ran correctly.  Even if you wrote

           print `cat /etc/termcap`;

       this code could and probably should be written as

           system("cat /etc/termcap") == 0
               or die "cat program failed!";

       which will get the output quickly (as it is generated, instead of only at the end) and also check the
       return value.

       <u>system()</u> also provides direct control over whether shell wildcard processing may take place, whereas
       backticks do not.

       <b>How</b> <b>can</b> <b>I</b> <b>call</b> <b>backticks</b> <b>without</b> <b>shell</b> <b>processing?</b>

       This is a bit tricky.  You can't simply write the command like this:

           @ok = `grep @opts '$search_string' @filenames`;

       As of Perl 5.8.0, you can use <u>open()</u> with multiple arguments.  Just like the list forms of <u>system()</u>
       and <u>exec()</u>, no shell escapes happen.

          open( GREP, "-|", 'grep', @opts, $search_string, @filenames );
          chomp(@ok = &lt;GREP&gt;);
          close GREP;

       You can also:

           my @ok = ();
           if (open(GREP, "-|")) {
               while (&lt;GREP&gt;) {
                   chomp;
                   push(@ok, $_);
               }
               close GREP;
           } else {
               exec 'grep', @opts, $search_string, @filenames;
           }

       Just as with <u>system()</u>, no shell escapes happen when you <u>exec()</u> a list.  Further examples of this can
       be found in "Safe Pipe Opens" in perlipc.

       Note that if you're use Microsoft, no solution to this vexing issue is even possible.  Even if Perl
       were to emulate <u>fork()</u>, you'd still be stuck, because Microsoft does not have a argc/argv-style API.

       <b>Why</b> <b>can't</b> <b>my</b> <b>script</b> <b>read</b> <b>from</b> <b>STDIN</b> <b>after</b> <b>I</b> <b>gave</b> <b>it</b> <b>EOF</b> <b>(^D</b> <b>on</b> <b>Unix,</b> <b>^Z</b> <b>on</b> <b>MS-DOS)?</b>

       Some stdio's set error and eof flags that need clearing.  The POSIX module defines <u>clearerr()</u> that
       you can use.  That is the technically correct way to do it.  Here are some less reliable workarounds:

       1   Try keeping around the seekpointer and go there, like this:

               $where = tell(LOG);
               seek(LOG, $where, 0);

       2   If that doesn't work, try seeking to a different part of the file and then back.

       3   If that doesn't work, try seeking to a different part of the file, reading something, and then
           seeking back.

       4   If that doesn't work, give up on your stdio package and use sysread.

       <b>How</b> <b>can</b> <b>I</b> <b>convert</b> <b>my</b> <b>shell</b> <b>script</b> <b>to</b> <b>perl?</b>

       Learn Perl and rewrite it.  Seriously, there's no simple converter.  Things that are awkward to do in
       the shell are easy to do in Perl, and this very awkwardness is what would make a shell-&gt;perl con-
       verter nigh-on impossible to write.  By rewriting it, you'll think about what you're really trying to
       do, and hopefully will escape the shell's pipeline datastream paradigm, which while convenient for
       some matters, causes many inefficiencies.

       <b>Can</b> <b>I</b> <b>use</b> <b>perl</b> <b>to</b> <b>run</b> <b>a</b> <b>telnet</b> <b>or</b> <b>ftp</b> <b>session?</b>

       Try the Net::FTP, TCP::Client, and Net::Telnet modules (available from CPAN).
       <a href="http://www.cpan.org/scripts/netstuff/telnet.emul.shar">http://www.cpan.org/scripts/netstuff/telnet.emul.shar</a> will also help for emulating the telnet proto-
       col, but Net::Telnet is quite probably easier to use..

       If all you want to do is pretend to be telnet but don't need the initial telnet handshaking, then the
       standard dual-process approach will suffice:

           use IO::Socket;             # new in 5.004
           $handle = IO::Socket::INET-&gt;new('www.perl.com:80')
                   || die "can't connect to port 80 on www.perl.com: $!";
           $handle-&gt;autoflush(1);
           if (fork()) {               # XXX: undef means failure
               select($handle);
               print while &lt;STDIN&gt;;    # everything from stdin to socket
           } else {
               print while &lt;$handle&gt;;  # everything from socket to stdout
           }
           close $handle;
           exit;

       <b>How</b> <b>can</b> <b>I</b> <b>write</b> <b>expect</b> <b>in</b> <b>Perl?</b>

       Once upon a time, there was a library called chat2.pl (part of the standard perl distribution), which
       never really got finished.  If you find it somewhere, <u>don't</u> <u>use</u> <u>it</u>.  These days, your best bet is to
       look at the Expect module available from CPAN, which also requires two other modules from CPAN,
       IO::Pty and IO::Stty.

       <b>Is</b> <b>there</b> <b>a</b> <b>way</b> <b>to</b> <b>hide</b> <b>perl's</b> <b>command</b> <b>line</b> <b>from</b> <b>programs</b> <b>such</b> <b>as</b> <b>"ps"?</b>

       First of all note that if you're doing this for security reasons (to avoid people seeing passwords,
       for example) then you should rewrite your program so that critical information is never given as an
       argument.  Hiding the arguments won't make your program completely secure.

       To actually alter the visible command line, you can assign to the variable $0 as documented in perl-
       var.  This won't work on all operating systems, though.  Daemon programs like sendmail place their
       state there, as in:

           $0 = "orcus [accepting connections]";

       <b>I</b> <b>{changed</b> <b>directory,</b> <b>modified</b> <b>my</b> <b>environment}</b> <b>in</b> <b>a</b> <b>perl</b> <b>script.</b>  <b>How</b> <b>come</b> <b>the</b> <b>change</b> <b>disappeared</b>
       <b>when</b> <b>I</b> <b>exited</b> <b>the</b> <b>script?</b>  <b>How</b> <b>do</b> <b>I</b> <b>get</b> <b>my</b> <b>changes</b> <b>to</b> <b>be</b> <b>visible?</b>


       Unix
           In the strictest sense, it can't be done--the script executes as a different process from the
           shell it was started from.  Changes to a process are not reflected in its parent--only in any
           children created after the change.  There is shell magic that may allow you to fake it by
           <u>eval()</u>ing the script's output in your shell; check out the comp.unix.questions FAQ for details.

       <b>How</b> <b>do</b> <b>I</b> <b>close</b> <b>a</b> <b>process's</b> <b>filehandle</b> <b>without</b> <b>waiting</b> <b>for</b> <b>it</b> <b>to</b> <b>complete?</b>

       Assuming your system supports such things, just send an appropriate signal to the process (see "kill"
       in perlfunc).  It's common to first send a TERM signal, wait a little bit, and then send a KILL sig-
       nal to finish it off.

       <b>How</b> <b>do</b> <b>I</b> <b>fork</b> <b>a</b> <b>daemon</b> <b>process?</b>

       If by daemon process you mean one that's detached (disassociated from its tty), then the following
       process is reported to work on most Unixish systems.  Non-Unix users should check their
       Your_OS::Process module for other solutions.

          Open /dev/tty and use the TIOCNOTTY ioctl on it.  See tty for details.  Or better yet, you can
           just use the <u>POSIX::setsid()</u> function, so you don't have to worry about process groups.

          Change directory to /

          Reopen STDIN, STDOUT, and STDERR so they're not connected to the old tty.

          Background yourself like this:

               fork &amp;&amp; exit;

       The Proc::Daemon module, available from CPAN, provides a function to perform these actions for you.

       <b>How</b> <b>do</b> <b>I</b> <b>find</b> <b>out</b> <b>if</b> <b>I'm</b> <b>running</b> <b>interactively</b> <b>or</b> <b>not?</b>

       Good question.  Sometimes "-t STDIN" and "-t STDOUT" can give clues, sometimes not.

           if (-t STDIN &amp;&amp; -t STDOUT) {
               print "Now what? ";
           }

       On POSIX systems, you can test whether your own process group matches the current process group of
       your controlling terminal as follows:

           use POSIX qw/getpgrp tcgetpgrp/;
           open(TTY, "/dev/tty") or die $!;
           $tpgrp = tcgetpgrp(fileno(*TTY));
           $pgrp = getpgrp();
           if ($tpgrp == $pgrp) {
               print "foreground\n";
           } else {
               print "background\n";
           }

       <b>How</b> <b>do</b> <b>I</b> <b>timeout</b> <b>a</b> <b>slow</b> <b>event?</b>

       Use the <u>alarm()</u> function, probably in conjunction with a signal handler, as documented in "Signals"
       in perlipc and the section on "Signals" in the Camel.  You may instead use the more flexible
       Sys::AlarmCall module available from CPAN.

       The <u>alarm()</u> function is not implemented on all versions of Windows.  Check the documentation for your
       specific version of Perl.

       <b>How</b> <b>do</b> <b>I</b> <b>set</b> <b>CPU</b> <b>limits?</b>

       Use the BSD::Resource module from CPAN.

       <b>How</b> <b>do</b> <b>I</b> <b>avoid</b> <b>zombies</b> <b>on</b> <b>a</b> <b>Unix</b> <b>system?</b>

       Use the reaper code from "Signals" in perlipc to call <u>wait()</u> when a SIGCHLD is received, or else use
       the double-fork technique described in "How do I start a process in the background?" in perlfaq8.

       <b>How</b> <b>do</b> <b>I</b> <b>use</b> <b>an</b> <b>SQL</b> <b>database?</b>

       The DBI module provides an abstract interface to most database servers and types, including Oracle,
       DB2, Sybase, mysql, Postgresql, ODBC, and flat files.  The DBI module accesses each database type
       through a database driver, or DBD.  You can see a complete list of available drivers on CPAN:
       <a href="http://www.cpan.org/modules/by-module/DBD/">http://www.cpan.org/modules/by-module/DBD/</a> .  You can read more about DBI on <a href="http://dbi.perl.org">http://dbi.perl.org</a> .

       Other modules provide more specific access: Win32::ODBC, Alzabo, iodbc, and others found on CPAN
       Search: <a href="http://search.cpan.org">http://search.cpan.org</a> .

       <b>How</b> <b>do</b> <b>I</b> <b>make</b> <b>a</b> <u>system()</u> <b>exit</b> <b>on</b> <b>control-C?</b>

       You can't.  You need to imitate the <u>system()</u> call (see perlipc for sample code) and then have a sig-
       nal handler for the INT signal that passes the signal on to the subprocess.  Or you can check for it:

           $rc = system($cmd);
           if ($rc &amp; 127) { die "signal death" }

       <b>How</b> <b>do</b> <b>I</b> <b>open</b> <b>a</b> <b>file</b> <b>without</b> <b>blocking?</b>

       If you're lucky enough to be using a system that supports non-blocking reads (most Unixish systems
       do), you need only to use the O_NDELAY or O_NONBLOCK flag from the Fcntl module in conjunction with
       <u>sysopen()</u>:

           use Fcntl;
           sysopen(FH, "/foo/somefile", O_WRONLY|O_NDELAY|O_CREAT, 0644)
               or die "can't open /foo/somefile: $!":

       <b>How</b> <b>do</b> <b>I</b> <b>tell</b> <b>the</b> <b>difference</b> <b>between</b> <b>errors</b> <b>from</b> <b>the</b> <b>shell</b> <b>and</b> <b>perl?</b>

       (answer contributed by brian d foy, "&lt;bdfoy@cpan.org&gt;"

       When you run a Perl script, something else is running the script for you, and that something else may
       output error messages.  The script might emit its own warnings and error messages.  Most of the time
       you cannot tell who said what.

       You probably cannot fix the thing that runs perl, but you can change how perl outputs its warnings by
       defining a custom warning and die functions.

       Consider this script, which has an error you may not notice immediately.

               #!/usr/locl/bin/perl

               print "Hello World\n";

       I get an error when I run this from my shell (which happens to be bash).  That may look like perl
       forgot it has a <u>print()</u> function, but my shebang line is not the path to perl, so the shell runs the
       script, and I get the error.

               $ ./test
               ./test: line 3: print: command not found

       A quick and dirty fix involves a little bit of code, but this may be all you need to figure out the
       problem.

               #!/usr/bin/perl -w

               BEGIN {
               $SIG{__WARN__} = sub{ print STDERR "Perl: ", @_; };
               $SIG{__DIE__}  = sub{ print STDERR "Perl: ", @_; exit 1};
               }

               $a = 1 + undef;
               $x / 0;
               __END__

       The perl message comes out with "Perl" in front.  The BEGIN block works at compile time so all of the
       compilation errors and warnings get the "Perl:" prefix too.

               Perl: Useless use of division (/) in void context at ./test line 9.
               Perl: Name "main::a" used only once: possible typo at ./test line 8.
               Perl: Name "main::x" used only once: possible typo at ./test line 9.
               Perl: Use of uninitialized value in addition (+) at ./test line 8.
               Perl: Use of uninitialized value in division (/) at ./test line 9.
               Perl: Illegal division by zero at ./test line 9.
               Perl: Illegal division by zero at -e line 3.

       If I don't see that "Perl:", it's not from perl.

       You could also just know all the perl errors, and although there are some people who may know all of
       them, you probably don't.  However, they all should be in the perldiag manpage. If you don't find the
       error in there, it probably isn't a perl error.

       Looking up every message is not the easiest way, so let perl to do it for you.  Use the diagnostics
       pragma with turns perl's normal messages into longer discussions on the topic.

               use diagnostics;

       If you don't get a paragraph or two of expanded discussion, it might not be perl's message.

       <b>How</b> <b>do</b> <b>I</b> <b>install</b> <b>a</b> <b>module</b> <b>from</b> <b>CPAN?</b>

       The easiest way is to have a module also named CPAN do it for you.  This module comes with perl ver-
       sion 5.004 and later.

           $ perl -MCPAN -e shell

           cpan shell -- CPAN exploration and modules installation (v1.59_54)
           ReadLine support enabled

           cpan&gt; install Some::Module

       To manually install the CPAN module, or any well-behaved CPAN module for that matter, follow these
       steps:

       1   Unpack the source into a temporary area.

       2
               perl Makefile.PL

       3
               make

       4
               make test

       5
               make install

       If your version of perl is compiled without dynamic loading, then you just need to replace step 3
       (<b>make</b>) with <b>make</b> <b>perl</b> and you will get a new <u>perl</u> binary with your extension linked in.

       See ExtUtils::MakeMaker for more details on building extensions.  See also the next question, "What's
       the difference between require and use?".

       <b>What's</b> <b>the</b> <b>difference</b> <b>between</b> <b>require</b> <b>and</b> <b>use?</b>

       Perl offers several different ways to include code from one file into another.  Here are the deltas
       between the various inclusion constructs:

           1)  do $file is like eval `cat $file`, except the former
               1.1: searches @INC and updates %INC.
               1.2: bequeaths an *unrelated* lexical scope on the eval'ed code.

           2)  require $file is like do $file, except the former
               2.1: checks for redundant loading, skipping already loaded files.
               2.2: raises an exception on failure to find, compile, or execute $file.

           3)  require Module is like require "Module.pm", except the former
               3.1: translates each "::" into your system's directory separator.
               3.2: primes the parser to disambiguate class Module as an indirect object.

           4)  use Module is like require Module, except the former
               4.1: loads the module at compile time, not run-time.
               4.2: imports symbols and semantics from that package to the current one.

       In general, you usually want "use" and a proper Perl module.

       <b>How</b> <b>do</b> <b>I</b> <b>keep</b> <b>my</b> <b>own</b> <b>module/library</b> <b>directory?</b>

       When you build modules, use the PREFIX and LIB options when generating Makefiles:

           perl Makefile.PL PREFIX=/mydir/perl LIB=/mydir/perl/lib

       then either set the PERL5LIB environment variable before you run scripts that use the mod-
       ules/libraries (see perlrun) or say

           use lib '/mydir/perl/lib';

       This is almost the same as

           BEGIN {
               unshift(@INC, '/mydir/perl/lib');
           }

       except that the lib module checks for machine-dependent subdirectories.  See Perl's lib for more
       information.

       <b>How</b> <b>do</b> <b>I</b> <b>add</b> <b>the</b> <b>directory</b> <b>my</b> <b>program</b> <b>lives</b> <b>in</b> <b>to</b> <b>the</b> <b>module/library</b> <b>search</b> <b>path?</b>

           use FindBin;
           use lib "$FindBin::Bin";
           use your_own_modules;

       <b>How</b> <b>do</b> <b>I</b> <b>add</b> <b>a</b> <b>directory</b> <b>to</b> <b>my</b> <b>include</b> <b>path</b> <b>(@INC)</b> <b>at</b> <b>runtime?</b>

       Here are the suggested ways of modifying your include path:

           the PERLLIB environment variable
           the PERL5LIB environment variable
           the perl -Idir command line flag
           the use lib pragma, as in
               use lib "$ENV{HOME}/myown_perllib";

       The latter is particularly useful because it knows about machine dependent architectures.  The lib.pm
       pragmatic module was first included with the 5.002 release of Perl.

       <b>What</b> <b>is</b> <b>socket.ph</b> <b>and</b> <b>where</b> <b>do</b> <b>I</b> <b>get</b> <b>it?</b>

       It's a perl4-style file defining values for system networking constants.  Sometimes it is built using
       h2ph when Perl is installed, but other times it is not.  Modern programs "use Socket;" instead.

<b>AUTHOR</b> <b>AND</b> <b>COPYRIGHT</b>
       Copyright (c) 1997-2006 Tom Christiansen, Nathan Torkington, and other authors as noted. All rights
       reserved.

       This documentation is free; you can redistribute it and/or modify it under the same terms as Perl
       itself.

       Irrespective of its distribution, all code examples in this file are hereby placed into the public
       domain.  You are permitted and encouraged to use this code in your own programs for fun or for profit
       as you see fit.  A simple comment in the code giving credit would be courteous but is not required.



perl v5.8.8                                      2006-01-07                                      PERLFAQ8(1)
</tt></pre>
</td></tr></table>
	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Darwin/Reference/ManPages/man1/perlfaq8.1.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Darwin/Reference/ManPages/man1/perlfaq8.1.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Darwin/Reference/ManPages/man1/perlfaq8.1.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

</body></html>
