<HTML><HEAD><META NAME="GENERATOR" CONTENT="Adobe FrameMaker 5.5/HTML Export Filter"><script language="JavaScript" src="frametest.js"></script><TITLE> Atomic Services</TITLE></HEAD><BODY BGCOLOR="#ffffff"><DIV><a name="top"></a><!-- start of banner --><!--#include virtual="/includes/framesetheader" --><!-- end of banner --><!-- start of path --><font face="Geneva,Helvetica,Arial" size="1"><b><br>PATH<spacer type="horizontal" size="5">&nbsp;</b><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Documentation</a> &gt; <!-- a href="" target="_top" -->Hardware<!-- /a -->  <b>&gt; </b><a href="../../devicemgrs.html" target="_top">Device Managers and Drivers</a> <b>&gt; </b><a href="../pci_srvcs.html" target="_top">PCI Card Services</a> <b>&gt; </b>Designing PCI Cards and Drivers for Power Macintosh Computers</font><br><br><!-- end of path --><A HREF="PCI_BOOK.220.html"><img src="images/up.gif" border="0" width="36" height="16"></A><nobr>&nbsp;</nobr><A HREF="PCI_BOOK.223.html"><img src="images/previous.gif" border="0" width="66" height="16"></A><nobr>&nbsp;</nobr><A HREF="PCI_BOOK.225.html"><img src="images/next.gif" border="0" width="49" height="16"></A><!-- insert Show/Hide frames --><a href="javascript:testFrame()"><script><!--document.write(frameLink);//--></script><!-- end Show/Hide frames --></A><HR></DIV><H1 CLASS="H2.Heading2"><A NAME="pgfId=3494"> </A><A NAME="16581"> </A>Atomic Services</H1><P CLASS="T1.Text1"><A NAME="pgfId=3495"> </A>Open Transport supplies atomic services that help reduce the need for drivers to disable and enable interrupts.</P><DIV><blockquote><p CLASS="NoteHead"><b><A NAME="pgfId=14494"> </A>Note</b></p><P CLASS="Note"><A NAME="pgfId=3496"> </A>Don't confuse these services with the DSL atomic services described in Chapter <A HREF="PCI_BOOK.140.html#12320" CLASS="XRef">11</A>. </P></blockquote></DIV><DIV><blockquote><p CLASS="ImportantHead"><b><A NAME="pgfId=14496"> </A>IMPORTANT</b></p><P CLASS="I.Important"><A NAME="pgfId=3503"> </A>Many atomic services have strict alignment requirements. Be sure to heed the following warnings. The <TT CLASS="cv">OTAllocMem</TT> and all STREAMS message blocks are guaranteed to be aligned to 32-bit boundaries. On STREAMS message blocks, this applies to the actual start of the message, not the <TT CLASS="cv">b_rptr</TT> field itself, which may not be aligned at all. In 16-bit operations, if the 16 bits cross a 32-bit boundary the atomic function will not work properly. In 32-bit functions, it is important that the variable being operated on be aligned on a 32-bit boundary. </P></blockquote><P CLASS="T1.Text1"><A NAME="pgfId=3507"> </A>The first set of services atomically sets, clears, or tests a single bit in a byte. The first parameter is a pointer to a single byte, and the second is a bit number from 0 to 7. The functions return the previous value of the bit. Bit 0 corresponds to a mask of 0x01, and bit 7 corresponds to a mask of 0x80.</P><CODE CLASS="Cv.Code"><A NAME="pgfId=14500"> </A>Boolean OTAtomicSetBit&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(UInt8* theByte, size_t theBitNo);<BR>Boolean OTAtomicClearBit&nbsp;&nbsp;&nbsp;&nbsp;(UInt8* theByte, size_t theBitNo);<BR>Boolean OTAtomicTestBit&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(UInt8* theByte, size_t theBitNo);<BR>Boolean OTAcquireLock &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(UInt8* theByte);<BR>void &nbsp;&nbsp;&nbsp;OTClearLock &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(UInt8* theByte);</CODE><P CLASS="T1.Text1"><A NAME="pgfId=3509"> </A><TT CLASS="cv">OTAcquireLock</TT> is a faster equivalent of <TT CLASS="cv">OTAtomicSetBit(theByte, 0)</TT>. It returns <TT CLASS="cv">true</TT> if the lock could be acquired (that is, if the bit was flipped from off to on). <TT CLASS="cv">OTClearLock</TT> is a macro that just zeroes the byte.</P><P CLASS="T1.Text1"><A NAME="pgfId=3510"> </A>The second set of services atomically add to a 32-, 16-, or 8-bit variable. By using a negative number, they can subtract. The return value is the new value of the variable  as it is when the operation is completed.</P><CODE CLASS="Cv.Code"><A NAME="pgfId=14507"> </A>SInt32 OTAtomicAdd32 (SInt32, SInt32* varToBeAddedTo);<BR>SInt16 OTAtomicAdd16 (SInt16, SInt16* varToBeAddedTo);<BR>SInt8&nbsp; OTAtomicAdd8 &nbsp;(SInt8, &nbsp;SInt8* &nbsp;varToBeAddedTo);</CODE><P CLASS="T1.Text1"><A NAME="pgfId=3512"> </A>The third service is a general compare and swap. It determines if the value at <TT CLASS="cv">where</TT> still contains the value <TT CLASS="cv">oVal</TT>; if so, it substitutes the value <TT CLASS="cv">nVal</TT>. If the compare and swap succeeds, the function returns <TT CLASS="cv">true</TT>, otherwise <TT CLASS="cv">false</TT>.</P><CODE CLASS="Cv.Code"><A NAME="pgfId=14511"> </A>Boolean OTCompareAndSwap32<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(UInt32 oVal, UInt32* nVal, UInt32** where);<BR>Boolean OTCompareAndSwap16<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(UInt16 oVal, UInt16* nVal, UInt16** where);<BR>Boolean OTCompareAndSwap8<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(UInt8 oVal, &nbsp;UInt8* nVal, &nbsp;UInt8** where);</CODE><P CLASS="T1.Text1"><A NAME="pgfId=3514"> </A>The fourth set of services is an atomic last in, first out (LIFO) list. <TT CLASS="cv">OTLIFOEnqueue</TT> and <TT CLASS="cv">OTLIFODequeue</TT> are self-explanatory. <TT CLASS="cv">OTLIFOStealList</TT> lets you remove all of the elements from the LIFO list atomically, so that the elements in the list can be iterated at your leisure by traditional means. <TT CLASS="cv">OTLIFOReverseList</TT> is for those who find that LIFO lists are next to useless in networking. Once the <TT CLASS="cv">OTLIFOStealList</TT> function has been executed, the result can be passed to <TT CLASS="cv">OTLIFOReverseList</TT>, which can be used to flip the list into a first in, first out (FIFO) configuration. The <TT CLASS="cv">OTLink</TT> and the <TT CLASS="cv">OTLIFO</TT> parameters must both be aligned on 32-bit boundaries. Note that <TT CLASS="cv">OTLIFOReverseList</TT> is not atomic.</P><br><br><CODE CLASS="Cv.Code"><A NAME="pgfId=14515"> </A>struct OTLink<BR>{<BR>&nbsp;&nbsp;&nbsp;&nbsp;void*&nbsp;&nbsp;&nbsp;fNext;<BR>};</CODE><br><br>struct OTLIFO<CODE CLASS="Cv.Code"><A NAME="pgfId=14519"> </A>struct OTLIFO<BR>{<BR>&nbsp;&nbsp;&nbsp;&nbsp;void* &nbsp;&nbsp;fLink;<BR>};</CODE><br><br><CODE CLASS="Cv.Code"><A NAME="pgfId=14523"> </A>void &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OTLIFOEnqueue&nbsp;&nbsp;&nbsp;(OTLIFO* list, OTLink* toAdd);<BR>OTLink* &nbsp;&nbsp;&nbsp;&nbsp;OTLIFODequeue&nbsp;&nbsp;&nbsp;(OTLIFO* list);<BR>OTLink* &nbsp;&nbsp;&nbsp;&nbsp;OTLIFOStealList&nbsp;(OTLIFO* list);<BR>OTLink* &nbsp;&nbsp;&nbsp;&nbsp;OTReverseList&nbsp;&nbsp;&nbsp;(OTLink* firstInList);</CODE><P CLASS="T1.Text1"><A NAME="pgfId=3518"> </A>The last set of services performs enqueueing and dequeueing from a LIFO list. It is used internally in the STREAMS implementation; it is exported so you can use it if it proves useful. If you look at the Open Transport LIFO implementation, it assumes that the structures being linked have their links pointing at the next link, and so on. Unfortunately, STREAMS messages (<TT CLASS="cv">msgb</TT> structures) are not linked this way internally (the <TT CLASS="cv">b_cont</TT> field does not point to the <TT CLASS="cv">b_cont</TT> field of the next message block but instead points to the actual message block itself). These two functions let you create a LIFO list where the head pointer of the list points to the actual object, but the next pointer in the object is at some arbitrary offset. It is important that the links and the list itself be aligned on 32-bit boundaries for these functions to work properly.</P><CODE CLASS="Cv.Code"><A NAME="pgfId=14527"> </A>void* OTEnqueue<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(void** list, void* newListHead, size_t offsetOfNextPtr);<BR>void* OTDequeue<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(void** theList, size_t offsetOfNextPtr);</CODE></DIV><HR>&#169 1999 Apple Computer, Inc. &#150 (Last Updated 26 March 99)<P><A HREF="PCI_BOOK.220.html"><img src="images/up.gif" border="0" width="36" height="16"></A><nobr>&nbsp;</nobr><A HREF="PCI_BOOK.223.html"><img src="images/previous.gif" border="0" width="66" height="16"></A><nobr>&nbsp;</nobr><A HREF="PCI_BOOK.225.html"><img src="images/next.gif" border="0" width="49" height="16"></A><!-- insert Show/Hide frames --><a href="javascript:testFrame()"><script><!--document.write(frameLink);//--></script><!-- end Show/Hide frames --></A><!-- start of footer --><!--#include virtual="/includes/framesetfooter" --><!-- end of footer --></body></HTML>