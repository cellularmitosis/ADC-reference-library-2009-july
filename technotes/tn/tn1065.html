<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"			"http://www.w3.org/TR/REC-html40/loose.dtd"><HTML><!-- Template 03-24-01 --><HEAD><LINK REL="stylesheet" HREF="../../adcstyle.css" TYPE="text/css"><LINK REL="stylesheet" HREF="../../style.css" TYPE="text/css"><title>Technical Note TN1065: Using QuickDraw GX Functionality from Pascal or Modula-2 - Without Writing Any C Code</title>    <meta name="keywords" content="Mac OS 8 QuickDraw GX modula pascal languages callback functionality">    <meta name="Description" content="Technical Note TN1065: This Technical Note details methodsthat a Pascal or Modula  programmer can use to take fulladvantage of QuickDraw GX from 68k code. Topics include:Differences Between C and Pascal Calling Conventions, CallingGX From Pascal-Conformant Code, Calling Pascal Code FromGX,         Calling Routines with More than One Argument,Calling Pascal Code From GX, Implementing a GX Callback,and Implementing a GX Extension or Driver."><meta name="categories" content="QuickDraw GX"><meta name="week-posted" content="Aug 26, 1996 - Sep 6, 1996"><LINK REL="stylesheet" HREF="../../css/adcstyle.css" TYPE="text/css"><script language="JavaScript" type="text/javascript" src="../../js/adc.js"></script></HEAD><BODY BGCOLOR="#FFFFFF"><a name="//apple_ref/doc/uid/DTS10002906" title="Using QuickDraw GX Functionality from Pascal or Modula-2 - Without Writing Any C Code"></a><A NAME="top"></A><!-- begin_header_information --><!--#include virtual="/adcnavbar" --><p><a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../technicalnotes/index.html">Technical Notes</a> &gt; <a href="../../technicalnotes/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../technicalnotes/LegacyTechnologies/idxGraphicsImaging-date.html">Graphics & Imaging</a> &gt; </p><div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/GraphicsImaging/index.html" target="_blank">Reference Library > Graphics & Imaging</a></li>
	</ul>
</div>




</div></div></div><!-- end_header_information --><!-- bottom_of_header_marker_comment --><!-- top_of_titles_marker_comment --><CENTER><table width="600" cellpadding="0" cellspacing="0" border="0">
<tr><td align="left" scope="row">
<h1>
<div id="pagehead">Technical Note TN1065</div>
<div id="pageheadsub">Using QuickDraw GX Functionality from Pascal or Modula-2 - Without Writing Any C Code</div>
</h1>
</td></tr></table></CENTER><!-- bottom_of_titles_marker_comment --><CENTER><TABLE BORDER=0 CELLSPACING=1 WIDTH=600><TR><td align="left"> <!-- begin_header_box --> <table width="600" cellpadding="0" cellspacing="0" border="0">	<tr>		<td width=300 valign="top" align=left scope="row">			<table border="0" width="300" cellpadding="0" cellspacing="0">			<tr>                        <td width=300 align=left> <img src="images/tnmenutop.gif" alt="" align="bottom" width=300 height=7></td>				</tr>				<tr bgcolor="#e6e6e6">					<td background="images/tnmenubody.gif" width=300 align=left>						<span id="menutitle">							CONTENTS                             <br>                            <br>						</span>					</td>				</tr>				<tr bgcolor="#e6e6e6">					<td background="images/tnmenubody.gif" width=300 align=left><!-- begin_toc --><p id="menutext"><A HREF = "#RTFToC1">Overview of the Problem</a><br><br><A HREF = "#RTFToC2">Differences Between C and Pascal Calling Conventions</a><br><br><A HREF = "#RTFToC3">Calling GX From Pascal-Conformant Code</a><br><br><A HREF = "#RTFToC4">Calling Routines with More than One Argument</a><br><br><A HREF = "#RTFToC5">Calling Pascal Code From GX</a><br><br><A HREF = "#RTFToC6">Implementing a GX Callback</a><br><br><A HREF = "#RTFToC7">Implementing a GX Extension or Driver</a><br><br><A HREF = "#Summary">Summary</a><br><br><A HREF="#Downloads">Downloadables</A></p>                  <!-- end_toc --> 								</td>				</tr>				<tr>					<td width=300 align=left scope="row">						<img src="images/tnmenubottom.gif" alt="" width=300 height=16>					</td>				</tr>			</table>		</td>		<td width=300 valign="top" align=left>			<!-- begin_intro_text -->            <P id = "introtext"><B>Important for all Apple Printing and Graphics Developers: </B></p><P id = "introtext">        The information in this Technote is still relevant up to and including        <A HREF = "tn1090.html">Mac OS 7.6</A>        with QuickDraw GX 1.1.5. Beginning with the release of Mac OS 8.0,        however, Apple plans to deliver a system which incorporates QuickDraw GX        graphics and typography <B>only</B>. QuickDraw GX printer drivers and GX printing        extensions will <B>not</B> be supported in Mac OS 8.0 or in future Mac OS releases. Apple's        goal is to simplify the user experience of printing by unifying the Macintosh        graphic and printing architectures and standardizing on the classic Printing        Manager. </P>        <P id = "introtext">QuickDraw GX was designed entirely with the C programmer in mind. As aconsequence, the user of a high-level language, such as Pascal or Modula-2, isleft unable to take advantage of all the capabilities of GX. This Technoteoutlines how you can get around this hurdle.</p><P id = "introtext">This Technote is aimed at programmers with some 68K assembly-languageexperience, who have an aversion to the C programming language. You will needto be familiar with the Macintosh Programmer's Workshop (MPW) environment, ifonly because that hosts the only 68K assembler on the Macintosh worth using. Iwill discuss how to make use of <i>all</i> the functionality of GX from alanguage like Pascal or Modula-2, without writing any C code.</p><P id = "introtext">The discussion breaks the problem down into all the important cases, and givesan example of how to deal with each. Based on this, you can construct your ownadaptation of Apple's GX interfaces, or you can make use of the adaptation inModula-2 that I have already done. The examples useModula-2 rather than Pascal, mainly because Modula-2 allows the definition ofroutine types, which Pascal does not.</p><CENTER><TABLE BORDER=0 WIDTH=275><TR><td bgcolor="#E6E6E6" align=left><P id = "introtext"><B>Note:</B><BR>This discussion applies only to using GX from 68K code. Differences inargument-passing conventions may be less of an issue in PowerPC code.</P></TD></TR></TABLE></CENTER> <CENTER><TABLE BORDER=0 WIDTH=275><TR><td bgcolor="#E6E6E6" align=left><P id = "introtext"><B>Warning:</B><BR>        Developers that intend to copy and paste the code that appears in this Technote should only do so from Netscape Navigator. Navigator fully supports all the special characters that appear within this Technote's code samples.</P></TD></TR></TABLE></CENTER><!-- end_intro_text --><!-- begin_date --><h3>&nbsp;Updated: [Sep 01 1996]</h3><!-- end_date -->                </TD>             </TR>          </TABLE>          <!-- end_header_box --> <BR><BR><hr width=500 align=center>          <BR><BR> <!-- begin_content --><a name = "RTFToC1"></a><H2>Overview of the Problem</H2><P>QuickDraw GX is a large piece of code, consisting of a number ofsubsystems. At the core is the graphics engine, and closely connected with thisare the font and layout routines. All this code follows C calling conventionsexclusively.</p><P>The GX Printing Manager uses an odd mixture of C and Pascal callingconventions. All application-level printing calls (and most calls back toapplication routines, apart from message overrides) use Pascal conventions,whereas calls made from drivers and extensions (and calls made <i>to</i> themfrom GX) follow C conventions.</p><P>Ancillary services, used heavily by the GX printing architecture, are providedby the Message Manager and the Collection Manager. The Collection Manager usesPascal conventions exclusively, so I don't need to discuss it further. TheMessage Manager uses C conventions exclusively.</p><P><A HREF="#top">Back to top</A></P><a name = "RTFToC2"></a><h2>Differences Between C and Pascal Calling Conventions</h2><P>The salient differences between C and Pascal calling conventions for 68K code,as far as GX calls are concerned, are: </p><ul><li>arguments end up in the opposite order on the stack;</li><li>Pascal expects the callee to pop the argument list, while C expects thecaller to do this;</li><li>function results of 4 bytes or less are returned in register D0 in C, on thestack in Pascal.</li></ul><P>There are other differences, such as treatment of arguments and resultslarger than 4 bytes, but it so happens these cases do not arise in the problemat hand, so they can be ignored for now.</p><P>There are two halves to the problem: your code calling GX, and GXcalling your code. The second is by far the more difficult one.</p><P><A HREF="#top">Back to top</A></P><a name = "RTFToC3"></a><h2>Calling GX From Pascal-Conformant Code</h2><p>In 68K code, all the GX graphics, layout and font functions are invokedvia the same A-trap, $A832. (Earlier versions of MacsBug named this trap as"Skia," which was the code name for GX graphics.) To call an A-trap routinethat follows C-language conventions from Pascal-conformant code, in general youhave to generate "glue" code that does the following: </p><ul><li>Make a copy of the argument list on the stack with the arguments in reverseorder;</li><li>Call the A-trap routine;</li><li>If the routine returns a function result, then copy register D0 into thestack location where Pascal expects the result to be;</li><li>Pop both copies of the argument list off the stack.</li></ul><P>One fact that helps to simplify things is that the arguments to, and resultsfrom, GX routines are exclusively 32-bit quantities (the only exceptions beingGX Printing Manager-related calls, which follow Pascal conventions anyway).</p><p>You can further simplify this in the situation where the routine takes no morethan one argument: in this case, there is no need to reorder the argumentlist--you can pass the compiler-generated list directly to the GX routine. Infact, the glue becomes so simple, it can be done as an inline.</p><P>Following are examples of all of the cases that can be handled with inlines.These can be adapted simply by changing the selector code as appropriate.First, the simplest possible case: a GX routine that takes no arguments andreturns no result: </p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>  PROCEDURE GXEnterGraphics;        CODE            0705FH,        (* moveq.l #$5F, d0 *)            0A832H;        (* _Skia *)</pre>	</TD></TR></TABLE></CENTER><P>It so happens that all the calls with no arguments and no result have selectorcodes between 0 and 127, hence the above example can be adapted directly,including the use of the moveq instruction.</p><p>Here is one with a result but no arguments: </p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>    PROCEDURE GXNewInk() : gxInk;        CODE            0303CH, 0009DH,    (* move.w #$9D, d0 *)            0A832H,        (* _Skia *)            02E80H;        (* move.l d0, (sp) *)</pre>	</TD></TR></TABLE></CENTER><p>This one has an argument but no result: </p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>    PROCEDURE GXDrawShape      (        source : gxShape      );        CODE            0303CH, 000DCH,        (* move.w #$DC, d0 *)            0A832H,            (* _Skia *)            0588FH;            (* addq.l #4, sp *)</pre>	</TD></TR></TABLE></CENTER><p>And this one has both a single argument and a result: </p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>    PROCEDURE GXNewShape      (        aType : gxShapeType      ) : gxShape;        CODE            0303CH, 0009EH,        (* move.w #$9E, d0 *)            0A832H,            (* _Skia *)            0588FH,            (* addq.l #4, sp *)            02E80H;            (* move.l d0, (sp) *)</pre>	</TD></TR></TABLE></CENTER><p>When you have more than one argument, then it becomes easier to call anassembly-language glue routine, than to use an inline. The repetitiveness ofthe structure of the glue makes it natural--in fact, imperative--to useassembly-language macros to generate it.</p><P><A HREF="#top">Back to top</A></P><a name = "RTFToC4"></a><h2>Calling Routines with More than One Argument</h2><p>Where the GX routine you're calling has more than one argument, the glueyou need to interface to it would look something like this: </p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>    lea        4(sp), a0    ; address of argument list    move.l    (a0)+, -(sp) ; copy arguments in reverse order    move.l    (a0)+, -(sp) ; repeat as many times as necessary    ...    move.w    #TrapCode, d0    dc.w        $A832              ; call the GX routine    add.l        #NrArgs*4, sp ; pop the copied argument list    move.l    (sp)+, a0          ; get the return address    add.l        #NrArgs*4, sp ; pop the original argument list    move.l    d0, (sp)          ; return the result (if appropriate)    jmp        (a0)           ; back to caller</pre>	</TD></TR></TABLE></CENTER><P>My actual macros make a few embellishments to this. First off, not all thearguments are actually longwords: there are a couple of layout routines(<code>GXGetOffsetGlyphs</code> and <code>GXGetGlyphOffset</code>) with arguments that are more naturallyrepresented as booleans. The glue will take care of converting all arguments tolongwords, as GX expects.</p><p>Here is a basic macro to generate the GX glue: </p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>_Skia    opword    $A832    macro    GXCall    &amp;ModuleName, &amp;RoutineName, &amp;ArgList, &amp;Result=, &amp;TrapCode.* General macro for generating call glue for both A-trap routines.* and library routines..* ModuleName is the name of the Modula-2 definition module.* containing the external declaration; RoutineName is the name of.* the routine. ArgList is the list of arguments,.* each argument being of the form &lt;name&gt;.&lt;size&gt; (name is ignored,.* but is useful for checking purposes), Result specifies the.* function result size (b, w, l for byte word or long, omit if.* no result), and TrapCode is the A-trap selector.    seg    '&amp;ModuleName'&amp;ModuleName._&amp;RoutineName proc export    lcla    &amp;ArgIndex, &amp;ArgListLength, &amp;NrArgs, &amp;ResultSize    lclc    &amp;ThisArgSize, &amp;ThisArg&amp;NrArgs seta &amp;nbr(&amp;ArgList)    if &amp;NrArgs &lt;&gt; 0 then    lea    4(sp), a0    endif    if &amp;Result &lt;&gt; '' then    if &amp;Result = 'b' then&amp;ResultSize seta 1    elseif &amp;Result = 'w' then&amp;ResultSize seta 2    elseif &amp;Result = 'l' then&amp;ResultSize seta 4    else    aerror    &amp;Concat('Unrecognized result size: ', &amp;Result)    endif    else.* no result&amp;ResultSize seta 0    endif&amp;ArgListLength seta 0&amp;ArgIndex seta    &amp;NrArgs    while &amp;ArgIndex &gt; 0 do&amp;ThisArg setc &amp;ArgList[&amp;ArgIndex]&amp;ThisArgSize seta &amp;pos('.', &amp;ThisArg)&amp;ThisArg setc &amp;ThisArg[&amp;ThisArgSize + 1 : 99]    if &amp;ThisArg = 'b' then&amp;ThisArgSize seta 2    move.b    (a0)+, d0    tst.b    (a0)+ ; bytes are pushed as words    extb.l    d0    move.l    d0, -(sp)    elseif &amp;ThisArg = 'w' then&amp;ThisArgSize seta 2    move.w    (a0)+, d0    ext.l    d0    move.l    d0, -(sp)    elseif &amp;ThisArg = 'l' then&amp;ThisArgSize seta 4    move.l    (a0)+, -(sp)    else    aerror    &amp;Concat('Unrecognized arg size: ', &amp;ArgList[&amp;ArgIndex])    endif&amp;ArgListLength seta &amp;ArgListLength + &amp;ThisArgSize&amp;ArgIndex seta    &amp;ArgIndex - 1    endwhile    move.w    #&amp;TrapCode, d0    _Skia    if &amp;NrArgs &lt;&gt; 0 then    add.l    #&amp;NrArgs*4, sp    endif    move.l    (sp)+, a0    if &amp;ArgListLength &lt;&gt; 0 then    add.l    #&amp;ArgListLength, sp    endif    if &amp;ResultSize = 1 then    move.b    d0, (sp)    elseif &amp;ResultSize = 2 then    move.w    d0, (sp)    elseif &amp;ResultSize = 4 then    move.l    d0, (sp)    endif    jmp    (a0)    endproc    endm</pre>	</TD></TR></TABLE></CENTER><p>And here is an example of how to use the above. First, the original C prototypeof the GX routine: </p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>    void GXGetOffsetGlyphs      (        gxShape layout,        gxByteOffset trial,        long leadingEdge,        gxLayoutOffsetState *offsetState,        unsigned short *firstGlyph,        unsigned short *secondGlyph      );</pre>	</TD></TR></TABLE></CENTER><p>Here's how I declared it in Modula-2: </p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>    PROCEDURE GXGetOffsetGlyphs      (        layout : gxShape;        trial : gxByteOffset;        leadingEdge : BOOLEAN;        VAR offsetState : gxLayoutOffsetState;        VAR firstGlyph : ShortCard;        VAR secondGlyph : ShortCard      );</pre>	</TD></TR></TABLE></CENTER><p>Here's the macro call to generate the glue: </p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>    GXCall    GXLayoutRoutines, GXGetOffsetGlyphs, (layout.l, trial.l,    leadingEdge.b, offsetState.l, firstGlyph.l, secondGlyph.l), , $15</pre>	</TD></TR></TABLE></CENTER><p>And a quick dump of the generated object code: </p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>    LEA        $0004(A7),A0    MOVE.L     (A0)+,-(A7)    MOVE.L     (A0)+,-(A7)    MOVE.L     (A0)+,-(A7)    MOVE.B     (A0)+,D0    TST.B      (A0)+    EXTB.L     D0    MOVE.L     D0,-(A7)    MOVE.L     (A0)+,-(A7)    MOVE.L     (A0)+,-(A7)    MOVE.W     #$0015,D0    DC.W       $A832               ; TB 0032    ADDA.W     #$0018,A7    MOVEA.L    (A7)+,A0    ADDA.W     #$0016,A7    JMP        (A0)</pre>	</TD></TR></TABLE></CENTER><p>Note the use of the EXTB instruction for extending the byte boolean toa long. That's only valid on 68020 and better processors--but then, GX won'trun on anything less!</p><P><A HREF="#top">Back to top</A></P><a name = "RTFToC5"></a><H2>Calling Pascal Code From GX</H2><P>This part of the problem is the opposite of the previous one: here youhave to wrap your routine in some "glue" that will convert between callingconventions, and pass that to GX for it to call.</p><p>This part is best broken into two main cases, with different applicable methodsof attack. The first is, when calling a GX routine, how to pass the address ofone of your routines for it to call back. The second is how to write a GXprinting extension or driver in a language that uses Pascal callingconventions.</p><P><A HREF="#top">Back to top</A></P><a name = "RTFToC6"></a><H2>Implementing a GX Callback</H2><p>One way to let GX call one of your routines is to write wrapper glue forit in assembly language. There are a couple of reasons why I feel this isundesirable: </p><ul>    <li>It is repetitive, tedious and error-prone. Having done it once, of course,you could copy and paste (and adapt) the code to a new project, but that is<i>not</i> a particularly effective way to reuse code.</li>    <li>It adds extra source files, which needlessly complicate the building of yourproject.</li></ul><P>Instead, my preferred approach is to have a library routine to generate theappropriate glue at run-time. I can write the routine once for each case, andreuse it every time that case arises. Some people may throw their hands up inhorror at this, and cry "self-modifying code!" However, the technique is infact quite simple and safe to use -- certainly simpler and safer than most ofthe alternatives...</p><p>The case I will use as an example is how to define the <code>gxSpoolProcedure</code>callback that you pass to GX when flattening and unflattening shapes. One nicething about defining your own interfaces is that you can make tweaks to improvetheir usability in some way. For instance, here is how I define the type of a<code>gxSpoolProcedure</code> in Modula-2:</p> <CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>    gxSpoolProcedure =        PROCEDURE          (            (*command : *) gxSpoolCommand,            (*block : *) gxSpoolBlockPtr,            (*arg : *) ADDRESS (* meaning is up to caller *)          ) : LONGINT;</pre>	</TD></TR></TABLE></CENTER><P>The difference from the "official" definition is the addition of an extraargument, which allows me to pass additional information to the routine. Thisinformation is passed to the glue-generating routine, and bound into thegenerated wrapper code, so GX doesn't need to know it is being passed!</p><p>Here is the structure for holding the wrapper glue code: </p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>    TYPE        BoundgxSpoolProcedure = ARRAY [1 .. 13] OF ShortCard;</pre>	</TD></TR></TABLE></CENTER><p>And here is the routine that takes the address of your spool callback routineand the value of the extra argument, and actually generates the wrapper glue: </p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>    PROCEDURE BindgxSpoolProcedure      (        TheProc : gxSpoolProcedure;        ToArg : ADDRESS;        VAR Result : BoundgxSpoolProcedure      );      (* creates a closure of the specified spool procedure        which can be passed where QuickDraw GX expects one. *)    BEGIN        Result[1] : = 041EFH;    (* lea n(sp), a0 *)        Result[2] : = 00004H;    (* n for above *)        Result[3] : = 042A7H;    (* clr.l -(sp) *) (* room for result *)        Result[4] : = 02F18H;    (* move.l (a0)+, -(sp) *) (* copy command arg *)        Result[5] : = 02F18H;    (* move.l (a0)+, -(sp) *) (* copy block arg *)        Result[6] : = 02F3CH;    (* move.l #n, -(sp) *) (* insert additional arg *)        Result[7] : = HiWrd(ToArg); (* n for above *)        Result[8] : = LoWrd(ToArg); (* ditto *)        Result[9] : = 04EB9H;    (* jsr l *)        Result[10] : = HiWrd(CAST(LongCard, TheProc)); (* l for above *)        Result[11] : = LoWrd(CAST(LongCard, TheProc)); (* ditto *)        Result[12] : = 0201FH;    (* move.l (sp)+, d0 *)            (* return result where C expects it *)        Result[13] : = 04E75H;    (* rts *)        FlushCaches    END BindgxSpoolProcedure;</pre>	</TD></TR></TABLE></CENTER><p>As an example of how to use the above, here is my version of the <code>HandleToShape</code>routine from the Apple-provided GX library source code. Note in particular howthe extra argument is used to pass the environment pointer to allow access toouter local variables from the inner routine: </p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>    PROCEDURE HandleToShape      (        TheHandle : Handle;        NrViewPorts : LONGINT;        ViewPorts : gxViewPortPtr (* array *)      ) : gxShape;      (* unflattens a handle into a new shape. Any graphics errors are        automatically posted. *)        VAR            SrcOffset : LONGCARD;            BoundSpoolFromHandle : BoundgxSpoolProcedure;            HandleSpool : gxSpoolBlock;        PROCEDURE SpoolFromHandle          (            command : gxSpoolCommand;            VAR block : gxSpoolBlock          ) : LONGINT;          (* spool routine to retrieve the flattened shape data from TheHandle. *)        BEGIN            SAVEREGS;            CASE VAL(INTEGER, command) OF            | GXGraphicsTypes.gxReadSpool:                BlockMoveData                  (                    (*sourcePtr : =*) TheHandle^ + SrcOffset,                    (*destPtr : =*) block.buffer,                    (*byteCount : =*) block.count                  );                SrcOffset : = SrcOffset + VAL(LONGCARD, block.count)            ELSE              (* ignore *)            END (*CASE*);            RETURN                0        END SpoolFromHandle;    BEGIN (*HandleToShape*)        SrcOffset : = 0;        BindgxSpoolProcedure          (            (*TheProc : =*)                CAST(GXUseful.gxSpoolProcedure, ADR(SpoolFromHandle)),            (*ToArg : =*) CurrentA6(),            (*@Result : =*) BoundSpoolFromHandle          );        HandleSpool.spoolProcedure : = ADR(BoundSpoolFromHandle);        HandleSpool.buffer : = NIL; (* let GX allocate the buffer *)        HandleSpool.bufferSize : = 0; (* ditto *)        RETURN            GXUnflattenShape              (                (*@block : =*) HandleSpool,                (*count : =*) NrViewPorts,                (*portList : =*) ViewPorts              )    END HandleToShape;</pre>	</TD></TR></TABLE></CENTER><P><A HREF="#top">Back to top</A></P><a name = "RTFToC7"></a><h2>Implementing a GX Extension or Driver</h2><P>When trying to write a GX printing extension or driver in a language thatconforms to Pascal calling conventions, you have the job of generatingappropriate glue for each of your message overrides. As I made clear in theprevious section, doing this by hand, in assembly language, is not my idea offun.</p><P>Thus, I hit upon the idea of writing an MPW tool, called <code>PrintingSegment</code>, toautomatically generate the glue code. The result takes the form of a .o objectfile that you link at the front of your "pext" or "pdvr" code segment. The sametool can also generate the "over" resources that tell GX printing where theroutine entry points are and which messages they handle. Thus, the tool alsosolves the problem of keeping the "over" resources in sync.</p><P>I did make one simplification: I decided that giving the tool the informationnecessary to copy and convert the argument list was too much work. Instead, Ipass a single pointer to the argument list as the argument to thePascal-conformant routine.</p><p>For example, consider the interface for an override for the <code>gxDespoolPage</code>message. In Apple's C interfaces, this is defined as: </p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>    typedef OSErr (*GXDespoolPageProcPtr)      (        gxSpoolFile theSpoolFile,        long numPages,        gxFormat theFormat,        gxShape *thePage,        Boolean *formatChanged      );</pre>	</TD></TR></TABLE></CENTER><p>The following record structure exactly mirrors the layout of the C argumentlist: </p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>    TYPE        BooleanPtr = POINTER TO BOOLEAN;        gxShapePtr = POINTER TO gxShape;        GXDespoolPageArgs =            RECORD                theSpoolFile : gxSpoolFile;                PageNumber : LONGINT;                theFormat : gxFormat;                thePage : gxShapePtr;                formatChanged : BooleanPtr            END (*RECORD*);</pre>	</TD></TR></TABLE></CENTER><p>(Note that all the C arguments are passed as longwords.) So thePascal-conformant override for this message is declared as: </p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>    PROCEDURE HandleDespoolPage      (        VAR Args : GXDespoolPageArgs      ) : OSErr;</pre>	</TD></TR></TABLE></CENTER><p>and the glue that <code>PrintingSegment</code> generates to call this override looks likethis: </p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>    CLR.W      -(A7)    PEA        $0006(A7)    JSR        HandleDespoolPage    MOVE.W     (A7)+,D0    RTS</pre>	</TD></TR></TABLE></CENTER><p>Here is what the body of <code>HandleDespoolPage</code> might look like, in a printingextension that allows the user to reverse the order in which pages areprinted: </p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>    PROCEDURE HandleDespoolPage      (        VAR Args : GXDespoolPageArgs      ) : OSErr;      (* override for gxDespoolPage message. *)        VAR            ThisPageNumber : LONGINT;            Err : OSErr;    BEGIN        SAVEREGS;        IF ReverseOrderPrinting THEN            ThisPageNumber : = NrPages - Args.PageNumber + 1        ELSE            ThisPageNumber : = Args.PageNumber        END (*IF*);        Err : = ForwardGXDespoolPage          (            (*theSpoolFile : =*) Args.theSpoolFile,            (*PageNumber : =*) ThisPageNumber,            (*theFormat : =*) Args.theFormat,            (*@thePage : =*) Args.thePage^,            (*@formatChanged : =*) Args.formatChanged^          );        RETURN            Err    END HandleDespoolPage;</pre>	</TD></TR></TABLE></CENTER><P><A HREF="#top">Back to top</A></P><a name = "Summary"></a><H2>Summary</H2><p>It is certainly feasible to write all kinds of GX-based code -- fromstraight applications to printer drivers and extensions -- in a high-levellanguage rather than C.</p><P><A HREF="#top">Back to top</A></P>         <P><A NAME=Downloads></A></P>                  <H2>Downloadables</H2>                  <TABLE BORDER=0 CELLPADDING=3 WIDTH="500">            <TR>               <td width=50 align=left>                  <P ALIGN=center><img src="images/acrobatsmall.gif" width=22 height=23 align=middle alt="Acrobat"></P>               </TD>               <td align="left">                  <P>Acrobat version of this Note (76K).</P>               </TD>               <td width=60 align=left>                  <P><A HREF="pdf/tn1065.pdf">Download</A></P>               </TD>            </TR></TABLE><P><A HREF="#top">Back to top</A></P></TD></TR></table></center><!-- begin_footer_information -->	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/technotes/tn/tn1065.html%3Fid%3DDTS10002906-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/technotes/tn/tn1065.html%3Fid%3DDTS10002906-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/technotes/tn/tn1065.html%3Fid%3DDTS10002906-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>
<!--#include virtual="/includes/footer"--><!-- end_footer_information --><hr width=500 align=center></BODY></HTML>