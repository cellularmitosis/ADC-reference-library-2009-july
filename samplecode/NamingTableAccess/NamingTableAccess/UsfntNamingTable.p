{	File:		UsfntNamingTable.p	Contains:	a Pascal Unit, and a small application demonstrating its usage. Helps dig	 			out the contents of the NamingTable in a TrueType 'sfnt' (see "The TrueTypeª	 			Font Format Specification Version 1.0", APDA M0825LL/A, p. 232).				Access to tables contained in a 'sfnt' has been coded along the lines				suggested by Mike Reed (see  d e v e l o p  n¡ 8, "Curves ahead").	Written by: Joseph Maure		Copyright:	Copyright © 1991-1999 by Apple Computer, Inc., All Rights Reserved.				You may incorporate this Apple sample source code into your program(s) without				restriction. This Apple sample source code has been provided "AS IS" and the				responsibility for its operation is yours. You are not permitted to redistribute				this Apple sample source code as "Apple sample source code" after having made				changes. If you're going to re-distribute the source, we require that you make				it clear in the source that the code was descended from Apple sample source				code, but that you've made changes.	Change History (most recent first):				8/12/1999	Karl Groethe	Updated for Metrowerks Codewarror Pro 2.1				}unit UsfntNamingTable;interface{¥  uses ¥}{¥  Script;  ¥}  { for script codes 0 = smRoman, 1 = smJapanese, ..., 31 = smExtArabic, 32 = Uninterp }  { and language codes 0 = langEnglish, 1 = langFrench, 2 = langGerman, 3 = langItalian, ..., 139 = langSundaneseRom }{$IFC UNDEFINED THINK_PASCAL}{$SETC THINK_PASCAL := 0}{$ENDC}{$IFC NOT THINK_PASCAL}	uses		Types, Memory;{$ENDC}	const{ nameID numbers for content of naming table strings }		kCopyright = 0;		kFamily = 1;		kStyle = 2;		kUnique = 3;		kFull = 4;		kVersion = 5;		kPostscript = 6;		kTrademark = 7;		kManufacturer = 8;function NamingTableLookup (sfnt: Handle; var platform, encoding, language, content, index: Integer): Str255;{ Returns the name from the naming table which corresponds to the given platform, encoding, language, content ID numbers. }{ A value of -1 for any of these acts as a wildcard; if a name has been found, -1 is replaced by the actual ID. }{ The search should start with index = 0; on return , <index>  points beyond the returned entry, such that the function }{ can be called repeatedly (with wildcard parameters) to find all the names for a given ID specification. }{ If there is no name for a given ID specification in the sfnt, or if an error ocurred,  the empty string is returned.}{ platform: 0 = UniChar, no specific encoding;  1 = Macintosh; 2 = ISO }{ encoding: if platform = Macintosh, then encodingID = Macintosh Script Manager code }{                 if platform = ISO, then encodingID = 0 = 7-bit ASCII, or 1 = ISO 10646, or 2 = ISO 8859-1 }implementation{ Some of these "hidden" implementation details are inspired by Mike Reed's OutlineAccess code }{ See  d e v e l o p   n¡ 8 , "Curves ahead " }{$IFC THINK_PASCAL}	type		IntegerPtr = ^Integer;{$ENDC}	function GetNamingTablePtr (sfnt: Handle): IntegerPtr;		const			kNumOffset = 4;   { from start of 'sfnt' resource }			kTableOffset = 12;		type			SfntDirectoryEntry = record					tableTag: OSType;					checkSum: Longint;					offset: Longint;					iLength: Longint;				end;			SfntTableDirectory = array[0..0] of SfntDirectoryEntry; { actually array[0 .. numOffsets-1] }			TablePtr = ^SfntTableDirectory;		var			p: IntegerPtr;			dir: TablePtr;			off: Longint;			index: Integer;	begin		p := IntegerPtr(ord4(sfnt^) + kNumOffset);		index := p^;  { = number of tables in table directory}		dir := TablePtr(ord4(sfnt^) + kTableOffset);		off := 0;		while index > 0 do			begin				index := index - 1;				with dir^[index] do					if tableTag = 'name' then						begin							off := offset;							Leave;						end;			end;		if off > 0 then			GetNamingTablePtr := IntegerPtr(ord4(sfnt^) + off)		else			GetNamingTablePtr := nil;	end;	function NamingTableLookup (sfnt: Handle; var platform, encoding, language, content, index: Integer): Str255;		const			kNumberOfRecs = 2;  { from start of NamingTable }			kStringStorage = 4;			kNameRecords = 6;		type			SfntNameRecord = record					platformID: Integer;					encodingID: Integer;					languageID: Integer;					nameID: Integer;					strLength: Integer;					strOffset: Integer;				end;			SfntNRArray = array[0..0] of SfntNameRecord; { actually array[0 .. count-1] }			SfntNRArrayPtr = ^SfntNRArray;		var			p0, p: IntegerPtr;			strStore: Ptr;			found: Boolean;			count: Integer;			s: Str255;			flags: SignedByte;	begin		flags := HGetState(sfnt);		HLock(sfnt);		found := false;		s := '';		p0 := GetNamingTablePtr(sfnt);		if p0 <> nil then			begin				p := IntegerPtr(ord4(p0) + kNumberOfRecs);  { points to number of NameRecords in Naming Table in the 'sfnt' }				count := p^;				p := IntegerPtr(ord4(p0) + kStringStorage);				strStore := Ptr(ord4(p0) + p^);  { points to actual string data }				p := IntegerPtr(ord4(p0) + kNameRecords);  { now points to nameRecords }				while (index < count) and not found do					with SfntNRArrayPtr(p)^[index] do						begin							if (platform = platformID) | (platform = -1) then								if (encoding = encodingID) | (encoding = -1) then									if (language = languageID) | (language = -1) then										found := (content = nameID) | (content = -1);							if found then								begin									platform := platformID;									encoding := encodingID;									language := languageID;									content := nameID;								end;							index := index + 1;						end;				if found then					with SfntNRArrayPtr(p)^[index - 1] do						begin							if strLength > 255 then								s[0] := chr(255)							else								s[0] := chr(strLength);							BlockMove(Ptr(ord4(strStore) + strOffset), @s[1], ord(s[0]));						end			end;		NamingTableLookup := s;		HSetState(sfnt, flags);	end;end.