<!-- Generated by Harlequin WebMaker 2.2.3 (23-Apr-1996)
LispWorks 3.2.2 -->
<HTML> <HEAD>
<TITLE>Using the Memory Management Utilities (IM: M)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING181></A>



<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="Memory-180.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Memory-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Memory-202.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="Memory-182.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="Memory-2.html"><B>Memory</B></A> / <BR><DD><A HREF="Memory-178.html"><B>Chapter 4 - Memory Management Utilities</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING181-0></A>
<H1><A NAME=MARKER-9-95></A>Using the Memory Management Utilities</H1>
 This section describes how you can<P>
<UL>
<LI>save and restore the value of the A5 register so that you can access your application's A5 world in completion routines or other interrupt tasks
<LI>access your application's QuickDraw global variables from within stand-alone code
<LI>change the address-translation mode so that you can temporarily use 32-bit addresses
<LI>strip the flag bits from a master pointer or other memory address
<LI>convert 24-bit addresses to 32-bit addresses<P>
</UL>
<A NAME=HEADING181-7></A>
<H2><A NAME=MARKER-9-96></A><A NAME=MARKER-2-97></A><A NAME=MARKER-2-98></A>Accessing the A5 World in Completion Routines</H2>
 <A NAME=MARKER-2-99></A>Some Toolbox and Operating System routines require you to pass the address of an application-defined <B>callback routine,</B> usually in a variable of type <CODE>ProcPtr</CODE>. After a certain condition has been met, the Toolbox executes the specified routine. The exact time at which the Toolbox executes the routine varies. The timing of execution is determined by the Toolbox routine to which you passed the routine's address and the action that must be completed before the routine is called.<P>
 Callback routines are quite common in the Macintosh system software. A grow-zone function, for instance, is an application-defined callback routine that is called every time the Memory Manager cannot find enough space in your heap to honor a memory-allocation request. Similarly, if your application plays a sound asynchronously, you can have the Sound Manager execute a <B>completion routine</B> after the sound is played. The completion routine might release the sound channel used to play the sound or perform other cleanup operations.<P>
 In general, you cannot predict what your application will be doing when an asynchronous completion or callback routine is actually executed. The routine could be called while your application is executing code of its own or executing another Toolbox or Operating System routine.<P>
<DL>
<DT><B>Note</B>
<DD>The completion or callback routine might even be called when your application is in the background. Before executing a completion or callback routine belonging to your application, the Process Manager checks whether your application is in the foreground. If not, the Process Manager performs a minor switch to give your application temporary control of the CPU.<EM></EM><A NAME=MARKER-2-100></A>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
 <A NAME=MARKER-2-101></A><A NAME=MARKER-2-102></A>Many Toolbox and Operating System routines do not need to access the calling application's global variables, QuickDraw global variables, or jump table. As a result, they sometimes use the A5 register for their own purposes. They save the current value of the register upon entry, modify the register as necessary, and then restore the original value on exit. As you can see, if one of these routines is executing when your callback routine is executed, your callback routine cannot depend on the value in the A5 register. This effectively prevents your callback routine from using any part of its A5 world.<A NAME=MARKER-2-103></A><P>
 To solve this problem, simply use the strategy that the Toolbox employs when it takes over the A5 register: save the current value in the A5 register at the start of your callback procedure, install your application's A5 value, and then restore the original value when you exit. <A HREF=#MARKER-9-107>Listing 4-1</A> illustrates a very simple grow-zone function that uses this technique. It uses the <CODE>SetCurrentA5</CODE> and <CODE>SetA5</CODE> utilities to manipulate the A5 register.<A NAME=MARKER-2-104></A><A NAME=MARKER-2-105></A><A NAME=MARKER-2-38></A><P>
<B>Listing 4-1  <A NAME=MARKER-9-107></A>A sample grow-zone function</B><P>
<PRE>
FUNCTION MyGrowZone (cbNeeded: Size): LongInt;
VAR
   theA5:   LongInt;             {value of A5 when function is called}
BEGIN
   theA5 := SetCurrentA5;        {remember current value of A5; install ours}
   IF (gEmergencyMemory^ &lt;&gt; NIL) &amp; (gEmergencyMemory &lt;&gt; GZSaveHnd) THEN
      BEGIN
         EmptyHandle(gEmergencyMemory);
         MyGrowZone := kEmergencyMemorySize;
      END
   ELSE
      MyGrowZone := 0;           {no more memory to release}
   theA5 := SetA5(theA5);        {restore previous value of A5}
END;
</PRE>
 The function <CODE>SetCurrentA5</CODE> does two things: it returns the current value in the A5 register, and it sets the A5 register to the value of the <CODE>CurrentA5</CODE> low-memory global variable. This global variable always contains a value that points to the boundary between the current application's parameters and its global variables. The <CODE>MyGrowZone</CODE> function defined in <A HREF=#MARKER-9-107>Listing 4-1</A> calls <CODE>SetCurrentA5</CODE> on entry to make sure that it can read the value of the gEmergencyMemory global variable.<A NAME=MARKER-2-108></A><P>
 The function <CODE>SetA5</CODE> also does two things: it returns the current value in the A5 register, and it sets the A5 register to whatever value you pass to the function. The <CODE>MyGrowZone</CODE> function calls <CODE>SetA5</CODE> with the original value of the A5 register as the parameter. In this case, the value returned by <CODE>SetA5</CODE> is ignored.<P>
 There is no way to test whether, at the time your callback routine is called, your application is executing a Toolbox routine that could change the A5 register. Therefore, to be safe, you should save and restore the A5 register in any callback routine that accesses any part of your A5 world. Such routines include<P>
<UL>
<LI>grow-zone functions<A NAME=MARKER-2-109></A>
<LI>Sound Manager completion routines
<LI>File Manager I/O completion routines<A NAME=MARKER-2-110></A>
<LI>control-action procedures<A NAME=MARKER-2-111></A>
<LI>TextEdit word-break and click-loop routines<A NAME=MARKER-2-112></A><A NAME=MARKER-2-113></A>
<LI>trap patches<A NAME=MARKER-2-114></A>
<LI>custom menu definition, window definition, and control definition procedures<A NAME=MARKER-2-115></A><A NAME=MARKER-2-116></A><A NAME=MARKER-2-117></A><P>
</UL>
 See the section of <a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><I>Inside Macintosh</I></A> describing any particular completion or callback routine for details on whether you need to save and restore the A5 register in this way.<A NAME=MARKER-2-118></A><A NAME=MARKER-2-119></A><A NAME=MARKER-2-120></A><P>
<A NAME=HEADING181-27></A>
<H2><A NAME=MARKER-9-121></A><A NAME=MARKER-2-122></A>Accessing the A5 World in Interrupt Tasks</H2>
 <A NAME=MARKER-2-123></A>Sometimes, an application-defined routine executes at a time when you can't reliably call <CODE>SetCurrentA5</CODE>. For example, if your application is not the current application and you call <CODE>SetCurrentA5</CODE> as illustrated in <A HREF=#MARKER-9-107>Listing 4-1</A>, the function will not return your application's value of <CODE>CurrentA5</CODE>. The <CODE>SetCurrentA5</CODE> function always returns the value of the low-memory global variable <CODE>CurrentA5</CODE>, which always belongs to the <I>current</I> application. You'll end up reading some other application's A5 world.<P>
 In general, you cannot reliably call <CODE>SetCurrentA5</CODE> in any code that is executed in response to an interrupt, including the following:<P>
<UL>
<LI>Time Manager tasks<A NAME=MARKER-2-124></A>
<LI>VBL tasks<A NAME=MARKER-2-125></A>
<LI>tasks installed using the Deferred Task Manager<A NAME=MARKER-2-126></A>
<LI>Notification Manager response procedures<A NAME=MARKER-2-127></A><P>
</UL>
 <A NAME=MARKER-2-128></A>Instead of calling <CODE>SetCurrentA5</CODE> at interrupt time, you can call it at noninterrupt time when yours is the current application. Then store the returned value where you can read it at interrupt time. For example, the Notification Manager allows you to store information in the notification record passed to <CODE>NMInstall</CODE>. When you set up a notification record, you can use the <CODE>nmRefCon</CODE> field to hold the value in the A5 register. <A HREF=#MARKER-9-129>Listing 4-2</A> illustrates how to save the current value in the A5 register and pass that value to a response procedure.<P>
<B>Listing 4-2  <A NAME=MARKER-9-129></A>Passing A5 to a notification response procedure</B><P>
<PRE>
VAR
   gMyNotification:  NMRec;         {a notification record}

BEGIN
   WITH gMyNotification DO
   BEGIN
      qType := ORD(nmType);         {set queue type}
      nmMark := 1;                  {put mark in Application menu}
      nmIcon := NIL;                {no alternating icon}
      nmSound := Handle(-1);        {play system alert sound}
      nmStr := NIL;                 {no alert box}
      nmResp := @SampleResponse;    {set response procedure}
      nmRefCon := SetCurrentA5;     {pass A5 to notification task}
   END;
END;
</PRE>
 The key step is to save the value of <CODE>CurrentA5</CODE> where the response procedure can find it--in this case, in the <CODE>nmRefCon</CODE> field. You must call <CODE>SetCurrentA5</CODE> at noninterrupt time; otherwise, you cannot be certain that it will return the correct value.<P>
 When the notification response procedure is executed, its first task should be to call the <CODE>SetA5</CODE> function, which sets register A5 to the value stored in the <CODE>nmRefCon</CODE> field. At the end of the routine, the notification response procedure should call the <CODE>SetA5</CODE> function again to restore the previous value of register A5. <A HREF=#MARKER-9-131>Listing 4-3</A> shows a simple response procedure that sets up the A5 register, modifies a global variable, and then restores the A5 register.<A NAME=MARKER-2-130></A><P>
<B>Listing 4-3  <CODE><A NAME=MARKER-9-131></A></CODE>Setting up and restoring the A5 register at interrupt time</B><P>
<PRE>
PROCEDURE SampleResponse (nmReqPtr: NMRecPtr);
VAR
   oldA5:      LongInt;       {A5 when procedure is called}
BEGIN
   oldA5 := SetA5(nmReqPtr^.nmRefCon);
                              {set A5 to the application's A5}
   gNotifReceived := TRUE;    {set an application global }
                              { to show alert was received}
   oldA5 := SetA5(oldA5);     {restore A5 to original value}
END;
</PRE>
<DL>
<DT><B>Note</B>
<DD>Many optimizing compilers (including MPW) might put the address of a global variable used by the interrupt routine into a register before the call to <CODE>SetA5</CODE>, thereby possibly generating incorrect references to global data. To avoid this problem, you can divide your completion routine into two separate routines, one to set up and restore A5 and one to do the actual completion work. Check the documentation for your development system to see if this division is necessary, or contact Macintosh Developer Technical Support.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
 Several of the other managers that you can use to install interrupt code--including the Deferred Task Manager, the Time Manager, and the Vertical Retrace Manager--do not include a reference constant field in their task records. Therefore, if you wish to access global variables from within one of these tasks, you must use another mechanism to attach the value of the A5 register to the task record.<P>
 To do this, you can define a new record that contains the task record and your own reference constant field. You can initialize the task record as you normally would and then copy the value of your application's A5 register into the reference constant field you created. Then, when you obtain a pointer to the task record at interrupt time, you can <BR>use your knowledge of the size of the task record to compute the location of your reference constant field. See the chapters "Time Manager" and "Vertical Retrace Manager" in <I><A HREF="../Processes/Processes-2.html">Inside Macintosh: Processes</A></I> for detailed illustrations of these techniques.<A NAME=MARKER-2-132></A><A NAME=MARKER-2-133></A><P>
<A NAME=HEADING181-44></A>
<H2><A NAME=MARKER-2-134></A><A NAME=MARKER-9-135></A>Using QuickDraw Global Variables in Stand-Alone Code</H2>
 <A NAME=MARKER-2-136></A><A NAME=MARKER-2-137></A>If you are writing a stand-alone code segment such as a definition procedure for a window, menu, or control, you might want routines in that segment to examine the QuickDraw global variables of the current application. For example, you might want a control definition function to reference some of the QuickDraw global variables, such as <CODE>thePort</CODE>, <CODE>screenBits</CODE>, or the predefined patterns. Stand-alone segments, however, have no A5 world; if you try to link a stand-alone code segment that references your application's global variables, the linker may be unable to resolve those references.<P>
 To solve this problem, you can have the definition function find the value of the application's A5 register (by calling the <CODE>SetCurrentA5</CODE> function) and then use that information to copy all of the application's QuickDraw global variables into a record in the function's own private storage. <A HREF=#MARKER-9-138>Listing 4-4</A> defines a record type with the same structure as the QuickDraw global variables. Note that <CODE>randSeed</CODE> is stored lowest in memory and <CODE>thePort</CODE> is stored highest in memory.<P>
<B>Listing 4-4  <A NAME=MARKER-9-138></A>Structure of the QuickDraw global variables</B><P>
<PRE>
TYPE
   QDVarRecPtr = ^QDVarRec;
   QDVarRec =
   RECORD
      randSeed:   LongInt;          {for random-number generator}
      screenBits: BitMap;           {rectangle enclosing screen}
      arrow:      Cursor;           {standard arrow cursor}
      dkGray:     Pattern;          {75% gray pattern}
      ltGray:     Pattern;          {25% gray pattern}
      gray:       Pattern;          {50% gray pattern}
      black:      Pattern;          {all-black pattern}
      white:      Pattern;          {all-white pattern}
      thePort:    GrafPtr;          {pointer to current GrafPort}
   END;
</PRE>
 The location of these variables is linker-dependent. However, the A5 register always points to the last of these global variables, <CODE>thePort</CODE>. The Operating System references all other QuickDraw global variables as negative offsets from <CODE>thePort</CODE>. Therefore, you must dereference the value in A5 (to obtain the address of <CODE>thePort</CODE>), and then subtract the combined size of the other QuickDraw global variables from that address. The difference is a pointer to the first of the QuickDraw global variables, <CODE>randSeed</CODE>. <BR>You can copy the entire record into a local variable simply by dereferencing that pointer, as illustrated in <A HREF=#MARKER-9-139>Listing 4-5</A>.<P>
<B>Listing 4-5  <A NAME=MARKER-9-139></A>Copying the QuickDraw global variables into a record</B><P>
<PRE>
PROCEDURE GetQDVars (VAR qdVars: QDVarRec);
TYPE
   LongPtr = ^LongInt;
BEGIN
   qdVars := QDVarRecPtr(LongPtr(SetCurrentA5)^ -
                         (SizeOf(QDVarRec) - SizeOf(thePort)))^;
END;
</PRE>
 Thereafter, your stand-alone code segment can read QuickDraw global variables through the structure returned by GetQDVars. <A HREF=#MARKER-9-140>Listing 4-6</A> defines a very simple draw routine for a control definition function. After reading the calling application's QuickDraw global variables, the draw routine paints a rectangle with a pattern.<P>
<B>Listing 4-6  <A NAME=MARKER-9-140></A>A control's draw routine using the calling application's QuickDraw patterns</B><P>
<PRE>
PROCEDURE DoDraw (varCode: Integer; myControl: ControlHandle;
                  flag: Integer);
VAR
   cRect: Rect;
   qdVars: QDVarRec;
   origPenState: PenState;
CONST
   kDraw = 1;                       {constant to specify drawing}
BEGIN
   GetPenState(origPenState);       {get original pen state}
   cRect := myControl^^.contrlRect; {get control's rectangle}
   IF flag = kDraw THEN
      BEGIN
         GetQDVars(qdVars);         {patterns are QD globals}
         PenPat(qdVars.gray);       {install desired pattern}
         PaintRect(cRect);          {paint the control}
      END;
   SetPenState(origPenState);       {restore original pen state}
END;
</PRE>
 The DoDraw drawing routine defined in <A HREF=#MARKER-9-140>Listing 4-6</A> retrieves the calling application's QuickDraw global variables and paints the control rectangle with a light gray pattern. It also saves and restores the pen state, because the <CODE>PenPat</CODE> procedure changes that state.<A NAME=MARKER-2-141></A><A NAME=MARKER-2-142></A><A NAME=MARKER-2-143></A><P>
<A NAME=HEADING181-56></A>
<H2><A NAME=MARKER-2-144></A><A NAME=MARKER-9-145></A><A NAME=MARKER-2-146></A>Switching Addressing Modes</H2>
 <A NAME=MARKER-2-89></A>If you are writing a driver for a slot-card device, you can use the <CODE>SwapMMUMode</CODE> procedure to change to 32-bit address-translation mode temporarily, as follows:<P>
<PRE>
myMode := true32b;               {specify switch to 32-bit mode}
SwapMMUMode(myMode);             {perform switch}
</PRE>
 The parameter passed to <CODE>SwapMMUMode</CODE> must be a variable that is equal to the constant <CODE>false32b</CODE> or the constant <CODE>true32b</CODE>.<P>
<PRE>
CONST
   false32b    = 0;              {24-bit addressing mode}
   true32b     = 1;              {32-bit addressing mode}
</PRE>
 The <CODE>SwapMMUMode</CODE> procedure switches to the specified mode and then changes the parameter to indicate the mode previously in use. Thereafter, you can restore the previous address-translation mode by again calling<P>
<PRE>
SwapMMUMode(myMode);
</PRE>
<DL>
<DT><B>Note</B>
<DD>You should switch to 32-bit mode only if the computer supports 32-bit addressing. To find out whether a system supports 32-bit mode and whether a system started up in 32-bit mode, use the <CODE>Gestalt</CODE> function, described in the chapter "Gestalt Manager" in <I><A HREF="../OSUtilities/OSUtilities-2.html">Inside Macintosh: Operating System Utilities</A></I>. To determine the current address-translation mode, call the <CODE>GetMMUMode</CODE> function.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
 <A NAME=MARKER-2-148></A><A NAME=MARKER-2-149></A>If you do call <CODE>SwapMMUMode</CODE>, be careful to avoid situations that can cause the system to read an invalid address from the program counter. When the system is in 24-bit mode and you load a code resource into a block of memory (for example, by calling <CODE>GetResource</CODE>), the high byte of that block's master pointer contains Memory Manager flag bits. If you try to execute that code by performing an assembly-language <CODE>JSR</CODE> instruction (typically <CODE>JSR (A0)</CODE>, with the master pointer in register A0), the entire master pointer is translated directly into the program counter. This, however, is not a valid 32-bit address. As soon as you switch to 32-bit mode, the program counter contains an invalid value. This is virtually certain to cause the system to crash.<P>
<DL>
<DT><B>Note</B>
<DD>This problem can arise when you change to 32-bit mode in code loaded from a resource or placed into a block of memory that was allocated by calls to Memory Manager routines. It does not arise with standard <CODE>'CODE'</CODE> resources because the Segment Manager fixes the program counter.<EM></EM><A NAME=MARKER-2-150></A><A NAME=MARKER-2-151></A>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
 To avoid this problem, simply call <CODE>StripAddress</CODE> on the address in the program counter before you call <CODE>SwapMMUMode</CODE>. <A HREF=#MARKER-9-153>Listing 4-7</A> shows one way to do this.<A NAME=MARKER-2-152></A><P>
<B>Listing 4-7  <A NAME=MARKER-9-153></A>Stripping the program counter</B><P>
<PRE>
PROCEDURE FixPC;
   INLINE   $41FA, $000A,  {LEA *+$000C,A0}
            $2008,         {MOVE.L A0,D0}
            $A055,         {_StripAddress}
            $2040,         {MOVEA.L D0,A0}
            $4ED0;         {JMP (A0); jump to next instruction}
</PRE>
 For these same reasons, you also need to call <CODE>StripAddress</CODE> on any address you pass to the <CODE>_SetTrapAddress</CODE> trap, if the address references a block in your application heap.<A NAME=MARKER-2-154></A><P>
<A NAME=HEADING181-70></A>
<H2><A NAME=MARKER-2-155></A><A NAME=MARKER-9-156></A><A NAME=MARKER-2-20></A>Stripping Flag Bits From Memory Addresses</H2>
 <A NAME=MARKER-2-158></A><A NAME=MARKER-2-159></A><A NAME=MARKER-2-50></A>If your code runs on a system that might have started up with the 24-bit Memory Manager, you sometimes need to <B>strip</B> the flag bits from a memory address before you use it. The Operating System provides the <CODE>StripAddress</CODE> function for this purpose.<P>
 The <CODE>StripAddress</CODE> function takes an address as a parameter and returns the value of the address's low-order 3 bytes if the computer started up in 24-bit mode. If the system started up in 32-bit mode, <CODE>StripAddress</CODE> returns the address unchanged (because it must already be a valid 32-bit address). Note that if a system starts up in 32-bit mode, you cannot switch it to 24-bit mode.<P>
<DL>
<DT><B>WARNING</B>
<DD>If you pass a valid 32-bit address to <CODE>StripAddress</CODE> and the computer started in 24-bit mode, the function still strips off the high byte of the address, thus probably rendering the address invalid. You can pass 32-bit addresses to <CODE>StripAddress</CODE> if the system started up in 32-bit mode, but then the function does nothing to the address. Therefore, you should ordinarily pass only 24-bit addresses to the <CODE>StripAddress</CODE> function.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
 You need to use <CODE>StripAddress</CODE> primarily in device drivers or other software that communicates heap addresses to external hardware (such as a NuBus card). Because the external hardware might interpret the flag bits of a master pointer as part of the address, you need to call <CODE>StripAddress</CODE> to clear those flag bits.<P>
 There is nothing inherently dangerous about 24-bit addresses. They cause problems only when you try to use them in 32-bit mode. So, unless you are switching addressing modes (by calling <CODE>SwapMMUMode</CODE>), you generally don't need to call <CODE>StripAddress</CODE>.<P>
 You might, however, need to call <CODE>StripAddress</CODE> in these special cases, even if you are not designing a driver:<P>
<UL>
<LI>Making ordered address comparisons. If you want to sort an array by address or do any other kind of ordered address comparison (that is, using &lt;, &gt;, \xD1, or ), you need to call <CODE>StripAddress</CODE> on each address before the comparison. Even though the CPU uses only the lower 3 bytes when it determines memory addresses in 24-bit mode, it uses all 32 bits when it performs arithmetic operations.<A NAME=MARKER-2-161></A><A NAME=MARKER-2-162></A>
<LI>Comparing master pointers. If you want to perform any type of comparison on master pointers (that is, on dereferenced handles), you must first call <CODE>StripAddress</CODE> on each address. The master pointer flag bits can change at any time, so you need to clear them before making the comparison. In general, you should call <CODE>StripAddress</CODE> when comparing any two pointers, if either of them might be a dereferenced handle.<A NAME=MARKER-2-163></A>
<LI>Accessing addresses in 32-bit mode. If you switch the computer to 32-bit mode manually, you need to call <CODE>StripAddress</CODE> on all 24-bit pointers and handles that you access while in 32-bit mode. Be careful, however, not to call <CODE>StripAddress</CODE> on a valid 32-bit address.
<LI>Fixing the program counter. You might need to use <CODE>StripAddress</CODE> to fix the value of the program counter before you switch manually to 32-bit mode. See <A HREF=#MARKER-9-145>"Switching Addressing Modes" on page 4-20</A> for details.
<LI>Overcoming Resource Manager limitations. To avoid a limitation in the Resource Manager's <CODE>OpenResFile</CODE> and <CODE>OpenRFPerm</CODE> routines, you should call <CODE>StripAddress</CODE> on pointers to the filenames that you pass to those functions, but only if the strings that represent the files are hard-coded into your application's code instead of in a separate resource. When the string is embedded in a code resource, the Resource Manager calls the <CODE>RecoverHandle</CODE> function with an invalid master pointer. Here is an example of the correct way to call <CODE>OpenResFile</CODE>:<A NAME=MARKER-2-164></A><A NAME=MARKER-2-165></A><P>
<pre>fileName := 'This file';<BR>myRef := OpenResFile(StringPtr(StripAddress(@fileName))^);</pre><P>
</UL>
 In virtually all other cases, you don't need to call <CODE>StripAddress</CODE> before using a <BR>valid 24-bit address. In particular, you don't need to call <CODE>StripAddress</CODE> before dereferencing a pointer or handle in 24-bit mode, unless you subsequently switch <BR>to 32-bit mode by calling <CODE>SwapMMUMode</CODE>. Also, you don't need to call <CODE>StripAddress</CODE> when checking pointers and handles for equality or when performing address arithmetic.<P>
 Because you need to call <CODE>StripAddress</CODE> rarely (if ever), the additional processing time required to call <CODE>StripAddress</CODE> shouldn't adversely affect the execution of your software. In some cases, however, you might want to avoid the overhead of calling the trap dispatcher every time you need to call <CODE>StripAddress</CODE>. (A good example might be a time-critical loop in an interrupt task.) You can use the <CODE>QuickStrip</CODE> function defined in <A HREF=#MARKER-9-166>Listing 4-8</A> in place of <CODE>StripAddress</CODE> when speed is a real concern.<P>
<B>Listing 4-8  <A NAME=MARKER-9-166></A>Stripping addresses in time-critical code</B><P>
<PRE>
FUNCTION QuickStrip (thePtr: Ptr): Ptr;
BEGIN
   QuickStrip := Ptr(BAND(LongInt(thePtr), gStripAddressMask));
END;
</PRE>
 The <CODE>QuickStrip</CODE> function defined in <A HREF=#MARKER-9-166>Listing 4-8</A> simply masks the address it is passed with the same mask <CODE>StripAddress</CODE> uses. You can calculate that mask by executing the lines of code in <A HREF=#MARKER-9-167>Listing 4-9</A> early in the execution of your software:<P>
<B>Listing 4-9  <A NAME=MARKER-9-167></A>Calculating the <CODE>StripAddress</CODE> mask</B><P>
<PRE>
VAR
   gStripAddressMask:   LongInt;    {global mask variable}

   gStripAddressMask := $FFFFFFFF;
   gStripAddressMask :=
                  LongInt(StripAddress(Ptr(gStripAddressMask)));
</PRE>
 Unless you are calling <CODE>StripAddress</CODE> repeatedly at interrupt time, you probably don't need to use this technique.<A NAME=MARKER-2-168></A><A NAME=MARKER-2-169></A><A NAME=MARKER-2-170></A><P>
<A NAME=HEADING181-91></A>
<H2><A NAME=MARKER-9-171></A>Translating Memory Addresses</H2>
 <A NAME=MARKER-2-177></A><A NAME=MARKER-2-173></A>As explained earlier in <A HREF=Memory-180.html#MARKER-9-60>"Address Translation" on page 4-8</A>, you sometimes need to override the Operating System's standard translation of 24-bit addresses into their 32-bit equivalents. This is necessary because the Virtual Memory Manager might have programmed the MMU to map unused NuBus slot addresses into the address space reserved for RAM. If you try to use a 24-bit address when the system switches to 32-bit mode, the standard translation might result in a 32-bit address that points to the space reserved for expansion cards. In that case, you are virtually guaranteed to obtain <BR>invalid results.<P>
 To prevent this problem, you can use the <CODE>Translate24To32</CODE> function to get the <BR>32-bit equivalent of a 24-bit address. In general, you should test for the presence of <BR>the <CODE>_Translate24To32</CODE> trap before you use any 24-bit addresses in 32-bit mode. <BR>If it is available, you should use it in place of the static translation process performed automatically by the Operating System while running in 32-bit mode.<P>
<DL>
<DT><B>Note</B>
<DD>You need to use the <CODE>Translate24To32</CODE> function only when the computer is running in 32-bit mode, it was booted in 24-bit mode, and you are communicating with external hardware. Most applications do not need to use it.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
 <A HREF=#MARKER-9-174>Listing 4-10</A> illustrates how to use <CODE>Translate24To32</CODE>. The <CODE>DoRoutine</CODE> procedure defined there calls the application-defined routine <CODE>MyRoutine</CODE> to process a block of <BR>data while in 32-bit mode. It checks whether the <CODE>_Translate24To32</CODE> trap is available, and if so, makes sure that the address to be read is a valid 32-bit address.<P>
<B>Listing 4-10  <A NAME=MARKER-9-174></A>Translating 24-bit to 32-bit addresses</B><P>
<PRE>
PROCEDURE DoRoutine (oldAddr: Ptr; length: LongInt);
BEGIN
   IF TrapAvailable(_Translate24To32) THEN
      MyRoutine(Translate24To32(oldAddr), length);
   ELSE
      MyRoutine(oldAddr, length);
END;
</PRE>
 Note that you don't need to call <CODE>StripAddress</CODE> before calling <CODE>Translate24To32</CODE>, because the <CODE>Translate24To32</CODE> function automatically ignores the high-order byte of the 24-bit address you pass it. (For a definition of the <CODE>TrapAvailable</CODE> function, see the chapter "Gestalt Manager" in <I><A HREF="../OSUtilities/OSUtilities-2.html">Inside Macintosh: Operating System Utilities</A></I>.)<A NAME=MARKER-2-175></A><A NAME=MARKER-2-176></A><A NAME=MARKER-2-177></A><P>

</BLOCKQUOTE>
<HR>
<center>
<A HREF="Memory-180.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Memory-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Memory-202.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="Memory-182.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="Memory-3.html">&copy; Apple Computer, Inc.</A><br>3 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>  
