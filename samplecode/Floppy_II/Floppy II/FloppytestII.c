#include	<Events.h>#include	<Devices.h>#include	<Memory.h>#include	<Types.h>#include	<StdIO.h>#include	<TextUtils.h>#define kHandleBased		0x0040	#define UnitToRef(unitNo)		( -(unitNo) - 1 )#define LMGetUnitNtryCnt() (* (short *) 0x1D2) typedef struct{	short		drvrFlags;		/* dReadEnable, etc */	short		drvrDelay;		/* for periodic actions via SystemTask */	short		drvrEMask;		/* for desk acc only */	short		drvrMenu;		/* for desk acc only */	short		drvrOpen;		/* offset to open routine */	short		drvrPrime;		/* offset to prime routine */	short		drvrCtl;		/* offset to control routine */	short		drvrStatus;		/* offset to status routine */	short		drvrClose;		/* offset to close routine */	unsigned char drvrName[];	/* Pascal string */} DriverHeader;typedef struct{	long		diskCapInBlocks;	char		numSides;	char		numSectors;	short		numTracks;} formatblock;short FindDriverByName( void *pString ){	short			refNo;	Byte			oldDriverFlags;	DCtlHandle		driverInfo;	DriverHeader	*driverPtr, **driverHandle;	short			unitNumber;	short			numEntriesInTable;		numEntriesInTable = LMGetUnitNtryCnt();		for ( unitNumber=0; unitNumber<numEntriesInTable; unitNumber++ ) {		refNo = UnitToRef(unitNumber);		driverInfo = GetDCtlEntry(refNo);		if (driverInfo) {			if ((**driverInfo).dCtlFlags & kHandleBased ) {				driverHandle = (void *)(**driverInfo).dCtlDriver;				if (!driverHandle || !(*driverHandle))					continue;									oldDriverFlags = HGetState((Handle) driverHandle);				HLock((Handle)driverHandle);								if (EqualString(pString, (**driverHandle).drvrName, false, true)) {					HSetState((Handle)driverHandle, oldDriverFlags);					return(refNo);					}								HSetState((Handle)driverHandle, oldDriverFlags);				}				else {				driverPtr = (void*)(**driverInfo).dCtlDriver;				if ( !driverPtr ) 					continue;									if ( EqualString( pString, driverPtr->drvrName, false, true ) )					return( refNo );				}			}		}		return(0);}void main(){	ParmBlkPtr		pBlockPtr;	OSErr			err;	short			refNum;	formatblock		formatList[40];	short			i;	Boolean			Cap, TSSData, numSide, numSec, numTrak, SD;	long			address;		refNum = FindDriverByName("\p.Sony");		pBlockPtr = (ParmBlkPtr) NewPtrClear (sizeof (ParamBlockRec));	if (MemError() != noErr)		Debugger();			pBlockPtr->cntrlParam.ioCompletion = nil;	pBlockPtr->cntrlParam.ioResult = 0;	pBlockPtr->cntrlParam.ioVRefNum = 1;	pBlockPtr->cntrlParam.ioCRefNum = refNum;	pBlockPtr->cntrlParam.csCode = 6;	pBlockPtr->cntrlParam.csParam[0] = 5;	address = &formatList;	pBlockPtr->cntrlParam.csParam[1] = (address >> 16);	pBlockPtr->cntrlParam.csParam[2] = &formatList;		err = PBStatus (pBlockPtr, false);	if (err != noErr)		DebugStr("\perror in PBStatus");			for (i = 0; i <= pBlockPtr->cntrlParam.csParam[0]; ++i) {		Cap = (formatList[i].diskCapInBlocks == 1440);		TSSData = ((formatList[i].numSides & 0x80) >> 4);		SD = ((formatList[i].numSides & 0x10) == 0);		numSide = ((formatList[i].numSides & 0xF) == 2);		numSec = (formatList[i].numSectors == 9);		numTrak = (formatList[i].numTracks == 80);				if (Cap && TSSData && SD && numSide && numSec && numTrak) {			printf ("the index I want is %i\n", i);			break;			}		if (i == pBlockPtr->cntrlParam.csParam[0])			printf ("No Such Drive Format at index %i\n", i++);		}			DisposPtr ((Ptr) pBlockPtr);		if (i <= pBlockPtr->cntrlParam.csParam[0]) {				pBlockPtr = (ParmBlkPtr) NewPtrClear (sizeof (ParamBlockRec));		if (MemError() != noErr)			Debugger();		pBlockPtr->cntrlParam.ioCompletion = nil;		pBlockPtr->cntrlParam.ioResult = 0;		pBlockPtr->cntrlParam.ioVRefNum = 1;		pBlockPtr->cntrlParam.ioCRefNum = refNum;		pBlockPtr->cntrlParam.csCode = 6;		pBlockPtr->cntrlParam.csParam[0] = i;			err = PBControl (pBlockPtr, false);		if (err != noErr)			DebugStr("\perror in PBControl");				DisposPtr ((Ptr) pBlockPtr);		}	return;}