/*************************************************************************************##		utils.c##		This segment handles file parsing, and basic utility functions.##		Author(s): 	Michael Marinkovich & Guillermo Ortiz#					marink@apple.com##		Modification History: ##			4/3/96		MWM 	Initial coding					 ##		Copyright © 1992-96 Apple Computer, Inc., All Rights Reserved###		You may incorporate this sample code into your applications without#		restriction, though the sample code has been provided "AS IS" and the#		responsibility for its operation is 100% yours.  However, what you are#		not permitted to do is to redistribute the source as "DSC Sample Code"#		after having made changes. If you're going to re-distribute the source,#		we require that you make it clear in the source that the code was#		descended from Apple Sample Code, but that you've made changes.#*************************************************************************************/#include <Events.h>#include <ToolUtils.h>#include <Gestalt.h>#include <OSUtils.h>#include <StandardFile.h>#include "App.h"#include "Proto.h"//----------------------------------------------------------------------////	DoOpenNew - query user for new file of type 'PICT'. Open it and //				display in a new window.////----------------------------------------------------------------------void DoOpenNew(void){	OSErr					err;	PicHandle				pict;	StandardFileReply		reply;	SFTypeList		 		typeList;	WindowRef				window;	Rect					bounds;	Rect					screenRect;	short					numTypes;	DocHnd					doc;	numTypes = 2;	typeList[0] = 'PICT';	typeList[1] = 'JPEG';		StandardGetFile(nil, numTypes, (unsigned long *)&typeList, &reply);	if ( reply.sfGood )	{		if (reply.sfType == 'JPEG')		{			SetRect(&bounds, 3, GetMBarHeight() + kTitleBarHeight + 3, 200, 300);			window = CreateWindow(nil, nil, &bounds, reply.sfFile.name, false,								  zoomDocProc, kDocKind, (WindowPtr)-1, true, nil );					if (window != nil) 			{				doc = (DocHnd)GetWRefCon(window);				if (doc != nil)				{					HLock((Handle)doc);					err = ReadJPEG(reply.sfFile, &(**doc).world);					if ((**doc).world != nil && err == noErr) 					{						SetPort(window);						InvalRect(&window->portRect);						AdjustScrollbars(window,true);					}						else					{						RemoveWindow(window);						HandleError(err, false);					}					HUnlock((Handle)doc);				}			}			}							else		{				pict = ReadFile(reply.sfFile);			if (pict != nil) 			{				bounds = (**pict).picFrame;				ZeroRect(&bounds);				OffsetRect(&bounds, 3, GetMBarHeight() + kTitleBarHeight + 3);				bounds.right += kScrollWidth;				bounds.bottom += kScrollWidth;				screenRect = qd.screenBits.bounds;				if (bounds.right > screenRect.right) 					bounds.right = screenRect.right;				if (bounds.bottom > screenRect.bottom) 					bounds.bottom = screenRect.bottom;					window = CreateWindow(nil, nil, &bounds, reply.sfFile.name, false,									  zoomDocProc, kDocKind, (WindowPtr)-1, true, nil );					if (window != nil) 				{					doc = (DocHnd)GetWRefCon(window);					if (doc != nil)					{						HLock((Handle)doc);						(**doc).world = PictToWorld(pict, &err);						if ((**doc).world == nil || err != noErr) 						{							KillPicture(pict);							RemoveWindow(window);							HandleError(err, false);						}						else						{							AdjustScrollbars(window,true);						}						HUnlock((Handle)doc);					}									}				if (pict != nil)					KillPicture(pict);			}		}							  	}	}//----------------------------------------------------------------------////	ReadFile - open and read disk data, returning PICT.//				////----------------------------------------------------------------------PicHandle ReadFile(FSSpec spec){	OSErr					err;	PicHandle				pict;	long					pictSize;	long					fileSize;	short					refNum;	SetCursor(*GetCursor(watchCursor));			// set the cursor to a watch while busy		err = FSpOpenDF( &spec, fsRdWrShPerm, &refNum );	if ( err == noErr ) {		err = GetEOF( refNum, &fileSize );		if ( err == noErr ) {			err = SetFPos(refNum, fsFromMark, 512);   // set position to our picture data			if ( err == noErr ) {				pictSize = fileSize - 512;				pict = (PicHandle)NewHandle(pictSize);				err = MemError();				if ( err == noErr && pict != nil ) {					HLock((Handle) pict);					err = FSRead(refNum, &pictSize, *pict);		// read in the pict data					HUnlock((Handle) pict);				}			}		}			FSClose( refNum );			// close the file		SetCursor( &qd.arrow );		// set cursor back to arrow	}		if (err != noErr)		pict = nil;		return pict;}	//----------------------------------------------------------------------////	ZeroRect - zero the top-left points of a rect//				////----------------------------------------------------------------------void ZeroRect(Rect *r){	Rect		zr;		zr = *r;		if (zr.left < 0)		OffsetRect(&zr,zr.left,0);	if (zr.top < 0)		OffsetRect(&zr,0,zr.top);		OffsetRect(&zr,-zr.left,-zr.top);		*r = zr;} //----------------------------------------------------------------------////	pstrcpy - pascal string copy//				////----------------------------------------------------------------------void pstrcpy(StringPtr dst, StringPtr src){	short	c;		for (c = *src; c > -1; c--)		dst[c] = src[c];}//----------------------------------------------------------------------////	pstrcat - pascal string concat//				////----------------------------------------------------------------------void pstrcat(StringPtr dst, StringPtr src){		short	c;	for (c = 1; c < src[0] + 1; c++)		dst[dst[0] + c] = src[c];	dst[0] += src[0];}