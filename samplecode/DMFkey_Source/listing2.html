<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>DMFkey Source - /RequestVideo.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxGraphicsImaging-date.html">Graphics & Imaging</a> &gt; <A HREF="javascript:location.replace('index.html');">DMFkey Source</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/GraphicsImaging/index.html" target="_blank">Reference Library > Graphics & Imaging</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">DMFkey Source</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/RequestVideo.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/DMFkey.c</option>
<option value="listing2.html">/RequestVideo.c</option>
<option value="listing3.html">/RequestVideo.h</option></select>
				</p>
				</form>
				<p><strong><a href="DMFkey_Source.zip">Download Sample</a></strong> (&#147;DMFkey_Source.zip&#148;, 20.4K)<BR>
<strong><a href="DMFkey_Source.dmg">Download Sample</a></strong> (&#147;DMFkey_Source.dmg&#148;, 81.8K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*  File:    RequestVideo.c    Description:RequestVideo demonstrates the usage of the Display Manager        introduced  with the PowerMacs and integrated into the system        under System 7.5. With  the RequestVideo sample code library,         developers will be able to explore the Display Manager API by        changing bit depth and screen resolution on  multisync displays        on built-in, NuBus, and PCI based video. Display Manager 1.0        is built into the Systems included with the first PowerMacs up        through System 7.5.  Display Manager 2.0 is included with the         release of the new PCI based PowerMacs, and will be included        in post 7.5 System Software releases.                   It is a good idea to reset the screen(s) to the original setting         before exit since the call to RVSetVideoAsScreenPrefs() may not        do the right thing under Display Manager 1.0 with certain video         drivers.          For information on the use of this sample code, please the         documentation in the Read Me file  Author:    EWA  Copyright:   Copyright: &copy; 1995-1999 by Apple Computer, Inc.        all rights reserved.    Disclaimer:  You may incorporate this sample code into your applications without        restriction, though the sample code has been provided &quot;AS IS&quot; and the        responsibility for its operation is 100% yours.  However, what you are        not permitted to do is to redistribute the source as &quot;DSC Sample Code&quot;        after having made changes. If you're going to re-distribute the source,        we require that you make it clear in the source that the code was        descended from Apple Sample Code, but that you've made changes.    Change History (most recent first):        6/24/99  Updated for Metrowerks Codewarror Pro 2.1(KG)        5/31/95  Added RVGetCurrentVideoSetting and RVConfirmVideoRequest routines            to make it easy to revert back to where you came from and to give            the user a chance to confirm the new setting if the new mode was            valid (ie: the card supports it) but not safe (the monitor may not).            (EWA)        5/24/95  Give the kAllValidModesBit requestFlags option for safe only or all            valid resolution timings.(EWA)*/#include &quot;RequestVideo.h&quot;// Internal includes#include &lt;Dialogs.h&gt;#include &lt;ROMDefs.h&gt;#include &lt;Devices.h&gt;#include &lt;Errors.h&gt;#include &lt;Gestalt.h&gt;#include &lt;Memory.h&gt;#include &lt;Palettes.h&gt;#include &lt;Slots.h&gt;#include &lt;StdIO.h&gt;#include &lt;Displays.h&gt;#include &lt;stdlib.h&gt;//--------------------------------------------------------------//// Internal defines, structs, typedefs, and routine declarations////--------------------------------------------------------------#define    KMonoDev      0            // false (handy definitions for gdDevType settings)#define    kColorDev      1            // true#define    char_Enter      0x03          // for our filter proc#define    char_Return      0x0D          //#define    iRevertItem      1            // User buttons#define    iConfirmItem    2            //#define    kSecondsToConfirm  8            // seconds before confirm dialog is taken down#define    rConfirmSwtchAlrt  2735          // ID of alert dialogstruct DepthInfo {  VDSwitchInfoRec      depthSwitchInfo;      // This is the switch mode to choose this timing/depth  VPBlock          depthVPBlock;        // VPBlock (including size, depth and format)};typedef struct DepthInfo DepthInfo;struct ListIteratorDataRec {  VDTimingInfoRec      displayModeTimingInfo;    // Contains timing flags and such  unsigned long      depthBlockCount;      // How many depths available for a particular timing  DepthInfo        *depthBlocks;        // Array of DepthInfo};typedef struct ListIteratorDataRec ListIteratorDataRec;void GetRequestTheDM1Way (    VideoRequestRecPtr requestRecPtr,                GDHandle walkDevice);void GetRequestTheDM2Way (    VideoRequestRecPtr requestRecPtr,                GDHandle walkDevice,                DMDisplayModeListIteratorUPP myModeIteratorProc,                DMListIndexType theDisplayModeCount,                DMListType *theDisplayModeList);pascal void ModeListIterator (  void *userData,                DMListIndexType itemIndex,                DMDisplayModeListEntryPtr displaymodeInfo);Boolean FindBestMatch (      VideoRequestRecPtr requestRecPtr,                short bitDepth,                unsigned long horizontal,                unsigned long vertical);void GravitateMonitors (void);pascal Boolean ConfirmAlertFilter (DialogPtr dlg, EventRecord *evt, short *itemHit);//--------------------------------------------------------------//// Implementation of sample code////--------------------------------------------------------------OSErr RVSetVideoRequest (VideoRequestRecPtr requestRecPtr){  GDHandle    aMonitor;  Boolean      displayMgrPresent;  unsigned long  displayMgrVersion;  OSErr      err;  Boolean      isColor;  long      value = 0;  Gestalt(gestaltDisplayMgrVers, (long*)&amp;displayMgrVersion);  Gestalt(gestaltDisplayMgrAttr,&amp;value);  displayMgrPresent=value&amp;(1&lt;&lt;gestaltDisplayMgrPresent);  if (displayMgrPresent)  {    if (requestRecPtr-&gt;displayMode &amp;&amp; requestRecPtr-&gt;depthMode)    {      if (requestRecPtr-&gt;availBitDepth == 1)  // Based on avail bit depth,         isColor = KMonoDev;          // set the device to a mono device, or      else isColor = kColorDev;        // set the device to a color device      SetDeviceAttribute(requestRecPtr-&gt;screenDevice,gdDevType,isColor);                // see how many monitors we have, aMonitor will be nil if we have only one.      aMonitor = DMGetFirstScreenDevice (dmOnlyActiveDisplays);      // get the first guy      aMonitor = DMGetNextScreenDevice ( aMonitor, dmOnlyActiveDisplays );  // get the next guy            if (nil == aMonitor || displayMgrVersion &gt;= 0x00020000)      {        // only call DMSetDisplayMode if we have one monitor or DM2.0 is installed        // since DM1.0 does not automatically gravitate monitors and our gravitate code        // is not implemented.        err = DMSetDisplayMode(  requestRecPtr-&gt;screenDevice,  // GDevice            requestRecPtr-&gt;displayMode,            // DM1.0 uses this            &amp;requestRecPtr-&gt;depthMode,            // DM1.0 uses this            (unsigned long) &amp;(requestRecPtr-&gt;switchInfo),  // DM2.0 uses this rather than displayMode/depthMode combo            nil);        if (noErr == err)        {          // Do the monitor gravitate here if we are using a version less than DM2.0          if (displayMgrVersion &lt; 0x00020000)            GravitateMonitors ();        }        else if (kDMDriverNotDisplayMgrAwareErr == err)        {          // DM not supported by driver, so all we can do is set the bit depth          err = SetDepth (requestRecPtr-&gt;screenDevice, requestRecPtr-&gt;depthMode, gdDevType, isColor);        }      }      else      {        // we have more than one monitor and DM1.0 is installed, so all we can do is set the bit depth        err = SetDepth (requestRecPtr-&gt;screenDevice, requestRecPtr-&gt;depthMode, gdDevType, isColor);      }            return (err);  // we did try to set the request    }  }  return (-1);  // return a generic error}// This extern should be removed once this function is formally defined in Displays.hextern pascal OSErr DMUseScreenPrefs(Boolean usePrefs, Handle displayState) THREEWORDINLINE(0x303C, 0x03EC, 0xABEB);OSErr RVSetVideoAsScreenPrefs (void){  Handle    displaystate;  Boolean    displayMgrPresent;  long    value = 0;  Gestalt(gestaltDisplayMgrAttr,&amp;value);  displayMgrPresent=value&amp;(1&lt;&lt;gestaltDisplayMgrPresent);  if (displayMgrPresent)  {    DMBeginConfigureDisplays (&amp;displaystate);  // Tell the world it is about to change    DMUseScreenPrefs (true, displaystate);    // Make the change    DMEndConfigureDisplays (displaystate);    // Tell the world the change is over        return (noErr);  // we (maybe) set the world back to a known setting  }  return (-1);  // return a generic error}OSErr RVGetCurrentVideoSetting (VideoRequestRecPtr requestRecPtr){  unsigned long    displayMgrVersion;  OSErr        error = paramErr;  CntrlParam      pBlock;  VDSwitchInfoRec    switchInfo;  AuxDCEHandle    theDCE;  VDSwitchInfoRec    videoMode;      requestRecPtr-&gt;availBitDepth      = 0;  // init to default - you can do it if it is important to you  requestRecPtr-&gt;availHorizontal      = 0;  requestRecPtr-&gt;availVertical      = 0;  requestRecPtr-&gt;availFlags        = 0;  requestRecPtr-&gt;displayMode        = -1;   requestRecPtr-&gt;depthMode        = -1;  requestRecPtr-&gt;switchInfo.csMode    = 0;  requestRecPtr-&gt;switchInfo.csData    = 0;  requestRecPtr-&gt;switchInfo.csPage    = 0;  requestRecPtr-&gt;switchInfo.csBaseAddr  = 0;  requestRecPtr-&gt;switchInfo.csReserved  = 0;    Gestalt(gestaltDisplayMgrVers, (long*)&amp;displayMgrVersion);  if (requestRecPtr-&gt;screenDevice)  {    if (displayMgrVersion &gt;= 0x00020000)    {  // get the info the DM 2.0 way      error = DMGetDisplayMode(requestRecPtr-&gt;screenDevice, &amp;switchInfo);      if (noErr == error)      {        requestRecPtr-&gt;depthMode      = switchInfo.csMode;        requestRecPtr-&gt;displayMode      = switchInfo.csData;         requestRecPtr-&gt;switchInfo.csMode  = switchInfo.csMode;        requestRecPtr-&gt;switchInfo.csData  = switchInfo.csData;      }      return (error);  // we (maybe) set the world back to a known setting    }    else    {  // get the info the DM 1.0 way      videoMode.csMode = -1;    // init to bogus value      videoMode.csData = -1;    // init to bogus value            pBlock.ioNamePtr = nil;      pBlock.ioCRefNum = (*(requestRecPtr-&gt;screenDevice))-&gt;gdRefNum;      pBlock.csCode = cscGetCurMode;      *(Ptr *)&amp;pBlock.csParam[0] = (Ptr)&amp;videoMode;              error = PBStatusSync((ParmBlkPtr )&amp;pBlock);  // ask the driver first....since we trust it the most              if ( noErr == error &amp;&amp; ((-1 == videoMode.csMode) || (-1 == videoMode.csData)) )        error = statusErr;            if (noErr != error)  // if the driver has no clue fill it videoMode by hand as a last resort      {          theDCE = (AuxDCEHandle)GetDCtlEntry((*(requestRecPtr-&gt;screenDevice))-&gt;gdRefNum);                if( theDCE )        {          videoMode.csData = (unsigned char)(*theDCE)-&gt;dCtlSlotId;           videoMode.csMode = (*(requestRecPtr-&gt;screenDevice))-&gt;gdMode;          error = noErr;        }      }      if (noErr == error)  // Set our data      {        requestRecPtr-&gt;displayMode      = videoMode.csData;         requestRecPtr-&gt;depthMode      = videoMode.csMode;        requestRecPtr-&gt;switchInfo.csMode  = videoMode.csMode;        requestRecPtr-&gt;switchInfo.csData  = videoMode.csData;      }      return (error);  // we (maybe) set the world back to a known setting    }  }  return (-1);}pascal Boolean ConfirmAlertFilter(DialogPtr theDialog, EventRecord *theEvent, short *itemHit){  char charCode;  Boolean enterORreturn;  Boolean returnValue = false;  if (0 == GetWRefCon(theDialog))    SetWRefCon (theDialog,TickCount());  else  {    if (GetWRefCon(theDialog) + kSecondsToConfirm * 60 &lt; TickCount())    {      returnValue = true;      theEvent-&gt;what = nullEvent;      *itemHit = 1;    }    else    {      if (theEvent-&gt;what == keyDown)      {        charCode = (char)theEvent-&gt;message &amp; charCodeMask;        enterORreturn = (charCode == (char)char_Return) || (charCode == (char)char_Enter);        if (enterORreturn)        {          theEvent-&gt;what = nullEvent;          returnValue = true;          *itemHit = iRevertItem;          if (enterORreturn &amp;&amp; (0 != (theEvent-&gt;modifiers &amp; optionKey)))          {            *itemHit = iConfirmItem;          }        }      }    }  }  return (returnValue);}OSErr RVConfirmVideoRequest (VideoRequestRecPtr requestRecPtr){  short      alertReturn;    // Alert() return value  ModalFilterUPP  confirmFilterUPP;  // got to have us one of them new fangled UPP thingies    if (requestRecPtr-&gt;availFlags &amp; 1&lt;&lt;kModeValidNotSafeBit)  {  // new mode is valid but not safe, so ask user to confirm    SetCursor(&amp;qd.arrow);                    // have to show the arrow    confirmFilterUPP = NewModalFilterProc (ConfirmAlertFilter);  // create a new modal filter proc UPP    alertReturn = Alert(rConfirmSwtchAlrt, confirmFilterUPP);  // alert the user    DisposeRoutineDescriptor (confirmFilterUPP);        // of course there is no DisposeModalFilterProc...        if (alertReturn != iConfirmItem)      return (-1);              // tell the caller to switch back to a known setting    else return (noErr);            // all is well with the new setting, just leave it  }  return (noErr);                  // the mode was safe, so do nothing}OSErr RVRequestVideoSetting (VideoRequestRecPtr requestRecPtr){  Boolean              displayMgrPresent;  short              iCount = 0;          // just a counter of GDevices we have seen  DMDisplayModeListIteratorUPP  myModeIteratorProc = nil;  // for DM2.0 searches  SpBlock              spBlock;  Boolean              suppliedGDevice;    DisplayIDType          theDisplayID;        // for DM2.0 searches  DMListIndexType          theDisplayModeCount;    // for DM2.0 searches  DMListType            theDisplayModeList;      // for DM2.0 searches  long              value = 0;  GDHandle            walkDevice = nil;      // for everybody  Gestalt(gestaltDisplayMgrAttr,&amp;value);  displayMgrPresent=value&amp;(1&lt;&lt;gestaltDisplayMgrPresent);  displayMgrPresent=displayMgrPresent &amp;&amp; (SVersion(&amp;spBlock)==noErr);  // need slot manager  if (displayMgrPresent)  {    // init the needed data before we start    if (requestRecPtr-&gt;screenDevice)              // user wants a specifc device?    {      walkDevice = requestRecPtr-&gt;screenDevice;      suppliedGDevice = true;    }    else    {      walkDevice = DMGetFirstScreenDevice (dmOnlyActiveDisplays);      // for everybody      suppliedGDevice = false;    }        myModeIteratorProc = NewDMDisplayModeListIteratorProc(ModeListIterator);  // for DM2.0 searches      // Note that we are hosed if somebody changes the gdevice list behind our backs while we are iterating....    // ...now do the loop if we can start    if( walkDevice &amp;&amp; myModeIteratorProc) do // start the search    {      iCount++;    // GDevice we are looking at (just a counter)      if( noErr == DMGetDisplayIDByGDevice( walkDevice, &amp;theDisplayID, false ) )  // DM1.0 does not need this, but it fits in the loop      {        theDisplayModeCount = 0;  // for DM2.0 searches        if (noErr == DMNewDisplayModeList(theDisplayID, 0, 0, &amp;theDisplayModeCount, &amp;theDisplayModeList) )        {          // search NuBus &amp; PCI the new kool way through Display Manager 2.0          GetRequestTheDM2Way (requestRecPtr, walkDevice, myModeIteratorProc, theDisplayModeCount, &amp;theDisplayModeList);          DMDisposeList(theDisplayModeList);  // now toss the lists for this gdevice and go on to the next one        }        else        {          // search NuBus only the old disgusting way through the slot manager          GetRequestTheDM1Way (requestRecPtr, walkDevice);        }      }    } while ( !suppliedGDevice &amp;&amp; nil != (walkDevice = DMGetNextScreenDevice ( walkDevice, dmOnlyActiveDisplays )) );  // go until no more gdevices    if( myModeIteratorProc )      DisposeRoutineDescriptor(myModeIteratorProc);    return (noErr);  // we were able to get the look for a match  }  return (-1);    // return a generic error}void GetRequestTheDM1Way (VideoRequestRecPtr requestRecPtr, GDHandle walkDevice){  AuxDCEHandle myAuxDCEHandle;  unsigned long  depthMode;  unsigned long  displayMode;  OSErr      error;  OSErr      errorEndOfTimings;  short      height;  short      jCount = 0;  Boolean      modeOk;  SpBlock      spAuxBlock;  SpBlock      spBlock;  unsigned long  switchFlags;  VPBlock      *vpData;  short      width;  myAuxDCEHandle = (AuxDCEHandle) GetDCtlEntry((**walkDevice).gdRefNum);    spBlock.spSlot = (**myAuxDCEHandle).dCtlSlot;  spBlock.spID = (**myAuxDCEHandle).dCtlSlotId;  spBlock.spExtDev = (**myAuxDCEHandle).dCtlExtDev;  spBlock.spHwDev = 0;                // we are going to get this pup  spBlock.spParamData = 1&lt;&lt;foneslot;          // this slot, enabled, and it better be here.  spBlock.spTBMask = 3;                // don't have constants for this yet  errorEndOfTimings = SGetSRsrc(&amp;spBlock);      // get the spDrvrHW so we know the ID of this puppy. This is important                            // since some video cards support more than one display, and the spDrvrHW                            // ID can, and will, be used to differentiate them.    if ( noErr == errorEndOfTimings )  {    // reinit the param block for the SGetTypeSRsrc loop, keep the spDrvrHW we just got    spBlock.spID = 0;                // start at zero,     spBlock.spTBMask = 2;              // 0b0010 - ignore DrvrSW - why ignore the SW side? Is it not important for video?    spBlock.spParamData = (1&lt;&lt;fall) + (1&lt;&lt;foneslot) + (1&lt;&lt;fnext);  // 0b0111 - this slot, enabled or disabled, so we even get 640x399 on Blackbird    spBlock.spCategory=catDisplay;    spBlock.spCType=typeVideo;    errorEndOfTimings = SGetTypeSRsrc(&amp;spBlock);  // but only on 7.0 systems, not a problem since we require DM1.0        // now, loop through all the timings for this GDevice    if ( noErr == errorEndOfTimings ) do    {      // now, loop through all possible depth modes for this timing mode      displayMode = (unsigned char)spBlock.spID;  // &quot;timing mode, ie:resource ref number&quot;      for (jCount = firstVidMode; jCount&lt;= sixthVidMode; jCount++)      {        depthMode = jCount;    // vid mode        error = DMCheckDisplayMode(walkDevice,displayMode,depthMode,&amp;switchFlags,0,&amp;modeOk);          // only if the mode is safe or we override it with the kAllValidModesBit request flag        if (  noErr == error &amp;&amp;            modeOk &amp;&amp;            (  switchFlags &amp; 1&lt;&lt;kNoSwitchConfirmBit ||              requestRecPtr-&gt;requestFlags &amp; 1&lt;&lt;kAllValidModesBit            )          )        {          // have a good displayMode/depthMode combo - now lets look inside          spAuxBlock = spBlock;        // don't ruin the iteration spBlock!!          spAuxBlock.spID = depthMode;    // vid mode          error=SFindStruct(&amp;spAuxBlock);    // get back a new spsPointer          if (noErr == error)          // keep going if no error\xC9          {            spAuxBlock.spID = 0x01;      // mVidParams request            error=SGetBlock (&amp;spAuxBlock);  // use the new spPointer and get back...a NewPtr'ed spResult            if (noErr == error)        // \xC9keep going if no error\xC9            {                // We have data! lets have a look              vpData = (VPBlock*)spAuxBlock.spResult;              height = vpData-&gt;vpBounds.bottom;  // left and top are usually zero              width = vpData-&gt;vpBounds.right;                            if (FindBestMatch (requestRecPtr, vpData-&gt;vpPixelSize, vpData-&gt;vpBounds.right, vpData-&gt;vpBounds.bottom))              {                requestRecPtr-&gt;screenDevice = walkDevice;                requestRecPtr-&gt;availBitDepth = vpData-&gt;vpPixelSize;                requestRecPtr-&gt;availHorizontal = vpData-&gt;vpBounds.right;                requestRecPtr-&gt;availVertical = vpData-&gt;vpBounds.bottom;                requestRecPtr-&gt;displayMode = displayMode;                requestRecPtr-&gt;depthMode = depthMode;                requestRecPtr-&gt;switchInfo.csMode = depthMode;        // fill in for completeness                requestRecPtr-&gt;switchInfo.csData = displayMode;                requestRecPtr-&gt;switchInfo.csPage = 0;                requestRecPtr-&gt;switchInfo.csBaseAddr = 0;                requestRecPtr-&gt;switchInfo.csReserved = 0;                if (switchFlags &amp; 1&lt;&lt;kNoSwitchConfirmBit)                  requestRecPtr-&gt;availFlags = 0;              // mode safe                else requestRecPtr-&gt;availFlags = 1&lt;&lt;kModeValidNotSafeBit;  // mode valid but not safe, requires user validation of mode switch              }              if (spAuxBlock.spResult) DisposePtr ((Ptr)spAuxBlock.spResult);  // toss this puppy when done            }          }        }      }      // go around again, looking for timing modes for this GDevice      spBlock.spTBMask = 2;    // ignore DrvrSW      spBlock.spParamData =  (1&lt;&lt;fall) + (1&lt;&lt;foneslot) + (1&lt;&lt;fnext);  // next resource, this slot, whether enabled or disabled      errorEndOfTimings = SGetTypeSRsrc(&amp;spBlock);  // and get the next timing mode    } while ( noErr == errorEndOfTimings );  // until the end of this GDevice  }}pascal void ModeListIterator(void *userData, DMListIndexType, DMDisplayModeListEntryPtr displaymodeInfo){  unsigned long      depthCount;  short          iCount;  ListIteratorDataRec    *myIterateData    = (ListIteratorDataRec*) userData;  DepthInfo        *myDepthInfo;    // set user data in a round about way  myIterateData-&gt;displayModeTimingInfo    = *displaymodeInfo-&gt;displayModeTimingInfo;    // now get the DMDepthInfo info into memory we own  depthCount = displaymodeInfo-&gt;displayModeDepthBlockInfo-&gt;depthBlockCount;  myDepthInfo = (DepthInfo*)NewPtrClear(depthCount * sizeof(DepthInfo));  // set the info for the caller  myIterateData-&gt;depthBlockCount = depthCount;  myIterateData-&gt;depthBlocks = myDepthInfo;  // and fill out all the entries  if (depthCount) for (iCount=0; iCount &lt; depthCount; iCount++)  {    myDepthInfo[iCount].depthSwitchInfo =       *displaymodeInfo-&gt;displayModeDepthBlockInfo-&gt;depthVPBlock[iCount].depthSwitchInfo;    myDepthInfo[iCount].depthVPBlock =       *displaymodeInfo-&gt;displayModeDepthBlockInfo-&gt;depthVPBlock[iCount].depthVPBlock;  }}void GetRequestTheDM2Way (  VideoRequestRecPtr requestRecPtr,              GDHandle walkDevice,              DMDisplayModeListIteratorUPP myModeIteratorProc,              DMListIndexType theDisplayModeCount,              DMListType *theDisplayModeList){  short          jCount;  short          kCount;  ListIteratorDataRec    searchData;  searchData.depthBlocks = nil;  // get the mode lists for this GDevice  for (jCount=0; jCount&lt;theDisplayModeCount; jCount++)    // get info on all the resolution timings  {    DMGetIndexedDisplayModeFromList(*theDisplayModeList, jCount, 0, myModeIteratorProc, &amp;searchData);        // for all the depths for this resolution timing (mode)...    if (searchData.depthBlockCount) for (kCount = 0; kCount &lt; searchData.depthBlockCount; kCount++)    {      // only if the mode is valid and is safe or we override it with the kAllValidModesBit request flag      if  (  searchData.displayModeTimingInfo.csTimingFlags &amp; 1&lt;&lt;kModeValid &amp;&amp;           (  searchData.displayModeTimingInfo.csTimingFlags &amp; 1&lt;&lt;kModeSafe ||            requestRecPtr-&gt;requestFlags &amp; 1&lt;&lt;kAllValidModesBit          )        )      {        if (FindBestMatch (  requestRecPtr,                  searchData.depthBlocks[kCount].depthVPBlock.vpPixelSize,                  searchData.depthBlocks[kCount].depthVPBlock.vpBounds.right,                  searchData.depthBlocks[kCount].depthVPBlock.vpBounds.bottom))        {          requestRecPtr-&gt;screenDevice = walkDevice;          requestRecPtr-&gt;availBitDepth = searchData.depthBlocks[kCount].depthVPBlock.vpPixelSize;          requestRecPtr-&gt;availHorizontal = searchData.depthBlocks[kCount].depthVPBlock.vpBounds.right;          requestRecPtr-&gt;availVertical = searchData.depthBlocks[kCount].depthVPBlock.vpBounds.bottom;                    // now set the important info for DM to set the display          requestRecPtr-&gt;depthMode = searchData.depthBlocks[kCount].depthSwitchInfo.csMode;          requestRecPtr-&gt;displayMode = searchData.depthBlocks[kCount].depthSwitchInfo.csData;          requestRecPtr-&gt;switchInfo = searchData.depthBlocks[kCount].depthSwitchInfo;          if (searchData.displayModeTimingInfo.csTimingFlags &amp; 1&lt;&lt;kModeSafe)            requestRecPtr-&gt;availFlags = 0;              // mode safe          else requestRecPtr-&gt;availFlags = 1&lt;&lt;kModeValidNotSafeBit;  // mode valid but not safe, requires user validation of mode switch          }      }    }      if (searchData.depthBlocks)    {      DisposePtr ((Ptr)searchData.depthBlocks);  // toss for this timing mode of this gdevice      searchData.depthBlocks = nil;        // init it just so we know    }  }}Boolean FindBestMatch (VideoRequestRecPtr requestRecPtr, short bitDepth, unsigned long horizontal, unsigned long vertical){  // ** do the big comparison **  // first time only if  (no mode yet) and  //            (bounds are greater/equal or kMaximizeRes not set) and  //            (depth is less/equal or kShallowDepth not set) and  //            (request match or kAbsoluteRequest not set)  if  (  nil == requestRecPtr-&gt;displayMode      &amp;&amp;      (  (horizontal &gt;= requestRecPtr-&gt;reqHorizontal &amp;&amp;        vertical &gt;= requestRecPtr-&gt;reqVertical)        ||                                    !(requestRecPtr-&gt;requestFlags &amp; 1&lt;&lt;kMaximizeResBit)        )      &amp;&amp;      (  bitDepth &lt;= requestRecPtr-&gt;reqBitDepth ||          !(requestRecPtr-&gt;requestFlags &amp; 1&lt;&lt;kShallowDepthBit)          )      &amp;&amp;      (  (horizontal == requestRecPtr-&gt;reqHorizontal &amp;&amp;          vertical == requestRecPtr-&gt;reqVertical &amp;&amp;        bitDepth == requestRecPtr-&gt;reqBitDepth)        ||        !(requestRecPtr-&gt;requestFlags &amp; 1&lt;&lt;kAbsoluteRequestBit)        )    )    {      // go ahead and set the new values      return (true);    }  else  // can we do better than last time?  {    // if  (kBitDepthPriority set and avail not equal req) and    //    ((depth is greater avail and depth is less/equal req) or kShallowDepth not set) and    //    (avail depth less reqested and new greater avail)    //    (request match or kAbsoluteRequest not set)    if  (  (  requestRecPtr-&gt;requestFlags &amp; 1&lt;&lt;kBitDepthPriorityBit &amp;&amp;           requestRecPtr-&gt;availBitDepth != requestRecPtr-&gt;reqBitDepth        )        &amp;&amp;        (  (  bitDepth &gt; requestRecPtr-&gt;availBitDepth &amp;&amp;            bitDepth &lt;= requestRecPtr-&gt;reqBitDepth          )          ||          !(requestRecPtr-&gt;requestFlags &amp; 1&lt;&lt;kShallowDepthBit)          )        &amp;&amp;        (  requestRecPtr-&gt;availBitDepth &lt; requestRecPtr-&gt;reqBitDepth &amp;&amp;          bitDepth &gt; requestRecPtr-&gt;availBitDepth          )        &amp;&amp;        (  (horizontal == requestRecPtr-&gt;reqHorizontal &amp;&amp;            vertical == requestRecPtr-&gt;reqVertical &amp;&amp;          bitDepth == requestRecPtr-&gt;reqBitDepth)          ||          !(requestRecPtr-&gt;requestFlags &amp; 1&lt;&lt;kAbsoluteRequestBit)          )      )    {      // go ahead and set the new values      return (true);    }    else    {      // match resolution: minimize \xC6h &amp; \xC6v      if  (  abs((requestRecPtr-&gt;reqHorizontal - horizontal)) &lt;=          abs((requestRecPtr-&gt;reqHorizontal - requestRecPtr-&gt;availHorizontal)) &amp;&amp;          abs((requestRecPtr-&gt;reqVertical - vertical)) &lt;=          abs((requestRecPtr-&gt;reqVertical - requestRecPtr-&gt;availVertical))        )      {        // now we have a smaller or equal delta        //  if (h or v greater/equal to request or kMaximizeRes not set)         if (  (horizontal &gt;= requestRecPtr-&gt;reqHorizontal &amp;&amp;            vertical &gt;= requestRecPtr-&gt;reqVertical)            ||            !(requestRecPtr-&gt;requestFlags &amp; 1&lt;&lt;kMaximizeResBit)          )        {          // if  (depth is equal or kBitDepthPriority not set) and          //    (depth is less/equal or kShallowDepth not set) and          //    ([h or v not equal] or [avail depth less reqested and new greater avail] or depth equal avail) and          //    (request match or kAbsoluteRequest not set)          if  (  (  requestRecPtr-&gt;availBitDepth == bitDepth ||                      !(requestRecPtr-&gt;requestFlags &amp; 1&lt;&lt;kBitDepthPriorityBit)              )              &amp;&amp;              (  bitDepth &lt;= requestRecPtr-&gt;reqBitDepth ||                  !(requestRecPtr-&gt;requestFlags &amp; 1&lt;&lt;kShallowDepthBit)                  )              &amp;&amp;              (  (requestRecPtr-&gt;availHorizontal != horizontal ||                requestRecPtr-&gt;availVertical != vertical)                ||                (requestRecPtr-&gt;availBitDepth &lt; requestRecPtr-&gt;reqBitDepth &amp;&amp;                bitDepth &gt; requestRecPtr-&gt;availBitDepth)                ||                (bitDepth == requestRecPtr-&gt;reqBitDepth)              )              &amp;&amp;              (  (horizontal == requestRecPtr-&gt;reqHorizontal &amp;&amp;                  vertical == requestRecPtr-&gt;reqVertical &amp;&amp;                bitDepth == requestRecPtr-&gt;reqBitDepth)                ||                !(requestRecPtr-&gt;requestFlags &amp; 1&lt;&lt;kAbsoluteRequestBit)                )            )          {            // go ahead and set the new values            return (true);          }        }      }    }  }  return (false);}void GravitateMonitors (void){  // do the magic gravitation here}</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/DMFkey_Source/listing2.html%3Fid%3DDTS10000436-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/DMFkey_Source/listing2.html%3Fid%3DDTS10000436-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/DMFkey_Source/listing2.html%3Fid%3DDTS10000436-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>