<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>Imageer - /source/fileCache.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxGraphicsImaging-date.html">Graphics & Imaging</a> &gt; <A HREF="javascript:location.replace('index.html');">Imageer</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/GraphicsImaging/index.html" target="_blank">Reference Library > Graphics & Imaging</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">Imageer</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/source/fileCache.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/source/doevent.c</option>
<option value="listing2.html">/source/eventloop.c</option>
<option value="listing3.html">/source/fileCache.c</option>
<option value="listing4.html">/source/fileIO.c</option>
<option value="listing5.html">/source/gxGraphics.c</option>
<option value="listing6.html">/source/Imageer.app.h</option>
<option value="listing7.html">/source/Imageer.protos.h</option>
<option value="listing8.html">/source/Imageer.r</option>
<option value="listing9.html">/source/imageFilter.c</option>
<option value="listing10.html">/source/menu.c</option>
<option value="listing11.html">/source/offscrnGraphics.c</option>
<option value="listing12.html">/source/PreCompiledHeaders.c</option>
<option value="listing13.html">/source/start.c</option>
<option value="listing14.html">/source/windows.c</option></select>
				</p>
				</form>
				<p><strong><a href="Imageer.zip">Download Sample</a></strong> (&#147;Imageer.zip&#148;, 161.4K)<BR>
<strong><a href="Imageer.dmg">Download Sample</a></strong> (&#147;Imageer.dmg&#148;, 243.1K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/****************************************************//*                          *//*  File:    fileCache.c              *//*                          *//*  Program:  Imageer                *//*                          *//*  By:      Jason Hodges-Harris          *//*                          *//*  Created:  12/01/95  00:00:00 AM        *//*                          *//*  Version:  1.0.0d3                *//*                          *//*  Copyright:  &copy; 1995-96 Apple Computer, Inc.,    */ /*          all rights reserved.      */    /*                          *//****************************************************//**** Macintosh Toolbox Headers *****/#ifndef __FILES__#include &lt;Files.h&gt;#endif#ifndef __FOLDERS__#include &lt;Folders.h&gt;#endif#ifndef __SCRIPT__#include &lt;Script.h&gt;#endif#ifndef __STANDARDFILE__#include &lt;StandardFile.h&gt;#endif#ifndef __STRING__#include &lt;string.h&gt;#endif#ifndef __STRINGS__#include &lt;Strings.h&gt;#endif#ifndef __TEXTUTILS__#include &lt;TextUtils.h&gt;#endif#ifndef __TYPES__#include &lt;Types.h&gt;#endif/****   Application headers and prototypes   ****/#ifndef __IMAGEERAPPHEADER__#include &quot;Imageer.app.h&quot;#endif#ifndef __IMAGEERPROTOSHEADER__#include &quot;Imageer.protos.h&quot;#endif/****  Global variables  ****/extern long   gTempFolderDirID,        gTempFileCount;extern short   gTempFolderVolRef;/****  Test to find if temporary folder exists  ****///  function tests for existence of the Temporary Folder inside the System Folder//  and creates folder if not present#pragma segment imageCacheOSErr  FindTempFolder(void){  OSErr    error = noErr;  Boolean    tempExists = false;  error = FindFolder(kOnSystemDisk, kTemporaryFolderType,             kCreateFolder,&amp;gTempFolderVolRef,             &amp;gTempFolderDirID);  if (error)    DisplayAlert (rGenWarning,rFileIOMessages,iCreateTempFldrErr);    return error;}/****  Remove image docs temporary files  ****/// Delete temp file(s) specified in boolean input parameters// used to hold Color QD cache information for undo/redo#pragma segment imageCacheOSErr  RemoveTempFile(ImageDocHndl theDocHndl, Boolean delUndoFile, Boolean delRedoFile){  OSErr    error = noErr;    HLock((Handle)theDocHndl);  if (delUndoFile)  {    error = FSpDelete(&amp;(*theDocHndl)-&gt;theTempUndoFileSpec);    (*theDocHndl)-&gt;hasUndoTemp = false;  }  if (delRedoFile)  {    error |= FSpDelete(&amp;(*theDocHndl)-&gt;theTempRedoFileSpec);    (*theDocHndl)-&gt;hasRedoTemp = false;  }  HUnlock((Handle)theDocHndl);  error = noErr;   // currently ignore error checking   if (error)    DisplayAlert (rGenWarning,rFileIOMessages,iDeleteTempFileErr);  return error;}/****  Save temporary Undo file  ****/// save cache file information from current image window prior// to image manipulation after removing previous obselete temporary file(s).#pragma segment imageCacheOSErr  SaveTempImageFile(ImageDocHndl theDocHndl, short tempFileOp){  Str255      theMenuString,          theResString;  OSErr      error = noErr;  Boolean      isRedoTempFile = false;    (*theDocHndl)-&gt;theLastAction = tempFileOp;  GetMenuItemText(GetMHandle(mEdit),iUndo,theMenuString);    GetIndString (theResString,rMenuItems,iOpRedo);  if (EqualString(theMenuString,theResString,true,true))    isRedoTempFile = true;  if (!isRedoTempFile)    RemoveTempFile(theDocHndl, true, true);  else    RemoveTempFile(theDocHndl, false, true);  switch (tempFileOp)  {    case kPixMapOp:      error = SavePixMaptoTemp(theDocHndl, isRedoTempFile);      if (error)      {        (*theDocHndl)-&gt;theUndoState = kCannotUndo;        DebugStr(&quot;\pError saving image PixMap to temp file.&quot;);      }    break;    case kColorTableOp:      error = SaveCTabtoTemp(theDocHndl, isRedoTempFile);      if (error)      {        (*theDocHndl)-&gt;theUndoState = kCannotUndo;        DebugStr(&quot;\pError saving image colorTable to temp file.&quot;);      }    break;    case kGXTransformOp:    break;  }  SetUndoItemText((*theDocHndl)-&gt;theUndoState);  return error;}/****  Load temporary file  ****/// Retrieve stored temporary file information and use to revert offscreen image to old state#pragma segment imageCacheOSErr  LoadTempImageFile(ImageDocHndl theDocHndl){  Str255      theMenuString,          theResString;  OSErr      error = noErr;  short      tempFileOpType = (*theDocHndl)-&gt;theLastAction;  Boolean      isRedoTempFile = false;    (*theDocHndl)-&gt;theLastAction = tempFileOpType;  GetMenuItemText(GetMHandle(mEdit),iUndo,theMenuString);    GetIndString (theResString,rMenuItems,iOpRedo);  if (EqualString(theMenuString,theResString,true,true))    isRedoTempFile = true;  switch (tempFileOpType)  {    case kPixMapOp:      if (!isRedoTempFile)        error = SavePixMaptoTemp(theDocHndl, true);      error |= LoadTemptoPixMap(theDocHndl, isRedoTempFile);      if (error)        DebugStr(&quot;\pError loading image PixMap from temp file.&quot;);    break;    case kColorTableOp:      if (!isRedoTempFile)        error = SaveCTabtoTemp(theDocHndl, true);      error |= LoadTemptoCTab(theDocHndl, isRedoTempFile);      if (error)        DebugStr(&quot;\pError loading image color table from temp file.&quot;);    break;    case kGXTransformOp:    break;  }  if (isRedoTempFile)    (*theDocHndl)-&gt;theUndoState = kCanUndo;  SetUndoItemText((*theDocHndl)-&gt;theUndoState);  return error;}/****  Save Pixmap Data to temporary file  ****/// Store locked down offscreen GWorld Pixmap in temp file for undo/redo operation#pragma segment imageCacheOSErr  SavePixMaptoTemp(ImageDocHndl theDocHndl, Boolean isRedoFile){  PixMapHandle  thePixMapHndl = nil;  Ptr        pixMapData;  long      width,          height,          fileSize,          diskSpace,          count;  Str63      tempFileName,          fileNumStr;  short      fileRefNum,          theVolRef;  OSErr      error = noErr;  thePixMapHndl = GetGWorldPixMap((**theDocHndl).theImageWorld);  if (PixMap32Bit(thePixMapHndl))    SaveSetMMUMode(true);  if (!LockPixels(thePixMapHndl))    error = kFailedLockPixels;  if (!error)  {    width = (**thePixMapHndl).rowBytes &amp; 0x3FFF;    height = (**theDocHndl).theImageYSize;    fileSize = width*height;    error = GetVInfo(gTempFolderVolRef, 0,&amp;theVolRef, &amp;diskSpace);    if (error)    {      DebugStr(&quot;\pCouldn't get information for Temporory folder volume.&quot;);      return kDefaultAppError;    }    // Test for adequate space on hard disk to save file information.    // Display warning dialog and return without saving data if disk is full    if (fileSize &gt; diskSpace)    {      DisplayAlert (rGenWarning,rFileIOMessages,iDiskFullErr);      return kDefaultAppError;    }    pixMapData = GetPixBaseAddr(thePixMapHndl);    if (isRedoFile)    {      (*theDocHndl)-&gt;theTempRedoFileSpec.vRefNum = gTempFolderVolRef;      (*theDocHndl)-&gt;theTempRedoFileSpec.parID = gTempFolderDirID;      (*theDocHndl)-&gt;hasRedoTemp = true;      (*theDocHndl)-&gt;theUndoState = kCanRedo;    }    else    {      (*theDocHndl)-&gt;theTempUndoFileSpec.vRefNum = gTempFolderVolRef;      (*theDocHndl)-&gt;theTempUndoFileSpec.parID = gTempFolderDirID;      (*theDocHndl)-&gt;hasUndoTemp = true;      (*theDocHndl)-&gt;theUndoState = kCanUndo;    }    // Create new temporary file name    // using an incremental number appended to filename to keep unique.    strcpy((char*)tempFileName,(char*)&quot;\pTempFile&quot;);    NumToString(gTempFileCount,fileNumStr);    gTempFileCount++;    p2cstr(tempFileName);    p2cstr(fileNumStr);    strcat((char*)tempFileName,(char *)fileNumStr);    c2pstr((char*)tempFileName);    // Save undo/redo file after first creating and opening new file.    if (!isRedoFile)    {      strcpy((char*)(*theDocHndl)-&gt;theTempUndoFileSpec.name,(char*)tempFileName);      error = FSpCreate(&amp;(*theDocHndl)-&gt;theTempUndoFileSpec,                 (OSType)AppCreator, 'Imtp', smSystemScript);      if (!error)        error = FSpOpenDF(&amp;(*theDocHndl)-&gt;theTempUndoFileSpec,fsRdWrPerm,&amp;fileRefNum);    }    else    {      strcpy((char*)(*theDocHndl)-&gt;theTempRedoFileSpec.name,(char*)tempFileName);      error = FSpCreate(&amp;(*theDocHndl)-&gt;theTempRedoFileSpec,                 (OSType)AppCreator, 'Imtp', smSystemScript);      if (!error)        error = FSpOpenDF(&amp;(*theDocHndl)-&gt;theTempRedoFileSpec,fsRdWrPerm,&amp;fileRefNum);    }    if (!error)    {      for (count = 0;count &lt; height;count++)      {        error = FSWrite(fileRefNum,&amp;width,pixMapData);        if (error)          DebugStr(&quot;\pError Writing Pixmap to Temp File.&quot;);        pixMapData+=width;      }      error = FSClose(fileRefNum);    }    UnlockPixels(thePixMapHndl);  }  SaveSetMMUMode(false);  return error;}/****  Load Pixmap Data from temp file  ****/// Retrieve temporary file. Locking down the Offscreen Pixmap,// before reading in the data directly.#pragma segment imageCacheOSErr  LoadTemptoPixMap(ImageDocHndl theDocHndl, Boolean isRedoFile){  PixMapHandle  thePixMapHndl = nil;  Ptr        pixMapData;  long      width,          height,          count;  short      fileRefNum;  OSErr      error = noErr;  thePixMapHndl = GetGWorldPixMap((**theDocHndl).theImageWorld);  if (PixMap32Bit(thePixMapHndl))    SaveSetMMUMode(true);  if (!LockPixels(thePixMapHndl))    error = kFailedLockPixels;  if (!error)  {    width = (**thePixMapHndl).rowBytes &amp; 0x3FFF;    height = (**theDocHndl).theImageYSize;    pixMapData = GetPixBaseAddr(thePixMapHndl);  // base addr of GWorld    if (isRedoFile)      error = FSpOpenDF(&amp;(*theDocHndl)-&gt;theTempRedoFileSpec,fsRdWrPerm,&amp;fileRefNum);    else      error = FSpOpenDF(&amp;(*theDocHndl)-&gt;theTempUndoFileSpec,fsRdWrPerm,&amp;fileRefNum);    if (!error)    {      for (count = 0;count &lt; height;count++)      {        FSRead(fileRefNum,&amp;width,pixMapData);        pixMapData+=width;      }      error = FSClose(fileRefNum);    }    UnlockPixels(thePixMapHndl);  }  SaveSetMMUMode(false);  return error;}/****  Save Color QuickDraw color table to temp file  ****/// For indexed Color QuickDraw images, the color table// information of the offscreen copy of the image is saved. // The Color Table's handle is locked down, size determined,// a new file created and the contents written out// with a unique name if no error is reported.#pragma segment imageCacheOSErr  SaveCTabtoTemp(ImageDocHndl theDocHndl, Boolean isRedoFile){  CTabHandle    cTabHndl;  long      fileSize,          diskSpace;  short      fileRefNum,          theVolRef;  OSErr      error = noErr;  Str63      tempFileName,          fileNumStr;    HLock((Handle)(*(*theDocHndl)-&gt;theImageWorld-&gt;portPixMap)-&gt;pmTable);  cTabHndl = (*(*theDocHndl)-&gt;theImageWorld-&gt;portPixMap)-&gt;pmTable;  fileSize = GetHandleSize((Handle)cTabHndl);  error = GetVInfo(gTempFolderVolRef, 0,&amp;theVolRef, &amp;diskSpace);  if (error)  {    DebugStr(&quot;\pCouldn't get information for Temporory folder volume.&quot;);    return kDefaultAppError;  }  if (fileSize &gt; diskSpace)  {    DisplayAlert (rGenWarning,rFileIOMessages,iDiskFullErr);    return kDefaultAppError;  }  if (isRedoFile)  {    (*theDocHndl)-&gt;theTempRedoFileSpec.vRefNum = gTempFolderVolRef;    (*theDocHndl)-&gt;theTempRedoFileSpec.parID = gTempFolderDirID;    (*theDocHndl)-&gt;hasRedoTemp = true;    (*theDocHndl)-&gt;theUndoState = kCanRedo;  }  else  {    (*theDocHndl)-&gt;theTempUndoFileSpec.vRefNum = gTempFolderVolRef;    (*theDocHndl)-&gt;theTempUndoFileSpec.parID = gTempFolderDirID;    (*theDocHndl)-&gt;hasUndoTemp = true;    (*theDocHndl)-&gt;theUndoState = kCanUndo;  }  strcpy((char*)tempFileName,(char*)&quot;\pTempFile&quot;);  NumToString(gTempFileCount,fileNumStr);  gTempFileCount++;  p2cstr(tempFileName);  p2cstr(fileNumStr);  strcat((char*)tempFileName,(char *)fileNumStr);  c2pstr((char*)tempFileName);  if (isRedoFile)  {    strcpy((char*)(*theDocHndl)-&gt;theTempRedoFileSpec.name,(char*)tempFileName);    error = FSpCreate(&amp;(*theDocHndl)-&gt;theTempRedoFileSpec,               (OSType)AppCreator, 'Imtp', smSystemScript);    if (!error)      error = FSpOpenDF(&amp;(*theDocHndl)-&gt;theTempRedoFileSpec,fsRdWrPerm,&amp;fileRefNum);    if (!error)    {      FSWrite(fileRefNum,&amp;fileSize,(*cTabHndl));      error = FSClose(fileRefNum);    }  }  else  {    strcpy((char*)(*theDocHndl)-&gt;theTempUndoFileSpec.name,(char*)tempFileName);    error = FSpCreate(&amp;(*theDocHndl)-&gt;theTempUndoFileSpec,               (OSType)AppCreator, 'Imtp', smSystemScript);    if (!error)      error = FSpOpenDF(&amp;(*theDocHndl)-&gt;theTempUndoFileSpec,fsRdWrPerm,&amp;fileRefNum);    if (!error)    {      error = FSWrite(fileRefNum,&amp;fileSize,*cTabHndl);      if (error)        DebugStr(&quot;\pError Writing Pixmap to Temp File.&quot;);      error = FSClose(fileRefNum);    }  }  HUnlock((Handle)cTabHndl);  return error;}/****  Load temporary file to Color QuickDraw color table  ****/// Load the saved color table cache file into the locked down// handle of a Color QD image's offscreen ColorTable handle// structure and force the Color Manager to recalculate the Color Table.#pragma segment imageCacheOSErr  LoadTemptoCTab(ImageDocHndl theDocHndl, Boolean isRedoFile){  CTabHandle    cTabHndl;  long      fileSize;  short      fileRefNum;  OSErr      error = noErr;    HLock((Handle)(*(*theDocHndl)-&gt;theImageWorld-&gt;portPixMap)-&gt;pmTable);  cTabHndl = (*(*theDocHndl)-&gt;theImageWorld-&gt;portPixMap)-&gt;pmTable;  fileSize = GetHandleSize((Handle)cTabHndl);  if (isRedoFile)    error = FSpOpenDF(&amp;(*theDocHndl)-&gt;theTempRedoFileSpec,fsRdWrPerm,&amp;fileRefNum);  else    error = FSpOpenDF(&amp;(*theDocHndl)-&gt;theTempUndoFileSpec,fsRdWrPerm,&amp;fileRefNum);  if (!error)  {    FSRead(fileRefNum,&amp;fileSize,(*cTabHndl));    error = FSClose(fileRefNum);  }  CTabChanged(cTabHndl);  HUnlock((Handle)cTabHndl);  return error;}</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/Imageer/listing3.html%3Fid%3DDTS10000150-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/Imageer/listing3.html%3Fid%3DDTS10000150-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/Imageer/listing3.html%3Fid%3DDTS10000150-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>