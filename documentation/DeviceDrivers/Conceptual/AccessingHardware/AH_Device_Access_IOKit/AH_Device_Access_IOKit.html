<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>Accessing Hardware From Applications: Device Access and the I/O Kit</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Device Access and the I/O Kit"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP30000378" title="Device Access and the I/O Kit"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../../HardwareDrivers/index.html#//apple_ref/doc/uid/TP30000440-TP40003576" target="_top">Hardware &amp; Drivers</a> &gt; <a href="../AH_Intro/AH_Intro.html#//apple_ref/doc/uid/TP40002714-BAJDAJDJ">Accessing Hardware From Applications</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../AH_Other_APIs/AH_Other_APIs.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../AH_Finding_Devices/AH_Finding_Devices.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP30000378-BAJDAJDJ" title="Device Access and the I/O Kit"></a><h1>Device Access and the I/O Kit</h1><p>In Mac OS X, kernel space is the protected memory partition in which the kernel resides, while user space is memory outside the kernel’s partition. Most device drivers reside in kernel space<a name="//apple_ref/doc/uid/TP30000378-DontLinkElementID_23"></a>, typically because they take primary interrupts (which requires them to live in the kernel) or because their primary client resides in the kernel (such as a device driver for an Ethernet card that resides in the kernel because the network stacks reside there).</p><p>Because only code running in the kernel can directly access hardware devices, Mac OS X provides two mechanisms that allow your application or other user-space<a name="//apple_ref/doc/uid/TP30000378-DontLinkElementID_24"></a> code to make use of kernel-resident drivers and other kernel services. These mechanisms are I/O Kit device interfaces and POSIX support, using device files.</p><p>This chapter summarizes fundamental I/O Kit concepts and terms and describes some of the actions the I/O Kit takes to support devices attached to a Mac OS X computer. Then, it introduces device interfaces and device files, describing how they work and where they fit into the I/O Kit’s layered, runtime architecture.</p>
<!-- This template is being used for both PDF and HTML. -->

    
    <h4>In this section:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="AH_Device_Access_IOKit.html#//apple_ref/doc/uid/TP30000378-CJAHIJFI">I/O Kit Summary</a>
				
			<br/>
			
        
			
			
				<a href="AH_Device_Access_IOKit.html#//apple_ref/doc/uid/TP30000378-BABBJHBI">Device Interfaces and Device Files</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP30000378-CJAHIJFI" title="I/O Kit Summary"></a><h2>I/O Kit Summary</h2><p>As the object-oriented framework for device-driver development for Mac OS X, the I/O Kit defines objects that represent the various hardware and software entities that form I/O connections in a running Mac OS X system. Using these objects, the I/O Kit models the layered, provider-client relationships between devices, drivers, and driver families. </p><p>The I/O Kit also provides services, accessible through a procedural interface, for obtaining device information and accessing devices from non-kernel code. By using this interface, you can obtain the hardware support your application needs without taking on the complexity of writing kernel-resident code.</p><p><a name="//apple_ref/doc/uid/TP30000378-DontLinkElementID_25"></a>This section first defines I/O Kit terms that describe the objects you find in a running Mac OS X system and some of the processes that act on them. Then, it summarizes the device-discovery process and how the use of device interfaces affects the layered architecture of the running system. For more in-depth coverage of the I/O Kit, see <em><a href="../../IOKitFundamentals/index.html#//apple_ref/doc/uid/TP0000011" target="_top">I/O Kit Fundamentals</a></em>.</p><a name="//apple_ref/doc/uid/TP30000378-TPXREF106" title="I/O Kit Definitions"></a><h3>I/O Kit Definitions</h3><p>The I/O Kit defines objects that represent both devices and the software that supports them. To work with device interfaces or device files, you should be familiar with the I/O Kit’s object-oriented view of the devices and software that make up a running Mac OS X system. The following list describes the I/O Kit elements, processes, and data structures you’ll encounter in the rest of this document.</p><ul class="spaceabove"><li class="li"><p>A <strong>family</strong> (or device family<a name="//apple_ref/doc/uid/TP30000378-DontLinkElementID_26"></a>) is a collection of software abstractions that are common to all devices of a particular category. Families provide functionality and services to drivers (defined next). The I/O Kit defines families for bus protocols (such as USB and FireWire), storage devices, human interface devices, and many others. For a full list of families and what types of application-based access they support, see <span class="content_text"><a href="../AH_Family_Reference/AH_Family_Reference.html#//apple_ref/doc/uid/TP30000693-BABCCBIJ">“I/O Kit Family Device-Access Support.”</a></span></p></li><li class="li"><p>A <strong>driver</strong> is an I/O Kit object that manages a specific piece of hardware. When the I/O Kit loads a driver<a name="//apple_ref/doc/uid/TP30000378-DontLinkElementID_27"></a>, it may need to load one or more families, too. Drivers are written as kernel extensions (or KEXTs) and are usually installed in the directory <code>/System/Library/Extensions</code>.</p><p>Many of a driver’s characteristics are found in its property list, a text file in XML (Extensible Markup Language)<a name="//apple_ref/doc/uid/TP30000378-DontLinkElementID_28"></a> format that describes the contents, settings, and requirements of the driver. A driver usually stores its property list (or <code>Info.plist</code> file<a name="//apple_ref/doc/uid/TP30000378-DontLinkElementID_29"></a>) in its <code>Contents</code> directory, where you can view it using the Property List Editor.</p></li><li class="li"><p>A <strong>nub</strong> is an I/O Kit object that represents a detected, controllable entity, such as a device or logical service. A nub<a name="//apple_ref/doc/uid/TP30000378-DontLinkElementID_30"></a> may represent a bus, a disk, a graphics adapter, or any number of similar entities. When it supports a specific piece of hardware, a nub can also be a driver.</p><p>A nub supports dynamic configuration by providing a connection match point between two drivers (and, by extension, between two families). A nub can also provide services to code running in user space through a device interface (defined below).</p></li><li class="li"><p>A <strong>service</strong> is an I/O Kit entity, based on a subclass of IOService, that provides certain capabilities to other I/O Kit objects. All driver and nub classes inherit from the IOService class. In the I/O Kit’s layered architecture, each layer is a client of the layer below it and a provider of services to the layer above it. A family, nub, or driver can be a service<a name="//apple_ref/doc/uid/TP30000378-DontLinkElementID_31"></a> provider to other I/O Kit objects.</p></li><li class="li"><p>A <strong>device interface</strong> is a user-space library or plug-in that provides an interface that an application can use to communicate with or control a device. A device interface communicates with its in-kernel counterpart, called a user client (defined next), to transmit commands from an application or user-space process to the in-kernel object that represents a device. A family that provides a device interface<a name="//apple_ref/doc/uid/TP30000378-DontLinkElementID_32"></a> also provides a user client to handle the kernel-side communication with the device. For information on which I/O Kit families provide the device interface–user client mechanism, see <span class="content_text"><a href="../AH_Family_Reference/AH_Family_Reference.html#//apple_ref/doc/uid/TP30000693-BABCCBIJ">“I/O Kit Family Device-Access Support.”</a></span></p></li><li class="li"><p>A <strong>user client</strong> is an in-kernel object that inherits from IOService and provides a connection between an in-kernel device driver or device nub and an application or process in user space. Some documentation uses the term “user client<a name="//apple_ref/doc/uid/TP30000378-DontLinkElementID_33"></a>” to refer to the combination of the user-space device interface and the in-kernel user client object, but for this discussion, “user client” refers to the in-kernel object alone.</p></li><li class="li"><p>The <strong>I/O Registry</strong> is a dynamic database that describes a collection of ”live” objects, each of which represents an I/O Kit entity (such as a driver, family, or nub). You can think of the I/O Registry<a name="//apple_ref/doc/uid/TP30000378-DontLinkElementID_34"></a> as a tree with a nub representing the computer’s main logic board at the root, and various device drivers and nubs as the leaves. In response to the addition or removal of hardware or other changes in the system, the I/O Registry automatically updates to reflect the current hardware configuration. (For an in-depth look at this structure, see <span class="content_text"><a href="../../IOKitFundamentals/TheRegistry/TheRegistry.html#//apple_ref/doc/uid/TP0000014" target="_top">“The I/O Registry”</a></span> in <em><a href="../../IOKitFundamentals/index.html#//apple_ref/doc/uid/TP0000011" target="_top">I/O Kit Fundamentals</a></em>.)</p><p>The developer version of Mac OS X includes I/O Registry Explorer<a name="//apple_ref/doc/uid/TP30000378-DontLinkElementID_35"></a> (located in <code>/Developer/Applications</code>), an application that allows you to examine the I/O Registry of your currently running system. There is also a command-line tool called <code><!--a-->ioreg<!--/a--></code> that<a name="//apple_ref/doc/uid/TP30000378-DontLinkElementID_36"></a> you can run in a Terminal window to display current I/O Registry information (the Terminal application is located in <code>/Applications/Utilities</code>). For more information about how to use <code><!--a-->ioreg<!--/a--></code>, type <code>man ioreg</code> in a Terminal window.</p></li><li class="li"><p>A <strong>driver personality</strong> is a dictionary of key-value pairs that specify device property values, such as family type, vendor name, or product name. A driver<a name="//apple_ref/doc/uid/TP30000378-DontLinkElementID_37"></a> is suitable for any device whose properties match one of the driver’s personalities. In its <code>Info.plist</code> file, a driver stores its personalities as values of the <code>IOKitPersonalities</code> key.</p></li><li class="li"><p><strong>Driver matching</strong> is the process the I/O Kit performs at boot time (and whenever the system’s hardware configuration changes) to find in-kernel device drivers for all devices currently attached to the system. When it finds the driver<a name="//apple_ref/doc/uid/TP30000378-DontLinkElementID_38"></a> personality that is most suitable for a particular device, the I/O Kit instantiates that personality, places a copy of its personality dictionary in the I/O Registry, and (in most cases) starts the driver.</p></li><li class="li"><p>A <strong>matching dictionary</strong> is a dictionary of key-value pairs that describe the properties of a device or other service. You create a matching dictionary<a name="//apple_ref/doc/uid/TP30000378-DontLinkElementID_39"></a> to specify the types of devices your application needs to access. The I/O Kit provides several general keys you can use in your matching dictionary and many device families define specific keys and matching protocols. During device matching (described next) the values in a matching dictionary are compared against nub properties in the I/O Registry.</p></li><li class="li"><p><strong>Device matching</strong> is the process of searching the I/O Registry for objects representing a specific device or device<a name="//apple_ref/doc/uid/TP30000378-DontLinkElementID_40"></a> type in the current system. For example, an application or other code running in Mac OS X can initiate a search for all USB storage devices. In device matching, the I/O Kit compares the keys and values in the matching dictionary an application supplies with a device nub’s properties stored in the I/O Registry.</p></li><li class="li"><p>A <strong>device file</strong> is a special file<a name="//apple_ref/doc/uid/TP30000378-DontLinkElementID_41"></a> the I/O Kit creates in the <code>/dev</code> folder for each serial and storage device it discovers. If your application needs to access such a device, you use I/O Kit functions to get the path to the device and use the POSIX<a name="//apple_ref/doc/uid/TP30000378-DontLinkElementID_42"></a> API to communicate with it.<a name="//apple_ref/doc/uid/TP30000378-DontLinkElementID_43"></a></p></li></ul><p>The I/O Kit framework <a name="//apple_ref/doc/uid/TP30000378-DontLinkElementID_44"></a>(stored on disk as <code>IOKit.framework</code> in <code>/System/Library/Frameworks</code>) contains a wide range of APIs that allow your application to work with devices. In addition to many folders that contain device-interface libraries and other user-space APIs for I/O Kit families, such as FireWire and Storage, the I/O Kit framework contains several files that define general I/O Kit APIs. These files, such as <code>IOCFPlugIn.h</code> (introduced in <span class="content_text"><a href="AH_Device_Access_IOKit.html#//apple_ref/doc/uid/TP30000378-CJAHAHFC">“Inside the Device-Interface Mechanism”</a></span>) and <code>IOKitLib.h</code> (covered in <span class="content_text"><a href="../AH_IOKitLib_API/AH_IOKitLib_API.html#//apple_ref/doc/uid/TP30000380-BAJDAJDJ">“The IOKitLib API”</a></span>), provide the foundation for kernel–user space communication. <span class="content_text"><a href="AH_Device_Access_IOKit.html#//apple_ref/doc/uid/TP30000378-CJAIEHFC">Figure 2-1</a></span> shows the location of the I/O Kit APIs as they appear on the desktop.</p><br/><div><a name="//apple_ref/doc/uid/TP30000378-CJAIEHFC" title="Figure 2-1The I/O Kit framework"></a><p><strong>Figure 2-1&nbsp;&nbsp;</strong>The I/O Kit framework</p><img src = "../art/ah_frameworks_screen.gif" alt = "The I/O Kit framework" width="644" height="338"></div><br/><p>To use any of the I/O Kit APIs, your application must link with <code>IOKit.framework</code>.</p><a name="//apple_ref/doc/uid/TP30000378-TPXREF108" title="I/O Kit Driver-Stack Building"></a><h3>I/O Kit Driver-Stack Building</h3><p><a name="//apple_ref/doc/uid/TP30000378-DontLinkElementID_45"></a>At boot time and whenever a system’s hardware configuration changes, the I/O Kit discovers new devices and instantiates and loads nub and driver objects to support them. The nubs and drivers form a stack of objects that model the dynamic client-provider relationships among the various I/O Kit entities representing the hardware and software components in an I/O connection. As an example, consider the objects the I/O Kit instantiates when it discovers a FireWire device (shown in <span class="content_text"><a href="AH_Device_Access_IOKit.html#//apple_ref/doc/uid/TP30000378-CJAIECGD">Figure 2-2</a></span>). </p><br/><div><a name="//apple_ref/doc/uid/TP30000378-CJAIECGD" title="Figure 2-2I/O Kit objects supporting a FireWire device"></a><p><strong>Figure 2-2&nbsp;&nbsp;</strong>I/O Kit objects supporting a FireWire device</p><img src = "../art/ah_fw_stack.gif" alt = "I/O Kit objects supporting a FireWire device" width="247" height="200"></div><br/><p>In this example, the IOFireWire family and the I/O Kit take the following steps:</p><ol class="ol"><li class="li"><p>The I/O Kit instantiates an IOFireWireController object for each FireWire hardware interface, such as FireWire OHCI (Open Host Controller Interface), on a Mac OS X system.</p></li><li class="li"><p>The IOFireWire family queries each device on the bus and publishes an IOFireWireDevice object for each device that responds with its bus information.</p></li><li class="li"><p>In its turn, the IOFireWireDevice object queries the device and publishes an IOFireWireUnit object for each unit directory it finds on the device.</p></li></ol><p>Although this is not shown in <span class="content_text"><a href="AH_Device_Access_IOKit.html#//apple_ref/doc/uid/TP30000378-CJAIECGD">Figure 2-2</a></span>, the I/O Kit matches drivers to particular unit types, such as SBP-2 or AV/C, which then publish nubs representing logical units.</p><p>You can also think of the driver stack as a branch in the I/O Registry tree. You can view the entities in any branch (driver stack) with I/O Registry Explorer. For example, <span class="content_text"><a href="AH_Device_Access_IOKit.html#//apple_ref/doc/uid/TP30000378-CJAIGBEH">Figure 2-3</a></span> shows the I/O Registry Explorer view of part of the driver stack shown in <span class="content_text"><a href="AH_Device_Access_IOKit.html#//apple_ref/doc/uid/TP30000378-CJAIECGD">Figure 2-2</a></span>, beginning with the IOFireWireDevice object. Note that <span class="content_text"><a href="AH_Device_Access_IOKit.html#//apple_ref/doc/uid/TP30000378-CJAIGBEH">Figure 2-3</a></span> also shows the IOFireWireAVCUnit object representing the logical AV/C unit.</p><br/><div><a name="//apple_ref/doc/uid/TP30000378-CJAIGBEH" title="Figure 2-3I/O Kit objects supporting a FireWire device in I/O Registry Explorer"></a><p><strong>Figure 2-3&nbsp;&nbsp;</strong>I/O Kit objects supporting a FireWire device in I/O Registry Explorer</p><img src = "../art/ah_fw_unit_ioreg.gif" alt = "I/O Kit objects supporting a FireWire device in I/O Registry Explorer" width="585" height="350"></div><br/><p>Notice the driver personality information (or, for a nub, the property table information) that the I/O Registry Explorer displays for the currently selected element. This information can help you choose key-value pairs to use for driver matching (for more information on the driver-matching process, see <span class="content_text"><a href="../AH_Finding_Devices/AH_Finding_Devices.html#//apple_ref/doc/uid/TP30000379-BAJDAJDJ">“Finding and Accessing Devices”</a></span>). For example, you might choose to look up devices with a specific vendor ID or GUID (globally unique ID), both of which are properties of a FireWire unit, as shown in <span class="content_text"><a href="AH_Device_Access_IOKit.html#//apple_ref/doc/uid/TP30000378-CJAIGBEH">Figure 2-3</a></span>.</p><p>When you use a device interface<a name="//apple_ref/doc/uid/TP30000378-DontLinkElementID_46"></a> to communicate with a device, a user client<a name="//apple_ref/doc/uid/TP30000378-DontLinkElementID_47"></a> object joins the driver stack. A family that provides a device interface also provides the user client object that transmits an application’s commands from the device interface to the device. When your application requests a device interface for a particular device, the device’s family instantiates the appropriate user client object, typically attaching it in the I/O Registry as a client of the device nub.</p><p>Revisiting the example of the FireWire device shown in <span class="content_text"><a href="AH_Device_Access_IOKit.html#//apple_ref/doc/uid/TP30000378-CJAIECGD">Figure 2-2</a></span>, the acquisition of the IOFireWireDeviceInterface that the IOFireWire family provides results in the stack shown in <span class="content_text"><a href="AH_Device_Access_IOKit.html#//apple_ref/doc/uid/TP30000378-CJABAEIF">Figure 2-4</a></span>.</p><br/><div><a name="//apple_ref/doc/uid/TP30000378-CJABAEIF" title="Figure 2-4Adding a device interface to the FireWire driver stack"></a><p><strong>Figure 2-4&nbsp;&nbsp;</strong>Adding a device interface to the FireWire driver stack</p><img src = "../art/ah_fw_interface_stack.gif" alt = "Adding a device interface to the FireWire driver stack" width="247" height="271"></div><br/><p>When the I/O Kit discovers a serial or storage device, it builds a stack of drivers and nubs similar to those shown in <span class="content_text"><a href="AH_Device_Access_IOKit.html#//apple_ref/doc/uid/TP30000378-CJAIECGD">Figure 2-2</a></span> for the FireWire device. In addition, however, the I/O Kit automatically creates a device file<a name="//apple_ref/doc/uid/TP30000378-DontLinkElementID_48"></a> in the <code>/dev</code> directory, even if there is no current request for user-space access to the device. <span class="content_text"><a href="AH_Device_Access_IOKit.html#//apple_ref/doc/uid/TP30000378-TPXREF110">Figure 2-5</a></span> shows the driver stack for a serial device.</p><br/><div><a name="//apple_ref/doc/uid/TP30000378-TPXREF110" title="Figure 2-5I/O Kit objects supporting a serial device"></a><p><strong>Figure 2-5&nbsp;&nbsp;</strong>I/O Kit objects supporting a serial device</p><img src = "../art/ah_serial_stack.gif" alt = "I/O Kit objects supporting a serial device" width="247" height="304"></div><br/><p>As with the FireWire device objects shown in <span class="content_text"><a href="AH_Device_Access_IOKit.html#//apple_ref/doc/uid/TP30000378-CJAIGBEH">Figure 2-3</a></span>, you can use the I/O Registry Explorer application to view the objects supporting a serial device, as <span class="content_text"><a href="AH_Device_Access_IOKit.html#//apple_ref/doc/uid/TP30000378-CJADJDJB">Figure 2-6</a></span> shows.</p><br/><div><a name="//apple_ref/doc/uid/TP30000378-CJADJDJB" title="Figure 2-6I/O Kit objects supporting a serial device in I/O Registry Explorer"></a><p><strong>Figure 2-6&nbsp;&nbsp;</strong>I/O Kit objects supporting a serial device in I/O Registry Explorer</p><img src = "../art/ah_serial_bsd_client_ioreg.gif" alt = "I/O Kit objects supporting a serial device in I/O Registry Explorer" width="549" height="366"></div><br/><a name="//apple_ref/doc/uid/TP30000378-BABBJHBI" title="Device Interfaces and Device Files"></a><h2>Device Interfaces and Device Files</h2><p><a name="//apple_ref/doc/uid/TP30000378-DontLinkElementID_49"></a><a name="//apple_ref/doc/uid/TP30000378-DontLinkElementID_50"></a>This section takes a closer look at the two main gateways to user-space device access, device interfaces and device files. The information in this section provides a conceptual overview of these mechanisms and does not constitute a step-by-step guide for using them. If you’re more interested in finding out how to use device interfaces or device files in your application, you can skip ahead to <span class="content_text"><a href="../AH_Finding_Devices/AH_Finding_Devices.html#//apple_ref/doc/uid/TP30000379-BAJDAJDJ">“Finding and Accessing Devices.”</a></span></p><p>This section concludes with a brief description of how the I/O Kit uses Mach ports to allow user-space processes to communicate with the kernel.</p><a name="//apple_ref/doc/uid/TP30000378-CJAHAHFC" title="Inside the Device-Interface Mechanism"></a><h3>Inside the Device-Interface Mechanism</h3><p>Accessing hardware in Mac OS X with a device interface is similar in concept to using the Device Manager in previous versions of the Mac OS. Instead of calling Device Manager functions such as <code>OpenDriver</code>, <code>CloseDriver</code>, and <code>Control</code>, however, you call functions from the I/O Kit to obtain a device interface, then call functions the device interface defines, such as <code>open</code>, <code>close</code>, and <code>getInquiryData</code>.</p><p>A <strong>device interface</strong> is a plug-in interface that conforms to the Core Foundation plug-in model<a name="//apple_ref/doc/uid/TP30000378-DontLinkElementID_51"></a> (described in Core Foundation developer documentation, available in the <span class="content_text"><a href="../../../../../referencelibrary/CoreFoundation/index.html#//apple_ref/doc/uid/TP30000943-TP30000421" target="_top">Core Foundation Reference Library</a></span>). As such, it is compatible with the basics of Microsoft’s COM (Component Object Model<a name="//apple_ref/doc/uid/TP30000378-DontLinkElementID_52"></a>) architecture. In practice, the only elements a device interface shares with COM are the layout of the interface itself (which conforms to the COM guidelines) and its inheritance from the COM-compatible <code>IUnknown</code> interface.</p><p>Following the Core Foundation plug-in model, an I/O Kit family that provides a device interface first defines a type that represents the collection of interfaces it supports. Then, it defines each interface, declaring the functions the interface implements. The type and the interfaces each receive a UUID (universal unique identifier<a name="//apple_ref/doc/uid/TP30000378-DontLinkElementID_53"></a>, or ID), a 128-bit value that uniquely and permanently identifies it. The family makes these UUIDs available as a predefined name your application uses when it requests a device interface. For example, the IOFireWire family defines its version 5 FireWire device interface UUID as <code>kIOFireWireDeviceInterfaceID_v5</code>, which is much easier to use than the UUID string itself, <code>127A12F6-C69F-11D6-9D11-0003938BEB0A</code>.</p><p>Before an application can get a specific, family-defined device interface, it first gets an instance of an intermediate plug-in of type IOCFPlugInInterface<a name="//apple_ref/doc/uid/TP30000378-DontLinkElementID_54"></a>. Defined in <code>IOCFPlugIn.h</code> (in the I/O Kit framework), the IOCFPlugInInterface structure begins with the <code><!--a-->IUNKNOWN_C_GUTS<!--/a--></code> macro, defined in <code>CFPlugInCOM.h</code> (in the Core Foundation framework). This macro expands into the structure definition of the COM <code>IUnknown</code> interface. This means that an instance of the IOCFPlugInInterface begins with the <code>IUnknown</code> interface functions, required for all interfaces based on the Core Foundation plug-in model, shown in <span class="content_text"><a href="AH_Device_Access_IOKit.html#//apple_ref/doc/uid/TP30000378-CJADAHGB">Figure 2-7</a></span>.</p><br/><div><a name="//apple_ref/doc/uid/TP30000378-CJADAHGB" title="Figure 2-7The IOCFPlugInInterface functions"></a><p><strong>Figure 2-7&nbsp;&nbsp;</strong>The IOCFPlugInInterface functions</p><img src = "../art/acchardware_iokit_003.gif" alt = "The IOCFPlugInInterface functions" width="210" height="96"></div><br/><p>The <code><!--a-->AddRef<!--/a--></code> and <code><!--a-->Release<!--/a--></code> functions operate on the reference<a name="//apple_ref/doc/uid/TP30000378-DontLinkElementID_55"></a> counts of the IOCFPlugInInterface object and the <code><!--a-->QueryInterface<!--/a--></code><a name="//apple_ref/doc/uid/TP30000378-DontLinkElementID_56"></a> function<a name="//apple_ref/doc/uid/TP30000378-DontLinkElementID_57"></a> creates new instances of the passed-in interface type, such as a device interface an I/O Kit family defines.</p><p>The <code>IOCFPlugIn.h</code> file also defines the function <code><!--a-->IOCreatePlugInInterfaceForService<!--/a--></code><a name="//apple_ref/doc/uid/TP30000378-DontLinkElementID_58"></a><a name="//apple_ref/doc/uid/TP30000378-DontLinkElementID_59"></a>, which creates a new IOCFPlugInInterface object, and <code><!--a-->IODestroyPlugInInterface<!--/a--></code><a name="//apple_ref/doc/uid/TP30000378-DontLinkElementID_60"></a><a name="//apple_ref/doc/uid/TP30000378-DontLinkElementID_61"></a>, which destroys the specified IOCFPlugInInterface object.</p><p>After your application gets the IOCFPlugInInterface object, it then calls its <code><!--a-->QueryInterface<!--/a--></code> function, supplying it with (among other arguments) the family-defined UUID name of the particular device interface the application needs. The <code><!--a-->QueryInterface<!--/a--></code> function returns an instance of the requested device interface and the application then has access to all the functions the device interface provides. For example, the USB family’s device interface for USB devices provides the functions shown in <span class="content_text"><a href="AH_Device_Access_IOKit.html#//apple_ref/doc/uid/TP30000378-CJAHDIJB">Figure 2-8</a></span>.</p><br/><div><a name="//apple_ref/doc/uid/TP30000378-CJAHDIJB" title="Figure 2-8Some of the IOUSBDeviceInterface functions"></a><p><strong>Figure 2-8&nbsp;&nbsp;</strong>Some of the IOUSBDeviceInterface functions</p><img src = "../art/ah_dev_interface_fcns.gif" alt = "Some of the IOUSBDeviceInterface functions" width="219" height="193"></div><br/><p>As shown in <span class="content_text"><a href="AH_Device_Access_IOKit.html#//apple_ref/doc/uid/TP30000378-CJAHDIJB">Figure 2-8</a></span>, the family-defined device interface also begins with the <code><!--a-->AddRef<!--/a--></code>, <code><!--a-->Release<!--/a--></code>, and <code><!--a-->QueryInterface<!--/a--></code> functions. This is because the family’s device interface, like the IOCFPlugInInterface, fulfills the COM requirement that all interfaces must inherit from the <code>IUnknown</code> interface. Your application will probably never need to use these three functions from within the device interface, however, because most family-defined device interfaces provide their own accessor and reference-counting functions.</p><p>An application that has acquired a device interface for a device can act as a user-space driver for that device. For example, an application can drive a scanner that complies with the SCSI Architecture Model specifications because Apple does not supply an in-kernel driver for such a device. See the documentation for the family of the device you want to access for more information.<a name="//apple_ref/doc/uid/TP30000378-DontLinkElementID_62"></a></p><a name="//apple_ref/doc/uid/TP30000378-TPXREF102" title="Inside the Device-File Mechanism"></a><h3>Inside the Device-File Mechanism</h3><p><a name="//apple_ref/doc/uid/TP30000378-DontLinkElementID_63"></a><a name="//apple_ref/doc/uid/TP30000378-DontLinkElementID_64"></a>Darwin, the Mac OS X kernel, implements a version of 4.4BSD, a UNIX-based operating system that serves as the basis for the file systems and networking facilities of Mac OS X. In addition, Darwin’s implementation of BSD includes much of the POSIX<a name="//apple_ref/doc/uid/TP30000378-DontLinkElementID_65"></a> API. Darwin exports programmatic interfaces consistent with the POSIX API to application space that allow applications to communicate with serial, storage, and network devices through device files.</p><p><a name="//apple_ref/doc/uid/TP30000378-DontLinkElementID_66"></a>In a UNIX file system, an I/O <a name="//apple_ref/doc/uid/TP30000378-DontLinkElementID_67"></a><strong>device file</strong> is a special file that represents a block or character device such as a terminal, disk drive, printer, scanner, or tape drive. In essence, the device file acts as a buffer or stream of data for the device. Historically, device files reside in the <code>/dev</code> directory and have standard names, such as <code>mt0</code> for the first magnetic tape device, <code>tty0</code> for the first terminal, and so on. Because a UNIX system treats a device file like any other disk file, you can use UNIX commands with device files to perform input and output operations on devices. When you send data to a device file, the kernel intercepts it and redirects it to the device. Similarly, when a process reads from a device file, the kernel gets the data from the device and passes it to the application.</p><p>As it does with other devices, when the I/O Kit discovers a serial or storage device, it builds up a driver stack to support it. In addition, it instantiates a BSD user-client object that creates a device file node in the<code> /dev</code> directory. The BSD user-client object acts as a conduit between a client accessing a device through a device file and the in-kernel objects representing the device. For a serial device, the I/O Kit instantiates an IOSerialBSDClient object and for a storage device, the I/O Kit instantiates an IOMediaBSDClient object.</p><p>When an application needs to access a serial or storage device for which it does not already have the device-file path, it can use I/O Kit functions to find a matching device in the I/O Registry. The application can then examine the object’s properties to get its device-file path name. The properties you use to create the pathname string vary somewhat depending on whether you’re accessing a serial or storage device; for more details, see <span class="content_text"><a href="../AH_Finding_Devices/AH_Finding_Devices.html#//apple_ref/doc/uid/TP30000379-BAJDAJDJ">“Finding and Accessing Devices.”</a></span></p><p>In <span class="content_text"><a href="AH_Device_Access_IOKit.html#//apple_ref/doc/uid/TP30000378-CJAJCIHE">Figure 2-9</a></span>, the I/O Registry Explorer application displays the properties of the IOSerialBSDClient for a modem.</p><br/><div><a name="//apple_ref/doc/uid/TP30000378-CJAJCIHE" title="Figure 2-9An IOSerialBSDClient object in I/O Registry Explorer"></a><p><strong>Figure 2-9&nbsp;&nbsp;</strong>An IOSerialBSDClient object in I/O Registry Explorer</p><img src = "../art/ah_serial_bsd_client_ioreg.gif" alt = "An IOSerialBSDClient object in I/O Registry Explorer" width="549" height="366"></div><br/><p>Because of the dynamic and parallel nature of a Mac OS X system, a device may receive a different device-file name every time the I/O Kit discovers it. For this reason, you must search the I/O Registry for the device you’re interested in to get the current device-file path before you attempt to access the device instead of hard-coding a device-file name, such as <code>/dev/cu.modem</code> or <code>/dev/rdisk0</code>, in your application. When you have the correct path to the device (including the device-file name), you then use either POSIX<a name="//apple_ref/doc/uid/TP30000378-DontLinkElementID_68"></a> functions, such as<a name="//apple_ref/doc/uid/TP30000378-DontLinkElementID_69"></a><code><!--a-->open<!--/a--></code> and<a name="//apple_ref/doc/uid/TP30000378-DontLinkElementID_70"></a><code><!--a-->close<!--/a--></code>, to communicate with a storage device or the POSIX <code><!--a-->termios<!--/a--></code> API for traditional UNIX serial port access to a serial device. For serial devices, data is also routed through PPP via the device file.</p><p>For information on the POSIX standard, see <span class="content_text"><a href="http://standards.ieee.org" target="_blank">http://standards.ieee.org</a></span>. For a POSIX programming reference, see <em>POSIX Programmer’s Guide: Writing Portable Unix Programs with the POSIX</em> by Donald A. Lewine.<a name="//apple_ref/doc/uid/TP30000378-DontLinkElementID_71"></a><a name="//apple_ref/doc/uid/TP30000378-DontLinkElementID_72"></a></p><p>If<a name="//apple_ref/doc/uid/TP30000378-DontLinkElementID_73"></a> your application needs to access a network connection, it does so using a particular IP address and standard socket functions. The I/O Kit builds up stacks of objects to support networking devices that are similar to the driver stacks for other devices. Because your application is concerned with accessing a connection instead of a device object, however, finding these objects in the I/O Registry is unnecessary.</p><p>Mac OS X provides networking APIs in Carbon and Cocoa that should handle most standard networking requirements for applications. You can also use the BSD sockets API to obtain network services. A recommended network programming book is <em>Unix Network Programming, Volume 1, Second Edition</em>, by W. Richard Stevens, Prentice-Hall PTR, 1998<a name="//apple_ref/doc/uid/TP30000378-DontLinkElementID_74"></a>.<a name="//apple_ref/doc/uid/TP30000378-DontLinkElementID_75"></a></p><a name="//apple_ref/doc/uid/TP30000378-TPXREF109" title="Communicating With the I/O Kit"></a><h3>Communicating With the I/O Kit</h3><p><a name="//apple_ref/doc/uid/TP30000378-DontLinkElementID_76"></a>Whether your application uses device interfaces or device files to access devices, it must communicate with the I/O Kit. The I/O Kit API (in the I/O Kit framework) includes functions to search the I/O Registry for specific devices or groups of devices, to access I/O Kit objects, and to access device and driver personality properties published in the I/O Registry. When an application uses these functions, it communicates with the I/O Kit through a Mach port<a name="//apple_ref/doc/uid/TP30000378-DontLinkElementID_77"></a>, a unidirectional communication channel between a client that requests a service and a server (in this case, the I/O Kit) that provides the service.</p><p>Darwin’s fundamental services and primitives are based on an Apple-enhanced version of Mach 3.0. Apple’s improvements allow Mach to provide object-based APIs with communication channels (such as ports), a complete set of IPC (interprocess communication) primitives, and improved portability, among other features. When an application or other user-space process communicates with the I/O Kit, it does so by using RPC (remote procedure calls) on the I/O Kit’s master port.</p><p>Specifically, your application requests the I/O Kit master port, using the I/O Kit function <code><!--a-->IOMasterPort<!--/a--></code>, before<a name="//apple_ref/doc/uid/TP30000378-DontLinkElementID_78"></a><a name="//apple_ref/doc/uid/TP30000378-DontLinkElementID_79"></a> it attempts to access any in-kernel objects, such as I/O Registry objects that represent devices. (Alternatively, it can use the convenience constant <code>kIOMasterPortDefault</code> to<a name="//apple_ref/doc/uid/TP30000378-DontLinkElementID_80"></a> access the I/O Kit master port—for more information on how to do this, see <span class="content_text"><a href="../AH_Finding_Devices/AH_Finding_Devices.html#//apple_ref/doc/uid/TP30000379-BABGAIHF">“Getting the I/O Kit Master Port.”</a></span>) </p><p>The <code><!--a-->IOMasterPort<!--/a--></code> function calls the <code><!--a-->host_get_io_master<!--/a--></code><a name="//apple_ref/doc/uid/TP30000378-DontLinkElementID_81"></a><a name="//apple_ref/doc/uid/TP30000378-DontLinkElementID_82"></a> function of <code>mach_host.c</code>, which returns a send right to the application. This means that the application has the right to use the port to access an object on the other side of the port, in this case, an I/O Kit object.</p><p>Don’t worry if you’re not knowledgeable about Mach. Except for the acquisition of the I/O Kit master port and some reference-counting issues (discussed in <span class="content_text"><a href="../AH_IOKitLib_API/AH_IOKitLib_API.html#//apple_ref/doc/uid/TP30000380-BABCCDHF">“Object Reference-Counting and Introspection”</a></span>), Darwin’s Mach-based infrastructure is seldom exposed when using the I/O Kit to access hardware. If you’re interested in learning more about how Darwin uses Mach, however, see <em><a href="../../../../Darwin/Conceptual/KernelProgramming/index.html#//apple_ref/doc/uid/TP30000905" target="_top">Kernel Programming Guide</a></em> for a good introduction.<a name="//apple_ref/doc/uid/TP30000378-DontLinkElementID_83"></a></p>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../AH_Other_APIs/AH_Other_APIs.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../AH_Finding_Devices/AH_Finding_Devices.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2001, 2007 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2007-02-08<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/DeviceDrivers/Conceptual/AccessingHardware/AH_Device_Access_IOKit/AH_Device_Access_IOKit.html%3Fid%3DTP30000376-2.10&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/DeviceDrivers/Conceptual/AccessingHardware/AH_Device_Access_IOKit/AH_Device_Access_IOKit.html%3Fid%3DTP30000376-2.10&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/DeviceDrivers/Conceptual/AccessingHardware/AH_Device_Access_IOKit/AH_Device_Access_IOKit.html%3Fid%3DTP30000376-2.10&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>