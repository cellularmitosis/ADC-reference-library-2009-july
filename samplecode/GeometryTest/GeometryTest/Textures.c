// routines to allow us to put texture maps on a parameterized group#include <QuickDraw.h>#include "QD3D.h"#include "QD3DGroup.h"#include "QD3DShader.h"#include "PictRead.h"		// this is a library file from QD3D applications folder#include "Textures.h"TQ3Status AddTextureToGroup( TQ3GroupObject	theGroup, TQ3StoragePixmap *textureImage){	TQ3TextureObject	textureObject;	TQ3GroupPosition	position;	TQ3Object			firstObject;	TQ3ShaderObject 	textureShader;	textureObject = Q3PixmapTexture_New(textureImage);		if( textureObject ) {		if( Q3Object_IsType(theGroup, kQ3GroupTypeDisplay) == kQ3True) {			Q3Group_GetFirstPosition(theGroup, &position);				Q3Group_GetPositionObject(theGroup, position,	&firstObject);				if( Q3Object_IsType(firstObject, kQ3SurfaceShaderTypeTexture) == kQ3True) {				TQ3TextureObject	oldTextureObject;				TQ3StoragePixmap oldTextureImage;										Q3TextureShader_GetTexture(firstObject, &oldTextureObject);				Q3PixmapTexture_GetPixmap(oldTextureObject, &oldTextureImage);								Q3Object_Dispose(oldTextureObject);				Q3TextureShader_SetTexture(firstObject, textureObject);				Q3Object_Dispose(textureObject);			} else {				textureShader = Q3TextureShader_New(textureObject);				Q3Object_Dispose(textureObject);				//Q3Group_SetPositionObject(theGroup, position, theDocument->textureShader);				Q3Group_AddObjectBefore(theGroup, position, textureShader);				Q3Object_Dispose(textureShader);			}						Q3Object_Dispose(firstObject);		} else if( Q3Object_IsType(theGroup, kQ3DisplayGroupTypeOrdered) == kQ3True) {						Q3Group_GetFirstPositionOfType(				theGroup,				kQ3ShapeTypeShader, &position);							if( position ) {				Q3Group_GetPositionObject(theGroup, position,	&firstObject);					if( Q3Object_IsType(firstObject, kQ3SurfaceShaderTypeTexture) == kQ3True) {					TQ3TextureObject	oldTextureObject;					TQ3StoragePixmap oldTextureImage;										Q3TextureShader_GetTexture(firstObject, &oldTextureObject);					Q3PixmapTexture_GetPixmap(oldTextureObject, &oldTextureImage);										Q3Object_Dispose(oldTextureObject);					Q3TextureShader_SetTexture(firstObject, textureObject);					Q3Object_Dispose(textureObject);				} else {					textureShader = Q3TextureShader_New(textureObject);					if( textureShader ) {						Q3Object_Dispose(textureObject);						Q3Group_SetPositionObject(theGroup, position, textureShader);						Q3Object_Dispose(textureShader);					} else {						return(kQ3Failure);					}				}			} else {				textureShader = Q3TextureShader_New(textureObject);				if( textureShader ) {					Q3Object_Dispose(textureObject);					Q3Group_AddObject(theGroup, textureShader);					Q3Object_Dispose(textureShader);				} else {					return(kQ3Failure);				}			}					}		return(kQ3Success);	} else {		return(kQ3Failure);	}}TQ3Status PictureFileToPixmap( TQ3StoragePixmap *bMap ){	TQ3Status		status = kQ3Failure;	PicHandle 		thePicture = nil;		bMap->image = NULL;		thePicture = GetPICTFile();	if(thePicture != NULL ) {			if (LoadMapPICT( thePicture, 					 0L,					 (unsigned long)((**thePicture).picFrame.right  - (**thePicture).picFrame.left),					 (unsigned long)((**thePicture).picFrame.bottom - (**thePicture).picFrame.top),					 bMap) != 0) {			status = kQ3Success;		}	}	return status;}TQ3Status TextureGroup( TQ3GroupObject	theGroup){	TQ3Status			status = kQ3Failure;	TQ3StoragePixmap 	myMap;		if (PictureFileToPixmap(&myMap) == kQ3Success) {		if( myMap.image != NULL ) {			status = AddTextureToGroup( theGroup, &myMap ) ;			Q3Object_Dispose(myMap.image);			myMap.image = NULL;		}	}	return status;}