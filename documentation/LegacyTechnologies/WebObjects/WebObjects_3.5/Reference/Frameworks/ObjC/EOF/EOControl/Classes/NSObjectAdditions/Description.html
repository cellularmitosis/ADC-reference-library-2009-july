<html><head><title></title></head>

<body bgcolor="#ffffff">

 

 

<h2><a name="//apple_ref/occ/cl/NSObject">NSObject Additions</a>

 <BR>

</h2>

<p><B>Inherits From:</B><BR>  

none <em>(NSObject is a root class)

</em>

<p><B>Declared in:</B>

EOControl/EOClassDescription.h<br>

EOControl/EOEditingContext.h<br>

EOControl/EOKeyValueCoding.h<br>

EOControl/EOObserver.h



<p><h3>Class At a Glance:</h3>

<p><dl><dt><h4>Purpose</h4>

</dl>Defines basic functionality for all enterprise objects.<p>

<dl><dt><h4>Principal Attributes</h4>

</dl><li>EOClassDescription





<dl><dt><h4>Creation</h4>

</dl><dl><dt>- init

<dl><dt>Designated initializer.

</dl><dt>- initWithEditingContext:classDescription:globalID:

<dl><dt>	Optional initializer.

</dl><dt>- awakeFromFetchInEditingContext:

<dl><dt>	Additional initialization after being fetched.

</dl><dt>- awakeFromInsertionInEditingContext:

<dl><dt>	Additional initialization after being created in memory.

</dl></dl><dl><dt><h4>Commonly Used Methods</h4>

</dl><dl><dt><a href="#//apple_ref/occ/instm/NSObject/willChange">- willChange</a>

<dl><dt>	Notifies observers of a change in state.

</dl><dt><a href="#//apple_ref/occ/instm/NSObject/editingContext">- editingContext</a>

<dl><dt>	Returns the receiver's EOEditingContext.

</dl><dt><a href="#//apple_ref/occ/instm/NSObject/addObject:toPropertyWithKey:">- addObject:toPropertyWithKey:</a>

<dl><dt>	Adds an object to a relationship property.

</dl><dt><a href="#//apple_ref/occ/instm/NSObject/removeObject:fromPropertyWithKey:">- removeObject:fromPropertyWithKey:</a>

<dl><dt>	Removes an object from a relationship property.

</dl><dt><a href="#//apple_ref/occ/instm/NSObject/addObject:toBothSidesOfRelationshipWithKey:">- addObject:toBothSidesOfRelationshipWithKey:</a>

<dl><dt>	Adds an object to a relationship property and the receiver 

to the reciprocal relationship.

<dt><a href="#1289">- removeObject:fromBothSidesOfRelationshipWithKey:</a>

</dl><dt><a href="#//apple_ref/occ/instm/NSObject/"></a>

<dl><dt>Removes an object from a relationship property and the receiver from the reciprocal relationship.

</dl></dl><dl><dt><h4>Methods to Implement or Override</h4>

</dl>These methods are invoked by the Framework. <p>

<dl><dt>- set<em>Key</em>:

<dl><dt>Sets the value for the property named <em>key</em>.

</dl><dt>- <em>key</em>

<dl><dt>Retrieves the value for the property named <em>key</em>.

</dl><dt>- addTo<em>Key</em>:

<dl><dt>Adds an object to a relationship property named <em>key</em>.

</dl><dt>- removeFrom<em>Key</em>:

<dl><dt>Removes an object from the property named <em>key</em>.

</dl><dt><a href="#//apple_ref/occ/instm/NSObject/handleTakeValue:forUnboundKey:">- handleTakeValue:forUnboundKey:</a>

<dl><dt>	Handles a failure of <B><a href="#1302">takeValue:forKey:</a> </B> to find a property.

</dl><dt><a href="#//apple_ref/occ/instm/NSObject/handleQueryWithUnboundKey:">- handleQueryWithUnboundKey:</a>

<dl><dt>	Handles a failure of <B><a href="#1359">valueForKey:</a> </B> to find a property.

</dl><dt><a href="#//apple_ref/occ/instm/NSObject/unableToSetNilForKey:">- unableToSetNilForKey:</a>

<dl><dt>	Handles an attempt to set a non-object property's value to <B>nil </B>.

</dl><dt>- validate<em>Key</em>:

<dl><dt>Validates a value for the property named <em>key</em>.

</dl><dt><a href="#//apple_ref/occ/instm/NSObject/validateForDelete">- validateForDelete</a>

<dl><dt>	Validates all properties before deleting the receiver.

</dl><dt><a href="#//apple_ref/occ/instm/NSObject/validateForInsert">- validateForInsert</a>

<dl><dt>	Validates all properties before inserting the receiver.

</dl><dt><a href="#//apple_ref/occ/instm/NSObject/validateForSave">- validateForSave</a>

<dl><dt>	Validates all properties before saving the receiver.

</dl><dt><a href="#//apple_ref/occ/instm/NSObject/validateForUpdate">- validateForUpdate</a>

<dl><dt>	Validates all properties before updating the receiver.

</dl></dl><p>

<a name="1083">

<a name="description"></a>

<h3>Class Description </h3>

</a>Enterprise Objects Framework adds a number of methods to NSObject for supporting operations common to all enterprise objects. Among these are methods for initializing instances, announcing changes, setting and retrieving property values, and performing validation of state. Some of these methods are for enterprise objects to implement or override, and some are meant to be used as defined by the Framework. Many methods are used internally by the Framework and rarely invoked by application code. The implementation or use of each method is highlighted in the following sections, which describe the major functional groups.<p>

<a name="1085">

<h3> Initialization Methods</h3>

</a>Enterprise objects are initialized using the <a href="#1261"><B>initWithEditingContext:classDescription:globalID: </B></a>, which by default simply invokes <B>init </B>. You can place your custom initialization code in <B>init </B>, or you can override <a href="#1261"><B>initWithEditingContext:classDescription:globalID: </B></a> to take advantage of the extra information available with this method.<p>

After initialization, an enterprise object receives an <B>awake... </B> message. The particular message depends on whether the object has been fetched from a database or created anew in the application. In the former case, it receives an <a href="#1211"><B>awakeFromFetchInEditingContext: </B></a> message. In the latter, it receives an <a href="#1215"><B>awakeFromInsertionInEditingContext: </B></a> message. The receiver can override either method to perform extra initialization-such as setting default values-based on how it was created.<p>

<a name="1088">

<h3> Announcing Changes</h3>

</a>For the Framework to keep all areas of an application synchronized, enterprise objects must notify their observers when their state changes. Objects do this by simply invoking <a href="#1372"><B>willChange </B></a> before altering any instance variable or other kind of state. This method informs all observers that the invoker is about to change. See the EOObserverCenter class specification for more information on change notification.<p>

The primary observer of changes in an object is its EOEditingContext. EOEditingContext is a subclass of EOObjectStore that manages collections of objects in memory, tracking inserts, deletes, and updates, and propagating changes to the persistent store as needed. You can get the EOEditingContext that contains an object by sending the object an <a href="#1237"><B>editingContext </B></a> message.<p>

<a name="1091">

<h3> Getting Object and Class Metadata</h3>

</a>One of the larger groups of methods added to NSObject provides information about an object's properties. Most of these methods consult an EOClassDescription to provide their answers. The <a href="#1219"><B>classDescription </B></a> method return an object's EOClassDescription. See that class specification for the methods it implements. Methods you can send directly to any object include <a href="#1240"><B>entityName </B></a>, which provides the name of the entity mapped to the receiver's class; <a href="#1204"><B>allPropertyKeys </B></a>, which returns the names of all the receiver's class properties, attributes and relationships alike; and <a href="#1207"><B>attributeKeys </B></a>, which returns just the names of the attributes.<p>

Some methods return information about relationships. <a href="#1319"><B>toOneRelationshipKeys </B></a> and <a href="#1315"><B>toManyRelationshipKeys </B></a> return the names of the receiver's relationships, while <a href="#1275"><B>isToManyKey: </B></a> tells which kind a particular relationship is. <a href="#1231"><B>deleteRuleForRelationshipKey: </B></a> indicates what should happen to the receiver's relationships when it's deleted. Similarly, <a href="#1279"><B>ownsDestinationObjectsForRelationshipKey: </B></a> indicates what should happen when another object is added to or removed from the receiver's relationship. Another method, <a href="#1223"><B>classDescriptionForDestinationKey: </B></a>, returns the EOClassDescription for the objects at the destination of a relationship.<p>

These methods are all properly implemented in terms of the receiver's EOClassDescription, so unless your object class doesn't have an EOClassDescription, there's little need to override them. One method you might override in your enterprise object class, however, is <a href="#1265"><B>inverseForRelationshipKey: </B></a>. Given the name of one of the receiver's relationships, this method finds the destination object's class data and determines the name of the relationship that points back at the receiver. The default implementation of this method looks for a relationship predicated on the same attributes in both the source and destination, which works correctly in most cases. If, however, you define a reciprocal pair of relationships on different attributes, you should override this method to take that into account. See the method description for an example.<p>

<a name="1095">

<h3> Key-Value Coding Methods</h3>

</a>A special set of methods form the Framework's main data transport mechanism, in which the properties of an enterprise object are accessed indirectly by name (or key), rather than directly through invocation of an accessor method or as instance variables. Thus, any object's state can be accessed in a consistent manner.<p>

The basic methods for accessing an enterprise object's values are <B><a href="#1302">takeValue:forKey:</a> </B> and <B><a href="#1359">valueForKey:</a> </B>. These two methods are defined by NSObject to use the accessor methods normally implemented by objects (or to access instance variables directly if need be), so that you don't have to write special code simply to integrate your enterprise objects into the Framework. Another pair of methods, <B><a href="#1311">takeValuesFromDictionary:</a> </B> and <B><a href="#1368">valuesForKeys:</a> </B>, gives access to groups of properties. Lastly, <B><a href="#1364">valueForKeyPath:</a> </B> and <B><a href="#1364">valueForKeyPath:</a> </B> give access to properties across key paths of the form <em>relationship.property</em>; for example, "department.name".<p>

All of the <code>takeValue...</code> methods have corresponding <code>takeStoredValue...</code> methods for setting object values from object store values:<a href="#1395"> <B>takeStoredValue:forKey: </B></a>,<a href="#1394"> <B>takeStoredValue:forKeyPath: </B></a>, and<a href="#1411"> <B>takeStoredValuesFromDictionary: </B></a>. To enable them, override<a href="#1400"> <B>useStoredAccessor </B></a> to return YES. This is discussed in more detail below.<p>

<a name="1098">

<h4> Default Implementations; Handling Access Errors</h4>

</a>The Framework provides default implementations of <B><a href="#1302">takeValue:forKey:</a> </B> and <B><a href="#1359">valueForKey:</a> </B> that work for all objects. The other four access methods are implemented in terms of these two. These implementations are general enough that your enterprise object classes should rarely need to override either key-value coding method. In accessing an object's property, the default NSObject implementations of the key-value coding methods use the class definition as follows:<p>

<ol>

<a name="1100">

<li>The key-value coding method looks for an accessor method based on the key. For example, with a key of "lastName", <B><a href="#1302">takeValue:forKey:</a> </B> looks for a method named <B>setLastName: </B> (note that the first letter of the property name is made uppercase), and <B><a href="#1359">valueForKey:</a> </B> looks for a method of the form <B>lastName </B>.

</a><a name="1101">

<li>If the key-value coding method doesn't find an accessor method, and the class responds YES to an <B><a href="#1182">accessInstanceVariablesDirectly</a> </B> message (which it does by default), it looks for an instance variable whose name is the same as the key and sets or retrieves its value directly. In setting an instance variable that's an object, <B><a href="#1302">takeValue:forKey:</a> </B> retains the new value and autoreleases the old one.

</a><a name="1102">

<li>If neither an accessor method nor an instance variable can be found, the default implementations invoke methods that your custom objects can override to handle failures. <a href="#1257"><B>handleTakeValue:forUnboundKey: </B></a> is invoked from <a href="#1302"><B>takeValue:forKey: </B></a>, and <a href="#1253"><B>handleQueryWithUnboundKey: </B></a> is invoked from <a href="#1359"><B>valueForKey: </B></a>. Normally these methods raise an exception, but you can implement them to set or get a value in whatever way is needed.

</a></ol>

The Framework also provides methods for setting object values from object store values:<a href="#1395"> <B>takeStoredValue:forKey: </B></a>,<a href="#1394"> <B>takeStoredValue:forKeyPath: </B></a>, and<a href="#1411"> <B>takeStoredValuesFromDictionary: </B></a>. You cause these methods to be used instead of their <code>takeValue...</code> counterparts by overriding<a href="#1400"> <B>useStoredAccessor </B></a> to return YES. When you override<a href="#1400"> <B>useStoredAccessor </B></a> to return YES, the <code>takeStoredValue...</code> methods are used whenever an object moves from one object store to another-for example, when you instantiate objects from database data, or when you transfer objects between EOEditingContexts. In all other cases the regular <code>takeValue...</code> methods are used, such as when a user modifies an object by providing a new value for it in a user interface. To think of it another way, the <code>takeStoredValue...</code> methods let you bypass the logic in your <code>set...</code> methods, whereas the <code>takeValue...</code> methods execute that logic.<p>

The <code>takeStoredValue...</code> methods are especially useful in cases where an object has instance variables whose values are interdependent. For example, suppose you have a Product object with <code>status</code> and <code>dateOfSale</code> attributes. When the Product's <code>status</code> changes to "sold," you'd also want to set its <code>dateOfSale</code> value-in all likelihood, by invoking <code>setDateOfSale:</code> from the object's <code>setStatus:</code> method. If you were using<a href="#1302"> <B>takeValue:forKey: </B></a>, initializing a Product object from database data would have the effect of invoking the object's <code>setStatus:</code> method, which in turn would attempt to change the object's <code>dateOfSale</code> date. You can prevent this from happening from using the <code>takeStoredValue...</code> methods. <p>

When you override<a href="#1400"> <B>useStoredAccessor </B></a> to return YES and you're changing the value of an object's property, the default NSObject implementations of the key-value coding methods use the class definition as follows:<p>

<ol>

<a name="1416">

<li>The key-value coding method looks for an instance variable whose name is the same as the key, but preceded by an underbar. It then sets the instance variable's value directly. For example, with a key of "lastName",<a href="#1395"> <B>takeStoredValue:forKey: </B></a> looks for an instance variable called <code>_lastName</code>.

</a><a name="1417">

<li>If the key-value coding method doesn't find an instance variable, it looks for an accessor method based on key, preceded by an underbar. For example, with a key of "lastName",<a href="#1395"> <B>takeStoredValue:forKey: </B></a> looks for a method called <code>_setLastName.</code>

</a><a name="1418">

<li>If the key-value coding method doesn't find an underbar-preceded instance variable or accessor method, it looks for an instance variable whose name is the same as the key (<code>lastName</code>) and sets its value directly. 

</a><a name="1419">

<li>Finally, the key-value coding method looks for an accessor method based on the key. For the key "lastName", this would be <code>setLastName:</code>.

</a><a name="1420">

<li>If none of the above instance variables or accessor methods can be found, the default implementations invoke methods that your custom objects can override to handle failures. <a href="#1257"><B>handleTakeValue:forUnboundKey: </B></a> is invoked from <a href="#1302"><B>takeValue:forKey: </B></a>, and <a href="#1253"><B>handleQueryWithUnboundKey: </B></a> is invoked from <a href="#1359"><B>valueForKey: </B></a>. Normally these methods raise an exception, but you can implement them to set or get a value in whatever way is needed.

</a></ol>

The key-value coding methods cache attribute bindings for both accessor methods and instance variables, making lookups efficient. If you need to clear these bindings-as when you add or remove a class from the run-time system-you can invoke <a href="#1185"><B>flushAllKeyBindings </B></a> to do so.<p>

Some subclasses of NSObject override the default implementations. EOGenericRecord's implementations, for example, simply store and retrieve the properties in an NSDictionary object held by the EOGenericRecord. NSDictionary and NSMutableDictionary, though not suitable for use as enterprise objects, meaningfully implement these methods by directly accessing their key-value pairs.<p>

<a name="1105">

<h4> Type Checking and Type Conversion</h4>

</a>The default implementations of the key-value coding methods accept any object as a value, and do no type checking or type conversion among object classes. It's possible, for example, to pass an NSString to <B><a href="#1302">takeValue:forKey:</a> </B> as the value for a property the receiver expects to be an NSDate. The sender of a key-value coding message is thus responsible for ensuring that a values is of the proper class, typically by using the <B>validateValue:forKey: </B> method to coerce it to the proper type. The interface layer's EODisplayGroup uses this on all values received from interface user objects, for example, as well as relying on number and date formatters to interpret string values typed by the user. For more information on the <B>validateValue:forKey: </B> method, see the EOClassDescription and EOEntityClassDescription class specifications.<p>

The key-value coding methods handle one special case with regard to value types. For enterprise objects that access numeric values as C scalar types, these methods automatically convert between the scalar types and NSNumber objects. For example, suppose your enterprise object defines these accessor methods:<p>

- (void)<B>setSalary: </B>(unsigned int)<em>salary<br></em>- (unsigned int)<B>salary </B><p>For the <B>setSalary: </B> method, <B><a href="#1302">takeValue:forKey:</a> </B> converts the object value for the "salary" key in the dictionary to an <B>unsigned int </B> and passes it as <em>salary</em>. Similarly, <B><a href="#1359">valueForKey:</a> </B> converts the return value of the <B>salary </B> method to an NSNumber and returns that.<p>

The default implementations support the following scalar types:<p>

<Table Border="3">

<caption></caption>

<tr><th>char<p>

</th><th>unsigned char<p>

</th></tr>

<tr><td scope="row"><a name="2673">

short

</a></td><td><a name="2675">

unsigned short

</a></td></tr>

<tr><td scope="row"><a name="2677">

int

</a></td><td><a name="2679">

unsigned int

</a></td></tr>

<tr><td scope="row"><a name="2681">

long

</a></td><td><a name="2683">

unsigned long

</a></td></tr>

<tr><td scope="row"><a name="2685">

float

</a></td><td><a name="2687">

double

</a></td></tr>



</Table>



<Table>

<tr><td>

</Table>

<p>

Object values are converted to these types with the standard messages <B>charValue </B>, <B>intValue </B>, <B>floatValue </B>, and so on. Note that the key-value coding methods don't check that an object value actually responds to these messages; this can result in a run-time error if the object doesn't respond to the appropriate message.<p>

One type of conversion these methods can't perform is that from a <B>nil </B> object value to a scalar value. C scalar values define no equivalent of a database system's NULL value, so these must be handled by the object itself. Upon encountering an <B>nil </B> while setting a scalar value, the <a href="#1302"><B>takeValue:forKey: </B></a> invokes <a href="#1323"><B>unableToSetNilForKey: </B></a>, which by default simply raises an exception. Enterprise object classes that use scalar values which may be NULL in the database should override this method to substitute the appropriate scalar value for <B>nil </B>, reinvoking <B><a href="#1302">takeValue:forKey:</a> </B> to set the substitute value. This method works in general to handle setting scalar properties to <B>nil </B>.<p>

<a name="1114">

<h4> EONull in Collections</h4>

</a>Because collection objects such as NSArray and NSDictionary can't contain <B>nil </B> as a value, it must represented by a special object, EONull. EONull provides a single instance that represents the NULL value for object attributes. The default implementations of <B><a href="#1311">takeValuesFromDictionary:</a> </B> and <B><a href="#1368">valuesForKeys:</a> </B> translate EONull and <B>nil </B> between NSDictionaries and enterprise objects, removing the need for your objects to explicitly test for EONull values. <p>

<a name="1116">

<h3> Relationship Accessor Methods</h3>

</a>Building on the key-value coding methods, another group of methods allows you to modify relationship properties by adding and removing single objects, rather than replacing the entire content of the relationship, and to modify relationships so that reciprocal relationships are automatically adjusted. <a href="#1199"><B>addObject:toPropertyWithKey: </B></a> and <a href="#1293"><B>removeObject:fromPropertyWithKey: </B></a> handle the first situation, doing all the work of altering arrays for to-many relationships. They both check first for a method you might implement, <B>addTo </B><em>Key</em><B>: </B> or <B>removeFrom </B><em>Key</em><B>: </B>, invoking that method if it's implemented, otherwise using the basic key-value coding methods to do the work.<p>

Reciprocal relationships are handled by <a href="#1194"><B>addObject:toBothSidesOfRelationshipWithKey: </B></a> and <a href="#1289"><B>removeObject:fromBothSidesOfRelationshipWithKey: </B></a>. For example, when you add an Employee to a Department's <B>employees </B> relationship, or remove it, you also want the Employee's <B>department </B> relationship altered to suit. These two methods take care of tracing the inverse relationship and use <a href="#1199"><B>addObject:toPropertyWithKey: </B></a> and <a href="#1293"><B>removeObject:fromPropertyWithKey: </B></a> to alter both relationships, whether they're to-one or to-many. Unless you have specific reasons to do otherwise, you should always use the methods that handle reciprocal relationships so that back pointers are properly updated.<p>

Two other methods that affect relationships are typically used internally by the Framework. You should rarely have a need either to invoke or override them. <a href="#1283"><B>propagateDeleteWithEditingContext: </B></a> applies an object's delete rule to the destinations of its relationships. The delete rule specifies whether a destination object should be ignored, also deleted, or whether the deletion should be disallowed if a destination exists. <a href="#1227"><B>clearProperties </B></a> simply sets all of the receiver's relationship properties to <B>nil </B>. An EOEditingContext uses this method to break circular references between its objects when the context is deallocated.<p>

<a name="1120">

<h3> Snapshots</h3>

</a>The key-value coding methods define a general mechanism for accessing an object's properties, but you first have to know what those properties are. Sometimes, however, you just want to preserve an object's entire state for later use, whether to undo changes to the object, compare the values that have changed, or just keep a record of the changes. The snapshotting methods provide this service, extracting or setting all properties at once and performing the necessary conversions for proper behavior. <B><a href="#1298">snapshot</a> </B> returns an NSDictionary containing all the receiver's properties, with EONull substituted for <B>nil </B> and arrays reproduced as shallow, immutable copies. <B><a href="#1326">updateFromSnapshot:</a> </B> sets properties of the receiver to the values in a snapshot, converting EONull to <B>nil </B>, and making shallow, mutable copies of any array values (allowing the object to add to and remove from the array).<p>

<a name="1122">

<h3> Validation</h3>

</a>Validating new values is a vital part of business logic. Several methods added to NSObject support validation at different stages of an object's life. Validation methods check for illegal value types, values outside of established limits, illegal relationships, and so on. All validation methods return <B>nil </B> if the values under consideration are valid, or an NSException indicating how the values aren't valid.<p>

There are two kinds of validation methods that you can override. The first covers individual properties, when it's important to validate a value before it changes. These methods are invoked automatically by the Framework when it changes a property value, such as when the user makes an edit in the user interface. These methods are dynamically invoked based on the property name. The second kind covers operations to the external store-inserting, updating, and deleting. These methods are invoked when the associated operation is performed. You can override these methods in your custom enterprise object classes to perform delayed validation of properties, to compare multiple properties against one another, and to allow or refuse the operation based on property values. For example, a Fee object might refuse to be deleted if it hasn't been paid yet.<p>

<a name="1125">

<h4> Immediate Validation of Individual Properties</h4>

</a>The most general method, <a href="#1354"><B>validateValue:forKey: </B></a>, is used by the Framework when an EODisplayGroup passes an updated value to the object and when the object is saved. This method does two things: coerce the value into an appropriate type for the object, and validate it according to the object's rules. Coercion is performed automatically for you, so all you need handle is validation itself.<p>

The default implementation of <a href="#1354"><B>validateValue:forKey: </B></a> consults the object's EOClassDescription for basic errors, such as a <B>nil </B> value when that isn't allowed. If no basic errors exist, this method then examines the object's class itself for a method of the form <B>validate </B><em>Key</em><B>: </B> and invokes that. These are the methods that your custom classes can implement to validate individual properties, such as <B>validateAge: </B> to check that the value the user entered is within acceptable limits.<p>

For example, suppose that Member objects have an <B>age </B> attribute stored as an integer. This attribute has an lower limit of 16, defined by the Member class. Now, suppose the user types "12" into a text field for the age. Before the EODisplayGroup updates the selected object, it sends the object a <a href="#1354"><B>validateValue:forKey: </B></a> message. The object uses its EOEntityClassDescription to convert the string "12" into an NSNumber, then invokes <B>validateAge: </B> with that NSNumber. Member's implementation of this method compares the age to its limit of 16 and returns an EOValidationException:<p>

<blockquote><pre>- (NSException *)validateAge:(NSNumber *)age<br>{<br>    if ([age intValue] &lt; 16) {<br>        return [NSException<br>            validationExceptionWithFormat:@"Age of %@ is below minimum.", age];<br>    }<br>    return nil;<br>}

</pre></blockquote><p>

The Framework adds the <B>validationExceptionWithFormat: </B> method to NSException for convenient creation of validation exceptions. The userInfo dictionaries in the exceptions raised by these methods contain the enterprise object being validated and the key (where applicable).<p>

<a name="1131">

<h4> Validation for Specific Operations</h4>

</a>The other validation methods are invoked at specific times-such as before the object is written to or deleted from the external store-and are particularly useful when properties must be compared or when expensive calculation is necessary. The methods are <a href="#1338"><B>validateForInsert </B></a>, <a href="#1350"><B>validateForUpdate </B></a>, <a href="#1342"><B>validateForSave </B></a>, and <a href="#1330"><B>validateForDelete </B></a>, and they're invoked automatically for the operations indicated by the method name. You can override these methods to check values individually or in groups; for example, you might verify that a pair of dates is in the proper temporal order:<p>

<blockquote><pre>- (NSException *)validateForSave<br>{<br>    if ([startDate compare:endDate] == NSOrderedDescending) {<br>        return [NSException<br>            validationExceptionWithFormat:@"Start date must not follow end date."];<br>    }<br>    return [super validateForSave];<br>}

</pre></blockquote><p>

Note that this method also invokes <B>super </B>'s implementation. This is important, as the default implementations of the <B>validateFor... </B> pass the check on to the object's EOClassDescription, which performs basic checking among properties. The access layer's EOEntityClassDescription class verifies constraints based on an EOModel, such as delete rules. For example, the delete rule for a Department object might state that it can't be deleted if it still contains Employee objects.<p>

<a href="#1342"><B>validateForSave </B></a> is the generic validation method for when an object is written to the external store. The default implementations of <a href="#1338"><B>validateForInsert </B></a> and <a href="#1350"><B>validateForUpdate </B></a> both invoke this method. If an object performs validation that isn't specific to insertion or to updating, it should go in <a href="#1342"><B>validateForSave </B></a>.<p>

<dl><dt>Initializing enterprise objects

<dl><dt><a href="#//apple_ref/occ/instm/NSObject/initWithEditingContext:classDescription:globalID:">- initWithEditingContext:classDescription:globalID:</a>

<dt><a href="#//apple_ref/occ/instm/NSObject/awakeFromFetchInEditingContext:">- awakeFromFetchInEditingContext:</a>

<dt><a href="#//apple_ref/occ/instm/NSObject/awakeFromInsertionInEditingContext:">- awakeFromInsertionInEditingContext:</a>

</dl><dt>Announcing changes

<dl><dt><a href="#//apple_ref/occ/instm/NSObject/willChange">- willChange</a>

</dl><dt>Getting an object's EOEditingContext

<dl><dt><a href="#//apple_ref/occ/instm/NSObject/editingContext">- editingContext</a>

</dl><dt>Getting class description information

<dl><dt><a href="#//apple_ref/occ/instm/NSObject/allPropertyKeys">- allPropertyKeys</a>

<dt><a href="#//apple_ref/occ/instm/NSObject/attributeKeys">- attributeKeys</a>

<dt><a href="#//apple_ref/occ/instm/NSObject/classDescription">- classDescription</a>

<dt><a href="#//apple_ref/occ/instm/NSObject/classDescriptionForDestinationKey:">- classDescriptionForDestinationKey:</a>

<dt><a href="#//apple_ref/occ/instm/NSObject/deleteRuleForRelationshipKey:">- deleteRuleForRelationshipKey:</a>

<dt><a href="#//apple_ref/occ/instm/NSObject/entityName">- entityName</a>

<dt><a href="#//apple_ref/occ/instm/NSObject/inverseForRelationshipKey:">- inverseForRelationshipKey:</a>

<dt><a href="#//apple_ref/occ/instm/NSObject/isToManyKey:">- isToManyKey:</a>

<dt><a href="#//apple_ref/occ/instm/NSObject/ownsDestinationObjectsForRelationshipKey:">- ownsDestinationObjectsForRelationshipKey:</a>

<dt><a href="#//apple_ref/occ/instm/NSObject/toManyRelationshipKeys">- toManyRelationshipKeys</a>

<dt><a href="#//apple_ref/occ/instm/NSObject/toOneRelationshipKeys">- toOneRelationshipKeys</a>

</dl><dt>Key-value coding

<dl><dt><a href="#//apple_ref/occ/instm/NSObject/takeValue:forKey:">- takeValue:forKey:</a>

<dt><a href="#//apple_ref/occ/instm/NSObject/valueForKey:">- valueForKey:</a>

<dt><a href="#//apple_ref/occ/instm/NSObject/takeValuesFromDictionary:">- takeValuesFromDictionary:</a>

<dt><a href="#//apple_ref/occ/instm/NSObject/valuesForKeys:">- valuesForKeys:</a>

<dt><a href="#//apple_ref/occ/instm/NSObject/takeValue:forKeyPath:">- takeValue:forKeyPath:</a>

<dt><a href="#//apple_ref/occ/instm/NSObject/valueForKeyPath:">- valueForKeyPath:</a>

<dt><a href="#//apple_ref/occ/instm/NSObject/takeStoredValue:forKey:">- takeStoredValue:forKey:</a>

<dt><a href="#//apple_ref/occ/instm/NSObject/takeStoredValue:forKeyPath:">- takeStoredValue:forKeyPath:</a>

<dt><a href="#//apple_ref/occ/instm/NSObject/takeStoredValuesFromDictionary:">- takeStoredValuesFromDictionary:</a>

<dt><a href="#//apple_ref/occ/instm/NSObject/handleQueryWithUnboundKey:">- handleQueryWithUnboundKey:</a>

<dt><a href="#//apple_ref/occ/instm/NSObject/handleTakeValue:forUnboundKey:">- handleTakeValue:forUnboundKey:</a>

<dt><a href="#//apple_ref/occ/instm/NSObject/unableToSetNilForKey:">- unableToSetNilForKey:</a>

<dt><a href="#//apple_ref/occ/clm/NSObject/accessInstanceVariablesDirectly">+ accessInstanceVariablesDirectly</a>

<dt><a href="#//apple_ref/occ/clm/NSObject/flushClassKeyBindings">+ flushClassKeyBindings</a>

<dt><a href="#//apple_ref/occ/clm/NSObject/flushAllKeyBindings">+ flushAllKeyBindings</a>

<dt><a href="#//apple_ref/occ/clm/NSObject/useStoredAccessor">+ useStoredAccessor</a>

</dl><dt>Modifying relationships

<dl><dt><a href="#//apple_ref/occ/instm/NSObject/addObject:toPropertyWithKey:">- addObject:toPropertyWithKey:</a>

<dt><a href="#//apple_ref/occ/instm/NSObject/removeObject:fromPropertyWithKey:">- removeObject:fromPropertyWithKey:</a>

<dt><a href="#//apple_ref/occ/instm/NSObject/addObject:toBothSidesOfRelationshipWithKey:">- addObject:toBothSidesOfRelationshipWithKey:</a>

<dt><a href="#//apple_ref/occ/instm/NSObject/removeObject:fromBothSidesOfRelationshipWithKey:">- removeObject:fromBothSidesOfRelationshipWithKey:</a>

<dt><a href="#//apple_ref/occ/instm/NSObject/propagateDeleteWithEditingContext:">- propagateDeleteWithEditingContext:</a>

<dt><a href="#//apple_ref/occ/instm/NSObject/clearProperties">- clearProperties</a>

</dl><dt>Working with snapshots

<dl><dt><a href="#//apple_ref/occ/instm/NSObject/snapshot">- snapshot</a>

<dt><a href="#//apple_ref/occ/instm/NSObject/updateFromSnapshot:">- updateFromSnapshot:</a>

</dl><dt>Validating values

<dl><dt><a href="#//apple_ref/occ/instm/NSObject/validateForDelete">- validateForDelete</a>

<dt><a href="#//apple_ref/occ/instm/NSObject/validateForInsert">- validateForInsert</a>

<dt><a href="#//apple_ref/occ/instm/NSObject/validateForSave">- validateForSave</a>

<dt><a href="#//apple_ref/occ/instm/NSObject/validateForUpdate">- validateForUpdate</a>

<dt><a href="#//apple_ref/occ/instm/NSObject/validateValue:forKey:">- validateValue:forKey:</a>

</dl><dt>Getting descriptions

<dl><dt><a href="#//apple_ref/occ/instm/NSObject/eoDescription">- eoDescription</a>

<dt><a href="#//apple_ref/occ/instm/NSObject/eoShallowDescription">- eoShallowDescription</a>

<dt><a href="#//apple_ref/occ/instm/NSObject/userPresentableDescription">- userPresentableDescription</a>

</dl></dl><a name="1181">

<a name="clm"></a>

<h3>Class Methods </h3>

</a><a name="1182">

<h4> <a name="//apple_ref/occ/clm/NSObject/accessInstanceVariablesDirectly">accessInstanceVariablesDirectly</a></h4>

</a>+ (BOOL)<B>accessInstanceVariablesDirectly </B><p>

Returns YES if the default implementations of the key-value coding methods, on finding no accessor method for a property, should access the corresponding instance variable directly. Returns NO if they shouldn't. NSObject's implementation of this method returns YES. Subclasses can override it to return NO, in which case the other methods won't access instance variables.<p>

<a name="1185">

<h4> <a name="//apple_ref/occ/clm/NSObject/flushAllKeyBindings">flushAllKeyBindings</a></h4>

</a>+ (void)<B>flushAllKeyBindings </B><p>

Invalidates the cached key binding information for all classes (caches are kept of key-to-method or instance variable bindings in order to make key-value coding efficient).<p>

<B>See also: </B>  

<B><a href="#//apple_ref/occ/clm/NSObject/flushClassKeyBindings">+ flushClassKeyBindings</a>

 </B><p><a name="1189">

<h4> <a name="//apple_ref/occ/clm/NSObject/flushClassKeyBindings">flushClassKeyBindings</a></h4>

</a>+ (void)<B>flushClassKeyBindings </B><p>

Invalidates the cached key binding information for the receiving class. This method should be invoked whenever a class is modified or removed from the run-time system.<p>

<B>See also: </B>  

<B><a href="#//apple_ref/occ/clm/NSObject/flushAllKeyBindings">+ flushAllKeyBindings</a>

 </B><p><a name="1400">

<h4> <a name="//apple_ref/occ/clm/NSObject/useStoredAccessor">useStoredAccessor</a></h4>

</a>+ (BOOL)<code>useStoredAccessor</code><p>

Returns YES if the default implementations of the key-value coding methods should be accessed using the <code>takeStoredValue...</code> methods, NO otherwise. NSObject's implementation of this method returns NO. Subclasses can override it to return YES. For more discussion of this topic, see the section "<a href="#1095">Key-Value Coding Methods</a>" in the class description.<p>

<B>See also: </B>  

<B><a href="#//apple_ref/occ/instm/NSObject/takeStoredValue:forKey:">- takeStoredValue:forKey:</a> </B>, <a href="#//apple_ref/occ/instm/NSObject/takeStoredValue:forKeyPath:"><B>- takeStoredValue:forKeyPath:</a> </B>, 

<B><a href="#//apple_ref/occ/instm/NSObject/takeStoredValuesFromDictionary:">- takeStoredValuesFromDictionary:</a>

 </B><p><a name="1193">

<a name="instm"></a>

<h3>Instance Methods </h3>

</a><a name="1194">

<h4> <a name="//apple_ref/occ/instm/NSObject/addObject:toBothSidesOfRelationshipWithKey:">addObject:toBothSidesOfRelationshipWithKey:</a></h4>

</a>- (void)<B>addObject: </B>(id)<em>anObject</em> <B>toBothSidesOfRelationshipWithKey: </B>(NSString *)<em>key</em><p>

Sets or adds <em>anObject</em> as the destination for the receiver's relationship identified by <em>key</em>, and also sets or adds the receiver for <em>anObject</em>'s reciprocal relationship if there is one. For a to-one relationship, <em>anObject</em> is set using <B><a href="#1302">takeValue:forKey:</a> </B>. For a to-many relationship, <em>anObject</em> is added using <B><a href="#1199">addObject:toPropertyWithKey:</a> </B>.<p>

This method also properly handles removing <B>self </B> and <em>anObject</em> from their previous relationship as needed. For example, if an Employee object belongs to the Research department, invoking this method with the Maintenance department removes the Employee from the Research department as well as setting the Employee's department to Maintenance.<p>

<B>See also: </B>  

<B><a href="#//apple_ref/occ/instm/NSObject/removeObject:fromBothSidesOfRelationshipWithKey:">- removeObject:fromBothSidesOfRelationshipWithKey:</a>

 </B><p><a name="1199">

<h4> <a name="//apple_ref/occ/instm/NSObject/addObject:toPropertyWithKey:">addObject:toPropertyWithKey:</a></h4>

</a>- (void)<B>addObject: </B>(id)<em>anObject</em> <B>toPropertyWithKey: </B>(NSString *)<em>key</em><p>

Adds <em>anObject</em> to the receiver's to-many relationship identified by <em>key</em>, without setting any reciprocal relationship. Similar to <a href="#1302"><B>takeValue:forKey: </B></a>, this method first attempts to invoke a method of the form <B>addTo </B><em>Key</em><B>: </B>. If the receiver doesn't have such a method, this method gets the property array using <a href="#1359"><B>valueForKey: </B></a> and operates directly on that.<p>

If the array is mutable, this method simply adds <em>anObject</em> using <B>addObject: </B>. Otherwise it constructs a new array containing any existing objects and <em>anObject</em>, then sets it using <B><a href="#1302">takeValue:forKey:</a> </B>.<p>

<B>See also: </B>  

<B><a href="#//apple_ref/occ/instm/NSObject/removeObject:fromPropertyWithKey:">- removeObject:fromPropertyWithKey:</a> </B>, 

<B><a href="#//apple_ref/occ/instm/NSObject/addObject:toBothSidesOfRelationshipWithKey:">- addObject:toBothSidesOfRelationshipWithKey:</a>

 </B><p><a name="1204">

<h4> <a name="//apple_ref/occ/instm/NSObject/allPropertyKeys">allPropertyKeys</a></h4>

</a>- (NSArray *)<B>allPropertyKeys </B><p>

Returns all of the receiver's property keys, as returned by <a href="#1207"><B>attributeKeys </B></a>, <a href="#1319"><B>toOneRelationshipKeys </B></a>, and <a href="#1315"><B>toManyRelationshipKeys </B></a>.<p>

<a name="1207">

<h4> <a name="//apple_ref/occ/instm/NSObject/attributeKeys">attributeKeys</a></h4>

</a>- (NSArray *)<B>attributeKeys </B><p>

Returns the names of the receiver's attributes, as determined from the EOClassDescription. You might wish to override this method to add keys for attributes not defined by the EOClassDescription. The access layer's subclass of EOClassDescription, EOEntityClassDescription, returns the names of attributes designated as class properties.<p>

<B>See also: </B>  

<B><a href="#//apple_ref/occ/instm/NSObject/toOneRelationshipKeys">- toOneRelationshipKeys</a> </B>, <a href="#//apple_ref/occ/instm/NSObject/toManyRelationshipKeys"><B>- toManyRelationshipKeys.</a> </B>, 

<B><a href="../EOClassDescription/EOClassDescription.html#//apple_ref/occ/instm/EOClassDescription/attributeKeys" target="_top">- attributeKeys </B> (EOClassDescription)</a>

<p><a name="1211">

<h4> <a name="//apple_ref/occ/instm/NSObject/awakeFromFetchInEditingContext:">awakeFromFetchInEditingContext:</a></h4>

</a>- (void)<B>awakeFromFetchInEditingContext: </B>(EOEditingContext *)<em>anEditingContext</em><p>

Overridden by subclasses to perform additional initialization upon being fetched from the external repository into <em>anEditingContext</em>. NSObject's implementation merely sends an <B>awakeObject:fromFetchInEditingContext: </B> to the receiver's EOClassDescription. Subclasses should invoke <B>super </B>'s implementation before performing their own initialization.<p>

<B>See also: </B>  

<B><a href="#//apple_ref/occ/instm/NSObject/awakeFromInsertionInEditingContext:">- awakeFromInsertionInEditingContext:</a>

 </B><p><a name="1215">

<h4> <a name="//apple_ref/occ/instm/NSObject/awakeFromInsertionInEditingContext:">awakeFromInsertionInEditingContext:</a></h4>

</a>- (void)<B>awakeFromInsertionInEditingContext: </B>(EOEditingContext *)<em>anEditingContext</em><p>

Overridden by subclasses to perform additional initialization upon being inserted into <em>anEditingContext</em>. This is commonly used to assign default values or record the time of insertion. NSObject's implementation merely sends an <B>awakeObject:fromInsertionInEditingContext: </B> to the receiver's EOClassDescription. Subclasses should invoke <B>super </B>'s implementation before performing their own initialization.<p>

<B>See also: </B>  

<B><a href="#//apple_ref/occ/instm/NSObject/awakeFromFetchInEditingContext:">- awakeFromFetchInEditingContext:</a>

 </B><p><a name="1219">

<h4> <a name="//apple_ref/occ/instm/NSObject/classDescription">classDescription</a></h4>

</a>- (EOClassDescription *)<B>classDescription </B><p>

Returns the EOClassDescription registered for the receiver's class. If none is found, posts an EOClassDescriptionNeededNotification on behalf of the receiver's class, allowing an observer to register a an EOClassDescription. See the EOClassDescription class specification for more information.<p>

<B>See also: </B>  

<B><a href="../EOClassDescription/EOClassDescription.html#//apple_ref/occ/clm/EOClassDescription/registerClassDescription:forClass:" target="_top">+ registerClassDescription:forClass: </B> (EOClassDescription)</a>

<p><a name="1223">

<h4> <a name="//apple_ref/occ/instm/NSObject/classDescriptionForDestinationKey:">classDescriptionForDestinationKey:</a></h4>

</a>- (EOClassDescription *)<B>classDescriptionForDestinationKey: </B>(NSString *)<em>key</em><p>

Returns the EOClassDescription for the destination objects of the relationship identified by <em>key</em>. If none is found, posts an EOClassDescriptionNeededNotification on behalf of the destination objects' class, allowing an observer to register a an EOClassDescription. See the EOClassDescription class specification for more information.<p>

<B>See also: </B>  

<B><a href="../EOClassDescription/EOClassDescription.html#//apple_ref/occ/clm/EOClassDescription/registerClassDescription:forClass:" target="_top">+ registerClassDescription:forClass: </B> (EOClassDescription)</a>, 

<B><a href="#//apple_ref/occ/instm/NSObject/classDescriptionForDestinationKey:">- classDescriptionForDestinationKey:</a>

 </B><p><a name="1227">

<h4> <a name="//apple_ref/occ/instm/NSObject/clearProperties">clearProperties</a></h4>

</a>- (void)<B>clearProperties </B><p>

Sets all of the receiver's to-one and to-many relationships to <B>nil </B>. EOEditingContexts use this method to break circular references among objects when they're deallocated. You should never need to invoke this method or override it.<p>

<B>See also: </B>  

<B><a href="#//apple_ref/occ/instm/NSObject/toOneRelationshipKeys">- toOneRelationshipKeys</a> </B>, <a href="#//apple_ref/occ/instm/NSObject/toManyRelationshipKeys"><B>- toManyRelationshipKeys</a> </B>, <a href="#//apple_ref/occ/instm/NSObject/takeValue:forKey:"><B>- takeValue:forKey:</a>

 </B><p><a name="1231">

<h4> <a name="//apple_ref/occ/instm/NSObject/deleteRuleForRelationshipKey:">deleteRuleForRelationshipKey:</a></h4>

</a>- (EODeleteRule)<B>deleteRuleForRelationshipKey: </B>(NSString *)<em>relationshipKey</em><p>

Returns a rule indicating how to handle the destination of the receiver's relationship named by <em>relationshipKey</em> when the receiver is deleted. The delete rule is one of:<p>

EODeleteRuleNullify<br>EODeleteRuleCascade<br>EODeleteRuleDeny<br>EODeleteRuleNoAction<p>For example, an Invoice object might return EODeleteRuleCascade for the relationship named "lineItems", since when an invoice is deleted, its line items should be as well.<p>

<B>See also: </B>  

<B><a href="#//apple_ref/occ/instm/NSObject/propagateDeleteWithEditingContext:">- propagateDeleteWithEditingContext:</a> </B>, <a href="#//apple_ref/occ/instm/NSObject/validateForDelete"><B>- validateForDelete</a> </B>, 

<B><a href="../EOClassDescription/EOClassDescription.html#//apple_ref/occ/instm/EOClassDescription/deleteRuleForRelationshipKey:" target="_top">- deleteRuleForRelationshipKey: </B> (EOClassDescription)</a>

<p><a name="1237">

<h4> <a name="//apple_ref/occ/instm/NSObject/editingContext">editingContext</a></h4>

</a>- (EOEditingContext *)<B>editingContext </B><p>

Returns the EOEditingContext that holds the receiver.<p>

<a name="1240">

<h4> <a name="//apple_ref/occ/instm/NSObject/entityName">entityName</a></h4>

</a>- (NSString *)<B>entityName </B><p>

Returns the name of the receiver's entity, or <B>nil </B> if it doesn't have one.<p>

<B>See also: </B>  

<B><a href="../EOClassDescription/EOClassDescription.html#//apple_ref/occ/instm/EOClassDescription/entityName" target="_top">- entityName </B> (EOClassDescription)</a>

<p><a name="1244">

<h4> <a name="//apple_ref/occ/instm/NSObject/eoDescription">eoDescription</a></h4>

</a>- (NSString *)<B>eoDescription </B><p>

Returns a full description of the receiver's property values by extracting them using the key-value coding methods. An object referenced through relationships is listed with the results of an <a href="#1249"><B>eoShallowDescription </B></a> message (to avoid infinite recursion through cyclical relationships).<p>

This method is useful for debugging. You can define your enterprise object's <B>description </B> method to invoke this one, so that the debugger's print-object command (<B>po </B> on the command line) automatically displays this description. You can also invoke this method directly on the command line.<p>

<B>See also: </B>  

<B><a href="#//apple_ref/occ/instm/NSObject/eoShallowDescription">- eoShallowDescription</a> </B>, <a href="#//apple_ref/occ/instm/NSObject/userPresentableDescription"><B>- userPresentableDescription</a>

 </B><p><a name="1249">

<h4> <a name="//apple_ref/occ/instm/NSObject/eoShallowDescription">eoShallowDescription</a></h4>

</a>- (NSString *)<B>eoShallowDescription </B><p>

Returns a string containing the receiver's class and entity names, along with the memory address of its <B>id </B>.<p>

<B>See also: </B>  

<B><a href="#//apple_ref/occ/instm/NSObject/eoDescription">- eoDescription</a> </B>, <a href="#//apple_ref/occ/instm/NSObject/userPresentableDescription"><B>- userPresentableDescription</a>

 </B><p><a name="1253">

<h4> <a name="//apple_ref/occ/instm/NSObject/handleQueryWithUnboundKey:">handleQueryWithUnboundKey:</a></h4>

</a>- (id)<B>handleQueryWithUnboundKey: </B>(NSString *)<em>key</em><p>

Invoked from <B><a href="#1359">valueForKey:</a> </B> when it finds no property binding for <em>key</em>. NSObject's implementation raises an NSInvalidArgumentException. Subclasses can override it to handle the query in some other way.<p>

<B>See also: </B>  

<B><a href="#//apple_ref/occ/instm/NSObject/handleTakeValue:forUnboundKey:">- handleTakeValue:forUnboundKey:</a>

 </B><p><a name="1257">

<h4> <a name="//apple_ref/occ/instm/NSObject/handleTakeValue:forUnboundKey:">handleTakeValue:forUnboundKey:</a></h4>

</a>- (void)<B>handleTakeValue: </B>(id)<em>value</em> <B>forUnboundKey: </B>(NSString *)<em>key</em><p>

Invoked from <B><a href="#1302">takeValue:forKey:</a> </B> when it finds no property binding for <em>key</em>. NSObject's implementation raises an NSInvalidArgumentException. Subclasses can override it to handle the request in some other way.<p>

<B>See also: </B>  

<B><a href="#//apple_ref/occ/instm/NSObject/handleQueryWithUnboundKey:">- handleQueryWithUnboundKey:</a>

 </B><p><a name="1261">

<h4> <a name="//apple_ref/occ/instm/NSObject/initWithEditingContext:classDescription:globalID:">initWithEditingContext:classDescription:globalID:</a></h4>

</a>- <B>initWithEditingContext: </B>(EOEditingContext *)<em>anEditingContext<br></em><B>classDescription: </B>(EOClassDescription *)<em>aClassDescription<br></em><B>globalID: </B>(EOGlobalID *)<em>globalID</em><p>

Overridden by subclasses to perform initialization with the extra arguments provided. NSObject's implementation simply invokes <B>init </B>.<p>

<B>See also: </B>  

<B><a href="../EOClassDescription/EOClassDescription.html#//apple_ref/occ/instm/EOClassDescription/createInstanceWithEditingContext:globalID:zone:" target="_top">- createInstanceWithEditingContext:classDescription:globalID: </B> (EOClassDescription)</a>, <a href="#//apple_ref/c/func/"><B></a>

 </B><p><a name="1265">

<h4> <a name="//apple_ref/occ/instm/NSObject/inverseForRelationshipKey:">inverseForRelationshipKey:</a></h4>

</a>- (NSString *)<B>inverseForRelationshipKey: </B>(NSString *)<em>relationshipKey</em><p>

Returns the name of the relationship pointing back to the receiver's class or entity from that named by <em>relationshipKey</em>, or <B>nil </B> if there isn't one. With EOEntity and EORelationship, for example, reciprocality is determined by the join attributes of the two EORelationships.<p>

You might override this method for reciprocal relationships that aren't defined using the same join attributes. For example, if a Member object has a relationship to CreditCard based on the card number, but a CreditCard has a relationship to Member based on the Member's primary key, both classes need to override this method. This is how Member might implement it:<p>

<blockquote><pre>- (NSString *)inverseForRelationshipKey:(NSString *)relationshipKey

</pre></blockquote><p>

<blockquote><pre>{

</pre></blockquote><p>

<blockquote><pre>    if ([relationshipKey isEqual:@"creditCard"]) return @"member";

</pre></blockquote><p>

<blockquote><pre>    return [super inverseForRelationshipKey:relationshipKey];

</pre></blockquote><p>

<blockquote><pre>}

</pre></blockquote><p>

<B>See also: </B>  

<B><a href="../EOClassDescription/EOClassDescription.html#//apple_ref/occ/instm/EOClassDescription/inverseForRelationshipKey:" target="_top">- inverseForRelationshipKey: </B> (EOClassDescription)</a>

<p><a name="1275">

<h4> <a name="//apple_ref/occ/instm/NSObject/isToManyKey:">isToManyKey:</a></h4>

</a>- (BOOL)<B>isToManyKey: </B>(NSString *)<em>key</em><p>

Returns YES if the receiver has a to-many relationship identified by <em>key</em>, NO otherwise.<p>

<B>See also: </B>  

<B><a href="#//apple_ref/occ/instm/NSObject/toManyRelationshipKeys">- toManyRelationshipKeys</a> </B>, <a href="#//apple_ref/occ/instm/NSObject/toOneRelationshipKeys"><B>- toOneRelationshipKeys</a>

 </B><p><a name="1279">

<h4> <a name="//apple_ref/occ/instm/NSObject/ownsDestinationObjectsForRelationshipKey:">ownsDestinationObjectsForRelationshipKey:</a></h4>

</a>- (BOOL)<B>ownsDestinationObjectsForRelationshipKey: </B>(NSString *)<em>key</em><p>

Returns YES if the receiver has a relationship identified by <em>key</em> that owns its destination, NO otherwise. If an object owns the destination for a relationship, then when that destination object is removed from the relationship, it's automatically deleted. Ownership of a relationship thus contrasts with a delete rule, in that the first applies when the destination is removed and the second applies when the source is deleted.<p>

<B>See also: </B>  

<B><a href="#//apple_ref/occ/instm/NSObject/deleteRuleForRelationshipKey:">- deleteRuleForRelationshipKey:</a> </B>, 

<B><a href="../EOClassDescription/EOClassDescription.html#//apple_ref/occ/instm/EOClassDescription/ownsDestinationObjectsForRelationshipKey:" target="_top">- ownsDestinationObjectsForRelationshipKey: </B> (EOClassDescription)</a>, 

<B><a href="../EORelationship/EORelationship.html#//apple_ref/occ/instm/EORelationship/ownsDestination" target="_top">- ownsDestination </B> (EORelationship)</a>

<p><a name="1283">

<h4> <a name="//apple_ref/occ/instm/NSObject/propagateDeleteWithEditingContext:">propagateDeleteWithEditingContext:</a></h4>

</a>- (void)<B>propagateDeleteWithEditingContext: </B>(EOEditingContext *)<em>anEditingContext</em><p>

Sends a <B>propagateDeleteForObject:editingContext: </B> message to the receiver's EOClassDescription. This causes the destination objects of the receiver's relationships to be deleted according to the delete rule for each relationship:<p>

<b>Delete Rule	Action

</b>EODeleteRuleNullify	The destination object is simply removed from the relationship,<br>

	and the receiver is likewise removed from the destination's<br>

	reciprocal relationship if there is one.<br>

EODeleteRuleCascade	As above, but the destination object is also deleted and<br>

	sent a <B>propagateDeleteWithEditingContext: </B> message.<br>

EODeleteRuleDeny	Applied in <a href="#1330"><B>validateForDelete </B></a>, not in this method.<br>

EODeleteRuleNoAction	The relationship is ignored when the receiver is deleted. 

The EODeleteRuleNoAction option is useful for tuning performance. In order to perform a deletion, 

Enterprise Objects Framework fires all the faults of the deleted object and then fires any to-many faults 

that point back to the deleted object. For example, suppose you have a simple application based on the 

sample Movies database. Deleting a Movie object has the effect of firing a to-one fault for the Movie's 

<code>studio</code> relationship, and then firing the to-many <code>movies</code> fault for that studio. In this scenario, it would 

make sense to set the delete rule EODeleteRuleNoAction for Movie's <code>studio</code> relationship. However, you 

should use this delete rule with great caution since it can result in dangling references in your object 

graph.

<B>See also: </B>  

<B><a href="#//apple_ref/occ/instm/NSObject/deleteRuleForRelationshipKey:">- deleteRuleForRelationshipKey:</a>

 </B><p><a name="1289">

<h4> <a name="//apple_ref/occ/instm/NSObject/removeObject:fromBothSidesOfRelationshipWithKey:">removeObject:fromBothSidesOfRelationshipWithKey:</a></h4>

</a>- (void)<B>removeObject: </B>(id)<em>anObject</em> <B>fromBothSidesOfRelationshipWithKey: </B>(NSString *)<em>key</em><p>

Removes <em>anObject</em> from the receiver's relationship identified by <em>key</em>, and also removes the receiver from <em>anObject</em>'s reciprocal relationship if there is one. For a to-one relationship, <em>anObject</em> is removed using <B><a href="#1302">takeValue:forKey:</a> </B> with <B>nil </B> as the value. For a to-many relationship, <em>anObject</em> is removed using <B><a href="#1293">removeObject:fromPropertyWithKey:</a> </B>.<p>

<B>See also: </B>  

<B><a href="#//apple_ref/occ/instm/NSObject/addObject:toBothSidesOfRelationshipWithKey:">- addObject:toBothSidesOfRelationshipWithKey:</a>

 </B><p><a name="1293">

<h4> <a name="//apple_ref/occ/instm/NSObject/removeObject:fromPropertyWithKey:">removeObject:fromPropertyWithKey:</a></h4>

</a>- (void)<B>removeObject: </B>(id)<em>anObject</em> <B>fromPropertyWithKey: </B>(NSString *)<em>key</em><p>

Removes <em>anObject</em> from the receiver's to-many relationship identified by <em>key</em>, without modifying any reciprocal relationship. Similar to <a href="#1302"><B>takeValue:forKey: </B></a>, this method first attempts to invoke a method of the form <B>removeFrom </B><em>Key</em><B>: </B>. If the receiver doesn't have such a method, this method gets the property array using <a href="#1359"><B>valueForKey: </B></a> and operates directly on that.<p>

If the array is mutable, this method simply locates <em>anObject</em> and removes it using <B>removeObjectAtIndex: </B>. Otherwise it constructs a new array containing any existing objects minus <em>anObject</em>, then sets it using <B><a href="#1302">takeValue:forKey:</a> </B>.<p>

<B>See also: </B>  

<B><a href="#//apple_ref/occ/instm/NSObject/addObject:toPropertyWithKey:">- addObject:toPropertyWithKey:</a> </B>, 

<B><a href="#//apple_ref/occ/instm/NSObject/removeObject:fromBothSidesOfRelationshipWithKey:">- removeObject:fromBothSidesOfRelationshipWithKey:</a>

 </B><p><a name="1298">

<h4> <a name="//apple_ref/occ/instm/NSObject/snapshot">snapshot</a></h4>

</a>- (NSDictionary *)<B>snapshot </B><p>

Returns an NSDictionary whose keys are those of the receiver's attributes, to-one relationships, and to-many relationships, and whose values are the values of those properties, with EONull substituted for <B>nil </B>. For to-many relationships, the dictionary contains shallow copies of the arrays to preserve the <B>id </B>s of the contents.<p>

<B>See also: </B>  

<B><a href="#//apple_ref/occ/instm/NSObject/updateFromSnapshot:">- updateFromSnapshot:</a> </B>, <a href="#//apple_ref/occ/instm/NSObject/allPropertyKeys"><B>- allPropertyKeys</a> </B>, <a href="#//apple_ref/occ/instm/NSObject/valueForKey:"><B>- valueForKey:</a>

 </B><p><a name="1395">

<h4> <a name="//apple_ref/occ/instm/NSObject/takeStoredValue:forKey:">takeStoredValue:forKey:</a></h4>

</a>- (void)<code>takeStoredValue:</code>(id)<em>value</em> <code>forKey:</code>(NSString *)<em>key</em><p>

Sets the property identified by <em>key</em> to <em>value</em>. If you haven't overridden<a href="#1400"> <B>useStoredAccessor </B></a> to return YES, this method simply invokes<a href="#1302"> <B>takeValue:forKey: </B></a>. If you have overridden<a href="#1400"> <B>useStoredAccessor </B></a> to return YES, the default implementation does the following:<p>

<ol>

<a name="1402">

<li>Searches for an instance variable whose name is the same as the key, but preceded by an underbar. Sets its value directly. For example, with a key of "lastName",<a href="#1395"> <B>takeStoredValue:forKey: </B></a> looks for an instance variable called <code>_lastName</code>.

</a><a name="1405">

<li>If the instance variable isn't found, searches for an accessor method based on the key, but preceded by an underbar. For example, with a key of "lastName",<a href="#1395"> <B>takeStoredValue:forKey: </B></a> looks for a method called <code>_setLastName.</code>

</a><a name="1407">

<li>If neither an underbar-preceded instance variable or accessor method is found, searches for an instance variable whose name is the same as the key and sets its value directly. 

</a><a name="1409">

<li>Finally, searches for an accessor method based on the key. For the key "lastName", this would be <code>setLastName:</code>.

</a></ol>

Classes can override this method to add custom behavior. The default implementation raises an exception if an unknown key is passed in. For more discussion of key-value coding, see the section "<a href="#1095">Key-Value Coding Methods</a>" in the class description.<p>

<B>See also: </B>  

<B><a href="#//apple_ref/occ/clm/NSObject/useStoredAccessor">+ useStoredAccessor</a> </B>, <a href="#//apple_ref/occ/instm/NSObject/takeStoredValue:forKeyPath:"><B>- takeStoredValue:forKeyPath:</a> </B>, <a href="#//apple_ref/occ/instm/NSObject/takeStoredValuesFromDictionary:"><B>- takeStoredValuesFromDictionary:</a>

 </B><p><a name="1394">

<h4> <a name="//apple_ref/occ/instm/NSObject/takeStoredValue:forKeyPath:">takeStoredValue:forKeyPath:</a></h4>

</a>- (void)<code>takeStoredValue:</code>(id)<em>value</em><code> forKeyPath:</code>(NSString *)<em>keyPath</em><p>

Sets the value for the derived property identified by <em>key</em><em>Path</em> to <em>value</em>. For example, suppose you have the following code:<p>

<blockquote><pre>[myEmployee takeStoredValue:aStreet forKeyPath:@"address.street"];

</pre></blockquote><p>

This code would first get the address object by invoking <code>[myEmployee valueForKey:@"address"]</code>, and then it would set the value using <code>[address setStoredValue:aStreet forKey:@"street"]</code>.<p>

<B>See also: </B>  

<B><a href="#//apple_ref/occ/clm/NSObject/useStoredAccessor">+ useStoredAccessor</a> </B>, <a href="#//apple_ref/occ/instm/NSObject/takeValue:forKey:"><B>- takeValue:forKey:</a> </B>, <a href="#//apple_ref/occ/instm/NSObject/takeStoredValuesFromDictionary:"><B>- takeStoredValuesFromDictionary:</a>

 </B><p><a name="1411">

<h4> <a name="//apple_ref/occ/instm/NSObject/takeStoredValuesFromDictionary:">takeStoredValuesFromDictionary:</a></h4>

</a>- (void)<code>takeStoredValuesFromDictionary:</code>(NSDictionary *)<em>aDictionary</em><p>

Sets properties of the receiver with values from <em>aDictionary</em>, using their keys to identify the properties. NSObject's implementation invokes <B><a href="#1395">takeStoredValue:forKey:</a> </B> for each key-value pair, substituting <B>nil </B> for EONull values in <em>aDictionary</em>.<p>

<B>See also: </B>  

<B><a href="#//apple_ref/occ/clm/NSObject/useStoredAccessor">+ useStoredAccessor</a> </B>, <a href="#//apple_ref/occ/instm/NSObject/takeValue:forKey:"><B>- takeValue:forKey:</a> </B>, <a href="#//apple_ref/occ/instm/NSObject/takeValue:forKeyPath:"><B>- takeValue:forKeyPath:</a>

 </B><p><a name="1302">

<h4> <a name="//apple_ref/occ/instm/NSObject/takeValue:forKey:">takeValue:forKey:</a></h4>

</a>- (void)<B>takeValue: </B>(id)<em>value</em> <B>forKey: </B>(NSString *)<em>key</em><p>

Sets the value for the property identified by <em>key</em> to <em>value</em>. NSObject's implementation does so by first checking the receiver for a selector of the form <B>set </B><em>Key</em><B>: </B>, invoking it if there is one. If there's no such method, and <B><a href="#1182">accessInstanceVariablesDirectly</a> </B> returns YES, NSObject's implementation checks for an instance variable named <em>key</em> and sets the value directly, autoreleasing the old value and retaining the new one.<p>

If there's neither an accessor method nor an instance variable matching <em>key</em>, NSObject's implementation invokes <B><a href="#1257">handleTakeValue:forUnboundKey:</a> </B> as a fallback mechanism. Subclasses can override <B><a href="#1257">handleTakeValue:forUnboundKey:</a> </B> to handle the request in some other way. For more discussion of key-value coding, see the section "<a href="#1095">Key-Value Coding Methods</a>" in the class description.<p>

<B>See also: </B>  

<B><a href="#//apple_ref/occ/instm/NSObject/takeValue:forKeyPath:">- takeValue:forKeyPath:</a> </B>, <a href="#//apple_ref/occ/instm/NSObject/takeValuesFromDictionary:"><B>- takeValuesFromDictionary:</a> </B>, <a href="#//apple_ref/occ/instm/NSObject/valueForKey:"><B>- valueForKey:</a>

 </B><p><a name="1307">

<h4> <a name="//apple_ref/occ/instm/NSObject/takeValue:forKeyPath:">takeValue:forKeyPath:</a></h4>

</a>- (void)<B>takeValue: </B>(id)<em>value</em> <B>forKeyPath: </B>(NSString *)<em>keyPath</em><p>

Sets the value for the derived property identified by <em>keyPath</em> to <em>value</em>. A key path has the form <em>relationship.property</em> (with one or more relationships); for example "department.name". NSObject's implementation of this method gets the destination object for each relationship using <B><a href="#1359">valueForKey:</a> </B>, and sends the final object a <B><a href="#1302">takeValue:forKey:</a> </B> message with <em>value</em> and <em>property</em>.<p>

<B>See also: </B>  

<B><a href="#//apple_ref/occ/instm/NSObject/takeValuesFromDictionary:">- takeValuesFromDictionary:</a> </B>, <a href="#//apple_ref/occ/instm/NSObject/valueForKeyPath:"><B>- valueForKeyPath:</a>

 </B><p><a name="1311">

<h4> <a name="//apple_ref/occ/instm/NSObject/takeValuesFromDictionary:">takeValuesFromDictionary:</a></h4>

</a>- (void)<B>takeValuesFromDictionary: </B>(NSDictionary *)<em>aDictionary</em><p>

Sets properties of the receiver with values from <em>aDictionary</em>, using their keys to identify the properties. NSObject's implementation invokes <B><a href="#1302">takeValue:forKey:</a> </B> for each key-value pair, substituting <B>nil </B> for EONull values in <em>aDictionary</em>.<p>

<B>See also: </B>  

<B><a href="#//apple_ref/occ/instm/NSObject/updateFromSnapshot:">- updateFromSnapshot:</a> </B>, <a href="#//apple_ref/occ/instm/NSObject/takeValue:forKeyPath:"><B>- takeValue:forKeyPath:</a> </B>, <a href="#//apple_ref/occ/instm/NSObject/valuesForKeys:"><B>- valuesForKeys:</a>

 </B><p><a name="1315">

<h4> <a name="//apple_ref/occ/instm/NSObject/toManyRelationshipKeys">toManyRelationshipKeys</a></h4>

</a>- (NSArray *)<B>toManyRelationshipKeys </B><p>

Returns the names of the receiver's to-many relationships, as determined from the EOClassDescription. You might wish to override this method to add keys for relationships not defined by the EOClassDescription. The access layer's subclass of EOClassDescription, EOEntityClassDescription, returns the names of to-many relationships designated as class properties.<p>

<B>See also: </B>  

<B><a href="#//apple_ref/occ/instm/NSObject/toOneRelationshipKeys.">- toOneRelationshipKeys.</a> </B>, <a href="#//apple_ref/occ/instm/NSObject/attributeKeys"><B>- attributeKeys</a> </B>, <a href="#//apple_ref/occ/instm/NSObject/attributeKeys"><B>- attributeKeys</a> </B>, 

<B><a href="../EOClassDescription/EOClassDescription.html#//apple_ref/occ/instm/EOClassDescription/toManyRelationshipKeys" target="_top">- toManyRelationshipKeys </B> (EOClassDescription)</a>

<p><a name="1319">

<h4> <a name="//apple_ref/occ/instm/NSObject/toOneRelationshipKeys">toOneRelationshipKeys</a></h4>

</a>- (NSArray *)<B>toOneRelationshipKeys </B><p>

Returns the names of the receiver's to-one relationships, as determined from the EOClassDescription. You might wish to override this method to add keys for relationships not defined by the EOClassDescription. The access layer's subclass of EOClassDescription, EOEntityClassDescription, returns the names of to-one relationships designated as class properties.<p>

<B>See also: </B>  

<B><a href="#//apple_ref/occ/instm/NSObject/toManyRelationshipKeys">- toManyRelationshipKeys.</a> </B>, <a href="#//apple_ref/occ/instm/NSObject/attributeKeys"><B>- attributeKeys</a> </B>, <a href="#//apple_ref/occ/instm/NSObject/attributeKeys"><B>- attributeKeys</a> </B>, 

<B><a href="../EOClassDescription/EOClassDescription.html#//apple_ref/occ/instm/EOClassDescription/toOneRelationshipKeys" target="_top">- toOneRelationshipKeys </B> (EOClassDescription)</a>

<p><a name="1323">

<h4> <a name="//apple_ref/occ/instm/NSObject/unableToSetNilForKey:">unableToSetNilForKey:</a></h4>

</a>- (void)<B>unableToSetNilForKey: </B>(NSString *)<em>key</em><p>

Invoked from <B><a href="#1302">takeValue:forKey:</a> </B> when it's given a <B>nil </B> value for a scalar property (such as an <B>int </B> or a <B>float </B>). NSObject's implementation raises an NSInvalidArgumentException. Subclasses can override it to handle the request in some other way, such as by substituting zero or a sentinel value and invoking <B>takeValue:forKey: </B> again.<p>

<a name="1326">

<h4> <a name="//apple_ref/occ/instm/NSObject/updateFromSnapshot:">updateFromSnapshot:</a></h4>

</a>- (void)<B>updateFromSnapshot: </B>(NSDictionary *)<em>aSnapshot</em><p>

Takes the values from <em>aSnapshot</em>, setting each one according to its key using <B><a href="#1302">takeValue:forKey:</a> </B>. In the process, EONull values are converted to <B>nil </B>, and array values are set as shallow mutable copies to preserve the <B>id </B>s of the contents.<p>

<B>See also: </B>  

<B><a href="#//apple_ref/occ/instm/NSObject/takeValuesFromDictionary:">- takeValuesFromDictionary:</a> </B>, <a href="#//apple_ref/occ/instm/NSObject/snapshot"><B>- snapshot</a>

 </B><p><a name="1385">

<h4> <a name="//apple_ref/occ/instm/NSObject/userPresentableDescription">userPresentableDescription</a></h4>

</a>- (NSString *)<code>userPresentableDescription</code><p>

Returns a short (no longer than 60 characters) description of an enterprise object based on its data. First checks to see if the enterprise object has an attribute called "name" and if so, it returns its value. Otherwise, checks for an attribute called "title". If neither of those attributes exists, this method enumerates the object's attributeKeys and returns the values of all of its properties, separated by commas (applying the default formatter for numbers and dates).<p>

<B>See also: </B>  

<B><a href="#//apple_ref/occ/instm/NSObject/eoDescription">- eoDescription</a> </B>, <a href="#//apple_ref/occ/instm/NSObject/eoShallowDescription"><B>- eoShallowDescription</a>

 </B><p><a name="1330">

<h4> <a name="//apple_ref/occ/instm/NSObject/validateForDelete">validateForDelete</a></h4>

</a>- (NSException *)<B>validateForDelete </B><p>

Confirms that the receiver can be deleted in its current state, returning <B>nil </B> if it can or an NSException that the sender may raise if it can't. For example, an object can't be deleted if it has a relationship with a delete rule of EODeleteRuleDeny and that relationship has a destination object.<p>

NSObject's implementation sends the receiver's EOClassDescription a <B>validateObjectForDelete: </B> message (which performs basic checking based on the presence or absence of values). Subclasses should invoke <B>super </B>'s implementation before performing their own validation, and should combine any exception returned by <B>super </B>'s implementation with their own:<p>

<blockquote><pre>- (NSException *)validateForDelete<br>{<br>    NSException *exception = [super validateForDelete];

</pre></blockquote><p>

<blockquote><pre>    if (/* some other violation */ ) {<br>        NSException *newException = /* the extra exception */;<br>        exception = [NSException aggregateExceptionWithExceptions:[NSArray<br>             arrayWithObjects:exception, newException, nil]];<br>    }<br><br>    return exception;<br>}

</pre></blockquote><p>

<B>See also: </B>  

<B><a href="#//apple_ref/occ/instm/NSObject/validateForInsert">- validateForInsert</a> </B>, <a href="#//apple_ref/occ/instm/NSObject/validateForSave"><B>- validateForSave</a> </B>, <a href="#//apple_ref/occ/instm/NSObject/validateForUpdate"><B>- validateForUpdate</a> </B>, <a href="#//apple_ref/occ/instm/NSObject/validateValue:forKey:"><B>- validateValue:forKey:</a> </B>, 

<B><a href="../NSException/NSException.html#//apple_ref/occ/clm/NSException/validationExceptionWithFormat:" target="_top">+ validationExceptionWithFormat: </B> (NSException Additions)</a>

<p><a name="1338">

<h4> <a name="//apple_ref/occ/instm/NSObject/validateForInsert">validateForInsert</a></h4>

</a>- (NSException *)<B>validateForInsert </B><p>

Confirms that the receiver can be inserted in its current state, returning <B>nil </B> if it can or an NSException that can be raised if it can't. NSObject's implementation simply invokes <B><a href="#1342">validateForSave</a> </B>.<p>

<B>See also: </B>  

<B><a href="#//apple_ref/occ/instm/NSObject/validateForDelete">- validateForDelete</a> </B>, <a href="#//apple_ref/occ/instm/NSObject/validateForSave"><B>- validateForSave</a> </B>, <a href="#//apple_ref/occ/instm/NSObject/validateForUpdate"><B>- validateForUpdate</a> </B>, <a href="#//apple_ref/occ/instm/NSObject/validateValue:forKey:"><B>- validateValue:forKey:</a> </B>, 

<B><a href="../NSException/NSException.html#//apple_ref/occ/clm/NSException/validationExceptionWithFormat:" target="_top">+ validationExceptionWithFormat: </B> (NSException Additions)</a>

<p><a name="1342">

<h4> <a name="//apple_ref/occ/instm/NSObject/validateForSave">validateForSave</a></h4>

</a>- (NSException *)<B>validateForSave </B><p>

Confirms that the receiver can be saved in its current state, returning <B>nil </B> if it can or an NSException that the sender may raise if it can't. NSObject's implementation sends the receiver's EOClassDescription a <B>validateObjectForSave: </B> message, then iterates through all of the receiver's properties, invoking <a href="#1354"><B>validateValue:forKey: </B></a> for each one. If this results in more than one exception, the exception returned contains the additional ones in its <B>userInfo </B> dictionary under the EOAdditionalExceptions key. Subclasses should invoke <B>super </B>'s implementation before performing their own validation, and should combine any exception returned by <B>super </B>'s implementation with their own:<p>

<blockquote><pre>- (NSException *)validateForSave<br>{<br>    NSException *exception = [super validateForSave];

</pre></blockquote><p>

<blockquote><pre>    if (/* some other violation */ ) {<br>        NSException *newException = /* the extra exception */;<br>        exception = [NSException aggregateExceptionWithExceptions:[NSArray<br>             arrayWithObjects:exception, newException, nil]];<br>    }<br><br>    return exception;<br>}

</pre></blockquote><p>

Enterprise objects can implement this method to check that certain relations between properties hold; for example, that the end date of a vacation period follows the begin date. To validate an individual property, you can simply implement a method for it as described under <a href="#1354"><B>validateValue:forKey: </B></a>.<p>

<B>See also: </B>  

<B><a href="#//apple_ref/occ/instm/NSObject/validateForDelete">- validateForDelete</a> </B>, <a href="#//apple_ref/occ/instm/NSObject/validateForInsert"><B>- validateForInsert</a> </B>, <a href="#//apple_ref/occ/instm/NSObject/validateForUpdate"><B>- validateForUpdate</a> </B>, 

<B><a href="../NSException/NSException.html#//apple_ref/occ/clm/NSException/validationExceptionWithFormat:" target="_top">+ validationExceptionWithFormat: </B> (NSException Additions)</a>, 

<B><a href="../NSException/NSException.html#//apple_ref/occ/clm/NSException/aggregateExceptionWithExceptions:" target="_top">+ aggregateExceptionWithExceptions: </B> (NSException Additions)</a>

<p><a name="1350">

<h4> <a name="//apple_ref/occ/instm/NSObject/validateForUpdate">validateForUpdate</a></h4>

</a>- (NSException *)<B>validateForUpdate </B><p>

Confirms that the receiver can be updated in its current state, returning <B>nil </B> if it can or an NSException that the sender may raise if it can't. NSObject's implementation simply invokes <B><a href="#1342">validateForSave</a> </B>.<p>

<B>See also: </B>  

<B><a href="#//apple_ref/occ/instm/NSObject/validateForDelete">- validateForDelete</a> </B>, <a href="#//apple_ref/occ/instm/NSObject/validateForInsert"><B>- validateForInsert</a> </B>, <a href="#//apple_ref/occ/instm/NSObject/validateForSave"><B>- validateForSave</a> </B>, <a href="#//apple_ref/occ/instm/NSObject/validateValue:forKey:"><B>- validateValue:forKey:</a> </B>, 

<B><a href="../NSException/NSException.html#//apple_ref/occ/clm/NSException/validationExceptionWithFormat:" target="_top">+ validationExceptionWithFormat: </B> (NSException Additions)</a>

<p><a name="1354">

<h4> <a name="//apple_ref/occ/instm/NSObject/validateValue:forKey:">validateValue:forKey:</a></h4>

</a>- (NSException *)<B>validateValue: </B>(id *)<em>valuePointer</em> <B>forKey: </B>(NSString *)<em>key</em><p>

Confirms that the value referenced by <em>valuePointer</em> is legal for the receiver, returning <B>nil </B> if it can or an EOValidationException that the sender may raise if it can't. NSObject's implementation sends a <B>validateValue:forKey: </B> message to the receiver's EOClassDescription. If that message doesn't return an exception, it checks for a method of the form <B>validate </B><em>Key</em><B>: </B> (for example, <B>validateBudget: </B> for a <em>key</em> of "budget") and invokes it, returning the result.<p>

Enterprise objects can implement individual <B>validate </B><em>Key</em><B>: </B> methods to check limits, test for nonsense values, and otherwise confirm individual properties. To validate multiple properties based on relations among them, override the appropriate <B>validateFor... </B> method.<p>

<B>See also: </B>  

<B><a href="#//apple_ref/occ/instm/NSObject/validateForDelete">- validateForDelete</a> </B>, <a href="#//apple_ref/occ/instm/NSObject/validateForInsert"><B>- validateForInsert</a> </B>, <a href="#//apple_ref/occ/instm/NSObject/validateForSave"><B>- validateForSave</a> </B>, <a href="#//apple_ref/occ/instm/NSObject/validateForUpdate"><B>- validateForUpdate</a> </B>, 

<B><a href="../NSException/NSException.html#//apple_ref/occ/clm/NSException/validationExceptionWithFormat:" target="_top">+ validationExceptionWithFormat: </B> (NSException Additions)</a>

<p><a name="1359">

<h4> <a name="//apple_ref/occ/instm/NSObject/valueForKey:">valueForKey:</a></h4>

</a>- (id)<B>valueForKey: </B>(NSString *)<em>key</em><p>

Returns the value for the property identified by <em>key</em>. NSObject's implementation does so by first checking the receiver for a method named <em>key</em>, invoking it if there is one. If there's no such method, and <B><a href="#1182">accessInstanceVariablesDirectly</a> </B> returns YES, NSObject's implementation checks for an instance variable named <em>key</em> and returns the instance variable.<p>

If there's neither an accessor method nor an instance variable matching <em>key</em>, NSObject's implementation invokes <B><a href="#1253">handleQueryWithUnboundKey:</a> </B> as a fallback mechanism. Subclasses can override <B><a href="#1253">handleQueryWithUnboundKey:</a> </B> to handle the request in some other way.<p>

<B>See also: </B>  

<B><a href="#//apple_ref/occ/instm/NSObject/valueForKeyPath:">- valueForKeyPath:</a> </B>, <a href="#//apple_ref/occ/instm/NSObject/valuesForKeys:"><B>- valuesForKeys:</a> </B>, <a href="#//apple_ref/occ/instm/NSObject/takeValue:forKey:"><B>- takeValue:forKey:</a>

 </B><p><a name="1364">

<h4> <a name="//apple_ref/occ/instm/NSObject/valueForKeyPath:">valueForKeyPath:</a></h4>

</a>- (id)<B>valueForKeyPath: </B>(NSString *)<em>keyPath</em><p>

Returns the value for the derived property identified by <em>keyPath</em>. A key path has the form <em>relationship.property</em> (with one or more relationships); for example "department.name". NSObject's implementation of this method gets the destination object for each relationship using <B><a href="#1359">valueForKey:</a> </B>, and returns the result of a <B><a href="#1359">valueForKey:</a> </B> message to the final object.<p>

<B>See also: </B>  

<B><a href="#//apple_ref/occ/instm/NSObject/valuesForKeys:">- valuesForKeys:</a> </B>, <a href="#//apple_ref/occ/instm/NSObject/takeValue:forKeyPath:"><B>- takeValue:forKeyPath:</a>

 </B><p><a name="1368">

<h4> <a name="//apple_ref/occ/instm/NSObject/valuesForKeys:">valuesForKeys:</a></h4>

</a>- (NSDictionary *)<B>valuesForKeys: </B>(NSArray *)<em>keys</em><p>

Returns an NSDictionary containing the property values identified by each of <em>keys</em>. NSObject's implementation invokes <a href="#1359"><B>valueForKey: </B></a> for each key in <em>keys</em>, substituting EONull in the NSDictionary for returned <B>nil </B> values.<p>

<B>See also: </B>  

<B><a href="#//apple_ref/occ/instm/NSObject/valueForKeyPath:">- valueForKeyPath:</a> </B>, <a href="#//apple_ref/occ/instm/NSObject/takeValuesFromDictionary:"><B>- takeValuesFromDictionary:</a>

 </B><p><a name="1372">

<h4> <a name="//apple_ref/occ/instm/NSObject/willChange">willChange</a></h4>

</a>- (void)<B>willChange </B><p>

Notifies any observers that the receiver's state is about to change, by sending each an <B>objectWillChange: </B> message. See the EOObserverCenter class specification for more information.<p>



 

 





<i>Copyright &#169; 1997, Apple Computer, Inc.   All rights

reserved.</i>



<!-- Last updated: 10/15/97 16:42:54 -->



</body>

</html>

