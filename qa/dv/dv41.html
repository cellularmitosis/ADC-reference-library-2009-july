<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"			"http://www.w3.org/TR/REC-html40/loose.dtd"><HTML><!--Template 06-20-02--><HEAD><LINK REL="stylesheet" HREF="../../adcstyle.css" TYPE="text/css"><LINK REL="stylesheet" HREF="../../style.css" TYPE="text/css">   <title>Technical Q&amp;A DV41: Native Disk Driver Debugging</title>	<meta name="keywords" content="ndrv debugging native disk drivers">	<meta name="Description" content="Technical Q&amp;A DV41: Advice about how to debug a native diskdriver"><meta name="categories" content="Devices"><meta name="week-posted" content="Feb 28, 2000 - Mar 3, 2000"><LINK REL="stylesheet" HREF="../../css/adcstyle.css" TYPE="text/css"><script language="JavaScript" type="text/javascript" src="../../js/adc.js"></script></HEAD><BODY BGCOLOR="#FFFFFF"><a name="//apple_ref/doc/uid/DTS10001182" title="Native Disk Driver Debugging"></a><!-- top_of_header_marker_comment --><!-- begin_header_information --><!--#include virtual="/adcnavbar" --><p><a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../technicalqas/index.html">Technical Q&As</a> &gt; <a href="../../technicalqas/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../technicalqas/LegacyTechnologies/idxHardwareDrivers-date.html">Hardware & Drivers</a> &gt; </p><div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="../../referencelibrary/HardwareDrivers/idxPCIandPCCard-date.html" target="_blank">Hardware & Drivers > PCI and PC Card</a></li>
	</ul>
</div>




</div></div></div><!-- end_header_information --><!-- bottom_of_header_marker_comment --><!-- top_of_titles_marker_comment --><CENTER><table width="600" cellpadding="0" cellspacing="0" border="0">
<tr><td align="left" scope="row">
<h1>
<div id="pagehead">Technical Q&amp;A DV41</div>
<div id="pageheadsub">Native Disk Driver Debugging</div>
</h1>
</td></tr></table></CENTER><!-- bottom_of_titles_marker_comment --><!-- begin_content --> <CENTER><TABLE BORDER=0 CELLPADDING=0 WIDTH=600>  <TR> <td align="left"><hr width=500 align=center>                  <p id=p2>Q: I'm trying to debug a native disk driver         (<CODE>'ndrv'</CODE>) and I want to set a MacsBug breakpoint         on the driver's main entry point (<CODE>DoDriverIO</CODE>).         For 68K disk drivers (<CODE>'DRVR'</CODE>s) this was easy,         but native drivers all export the same symbol         (<CODE>DoDriverIO</CODE>) so it's hard to tell what's what.         How do I find my driver's main entry point?</P>                  <p id=p4>A: This can be done, but it requires some new tricks. For         the benefit of those with limited <CODE>'DRVR'</CODE>         experience, I'll start by going over the technique used for         68K drivers. I'll then show how you can extend the technique         for native drivers.</P>                  <TABLE BORDER=0 CELLPADDING=5 WIDTH=550> <TR> <td bgcolor="#e6e6e6" align=left>                  <p id=p4><B>Note:</B><BR>                                    This technique is most useful in situations where                  you are debugging without source code, or where                  recompiling the source to include the appropriate                  <CODE>DebugStr</CODE>'s is not practical. If you                  have the source and can easily load a new version                  of your driver to include the required debugger                  breaks, there's no point messing around in MacsBug.</p></td></TR>         </TABLE><TABLE BORDER=0 CELLPADDING=5 WIDTH=550> <TR> <td bgcolor="#e6e6e6" align=left>                  <p id=p4><B>Note:</B><BR>                                    You can apply this technique to other types of                  drivers (for example, serial drivers); the only                  requirement is that the driver appears in the unit                  table.               </p></td></TR>         </TABLE><TABLE BORDER=0 CELLPADDING=5 WIDTH=550> <TR> <td bgcolor="#e6e6e6" align=left>                  <p id=p4><B>Note:</B><BR>                                    These examples were generated using MacsBug 6.6 on                  Mac OS 9.               </p></td></TR>         </TABLE><br>                  <p id=p4>Finding a 68K Driver's Entry Points</p>                  <p id=p4>To start off, you need to find your driver's reference         number. For disk drivers, this is a simple application of         the MacsBug <CODE>drive</CODE> command.</P>                  <TABLE BORDER=0 CELLPADDING=5 WIDTH=550>             <TR>               <td bgcolor="#e6e6e6" align=left>                  <pre>&gt;&gt;&gt; drive Displaying Drive Queue  Drive Volume               Flags dRef Driver Name           FSID   Size   QElem at  0009  The Count            leiS  FFCA .ATADisk              0000 013044C6 001D2896  0008  &lt;none&gt;               lEIS  FFCC .AppleUSBMassStorage  0000 0003C300 00553F4E  0001  &lt;none&gt;               lEiD  FFCC .AppleUSBMassStorage  0000 0000FFFF 00553F9A</pre>               </td></TR>         </TABLE><br>                  <p id=p4>The column labeled <CODE>dRef</CODE> (in all listings in         this Q&amp;A, the interesting data is highlighted in red) yields the driver         reference number. In this example, we'll look at the main         hard disk, whose driver is ".ATADisk" and driver reference         number is <CODE>$FFCA</CODE>. You can pass this driver reference number         to the MacsBug <CODE>drvr</CODE> command to get more         information about the driver.</P>                  <TABLE BORDER=0 CELLPADDING=5 WIDTH=550>             <TR>               <td bgcolor="#e6e6e6" align=left>                  <pre>&gt;&gt;&gt; drvr ffca Displaying Driver Control Entries  dRef dNum Driver         Flg  Ver   qHead  Stor/Ver Dely  Drvr at DCE at  FFCA 0035 .ATADisk       bPO   #0 00000000 001D285C 0065 001D650E 0003F3B0</pre></td></TR>         </TABLE><br>                  <p id=p4>For a 68K driver, the column labeled <CODE>Drvr at</CODE>         contains the address of the beginning of the driver header.         In this example, the address is <CODE>$001D650E</CODE>. You can dump the         driver header using the built-in <CODE>drvr</CODE> template,         which produces the nicely formatted output shown below.</P>                  <TABLE BORDER=0 CELLPADDING=5 WIDTH=550>             <TR>               <td bgcolor="#e6e6e6" align=left>                  <pre>&gt;&gt;&gt; dm 1d650e drvr Displaying DRVR at 001D650E  001D650E  drvrFlags          6F00  001D6510  drvrDelay          0065  001D6512  drvrEMask          0000  001D6514  drvrMenu           0000  001D6516  drvrOpen           0020  001D6518  drvrPrime          00A2  001D651A  drvrCtl            0044  001D651C  drvrStatus         0054  001D651E  drvrClose          0034  001D6520  drvrName           ".ATADisk" </pre>               </td></TR>         </TABLE><br>                  <p id=p4>The import fields are the <CODE>drvrOpen</CODE>,         <CODE>drvrPrime</CODE>, <CODE>drvrCtl</CODE>, and         <CODE>drvrStatus</CODE> fields. Each contains the offset (in         bytes) from the beginning of the driver header to the         corresponding entry point. You can use the offset to         calculate the address of the entry point. For example, to         disassemble the beginning of the driver's Control entry         point, you might do the following.</P>                  <TABLE BORDER=0 CELLPADDING=5 WIDTH=550>             <TR>               <td bgcolor="#e6e6e6" align=left>                  <pre>&gt;&gt;&gt; il 1d650e+44 Disassembling from 1d650e+44  No procedure name            001D6552   MOVE.L     A5,-(A7)            001D6554   MOVEA.L    $0014(A1),A5            001D6558   MOVE.L     A1,-(A7)            001D655A   MOVE.L     A0,-(A7)            001D655C   JSR        *+$22A8            001D6560   BRA.S      *+$005E</pre>               </td></TR>         </TABLE><br>                  <p id=p4>To set a breakpoint on that entry point, use the MacsBug         <CODE>br</CODE> command.</P>                  <TABLE BORDER=0 CELLPADDING=5 WIDTH=550>             <TR>               <td bgcolor="#e6e6e6" align=left>                  <pre>&gt;&gt;&gt; br 1d650e+44 Break at 001D6552 every time</pre>               </td></TR>         </TABLE><br>                  <p id=p4>This will break every time the driver's Control entry         point is called. Register A0 contains the address of the         parameter block (in the case of the Control entry point,         this will be a <CODE>CntrlParamBlockRec</CODE>) passed to         your driver. You can dump this using the         <CODE>CntrlParamBlockRec</CODE> template.</P>                  <TABLE BORDER=0 CELLPADDING=5 WIDTH=550>             <TR>               <td bgcolor="#e6e6e6" align=left>                  <pre>&gt;&gt;&gt; dm a0 cpb Displaying CntrlParamBlockRec at 03D1FC4C  03D1FC4C  qLink              NIL  03D1FC50  qType              0002 = ioQType  03D1FC52  ioTrap             A004 _Control  03D1FC54  ioCmdAddr          00010001 -&gt;  03D1FC58  ioCompletion       NIL  03D1FC5C  ioResult           0001  03D1FC5E  ioNamePtr          NIL  03D1FC62  ioVRefNum          0009 = The Count  03D1FC64  ioCRefNum          FFCA  03D1FC66  csCode             0015  03D1FC68  csParam            0000 0001 0000 0009 03D1 FD10 03D1 FCA0...</pre>               </td></TR>         </TABLE><TABLE BORDER=0 CELLPADDING=5 WIDTH=550> <TR> <td bgcolor="#e6e6e6" align=left>                  <p id=p4><B>Note:</B><BR>                                    MacsBug includes two built-in macros,                  <CODE>cpb</CODE> and <CODE>iopb</CODE>, which                  expand to <CODE>CntrlParamBlockRec</CODE> (for                  Control and Status requests) and                  <CODE>IOParamBlockRec</CODE> (for Prime requests)                  respectively.               </p></td></TR>         </TABLE><br>                  <p id=p4>This template nicely displays:</P>                  <UL>            <LI><CODE>ioTrap</CODE> -- This field encodes both the            type of the request (Control, Status, and so on) and the            mode of execution (synchronous, asynchronous, immediate).            Modern versions of MacsBug show the appropriate symbolic            name (in this case, <CODE>_Control</CODE>).</li>                        <LI><CODE>ioVRefNum</CODE> -- For a Control request to a            disk driver, this typically contains the drive number of            the drive targeted by the request.</li>                        <LI><CODE>ioCRefNum</CODE> -- The driver reference number            of the target driver. We know this will be our driver            reference number (established above) because otherwise            the Device Manager wouldn't have called the entry point.</li>                        <LI><CODE>csCode</CODE> -- The type of request, in this            case a <CODE>kDriveIcon</CODE> (15) request. For a full            list of request codes for disk drivers, see the MoreDisks            module of the DTS sample            <A HREF="ftp://ftp.apple.com/developer/Sample_Code/Overview/MoreIsBetter.sit">MoreIsBetter</A>.</li>                        <LI><CODE>csParam</CODE> -- Many requests contain            request-specific information in this field.</li>         </UL>                  <p id=p4>If you want to watch for a specific request to your         driver, you can use a MacsBug conditional breakpoint. For         example, if you want to watch for         <CODE>kRegisterPartition</CODE> (50) requests, you might use         the following command.</P>                  <TABLE BORDER=0 CELLPADDING=5 WIDTH=550>             <TR>               <td bgcolor="#e6e6e6" align=left>                  <pre>&gt;&gt;&gt; br 1d650e+44 (a0+1a)^.w=#50.w Break at 001D6522 when (a0+1a)^.w=#50.w</pre>               </td></TR>         </TABLE><br>                  <p id=p4>This command tells MacsBug to break at the driver's         Control entry point where the <CODE>csCode</CODE> field         (offset $1A, field size of 2 bytes denoted by ".w") of the         <CODE>CntrlParamBlockRec</CODE> is 50 (# denotes decimal in         MacsBug). The ".w" notation on the constant is not strictly         necessary in this case, but I use it habitually because it         avoids a common sign extension "gotcha" when breaking on the         <CODE>ioCRefNum</CODE> field.</P>                  <p id=p4>You might be amazed that DTS engineers can instantly         calculate the offset of the <CODE>csCode</CODE> field in the         <CODE>CntrlParamBlockRec</CODE> structure, but in reality we         cheat and use the MacsBug <CODE>help</CODE> command.</P>                  <TABLE BORDER=0 CELLPADDING=5 WIDTH=550>             <TR>               <td bgcolor="#e6e6e6" align=left>                  <pre>&gt;&gt;&gt; help CntrlParamBlockRec CNTRLPARAMBLOCKREC is a template (size = $0032 bytes):     +0000  qLink              ^CntrlParamBlockRec     +0004  qType              E2_QType     +0006  ioTrap             IOTrapWord     +0008  ioCmdAddr          Pointer     +000C  ioCompletion       Pointer     +0010  ioResult           Word     +0012  ioNamePtr          ^pString     +0016  ioVRefNum          VRefNum     +0018  ioCRefNum          Word     +001A  csCode             Word     +001C  csParam            Word           000B</pre>               </td></TR>         </TABLE><br>                  <p id=p4>The output shows all the fields in the template along         with their offsets. Very handy!</P>                  <p>Finding a Native Driver's Entry Point</p>                  <p id=p4>The following example shows what happens when you try to         use the above technique for a native disk driver, in this         case the ".AppleUSBMassStorage" unit table (UT) shim driver.         </P>                  <TABLE BORDER=0 CELLPADDING=5 WIDTH=550>             <TR>               <td bgcolor="#e6e6e6" align=left>                  <pre>&gt;&gt;&gt; drive Displaying Drive Queue  Drive Volume               Flags dRef Driver Name           FSID   Size   QElem at  0009  The Count            leiS  FFCA .ATADisk              0000 013044C6 001D2896  0008  &lt;none&gt;               lEIS  FFCC .AppleUSBMassStorage  0000 0003C300 00553F4E  0001  &lt;none&gt;               lEiD  FFCC .AppleUSBMassStorage  0000 0000FFFF 00553F9A&gt;&gt;&gt; drvr ffcc Displaying Driver Control Entries  dRef dNum Driver         Flg  Ver   qHead  Stor/Ver Dely  Drvr at DCE at  FFCC 0033 .AppleUSBMass... bPO   #0 00000000 02.02f00 0000 00196778 00196740&gt;&gt;&gt; dm 196778 drvr Displaying DRVR at 00196778  00196778  drvrFlags          0000  0019677A  drvrDelay          0000  0019677C  drvrEMask          0000  0019677E  drvrMenu           0000  00196780  drvrOpen           0000  00196782  drvrPrime          0000  00196784  drvrCtl            0000  00196786  drvrStatus         0000  00196788  drvrClose          0000  0019678A  drvrName           ".AppleUSBMassStorage" </pre>               </td></TR>         </TABLE><br>                  <p id=p4>Notice how the entry point offsets in the driver header         are all zero -- the old 68K driver technique is obviously         not going to work here! Instead, we must use the MacsBug         <CODE>frags</CODE> command to dump information about the         fragment containing the driver. The following example shows         how to display all information (the <CODE>-a</CODE> option)         about a driver whose fragment name is         "MyDriverFragmentName".</P>                  <TABLE BORDER=0 CELLPADDING=5 WIDTH=550>             <TR>               <td bgcolor="#e6e6e6" align=left>                  <pre>&gt;&gt;&gt; frags -a "MyDriverFragmentName" CFM Info for fragments in all contexts.  Finder                             heap zone @ 03AFE920, contextID = 01C30001  &lt;System Context&gt;                   heap zone @ 00002800, contextID = 00000001        ^FFE22770                              connID = 00000386 (closureID = 00000385)           pef @ FFE22770, flags = 00, symbols #2           sect #0: @ FFE227F0-FFE2B244 exec,  use = #1, length = #35412           sect #1: @ 0054FEC0-00555708 data,  use = #1, length = #22600              DoDriverIO                        tvec 005500E8              TheDriverDescription              data 00553A30            Import Libraries:              DriverLoaderLib        vers=00000000 oldest=00000000              DriverServicesLib      vers=00000000 oldest=00000000              InterfaceLib           vers=00000000 oldest=00000000              NameRegistryLib        vers=00000000 oldest=00000000</pre>               </td></TR>         </TABLE><br>                  <p id=p4>This assumes that your driver has a well known fragment         name, which you supply as a parameter to <CODE>frags</CODE>.         However, in many cases, such as the USB driver in this         example, the driver's fragment name is not well known. To         find the fragment you must use dump out the driver's device         control entry (DCE). You can find the address of the DCE in         the output of the <CODE>drvr</CODE> command (in the column         labeled <CODE>DCE at</CODE>).</P>                  <TABLE BORDER=0 CELLPADDING=5 WIDTH=550>             <TR>               <td bgcolor="#e6e6e6" align=left>                  <pre>&gt;&gt;&gt; drvr ffcc Displaying Driver Control Entries  dRef dNum Driver         Flg  Ver   qHead  Stor/Ver Dely  Drvr at DCE at  FFCC 0033 .AppleUSBMass... bPO   #0 00000000 02.02f00 0000 00196778 00196740</pre>               </td></TR>         </TABLE><br>                  <p id=p4>In this case, the DCE is at address <CODE>$00196740</CODE>. You can         dump the DCE using the <CODE>DCtlEntry</CODE> template.</P>                  <TABLE BORDER=0 CELLPADDING=5 WIDTH=550>             <TR>               <td bgcolor="#e6e6e6" align=left>                  <pre>&gt;&gt;&gt; dm 196740 dctlentry Displaying DCtlEntry at 00196740  00196740  dCtlDriver         00196778  00196744  dCtlFlags          #7980  00196746  dCtlQHdr  00196746    qFlags           #0  00196748    qHead            00000000  0019674C    qTail            00000000  00196750  dCtlPosition       #1024  00196754  dCtlStorage        00000385  00196758  dCtlRefNum         #-52  0019675A  dCtlCurTicks       #1664992  0019675E  dCtlWindow         001967B0  00196762  dCtlDelay          #0  00196764  dCtlEMask          #0  00196766  dCtlMenu           #0 </pre>               </td></TR>         </TABLE><br>                  <p id=p4>For those of you familiar with 68K drivers, this DCE will         look somewhat strange. For example, the         <CODE>dCtlWindow</CODE> field is not nil, which is fine for         a desk accessory but very weird for a disk driver. These         inconsistencies exist because this is a native driver's DCE.         For native drivers, the Device Manager reuses certain DCE         fields to store its internal state.</P>                  <TABLE BORDER=0 CELLPADDING=5 WIDTH=550> <TR> <td bgcolor="#e6e6e6" align=left>                  <p id=p4><B>IMPORTANT:<BR>                                    </B>The format of the DCE for native drivers is                  officially undocumented and may change in future                  system releases. While this Q&amp;A discusses some                  details of this, this discussion is for debugging                  purposes only. Do not put dependencies on the                  format of a native driver's DCE in your code.               </p></td></TR>         </TABLE><br>                  <p id=p4>One item stored by the Device Manager in the native         driver's DCE is the CFM closure ID for the driver's code         fragment, which is stored in the <CODE>dCtlStorage</CODE>         field. In the above example, this closure ID is <CODE>$00000385</CODE>.         You can find the corresponding code fragment using         <CODE>frags</CODE>. While <CODE>frags</CODE> does not allow         you to look up a fragment by closure ID, you can display all         of the fragments and then search the output for the fragment         with the correct ID. You can make your life easier by only         dumping the fragments in the system context (the <CODE>-c         1</CODE> argument to <CODE>frags</CODE>) and by noticing         that the displayed connection and closure IDs are typically         sorted by ID number.</P>                  <TABLE BORDER=0 CELLPADDING=5 WIDTH=550>             <TR>               <td bgcolor="#e6e6e6" align=left>                  <pre>&gt;&gt;&gt; frags -c 1 CFM Info for fragments in all contexts.  &lt;System Context&gt;                   heap zone @ 00002800, contextID = 00000001...        OTKernelUtilLib            connID = 000003D4 (closureID = 000003D3)        OTKernelContextLib         connID = 000003D5        OTNtvUtilLib               connID = 000003CF (closureID = 00000424)        OTUtilityLib               connID = 000003D0        OTStackSwapLib             connID = 000003CD (closureID = 000003CC)        OTGlobalLib                connID = 000003C8 (closureID = 000003CA)        RootLibrary                connID = 000003C4 (closureID = 000003C3)        SLMGlobal                  connID = 000003BE (closureID = 000003BD)        USBHIDKeyboardModule       connID = 00000390 (closureID = 0000038F)        ^FFE22770                  connID = 00000386 (closureID = 00000385)        USBImationSuperDiskClass   connID = 0000036E (closureID = 0000036D)        USB Software Locator       connID = 00000331 (closureID = 00000330)        USBHIDAppleMouseModule     connID = 00000307 (closureID = 00000306)        CursorDevicesLib           connID = 00000308...</pre>               </td></TR>         </TABLE><br>                  <p id=p4>In this case, the fragment with a closure ID of <CODE>$00000385</CODE>         is named "^FFE22770" (a unique name generated by the USB         Manager). Once you know the name, you can use         <CODE>frags</CODE> to display information about the         fragment.</P>                  <TABLE BORDER=0 CELLPADDING=5 WIDTH=550>             <TR>               <td bgcolor="#e6e6e6" align=left>                  <pre>&gt;&gt;&gt; frags -a "^FFE22770" CFM Info for fragments in all contexts.  Finder                             heap zone @ 03AFE920, contextID = 01C30001  &lt;System Context&gt;                   heap zone @ 00002800, contextID = 00000001        ^FFE22770                              connID = 00000386 (closureID = 00000385)           pef @ FFE22770, flags = 00, symbols #2           sect #0: @ FFE227F0-FFE2B244 exec,  use = #1, length = #35412           sect #1: @ 0054FEC0-00555708 data,  use = #1, length = #22600              DoDriverIO                        tvec 005500E8              TheDriverDescription              data 00553A30            Import Libraries:              DriverLoaderLib        vers=00000000 oldest=00000000              DriverServicesLib      vers=00000000 oldest=00000000              InterfaceLib           vers=00000000 oldest=00000000              NameRegistryLib        vers=00000000 oldest=00000000</pre>               </td></TR>         </TABLE><br>                  <p id=p4>You can now set a breakpoint on the         <CODE>DoDriverIO</CODE> entry point. In this case, the entry         point is a         <a href="../../documentation/mac/runtimehtml/RTArch-146.html">transition         vector</A>, so you must use the <CODE>tvb</CODE> command.         </P>                  <TABLE BORDER=0 CELLPADDING=5 WIDTH=550>             <TR>               <td bgcolor="#e6e6e6" align=left>                  <pre>&gt;&gt;&gt; tvb 5500e8 TVector Break at "DoDriverIO" (TVector at 005500E8) every time</pre>               </td></TR>         </TABLE><br>                  <p id=p4>Once you stop at the transition vector break, you can         look in the PowerPC registers for the parameters to the         <CODE>DoDriverIO</CODE> routine. The prototype for the         <CODE>DoDriverIO</CODE> entry point is shown below.</P>                  <TABLE BORDER=0 CELLPADDING=5 WIDTH=550>             <TR>               <td bgcolor="#e6e6e6" align=left>                  <pre>typedef extern OSErr (*DriverEntryPointPtr)(AddressSpaceID SpaceID,                                            IOCommandID CommandID,                                            IOCommandContents Contents,                                            IOCommandCode Code,                                            IOCommandKind Kind);</pre>               </td></TR>         </TABLE><br>                  <p id=p4>In PowerPC calling conventions, the first parameter is         place in register R3, the next in R4, and so on. The         contents of the registers are summarized by the following         "cheat sheet."</P>                  <TABLE BORDER=1>            <TR>               <TH WIDTH=60>                  <P ALIGN=LEFT>Register</p>               </TH><TH WIDTH=90>                  <P ALIGN=LEFT>Param Name</p>               </TH><TH>                  <P ALIGN=LEFT>Description</p>               </TH></TR>            <TR>               <td valign=top width=60 align=left>                  <p id=p4>R3               </p></td><td valign=top width=90 align=left>                  <p id=p4><CODE>SpaceID</CODE>               </p></td><td valign=top align=left>                  <p id=p4>The target address space, always -1                  (<CODE>kCurrentAddressSpace</CODE>) on current                  systems.               </p></td></TR>            <TR>               <td valign=top width=60 align=left>                  <p id=p4>R4               </p></td><td valign=top width=90 align=left>                  <p id=p4>CommandID               </p></td><td valign=top align=left>                  <p id=p4>An opaque value allocated by the system.               </p></td></TR>            <TR>               <td valign=top width=60 align=left>                  <p id=p4>R5               </p></td><td valign=top width=90 align=left>                  <p id=p4><CODE>Contents</CODE>               </p></td><td valign=top align=left>                  <p id=p4>For typical requests (Read, Write, Control,                  Status) this is basically a                  <CODE>ParmBlkPtr</CODE>.               </p></td></TR>            <TR>               <td valign=top width=60 align=left>                  <p id=p4>R6               </p></td><td valign=top width=90 align=left>                  <p id=p4><CODE>Code</CODE>               </p></td><td valign=top align=left>                  <p id=p4>The type of request, 0 for Open, 1 for Close, 2                  for Read, 3 for Write, 4 for Control, and 5 for                  Status. Other request types are described in                  "Devices.h".               </p></td></TR>            <TR>               <td valign=top width=60 align=left>                  <p id=p4>R7               </p></td><td valign=top width=90 align=left>                  <p id=p4><CODE>Kind</CODE>               </p></td><td valign=top align=left>                  <p id=p4>The mode of the request, 1 for synchronous, 2                  for asynchronous, 3 for immediate.               </p></td></TR>         </TABLE><br>                  <p id=p4>You can use this information to break on a specific set         of requests to the driver. For example, the following breaks         on all Control requests.</P>                  <TABLE BORDER=0 CELLPADDING=5 WIDTH=550>             <TR>               <td bgcolor="#e6e6e6" align=left>                  <pre>&gt;&gt;&gt; tvb 5500e8 r6=4 TVector Break at "DoDriverIO" (TVector at 005500E8) when r6=4</pre></td></TR>         </TABLE><br>                  <p id=p4>You can even look at the content of the parameter block.         For example the following breaks on all Driver Gestalt         requests (a Status request with <CODE>csCode</CODE> set to         <CODE>kDriverGestaltCode</CODE> (43)).</P>                  <TABLE BORDER=0 CELLPADDING=5 WIDTH=550>             <TR>               <td bgcolor="#e6e6e6" align=left>                  <pre>&gt;&gt;&gt; tvb 5500e8 ((r6=5)&amp;((r5+1a)^.w=#43.w)) TVector Break at "DoDriverIO" (TVector at 005500E8) when ((r6=5)&amp;((r5+1a)^.w=#43.w))</pre></td></TR>         </TABLE><br>                  <p id=p4>References</p>                  <UL>            <LI>The            <a href="http://developer.apple.com/tools/debuggers/MacsBug/index.html">MacsBug            Reference and Debugging Guide</A> is an excellent            reference for 68K debugging in MacsBug. Unfortunately it            hasn't been updated for PowerPC debugging.</li>                        <LI>For PowerPC MacsBug debugging, the best place to            start is the MacsBug built-in help; to get that, simply            type <CODE>help</CODE> in MacsBug.</li>                        <LI>To truly understand assembly language debugging, you            need to be familiar with the Mac OS 68K and PowerPC            runtime architectures, both of which as well described in            <a href="../../documentation/mac/runtimehtml/RTArch-2.html">Mac            OS Runtime Architectures</A>.</li>                        <LI>For general information about writing disk drivers,            the best place to start is Technote 1189            <a href="../../technotes/tn/tn1189.html">The            Monster Disk Driver Technote</A>.</li>                        <LI>For a full list of request codes for disk drivers,            see the MoreDisks module of the DTS sample            <A HREF="ftp://ftp.apple.com/developer/Sample_Code/Overview/MoreIsBetter.sit">MoreIsBetter</A>.</li>                  </UL> </td>       </tr></table></CENTER><!-- end_content --><!-- begin_date --><H4 ALIGN=center>[Feb 28 2000]</H4><!-- end_date --><!-- begin_footer_information -->	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/qa/dv/dv41.html%3Fid%3DDTS10001182-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/qa/dv/dv41.html%3Fid%3DDTS10001182-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/qa/dv/dv41.html%3Fid%3DDTS10001182-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>
<!--#include virtual="/includes/footer"--><!-- end_footer_information --> <hr width=500 align=center> </BODY> </HTML>