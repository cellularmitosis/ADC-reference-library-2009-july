 /*--------------------------	Inclusions--------------------------*/#include <QuickDraw.h>#include <Windows.h>#include <OSUtils.h>#include <FixMath.h>#include "BigEasy2.h"#include "BigEasyTextish.h"#include "BigEasyDialogs.h"#include "MusicHelper.h"#include "FlatInstrumentTest.h"typedef unsigned long uuuulong;		/* hmmmm what is this, sheesh */// еее typedef pascal void (*TunePlayCallBackProcPtr)(uuuulong *event,long seed,long refCon);#define kTuneSetNoteChannelsSelect kTuneLastSelector#define kTuneSetPartTransposeSelect kTuneLastSelector+1#if 0enum	{	kTuneQuickStart = 8				/* Leave all the controllers where they are, ignore start time */	};pascal ComponentResult TuneSetNoteChannels(TunePlayer tp,		unsigned long count,NoteChannel *noteChannelList,		TunePlayCallBackProcPtr playCallBackProc,		long refCon)	 FIVEWORDINLINE(0x2F3C, 16, kTuneSetNoteChannelsSelect, 0x7000, 0xA82A);pascal ComponentResult TuneSetPartTranspose(TunePlayer tp,		unsigned long part,		long transpose,		long velocityShift)	 FIVEWORDINLINE(0x2F3C, 12, kTuneSetPartTransposeSelect, 0x7000, 0xA82A);#endif/*--------------------------	Limits and Konstants--------------------------*/enum	{	mOpen = 100,	mClose	};#define kTunePlayerCount 3typedef struct	{	WindowPtr w;	NoteAllocator na;	TunePlayer tp[kTunePlayerCount];	short tpStep;	ToneDescription td;	MusicScore ms;	Handle headerH,tuneH;	} Globals;Globals g;/*--------------------------	Prototypes--------------------------*/static void DrawDoc(short n);static void ClickDoc(short n,Point p,short mods);static void KeyDoc(short n,short key,short code,short mods);static void IdleDoc(short n, Boolean front);static void GoAwayDoc(short n);static void ActivateDoc(short n);static void DeactivateDoc(short n);static void LetsQuit(short n,short menuItem,short menuRef);static void OpenWindow(short n,short menuItem,short menuRef);static void InitVars(void);static pascal Boolean MyFilterProc(DialogPtr theDialog,		EventRecord *theEvent,short *itemHit);		/*--------------------------	Computer Programs--------------------------*/#define kHeaderHeight 17void DrawDoc(short n)/* * Draws the window. */	{	EraseRect(&gBigRect);	MoveTo(10,20);	DrawString("\pClick in window to play.");	MoveTo(10,40);	DrawString("\pOption-click to save movie.");	}#define knccount 10void ClickDoc(short n,Point p,short mods)/* * Come here for a click in the window. */	{	ComponentResult result;	NoteChannel nc[knccount];	Boolean ourNC;	short i;	TunePlayer tp;	tp = g.tp[g.tpStep];	g.tpStep = (g.tpStep + 1 ) % kTunePlayerCount;	if(!g.headerH)		{		g.headerH = GetMusicScoreHeader(g.ms);		HLock(g.headerH);		}	if(!g.tuneH)		{		g.tuneH = GetMusicScoreScore(g.ms);		HLock(g.tuneH);		}#if 0	if(mods & shiftKey)		{		NoteRequest nr;		ourNC = true;		result = NAStuffToneDescription(g.na,(p.h & 127) + 1,&nr.tone);		nr.polyphony = 1;		nr.typicalPolyphony = fixed1;		result = NANewNoteChannel(g.na,&nr,&nc[0]);		for(i = 1; i < knccount; i++)			nc[i] = nc[0];		result = TuneSetNoteChannels(tp,knccount,nc,nil,0);		}	else if (!(mods & controlKey))#endif		{		result = TuneSetHeader(tp,*(unsigned long **)g.headerH);		ourNC = false;		}#if 0	for(i = 0; i < knccount; i++)		result = TuneSetPartTranspose(tp,i,((p.v & 63) - 32)<<8,0);#endif	TuneQueue(tp,		*(unsigned long **)g.tuneH,		fixed1,		0,		0x7FFFFFFF,		kTuneStartNow,//		kTuneStartNow + ((mods & controlKey) ? kTuneQuickStart : 0),		nil,		0);	while(Button());	if(mods & (shiftKey | cmdKey))		{		TuneFlush(tp);		TuneStop(tp,0);		}	if(ourNC)		NADisposeNoteChannel(g.na,nc[0]);	if(mods & optionKey)		{		MusicMovie mm;		StandardFileReply sfr;		StandardPutFile("\pSave Music Movie:","\pTunetest",&sfr);		if(sfr.sfGood)			{			mm = StartMusicMovie(&sfr.sfFile,g.headerH);			AddMusicMovieSample(mm,g.tuneH);			FinishMusicMovie(&mm);			}		}	}#define kOptionA (0xFF & (unsigned short)'М')void KeyDoc(short n,short key,short code,short mods)	{	MusicScore ms1,ms2;	Handle header,tune1,tune2;	if(key >= 'a' && key <= 'z')		key += 'A' - 'a';	if(key == 'A' || key == 'B' || key == kOptionA)		{		ms1 = NewMusicScore();		AddMusicScoreGMInstrument(ms1,1);		/* piano */		ms2 = NewMusicScore();		AddMusicScoreGMInstrument(ms2,1);		/* piano */		AddMusicScoreNote(ms1,1,60,100,600);		AddMusicScoreRest(ms1,20);		AddMusicScoreNote(ms2,1,80,70,600);		AddMusicScoreRest(ms2,300);		header = GetMusicScoreHeader(ms1);		tune1 = GetMusicScoreScore(ms1);		tune2 = GetMusicScoreScore(ms2);		HLock(header);		HLock(tune1);		HLock(tune2);		TuneSetHeader(g.tp[0],*(unsigned long **)header);		TuneQueue(g.tp[0],			*(unsigned long **)tune1,			fixed1,			0,			0x7FFFFFFF,			kTuneStartNewMaster,			nil,			0);		TuneQueue(g.tp[0],			*(unsigned long **)tune2,			fixed1,			0,			0x7FFFFFFF,			0 + (key == 'A' ? 0 : kTuneDontClipNotes),			nil,			0);		if(key == kOptionA)			{			MusicMovie mm;			StandardFileReply sfr;				StandardPutFile("\pSave Music Movie:","\pTunetest",&sfr);			if(sfr.sfGood)				{				mm = StartMusicMovie(&sfr.sfFile,header);				AddMusicMovieSample(mm,tune1);				AddMusicMovieSample(mm,tune2);				FinishMusicMovie(&mm);				}			}		}	}void IdleDoc(short n, Boolean front)	{	#pragma unused (n,front)	}void GoAwayDoc(short n)/* * Close that window... */	{	UninstallWindow(n);	}void ActivateDoc(short n)	{#pragma unused (n) 	SetMenuItem(mClose,1,0,0,nil);				/* enable "Close" menu item		*/	SetMenuItem(mOpen,-1,0,0,nil);				/* disable "Open" menu item		*/	}void DeactivateDoc(short n)	{#pragma unused (n)	SetMenuItem(mClose,-1,0,0,nil);				/* disable "Close" menu item	*/	SetMenuItem(mOpen,1,0,0,nil);				/* enable "Open" menu item		*/	}void LetsQuit(short n,short menuItem,short menuRef)	{#pragma unused (n,menuItem,menuRef)	gQuitApp++;	}#define kWindowWidth 220#define kWindowHeight 140void OpenWindow(short n,short menuItem,short menuRef)	{#pragma unused (n,menuItem,menuRef)	Rect r;	SetRect(&r,0,0,kWindowWidth,kWindowHeight);	OffsetRect(&r,20,40);	g.w = InstallWindow(1,"\p",&r,0,wCopyDraw,								DrawDoc,ClickDoc,KeyDoc,nil,								ActivateDoc,DeactivateDoc,IdleDoc);	}Fixed FRandom(Fixed low,Fixed high);Fixed FRandom(Fixed low,Fixed high)	{	unsigned long x,y;	x = Random();	x &= 0xFFFF;	y = Random();	y &= 0xFFFF;	x <<= 16;	x = x % (high - low + 1);	x += low;	return (Fixed) x;	}void DoBeat1(void);void DoBeat1(void)	{	long tu,d;	tu = 100;	d = 300;/* 1 */	AddMusicScoreNote(g.ms,1,0x3200,127,d*5);	AddMusicScoreNote(g.ms,1,0x3244,100,d*5);	AddMusicScoreNote(g.ms,2,60,120,d);	AddMusicScoreNote(g.ms,2,90,120,d);	AddMusicScoreRest(g.ms,tu*2);/* 2 */	AddMusicScoreNote(g.ms,2,63,120,d);	AddMusicScoreNote(g.ms,3,93,90,d);	AddMusicScoreNote(g.ms,3,88,90,d);	AddMusicScoreRest(g.ms,tu*2);/* 3 */	AddMusicScoreNote(g.ms,2,60,120,d);	AddMusicScoreNote(g.ms,2,92,120,d);	AddMusicScoreRest(g.ms,tu*1);	AddMusicScoreNote(g.ms,2,91,120,d);	AddMusicScoreRest(g.ms,tu*2);/* (4) */	AddMusicScoreNote(g.ms,2,92,120,d);	AddMusicScoreRest(g.ms,tu*1);/* 5 */	AddMusicScoreNote(g.ms,2,93,120,d);	AddMusicScoreNote(g.ms,2,60,120,d);	AddMusicScoreRest(g.ms,tu*2);/* 6 */	AddMusicScoreNote(g.ms,1,0x2200,80,d*5);	AddMusicScoreNote(g.ms,1,0x2244,80,d*5);	AddMusicScoreNote(g.ms,2,63,120,d);	AddMusicScoreRest(g.ms,tu*2);/* 7 */	AddMusicScoreNote(g.ms,1,0x3900,80,d*5);	AddMusicScoreNote(g.ms,1,0x3244,80,d*5);	AddMusicScoreNote(g.ms,2,60,120,d);	AddMusicScoreNote(g.ms,2,92,120,d);	AddMusicScoreRest(g.ms,tu*1);	AddMusicScoreNote(g.ms,3,92,120,d);	AddMusicScoreNote(g.ms,3,87,86,d);	AddMusicScoreNote(g.ms,2,91,80,d);	AddMusicScoreRest(g.ms,tu*1);/* 8 */	AddMusicScoreNote(g.ms,2,91,120,d);	AddMusicScoreRest(g.ms,tu*1);	AddMusicScoreNote(g.ms,2,92,120,d);	AddMusicScoreRest(g.ms,tu*1);	}void InitVars()/* * Called once at startup: yes, it * inits the vars. */	{	ComponentResult result;	short i;	Fixed p;	FlatInstrument *flatInstrument,*flatInstrument2;	flatInstrument2 = CreateFlatInstrument();	flatInstrument = CreateFlatInstrumentFromSnd(1010);	g.na = OpenDefaultComponent('nota',0);	g.tpStep = 0;	for(i = 0; i < kTunePlayerCount; i++)		g.tp[i] = OpenDefaultComponent('tune',0);	g.ms = NewMusicScore();	AddMusicScoreGMInstrument(g.ms,1);		/* piano *///	AddMusicScoreGMInstrument(g.ms,53);//	AddMusicScoreGMInstrument(g.ms,12);		/* vibraphone */	AddMusicScoreFlatInstrument(g.ms,flatInstrument2);		/* ringmods */	AddMusicScoreFlatInstrument(g.ms,flatInstrument);		/* boomp */#if 1	DoBeat1();#else#define kTimeUnit 400	for(i = 0; i < 12; i++)		{		AddMusicScoreNote(g.ms,1,60+i,100,kTimeUnit*3/4);		AddMusicScoreNote(g.ms,2,60+i,80,kTimeUnit);		p = i+60;		p<<=16;		AddMusicScoreNote(g.ms,2,i+55,				80,kTimeUnit/2);		AddMusicScoreRest(g.ms,kTimeUnit/2);		AddMusicScoreNote(g.ms,2,i+55,				90,kTimeUnit/4);		AddMusicScoreRest(g.ms,kTimeUnit/4);		AddMusicScoreNote(g.ms,2,i+55,				80,kTimeUnit/4);		AddMusicScoreRest(g.ms,kTimeUnit/4);		}	AddMusicScoreNote(g.ms,1,48,100,kTimeUnit*9);	AddMusicScoreNote(g.ms,2,52,60,kTimeUnit*9);	AddMusicScoreNote(g.ms,2,55,60,kTimeUnit*9);	AddMusicScoreNote(g.ms,2,(55L<<8) | 0x10,60,kTimeUnit*9);	AddMusicScoreNote(g.ms,1,72,60,kTimeUnit*9);	AddMusicScoreRest(g.ms,10);	AddMusicScoreNote(g.ms,1,79,100,kTimeUnit*9);	AddMusicScoreRest(g.ms,10);	AddMusicScoreNote(g.ms,1,84,90,kTimeUnit*9);	AddMusicScoreRest(g.ms,kTimeUnit*14);#endif	}void AddMusicScoreNote(MusicScore ms,		short part,Fixed pitch,long velocity,TimeValue noteDuration);void AddMusicScoreRest(MusicScore ms,TimeValue restDuration);void Bootstrap()	{	InitVars();/*** File Menu ***/	InstallMenu("\pFile",nil,0);	InstallMenuItem("\pQuit/Q",LetsQuit,0);/*** Edit Menu ***/	InstallEditMenu(nil,nil,nil,nil,nil);/*** Picker Menu ***/	InstallMenu("\pTune",nil,0);	OpenWindow(0,0,0);	}void Hatstrap()/*  * clean up  */	{	short i;	for(i = 0; i < kTunePlayerCount; i++)		CloseComponent(g.tp[i]);	}pascal Boolean MyFilterProc(DialogPtr theDialog,		EventRecord *theEvent,short *itemHit)	{	GrafPort *oldPort;	GetPort(&oldPort);	SetPort(theDialog);	if(theEvent->what == updateEvt && (DialogPtr)theEvent->message != theDialog)			HandleUpdateEvent(theEvent);	SetPort(oldPort);	return false;	}