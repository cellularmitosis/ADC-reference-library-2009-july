<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/1998/REC-html40-19980424/loose.dtd">
<html>
<head>
<title>IOPCCard16Device</title>
<meta http-equiv="Content-Type" content="text/html; charset=ascii">
<meta name="generator" content="HeaderDoc">
<style><!--
#tocMenu {
		display: block;
		position:fixed;
		top:0px;
		left:0px;
		width:210px;
		height:100%;
		background:transparent;
}
#bodyText {
		margin-left: 210px;
}
--></style>
<meta id="toc-file" name="toc-file" content="toc.html">
<script language="JavaScript" src="../../../../../../Resources/JavaScript/page.js" type="text/javascript"></script><link rel="stylesheet" type="text/css" href="../../../../../../Resources/CSS/frameset_styles.css">
<style type="text/css"><!--.keyword {background:#ffffff; color:#761550;}.template {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.function {background:#ffffff; color:#000000;}.string {background: #ffffff; color:#891315;}.preprocessor {background:#ffffff; color:#236e25}.comment {background:#ffffff; color:#236e25}.char {background: #ffffff; color:#0000ff;}.var {background:#ffffff; color:#000000;}.type {background:#ffffff; color:#761550;}.param {background:#ffffff; color:#000000;}.graybox {         border-top: 1px solid #919699;         border-left: 1px solid #919699;         margin-bottom: 10px;         }  .graybox th {         padding: 4px 8px 4px 8px;         background: #E2E2E2;         font-size: 12px;         font-weight: bold;         border-bottom: 1px solid #919699;         border-right: 1px solid #919699;         }  .graybox td {         padding: 8px;         font-size: 12px;         text-align: left;         vertical-align: top;         border-bottom: 1px solid #919699;         border-right: 1px solid #919699;         }  --></style>
</head>
<body bgcolor="#ffffff" onload="initialize_page();">
<noscript>
<div id="tocMenu">
<iframe id="toc_content" name="toc_content" src="toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
</div>
</noscript>
<div id="bodyText">
<!-- start of header -->

<!-- start of header -->
<!--#include virtual="/includes/framesetheader"-->
<!-- end of header -->

<table width="600"><tr><td scope="row">
<!-- begin breadcrumb insert request --><font face="Geneva,Helvetica,Arial" size="1">
 <a target="_top" href="http://developer.apple.com">ADC Home</a> <b>&gt;</b> <a href="../../../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> <b>&gt;</b> <a href="../../../../../../../reference/index.html#//apple_ref/doc/uid/TP30001281" target="_top">Reference</a> <b>&gt;</b> <a href="../../../../../../../reference/Darwin/index.html#//apple_ref/doc/uid/TP30001281-TP30000422" target="_top">Darwin</a> <b>&gt;</b> <a href="../../../index.html#//apple_ref/doc/framework/kernel_fw_leo" target="_top">Kernel Framework Reference</a></font>
<!-- end breadcrumb insert request -->
<p>&#160;</p>
</td></tr></table>
<!-- end of header --><a name="top"></a>
<a name="//apple_ref/doc/class/IOPCCard16Device" title="IOPCCard16Device"></a>
<hr>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h1><a name="IOPCCard16Device">IOPCCard16Device</a></h1>
</td></tr></table>
<div class="spec_sheet_info_box"><table cellspacing="0" class="specbox">
<tr>
<td scope="row"><b>Inherits from:</b></td>
<td><div style="margin-bottom:1px"><div class="content_text">
<a href="../../../IOService_h/Classes/IOService/index.html#//apple_ref/cpp/cl/IOService" target="_top">IOService</a>
</div></div></td>
</tr>
<tr>
<td scope="row"><b>Declared In:</b></td>
<td><div style="margin-bottom:1px"><div class="content_text"><a href="../../index.html" target="_top">IOPCCard16Device.h</a></div></div></td>
</tr>
</table></div>
<h2>Overview</h2>
<p><!-- begin abstract --></p>
<p>Class that represents a 16-bit PC Card device.
<!-- end abstract --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p><b>Introduction</b>    
</p>
<p>After the discovery of a 16-bit PC Card, the PC Card Family creates
and publishes an instance of the IOPCCard16Device provider nub.
This nub provides the driver with methods to handle card
initialization, simplified memory and I/O window management, and
access to Card Services.
</p>
<p>Typically, drivers that attach to the IOPCCard16Device nub will either
subclass from another IOKit family or directly from IOService.  The
IOPCCard16Device class is not meant to be subclassed.
</p>
<p>Writing drivers for 16-bit PC Cards should be very similar to writing
drivers for PCI or CardBus devices.  The main difference is that a
card's configuration will also need to be selected before the card can
be used.  Once the configuration is selected, the mapping of register windows works exactly as with PCI or CardBus device.  Most
drivers should never need to make a Card Services call to support their
card.
</p>
<p>The IOPCCard16Device class defers much of its work to an instance of
IOPCCard16Enabler class.  The enabler does the work of finding,
ordering, reserving, and enabling possible card configurations.  It
handles the details of requesting and releasing individual elements of
that configuration from Card Services.  The PC Card Family provides a
default enabler that should handle most cards.  The default enabler is
automatically installed for you.
</p>
<p>During sleep, PC Cards are completely powered off.  When power is
returned, cards are automatically reconfigured and left in basically the
same state as if the configure method had just been called.  The
driver is responsible for saving any additional card state across this
power management event or it can just reinitialize the card from scratch.
The driver should also protect itself at this time from outside events
and try to avoid touching the hardware.  Typical events include: user
requests, spurious interrupts, timer events, card ejection events, ...
</p>
<p>When cards are powered down from the menu bar or physically ejected,
the driver will first receive a Card Services event through its
message method before being terminated. Power management events are
handled in the usual IOKit manner.
</p>
<p><b>Types of Driver Matching Supported by IOPCCard16Device</b>
</p>
<p>Matching is done by comparing the driver's matching properties against
information retrieved from the PC Card's CIS information.  In addition to
what is provided by IOService, the following types of matching are
supported:
</p>
<p><b>"IONameMatch"</b>
</p>
<p>The "IONameMatch" property matches the name give by the PC Card Bridge
driver to a card's driver.  Normally, this name will be of the form
"pccardX,Y", where X is the manufacturer ID and Y is the card ID.
Both IDs are taken from the tuple CISTPL_MANFID.
</p>
<p>If the card has no CIS on it, the name will be "pccard-no-cis".  If
the card has CIS but it does not have the CISTPL_MANFID tuple the name
will be "pccard-no-manfid".
</p>
<p><b>"VersionOneInfo"</b>
</p>
<p>The "VersionOneInfo" property match is based on the CISTPL_VERS_1
tuple.  It matches against an array of strings, where each string is
one of the entries from the version one tuple.  Trailing entries that are
omitted from the driver's matching entry are treated as wild matches.
</p>
<p><b>"FunctionName"</b>
</p>
<p>The "FunctionName" property match is based on the CISTPL_FUNCID tuple.
The following function type strings are supported:
</p>
<p>"Multi-Function", "Memory", "Serial Port", "Parallel Port",
"Fixed Disk", "Video Adapter", "Network Adapter", "AIMS",
"SCSI", "Security", "Instrument", "Vendor-Specific", "Anonymous"
</p>
<p>The "Anonymous" string is used if no CIS information was found on the card.	
</p>
<p><b>"FunctionID"</b>
</p>
<p>The "FunctionID" property match is is also based on the CISTPL_FUNCID tuple.
Instead of looking for a string, it matches on the actual ID number.
</p>
<p><b>"VendorID"</b>
</p>
<p>The "VendorID" property match is based on the manufacturer ID in the
CISTPL_MANFID tuple.
</p>
<p><b>"DeviceID"</b>
</p>
<p>The "DeviceID" property match is based on the device ID in the CISTPL_MANFID tuple.
</p>
<p><b>"MemoryDeviceName"</b>
</p>
<p>The "MemoryDeviceName" property match is based on the CISTPL_DEVICE
and CISTPL_DEVICE_A tuples.  It matches against the following memory
types:
</p>
<p>"ROM", "OTPROM", "EPROM", "EEPROM", "Flash",
"SRAM",	"DRAM",	"Function Specific", "Extended"
<!-- end discussion -->
</p>
<hr>
<br><h2>Functions</h2>
<a name="HeaderDoc_functions"></a>
<dl>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOPCCard16Device/cardServices/int/(int,void*,void*,void*)" target="_top">cardServices</a></tt></dt>
<dd><p>Makes a call to Card Services.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOPCCard16Device/configure/bool/(UInt32)" target="_top">configure</a></tt></dt>
<dd><p>Selects a 16-bit card configuration and enables it for use.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOPCCard16Device/getCardServicesHandle/client_handle_t/()" target="_top">getCardServicesHandle</a></tt></dt>
<dd><p>Returns the Card Services client handle for this card.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOPCCard16Device/getConfigurationInfo/bool/(config_info_t*)" target="_top">getConfigurationInfo</a></tt></dt>
<dd><p>Returns information on the card's current configuration.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOPCCard16Device/getState/u_int/()" target="_top">getState</a></tt></dt>
<dd><p>Returns the current state of the card.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOPCCard16Device/getWindowAttributes/bool/(UInt32,UInt32*)" target="_top">getWindowAttributes</a></tt></dt>
<dd><p>Returns the attributes of this window.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOPCCard16Device/getWindowCount/UInt32/()" target="_top">getWindowCount</a></tt></dt>
<dd><p>Returns the number of windows that have been configured.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOPCCard16Device/getWindowHandle/bool/(UInt32,window_handle_t*)" target="_top">getWindowHandle</a></tt></dt>
<dd><p>Returns the Card Services handle for this window.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOPCCard16Device/getWindowOffset/bool/(UInt32,UInt32*)" target="_top">getWindowOffset</a></tt></dt>
<dd><p>Returns the offset that this window is currently at.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOPCCard16Device/getWindowSize/UInt32/(UInt32)" target="_top">getWindowSize</a></tt></dt>
<dd><p>Returns the size of this window.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOPCCard16Device/getWindowType/UInt32/(UInt32)" target="_top">getWindowType</a></tt></dt>
<dd><p>Returns the window type.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOPCCard16Device/installEnabler/bool/(IOPCCard16Enabler*)" target="_top">installEnabler</a></tt></dt>
<dd><p>Installs an alternate 16-bit PC Card enabler.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOPCCard16Device/ioDeviceMemory/IODeviceMemory*/()" target="_top">ioDeviceMemory</a></tt></dt>
<dd><p>Accessor to the I/O space aperture for this bus.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOPCCard16Device/ioRead16/UInt16/(UInt16,IOMemoryMap*)" target="_top">ioRead16</a></tt></dt>
<dd><p>Reads a 16-bit value from an I/O space aperture.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOPCCard16Device/ioRead32/UInt32/(UInt16,IOMemoryMap*)" target="_top">ioRead32</a></tt></dt>
<dd><p>Reads a 32-bit value from an I/O space aperture.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOPCCard16Device/ioRead8/UInt8/(UInt16,IOMemoryMap*)" target="_top">ioRead8</a></tt></dt>
<dd><p>Reads an 8-bit value from an I/O space aperture.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOPCCard16Device/ioWrite16/void/(UInt16,UInt16,IOMemoryMap*)" target="_top">ioWrite16</a></tt></dt>
<dd><p>Writes a 16-bit value to an I/O space aperture.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOPCCard16Device/ioWrite32/void/(UInt16,UInt32,IOMemoryMap*)" target="_top">ioWrite32</a></tt></dt>
<dd><p>Writes a 32-bit value to an I/O space aperture.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOPCCard16Device/ioWrite8/void/(UInt16,UInt8,IOMemoryMap*)" target="_top">ioWrite8</a></tt></dt>
<dd><p>Writes an 8-bit value to an I/O space aperture.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOPCCard16Device/setWindowOffset/bool/(UInt32,UInt32)" target="_top">setWindowOffset</a></tt></dt>
<dd><p>Sets the offset for this window.
</p></dd>
<dt><tt><a href="index.html#//apple_ref/cpp/instm/IOPCCard16Device/unconfigure/bool/()" target="_top">unconfigure</a></tt></dt>
<dd><p>Unconfigures a card.
</p></dd>
</dl>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOPCCard16Device/cardServices/int/(int,void*,void*,void*);  indexgroup=PCCard ;   name=IOPCCard16Device::cardServices --><a name="//apple_ref/cpp/instm/IOPCCard16Device/cardServices/int/(int,void*,void*,void*)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="cardServices">cardServices</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Makes a call to Card Services.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <!-- a --><span class="type">int</span><!-- /a --> <!-- a --><span class="function">cardServices</span><!-- /a -->(
    <!-- a --><span class="type">int</span><!-- /a --> <span class="param">func</span>,
    <a href="../../../../../../GraphicsImaging/Reference/ImageCaptureDeviceModulesReference/ICADevice/CompositePage.html#//apple_ref/c/tdef/void" target="_top" class="type"><span class="type">void</span></a> <span class="type">*</span><!-- a --><span class="type">arg1</span><!-- /a --> = <span class="number">0</span>,
    <a href="../../../../../../GraphicsImaging/Reference/ImageCaptureDeviceModulesReference/ICADevice/CompositePage.html#//apple_ref/c/tdef/void" target="_top" class="type"><span class="type">void</span></a> <span class="type">*</span><!-- a --><span class="type">arg2</span><!-- /a --> = <span class="number">0</span>,
    <a href="../../../../../../GraphicsImaging/Reference/ImageCaptureDeviceModulesReference/ICADevice/CompositePage.html#//apple_ref/c/tdef/void" target="_top" class="type"><span class="type">void</span></a> <span class="type">*</span><!-- a --><span class="type">arg3</span><!-- /a --> = <span class="number">0</span>); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>func</code></dt>
<dd><p>The Card Services function index.</p></dd>
<dt><code>arg1</code></dt>
<dd><p>Argument number one.</p></dd>
<dt><code>arg2</code></dt>
<dd><p>Argument number two.</p></dd>
<dt><code>arg3</code></dt>
<dd><p>Argument number three.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->See "IOKit/pccard/cs.h" for return codes.

<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>This method is used to directly make calls to Card Services.  You should always call Card Services using this method.  This will ensure that it is run on the correct IOPCCardBridge workloop.  See the file "doc/PCMCIA-PROG" in the IOPCCardFamily Darwin project and header file "IOKit/pccard/cs.h" for more info.<br><br><i>In most cases, you should never need to use this method and its misuse will cause problems.</i>
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOPCCard16Device/configure/bool/(UInt32);  indexgroup=PCCard ;   name=IOPCCard16Device::configure --><a name="//apple_ref/cpp/instm/IOPCCard16Device/configure/bool/(UInt32)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="configure">configure</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Selects a 16-bit card configuration and enables it for use.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <!-- a --><span class="type">bool</span><!-- /a --> <!-- a --><span class="function">configure</span><!-- /a -->(
    <!-- a --><span class="type">UInt32</span><!-- /a --> <!-- a --><span class="type">index</span><!-- /a --> = <span class="number">0</span>); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>index</code></dt>
<dd><p>Index of configuration to try.  If no index is given then try all indexes, one by one, until successful.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->Returns true if the card configuration was successful.

<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>This method uses the indicated index from the 16-bit PC Card Configuration Table Entry Tuple, CISTPL_CFTABLE_ENTRY, to allocate resources and properly configure the card.  If the index is not specified, the currently installed enabler will decide the order in which configuration entries are to be tried.  If no index is given, configuration entries are tried one by one until the card is successfully configured. The default enabler sorts entries first by looking for the least number of windows, preferring memory windows over I/O windows.<br><br>After making this call, windows need to be mapped into the kernel virtual address space by using the mapDeviceMemoryWithIndex().  This step is the same as the one you would take in a PCI or Cardbus based driver.  Additional information about the configured windows can be obtained from this class.  This information is sometimes needed when writing a generic driver that matches against multiple cards.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOPCCard16Device/getCardServicesHandle/client_handle_t/();  indexgroup=PCCard ;   name=IOPCCard16Device::getCardServicesHandle --><a name="//apple_ref/cpp/instm/IOPCCard16Device/getCardServicesHandle/client_handle_t/()"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="getCardServicesHandle">getCardServicesHandle</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Returns the Card Services client handle for this card.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <!-- a --><span class="type">client_handle_t</span><!-- /a --> <!-- a --><span class="function">getCardServicesHandle</span><!-- /a -->(
    <span class="param">void</span>); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->Returns Card Services client handle. This should always be successful.

<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>This method returns the Card Services client handle for this card.  This handle is created for the driver when the card was bound to Card Services.  This handle is needed to make most Card Services calls.  In most cases you should not need to use this method.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOPCCard16Device/getConfigurationInfo/bool/(config_info_t*);  indexgroup=PCCard ;   name=IOPCCard16Device::getConfigurationInfo --><a name="//apple_ref/cpp/instm/IOPCCard16Device/getConfigurationInfo/bool/(config_info_t*)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="getConfigurationInfo">getConfigurationInfo</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Returns information on the card's current configuration.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <!-- a --><span class="type">bool</span><!-- /a --> <!-- a --><span class="function">getConfigurationInfo</span><!-- /a -->(
    <!-- a --><span class="type">config_info_t</span><!-- /a --> <span class="type">*</span><span class="param">config</span>); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>config</code></dt>
<dd><p>Pointer to config_info_t structure to be filled in.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->Returns true on success.

<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>This is a convenience method used to call the Card Services call GetConfigurationInfo.  Normally this call is not needed.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOPCCard16Device/getState/u_int/();  indexgroup=PCCard ;   name=IOPCCard16Device::getState --><a name="//apple_ref/cpp/instm/IOPCCard16Device/getState/u_int/()"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="getState">getState</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Returns the current state of the card.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <!-- a --><span class="type">u_int</span><!-- /a --> <!-- a --><span class="function">getState</span><!-- /a -->(
    <span class="param">void</span>); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->Current state of card.  Returns zero if the enabler has not been installed.

<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>This method returns the current state of the card by asking the enabler.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOPCCard16Device/getWindowAttributes/bool/(UInt32,UInt32*);  indexgroup=PCCard ;   name=IOPCCard16Device::getWindowAttributes --><a name="//apple_ref/cpp/instm/IOPCCard16Device/getWindowAttributes/bool/(UInt32,UInt32*)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="getWindowAttributes">getWindowAttributes</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Returns the attributes of this window.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <!-- a --><span class="type">bool</span><!-- /a --> <!-- a --><span class="function">getWindowAttributes</span><!-- /a -->(
    <!-- a --><span class="type">UInt32</span><!-- /a --> <span class="param">index</span>,
    <!-- a --><span class="type">UInt32</span><!-- /a --> <span class="type">*</span><span class="param">attributes</span>); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>index</code></dt>
<dd><p>Index of window.</p></dd>
<dt><code>attributes</code></dt>
<dd><p>Pointer to the attribute flags to be filled in.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->Returns attributes for the window.

<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>This method returns the attributes for the specified window.  The meaning of the attributes flags varies depending on the type of window.  The most useful attributes are the data access width flags for I/O windows.  For definitions of these flags for both types of windows see "IOKit/pccard/cs.h".
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOPCCard16Device/getWindowCount/UInt32/();  indexgroup=PCCard ;   name=IOPCCard16Device::getWindowCount --><a name="//apple_ref/cpp/instm/IOPCCard16Device/getWindowCount/UInt32/()"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="getWindowCount">getWindowCount</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Returns the number of windows that have been configured.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <!-- a --><span class="type">UInt32</span><!-- /a --> <!-- a --><span class="function">getWindowCount</span><!-- /a -->(
    <span class="param">void</span>); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->Returns the number of windows.

<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>This method returns the number of windows in this configuration.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOPCCard16Device/getWindowHandle/bool/(UInt32,window_handle_t*);  indexgroup=PCCard ;   name=IOPCCard16Device::getWindowHandle --><a name="//apple_ref/cpp/instm/IOPCCard16Device/getWindowHandle/bool/(UInt32,window_handle_t*)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="getWindowHandle">getWindowHandle</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Returns the Card Services handle for this window.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <!-- a --><span class="type">bool</span><!-- /a --> <!-- a --><span class="function">getWindowHandle</span><!-- /a -->(
    <!-- a --><span class="type">UInt32</span><!-- /a --> <span class="param">index</span>,
    <!-- a --><span class="type">window_handle_t</span><!-- /a --> <span class="type">*</span><span class="param">handle</span>); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>index</code></dt>
<dd><p>Index to window.</p></dd>
<dt><code>handle</code></dt>
<dd><p>Pointer to the window_handle_t structure to be filled in.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->Returns true if the window handle was found.

<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>This method returns the Card Services handle for the window requested.  This call is only valid for memory windows. Normally this call is not needed.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOPCCard16Device/getWindowOffset/bool/(UInt32,UInt32*);  indexgroup=PCCard ;   name=IOPCCard16Device::getWindowOffset --><a name="//apple_ref/cpp/instm/IOPCCard16Device/getWindowOffset/bool/(UInt32,UInt32*)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="getWindowOffset">getWindowOffset</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Returns the offset that this window is currently at.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <!-- a --><span class="type">bool</span><!-- /a --> <!-- a --><span class="function">getWindowOffset</span><!-- /a -->(
    <!-- a --><span class="type">UInt32</span><!-- /a --> <span class="param">index</span>,
    <!-- a --><span class="type">UInt32</span><!-- /a --> <span class="type">*</span><span class="param">offset</span>); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>index</code></dt>
<dd><p>Index of window.</p></dd>
<dt><code>offset</code></dt>
<dd><p>The current offset for this window.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->Returns true if the returned window offset is valid.

<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>This method returns the current offset for this window into the card's memory space.  This call is only valid for memory windows.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOPCCard16Device/getWindowSize/UInt32/(UInt32);  indexgroup=PCCard ;   name=IOPCCard16Device::getWindowSize --><a name="//apple_ref/cpp/instm/IOPCCard16Device/getWindowSize/UInt32/(UInt32)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="getWindowSize">getWindowSize</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Returns the size of this window.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <!-- a --><span class="type">UInt32</span><!-- /a --> <!-- a --><span class="function">getWindowSize</span><!-- /a -->(
    <!-- a --><span class="type">UInt32</span><!-- /a --> <span class="param">index</span>); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>index</code></dt>
<dd><p>Index of window.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->Returns the size of the window in bytes.

<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>This method returns the size of the window in bytes.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOPCCard16Device/getWindowType/UInt32/(UInt32);  indexgroup=PCCard ;   name=IOPCCard16Device::getWindowType --><a name="//apple_ref/cpp/instm/IOPCCard16Device/getWindowType/UInt32/(UInt32)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="getWindowType">getWindowType</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Returns the window type.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <!-- a --><span class="type">UInt32</span><!-- /a --> <!-- a --><span class="function">getWindowType</span><!-- /a -->(
    <!-- a --><span class="type">UInt32</span><!-- /a --> <span class="param">index</span>); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>index</code></dt>
<dd><p>Index of window.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->Returns IOPCCARD16_MEMORY_WINDOW, IOPCCARD16_IO_WINDOW or IOPCCARD16_BAD_INDEX.

<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>This method is used to find the type of window given its index.  There are two types of windows, I/O and memory.  if they are available in a specific configuration, memory windows will always come first in the list of windows.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOPCCard16Device/installEnabler/bool/(IOPCCard16Enabler*);  indexgroup=PCCard ;   name=IOPCCard16Device::installEnabler --><a name="//apple_ref/cpp/instm/IOPCCard16Device/installEnabler/bool/(IOPCCard16Enabler*)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="installEnabler">installEnabler</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Installs an alternate 16-bit PC Card enabler.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <!-- a --><span class="type">bool</span><!-- /a --> <!-- a --><span class="function">installEnabler</span><!-- /a -->(
    <a href="../../../IOPCCard16Enabler_h/Classes/IOPCCard16Enabler/index.html#//apple_ref/cpp/cl/IOPCCard16Enabler" target="_top" class="type"><span class="type">IOPCCard16Enabler</span></a> <span class="type">*</span><!-- a --><span class="type">customEnabler</span><!-- /a --> = <span class="number">0</span>); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>customEnabler</code></dt>
<dd><p>Pointer in the instance of an alternate enabler.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->Returns true if the enabler was successfully installed.

<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>This method switches out the default enabler for a user-supplied enabler.  It is not necessary to call this method if the default enabler is going to be used.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOPCCard16Device/ioDeviceMemory/IODeviceMemory*/();  indexgroup=PCCard ;   name=IOPCCard16Device::ioDeviceMemory --><a name="//apple_ref/cpp/instm/IOPCCard16Device/ioDeviceMemory/IODeviceMemory*/()"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="ioDeviceMemory">ioDeviceMemory</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Accessor to the I/O space aperture for this bus.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="../../../IODeviceMemory_h/Classes/IODeviceMemory/index.html#//apple_ref/cpp/cl/IODeviceMemory" target="_top" class="type"><span class="type">IODeviceMemory</span></a> <span class="type">*</span> <!-- a --><span class="function">ioDeviceMemory</span><!-- /a -->(
    <span class="param">void</span>); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->A pointer to an IODeviceMemory object for the I/O aperture. The IODeviceMemory is retained by the provider, so is valid while attached, or while any mappings to it exist. It should not be released by the caller.

<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>This method will return a reference to the IODeviceMemory for the I/O aperture of the bus the device is on.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOPCCard16Device/ioRead16/UInt16/(UInt16,IOMemoryMap*);  indexgroup=PCCard ;   name=IOPCCard16Device::ioRead16 --><a name="//apple_ref/cpp/instm/IOPCCard16Device/ioRead16/UInt16/(UInt16,IOMemoryMap*)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="ioRead16">ioRead16</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Reads a 16-bit value from an I/O space aperture.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <!-- a --><span class="type">UInt16</span><!-- /a --> <!-- a --><span class="function">ioRead16</span><!-- /a -->(
    <!-- a --><span class="type">UInt16</span><!-- /a --> <span class="param">offset</span>,
    <a href="../../../IOMemoryDescriptor_h/Classes/IOMemoryMap/index.html#//apple_ref/cpp/cl/IOMemoryMap" target="_top" class="type"><span class="type">IOMemoryMap</span></a> <span class="type">*</span><!-- a --><span class="type">map</span><!-- /a --> = <span class="number">0</span> ); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>offset</code></dt>
<dd><p>An offset into a bus or device's I/O space aperture.</p></dd>
<dt><code>map</code></dt>
<dd><p>If the offset is relative to the beginning of a device's aperture, an IOMemoryMap object for that object should be passed in. Otherwise, passing zero will write the value relative to the beginning of the bus's I/O space.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->The value read in host byte order (big endian on PPC).

<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>This method will read a 16-bit value from a 2-byte aligned offset in an I/O space aperture. If a map object is passed in, the value is read relative to it, otherwise the value is read relative to the I/O space aperture for the bus. This function encapsulates the differences between architectures in generating I/O space operations. An eieio instruction is included on PPC.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOPCCard16Device/ioRead32/UInt32/(UInt16,IOMemoryMap*);  indexgroup=PCCard ;   name=IOPCCard16Device::ioRead32 --><a name="//apple_ref/cpp/instm/IOPCCard16Device/ioRead32/UInt32/(UInt16,IOMemoryMap*)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="ioRead32">ioRead32</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Reads a 32-bit value from an I/O space aperture.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <!-- a --><span class="type">UInt32</span><!-- /a --> <!-- a --><span class="function">ioRead32</span><!-- /a -->(
    <!-- a --><span class="type">UInt16</span><!-- /a --> <span class="param">offset</span>,
    <a href="../../../IOMemoryDescriptor_h/Classes/IOMemoryMap/index.html#//apple_ref/cpp/cl/IOMemoryMap" target="_top" class="type"><span class="type">IOMemoryMap</span></a> <span class="type">*</span><!-- a --><span class="type">map</span><!-- /a --> = <span class="number">0</span> ); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>offset</code></dt>
<dd><p>An offset into a bus or device's I/O space aperture.</p></dd>
<dt><code>map</code></dt>
<dd><p>If the offset is relative to the beginning of a device's aperture, an IOMemoryMap object for that object should be passed in. Otherwise, passing zero will write the value relative to the beginning of the bus's I/O space.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->The value read in host byte order (big endian on PPC).

<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>This method will read a 32-bit value from a 4-byte aligned offset in an I/O space aperture. If a map object is passed in, the value is read relative to it, otherwise the value is read relative to the I/O space aperture for the bus. This function encapsulates the differences between architectures in generating I/O space operations. An eieio instruction is included on PPC.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOPCCard16Device/ioRead8/UInt8/(UInt16,IOMemoryMap*);  indexgroup=PCCard ;   name=IOPCCard16Device::ioRead8 --><a name="//apple_ref/cpp/instm/IOPCCard16Device/ioRead8/UInt8/(UInt16,IOMemoryMap*)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="ioRead8">ioRead8</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Reads an 8-bit value from an I/O space aperture.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <!-- a --><span class="type">UInt8</span><!-- /a --> <!-- a --><span class="function">ioRead8</span><!-- /a -->(
    <!-- a --><span class="type">UInt16</span><!-- /a --> <span class="param">offset</span>,
    <a href="../../../IOMemoryDescriptor_h/Classes/IOMemoryMap/index.html#//apple_ref/cpp/cl/IOMemoryMap" target="_top" class="type"><span class="type">IOMemoryMap</span></a> <span class="type">*</span><!-- a --><span class="type">map</span><!-- /a --> = <span class="number">0</span> ); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>offset</code></dt>
<dd><p>An offset into a bus or device's I/O space aperture.</p></dd>
<dt><code>map</code></dt>
<dd><p>If the offset is relative to the beginning of a device's aperture, an IOMemoryMap object for that object should be passed in. Otherwise, passing zero will write the value relative to the beginning of the bus's I/O space.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->The value read in host byte order (big endian on PPC).

<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>This method will read an 8-bit value from an offset in an I/O space aperture. If a map object is passed in, the value is read relative to it, otherwise the value is read relative to the I/O space aperture for the bus. This function encapsulates the differences between architectures in generating I/O space operations. An eieio instruction is included on PPC.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOPCCard16Device/ioWrite16/void/(UInt16,UInt16,IOMemoryMap*);  indexgroup=PCCard ;   name=IOPCCard16Device::ioWrite16 --><a name="//apple_ref/cpp/instm/IOPCCard16Device/ioWrite16/void/(UInt16,UInt16,IOMemoryMap*)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="ioWrite16">ioWrite16</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Writes a 16-bit value to an I/O space aperture.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="../../../../../../GraphicsImaging/Reference/ImageCaptureDeviceModulesReference/ICADevice/CompositePage.html#//apple_ref/c/tdef/void" target="_top" class="type"><span class="type">void</span></a> <!-- a --><span class="function">ioWrite16</span><!-- /a -->(
    <!-- a --><span class="type">UInt16</span><!-- /a --> <span class="param">offset</span>,
    <!-- a --><span class="type">UInt16</span><!-- /a --> <span class="param">value</span>,
    <a href="../../../IOMemoryDescriptor_h/Classes/IOMemoryMap/index.html#//apple_ref/cpp/cl/IOMemoryMap" target="_top" class="type"><span class="type">IOMemoryMap</span></a> <span class="type">*</span><!-- a --><span class="type">map</span><!-- /a --> = <span class="number">0</span> ); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>offset</code></dt>
<dd><p>An offset into a bus or device's I/O space aperture.</p></dd>
<dt><code>value</code></dt>
<dd><p>The value to be written in host byte order (big endian on PPC).</p></dd>
<dt><code>map</code></dt>
<dd><p>If the offset is relative to the beginning of a device's aperture, an IOMemoryMap object for that object should be passed in. Otherwise, passing zero will write the value relative to the beginning of the bus's I/O space.</p></dd>
</dl>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>This method will write a 16-bit value to a 2-byte aligned offset in an I/O space aperture. If a map object is passed in, the value is written relative to it, otherwise the value is written relative to the I/O space aperture for the bus. This function encapsulates the differences between architectures in generating I/O space operations. An eieio instruction is included on PPC.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOPCCard16Device/ioWrite32/void/(UInt16,UInt32,IOMemoryMap*);  indexgroup=PCCard ;   name=IOPCCard16Device::ioWrite32 --><a name="//apple_ref/cpp/instm/IOPCCard16Device/ioWrite32/void/(UInt16,UInt32,IOMemoryMap*)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="ioWrite32">ioWrite32</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Writes a 32-bit value to an I/O space aperture.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="../../../../../../GraphicsImaging/Reference/ImageCaptureDeviceModulesReference/ICADevice/CompositePage.html#//apple_ref/c/tdef/void" target="_top" class="type"><span class="type">void</span></a> <!-- a --><span class="function">ioWrite32</span><!-- /a -->(
    <!-- a --><span class="type">UInt16</span><!-- /a --> <span class="param">offset</span>,
    <!-- a --><span class="type">UInt32</span><!-- /a --> <span class="param">value</span>,
    <a href="../../../IOMemoryDescriptor_h/Classes/IOMemoryMap/index.html#//apple_ref/cpp/cl/IOMemoryMap" target="_top" class="type"><span class="type">IOMemoryMap</span></a> <span class="type">*</span><!-- a --><span class="type">map</span><!-- /a --> = <span class="number">0</span> ); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>offset</code></dt>
<dd><p>An offset into a bus or device's I/O space aperture.</p></dd>
<dt><code>value</code></dt>
<dd><p>The value to be written in host byte order (big endian on PPC).</p></dd>
<dt><code>map</code></dt>
<dd><p>If the offset is relative to the beginning of a device's aperture, an IOMemoryMap object for that object should be passed in. Otherwise, passing zero will write the value relative to the beginning of the bus's I/O space.</p></dd>
</dl>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>This method will write a 32-bit value to a 4-byte aligned offset in an I/O space aperture. If a map object is passed in, the value is written relative to it, otherwise the value is written relative to the I/O space aperture for the bus. This function encapsulates the differences between architectures in generating I/O space operations. An eieio instruction is included on PPC.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOPCCard16Device/ioWrite8/void/(UInt16,UInt8,IOMemoryMap*);  indexgroup=PCCard ;   name=IOPCCard16Device::ioWrite8 --><a name="//apple_ref/cpp/instm/IOPCCard16Device/ioWrite8/void/(UInt16,UInt8,IOMemoryMap*)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="ioWrite8">ioWrite8</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Writes an 8-bit value to an I/O space aperture.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <a href="../../../../../../GraphicsImaging/Reference/ImageCaptureDeviceModulesReference/ICADevice/CompositePage.html#//apple_ref/c/tdef/void" target="_top" class="type"><span class="type">void</span></a> <!-- a --><span class="function">ioWrite8</span><!-- /a -->(
    <!-- a --><span class="type">UInt16</span><!-- /a --> <span class="param">offset</span>,
    <!-- a --><span class="type">UInt8</span><!-- /a --> <span class="param">value</span>,
    <a href="../../../IOMemoryDescriptor_h/Classes/IOMemoryMap/index.html#//apple_ref/cpp/cl/IOMemoryMap" target="_top" class="type"><span class="type">IOMemoryMap</span></a> <span class="type">*</span><!-- a --><span class="type">map</span><!-- /a --> = <span class="number">0</span> ); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>offset</code></dt>
<dd><p>An offset into a bus or device's I/O space aperture.</p></dd>
<dt><code>value</code></dt>
<dd><p>The value to be written in host byte order (big endian on PPC).</p></dd>
<dt><code>map</code></dt>
<dd><p>If the offset is relative to the beginning of a device's aperture, an IOMemoryMap object for that object should be passed in. Otherwise, passing zero will write the value relative to the beginning of the bus's I/O space.</p></dd>
</dl>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>This method will write a 8-bit value to an offset in an I/O space aperture. If a map object is passed in, the value is written relative to it, otherwise the value is written relative to the I/O space aperture for the bus. This function encapsulates the differences between architectures in generating I/O space operations. An eieio instruction is included on PPC.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOPCCard16Device/setWindowOffset/bool/(UInt32,UInt32);  indexgroup=PCCard ;   name=IOPCCard16Device::setWindowOffset --><a name="//apple_ref/cpp/instm/IOPCCard16Device/setWindowOffset/bool/(UInt32,UInt32)"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="setWindowOffset">setWindowOffset</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Sets the offset for this window.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <!-- a --><span class="type">bool</span><!-- /a --> <!-- a --><span class="function">setWindowOffset</span><!-- /a -->(
    <!-- a --><span class="type">UInt32</span><!-- /a --> <span class="param">index</span>,
    <!-- a --><span class="type">UInt32</span><!-- /a --> <span class="param">newOffset</span>); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Parameters</font></h5>
<dl>
<dt><code>index</code></dt>
<dd><p>Index of window.</p></dd>
<dt><code>offset</code></dt>
<dd><p>The new offset for this window.</p></dd>
</dl>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->Returns true if the window offset was successfully updated.

<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>This method updates the offset into the card's memory space for this window.  This call is only valid for memory windows.
<!-- end discussion -->
</p>
<p></p>
<hr>
<!-- headerDoc=instm;  uid=//apple_ref/cpp/instm/IOPCCard16Device/unconfigure/bool/();  indexgroup=PCCard ;   name=IOPCCard16Device::unconfigure --><a name="//apple_ref/cpp/instm/IOPCCard16Device/unconfigure/bool/()"></a>
<table border="0" cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row">
<h3><a name="unconfigure">unconfigure</a></h3>
</td></tr></table>
<hr>
<p><!-- begin abstract --></p>
<p>Unconfigures a card.
<!-- end abstract --></p>
<p></p>
<pre><tt>public</tt>
<br><span class="keyword">virtual</span> <!-- a --><span class="type">bool</span><!-- /a --> <!-- a --><span class="function">unconfigure</span><!-- /a -->(
    <span class="param">void</span>); </pre>
<h5 class="tight"><font face="Lucida Grande,Helvetica,Arial">Return Value</font></h5>
<p><!-- begin return value -->Returns true if the card was successfully unconfigured.

<!-- end return value --></p>
<h5 class="tight">
<font face="Lucida Grande,Helvetica,Arial">Discussion</font>
</h5>
<!-- begin discussion --><p>This method releases resources that were previously allocated back to Card Services. It does not unmap windows. Virtual-to-physical mappings need to be released separately.
<!-- end discussion -->
</p>
<p></p>
<p><!-- start of footer -->

<!-- start of footer --> 
	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Darwin/Reference/KernelIOKitFramework/IOPCCard16Device_h/Classes/IOPCCard16Device/index.html%3Fid%3DTP30000816-3.4&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Darwin/Reference/KernelIOKitFramework/IOPCCard16Device_h/Classes/IOPCCard16Device/index.html%3Fid%3DTP30000816-3.4&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Darwin/Reference/KernelIOKitFramework/IOPCCard16Device_h/Classes/IOPCCard16Device/index.html%3Fid%3DTP30000816-3.4&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

</p>
<p>&#160;</p>
<!--#include virtual="/footer"-->
<!-- end of footer -->


<!-- end of footer -->
Last Updated: 2008-12-19
</div>
<!-- headerDoc=cl; uid=//apple_ref/cpp/cl/IOPCCard16Device; indexgroup=PCCard ; name=IOPCCard16Device--><a name="//apple_ref/cpp/cl/IOPCCard16Device"></a>
</body>
</html>
