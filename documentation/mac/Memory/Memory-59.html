<!-- Generated by Harlequin WebMaker 2.2.3 (23-Apr-1996)
LispWorks 3.2.2 -->
<HTML> <HEAD>
<TITLE>Organization of Memory (IM: M)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING59></A>



<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="Memory-58.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Memory-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Memory-202.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="Memory-60.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="Memory-2.html"><B>Memory</B></A> / <BR><DD><A HREF="Memory-56.html"><B>Chapter 2 - Memory Manager</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING59-0></A>
<H1><A NAME=MARKER-9-179></A>Organization of Memory</H1>
 <A NAME=MARKER-2-180></A>This section describes the organization of heap zones and block headers. In general, you do not need to know how the Memory Manager organizes heap zones or block headers if your application simply allocates and releases blocks of memory. The information described in this section is used by the Memory Manager for its own purposes. Developers of some specialized applications and utilities might, however, need to know exactly how zones and block headers are organized. This information is also sometimes useful for debugging.<P>
<DL>
<DT><B>WARNING</B>
<DD>This section is provided primarily for informational purposes. The organization and size of heap zones and block headers is subject to change in future system software versions.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
<A NAME=HEADING59-3></A>
<H2><A NAME=MARKER-9-181></A>Heap Zones</H2>
 <A NAME=MARKER-2-182></A>Except for temporary memory blocks, all relocatable and nonrelocatable blocks <BR>exist within heap zones. A heap zone consists of a zone header, a zone trailer block, <BR>and usable bytes in between. The header contains all of the information the <BR>Memory Manager needs about that heap zone; the trailer is just a minimum-sized free block placed as a marker at the end of the zone.<P>
 In Pascal, a heap zone is defined as a <B>zone record</B> of type <CODE>Zone</CODE>. The zone record contains all of the fields of the zone header. A heap zone is always referred to with a <B>zone pointer</B> of data type <CODE>THz</CODE>.<A NAME=MARKER-2-163></A><A NAME=MARKER-2-184></A><A NAME=MARKER-2-185></A><P>
<DL>
<DT><B>WARNING</B>
<DD>The fields of the zone header are for the Memory Manager's own internal use. You can examine the contents of the zone's fields, but in general it doesn't make sense for your application to try to change them. The only fields of the zone record that you can safely modify directly are the <CODE>moreMast</CODE> and <CODE>purgeProc</CODE> fields.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
<PRE>
TYPE Zone =
RECORD
   bkLim:         Ptr;           {first usable byte after zone}
   purgePtr:      Ptr;           {used internally}
   hFstFree:      Ptr;           {first free master pointer}
   zcbFree:       LongInt;       {number of free bytes in zone}
   gzProc:        ProcPtr;       {grow-zone function}
   moreMast:      Integer;       {num. of master ptrs to allocate}
   flags:         Integer;       {used internally}
   cntRel:        Integer;       {reserved}
   maxRel:        Integer;       {reserved}
   cntNRel:       Integer;       {reserved}
   maxNRel:       Integer;       {reserved}
   cntEmpty:      Integer;       {reserved}
   cntHandles:    Integer;       {reserved}
   minCBFree:     LongInt;       {reserved}
   purgeProc:     ProcPtr;       {purge-warning procedure}
   sparePtr:      Ptr;           {used internally}
   allocPtr:      Ptr;           {used internally}
   heapData:      Integer;       {first usable byte in zone}
END;
THz = ^Zone;                     {zone pointer}
</PRE>
<DL>
<H5>Field Description</H5>
<DT><CODE>bkLim</CODE>
<DD> A pointer to the byte <I>following</I> the last byte of usable space in <BR>the zone.<A NAME=MARKER-2-186></A>
<DT><CODE>purgePtr</CODE>
<DD> Used internally.<A NAME=MARKER-2-187></A>
<DT><CODE>hFstFree</CODE>
<DD> A pointer to the first free master pointer in the zone. All master pointers that are allocated but not currently in use are linked together into a list. The <CODE>hFstFree</CODE> field references the head node of this list. The Memory Manager updates this list every time it allocates a new relocatable block or releases one, so that the list contains all unused master pointers. If the Memory Manager needs a new master pointer but this field is set to <CODE>NIL</CODE>, it allocates a new nonrelocatable block of master pointers. You can check the value of this field to see whether allocating a relocatable block would cause a new block of master pointers to be allocated.<A NAME=MARKER-2-188></A>
<DT><CODE>zcbFree</CODE>
<DD> The number of free bytes remaining in the zone. As blocks are allocated and released, the Memory Manager adjusts this field accordingly. You can use the <CODE>FreeMem</CODE> function to determine the value of this field for the current heap zone.<A NAME=MARKER-2-189></A>
<DT><CODE>gzProc</CODE>
<DD> A pointer to a grow-zone function that system software uses to maintain control over the heap. The system's grow-zone function subsequently calls the grow-zone function you specify for your heap, if any. You can change a heap zone's grow-zone function at any time but should do so only by calling the <CODE>InitZone</CODE> or <CODE>SetGrowZone</CODE> procedures. Note that in current versions of system software, this field does not contain a pointer to the grow-zone function that your application defines.<A NAME=MARKER-2-190></A>
<DT><CODE>moreMast</CODE>
<DD> The number of master pointers the Memory Manager should allocate at a time. The Memory Manager allocates this many automatically when a heap zone is initialized. By default, master pointers are allocated 32 at a time for the system heap zone and 64 at a time for the application heap zone, but this might change in future versions of system software.<A NAME=MARKER-2-191></A>
<DT><CODE>flags</CODE>
<DD> Used internally.<A NAME=MARKER-2-192></A>
<DT><CODE>cntRel</CODE>
<DD> Reserved.<A NAME=MARKER-2-193></A>
<DT><CODE>maxRel</CODE>
<DD> Reserved.<A NAME=MARKER-2-194></A>
<DT><CODE>cntNRel</CODE>
<DD> Reserved.<A NAME=MARKER-2-195></A>
<DT><CODE>maxNRel</CODE>
<DD> Reserved.<A NAME=MARKER-2-196></A>
<DT><CODE>cntEmpty</CODE>
<DD> Reserved.<A NAME=MARKER-2-197></A>
<DT><CODE>cntHandles</CODE>
<DD> Reserved.<A NAME=MARKER-2-198></A>
<DT><CODE>minCBFree</CODE>
<DD> Reserved.<A NAME=MARKER-2-199></A>
<DT><CODE>purgeProc</CODE>
<DD> A pointer to the zone's purge-warning procedure, or <CODE>NIL</CODE> if there is none. The Memory Manager calls this procedure before it purges a block from the zone. Note that whenever you call the Resource Manager procedure <CODE>SetResPurge</CODE> with the parameter set to <CODE>TRUE</CODE>, the Resource Manager installs its own purge-warning procedure, overriding any purge-warning procedure you have specified here.<A NAME=MARKER-2-200></A><A NAME=MARKER-2-201></A>
<DT><CODE>sparePtr</CODE>
<DD> Used internally.<A NAME=MARKER-2-202></A>
<DT><CODE>allocPtr</CODE>
<DD> Used internally.<A NAME=MARKER-2-203></A>
<DT><CODE>heapData</CODE>
<DD> A dummy field marking the beginning of the zone's usable <BR>memory space. The integer in this field has no significance in <BR>itself; it is just the first 2 bytes in the block header of the first <BR>block in the zone. For example, if <CODE>myZone</CODE> is a zone pointer, then<CODE> @(myZone^.heapData)</CODE> is the address of the first usable byte in the zone, and <CODE>myZone^.bkLim</CODE> is a pointer to the byte following the last usable byte in the zone.<A NAME=MARKER-2-204></A><A NAME=MARKER-2-205></A><A NAME=MARKER-2-206></A>
</DL>
 The structure of a heap zone is the same in both 24-bit and 32-bit addressing modes. The use of several of the fields that are reserved or used internally, however, may differ in 24-bit and 32-bit heap zones.<A NAME=MARKER-2-207></A><P>
<A NAME=HEADING59-27></A>
<H2>Block Headers</H2>
 <A NAME=MARKER-2-208></A>Every block in a heap zone, whether allocated or free, has a <B>block header</B> that the Memory Manager uses to find its way around in the zone. Block headers are completely transparent to your application. All pointers and handles to allocated blocks reference the beginning of the block's logical contents, following the end of the header. Similarly, whenever you use a variable of type <CODE>Size</CODE>, that variable refers to the number of bytes in the block's logical contents, not including the block header. That size is known as the block's <B>logical size,</B> as opposed to its <B>physical size,</B> the number of bytes it actually occupies in memory, including the header and any unused bytes at the end of the block.<A NAME=MARKER-2-209></A><A NAME=MARKER-2-210></A><A NAME=MARKER-2-211></A><P>
 There are two reasons that a block might contain such unused bytes:<P>
<UL>
<LI>The Memory Manager allocates space only in even numbers of bytes. (This practice guarantees that both the contents and the address of a master pointer are even.) <BR>If a block's logical size is odd, an extra, unused byte is added at the end to make the physical size an even number. On computers containing the MC68020, MC68030, <BR>or MC68040 microprocessor, blocks are padded to 4-byte boundaries.<A NAME=MARKER-2-212></A>
<LI>The minimum number of bytes in a block is 12. This minimum applies to all <BR>blocks, free as well as allocated. If allocating the required number of bytes from a <BR>free block would leave a fragment of fewer than 12 free bytes, the leftover bytes are included unused at the end of the newly allocated block instead of being returned to free storage.<P>
</UL>
 There is no Pascal record type defining the structure of block headers because you shouldn't normally need to access them directly. In addition, the structure of a block header depends on whether the block is located in a 24-bit or 32-bit zone.<P>
 In a 24-bit zone, a block header consists of 8 bytes, which together make up two long words, as shown in <A HREF=#MARKER-9-213>Figure 2-1</A>.<P>
<B>Figure 2-1  <A NAME=MARKER-9-213></A>A block header in a 24-bit zone</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/MM-01.jpg">
 In the first long word, the low-order 3 bytes contain the block's physical size in bytes. Adding this number to the block's address gives the address of the next block in the zone. The first byte of the block header is a <B>tag byte</B> that provides other information on the block. The bits in the tag byte have these meanings:<A NAME=MARKER-2-214></A>
<TABLE BORDER="0" CELLPADDING=3><TH ALIGN=LEFT>Bit<TH>Meaning<TR>
<TD>0-3<TD>The block's size correction<TR>
<TD>4-5<TD>Reserved<TR>
<TD>6-7<TD>The block type</TABLE>
<P>
 In the tag byte, the high-order 2 bits determine whether a block is free (binary 00), relocatable (binary 10), or nonrelocatable (binary 01). The low-order 4 bits contain a block's <B>size correction,</B> the number of unused bytes at the end of the block, beyond the end of the block's contents. This correction is equal to the difference between the block's logical and physical sizes, excluding the 8 bytes of overhead for the block header, as in the following formula:<A NAME=MARKER-2-5></A><P>
<PRE>
physicalSize = logicalSize + sizeCorrection + 8
</PRE>
 The contents of the second long word (4 bytes) in the 24-bit block header depend on the type of block. For relocatable blocks, the second long word contains the block's <B>relative handle:</B> a pointer to the block's master pointer, expressed as an offset relative to the start of the heap zone rather than as an absolute memory address. Adding the relative handle to the zone pointer produces a true handle for this block. For nonrelocatable blocks, the second long word of the header is just a pointer to the block's zone. For free blocks, the contents of these 4 bytes are undefined.<A NAME=MARKER-2-217></A><A NAME=MARKER-2-218></A><P>
 In a 32-bit zone, a block header consists of 12 bytes, which together make up three long words, as shown in <A HREF=#MARKER-9-219>Figure 2-2</A>.<P>
<B>Figure 2-2  <A NAME=MARKER-9-219></A>A block header in a 32-bit zone</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/MM-02.jpg">
 The first byte of the block header is a tag byte that indicates the type of the block. The bits in the tag byte have these meanings:
<TABLE BORDER="0" CELLPADDING=3><TH ALIGN=LEFT>Bit<TH>Meaning<TR>
<TD>0-5<TD>Reserved<TR>
<TD>6-7<TD>The block type</TABLE>
<P>
 In the tag byte, the high-order 2 bits determine whether a block is free (binary 00), relocatable (binary 10), or nonrelocatable (binary 01).<P>
 The second byte in the block header contains the master pointer flag bits, if the block is a relocatable block. Otherwise, this byte is undefined. The bits in this byte have these meanings:
<TABLE BORDER="0" CELLPADDING=3><TH ALIGN=LEFT>Bit<TH>Meaning<TR>
<TD>0-4<TD>Reserved<TR>
<TD>5<TD>If set, block contains resource data<TR>
<TD>6<TD>If set, block is purgeable<TR>
<TD>7<TD>If set, block is locked</TABLE>
<P>
 The low-order byte of the high-order long word contains the block's size correction. This correction is equal to the difference between the block's logical and physical sizes, excluding the 12 bytes of overhead for the block header, as follows:<A NAME=MARKER-2-220></A><A NAME=MARKER-2-221></A><P>
<PRE>
physicalSize = logicalSize + sizeCorrection + 12
</PRE>
 The second long word in the 32-bit block header contains the block's physical size, and the third long word contains the block's relative handle. These fields have the same meaning as the corresponding fields in the 24-bit block header.<A NAME=MARKER-2-222></A><A NAME=MARKER-2-223></A><P>

</BLOCKQUOTE>
<HR>
<center>
<A HREF="Memory-58.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Memory-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Memory-202.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="Memory-60.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="Memory-3.html">&copy; Apple Computer, Inc.</A><br>3 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>  
