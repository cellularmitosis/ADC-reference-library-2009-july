<html>	<head>		<title>EODatabase Concepts</title>	</head><BODY bgcolor=#ffffff>		<!-- start of header -->		<!--#include virtual="/includes/framesetheader" -->		<!-- end of header --><!-- start of path --><table cellspacing=0 border=0 width=600 valign="left"><tr><td scope="row"><font face="Geneva,Helvetica,Arial" size="1"><b>PATH<spacer type="horizontal" size="5">&nbsp;</b><a href="../../../../../index.html" target="_top">Documentation</a> <b>></b> <a href="../../../../webobjects.html" target="_top">WebObjects</a></font></td></tr></table><br><!-- end of path -->		<a href="../../EOAccessTOC.html"><img src="../Art/up.gif" border="0" alt="Table of Contents"></a> <a name="EODatabase"></a>		<h1><font color="#000066"><a name="//apple_ref/UNKNOWN_LANGUAGE/cl/EODatabase.Concepts">EODatabase.Concepts</a></font></h1>		<br>		<br>		<a name="DAEDDFEF"></a>		<h2>The Database Level</h2>		<p>The EODatabase, EODatabaseContext, and EODatabaseChannel classes form the database level of the Enterprise Objects Framework. The database level is a client of the <b>adaptor level</b>, which is defined by the adaptor classes: EOAdaptor, EOAdaptorContext, and EOAdaptorChannel. Together, the database and adaptor levels make up the <b>access layer</b> of the Enterprise Objects Framework.</p>		<center>			<p><b>Figure 0-1 The Access Layer</b></p>			<img src="../Art/AdDb.GIF" alt="[image: ../Art/AdDb.GIF]"> </center>		<p>The database level acts as an intermediary between the adaptor level and the <b>control layer</b>, which includes an EOObjectStoreCoordinator and an EOEditingContext ( <a href="#CIDDJEBF">Figure 0-2</a>). The control layer operates in terms of enterprise objects, while the adaptor level operates in terms of database rows packaged as NSDictionaries. It's the job of the database level to perform the necessary object-to-relational translation between the two. </p>		<p>There's little need for your code to interact directly with an EODatabase object. An EOEditingContext creates its own database level objects, which create their own corresponding adaptor level objects. Once the network of objects is in place, your code might interact with an EODatabase to access its corresponding EOAdaptor object, but additional programmatic interaction is usually unnecessary.</p>		<center>			<a name="CIDDJEBF"></a>			<p><b>Figure 0-2 The EODatabase Level as an Intermediary Between the Adaptor Level and the Control Layer</b></p>			<img src="../Art/AdDbEc.GIF" alt="[image: ../Art/AdDbEc.GIF]"> </center>		<br>		<a name="DAEDJCCB"></a>		<h2>Snapshots</h2>		<p>EODatabase's most significant responsibility is to record <b>snapshots</b> for its EODatabaseContexts. A snapshot is a dictionary whose keys are attribute names and whose values are the corresponding, last-known database values. Enterprise Objects Framework records snapshots as it successfully fetches, inserts and updates enterprise objects. Snapshot information is used when changes to enterprise objects are saved back out to the database to ensure that row data has not been changed by someone else since it was last recorded by the application.</p>		<p>A snapshot contains entries for a row's primary key, class properties, foreign keys for class property relationships, and attributes used for locking. They are recorded under the globalIDs of their enterprise objects. (EOGlobalIDs are based on an object's primary key and its associated entity; see the class specification for EOGlobalID in the EOControl framework for more information.)</p>		<p>EODatabase also records snapshots for to-many relationships. These snapshots consist of an NSDictionary of NSDictionaries, in which the top-level dictionary has as its key the globalID of the enterprise object for which to-many relationships are being recorded. The key's value is a dictionary whose keys are the names of the enterprise object's to-many relationships. Each of these keys in turn has as its value an array of globalIDs that identify the objects at the destination of the relationship.</p>		<p>The snapshots made by an EODatabase form the global view of data for nearly every other part of the application, representing the current view of data in the server as far as the application is concerned (though other applications may have made changes). This global view is temporarily overridden locally by EODatabaseContexts, which form their own snapshots as they make changes during a transaction. When an EODatabaseContext commits its top-level transaction, it reconciles all changed snapshots with the global view of the database object, so that other database contexts (except those with open transactions) immediately use the new snapshots as well. EODatabaseContexts automatically use their EODatabase to record snapshots, so there's no need for your application to intervene in an EODatabase's snapshotting mechanism.</p>		<p>For more information on snapshots and how they relate to an application's update strategy, see the EODatabaseContext class specification.</p>		<br>		<h3>Entity Caching</h3>		<p>An EODatabase object also performs the function of caching enterprise objects for entities that cache their objects (see the EOEntity class specification). An EODatabase's entity cache stores the globalIDs of enterprise objects for entities that cache their objects. The first time you perform a fetch against such an entity, all of its objects are fetched, regardless of the fetch specification used. The globalIDs of the resulting objects are stored in the EODatabase's entity cache by entity name. Whenever possible, subsequent fetches are performed against the cache (in memory) rather than against the database. With a globalID, Enterprise Objects Framework can look up the values for the corresponding object in its snapshot using EODatabase's or EODatabaseContext's snapshotForGlobalID method.</p>		<p>As an example, suppose that you have an entity named Rating that contains all the valid ratings for Movies (G, PG, R, and so on). Rather than store a Movie's rating directly in the Movie as an attribute, Movie maintains a relationship to a Rating. To specify a rating for a movie, users select the rating from a pop-up list of the possible values. Since the ratings in the Rating entity never change, the Rating entity should cache its objects. The values that populate the rating pop-up list are only fetched once, and there's no need to fetch them again; the relationships between Movies and Ratings can be maintained without subsequent fetches.</p>		<p>The entity cache is managed automatically; you shouldn't have to manipulate it explicitly. However, if you need to access or alter the cache, EODatabase provides several methods for interacting with it.</p>		<p>&copy; 2001 Apple Computer, Inc. (Last Published April 13, 2001)</p>		<br>		<a href="../../EOAccessTOC.html"><img src="../Art/up.gif" border="0" alt="Table of Contents"></a> <!-- start of footer -->		<!--#include virtual="/includes/framesetfooter" -->		<!-- end of footer -->	</body></html>