<!-- Generated by Harlequin WebMaker 2.2.3 (23-Apr-1996)
LispWorks 3.2.2 -->
<HTML> <HEAD>
<TITLE>Using InputSprocket (GameSprockets)</TITLE>
</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000" ="A" NAME="HEADING164"></A>



<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="GameSprockets-163.html"><IMG ALIGN="BOTTOM" SRC="prev.gif" BORDER="none" HSPACE="20" ALT="Previous"></A> <A HREF="GameSprockets-2.html"><IMG ALIGN="BOTTOM" SRC="content.gif" BORDER="none" HSPACE="20" ALT="Book Contents"></A> <A HREF="GameSprockets-318.html"><IMG ALIGN="BOTTOM" SRC="index.gif" BORDER="none" HSPACE="20" ALT="Book Index"></A> <A HREF="GameSprockets-165.html"><IMG ALIGN="BOTTOM" SRC="next.gif" BORDER="none" HSPACE="20" ALT="Next"></A> </CENTER><P>
<FONT SIZE="-1"><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="GameSprockets-2.html"><B>Apple Game Sprockets Guide</B></A> / <BR><DD><A HREF="GameSprockets-162.html"><B>Chapter 3 - InputSprocket</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME="HEADING164-0"></A>
<H1>Using InputSprocket</H1>
 This section illustrates basic ways of using InputSprocket. In particular, it provides source code samples that show how you can<P>
<UL>
<LI>Initialize need structures and allocate virtual elements
<LI>Build an element list
<LI>Process input data during game play
<LI>Deactivate keyboard and mouse devices<P>
</UL>
<DL>
<DT><B>Note</B>
<DD>The code samples shown in this section provide no error handling.<EM></EM>  <IMG ALIGN="BOTTOM" SRC="graphics/triangle.gif">
</DL>
<A NAME="HEADING164-7"></A>
<H2>Initializing Need Structures and Allocating Virtual Elements</H2>
 <A NAME="MARKER-2-19"></A>During initialization the game describes its requirements for input by filling out a <CODE>ISpNeed</CODE> data structure for each requirement (the structure is described on <A HREF="GameSprockets-185.html#MARKER-9-106">(page 3-29)</A>. The need structure has fields for an element kind and an element label, so the game can describe the data and its intended use. Other fields specify how to use the keyboard and mouse for keyboard emulation. The game also provides a string and an icon to identify the input requirement in a user interface. <P>
 After filling out the need structures, the game allocates a virtual element to meet each input requirement. Allocation of virtual elements must happen before you call <CODE>ISpInit</CODE> because after that call the device driver may begin using the virtual elements. <P>
 The <CODE>InitNeeds</CODE> routine shown in <A HREF="#MARKER-9-21">Listing 3-1</A> creates an array of initialized <A NAME="MARKER-2-20"></A>ISpNeed structures. It then uses the <CODE>ISpElement_NewVirtualFromNeeds</CODE> function <A HREF="GameSprockets-195.html#MARKER-9-118">(page 3-36)</A> to allocate virtual elements. You can use <CODE>ISpElement_NewVirtualFromNeeds</CODE> only with built-in element kinds, which is the case in the example. Otherwise, you allocate virtual elements individually using the <CODE>ISpElement_NewVirtual</CODE> function <A HREF="GameSprockets-194.html#MARKER-9-116">(page 3-36)</A>.<P>
<A NAME="MARKER-9-21"></A><B>Listing 3-1  Initializing need structures and allocating virtual elements</B><P>
<PRE>
OSStatus InitNeeds(ISpNeed *theNeeds,ISpElementReference *elements)
{
   ISpNeed tempNeeds[kNumNeeds] =
   {
      { 
         &quot;\pForward Thrust&quot;, 
         kIconSuiteID_YThrust, 
         kISpElementKind_Axis,
         kISpElementLabel_YAxis, 
         0
      },
      { 
         &quot;\pSide Thrust&quot;, 
         kISpElementKind_Axis,
         kISpElementLabel_XAxis,
         0
      },
      { 
         &quot;\pVertical Thrust&quot;, 
         kIconSuiteID_ZThrust,
         kISpElementKind_Axis, 
         kISpElementLabel_ZAxis, 
         0
      },
      { 
         &quot;\pLook&quot;, 
         kIconSuiteID_Look, 
         kISpElementKind_Movement,
         kISpElementLabel_None,  
         0
      },
      { 
         &quot;\pLaser&quot;, 
         kIconSuiteID_Fire, 
         kISpElementKind_Button,
         kISpElementLabel_Fire, 
         0
      },
      { 
         &quot;\pMissle&quot;, 
         kIconSuiteID_Pause, 
         kISpElementKind_Button,
         kISpElementLabel_Fire, 
         0
      },
      { &quot;\pShields&quot;, 
         kIconSuiteID_Shields,
         kISpElementKind_Button,
         kISpElementLabel_None, 
         0
      },
      { 
         &quot;\pStart/Stop&quot;, 
         kIconSuiteID_Start, 
         kISpElementKind_Button,
         kISpElementLabel_Start, 
         kISpNeedFlag_NoMultiConfig
      }
   };

   int itr;
   for(itr = 0; itr &lt; kNumNeeds; itr++)
   {
      theNeeds[itr] = tempNeeds[itr];
   }

   OSStatus result = ISpElement_NewVirtualFromNeeds(kNumNeeds, theNeeds,
      elements, 0);

   return result;
}
</PRE>
<A NAME="HEADING164-13"></A>
<H2>Building an Element List</H2>
 <A NAME="MARKER-2-22"></A>When configuration is finished and virtual elements are allocated, you probably want to build a list of elements the game wants to get events for during play. <A HREF="#MARKER-9-23">Listing 3-2</A> shows the BuildMyElementList routine, which puts all the button and directional pad elements on an element list. Games usually poll axis and movement elements, so they are not included on the list.<P>
 <CODE>BuildMyElementList</CODE> also makes the reference constant returned by <CODE>ISpElementList_AddElements</CODE> for each element it adds equal to the index of the element in the array of need structures passed to the drivers during autoconfiguration. This is also the same as the index of the element in the list of virtual elements allocated during the autoconfiguration process (see <A HREF="#MARKER-9-21">Listing 3-1</A> for an example of creating virtual elements). The game uses the reference constant (which is passed in the <CODE>ISpElementEvent</CODE> structure) to identify the element when it gets element events using <CODE>ISpElementList_GetNextEvent</CODE>.<P>
<B>Listing 3-2  <A NAME="MARKER-9-23"></A>Building an element list</B><P>
<PRE>
<CODE>ISpElementListReference BuildMyElementList(UInt32 count, ISpNeed *needs, 
   ISpElementReference *elements)
{
   int itr;
   ISpElementListReference theList = nil;

   ISpElementList_New(0, nil, &amp;theList, 0);
   for(itr = 0; itr &lt; count; itr++)
   {
      if ((needs[itr].theKind == kISpElementKind_Button) ||
         (needs[itr].theKind == kISpElementKind_DPad))
      {
            ISpElementList_AddElements(theList, itr, 1,
               &amp;(elements[itr]));
      }
   }

   return theList;
}
</CODE></PRE>
 <CODE>BuildMyElementList</CODE> first defines an element list reference to the list that will be built. It next uses the ISpElementList_New function <A HREF="GameSprockets-217.html#MARKER-9-155">(page 3-51)</A> to create an empty element list. Finally, <CODE>BuildMyElementList</CODE> uses the ISpElementList_AddElements function <A HREF="GameSprockets-220.html#MARKER-9-159">(page 3-53)</A> to add elements of kind <CODE>kISpElementKind_Button</CODE> and <CODE>kISpElementKind_DPad</CODE> to the list. They are added one at a time so that each element can be assigned the reference constant that corresponds to its index in the array of need structures.<P>
<A NAME="HEADING164-19"></A>
<H2>Processing Input Data During Play</H2>
 <A NAME="MARKER-2-24"></A>During game play the game obtains data from all the input devices either by polling or getting events. <A HREF="#MARKER-9-25">Listing 3-3</A> shows the <CODE>ProcessInput</CODE> routine. This routine runs the main game loop, polling for the state of axis and movement elements and getting events from button elements.<P>
 <CODE>ProcessInput</CODE> takes an element list that has been built so that the index of each element corresponds to its position in the array of need structures passed to the drivers during autoconfiguration (see <A HREF="#MARKER-9-23">Listing 3-2</A> for an example of how to do this). <P>
 Notice that there are two routines for getting the state of an element--<CODE>ISpElement_GetSimpleState</CODE> and <CODE>ISpElement_GetComplexState</CODE>. The <CODE>ISpElement_GetSimpleState</CODE> function <A HREF="GameSprockets-210.html#MARKER-9-145">(page 3-47)</A> is for elements whose data fits in an unsigned 32-bit integer. For other elements, in this case, movement kind elements, use <CODE>ISpElement_GetComplexState</CODE> <A HREF="GameSprockets-211.html#MARKER-9-147">(page 3-47)</A> where you can specify the size of the buffer needed to hold the data.<P>
 Buttons work in a variety of ways and the code illustrates how to get events for three types--a firing button, where only down events matter (the laser and missile buttons); a toggle (the stop button); and a hold-to-activate button (the shield button). <P>
<B>Listing 3-3  <A NAME="MARKER-9-25"></A>Processing input data</B><P>
<PRE>
<CODE>enum
{
   kForwardThrust = 0,
   kSideThrust,
   kVerticalThrust,
   kLook,
   kLaser,
   kMissle,
   kShields,
   kStartStop,
   kNumNeeds
};

typedef struct InputData
{
   UInt32   x,y,z;       // x,y and z thrust
   UInt32   xLook, yLook;
   Boolean  fireLasers;
   Boolean  fireMissles;
   Boolean  shields;    // down activates; up deactivates
   Boolean  stopped;    // toggle
} InputData;
   
void ProcessInput(ISpElementReference *theElements, 
   ISpElementListReference myList, InputData *myInput)
{
   ISpElement_GetSimpleState(theElements[kForwardThrust],
       &amp;(myInput-&gt;x));
   ISpElement_GetSimpleState(theElements[kSideThrust], &amp;(myInput-&gt;y));
   ISpElement_GetSimpleState(theElements[kVerticalThrust],
      &amp;(myInput-&gt;z));
      
   ISpMovementData tempMovement;
   ISpElement_GetComplexState(theElements[kLook],
      sizeof(ISpMovementData),&amp;tempMovement);
   myInput-&gt;xLook = tempMovement.xAxis;
   myInput-&gt;yLook = tempMovement.yAxis;

   myInput-&gt;fireLasers = false;
   myInput-&gt;fireMissles = false;
    
   Boolean wasEvent;
   ISpElementEvent theEvent;
    
   while(1)
   {
      ISpElementList_GetNextEvent(myList, sizeof(ISpElementEvent),
         &amp;theEvent, &amp;wasEvent);
             
      switch(theEvent.refCon)
      {
         case kLaser:
            if (theEvent.data == kISpButtonDown)
            {
               myInput-&gt;fireLasers = true;
            }
         break;
                       
         case kMissle:
            if (theEvent.data == kISpButtonDown)
            {
               myInput-&gt;fireMissles = true;
            }
         break;
                       
         case kShields:
            if (theEvent.data == kISpButtonDown)
            {
               myInput-&gt;shields = true;
            }
            else if (theEvent.data == kISpButtonUp)
            {
               myInput-&gt;shields = false;
            }
         break;
                      
         case kStartStop:
            if (theEvent.data == kISpButtonDown)
            {
               myInput-&gt;stopped = !myInput-&gt;stopped;
            }
         break;
      }
           
      if (!wasEvent)
      {
         return;
      }
   }
}</CODE>
</PRE>
<A NAME="HEADING164-26"></A>
<H2>Turning the Keyboard and Mouse On and Off</H2>
 <A NAME="MARKER-2-26"></A>By default, keyboard and mouse input devices are inactive. This is fine for games that run in a window where the user probably expects the mouse and keyboard to behave normally. However, most games will want to activate the keyboard and mouse. Later, there may be a point in the game where the user needs to enter text, in which case, you would want to deactivate the keyboard and mouse as game input devices so that you can return to using the standard methods provided by the OS to manage them.<P>
 <A HREF="#MARKER-9-27">Listing 3-4</A> shows the <CODE>SetKeyboardMouseActivation</CODE> function that deactivates and activates the keyboard and mouse devices.<P>
<B>Listing 3-4  <A NAME="MARKER-9-27"></A>Turning off keyboard and mouse devices</B><P>
<PRE><CODE>
void SetKeyboardMouseActivation(Boolean active)
{
   enum           { kSimple = 100 }; 
   ISpDeviceReference buffer[kSimple];
   UInt32         count;

   ISpDevices_ExtractByClass(kISpDeviceClass_Mouse, kSimple, &amp;count,
      buffer);
             
   if (active) { ISpDevices_Activate(count,buffer); }
   else { ISpDevices_Deactivate(count, buffer); }
     
   ISpDevices_ExtractByClass(kISpDeviceClass_Keyboard,kSimple,&amp;count,
      buffer);

   if (active) { ISpDevices_Activate(count,buffer); }
   else { ISpDevices_Deactivate(count, buffer); }
}</CODE>
</PRE>
 The <CODE>SetKeyboardMouseActivation</CODE> function uses <CODE>ISpDevices_ExtractByClass</CODE> <A HREF="GameSprockets-198.html#MARKER-9-123">(page 3-39)</A> to find the keyboard and mouse devices. Notice that the buffer allocated to hold the device references is allocated for 100 devices, a number likely to be sufficient. The <CODE>ISpDevices_Deactivate</CODE> function is described on <A HREF="GameSprockets-231.html#MARKER-9-42">(page 3-41)</A>; <CODE>ISpDevices_Activate</CODE> is on <A HREF="GameSprockets-200.html#MARKER-9-127">(page 3-41)</A>.<P>
</BLOCKQUOTE>
<HR>
<CENTER>
<A HREF="GameSprockets-163.html"><IMG ALIGN="BOTTOM" SRC="prev.gif" BORDER="none" HSPACE="20" ALT="Previous"></A> <A HREF="GameSprockets-2.html"><IMG ALIGN="BOTTOM" SRC="content.gif" BORDER="none" HSPACE="20" ALT="Book Contents"></A> <A HREF="GameSprockets-318.html"><IMG ALIGN="BOTTOM" SRC="index.gif" BORDER="none" HSPACE="20" ALT="Book Index"></A> <A HREF="GameSprockets-165.html"><IMG ALIGN="BOTTOM" SRC="next.gif" BORDER="none" HSPACE="20" ALT="Next"></A> </CENTER><P>
<CENTER><FONT SIZE="-1"><A HREF="GameSprockets-3.html">&copy; Apple Computer, Inc.</A><BR>2 JUL 1996</CENTER></FONT><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML> 
