<!-- Generated by Harlequin WebMaker 2.2.3 (23-Apr-1996)
LispWorks 3.2.2 -->
<HTML> <HEAD>
<TITLE>Writing Your Own List Definition Procedure (IM: MTb)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING219></A>


<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="MoreToolbox-218.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="MoreToolbox-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="MoreToolbox-513.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="MoreToolbox-220.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="MoreToolbox-2.html"><B>More Macintosh Toolbox</B></A> / <BR><DD><A HREF="MoreToolbox-202.html"><B>Chapter 4 - List Manager</B></A> / <A HREF="MoreToolbox-209.html"><B>Using the List Manager</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING219-0></A>
<H2><A NAME=MARKER-9-274></A>Writing Your Own List Definition Procedure<A NAME=MARKER-9-318></A></H2>
 The default list definition procedure supports only the display of unstyled text. <BR>If your application needs to display items graphically, you can create your own <BR>list definition procedure. For example, the Chooser desk accessory uses its own list definition procedure to display icons and names corresponding to Chooser extensions. <A HREF=#MARKER-9-276>Figure 4-19</A> illustrates the Chooser's use of a custom list definition procedure.<P>
<B>Figure 4-19  <A NAME=MARKER-9-276></A>The Chooser's use of a custom list definition procedure</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/LM-S-19.jpg">
 This section explains how you can write a list definition procedure. After writing a list definition procedure, you must compile it as a resource of type <CODE>'LDEF'</CODE> and store it in the resource fork of any application that uses the list definition procedure. <A NAME=MARKER-2-260></A>  <A NAME=MARKER-9-171></A><A NAME=MARKER-2-265></A><P>
 This section provides code for a list definition procedure that supports the display of QuickDraw pictures. It works by requiring the application that uses it to store as cell data variables of type <CODE>PicHandle</CODE>. That way, each cell stores only 4 bytes of data, and the List Manager's 32 KB limit is not at risk of being approached for small lists. This list definition procedure provides enough versatility to display virtually any type of image.<P>
 You can write your own list definition procedure to store some type of data other than unstyled text. You can give your list definition procedure any name you choose, but it must be defined like this:<P>
<PRE>
PROCEDURE MyLDEF (message: Integer; selected: Boolean; 
                  VAR cellRect: Rect; theCell: Cell; 
                  dataOffset: Integer; dataLen: Integer;
                  theList: ListHandle);
</PRE>
 The List Manager can send four types of messages to your list definition procedure, as indicated by a value passed in the <CODE>message</CODE> parameter. The following constants define the different types of messages:<P>
<PRE>
CONST 
   lInitMsg          = 0;     {do any special list initialization}
   lDrawMsg          = 1;     {draw the cell}
   lHiliteMsg        = 2;     {invert cell's highlight state}
   lCloseMsg         = 3;     {take any special disposal action}
</PRE>
 Of the second through seventh parameters to a list definition procedure, only the <CODE>theList</CODE> parameter, which contains a handle to a list record, can be accessed by your list definition procedure in response to all four messages.<P>
 The <CODE>selected</CODE>, <CODE>cellRect</CODE>, <CODE>theCell</CODE>, <CODE>dataOffset</CODE>, and <CODE>dataLen</CODE> parameters pass information to your list definition procedure only when the value in the <CODE>message</CODE> parameter contains the <CODE>lDrawMsg</CODE> or the <CODE>lHiliteMsg</CODE> constant. These parameters provide information about the cell to be affected by the message. The <CODE>selected</CODE> parameter indicates whether the cell should be highlighted. The <CODE>cellRect</CODE> and <CODE>theCell</CODE> parameters indicate the cell's rectangle and coordinates. Finally, the <CODE>dataOffset</CODE> and <CODE>dataLen</CODE> parameters specify the offset and length of the cell's data within the relocatable block referenced by the <CODE>cells</CODE> field of the list record.<P>
 <A HREF=#MARKER-9-282>Listing 4-28</A> shows a list definition procedure that processes messages sent to it by the List Manager.<A NAME=MARKER-9-340></A><P>
<B>Listing 4-28  <A NAME=MARKER-9-282></A>Processing messages to a list definition procedure<A NAME=MARKER-2-283></A></B><P>
<PRE>
PROCEDURE MyLDEF (message: Integer; selected: Boolean; 
                  VAR cellRect: Rect; theCell: Cell; 
                  dataOffset: Integer; dataLen: Integer;
                  theList: ListHandle);
BEGIN
   CASE message OF
      lInitMsg: 
         MyLDEFInit(theList);
      lDrawMsg: 
         MyLDEFDraw(selected, cellRect, theCell, dataOffset,
                     dataLen, theList);
      lHiliteMsg: 
         MyLDEFHighlight(selected, cellRect, theCell,
                         dataOffset, dataLen, theList);
      lCloseMsg: 
         MyLDEFClose(theList);
   END;
END;
</PRE>
 The <CODE>MyLDEF</CODE> procedure defined in <A HREF=#MARKER-9-282>Listing 4-28</A> calls procedures defined later in this section to handle the various messages specified by the <CODE>message</CODE> parameter. It passes all relevant parameters to these message-handling procedures. Thus, it passes only the <CODE>theList</CODE> parameter to the procedures that handle the initialization and close messages.<P>
<A NAME=HEADING219-16></A>
<H3>Responding to the Initialization Message<A NAME=MARKER-2-284></A></H3>
 The List Manager automatically allocates memory for a list and fills out the fields of a list record before calling your list definition procedure with a <CODE>lInitMsg</CODE> message. Your application might respond to the initialization message by changing fields of the list record, such as the <CODE>cellSize</CODE> and <CODE>indent</CODE> fields. (These fields are by default set according to a formula discussed in <A HREF=MoreToolbox-208.html#MARKER-9-99>"About the List Manager" beginning on page 4-13</A>.) <P>
 Many list definition procedures do not need to perform any action in response to the initialization message. For example, the list definition procedure that allows the Standard File Package to display small icons next to the names of files uses the standard cell size and thus does not need to perform any special initialization. <P>
 Since pictures can come in a variety of sizes, the pictures list definition procedure introduced in <A HREF=#MARKER-9-282>Listing 4-28</A> does not need to perform any special initialization either; it depends on the application that uses the list definition procedure to define the correct cell size. Thus, <A HREF=#MARKER-9-285>Listing 4-29</A> shows how the pictures list definition procedure responds to the initialization method.<P>
<B>Listing 4-29  <A NAME=MARKER-9-285></A>Using the default initialization method<A NAME=MARKER-2-286></A></B><P>
<PRE>
PROCEDURE MyLDEFInit (theList: ListHandle);
BEGIN
END;
</PRE>
<DL>
<DT><B>Note</B>
<DD>Your list definition procedure does not actually need to call a procedure that responds to the initialization message if it does not need to perform any special action.<EM></EM><A NAME=MARKER-2-310></A>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
<A NAME=HEADING219-23></A>
<H3>Responding to the Draw Message<A NAME=MARKER-2-297></A></H3>
 Your list definition procedure must respond to the <CODE>lDrawMsg</CODE> message by examining the specified cell's data and drawing the cell as appropriate. At the same time, your list definition procedure must ensure that it does not alter the characteristics of the drawing environment.<P>
 <A HREF=#MARKER-9-289>Listing 4-30</A> shows how the pictures list definition procedure responds to the draw message.<P>
<B>Listing 4-30  <A NAME=MARKER-9-289></A>Responding to the <CODE>lDrawMsg</CODE> message<A NAME=MARKER-2-290></A></B><P>
<PRE>
PROCEDURE MyLDEFDraw (selected: Boolean; cellRect: Rect;
                      theCell: Cell; dataOffset: Integer;
                      dataLen: Integer; theList: ListHandle);
VAR
   savedPort:     GrafPtr;          {old graphics port}
   savedClip:     RgnHandle;        {old clip region}
   savedPenState: PenState;         {old pen state}
   myPicture:     PicHandle;        {handle to a picture}
BEGIN
   {set up the drawing environment}
   GetPort(savedPort);              {remember the port}
   SetPort(theList^^.port);         {set port to list's port}
   savedClip := NewRgn;             {create new region}
   GetClip(savedClip);              {set region to clip region}
   ClipRect(cellRect);              {set clip region to cell }
                                    { rectangle}
   GetPenState(savedPenState);      {remember pen state}
   PenNormal;                       {use normal pen type}
   {draw the cell if it contains data}
   EraseRect(cellRect);             {erase before drawing}
   IF dataLen = SizeOf(PicHandle) THEN
   BEGIN
                                    {get handle to picture}
      LGetCell(@myPicture, dataLen, theCell, theList);
                                    {draw the picture}
      DrawPicture(myPicture, cellRect);
   END;
   {select the cell if necessary}
   IF selected THEN                 {highlight cell}
      MyLDEFHighlight(selected, cellRect, theCell, dataOffset,
                      dataLen, theList);
   {restore graphics environment}
   SetPort(savedPort);              {restore saved port}
   SetClip(savedClip);              {restore clip region}
   DisposeRgn(savedClip);           {free region memory}
   SetPenState(savedPenState);      {restore pen state}
 END;
</PRE>
 The <CODE>MyLDEFDraw</CODE> procedure defined in <A HREF=#MARKER-9-289>Listing 4-30</A> begins by saving characteristics <BR>of the current graphics environment, such as the graphics port, the clipping region, and <BR>the pen state. It also sets the pen to a normal state, and sets the clipping region to the cell's rectangle. The <CODE>MyLDEFDraw</CODE> procedure then draws in the cell rectangle by erasing the rectangle, getting the handle stored as the cell's data, and drawing the picture referenced by that handle. Then, if the cell should be selected, it simply calls <BR>the <CODE>MyLDEFHighlight</CODE> procedure defined in the next section. Before returning, <CODE>MyLDEFDraw</CODE> restores the graphics environment to its previous state and disposes of the memory it used to remember the clipping region.<P>
<DL>
<DT><B>Note</B>
<DD>For more information on the QuickDraw routines and data structures used in <A HREF=#MARKER-9-289>Listing 4-30</A>, see <I><A HREF="../QuickDraw/QuickDraw-2.html">Inside Macintosh: Imaging with QuickDraw</A></I>.<EM></EM><A NAME=MARKER-9-366></A>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
<A NAME=HEADING219-30></A>
<H3>Responding to the Highlighting Message<A NAME=MARKER-2-302></A></H3>
 Virtually every list definition procedure should respond to the <CODE>lHiliteMsg</CODE> message in the same way, by inverting the bits in the cell's rectangle. Your list definition procedure would need to respond in a different way if selected list items should not simply be highlighted. For example, in a list of patterns, simply highlighting selected cells could confuse the user because highlighted patterns look just like other patterns.<P>
 <A HREF=#MARKER-9-293>Listing 4-31</A> shows how your list definition procedure can respond to the <CODE>lHiliteMsg</CODE> message in a way that is compatible with all Macintosh models, including models that do not support Color QuickDraw. <P>
<B>Listing 4-31  <A NAME=MARKER-9-293></A>Responding to the <CODE>lHiliteMsg</CODE> message<A NAME=MARKER-2-294></A></B><P>
<PRE>
PROCEDURE MyLDEFHighlight (selected: Boolean; cellRect: Rect;
                           theCell: Cell; dataOffset: Integer;
                           dataLen: Integer; theList: ListHandle);
BEGIN
                           {use color highlighting if possible}
   BitClr(Ptr(HiliteMode), pHiliteBit);    
   InvertRect(cellRect);   {highlight cell rectangle}
END;
</PRE>
 For more information on highlighting, see <I><A HREF="../QuickDraw/QuickDraw-2.html">Inside Macintosh: Imaging with QuickDraw</A></I>.<A NAME=MARKER-2-279></A><P>
<A NAME=HEADING219-36></A>
<H3>Responding to the Close Message<A NAME=MARKER-2-250></A></H3>
 The List Manager sends your list definition procedure the <CODE>lCloseMsg</CODE> message immediately before disposing of the data occupied by a list. Your list definition procedure needs to respond to the close message only if it needs to perform some special processing before a list is disposed, such as releasing memory associated with a list that would not be released by the <CODE>LDispose</CODE> procedure.<P>
 The pictures list definition procedure responds to the close message by freeing memory occupied by the list's pictures, whose handles are stored in the list. While the <CODE>LDispose</CODE> procedure will dispose of the picture handles themselves, it cannot dispose of the relocatable blocks referenced by the picture handles.<P>
 <A HREF=#MARKER-9-297>Listing 4-32</A> shows how the pictures list definition procedure responds to the <CODE>lCloseMsg</CODE> message.<P>
<B>Listing 4-32  <A NAME=MARKER-9-297></A>Responding to the <CODE>lCloseMsg</CODE> message<A NAME=MARKER-2-298></A></B><P>
<PRE>
PROCEDURE MyLDEFClose (theList: ListHandle);
   VAR
      aCell:         Cell;          {cell in the list}
      myPicHandle:   PicHandle;     {handle stored as cell data}
      myDataLength:  Integer;       {length in bytes of cell data}
BEGIN
   SetPt(aCell, 0, 0);
   IF PtInRect(aCell, theList^^.dataBounds) THEN
   REPEAT                           
      {free memory only if cell's data is 4 bytes long}
      myDataLength := SizeOf(PicHandle); 
      LGetCell(@myPicHandle, myDataLength, aCell, theList);
      IF myDataLength = SizeOf(PicHandle) THEN
         KillPicture(myPicHandle);
   UNTIL NOT LNextCell(TRUE, TRUE, aCell, theList);
END;
</PRE>
<A NAME=HEADING219-42></A>
<H3>Using the Pictures List Definition Procedure<A NAME=MARKER-2-299></A></H3>
 The pictures list definition procedure introduced in <A HREF=#MARKER-9-282>Listing 4-28</A> can display a list containing pictures. For example, the SurfWriter application uses it to display a list of icons. SurfWriter first creates a list using the <CODE>MyCreateVerticallyScrollingList</CODE> function shown in <A HREF=MoreToolbox-210.html#MARKER-9-138>Listing 4-1 on page 4-18</A>. After creating the list, rather than using the default cell size as calculated by the List Manager, the SurfWriter application sets the size of the cells using the <CODE>LCellSize</CODE> procedure, as shown in <A HREF=#MARKER-9-301>Listing 4-33</A>.<A NAME=MARKER-2-328></A><P>
<B>Listing 4-33  <A NAME=MARKER-9-301></A>Setting the cell size of a list<A NAME=MARKER-2-302></A></B><P>
<PRE>
PROCEDURE MySetCellSizeForIconList(myCellSize: Point;
                                   myList: ListHandle);
BEGIN
   LCellSize(myCellSize, myList);
END;
</PRE>
 To later add an icon to a list of icons, the SurfWriter application uses the procedure shown in <A HREF=#MARKER-9-303>Listing 4-34</A>.<P>
<B>Listing 4-34  <A NAME=MARKER-9-303></A>Adding an icon to a list of icons<A NAME=MARKER-2-304></A></B><P>
<PRE>
PROCEDURE MyAddIconToList(myCellRect: Rect; myPlotRect: Rect;
                          myCell: Cell; theList: ListHandle;
                          VAR myPicHandle: PicHandle; 
                          resID: Integer);
CONST
   kIconWidth     = 32; {width of an icon}
   kIconHeight    = 32; {height of an icon}
   kExtraSpace    = 2;  {extra space on top and to left of icon}
VAR
   myIcon:  Handle;
BEGIN
   {picture occupies entire cell rectangle}
   SetRect(myCellRect, 0, 0, kIconWidth + kExtraSpace, 
           kIconHeight + kExtraSpace);
   {plot icon over portion of rectangle}
   SetRect(myPlotRect, kExtraSpace, kExtraSpace, kIconWidth +
           kExtraSpace, kIconHeight + kExtraSpace);
   {load icon from resource file}
   myIcon := GetIcon(resID);
   {create the picture}
   myPicHandle := OpenPicture(myCellRect);
   PlotIcon(myPlotRect, myIcon);
   ClosePicture;
   {store handle to picture as cell data}
   LSetCell(@myPicHandle, SizeOf(PicHandle), myCell, theList);
   {release icon resource}
   ReleaseResource(myIcon);
END;
</PRE>
 Note that the <CODE>MyAddIconToList</CODE> procedure uses the QuickDraw routines <CODE>OpenPicture</CODE> and <CODE>ClosePicture</CODE> to bracket the set of drawing commands that it uses to define the picture data for a particular cell. It then stores the handle to the picture <BR>as the cell's data, so that the pictures list definition procedure can draw the picture within the cell.<A NAME=MARKER-9-155></A><P>
</BLOCKQUOTE>
<HR>
<center>
<A HREF="MoreToolbox-218.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="MoreToolbox-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="MoreToolbox-513.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="MoreToolbox-220.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="MoreToolbox-3.html">&copy; Apple Computer, Inc.</A><br>6 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>   
