<!-- Generated by Harlequin WebMaker 2.2.3 (23-Apr-1996)
LispWorks 3.2.2 -->
<HTML> <HEAD>
<TITLE>Responding to Mouse Events in a Control(IM:Tb)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING310></A>


<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="Toolbox-309.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Toolbox-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Toolbox-490.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="Toolbox-311.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="Toolbox-2.html"><B>Macintosh Toolbox Essentials</B></A> / <BR><DD><A HREF="Toolbox-297.html"><B>Chapter 5 - Control Manager</B></A> / <A HREF="Toolbox-308.html"><B>Using the Control Manager</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING310-0></A>
<H2><A NAME=MARKER-9-196></A>Responding to Mouse Events in a Control</H2>
 The Control Manager provides several routines to help you detect and respond to mouse events involving controls. For mouse events in controls, you generally perform the following tasks:<A NAME=MARKER-2-197></A><A NAME=MARKER-2-198></A><P>
<OL>
<LI>In your event-handling code, use the Window Manager function <CODE>FindWindow</CODE> to determine the window in which the mouse-down event occurred.
<LI>If the mouse-down event occurred in the content region of your application's active window, use the <CODE>FindControl</CODE> function to determine whether the mouse-down event occurred in an active control and, if so, which control.
<LI>Call <CODE>TrackControl</CODE> to handle user interaction for the control for as long as the user holds the mouse button down. For scroll arrows and the gray areas of scroll bars, you must define an action procedure for <CODE>TrackControl</CODE> to use. This action procedure should cause the document to scroll as long as the user holds down the mouse button. For pop-up menus, you pass <CODE>Pointer(-1)</CODE> in a parameter to <CODE>TrackControl</CODE> to <BR>use the action procedure defined in the pop-up control definition function. For the scroll box in scroll bars and for the other standard controls, you pass <CODE>NIL</CODE> in a parameter to <CODE>TrackControl</CODE> to get the Control Manager's standard response to mouse-down events.
<LI>When <CODE>TrackControl</CODE> reports that the user has released the mouse button with the cursor in a control, respond appropriately. This may require you to use other Control Manager routines, such as <CODE>GetControlValue</CODE> and <CODE>SetControlValue</CODE>, to determine and change control settings.<P>
</OL>
 These and other routines for responding to events involving controls are described in the next several sections.<P>
<DL>
<DT><B>Note</B>
<DD>The Dialog Manager procedure <CODE>ModalDialog</CODE> automatically calls <CODE>FindWindow</CODE>, <CODE>FindControl<DFN>, and TrackControl</DFN></CODE> for mouse-down events in the controls of alert and modal dialog boxes. You can use the Dialog Manager function <CODE>DialogSelect</CODE>, which automatically calls <CODE>FindWindow</CODE>, <CODE>FindControl<DFN>, and TrackControl</DFN></CODE>, to help you handle mouse events in your movable modal and modeless dialog boxes.<A NAME=MARKER-2-199></A><EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
<A NAME=HEADING310-8></A>
<H3>Determining a Mouse-Down Event in a Control</H3>
 <A NAME=MARKER-9-567></A><A NAME=MARKER-2-201></A>When your application receives a mouse-down event, use the Window Manager function <CODE>FindWindow</CODE> to determine the window in which the event occurred. If the cursor was in the content region of your application's active window when the user pressed the mouse button, use the <CODE>FindControl</CODE> function to determine whether the mouse-down event occurred in an active control and, if so, which control.<P>
 When the mouse-down event occurs in a visible, active control, <CODE>FindControl</CODE> returns a handle to that control as well as a part code identifying the control's part. (Note that when the mouse-down event occurs in an invisible or inactive control, or when the cursor is not in a control, <CODE>FindControl</CODE> sets the control handle to <CODE>NIL</CODE> and returns 0 as its part code.)<P>
 A simple control such as a button or checkbox might have just one "part"; a more complex control can have as many parts as are needed to define how the control operates. A scroll bar has five parts: two scroll arrows, the scroll box, and the two gray areas on either side of the scroll box. <A HREF=Toolbox-303.html#MARKER-9-76>Figure 5-4</A> on <A HREF=Toolbox-303.html#MARKER-9-76>page 5-7</A> shows the five parts of a scroll bar.<P>
 <A NAME=MARKER-2-202></A>A <B>part code</B> is an integer from 1 through 253 that identifies a part of a control. To allow different parts of a multipart control to respond to mouse events in different ways, many of the Control Manager routines accept a part code as a parameter or return one as <BR>a result. Part codes are assigned to a control by its control definition function. The standard control definition functions define the following part codes. Also listed are the constants you can use to represent them. 
<TABLE BORDER="0" CELLPADDING=3><TH ALIGN=LEFT>Constant<TH>Part code<TH>Control part<TR>
<TD>inButton<TD>10<TD>Button<A NAME=MARKER-2-11></A><A NAME=MARKER-2-579></A><TR>
<TD>inCheckBox<TD>11<TD>Entire checkbox or radio button<A NAME=MARKER-2-479></A><A NAME=MARKER-2-550></A><TR>
<TD><A NAME=MARKER-2-15></A>inUpButton<TD>20<TD>Up scroll arrow for a vertical scroll bar, left scroll arrow for a horizontal scroll bar<A NAME=MARKER-2-192></A><TR>
<TD>inDownButton<TD>21<TD>Down scroll arrow for a vertical scroll bar, right scroll arrow for a horizontal scroll bar<A NAME=MARKER-2-17></A><A NAME=MARKER-2-18></A><TR>
<TD><A NAME=MARKER-2-19></A>inPageUp<TD>22<TD>Gray area above scroll box for a vertical scroll <BR>bar, gray area to left of scroll box for a horizontal <BR>scroll bar<A NAME=MARKER-2-130></A><TR>
<TD>inPageDown<TD>23<TD>Gray area below scroll box for a vertical scroll bar, gray area to right of scroll box for a horizontal <BR>scroll bar<A NAME=MARKER-2-141></A><A NAME=MARKER-9-566></A><TR>
<TD>inThumb<TD>129<TD>Scroll box<A NAME=MARKER-21-651></A><A NAME=MARKER-2-38></A><A NAME=MARKER-2-25></A><A NAME=MARKER-2-26></A><A NAME=MARKER-2-571></A></TABLE>
<P>
 The pop-up control definition function does not define part codes for pop-up menus. Instead (as explained in <A HREF=Toolbox-309.html#MARKER-9-164>"Creating a Pop-Up Menu" beginning on page 5-22</A>), your application should store the handles for your pop-up menus when you create them. <BR>Your application should then test the handles you store against the handles returned <BR>by <CODE>FindControl</CODE> before responding to users' choices in pop-up menus; this is described in more detail later in the next section.<P>
 <A NAME=MARKER-2-203></A><A HREF=#MARKER-9-204>Listing 5-9</A> illustrates an application-defined procedure, <CODE>DoMouseDown</CODE>, that an application might call in response to a mouse-down event. The <CODE>DoMouseDown</CODE> routine first calls the Window Manager function <CODE>FindWindow</CODE>, which returns two values: a pointer to the window in which the mouse-down event occurred and a constant that provides additional information about the location of that event. If <CODE>FindWindow</CODE> returns the <CODE>inContent</CODE> constant, then the mouse-down event occurred in the content area of one of the application's windows.<P>
<B>Listing 5-9  <A NAME=MARKER-9-204></A>Detecting mouse-down events in a window</B><P>
<PRE>
PROCEDURE DoMouseDown (event: EventRecord);
VAR
   part:       Integer;
   thisWindow: WindowPtr;
BEGIN       {handle mouse-down event}
   part := FindWindow(event.where, thisWindow);
   CASE part OF
      inMenuBar:
         ;  {mouse-down in menu bar, respond appropriately here}
      inContent: 
         IF thisWindow &lt;&gt; FrontWindow THEN
            {mouse-down in an inactive window; use SelectWindow }
            { to make it active here}
         ELSE        {mouse-down in the active window}
            DoContentClick(thisWindow, event);
      {handle other cases here}
   END; {of CASE statement}
END;  {DoMouseDown}
</PRE>
 In <A HREF=#MARKER-9-204>Listing 5-9</A>, when <CODE>FindWindow</CODE> reports a mouse-down event in the content region of a window containing controls, <CODE>DoMouseDown</CODE> calls another application-defined procedure, <CODE>DoContentClick</CODE>, and passes it the window pointer returned by the <CODE>FindWindow<DFN> function</DFN></CODE> as well as the event record.<A NAME=MARKER-2-312></A><P>
 <A HREF=#MARKER-9-206>Listing 5-10</A> shows an application-defined procedure, <CODE>DoContentClick</CODE>, that uses this information to determine whether the mouse-down event occurred in a control.<P>
<B>Listing 5-10  <A NAME=MARKER-9-206></A>Detecting mouse-down events in a pop-up menu and a button</B><P>
<PRE>
PROCEDURE DoContentClick (window: WindowPtr; event: EventRecord);
VAR
   mouse:      Point;
   control:    ControlHandle;
   part:       Integer;
   windowType: Integer;
BEGIN
   windowType := MyGetWindowType(window);    {get window type}

   CASE windowType OF 

   kPlaySoundsModelessDialogBox:
      BEGIN
         SetPort(window);
         mouse := event.where;   {get the mouse location}
         GlobalToLocal(mouse);   {convert to local coordinates}
         part := FindControl(mouse, window, control);
         IF control = gSpeedPopUpControlHandle THEN
            {mouse-down in Modem Speed pop-up menu}
            DoPopUpMenu(mouse, control);
         CASE part OF
            inButton:   {mouse-down in Play button}
               DoPlayButton(mouse, control);
            inCheckBox: {mouse-down in checkbox}
               DoDrumRollCheckBox(mouse, control);
            OTHERWISE
            ;
         END;  {of CASE for control part codes}
      END;  {of kPlaySoundsModelessDialogBox case}
   {handle other window types, such as document windows, here}
   END; {of CASE for window types}
END; {of DoContentClick}
</PRE>
 <A HREF=#MARKER-9-208>Figure 5-15</A> shows the Play Sounds window; <CODE>DoContentClick</CODE> uses the <CODE>FindControl</CODE> function to determine whether the mouse-down event occurred in the pop-up menu, the Play button, or the Add Drum Roll checkbox.<P>
 First, however, <CODE>DoContentClick</CODE> uses the event record to determine the cursor location, which is specified in global coordinates. Because the <CODE>FindControl</CODE> function expects the cursor location in coordinates local to the window, <CODE>DoContentClick</CODE> uses the QuickDraw procedure <CODE>GlobalToLocal</CODE> to convert the point stored in the <CODE>where<DFN> field of the event record to coordinates local to the current window. The</DFN></CODE> <CODE>GlobalToLocal<DFN> procedure takes one parameter, a point in global coordinates--where the upper-left corner of the entire bit image is coordinate (0,0). See <I>Inside Macintosh: Imaging for more information about the GlobalToLocal procedure.<A NAME=MARKER-2-75></A></I> </DFN></CODE><P>
<B>Figure 5-15  <A NAME=MARKER-9-208></A>Three controls in a window</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/CM-S-12.jpg"><P>
 <DFN>When </DFN>it<DFN> calls <CODE>FindControl, DoContentClick passes the </CODE></DFN>cursor<DFN> location in the window's local coordinates as well as the pointer returned earlier by the <CODE>FindWindow</CODE></DFN> function (shown in <A HREF=#MARKER-9-204>Listing 5-9 on page 5-29</A>).<P>
 If the cursor is in a control, <CODE>FindControl</CODE> returns a handle to the control and a part code indicating the control part. Because the pop-up control definition function does <BR>not define control parts, <CODE>DoContentClick</CODE> tests the control handle returned by <CODE>FindControl</CODE> against a pop-up menu's control handle that the application stores <BR>in its own global variable. If these are handles to the same control, <CODE>DoContentClick</CODE> calls another application-defined routine, <CODE>DoPopUpMenu</CODE>. <P>
 After checking whether <CODE>FindControl</CODE> returns a control handle to a pop-up menu, <CODE>DoContentClick</CODE> uses the part code that <CODE>FindControl</CODE> returns to determine whether the cursor is in one of the other two controls. If <CODE>FindControl</CODE> returns the <CODE>inButton</CODE> constant, <CODE>DoContentClick</CODE> calls another application-defined routine, <CODE>DoPlayButton</CODE>. If <CODE>FindControl</CODE> returns the <CODE>inCheckBox</CODE> constant, <CODE>DoContentClick</CODE> calls another application-defined routine, <CODE>DoDrumRollCheckBox</CODE>. <P>
 As described in the next section, all three of these application-defined routines--<CODE>DoPopUpMenu</CODE>, <CODE>DoPlayButton</CODE>, and <CODE>DoDrumRollCheckBox</CODE>--in turn use the <CODE>TrackControl</CODE> function to follow and respond to the user's mouse movements in <BR>the control reported by <CODE>FindControl</CODE>.<A NAME=MARKER-2-175></A><P>
<A NAME=HEADING310-29></A>
<H3>Tracking the Cursor in a Control</H3>
 After using the <CODE>FindControl<DFN> function to </DFN></CODE>determine that the user pressed the mouse button when the cursor was in a control, use the <CODE>TrackControl</CODE> function first to follow and respond to the user's mouse movements, and then to determine which control part contains the cursor when the user releases the mouse button.<P>
 <A NAME=MARKER-2-180></A>Generally, you use <CODE>TrackControl</CODE> after using the <CODE>FindControl<DFN> function to </DFN></CODE>determine that the mouse-down event occurred in a control. You pass to <CODE>TrackControl</CODE> the control handle returned by the <CODE>FindControl</CODE> function, and you<DFN> </DFN>also pass to <CODE>TrackControl<DFN> the same point you passed to FindControl</DFN></CODE> (that is, a point in coordinates local to the window).<P>
 The <CODE>TrackControl</CODE> function follows the movements of the cursor in a control and provides visual feedback until the user releases the mouse button. The visual feedback given by <CODE>TrackControl</CODE> depends on the control part in which the mouse-down event occurred. When highlighting the control is appropriate--in a button, for example--<CODE>TrackControl</CODE> highlights the control part (and removes the highlighting when the user releases the mouse button). When the user presses the mouse button while the cursor is in an indicator (such as the scroll box of a scroll bar) and then moves the mouse, <CODE>TrackControl</CODE> responds by dragging a dotted outline of the indicator. <A HREF=Toolbox-305.html#MARKER-9-99>Figure 5-8</A> on <A HREF=Toolbox-305.html#MARKER-9-99>page 5-10</A> illustrates how <CODE>TrackControl</CODE> provides visual feedback.<A NAME=MARKER-2-211></A><A NAME=MARKER-2-134></A><P>
 <A NAME=MARKER-2-193></A>You can also use an action procedure to undertake additional actions as long as the user holds down the mouse button. For example, if the user is working in a text document and holds down the mouse button while the cursor is in a scroll arrow, your action procedure should continuously scroll through the document one line (or some equivalent measure) at a time until the user releases the button or reaches the end of the document. You pass a pointer to this procedure to <CODE>TrackControl</CODE>. (<A HREF=Toolbox-312.html#MARKER-9-279>"Scrolling in Response to Events in Scroll Arrows and Gray Areas" beginning on page 5-52</A> describes how to do this.)<P>
 The <CODE>TrackControl</CODE> function returns the control's part code if the user releases <BR>the mouse button while the cursor is inside the control part, or 0 if the user releases the mouse button while the cursor is outside the control part. Unless <CODE>TrackControl</CODE> returns 0 as its function result, your application should then respond as appropriate to <BR>a mouse-up event in that control part. When <CODE>TrackControl</CODE> returns 0 as its function result, your application should do nothing. <P>
 <A HREF=#MARKER-9-214>Listing 5-11</A> on the next page shows an application-defined procedure, <CODE>DoPlayButton</CODE>, that uses <CODE>TrackControl</CODE> to track mouse-down events in the Play button shown in <A HREF=#MARKER-9-208>Figure 5-15</A>. The <CODE>DoPlayButton</CODE> routine passes, to <CODE>TrackControl</CODE>, the control handle returned by <CODE>FindControl</CODE>. The <CODE>DoPlayButton</CODE> routine also passes to <CODE>TrackControl<DFN> the same cursor location it passed to FindControl</DFN></CODE> (that is, a point in local coordinates). Because buttons don't need an action procedure, <CODE>NIL</CODE> is passed as the final parameter <BR>to <CODE>TrackControl</CODE>.<P>
<B>Listing 5-11  <A NAME=MARKER-9-214></A>Using the <CODE>TrackControl</CODE> function with a button</B><P>
<PRE>
PROCEDURE DoPlayButton (mouse: Point; control: ControlHandle);
BEGIN
   IF TrackControl(control, mouse, NIL) &lt;&gt; 0 THEN  {user clicks Play}
   BEGIN
      IF gPlayDrumRoll = TRUE THEN  {user clicked Play Drum Roll checkbox }
         DoPlayDrumRoll;            { so play a drum roll first}
      SysBeep(30);   {always play system alert sound when user clicks Play}
   END;
END;  
</PRE>
 When the user presses the mouse button when the cursor is in the Play button, <CODE>TrackControl</CODE> inverts the Play button. If the user releases the mouse button after moving the cursor outside the control part, <CODE>TrackControl</CODE> stops inverting the <BR>button and returns the value 0, in which case <CODE>DoPlayButton</CODE> does nothing.<P>
 If, however, the user releases the mouse button with the cursor in the Play button, <CODE>TrackControl</CODE> stops inverting the Play button and returns the value for the <CODE>inButton</CODE> constant. Then <CODE>DoPlayButton</CODE> calls the Sound Manager procedure <CODE>SysBeep</CODE> to play the system alert sound (which is described in the chapter "Dialog Manager" in this book). Before releasing the mouse button, the user can move the cursor away from the control part and then return to it, and <CODE>TrackControl</CODE> will still return the part code when the user releases the mouse button.<P>
 <A NAME=MARKER-2-331></A><A NAME=MARKER-2-216></A><A NAME=MARKER-2-217></A>For buttons, checkboxes, radio buttons, and the scroll box in a scroll bar, your application typically passes <CODE>NIL</CODE> to <CODE>TrackControl</CODE> to use no action procedure. However, <CODE>TrackControl</CODE> still responds visually to mouse events in active controls. That is, when the user presses the mouse button with the cursor over a control whose action procedure is set to <CODE>NIL</CODE>, <CODE>TrackControl</CODE> changes the control's display appropriately until the user releases the mouse button. <P>
 For scroll arrows and for the gray areas of a scroll box, you need to define your own action procedures. You pass a pointer to the action procedure as one of the parameters to <CODE>TrackControl</CODE>, as described in <A HREF=Toolbox-312.html#MARKER-9-279>"Scrolling in Response to Events in Scroll Arrows and Gray Areas" beginning on page 5-52</A>. <P>
 For a pop-up menu, you must pass <CODE>Pointer(-1)</CODE> to <CODE>TrackControl</CODE> for its action procedure; this causes <CODE>TrackControl</CODE> to use the action procedure defined in the pop-up control definition function.<A NAME=MARKER-2-218></A> <A NAME=MARKER-2-219></A><A NAME=MARKER-2-220></A><P>
 <A HREF=#MARKER-9-206>Listing 5-10 on page 5-30</A> calls an application-defined routine, <CODE>DoPopUpMenu</CODE>, when <CODE>FindControl</CODE> reports a mouse-down event in a pop-up menu. <A HREF=#MARKER-9-221>Listing 5-12</A> shows how <CODE>DoPopUpMenu</CODE> uses <CODE>TrackControl</CODE> to handle user interaction in the pop-up menu. By passing <CODE>Pointer(-1</CODE>) to <CODE>TrackControl</CODE>, <CODE>DoPopUpMenu</CODE> uses the action procedure defined in the pop-up control definition function.<P>
<B>Listing 5-12  <A NAME=MARKER-9-221></A>Using <CODE>TrackControl</CODE> with a pop-up menu</B><P>
<PRE>
PROCEDURE DoPopUpMenu (mouse: Point; control: ControlHandle);
VAR
   menuItem:   Integer;
   part:       Integer;
BEGIN
   part := TrackControl(control, mouse, Pointer(-1));
   menuItem := GetControlValue(control);
   IF menuItem &lt;&gt; gCurrentItem THEN
   BEGIN
      gCurrentItem := menuItem;
      SetMyCommunicationSpeed; {use speed stored in gCurrentItem}
   END;
END; {of DoPopUpMenu}
</PRE>
 The action procedure for pop-up menus highlights the pop-up menu title, displays the pop-up menu, and handles all user interaction while the user drags up and down the menu. When the user releases the mouse button, the action procedure closes the pop-up box, draws the user's choice in the pop-up box (or restores the previous item if the user doesn't make a new choice), and removes the highlighting of the pop-up title. The pop-up control definition function then changes the value of the <CODE>contrlValue</CODE> field of the control record to the number of the menu item chosen by the user.<A NAME=MARKER-2-222></A><A NAME=MARKER-21-333></A><P>
 Because buttons do not retain settings, responding to them is very straightforward: when the user clicks a button, your application should immediately undertake the action described by the button's title. For pop-up menus and other types of controls, you must determine their current settings before responding to the user's action. For example, before responding, you need to know which item the user has chosen in a pop-up menu, whether a checkbox is checked, or how far the user has moved the scroll box. The action you take may, in turn, involve changing other control settings. Determining and changing control settings are described in the next section.<A NAME=MARKER-2-224></A><A NAME=MARKER-9-589></A> <A NAME=MARKER-9-586></A><P>
 After learning how to determine and change control settings, see <A HREF=Toolbox-312.html#MARKER-9-245>"Scrolling Through a Document" beginning on page 5-40</A> for a detailed discussion of how to respond to mouse events in scroll bars.<P>
</BLOCKQUOTE>
<HR>
<center>
<A HREF="Toolbox-309.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Toolbox-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Toolbox-490.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="Toolbox-311.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="Toolbox-3.html">&copy; Apple Computer, Inc.</A><br>11 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>  
