/*	File:		FileSharingOn.c		Description:This snippet demonstrates how to determine whether or not File Sharing is on.	Author:		VMC		Copyright: 	Copyright: © 1996-1999 by Apple Computer, Inc.				all rights reserved.		Disclaimer:	You may incorporate this sample code into your applications without				restriction, though the sample code has been provided "AS IS" and the				responsibility for its operation is 100% yours.  However, what you are				not permitted to do is to redistribute the source as "DSC Sample Code"				after having made changes. If you're going to re-distribute the source,				we require that you make it clear in the source that the code was				descended from Apple Sample Code, but that you've made changes.		Change History (most recent first):				6/25/99	Updated for Metrowerks Codewarror Pro 2.1(KG)*/#include <StandardFile.h>#include "FileSharingOn.h"/*****  globals *****/Boolean					gQuitTheApp = false;		/* true = quit program *//*****	main() *****/void main(){	short			sleepTime  =  60;	EventRecord		myEvent;		initApp();								/* call initialization routine */	setUpMenus();	do	{		if (WaitNextEvent(everyEvent, &myEvent, sleepTime, NIL))			switch (myEvent.what)			{				case mouseDown:					doMousedown(&myEvent);					break;									case keyDown:				case autoKey:					doKey(&myEvent);					break;				case kHighLevelEvent:					doHighLevel(&myEvent);					break;				case activateEvt:					break;								case updateEvt:					doUpdate(&myEvent);					break; 								case diskEvt:					break;							case osEvt:				/*  I don't really care yet. */					break;			}	}  while (!gQuitTheApp);			} 				/* end of main *//*****	initApp() *****/void initApp(){		/* Memory specific initializations. */		MaxApplZone();				/* grow the heap to its maximum size */	MoreMasters();		   		/* create more master pointers		 */	MoreMasters();	MoreMasters();	MoreMasters();	MoreMasters();	/* Initializing the ROM Managers */		InitGraf((Ptr) &qd.thePort);	InitFonts();	InitWindows();	InitMenus();	FlushEvents(everyEvent,0);	TEInit();	InitDialogs(NIL);	InitCursor();		if (!checkGestaltFeatures())		ExitToShell();		/* Install the required Apple Event Handlers */	if (!installAEHandlers())		ExitToShell();}				/* end of initApp() *//*****  checkGestaltFeatures() *****/Boolean checkGestaltFeatures(){	long		gestaltFeature;	OSErr		myErr;	myErr = Gestalt(gestaltSystemVersion, &gestaltFeature); 	/* which SysVersion present? */	if (myErr == noErr)	{		gestaltFeature = (gestaltFeature >> 8) & 0xf; 										/* shift result over & mask out major version number */		if (gestaltFeature < 7) 		/* This is a System 7+ shell.  We quit otherwise. */		{			StopAlert(BADSYSTEMID, nil);			return(false);		}	}		if (myErr == noErr)	{		myErr = Gestalt(gestaltQuickdrawVersion, &gestaltFeature);													/* we want color QD cuz we're spoiled */		if (myErr == noErr)		{			if(gestaltFeature < gestalt32BitQD)			{				StopAlert(BADQUICKDRAWID, nil);				return(false);			}		}	}				if (myErr == noErr)	{		myErr = Gestalt(gestaltAppleEventsAttr, &gestaltFeature);		if (myErr == noErr)		{			if (!(gestaltFeature & 0xf))			{				StopAlert(NOAPPLEEVENTS, nil);				return(false);			}		}	}	if (!myErr)				return(true);			/* if there was an error we cannot continue */	else	{		return(false);			/* we made it through without a hitch */	}}/*****	installAEHandlers *****/Boolean installAEHandlers(){	OSErr		myErr;		myErr = AEInstallEventHandler ( kCoreEventClass, 					kAEOpenApplication, NewAEEventHandlerProc(DoOpenAppAE), 0L, false );	if (myErr == noErr)		myErr = AEInstallEventHandler ( kCoreEventClass,					kAEOpenDocuments, NewAEEventHandlerProc(DoOpenDocAE), 0L, false );	if (myErr == noErr)		myErr = AEInstallEventHandler ( kCoreEventClass,					kAEPrintDocuments, NewAEEventHandlerProc(DoPrintDocAE), 0L, false );	if (myErr == noErr)		myErr = AEInstallEventHandler ( kCoreEventClass,					kAEQuitApplication, NewAEEventHandlerProc(DoQuitAppAE), 0L, false );	if (myErr)		return(false);	else		return(true);}/*****	setUpMenus() 			This will put up our menus.  Be sure to read the comments by the			AppendMenu() and SetItem() calls to see how different options			behave.		*****/void setUpMenus(){	short			n;	MenuHandle		theMenu;		for (n = 0; n < MAXMENUS; n++)	{		theMenu = GetMenu(FIRSTMENUID + n);		if (theMenu)  							InsertMenu(theMenu, 0);	}	theMenu = GetMenuHandle(APPLEMENU);	if (theMenu)		AppendResMenu(theMenu, 'DRVR');		DrawMenuBar();	return;}					/* end of setUpMenus()  *//*****	setUpWindow() *****/void setUpWindow( void ){	WindowPtr	myWind;	myWind = GetNewCWindow(WINDOWID, nil, PUTINFRONT);	if (myWind != nil)	{		ShowWindow(myWind);	}}/*****	doMousedown()			We figure out where the user has clicked the mouse.  If the user			clicks anywhere but the menu bar, we beep.  Otherwise, we figure			out which menu they have clicked and dispatch.*****/void doMousedown(EventRecord *eventRec){	short		windPart;	WindowPtr	myWind;	long		menuResult;		windPart = FindWindow(eventRec->where, &myWind);		switch(windPart)	{		case inContent:			SelectWindow(myWind);			break;		case inDrag:			DragWindow( myWind, eventRec->where, &qd.screenBits.bounds );			break;		case inMenuBar:			menuResult = MenuSelect(eventRec->where);			dispatch(menuResult);			break;		case inSysWindow:			SystemClick( eventRec, myWind );			break;					case inGoAway:			gQuitTheApp = true;			break;					default:			break;	}	return;} 				/* end of doMousedown *//***** 	doKey()			We ignore keys pressed unless they are accompanied by a 			command key.  Then we dispatch.*****/void doKey(EventRecord *eventRec){	char	keyPressed;	long	menuResult;		keyPressed = (char) (eventRec->message & charCodeMask);		if((eventRec->modifiers & cmdKey) != 0)	{		menuResult = MenuKey(keyPressed);		dispatch(menuResult);		}	return;} 				/* end of do_key *//*****	doHighLevel() *****/void doHighLevel(EventRecord *eventRec){	OSErr myErr;	myErr = AEProcessAppleEvent(eventRec);}pascal OSErr	DoOpenAppAE(AppleEvent theAppleEvent, AppleEvent reply, long refCon){	#pragma unused(theAppleEvent, reply, refCon)		setUpWindow();	return(noErr);}pascal OSErr	DoOpenDocAE(AppleEvent theAppleEvent, AppleEvent reply, long refCon){	#pragma unused(theAppleEvent, reply, refCon)		return(noErr);}pascal OSErr	DoPrintDocAE(AppleEvent theAppleEvent, AppleEvent reply, long refCon){	#pragma unused(theAppleEvent, reply, refCon)		return(noErr);}pascal OSErr	DoQuitAppAE(AppleEvent theAppleEvent, AppleEvent reply, long refCon){	#pragma unused(theAppleEvent, reply, refCon)		gQuitTheApp = true;	return(noErr);}/***** doUpdate() *****/void	doUpdate(EventRecord *eventRec){	GrafPtr		savedPort;	WindowPtr	theWindow;	theWindow = (WindowPtr) eventRec->message;		GetPort(&savedPort);	SetPort((GrafPtr) theWindow);	BeginUpdate(theWindow);	EndUpdate(theWindow);	SetPort(savedPort);}/***** 	dispatch()			We determine which menu the user has chosen (either with mouse			or with command keys) and jump to the routine that handles			that menu's commands.*****/void dispatch(long menuResult){	short		theMenu;			/* menu selected */	short		theItem;			/* item selected */		theMenu = HiWord (menuResult);		/* menuID selected */	theItem = LoWord (menuResult);		/* item# selected */		switch (theMenu)	{		case APPLEMENU:			doAppleCmds(theItem);			break;		case FILEMENU:			doFileCmds(theItem);			break;					case EDITMENU:			break;		case TESTMENU:			doTestCmds(theItem);			break;	}	HiliteMenu(0);}				/* end of dispatch *//***** 	doAppleCmds() 			When the user chooses the "About MyMenuText" item, we display the			About box.  If the user chooses a DA, we open the DA.*****/void doAppleCmds(short theItem){		MenuHandle		myMenu;	Str255			name;	short			dummy;		if(theItem == appleABOUT)	{		Alert(ABOUTID, (ModalFilterUPP) NIL);	}	else	{		myMenu = GetMenuHandle (APPLEMENU);		if (myMenu)		{			GetMenuItemText(myMenu, theItem, name);			dummy = OpenDeskAcc(name);		}	}	return;} 				/* end of doAppleCmds *//*****	doFileCmds() 			When the user chooses Quit on the File menu, we quit.*****/void doFileCmds (short theItem){	switch (theItem)	{					case fileQUIT:			gQuitTheApp = true;			break;	}	return;} /* end of doFileCmds *//*****	doTestCmds()			When the user chooses the item in the Test menu, they			will get to choose a folder with a custom icon*****/void doTestCmds (short theItem){			switch (theItem)	{		case testDOTHETEST:			theTest();			break;				}		return;}				/* end of doTestCmds */void theTest(){	Boolean		sharingOn;		sharingOn = sharingIsOn();	if (sharingOn)		DebugStr("\pSharing is on.");}/*	This is a C version of code in Inside Mac:Files for determining	if FileSharing is active on a particular Macintosh.	sharingIsOn indexes through all the local volumes on	a Macintosh with PBHGetVInfo(), so we can obtain true volume	reference number information.  We can take the vRefNum we obtain	and pass it to the volIsSharable() routine until we find a volume	for which FileSharing is truly active.  If we get an error, for	example, if we run out of volumes and get an error -35 (nsvErr), 	or if we find that FileSharing is active on a volume, then we drop	out of our while loop and return the results.*/Boolean sharingIsOn(){	Boolean			sharing = false;	HParamBlockRec	myHPB;	OSErr			myErr;	short			volIndex = 1;		do	{		myHPB.volumeParam.ioNamePtr = nil;		myHPB.volumeParam.ioVolIndex = volIndex;				myErr = PBHGetVInfoSync(&myHPB);		if (myErr == noErr)			sharing = volIsSharable(myHPB.volumeParam.ioVRefNum);		volIndex++;	} while ((myErr == noErr) && (!sharing));		return(sharing);}/*	volIsSharable lets us know if the bHasPersonalAccessPrivileges bit	of the vMAttrib field of the GetVolParmsInfoBuffer is set, which 	indicates that FileSharing is active.*/Boolean volIsSharable(short vRefNum){	HParamBlockRec			myHPB;	GetVolParmsInfoBuffer	myInfoBuffer;	OSErr					myErr;		myHPB.ioParam.ioNamePtr = nil;	myHPB.ioParam.ioVRefNum = vRefNum;	myHPB.ioParam.ioBuffer = (Ptr) &myInfoBuffer;	myHPB.ioParam.ioReqCount = sizeof(GetVolParmsInfoBuffer);		myErr = PBHGetVolParmsSync(&myHPB);	if (myErr == noErr)	{		if (((myInfoBuffer.vMAttrib) & (1L << bHasPersonalAccessPrivileges)) != 0)			return(true);		else			return(false);	}	else		return(false);}