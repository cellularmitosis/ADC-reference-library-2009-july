<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>Resource Programming Guide: Nib Files</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Nib Files"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/10000051i-CH4" title="Nib Files"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../index.html#//apple_ref/doc/uid/TP30000440-TP30000416" target="_top">Cocoa</a> &gt; <a href="../../../ResourceManagement-date.html#//apple_ref/doc/uid/TP30000440-TP30000416-TP30000458" target="_top">Resource Management</a> &gt; <a href="../Introduction/Introduction.html#//apple_ref/doc/uid/10000051i-CH1-SW1">Resource Programming Guide</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../MOSXResources/MOSXResources.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../Strings/Strings.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/10000051i-CH4-SW8" title="Nib Files"></a><h1>Nib Files</h1><p>Nib files play an important role in the creation of applications in Mac OS X and iPhone OS. Nib files let you create and manipulate your user interfaces graphically, using the Interface Builder application, instead of programmatically. Because you can see the results of your changes instantly, this gives you the ability to experiment with different layouts and configurations very quickly. It also gives you the flexibility to change many aspects of your user interface later without rewriting any code. </p><p>For applications built using the AppKit or UIKit frameworks, nib files take on an extra significance. Both of these frameworks support the use of nib files both for the visual layout of windows, views, and controls and also for the integration of those items with the application’s event handling code. Interface Builder works in conjunction with these frameworks, and with Xcode, to help you connect the controls of your user interface to the objects in your project that respond to those controls. This integration significantly reduces the amount of setup that is required after a nib file is loaded and also makes it easy to change the relationships between your code and user interface later.</p><p>Because the level of support for nib files is more extensive in Cocoa applications than it is for Carbon applications, the following sections focus on the use of nib files with the AppKit and UIKit frameworks. Although Carbon applications can also use nib files, they do so in a very different way than both AppKit and UIKit, and so the use of nib files in Carbon applications is discussed separately in <span class="content_text"><a href="../CarbonNibs/CarbonNibs.html#//apple_ref/doc/uid/10000051i-CH5-SW1">“Carbon Resources.”</a></span> </p><div class="notebox"><a name="//apple_ref/doc/uid/10000051i-CH4-SW2" title="Note"></a><p><strong>Note:</strong>&nbsp;Although you can create an Objective-C application without using nib files, doing so is very rare and not recommended. Depending on your application, avoiding the use of nib files can involve overriding large amounts of framework behavior to achieve the same results you would get using a nib file.  </p></div>
<!-- This template is being used for both PDF and HTML. -->

    
    <h4>In this section:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="CocoaNibs.html#//apple_ref/doc/uid/10000051i-CH4-SW13">Anatomy of a Nib File</a>
				
			<br/>
			
        
			
			
				<a href="CocoaNibs.html#//apple_ref/doc/uid/10000051i-CH4-SW4">Nib File Design Guidelines</a>
				
			<br/>
			
        
			
			
				<a href="CocoaNibs.html#//apple_ref/doc/uid/10000051i-CH4-SW18">The Nib Object Life Cycle</a>
				
			<br/>
			
        
			
			
				<a href="CocoaNibs.html#//apple_ref/doc/uid/10000051i-CH4-SW20">Built-In Support For Nib Files</a>
				
			<br/>
			
        
			
			
				<a href="CocoaNibs.html#//apple_ref/doc/uid/10000051i-CH4-SW24">Loading Nib Files Programmatically</a>
				
			<br/>
			
        
			
			
				<a href="CocoaNibs.html#//apple_ref/doc/uid/10000051i-CH4-SW32">Connecting Menu Items Across Nib Files</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/10000051i-CH4-SW13" title="Anatomy of a Nib File"></a><h2>Anatomy of a Nib File</h2><p>Nib files are the documents produced by the Interface Builder application. A nib file describes the visual elements of your application’s user interface, including windows, views, controls, and many others. It can also describe non-visual elements, such as the objects in your application that manage your windows and views.Most importantly, a nib file describes these objects exactly as they were configured in Interface Builder. At runtime, these descriptions are used to recreate the objects and their configuration inside your application. When you load a nib file at runtime, you get an exact replica of the objects that were in your Interface Builder document. The nib-loading code instantiates the objects reestablishes all of the properties and connections that were present between the objects in Interface Builder. </p><p>The following sections describe how nib files used with the AppKit and UIKit frameworks are organized, the types of objects found in them, and how you use those objects effectively.</p><a name="//apple_ref/doc/uid/10000051i-CH4-SW14" title="About Your Interface Objects"></a><h3>About Your Interface Objects</h3><p>Interface objects are what you add to an Interface Builder document to implement your user interface. When a nib is loaded at runtime, the interface objects are the objects actually instantiated by the nib-loading code. Most new documents in Interface Builder have at least one interface object by default, typically a window or menu resource, and you add more interface objects to a nib file as part of your interface design. This is the most common type of object in a nib file and is typically why you create nib files in the first place. </p><p>Besides representing visual objects, such as windows, views, controls, and menus, interface objects can also represent non-visual objects. In nearly all cases, the non-visual objects you add to a nib file are extra controller objects that your application uses to manage the visual objects. Although you could create these objects in your application, it is often more convenient to add them to a nib file and configure them there. Interface Builder provides a generic object that you use specifically when adding controllers and other non-visual objects to a nib file. It also provides the controller objects that are typically used to manage Cocoa bindings. </p><a name="//apple_ref/doc/uid/10000051i-CH4-SW15" title="About the File&acirc;&#128;&#153;s Owner"></a><h3>About the File’s Owner</h3><p>One of the most important objects in a nib file is the File’s Owner object. Unlike interface objects, the File’s Owner object is a proxy object that is not created when the nib file is loaded. Instead, you create this object in your code and pass it to the nib-loading code. The reason this object is so important is that it is the main link between your application code and the contents of the nib file. More specifically, it is the controller object that is responsible for the contents of the nib file.</p><p>In Interface Builder, you can create connections between the File’s Owner and the other interface objects in your nib file. When you load the nib file, the nib-loading code recreates these connections using the replacement object you specify. This allows your object to reference objects in the nib file and receive messages from the interface objects automatically. </p><a name="//apple_ref/doc/uid/10000051i-CH4-SW16" title="About the First Responder"></a><h3>About the First Responder</h3><p>In Interface Builder, the First Responder is a proxy object that represents the first object in your application’s dynamically determined responder chain. Because the responder chain of an application cannot be determined at design time, the First Responder proxy acts as a stand-in target for any action messages that need to be directed at the application’s responder chain. Menu items commonly target the First Responder proxy. For example, the Minimize menu item in the Window menu hides the frontmost window in an application, not just a specific window, and the Copy menu item should copy the current selection, not just the selection of a single control or view. Other objects in your application can target the First Responder as well.</p><p>When you load a nib file into memory, there is nothing you have to do to manage or replace the First Responder proxy object. The AppKit and UIKit frameworks automatically set and maintain the first responder based on the application’s current configuration.</p><p>For more information about the responder chain and how it is used to dispatch events in AppKit–based applications, see <span class="content_text"><a href="../../EventOverview/EventArchitecture/EventArchitecture.html#//apple_ref/doc/uid/10000060i-CH3" target="_top">Event Architecture</a></span> in<em><a href="../../EventOverview/index.html#//apple_ref/doc/uid/10000060i" target="_top">Cocoa Event-Handling Guide</a></em>. For information about the responder chains and handling actions in iPhone applications, see <em><!--a target="_top" -->iPhone Application Programming Guide<!--/a--></em>. </p><a name="//apple_ref/doc/uid/10000051i-CH4-SW17" title="About the Top-Level Objects"></a><h3>About the Top-Level Objects</h3><p>When your program loads a nib file, Cocoa recreates the entire graph of objects you created in Interface Builder. This object graph includes all of the windows, views, controls, cells, menus, and custom objects found in the nib file. The <strong>top-level objects</strong> are the subset of these objects that do not have a parent object. The top-level objects typically include only the windows, menubars, and custom controller objects that you add to the nib file. (Objects such as File’s Owner, First Responder, and Application are proxy objects and not considered top-level objects.) In Interface Builder, you can see the top-level objects in the nib document window when it is set to icon mode (see the circled items in <span class="content_text">Figure 2-1</span>). </p><br/><div><a name="//apple_ref/doc/uid/10000051i-CH4-SW3" title="Figure 2-1Top-level objects in a nib file"></a><p><strong>Figure 2-1&nbsp;&nbsp;</strong>Top-level objects in a nib file</p><img src = "../Art/docwindow.jpg" alt = "Top-level objects in a nib file" ></div><br/><p>Typically, you use outlets in the File’s Owner object to store references to the top-level objects of a nib file. If you do not use outlets, however, you can retrieve the top-level objects from the nib-loading routines directly. You should always keep a pointer to these objects somewhere because your application is responsible for releasing them when it is through using them. For more information about the nib object behavior at load time, see <span class="content_text"><a href="CocoaNibs.html#//apple_ref/doc/uid/10000051i-CH4-SW6">“Nib Object Retention.”</a></span> </p><a name="//apple_ref/doc/uid/10000051i-CH4-SW9" title="About Image and Sound Resources"></a><h3>About Image and Sound Resources</h3><p>In Interface Builder, you can associate external image and sound resources with the contents of your nib files. Some controls and views are able to display images or play sounds as part of their default configuration. The Interface Builder library provides access to the image and sound resources of your Xcode projects so that you can link your nib files to these resources. The nib file does not store these resources directly. Instead, it stores the name of the resource file so that the nib-loading code can find it later. </p><p>When you load a nib file that contains references to image or sound resources, the nib-loading code also reads in those resource files and caches them in memory. In Mac OS X, image and sound resources are stored in named caches so that you can access them later if needed. In iPhone OS, only image resources are stored in named caches. To access images, you use the <code>imageNamed:</code> method of <code><a href="../../../Reference/ApplicationKit/Classes/NSImage_Class/Reference/Reference.html#//apple_ref/occ/cl/NSImage" target="_top">NSImage</a></code> or <code><!--a target="_top" -->UIImage<!--/a--></code>, depending on your platform. To access cached sounds in Mac OS X, use the <code><a href="../../../Reference/ApplicationKit/Classes/NSSound_Class/Reference/Reference.html#//apple_ref/occ/clm/NSSound/soundNamed:" target="_top">soundNamed:</a></code> method of <code><a href="../../../Reference/ApplicationKit/Classes/NSSound_Class/Reference/Reference.html#//apple_ref/occ/cl/NSSound" target="_top">NSSound</a></code>.</p><a name="//apple_ref/doc/uid/10000051i-CH4-SW4" title="Nib File Design Guidelines"></a><h2>Nib File Design Guidelines</h2><p>When creating your nib files, it is important to think carefully about how you intend to use the objects in that file. A very simple application might be able to store all of its user interface components in a single nib file, but for most applications, it is better to distribute components across multiple nib files. Creating smaller nib files lets you load only those portions of your interface that you need immediately. Smaller nib files results in better performance for your application. They also make it easier to debug any problems you might encounter, since there are fewer places to look for problems.  </p><p>When creating your nib files, try to keep the following guidelines in mind:</p><ul class="ul"><li class="li"><p>Design your nib files with lazy loading in mind. Plan on loading nib files that contain only those objects you need right away. </p></li><li class="li"><p>In the main nib file for a Mac OS X application, consider storing only the application menu bar and an optional application delegate object in the nib file. Avoid including any windows or user-interface elements that will not be used until after the application has launched. Instead, place those resources in separate nib files and load them as needed after launch.</p></li><li class="li"><p>Store repeated user-interface components (such as document windows) in separate nib files. </p></li><li class="li"><p>For a window or menu that is used only occasionally, store it in a separate nib file. By storing it in a separate nib file, you load the resource into memory only if it is actually used. </p></li><li class="li"><p>Make the File’s Owner the single point-of-contact for anything outside of the nib file; see <span class="content_text"><a href="CocoaNibs.html#//apple_ref/doc/uid/10000051i-CH4-SW7">“Accessing the Contents of a Nib File.”</a></span> </p></li></ul><a name="//apple_ref/doc/uid/10000051i-CH4-SW18" title="The Nib Object Life Cycle"></a><h2>The Nib Object Life Cycle</h2><p>When a nib file is loaded into memory, the nib-loading code takes several steps to that ensure the objects in the nib file are created and initialized properly. Understanding these steps can help you write better controller code to manage your user interfaces. </p><a name="//apple_ref/doc/uid/10000051i-CH4-SW19" title="The Object Loading Process"></a><h3>The Object Loading Process</h3><p>When you use the methods of <code><a href="../../../Reference/ApplicationKit/Classes/NSNib_Class/Reference/Reference.html#//apple_ref/occ/cl/NSNib" target="_top">NSNib</a></code> or <code><a href="../../../Reference/Foundation/Classes/NSBundle_Class/Reference/Reference.html#//apple_ref/occ/cl/NSBundle" target="_top">NSBundle</a></code> to load and instantiate the objects in a nib file, the underlying nib-loading code does the following: </p><ol class="ol"><li class="li"><p>It loads the contents of the nib file and any referenced resource files into memory:</p><ul class="ul"><li class="li"><p>The raw data for the entire nib object graph is loaded into memory but is not unarchived.</p></li><li class="li"><p>Any custom image resources associated with the nib file are loaded and added to the Cocoa image cache; see <span class="content_text"><a href="CocoaNibs.html#//apple_ref/doc/uid/10000051i-CH4-SW9">“About Image and Sound Resources.”</a></span></p></li><li class="li"><p>Any custom sound resources associated with the nib file are loaded and added to the Cocoa sound cache; see <span class="content_text"><a href="CocoaNibs.html#//apple_ref/doc/uid/10000051i-CH4-SW9">“About Image and Sound Resources.”</a></span></p></li></ul></li><li class="li"><p>It unarchives the nib object graph data and instantiates the objects. How it initializes each new object depends on the type of the object and how it was encoded in the archive by Interface Builder. The nib-loading code uses the following rules (in order) to determine which initialization method to use. </p><ol class="ol"><li class="ol ol"><p>Standard Interface Builder objects (and custom subclasses of those objects) receive an <code>initWithCoder:</code> message.</p><p>In Mac OS X, the list of standard objects includes the views, cells, menus, and view controllers that are provided by the system and available in the default Interface Builder library. It also includes any third-party objects that were added to the Interface Builder library using a custom plug-in. Even if you change the class of such an object, Interface Builder encodes the standard object into the nib file and then tells the archiver to swap in your custom class when the object is unarchived.</p><p>In iPhone OS, any object that conforms to the <code><a href="../../../Reference/Foundation/Protocols/NSCoding_Protocol/Reference/Reference.html#//apple_ref/occ/intf/NSCoding" target="_top">NSCoding</a></code> protocol is initialized using the <code>initWithCoder:</code> method. This includes all subclasses of <code><!--a target="_top" -->UIView<!--/a--></code> and <code><!--a target="_top" -->UIViewController<!--/a--></code> whether they are part of the default Interface Builder library or custom classes you define. </p></li><li class="ol ol"><p>Custom views in Mac OS X receive an <code>initWithFrame:</code> message.</p><p>Custom views are subclasses of <code><a href="../../../Reference/ApplicationKit/Classes/NSView_Class/Reference/NSView.html#//apple_ref/occ/cl/NSView" target="_top">NSView</a></code> for which Interface Builder does not have an available implementation. Typically, these are views that you define in your application and use to provide custom visual content. Custom views do not include standard system views (like <code><a href="../../../Reference/ApplicationKit/Classes/NSSlider_Class/Reference/Reference.html#//apple_ref/occ/cl/NSSlider" target="_top">NSSlider</a></code>) that are part of the default Interface Builder library or part of an integrated third-party plug-in. </p><p>When it encounters a custom view, Interface Builder encodes a special <code>NSCustomView</code> object into your nib file. The custom view object includes the information it needs to build the real view subclass you specified. At load time, the <code>NSCustomView</code> object sends an <code>alloc</code> and <code>initWithFrame:</code> message to the real view class and then swaps the resulting view object in for itself. The net effect is that the real view object handles subsequent interactions during the nib-loading process.</p><p>Custom views in iPhone OS do not use the <code>initWithFrame:</code> method for initialization.</p></li><li class="ol ol"><p>Custom objects other than those described in the preceding steps receive an <code>init</code> message. </p></li></ol></li><li class="li"><p>It reestablishes all connections (actions, outlets, and bindings) between objects in the nib file. This includes connections to File’s Owner and other proxy objects. The approach for establishing connections differs depending on the platform:</p><ul class="ul"><li class="li"><p>Outlet connections</p><ul class="nested"><li class="nested li"><p>In Mac OS X, the nib-loading code tries to reconnect outlets using the object’s own methods first. For each outlet, Cocoa looks for a method of the form <code>set</code><em>OutletName</em><code>:</code> and calls it if such a method is present. If it cannot find such a method, Cocoa searches the object for an instance variable with the corresponding outlet name and tries to set the value directly. If the instance variable cannot be found, no connection is created.</p><p>In Mac OS X v10.5 and later, setting an outlet also generates a key-value observing (KVO) notification for any registered observers. These notifications may occur before all inter-object connections are reestablished and definitely occur before any <code>awakeFromNib</code> methods of the objects have been called. Prior to v10.5, these notifications are not generated. For more information about KVO notifications, see <em><a href="../../KeyValueObserving/index.html#//apple_ref/doc/uid/10000177i" target="_top">Key-Value Observing Programming Guide</a></em>. </p></li><li class="nested li"><p>In iPhone OS, the nib-loading code uses the <code><a href="../../../Reference/Foundation/Protocols/NSKeyValueCoding_Protocol/Reference/Reference.html#//apple_ref/occ/instm/NSObject/setValue:forKey:" target="_top">setValue:forKey:</a></code> method to reconnect each outlet. That method similarly looks for an appropriate accessor method and falls back on other means when that fails. For more information about how this method sets values, see its description in <em><a href="../../../Reference/Foundation/Protocols/NSKeyValueCoding_Protocol/index.html#//apple_ref/doc/uid/TP40003780" target="_top">NSKeyValueCoding Protocol Reference</a></em>. </p><p>Setting an outlet in iPhone OS also generates a KVO notification for any registered observers. These notifications may occur before all inter-object connections are reestablished and definitely occur before any <code>awakeFromNib</code> methods of the objects have been called. For more information about KVO notifications, see <em><a href="../../KeyValueObserving/index.html#//apple_ref/doc/uid/10000177i" target="_top">Key-Value Observing Programming Guide</a></em>.</p></li></ul></li><li class="li"><p>Action connections</p><ul class="nested"><li class="nested li"><p>In Mac OS X, the nib-loading code uses the source object’s <code><a href="../../../Reference/ApplicationKit/Classes/NSControl_Class/Reference/Reference.html#//apple_ref/occ/instm/NSControl/setTarget:" target="_top">setTarget:</a></code> and <code><a href="../../../Reference/ApplicationKit/Classes/NSControl_Class/Reference/Reference.html#//apple_ref/occ/instm/NSControl/setAction:" target="_top">setAction:</a></code> methods to establish the connection to the target object. If the target object does not respond to the action method, no connection is created. If the target object is <code>nil</code>, the action is handled by the responder chain. </p></li><li class="nested li"><p>In iPhone OS, the nib-loading code uses the <code><!--a target="_top" -->addTarget:action:forControlEvents:<!--/a--></code> method of the <code><!--a target="_top" -->UIControl<!--/a--></code> object to configure the action. If the target is <code>nil</code>, the action is handled by the responder chain.</p></li></ul></li><li class="li"><p>Bindings</p><ul class="nested"><li class="nested li"><p>In Mac OS X, Cocoa uses the <code><a href="../../../Reference/ApplicationKit/Protocols/NSKeyValueBindingCreation_Protocol/Reference/Reference.html#//apple_ref/occ/instm/NSObject/bind:toObject:withKeyPath:options:" target="_top">bind:toObject:withKeyPath:options:</a></code> method of the source object to create the connection between it and its target object. </p></li><li class="nested li"><p>Bindings are not supported in iPhone OS.</p></li></ul></li></ul></li><li class="li"><p>It sends an <code>awakeFromNib</code> message to the appropriate objects in the nib file that define the matching selector:</p><ul class="ul"><li class="li"><p>In Mac OS X, this message is sent to any interface objects that define the method. It is also sent to the File’s Owner and any proxy objects that define it as well.</p></li><li class="li"><p>In iPhone OS, this message is sent only to the interface objects that were instantiated by the nib-loading code. It is not sent to File’s Owner, First Responder, or any other proxy objects.</p></li></ul></li><li class="li"><p>It displays any windows whose “Visible at launch time” attribute was enabled in Interface Builder.</p></li></ol><p>The order in which the nib-loading code calls the <code>awakeFromNib</code> methods of objects is not guaranteed. In Mac OS X, Cocoa tries to call the <code>awakeFromNib</code> method of File’s Owner last but does not guarantee that behavior. If you need to configure the objects in your nib file further at load time, the most appropriate time to do so is after your nib-loading call returns. At that point, all of the objects are created, initialized, and ready for use.  </p><a name="//apple_ref/doc/uid/10000051i-CH4-SW6" title="Nib Object Retention"></a><h3>Nib Object Retention</h3><p>Each time you ask the <code><a href="../../../Reference/Foundation/Classes/NSBundle_Class/Reference/Reference.html#//apple_ref/occ/cl/NSBundle" target="_top">NSBundle</a></code> or <code><a href="../../../Reference/ApplicationKit/Classes/NSNib_Class/Reference/Reference.html#//apple_ref/occ/cl/NSNib" target="_top">NSNib</a></code> class to load a nib file, the underlying code creates a new copy of the objects in that file and returns them to you. The nib-loading code does not recycle nib file objects from a previous load attempt. Because each set of objects is a new copy, your code is responsible for releasing those objects when it is done with them. How you release the objects depends on the platform and on the memory model in use. <span class="content_text">Table 2-1</span> lists the supported platform and memory model configurations and the nib retention behavior associated with each one. </p><a name="//apple_ref/doc/uid/10000051i-CH4-SW10" title="Table 2-1Object retention rules for nib objects"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 2-1&nbsp;&nbsp;</strong>Object retention rules for nib objects</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Configuration</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Description</p></th></tr><tr><td  scope="row"><p>Mac OS X - managed memory model</p></td><td ><p>Objects in the nib file are initially created with a retain count of 1. As it rebuilds the object hierarchy, however, AppKit autoreleases any objects that have a parent or owning object, such as views nested inside view hierarchies. By the time the nib-loading code is done, only the top-level objects in the nib file have a positive retain count and no owning object. Your code is responsible for releasing these top-level objects.</p></td></tr><tr><td  scope="row"><p>Mac OS X - garbage collected memory model</p></td><td ><p>Most objects in the graph are kept in memory through strong references between the objects. Only the top-level objects in the nib file do not have strong references initially. Thus, your code must create strong references to these objects to prevent the object graph from being released. </p></td></tr><tr><td  scope="row"><p>iPhone OS - managed memory model</p></td><td ><p>Objects in the nib file are created with a retain count of 1 and then autoreleased. As it rebuilds the object hierarchy, however, UIKit reestablishes connections between the objects using the <code><a href="../../../Reference/Foundation/Protocols/NSKeyValueCoding_Protocol/Reference/Reference.html#//apple_ref/occ/instm/NSObject/setValue:forKey:" target="_top">setValue:forKey:</a></code> method, which uses the available setter method or retains the object by default if no setter method is available. If you define outlets for nib-file objects, you should also define a setter method for accessing that outlet. Setter methods for outlets should retain their values, and setter methods for outlets containing top-level objects must retain their values to prevent them from being deallocated. If you do not store the top-level objects in outlets, you must retain either the array returned by the <code><!--a target="_top" -->loadNibNamed:owner:options:<!--/a--></code> method or the objects inside the array to prevent those objects from being released prematurely.</p></td></tr></table></div><p>For both Mac OS X and UIKit, the recommended way to manage the top-level objects in a nib file is to create outlets for them in the File’s Owner object and then define setter methods to retain and release those objects as needed. Setter methods give you an appropriate place to include your memory-management code, even in situations where your application uses garbage collection. One easy way to implement your setter methods is to use the <code>@property</code> syntax and let the compiler create them for you. For more information on how to define properties, see <em><a href="../../ObjectiveC/index.html#//apple_ref/doc/uid/TP30001163" target="_top">The Objective-C 2.0 Programming Language</a></em>.  </p><a name="//apple_ref/doc/uid/10000051i-CH4-SW20" title="Built-In Support For Nib Files"></a><h2>Built-In Support For Nib Files</h2><p>The AppKit and UIKit frameworks both provide a certain amount of automated behavior for loading and managing nib files in an application. Both frameworks provide infrastructure for loading an application’s main nib file. In addition, the AppKit framework provides support for loading other nib files through the <code><a href="../../../Reference/ApplicationKit/Classes/NSDocument_Class/Reference/Reference.html#//apple_ref/occ/cl/NSDocument" target="_top">NSDocument</a></code> and <code><a href="../../../Reference/ApplicationKit/Classes/NSWindowController_Class/Reference/Reference.html#//apple_ref/occ/cl/NSWindowController" target="_top">NSWindowController</a></code> classes. The following sections describe the built-in support for nib files, how you can take advantage of it, and ways to modify that support in your own applications. </p><a name="//apple_ref/doc/uid/10000051i-CH4-SW21" title="Loading the Main Nib File"></a><h3>Loading the Main Nib File</h3><p>Most of the Xcode project templates for applications come preconfigured with a main nib file already in place. All you have to do is modify this default nib file in Interface Builder and build your application. At launch time, the application’s default configuration data tells the application object where to find this nib file so that it can load it. In applications based on either AppKit and UIKit, this configuration data is located in the application’s <code>Info.plist</code> file. When an application is first loaded, the default application startup code looks in the <code>Info.plist</code> file for the <code>NSMainNibFile</code> key. If it finds it, it looks in the application bundle for a nib file whose name (with or without the filename extension) matches the value of that key and loads it.</p><a name="//apple_ref/doc/uid/10000051i-CH4-SW23" title="Document and Window Controller Nib Files"></a><h3>Document and Window Controller Nib Files</h3><p>In the AppKit framework, the <code><a href="../../../Reference/ApplicationKit/Classes/NSDocument_Class/Reference/Reference.html#//apple_ref/occ/cl/NSDocument" target="_top">NSDocument</a></code> class works with the default window controller to load the nib file containing your document window. The <code><a href="../../../Reference/ApplicationKit/Classes/NSDocument_Class/Reference/Reference.html#//apple_ref/occ/instm/NSDocument/windowNibName" target="_top">windowNibName</a></code> method of <code>NSDocument</code> is a convenience method that you can use to specify the nib file containing the corresponding document window. When a new document is created, the document object passes the nib file name you specify to the default window controller object, which loads and manages the contents of the nib file. If you use the standard templates provided by Xcode, the only thing you have to do is add the contents of your document window to the nib file. </p><p>The <code><a href="../../../Reference/ApplicationKit/Classes/NSWindowController_Class/Reference/Reference.html#//apple_ref/occ/cl/NSWindowController" target="_top">NSWindowController</a></code> class also provides automatic support for loading nib files. If you create custom window controllers programmatically, you have the option of initializing them with an <code><a href="../../../Reference/ApplicationKit/Classes/NSWindow_Class/Reference/Reference.html#//apple_ref/occ/cl/NSWindow" target="_top">NSWindow</a></code> object or with the name of a nib file. If you choose the latter option, the <code>NSWindowController</code> class automatically loads the specified nib file the first time a client tries to access the window. After that, the window controller keeps the window around in memory; it does not reload it from the nib file, even if the window’s “Release when closed” attribute is set in Interface Builder.  </p><div class="importantbox"><a name="//apple_ref/doc/uid/10000051i-CH4-DontLinkElementID_4" title="Important:"></a><p><strong>Important:</strong>&nbsp;When using either <code>NSWindowController</code> or <code>NSDocument</code> to load windows automatically, it is important that your nib file be configured correctly. Both classes include a <code>window</code> outlet that you must connect to the window you want them to manage. If you do not connect this outlet to a window object, the nib file is loaded but the document or window controller does not display any windows. For more information about the Cocoa document architecture, see <em><a href="../../Documents/index.html#//apple_ref/doc/uid/10000006i" target="_top">Document-Based Applications Overview</a></em>.</p><p></p></div><a name="//apple_ref/doc/uid/10000051i-CH4-SW22" title="Changing the Nib Files from the Xcode Defaults"></a><h3>Changing the Nib Files from the Xcode Defaults</h3><p>When you create a new Cocoa application project in Xcode, the project template comes preconfigured with one or more nib files. If you have existing nib files you want to use instead, you can replace the template nib files with your custom nib files. Changing the nib file associated with a document object is easy but changing the application’s main nib file is somewhat more involved.</p><p>Each document in a Cocoa document-based application has its own nib file for storing the document window and any supporting objects. The <code><a href="../../../Reference/ApplicationKit/Classes/NSDocument_Class/Reference/Reference.html#//apple_ref/occ/cl/NSDocument" target="_top">NSDocument</a></code> class finds this nib file by calling its own <code><a href="../../../Reference/ApplicationKit/Classes/NSDocument_Class/Reference/Reference.html#//apple_ref/occ/instm/NSDocument/windowNibName" target="_top">windowNibName</a></code> method, the declaration for which is included in the default document class that comes with the Xcode template. To change the nib file associated with the document, simply change the string returned by the <code>windowNibName</code> method of your document class.</p><p>The main nib file is the only nib file that is required in a Cocoa application. It is loaded immediately before the application enters its main event loop, and the File’s Owner for this nib file is the <code><a href="../../../Reference/ApplicationKit/Classes/NSApplication_Class/Reference/Reference.html#//apple_ref/occ/cl/NSApplication" target="_top">NSApplication</a></code> object itself. A typical main nib contains only the application menu bar and perhaps an application delegate object to handle any application-related events (such as launch-time notifications). Although many applications include other objects in this nib file, doing so is generally not recommended. Instead, it is always preferable to lazily load other resources only as they are needed. Extra objects consume more memory and require more time to load from disk, both of which can degrade launch-time performance. </p><p>In Xcode, every new Cocoa project comes configured with a main nib file, called <code>MainMenu.xib</code>, that contains a default menu bar for your project. To change the main nib file for your Cocoa application, do the following: </p><ol class="ol"><li class="li"><p>In Interface Builder, open the nib file that you want to make the main nib.</p></li><li class="li"><p>Select the File’s Owner object of the nib and open the identity inspector.</p></li><li class="li"><p>In the identity inspector, set the class of File’s Owner to <code>NSApplication</code> (or to your custom subclass of <code>NSApplication</code> if you define one).</p></li><li class="li"><p>Open your application project in Xcode.</p></li><li class="li"><p>In the Targets section of the Groups &amp; Files pane, select your application target.</p></li><li class="li"><p>Open an inspector (or Info) window for the target and select the Properties tab.</p></li><li class="li"><p>In the Main Nib File field, enter the name of your new nib file. </p></li></ol><p>The preceding set of steps also work if you want to change the main nib file for an iPhone application. Instead of the <code>NSApplication</code> class, set the class of the File’s Owner proxy to <code><!--a target="_top" -->UIApplication<!--/a--></code>. In addition, you might also want to add a custom object and connect it to the delegate outlet of the <code>UIApplication</code>. (You could create the delegate object programmatically from the <code><!--a target="_top" -->UIApplicationMain<!--/a--></code> function but creating it in the nib file is much more common.) </p><a name="//apple_ref/doc/uid/10000051i-CH4-SW24" title="Loading Nib Files Programmatically"></a><h2>Loading Nib Files Programmatically</h2><p>Both Mac OS X and iPhone OS provide convenience methods for loading nib files into your application. Both the AppKit and UIKit framework define additional methods on the NSBundle class that support the loading of nib files. In addition, the AppKit framework also provides the <code><a href="../../../Reference/ApplicationKit/Classes/NSNib_Class/Reference/Reference.html#//apple_ref/occ/cl/NSNib" target="_top">NSNib</a></code> class, which provides similar nib-loading behavior as <code><a href="../../../Reference/Foundation/Classes/NSBundle_Class/Reference/Reference.html#//apple_ref/occ/cl/NSBundle" target="_top">NSBundle</a></code> but offers some additional advantages that might be useful in specific situations. </p><p>As you plan out your application, make sure any nib files you plan to load manually are configured in a way that simplifies the loading process. Choosing an appropriate object for File’s Owner and keeping your nib files small can greatly improve their ease of use and memory efficiency. For more tips on configuring your nib files, see <span class="content_text"><a href="CocoaNibs.html#//apple_ref/doc/uid/10000051i-CH4-SW4">“Nib File Design Guidelines.”</a></span>  </p><a name="//apple_ref/doc/uid/10000051i-CH4-SW25" title="Loading Nib Files Using NSBundle"></a><h3>Loading Nib Files Using NSBundle</h3><p>The AppKit and UIKit frameworks define additional methods on the <code><a href="../../../Reference/Foundation/Classes/NSBundle_Class/Reference/Reference.html#//apple_ref/occ/cl/NSBundle" target="_top">NSBundle</a></code> class (using Objective-C categories) to support the loading of nib file resources. The semantics for how you use the methods differs between the two platforms as does the syntax for the methods. In AppKit, there are more options for accessing bundles in general and so there are correspondingly more methods for loading nib files from those bundles. In UIKit, applications can load nib files only from their main bundle and so fewer options are needed. The methods available on the two platforms are as follows:</p><ul class="spaceabove"><li class="li"><p>AppKit</p><ul class="nested"><li class="nested li"><p><code><a href="../../../Reference/ApplicationKit/Classes/NSBundle_AppKitAdditions/Reference/Reference.html#//apple_ref/occ/clm/NSBundle/loadNibNamed:owner:" target="_top">loadNibNamed:owner:</a></code> class method</p></li><li class="nested li"><p><code><a href="../../../Reference/ApplicationKit/Classes/NSBundle_AppKitAdditions/Reference/Reference.html#//apple_ref/occ/instm/NSBundle/loadNibFile:externalNameTable:withZone:" target="_top">loadNibFile:externalNameTable:withZone:</a></code> class method</p></li><li class="nested li"><p><code><a href="../../../Reference/ApplicationKit/Classes/NSBundle_AppKitAdditions/Reference/Reference.html#//apple_ref/occ/clm/NSBundle/loadNibFile:externalNameTable:withZone:" target="_top">loadNibFile:externalNameTable:withZone:</a></code> instance method</p></li></ul></li><li class="li"><p>UIKit</p><ul class="nested"><li class="nested li"><p><code><!--a target="_top" -->loadNibNamed:owner:options:<!--/a--></code> instance method</p></li></ul></li></ul><p>Whenever loading a nib file, you should always specify an object to act as File’s Owner of that nib file. The role of the File’s Owner is an important one. It is the primary interface between your running code and the new objects that are about to created in memory. All of the nib-loading methods provide a way to specify the File’s Owner, either directly or as a parameter in an options dictionary. </p><p>One of the semantic differences between the way the AppKit and UIKit frameworks handle nib loading is the way the top-level nib objects are returned to your application. In the AppKit framework, you must explicitly request them using one of the <code><a href="../../../Reference/ApplicationKit/Classes/NSBundle_AppKitAdditions/Reference/Reference.html#//apple_ref/occ/instm/NSBundle/loadNibFile:externalNameTable:withZone:" target="_top">loadNibFile:externalNameTable:withZone:</a></code> methods. In UIKit, the <code><!--a target="_top" -->loadNibNamed:owner:options:<!--/a--></code> method returns an array of these objects directly. The simplest way to avoid having to worry about the top-level objects in either case is to store them in outlets of your File’s Owner object and to make sure the setter methods for those outlets retain their values. Because each platform uses different retain semantics, however, you must be sure to send the proper retain or release messages when appropriate. For information about the retention semantics for nib objects, see <span class="content_text"><a href="CocoaNibs.html#//apple_ref/doc/uid/10000051i-CH4-SW6">“Nib Object Retention.”</a></span> </p><p><span class="content_text">Listing 2-1</span> shows a simple example of how to load a nib file using the <code>NSBundle</code> class in an AppKit–based application. As soon as the <code><a href="../../../Reference/ApplicationKit/Classes/NSBundle_AppKitAdditions/Reference/Reference.html#//apple_ref/occ/clm/NSBundle/loadNibNamed:owner:" target="_top">loadNibNamed:owner:</a></code> method returns, you can begin using any outlets that refer to the nib file objects. In other words, the entire nib-loading process occurs within the confines of that single call. The nib-loading methods in the AppKit framework return a Boolean value to indicate whether the load operation was successful.</p><a name="//apple_ref/doc/uid/10000051i-CH4-SW1" title="Listing 2-1Loading a nib file from the current bundle"></a><p class="codesample"><strong>Listing 2-1&nbsp;&nbsp;</strong>Loading a nib file from the current bundle</p><div class="codesample"><table><tr><td scope="row"><pre>- (BOOL)loadMyNibFile<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    // The myNib file must be in the bundle that defines self's class.<span></span></pre></td></tr><tr><td scope="row"><pre>    if (![NSBundle loadNibNamed:@"myNib" owner:self])<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        NSLog(@"Warning! Could not load myNib file.\n");<span></span></pre></td></tr><tr><td scope="row"><pre>        return NO;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    return YES;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p><span class="content_text">Listing 2-2</span> shows an example of how to load a nib file in a UIKit–based application. In this case, the method checks the returned array to see if the nib objects were loaded successfully. (Every nib file should have at least one top-level object representing the contents of the nib file.) This example shows the simple case when the nib file contains no proxy objects other than the File’s Owner object. For an example of how to specify additional proxy objects, see <span class="content_text"><a href="CocoaNibs.html#//apple_ref/doc/uid/10000051i-CH4-SW30">“Replacing Proxy Objects at Load Time.”</a></span></p><a name="//apple_ref/doc/uid/10000051i-CH4-SW11" title="Listing 2-2Loading a nib in an iPhone application"></a><p class="codesample"><strong>Listing 2-2&nbsp;&nbsp;</strong>Loading a nib in an iPhone application</p><div class="codesample"><table><tr><td scope="row"><pre>- (BOOL)loadMyNibFile<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    NSArray*    topLevelObjs = nil;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    topLevelObjs = [[NSBundle mainBundle] loadNibNamed:@"myNib" owner:self options:nil];<span></span></pre></td></tr><tr><td scope="row"><pre>    if (topLevelObjs == nil)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        NSLog(@"Error! Could not load myNib file.\n");<span></span></pre></td></tr><tr><td scope="row"><pre>        return NO;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    return YES;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/10000051i-CH4-SW26" title="Getting a Nib File&acirc;&#128;&#153;s Top-Level Objects"></a><h3>Getting a Nib File’s Top-Level Objects</h3><p>The easiest way to get the top-level objects of your nib file is to define outlets in the File’s Owner object along with setter methods (or better yet, properties) for accessing those objects. This approach ensures that the top-level objects are retained by your object and that you always have references to them.</p><p><span class="content_text">Listing 2-3</span> shows the interface and implementation of a stripped down Cocoa class that uses an outlet to retain the nib file’s only top-level object. In this case, the only top-level object in the nib file is an <code><a href="../../../Reference/ApplicationKit/Classes/NSWindow_Class/Reference/Reference.html#//apple_ref/occ/cl/NSWindow" target="_top">NSWindow</a></code> object. Because top-level objects in Cocoa have an initial retain count of 1, an extra release message is included. This is fine because by the time the release call is made, the property has already retained the window. You would not want to release top-level objects in this manner in an iPhone application.</p><a name="//apple_ref/doc/uid/10000051i-CH4-SW33" title="Listing 2-3Using outlets to get the top-level objects"></a><p class="codesample"><strong>Listing 2-3&nbsp;&nbsp;</strong>Using outlets to get the top-level objects</p><div class="codesample"><table><tr><td scope="row"><pre>// Class interface<span></span></pre></td></tr><tr><td scope="row"><pre>@interface MyController : NSObject {<span></span></pre></td></tr><tr><td scope="row"><pre>    NSWindow *window;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre>@property(retain) IBOutlet NSWindow *window;<span></span></pre></td></tr><tr><td scope="row"><pre>- (void)loadMyWindow;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>// Class implementation<span></span></pre></td></tr><tr><td scope="row"><pre>@implementation MyController<span></span></pre></td></tr><tr><td scope="row"><pre>// The synthesized property retains the window automatically.<span></span></pre></td></tr><tr><td scope="row"><pre>@synthesize window;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (void)loadMyWindow<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    [NSBundle loadNibNamed:@"myNib" owner:self];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // The window starts off with a retain count of 1<span></span></pre></td></tr><tr><td scope="row"><pre>    // and is then retained by the property, so add an extra release.<span></span></pre></td></tr><tr><td scope="row"><pre>    [window release];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr></table></div><p>If you do not want to use outlets to store references to your nib file’s top-level objects, you must retrieve those objects manually in your code. The technique for obtaining the top-level objects differs depending on the target platform. In Mac OS X, you must ask for the objects explicitly, whereas in iPhone OS they are returned to you automatically. </p><p><span class="content_text">Listing 2-4</span> shows the process for getting the top-level objects of a nib file in Mac OS X. This method places a mutable array into the nameTable dictionary and associates it with the <code><a href="../../../Reference/ApplicationKit/Classes/NSNib_Class/Reference/Reference.html#//apple_ref/c/data/NSNibTopLevelObjects" target="_top">NSNibTopLevelObjects</a></code> key. The nib-loading code looks for this array object and, if present, places the top-level objects in it. Because each object starts with a retain count of 1 before it is added to the array, simply releasing the array is not enough to release the objects in the array as well. As a result, this method sends a release message to each of the objects to ensure that the array is the only entity holding a reference to them. </p><a name="//apple_ref/doc/uid/10000051i-CH4-SW27" title="Listing 2-4Getting the top-level objects from a nib file at runtime"></a><p class="codesample"><strong>Listing 2-4&nbsp;&nbsp;</strong>Getting the top-level objects from a nib file at runtime</p><div class="codesample"><table><tr><td scope="row"><pre>- (NSArray*)loadMyNibFile<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    NSBundle*            aBundle = [NSBundle mainBundle];<span></span></pre></td></tr><tr><td scope="row"><pre>    NSMutableArray*      topLevelObjs = [NSMutableArray array];<span></span></pre></td></tr><tr><td scope="row"><pre>    NSDictionary*        nameTable = [NSDictionary dictionaryWithObjectsAndKeys:<span></span></pre></td></tr><tr><td scope="row"><pre>                                            self, NSNibOwner,<span></span></pre></td></tr><tr><td scope="row"><pre>                                            topLevelObjs, NSNibTopLevelObjects,<span></span></pre></td></tr><tr><td scope="row"><pre>                                            nil];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if (![aBundle loadNibFile:@"myNib" externalNameTable:nameTable withZone:nil])<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        NSLog(@"Warning! Could not load myNib file.\n");<span></span></pre></td></tr><tr><td scope="row"><pre>        return nil;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Release the objects so that they are just owned by the array.<span></span></pre></td></tr><tr><td scope="row"><pre>    [topLevelObjs makeObjectsPerformSelector:@selector(release)];<span></span></pre></td></tr><tr><td scope="row"><pre>    return topLevelObjs;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>Obtaining the top-level objects in an iPhone application is much simpler and is shown in <span class="content_text"><a href="CocoaNibs.html#//apple_ref/doc/uid/10000051i-CH4-SW11">Listing 2-2</a></span>. In the UIKit framework, the <code><!--a target="_top" -->loadNibNamed:owner:options:<!--/a--></code> method of <code><a href="../../../Reference/Foundation/Classes/NSBundle_Class/Reference/Reference.html#//apple_ref/occ/cl/NSBundle" target="_top">NSBundle</a></code> automatically returns an array with the top-level objects. In addition, by the time the array is returned, the retain counts on the objects are adjusted so that you do not need to send each object an extra release message. The returned array is the only owner of the objects.  </p><a name="//apple_ref/doc/uid/10000051i-CH4-SW28" title="Loading Nib Files Using NSNib"></a><h3>Loading Nib Files Using NSNib</h3><p>In Mac OS X, the AppKit framework supports the loading of nib files using the <code><a href="../../../Reference/ApplicationKit/Classes/NSNib_Class/Reference/Reference.html#//apple_ref/occ/cl/NSNib" target="_top">NSNib</a></code> class. You can use the <code>NSNib</code> class to load nib files that reside outside of a bundle or in situations where you plan to load the same nib file more than once. Loading a nib file with this class is always a two-step process. First, you create an instance of the <code>NSNib</code> class, initializing it with the nib file’s location information. Second, you instantiate the contents of the nib file to load the objects into memory. Each time you instantiate the nib file, you specify a different File’s Owner object and can also receive a new set of top-level objects.</p><div class="notebox"><a name="//apple_ref/doc/uid/10000051i-CH4-SW29" title="Note"></a><p><strong>Note:</strong>&nbsp;The <code>NSNib</code> class is not available in iPhone OS. You should use the <code><a href="../../../Reference/Foundation/Classes/NSBundle_Class/Reference/Reference.html#//apple_ref/occ/cl/NSBundle" target="_top">NSBundle</a></code> class to load nib files instead.</p></div><p>When you want to load the same nib file multiple times, the two-step process used by <code>NSNib</code> offers some advantages over the <code>NSBundle</code> methods. An <code>NSNib</code> object loads the nib data into memory only once, but each time you call one of its instantiate methods, you receive a unique copy of the nib file objects. If you need to create several copies of a nib file’s objects in quick succession, the caching provided by <code>NSNib</code> can improve performance. </p><p><span class="content_text">Listing 2-5</span> shows one way to load the contents of a nib file using the <code>NSNib</code> class. The array returned to you by the <code><a href="../../../Reference/ApplicationKit/Classes/NSNib_Class/Reference/Reference.html#//apple_ref/occ/instm/NSNib/instantiateNibWithOwner:topLevelObjects:" target="_top">instantiateNibWithOwner:topLevelObjects:</a></code> method comes already autoreleased. If you intend to use that array for any period of time, you should make a copy of it. </p><a name="//apple_ref/doc/uid/10000051i-CH4-SW5" title="Listing 2-5Loading a nib file using NSNib"></a><p class="codesample"><strong>Listing 2-5&nbsp;&nbsp;</strong>Loading a nib file using NSNib</p><div class="codesample"><table><tr><td scope="row"><pre>- (NSArray*)loadMyNibFile<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    NSNib*      aNib = [[NSNib alloc] initWithNibNamed:@"MyPanel" bundle:nil];<span></span></pre></td></tr><tr><td scope="row"><pre>    NSArray*    topLevelObjs = nil;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if (![aNib instantiateNibWithOwner:self topLevelObjects:&amp;topLevelObjs])<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        NSLog(@"Warning! Could not load nib file.\n");<span></span></pre></td></tr><tr><td scope="row"><pre>        return nil;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    // Release the raw nib data.<span></span></pre></td></tr><tr><td scope="row"><pre>    [aNib release];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Release the top-level objects so that they are just owned by the array.<span></span></pre></td></tr><tr><td scope="row"><pre>    [topLevelObjs makeObjectsPerformSelector:@selector(release)];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Do not autorelease topLevelObjs.<span></span></pre></td></tr><tr><td scope="row"><pre>    return topLevelObjs;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/10000051i-CH4-SW30" title="Replacing Proxy Objects at Load Time"></a><h3>Replacing Proxy Objects at Load Time</h3><p>In iPhone OS, it is possible to create nib files that include proxy objects besides the File’s Owner. Proxy objects represent objects created outside of the nib file but which have some connection to the nib file’s contents. Proxies are commonly used to support navigation controllers in iPhone applications. When working with navigation controllers, you typically connect the File’s Owner object to some common object such as your application delegate. Proxy objects therefore represent the parts of the navigation controller object hierarchy that are already loaded in memory, either because they were created programmatically or loaded from a different nib file.</p><div class="notebox"><a name="//apple_ref/doc/uid/10000051i-CH4-SW31" title="Note"></a><p><strong>Note:</strong>&nbsp;Custom proxy objects (other than File’s Owner) are not supported in Mac OS X nib files.</p></div><p>Each proxy object you add to a nib file must have a unique name. To assign a name to an object, select the object in Interface Builder and open the inspector window. The Attributes pane of the inspector contains a Name field, which you use to specify the name for your proxy object. The name you assign should be descriptive of the object’s behavior or type, but really it can be anything you want.</p><p>When you are ready to load a nib file containing proxy objects, you must specify the replacement objects for any proxies when you call the <code><!--a target="_top" -->loadNibNamed:owner:options:<!--/a--></code> method. The <em>options</em> parameter of this method accepts a dictionary of additional information. You use this dictionary to pass in the information about your proxy objects. The dictionary must contain the <code><!--a target="_top" -->UINibProxiedObjectsKey<!--/a--></code> key whose value is another dictionary containing the name and object for each proxy replacement.</p><p><span class="content_text">Listing 2-6</span> shows a sample version of an <code>applicationDidFinishLaunching:</code> method that loads the application’s main nib file manually. Because the application’s delegate object is created by the <code><!--a target="_top" -->UIApplicationMain<!--/a--></code> function, this method uses a proxy (with the name “AppDelegate”) in the main nib file to represent that object. The proxies dictionary stores the proxy object information and the options dictionary wraps that dictionary. </p><a name="//apple_ref/doc/uid/10000051i-CH4-SW12" title="Listing 2-6Replacing proxy objects in a nib file"></a><p class="codesample"><strong>Listing 2-6&nbsp;&nbsp;</strong>Replacing proxy objects in a nib file</p><div class="codesample"><table><tr><td scope="row"><pre>- (void)applicationDidFinishLaunching:(UIApplication *)application<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    NSArray*    topLevelObjs = nil;<span></span></pre></td></tr><tr><td scope="row"><pre>    NSDictionary*    proxies = [NSDictionary dictionaryWithObject:self forKey:@"AppDelegate"];<span></span></pre></td></tr><tr><td scope="row"><pre>    NSDictionary*    options = [NSDictionary dictionaryWithObject:proxies forKey:UINibProxiedObjectsKey];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    topLevelObjs = [[NSBundle mainBundle] loadNibNamed:@"Main" owner:self options:options];<span></span></pre></td></tr><tr><td scope="row"><pre>    if ([topLevelObjs count] == 0)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        NSLog(@"Warning! Could not load myNib file.\n");<span></span></pre></td></tr><tr><td scope="row"><pre>        return;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Show window<span></span></pre></td></tr><tr><td scope="row"><pre>    [window makeKeyAndVisible];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr></table></div><p>For more information about the options dictionary of the <code>loadNibNamed:owner:options:</code> method, see <em><!--a target="_top" -->NSBundle UIKit Additions Reference<!--/a--></em>. </p><a name="//apple_ref/doc/uid/10000051i-CH4-SW7" title="Accessing the Contents of a Nib File"></a><h3>Accessing the Contents of a Nib File</h3><p>Upon the successful loading a nib file, its contents become ready for you to use immediately. If you configured outlets in your File’s Owner to point to nib file objects, you can now use those outlets. If you did not configure your File’s Owner with any outlets, you should make sure you obtain a reference to the top-level objects in some manner so that you can release them later.</p><p>Because outlets are populated with real objects when a nib file is loaded, you can subsequently use outlets as you would any other object you created programmatically. For example, if you have an outlet pointing to a window, you could send that window a <code><a href="../../../Reference/ApplicationKit/Classes/NSWindow_Class/Reference/Reference.html#//apple_ref/occ/instm/NSWindow/makeKeyAndOrderFront:" target="_top">makeKeyAndOrderFront:</a></code> message to show it on the user’s screen. When you are done using the objects in your nib file, you must release them like any other objects.</p><div class="importantbox"><a name="//apple_ref/doc/uid/10000051i-CH4-DontLinkElementID_5" title="Important:"></a><p><strong>Important:</strong>&nbsp;You are responsible for releasing the top-level objects of any nib files you load when you are finished with those objects. Failure to do so is a cause of memory leaks in many applications. After releasing the top-level objects, it is a good idea to clear any outlets pointing to objects in the nib file by setting them to <code>nil</code>. You should clear outlets associated with all of the nib file’s objects, not just the top-level objects. </p><p></p></div><a name="//apple_ref/doc/uid/10000051i-CH4-SW32" title="Connecting Menu Items Across Nib Files"></a><h2>Connecting Menu Items Across Nib Files</h2><p>The items in a Mac OS X application’s menu bar often need to interact with many different objects, including your application’s documents and windows. The problem is that many of these objects cannot (or should not) be accessed directly from the main nib file. The File’s Owner of the main nib file is always set to an instance of the <code><a href="../../../Reference/ApplicationKit/Classes/NSApplication_Class/Reference/Reference.html#//apple_ref/occ/cl/NSApplication" target="_top">NSApplication</a></code> class. And although you might be able to instantiate a number of custom objects in your main nib file, doing so is hardly practical or necessary. In the case of document objects, connecting directly to a specific document object is not even possible because the number of document objects can change dynamically and can even be zero.</p><p>Most menu items send action messages to one of the following:</p><ul class="ul"><li class="li"><p>A fixed object that always handles the command </p></li><li class="li"><p>A dynamic object, such as a document or window</p></li></ul><p>Messaging fixed objects is a relatively straightforward process that is usually best handled through the application delegate. The application delegate object assists the <code>NSApplication</code> object in running the application and is one of the few objects that rightfully belongs in the main nib file. If the menu item refers to an application-level command, you can implement that command directly in the application delegate or just have the delegate forward the message to the appropriate object elsewhere in your application. </p><p>If you have a menu item that acts on the contents of the frontmost window, you need to link the menu item to the First Responder proxy object. If the action method associated with the menu item is specific to one of your objects (and not defined by Cocoa), you must add that action to the First Responder before creating the connection. To set up a First Responder connection in Interface Builder v3.0 and later, do the following:  </p><ol class="ol"><li class="li"><p>For custom actions, add the action to the First Responder proxy object:</p><ol class="ol"><li class="ol ol"><p>In your main nib file, select the First Responder proxy object.</p></li><li class="ol ol"><p>Open the inspector window and select the Identity pane.</p></li><li class="ol ol"><p>In the Class Actions section, click the plus (+) button to add the new action method. The new action’s name is initially selected.</p></li><li class="ol ol"><p>Enter the name of your action and press Return.</p></li></ol></li><li class="li"><p>Open the menu bar resource.</p></li><li class="li"><p>If you have not already done so, add your menu item to the desired menu.</p></li><li class="li"><p>Control-click the menu item and drag it to the First Responder proxy object in the nib document window.</p></li><li class="li"><p>In the Connections tab of the inspector window, select your action and click Connect.</p></li></ol><p>After creating the connection, you need to implement the action method in your <code><a href="../../../Reference/ApplicationKit/Classes/NSDocument_Class/Reference/Reference.html#//apple_ref/occ/cl/NSDocument" target="_top">NSDocument</a></code> or <code><a href="../../../Reference/ApplicationKit/Classes/NSResponder_Class/Reference/Reference.html#//apple_ref/occ/cl/NSResponder" target="_top">NSResponder</a></code> subclass. That object should also implement the <code><a href="../../../Reference/ApplicationKit/Protocols/NSMenuValidation_Protocol/Reference/Reference.html#//apple_ref/occ/instm/NSObject/validateMenuItem:" target="_top">validateMenuItem:</a></code> method to enable the menu item at appropriate times. For more information about how the responder chain handles commands, see <em><a href="../../EventOverview/index.html#//apple_ref/doc/uid/10000060i" target="_top">Cocoa Event-Handling Guide</a></em>. </p>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../MOSXResources/MOSXResources.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../Strings/Strings.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2009 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2009-01-06<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Cocoa/Conceptual/LoadingResources/CocoaNibs/CocoaNibs.html%3Fid%3D10000051i-3.3&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Cocoa/Conceptual/LoadingResources/CocoaNibs/CocoaNibs.html%3Fid%3D10000051i-3.3&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Cocoa/Conceptual/LoadingResources/CocoaNibs/CocoaNibs.html%3Fid%3D10000051i-3.3&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>