<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>SCAudioCompress - /scaudiocompress.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/QuickTime/index.html">QuickTime</a> &gt; <a href="../../samplecode/QuickTime/idxMusicAudio-date.html">Audio</a> &gt; <A HREF="javascript:location.replace('index.html');">SCAudioCompress</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->


	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">SCAudioCompress</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/scaudiocompress.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/ReadMe.txt</option>
<option value="listing2.html">/scaudiocompress.c</option></select>
				</p>
				</form>
				<p><strong><a href="scaudiocompress.zip">Download Sample</a></strong> (&#147;scaudiocompress.zip&#148;, 35.8K)<BR>
<strong><a href="scaudiocompress.dmg">Download Sample</a></strong> (&#147;scaudiocompress.dmg&#148;, 97.1K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*

File: scaudiocompress.c

Abstract:   Demonstrates typical usage of the SCAudio compression API's, in
            particular, SCAudioFillBuffer.  Also demonstrates how to read
            from files using (1) MovieAudioExtraction, and (2) AudioFile API,
            and how to write audio QuickTime movies using AddMediaSample2 or
            .caf files using AudioFile API.

Version: 1.0

Disclaimer: IMPORTANT:  This Apple software is supplied to you by Apple
Computer, Inc. (&quot;Apple&quot;) in consideration of your agreement to the
following terms, and your use, installation, modification or
redistribution of this Apple software constitutes acceptance of these
terms.  If you do not agree with these terms, please do not use,
install, modify or redistribute this Apple software.

In consideration of your agreement to abide by the following terms, and
subject to these terms, Apple grants you a personal, non-exclusive
license, under Apple's copyrights in this original Apple software (the
&quot;Apple Software&quot;), to use, reproduce, modify and redistribute the Apple
Software, with or without modifications, in source and/or binary forms;
provided that if you redistribute the Apple Software in its entirety and
without modifications, you must retain this notice and the following
text and disclaimers in all such redistributions of the Apple Software. 
Neither the name, trademarks, service marks or logos of Apple Computer,
Inc. may be used to endorse or promote products derived from the Apple
Software without specific prior written permission from Apple.  Except
as expressly stated in this notice, no other rights or licenses, express
or implied, are granted by Apple herein, including but not limited to
any patent rights that may be infringed by your derivative works or by
other works in which the Apple Software may be incorporated.

The Apple Software is provided by Apple on an &quot;AS IS&quot; basis.  APPLE
MAKES NO WARRANTIES, EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION
THE IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY AND FITNESS
FOR A PARTICULAR PURPOSE, REGARDING THE APPLE SOFTWARE OR ITS USE AND
OPERATION ALONE OR IN COMBINATION WITH YOUR PRODUCTS.

IN NO EVENT SHALL APPLE BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL
OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) ARISING IN ANY WAY OUT OF THE USE, REPRODUCTION,
MODIFICATION AND/OR DISTRIBUTION OF THE APPLE SOFTWARE, HOWEVER CAUSED
AND WHETHER UNDER THEORY OF CONTRACT, TORT (INCLUDING NEGLIGENCE),
STRICT LIABILITY OR OTHERWISE, EVEN IF APPLE HAS BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.

Copyright &copy; 2006 Apple Computer, Inc., All Rights Reserved

*/ 

#include &lt;TargetConditionals.h&gt;

#if TARGET_OS_MAC
  #include &lt;CoreServices/CoreServices.h&gt;
  #include &lt;QuickTime/QuickTime.h&gt;
  #include &lt;AudioToolbox/AudioToolbox.h&gt;
  #include &lt;ApplicationServices/ApplicationServices.h&gt;
#else
  #include &lt;stdlib.h&gt;
  #include &lt;stdio.h&gt;
  #include &lt;string.h&gt;
  #include &lt;QuickTimeComponents.h&gt;
  #include &lt;QTML.h&gt;
#endif

#define kQTAudioPropertyID_MaxAudioSampleSize   'mssz'

#define DEFAULT_PULL_FRAMES         5000
#define LOG_FILE                    stderr
#define LOG_DATA_FLOW        0

#if TARGET_OS_MAC
  #if LOG_DATA_FLOW
    #define logflow(...)      fprintf(LOG_FILE, __VA_ARGS__)
  #else
    #define logflow(...)
  #endif
#else
        // Windows compiler unfortunately does not allow variadic macros
        
    int __cdecl logflow(const char *format, ...)
    {
      int    retval = 0;
    #if LOG_DATA_FLOW
      va_list args;
      char *  buffer = NULL;
      int    len;
      
      va_start( args, format );

      len = _vscprintf( format, args ) // _vscprintf doesn't count
                    + 1; // terminating '\0'
      buffer = malloc( len * sizeof(char) );
      retval = vsprintf( buffer, format, args );
      OutputDebugString(buffer);
      free( buffer );

      va_end(args);
    #endif
      return retval;
    }
#endif

typedef struct {
    char *              inFile;
    char *              outFile;
    Boolean              suppressUI;
    Boolean              forceQTRead;
  Boolean              extractionComplete;
  Boolean              writingMovie;
    Boolean                         writingRaw;
    UInt8                       pad[1];
  FILE *              rawFile;
  SInt32              onlyChannel;
    UInt32              pullPackets;
    AudioStreamBasicDescription     inasbd;
    UInt32                          inputBufferSize;
    void **                         inputBuffers;
    
    Movie              m;
    MovieAudioExtractionRef      mae;
 
#if TARGET_OS_MAC
    AudioFileID            af;
#endif
  UInt64              srcFilePacketCount;
  SInt64              srcPacketsRead;
  AudioStreamPacketDescription *  packetDescs;
  UInt32              numPacketDescs;
  UInt32              srcFileMaxPacketSize;
  void *              srcFileReadBuffer;
  UInt32              srcFileReadBufferSize;

#if TARGET_OS_MAC
    AudioFileID            outaf;
#endif
  SInt64              numPacketsWritten;
  
  Movie              outm;
  DataHandler            dataH;
  Media              media;
  SoundDescriptionHandle      sdh;
    
    ComponentInstance        stdAudio;
} SCAudioCompressDataRecord, *SCAudioCompressData;



// --------------------------------------------------------------------------------
/*
    mySCAudioInputDataProc is called for input in the specified source format.
    The source format is specified using the kQTSCAudioPropertyID_InputBasicDescription
    property in the ConfigureStdAudio function below.  The input data proc may
    provide exactly the number of packets of audio requested in *ioNumberDataPackets,
    fewer packets, or more packets.  The means to signal end of data is identical
    to that specified for AudioConverters in technical Q&amp;A 1317:
    http://developer.apple.com/qa/qa2001/qa1317.html
    
    Unlike AudioConverters, the source format and destination format can have 
    totally different channel layouts.  SCAudioFillBuffer's processing chain
    uses:
    (1) an AudioConverter for decode (if necessary)
    (2) a MatrixMixer for mixing (if necessary)
    (3) another AudioConverter for encode (if necessary)
*/
// --------------------------------------------------------------------------------

static ComponentResult
mySCAudioInputDataProc( ComponentInstance ci, 
            UInt32 *ioNumberDataPackets, 
            AudioBufferList *ioData, 
            AudioStreamPacketDescription **outDataPacketDescription, 
            void *inRefCon)
{
  ComponentResult err = noErr;
  SCAudioCompressData globs = (SCAudioCompressData)inRefCon;
  UInt32 pullPackets = *ioNumberDataPackets;
  
  *ioNumberDataPackets = 0;
  
  if (globs-&gt;mae)
  {
  
  
    UInt32 flags = 0;
    
    // if it's movie audio extraction, we know we're doing pcm, packetdescriptions
    // are unnecessary.
    if ( globs-&gt;extractionComplete )
    {
      ioData-&gt;mBuffers[0].mData = NULL;
      ioData-&gt;mBuffers[0].mDataByteSize = 0;
      goto bail;
    }
        
        if ( ioData-&gt;mBuffers[0].mData == NULL )
        {
            UInt32 i, neededBufSize = pullPackets * globs-&gt;inasbd.mBytesPerPacket;
            if ( globs-&gt;inputBufferSize &lt; neededBufSize )
            {
                globs-&gt;inputBufferSize = neededBufSize;
                if ( globs-&gt;inputBuffers )
                {
                    for ( i = 0; i &lt; globs-&gt;inasbd.mChannelsPerFrame; i++ )
                        free(globs-&gt;inputBuffers[i]);
                    free(globs-&gt;inputBuffers);
                    globs-&gt;inputBuffers = NULL;
                }
                
                globs-&gt;inputBuffers = malloc( sizeof(void*) * globs-&gt;inasbd.mChannelsPerFrame );
                    
                for ( i = 0; i &lt; globs-&gt;inasbd.mChannelsPerFrame; i++ )
                    globs-&gt;inputBuffers[i] = malloc( globs-&gt;inputBufferSize );
            }
            
            for ( i = 0; i &lt; ioData-&gt;mNumberBuffers; i++ )
            {
                ioData-&gt;mBuffers[i].mDataByteSize = globs-&gt;inputBufferSize;
                ioData-&gt;mBuffers[i].mData = globs-&gt;inputBuffers[i];
            }
        }
        
    
    logflow(&quot;Calling MovieAudioExtractionFillBuffer() for %lu frames\n&quot;, pullPackets);
    err = MovieAudioExtractionFillBuffer(  globs-&gt;mae, &amp;pullPackets, ioData, &amp;flags);
    if ( flags &amp; kQTMovieAudioExtractionComplete )
    {
      globs-&gt;extractionComplete = true;
      logflow(&quot;setting kQTMovieAudioExtractionComplete to true\n&quot;);
    }
    
    *ioNumberDataPackets = pullPackets;
    logflow(&quot;MovieAudioExtractionFillBuffer() returned %lu frames\n&quot;, pullPackets);
    
    
    
  }
#if TARGET_OS_MAC
  else if ( globs-&gt;af ) {
    
    // do it the audio file way
    
    if ( globs-&gt;srcPacketsRead == globs-&gt;srcFilePacketCount )
    {
      // end of data
      ioData-&gt;mBuffers[0].mData = NULL;
      ioData-&gt;mBuffers[0].mDataByteSize = 0;
      goto bail;
    }
    
    if ( pullPackets &gt; (globs-&gt;srcFilePacketCount - globs-&gt;srcPacketsRead) )
      pullPackets = globs-&gt;srcFilePacketCount - globs-&gt;srcPacketsRead;
    
    if (outDataPacketDescription)
    {
      if (pullPackets &gt; globs-&gt;numPacketDescs)
      {
        if (globs-&gt;packetDescs)
          free(globs-&gt;packetDescs);
        globs-&gt;packetDescs = (AudioStreamPacketDescription*)calloc(pullPackets, sizeof(AudioStreamPacketDescription));
        globs-&gt;numPacketDescs = pullPackets;
      }
    }
    
    if ( pullPackets * globs-&gt;srcFileMaxPacketSize &gt; globs-&gt;srcFileReadBufferSize )
    {
      if (globs-&gt;srcFileReadBuffer)
        free(globs-&gt;srcFileReadBuffer);
      globs-&gt;srcFileReadBufferSize = pullPackets * globs-&gt;srcFileMaxPacketSize;
      globs-&gt;srcFileReadBuffer = calloc(1, globs-&gt;srcFileReadBufferSize);
    }
    
    ioData-&gt;mBuffers[0].mData = globs-&gt;srcFileReadBuffer;
  
    logflow(&quot;Reading %lu packets from src AudioFile\n&quot;, pullPackets);
    
    err = AudioFileReadPackets (  globs-&gt;af, 
                    false,      // inUseCache,
                    &amp;ioData-&gt;mBuffers[0].mDataByteSize,    // outNumBytes,
                    globs-&gt;packetDescs,
                    globs-&gt;srcPacketsRead, 
                    &amp;pullPackets, 
                    ioData-&gt;mBuffers[0].mData);
    if (err)
    {
      fprintf(LOG_FILE, &quot;### AudioFileReadPackets() returned err %ld\n&quot;, err);
      goto bail;
    }
    
    logflow(&quot;AudioFileReadPackets() returned %ld packets\n&quot;, pullPackets);
    
    *ioNumberDataPackets = pullPackets;
    if (outDataPacketDescription)
      *outDataPacketDescription = globs-&gt;packetDescs;
    
    globs-&gt;srcPacketsRead += pullPackets;
  }
#endif // TARGET_OS_MAC
  else
    err = paramErr;
  
bail:  
  return err;
}



// --------------------------------------------------------------------------------
/*
    DoSCAudioCompress - here is where we call SCAudioFillBuffer repeatedly and
    write the resulting packets to file using QuickTime's AddMediaSample2 API,
    and AudioFile's AudioFileWritePackets API.  Code is also provided to write
    raw PCM (headerless) interleaved frames to disk.
*/
// --------------------------------------------------------------------------------


static OSStatus
DoSCAudioCompress( SCAudioCompressData globs )
{
  OSStatus err = noErr;
  AudioStreamPacketDescription * aspds = NULL;
  AudioStreamBasicDescription asbd;
  UInt32 maxBytesPerPacket = 0;
  AudioBufferList * abl = NULL;
  void * buffer = NULL;
  UInt32 bufferSize = 0;
  SInt32 onlyChannel = 0;
  Boolean requiresPackets = false;
  
  // see if the output format is externally framed and requires packet descriptions
  err = QTGetComponentProperty(  globs-&gt;stdAudio, kQTPropertyClass_SCAudio, 
                  kQTSCAudioPropertyID_OutputFormatIsExternallyFramed,
                  sizeof(requiresPackets), &amp;requiresPackets, NULL );
  if (err)
    fprintf(LOG_FILE, &quot;### Get(kQTSCAudioPropertyID_OutputFormatIsExternallyFramed) returned err %ld\n&quot;, err);
  if (requiresPackets)
    aspds = (AudioStreamPacketDescription*)calloc(globs-&gt;pullPackets, sizeof(AudioStreamPacketDescription));
  
  
  
  err = QTGetComponentProperty(  globs-&gt;stdAudio, kQTPropertyClass_SCAudio, 
                  kQTSCAudioPropertyID_BasicDescription,
                  sizeof(asbd), &amp;asbd, NULL );
  if (err)
  {
    fprintf(LOG_FILE, &quot;### In DoSCAudioCompress(): QTGetComponentProperty(stdAudio, BasicDescription) returned err %ld\n&quot;, err);
    goto bail;
  }
  
  // figure out the max bytes per packet
  if ( asbd.mBytesPerPacket )
  {
    maxBytesPerPacket = asbd.mBytesPerPacket;
  }
  else {
    err = QTGetComponentProperty(  globs-&gt;stdAudio, kQTPropertyClass_SCAudio, 
                    kQTSCAudioPropertyID_MaximumOutputPacketSize, 
                    sizeof(maxBytesPerPacket), &amp;maxBytesPerPacket, NULL);
    if (err)
    {
      fprintf(LOG_FILE, &quot;### Get(kQTSCAudioPropertyID_MaximumOutputPacketSize) returned err %ld\n&quot;, err);
      goto bail;
    }
  }
  
  
  // now we can make an audio buffer list big enough for the data we want to get
  bufferSize = maxBytesPerPacket * globs-&gt;pullPackets;
  if ( asbd.mFormatFlags &amp; kLinearPCMFormatFlagIsNonInterleaved )
    bufferSize *= asbd.mChannelsPerFrame;
    
  if (bufferSize == 0)
  {
    fprintf(LOG_FILE, &quot;### bufferSize rolled over.\n&quot;);
    err = memFullErr;
    goto bail;
  }
  buffer = malloc(bufferSize);
  bufferSize = maxBytesPerPacket * globs-&gt;pullPackets;
  
  if ( asbd.mFormatFlags &amp; kLinearPCMFormatFlagIsNonInterleaved )
  {
    abl = (AudioBufferList*)calloc(1, 
        offsetof(AudioBufferList, mBuffers[asbd.mChannelsPerFrame]));
    abl-&gt;mNumberBuffers = asbd.mChannelsPerFrame;
  }
  else {
    abl = (AudioBufferList*)calloc(1, offsetof(AudioBufferList, mBuffers[1]));
    abl-&gt;mNumberBuffers = 1;
  }
  
  if ( globs-&gt;onlyChannel &gt; -1 )
    onlyChannel = globs-&gt;onlyChannel;
  
  while ( true )
  {
    UInt32 i, pullPackets = globs-&gt;pullPackets;
    void * ptr = buffer;
    
    for (i = 0; i &lt; abl-&gt;mNumberBuffers; i++)
    {
      abl-&gt;mBuffers[i].mNumberChannels = (abl-&gt;mNumberBuffers &gt; 1 ? 1 : asbd.mChannelsPerFrame);
      abl-&gt;mBuffers[i].mDataByteSize = bufferSize;
      abl-&gt;mBuffers[i].mData = ptr;
      ptr = (UInt8*)ptr + bufferSize;
    }
    
    logflow(&quot;calling SCAudioFillBuffer for %lu packets\n&quot;, pullPackets);
    err = SCAudioFillBuffer(globs-&gt;stdAudio,
                mySCAudioInputDataProc,
                (void*)globs,
                &amp;pullPackets,
                abl,
                aspds);
    if (err)
    {
      fprintf(LOG_FILE, &quot;received err %ld from SCAudioFillBuffer\n&quot;, err);
      goto bail;
    }
    else if (pullPackets == 0 &amp;&amp; abl-&gt;mBuffers[0].mDataByteSize == 0) {
      fprintf(LOG_FILE, &quot;received EOS from SCAudioFillBuffer, finishing\n&quot;);
      break;
    }
    
    logflow(&quot;SCAudioFillBuffer returned %ld packets\n&quot;, pullPackets);
    if (pullPackets)
    {
    #if TARGET_OS_MAC
      if (globs-&gt;outaf)
      {
        err = AudioFileWritePackets (  globs-&gt;outaf,  
                        false,              // inUseCache,
                        abl-&gt;mBuffers[onlyChannel].mDataByteSize,  // inNumBytes,
                        aspds,              // inPacketDescriptions,
                        globs-&gt;numPacketsWritten,    // inStartingPacket, 
                        &amp;pullPackets,          // ioNumPackets, 
                        abl-&gt;mBuffers[onlyChannel].mData );    // inBuffer
        if (err)
        {
          fprintf(LOG_FILE, &quot;### AudioFileWritePackets() returned err %ld\n&quot;, err);
          goto bail;
        }
        
        logflow(&quot;AudioFileWritePackets() wrote %ld packets\n&quot;, pullPackets);
        globs-&gt;numPacketsWritten += pullPackets;
      }
      else
    #endif // TARGET_OS_MAC
            if (globs-&gt;writingRaw) {
                UInt32 i;
                
                for (i = 0; i &lt; abl-&gt;mNumberBuffers; i++)
                {
          if ( 1 &gt; fwrite(abl-&gt;mBuffers[i].mData, abl-&gt;mBuffers[i].mDataByteSize, 1, globs-&gt;rawFile) )
          {
                        fprintf(LOG_FILE, &quot;### fwrite() returned err %d\n&quot;, ferror(globs-&gt;rawFile));
                        goto bail;
                    }
                }
            }
      else {
        
        // add to the movie
        if (aspds)
        {
          // if we've got packet descriptions, we need to add them one at a time
          UInt32 i;
          
          for (i = 0; i &lt; pullPackets; i++)
          {
            err = AddMediaSample2(  globs-&gt;media,
                        (UInt8*)abl-&gt;mBuffers[onlyChannel].mData + aspds[i].mStartOffset,
                        aspds[i].mDataByteSize,
                        (aspds[i].mVariableFramesInPacket 
                          ? aspds[i].mVariableFramesInPacket 
                          : asbd.mFramesPerPacket), //decodeDurationPerSample
                        0, //displayOffset
                        (SampleDescriptionHandle)globs-&gt;sdh,
                        1, // numberOfSamples
                        0, // sampleFlags
                        NULL ); // sampleDecodeTimeOut
            if (err)
            {
              fprintf(LOG_FILE, &quot;### AddMediaSample2() returned err %ld\n&quot;, err);
              goto bail;
            }
          }
        }
        else {
          // make believe the frames in each packet are individually accessible.
          // this is commonly known as &quot;THE LIE&quot;.  It's the truth for PCM.
          // It's a lie for all CBR compressed formats.
          ItemCount numSamples = pullPackets * asbd.mFramesPerPacket;
          err = AddMediaSample2(  globs-&gt;media,
                      abl-&gt;mBuffers[onlyChannel].mData,
                      abl-&gt;mBuffers[onlyChannel].mDataByteSize,
                      1, //decodeDurationPerSample
                      0, //displayOffset
                      (SampleDescriptionHandle)globs-&gt;sdh,
                      numSamples, // numberOfSamples
                      0, // sampleFlags
                      NULL ); // sampleDecodeTimeOut
          if (err)
          {
            fprintf(LOG_FILE, &quot;### AddMediaSample2() returned err %ld\n&quot;, err);
            goto bail;
          }
        }
      }
    }
  }
  
bail:
  if (aspds)
    free(aspds);
  if (buffer)
    free(buffer);
  
  return err;
}


// --------------------------------------------------------------------------------
/*
    ConfigureStdAudio - Here's where we instantiate StdAudio, and feed it information
    about our source (asbd, layout, magic cookie).  If we've not been directed to
    suppress ui, we display the StdAudio modal dialog and let the user select
    his/her desired output format.
*/
// --------------------------------------------------------------------------------


static OSStatus
ConfigureStdAudio ( SCAudioCompressData globs )
{
    OSStatus err = noErr;
    AudioStreamBasicDescription inasbd;
  AudioChannelLayout * pLayout = NULL;
  void * magicCookie = NULL;
  UInt32 size = sizeof(inasbd), layoutSize = 0, cookieSize = 0;
  UInt32 numDiscreteInputChannels = 0;
    
    err = OpenADefaultComponent(StandardCompressionType, StandardCompressionSubTypeAudio, &amp;globs-&gt;stdAudio);
    if (err)
    {
        fprintf(LOG_FILE, &quot;### OpenADefaultComponent('scdi', 'audi') returned err %ld\n&quot;, err);
        goto bail;
    }

#if TARGET_OS_MAC
    if (globs-&gt;af)
    {
        
    
    
        // 1. get asbd
        err = AudioFileGetProperty( globs-&gt;af, kAudioFilePropertyDataFormat, &amp;size, &amp;inasbd);
        if (err)
        {
            fprintf(LOG_FILE, &quot;### AudioFileGetProperty(kAudioFilePropertyDataFormat) returned err %ld\n&quot;, err);
            goto bail;
        }
    
    
    // 2. get channel layout
    if ( noErr == AudioFileGetPropertyInfo( globs-&gt;af, kAudioFilePropertyChannelLayout, &amp;layoutSize, NULL ) )
    {
      pLayout = (AudioChannelLayout*)calloc(1, layoutSize);
      if ( noErr != AudioFileGetProperty( globs-&gt;af, kAudioFilePropertyChannelLayout, &amp;layoutSize, pLayout) )
      {
        free(pLayout);
        pLayout = NULL;
      }
    }
    
    
    // 3. get magic cookie
    if ( noErr == AudioFileGetPropertyInfo( globs-&gt;af, kAudioFilePropertyMagicCookieData, &amp;cookieSize, NULL ) )
    {
      magicCookie = calloc(1, cookieSize);
      if ( noErr != AudioFileGetProperty( globs-&gt;af, kAudioFilePropertyMagicCookieData, &amp;cookieSize, magicCookie) )
      {
        free(magicCookie);
        magicCookie = NULL;
      }
    }
    
    numDiscreteInputChannels = inasbd.mChannelsPerFrame;
    
    }
#endif // TARGET_OS_MAC
    else if ( globs-&gt;m ) {
    
    UInt32 maxSampleSize = 0;
    Boolean allChansDiscrete;
  
        // do it the qt way - use MovieAudioExtraction API's
    err = MovieAudioExtractionBegin( globs-&gt;m, 0, &amp;globs-&gt;mae );
    if (err)
    {
      fprintf(LOG_FILE, &quot;### MovieAudioExtractionBegin() returned err %ld\n&quot;, err);
      goto bail;
    }
    
    
    
    
    // first things first, temporarily set the extraction session to &quot;AllChannelsDiscrete&quot;, so
    // we can get the true (unmixed) channel count in the source movie.  We want the user to
    // have the option of exporting all the source channels without doing any mixing, and
    // for that we need to tell StdAudio the discrete number of channels to allow
    allChansDiscrete = true;
    
    err = MovieAudioExtractionSetProperty(  globs-&gt;mae,
                        kQTPropertyClass_MovieAudioExtraction_Movie,
                        kQTMovieAudioExtractionMoviePropertyID_AllChannelsDiscrete,
                        sizeof(allChansDiscrete), &amp;allChansDiscrete);
    if (err)
    {
      fprintf(LOG_FILE, &quot;### MovieAudioExtractionSetProperty(allChannelsDiscrete) returned err %ld\n&quot;, err);
      goto bail;
    }
    err = MovieAudioExtractionGetProperty(  globs-&gt;mae, kQTPropertyClass_MovieAudioExtraction_Audio,
                        kQTMovieAudioExtractionAudioPropertyID_AudioStreamBasicDescription,
                        sizeof(inasbd), &amp;inasbd, NULL );
    if (err)
    {
      fprintf(LOG_FILE, &quot;### MovieAudioExtractionGetProperty(asbd (allChannelsDiscrete)) returned err %ld\n&quot;, err);
      goto bail;
    }
    numDiscreteInputChannels = inasbd.mChannelsPerFrame;
    
    allChansDiscrete = false;
    err = MovieAudioExtractionSetProperty(  globs-&gt;mae,
                        kQTPropertyClass_MovieAudioExtraction_Movie,
                        kQTMovieAudioExtractionMoviePropertyID_AllChannelsDiscrete,
                        sizeof(allChansDiscrete), &amp;allChansDiscrete);
    if (err)
    {
      fprintf(LOG_FILE, &quot;### MovieAudioExtractionSetProperty(allChannelsDiscrete) returned err %ld\n&quot;, err);
      goto bail;
    }
    
    
    
    
    
    // not doing AllChannelsDiscrete any more - find out info about the summary mixed audio
    
    err = MovieAudioExtractionGetProperty(  globs-&gt;mae, kQTPropertyClass_MovieAudioExtraction_Audio,
                        kQTMovieAudioExtractionAudioPropertyID_AudioStreamBasicDescription,
                        sizeof(inasbd), &amp;inasbd, NULL );
    if (err)
    {
      fprintf(LOG_FILE, &quot;### MovieAudioExtractionGetProperty(asbd) returned err %ld\n&quot;, err);
      goto bail;
    }
        
        // get max sample size (needed for accurate 'alac').
        err = MovieAudioExtractionGetProperty(  globs-&gt;mae, kQTPropertyClass_MovieAudioExtraction_Audio,
                        kQTAudioPropertyID_MaxAudioSampleSize,
                        sizeof(maxSampleSize), &amp;maxSampleSize, NULL );
        if (noErr == err &amp;&amp; maxSampleSize)
        {
            inasbd.mBitsPerChannel = maxSampleSize;
            if (maxSampleSize &lt;= 32)
            {
                inasbd.mFormatFlags &amp;= ~(kLinearPCMFormatFlagIsFloat | kLinearPCMFormatFlagIsNonInterleaved);
                inasbd.mFormatFlags |= kLinearPCMFormatFlagIsSignedInteger;
                inasbd.mBytesPerFrame = inasbd.mBytesPerPacket = maxSampleSize/8 * inasbd.mChannelsPerFrame; 
            }
            
            err = MovieAudioExtractionSetProperty(  globs-&gt;mae,
                                                    kQTPropertyClass_MovieAudioExtraction_Audio,
                                                    kQTMovieAudioExtractionAudioPropertyID_AudioStreamBasicDescription,
                                                    sizeof(inasbd), &amp;inasbd);
            if (err)
            {
                fprintf(LOG_FILE, &quot;### MovieAudioExtractionSetProperty(asbd) returned err %ld\n&quot;, err);
                goto bail;
            }
        }
    
    
    if ( noErr == MovieAudioExtractionGetPropertyInfo(  globs-&gt;mae, kQTPropertyClass_MovieAudioExtraction_Audio,
                              kQTMovieAudioExtractionAudioPropertyID_AudioChannelLayout,
                              NULL, &amp;layoutSize, NULL ) )
    {
      if (layoutSize)
      {
        pLayout = (AudioChannelLayout*)calloc(1, layoutSize);
        if (noErr != MovieAudioExtractionGetProperty(globs-&gt;mae, kQTPropertyClass_MovieAudioExtraction_Audio,
                              kQTMovieAudioExtractionAudioPropertyID_AudioChannelLayout,
                              layoutSize, pLayout, &amp;layoutSize))
        {
          free(pLayout);
          pLayout = NULL;
        }
      }
    }
    }
  else {
  
    fprintf(LOG_FILE, &quot;### ConfigureStdAudio() called without a source AudioFileID or Movie!\n&quot;);
    err = paramErr;
    goto bail;
    
  }
  
  
  
  
  
  // set the input desc info on stdaudio
  err = QTSetComponentProperty(   globs-&gt;stdAudio, kQTPropertyClass_SCAudio, 
                  kQTSCAudioPropertyID_InputBasicDescription,
                  sizeof(inasbd), &amp;inasbd );
  if (err)
  {
    fprintf(LOG_FILE, &quot;### QTSetComponentProperty(stdaudio, InputBasicDescription) returned err %ld\n&quot;, err);
    goto bail;
  }
  
  if (pLayout)
  {
    err = QTSetComponentProperty(  globs-&gt;stdAudio, kQTPropertyClass_SCAudio,
                    kQTSCAudioPropertyID_InputChannelLayout,
                    layoutSize, pLayout );
    if (err)
    {
      fprintf(LOG_FILE, &quot;### QTSetComponentProperty(stdaudio, InputChannelLayout) returned err %ld\n&quot;, err);
      goto bail;
    }
  }
  
  if (magicCookie)
  {
    err = QTSetComponentProperty(  globs-&gt;stdAudio, kQTPropertyClass_SCAudio,
                    kQTSCAudioPropertyID_InputMagicCookie,
                    cookieSize, magicCookie );
    if (err)
    {
      fprintf(LOG_FILE, &quot;### QTSetComponentProperty(stdaudio, InputMagicCookie) returned err %ld\n&quot;, err);
      goto bail;
    }
  }
  
  
  // the following function call is optional - we can specify a list of allowable AudioChannelLayoutTag's
  // to StdAudio.  StdAudio will prune its list of available layout tags to our specified set.
  // If you want StdAudio to allow export to a custom layout (i.e. if the source movie has a 
  // whacky AudioChannelLayout that is not encompassed by any of the AudioChannelLayoutTag's),
  // or to show &quot;n Discrete Channels&quot; as an option, you need to set the
  // kQTSCAudioPropertyID_ClientRestrictedChannelLayoutTagList property, as shown
  // below.
  {
    AudioChannelLayoutTag tagList[] = 
      {
        kAudioChannelLayoutTag_DiscreteInOrder | numDiscreteInputChannels,  // OR in the real discrete number of channels
        kAudioChannelLayoutTag_UseChannelDescriptions,            // allows passthru of source's whacky custom channel layout (if it has one)
        
        kAudioChannelLayoutTag_Mono,
        kAudioChannelLayoutTag_Stereo,
        kAudioChannelLayoutTag_Quadraphonic,
        kAudioChannelLayoutTag_MPEG_5_0_A,
        kAudioChannelLayoutTag_MPEG_5_0_B,
        kAudioChannelLayoutTag_MPEG_5_0_C,
        kAudioChannelLayoutTag_MPEG_5_0_D,
        kAudioChannelLayoutTag_MPEG_5_1_A,
        kAudioChannelLayoutTag_MPEG_5_1_B,
        kAudioChannelLayoutTag_MPEG_5_1_C,
        kAudioChannelLayoutTag_MPEG_5_1_D,
        kAudioChannelLayoutTag_AudioUnit_6_0,
        kAudioChannelLayoutTag_AAC_6_0,
        kAudioChannelLayoutTag_MPEG_6_1_A,
        kAudioChannelLayoutTag_AAC_6_1,
        kAudioChannelLayoutTag_AudioUnit_7_0,
        kAudioChannelLayoutTag_AAC_7_0,
        kAudioChannelLayoutTag_MPEG_7_1_A,
        kAudioChannelLayoutTag_MPEG_7_1_B,
        kAudioChannelLayoutTag_MPEG_7_1_C,
        kAudioChannelLayoutTag_Emagic_Default_7_1,
        kAudioChannelLayoutTag_AAC_Octagonal
       };
       
    (void)QTSetComponentProperty(globs-&gt;stdAudio,
        kQTPropertyClass_SCAudio,
        kQTSCAudioPropertyID_ClientRestrictedChannelLayoutTagList,
        sizeof(tagList),
        tagList);
  }
  
  
  
  if (globs-&gt;onlyChannel &gt; -1 ||
        globs-&gt;writingRaw)
  {
    // if globs-&gt;onlyChannel &gt; -1, we need to only write one of the source channels.  This requires that
    // (1) onlyChannel must be &lt; inasbd.mChannelsPerFrame
    // (2) StdAudio must be configured to only do deinterleaved
    // (3) Stdaudio must be configured to only do PCM (as per 2 above)
    SCAudioFormatFlagsRestrictions restrictions = { 0 };
    OSType restrictedFormat = 'lpcm';
    
    if (globs-&gt;onlyChannel &gt;= (SInt32)inasbd.mChannelsPerFrame)
    {
      fprintf(LOG_FILE, &quot;### The requested channel (%lu) to write is greater than the source number of channels (%lu)\n&quot;,
        globs-&gt;onlyChannel, inasbd.mChannelsPerFrame);
      err = badFormat;
      goto bail;
    }
    
        restrictions.formatFlagsMask = kAudioFormatFlagIsNonInterleaved;
        
        if (globs-&gt;onlyChannel &gt; -1)
        {
            restrictions.formatFlagsValues = kAudioFormatFlagIsNonInterleaved;
        }
        else {
            // if writing raw, we want to force interleaved
        }
    
    err = QTSetComponentProperty(  globs-&gt;stdAudio, kQTPropertyClass_SCAudio,
                    kQTSCAudioPropertyID_ClientRestrictedLPCMFlags,
                    sizeof(restrictions), &amp;restrictions );
    if (err)
    {  
      fprintf(LOG_FILE, &quot;### QTSetComponentProperty(stdaudio, ClientRestrictedLPCMFlags) returned err %ld\n&quot;, err);
      goto bail;
    }
    
    err = QTSetComponentProperty(  globs-&gt;stdAudio, kQTPropertyClass_SCAudio,
                    kQTSCAudioPropertyID_ClientRestrictedCompressionFormatList,
                    sizeof(restrictedFormat), &amp;restrictedFormat );
    if (err)
    {
      fprintf(LOG_FILE, &quot;### QTSetComponentProperty(stdaudio, ClientRestrictedCompressionFormatList) returned err %ld\n&quot;, err);
      goto bail;
    }
  }
  
  
  
  // now StdAudio has been configured with the input info.
  // Display the dialog now
  if ( false == globs-&gt;suppressUI )
  {
    SCExtendedProcs xProcs;
    
    
    // make our command line test app an app that can become the foreground process
  #if TARGET_OS_MAC
    extern  int32_t  CPSEnableForegroundOperation( ProcessSerialNumber * PSN );
    
    ProcessSerialNumber psn;
    
    GetCurrentProcess(&amp;psn);
    CPSEnableForegroundOperation(&amp;psn);
    SetFrontProcess(&amp;psn);
  #endif
    
    memset(&amp;xProcs, 0, sizeof(xProcs));
    strcpy((char*)xProcs.customName + 1, &quot;Select Output Format&quot;);
    xProcs.customName[0] = (unsigned char)strlen((char*)xProcs.customName + 1);
    (void)QTSetComponentProperty(  globs-&gt;stdAudio, kQTPropertyClass_SCAudio, 
                    kQTSCAudioPropertyID_ExtendedProcs, 
                    sizeof(xProcs), &amp;xProcs);
                    
    err = SCRequestImageSettings(globs-&gt;stdAudio);
    if (err == userCanceledErr)
      err = noErr; // User cancelling is ok.
    if (err)
    {
      fprintf(LOG_FILE, &quot;### SCRequestImageSettings() returned err %ld\n&quot;, err);
      goto bail;
    }
  }
  
  // Now we've given the user an opportunity to specify output settings, including
  // the &quot;Render Quality&quot; for the export operation (Render Quality is one of the
  // choices in the dialog).  If we are extracting from a movie, we should apply
  // that same render quality to the MovieAudioExtraction Session, so that
  // any scaled edits or codec decompressions are done at the same render quality
  // that was specified in the dialog
  if (globs-&gt;mae)
  {
    UInt32 renderQuality;
    
    if (noErr == QTGetComponentProperty(globs-&gt;stdAudio, kQTPropertyClass_SCAudio,
                      kQTSCAudioPropertyID_RenderQuality,
                      sizeof(renderQuality), &amp;renderQuality, NULL))
    {
      err = MovieAudioExtractionSetProperty(  globs-&gt;mae,
                          kQTPropertyClass_MovieAudioExtraction_Audio,
                          kQTMovieAudioExtractionAudioPropertyID_RenderQuality,
                          sizeof(renderQuality), &amp;renderQuality);
      if (err)
      {
        fprintf(LOG_FILE, &quot;### MovieAudioExtractionSetProperty(renderQuality) returned err %ld\n&quot;, err);
        goto bail;
      }
    }
  }
  
  // if we've been configured to produce discrete output channels, we need
  // to set up MovieAudioExtraction to render the PCM samples without mixing
  if (globs-&gt;mae)
  {
    AudioChannelLayout * outputLayout = NULL;
    UInt32         outputLayoutSize = 0;
    
    err = QTGetComponentPropertyInfo(globs-&gt;stdAudio, kQTPropertyClass_SCAudio,
        kQTSCAudioPropertyID_ChannelLayout, NULL, &amp;outputLayoutSize, NULL);
    if (err)
    {
      fprintf(LOG_FILE, &quot;### QTGetComponentPropertyInfo(layoutSize) returned err %ld\n&quot;, err);
      goto bail;
    }
    
    outputLayout = (AudioChannelLayout*)malloc(outputLayoutSize);
    
    err = QTGetComponentProperty(globs-&gt;stdAudio, kQTPropertyClass_SCAudio,
                      kQTSCAudioPropertyID_ChannelLayout,
                      outputLayoutSize, outputLayout, &amp;outputLayoutSize);
    if (err)
    {
      fprintf(LOG_FILE, &quot;### QTGetComponentProperty(layoutSize) returned err %ld\n&quot;, err);
    }
    if (err == noErr &amp;&amp; 
      ((outputLayout-&gt;mChannelLayoutTag &amp; 0xFFFF0000) == kAudioChannelLayoutTag_DiscreteInOrder))
    {
      Boolean allChansDiscrete = true;
      err = MovieAudioExtractionSetProperty(  globs-&gt;mae,
                          kQTPropertyClass_MovieAudioExtraction_Movie,
                          kQTMovieAudioExtractionMoviePropertyID_AllChannelsDiscrete,
                          sizeof(allChansDiscrete), &amp;allChansDiscrete);
      if (err)
      {
        fprintf(LOG_FILE, &quot;### MovieAudioExtractionSetProperty(allChannelsDiscrete - for real this time!) returned err %ld\n&quot;, err);
      }
      
      if (err == noErr)
      {
        // re-get the input asbd (with new number of channels)
        err = MovieAudioExtractionGetProperty(  globs-&gt;mae, kQTPropertyClass_MovieAudioExtraction_Audio,
                            kQTMovieAudioExtractionAudioPropertyID_AudioStreamBasicDescription,
                            sizeof(inasbd), &amp;inasbd, NULL );
        if (err)
        {
          fprintf(LOG_FILE, &quot;### MovieAudioExtractionGetProperty(asbd) returned err %ld\n&quot;, err);
        }
        
        // tell StdAudio about the input format change
        if (err == noErr)
        {
          SoundDescriptionHandle sdh = NULL;
          
          err = QTSoundDescriptionCreate(&amp;inasbd, outputLayout, outputLayoutSize, NULL, 0,
              kQTSoundDescriptionKind_Movie_AnyVersion, &amp;sdh);
              
          if (err)
          {
            fprintf(LOG_FILE, &quot;### QTSoundDescriptionCreate() returned err %ld\n&quot;, err);
          }
          
          if (err == noErr)
          {
            err = QTSetComponentProperty(globs-&gt;stdAudio, kQTPropertyClass_SCAudio,
                      kQTSCAudioPropertyID_InputSoundDescription,
                      sizeof(sdh), &amp;sdh);
            if (err)
            {
              fprintf(LOG_FILE, &quot;### QTSetComponentProperty(InputSDH) returned err %ld\n&quot;, err);
            }
          }
          DisposeHandle((Handle)sdh);
        }
      }
    }
    free(outputLayout);
    if (err) 
      goto bail;
  }
    
    globs-&gt;inasbd = inasbd;
    
bail:
  if (pLayout)
    free(pLayout);
  if (magicCookie)
    free(magicCookie);
    return err;
}


// --------------------------------------------------------------------------------
/*
    OpenDestinationFile - Here's where we open the destination file, either a
    QuickTime movie, .caf file, or raw pcm file.
*/
// --------------------------------------------------------------------------------


static OSStatus
OpenDestinationFile ( SCAudioCompressData globs )
{
    OSStatus err = noErr;
#if TARGET_OS_MAC
  CFStringRef  filename = NULL;
#endif
  UInt32 size;
  AudioStreamBasicDescription format = { 0 };
  
  // get the format we'll be writing
  err = QTGetComponentProperty(  globs-&gt;stdAudio, kQTPropertyClass_SCAudio, 
                  kQTSCAudioPropertyID_BasicDescription,
                  sizeof(format), &amp;format, NULL );
  if (err)
  {
    fprintf(LOG_FILE, &quot;### QTGetComponentProperty(stdAudio, BasicDescription) returned err %ld\n&quot;, err);
    goto bail;
  }
  
  if (globs-&gt;onlyChannel &gt; -1)
  {
    if (globs-&gt;onlyChannel &gt;= (SInt32)format.mChannelsPerFrame)
    {
      fprintf(LOG_FILE, &quot;### The requested channel (%lu) to write is greater than the source number of channels (%lu)\n&quot;,
        globs-&gt;onlyChannel + 1, format.mChannelsPerFrame);
      err = badFormat;
      goto bail;
    }
    
    format.mFormatFlags &amp;= ~kLinearPCMFormatFlagIsNonInterleaved;
    format.mChannelsPerFrame = 1;
  }
  
  
  
  // delete the file if there already is one
  remove(globs-&gt;outFile);
  
  err = noErr;
  

    
  if (globs-&gt;writingMovie)
  {
    
    CFStringRef fullpath = CFStringCreateWithCString(NULL, globs-&gt;outFile, kCFStringEncodingASCII);
    Handle dataRef = NULL;
    OSType dataRefType = 0;
    Track t;
    
    
    err = QTNewDataReferenceFromFullPathCFString(fullpath, kQTNativeDefaultPathStyle, 0, &amp;dataRef, &amp;dataRefType);
    CFRelease(fullpath);
    if( err ) 
    {
      fprintf( LOG_FILE, &quot;### QTNewDataReferenceFromFullPathCFString() returned err %ld\n&quot;, err );
      goto bail;
    }
    
    err = CreateMovieStorage(  dataRef, dataRefType, 'TVOD', 0, createMovieFileDeleteCurFile,
                  &amp;globs-&gt;dataH, &amp;globs-&gt;outm );
    DisposeHandle(dataRef);
    if (err)
    {
      fprintf( LOG_FILE, &quot;### CreateMovieStorage() returned err %ld\n&quot;, err);
      goto bail;
    }
    
    t = NewMovieTrack(globs-&gt;outm, 0, 0, kFullVolume);
    err = GetMoviesError();
    if (err)
    {
      fprintf(LOG_FILE, &quot;### NewMovieTrack() returned err %ld\n&quot;, err);
      goto bail;
    }
    
    globs-&gt;media = NewTrackMedia(t, SoundMediaType, (TimeScale)format.mSampleRate, NULL, 0);
    err = GetMoviesError();
    if (err)
    {
      fprintf(LOG_FILE, &quot;### NewTrackMedia() returned err %ld\n&quot;, err);
      goto bail;
    }
    
    err = BeginMediaEdits( globs-&gt;media );
    if (err)
    {
      fprintf(LOG_FILE, &quot;### BeginMediaEdits() returned err %ld\n&quot;, err);
    }
    
    err = QTSoundDescriptionCreate( &amp;format, NULL, 0, NULL, 0, 
                    kQTSoundDescriptionKind_Movie_LowestPossibleVersion,
                    &amp;globs-&gt;sdh);
    if (err)
    {
      fprintf(LOG_FILE, &quot;### QTSoundDescriptionCreate() returned err %ld\n&quot;, err);
      goto bail;
    }
    
    
    
  }
    else if ( globs-&gt;writingRaw ) {

    globs-&gt;rawFile = fopen(globs-&gt;outFile, &quot;w&quot;);

        if ( NULL == globs-&gt;rawFile )
        {
            fprintf(LOG_FILE, &quot;### fopen() returned err %d\n&quot;, errno);
      goto bail;
        }

    }
#if TARGET_OS_MAC
  else {
    unsigned char sep = '/'; // For Windows, sep would be '\\'
    FSRef fsdir, fspath;
    Boolean isDirectory = false;
    UInt32 i, len = (UInt32)strlen(globs-&gt;outFile);

      // separate the directory from the last component of the path
    for (i = len; i &gt; 0; i--)
    {
      if ( globs-&gt;outFile[i - 1] == sep )
      {
        char temp;
        filename = CFStringCreateWithCString(NULL, globs-&gt;outFile + i, kCFStringEncodingASCII);
        temp = globs-&gt;outFile[i];
        globs-&gt;outFile[i] = '\0';
        err = FSPathMakeRef((UInt8*)globs-&gt;outFile, &amp;fsdir, &amp;isDirectory);
        globs-&gt;outFile[i] = temp;
        if (err || !isDirectory)
        {
          fprintf(LOG_FILE, &quot;### FSPathMakeRef for \&quot;%s\&quot; returned err %ld\n&quot;, globs-&gt;outFile, err);
          goto bail;
        }
        break;
      }
    }
    
    if ( NULL == filename )
    {
      fprintf(LOG_FILE, &quot;### Couldn't parse \&quot;%s\&quot; for the last path component\n&quot;, globs-&gt;outFile);
      err = paramErr;
      goto bail;
    }

    err = AudioFileCreate (  &amp;fsdir, filename, kAudioFileCAFType, &amp;format,
                0, // inFlags,
                &amp;fspath, &amp;globs-&gt;outaf);
    if (err)
    {
      fprintf(LOG_FILE, &quot;### AudioFileCreate() returned err %ld\n&quot;, err);
      goto bail;
    }
  }  
#endif  
  
  if ( globs-&gt;onlyChannel == -1 &amp;&amp; false == globs-&gt;writingRaw )
  {
    // set the layout on the file
    if (noErr == QTGetComponentPropertyInfo(globs-&gt;stdAudio, kQTPropertyClass_SCAudio,
                        kQTSCAudioPropertyID_ChannelLayout,
                        NULL, &amp;size, NULL))
    {
      if (size)
      {
        AudioChannelLayout * pLayout = (AudioChannelLayout*)calloc(1, size);
        if (noErr == QTGetComponentProperty(globs-&gt;stdAudio, kQTPropertyClass_SCAudio,
                          kQTSCAudioPropertyID_ChannelLayout,
                          size, pLayout, &amp;size))
        {
        #if TARGET_OS_MAC
          if (globs-&gt;outaf)
          {
            err = AudioFileSetProperty(globs-&gt;outaf, kAudioFilePropertyChannelLayout, size, pLayout);
            if (err)
              fprintf(LOG_FILE, &quot;### AudioFileSetProperty(kAudioFilePropertyChannelLayout) returned err %ld\n&quot;, err);
          }
          else 
        #endif
          {
            err = QTSoundDescriptionSetProperty(globs-&gt;sdh, kQTPropertyClass_SoundDescription,
                              kQTSoundDescriptionPropertyID_AudioChannelLayout,
                              size, pLayout);
            if (err)
              fprintf(LOG_FILE, &quot;### QTSoundDescriptionSetProperty(ChannelLayout) returned err %ld\n&quot;, err);
          }
        }
        free(pLayout);
        if (err)
          goto bail;
      }
    }
    
    
    // set the magic cookie on the file
    if (noErr == QTGetComponentPropertyInfo(globs-&gt;stdAudio, kQTPropertyClass_SCAudio,
                        kQTSCAudioPropertyID_MagicCookie,
                        NULL, &amp;size, NULL))
    {
      if (size)
      {
        void * magicCookie = calloc(1, size);
        if (noErr == QTGetComponentProperty(globs-&gt;stdAudio, kQTPropertyClass_SCAudio,
                          kQTSCAudioPropertyID_MagicCookie,
                          size, magicCookie, &amp;size))
        {
        #if TARGET_OS_MAC
          if (globs-&gt;outaf)
          {
            err = AudioFileSetProperty(globs-&gt;outaf, kAudioFilePropertyMagicCookieData, size, magicCookie);
            if (err)
              fprintf(LOG_FILE, &quot;### AudioFileSetProperty(kAudioFilePropertyChannelLayout) returned err %ld\n&quot;, err);
          }
          else 
        #endif
          {
            err = QTSoundDescriptionSetProperty(globs-&gt;sdh, kQTPropertyClass_SoundDescription,
                              kQTSoundDescriptionPropertyID_MagicCookie,
                              size, magicCookie);
            if (err)
              fprintf(LOG_FILE, &quot;### QTSoundDescriptionSetProperty(MagicCookie) returned err %ld\n&quot;, err);
          }
        }
        free(magicCookie);
        if (err)
          goto bail;
      }
    }
  }
  
  
  
  
bail:
#if TARGET_OS_MAC
  if (filename)
    CFRelease(filename);
#endif
    return err;
}


// --------------------------------------------------------------------------------
/*
    OpenSourceFile - Here's where we open the source file.  First we try to open
    it using AudioFileOpen, and fall back to importing it as a QuickTime movie
    if AudioFile doesn't understand the file format.
*/
// --------------------------------------------------------------------------------


static OSStatus
OpenSourceFile( SCAudioCompressData globs )
{
    OSStatus err = noErr;
    
    if ( NULL == globs-&gt;inFile || NULL == globs-&gt;outFile )
        return paramErr;

#if TARGET_OS_MAC    
    if (false == globs-&gt;forceQTRead)
    {
    UInt32 size;
    FSRef fsref;
        err = FSPathMakeRef( (UInt8*)globs-&gt;inFile, &amp;fsref, NULL );
        if (err)
        {
            fprintf(LOG_FILE, &quot;### FSPathMakeRef(\&quot;%s\&quot;) returned err %ld\n&quot;, globs-&gt;inFile, err);
            goto bail;
        }
    err = AudioFileOpen( &amp;fsref, fsRdPerm, 0, &amp;globs-&gt;af );
        if (err)
    {
            fprintf(LOG_FILE, &quot;AudioFileOpen(\&quot;%s\&quot;) returned err %ld (reverting to QT read path)\n&quot;, globs-&gt;inFile, err);
      goto readWithQT;
    }
      
    size = sizeof(globs-&gt;srcFilePacketCount);
    err = AudioFileGetProperty(  globs-&gt;af, kAudioFilePropertyAudioDataPacketCount,
                  &amp;size, &amp;globs-&gt;srcFilePacketCount);
    if (err)
    {
      fprintf(LOG_FILE, &quot;AudioFileGetProperty(kAudioFilePropertyAudioDataPacketCount) returned err %ld\n&quot;, err);
      goto bail;
    }
    
    size = sizeof(globs-&gt;srcFileMaxPacketSize);
    err = AudioFileGetProperty(  globs-&gt;af, kAudioFilePropertyMaximumPacketSize,
                  &amp;size, &amp;globs-&gt;srcFileMaxPacketSize);
    if (err)
    {
      fprintf(LOG_FILE, &quot;AudioFileGetProperty(kAudioFilePropertyMaximumPacketSize) returned err %ld\n&quot;, err);
      goto bail;
    }
    }

readWithQT:    
    // open the input file with QT if needed
    if ( globs-&gt;af == 0 )
#endif // TARGET_OS_MAC
    {
        Handle dataRef = NULL;
        OSType dataRefType = 0;
        short resID = 0;
    CFStringRef fullpath = CFStringCreateWithCString(NULL, globs-&gt;inFile, kCFStringEncodingASCII);
        
    err = QTNewDataReferenceFromFullPathCFString(fullpath, kQTNativeDefaultPathStyle, 0, &amp;dataRef, &amp;dataRefType);
    CFRelease(fullpath);
        if (err)
        {
            fprintf(LOG_FILE, &quot;### QTNewDataReferenceFromFullPathCFString(\&quot;%s\&quot;) returned err %ld\n&quot;, globs-&gt;inFile, err);
            goto bail;
        }
        
        err = NewMovieFromDataRef(  &amp;globs-&gt;m, 
                                    newMovieActive | newMovieDontAskUnresolvedDataRefs,
                                    &amp;resID,
                                    dataRef, dataRefType);
        DisposeHandle(dataRef);
        if (err)
        {
            fprintf(LOG_FILE, &quot;### NewMovieFromDataRef() returned err %ld\n&quot;, err);
            goto bail;
        }
    }
bail:
    return err;
}


// --------------------------------------------------------------------------------


static OSStatus
RunTheTest( SCAudioCompressData globs )
{
    OSStatus err = noErr;
  
#if TARGET_OS_WIN32
  InitializeQTML(0);
#endif
  err = EnterMovies();
  if (err) 
  { 
    fprintf(LOG_FILE, &quot;EnterMovies() returned err %ld\n&quot;, err);
    goto bail; 
  }
    
    err = OpenSourceFile(globs);
    if (err) goto bail;
    
    err = ConfigureStdAudio(globs);
    if (err) goto bail;
    
    err = OpenDestinationFile(globs);
    if (err) goto bail;
  
  err = DoSCAudioCompress(globs);
  if (err) goto bail;
bail:
    return err;
}



// --------------------------------------------------------------------------------


static void
PrintUsage(FILE * f)
{
#if TARGET_OS_MAC
    fprintf(f, &quot;scaudiocompress -i /path/to/inputfile -o /path/to/outputfile.(caf | mov | pcm) { [-writeraw] | [-noui] | [-pullPackets #] | [-forceqtinput] }\n&quot;);
    fprintf(f, &quot;\t(default output file format is .caf)\n&quot;);
#else
    fprintf(f, &quot;scaudiocompress -i /path/to/inputfile -o /path/to/outputfile.(mov | pcm) { [-writeraw] | [-noui] | [-pullPackets #] | [-forceqtinput] }\n&quot;);
    fprintf(f, &quot;\t(default output file format is .mov)\n&quot;);
#endif
    fprintf(f, &quot;\t-noui          = Run automated test.  No StdAudio dialog UI is shown.\n&quot;);
    fprintf(f, &quot;\t-pullpackets   = The number of packets of audio to pull for at a time.  Default is %lu.\n&quot;, DEFAULT_PULL_FRAMES);
    fprintf(f, &quot;\t-forceqtinput  = Don't try to open the input file using AudioFile API's, just use QuickTime API's\n&quot;);
  fprintf(f, &quot;\t-channel       = Only write the specified input channel (zero-based) to the output movie/audio file\n&quot;);
}


// --------------------------------------------------------------------------------


int main (int argc, const char * argv[]) {
    int i;
    OSStatus err = noErr;
    SCAudioCompressDataRecord globs = { 0 };
    
    globs.pullPackets = DEFAULT_PULL_FRAMES;
  globs.onlyChannel = -1;
    
    for (i = 1; i &lt; argc; i++)
    {
        if ( (0 == strncmp(&quot;-input&quot;, argv[i], 2)) &amp;&amp; i + 1 &lt; argc )
            globs.inFile = (char*)argv[++i];
    if ( (0 == strncmp(&quot;-channel&quot;, argv[i], 2)) &amp;&amp; i + 1 &lt; argc )
      globs.onlyChannel = strtol(argv[++i], NULL, 0);
        if ( (0 == strncmp(&quot;-output&quot;, argv[i], 2)) &amp;&amp; i + 1 &lt; argc )
            globs.outFile = (char*)argv[++i];
        if ( 0 == strncmp(&quot;-noui&quot;, argv[i], 2) )
            globs.suppressUI = true;
        if ( (0 == strncmp(&quot;-pullpackets&quot;, argv[i], 2)) &amp;&amp; i + 1 &lt; argc )
            globs.pullPackets = strtoul(argv[++i], NULL, 0);
        if ( 0 == strncmp(&quot;-forceqtinput&quot;, argv[i], 2) )
            globs.forceQTRead = true;
    }
    
    if ( NULL == globs.inFile || NULL == globs.outFile )
    {
        PrintUsage(LOG_FILE);
        err = paramErr;
        goto bail;
    }
    
    // see if they want to write a quicktime movie, or raw pcm file
  if ( strlen(globs.outFile) &gt; 4 )
  {
        const char * extension = globs.outFile + strlen(globs.outFile) - 4;
    if ( 0 == strcmp(extension, &quot;.mov&quot;) )
      globs.writingMovie = true;
        else if ( 0 == strcmp(extension, &quot;.pcm&quot;) )
            globs.writingRaw = true;
  }
    
    
    err = RunTheTest( &amp;globs );
    if (err)
    {
        fprintf(LOG_FILE, &quot;### DoSCAudioCompressTest returned %ld\n&quot;, err);
        goto bail;
    }
    
bail:

    // close up stuff
    if (globs.stdAudio)
        CloseComponent(globs.stdAudio);
    
    if (globs.mae)
        MovieAudioExtractionEnd(globs.mae);
        
    if (globs.m)
        DisposeMovie(globs.m);

#if TARGET_OS_MAC        
    if (globs.af)
        AudioFileClose(globs.af);
#endif

  if (globs.packetDescs)
    free(globs.packetDescs);
    
  if (globs.srcFileReadBuffer)
    free(globs.srcFileReadBuffer);

#if TARGET_OS_MAC
    if (globs.outaf)
    {
        OSStatus afcloseErr = AudioFileClose(globs.outaf);
        if (afcloseErr)
            fprintf(LOG_FILE, &quot;### AudioFileClose \&quot;%s\&quot; returned %ld\n&quot;, globs.outFile, afcloseErr);
    }
#endif
  
  if (globs.outm)
  {
    Track t = GetMediaTrack( globs.media );
    err = EndMediaEdits( globs.media );
    if (err)
      fprintf(LOG_FILE, &quot;### EndMediaEdits() returned err %ld\n&quot;, err);
    
    err = InsertMediaIntoTrack( t, 0, 0, GetMediaDuration(globs.media), fixed1 );
    if (err)
      fprintf(LOG_FILE, &quot;### InsertMediaIntoTrack() returned err %ld\n&quot;, err);
      
    err = AddMovieToStorage( globs.outm, globs.dataH );
    if (err)
      fprintf(LOG_FILE, &quot;### AddMovieToStorage() returned err %ld\n&quot;, err);
      
    CloseMovieStorage( globs.dataH );
    DisposeMovie(globs.outm);
    DisposeHandle((Handle)globs.sdh);
  }
    
    if ( globs.inputBuffers )
    {
        for ( i = 0; i &lt; (int)globs.inasbd.mChannelsPerFrame; i++ )
            free(globs.inputBuffers[i]);
        free(globs.inputBuffers);
    }
    
    if (globs.writingRaw &amp;&amp; globs.rawFile)
    {
    fclose(globs.rawFile);
    }

    return err;
}
</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/scaudiocompress/listing2.html%3Fid%3DDTS10003962-1.1&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/scaudiocompress/listing2.html%3Fid%3DDTS10003962-1.1&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/scaudiocompress/listing2.html%3Fid%3DDTS10003962-1.1&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>