<html><head><title>Mac OS X
 Manual Page For perlintro(1)</title>
<style type="text/css"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { font-size: 1px; background: #ffffff; color: #ffffff; } --></style>
<style type="text/css" media="print, aural, braille, embossed, projection, tty"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { display: none; } --></style>
</head><body bgcolor="white">
<a name="//apple_ref/doc/man/1/perlintro" title="Mac OS X
 Manual Page for perlintro(1)"><!-- headerDoc=man; indexgroup=Section 1; uid="//apple_ref/doc/man/1/perlintro"; name=perlintro(1) --></a>
<!--#include virtual="/includes/framesetheader"-->
<table width=600><tr><td scope="row">
<!-- begin breadcrumb insert request --><font face="Geneva,Helvetica,Arial" size="1">
 <a target="_top" href="http://developer.apple.com">ADC Home</a> <b>&gt;</b> <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> <b>&gt;</b> <a href="../../../../../reference/index.html#//apple_ref/doc/uid/TP30001281" target="_top">Reference</a> <b>&gt;</b> <!-- a href="" target="_top" -->Mac OS X<!-- /a --> <b>&gt;</b> <a href="../index.html#//apple_ref/doc/framework/manpages" target="_top">Mac OS X Man Pages</a></font>
<!-- end breadcrumb insert request -->
<p>&nbsp;</p>
</td></tr></table>
<!-- end of header -->
<table border="0"  cellpadding="2" cellspacing="2" width="630pt"><tr><td valign="top" height="12" colspan="5" scope="row">
<p style='text-align:justify;'>This document is a Mac OS X manual page.  Manual pages are a command-line technology
for providing documentation.  You can view these manual pages locally using the
<a href="man.1.html#//apple_ref/doc/man/1/man">man(1)</a> command.
These manual pages come from many different sources, and thus, have a variety of writing
styles.</p>
<p style='text-align:justify;'>For more information about the manual page format, see the manual page for 
<a href="../man5/manpages.5.html#//apple_ref/doc/man/5/manpages">manpages(5)</a>.</p>
</td></tr></table>
<hr />
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row"><pre class="manpages"><tt>
PERLINTRO(1)                          Perl Programmers Reference Guide                          PERLINTRO(1)



<b>NAME</b>
       perlintro -- a brief introduction and overview of Perl

<b>DESCRIPTION</b>
       This document is intended to give you a quick overview of the Perl programming language, along with
       pointers to further documentation.  It is intended as a "bootstrap" guide for those who are new to
       the language, and provides just enough information for you to be able to read other peoples' Perl and
       understand roughly what it's doing, or write your own simple scripts.

       This introductory document does not aim to be complete.  It does not even aim to be entirely accu-<font color="#ffffff" class="whiteout">rate.&nbsp;accurate.</font>
       rate.  In some cases perfection has been sacrificed in the goal of getting the general idea across.
       You are <u>strongly</u> advised to follow this introduction with more information from the full Perl manual,
       the table of contents to which can be found in perltoc.

       Throughout this document you'll see references to other parts of the Perl documentation.  You can
       read that documentation using the "perldoc" command or whatever method you're using to read this doc-<font color="#ffffff" class="whiteout">ument.&nbsp;document.</font>
       ument.

       <b>What</b> <b>is</b> <b>Perl?</b>

       Perl is a general-purpose programming language originally developed for text manipulation and now
       used for a wide range of tasks including system administration, web development, network programming,
       GUI development, and more.

       The language is intended to be practical (easy to use, efficient, complete) rather than beautiful
       (tiny, elegant, minimal).  Its major features are that it's easy to use, supports both procedural and
       object-oriented (OO) programming, has powerful built-in support for text processing, and has one of
       the world's most impressive collections of third-party modules.

       Different definitions of Perl are given in perl, perlfaq1 and no doubt other places.  From this we
       can determine that Perl is different things to different people, but that lots of people think it's
       at least worth writing about.

       <b>Running</b> <b>Perl</b> <b>programs</b>

       To run a Perl program from the Unix command line:

           perl progname.pl

       Alternatively, put this as the first line of your script:

           #!/usr/bin/env perl

       ... and run the script as "/path/to/script.pl".  Of course, it'll need to be executable first, so
       "chmod 755 script.pl" (under Unix).

       For more information, including instructions for other platforms such as Windows and Mac OS, read
       perlrun.

       <b>Basic</b> <b>syntax</b> <b>overview</b>

       A Perl script or program consists of one or more statements.  These statements are simply written in
       the script in a straightforward fashion.  There is no need to have a "main()" function or anything of
       that kind.

       Perl statements end in a semi-colon:

           print "Hello, world";

       Comments start with a hash symbol and run to the end of the line

           # This is a comment

       Whitespace is irrelevant:

           print
               "Hello, world"
               ;

       ... except inside quoted strings:

           # this would print with a linebreak in the middle
           print "Hello
           world";

       Double quotes or single quotes may be used around literal strings:

           print "Hello, world";
           print 'Hello, world';

       However, only double quotes "interpolate" variables and special characters such as newlines ("\n"):

           print "Hello, $name\n";     # works fine
           print 'Hello, $name\n';     # prints $name\n literally

       Numbers don't need quotes around them:

           print 42;

       You can use parentheses for functions' arguments or omit them according to your personal taste.  They
       are only required occasionally to clarify issues of precedence.

           print("Hello, world\n");
           print "Hello, world\n";

       More detailed information about Perl syntax can be found in perlsyn.

       <b>Perl</b> <b>variable</b> <b>types</b>

       Perl has three main variable types: scalars, arrays, and hashes.

       Scalars
           A scalar represents a single value:

               my $animal = "camel";
               my $answer = 42;

           Scalar values can be strings, integers or floating point numbers, and Perl will automatically
           convert between them as required.  There is no need to pre-declare your variable types.

           Scalar values can be used in various ways:

               print $animal;
               print "The animal is $animal\n";
               print "The square of $answer is ", $answer * $answer, "\n";

           There are a number of "magic" scalars with names that look like punctuation or line noise.  These
           special variables are used for all kinds of purposes, and are documented in perlvar.  The only
           one you need to know about for now is $_ which is the "default variable".  It's used as the
           default argument to a number of functions in Perl, and it's set implicitly by certain looping
           constructs.

               print;          # prints contents of $_ by default

       Arrays
           An array represents a list of values:

               my @animals = ("camel", "llama", "owl");
               my @numbers = (23, 42, 69);
               my @mixed   = ("camel", 42, 1.23);

           Arrays are zero-indexed.  Here's how you get at elements in an array:

               print $animals[0];              # prints "camel"
               print $animals[1];              # prints "llama"

           The special variable $#array tells you the index of the last element of an array:

               print $mixed[$#mixed];       # last element, prints 1.23

           You might be tempted to use "$#array + 1" to tell you how many items there are in an array.
           Don't bother.  As it happens, using @array where Perl expects to find a scalar value ("in scalar
           context") will give you the number of elements in the array:

               if (@animals &lt; 5) { ... }

           The elements we're getting from the array start with a "$" because we're getting just a single
           value out of the array -- you ask for a scalar, you get a scalar.

           To get multiple values from an array:

               @animals[0,1];                  # gives ("camel", "llama");
               @animals[0..2];                 # gives ("camel", "llama", "owl");
               @animals[1..$#animals];         # gives all except the first element

           This is called an "array slice".

           You can do various useful things to lists:

               my @sorted    = sort @animals;
               my @backwards = reverse @numbers;

           There are a couple of special arrays too, such as @ARGV (the command line arguments to your
           script) and @_ (the arguments passed to a subroutine).  These are documented in perlvar.

       Hashes
           A hash represents a set of key/value pairs:

               my %fruit_color = ("apple", "red", "banana", "yellow");

           You can use whitespace and the "=&gt;" operator to lay them out more nicely:

               my %fruit_color = (
                   apple  =&gt; "red",
                   banana =&gt; "yellow",
               );

           To get at hash elements:

               $fruit_color{"apple"};           # gives "red"

           You can get at lists of keys and values with "keys()" and "values()".

               my @fruits = keys %fruit_colors;
               my @colors = values %fruit_colors;

           Hashes have no particular internal order, though you can sort the keys and loop through them.

           Just like special scalars and arrays, there are also special hashes.  The most well known of
           these is %ENV which contains environment variables.  Read all about it (and other special vari-<font color="#ffffff" class="whiteout">ables)&nbsp;variables)</font>
           ables) in perlvar.

       Scalars, arrays and hashes are documented more fully in perldata.

       More complex data types can be constructed using references, which allow you to build lists and
       hashes within lists and hashes.

       A reference is a scalar value and can refer to any other Perl data type. So by storing a reference as
       the value of an array or hash element, you can easily create lists and hashes within lists and
       hashes. The following example shows a 2 level hash of hash structure using anonymous hash references.

           my $variables = {
               scalar  =&gt;  {
                            description =&gt; "single item",
                            sigil =&gt; '$',
                           },
               array   =&gt;  {
                            description =&gt; "ordered list of items",
                            sigil =&gt; '@',
                           },
               hash    =&gt;  {
                            description =&gt; "key/value pairs",
                            sigil =&gt; '%',
                           },
           };

           print "Scalars begin with a $variables-&gt;{'scalar'}-&gt;{'sigil'}\n";

       Exhaustive information on the topic of references can be found in perlreftut, perllol, perlref and
       perldsc.

       <b>Variable</b> <b>scoping</b>

       Throughout the previous section all the examples have used the syntax:

           my $var = "value";

       The "my" is actually not required; you could just use:

           $var = "value";

       However, the above usage will create global variables throughout your program, which is bad program-<font color="#ffffff" class="whiteout">ming&nbsp;programming</font>
       ming practice.  "my" creates lexically scoped variables instead.  The variables are scoped to the
       block (i.e. a bunch of statements surrounded by curly-braces) in which they are defined.

           my $a = "foo";
           if ($some_condition) {
               my $b = "bar";
               print $a;           # prints "foo"
               print $b;           # prints "bar"
           }
           print $a;               # prints "foo"
           print $b;               # prints nothing; $b has fallen out of scope

       Using "my" in combination with a "use strict;" at the top of your Perl scripts means that the inter-<font color="#ffffff" class="whiteout">preter&nbsp;interpreter</font>
       preter will pick up certain common programming errors.  For instance, in the example above, the final
       "print $b" would cause a compile-time error and prevent you from running the program.  Using "strict"
       is highly recommended.

       <b>Conditional</b> <b>and</b> <b>looping</b> <b>constructs</b>

       Perl has most of the usual conditional and looping constructs except for case/switch (but if you
       really want it, there is a Switch module in Perl 5.8 and newer, and on CPAN. See the section on mod-<font color="#ffffff" class="whiteout">ules,&nbsp;modules,</font>
       ules, below, for more information about modules and CPAN).

       The conditions can be any Perl expression.  See the list of operators in the next section for infor-<font color="#ffffff" class="whiteout">mation&nbsp;information</font>
       mation on comparison and boolean logic operators, which are commonly used in conditional statements.

       if
               if ( condition ) {
                   ...
               } elsif ( other condition ) {
                   ...
               } else {
                   ...
               }

           There's also a negated version of it:

               unless ( condition ) {
                   ...
               }

           This is provided as a more readable version of "if (!condition)".

           Note that the braces are required in Perl, even if you've only got one line in the block.  How-<font color="#ffffff" class="whiteout">ever,&nbsp;However,</font>
           ever, there is a clever way of making your one-line conditional blocks more English like:

               # the traditional way
               if ($zippy) {
                   print "Yow!";
               }

               # the Perlish post-condition way
               print "Yow!" if $zippy;
               print "We have no bananas" unless $bananas;

       while
               while ( condition ) {
                   ...
               }

           There's also a negated version, for the same reason we have "unless":

               until ( condition ) {
                   ...
               }

           You can also use "while" in a post-condition:

               print "LA LA LA\n" while 1;          # loops forever

       for Exactly like C:

               for ($i=0; $i &lt;= $max; $i++) {
                   ...
               }

           The C style for loop is rarely needed in Perl since Perl provides the more friendly list scanning
           "foreach" loop.

       foreach
               foreach (@array) {
                   print "This element is $_\n";
               }

               # you don't have to use the default $_ either...
               foreach my $key (keys %hash) {
                   print "The value of $key is $hash{$key}\n";
               }

       For more detail on looping constructs (and some that weren't mentioned in this overview) see perlsyn.

       <b>Builtin</b> <b>operators</b> <b>and</b> <b>functions</b>

       Perl comes with a wide selection of builtin functions.  Some of the ones we've already seen include
       "print", "sort" and "reverse".  A list of them is given at the start of perlfunc and you can easily
       read about any given function by using "perldoc -f functionname".

       Perl operators are documented in full in perlop, but here are a few of the most common ones:

       Arithmetic
               +   addition
               -   subtraction
               *   multiplication
               /   division

       Numeric comparison
               ==  equality
               !=  inequality
               &lt;   less than
               &gt;   greater than
               &lt;=  less than or equal
               &gt;=  greater than or equal

       String comparison
               eq  equality
               ne  inequality
               lt  less than
               gt  greater than
               le  less than or equal
               ge  greater than or equal

           (Why do we have separate numeric and string comparisons?  Because we don't have special variable
           types, and Perl needs to know whether to sort numerically (where 99 is less than 100) or alpha-<font color="#ffffff" class="whiteout">betically&nbsp;alphabetically</font>
           betically (where 100 comes before 99).

       Boolean logic
               &amp;&amp;  and
               ||  or
               !   not

           ("and", "or" and "not" aren't just in the above table as descriptions of the operators -- they're
           also supported as operators in their own right.  They're more readable than the C-style opera-<font color="#ffffff" class="whiteout">tors,&nbsp;operators,</font>
           tors, but have different precedence to "&amp;&amp;" and friends.  Check perlop for more detail.)

       Miscellaneous
               =   assignment
               .   string concatenation
               x   string multiplication
               ..  range operator (creates a list of numbers)

       Many operators can be combined with a "=" as follows:

           $a += 1;        # same as $a = $a + 1
           $a -= 1;        # same as $a = $a - 1
           $a .= "\n";     # same as $a = $a . "\n";

       <b>Files</b> <b>and</b> <b>I/O</b>

       You can open a file for input or output using the "open()" function.  It's documented in extravagant
       detail in perlfunc and perlopentut, but in short:

           open(INFILE,  "input.txt")   or die "Can't open input.txt: $!";
           open(OUTFILE, "&gt;output.txt") or die "Can't open output.txt: $!";
           open(LOGFILE, "&gt;&gt;my.log")    or die "Can't open logfile: $!";

       You can read from an open filehandle using the "&lt;&gt;" operator.  In scalar context it reads a single
       line from the filehandle, and in list context it reads the whole file in, assigning each line to an
       element of the list:

           my $line  = &lt;INFILE&gt;;
           my @lines = &lt;INFILE&gt;;

       Reading in the whole file at one time is called slurping. It can be useful but it may be a memory
       hog. Most text file processing can be done a line at a time with Perl's looping constructs.

       The "&lt;&gt;" operator is most often seen in a "while" loop:

           while (&lt;INFILE&gt;) {     # assigns each line in turn to $_
               print "Just read in this line: $_";
           }

       We've already seen how to print to standard output using "print()".  However, "print()" can also take
       an optional first argument specifying which filehandle to print to:

           print STDERR "This is your final warning.\n";
           print OUTFILE $record;
           print LOGFILE $logmessage;

       When you're done with your filehandles, you should "close()" them (though to be honest, Perl will
       clean up after you if you forget):

           close INFILE;

       <b>Regular</b> <b>expressions</b>

       Perl's regular expression support is both broad and deep, and is the subject of lengthy documentation
       in perlrequick, perlretut, and elsewhere.  However, in short:

       Simple matching
               if (/foo/)       { ... }  # true if $_ contains "foo"
               if ($a =~ /foo/) { ... }  # true if $a contains "foo"

           The "//" matching operator is documented in perlop.  It operates on $_ by default, or can be
           bound to another variable using the "=~" binding operator (also documented in perlop).

       Simple substitution
               s/foo/bar/;               # replaces foo with bar in $_
               $a =~ s/foo/bar/;         # replaces foo with bar in $a
               $a =~ s/foo/bar/g;        # replaces ALL INSTANCES of foo with bar in $a

           The "s///" substitution operator is documented in perlop.

       More complex regular expressions
           You don't just have to match on fixed strings.  In fact, you can match on just about anything you
           could dream of by using more complex regular expressions.  These are documented at great length
           in perlre, but for the meantime, here's a quick cheat sheet:

               .                   a single character
               \s                  a whitespace character (space, tab, newline)
               \S                  non-whitespace character
               \d                  a digit (0-9)
               \D                  a non-digit
               \w                  a word character (a-z, A-Z, 0-9, _)
               \W                  a non-word character
               [aeiou]             matches a single character in the given set
               [^aeiou]            matches a single character outside the given set
               (foo|bar|baz)       matches any of the alternatives specified

               ^                   start of string
               $                   end of string

           Quantifiers can be used to specify how many of the previous thing you want to match on, where
           "thing" means either a literal character, one of the metacharacters listed above, or a group of
           characters or metacharacters in parentheses.

               *                   zero or more of the previous thing
               +                   one or more of the previous thing
               ?                   zero or one of the previous thing
               {3}                 matches exactly 3 of the previous thing
               {3,6}               matches between 3 and 6 of the previous thing
               {3,}                matches 3 or more of the previous thing

           Some brief examples:

               /^\d+/              string starts with one or more digits
               /^$/                nothing in the string (start and end are adjacent)
               /(\d\s){3}/         a three digits, each followed by a whitespace
                                   character (eg "3 4 5 ")
               /(a.)+/             matches a string in which every odd-numbered letter
                                   is a (eg "abacadaf")

               # This loop reads from STDIN, and prints non-blank lines:
               while (&lt;&gt;) {
                   next if /^$/;
                   print;
               }

       Parentheses for capturing
           As well as grouping, parentheses serve a second purpose.  They can be used to capture the results
           of parts of the regexp match for later use.  The results end up in $1, $2 and so on.

               # a cheap and nasty way to break an email address up into parts

               if ($email =~ /([^@]+)@(.+)/) {
                   print "Username is $1\n";
                   print "Hostname is $2\n";
               }

       Other regexp features
           Perl regexps also support backreferences, lookaheads, and all kinds of other complex details.
           Read all about them in perlrequick, perlretut, and perlre.

       <b>Writing</b> <b>subroutines</b>

       Writing subroutines is easy:

           sub log {
               my $logmessage = shift;
               print LOGFILE $logmessage;
           }

       What's that "shift"?  Well, the arguments to a subroutine are available to us as a special array
       called @_ (see perlvar for more on that).  The default argument to the "shift" function just happens
       to be @_.  So "my $logmessage = shift;" shifts the first item off the list of arguments and assigns
       it to $logmessage.

       We can manipulate @_ in other ways too:

           my ($logmessage, $priority) = @_;       # common
           my $logmessage = $_[0];                 # uncommon, and ugly

       Subroutines can also return values:

           sub square {
               my $num = shift;
               my $result = $num * $num;
               return $result;
           }

       For more information on writing subroutines, see perlsub.

       <b>OO</b> <b>Perl</b>

       OO Perl is relatively simple and is implemented using references which know what sort of object they
       are based on Perl's concept of packages.  However, OO Perl is largely beyond the scope of this docu-<font color="#ffffff" class="whiteout">ment.&nbsp;document.</font>
       ment.  Read perlboot, perltoot, perltooc and perlobj.

       As a beginning Perl programmer, your most common use of OO Perl will be in using third-party modules,
       which are documented below.

       <b>Using</b> <b>Perl</b> <b>modules</b>

       Perl modules provide a range of features to help you avoid reinventing the wheel, and can be down-<font color="#ffffff" class="whiteout">loaded&nbsp;downloaded</font>
       loaded from CPAN ( <a href="http://www.cpan.org/">http://www.cpan.org/</a> ).  A number of popular modules are included with the Perl
       distribution itself.

       Categories of modules range from text manipulation to network protocols to database integration to
       graphics.  A categorized list of modules is also available from CPAN.

       To learn how to install modules you download from CPAN, read perlmodinstall

       To learn how to use a particular module, use "perldoc Module::Name".  Typically you will want to "use
       Module::Name", which will then give you access to exported functions or an OO interface to the mod-
       ule.

       perlfaq contains questions and answers related to many common tasks, and often provides suggestions
       for good CPAN modules to use.

       perlmod describes Perl modules in general.  perlmodlib lists the modules which came with your Perl
       installation.

       If you feel the urge to write Perl modules, perlnewmod will give you good advice.

<b>AUTHOR</b>
       Kirrily "Skud" Robert &lt;skud@cpan.org&gt;



perl v5.8.8                                      2006-01-07                                     PERLINTRO(1)
</tt></pre>
</td></tr></table>
	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Darwin/Reference/ManPages/man1/perlintro.1.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Darwin/Reference/ManPages/man1/perlintro.1.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Darwin/Reference/ManPages/man1/perlintro.1.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

</body></html>
