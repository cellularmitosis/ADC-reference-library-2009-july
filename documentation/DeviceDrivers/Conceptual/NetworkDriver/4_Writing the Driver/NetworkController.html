<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>Network Device Driver Programming Guide: Writing a Driver for an Ethernet Controller</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Writing a Driver for an Ethernet Controller"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP40000913-CH204" title="Writing a Driver for an Ethernet Controller"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../../HardwareDrivers/index.html#//apple_ref/doc/uid/TP30000440-TP40003576" target="_top">Hardware &amp; Drivers</a> &gt; <a href="../../../../HardwareDrivers/Networking-date.html#//apple_ref/doc/uid/TP30000440-TP40003576-TP30000453" target="_top">Networking</a> &gt; <a href="../1_Intro/Intro.html#//apple_ref/doc/uid/TP40000913-CH201-DontLinkElementID_3">Network Device Driver Programming Guide</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../3_Tipsfolder/TipsonBringup.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../RevisionHistory/revhist.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP40000913-CH204-DontLinkElementID_13" title="Writing a Driver for an Ethernet Controller"></a><h1><a name="//apple_ref/doc/uid/TP40000913-CH204-TP9" title="Writing a Driver for an Ethernet Controller"></a>Writing a Driver for an Ethernet Controller</h1><p>This chapter describes what a network driver does to set up its interface object, to handle I/O, and to perform its other tasks. Follow the CDC Ethernet driver provided at <span class="content_text"><a href="http://www.opensource.apple.com/darwinsource/tarballs/apsl/AppleUSBCDCDriver-314.4.1.tar.gz" target="_blank">http://www.opensource.apple.com/darwinsource/tarballs/apsl/AppleUSBCDCDriver-314.4.1.tar.gz</a></span> for specific examples of how to implement the functionality required of a network driver. In particular this document will refer to the functions in <code>AppleUSBCDCEMData.cpp</code>.</p>
<!-- This template is being used for both PDF and HTML. -->

    
    <h4>In this section:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="NetworkController.html#//apple_ref/doc/uid/TP40000913-CH204-DontLinkElementID_2">Driver Overview</a>
				
			<br/>
			
        
			
			
				<a href="NetworkController.html#//apple_ref/doc/uid/TP40000913-CH204-TPXREF115">Startup and Shutdown</a>
				
			<br/>
			
        
			
			
				<a href="NetworkController.html#//apple_ref/doc/uid/TP40000913-CH204-TPXREF119">Defining Capabilities, Restrictions, and Modes</a>
				
			<br/>
			
        
			
			
				<a href="NetworkController.html#//apple_ref/doc/uid/TP40000913-CH204-TPXREF103">Enabling and Disabling the Driver</a>
				
			<br/>
			
        
			
			
				<a href="NetworkController.html#//apple_ref/doc/uid/TP40000913-CH204-TPXREF104">Performing I/O</a>
				
			<br/>
			
        
			
			
				<a href="NetworkController.html#//apple_ref/doc/uid/TP40000913-CH204-TPXREF124">Advertising and Changing Filter Modes</a>
				
			<br/>
			
        
			
			
				<a href="NetworkController.html#//apple_ref/doc/uid/TP40000913-CH204-TPXREF125">Advertising and Changing Media</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP40000913-CH204-DontLinkElementID_2" title="Driver Overview"></a><h2>Driver Overview</h2><p>Before diving into the specifics of what you need to be do to write a network driver, it may be helpful to see the basic functions which you need to override. These descriptions are meant to give you an idea of what is entailed in creating a very simple network driver.</p><dl class="termdef">	<dt><code><!--a-->start<!--/a--></code></dt><dd><p>The <code><!--a-->start<!--/a--></code> function should initialize the device to a working state. It also needs to create a network object and make it visible to the networking stack as an interface.</p></dd><dt><code><!--a-->stop<!--/a--></code></dt><dd><p>The <code><!--a-->stop<!--/a--></code> function must free anything allocated in <code><!--a-->start<!--/a--></code> and also release the network object created in <code><!--a-->start<!--/a--></code>.</p></dd><dt><code><!--a-->enable<!--/a--></code></dt><dd><p>As mentioned in <span class="content_text"><a href="../3_Tipsfolder/TipsonBringup.html#//apple_ref/doc/uid/TP40000913-CH203-TP9">“Tips on Bringing Up a UNIX Network Driver,”</a></span> the <code><!--a-->enable<!--/a--></code> function is run when the system sets the driver’s status to <code>up</code>. This function is also responsible for starting the hardware’s transmit and receive capabilities. It should inform the system about the link status of the hardware.</p></dd><dt><code><!--a-->disable<!--/a--></code></dt><dd><p>The <code><!--a-->disable<!--/a--></code> function releases anything allocated, and stops any functions started in <code><!--a-->enable<!--/a--></code>.</p></dd><dt><code><!--a-->getHardwareAddress<!--/a--></code></dt><dd><p>The <code><!--a-->getHardwareAddress<!--/a--></code> function returns the MAC address of the network device.</p></dd><dt><code><!--a-->outputPacket<!--/a--></code></dt><dd><p>The <code><!--a-->outputPacket<!--/a--></code> function sends the packet to the hardware for transmission. It will be called from multiple threads, so it needs to be thread-safe.</p></dd></dl><p>Each of these functions are described in more depth further in this chapter. </p><a name="//apple_ref/doc/uid/TP40000913-CH204-TPXREF115" title="Startup and Shutdown"></a><h2>Startup and Shutdown</h2><p>A network driver’s <code><!--a-->start<!--/a--></code> function is responsible for setting up the resources the driver needs all the time, whether the driver is enabled or disabled. These include the network interface object, a work loop, and an output queue, along with whatever specific resources the driver needs. In addition, the driver should retain its provider nub (that is, the nub for the bus it is attached to, such as an IOUSBDevice nub). The <code><!--a-->stop<!--/a--></code> function reverses all this, releasing the nub and disposing of any resources created in <code><!--a-->start<!--/a--></code>. See the example driver for samples of these two functions.</p><p>The <code><!--a-->start<!--/a--></code> function is typically not the place for a driver to allocate its transmit and receive buffers and other such runtime resources that are needed only while the driver is enabled and handling network traffic. Creation and disposal of these resources is managed by the <code><!--a-->enable<!--/a--></code> and <code><!--a-->disable<!--/a--></code> functions, described in <span class="content_text"><a href="NetworkController.html#//apple_ref/doc/uid/TP40000913-CH204-TPXREF103">“Enabling and Disabling the Driver.”</a></span></p><a name="//apple_ref/doc/uid/TP40000913-CH204-TPXREF116" title="Opening the Provider Nub"></a><h3>Opening the Provider Nub</h3><p>You invoke the <code><!--a-->start<!--/a--></code> function with a single argument, the nub of the hardware device that your ethernet controller is connected to. The driver should do three things with the nub: verify that it is of the appropriate class, retain a reference to it, and open it in order to access its services.</p><p>Your driver has two options before returning from the <code>start</code> function. If you close the nub at the end of the <code>start</code> function, then you must reopen it in the <code>enable</code> function. However, you also have the option to leave the nub open, so that it will be ready to use in the <code>enable</code> function. It is recommended that the former technique be used, but because a network driver is rarely “downed,” either technique is acceptable. The sample code uses the latter method.</p><a name="//apple_ref/doc/uid/TP40000913-CH204-BAAHFIBI" title="Setting up Output Queuing"></a><h3>Setting up Output Queuing</h3><p>IONetworkController, the superclass of all network drivers, defines the <code><!--a-->outputPacket<!--/a--></code> function for packet transmission. This function is typically called indirectly by the network interface through the network family’s standard queuing mechanism, defined by IOOutputQueue and its subclasses. A driver can choose to have it invoked directly by the network interface, however, and implement its own internal queuing mechanism.</p><p>A driver’s output queue is created by the <code><!--a-->createOutputQueue<!--/a--></code> function. The network driver superclass, IONetworkController, invokes this function automatically on startup. The driver should override this function to create an instance of an IOOutputQueue subclass suitable for the driver, or not override it at all if the driver performs its own queuing—in which case the network interface will pass outgoing packets directly to the driver.</p><p>The simplest IOOuputQueue subclass to use is IOGatedOutputQueue. This class queues packets using a lock and dequeues them one at a time using a command gate on the driver’s work loop. It invokes <code><!--a-->outputPacket<!--/a--></code> once for each packet, breaking up <code>mbuf_t</code> packet chains so that the driver doesn’t have to handle them. Using the work loop means that transmit and receive operations are mutually exclusive. If your network hardware has completely distinct transmit and receive engines, using an IOGatedOutputQueue object may not be the most efficient option. Even so, it makes bringing up a driver quite simple, as you do not have to worry about locking while you establish control of the hardware itself.</p><p>If your network hardware supports multithreaded access, as it does when the transmit and receive engines are distinct, you may want to use an IOBasicOutputQueue instead. This class is the actually the superclass of IOGatedOutputQueue, and it defines the locking mechanism that IOGatedOutputQueue uses. For dequeuing, however, it negotiates multiple queuing threads so that only a single thread at a time dequeues packets and invokes the driver’s <code><!--a-->outputPacket<!--/a--></code> function. This queue subclass also breaks up <code>mbuf_t</code> packet chains for the driver. Because dequeuing isn’t synchronized with the work loop, however, both transmission and reception can occur at the same time.</p><p>If a driver performs queuing internally, it doesn’t override <code><!--a-->createOutputQueue<!--/a--></code>, and it implements its own queuing mechanism. If you are porting a driver that already performs its own output locking, for example, you will probably choose this option. In this case, when the network interface needs to transmit packets, it invokes the driver’s <code><!--a-->outputPacket<!--/a--></code> function directly. The driver is then responsible for all locking of its internal queue and related data, for handling stall conditions, and further for handling <code>mbuf_t</code> packet chains. The output queue classes guarantee that a single packet at a time is passed to <code><!--a-->outputPacket<!--/a--></code>; this is not the case when the driver forgoes using an output queue object.</p><p>Another option a driver has is to create its own subclass of IOOutputQueue. See the class reference documentation and the source code for more information.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40000913-CH204-DontLinkElementID_14" title="Note"></a><p><strong>Note:</strong>&nbsp;While this document refers to the new <code>mbuf_t</code> structure, introduced in Mac OS v10.4, the sample code still uses an <code>mbuf</code> structure. The <code>mbuf</code> structure is supported in order to preserve binary compatibility of drivers on pre-Mac OS v10.4 systems. However, if you are writing a driver for a Mac OS v10.4 system, it is highly recommended that your driver use the <code>mbuf_t</code> structure.</p></div><a name="//apple_ref/doc/uid/TP40000913-CH204-TPXREF118" title="Setting up a Network Interface"></a><h3>Setting up a Network Interface</h3><p>As with any driver, a network driver is responsible for creating its nub. A network nub is an instance of a subclass of IONetworkInterface. Each type of network controller has a corresponding subclass of IONetworkInterface; an IOEthernetController, for example, uses an IOEthernetInterface. Creating the network interface is implemented by the driver’s superclass; all the driver need do is call the <code><!--a-->attachInterface<!--/a--></code> function and implement a few auxiliary functions. If the driver includes a custom subclass of the network interface class, it can override <code><!--a-->createInterface<!--/a--></code> to create an instance of the custom subclass rather than the default class.</p><p>The <code><!--a-->attachInterface<!--/a--></code> function takes two parameters: a pointer to the network interface object, which is filled by the function, and an optional “register with the network stacks” flag. This flag is <code>true</code> by default, meaning that the interface object will be registered with the DLIL, that the driver’s <code><!--a-->enable<!--/a--></code> function may be invoked during startup and that the driver may receive requests to transmit packets  before <code><!--a-->attachInterface<!--/a--></code> returns (and before <code><!--a-->start<!--/a--></code> completes). If your driver needs to perform additional initialization, you can pass <code><!--a  -->false<!--/a--></code> to delay registering with the network stacks. If you do this, your driver must invoke the interface’s <code><!--a-->registerService<!--/a--></code> function when it becomes ready to handle network traffic.</p><p>Because a network interface can’t be reconfigured after it registers itself with the BSD network stack, it invokes a callback on the driver from the <code><!--a-->attachInterface<!--/a--></code> function. The callback is <code><!--a-->configureInterface<!--/a--></code>, and the driver can implement it to set up maximum transfer sizes, filter tap modes, and other such settings as described in the IONetworkInterface reference documentation. Network drivers typically use this function to get their references to the statistics structures maintained by the network interface before any network traffic comes by. (See <span class="content_text"><a href="NetworkController.html#//apple_ref/doc/uid/TP40000913-CH204-TPXREF106">“Gathering Network Statistics”</a></span> below for information on how to do this.)</p><p>For ethernet drivers, another function related to setting up the interface is <code><!--a-->getHardwareAddress<!--/a--></code>, which the interface object invokes in order to register the ethernet address with the BSD network stack. Before invoking <code><!--a-->attachInterface<!--/a--></code>, the driver should determine in the <code><!--a-->start<!--/a--></code> function what the hardware address is, and implement <code><!--a-->getHardwareAddress<!--/a--></code> to provide this address on request. Other networking protocols may require a similar function.</p><a name="//apple_ref/doc/uid/TP40000913-CH204-TPXREF119" title="Defining Capabilities, Restrictions, and Modes"></a><h2>Defining Capabilities, Restrictions, and Modes</h2><p>This section presents some useful functions that will be explained more fully in later versions of this book.</p><p>A network driver overrides a number of IONetworkController functions in order to advertise its capabilities and restrictions. Some of these functions, and their uses, are:</p><ul class="ul"><li class="li"><p><code><!--a-->setMaxTransferUnit<!--/a--></code>, which allows clients to set the largest single packet size to transfer.</p></li><li class="li"><p><code><!--a-->getPacketBufferConstraints<!--/a--></code>, which informs the driver’s superclass of alignment constraints for packet buffers.</p></li><li class="li"><p><code><!--a-->getVendorString<!--/a--></code>, which provides the vendor name for the hardware controller that the driver is operating.</p></li><li class="li"><p><code><!--a-->getModelString<!--/a--></code>, which provides the model name for the hardware controller that the driver is operating.</p></li></ul><a name="//apple_ref/doc/uid/TP40000913-CH204-TPXREF103" title="Enabling and Disabling the Driver"></a><h2>Enabling and Disabling the Driver</h2><p>When a network interface is brought up—for example, using the <code>ifconfig</code> command—the driver’s <code><!--a-->enable<!--/a--></code> function is invoked. This function is responsible for preparing the driver to transmit and receive packets. Here are a few of the operations typically performed in <code><!--a-->enable<!--/a--></code>:</p><ul class="ul"><li class="li"><p>Opening the driver’s provider nub (if the nub was closed in the <code><!--a-->start<!--/a--></code> function).</p></li><li class="li"><p>Creating any resources needed by the driver for operation, such as hardware-specific transmit and receive buffers, memory cursors for managing scatter/gather lists, and event sources for the work loop.</p></li><li class="li"><p>Resetting the hardware so that it’s ready to transmit and receive packets.</p></li><li class="li"><p>Starting I/O by enabling hardware interrupts as well as interrupt event sources and setting timer event sources, restarting the output queue (if the driver uses one), and then starting the transmit and receive engines on the hardware.</p></li></ul><p>The <code><!--a-->disable<!--/a--></code> function must reverse this process, disabling what was enabled, shutting down what was started, disposing of resources that were created, and, if necessary, closing the provider nub. The driver should also reset the hardware when disabling, to leave it in a known state.</p><p>You invoke the <code><!--a-->enable<!--/a--></code> and <code><!--a-->disable<!--/a--></code> functions within a synchronized context through the driver’s superclass, using an IOCommandGate on the driver’s work loop. These functions are intended to be overridden, and not directly invoked.</p><a name="//apple_ref/doc/uid/TP40000913-CH204-TPXREF120" title="Opening and Closing the Provider Nub"></a><h3>Opening and Closing the Provider Nub</h3><p>Both <code><!--a-->enable<!--/a--></code> and <code><!--a-->disable<!--/a--></code> are invoked with the provider nub the driver was originally started with. The <code><!--a-->enable<!--/a--></code> function is responsible for invoking <code><!--a-->open<!--/a--></code> on the nub, returning a failure result if it can’t open the nub. Similarly, <code><!--a-->disable<!--/a--></code> must invoke <code><!--a-->close<!--/a--></code> on the nub. Because network driver code can be running in multiple threads, however, the driver should implement a mutex. The lock should ensure that the <code><!--a-->enable<!--/a--></code> function is allowed to run only once at a time, and that the <code><!--a-->disable<!--/a--></code> function can run only after the <code><!--a-->enable<!--/a--></code> function. The sample driver uses a Boolean variable, <code>fNetifEnabled</code>, as the lock.</p><a name="//apple_ref/doc/uid/TP40000913-CH204-TPXREF121" title="Creating and Destroying Resources"></a><h3>Creating and Destroying Resources</h3><p>In order to preserve kernel resources, a driver should never consume more system memory than necessary. This means that the driver should delay creating resources until they’re actually needed, as when the driver becomes active, and should dispose of those resources when it becomes inactive. Such resources typically include any hardware-specific transmit and receive buffers, the BSD <code>mbuf_t</code> structures used to pass packets up and down, memory cursor objects used to manage scatter/gather lists based on the <code>mbuf_t</code> structures, and any event sources needed for operation.</p><p>Hardware-specific resources are necessarily outside the scope of this document. Whatever the hardware-specific resources are, however, they will typically include a receive buffer that contains <code>mbuf_t</code> structures. Your driver can use its network interface object to allocate and free these structures through the <code><!--a-->allocatePacket<!--/a--></code> and <code><!--a-->freePacket<!--/a--></code> functions defined by IONetworkController.</p><p>Memory cursors, represented by the IOMBufMemoryCursor group of classes, manage the translation between <code>mbuf_t</code> structures and scatter/gather lists used by the hardware. Specific classes are available to handle data in big-endian, little-endian, or CPU-native byte order, and to handle data used with DBDMA engines. Your driver will typically create one or more memory cursors, depending on whether it’s single- or multithreaded and whether the transmit and receive buffers used by hardware are similar or different.</p><a name="//apple_ref/doc/uid/TP40000913-CH204-TPXREF122" title="Starting and Stopping I/O"></a><h3>Starting and Stopping I/O</h3><p>To start I/O, the <code><!--a-->enable<!--/a--></code> function should enable the interrupt and timer event sources and then enable any hardware-specific interrupts. Following this, it should start up the output queue (if it has one) using IOOutputQueue’s <code><!--a-->setCapacity<!--/a--></code> and <code><!--a-->start<!--/a--></code> functions. Finally, it should start any I/O engines on the hardware.</p><p>The <code><!--a-->disable<!--/a--></code> function stops I/O by roughly reversing this process. It should disable hardware-specific interrupts, disable the interrupt event source and cancel any pending timeout. It should then stop the I/O engines and reset the hardware if necessary. Then, it must stop and flush the output queue by invoking its <code><!--a-->stop<!--/a--></code> function, setting its capacity to zero with <code><!--a-->setCapacity<!--/a--></code>, and invoking <code><!--a-->flush<!--/a--></code>. </p><a name="//apple_ref/doc/uid/TP40000913-CH204-TPXREF104" title="Performing I/O"></a><h2>Performing I/O</h2><p>Everything that has been covered up to now is essentially support for the real purpose of a network driver: to send and receive packets through the network controller. The network family specifies the means for a driver to get an output request from the network interface object, and to hand received packets up to it, as well as defining data structures for gathering statistics. Additional functions defined by the network interface and controller superclasses provide support for managing packet buffers, and the <code>mbuf_t</code> memory cursor classes aid in the use of scatter/gather lists based on those buffers.</p><a name="//apple_ref/doc/uid/TP40000913-CH204-TPXREF123" title="Transmitting Packets"></a><h3>Transmitting Packets</h3><p>A network driver’s entry point for transmission is the <code><!--a-->outputPacket<!--/a--></code> function. This function is invoked either by an IOOutputQueue or by the network interface directly. Depending on the type of queue used (see <span class="content_text"><a href="NetworkController.html#//apple_ref/doc/uid/TP40000913-CH204-BAAHFIBI">“Setting up Output Queuing”</a></span> above), this function may or may not be invoked within the protected context of the driver’s work loop.</p><p>The sole argument to <code><!--a-->outputPacket<!--/a--></code> is an <code>mbuf_t</code> for the packet or packets to be transmitted. A driver that uses an output queue object is guaranteed to be passed a single-packet <code>mbuf_t</code>. A driver that does its own queuing must be able to process a chain of packets in a single <code>mbuf_t</code> pointer. The <code>mbuf_t</code> passed in becomes the property of the driver.</p><p>To actually output the packet or packets, the driver must check its hardware-specific resources and prepare a buffer. Depending on the state of the resources, the driver may need to return a packet status of stalled (<code><!--a  -->kIOReturnStall<!--/a--></code>), as when the hardware transmit buffers are all full, or dropped (<code><!--a  -->kIOReturnDropped<!--/a--></code>), as when an error occurs in processing the packet. If the driver returns <code><!--a  -->kIOReturnDropped<!--/a--></code>, it should also put the <code>mbuf_t</code> back into the network stack’s common pool by invoking the superclass’s <code><!--a-->freePacket<!--/a--></code> function.</p><p>In order to generate a scatter/gather list for the packet, the driver uses an IOMBufMemoryCursor, invoking its <code><!--a-->getPhysicalSegmentsWithCoalesce<!--/a--></code> function to create a list of physical location/length pairs for the memory segments of the <code>mbuf_t</code>. Once it has this information the driver can insert it into the hardware buffers and issue the go-ahead to the hardware controller.</p><p>After the packet has been transmitted by the hardware, the driver should reclaim its transmit buffer and put the <code>mbuf_t</code> back into the network stack’s common pool by invoking the superclass’s <code><!--a-->freePacket<!--/a--></code> function.</p><a name="//apple_ref/doc/uid/TP40000913-CH204-TPXREF105" title="Receiving Packets"></a><h3>Receiving Packets</h3><p>Receiving packets is typically done through an interrupt handler, or possibly a timer for a device that requires polling. In either case, reception is always handled within the protected context of the driver’s work loop</p><p>To process incoming packets, the driver must extract the <code>mbuf_t</code> structure for each from its hardware receive buffers and pass it up to the network interface object by invoking that object’s <code><!--a-->inputPacket<!--/a--></code> function. For efficient replacement of an <code>mbuf_t</code> structure containing a received packet, IONetworkController defines the functions <code><!--a-->copyPacket<!--/a--></code>, <code><!--a-->replacePacket<!--/a--></code>, and <code><!--a-->replaceOrCopyPacket<!--/a--></code>, which performs the most efficient operation based on the size of the received packet. While it is recommended that you use these functions, the example driver does not take advantage of them. </p><p>The <code><!--a-->inputPacket<!--/a--></code> function has an optional argument to allow for queueing of multiple packets. If the driver uses input queueing, it must invoke the network interface’s <code><!--a-->flushInputQueue<!--/a--></code> function to ensure that the packets find their way up the network stack.</p><a name="//apple_ref/doc/uid/TP40000913-CH204-TPXREF106" title="Gathering Network Statistics"></a><h3>Gathering Network Statistics</h3><p>The network family defines several structures for recording network statistics. If you want your driver to do this, it must get the addresses of these structures from the network interface object and then update the relevant fields during operation.</p><p>The structures are available from the network interface object through its <code><!--a-->getNetworkData<!--/a--></code> function. This function takes the name of the relevant network data structure, for which constants are defined by the network interface classes. The constant <code><!--a  -->kIONetworkStatsKey<!--/a--></code>, for example, indicates the generic network statistics structure, which contains fields for number of input and output packets, among others.</p><p>The <code><!--a-->getNetworkData<!--/a--></code> function returns an IONetworkData object, from which you can retrieve the data buffer address using its <code><!--a-->getBuffer<!--/a--></code> function. Casting the returned pointer to the appropriate type gives your driver direct access to the network data structure.</p><a name="//apple_ref/doc/uid/TP40000913-CH204-TPXREF124" title="Advertising and Changing Filter Modes"></a><h2>Advertising and Changing Filter Modes</h2><p>To indicate what kinds of packet filtering (addressing) a driver supports, it overrides <code><!--a-->getPacketFilters<!--/a--></code>. This function is invoked with a pointer to a bitfield indicating which addressing modes are supported, such as unicast, broadcast, and multicast. The driver’s implementation of this function should set the bits for the modes it supports and return a success code.</p><p>In order to support promiscuous and multicast modes, a network driver overrides the <code><!--a-->setPromiscuousMode<!--/a--></code>, <code><!--a-->setMulticastMode<!--/a--></code>, and <code><!--a-->setMulticastList<!--/a--></code> functions defined by IONetworkController. The set-mode functions can be implemented to just set a flag in the driver; actually supporting the modes requires hardware-specific code in the I/O handling functions, of course. <code><!--a-->setMulticastList<!--/a--></code> is invoked with a list of hardware addresses, which the driver should pass down to the hardware.</p><a name="//apple_ref/doc/uid/TP40000913-CH204-TPXREF125" title="Advertising and Changing Media"></a><h2>Advertising and Changing Media</h2><p>When a network controller driver starts up, it typically examines its hardware for the media supported and currently active, for example10Base-T and 100Base-T for ethernet. A driver can advertise these media by creating an instance of IONetworkMedium for each one, collecting them in an OSDictionary that it makes available to the network family by invoking the <code><!--a-->setMediumDictionary<!--/a--></code> function defined by IONetworkController.</p><p>The driver should also invoke <code><!--a-->setCurrentMedium<!--/a--></code> to establish the current selected medium. Similarly, when the driver notes that the network link has come up or gone down, it should invoke the <code><!--a-->setLinkStatus<!--/a--></code> function to report the status to the network interface object.</p>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../3_Tipsfolder/TipsonBringup.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../RevisionHistory/revhist.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2000, 2008 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2008-03-11<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/DeviceDrivers/Conceptual/NetworkDriver/4_Writing the Driver/NetworkController.html%3Fid%3DTP40000913-3.1&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/DeviceDrivers/Conceptual/NetworkDriver/4_Writing the Driver/NetworkController.html%3Fid%3DTP40000913-3.1&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/DeviceDrivers/Conceptual/NetworkDriver/4_Writing the Driver/NetworkController.html%3Fid%3DTP40000913-3.1&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>