<html><head><title>Mac OS X
 Manual Page For binary(ntcl)</title>
<style type="text/css"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { font-size: 1px; background: #ffffff; color: #ffffff; } --></style>
<style type="text/css" media="print, aural, braille, embossed, projection, tty"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { display: none; } --></style>
</head><body bgcolor="white">
<a name="//apple_ref/doc/man/ntcl/binary" title="Mac OS X
 Manual Page for binary(ntcl)"><a name="//apple_ref/doc/man/n/binary" title="Mac OS X
 Manual Page for binary(ntcl)"><!-- headerDoc=man; indexgroup=Section ntcl; uid="//apple_ref/doc/man/ntcl/binary"; name=binary(ntcl) --></a>
<!--#include virtual="/includes/framesetheader"-->
<table width=600><tr><td scope="row">
<!-- begin breadcrumb insert request --><font face="Geneva,Helvetica,Arial" size="1">
 <a target="_top" href="http://developer.apple.com">ADC Home</a> <b>&gt;</b> <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> <b>&gt;</b> <a href="../../../../../reference/index.html#//apple_ref/doc/uid/TP30001281" target="_top">Reference</a> <b>&gt;</b> <!-- a href="" target="_top" -->Mac OS X<!-- /a --> <b>&gt;</b> <a href="../index.html#//apple_ref/doc/framework/manpages" target="_top">Mac OS X Man Pages</a></font>
<!-- end breadcrumb insert request -->
<p>&nbsp;</p>
</td></tr></table>
<!-- end of header -->
<table border="0"  cellpadding="2" cellspacing="2" width="630pt"><tr><td valign="top" height="12" colspan="5" scope="row">
<p style='text-align:justify;'>This document is a Mac OS X manual page.  Manual pages are a command-line technology
for providing documentation.  You can view these manual pages locally using the
<a href="../man1/man.1.html#//apple_ref/doc/man/1/man">man(1)</a> command.
These manual pages come from many different sources, and thus, have a variety of writing
styles.</p>
<p style='text-align:justify;'>For more information about the manual page format, see the manual page for 
<a href="../man5/manpages.5.html#//apple_ref/doc/man/5/manpages">manpages(5)</a>.</p>
</td></tr></table>
<hr />
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row"><pre class="manpages"><tt>
binary(n)                                   Tcl Built-In Commands                                  binary(n)



____________________________________________________________________________________________________________

<b>NAME</b>
       binary - Insert and extract fields from binary strings

<b>SYNOPSIS</b>
       <b>binary</b> <b>format</b> <u>formatString</u> ?<u>arg</u> <u>arg</u> <u>...</u>?
       <b>binary</b> <b>scan</b> <u>string</u> <u>formatString</u> ?<u>varName</u> <u>varName</u> <u>...</u>?
____________________________________________________________________________________________________________


<b>DESCRIPTION</b>
       This  command  provides facilities for manipulating binary data.  The first form, <b>binary</b> <b>format</b>, cre-<font color="#ffffff" class="whiteout">ates&nbsp;creates</font>
       ates a binary string from normal Tcl values.  For example, given the values 16 and 22, on  a  32  bit
       architecture,  it  might  produce  an 8-byte binary string consisting of two 4-byte integers, one for
       each of the numbers.  The second form of the command, <b>binary</b> <b>scan</b>, does  the  opposite:  it  extracts
       data from a binary string and returns it as ordinary Tcl string values.


<b>BINARY</b> <b>FORMAT</b>
       The <b>binary</b> <b>format</b> command generates a binary string whose layout is specified by the <u>formatString</u> and
       whose contents come from the additional arguments.  The resulting binary value is returned.

       The <u>formatString</u> consists of a sequence of zero or more field specifiers separated by  zero  or  more
       spaces.  Each field specifier is a single type character followed by an optional numeric <u>count</u>.  Most
       field specifiers consume one argument to obtain the value to be formatted.  The type character speci-<font color="#ffffff" class="whiteout">fies&nbsp;specifies</font>
       fies how the value is to be formatted.  The <u>count</u> typically indicates how many items of the specified
       type are taken from the value.  If present, the <u>count</u> is a non-negative decimal integer or  <b>*</b>,  which
       normally  indicates  that  all  of the items in the value are to be used.  If the number of arguments
       does not match the number of fields in the format string that consume arguments,  then  an  error  is
       generated.

       Here is a small example to clarify the relation between the field specifiers and the arguments:
              <b>binary</b> <b>format</b> <b>d3d</b> <b>{1.0</b> <b>2.0</b> <b>3.0</b> <b>4.0}</b> <b>0.1</b>

       The  first argument is a list of four numbers, but because of the count of 3 for the associated field
       specifier, only the first three will be used. The second argument is associated with the second field
       specifier. The resulting binary string contains the four numbers 1.0, 2.0, 3.0 and 0.1.

       Each  type-count pair moves an imaginary cursor through the binary data, storing bytes at the current
       position and advancing the cursor to just after the last byte stored.  The  cursor  is  initially  at
       position 0 at the beginning of the data.  The type may be any one of the following characters:

       <b>a</b>    Stores  a  character  string  of length <u>count</u> in the output string.  Every character is taken as
            modulo 256 (i.e. the low byte of every character is used, and the high byte discarded)  so  when
            storing  character strings not wholly expressible using the characters \u0000-\u00ff, the <b>encod</b>-<font color="#ffffff" class="whiteout">ing&nbsp;encoding</font>
            <b>ing</b> <b>convertto</b> command should be used first if this truncation is not desired (i.e. if the  char-<font color="#ffffff" class="whiteout">acters&nbsp;characters</font>
            acters  are  not part of the ISO 8859-1 character set.)  If <u>arg</u> has fewer than <u>count</u> bytes, then
            additional zero bytes are used to pad out the field.   If  <u>arg</u>  is  longer  than  the  specified
            length,  the extra characters will be ignored.  If <u>count</u> is <b>*</b>, then all of the bytes in <u>arg</u> will
            be formatted.  If <u>count</u> is omitted, then one character will be formatted.  For example,
                   <b>binary</b> <b>format</b> <b>a7a*a</b> <b>alpha</b> <b>bravo</b> <b>charlie</b>
            will return a string equivalent to <b>alpha\000\000bravoc</b>.

       <b>A</b>    This form is the same as <b>a</b> except that spaces are used for padding instead of nulls.  For  exam-<font color="#ffffff" class="whiteout">ple,&nbsp;example,</font>
            ple,
                   <b>binary</b> <b>format</b> <b>A6A*A</b> <b>alpha</b> <b>bravo</b> <b>charlie</b>
            will return <b>alpha</b> <b>bravoc</b>.

       <b>b</b>    Stores  a  string  of  <u>count</u>  binary  digits in low-to-high order within each byte in the output
            string.  <u>Arg</u> must contain a sequence of <b>1</b> and <b>0</b> characters.  The resulting bytes are emitted  in
            first to last order with the bits being formatted in low-to-high order within each byte.  If <u>arg</u>
            has fewer than <u>count</u> digits, then zeros will be used for the remaining bits.  If  <u>arg</u>  has  more
            than  the specified number of digits, the extra digits will be ignored.  If <u>count</u> is <b>*</b>, then all
            of the digits in <u>arg</u> will be formatted.  If <u>count</u> is omitted, then one digit will be  formatted.
            If  the number of bits formatted does not end at a byte boundary, the remaining bits of the last
            byte will be zeros.  For example,
                   <b>binary</b> <b>format</b> <b>b5b*</b> <b>11100</b> <b>111000011010</b>
            will return a string equivalent to <b>\x07\x87\x05</b>.

       <b>B</b>    This form is the same as <b>b</b> except that the bits are stored  in  high-to-low  order  within  each
            byte.  For example,
                   <b>binary</b> <b>format</b> <b>B5B*</b> <b>11100</b> <b>111000011010</b>
            will return a string equivalent to <b>\xe0\xe1\xa0</b>.

       <b>h</b>    Stores  a  string  of  <u>count</u>  hexadecimal  digits  in low-to-high within each byte in the output
            string.  <u>Arg</u> must contain a sequence of characters in the set  ``0123456789abcdefABCDEF''.   The
            resulting  bytes  are emitted in first to last order with the hex digits being formatted in low-<font color="#ffffff" class="whiteout">to-high&nbsp;lowto-high</font>
            to-high order within each byte.  If <u>arg</u> has fewer than <u>count</u> digits, then zeros will be used for
            the  remaining  digits.   If  <u>arg</u> has more than the specified number of digits, the extra digits
            will be ignored.  If <u>count</u> is <b>*</b>, then all of the digits in <u>arg</u> will be formatted.  If  <u>count</u>  is
            omitted,  then one digit will be formatted.  If the number of digits formatted does not end at a
            byte boundary, the remaining bits of the last byte will be zeros.  For example,
                   <b>binary</b> <b>format</b> <b>h3h*</b> <b>AB</b> <b>def</b>
            will return a string equivalent to <b>\xba\x00\xed\x0f</b>.

       <b>H</b>    This form is the same as <b>h</b> except that the digits are stored in high-to-low  order  within  each
            byte.  For example,
                   <b>binary</b> <b>format</b> <b>H3H*</b> <b>ab</b> <b>DEF</b>
            will return a string equivalent to <b>\xab\x00\xde\xf0</b>.

       <b>c</b>    Stores  one  or  more 8-bit integer values in the output string.  If no <u>count</u> is specified, then
            <u>arg</u> must consist of an integer value; otherwise <u>arg</u> must consist of a list containing  at  least
            <u>count</u>  integer elements.  The low-order 8 bits of each integer are stored as a one-byte value at
            the cursor position.  If <u>count</u> is <b>*</b>, then all of the integers in the list are formatted.  If the
            number  of  elements in the list is fewer than <u>count</u>, then an error is generated.  If the number
            of elements in the list is greater than <u>count</u>, then the extra elements are ignored.   For  exam-<font color="#ffffff" class="whiteout">ple,&nbsp;example,</font>
            ple,
                   <b>binary</b> <b>format</b> <b>c3cc*</b> <b>{3</b> <b>-3</b> <b>128</b> <b>1}</b> <b>260</b> <b>{2</b> <b>5}</b>
            will return a string equivalent to <b>\x03\xfd\x80\x04\x02\x05</b>, whereas
                   <b>binary</b> <b>format</b> <b>c</b> <b>{2</b> <b>5}</b>
            will generate an error.

       <b>s</b>    This  form  is  the same as <b>c</b> except that it stores one or more 16-bit integers in little-endian
            byte order in the output string.  The low-order 16-bits of each integer are stored as a two-byte
            value at the cursor position with the least significant byte stored first.  For example,
                   <b>binary</b> <b>format</b> <b>s3</b> <b>{3</b> <b>-3</b> <b>258</b> <b>1}</b>
            will return a string equivalent to <b>\x03\x00\xfd\xff\x02\x01</b>.

       <b>S</b>    This  form is the same as <b>s</b> except that it stores one or more 16-bit integers in big-endian byte
            order in the output string.  For example,
                   <b>binary</b> <b>format</b> <b>S3</b> <b>{3</b> <b>-3</b> <b>258</b> <b>1}</b>
            will return a string equivalent to <b>\x00\x03\xff\xfd\x01\x02</b>.

       <b>i</b>    This form is the same as <b>c</b> except that it stores one or more 32-bit  integers  in  little-endian
            byte  order  in  the output string.  The low-order 32-bits of each integer are stored as a four-<font color="#ffffff" class="whiteout">byte&nbsp;fourbyte</font>
            byte value at the cursor position with the least significant byte stored first.  For example,
                   <b>binary</b> <b>format</b> <b>i3</b> <b>{3</b> <b>-3</b> <b>65536</b> <b>1}</b>
            will return a string equivalent to <b>\x03\x00\x00\x00\xfd\xff\xff\xff\x00\x00\x01\x00</b>

       <b>I</b>    This form is the same as <b>i</b> except that it stores one or more one or more 32-bit integers in big-<font color="#ffffff" class="whiteout">endian&nbsp;bigendian</font>
            endian byte order in the output string.  For example,
                   <b>binary</b> <b>format</b> <b>I3</b> <b>{3</b> <b>-3</b> <b>65536</b> <b>1}</b>
            will return a string equivalent to <b>\x00\x00\x00\x03\xff\xff\xff\xfd\x00\x01\x00\x00</b>

       <b>w</b>    This  form  is  the same as <b>c</b> except that it stores one or more 64-bit integers in little-endian |
            byte order in the output string.  The low-order 64-bits of each integer are stored as an  eight- |
            byte value at the cursor position with the least significant byte stored first.  For example,    |
                   <b>binary</b> <b>format</b> <b>w</b> <b>7810179016327718216</b>                                                       |
            will return the string <b>HelloTcl</b>                                                                  |

       <b>W</b>                                                                                                     ||
            This form is the same as <b>w</b> except that it stores one or more one or more 64-bit integers in big- |
            endian byte order in the output string.  For example,                                            |
                   <b>binary</b> <b>format</b> <b>Wc</b> <b>4785469626960341345</b> <b>110</b>                                                  |
            will return the string <b>BigEndian</b>

       <b>f</b>    This form is the same as <b>c</b> except that it stores one or more one or more single-precision float-<font color="#ffffff" class="whiteout">ing&nbsp;floating</font>
            ing in the machine's native representation in the output string.   This  representation  is  not
            portable  across  architectures,  so it should not be used to communicate floating point numbers
            across the network.  The size of a floating point number may vary across architectures,  so  the
            number of bytes that are generated may vary.  If the value overflows the machine's native repre-<font color="#ffffff" class="whiteout">sentation,&nbsp;representation,</font>
            sentation, then the value of FLT_MAX as defined by the system will be used instead.  Because Tcl
            uses  double-precision floating-point numbers internally, there may be some loss of precision in
            the conversion to single-precision.  For example, on a Windows system running on an  Intel  Pen-<font color="#ffffff" class="whiteout">tium&nbsp;Pentium</font>
            tium processor,
                   <b>binary</b> <b>format</b> <b>f2</b> <b>{1.6</b> <b>3.4}</b>
            will return a string equivalent to <b>\xcd\xcc\xcc\x3f\x9a\x99\x59\x40</b>.

       <b>d</b>    This form is the same as <b>f</b> except that it stores one or more one or more double-precision float-<font color="#ffffff" class="whiteout">ing&nbsp;floating</font>
            ing in the machine's native representation in the output string.  For example, on a Windows sys-<font color="#ffffff" class="whiteout">tem&nbsp;system</font>
            tem running on an Intel Pentium processor,
                   <b>binary</b> <b>format</b> <b>d1</b> <b>{1.6}</b>
            will return a string equivalent to <b>\x9a\x99\x99\x99\x99\x99\xf9\x3f</b>.

       <b>x</b>    Stores  <u>count</u> null bytes in the output string.  If <u>count</u> is not specified, stores one null byte.
            If <u>count</u> is <b>*</b>, generates an error.  This type does not consume an argument.  For example,
                   <b>binary</b> <b>format</b> <b>a3xa3x2a3</b> <b>abc</b> <b>def</b> <b>ghi</b>
            will return a string equivalent to <b>abc\000def\000\000ghi</b>.

       <b>X</b>    Moves the cursor back <u>count</u> bytes in the output string.  If <u>count</u> is <b>*</b> or  is  larger  than  the
            current  cursor  position,  then  the  cursor  is positioned at location 0 so that the next byte
            stored will be the first byte in the result string.  If <u>count</u> is  omitted  then  the  cursor  is
            moved back one byte.  This type does not consume an argument.  For example,
                   <b>binary</b> <b>format</b> <b>a3X*a3X2a3</b> <b>abc</b> <b>def</b> <b>ghi</b>
            will return <b>dghi</b>.

       <b>@</b>    Moves  the  cursor to the absolute location in the output string specified by <u>count</u>.  Position 0
            refers to the first byte in the output string.  If <u>count</u> refers to a position  beyond  the  last
            byte stored so far, then null bytes will be placed in the uninitialized locations and the cursor
            will be placed at the specified location.  If <u>count</u> is <b>*</b>, then the cursor is moved to  the  cur-<font color="#ffffff" class="whiteout">rent&nbsp;current</font>
            rent end of the output string.  If <u>count</u> is omitted, then an error will be generated.  This type
            does not consume an argument. For example,
                   <b>binary</b> <b>format</b> <b>a5@2a1@*a3@10a1</b> <b>abcde</b> <b>f</b> <b>ghi</b> <b>j</b>
            will return <b>abfdeghi\000\000j</b>.


<b>BINARY</b> <b>SCAN</b>
       The <b>binary</b> <b>scan</b> command parses fields from a binary string, returning the number of conversions  per-<font color="#ffffff" class="whiteout">formed.&nbsp;performed.</font>
       formed.   <u>String</u>  gives the input to be parsed and <u>formatString</u> indicates how to parse it.  Each <u>var</u>-<font color="#ffffff" class="whiteout">Name&nbsp;varName</font>
       <u>Name</u> gives the name of a variable; when a field is scanned from <u>string</u> the result is assigned to  the
       corresponding variable.

       As with <b>binary</b> <b>format</b>, the <u>formatString</u> consists of a sequence of zero or more field specifiers sepa-<font color="#ffffff" class="whiteout">rated&nbsp;separated</font>
       rated by zero or more spaces.  Each field specifier  is  a  single  type  character  followed  by  an
       optional numeric <u>count</u>.  Most field specifiers consume one argument to obtain the variable into which
       the scanned values should be placed.  The type character specifies how  the  binary  data  is  to  be
       interpreted.   The  <u>count</u> typically indicates how many items of the specified type are taken from the
       data.  If present, the <u>count</u> is a non-negative decimal integer or <b>*</b>, which  normally  indicates  that
       all  of the remaining items in the data are to be used.  If there are not enough bytes left after the
       current cursor position to satisfy the current field specifier, then the  corresponding  variable  is
       left  untouched  and  <b>binary</b> <b>scan</b> returns immediately with the number of variables that were set.  If
       there are not enough arguments for all of the fields in the format  string  that  consume  arguments,
       then an error is generated.

       A  similar  example  as  with  <b>binary</b> <b>format</b> should explain the relation between field specifiers and
       arguments in case of the binary scan subcommand:
              <b>binary</b> <b>scan</b> <b>$bytes</b> <b>s3s</b> <b>first</b> <b>second</b>

       This command (provided the binary string in the variable <u>bytes</u> is long  enough)  assigns  a  list  of
       three  integers  to  the  variable <u>first</u> and assigns a single value to the variable <u>second</u>.  If <u>bytes</u>
       contains fewer than 8 bytes (i.e. four 2-byte integers), no assignment to <u>second</u> will be made, and if
       <u>bytes</u>  contains fewer than 6 bytes (i.e. three 2-byte integers), no assignment to <u>first</u> will be made.
       Hence:
              <b>puts</b> <b>[binary</b> <b>scan</b> <b>abcdefg</b> <b>s3s</b> <b>first</b> <b>second]</b>
              <b>puts</b> <b>$first</b>
              <b>puts</b> <b>$second</b>
       will print (assuming neither variable is set previously):
              <b>1</b>
              <b>25185</b> <b>25699</b> <b>26213</b>
              <u>can't</u> <u>read</u> <u>"second":</u> <u>no</u> <u>such</u> <u>variable</u>

       It is <b>important</b> to note that the <b>c</b>, <b>s</b>, and <b>S</b> (and <b>i</b> and <b>I</b> on 64bit systems) will be scanned into long
       data  size  values.   In  doing this, values that have their high bit set (0x80 for chars, 0x8000 for
       shorts, 0x80000000 for ints), will be sign extended.  Thus the following will occur:
              <b>set</b> <b>signShort</b> <b>[binary</b> <b>format</b> <b>s1</b> <b>0x8000]</b>
              <b>binary</b> <b>scan</b> <b>$signShort</b> <b>s1</b> <b>val;</b> <u>#</u> <u>val</u> <u>==</u> <u>0xFFFF8000</u>
       If you want to produce an unsigned value, then you can mask the return value  to  the  desired  size.
       For example, to produce an unsigned short value:
              <b>set</b> <b>val</b> <b>[expr</b> <b>{$val</b> <b>&amp;</b> <b>0xFFFF}];</b> <u>#</u> <u>val</u> <u>==</u> <u>0x8000</u>

       Each  type-count  pair moves an imaginary cursor through the binary data, reading bytes from the cur-<font color="#ffffff" class="whiteout">rent&nbsp;current</font>
       rent position.  The cursor is initially at position 0 at the beginning of the data.  The type may  be
       any one of the following characters:

       <b>a</b>    The  data is a character string of length <u>count</u>.  If <u>count</u> is <b>*</b>, then all of the remaining bytes
            in <u>string</u> will be scanned into the variable.  If <u>count</u> is omitted, then one  character  will  be
            scanned.   All characters scanned will be interpreted as being in the range \u0000-\u00ff so the
            <b>encoding</b> <b>convertfrom</b> command might be needed if the string is not an  ISO  8859-1  string.   For
            example,
                   <b>binary</b> <b>scan</b> <b>abcde\000fghi</b> <b>a6a10</b> <b>var1</b> <b>var2</b>
            will return <b>1</b> with the string equivalent to <b>abcde\000</b> stored in <b>var1</b> and <b>var2</b> left unmodified.

       <b>A</b>    This form is the same as <b>a</b>, except trailing blanks and nulls are stripped from the scanned value
            before it is stored in the variable.  For example,
                   <b>binary</b> <b>scan</b> <b>"abc</b> <b>efghi</b>  <b>\000"</b> <b>A*</b> <b>var1</b>
            will return <b>1</b> with <b>abc</b> <b>efghi</b> stored in <b>var1</b>.

       <b>b</b>    The data is turned into a string of <u>count</u> binary digits in low-to-high order  represented  as  a
            sequence  of ``1'' and ``0'' characters.  The data bytes are scanned in first to last order with
            the bits being taken in low-to-high order within each byte.  Any extra bits in the last byte are
            ignored.   If <u>count</u> is <b>*</b>, then all of the remaining bits in <b>string</b> will be scanned.  If <u>count</u> is
            omitted, then one bit will be scanned.  For example,
                   <b>binary</b> <b>scan</b> <b>\x07\x87\x05</b> <b>b5b*</b> <b>var1</b> <b>var2</b>
            will return <b>2</b> with <b>11100</b> stored in <b>var1</b> and <b>1110000110100000</b> stored in <b>var2</b>.

       <b>B</b>    This form is the same as <b>b</b>, except the bits are taken in high-to-low  order  within  each  byte.
            For example,
                   <b>binary</b> <b>scan</b> <b>\x70\x87\x05</b> <b>B5B*</b> <b>var1</b> <b>var2</b>
            will return <b>2</b> with <b>01110</b> stored in <b>var1</b> and <b>1000011100000101</b> stored in <b>var2</b>.

       <b>h</b>    The data is turned into a string of <u>count</u> hexadecimal digits in low-to-high order represented as
            a sequence of characters in the set ``0123456789abcdef''.  The data bytes are scanned  in  first
            to  last order with the hex digits being taken in low-to-high order within each byte.  Any extra
            bits in the last byte are ignored.  If <u>count</u> is <b>*</b>, then all  of  the  remaining  hex  digits  in
            <b>string</b> will be scanned.  If <u>count</u> is omitted, then one hex digit will be scanned.  For example,
                   <b>binary</b> <b>scan</b> <b>\x07\x86\x05</b> <b>h3h*</b> <b>var1</b> <b>var2</b>
            will return <b>2</b> with <b>706</b> stored in <b>var1</b> and <b>50</b> stored in <b>var2</b>.

       <b>H</b>    This  form  is the same as <b>h</b>, except the digits are taken in high-to-low order within each byte.
            For example,
                   <b>binary</b> <b>scan</b> <b>\x07\x86\x05</b> <b>H3H*</b> <b>var1</b> <b>var2</b>
            will return <b>2</b> with <b>078</b> stored in <b>var1</b> and <b>05</b> stored in <b>var2</b>.

       <b>c</b>    The data is turned into <u>count</u> 8-bit signed integers and stored in the corresponding variable  as
            a  list.  If <u>count</u> is <b>*</b>, then all of the remaining bytes in <b>string</b> will be scanned.  If <u>count</u> is
            omitted, then one 8-bit integer will be scanned.  For example,
                   <b>binary</b> <b>scan</b> <b>\x07\x86\x05</b> <b>c2c*</b> <b>var1</b> <b>var2</b>
            will return <b>2</b> with <b>7</b> <b>-122</b> stored in <b>var1</b> and <b>5</b> stored in <b>var2</b>.  Note that the integers  returned
            are signed, but they can be converted to unsigned 8-bit quantities using an expression like:
                   <b>expr</b> <b>(</b> <b>$num</b> <b>+</b> <b>0x100</b> <b>)</b> <b>%</b> <b>0x100</b>

       <b>s</b>    The data is interpreted as <u>count</u> 16-bit signed integers represented in little-endian byte order.
            The integers are stored in the corresponding variable as a list.  If <u>count</u> is <b>*</b>, then all of the
            remaining bytes in <b>string</b> will be scanned.  If <u>count</u> is omitted, then one 16-bit integer will be
            scanned.  For example,
                   <b>binary</b> <b>scan</b> <b>\x05\x00\x07\x00\xf0\xff</b> <b>s2s*</b> <b>var1</b> <b>var2</b>
            will return <b>2</b> with <b>5</b> <b>7</b> stored in <b>var1</b> and <b>-16</b> stored in <b>var2</b>.  Note that the  integers  returned
            are signed, but they can be converted to unsigned 16-bit quantities using an expression like:
                   <b>expr</b> <b>(</b> <b>$num</b> <b>+</b> <b>0x10000</b> <b>)</b> <b>%</b> <b>0x10000</b>

       <b>S</b>    This  form  is the same as <b>s</b> except that the data is interpreted as <u>count</u> 16-bit signed integers
            represented in big-endian byte order.  For example,
                   <b>binary</b> <b>scan</b> <b>\x00\x05\x00\x07\xff\xf0</b> <b>S2S*</b> <b>var1</b> <b>var2</b>
            will return <b>2</b> with <b>5</b> <b>7</b> stored in <b>var1</b> and <b>-16</b> stored in <b>var2</b>.

       <b>i</b>    The data is interpreted as <u>count</u> 32-bit signed integers represented in little-endian byte order.
            The integers are stored in the corresponding variable as a list.  If <u>count</u> is <b>*</b>, then all of the
            remaining bytes in <b>string</b> will be scanned.  If <u>count</u> is omitted, then one 32-bit integer will be
            scanned.  For example,
                   <b>binary</b> <b>scan</b> <b>\x05\x00\x00\x00\x07\x00\x00\x00\xf0\xff\xff\xff</b> <b>i2i*</b> <b>var1</b> <b>var2</b>
            will  return  <b>2</b> with <b>5</b> <b>7</b> stored in <b>var1</b> and <b>-16</b> stored in <b>var2</b>.  Note that the integers returned
            are signed and cannot be represented by Tcl as unsigned values.

       <b>I</b>    This form is the same as <b>I</b> except that the data is interpreted as <u>count</u> 32-bit  signed  integers
            represented in big-endian byte order.  For example,
                   <b>binary</b> <b>scan</b> <b>\x00\x00\x00\x05\x00\x00\x00\x07\xff\xff\xff\xf0</b> <b>I2I*</b> <b>var1</b> <b>var2</b>
            will return <b>2</b> with <b>5</b> <b>7</b> stored in <b>var1</b> and <b>-16</b> stored in <b>var2</b>.

       <b>w</b>    The data is interpreted as <u>count</u> 64-bit signed integers represented in little-endian byte order. |
            The integers are stored in the corresponding variable as a list.  If <u>count</u> is <b>*</b>, then all of the |
            remaining bytes in <b>string</b> will be scanned.  If <u>count</u> is omitted, then one 64-bit integer will be |
            scanned.  For example,                                                                           |
                   <b>binary</b> <b>scan</b> <b>\x05\x00\x00\x00\x07\x00\x00\x00\xf0\xff\xff\xff</b> <b>wi*</b> <b>var1</b> <b>var2</b>                |
            will return <b>2</b> with <b>30064771077</b> stored in <b>var1</b> and <b>-16</b> stored in <b>var2</b>.  Note  that  the  integers |
            returned are signed and cannot be represented by Tcl as unsigned values.                         |

       <b>W</b>                                                                                                     ||
            This form is the same as <b>w</b> except that the data is interpreted as <u>count</u> 64-bit  signed  integers |
            represented in big-endian byte order.  For example,                                              |
                   <b>binary</b> <b>scan</b> <b>\x00\x00\x00\x05\x00\x00\x00\x07\xff\xff\xff\xf0</b> <b>WI*</b> <b>var1</b> <b>var2</b>                |
            will return <b>2</b> with <b>21474836487</b> stored in <b>var1</b> and <b>-16</b> stored in <b>var2</b>.

       <b>f</b>    The data is interpreted as <u>count</u> single-precision floating point numbers in the machine's native
            representation.  The floating point numbers are stored in the corresponding variable as a  list.
            If  <u>count</u> is <b>*</b>, then all of the remaining bytes in <b>string</b> will be scanned.  If <u>count</u> is omitted,
            then one single-precision floating point number will be scanned.  The size of a  floating  point
            number  may vary across architectures, so the number of bytes that are scanned may vary.  If the
            data does not represent a valid floating point number, the resulting value is undefined and com-<font color="#ffffff" class="whiteout">piler&nbsp;compiler</font>
            piler dependent.  For example, on a Windows system running on an Intel Pentium processor,
                   <b>binary</b> <b>scan</b> <b>\x3f\xcc\xcc\xcd</b> <b>f</b> <b>var1</b>
            will return <b>1</b> with <b>1.6000000238418579</b> stored in <b>var1</b>.

       <b>d</b>    This  form is the same as <b>f</b> except that the data is interpreted as <u>count</u> double-precision float-<font color="#ffffff" class="whiteout">ing&nbsp;floating</font>
            ing point numbers in the machine's native representation. For example, on a Windows system  run-<font color="#ffffff" class="whiteout">ning&nbsp;running</font>
            ning on an Intel Pentium processor,
                   <b>binary</b> <b>scan</b> <b>\x9a\x99\x99\x99\x99\x99\xf9\x3f</b> <b>d</b> <b>var1</b>
            will return <b>1</b> with <b>1.6000000000000001</b> stored in <b>var1</b>.

       <b>x</b>    Moves  the  cursor forward <u>count</u> bytes in <u>string</u>.  If <u>count</u> is <b>*</b> or is larger than the number of
            bytes after the current cursor cursor position, then the cursor is  positioned  after  the  last
            byte in <u>string</u>.  If <u>count</u> is omitted, then the cursor is moved forward one byte.  Note that this
            type does not consume an argument.  For example,
                   <b>binary</b> <b>scan</b> <b>\x01\x02\x03\x04</b> <b>x2H*</b> <b>var1</b>
            will return <b>1</b> with <b>0304</b> stored in <b>var1</b>.

       <b>X</b>    Moves the cursor back <u>count</u> bytes in <u>string</u>.  If <u>count</u> is <b>*</b> or is larger than the current cursor
            position,  then the cursor is positioned at location 0 so that the next byte scanned will be the
            first byte in <u>string</u>.  If <u>count</u> is omitted then the cursor is moved back one  byte.   Note  that
            this type does not consume an argument.  For example,
                   <b>binary</b> <b>scan</b> <b>\x01\x02\x03\x04</b> <b>c2XH*</b> <b>var1</b> <b>var2</b>
            will return <b>2</b> with <b>1</b> <b>2</b> stored in <b>var1</b> and <b>020304</b> stored in <b>var2</b>.

       <b>@</b>    Moves  the  cursor  to  the  absolute location in the data string specified by <u>count</u>.  Note that
            position 0 refers to the first byte in <u>string</u>.  If <u>count</u> refers to a position beyond the end  of
            <u>string</u>,  then  the cursor is positioned after the last byte.  If <u>count</u> is omitted, then an error
            will be generated.  For example,
                   <b>binary</b> <b>scan</b> <b>\x01\x02\x03\x04</b> <b>c2@1H*</b> <b>var1</b> <b>var2</b>
            will return <b>2</b> with <b>1</b> <b>2</b> stored in <b>var1</b> and <b>020304</b> stored in <b>var2</b>.


<b>PLATFORM</b> <b>ISSUES</b>
       Sometimes it is desirable to format or scan integer values in the native byte order for the  machine.
       Refer  to  the <b>byteOrder</b> element of the <b>tcl_platform</b> array to decide which type character to use when
       formatting or scanning integers.


<b>SEE</b> <b>ALSO</b>
       <a href="format.ntcl.html#//apple_ref/doc/man/n/format">format(n)</a>, <a href="scan.ntcl.html#//apple_ref/doc/man/n/scan">scan(n)</a>, <a href="tclvars.ntcl.html#//apple_ref/doc/man/n/tclvars">tclvars(n)</a>


<b>KEYWORDS</b>
       binary, format, scan



Tcl                                                  8.0                                           binary(n)
</tt></pre>
</td></tr></table>
	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Darwin/Reference/ManPages/mann/binary.ntcl.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Darwin/Reference/ManPages/mann/binary.ntcl.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Darwin/Reference/ManPages/mann/binary.ntcl.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

</body></html>
