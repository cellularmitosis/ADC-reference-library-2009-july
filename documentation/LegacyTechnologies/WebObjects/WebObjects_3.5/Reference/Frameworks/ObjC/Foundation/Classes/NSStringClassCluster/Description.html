<html><head><title></title></head>

<body bgcolor="#ffffff">

 

 

<h1>

<img src="../cluster.gif">

<FONT COLOR="#000066">

<a name="527">

NSString Class Cluster

</a>

</FONT>

</h1>

<p><h3>

<a name="552">

Class Cluster Description 

</a>

</h3>

NSString objects represent character strings in OpenStep frameworks. Representing strings as objects allows you to use strings wherever you use other objects. It also provides the benefits of encapsulation, so that string objects can use whatever encoding and storage is needed for efficiency while simply appearing as arrays of characters. The cluster's two public classes, NSString and NSMutableString, declare the programmatic interface for noneditable and editable strings, respectively.<p>

<B><dt>Note:	</B>

An immutable string is a text string that is defined when it is created and subsequently cannot be 

changed. An immutable string is implemented as array of Unicode characters (in other words, a text 

string). To create and manage an immutable string, use the NSString class. To construct and manage 

a string that can be changed after it has been created, use NSMutableString.

The objects you create using NSString and NSMutableStringare referred to as <strong>string objects</strong> (or, when no confusion will result, merely as <em>strings</em>). The term <strong>C string</strong> refers to the standard <code>char *</code> type. Because of the nature of class clusters, string objects aren't actual instances of the NSString or NSMutableString classes but of one of their private subclasses. Although a string object's class is private, its interface is public, as declared by these abstract superclasses, NSString and NSMutableString. The string classes adopt the NSCopying and NSMutableCopying protocols, making it convenient to convert a string of one type to the other.<p>

A string object presents itself as an array of Unicode&#174; characters (Unicode is a registered trademark of Unicode, Inc.). You can determine how many characters it contains with the <code>length</code> method and can retrieve a specific character with the <code>characterAtIndex:</code> method. These two "primitive" methods provide basic access to a string object. Most use of strings, however, is at a higher level, with the strings being treated as single entities: You compare strings against one another, search them for substrings, combine them into new strings, and so on. If you need to access string objects character-by-character, you must understand the Unicode character encoding, specifically issues related to composed character sequences. For details see:<p>

<em>The Unicode Standard:  Worldwide Character Encoding</em>, Version 1.0, Volumes 1 and 2. The Unicode Consortium. Addison-Wesley. ISBN 0-201-56788-1 (Volume 1) and 0-201-60845-6 (Volume 2).<p>

Version 2.0, also published by Addison-Wesley, is forthcoming. ISBN 0-201-48345-9. <p>

<h3>

<a name="559">

 Creating and Converting String Objects

</a>

</h3>

NSString provides several means for creating instances, most based around the various character encodings it supports. Although string objects always present their own contents as Unicode characters, they can convert their contents to and from many other encodings, such as 7-bit ASCII, ISO Latin 1, EUC, and Shift-JIS. The <code>availableStringEncodings</code> class method returns the encodings supported. You can specify an encoding explicitly when converting a C string to or from a string object, or use the <strong>default C string encoding</strong>, which varies from platform to platform and is returned by the <code>defaultCStringEncoding</code> class method.<p>

The simplest way to create a string object in source code is to use either the <code>stringWithCString:</code> class method or the <code>initWithCString:</code> instance method. Each takes a standard null-terminated C string in the default C string encoding and produces a string object. As a convenience, the Objective-C language also supports the <code>@"..."</code> construct to create a string object constant from 7-bit ASCII encoding:<p>

<blockquote><pre>NSString *temp = @"/tmp/scratch";

</pre></blockquote><p>Such an object is created at compile time and exists throughout your program's execution. The compiler makes such object constants unique on a per-module basis, and they're never deallocated (though you can retain and release them as you do any other object).<p>

To get a C string from a string object, use the <code>cString</code> message. This returns a <code>char *</code> in the system's default string encoding, or raises an exception if it can't convert its contents to that encoding. The C string you receive is owned by a temporary object, though, so it will become invalid when automatic deallocation takes place. If you want to get a permanent C string, you must create a buffer and use one of the <code>getCString:...</code> methods to fill it. You can find out how large the buffer needs to be with the <code>cStringLength</code> method.<p>

Similar methods allow you to create string objects from characters in the Unicode encoding or an arbitrary encoding, and to extract data in these encodings. <code>initWithData:encoding:</code> and <code>dataUsingEncoding:</code> perform these conversions from and to NSData objects. You can also read a string directly from a file in the Unicode or default C string encoding using the <code>stringWithContentsOfFile:</code> class method, and write a string using <code>writeToFile:atomically:</code>.<p>

Finally, two types of method allow you to build a string from existing string objects. <code>localizedStringWithFormat:</code> and its siblings use a format string as a template into which the values you provide (string and other objects, numerics values, and so on) are inserted. The methods <code>stringByAppendingString:</code> and <code>stringByAppendingFormat:</code> create a new string by adding one string after another, in the second case using a format string.<p>

In format strings, a `%' character announces a placeholder for a value, with the characters that follow determining the kind of value expected and how to format it. For example, a format string of "%d houses" expects an integer value to be substituted for the format expression "%d". NSString supports the format characters defined for the ANSI C function <code>printf()</code>, plus `@' for any object. If the object responds to the <code>descriptionWithLocale:</code> message, NSString sends that message to retrieve the text representation, otherwise, it sends a <code>description</code> message.<p>

<B><dt>Note:	</B>

Many compilers perform typecasting of arguments to <code>printf()</code>, so that printing an integer into a <code>%f</code> 

(floating-point) placeholder works as expected. This typecasting doesn't occur with NSString's 

formatted methods, so be sure to cast your values explicitly.

Value formatting is affected by the user's current locale, which is an NSDictionary specifying number, date, and other kinds of formats. NSString uses only the locale's definition for the decimal separator (given by the key named NSDecimalSeparator). If you use a method that doesn't specify a locale, the string assumes the default locale. See "Locales" in the "Other Features" section of the Foundation Kit documentation for more information on locales.<p>

This table summarizes the most common means of creating and converting string objects:<p>

<Table Border="3">

<caption></caption>

<tr><th><b>Source</b>

</th><th><b>Creation Method</b>

</th><th><b>Extraction Method</b>

</th></tr>

<tr><td scope="row">Default C string encoding

</td><td>stringWithCString:

</td><td>getCString: (or cString)

</td></tr>

<tr><td scope="row">In code

</td><td>@"..." compiler construct

</td><td>&nbsp;</td></tr>

<tr><td scope="row">Unicode encoding

</td><td>stringWithCharacters:length:

</td><td>getCharacters:length:

</td></tr>

<tr><td scope="row">Arbitrary encoding

</td><td>initWithData:encoding:

</td><td>dataUsingEncoding:

</td></tr>

<tr><td scope="row">File contents

</td><td>stringWithContentsOfFile:

</td><td>writeToFile:atomically:

</td></tr>

<tr><td scope="row">Format string

</td><td>localizedStringWithFormat:

</td><td>initWithFormat:locale:

</td></tr>

<tr><td scope="row">Existing strings

</td><td>stringByAppendingString:

</td><td>stringByAppendingFormat:

</td></tr>



</Table>



<Table>

<tr><td scope="row">

</Table>

<p>

<h3>

<a name="571">

 Working with String Objects

</a>

</h3>

The string classes provide methods for finding characters and substrings within strings and for comparing one string to another. These methods conform to the Unicode standard for determining whether two character sequences are equivalent. The string classes provide comparison methods that handle composed character sequences properly, though you do have the option of specifying a literal search when efficiency is important and you can guarantee some canonical form for composed character sequences.<p>

The search and comparison methods each come in three variants. The simplest version of each searches or compares entire strings. Other variants allow you to alter the way comparison of composed character sequences is performed and to specify a specific range of characters within a string to be searched or compared. You can specify these options (not all options are available for every method):<p>

<Table Border="3">

<caption></caption>

<tr><th><b>Search Option</b>

</th><th><b>Effect</b>

</th></tr>

<tr><td scope="row">NSCaseInsensitiveSearch

</td><td>Ignores case distinctions among characters.

</td></tr>

<tr><td scope="row">NSLiteralSearch

</td><td>Performs a byte-for-byte comparison. Differing literal sequences (such as 

composed character sequences) that would otherwise be considered 

equivalent are considered not to match. Using this option can speed some 

operations dramatically.

</td></tr>

<tr><td scope="row">NSBackwardsSearch

</td><td>Performs searching from the end of the range toward the beginning.

</td></tr>

<tr><td scope="row">NSAnchoredSearch

</td><td>Performs searching only on characters at the beginning or end of the range. 

No match at the beginning or end means nothing is found, even if a matching 

sequence of characters occurs elsewhere in the string.

</td></tr>



</Table>



<Table>

<tr><td scope="row">

</Table>

<p>

<B><dt>Note:	</B>

Search and comparison are currently performed as if the NSLiteralSearch option were specified. As 

the Unicode encoding becomes more widely used, and the need for more flexible comparison 

increases, the default behavior will be changed accordingly.

Substrings are only found if completely contained within the specified range. If you specify a range for a search or comparison method and don't request NSLiteralSearch, the range must not break composed character sequences on either end; if it does you could get an incorrect result. (See the method description for <code>rangeOfComposedCharacterSequenceAtIndex:</code> for a code sample that adjusts a range to lie on character sequence boundaries.)<p>

The basic search and comparison methods are these:<p>

<Table Border="3">

<caption></caption>

<tr><th><b>Search methods</b>

</th><th><b>Comparison methods</b>

</th></tr>

<tr><td scope="row">rangeOfString:

</td><td>compare:

</td></tr>

<tr><td scope="row">rangeOfString:options:

</td><td>compare:options:

</td></tr>

<tr><td scope="row">rangeOfStrings:options:range:

</td><td>compare:options:range:

</td></tr>

<tr><td scope="row">rangeOfCharacterFromSet:

</td><td>&nbsp;</td></tr>

<tr><td scope="row">rangeOfCharacterFromSet:options:

</td><td>&nbsp;</td></tr>

<tr><td scope="row">rangeOfCharacterFromSet:options:range:

</td><td>&nbsp;</td></tr>



</Table>



<Table>

<tr><td scope="row">

</Table>

<p>

The <code>rangeOfString:...</code> methods search for a substring within the receiver. The <code>rangeOfCharacterFromSet:...</code> methods search for individual characters from a supplied set of characters. The <code>compare:...</code> methods return the lexical ordering of the receiver and the supplied string. Several other methods allow you to determine whether two strings are equal or whether one is the prefix or suffix of another, but they don't have variants that allow you to specify search options or ranges.<p>

In addition to searching and comparing strings, you can combine and divide them in various ways. The simplest way to put two strings together is to append one to the other. The <code>stringByAppendingString:</code> method returns a string object formed from the receiver and the argument supplied. You can also combine several strings according to a template with the <code>initWithFormat:</code>, <code>stringWithFormat:</code> and <code>stringByAppendingFormat:</code> methods. See <a href="#559">"Creating and Converting String Objects"</a> for more information.<p>

You can extract substrings from the beginning or end of a string to a particular index, or from a specific range, with the <code>substringToIndex:</code>, <code>substringFromIndex:</code>, and <code>substringWithRange:</code> methods. You can also split a string into substrings (based on a separator string) with the <code>componentsSeparatedByString:</code> method.<p>

Most of the NSString classes' remaining methods are for conveniences such as changing case, quickly extracting numeric values, and working with encodings. There's also a set of methods for treating strings as file system paths, described below in <a href="#581">"Manipulating Paths"</a>. An additional class cluster, NSScanner, allows you to scan a string object for numeric and string values. Both the NSString and the NSScanner class clusters use the NSCharacterSet class cluster for search operations. See the appropriate class specifications for more information.<p>

<h3>

<a name="581">

 Manipulating Paths

</a>

</h3>

In addition to all the basic methods for working with character strings merely as strings, NSString also provides a rich set of methods for manipulating strings as file system paths. A string can extract a path's directory, file name, and extension, expand a tilde expression (such as "~me") or create one for the user's home directory, and clean up paths containing symbolic links, redundant slashes, and references to "." (current directory) and ".." (parent directory). These methods are listed under <a href="#689">"Working with paths"</a> in the Method Types section.<p>

NSString represents paths generically with `/' as the path separator and `.' as the extension separator. Methods that accept strings as path arguments convert these generic representations to the proper system-specific form as needed. On systems with an implicit root directory, absolute paths begin with a path separator or with a tilde expression ("~/..." or "~<em>user</em>/..."). On systems that require explicit expression of root directories for different devices, such as Microsoft Windows 95, absolute paths begin with the name of the device (for example, "C:/Documents/Paper.doc" to represent the actual path "C:\Documents\Paper.doc"). Where a device must be specified, you can do that yourself-introducing a system dependency-or allow the string object to add a default device.<p>

<hr><p>

<h1>

<img src="../clsclstr.gif">

<FONT COLOR="#000066">

<a name="584"><a name="//apple_ref/occ/cl/NSString">NSString</a>

</a>

</FONT>

</h1>

<p><B>Inherits From:</B><BR>  

NSObject



<p><B>Conforms To:</B><BR>

NSCoding<br>

NSCopying<br>

NSMutableCopying<br>

NSObject (NSObject)



<p><B>Declared In:	</B><BR>

Foundation/NSString.h<br>

Foundation/NSPathUtilities.h



<p><a name="588"></a>

<a name="description"></a>

<H2>Class Description

</H2>

The NSString class declares the programmatic interface for an object that manages immutable strings. (An immutable string is a text string that is defined when it is created and subsequently cannot be changed. An immutable string is implemented as array of Unicode characters (in other words, a text string). To create and manage a string that can be changed after it has been created, use NSMutableString.)<p>

The NSString class has two primitive methods-<code>length</code> and <code>characterAtIndex:</code>-that provide the basis for all other methods in its interface. The <code>length</code> method returns the total number of Unicode characters in the string. <code>characterAtIndex:</code> gives access to each character in the string by index, with index values starting at 0.<p>

NSString declares methods for finding and comparing strings. It also declares methods for reading numeric values from strings, for combining strings in various ways, and for converting a string to different forms (such as encoding and case changes). General use of these methods is presented in the class cluster description under <a href="#571">"Working with String Objects"</a>.<p>

<HR WIDTH="50%" ALIGN="LEFT">

<h2>Adopted Protocols</h2>  





<dl>

<dt>NSCoding<dd><dl><dd><dl><dd><dl><dd><dl>

<dt><a href="../../Protocols/NSCoding.html#//apple_ref/occ/intfm/NSCoding/encodeWithCoder:" target="_top">- encodeWithCoder:</a><dt><a href="../../Protocols/NSCoding/NSCoding.html#//apple_ref/occ/intfm/NSCoding/initWithCoder:" target="_top">- initWithCoder:</a></dl></dd>

</dl></dd></dl></dd></dl></dd><dt>NSCopying<dd><dl><dd><dl><dd><dl><dd><dl>

<dt><a href="../../Protocols/NSCopying/NSCopying.html#//apple_ref/occ/intfm/NSCopying/copyWithZone:" target="_top">- copyWithZone:</a></dl></dd>

</dl></dd></dl></dd></dl></dd><dt>NSMutableCopying<dd><dl><dd><dl><dd><dl><dd><dl>

<dt><a href="../../Protocols/NSMutableCopying/NSMutableCopying.html#//apple_ref/occ/intfm/NSMutableCopying/mutableCopyWithZone:" target="_top">- mutableCopyWithZone:</a></dl></dd>

</dl></dd></dl></dd></dl></dd></dl>

<a name="600">

<HR WIDTH="50%" ALIGN="LEFT">

<h2>Method Types

</h2>

</a><dl>

<dt>Creating temporary strings<dd><dl><dd><dl><dd><dl><dd><dl>

<dt><a href="#//apple_ref/occ/clm/NSString/stringWithCString:">+ stringWithCString:</a><dt><a href="#//apple_ref/occ/clm/NSString/stringWithCString:length:">+ stringWithCString:length:</a><dt><a href="#//apple_ref/occ/clm/NSString/stringWithFormat:">+ stringWithFormat:</a><dt><a href="#//apple_ref/occ/clm/NSString/localizedStringWithFormat:">+ localizedStringWithFormat:</a><dt><a href="#//apple_ref/occ/clm/NSString/stringWithContentsOfFile:">+ stringWithContentsOfFile:</a><dt><a href="#//apple_ref/occ/clm/NSString/stringWithCharacters:length:">+ stringWithCharacters:length:</a><dt><a href="#//apple_ref/occ/clm/NSString/string">+ string</a><dt><a href="#//apple_ref/occ/clm/NSString/stringWithString:">+ stringWithString:</a></dl></dd>

</dl></dd></dl></dd></dl></dd><dt>Initializing newly allocated strings<dd><dl><dd><dl><dd><dl><dd><dl>

<dt><a href="#//apple_ref/occ/instm/NSString/initWithCharactersNoCopy:length:freeWhenDone:">- initWithCharactersNoCopy:length:freeWhenDone:</a><dt><a href="#//apple_ref/occ/instm/NSString/initWithCharacters:length:">- initWithCharacters:length:</a><dt><a href="#//apple_ref/occ/instm/NSString/initWithCStringNoCopy:length:freeWhenDone:">- initWithCStringNoCopy:length:freeWhenDone:</a><dt><a href="#//apple_ref/occ/instm/NSString/initWithCString:length:">- initWithCString:length:</a><dt><a href="#//apple_ref/occ/instm/NSString/initWithCString:">- initWithCString:</a><dt><a href="#//apple_ref/occ/instm/NSString/initWithString:">- initWithString:</a><dt><a href="#//apple_ref/occ/instm/NSString/initWithFormat:">- initWithFormat:</a><dt><a href="#//apple_ref/occ/instm/NSString/initWithFormat:arguments:">- initWithFormat:arguments:</a><dt><a href="#//apple_ref/occ/instm/NSString/initWithFormat:locale:">- initWithFormat:locale:</a><dt><a href="#//apple_ref/occ/instm/NSString/initWithFormat:locale:arguments:">- initWithFormat:locale:arguments:</a><dt><a href="#//apple_ref/occ/instm/NSString/initWithData:encoding:">- initWithData:encoding:</a><dt><a href="#//apple_ref/occ/instm/NSString/initWithContentsOfFile:">- initWithContentsOfFile:</a><dt><a href="#//apple_ref/occ/instm/NSString/init">- init</a></dl></dd>

</dl></dd></dl></dd></dl></dd><dt>Getting a string's length<dd><dl><dd><dl><dd><dl><dd><dl>

<dt><a href="#//apple_ref/occ/instm/NSString/length">- length</a></dl></dd>

</dl></dd></dl></dd></dl></dd><dt>Accessing characters<dd><dl><dd><dl><dd><dl><dd><dl>

<dt><a href="#//apple_ref/occ/instm/NSString/characterAtIndex:">- characterAtIndex:</a><dt><a href="#//apple_ref/occ/instm/NSString/getCharacters:">- getCharacters:</a><dt><a href="#//apple_ref/occ/instm/NSString/getCharacters:range:">- getCharacters:range:</a></dl></dd>

</dl></dd></dl></dd></dl></dd><dt>Combining strings<dd><dl><dd><dl><dd><dl><dd><dl>

<dt><a href="#//apple_ref/occ/instm/NSString/stringByAppendingFormat:">- stringByAppendingFormat:</a><dt><a href="#//apple_ref/occ/instm/NSString/stringByAppendingString:">- stringByAppendingString:</a></dl></dd>

</dl></dd></dl></dd></dl></dd><dt>Dividing strings<dd><dl><dd><dl><dd><dl><dd><dl>

<dt><a href="#//apple_ref/occ/instm/NSString/componentsSeparatedByString:">- componentsSeparatedByString:</a><dt><a href="#//apple_ref/occ/instm/NSString/substringFromIndex:">- substringFromIndex:</a><dt><a href="#//apple_ref/occ/instm/NSString/substringWithRange:">- substringWithRange:</a><dt><a href="#//apple_ref/occ/instm/NSString/substringToIndex:">- substringToIndex:</a></dl></dd>

</dl></dd></dl></dd></dl></dd><dt>Finding characters and substrings<dd><dl><dd><dl><dd><dl><dd><dl>

<dt><a href="#//apple_ref/occ/instm/NSString/rangeOfCharacterFromSet:">- rangeOfCharacterFromSet:</a><dt><a href="#//apple_ref/occ/instm/NSString/rangeOfCharacterFromSet:options:">- rangeOfCharacterFromSet:options:</a><dt><a href="#//apple_ref/occ/instm/NSString/rangeOfCharacterFromSet:options:range:">- rangeOfCharacterFromSet:options:range:</a><dt><a href="#//apple_ref/occ/instm/NSString/rangeOfString:">- rangeOfString:</a><dt><a href="#//apple_ref/occ/instm/NSString/rangeOfString:options:">- rangeOfString:options:</a><dt><a href="#//apple_ref/occ/instm/NSString/rangeOfString:options:range:">- rangeOfString:options:range:</a></dl></dd>

</dl></dd></dl></dd></dl></dd><dt>Determining line ranges<dd><dl><dd><dl><dd><dl><dd><dl>

<dt><a href="#//apple_ref/occ/instm/NSString/getLineStart:end:contentsEnd:forRange:">- getLineStart:end:contentsEnd:forRange:</a><dt><a href="#//apple_ref/occ/instm/NSString/lineRangeForRange:">- lineRangeForRange:</a></dl></dd>

</dl></dd></dl></dd></dl></dd><dt>Determining composed character sequences<dd><dl><dd><dl><dd><dl><dd><dl>

<dt><a href="#//apple_ref/occ/instm/NSString/rangeOfComposedCharacterSequenceAtIndex:">- rangeOfComposedCharacterSequenceAtIndex:</a></dl></dd>

</dl></dd></dl></dd></dl></dd><dt><code>Converting string contents into a property list</code><dd><dl><dd><dl><dd><dl><dd><dl>

<dt><a href="#//apple_ref/occ/instm/NSString/propertyList">- propertyList</a><dt><a href="#//apple_ref/occ/instm/NSString/propertyListFromStringsFileFormat">- propertyListFromStringsFileFormat</a></dl></dd>

</dl></dd></dl></dd></dl></dd><dt>Identifying and comparing strings<dd><dl><dd><dl><dd><dl><dd><dl>

<dt><a href="#//apple_ref/occ/instm/NSString/caseInsensitiveCompare:">- caseInsensitiveCompare:</a><dt><a href="#//apple_ref/occ/instm/NSString/compare:">- compare:</a><dt><a href="#//apple_ref/occ/instm/NSString/compare:options:">- compare:options:</a><dt><a href="#//apple_ref/occ/instm/NSString/compare:options:range:">- compare:options:range:</a><dt><a href="#//apple_ref/occ/instm/NSString/hasPrefix:">- hasPrefix:</a><dt><a href="#//apple_ref/occ/instm/NSString/hasSuffix:">- hasSuffix:</a><dt><a href="#//apple_ref/occ/instm/NSString/isEqualToString:">- isEqualToString:</a><dt><a href="#//apple_ref/occ/instm/NSString/hash">- hash</a></dl></dd>

</dl></dd></dl></dd></dl></dd><dt>Getting a shared prefix<dd><dl><dd><dl><dd><dl><dd><dl>

<dt><a href="#//apple_ref/occ/instm/NSString/commonPrefixWithString:options:">- commonPrefixWithString:options:</a></dl></dd>

</dl></dd></dl></dd></dl></dd><dt>Changing case<dd><dl><dd><dl><dd><dl><dd><dl>

<dt><a href="#//apple_ref/occ/instm/NSString/capitalizedString">- capitalizedString</a><dt><a href="#//apple_ref/occ/instm/NSString/lowercaseString">- lowercaseString</a><dt><a href="#//apple_ref/occ/instm/NSString/uppercaseString">- uppercaseString</a></dl></dd>

</dl></dd></dl></dd></dl></dd><dt>Getting C strings<dd><dl><dd><dl><dd><dl><dd><dl>

<dt><a href="#//apple_ref/occ/instm/NSString/cString">- cString</a><dt><a href="#//apple_ref/occ/instm/NSString/lossyCString">- lossyCString</a><dt><a href="#//apple_ref/occ/instm/NSString/cStringLength">- cStringLength</a><dt><a href="#//apple_ref/occ/instm/NSString/getCString:">- getCString:</a><dt><a href="#//apple_ref/occ/instm/NSString/getCString:maxLength:">- getCString:maxLength:</a><dt><a href="#//apple_ref/occ/instm/NSString/getCString:maxLength:range:remainingRange:">- getCString:maxLength:range:remainingRange:</a></dl></dd>

</dl></dd></dl></dd></dl></dd><dt>Getting numeric values<dd><dl><dd><dl><dd><dl><dd><dl>

<dt><a href="#//apple_ref/occ/instm/NSString/doubleValue">- doubleValue</a><dt><a href="#//apple_ref/occ/instm/NSString/floatValue">- floatValue</a><dt><a href="#//apple_ref/occ/instm/NSString/intValue">- intValue</a></dl></dd>

</dl></dd></dl></dd></dl></dd><dt>Working with encodings<dd><dl><dd><dl><dd><dl><dd><dl>

<dt><a href="#//apple_ref/occ/clm/NSString/availableStringEncodings">+ availableStringEncodings</a><dt><a href="#//apple_ref/occ/clm/NSString/defaultCStringEncoding">+ defaultCStringEncoding</a><dt><a href="#//apple_ref/occ/clm/NSString/localizedNameOfStringEncoding:">+ localizedNameOfStringEncoding:</a><dt><a href="#//apple_ref/occ/instm/NSString/canBeConvertedToEncoding:">- canBeConvertedToEncoding:</a><dt><a href="#//apple_ref/occ/instm/NSString/dataUsingEncoding:">- dataUsingEncoding:</a><dt><a href="#//apple_ref/occ/instm/NSString/dataUsingEncoding:allowLossyConversion:">- dataUsingEncoding:allowLossyConversion:</a><dt><a href="#//apple_ref/occ/instm/NSString/description">- description</a><dt><a href="#//apple_ref/occ/instm/NSString/fastestEncoding">- fastestEncoding</a><dt><a href="#//apple_ref/occ/instm/NSString/smallestEncoding">- smallestEncoding</a></dl></dd>

</dl></dd></dl></dd></dl></dd><dt><a name="689">Working with paths</a><dd><dl><dd><dl><dd><dl><dd><dl>

<dt><a href="#//apple_ref/occ/clm/NSString/pathWithComponents:">+ pathWithComponents:</a><dt><a href="#//apple_ref/occ/instm/NSString/pathComponents">- pathComponents</a><dt><a href="#//apple_ref/occ/instm/NSString/completePathIntoString:caseSensitive:matchesIntoArray:filterTypes:">- completePathIntoString:caseSensitive:<br>matchesIntoArray:filterTypes:</a><dt><a href="#//apple_ref/occ/instm/NSString/fileSystemRepresentation">- fileSystemRepresentation</a><dt><a href="#//apple_ref/occ/instm/NSString/getFileSystemRepresentation:maxLength:">- getFileSystemRepresentation:maxLength:</a><dt><a href="#//apple_ref/occ/instm/NSString/isAbsolutePath">- isAbsolutePath</a><dt><a href="#//apple_ref/occ/instm/NSString/lastPathComponent">- lastPathComponent</a><dt><a href="#//apple_ref/occ/instm/NSString/pathExtension">- pathExtension</a><dt><a href="#//apple_ref/occ/instm/NSString/stringByAbbreviatingWithTildeInPath">- stringByAbbreviatingWithTildeInPath</a><dt><a href="#//apple_ref/occ/instm/NSString/stringByAppendingPathComponent:">- stringByAppendingPathComponent:</a><dt><a href="#//apple_ref/occ/instm/NSString/stringByAppendingPathExtension:">- stringByAppendingPathExtension:</a><dt><a href="#//apple_ref/occ/instm/NSString/stringByDeletingLastPathComponent">- stringByDeletingLastPathComponent</a><dt><a href="#//apple_ref/occ/instm/NSString/stringByDeletingPathExtension">- stringByDeletingPathExtension</a>

<dt><a href="#//apple_ref/occ/instm/NSString/stringByExpandingTildeInPath">- stringByExpandingTildeInPath</a><dt><a href="#//apple_ref/occ/instm/NSString/stringByResolvingSymlinksInPath">- stringByResolvingSymlinksInPath</a>

<dt><a href="#//apple_ref/occ/instm/NSString/stringByStandardizingPath">- stringByStandardizingPath</a><dt><a href="#//apple_ref/occ/instm/NSString/stringsByAppendingPaths:">- stringsByAppendingPaths:</a></dl></dd>

</dl></dd></dl></dd></dl></dd><dt>Writing to a file<dd><dl><dd><dl><dd><dl><dd><dl>

<dt><a href="#//apple_ref/occ/instm/NSString/writeToFile:atomically:">- writeToFile:atomically:</a></dl></dd>

</dl></dd></dl></dd></dl></dd></dl>

<HR WIDTH="50%" ALIGN="LEFT">

<a name="709"></a>

<a name="clm"></a>

<h2>Class Methods</h2>  





<a name="710"></a>

<h3>

 <a name="//apple_ref/occ/clm/NSString/availableStringEncodings">availableStringEncodings</a>

</h3>

+ (const NSStringEncoding *)<code>availableStringEncodings</code>

<P>Returns a zero-terminated list of the encodings that string objects support in the application's environment. Among the more commonly used are:<p>

NSASCIIStringEncoding<br>NSNEXTSTEPStringEncoding<br>NSUnicodeStringEncoding<br>NSISOLatin1StringEncoding<br>NSISOLatin2StringEncoding<br>NSSymbolStringEncoding<p>

See the "Types and Constants" section of the Foundation Kit documentation for a complete list and descriptions of supported encodings.<p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/clm/NSString/localizedNameOfStringEncoding:">+ localizedNameOfStringEncoding:</a>

</code><p><hr WIDTH="25%" ALIGN="LEFT">

<a name="716"></a>

<h3> <a name="//apple_ref/occ/clm/NSString/defaultCStringEncoding">defaultCStringEncoding</a></h3>

+ (NSStringEncoding)<code>defaultCStringEncoding</code>

<P>Returns the C string encoding assumed for any method accepting a C string as an argument (these methods use <code>CString</code> in the keywords for such arguments; for example, <code>stringWithCString:</code>). The default C string encoding is determined from system information, and can't be changed programmatically for an individual process. See the description of NSStringEncoding in the "Types and Constants" section for a full list of supported encodings.<p>

<hr WIDTH="25%" ALIGN="LEFT">

<a name="719"></a>

<h3> <a name="//apple_ref/occ/clm/NSString/localizedNameOfStringEncoding:">localizedNameOfStringEncoding:</a></h3>

+ (NSString *)<code>localizedNameOfStringEncoding:</code>(NSStringEncoding)<em>encoding</em>

<P>Returns a human-readable string giving the name of <em>encoding</em> in the current locale's language. See "Locales" in the "Other Features" section of the Foundation Kit documentation for more information on locales.<p>

<hr WIDTH="25%" ALIGN="LEFT">

<a name="722"></a>

<h3> <a name="//apple_ref/occ/clm/NSString/localizedStringWithFormat:">localizedStringWithFormat:</a></h3>

+ (NSString *)<code>localizedStringWithFormat:</code>(NSString *)<em>format, ...</em>

<P>Returns a string created by using <em>format</em> as a template into which the following argument values are substituted according to the formatting information of the current locale. For example, this code excerpt creates a string from another string and an <code>int</code>:<p>

<blockquote><pre>NSString *myString = [NSString localizedStringWithFormat:@"%@: %d\n",<br>        @"Cost", 32];

</pre></blockquote><p>The resulting string has the value "Cost: 32\n".<p>

See <a href="#559">"Creating and Converting String Objects"</a> in the class cluster description for more information.<p>

<hr WIDTH="25%" ALIGN="LEFT">

<a name="728"></a>

<h3><a name="//apple_ref/occ/clm/NSString/pathWithComponents:">pathWithComponents:</a></h3>

+ (NSString *)<code>pathWithComponents:</code>(NSArray *)<em>components</em>

<P>Returns a string built from the strings in <em>components</em>, by concatenating them with a path separator between each pair. To create an absolute path, use a slash mark "/" as the first component. To include a trailing path divider, use an empty string as the last component. This method doesn't clean up the path created; use <code>stringByStandardizingPath</code> to resolve empty components, references to the parent directory, and so on.<p>

On systems that require an explicit root device for an absolute path, this method add a default device specifier (such as "C:" on Windows systems).<p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/instm/NSString/pathComponents">- pathComponents</a>

</code><p><hr WIDTH="25%" ALIGN="LEFT">

<a name="733"></a>

<h3><a name="//apple_ref/occ/clm/NSString/string">string</a></h3>

+ (id)<code>string</code>

<P>Returns an empty string.<p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/instm/NSString/init">- init</a>

</code><p><hr WIDTH="25%" ALIGN="LEFT">

<a name="737"></a>

<h3> <a name="//apple_ref/occ/clm/NSString/stringWithCharacters:length:">stringWithCharacters:length:</a></h3>

+ (id)<code>stringWithCharacters:</code>(const unichar *)<em>chars</em> <code>length:</code>(unsigned int)<em>length</em>

<P>Returns a string containing <em>length</em> characters taken from <em>chars</em>, which may not be NULL. This method doesn't stop short at a zero character.<p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/instm/NSString/initWithCharacters:length:">- initWithCharacters:length:</a>

</code><p><hr WIDTH="25%" ALIGN="LEFT">

<a name="741"></a>

<h3> <a name="//apple_ref/occ/clm/NSString/stringWithContentsOfFile:">stringWithContentsOfFile:</a></h3>

+ (id)<code>stringWithContentsOfFile:</code>(NSString *)<em>path</em> 

<P>Returns a string created by reading characters from the file named by <em>path</em>. If the contents begin with a byte-order mark (U+FEFF or U+FFFE), interprets the contents as Unicode characters; otherwise interprets the contents as characters in the default C string encoding. Returns <code>nil</code> if the file can't be opened.<p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/instm/NSString/initWithContentsOfFile:">- initWithContentsOfFile:</a></code>, <a href="#//apple_ref/occ/clm/NSString/defaultCStringEncoding"><code>+ defaultCStringEncoding</a>

</code><p><hr WIDTH="25%" ALIGN="LEFT">

<a name="745"></a>

<h3> <a name="//apple_ref/occ/clm/NSString/stringWithCString:">stringWithCString:</a></h3>

+ (id)<code>stringWithCString:</code>(const char *)<em>cString</em>

<P>Returns a string containing derived from the characters in <em>cString</em>, which must end with a zero character and which may not be NULL. <em>cString</em> should contain characters in the default C string encoding. If the argument passed to <code>stringWithCString</code> is not a NULL-terminated C string, the results are undefined.<p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/instm/NSString/initWithCString:">- initWithCString:</a></code>, <a href="#//apple_ref/occ/clm/NSString/defaultCStringEncoding"><code>+ defaultCStringEncoding</a>

</code><p><hr WIDTH="25%" ALIGN="LEFT">

<a name="749"></a>

<h3> <a name="//apple_ref/occ/clm/NSString/stringWithCString:length:">stringWithCString:length:</a></h3>

+ (id)<code>stringWithCString:</code>(const char *)<em>cString</em> <code>length:</code>(unsigned int)<em>length</em>

<P>Returns a string containing characters derived from <em>cString</em>, which may not be NULL. <em>cString</em> should contain characters in the default C string encoding. This method converts <em>length</em> * <code>sizeof(char)</code> bytes from <em>cString</em>, and doesn't stop short at a zero character.<p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/instm/NSString/initWithCString:length:">- initWithCString:length:</a></code>, <a href="#//apple_ref/occ/clm/NSString/defaultCStringEncoding"><code>+ defaultCStringEncoding</a>

</code><p><hr WIDTH="25%" ALIGN="LEFT">

<a name="753"></a>

<h3> <a name="//apple_ref/occ/clm/NSString/stringWithFormat:">stringWithFormat:</a></h3>

+ (id)<code>stringWithFormat:</code>(NSString *)<em>format</em>, <em>.</em>..

<P>Returns a string created in the manner of <code>localizedStringWithFormat:</code>, but using the default locale to format numbers. See <a href="#559">"Creating and Converting String Objects"</a> in the class cluster description for more information.<p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/instm/NSString/initWithFormat:">- initWithFormat:</a>

</code><p><hr WIDTH="25%" ALIGN="LEFT">

<a name="757"></a>

<h3><a name="//apple_ref/occ/clm/NSString/stringWithString:">stringWithString:</a></h3>

+ (id)<code>stringWithString:</code>(NSString *)<em>aString</em>

<P>Returns a string created by copying the characters from <em>aString</em>.<p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/instm/NSString/initWithString:">- initWithString:</a>

</code><p><HR WIDTH="50%" ALIGN="LEFT">

<a name="instm"></a>

<h2>Instance Methods</h2>  





<a name="762"></a>

<h3>

 <a name="//apple_ref/occ/instm/NSString/canBeConvertedToEncoding:">canBeConvertedToEncoding:</a>

</h3>

- (BOOL)<code>canBeConvertedToEncoding:</code>(NSStringEncoding)<em>encoding</em>

<P>Returns YES if the receiver can be converted to <em>encoding</em> without loss of information. Returns NO if characters would have to be changed or deleted in the process of changing encodings.<p>

If you plan to actually convert a string, the <code>dataUsingEncoding:...</code> methods simply return <code>nil</code> on failure, so you can avoid the overhead of invoking this method yourself by simply trying to convert the string.<p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/instm/NSString/dataUsingEncoding:allowLossyConversion:">- dataUsingEncoding:allowLossyConversion:</a>

</code><p><hr WIDTH="25%" ALIGN="LEFT">

<a name="767"></a>

<h3> <a name="//apple_ref/occ/instm/NSString/capitalizedString">capitalizedString</a></h3>

- (NSString *)<code>capitalizedString</code>

<P>Returns a string with the first character from each word in the receiver changed to its corresponding uppercase value, and all remaining characters set to their corresponding lowercase values. A "word" here is any sequence of characters delimited by spaces, tabs, or line terminators (listed under <code>getLineStart:end:contentsEnd:forRange:</code>). Other common word delimiters such as hyphens and other punctuation aren't considered, so this method may not generally produce the desired results for multi-word strings.<p>

Case transformations aren't guaranteed to be symmetrical or to produce strings of the same lengths as the originals. See <code>lowercaseString</code> for an example.<p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/instm/NSString/lowercaseString">- lowercaseString</a></code>, <a href="#//apple_ref/occ/instm/NSString/uppercaseString"><code>- uppercaseString</a>

</code><p><hr WIDTH="25%" ALIGN="LEFT">

<a name="772"></a>

<h3> <a name="//apple_ref/occ/instm/NSString/caseInsensitiveCompare:">caseInsensitiveCompare:</a></h3>

- (NSComparisonResult)<code>caseInsensitiveCompare:</code>(NSString *)<em>aString</em>

<P>This convenience method invokes <code>compare:options:</code> with NSCaseInsensitiveSearch as the only option.<p>

<hr WIDTH="25%" ALIGN="LEFT">

<a name="775"></a>

<h3> <a name="//apple_ref/occ/instm/NSString/characterAtIndex:">characterAtIndex:</a></h3>

- (unichar)<code>characterAtIndex:</code>(unsigned int)<em>index</em>

<P>Returns the character at the array position given by <em>index</em>. Raises an NSRangeException if <em>index</em> lies beyond the end of the string.<p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/instm/NSString/getCharacters:">- getCharacters:</a></code>, <a href="#//apple_ref/occ/instm/NSString/getCharacters:range:"><code>- getCharacters:range:</a>

</code><p><hr WIDTH="25%" ALIGN="LEFT">

<a name="779"></a>

<h3> <a name="//apple_ref/occ/instm/NSString/commonPrefixWithString:options:">commonPrefixWithString:options:</a></h3>

- (NSString *)<code>commonPrefixWithString:</code>(NSString *)<em>aString<br></em><code>options:</code>(unsigned int)<em>mask</em>

<P>Returns a string containing characters that the receiver and <em>aString</em> have in common, starting from the beginning of each up to the first characters that aren't equivalent. The returned string is based on the characters of the receiver. For example, if the receiver is "Ma&#168;dchen" and <em>aString</em> is "M&auml;dchenschule", the string returned is "Ma&#168;dchen", not "M&auml;dchen". The following search options may be specified in <em>mask</em> by combining them with the C bitwise OR operator:<p>

NSCaseInsensitiveSearch<br>NSLiteralSearch<p>

See <a href="#571">"Working with String Objects"</a> in the class cluster description for details on these options.<p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/instm/NSString/hasPrefix:">- hasPrefix:</a>

</code><p><hr WIDTH="25%" ALIGN="LEFT">

<a name="785"></a>

<h3> <a name="//apple_ref/occ/instm/NSString/compare:">compare:</a></h3>

- (NSComparisonResult)<code>compare:</code>(NSString *)<em>aString</em>

<P>Invokes <code>compare:options:</code> with no options.<p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/instm/NSString/compare:options:range:">- compare:options:range:</a></code>, <a href="#//apple_ref/occ/instm/NSString/caseInsensitiveCompare:"><code>- caseInsensitiveCompare:</a></code>, <a href="#//apple_ref/occ/instm/NSString/isEqualToString:"><code>- isEqualToString:</a>

</code><p><hr WIDTH="25%" ALIGN="LEFT">

<a name="789"></a>

<h3> <a name="//apple_ref/occ/instm/NSString/compare:options:">compare:options:</a></h3>

- (NSComparisonResult)<code>compare:</code>(NSString *)<em>aString</em> <code>options:</code>(unsigned int)<em>mask</em>

<P>Invokes <code>compare:options:range:</code> with <em>mask</em> as the options and the receiver's full extent as the range.<p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/instm/NSString/caseInsensitiveCompare:">- caseInsensitiveCompare:</a></code>, <a href="#//apple_ref/occ/instm/NSString/isEqualToString:"><code>- isEqualToString:</a>

</code><p><hr WIDTH="25%" ALIGN="LEFT">

<a name="793"></a>

<h3> <a name="//apple_ref/occ/instm/NSString/compare:options:range:">compare:options:range:</a></h3>

- (NSComparisonResult)<code>compare:</code>(NSString *)<em>aString<br></em><code>options:</code>(unsigned int)<em>mask<br></em><code>range:</code>(NSRange)<em>aRange</em>

<P>Returns NSOrderedAscending if the substring of the receiver given by <em>aRange</em> precedes <em>aString</em> in lexical ordering, NSOrderedSame if the substring of the receiver and <em>aString</em> are equivalent in lexical value, and NSOrderedDescending if the substring of the receiver follows <em>aString</em>. You can specify the following options in <em>mask</em> by combining them with the C bitwise OR operator:<p>

NSCaseInsensitiveSearch<br>NSLiteralSearch<p>

See <a href="#571">"Working with String Objects"</a> in the class cluster description for details on these options.<p>

Raises an NSRangeException if any part of <em>aRange</em> lies beyond the end of the string.<p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/instm/NSString/caseInsensitiveCompare:">- caseInsensitiveCompare:</a></code>, <a href="#//apple_ref/occ/instm/NSString/isEqualToString:"><code>- isEqualToString:</a>

</code><p><hr WIDTH="25%" ALIGN="LEFT">

<a name="800"></a>

<h3> <a name="//apple_ref/occ/instm/NSString/completePathIntoString:caseSensitive:matchesIntoArray:filterTypes:">completePathIntoString:caseSensitive:matchesIntoArray:filterTypes:</a></h3>

- (unsigned int)<code>completePathIntoString:</code>(NSString **)<em>outputName<br></em><code>caseSensitive:</code>(BOOL)<em>flag<br></em><code>matchesIntoArray:</code>(NSArray **)<em>outputArray</em> <br><code>filterTypes:</code>(NSArray *)<em>filterTypes</em>

<P>Attempts to perform file- name completion on the receiver, interpreting it as a path in the file system and returning by reference in <em>outputName</em> the longest path that matches the receiver. Considers case if <em>flag</em> is YES. If <em>outputArray</em> is non-NULL, returns all matching file names in an NSArray given by <em>outputArray</em>. If an array of strings is provided in <em>filterTypes</em>, considers only paths whose extensions (not including the extension separator) match one of those strings.<p>

Returns 0 if no matches are found and 1 if exactly one match is found. In the case of multiple matches, returns the actual number of matching paths if <em>outputArray</em> is provided, or simply a positive value if <em>outputArray</em> is NULL. Hence, you can check for the existence of matches without retrieving by passing NULL as <em>outputArray</em> <p>

<hr WIDTH="25%" ALIGN="LEFT">

<a name="804"></a>

<h3> <a name="//apple_ref/occ/instm/NSString/componentsSeparatedByString:">componentsSeparatedByString:</a></h3>

- (NSArray *)<code>componentsSeparatedByString:</code>(NSString *)<em>separator</em>

<P>Returns an NSArray containing substrings from the receiver that have been divided by <em>separator</em>. The substrings in the array appear in the order they did in the receiver. If the string begins or ends with the separator, the first or last substring, respectively, is empty. For example, this code excerpt:<p>

<blockquote><pre>NSString *list = @"wrenches, hammers, saws";<br>NSArray *listItems = [list componentsSeparatedByString:@", "];

</pre></blockquote><p>produces an array with these contents:<p>

<Table Border="3">

<caption></caption>

<tr><th><b>Index</b>

</th><th><b>Substring</b>

</th></tr>

<tr><td scope="row">0

</td><td>wrenches

</td></tr>

<tr><td scope="row">1

</td><td>hammers

</td></tr>

<tr><td scope="row">2

</td><td>saws

</td></tr>



</Table>



<Table>

<tr><td scope="row">

</Table>

<p>

If <code>list</code> begins with a comma and space-for example, ", wrenches, hammers, saws"-the array has these contents:<p>

<Table Border="3">

<caption></caption>

<tr><th><b>Index</b>

</th><th><b>Substring</b>

</th></tr>

<tr><td scope="row">0

</td><td><em>(empty string)</em> 

</td></tr>

<tr><td scope="row">1

</td><td>wrenches

</td></tr>

<tr><td scope="row">2

</td><td>hammers

</td></tr>

<tr><td scope="row">3

</td><td>saws

</td></tr>



</Table>



<Table>

<tr><td scope="row">

</Table>

<p>

If <code>list</code> has no separators-for example, "wrenches"-the array contains the string itself, in this case "wrenches".<p>

<B>See also: </B>  

<code><a href="../NSArrayClassCluster/NSArrayClassCluster.html#//apple_ref/occ/instm/NSArray/componentsJoinedByString:" target="_top">- componentsJoinedByString:</code> (NSArray class cluster)</a>, <a href="#//apple_ref/occ/instm/NSString/pathComponents"><code>- pathComponents</a>

</code><p><hr WIDTH="25%" ALIGN="LEFT">

<a name="812"></a>

<h3> <a name="//apple_ref/occ/instm/NSString/cString">cString</a></h3>

- (const char *)<code>cString</code>

<P>Returns a representation of the receiver as a C string in the default C string encoding. The returned C string will be automatically freed just as a returned object would be released; your code should copy the C string or use <code>getCString:</code> if it needs to store the C string outside of the autorelease context in which the C string is created.<p>

Raises an NSCharacterConversionException if the receiver can't be represented in the default C string encoding without loss of information. Use <code>canBeConvertedToEncoding:</code> if necessary to check whether a string can be losslessly converted to the default C string encoding. If it can't, use <code>lossyCString</code> or <code>dataUsingEncoding:allowLossyConversion:</code> to get a C string representation with some loss of information.<p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/instm/NSString/getCString:">- getCString:</a></code>, <a href="#//apple_ref/occ/instm/NSString/canBeConvertedToEncoding:"><code>- canBeConvertedToEncoding:</a></code>, <a href="#//apple_ref/occ/clm/NSString/defaultCStringEncoding"><code>+ defaultCStringEncoding</a></code>, <a href="#//apple_ref/occ/instm/NSString/cStringLength"><code>- cStringLength</a></code>, 

<code><a href="#//apple_ref/occ/instm/NSString/getCharacters:">- getCharacters:</a>

</code><p><hr WIDTH="25%" ALIGN="LEFT">

<a name="817"></a>

<h3> <a name="//apple_ref/occ/instm/NSString/cStringLength">cStringLength</a></h3>

- (unsigned int)<code>cStringLength</code>

<P>Returns the length in <code>char</code>-sized units of the receiver's C string representation in the default C string encoding.<p>

Raises 0 if the receiver can't be represented in the default C string encoding without loss of information. You can also use <code>canBeConvertedToEncoding:</code> to check whether a string can be losslessly converted to the default C string encoding. If it can't, use <code>lossyCString</code> to get a C string representation with some loss of information, then check its length explicitly using the ANSI function <code>strlen()</code>.<p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/instm/NSString/cString">- cString</a></code>, <a href="#//apple_ref/occ/instm/NSString/canBeConvertedToEncoding:"><code>- canBeConvertedToEncoding:</a></code>, <a href="#//apple_ref/occ/clm/NSString/defaultCStringEncoding"><code>+ defaultCStringEncoding</a></code>, <a href="#//apple_ref/occ/instm/NSString/length"><code>- length</a>

</code><p><hr WIDTH="25%" ALIGN="LEFT">

<a name="822"></a>

<h3> <a name="//apple_ref/occ/instm/NSString/dataUsingEncoding:">dataUsingEncoding:</a></h3>

- (NSData *)<code>dataUsingEncoding:</code>(NSStringEncoding)<em>encoding</em>

<P>Invokes <code>dataUsingEncoding:allowLossyConversion:</code> with NO as the argument for allowing lossy conversion.<p>

<hr WIDTH="25%" ALIGN="LEFT">

<a name="825"></a>

<h3> <a name="//apple_ref/occ/instm/NSString/dataUsingEncoding:allowLossyConversion:">dataUsingEncoding:allowLossyConversion:</a></h3>

- (NSData *)<code>dataUsingEncoding:</code>(NSStringEncoding)<em>encoding<br></em><code>allowLossyConversion:</code>(BOOL)<em>flag</em>

<P>Returns an NSData object containing a representation of the receiver in <em>encoding</em>. Returns <code>nil</code> if <em>flag</em> is NO and the receiver can't be converted without losing some information (such as accents or case). If <em>flag</em> is YES and the receiver can't be converted without losing some information, some characters may be removed or altered in conversion. For example, in converting a character from NSUnicodeStringEncoding to NSASCIIStringEncoding, the character `&Aacute;' becomes `A', losing the accent.<p>

The result of this method, when lossless conversion is made, is the default "plain text" format for <em>encoding</em> and is the recommended way to save or transmit a string object.<p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/instm/NSString/canBeConvertedToEncoding:">- canBeConvertedToEncoding:</a>

</code><p><hr WIDTH="25%" ALIGN="LEFT">

<a name="830"></a>

<h3> <a name="//apple_ref/occ/instm/NSString/description">description</a></h3>

@protocol NSObject

<P>- (NSString *)<code>description</code>

<P>Returns <code>self</code>.<p>

<hr WIDTH="25%" ALIGN="LEFT">

<a name="834"></a>

<h3> <a name="//apple_ref/occ/instm/NSString/doubleValue">doubleValue</a></h3>

- (double)<code>doubleValue</code>

<P>Returns the floating-point value of the receiver's text as a <code>double</code>, skipping whitespace at the beginning of the string. Returns HUGE_VAL or -HUGE_VAL on overflow, 0.0 on underflow. Also returns 0.0 if the receiver doesn't begin with a valid text representation of a floating-point number.<p>

This method uses formatting information stored in the default locale; use an NSScanner for localized scanning of numeric values from a string.<p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/instm/NSString/intValue">- intValue</a></code>,<code> <a href="#//apple_ref/occ/instm/NSString/floatValue">- floatValue</a></code>, <code><a href="../NSScannerClassCluster/NSScannerClassCluster.html#//apple_ref/occ/instm/NSScanner/scanDouble:" target="_top">- scanDouble: </code>(NSScanner)</a>

<p><hr WIDTH="25%" ALIGN="LEFT">

<a name="839"></a>

<h3> <a name="//apple_ref/occ/instm/NSString/fastestEncoding">fastestEncoding</a></h3>

- (NSStringEncoding)<code>fastestEncoding</code>

<P>Returns the fastest encoding to which the receiver may be converted without loss of information. "Fastest" applies to retrieval of characters from the string. This encoding may not be space efficient.<p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/instm/NSString/smallestEncoding">- smallestEncoding</a></code>, <a href="#//apple_ref/occ/instm/NSString/getCharacters:range:"><code>- getCharacters:range:</a>

</code><p><hr WIDTH="25%" ALIGN="LEFT">

<a name="843"></a>

<h3> <a name="//apple_ref/occ/instm/NSString/fileSystemRepresentation">fileSystemRepresentation</a></h3>

- (const char *)<code>fileSystemRepresentation</code>

<P>Returns a file system specific representation of the receiver, as described for <code>getFileSystemRepresentation:maxLength:</code>. The returned C string will be automatically freed just as a returned object would be released; your code should copy the representation or use <code>getFileSystemRepresentation:maxLength:</code> if it needs to store the representation outside of the autorelease context in which the representation is created.<p>

Raises an NSCharacterConversionException if the receiver can't be represented in the file system's encoding.<p>

<hr WIDTH="25%" ALIGN="LEFT">

<a name="847"></a>

<h3> <a name="//apple_ref/occ/instm/NSString/floatValue">floatValue</a></h3>

- (float)<code>floatValue</code>

<P>Returns the floating-point value of the receiver's text as a <code>float</code>, skipping whitespace at the beginning of the string. Returns HUGE_VAL or -HUGE_VAL on overflow, 0.0 on underflow. Also returns 0.0 if the receiver doesn't begin with a valid text representation of a floating-point number.<p>

This method uses formatting information stored in the default locale; use an NSScanner for localized scanning of numeric values from a string.<p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/instm/NSString/doubleValue">- doubleValue</a></code>,<code> <a href="#//apple_ref/occ/instm/NSString/intValue">- intValue</a></code>, <code><a href="../NSScannerClassCluster/NSScannerClassCluster.html#//apple_ref/occ/instm/NSScanner/scanFloat:" target="_top">- scanFloat: </code>(NSScanner)</a>

<p><hr WIDTH="25%" ALIGN="LEFT">

<a name="852"></a>

<h3> <a name="//apple_ref/occ/instm/NSString/getCharacters:">getCharacters:</a></h3>

- (void)<code>getCharacters:</code>(unichar *)<em>buffer</em>

<P>Invokes <code>getCharacters:range:</code> with <em>buffer</em> and the entire extent of the receiver as the range. <em>buffer</em> must be large enough to contain all the characters in the string.<p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/instm/NSString/length">- length</a>

</code><p><hr WIDTH="25%" ALIGN="LEFT">

<a name="856"></a>

<h3> <a name="//apple_ref/occ/instm/NSString/getCharacters:range:">getCharacters:range:</a></h3>

- (void)<code>getCharacters:</code>(unichar *)<em>buffer</em> <code>range:</code>(NSRange)<em>aRange</em>

<P>Copies characters from <em>aRange</em> in the receiver into <em>buffer</em>, which must be large enough to contain them. Does not add a zero character. Raises an NSRangeException if any part of <em>aRange</em> lies beyond the end of the string.<p>

The abstract implementation of this method uses <code>characterAtIndex:</code> repeatedly, correctly extracting the characters, though very inefficiently. Subclasses should override it to provide a fast implementation.<p>

<hr WIDTH="25%" ALIGN="LEFT">

<a name="860"></a>

<h3> <a name="//apple_ref/occ/instm/NSString/getCString:">getCString:</a></h3>

- (void)<code>getCString:</code>(char *)<em>buffer</em>

<P>Invokes <code>getCString:maxLength:range:remainingRange:</code> with NSMaximumStringLength as the maximum length, the receiver's entire extent as the range, and NULL for the remaining range. <em>buffer</em> must be large enough to contain the resulting C string plus a terminating zero character (which this method adds).<p>

Raises an NSCharacterConversionException if the receiver can't be represented in the default C string encoding without loss of information. Use <code>canBeConvertedToEncoding:</code> if necessary to check whether a string can be losslessly converted to the default C string encoding. If it can't, use <code>lossyCString</code> or <code>dataUsingEncoding:allowLossyConversion:</code> to get a C string representation with some loss of information.<p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/instm/NSString/cStringLength">- cStringLength</a></code>, <a href="#//apple_ref/occ/instm/NSString/canBeConvertedToEncoding:"><code>- canBeConvertedToEncoding:</a></code>, <a href="#//apple_ref/occ/clm/NSString/defaultCStringEncoding"><code>+ defaultCStringEncoding</a></code>, 

<code><a href="#//apple_ref/occ/instm/NSString/getCharacters:">- getCharacters:</a>

</code><p><hr WIDTH="25%" ALIGN="LEFT">

<a name="865"></a>

<h3> <a name="//apple_ref/occ/instm/NSString/getCString:maxLength:">getCString:maxLength:</a></h3>

- (void)<code>getCString:</code>(char *)<em>buffer</em> <code>maxLength:</code>(unsigned int)<em>maxLength</em>

<P>Invokes <code>getCString:maxLength:range:remainingRange:</code> with <em>maxLength</em> as the maximum length in <code>char</code>-sized units, the receiver's entire extent as the range, and NULL for the remaining range. <em>buffer</em> must be large enough to contain <em>maxLength</em> <code>char</code>s plus a terminating zero <code>char</code> (which this method adds).<p>

Raises an NSCharacterConversionException if the receiver can't be represented in the default C string encoding without loss of information. Use <code>canBeConvertedToEncoding:</code> if necessary to check whether a string can be losslessly converted to the default C string encoding. If it can't, use <code>lossyCString</code> or <code>dataUsingEncoding:allowLossyConversion:</code> to get a C string representation with some loss of information.<p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/instm/NSString/cStringLength">- cStringLength</a></code>, <a href="#//apple_ref/occ/instm/NSString/canBeConvertedToEncoding:"><code>- canBeConvertedToEncoding:</a></code>, <a href="#//apple_ref/occ/clm/NSString/defaultCStringEncoding"><code>+ defaultCStringEncoding</a></code>, 

<code><a href="#//apple_ref/occ/instm/NSString/getCharacters:">- getCharacters:</a>

</code><p><hr WIDTH="25%" ALIGN="LEFT">

<a name="870"></a>

<h3> <a name="//apple_ref/occ/instm/NSString/getCString:maxLength:range:remainingRange:">getCString:maxLength:range:remainingRange:</a></h3>

- (void)<code>getCString:</code>(char *)<em>buffer<br></em><code>maxLength:</code>(unsigned int)<em>maxLength<br></em><code>range:</code>(NSRange)<em>aRange<br></em><code>remainingRange:</code>(NSRange *)<em>leftoverRange</em>

<P>Converts the receiver's characters to the default C string encoding and stores them in <em>buffer</em>. <em>buffer</em> must be large enough to contain <em>maxLength</em> <code>char</code>s plus a terminating zero <code>char</code> (which this method adds). Copies and converts as many character as possible from <em>aRange</em>, and stores the range of those not converted in the NSRange given by <em>leftoverRange</em> (if it's non-NULL). Raises an NSRangeException if any part of <em>aRange</em> lies beyond the end of the string.<p>

Raises an NSCharacterConversionException if the receiver can't be represented in the default C string encoding without loss of information. Use <code>canBeConvertedToEncoding:</code> if necessary to check whether a string can be losslessly converted to the default C string encoding. If it can't, use <code>lossyCString</code> or <code>dataUsingEncoding:allowLossyConversion:</code> to get a C string representation with some loss of information.<p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/instm/NSString/cStringLength">- cStringLength</a></code>, <a href="#//apple_ref/occ/instm/NSString/canBeConvertedToEncoding:"><code>- canBeConvertedToEncoding:</a></code>, <a href="#//apple_ref/occ/clm/NSString/defaultCStringEncoding"><code>+ defaultCStringEncoding</a></code>, 

<code><a href="#//apple_ref/occ/instm/NSString/getCharacters:">- getCharacters:</a>

</code><p><hr WIDTH="25%" ALIGN="LEFT">

<a name="875"></a>

<h3> <a name="//apple_ref/occ/instm/NSString/getFileSystemRepresentation:maxLength:">getFileSystemRepresentation:maxLength:</a></h3>

- (BOOL)<code>getFileSystemRepresentation:</code>(char *)<em>buffer</em> <code>maxLength:</code>(unsigned int)<em>maxLength</em>

<P>Interprets the receiver as a system-independent path, filling <em>buffer</em> with a C string in a format and encoding suitable for use with file system calls. This is done by replacing the abstract path and extension separator characters (`/' and `.' respectively) with their equivalents for the operating system. For example, on Microsoft Windows 95 the receiver "C:/Working/Sample.tiff" is returned as the C string "C:\Working\Sample.tiff".<p>

<em>buffer</em> must be large enough to contain <em>maxLength</em> <code>char</code>s plus a terminating zero <code>char</code> (which this method adds). Returns YES if <em>buffer</em> is successfully filled with a file system representation, NO if not (for example, if <em>maxLength</em> would be exceeded). Also returns NO if the receiver can't be represented in the file system's encoding.<p>

If the system-specific path or extension separator appear in the abstract representation, the characters they're converted to depend on the system (unless they're identical to the abstract separators). On Windows 95, for example, a `\' character is converted to `/'.<p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/instm/NSString/fileSystemRepresentation">- fileSystemRepresentation</a>

</code><p><hr WIDTH="25%" ALIGN="LEFT">

<a name="881"></a>

<h3><a name="//apple_ref/occ/instm/NSString/getLineStart:end:contentsEnd:forRange:">getLineStart:end:contentsEnd:forRange:</a></h3>

+ (void)<code>getLineStart:</code>(unsigned int *)<em>startIndex<br></em><code>end:</code>(unsigned int *)<em>lineEndIndex<br></em><code>contentsEnd:</code>(unsigned int *)<em>contentsEndIndex<br></em><code>forRange:</code>(NSRange)<em>aRange</em>

<P>Returns by reference the indexes of the smallest range of lines containing <em>aRange</em>. A line is delimited by any of these characters, the longest possible sequence being preferred to any shorter:<p>

<ul><li><code>U+000D</code> (<code>\r</code> or CR)<br>

<li><code>U+2028</code> (Unicode line separator)<br>

<li><code>U+000A</code> (<code>\n</code> or LF)<br>

<li><code>U+2029</code> (Unicode paragraph separator)<br>

<li><code>\r\n</code>, in that order (also known as CRLF)<br>

</ul>When this method returns, <em>startIndex</em> contains the index of the first character of the line, which is at or before the location of <em>aRange;</em> <em>lineEndIndex</em> contains the index of the first character past the line terminator; and <em>contentsEndIndex</em> contains the index of the first character of the line terminator itself. You may pass a NULL pointer for any of these arguments, in which case the work to compute the value isn't performed.<p>

You can use the results of this method to construct ranges for lines by using the start index as the range's location and the difference between the end index and the start index as the range's length.<p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/instm/NSString/lineRangeForRange:">- lineRangeForRange:</a></code>

<p><hr WIDTH="25%" ALIGN="LEFT">

<a name="892"></a>

<h3> <a name="//apple_ref/occ/instm/NSString/hash">hash</a></h3>

- (unsigned int)<code>hash</code>

<P>Returns an unsigned integer that can be used as a hash table address. If two string objects are equal (as determined by the <code>isEqualToString:</code> method), they must have the same hash value. The abstract implementation of this method fulfills this requirement, so subclasses of NSString shouldn't override it.<p>

<hr WIDTH="25%" ALIGN="LEFT">

<a name="895"></a>

<h3> <a name="//apple_ref/occ/instm/NSString/hasPrefix:">hasPrefix:</a></h3>

- (BOOL)<code>hasPrefix:</code>(NSString *)<em>aString</em>

<P>Returns YES if <em>aString</em> matches the beginning characters of the receiver, NO otherwise. Returns NO if <em>aString</em> is the null string. This method is a convenience for comparing strings using the NSAnchoredSearch option. See <a href="#571">"Working with String Objects"</a> in the class cluster description for more information.<p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/instm/NSString/hasSuffix:">- hasSuffix:</a></code>, <a href="#//apple_ref/occ/instm/NSString/compare:options:range:"><code>- compare:options:range:</a>

</code><p><hr WIDTH="25%" ALIGN="LEFT">

<a name="899"></a>

<h3> <a name="//apple_ref/occ/instm/NSString/hasSuffix:">hasSuffix:</a></h3>

- (BOOL)<code>hasSuffix:</code>(NSString *)<em>aString</em>

<P>Returns YES if <em>aString</em> matches the ending characters of the receiver, NO otherwise. Returns NO if <em>aString</em> is the null string. This method is a convenience for comparing strings using the NSAnchoredSearch and NSBackwardsSearch options. See <a href="#571">"Working with String Objects"</a> in the class cluster description for more information.<p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/instm/NSString/hasPrefix:">- hasPrefix:</a></code>, <a href="#//apple_ref/occ/instm/NSString/compare:options:range:"><code>- compare:options:range:</a>

</code><p><hr WIDTH="25%" ALIGN="LEFT">

<a name="903"></a>

<h3> <a name="//apple_ref/occ/instm/NSString/init">init</a></h3>

- (id)<code>init</code>

<P>Initializes the receiver, a newly allocated NSString, to contain no characters. Returns <code>self</code>.<p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/clm/NSString/string">+ string</a>

</code><p><hr WIDTH="25%" ALIGN="LEFT">

<a name="907"></a>

<h3> <a name="//apple_ref/occ/instm/NSString/initWithCharacters:length:">initWithCharacters:length:</a></h3>

- (id)<code>initWithCharacters:</code>(const unichar *)<em>characters</em> <code>length:</code>(unsigned int)<em>length</em>

<P>Initializes the receiver, a newly allocated NSString, by copying <em>length</em> characters from <em>characters</em>, which may not be NULL. This method doesn't stop short at a zero character. Returns <code>self</code>.<p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/clm/NSString/stringWithCharacters:length:">+ stringWithCharacters:length:</a>

</code><p><hr WIDTH="25%" ALIGN="LEFT">

<a name="911"></a>

<h3> <a name="//apple_ref/occ/instm/NSString/initWithCharactersNoCopy:length:freeWhenDone:">initWithCharactersNoCopy:length:freeWhenDone:</a></h3>

- (id)<code>initWithCharactersNoCopy:</code>(unichar *)<em>characters<br></em><code>length:</code>(unsigned int)<em>length<br></em><code>freeWhenDone:</code>(BOOL)<em>flag</em>

<P>Initializes the receiver, a newly allocated NSString, to contain <em>length</em> characters from <em>characters</em>, which may not be NULL. This method doesn't stop short at a zero character. The receiver becomes the owner of <em>characters;</em> if <em>flag</em> is YES the receiver will free the memory when it no longer needs them, but if <em>flag</em> is NO it won't. Returns <code>self</code>.<p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/clm/NSString/stringWithCharacters:length:">+ stringWithCharacters:length:</a>

</code><p><hr WIDTH="25%" ALIGN="LEFT">

<a name="915"></a>

<h3> <a name="//apple_ref/occ/instm/NSString/initWithContentsOfFile:">initWithContentsOfFile:</a></h3>

- (id)<code>initWithContentsOfFile:</code>(NSString *)<em>path</em>

<P>Initializes the receiver, a newly allocated NSString, by reading characters from the file named by <em>path</em>. If the contents begin with a byte-order mark (U+FEFF or U+FFFE), interprets the contents as Unicode characters; otherwise interprets the contents as characters in the default C string encoding. Returns <code>self</code>, or <code>nil</code> if the file can't be opened.<p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/clm/NSString/stringWithContentsOfFile:">+ stringWithContentsOfFile:</a></code>, <a href="#//apple_ref/occ/clm/NSString/defaultCStringEncoding"><code>+ defaultCStringEncoding</a>

</code><p><hr WIDTH="25%" ALIGN="LEFT">

<a name="919"></a>

<h3> <a name="//apple_ref/occ/instm/NSString/initWithCString:">initWithCString:</a></h3>

- (id)<code>initWithCString:</code>(const char *)<em>cString</em>

<P>Initializes the receiver, a newly allocated NSString, by converting the characters in <em>cString</em> from the default C string encoding into the Unicode character encoding. <em>cString</em> must be a zero-terminated C string in the default C string encoding, and may not be NULL. Returns <code>self</code>.<p>

<B><dt>Note:	</B>

To create an immutable string from an immutable CString buffer, do not attempt to use this method. 

Instead, use <code>initWithCStringNoCopy</code>.

<B>See also: </B>  

<code><a href="#//apple_ref/occ/clm/NSString/stringWithCString:">+ stringWithCString:</a></code>, <a href="#//apple_ref/occ/instm/NSString/initWithCStringNoCopy:length:freeWhenDone:"><code>-initWithCStringNoCopy:length:freeWhenDone:</a></code>,<a href="#//apple_ref/occ/clm/NSString/defaultCStringEncoding"><code>+ defaultCStringEncoding</a>

</code><p><hr WIDTH="25%" ALIGN="LEFT">

<a name="924"></a>

<h3> <a name="//apple_ref/occ/instm/NSString/initWithCString:length:">initWithCString:length:</a></h3>

- (id)<code>initWithCString:</code>(const char *)<em>cString</em> <code>length:</code>(unsigned int)<em>length</em>

<P>Initializes the receiver, a newly allocated NSString, by converting the characters of <em>cString</em> from the default C string encoding into the Unicode character encoding. This method converts <em>length</em> * <code>sizeof(char)</code> bytes from <em>cString</em>, and doesn't stop short at a zero character. <em>cString</em> must contain bytes in the default C string encoding, and may not be NULL. Returns <code>self</code>.<p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/clm/NSString/stringWithCString:length:">+ stringWithCString:length:</a></code>, <a href="#//apple_ref/occ/clm/NSString/defaultCStringEncoding"><code>+ defaultCStringEncoding</a>

</code><p><hr WIDTH="25%" ALIGN="LEFT">

<a name="928"></a>

<h3> <a name="//apple_ref/occ/instm/NSString/initWithCStringNoCopy:length:freeWhenDone:">initWithCStringNoCopy:length:freeWhenDone:</a></h3>

- (id)<code>initWithCStringNoCopy:</code>(char *)<em>cString<br></em><code>length:</code>(unsigned int)<em>length<br></em><code>freeWhenDone:</code>(BOOL)<em>flag</em>

<P>Initializes the receiver, a newly allocated NSString, by converting the characters of <em>cString</em> from the default C string encoding into the Unicode character encoding. This method converts <em>length</em> * <code>sizeof(char)</code> bytes from <em>cString</em>, and doesn't stop short at a zero character. <em>cString</em> must be contain characters in the default C string encoding, and may not be NULL. The receiver becomes the owner of <em>cString;</em> if <em>flag</em> is YES it will free the memory when it no longer needs it, but if <em>flag</em> is NO it won't. Returns <code>self</code>.<p>

<B><dt>Note:	</B>

You can use this method to create an immutable string from an immutable (<code>const char*</code>) C-string 

buffer. If you receive a warning message, you can disregard it; its purpose is simply to warn you that 

the C string passed as the method's first argument may be modified. If you make certain that the 

<code>freeWhenDone</code> argument to <code>initWithStringNoCopy</code> is NO, the C string passed as the method's first 

argument cannot be modified, so you can safely use <code>initWithStringNoCopy</code> to create an immutable 

string from an immutable (<code>const char*</code>) C-string buffer.

<B>See also: </B>  

<code><a href="#//apple_ref/occ/clm/NSString/stringWithCString:length:">+ stringWithCString:length:</a></code>, <a href="#//apple_ref/occ/clm/NSString/defaultCStringEncoding"><code>+ defaultCStringEncoding</a>

</code><p><hr WIDTH="25%" ALIGN="LEFT">

<a name="933"></a>

<h3> <a name="//apple_ref/occ/instm/NSString/initWithData:encoding:">initWithData:encoding:</a></h3>

- (id)<code>initWithData:</code>(NSData *)<em>data</em> <code>encoding:</code>(NSStringEncoding)<em>encoding</em>

<P>Initializes the receiver, a newly allocated NSString, by converting the bytes in <em>data</em> into Unicode characters. <em>data</em> must be an NSData object containing bytes in <em>encoding</em> and in the default plain text format (that is, pure content with no attribute or other markup) for that encoding. Returns <code>self</code>.<p>

<hr WIDTH="25%" ALIGN="LEFT">

<a name="936"></a>

<h3> <a name="//apple_ref/occ/instm/NSString/initWithFormat:">initWithFormat:</a></h3>

- (id)<code>initWithFormat:</code>(NSString *)<em>format</em>, ...

<P>Invokes <code>initWithFormat:locale:arguments:</code> with <code>nil</code> as the locale.<p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/clm/NSString/stringWithFormat:">+ stringWithFormat:</a>

</code><p><hr WIDTH="25%" ALIGN="LEFT">

<a name="940"></a>

<h3> <a name="//apple_ref/occ/instm/NSString/initWithFormat:arguments:">initWithFormat:arguments:</a></h3>

- (id)<code>initWithFormat:</code>(NSString *)<em>format</em> <code>arguments:</code>(va_list)<em>argList</em>

<P>Invokes <code>initWithFormat:locale:arguments:</code> with <code>nil</code> as the locale.<p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/clm/NSString/stringWithFormat:">+ stringWithFormat:</a>

</code><p><hr WIDTH="25%" ALIGN="LEFT">

<a name="944"></a>

<h3> <a name="//apple_ref/occ/instm/NSString/initWithFormat:locale:">initWithFormat:locale:</a></h3>

- (id)<code>initWithFormat:</code>(NSString *)<em>format</em> <br><code>locale:</code>(NSDictionary *)<em>dictionary,</em> ...

<P>Invokes <code>initWithFormat:locale:arguments:</code> with <em>dictionary</em> as the locale.<p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/clm/NSString/localizedStringWithFormat:">+ localizedStringWithFormat:</a>

</code><p><hr WIDTH="25%" ALIGN="LEFT">

<a name="948"></a>

<h3> <a name="//apple_ref/occ/instm/NSString/initWithFormat:locale:arguments:">initWithFormat:locale:arguments:</a></h3>

- (id)<code>initWithFormat:</code>(NSString *)<em>format</em> <br><code>locale:</code>(NSDictionary *)<em>dictionary<br></em><code>arguments:</code>(va_list)<em>argList</em>

<P>Initializes a newly allocated string object, using <em>format</em> as a template into which the following argument values are substituted according to the formatting information of the current locale. For example, this code excerpt creates a string from <code>myArgs</code>, which is derived from a string object with the value "Cost:" and an <code>int</code> with the value 32:<p>

<blockquote><pre>va_list myArgs;<br>NSDictionary *myLocale;    /* Assume this exists. */<br>    <br>NSString *myString = [[NSString alloc] initWithFormat:@"%@: %d\n",<br>        locale:[[NSUserDefaults standardUserDefaults] dictionaryRepresentation]<br>        arguments:myArgs];

</pre></blockquote><p>(Note the message construct for retrieving the user's locale.). The resulting string has the value "Cost: 32\n".<p>

See <a href="#559">"Creating and Converting String Objects"</a> in the class cluster description for more information. Returns <code>self</code>.<p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/instm/NSString/initWithFormat:arguments:">- initWithFormat:arguments:</a>

</code><p><hr WIDTH="25%" ALIGN="LEFT">

<a name="955"></a>

<h3> <a name="//apple_ref/occ/instm/NSString/initWithString:">initWithString:</a></h3>

- (id)<code>initWithString:</code>(NSString *)<em>aString</em>

<P>Initializes the receiver, a newly allocated NSString, by copying the characters from <em>aString</em>. Returns <code>self</code>.<p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/clm/NSString/stringWithString:">+ stringWithString:</a>

</code><p><hr WIDTH="25%" ALIGN="LEFT">

<a name="959"></a>

<h3> <a name="//apple_ref/occ/instm/NSString/intValue">intValue</a></h3>

- (int)<code>intValue</code>

<P>Returns the integer value of the string's text, assuming a decimal representation and skipping whitespace at the beginning of the string. Returns INT_MAX or INT_MIN on overflow. Returns 0 if the receiver doesn't begin with a valid decimal text representation of a number.<p>

This method uses formatting information stored in the default locale; use an NSScanner for localized scanning of numeric values from a string.<p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/instm/NSString/doubleValue">- doubleValue</a></code>,<code> <a href="#//apple_ref/occ/instm/NSString/floatValue">- floatValue</a></code>, <code><a href="../NSScannerClassCluster/NSScannerClassCluster.html#//apple_ref/occ/instm/NSScanner/scanInt:" target="_top">- scanInt: </code>(NSScanner)</a>

<p><hr WIDTH="25%" ALIGN="LEFT">

<a name="964"></a>

<h3><a name="//apple_ref/occ/instm/NSString/isAbsolutePath">isAbsolutePath</a></h3>

- (BOOL)<code>isAbsolutePath</code>

<P>Interprets the receiver as a path, returning YES if it represents an absolute path, NO if it represents a relative path. See <a href="#581">"Manipulating Paths"</a> in the class description for more information on paths.<p>

<hr WIDTH="25%" ALIGN="LEFT">

<a name="967"></a>

<h3> <a name="//apple_ref/occ/instm/NSString/isEqualToString:">isEqualToString:</a></h3>

- (BOOL)<code>isEqualToString:</code>(NSString *)<em>aString</em>

<P>Returns YES if <em>aString</em> is equivalent to the receiver (if they have the same <code>id</code> or if they compare as NSOrderedSame), NO otherwise. When you know both objects are strings, this method is a faster way to check equality than <code>isEqual:</code>.<p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/instm/NSString/compare:options:range:">- compare:options:range:</a>

</code><p><hr WIDTH="25%" ALIGN="LEFT">

<a name="971"></a>

<h3> <a name="//apple_ref/occ/instm/NSString/lastPathComponent">lastPathComponent</a></h3>

- (NSString *)<code>lastPathComponent</code>

<P>Returns the last path component of the receiver. The following table illustrates the effect of <code>lastPathComponent</code> on a variety of different paths:<p>

<Table Border="3">

<caption></caption>

<tr><th><b>Receiver's String Value</b>

</th><th><b>String Returned</b>

</th></tr>

<tr><td scope="row">"/tmp/scratch.tiff<em>"

</em></td><td>"scratch.tiff<em>"

</em></td></tr>

<tr><td scope="row">"/tmp/scratch<em>"

</em></td><td>"scratch<em>"

</em></td></tr>

<tr><td scope="row">"/tmp/<em>"

</em></td><td>"tmp<em>"

</em></td></tr>

<tr><td scope="row">"scratch<em>"

</em></td><td>"scratch<em>"

</em></td></tr>

<tr><td scope="row">"/<em>"

</em></td><td>"<em>" (an empty string)

</em></td></tr>



</Table>



<Table>

<tr><td scope="row">

</Table>

<p>

<hr WIDTH="25%" ALIGN="LEFT">

<a name="974"></a>

<h3> <a name="//apple_ref/occ/instm/NSString/length">length</a></h3>

- (unsigned int)<code>length</code>

<P>Returns the number of Unicode characters in the receiver. This includes the individual characters of composed character sequences, so you can't use this method to determine if a string will be visible when printed, or how long it will appear.<p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/instm/NSString/cStringLength">- cStringLength</a></code>, <code>- sizeWithAttributes:</code> (NSString Additions in the Application Kit)

<p><hr WIDTH="25%" ALIGN="LEFT">

<a name="978"></a>

<h3><a name="//apple_ref/occ/instm/NSString/lineRangeForRange:">lineRangeForRange:</a></h3>

+ (NSRange)<code>lineRangeForRange:</code>(NSRange)<em>aRange</em>

<P>Returns the smallest range of lines containing <em>aRange</em>, including the characters that terminate the line.<p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/instm/NSString/getLineStart:end:contentsEnd:forRange:">- getLineStart:end:contentsEnd:forRange:</a></code>

<p><hr WIDTH="25%" ALIGN="LEFT">

<a name="982"></a>

<h3> <a name="//apple_ref/occ/instm/NSString/lossyCString">lossyCString</a></h3>

- (const char *)<code>lossyCString</code>

<P>Returns a representation of the receiver as a C string in the default C string encoding, possibly losing information in converting to that encoding (and not raising an exception as <code>cString</code> does). The returned C string will be automatically freed just as a returned object would be released; your code should copy the C string or use <code>getCString:</code> if it needs to store the C string outside of the autorelease context in which the C string is created.<p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/instm/NSString/getCString:">- getCString:</a></code>, <a href="#//apple_ref/occ/instm/NSString/canBeConvertedToEncoding:"><code>- canBeConvertedToEncoding:</a></code>, <a href="#//apple_ref/occ/clm/NSString/defaultCStringEncoding"><code>+ defaultCStringEncoding</a></code>, <a href="#//apple_ref/occ/instm/NSString/cStringLength"><code>- cStringLength</a></code>, 

<code><a href="#//apple_ref/occ/instm/NSString/getCharacters:">- getCharacters:</a>

</code><p><hr WIDTH="25%" ALIGN="LEFT">

<a name="986"></a>

<h3> <a name="//apple_ref/occ/instm/NSString/lowercaseString">lowercaseString</a></h3>

- (NSString *)<code>lowercaseString</code>

<P>Returns a string with each character from the receiver changed to its corresponding lowercase value. Case transformations aren't guaranteed to be symmetrical or to produce strings of the same lengths as the originals. The result of this statement:<p>

<blockquote><pre>lcString = [myString lowercaseString];

</pre></blockquote><p>might not be equal to this:<p>

<blockquote><pre>lcString = [[myString uppercaseString] lowercaseString];

</pre></blockquote><p>For example, the uppercase form of "&#223;" in German is "SS", so converting "e&#223;en" to uppercase then lowercase produces this sequence of strings:<p>

"e&#223;en<em>"<br></em>"ESSEN<em>"<br></em>"essen<em>"</em><p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/instm/NSString/capitalizedString">- capitalizedString</a></code>, <a href="#//apple_ref/occ/instm/NSString/uppercaseString"><code>- uppercaseString</a>

</code><p><hr WIDTH="25%" ALIGN="LEFT">

<a name="995"></a>

<h3><a name="//apple_ref/occ/instm/NSString/pathComponents">pathComponents</a></h3>

- (NSArray *)<code>pathComponents</code>

<P>Interprets the receiver as a path, returning an array of strings containing, in order, each path component of the receiver. The strings in the array appear in the order they did in the receiver. If the string begins or ends with the path separator then the first or last component, respectively, is empty. Empty components (caused by consecutive path separators) are deleted. For example, this code excerpt:<p>

<blockquote><pre>NSString *path = @"tmp/scratch";<br>NSArray *pathComponents = [path componentsSeparatedByString:@"/"];

</pre></blockquote><p>produces an array with these contents:<p>

<Table Border="3">

<caption></caption>

<tr><th><b>Index</b>

</th><th><b>Path Component</b>

</th></tr>

<tr><td scope="row">0

</td><td>tmp

</td></tr>

<tr><td scope="row">1

</td><td>scratch

</td></tr>



</Table>



<Table>

<tr><td scope="row">

</Table>

<p>

If the receiver begins with a slash-for example, "/tmp/scratch"-the array has these contents:<p>

<Table Border="3">

<caption></caption>

<tr><th><b>Index</b>

</th><th><b>Path Component</b>

</th></tr>

<tr><td scope="row">0

</td><td>"/"

</td></tr>

<tr><td scope="row">1

</td><td>"tmp"

</td></tr>

<tr><td scope="row">2

</td><td>"scratch"

</td></tr>



</Table>



<Table>

<tr><td scope="row">

</Table>

<p>

If the receiver has no separators-for example, "scratch"-the array contains the string itself, in this case "scratch".<p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/clm/NSString/pathWithComponents:">+ pathWithComponents:</a></code>, <a href="#//apple_ref/occ/instm/NSString/stringByStandardizingPath"><code>- stringByStandardizingPath</a></code>, <a href="#//apple_ref/occ/instm/NSString/componentsSeparatedByString:"><code>- componentsSeparatedByString:</a>

</code><p><hr WIDTH="25%" ALIGN="LEFT">

<a name="1003"></a>

<h3> <a name="//apple_ref/occ/instm/NSString/pathExtension">pathExtension</a></h3>

- (NSString *)<code>pathExtension</code>

<P>Interprets the receiver as a path, returning the receiver's extension, if any (not including the extension divider). The following table illustrates the effect of <code>pathExtension</code> on a variety of different paths:<p>

<Table Border="3">

<caption></caption>

<tr><th><b>Receiver's String Value</b>

</th><th><b>String Returned</b>

</th></tr>

<tr><td scope="row">"/tmp/scratch.tiff"

</td><td>"tiff"

</td></tr>

<tr><td scope="row">"/tmp/scratch"

</td><td>""<em> (an empty string)

</em></td></tr>

<tr><td scope="row">"/tmp/"

</td><td>""<em> (an empty string)

</em></td></tr>

<tr><td scope="row">"/tmp/scratch..tiff"

</td><td>"tiff"

</td></tr>



</Table>



<Table>

<tr><td scope="row">

</Table>

<p>

<hr WIDTH="25%" ALIGN="LEFT">

<a name="1006"></a>

<h3> <a name="//apple_ref/occ/instm/NSString/propertyList">propertyList</a></h3>

- (id)<code>propertyList</code>

<P>Parses the receiver as a text representation of a property list, returning an NSString, NSData, NSArray, or NSDictionary object according to the topmost element. Arrays are delimited by parentheses, with individual elements separated by commas and optional spaces. Dictionaries are delimited by curly braces, with key-value pairs separated by semicolons, the key and value separated by an equals sign. Strings appear as plain text if they contain no whitespace, or enclosed in straight quotation marks if they do. Data items are delimited by angle brackets and encoded as hexadecimal digits. Here's a short example of a text-format property list:<p>

<blockquote><pre>{<br>    Title = "Star Wars";<br>    Director = "Lucas, George";<br>    Cast = (<br>        "Hamill, Mark",<br>        "Fisher, Carrie",<br>        "Ford, Harrison"<br>    );<br>    "Thumbnail Image" = &lt;040b7479 70656473 (many more sets of digits) 8484074e&gt;<br>}

</pre></blockquote><p><B>See also: </B>  

<code><a href="#//apple_ref/occ/instm/NSString/propertyListFromStringsFileFormat">- propertyListFromStringsFileFormat</a></code>, <a href="#//apple_ref/occ/clm/NSString/stringWithContentsOfFile:"><code>+ stringWithContentsOfFile:</a>

</code><p><hr WIDTH="25%" ALIGN="LEFT">

<a name="1011"></a>

<h3> <a name="//apple_ref/occ/instm/NSString/propertyListFromStringsFileFormat">propertyListFromStringsFileFormat</a></h3>

- (NSDictionary *)<code>propertyListFromStringsFileFormat</code>

<P>Returns a dictionary object initialized with the keys and values found in the receiver. The receiver must contain text in the format used for <code>.strings</code> files. In this format, keys and values are separated by an equals sign, and each key-value pair is terminated with a semicolon. The value is optional, however; if not present, the equals sign is also omitted. The keys and values themselves are always strings enclosed in straight quotation marks. Comments may be included, delimited by <code>/*</code> and <code>*/</code> as for ANSI C comments. Here's a short example of a strings file:<p>

<blockquote><pre>/* Question in confirmation panel for quitting. */<br>"Confirm Quit" = "Are you sure you want to quit?";<br>    <br>/* Message when user tries to close unsaved document */<br>"Close or Save" = "Save changes before closing?";<br>    <br>/* Word for Cancel */<br>"Cancel";

</pre></blockquote><p><B>See also: </B>  

<code><a href="#//apple_ref/occ/instm/NSString/propertyList">- propertyList</a></code>, <a href="#//apple_ref/occ/clm/NSString/stringWithContentsOfFile:"><code>+ stringWithContentsOfFile:</a>

</code><p><hr WIDTH="25%" ALIGN="LEFT">

<a name="1016"></a>

<h3> <a name="//apple_ref/occ/instm/NSString/rangeOfCharacterFromSet:">rangeOfCharacterFromSet:</a></h3>

- (NSRange)<code>rangeOfCharacterFromSet:</code>(NSCharacterSet *)<em>aSet</em>

<P>Invokes <code>rangeOfCharacterFromSet:options:</code> with no options.<p>

<hr WIDTH="25%" ALIGN="LEFT">

<a name="1019"></a>

<h3> <a name="//apple_ref/occ/instm/NSString/rangeOfCharacterFromSet:options:">rangeOfCharacterFromSet:options:</a></h3>

- (NSRange)<code>rangeOfCharacterFromSet:</code>(NSCharacterSet *)<em>aSet<br></em><code>options:</code>(unsigned int)<em>mask</em>

<P>Invokes <code>rangeOfCharacterFromSet:options:range:</code> with <em>mask</em> for the options and the entire extent of the receiver for the range.<p>

<hr WIDTH="25%" ALIGN="LEFT">

<a name="1022"></a>

<h3> <a name="//apple_ref/occ/instm/NSString/rangeOfCharacterFromSet:options:range:">rangeOfCharacterFromSet:options:range:</a></h3>

- (NSRange)<code>rangeOfCharacterFromSet:</code>(NSCharacterSet *)<em>aSet<br></em><code>options:</code>(unsigned int)<em>mask<br></em><code>range:</code>(NSRange)<em>aRange</em>

<P>Returns the range in the receiver of the first character found from <em>aSet</em>. The search is restricted to characters in the receiver within <em>aRange</em>. The following options may be specified in <em>mask</em> by combining them with the C bitwise OR operator:<p>

NSCaseInsensitiveSearch<br>NSLiteralSearch<br>NSBackwardsSearch<p>

See <a href="#571">"Working with String Objects"</a> in the class cluster description for details on these options. Raises an NSRangeException if any part of <em>aRange</em> lies beyond the end of the string.<p>

Since precomposed characters in <em>aSet</em> can match composed characters sequences in the receiver, the length of the returned range can be greater than one. For example, if you search for "&uuml;" in the string "stru&#168;del", the returned range is {3,2}.<p>

<hr WIDTH="25%" ALIGN="LEFT">

<a name="1028"></a>

<h3> <a name="//apple_ref/occ/instm/NSString/rangeOfComposedCharacterSequenceAtIndex:">rangeOfComposedCharacterSequenceAtIndex:</a></h3>

- (NSRange)<code>rangeOfComposedCharacterSequenceAtIndex:</code>(unsigned int)<em>anIndex</em>

<P>Returns the range in the receiver of the composed character sequence located at <em>anIndex</em>. The composed character sequence includes the first base character found at or before <em>anIndex</em>, and its length includes the base character and all non-base<em> </em>characters following the base character.<p>

Raises an NSRangeException if <em>anIndex</em> lies beyond the end of the string.<p>

If you want to write a method to adjust an arbitrary range so that it includes the composed character sequences on its boundaries, you can create a method such as this: <p>

<blockquote><pre>- (NSRange)adjustRange:(NSRange)aRange<br>{<br>    unsigned int index, endIndex;<br>    NSRange newRange, endRange;<br>    <br>    index = aRange.location;<br>    newRange = [self rangeOfComposedCharacterSequenceAtIndex:index];<br>    <br>    index = aRange.location + aRange.length;<br>    endRange = [self rangeOfComposedCharacterSequenceAtIndex:index];<br>    endIndex = endRange.location + endRange.length;<br>    <br>    newRange.length = endIndex - newRange.location;<br>    <br>    return newRange;<br>}

</pre></blockquote><p><code>adjustRange:</code> begins by correcting the location for the beginning of <em>aRange</em>, storing it in <code>newRange</code>. It then works at the end of <em>aRange,</em> correcting the location and storing it in <code>endIndex</code>. Finally, it sets the length of <code>newRange</code> to the difference between <code>endIndex</code> and the new range's location.<p>

<hr WIDTH="25%" ALIGN="LEFT">

<a name="1035"></a>

<h3> <a name="//apple_ref/occ/instm/NSString/rangeOfString:">rangeOfString:</a></h3>

- (NSRange)<code>rangeOfString:</code>(NSString *)<em>aString</em>

<P>Invokes <code>rangeOfString:options:</code> with no options.<p>

<hr WIDTH="25%" ALIGN="LEFT">

<a name="1038"></a>

<h3> <a name="//apple_ref/occ/instm/NSString/rangeOfString:options:">rangeOfString:options:</a></h3>

- (NSRange)<code>rangeOfString:</code>(NSString *)<em>aString</em> <code>options:</code>(unsigned int)<em>mask</em>

<P>Invokes <code>rangeOfString:options:range:</code> with the options specified by mask and the entire extent of the receiver as the range.<p>

<hr WIDTH="25%" ALIGN="LEFT">

<a name="1041"></a>

<h3> <a name="//apple_ref/occ/instm/NSString/rangeOfString:options:range:">rangeOfString:options:range:</a></h3>

- (NSRange)<code>rangeOfString:</code>(NSString *)<em>subString<br></em><code>options:</code>(unsigned int)<em>mask<br></em><code>range:</code>(NSRange)<em>aRange</em>

<P>Returns an NSRange giving the location and length of the first occurrence of <em>subString</em> within <em>aRange</em> in the receiver. If <em>subString</em> isn't found, the length of the returned NSRange is zero. The length of the returned range and that of <em>subString</em> may differ if equivalent composed character sequences are matched. The following options may be specified in <em>mask</em> by combining them with the C bitwise OR operator:<p>

NSCaseInsensitiveSearch<br>NSLiteralSearch<br>NSBackwardsSearch<br>NSAnchoredSearch<p>

See <a href="#571">"Working with String Objects"</a> in the class cluster description for details on these options. Raises an NSRangeException if any part of <em>aRange</em> lies beyond the end of the string. Returns a range of {NSNotFound, 0} if <em>subString</em> is the null string.<p>

<hr WIDTH="25%" ALIGN="LEFT">

<a name="1046"></a>

<h3> <a name="//apple_ref/occ/instm/NSString/smallestEncoding">smallestEncoding</a></h3>

- (NSStringEncoding)<code>smallestEncoding</code>

<P>Returns the smallest encoding to which the receiver can be converted without loss of information. This encoding may not be the fastest for accessing characters, but is very space-efficient. This method itself may take some time to execute.<p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/instm/NSString/fastestEncoding">- fastestEncoding</a></code>, <a href="#//apple_ref/occ/instm/NSString/getCharacters:range:"><code>- getCharacters:range:</a>

</code><p><hr WIDTH="25%" ALIGN="LEFT">

<a name="1050"></a>

<h3> <a name="//apple_ref/occ/instm/NSString/stringByAbbreviatingWithTildeInPath">stringByAbbreviatingWithTildeInPath</a></h3>

- (NSString *)<code>stringByAbbreviatingWithTildeInPath</code>

<P>Returns a string representing the receiver as a path, with a tilde, "~", substituted for the full path to the current user's home directory, or "~<em>user</em>" for a user other than the current user. Returns the receiver unaltered if it doesn't begin with the user's home directory.<p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/instm/NSString/stringByExpandingTildeInPath">- stringByExpandingTildeInPath</a>

</code><p><hr WIDTH="25%" ALIGN="LEFT">

<a name="1054"></a>

<h3> <a name="//apple_ref/occ/instm/NSString/stringByAppendingFormat:">stringByAppendingFormat:</a></h3>

- (NSString *)<code>stringByAppendingFormat:</code>(NSString *)<em>format</em>, ...

<P>Returns a string made by appending to the receiver a string constructed from <em>format</em> and following arguments in the manner of <code>stringWithFormat:</code>.<p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/instm/NSString/stringByAppendingString:">- stringByAppendingString:</a>

</code><p><hr WIDTH="25%" ALIGN="LEFT">

<a name="1058"></a>

<h3> <a name="//apple_ref/occ/instm/NSString/stringByAppendingPathComponent:">stringByAppendingPathComponent:</a></h3>

- (NSString *)<code>stringByAppendingPathComponent:</code>(NSString *)<em>aString</em>

<P>Returns a string made by appending <em>aString</em>, preceded by if necessary by a path separator. The following table illustrates the effect of this method on a variety of different paths, assuming that <em>aString</em> is supplied as "scratch.tiff":<p>

<Table Border="3">

<caption></caption>

<tr><th><b>Receiver's String Value</b>

</th><th><b>Resulting String</b>

</th></tr>

<tr><td scope="row">"/tmp"

</td><td>"/tmp/scratch.tiff"

</td></tr>

<tr><td scope="row">"/tmp/"

</td><td>"/tmp/scratch.tiff"

</td></tr>

<tr><td scope="row">"/"

</td><td>"/scratch.tiff"

</td></tr>

<tr><td scope="row">"" <em>(an empty string)

</em></td><td>"scratch.tiff"

</td></tr>



</Table>



<Table>

<tr><td scope="row">

</Table>

<p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/instm/NSString/stringsByAppendingPaths:">- stringsByAppendingPaths:</a></code>, <a href="#//apple_ref/occ/instm/NSString/stringByAppendingPathExtension:"><code>- stringByAppendingPathExtension:</a></code>, 

<code><a href="#//apple_ref/occ/instm/NSString/stringByDeletingLastPathComponent">- stringByDeletingLastPathComponent</a>

</code><p><hr WIDTH="25%" ALIGN="LEFT">

<a name="1062"></a>

<h3> <a name="//apple_ref/occ/instm/NSString/stringByAppendingPathExtension:">stringByAppendingPathExtension:</a></h3>

- (NSString *)<code>stringByAppendingPathExtension:</code>(NSString *)<em>string</em>

<P>Returns a string made by appending to the receiver an extension separator followed by <em>aString</em>. The following table illustrates the effect of this method on a variety of different paths, assuming that <em>aString</em> is supplied as @"tiff":<p>

<Table Border="3">

<caption></caption>

<tr><th><b>Receiver's String Value</b>

</th><th><b>Resulting String</b>

</th></tr>

<tr><td scope="row">"/tmp/scratch.old"

</td><td>"/tmp/scratch.old.tiff"

</td></tr>

<tr><td scope="row">"/tmp/scratch."

</td><td>"/tmp/scratch..tiff"

</td></tr>

<tr><td scope="row">"/tmp/"

</td><td>"/tmp/.tiff"

</td></tr>

<tr><td scope="row">"scratch"

</td><td>"scratch.tiff"

</td></tr>



</Table>



<Table>

<tr><td scope="row">

</Table>

<p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/instm/NSString/stringByAppendingPathComponent:">- stringByAppendingPathComponent:</a></code>, <a href="#//apple_ref/occ/instm/NSString/stringByDeletingPathExtension"><code>- stringByDeletingPathExtension</a>

</code><p><hr WIDTH="25%" ALIGN="LEFT">

<a name="1066"></a>

<h3> <a name="//apple_ref/occ/instm/NSString/stringByAppendingString:">stringByAppendingString:</a></h3>

- (NSString *)s<code>tringByAppendingString:</code>(NSString *)<em>aString</em>

<P>Returns a string object made by appending <em>aString</em> to the receiver. This code excerpt, for example:<p>

<blockquote><pre>NSString *errorTag = @"Error: ";<br>NSString *errorString = @"premature end of file.";<br>NSString *errorMessage = [errorTag stringByAppendingString:errorString];

</pre></blockquote><p>produces the string "Error: premature end of file.".<p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/instm/NSString/stringByAppendingFormat:">- stringByAppendingFormat:</a>

</code><p><hr WIDTH="25%" ALIGN="LEFT">

<a name="1072"></a>

<h3> <a name="//apple_ref/occ/instm/NSString/stringByDeletingLastPathComponent">stringByDeletingLastPathComponent</a></h3>

- (NSString *)<code>stringByDeletingLastPathComponent</code>

<P>Returns a string made by deleting the last path component from the receiver, along with any final path separator. If the receiver represents the root path, however, it's returned unaltered. The following table illustrates the effect of this method on a variety of different paths:<p>

<Table Border="3">

<caption></caption>

<tr><th><b>Receiver's String Value</b>

</th><th><b>Resulting String</b>

</th></tr>

<tr><td scope="row">"/tmp/scratch.tiff"

</td><td>"/tmp"

</td></tr>

<tr><td scope="row">"/tmp/lock/"

</td><td>"/tmp"

</td></tr>

<tr><td scope="row">"/tmp/"

</td><td>"/"

</td></tr>

<tr><td scope="row">"/tmp"

</td><td>"/"

</td></tr>

<tr><td scope="row">"/"

</td><td>"/"

</td></tr>

<tr><td scope="row">"scratch.tiff"

</td><td>""<em> (an empty string)

</em></td></tr>



</Table>



<Table>

<tr><td scope="row">

</Table>

<p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/instm/NSString/stringByDeletingPathExtension">- stringByDeletingPathExtension</a></code>, <a href="#//apple_ref/occ/instm/NSString/stringByAppendingPathComponent:"><code>- stringByAppendingPathComponent:</a>

</code><p><hr WIDTH="25%" ALIGN="LEFT">

<a name="1076"></a>

<h3> <a name="//apple_ref/occ/instm/NSString/stringByDeletingPathExtension">stringByDeletingPathExtension</a></h3>

- (NSString *)<code>stringByDeletingPathExtension</code>

<P>Returns a string made by deleting the extension (if any, and only the last) from the receiver. Strips any trailing path separator before checking for an extension. If the receiver represents the root path, however, it's returned unaltered. The following table illustrates the effect of this method on a variety of different paths:<p>

<Table Border="3">

<caption></caption>

<tr><th><b>Receiver's String Value</b>

</th><th><b>Resulting String</b>

</th></tr>

<tr><td scope="row">"/tmp/scratch.tiff"

</td><td>"/tmp/scratch"

</td></tr>

<tr><td scope="row">"/tmp/"

</td><td>"/tmp"

</td></tr>

<tr><td scope="row">"scratch.bundle/"

</td><td>"scratch"

</td></tr>

<tr><td scope="row">"scratch..tiff"

</td><td>"scratch."

</td></tr>

<tr><td scope="row">".tiff"

</td><td>""<em> (an empty string)

</em></td></tr>

<tr><td scope="row">"/"

</td><td>"/"

</td></tr>



</Table>



<Table>

<tr><td>

</Table>

<p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/instm/NSString/pathExtension">- pathExtension</a></code>, <a href="#//apple_ref/occ/instm/NSString/stringByDeletingLastPathComponent"><code>- stringByDeletingLastPathComponent</a>

</code><p><hr WIDTH="25%" ALIGN="LEFT">

<a name="1080"></a>

<h3> <a name="//apple_ref/occ/instm/NSString/stringByExpandingTildeInPath">stringByExpandingTildeInPath</a></h3>

- (NSString *)<code>stringByExpandingTildeInPath</code>

<P>Returns a string made by expanding the initial component, if it begins with "~" or "~<em>user</em>", to its full path value. Returns the receiver unaltered if that component can't be expanded. <p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/instm/NSString/stringByAbbreviatingWithTildeInPath">- stringByAbbreviatingWithTildeInPath</a>

</code><p><hr WIDTH="25%" ALIGN="LEFT">

<a name="1084"></a>

<h3> <a name="//apple_ref/occ/instm/NSString/stringByResolvingSymlinksInPath">stringByResolvingSymlinksInPath</a></h3>

<code>- (NSString *)stringByResolvingSymlinksInPath</code>

<P>On Microsoft Windows: Returns <code>self</code>.<p>

On UNIX platforms: Expands an initial tilde expression in the receiving path, then resolves all symbolic links and references to current or parent directories if possible, returning a standardized path. If the original path is absolute, all symbolic links are guaranteed to be removed; if it's a relative path, symbolic links that can't be resolved are left unresolved in the returned string. Returns <code>self</code> if an error occurs.<p>

<B><dt>Note:	</B>

If the name of the receiving path begins with <code>/private</code>, the <code>stringByResolvingSymlinksInPath</code> 

method strips off the <code>/private</code> designator, provided the result is the name of an existing file.

<B>See also: </B>  

<code><a href="#//apple_ref/occ/instm/NSString/stringByStandardizingPath">- stringByStandardizingPath</a></code>, <a href="#//apple_ref/occ/instm/NSString/stringByExpandingTildeInPath"><code>- stringByExpandingTildeInPath</a>

</code><p><hr WIDTH="25%" ALIGN="LEFT">

<a name="1090"></a>

<h3> <a name="//apple_ref/occ/instm/NSString/stringByStandardizingPath">stringByStandardizingPath</a></h3>

<code>- (NSString *)stringByStandardizingPath</code>

<P>Returns a string representing the receiving path, with extraneous path components removed. If stringByStandardizingPath detects symbolic links in a path name, the stringByResolvingSymlinksInPath method is called to resolve them. If an invalid path name is provided, stringByStandardizingPath may attempt<code> </code>to resolve it by calling<code> stringByResolvingSymlinksInPath</code>, and the results are undefined. If any other kind error is encountered (such as a path component not existing), self is returned.<p>

The changes that this method can make in the provided string are:<p>

<ul><li>An initial tilde expression is expanded using <code>stringByExpandingTildeInPath</code>.<p>

<li>Empty components and references to the current directory (that is, the sequences "//" and "/./") are reduced to single path separators.<p>

<li>In absolute paths only, references to the parent directory (that is, the component "..") are resolved to the real parent directory if possible using <code>stringByResolvingSymlinksInPath</code>, which consults the file system to resolve each potential symbolic link.<p>

<li>In relative paths, because symbolic links can't be resolved, references to the parent directory are left in place.<p>

<li>On Mach, an initial component of "/private" is removed from the path if the result still indicates an existing file or directory (checked by consulting the file system).<p>

</ul><B>See also: </B>  

<code><a href="#//apple_ref/occ/instm/NSString/stringByExpandingTildeInPath">- stringByExpandingTildeInPath</a></code>, <a href="#//apple_ref/occ/instm/NSString/stringByResolvingSymlinksInPath"><code>- stringByResolvingSymlinksInPath</a>

</code><p><hr WIDTH="25%" ALIGN="LEFT">

<a name="1100"></a>

<h3> <a name="//apple_ref/occ/instm/NSString/stringsByAppendingPaths:">stringsByAppendingPaths:</a></h3>

- (NSArray *)<code>stringsByAppendingPaths:</code>(NSArray *)<em>paths</em>

<P>Returns an array of strings made by separately appending each string in <em>paths</em> to the receiver, preceded by if necessary by a path separator. See <code>stringByAppendingPathComponent:</code> for an individual example.<p>

<hr WIDTH="25%" ALIGN="LEFT">

<a name="1103"></a>

<h3> <a name="//apple_ref/occ/instm/NSString/substringFromIndex:">substringFromIndex:</a></h3>

- (NSString *)<code>substringFromIndex:</code>(unsigned int)<em>anIndex</em>

<P>Returns a string object containing the characters of the receiver from the one at <em>anIndex</em> to the end. Raises an NSRangeException if <em>anIndex</em> lies beyond the end of the string.<p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/instm/NSString/substringWithRange:">- substringWithRange:</a></code>, <a href="#//apple_ref/occ/instm/NSString/substringToIndex:"><code>- substringToIndex:</a>

</code><p><hr WIDTH="25%" ALIGN="LEFT">

<a name="1107"></a>

<h3> <a name="//apple_ref/occ/instm/NSString/substringToIndex:">substringToIndex:</a></h3>

- (NSString *)<code>substringToIndex:</code>(unsigned int)<em>anIndex</em>	

<P>Returns a string object containing the characters of the receiver up to, but not including, the one at <em>anIndex</em>. Raises an NSRangeException if <em>anIndex</em> lies beyond the end of the string.<p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/instm/NSString/substringFromIndex:">- substringFromIndex:</a></code>, <a href="#//apple_ref/occ/instm/NSString/substringWithRange:"><code>- substringWithRange:</a>

</code><p><hr WIDTH="25%" ALIGN="LEFT">

<a name="1111"></a>

<h3> <a name="//apple_ref/occ/instm/NSString/substringWithRange:">substringWithRange:</a></h3>

- (NSString *)<code>substringWithRange:</code>(NSRange)<em>aRange</em>

<P>Returns a string object containing the characters of the receiver that lie within <em>aRange</em>. Raises an NSRangeException if any part of <em>aRange</em> lies beyond the end of the string.<p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/instm/NSString/substringFromIndex:">- substringFromIndex:</a></code>, <a href="#//apple_ref/occ/instm/NSString/substringToIndex:"><code>- substringToIndex:</a>

</code><p><hr WIDTH="25%" ALIGN="LEFT">

<a name="1115"></a>

<h3> <a name="//apple_ref/occ/instm/NSString/uppercaseString">uppercaseString</a></h3>

- (NSString *)<code>uppercaseString</code>

<P>Returns a string with each character from the receiver changed to its corresponding uppercase value. Case transformations aren't guaranteed to be symmetrical or to produce strings of the same lengths as the originals. See <code>lowercaseString</code> for an example.<p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/instm/NSString/capitalizedString">- capitalizedString</a></code>, <a href="#//apple_ref/occ/instm/NSString/lowercaseString"><code>- lowercaseString</a>

</code><p><hr WIDTH="25%" ALIGN="LEFT">

<a name="1119"></a>

<h3> <a name="//apple_ref/occ/instm/NSString/writeToFile:atomically:">writeToFile:atomically:</a></h3>

- (BOOL)<code>writeToFile:</code>(NSString *)<em>path</em> <code>atomically:</code>(BOOL)<em>flag</em>

<P>Writes the string's characters to the file named by <em>path</em>, returning YES on success and NO on failure. If <em>flag</em> is YES, attempts to write the file safely so that an existing file named by <em>path</em> is not overwritten, nor does a new file at <em>path</em> actually get created, unless the write is successful. The string is written in the default C string encoding if possible (that is, if no information would be lost), in the Unicode encoding otherwise.<p>

If <em>path</em> contains a tilde (~) character, you must expand it with <code>stringByExpandingTildeInPath:</code> before invoking this method.<p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/clm/NSString/defaultCStringEncoding">+ defaultCStringEncoding</a>

</code><p><hr><p>

<h1>

<img src="../clsclstr.gif">

<FONT COLOR="#000066">

<a name="1124"><a name="//apple_ref/occ/cl/NSMutableString">NSMutableString</a>

</a>

</FONT>

</h1>

<p><B>Inherits From:</B><BR>  

NSString : NSObject



<p><B>Conforms To:</B><BR>

NSCoding (NSString)<br>

NSCopying (NSString)<br>

NSMutableCopying (NSString)<br>

NSObject (NSObject)



<p><B>Declared In:	</B><BR>

Foundation/NSString.h



<p><a name="1128"></a>

<a name="description"></a>

<H2>Class Description

</H2>

The NSMutableString class declares the programmatic interface to an object that manages a mutable string-that is, a string whose contents can be edited. To construct and manage an immutable string-or a string that cannot be changed after it has been created-use an object of the NSString class.<p>

An immutable string is implemented as array of Unicode characters (in other words, as a text string). The NSMutableString class adds one primitive method-<code>replaceCharactersInRange:withString:</code>-to the basic string-handling behavior inherited from NSString. All other methods that modify a string work through this method. For example, <code>insertString:atIndex:</code> simply replaces the characters in a range of zero length, while <code>deleteCharactersInRange:</code> replaces the characters in a given range with no characters.<p>

<a name="1131">

<HR WIDTH="50%" ALIGN="LEFT">

<h2>Method Types

</h2>

</a><dl>

<dt>Creating temporary strings<dd><dl><dd><dl><dd><dl><dd><dl>

<dt><a href="#//apple_ref/occ/clm/NSMutableString/stringWithCapacity:">+ stringWithCapacity:</a></dl></dd>

</dl></dd></dl></dd></dl></dd><dt>Initializing an NSMutableString<dd><dl><dd><dl><dd><dl><dd><dl>

<dt><a href="#//apple_ref/occ/instm/NSMutableString/initWithCapacity:">- initWithCapacity:</a></dl></dd>

</dl></dd></dl></dd></dl></dd><dt><code>Modifying a string</code><dd><dl><dd><dl><dd><dl><dd><dl>

<dt><code><a href="#//apple_ref/occ/instm/NSMutableString/appendFormat:">- appendFormat:</a></code><dt><code><a href="#//apple_ref/occ/instm/NSMutableString/appendString:">- appendString:</a></code><dt><code><a href="#//apple_ref/occ/instm/NSMutableString/deleteCharactersInRange:">- deleteCharactersInRange:</a></code><dt><code><a href="#//apple_ref/occ/instm/NSMutableString/insertString:atIndex:">- insertString:atIndex:</a></code><dt><code><a href="#//apple_ref/occ/instm/NSMutableString/replaceCharactersInRange:withString:">- replaceCharactersInRange:withString:</a></code><dt><code><a href="#//apple_ref/occ/instm/NSMutableString/setString:">- setString:</a></code></dl></dd>

</dl></dd></dl></dd></dl></dd></dl>

<HR WIDTH="50%" ALIGN="LEFT">

<a name="1143"></a>

<a name="clm"></a>

<h2>Class Methods</h2>  





<a name="1144"></a>

<h3>

 <a name="//apple_ref/occ/clm/NSMutableString/stringWithCapacity:">stringWithCapacity:</a>

</h3>

+ (NSMutableString *)<code>stringWithCapacity:</code>(unsigned int)<em>capacity</em>

<P>Returns an empty mutable string, using <em>capacity</em> as a hint for how much initial storage to reserve.<p>

<HR WIDTH="50%" ALIGN="LEFT">

<a name="instm"></a>

<h2>Instance Methods</h2>  





<a name="1148"></a>

<h3>

 <a name="//apple_ref/occ/instm/NSMutableString/appendFormat:">appendFormat:</a>

</h3>

- (void)<code>appendFormat:</code>(NSString *)<em>format</em>, ...

<P>Adds a constructed string to the receiver. Creates the new string by using NSString's <code>stringWithFormat:</code> method with the arguments listed.<p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/instm/NSMutableString/appendString:">- appendString:</a>

</code><p><hr WIDTH="25%" ALIGN="LEFT">

<a name="1152"></a>

<h3> <a name="//apple_ref/occ/instm/NSMutableString/appendString:">appendString:</a></h3>

- (void)<code>appendString:</code>(NSString *)<em>aString</em>

<P>Adds the characters of <em>aString</em> to end of the receiver.<p>

<B>See also: </B>  

<code><a href="#//apple_ref/occ/instm/NSMutableString/appendFormat:">- appendFormat:</a>

</code><p><hr WIDTH="25%" ALIGN="LEFT">

<a name="1156"></a>

<h3> <a name="//apple_ref/occ/instm/NSMutableString/deleteCharactersInRange:">deleteCharactersInRange:</a></h3>

- (void)<code>deleteCharactersInRange:</code>(NSRange)<em>aRange</em>

<P>Removes the characters in <em>aRange</em> from the receiver. Raises an NSRangeException if any part of <em>aRange</em> lies beyond the end of the string.<p>

<hr WIDTH="25%" ALIGN="LEFT">

<a name="1159"></a>

<h3> <a name="//apple_ref/occ/instm/NSMutableString/initWithCapacity:">initWithCapacity:</a></h3>

-<code> </code>(id)<code>initWithCapacity:</code>(unsigned int)<em>capacity</em>

<P>Initializes a newly allocated NSMutableString, using <em>capacity</em> as a hint for how much memory to allocate. Returns <code>self</code>.<p>

<hr WIDTH="25%" ALIGN="LEFT">

<a name="1162"></a>

<h3> <a name="//apple_ref/occ/instm/NSMutableString/insertString:atIndex:">insertString:atIndex:</a></h3>

- (void)<code>insertString:</code>(NSString *)<em>aString</em> <code>atIndex:</code>(unsigned int)<em>anIndex</em>

<P>Inserts the characters of <em>aString</em> into the receiver, so that the new characters begin at <em>anIndex</em> and the existing characters from <em>anIndex</em> to the end are shifted by the length of <em>aString</em>. Raises an NSRangeException if <em>anIndex</em> lies beyond the end of the string.<p>

<hr WIDTH="25%" ALIGN="LEFT">

<a name="1165"></a>

<h3> <a name="//apple_ref/occ/instm/NSMutableString/replaceCharactersInRange:withString:">replaceCharactersInRange:withString:</a></h3>

- (void)<code>replaceCharactersInRange:</code>(NSRange)<em>aRange<br></em><code>withString:</code>(NSString *)<em>aString</em>

<P>Replaces the characters from <em>aRange</em> with those in <em>aString</em>. Raises an NSRangeException if any part of <em>aRange</em> lies beyond the end of the string.<p>

<hr WIDTH="25%" ALIGN="LEFT">

<a name="1168"></a>

<h3> <a name="//apple_ref/occ/instm/NSMutableString/setString:">setString:</a></h3>

- (void)<code>setString:</code>(NSString *)<em>aString</em>

<P>Replaces the characters of the receiver with those in <em>aString</em>.<p>



 

 





<i>Copyright &#169; 1997, Apple Computer, Inc.   All rights

reserved.</i>



<!-- Last updated: 06/17/97 16:52:44 -->



</body>

</html>

