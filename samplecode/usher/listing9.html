<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>usher - /sources/QTSSampleCodeUtils.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxQuickTime-date.html">QuickTime</a> &gt; <A HREF="javascript:location.replace('index.html');">usher</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/QuickTime/index.html" target="_blank">Reference Library > QuickTime</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">usher</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/sources/QTSSampleCodeUtils.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/notes/usingusher.htm</option>
<option value="listing2.html">/sources/AppSupport.c</option>
<option value="listing3.html">/sources/AppSupport.h</option>
<option value="listing4.html">/sources/MovieSourcing.c</option>
<option value="listing5.html">/sources/MovieSourcing.h</option>
<option value="listing6.html">/sources/PresInfoWindow.c</option>
<option value="listing7.html">/sources/PresInfoWindow.h</option>
<option value="listing8.html">/sources/PresinfoWindow.r</option>
<option value="listing9.html">/sources/QTSSampleCodeUtils.c</option>
<option value="listing10.html">/sources/QTSSampleCodeUtils.h</option>
<option value="listing11.html">/sources/SimplePres.c</option>
<option value="listing12.html">/sources/SimplePres.h</option>
<option value="listing13.html">/sources/SourcingSupport.c</option>
<option value="listing14.html">/sources/SourcingSupport.h</option>
<option value="listing15.html">/sources/usher.r</option>
<option value="listing16.html">/sources/UsherBroadcast.c</option>
<option value="listing17.html">/sources/UsherBroadcast.h</option>
<option value="listing18.html">/sources/UsherCarbon.r</option>
<option value="listing19.html">/sources/UsherCommands.h</option>
<option value="listing20.html">/sources/UsherMinWindow.c</option>
<option value="listing21.html">/sources/UsherMinWindow.h</option>
<option value="listing22.html">/sources/UsherMinWindow.r</option>
<option value="listing23.html">/sources/UsherNew.c</option>
<option value="listing24.html">/sources/UsherNew.h</option>
<option value="listing25.html">/sources/usherRezDefines.h</option>
<option value="listing26.html">/sources/WindowSupport.c</option>
<option value="listing27.html">/sources/WindowSupport.h</option>
<option value="listing28.html">/UsherReleaseNotes.txt</option></select>
				</p>
				</form>
				<p><strong><a href="usher.zip">Download Sample</a></strong> (&#147;usher.zip&#148;, 212.3K)<BR>
<strong><a href="usher.dmg">Download Sample</a></strong> (&#147;usher.dmg&#148;, 293.2K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*  File:    QTSSampleCodeUtils.c  Copyright:  &copy; 2000-2001 by Apple Computer, Inc., all rights reserved.*/#include &lt;stdarg.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;NumberFormatting.h&gt;#include &lt;StringCompare.h&gt;#include &lt;ControlDefinitions.h&gt;#include &lt;TextUtils.h&gt;#include &lt;QuickTimeStreaming.h&gt;#include &quot;QTSSampleCodeUtils.h&quot;// ---------------------------------------------------------------------------//    D E F I N I T I O N S// ---------------------------------------------------------------------------#define kMaxPStringLength    255// ---------------------------------------------------------------------------//    P R O T O T Y P E S// ---------------------------------------------------------------------------static void FindThisApplication(FSSpec *outSpec);// ---------------------------------------------------------------------------//    SafeHandToHand// ---------------------------------------------------------------------------OSErr SafeHandToHand(Handle inOrigHandle, Handle *outNewHandle){  OSErr    err = noErr;  SInt32    handleSize;    if (inOrigHandle == NULL)  {    *outNewHandle = NULL;  }  else  {    handleSize = GetHandleSize(inOrigHandle);    *outNewHandle = QTSNewHandle(handleSize, 0L, NULL);    EXITIFERR( err = MemError() );    BlockMoveData(*inOrigHandle, **outNewHandle, handleSize);  }exit:  return err;}#pragma mark -// ---------------------------------------------------------------------------//    QTSCopyMediaParams// ---------------------------------------------------------------------------OSErr QTSCopyMediaParams(QTSMediaParams *inSourceMediaParams, QTSMediaParams *outDestMediaParams){  OSErr  err = noErr;  if ((outDestMediaParams != nil) &amp;&amp; (inSourceMediaParams != nil)) {    *outDestMediaParams = *inSourceMediaParams;    outDestMediaParams-&gt;v.clip = nil;    outDestMediaParams-&gt;a.frequencyBands = nil;        err = CopyRgnUtil(inSourceMediaParams-&gt;v.clip, &amp;(outDestMediaParams-&gt;v.clip));    if ((err == noErr) &amp;&amp; (inSourceMediaParams-&gt;a.frequencyBandsCount &gt; 0)) {      long  frequencyBandsPtrSize;            frequencyBandsPtrSize = inSourceMediaParams-&gt;a.frequencyBandsCount * sizeof(UnsignedFixed);            outDestMediaParams-&gt;a.frequencyBands = (void*)QTSNewPtr(frequencyBandsPtrSize, 0L, 0L);      if ((err = MemError()) == noErr) {        BlockMoveData(inSourceMediaParams-&gt;a.frequencyBands,                outDestMediaParams-&gt;a.frequencyBands,                frequencyBandsPtrSize);      }    }  } else {    err = paramErr;  }    return err;}// ---------------------------------------------------------------------------//    QTSDisposeMediaParams// ---------------------------------------------------------------------------void QTSDisposeMediaParams(QTSMediaParams *inMediaParams){  if (inMediaParams != nil) {    DISPOSEIFRGN(inMediaParams-&gt;v.clip);    DisposePtr((Ptr)inMediaParams-&gt;a.frequencyBands);  }}// ---------------------------------------------------------------------------//    CopyRgnUtil// ---------------------------------------------------------------------------OSErr CopyRgnUtil(RgnHandle inRgn, RgnHandle *ioRgn){  // make ioRgn look like inRgn  OSErr    err = noErr;  if (inRgn == NULL)  {    DISPOSEIFRGN(*ioRgn);  }  else  {    if (*ioRgn == NULL)  {      *ioRgn = NewRgn();      if (*ioRgn == NULL)  {        err = memFullErr;        goto exit;      }      }      MacCopyRgn(inRgn, *ioRgn);    err = MemError();  }exit:    if (err != noErr)  {    DISPOSEIFRGN(*ioRgn);      }  return err;}#pragma mark -// ---------------------------------------------------------------------------//    QTSGetTimeBaseTime// ---------------------------------------------------------------------------UInt32 QTSGetTimeBaseTime(TimeBase inTimeBase, TimeScale inTimeScale){  TimeRecord    timeRecord;    timeRecord.value.lo = 0;  timeRecord.value.hi = 0;  timeRecord.scale = inTimeScale;  timeRecord.base = inTimeBase;  GetTimeBaseStatus(inTimeBase, &amp;timeRecord);  ConvertTimeScale(&amp;timeRecord, inTimeScale);  return timeRecord.value.lo;}// ---------------------------------------------------------------------------//    QTSGetTimeBaseTime64// ---------------------------------------------------------------------------void QTSGetTimeBaseTime64(TimeBase inTimeBase, TimeScale inTimeScale, TimeValue64 *outTime){  TimeRecord    timeRecord;    timeRecord.value.lo = 0;  timeRecord.value.hi = 0;  timeRecord.scale = inTimeScale;  timeRecord.base = inTimeBase;  GetTimeBaseStatus(inTimeBase, &amp;timeRecord);  ConvertTimeScale(&amp;timeRecord, inTimeScale);  *outTime = *((TimeValue64*)&amp;timeRecord.value);}// ---------------------------------------------------------------------------//    QTSConvertDuration// ---------------------------------------------------------------------------UInt32 QTSConvertDuration(UInt32 inOriginalDuration,      TimeScale inOriginalTimeScale, TimeScale inNewTimeScale){  TimeRecord    timeRecord;    if (inNewTimeScale != 0 &amp;&amp; inOriginalTimeScale != 0)  {    timeRecord.value.lo = inOriginalDuration;    timeRecord.value.hi = 0;    timeRecord.scale = inOriginalTimeScale;    timeRecord.base = NULL;    ConvertTimeScale(&amp;timeRecord, inNewTimeScale);  }  else {    //DEBUGF((&quot;QTSConvertDuration - 0 timescale, dur %ld, origtimescale %ld, newtimescale %ld&quot;,    //          inOriginalDuration, inOriginalTimeScale, inNewTimeScale));    timeRecord.value.lo = 0;  }  return timeRecord.value.lo;}// ---------------------------------------------------------------------------//    QTSConvertDuration64// ---------------------------------------------------------------------------void QTSConvertDuration64(const TimeValue64 *inOriginalDuration,      TimeScale inOriginalTimeScale, TimeScale inNewTimeScale,      TimeValue64 *outConvertedDuration){  TimeRecord    timeRecord;    if (inNewTimeScale != 0 &amp;&amp; inOriginalTimeScale != 0)  {    timeRecord.value = *((wide*)inOriginalDuration);    timeRecord.scale = inOriginalTimeScale;    timeRecord.base = NULL;    ConvertTimeScale(&amp;timeRecord, inNewTimeScale);    *outConvertedDuration = *((TimeValue64*)&amp;timeRecord.value);  }  else  {    //DEBUGF((&quot;QTSConvertDuration64 - 0 timescale, dur %0.8x %0.8x, origtimescale %ld, newtimescale %ld&quot;,    //          QTSInt64Hi32(*inOriginalDuration), QTSInt64Lo32(*inOriginalDuration), inOriginalTimeScale, inNewTimeScale));    *outConvertedDuration = 0;  }}// ---------------------------------------------------------------------------//    DateTimeRecToString// ---------------------------------------------------------------------------void DateTimeRecToString(const DateTimeRec *inRec, char *outString){  sprintf((char*)outString, &quot;%0.2u:%0.2u:%0.2u:%0.2u&quot;, inRec-&gt;day, inRec-&gt;hour,              inRec-&gt;minute, inRec-&gt;second);}// ---------------------------------------------------------------------------//    TimeValue64ToDateTimeRec// ---------------------------------------------------------------------------void TimeValue64ToDateTimeRec(const TimeValue64 *inTime64, TimeScale inTimeScale, DateTimeRec *outRec){  TimeValue64    time64;  TimeValue64    temp64;#define kNumSecondsPerMinute    60#define kNumMinutesPerHour      60#define kNumHoursPerDay        24#define kNumSecondsPerHour      (kNumSecondsPerMinute * kNumMinutesPerHour)#define kNumSecondsPerDay      (kNumSecondsPerMinute * kNumMinutesPerHour * kNumHoursPerDay)    memset(outRec, 0, sizeof(*outRec));  time64 = *inTime64;  if (inTimeScale == 0)  {    DEBUGF((&quot;TimeValue64ToDateTimeRec-timescale=0&quot;));    goto exit;  }  temp64 = time64 / (kNumSecondsPerDay * inTimeScale);  if (temp64 &gt; 0)  {    outRec-&gt;day = (short)temp64;    time64 -= (temp64 * kNumSecondsPerDay * inTimeScale);  }    temp64 = time64 / (kNumSecondsPerHour * inTimeScale);  if (temp64 &gt; 0)  {    outRec-&gt;hour = (short)temp64;    time64 -= (temp64 * kNumSecondsPerHour * inTimeScale);  }    temp64 = time64 / (kNumSecondsPerMinute * inTimeScale);  if (temp64 &gt; 0)  {    outRec-&gt;minute = (short)temp64;    time64 -= (temp64 * kNumSecondsPerMinute * inTimeScale);  }          temp64 = (time64 + inTimeScale/2) / (inTimeScale);  if (temp64 &gt; 0)  {    outRec-&gt;second = (short)temp64;  }exit:  return;}// ---------------------------------------------------------------------------//    TimeValue64ToString// ---------------------------------------------------------------------------void TimeValue64ToString(const TimeValue64 *inTime64, TimeScale inTimeScale, char *outString){  DateTimeRec    dtrec;      TimeValue64ToDateTimeRec(inTime64, inTimeScale, &amp;dtrec);  DateTimeRecToString(&amp;dtrec, outString);}#pragma mark -// ---------------------------------------------------------------------------//    CStringToCStringPtr// ---------------------------------------------------------------------------OSErr CStringToCStringPtr(const char *inString, CStringPtr *outCStringPtr){  return StringToCStringPtr(inString, strlen(inString), outCStringPtr);}// ---------------------------------------------------------------------------//    PStringToCStringPtr// ---------------------------------------------------------------------------OSErr PStringToCStringPtr(const unsigned char *inString, CStringPtr *outCStringPtr){  return StringToCStringPtr((const char*)&amp;(inString[1]), inString[0], outCStringPtr);}// ---------------------------------------------------------------------------//    StringToCStringPtr// ---------------------------------------------------------------------------OSErr StringToCStringPtr(const char *inString, UInt32 inStringLength, CStringPtr *outCStringPtr){  Ptr      myPtr;  OSErr    err = noErr;    myPtr = QTSNewPtr((long)(inStringLength + 1), 0L, NULL);  if (myPtr == NULL)  {    err = memFullErr;    *outCStringPtr = NULL;  }  else  {    if (inStringLength &gt; 0)  {      BlockMoveData(inString, myPtr, (long)inStringLength);    }    myPtr[inStringLength] = '\0';    *outCStringPtr = myPtr;  }  return err;}//----------------------------------------------------------------------------------------//    CopyCToPStr: //----------------------------------------------------------------------------------------void CopyCToPStr(const char *inCString, unsigned char *outPString){  CopyCToPStrn(inCString, outPString, kMaxPStringLength);} //----------------------------------------------------------------------------------------//    CopyCToPStrn //----------------------------------------------------------------------------------------void CopyCToPStrn(const char *inCString, unsigned char *outPString, UInt32 inMaxLength){  unsigned long    length;    length = strlen(inCString);  if (length &gt; inMaxLength)  {    length = kMaxPStringLength;  }  BlockMoveData(inCString, &amp;(outPString[1]), (long)length);  outPString[0] = (unsigned char)length;} //----------------------------------------------------------------------------------------//    CopyPToCStr: //----------------------------------------------------------------------------------------void CopyPToCStr(const unsigned char *inPString, char *outCString){  CopyPToCStrn(inPString, outCString, kMaxPStringLength);} //----------------------------------------------------------------------------------------//    CopyPToCStrn //----------------------------------------------------------------------------------------void CopyPToCStrn(const unsigned char *inPString, char *outCString, UInt32 inMaxLength){  unsigned long    length;    length = inPString[0];  if (length &gt; inMaxLength)  {    length = inMaxLength;  }  BlockMoveData( &amp;(inPString[1]), outCString, (long)length );  outCString[length] = '\0';} // ---------------------------------------------------------------------------//    pstrcpy// ---------------------------------------------------------------------------unsigned char *pstrcpy(unsigned char *dest, const unsigned char *source){  BlockMoveData(source, dest, source[0]+1);  return dest;}// ---------------------------------------------------------------------------//    pstrncpy// ---------------------------------------------------------------------------unsigned char *pstrncpy(unsigned char *dest, const unsigned char *source, long maxLength){  long    copyLength;    if (maxLength &lt; source[0])  {    copyLength = maxLength+1;  }  else  {    copyLength = source[0]+1;  }  BlockMoveData(source, dest, copyLength);  dest[0] = (unsigned char)(copyLength-1);  return dest;}// ---------------------------------------------------------------------------//    pstrcat// ---------------------------------------------------------------------------unsigned char *pstrcat(unsigned char *dest, const unsigned char *source){  BlockMoveData(source + 1, dest + dest[0]+1, source[0]);  dest[0] = (unsigned char)(dest[0] + source[0]);  return dest;}// ---------------------------------------------------------------------------//    pstrncat// ---------------------------------------------------------------------------unsigned char *pstrncat(unsigned char *dest, const unsigned char *source, long maxLength){  long    copyLength;    if (maxLength - (dest[0]+1) &lt; source[0])  {    copyLength = maxLength - (dest[0]+1);  }  else  {    copyLength = source[0];  }  BlockMoveData(source + 1, dest + dest[0]+1, copyLength);  dest[0] = (unsigned char)(dest[0] + copyLength);  return dest;}// ---------------------------------------------------------------------------//    ScanTo// ---------------------------------------------------------------------------char *ScanTo(const char *inText, char inChar, UInt32 inTextLength){  const char  *current = inText;  const char  *end = inText + inTextLength;  Boolean    found = false;  // like strchr except it doesn't assume null terminated  while (current &lt; end)  {    if (current[0] == inChar)  {      found = true;      break;    }    ++current;  }  return (found ? (char*)current : NULL);}// ---------------------------------------------------------------------------//    ScanToString// ---------------------------------------------------------------------------const char *ScanToString(const char *inText, UInt32 inTextLength,        const char *inMatchString, UInt32 inMatchStringLength){  const char  *current = inText;  const char  *end = inText + inTextLength;  Boolean    done = false;  Boolean    found = false;  char    firstChar;    firstChar = inMatchString[0];  while ( (current &lt; end)  &amp;&amp;      ((current = ScanTo(current, firstChar, end - current)) != NULL) )  {    if (StartsWith(current, end - current, inMatchString, inMatchStringLength))  {      found = true;      break;    }  else  {      ++current;    }  };  if (!found)  {    current = NULL;  }  return current;}// ---------------------------------------------------------------------------//    StartsWith// ---------------------------------------------------------------------------Boolean StartsWith(const char *inLine, UInt32 inMaxLineLength,        const char *inMatchString, UInt32 inMatchStringLength){  Boolean    matches = false;  if ((inMaxLineLength == 0)  ||  (inLine[0] == '\0')  ||    (inMatchStringLength == 0)  ||  (inMatchString[0] == '\0') )  {    //DEBUGF((&quot;StartsWith - one string is empty&quot;));  }  else  {    if (inMaxLineLength &gt;= inMatchStringLength)  {      matches = EqualChars(inLine, inMatchStringLength, inMatchString, inMatchStringLength);    }  }  return matches;}// ---------------------------------------------------------------------------//    EndsWith// ---------------------------------------------------------------------------Boolean EndsWith(const char *inLine, UInt32 inMaxLineLength,          const char *inMatchString, UInt32 inMatchStringLength){  Boolean    matches = false;  if ((inMaxLineLength == 0)  ||  (inLine[0] == '\0')  ||    (inMatchStringLength == 0)  ||  (inMatchString[0] == '\0') )  {    //DEBUGF((&quot;EndsWith - one string is empty&quot;));  }  else  {    if (inMaxLineLength &gt;= inMatchStringLength)  {      matches = EqualChars(inLine + (inMaxLineLength - inMatchStringLength),          inMatchStringLength, inMatchString, inMatchStringLength);    }  }  return matches;}// ---------------------------------------------------------------------------//    EqualChars// ---------------------------------------------------------------------------Boolean EqualChars(const char *inCharsA, UInt32 inCharsALength,          const char *inCharsB, UInt32 inCharsBLength){#if TARGET_API_MAC_CARBON  return (Boolean)(IdenticalText(inCharsA, inCharsB,          inCharsALength, inCharsBLength, nil) == 0);#else  // IUMagIDString has some problems with zero lengths, so check beforehand  if ((inCharsALength &gt; 0)  &amp;&amp;  (inCharsA[0] != '\0')  &amp;&amp;    (inCharsBLength &gt; 0)  &amp;&amp;  (inCharsB[0] != '\0'))  {    return (Boolean)(IUMagIDString(inCharsA, inCharsB,        (short)inCharsALength, (short)inCharsBLength) == 0);  }  return false;#endif}// ---------------------------------------------------------------------------//    GetLineEnd// ---------------------------------------------------------------------------const char *GetLineEnd(const char *inChars, UInt32 inMaxLength){  const char    *current = inChars;  const char    *end = inChars + inMaxLength;     while ( (current &lt; end)    &amp;&amp;      (current[0] != CR)   &amp;&amp;      (current[0] != LF)  &amp;&amp;      (current[0] != '\0') )  {          ++current;  }  return current;}// ---------------------------------------------------------------------------//    GetNextLineStart// ---------------------------------------------------------------------------const char *GetNextLineStart(const char *inChars, UInt32 inMaxLength){  const char    *current = inChars;  const char    *end = inChars + inMaxLength;     while ( (current &lt; end)    &amp;&amp;      (current[0] == CR)   &amp;&amp;      (current[0] == LF)  &amp;&amp;      (current[0] != '\0') )  {    ++current;  }  return current;}// ---------------------------------------------------------------------------//    IsEOLChar// ---------------------------------------------------------------------------Boolean IsEOLChar(char inChar){  return ((inChar == CR)  ||  (inChar == LF));}// ---------------------------------------------------------------------------//    GetShortDateTimeString// ---------------------------------------------------------------------------void GetShortDateTimeString(char *outString, UInt32 inRandomNum){  UInt32      secs;  DateTimeRec    rec;  UInt32      randomNum;  OSErr      err = noErr;    GetDateTime(&amp;secs);  SecondsToDate( secs, &amp;rec);  randomNum = inRandomNum &amp; 0x000000FF;  if (randomNum == 0)  {    sprintf(outString, &quot;%02d%02d%02d%02d%02d%02d&quot;,      rec.year &gt; 1999 ? rec.year - 2000 : rec.year - 1900,      rec.month, rec.day, rec.hour, rec.minute, rec.second);  }  else  {    sprintf(outString, &quot;%02d%02d%02d%02d%02d%02d%02d&quot;,      rec.year &gt; 1999 ? rec.year - 2000 : rec.year - 1900,      rec.month, rec.day, rec.hour, rec.minute, rec.second, randomNum);  }}#pragma mark -//-----------------------------------------------------------------------------//    GetFileContents//-----------------------------------------------------------------------------OSErr GetFileContents(const FSSpec *inSpec, UInt32 inMaxHandleSize,          Handle *outContents, UInt32 *outFileSize){  OSErr    err = noErr;  short    refNum = kFileNotOpen;  long    length;  Handle    myHandle = NULL;    EXITIFERR( err = FSpOpenDF(inSpec, fsRdPerm, &amp;refNum) );  EXITIFERR( err = GetEOF(refNum, &amp;length) );  if (outFileSize != NULL)  {    *outFileSize = length;  }  if ((inMaxHandleSize != 0)  &amp;&amp;  (length &gt; (SInt32)inMaxHandleSize))  {    length = inMaxHandleSize;  }  myHandle = NewHandle(length);  EXITIFERR( err = MemError() );  HLock(myHandle);  EXITIFERR( err = FSRead(refNum, &amp;length, *myHandle) );  HUnlock(myHandle);  *outContents = myHandle;exit:  if (refNum != kFileNotOpen)  {    FSClose(refNum);  }  if (err != noErr)  {    DisposeHandle(myHandle);    }  return err;}//-----------------------------------------------------------------------------//    MakeFolderIfNecessary//-----------------------------------------------------------------------------OSErr MakeFolderIfNecessary( short inVRefNum, long inParentDirID,           const StringPtr inName, long *outFolderDirID ){  OSErr    err = noErr;  // try to get info on it   if (!FolderExists(inVRefNum, inParentDirID, inName, outFolderDirID))  {    err = DirCreate(inVRefNum, inParentDirID, inName, outFolderDirID);  }  return err;}//-----------------------------------------------------------------------------//    FolderExists//-----------------------------------------------------------------------------Boolean FolderExists(const short inVRefNum, const long inParentDirID,                const StringPtr inName, long *outFolderDirID){  CInfoPBRec    myCPB;  OSErr      err;  memset( &amp;myCPB, 0, sizeof(CInfoPBRec) );  myCPB.dirInfo.ioNamePtr = (StringPtr)inName;  //  ok to use const, since ioFDirIndex == 0  myCPB.dirInfo.ioVRefNum = inVRefNum;  myCPB.dirInfo.ioDrDirID = inParentDirID;       myCPB.dirInfo.ioFDirIndex = 0;   // to get info about the actual folder itself     err = PBGetCatInfoSync(  &amp;myCPB );  *outFolderDirID = myCPB.dirInfo.ioDrDirID;  return (Boolean)(err == noErr);}//-----------------------------------------------------------------------------//    GetAppRelativeFolderSpec//-----------------------------------------------------------------------------OSErr GetAppRelativeFolderSpec(const StringPtr inFolderName, FSSpec *outFolderSpec){  OSErr    err = noErr;  FSSpec    mySpec;  if (inFolderName != NULL)  {    FindThisApplication(&amp;mySpec);    err = FSMakeFSSpec(mySpec.vRefNum, mySpec.parID, inFolderName, outFolderSpec);  }  else  {    FindThisApplication(outFolderSpec);  }          return err;}#pragma mark -// ---------------------------------------------------------------------------//  DialogGetItemHandle// ---------------------------------------------------------------------------void DialogSetItemHandle( DialogPtr inDialog, DialogItemIndex inItemIndex, Handle handle){  Handle  temp;  short  type;  Rect  rect;    GetDialogItem( inDialog, inItemIndex, &amp;type, &amp;temp, &amp;rect);  SetDialogItem( inDialog, inItemIndex, type, handle, &amp;rect);}// ---------------------------------------------------------------------------//  DialogGetItemHandle// ---------------------------------------------------------------------------void DialogGetItemHandle( DialogPtr inDialog, DialogItemIndex inItemIndex, Handle* handle){  short  type;  Rect  rect;    GetDialogItem( inDialog, inItemIndex, &amp;type, handle, &amp;rect);}// ---------------------------------------------------------------------------//  DialogSetControlValue// ---------------------------------------------------------------------------void DialogSetControlValue( DialogPtr inDialog, DialogItemIndex inItemIndex, SInt16 value){  Handle  handle;  short  type;  Rect  rect;    GetDialogItem( inDialog, inItemIndex, &amp;type, &amp;handle, &amp;rect);  SetControlValue( (ControlHandle)handle, value);}// ---------------------------------------------------------------------------//  DialogGetControlValue// ---------------------------------------------------------------------------SInt16 DialogGetControlValue( DialogPtr inDialog, DialogItemIndex inItemIndex){  Handle  handle;  short  type;  Rect  rect;  SInt16  value;    GetDialogItem( inDialog, inItemIndex, &amp;type, &amp;handle, &amp;rect);  value = GetControlValue( (ControlHandle)handle);  return value;}// ---------------------------------------------------------------------------//  DialogSetControlTitle// ---------------------------------------------------------------------------void DialogSetControlTitle( DialogPtr inDialog, DialogItemIndex inItemIndex, StringPtr title){  Handle  handle;  short  type;  Rect  rect;    GetDialogItem( inDialog, inItemIndex, &amp;type, &amp;handle, &amp;rect);  SetControlTitle( (ControlHandle)handle, title);}// ---------------------------------------------------------------------------//  DialogGetControlTitle// ---------------------------------------------------------------------------void DialogGetControlTitle( DialogPtr inDialog, DialogItemIndex inItemIndex, StringPtr title){  Handle  handle;  short  type;  Rect  rect;    GetDialogItem( inDialog, inItemIndex, &amp;type, &amp;handle, &amp;rect);  GetControlTitle( (ControlHandle)handle, title);}// ---------------------------------------------------------------------------//  DialogSetRadioButton// ---------------------------------------------------------------------------void DialogSetRadioButton( DialogPtr inDialog, DialogItemIndex inItemIndex, Boolean enable){  DialogSetCheckBox( inDialog, inItemIndex, enable);}// ---------------------------------------------------------------------------//  DialogGetRadioButton// ---------------------------------------------------------------------------void DialogGetRadioButton( DialogPtr inDialog, DialogItemIndex inItemIndex, Boolean* enabled){  DialogGetCheckBox(inDialog, inItemIndex, enabled);}// ---------------------------------------------------------------------------//  DialogSetCheckBox// ---------------------------------------------------------------------------void DialogSetCheckBox( DialogPtr inDialog, DialogItemIndex inItemIndex, Boolean enable){  DialogSetControlValue( inDialog, inItemIndex, (short)(enable? 1: 0));}// ---------------------------------------------------------------------------//  DialogGetCheckBox// ---------------------------------------------------------------------------void DialogGetCheckBox( DialogPtr inDialog, DialogItemIndex inItemIndex, Boolean* enabled){  SInt16  value;    value = DialogGetControlValue( inDialog, inItemIndex);  if (value == 0){    *enabled = false;  }else{    *enabled = true;  }}// ---------------------------------------------------------------------------//  DialogSetTextInteger// ---------------------------------------------------------------------------void DialogSetTextInteger( DialogPtr inDialog, DialogItemIndex inItemIndex, SInt32 number){  Str63  text;    NumToString( number, text);  DialogSetText( inDialog, inItemIndex, text, false);    }// ---------------------------------------------------------------------------//  DialogGetTextInteger// ---------------------------------------------------------------------------SInt32 DialogGetTextInteger( DialogPtr inDialog, DialogItemIndex inItemIndex){  Str63  text;  SInt32  number;    DialogGetText( inDialog, inItemIndex, text);      StringToNum( text, &amp;number);    return number;}// ---------------------------------------------------------------------------//  DialogSetText// ---------------------------------------------------------------------------void DialogSetText(DialogPtr inDialog, DialogItemIndex inItemIndex, StringPtr text, Boolean inSelectText){  Handle  handle;  short  type;  Rect  temp;    GetDialogItem( inDialog, inItemIndex, &amp;type, &amp;handle, &amp;temp);  SetDialogItemText( handle, text);  if (inSelectText)  {      DialogSelectText( inDialog, inItemIndex);  }  }// ---------------------------------------------------------------------------//  DialogGetText// ---------------------------------------------------------------------------void DialogGetText( DialogPtr inDialog, DialogItemIndex inItemIndex, StringPtr text){  Handle  handle;  short  type;  Rect  temp;    GetDialogItem( inDialog, inItemIndex, &amp;type, &amp;handle, &amp;temp);  GetDialogItemText( handle, text);    }// ---------------------------------------------------------------------------//  DialogSelectText// ---------------------------------------------------------------------------void DialogSelectText( DialogPtr inDialog, DialogItemIndex inItemIndex){  SelectDialogItemText( inDialog, inItemIndex, 0, 32767);}// ---------------------------------------------------------------------------//  DialogSetItemRect// ---------------------------------------------------------------------------void DialogSetItemRect( DialogPtr inDialog, DialogItemIndex inItemIndex, Rect* rect){  Handle  handle;  short  type;  Rect  temp;    GetDialogItem( inDialog, inItemIndex, &amp;type, &amp;handle, &amp;temp);  SetDialogItem( inDialog, inItemIndex, type, handle, rect);}// ---------------------------------------------------------------------------//  DialogGetItemRect// ---------------------------------------------------------------------------void DialogGetItemRect( DialogPtr inDialog, DialogItemIndex inItemIndex, Rect* rect){  Handle  handle;  short  type;    GetDialogItem( inDialog, inItemIndex, &amp;type, &amp;handle, rect);}// ---------------------------------------------------------------------------//  DialogRefreshItemRect// ---------------------------------------------------------------------------void DialogRefreshItemRect( DialogPtr inDialog, DialogItemIndex inItemIndex){  Rect  rect;    DialogGetItemRect( inDialog, inItemIndex, &amp;rect);#if TARGET_API_MAC_CARBON  InvalWindowRect( GetDialogWindow(inDialog), &amp;rect);#else  InvalRect( &amp;rect);#endif}// ---------------------------------------------------------------------------//  DialogEnableItem// ---------------------------------------------------------------------------void DialogEnableItem( DialogPtr inDialog, DialogItemIndex inItemIndex, Boolean enable){  Handle  handle;  short  type;  Rect  rect;    GetDialogItem( inDialog, inItemIndex, &amp;type, &amp;handle, &amp;rect);  if ( handle != NULL){    HiliteControl( (ControlHandle)handle, (short)(enable? 0: 255));  }}// ---------------------------------------------------------------------------//  DialogShowItem// ---------------------------------------------------------------------------void DialogShowItem( DialogPtr inDialog, DialogItemIndex inItemIndex, Boolean show){  if (show){    ShowDialogItem( inDialog, inItemIndex);  }else{    HideDialogItem( inDialog, inItemIndex);  }}// ---------------------------------------------------------------------------//  DialogOffsetControl// ---------------------------------------------------------------------------void DialogOffsetControl( DialogPtr inDialog, DialogItemIndex inItemIndex, SInt16 xOffset, SInt16 yOffset){  Rect      rect;  ControlHandle  control;    DialogGetItemRect( inDialog, inItemIndex, &amp;rect);  MacOffsetRect( &amp;rect, xOffset, yOffset);  DialogSetItemRect( inDialog, inItemIndex, &amp;rect);  DialogGetItemHandle( inDialog, inItemIndex, (Handle*)&amp;control);    MoveControl( control, rect.left, rect.top);}// ---------------------------------------------------------------------------//  DialogAnimateControl// ---------------------------------------------------------------------------void DialogAnimateControl( DialogPtr inDialog, DialogItemIndex inItemIndex){  ControlHandle  handle;  UInt32      ticks;    DialogGetItemHandle( inDialog, inItemIndex, (Handle*)&amp;handle);  HiliteControl( handle, kControlButtonPart);  Delay( 8, &amp;ticks);  HiliteControl( handle, 0);}// ---------------------------------------------------------------------------//  DialogSetControl// ---------------------------------------------------------------------------void DialogSetControlProc( DialogPtr inDialog, DialogItemIndex inItemIndex, ControlActionUPP proc){  ControlHandle  control;    DialogGetItemHandle( inDialog, inItemIndex, (Handle*)&amp;control);  SetControlAction( control, proc);}// ---------------------------------------------------------------------------//  DialogSetControlRange// ---------------------------------------------------------------------------void DialogSetControlRange( DialogPtr inDialog, DialogItemIndex inItemIndex, SInt16 min, SInt16 max){  ControlHandle  control;    DialogGetItemHandle( inDialog, inItemIndex, (Handle*)&amp;control);  SetControlMinimum( control, min);  SetControlMaximum( control, max);}#pragma mark -typedef struct UserItemRec  {  long padding1;  Rect box;  short padding2;} UserItemRec;typedef struct DITLRec  {  short numItems;  UserItemRec theUserItems[1];} DITLRec, **DITLHand;// ---------------------------------------------------------------------------//    DITLGetItemRect// ---------------------------------------------------------------------------void DITLGetItemRect(Handle inDITLHandle, DialogItemIndex inItemIndex, Rect *outRect){  DITLHand    myDitlHandle = (DITLHand)inDITLHandle;  *outRect = (**myDitlHandle).theUserItems[inItemIndex-1].box;}// ---------------------------------------------------------------------------//    DITLSetItemRect// ---------------------------------------------------------------------------void DITLSetItemRect(Handle inDITLHandle, DialogItemIndex inItemIndex, Rect *inRect){  DITLHand    myDitlHandle = (DITLHand)inDITLHandle;  (**myDitlHandle).theUserItems[inItemIndex-1].box = *inRect;}#pragma mark -// ---------------------------------------------------------------------------//  MenuEnableItem// ---------------------------------------------------------------------------void MenuEnableItem( MenuHandle menu, MenuItemIndex index, Boolean enable){  if (enable){    DisableMenuItem( menu, index);  }else{    MacEnableMenuItem( menu, index);  }}#pragma mark -//-----------------------------------------------------------------------------//    FindThisApplication//-----------------------------------------------------------------------------// return a File Spec for the current app filestatic void FindThisApplication(FSSpec *outSpec){  ProcessSerialNumber process;  ProcessInfoRec     info;    MacGetCurrentProcess(&amp;process);    info.processInfoLength = sizeof(ProcessInfoRec);  info.processName = nil;  info.processAppSpec = outSpec;  GetProcessInformation(&amp;process, &amp;info);}#pragma mark -#define kMaxDebugFBufferSize    512// ---------------------------------------------------------------------------//    Logger_New// ---------------------------------------------------------------------------OSErr Logger_New(const FSSpec *inFileSpec, SInt32 inFlags,        OSType inFileCreator, OSType inFileType, Logger *outLog){  OSErr    err = noErr;  Logger    log = NULL;    log = (Logger)QTSNewHandleClear(sizeof(LoggerRecord));  if (log == NULL)  {    EXITERR( err = memFullErr );  }  EXITIFERR( err = MemError() );    BlockMoveData(inFileSpec, &amp;((**log).fileSpec), sizeof(FSSpec));  (**log).flags = inFlags;  (**log).fileRefNum = kFileNotOpen;  (**log).fileCreator = inFileCreator;  (**log).fileType = inFileType;  *outLog = log;exit:  return err;}// ---------------------------------------------------------------------------//    Logger_Dispose// ---------------------------------------------------------------------------void Logger_Dispose(Logger inLog){  if (inLog != NULL)  {    if ((**inLog).fileRefNum != kFileNotOpen)  {      FSClose((**inLog).fileRefNum);    }    DisposeHandle((Handle)inLog);  }}// ---------------------------------------------------------------------------//    Logger_OpenFile// ---------------------------------------------------------------------------OSErr Logger_OpenFile(Logger inLog){  OSErr    err = noErr;  char    oldState;  short    refNum = kFileNotOpen;  long    length = 0;    oldState = HGetState((Handle)inLog);  HLock((Handle)inLog);  err = FSpOpenDF(&amp;((**inLog).fileSpec), fsRdWrPerm, &amp;refNum);  if (err == fnfErr)  {    EXITIFERR( err = FSpCreate(&amp;((**inLog).fileSpec), (**inLog).fileCreator, (**inLog).fileType, smSystemScript) );    EXITIFERR( err = FSpOpenDF(&amp;((**inLog).fileSpec), fsRdWrPerm, &amp;refNum) );  }      EXITIFERR( err = GetEOF(refNum, &amp;length) );  (**inLog).fileRefNum = refNum;  (**inLog).fileLength = length;exit:  HSetState((Handle)inLog, oldState);  return err;}// ---------------------------------------------------------------------------//    Logger_CloseFile// ---------------------------------------------------------------------------void Logger_CloseFile(Logger inLog){  if ((**inLog).fileRefNum != kFileNotOpen)  {    FSClose((**inLog).fileRefNum);    (**inLog).fileRefNum = kFileNotOpen;  }}// ---------------------------------------------------------------------------//    Logger_Write// ---------------------------------------------------------------------------OSErr Logger_Write(Logger inLog, SInt32 inFlags, const char *inData, UInt32 inLength){  OSErr    err = noErr;  Boolean    fileWasOpen = true;  long    count = inLength;  SInt32    flags = (**inLog).flags | inFlags;  if ((**inLog).fileRefNum == kFileNotOpen)  {    EXITIFERR( err = Logger_OpenFile(inLog) );    fileWasOpen = false;  }    EXITIFERR( err = SetFPos((**inLog).fileRefNum, fsFromLEOF, 0) );  if (flags &amp; kLoggerWriteFlag_AddDateTime)  {    EXITIFERR( err = Logger_WriteDateTime(inLog) );    }    EXITIFERR( err = FSWrite((**inLog).fileRefNum, &amp;count, inData) );    if (flags &amp; kLoggerWriteFlag_AddEOL)  {    EXITIFERR( err = Logger_WriteEOL(inLog) );  }exit:  if (!fileWasOpen)  {    Logger_CloseFile(inLog);  }  return err;}// ---------------------------------------------------------------------------//    Logger_Printf// ---------------------------------------------------------------------------OSErr Logger_Printf(Logger inLog, SInt32 inFlags, const char *format, ...){  OSErr    err = noErr;  Boolean    fileWasOpen = true;  long    count;  SInt32    flags = (**inLog).flags | inFlags;  unsigned char buffer[kMaxDebugFBufferSize];  va_list   ptr;    va_start(ptr, format);  buffer[0] = (unsigned char)vsprintf((char*)buffer + 1, format, ptr);  va_end(ptr);  if ((**inLog).fileRefNum == kFileNotOpen)  {    EXITIFERR( err = Logger_OpenFile(inLog) );    fileWasOpen = false;  }    EXITIFERR( err = SetFPos((**inLog).fileRefNum, fsFromLEOF, 0) );  if (flags &amp; kLoggerWriteFlag_AddDateTime)  {    EXITIFERR( err = Logger_WriteDateTime(inLog) );    }    count = buffer[0];  EXITIFERR( err = FSWrite((**inLog).fileRefNum, &amp;count, &amp;(buffer[1])) );    if (flags &amp; kLoggerWriteFlag_AddEOL)  {    EXITIFERR( err = Logger_WriteEOL(inLog) );  }exit:  if (!fileWasOpen)  {    Logger_CloseFile(inLog);  }  return err;}// ---------------------------------------------------------------------------//    Logger_WriteEOL// ---------------------------------------------------------------------------OSErr Logger_WriteEOL(Logger inLog){  OSErr    err = noErr;  Boolean    fileWasOpen = true;  long    count;  UInt32    eol;#if TARGET_OS_MAC  #define kEOL          0x0d000000  #define kEOLLength    1#else  #define kEOL          0x0d0a0000  #define kEOLLength    2#endif  if ((**inLog).fileRefNum == kFileNotOpen)  {    EXITIFERR( err = Logger_OpenFile(inLog) );    fileWasOpen = false;  }    EXITIFERR( err = SetFPos((**inLog).fileRefNum, fsFromLEOF, 0) );  eol = kEOL;  count = kEOLLength;  EXITIFERR( err = FSWrite((**inLog).fileRefNum, &amp;count, &amp;eol) );  exit:  if (!fileWasOpen)  {    Logger_CloseFile(inLog);  }  return err;}// ---------------------------------------------------------------------------//    Logger_WriteDateTime// ---------------------------------------------------------------------------OSErr Logger_WriteDateTime(Logger inLog){  OSErr      err = noErr;  Boolean      fileWasOpen = true;  long      count;  UInt32      secs;  Str255      tempString;  if ((**inLog).fileRefNum == kFileNotOpen)  {    EXITIFERR( err = Logger_OpenFile(inLog) );    fileWasOpen = false;  }  EXITIFERR( err = SetFPos((**inLog).fileRefNum, fsFromLEOF, 0) );  GetDateTime(&amp;secs);  DateString(secs, shortDate, tempString, NULL);  pstrcat(tempString, &quot;\p &quot;);  count = tempString[0];  EXITIFERR( err = FSWrite((**inLog).fileRefNum, &amp;count, &amp;(tempString[1])) );  TimeString(secs, true, tempString, NULL);  pstrcat(tempString, &quot;\p - &quot;);  count = tempString[0];  EXITIFERR( err = FSWrite((**inLog).fileRefNum, &amp;count, &amp;(tempString[1])) );  exit:  if (!fileWasOpen)  {    Logger_CloseFile(inLog);  }  return err;}static Logger sDebugLog = NULL;static SInt32 sDebugFlags = kDebugFlag_WriteToLog;// ---------------------------------------------------------------------------//    SetDebugLog// ---------------------------------------------------------------------------void SetDebugLog(Logger inLog){  sDebugLog = inLog;}// ---------------------------------------------------------------------------//    SetDebugFlags// ---------------------------------------------------------------------------void SetDebugFlags(SInt32 inFlags, SInt32 inFlagsMask){  sDebugFlags &amp;= ~inFlagsMask;  sDebugFlags |= (inFlags &amp; inFlagsMask);}#define DEBUGGER_STR( _pascalStrWithNull)  DebugStr( _pascalStrWithNull);#if USHER_DEBUG// ---------------------------------------------------------------------------//    samplecodeutilsdebugf// ---------------------------------------------------------------------------void samplecodeutilsdebugf(const char* format, ...){#if USHER_DEBUG  unsigned char buffer[kMaxDebugFBufferSize];  va_list ptr;    va_start(ptr, format);  buffer[0] = (unsigned char)vsprintf((char*)buffer + 1, format, ptr);  va_end(ptr);  #define kLogDebugPrefix    &quot;&lt;debugf&gt;&quot;    if (sDebugFlags &amp; kDebugFlag_WriteToLog)  {    if (sDebugLog != NULL)  {      Logger_Write(sDebugLog, kLoggerWriteFlag_AddDateTime,            kLogDebugPrefix, strlen(kLogDebugPrefix));      Logger_Write(sDebugLog, kLoggerWriteFlag_AddEOL,            (const char*)&amp;(buffer[1]), buffer[0]);    }  }  if (sDebugFlags &amp; kDebugFlag_DebugStr)  {    DEBUGGER_STR( buffer);  }#else  #pragma unused(format)#endif}#endif</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/usher/listing9.html%3Fid%3DDTS10001057-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/usher/listing9.html%3Fid%3DDTS10001057-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/usher/listing9.html%3Fid%3DDTS10001057-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>