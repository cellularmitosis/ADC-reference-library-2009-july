<html><head><title>Mac OS X
 Manual Page For Convert::BinHex(3pm)</title>
<style type="text/css"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { font-size: 1px; background: #ffffff; color: #ffffff; } --></style>
<style type="text/css" media="print, aural, braille, embossed, projection, tty"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { display: none; } --></style>
</head><body bgcolor="white">
<a name="//apple_ref/doc/man/3pm/Convert::BinHex" title="Mac OS X
 Manual Page for Convert::BinHex(3pm)"><a name="//apple_ref/doc/man/3/Convert::BinHex" title="Mac OS X
 Manual Page for Convert::BinHex(3pm)"><!-- headerDoc=man; indexgroup=Section 3pm; uid="//apple_ref/doc/man/3pm/Convert::BinHex"; name=Convert::BinHex(3pm) --></a>
<!--#include virtual="/includes/framesetheader"-->
<table width=600><tr><td scope="row">
<!-- begin breadcrumb insert request --><font face="Geneva,Helvetica,Arial" size="1">
 <a target="_top" href="http://developer.apple.com">ADC Home</a> <b>&gt;</b> <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> <b>&gt;</b> <a href="../../../../../reference/index.html#//apple_ref/doc/uid/TP30001281" target="_top">Reference</a> <b>&gt;</b> <!-- a href="" target="_top" -->Mac OS X<!-- /a --> <b>&gt;</b> <a href="../index.html#//apple_ref/doc/framework/manpages" target="_top">Mac OS X Man Pages</a></font>
<!-- end breadcrumb insert request -->
<p>&nbsp;</p>
</td></tr></table>
<!-- end of header -->
<table border="0"  cellpadding="2" cellspacing="2" width="630pt"><tr><td valign="top" height="12" colspan="5" scope="row">
<p style='text-align:justify;'>This document is a Mac OS X manual page.  Manual pages are a command-line technology
for providing documentation.  You can view these manual pages locally using the
<a href="../man1/man.1.html#//apple_ref/doc/man/1/man">man(1)</a> command.
These manual pages come from many different sources, and thus, have a variety of writing
styles.</p>
<p style='text-align:justify;'>For more information about the manual page format, see the manual page for 
<a href="../man5/manpages.5.html#//apple_ref/doc/man/5/manpages">manpages(5)</a>.</p>
</td></tr></table>
<hr />
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row"><pre class="manpages"><tt>
Convert::BinHex(3)                   User Contributed Perl Documentation                  Convert::BinHex(3)



<b>NAME</b>
       Convert::BinHex - extract data from Macintosh BinHex files

       <u>ALPHA</u> <u>WARNING:</u> <u>this</u> <u>code</u> <u>is</u> <u>currently</u> <u>in</u> <u>its</u> <u>Alpha</u> <u>release.</u>  <u>Things</u> <u>may</u> <u>change</u> <u>drastically</u> <u>until</u> <u>the</u>
       <u>interface</u> <u>is</u> <u>hammered</u> <u>out:</u> <u>if</u> <u>you</u> <u>have</u> <u>suggestions</u> <u>or</u> <u>objections,</u> <u>please</u> <u>speak</u> <u>up</u> <u>now!</u>

<b>SYNOPSIS</b>
       <b>Simple</b> <b>functions:</b>

           use Convert::BinHex qw(binhex_crc macbinary_crc);

           # Compute HQX7-style CRC for data, pumping in old CRC if desired:
           $crc = binhex_crc($data, $crc);

           # Compute the MacBinary-II-style CRC for the data:
           $crc = macbinary_crc($data, $crc);

       <b>Hex</b> <b>to</b> <b>bin,</b> <b>low-level</b> <b>interface.</b>  Conversion is actually done via an object
       ("Convert::BinHex::Hex2Bin") which keeps internal conversion state:

           # Create and use a "translator" object:
           my $H2B = Convert::BinHex-&gt;hex2bin;    # get a converter object
           while (&lt;STDIN&gt;) {
               print $STDOUT $H2B-&gt;next($_);        # convert some more input
           }
           print $STDOUT $H2B-&gt;done;              # no more input: finish up

       <b>Hex</b> <b>to</b> <b>bin,</b> <b>OO</b> <b>interface.</b>  The following operations <u>must</u> be done in the order shown!

           # Read data in piecemeal:
           $HQX = Convert::BinHex-&gt;open(FH=&gt;\*STDIN) || die "open: $!";
           $HQX-&gt;read_header;                  # read header info
           @data = $HQX-&gt;read_data;            # read in all the data
           @rsrc = $HQX-&gt;read_resource;        # read in all the resource

       <b>Bin</b> <b>to</b> <b>hex,</b> <b>low-level</b> <b>interface.</b>  Conversion is actually done via an object
       ("Convert::BinHex::Bin2Hex") which keeps internal conversion state:

           # Create and use a "translator" object:
           my $B2H = Convert::BinHex-&gt;bin2hex;    # get a converter object
           while (&lt;STDIN&gt;) {
               print $STDOUT $B2H-&gt;next($_);        # convert some more input
           }
           print $STDOUT $B2H-&gt;done;              # no more input: finish up

       <b>Bin</b> <b>to</b> <b>hex,</b> <b>file</b> <b>interface.</b>  Yes, you can convert <u>to</u> BinHex as well as from it!

           # Create new, empty object:
           my $HQX = Convert::BinHex-&gt;new;

           # Set header attributes:
           $HQX-&gt;filename("logo.gif");
           $HQX-&gt;type("GIFA");
           $HQX-&gt;creator("CNVS");

           # Give it the data and resource forks (either can be absent):
           $HQX-&gt;data(Path =&gt; "/path/to/data");       # here, data is on disk
           $HQX-&gt;resource(Data =&gt; $resourcefork);     # here, resource is in core

           # Output as a BinHex stream, complete with leading comment:
           $HQX-&gt;encode(\*STDOUT);

       <b>PLANNED!!!!</b> <b>Bin</b> <b>to</b> <b>hex,</b> <b>"CAP"</b> <b>interface.</b>  <u>Thanks</u> <u>to</u> <u>Ken</u> <u>Lunde</u> <u>for</u> <u>suggesting</u> <u>this</u>.

           # Create new, empty object from CAP tree:
           my $HQX = Convert::BinHex-&gt;from_cap("/path/to/root/file");
           $HQX-&gt;encode(\*STDOUT);

<b>DESCRIPTION</b>
       <b>BinHex</b> is a format used by Macintosh for transporting Mac files safely through electronic mail, as
       short-lined, 7-bit, semi-compressed data streams.  Ths module provides a means of converting those
       data streams back into into binary data.

<b>FORMAT</b>
       <u>(Some</u> <u>text</u> <u>taken</u> <u>from</u> <u>RFC-1741.)</u>  Files on the Macintosh consist of two parts, called <u>forks</u>:

       Data fork
           The actual data included in the file.  The Data fork is typically the only meaningful part of a
           Macintosh file on a non-Macintosh computer system.  For example, if a Macintosh user wants to
           send a file of data to a user on an IBM-PC, she would only send the Data fork.

       Resource fork
           Contains a collection of arbitrary attribute/value pairs, including program segments, icon
           bitmaps, and parametric values.

       Additional information regarding Macintosh files is stored by the Finder in a hidden file, called the
       "Desktop Database".

       Because of the complications in storing different parts of a Macintosh file in a non-Macintosh
       filesystem that only handles consecutive data in one part, it is common to convert the Macintosh file
       into some other format before transferring it over the network.  The BinHex format squashes that data
       into transmittable ASCII as follows:

       1.  The file is output as a <b>byte</b> <b>stream</b> consisting of some basic header information (filename, type,
           creator), then the data fork, then the resource fork.

       2.  The byte stream is <b>compressed</b> by looking for series of duplicated bytes and representing them
           using a special binary escape sequence (of course, any occurences of the escape character must
           also be escaped).

       3.  The compressed stream is <b>encoded</b> via the "6/8 hemiola" common to <u>base64</u> and <u>uuencode</u>: each group
           of three 8-bit bytes (24 bits) is chopped into four 6-bit numbers, which are used as indexes into
           an ASCII "alphabet".  (I assume that leftover bytes are zero-padded; documentation is thin).

<b>FUNCTIONS</b>
       <b>CRC</b> <b>computation</b>


       macbinary_crc DATA, SEED
           Compute the MacBinary-II-style CRC for the given DATA, with the CRC seeded to SEED.  Normally,
           you start with a SEED of 0, and you pump in the previous CRC as the SEED if you're handling a lot
           of data one chunk at a time.  That is:

               $crc = 0;
               while (&lt;STDIN&gt;) {
                   $crc = macbinary_crc($_, $crc);
               }

           <u>Note:</u> Extracted from the <u>mcvert</u> utility (Doug Moore, April '87), using a "magic array" algorithm
           by Jim Van Verth for efficiency.  Converted to Perl5 by Eryq.  <b>Untested.</b>

       binhex_crc DATA, SEED
           Compute the HQX-style CRC for the given DATA, with the CRC seeded to SEED.  Normally, you start
           with a SEED of 0, and you pump in the previous CRC as the SEED if you're handling a lot of data
           one chunk at a time.  That is:

               $crc = 0;
               while (&lt;STDIN&gt;) {
                   $crc = binhex_crc($_, $crc);
               }

           <u>Note:</u> Extracted from the <u>mcvert</u> utility (Doug Moore, April '87), using a "magic array" algorithm
           by Jim Van Verth for efficiency.  Converted to Perl5 by Eryq.

<b>OO</b> <b>INTERFACE</b>
       <b>Conversion</b>


       bin2hex
           <u>Class</u> <u>method,</u> <u>constructor.</u>  Return a converter object.  Just creates a new instance of
           "Convert::BinHex::Bin2Hex"; see that class for details.

       hex2bin
           <u>Class</u> <u>method,</u> <u>constructor.</u>  Return a converter object.  Just creates a new instance of
           "Convert::BinHex::Hex2Bin"; see that class for details.

       <b>Construction</b>


       new PARAMHASH
           <u>Class</u> <u>method,</u> <u>constructor.</u>  Return a handle on a BinHex'able entity.  In general, the data and
           resource forks for such an entity are stored in native format (binary) format.

           Parameters in the PARAMHASH are the same as header-oriented method names, and may be used to set
           attributes:

               $HQX = new Convert::BinHex filename =&gt; "icon.gif",
                                          type    =&gt; "GIFB",
                                          creator =&gt; "CNVS";

       open PARAMHASH
           <u>Class</u> <u>method,</u> <u>constructor.</u>  Return a handle on a new BinHex'ed stream, for parsing.  Params are:

           Data
               Input a HEX stream from the given data.  This can be a scalar, or a reference to an array of
               scalars.

           Expr
               Input a HEX stream from any <u>open()</u>able expression.  It will be opened and binmode'd, and the
               filehandle will be closed either on a "close()" or when the object is destructed.

           FH  Input a HEX stream from the given filehandle.

           NoComment
               If true, the parser should not attempt to skip a leading "(This file...)"  comment.  That
               means that the first nonwhite characters encountered must be the binhex'ed data.

       <b>Get/set</b> <b>header</b> <b>information</b>


       creator [VALUE]
           <u>Instance</u> <u>method.</u>  Get/set the creator of the file.  This is a four-character string (though I
           don't know if it's guaranteed to be printable ASCII!)  that serves as part of the Macintosh's
           version of a MIME "content-type".

           For example, a document created by "Canvas" might have creator "CNVS".

       data [PARAMHASH]
           <u>Instance</u> <u>method.</u>  Get/set the data fork.  Any arguments are passed into the <u>new()</u> method of
           "Convert::BinHex::Fork".

       filename [VALUE]
           <u>Instance</u> <u>method.</u>  Get/set the name of the file.

       flags [VALUE]
           <u>Instance</u> <u>method.</u>  Return the flags, as an integer.  Use bitmasking to get as the values you need.

       header_as_string
           Return a stringified version of the header that you might use for logging/debugging purposes.  It
           looks like this:

               X-HQX-Software: BinHex 4.0 (Convert::BinHex 1.102)
               X-HQX-Filename: Something_new.eps
               X-HQX-Version: 0
               X-HQX-Type: EPSF
               X-HQX-Creator: ART5
               X-HQX-Data-Length: 49731
               X-HQX-Rsrc-Length: 23096

           As some of you might have guessed, this is RFC-822-style, and may be easily plunked down into the
           middle of a mail header, or split into lines, etc.

       requires [VALUE]
           <u>Instance</u> <u>method.</u>  Get/set the software version required to convert this file, as extracted from
           the comment that preceded the actual binhex'ed data; e.g.:

               (This file must be converted with BinHex 4.0)

           In this case, after parsing in the comment, the code:

               $HQX-&gt;requires;

           would get back "4.0".

       resource [PARAMHASH]
           <u>Instance</u> <u>method.</u>  Get/set the resource fork.  Any arguments are passed into the <u>new()</u> method of
           "Convert::BinHex::Fork".

       type [VALUE]
           <u>Instance</u> <u>method.</u>  Get/set the type of the file.  This is a four-character string (though I don't
           know if it's guaranteed to be printable ASCII!)  that serves as part of the Macintosh's version
           of a MIME "content-type".

           For example, a GIF89a file might have type "GF89".

       version [VALUE]
           <u>Instance</u> <u>method.</u>  Get/set the version, as an integer.

       <b>Decode,</b> <b>high-level</b>


       read_comment
           <u>Instance</u> <u>method.</u>  Skip past the opening comment in the file, which is of the form:

              (This file must be converted with BinHex 4.0)

           As per RFC-1741, <u>this</u> <u>comment</u> <u>must</u> <u>immediately</u> <u>precede</u> <u>the</u> <u>BinHex</u> <u>data,</u> and any text before it
           will be ignored.

           <u>You</u> <u>don't</u> <u>need</u> <u>to</u> <u>invoke</u> <u>this</u> <u>method</u> <u>yourself;</u> "read_header()" will do it for you.  After the
           call, the version number in the comment is accessible via the "requires()" method.

       read_header
           <u>Instance</u> <u>method.</u>  Read in the BinHex file header.  You must do this first!

       read_data [NBYTES]
           <u>Instance</u> <u>method.</u>  Read information from the data fork.  Use it in an array context to slurp all
           the data into an array of scalars:

               @data = $HQX-&gt;read_data;

           Or use it in a scalar context to get the data piecemeal:

               while (defined($data = $HQX-&gt;read_data)) {
                  # do stuff with $data
               }

           The NBYTES to read defaults to 2048.

       read_resource [NBYTES]
           <u>Instance</u> <u>method.</u>  Read in all/some of the resource fork.  See "read_data()" for usage.

       <b>Encode,</b> <b>high-level</b>


       encode OUT
           Encode the object as a BinHex stream to the given output handle OUT.  OUT can be a filehandle, or
           any blessed object that responds to a "print()" message.

           The leading comment is output, using the "requires()" attribute.

<b>SUBMODULES</b>
       <b>Convert::BinHex::Bin2Hex</b>

       A BINary-to-HEX converter.  This kind of conversion requires a certain amount of state information;
       it cannot be done by just calling a simple function repeatedly.  Use it like this:

           # Create and use a "translator" object:
           my $B2H = Convert::BinHex-&gt;bin2hex;    # get a converter object
           while (&lt;STDIN&gt;) {
               print STDOUT $B2H-&gt;next($_);          # convert some more input
           }
           print STDOUT $B2H-&gt;done;               # no more input: finish up

           # Re-use the object:
           $B2H-&gt;rewind;                 # ready for more action!
           while (&lt;MOREIN&gt;) { ...

       On each iteration, "next()" (and "done()") may return either a decent-sized non-empty string
       (indicating that more converted data is ready for you) or an empty string (indicating that the
       converter is waiting to amass more input in its private buffers before handing you more stuff to
       output.

       Note that "done()" <u>always</u> converts and hands you whatever is left.

       This may have been a good approach.  It may not.  Someday, the converter may also allow you give it
       an object that responds to <u>read()</u>, or a FileHandle, and it will do all the nasty buffer-filling on
       its own, serving you stuff line by line:

           # Someday, maybe...
           my $B2H = Convert::BinHex-&gt;bin2hex(\*STDIN);
           while (defined($_ = $B2H-&gt;getline)) {
               print STDOUT $_;
           }

       Someday, maybe.  Feel free to voice your opinions.

       <b>Convert::BinHex::Hex2Bin</b>

       A HEX-to-BINary converter. This kind of conversion requires a certain amount of state information; it
       cannot be done by just calling a simple function repeatedly.  Use it like this:

           # Create and use a "translator" object:
           my $H2B = Convert::BinHex-&gt;hex2bin;    # get a converter object
           while (&lt;STDIN&gt;) {
               print STDOUT $H2B-&gt;next($_);          # convert some more input
           }
           print STDOUT $H2B-&gt;done;               # no more input: finish up

           # Re-use the object:
           $H2B-&gt;rewind;                 # ready for more action!
           while (&lt;MOREIN&gt;) { ...

       On each iteration, "next()" (and "done()") may return either a decent-sized non-empty string
       (indicating that more converted data is ready for you) or an empty string (indicating that the
       converter is waiting to amass more input in its private buffers before handing you more stuff to
       output.

       Note that "done()" <u>always</u> converts and hands you whatever is left.

       Note that this converter does <u>not</u> find the initial "BinHex version" comment.  You have to skip that
       yourself.  It only handles data between the opening and closing ":".

       <b>Convert::BinHex::Fork</b>

       A fork in a Macintosh file.

           # How to get them...
           $data_fork = $HQX-&gt;data;      # get the data fork
           $rsrc_fork = $HQX-&gt;resource;  # get the resource fork

           # Make a new fork:
           $FORK = Convert::BinHex::Fork-&gt;new(Path =&gt; "/tmp/file.data");
           $FORK = Convert::BinHex::Fork-&gt;new(Data =&gt; $scalar);
           $FORK = Convert::BinHex::Fork-&gt;new(Data =&gt; \@array_of_scalars);

           # Get/set the length of the data fork:
           $len = $FORK-&gt;length;
           $FORK-&gt;length(170);        # this overrides the REAL value: be careful!

           # Get/set the path to the underlying data (if in a disk file):
           $path = $FORK-&gt;path;
           $FORK-&gt;path("/tmp/file.data");

           # Get/set the in-core data itself, which may be a scalar or an arrayref:
           $data = $FORK-&gt;data;
           $FORK-&gt;data($scalar);
           $FORK-&gt;data(\@array_of_scalars);

           # Get/set the CRC:
           $crc = $FORK-&gt;crc;
           $FORK-&gt;crc($crc);

<b>UNDER</b> <b>THE</b> <b>HOOD</b>
       <b>Design</b> <b>issues</b>


       BinHex needs a stateful parser
           Unlike its cousins <u>base64</u> and <u>uuencode</u>, BinHex format is not amenable to being parsed line-by-<font color="#ffffff" class="whiteout">line.&nbsp;line-byline.</font>
           line.  There appears to be no guarantee that lines contain 4n encoded characters... and even if
           there is one, the BinHex compression algorithm interferes: even when you can <u>decode</u> one line at a
           time, you can't necessarily <u>decompress</u> a line at a time.

           For example: a decoded line ending with the byte "\x90" (the escape or "mark" character) is
           ambiguous: depending on the next decoded byte, it could mean a literal "\x90" (if the next byte
           is a "\x00"), or it could mean n-1 more repetitions of the previous character (if the next byte
           is some nonzero "n").

           For this reason, a BinHex parser has to be somewhat stateful: you cannot have code like this:

               #### NO! #### NO! #### NO! #### NO! #### NO! ####
               while (&lt;STDIN&gt;) {            # read HEX
                   print hexbin($_);          # convert and write BIN
               }

           unless something is happening "behind the scenes" to keep track of what was last done.  <u>The</u>
           <u>dangerous</u> <u>thing,</u> <u>however,</u> <u>is</u> <u>that</u> <u>this</u> <u>approach</u> <u>will</u> <u></u><b><u>s</u></b><u></u><b><u>e</u></b> <u>to</u> <u>work,</u> <u>if</u> <u>you</u> <u>only</u> <u>test</u> <u>it</u> <u>on</u> <u>BinHex</u>
           <u>files</u> <u>which</u> <u>do</u> <u>not</u> <u>use</u> <u>compression</u> <u>and</u> <u>which</u> <u>have</u> <u>4n</u> <u>HEX</u> <u>characters</u> <u>on</u> <u>each</u> <u>line.</u>

           Since we have to be stateful anyway, we use the parser object to keep our state.

       We need to be handle large input files
           Solutions that demand reading everything into core don't cut it in my book.  The first MPEG file
           that comes along can louse up your whole day.  So, there are no size limitations in this module:
           the data is read on-demand, and filehandles are always an option.

       Boy, is this slow!
           A lot of the byte-level manipulation that has to go on, particularly the CRC computing (which
           involves intensive bit-shifting and masking) slows this module down significantly.  What is
           needed perhaps is an <u>optional</u> extension library where the slow pieces can be done more quickly...
           a Convert::BinHex::CRC, if you will.  Volunteers, anyone?

           Even considering that, however, it's slower than I'd like.  I'm sure many improvements can be
           made in the HEX-to-BIN end of things.  No doubt I'll attempt some as time goes on...

       <b>How</b> <b>it</b> <b>works</b>

       Since BinHex is a layered format, consisting of...

             A Macintosh file [the "BIN"]...
                Encoded as a structured 8-bit bytestream, then...
                   Compressed to reduce duplicate bytes, then...
                      Encoded as 7-bit ASCII [the "HEX"]

       ...there is a layered parsing algorithm to reverse the process.  Basically, it works in a similar
       fashion to stdio's <u>fread()</u>:

              0. There is an internal buffer of decompressed (BIN) data,
                 initially empty.
              1. Application asks to read() n bytes of data from object
              2. If the buffer is not full enough to accomodate the request:
                   2a. The read() method grabs the next available chunk of input
                       data (the HEX).
                   2b. HEX data is converted and decompressed into as many BIN
                       bytes as possible.
                   2c. BIN bytes are added to the read() buffer.
                   2d. Go back to step 2a. until the buffer is full enough
                       or we hit end-of-input.

       The conversion-and-decompression algorithms need their own internal buffers and state (since the next
       input chunk may not contain all the data needed for a complete conversion/decompression operation).
       These are maintained in the object, so parsing two different input streams simultaneously is
       possible.

<b>WARNINGS</b>
       Only handles "Hqx7" files, as per RFC-1741.

       Remember that Macintosh text files use "\r" as end-of-line: this means that if you want a textual
       file to look normal on a non-Mac system, you probably want to do this to the data:

           # Get the data, and output it according to normal conventions:
           foreach ($HQX-&gt;read_data) { s/\r/\n/g; print }

<b>CHANGE</b> <b>LOG</b>
       Current version: $Id: BinHex.pm,v 1.119 1997/06/28 05:12:42 eryq Exp $

       Version 1.118
           Ready to go public (with Paul's version, patched for native Mac support)!  Warnings have been
           suppressed in a few places where undefined values appear.

       Version 1.115
           Fixed another bug in comp2bin, related to the MARK falling on a boundary between inputs.  Added
           testing code.

       Version 1.114
           Added BIN-to-HEX conversion.  Eh.  It's a start.  Also, a lot of documentation additions and
           cleanups.  Some methods were also renamed.

       Version 1.103
           Fixed bug in decompression (wasn't saving last character).  Fixed "NoComment" bug.

       Version 1.102
           Initial release.

<b>AUTHOR</b> <b>AND</b> <b>CREDITS</b>
       Written by Eryq, <a href="http://www.enteract.com/~eryq"><u>http://www.enteract.com/~eryq</u></a> / <u>eryq@enteract.com</u>

       Support for native-Mac conversion, <u>plus</u> invaluable contributions in Alpha Testing, <u>plus</u> a few
       patches, <u>plus</u> the baseline binhex/debinhex programs, were provided by Paul J. Schinder (NASA/GSFC).

       Ken Lunde (Adobe) suggested incorporating the CAP file representation.

<b>TERMS</b> <b>AND</b> <b>CONDITIONS</b>
       Copyright (c) 1997 by Eryq.  All rights reserved.  This program is free software; you can
       redistribute it and/or modify it under the same terms as Perl itself.

       This software comes with <b>NO</b> <b>WARRANTY</b> of any kind.  See the COPYING file in the distribution for
       details.



perl v5.8.8                                      1997-06-27                               Convert::BinHex(3)
</tt></pre>
</td></tr></table>
	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Darwin/Reference/ManPages/man3/Convert__BinHex.3pm.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Darwin/Reference/ManPages/man3/Convert__BinHex.3pm.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Darwin/Reference/ManPages/man3/Convert__BinHex.3pm.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

</body></html>
