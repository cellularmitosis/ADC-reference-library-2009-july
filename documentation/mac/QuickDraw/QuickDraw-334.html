<!-- Generated by Harlequin WebMaker 2.2.3 (23-Apr-1996)
LispWorks 3.2.2 -->
<HTML> <HEAD>
<TITLE>Using Pictures (IM: Im)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING334></A>



<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!--end of header -->

<center>
<A HREF="QuickDraw-333.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="QuickDraw-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="QuickDraw-476.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="QuickDraw-335.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="QuickDraw-2.html"><B>Imaging With QuickDraw</B></A> / <BR><DD><A HREF="QuickDraw-332.html"><B>Chapter 7 - Pictures</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING334-0></A>
<H1>Using Pictures</H1>
 To create a picture, you should<P>
<UL>
<LI>use the <CODE>OpenCPicture</CODE> function to create a <CODE>Picture</CODE> record and begin defining the picture
<LI>issue QuickDraw drawing commands, which are collected in the <CODE>Picture</CODE> record
<LI>use the <CODE>PicComment</CODE> procedure to include picture comments in the picture definition (optional)
<LI>use the <CODE>ClosePicture</CODE> procedure to conclude the picture definition<P>
</UL>
 To open an existing picture, you should<P>
<UL>
<LI>use File Manager routines to get a picture stored in a <CODE>'PICT'</CODE> file
<LI>use the <CODE>GetPicture</CODE> function to get a picture stored in a <CODE>'PICT'</CODE> resource
<LI>use the Scrap Manager function <CODE>GetScrap</CODE> to get a picture stored in the scrap<P>
</UL>
 To draw a picture, you should use the <CODE>DrawPicture</CODE> procedure.<P>
 To save a picture, you should<P>
<UL>
<LI>use File Manager routines to save the picture in a <CODE>'PICT'</CODE> file
<LI>use Resource Manager routines to save the picture in a <CODE>'PICT'</CODE> resource
<LI>use the Scrap Manager function <CODE>PutScrap</CODE> to place the picture in the scrap<P>
</UL>
 To conserve memory, you can spool large pictures to and from disk storage; you should<P>
<UL>
<LI>write your own low-level procedures--using File Manager routines--that read and write temporary <CODE>'PICT'</CODE> files to disk
<LI>use the <CODE>SetStdCProcs</CODE> procedure for a color graphics port (or the <CODE>SetStdProcs</CODE> procedure for a basic graphics port) and replace QuickDraw's standard low-level procedures <CODE>StdGetPic</CODE> and <CODE>StdPutPic</CODE> with your own procedures for reading and writing temporary <CODE>'PICT'</CODE> files to disk<P>
</UL>
 To gather information about a single picture, pixel map, or bitmap, you should<P>
<UL>
<LI>use the <CODE>GetPictInfo</CODE> function to get information about a picture, or use the <CODE>GetPixMapInfo</CODE> function to get information about a pixel map or bitmap
<LI>use the <CODE>Palette</CODE> record or the <CODE>ColorTable</CODE> record, the handles of which are returned by these functions in a <CODE>PictInfo</CODE> record, to examine the colors collected from the picture, pixel map, or bitmap
<LI>use the <CODE>FontSpec</CODE> record, the handle of which is returned by <CODE>GetPictInfo</CODE> in a <CODE>PictInfo</CODE> record, to examine the fonts contained in the picture
<LI>use the <CODE>CommentSpec</CODE> record, the handle of which is returned by <CODE>GetPictInfo</CODE> in a <CODE>PictInfo</CODE> record, to examine the picture comments contained in the picture
<LI>examine the rest of the fields of the <CODE>PictInfo</CODE> record for additional information--such as pixel depth or optimal resolution--about the picture, pixel map, or bitmap
<LI>use the Memory Manager procedure <CODE>DisposeHandle</CODE> to release the memory occupied by the <CODE>PictInfo</CODE>, <CODE>FontSpec</CODE>, and <CODE>CommentSpec</CODE> records; use the Palette Manager procedure <CODE>DisposePalette</CODE> to release the memory occupied by a <CODE>Palette</CODE> record; and use the Color QuickDraw procedure <CODE>DisposeCTable</CODE> to release the memory occupied by a <CODE>ColorTable</CODE> record when you are finished with the information collected by the <CODE>GetPictInfo</CODE> function<P>
</UL>
 To gather information about multiple pictures, pixel maps, and bitmaps, you should<P>
<UL>
<LI>use the <CODE>NewPictInfo</CODE> function to begin collecting pictures, pixel maps, and bitmaps for your survey
<LI>use the <CODE>RecordPictInfo</CODE> function to add the information for a picture to your survey
<LI>use the <CODE>RecordPixMapInfo</CODE> function to add the information for a pixel map or bitmap to your survey
<LI>use the <CODE>RetrievePictInfo</CODE> function to return the collected information in a <CODE>PictInfo</CODE> record
<LI>use the <CODE>Palette</CODE> record or the <CODE>ColorTable</CODE> record, the handles of which are returned in the <CODE>PictInfo</CODE> record, to examine the colors collected from the pictures, pixel maps, and bitmaps
<LI>use the <CODE>FontSpec</CODE> record, the handle of which is returned in the <CODE>PictInfo</CODE> record, to examine the fonts contained in the collected pictures
<LI>use the <CODE>CommentSpec</CODE> record, the handle of which is returned in the <CODE>PictInfo</CODE> record, to examine the picture comments contained in the collected pictures
<LI>examine the rest of the fields of the <CODE>PictInfo</CODE> record for additional information about the pictures, pixel maps, and bitmaps in your survey
<LI>use the <CODE>DisposePictInfo</CODE> function to dispose of the private data structures allocated by the <CODE>NewPictInfo</CODE> function; use the Memory Manager procedure <CODE>DisposeHandle</CODE> to release the memory occupied by <CODE>PictInfo</CODE>, <CODE>FontSpec</CODE>, and <CODE>CommentSpec</CODE> records; use the Palette Manager procedure <CODE>DisposePalette</CODE> to release the memory occupied by a <CODE>Palette</CODE> record; and use the Color QuickDraw procedure <CODE>DisposeCTable</CODE> to release the memory occupied by a <CODE>ColorTable</CODE> record when you are finished with the information collected by <CODE>NewPictInfo</CODE><P>
</UL>
 When you are finished using a picture (such as when you close the window containing it), you should<P>
<UL>
<LI>release the memory it occupies by calling the <CODE>KillPicture</CODE> procedure if the picture is not stored in a <CODE>'PICT'</CODE> resource
<LI>release the memory it occupies by calling the Resource Manager procedure <CODE>ReleaseResource</CODE> if the picture is stored in a <CODE>'PICT'</CODE> resource<P>
</UL>
 Before using the routines described in this chapter, you must use the <CODE>InitGraf</CODE> procedure, described in the chapter "Basic QuickDraw" in this book, to initialize QuickDraw. The routines in this chapter are available on all computers running System 7--including those supporting only basic QuickDraw. To test for the existence of System 7, use the <CODE>Gestalt</CODE> function with the <CODE>gestaltSystemVersion</CODE> selector. Test the low-order word in the <CODE>response</CODE> parameter; if the value is $0700 or greater, all of the routines in this chapter are supported.<A NAME=MARKER-2-248></A><P>
<DL>
<DT><B>Note</B>
<DD>On computers running only basic QuickDraw, the Picture Utilities return <CODE>NIL</CODE> in place of handles to <CODE>Palette</CODE> and <CODE>ColorTable</CODE> records.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
<A NAME=HEADING334-40></A>
<H2>Creating and Drawing Pictures</H2>
 <A NAME=MARKER-9-523></A>Use the <CODE>OpenCPicture</CODE> function to begin defining a picture. <CODE>OpenCPicture</CODE> collects your subsequent QuickDraw drawing commands in a new <CODE>Picture</CODE> record. To complete the collection of drawing and picture comment commands that define your picture, use the <CODE>ClosePicture</CODE> procedure.<P>
<DL>
<DT><B>Note</B>
<DD>Operations with the following routines are not recorded in pictures: <CODE>CopyMask</CODE>, <CODE>CopyDeepMask</CODE>, <CODE>SeedFill</CODE>, <CODE>SeedCFill</CODE>, <CODE>CalcMask</CODE>, <CODE>CalcCMask</CODE>, and <CODE>PlotCIcon</CODE>.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
 You pass information to <CODE>OpenCPicture</CODE> in the form of an <CODE>OpenCPicParams</CODE> record. This record provides a simple mechanism for specifying resolutions when creating images. For example, applications that create pictures from scanned images can specify resolutions higher than 72 dpi for these pictures in <CODE>OpenCPicParams</CODE> records.<A NAME=MARKER-2-571></A><P>
 <A HREF=#MARKER-9-44>Listing 7-1</A> shows an application-defined routine, <CODE>MyCreateAndDrawPict</CODE>, that begins creating a picture by assigning values to the fields of an <CODE>OpenCPicParams</CODE> record. In this example, the normal screen resolution of 72 dpi is specified as the picture's resolution. You also specify a rectangle for best displaying the picture at this resolution. <P>
<B>Listing 7-1  <A NAME=MARKER-9-44></A>Creating and drawing a picture</B><P>
<PRE>
FUNCTION MyCreateAndDrawPict(pFrame: Rect): PicHandle;
CONST
   cHRes = $00480000;   {for 72 dpi}
   cVRes = $00480000;   {for 72 dpi}
VAR
   myOpenCPicParams: OpenCPicParams;
   myPic:            PicHandle;
   trianglePoly:     PolyHandle;
BEGIN
   WITH myOpenCPicParams DO BEGIN
      srcRect := pFrame;   {best rectangle for displaying this picture}
      hRes := cHRes;       {horizontal resolution}
      vRes := cVRes;       {vertical resolution}
      version := - 2;      {always set this field to -2}
      reserved1 := 0;      {this field is unused}
      reserved2 := 0;      {this field is unused}
   END;
   myPic := OpenCPicture(myOpenCPicParams);  {start creating the picture}
   ClipRect(pFrame);                      {always set a valid clip region}
   FillRect(pFrame,dkGray);   {create a dark gray rectangle for background}
   FillOval(pFrame,ltGray);   {overlay the rectangle with a light gray oval}
   trianglePoly := OpenPoly;  {start creating a triangle}
   WITH pFrame DO BEGIN
      MoveTo(left,bottom);
      LineTo((right - left) DIV 2,top);
      LineTo(right,bottom);
      LineTo(left,bottom);
   END;
   ClosePoly;                 {finish the triangle}
   PaintPoly(trianglePoly);   {paint the triangle}
   KillPoly(trianglePoly);    {dispose of the memory for the triangle}
   ClosePicture;              {finish the picture}
   DrawPicture(myPic,pFrame);       {draw the picture}
   IF QDError &lt;&gt; noErr THEN
      ; {likely error is that there is insufficient memory}
   MyCreateAndDrawPict := myPic;
END;
</PRE>
 After assigning values to the fields of an <CODE>OpenCPicParams</CODE> record, the <CODE>MyCreateAndDrawPict</CODE> routine passes this record to the <CODE>OpenCPicture</CODE> function.<P>
<DL>
<DT><B>IMPORTANT</B>
<DD>Always use the <CODE>ClipRect</CODE> procedure to specify a clipping region appropriate for your picture before you call <CODE>OpenCPicture</CODE>. If you do not use <CODE>ClipRect</CODE> to specify a clipping region, <CODE>OpenCPicture</CODE> uses the clipping region specified in the current graphics port. If the clipping region is very large (as it is when a graphics port is initialized) and you scale the picture when drawing it, the clipping region can become invalid when <CODE>DrawPicture</CODE> scales the clipping region--in which case, your picture will not be drawn. On the other hand, if the graphics port specifies a small clipping region, part of your drawing may be clipped when you draw it. Setting a clipping region equal to the port rectangle of the current graphics port, as shown in <A HREF=#MARKER-9-44>Listing 7-1</A>, always sets a valid clipping region.<EM></EM><A NAME=MARKER-2-45></A>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
 The <CODE>MyCreateAndDrawPict</CODE> routine uses QuickDraw commands to draw a filled rectangle, a filled oval, and a black triangle. These commands are stored in the <CODE>Picture</CODE> record. <P>
<DL>
<DT><B>Note</B>
<DD>If there is insufficient memory to draw a picture in Color QuickDraw, the <CODE>QDError</CODE> function (described in the chapter "Color QuickDraw" in this book) returns the result code <CODE>noMemForPictPlaybackErr</CODE>.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
 The <CODE>MyCreateAndDrawPict</CODE> routine concludes the picture definition by using the <CODE>ClosePicture</CODE> procedure. By passing to the <CODE>DrawPicture</CODE> procedure the handle to the newly defined picture, <CODE>MyCreateAndDrawPict</CODE> replays in the current graphics port the drawing commands stored in the <CODE>Picture</CODE> record. <A HREF=#MARKER-9-46>Figure 7-3</A> shows the resulting figure.<P>
<A NAME=MARKER-9-46></A><B>Figure 7-3  A simple picture</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/PICT-S-01.jpg"><BR>
<DL>
<DT><B>Note</B>
<DD><A NAME=MARKER-9-335></A>After using <CODE>DrawPicture</CODE> to draw a picture, your application can use the Window Manager procedure <CODE>SetWindowPic</CODE> to save a handle to the picture in the window record. When the window's content region must be updated, the Window Manager draws this picture, or only a part of it as necessary, instead of generating an update event. Another Window Manager routine, the <CODE>GetWindowPic</CODE> function, allows your application to retrieve the picture handle that you store using <CODE>SetWindowPic</CODE>. When you use the Window Manager procedure <CODE>DisposeWindow</CODE> to close a window, <CODE>DisposeWindow</CODE> automatically calls the <CODE>KillPicture</CODE> procedure to release the memory allocated to a picture referenced in the window record. These routines and the window record are described in the chapter "Window Manager" in <I><A HREF="../Toolbox/Toolbox-2.html">Inside Macintosh: Macintosh Toolbox Essentials</A></I>.<EM></EM><A NAME=MARKER-2-255></A><A NAME=MARKER-2-420></A><A NAME=MARKER-2-52></A><A NAME=MARKER-2-52></A><A NAME=MARKER-2-141></A><A NAME=MARKER-2-142></A>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
<A NAME=HEADING334-55></A>
<H2><A NAME=MARKER-9-55></A>Opening and Drawing Pictures</H2>
 <A NAME=MARKER-2-56></A>Using File Manager routines, your application can retrieve pictures saved in <CODE>'PICT'</CODE> files; using the <CODE>GetPicture</CODE> function, your application can retrieve pictures saved in the resource forks of other file types; and using the Scrap Manager function <CODE>GetScrap</CODE>, your application can retrieve pictures stored in the scrap. <P>
<A NAME=HEADING334-57></A>
<H3><A NAME=MARKER-9-57></A>Drawing a Picture Stored in a 'PICT' File</H3>
 <A NAME=MARKER-2-234></A><A NAME=MARKER-8-7></A><A HREF=#MARKER-9-60>Listing 7-2</A> illustrates an application-defined routine, called <CODE>MyDrawFilePicture</CODE>, that uses File Manager routines to retrieve a picture saved in a <CODE>'PICT'</CODE> file. The <CODE>MyDrawFilePicture</CODE> routine takes a file reference number as a parameter. <P>
<B>Listing 7-2  <A NAME=MARKER-9-60></A>Opening and drawing a picture from disk</B><P>
<PRE>
FUNCTION MyDrawFilePicture(pictFileRefNum: Integer; destRect: Rect): OSErr;
CONST
   cPicFileHeaderSize = 512;
VAR
   myPic:      PicHandle;
   dataLength: LongInt;
   err:        OSErr;
BEGIN    {This listing assumes the current graphics port is set.}
   err := GetEOF(pictFileRefNum,dataLength);    {get file length}
   IF err = noErr THEN BEGIN
      err := SetFPos(pictFileRefNum,fsFromStart,
                     cPicFileHeaderSize); {move past the 512-byte 'PICT' }
                                          { file header}
      dataLength := dataLength - cPicFileHeaderSize;  {remove 512-byte }
                                    { 'PICT' file header from file length}
      myPic := PicHandle(NewHandle(dataLength)); {allocate picture handle}
      IF (err = noErr) &amp; (myPic &lt;&gt; NIL) THEN BEGIN
         HLock(Handle(myPic));   {lock picture handle before using FSRead}
         err := FSRead(pictFileRefNum,dataLength,Ptr(myPic^)); {read file}
         HUnlock(Handle(myPic)); {unlock picture handle after using FSRead}
         MyAdjustDestRect(myPic,destRect);   {see Listing 7-7 on page 7-18}
         DrawPicture(myPic,destRect);
         IF QDError &lt;&gt; noErr THEN
            ; {likely error is that there is insufficient memory}
         KillPicture(myPic);
      END;
   END;
   MyDrawFilePicture := err;
END;
</PRE>
 In code not shown in <A HREF=#MARKER-9-60>Listing 7-2</A>, this application uses the File Manager procedure <CODE>StandardGetFile</CODE> to display a dialog box that asks the user for the name of a <CODE>'PICT'</CODE> file; using the file system specification record returned by <CODE>StandardGetFile</CODE>, the application calls the File Manager function <CODE>FSpOpenDF</CODE> to return a file reference number for the file. The application then passes this file reference number to <CODE>MyDrawFilePicture</CODE>.<A NAME=MARKER-2-187></A><P>
 Because every <CODE>'PICT'</CODE> file contains a 512-byte header for application-specific use, <CODE>MyDrawFilePicture</CODE> uses the File Manager function <CODE>SetFPos</CODE> to skip past this header information. The <CODE>MyDrawFilePicture</CODE> function then uses the File Manager function <CODE>FSRead</CODE> to read the file's remaining bytes--those of the <CODE>Picture</CODE> record--into memory. <P>
 The <CODE>MyDrawFilePicture</CODE> function creates a handle for the buffer into which the <CODE>Picture</CODE> record is read. Passing this handle to the <CODE>DrawPicture</CODE> procedure, <CODE>MyDrawFilePicture</CODE> is able to replay onscreen the commands stored in the <CODE>Picture</CODE> record.<P>
 For large <CODE>'PICT'</CODE> files, it is useful to spool the picture data from disk as necessary instead of reading all of it directly into memory. In low-memory conditions, for example, your application might find it useful to create a temporary file on disk for storing drawing instructions; your application can read this information as necessary. The application-defined routine <CODE>MyReplaceGetPic</CODE> shown in <A HREF=#MARKER-9-63>Listing 7-3</A> replaces the <CODE>getPicProc</CODE> field of the current graphics port's <CODE>CQDProcs</CODE> record with an application-defined low-level routine, called <CODE>MyFileGetPic</CODE>. While QuickDraw's standard <CODE>StdGetPic</CODE> procedure reads picture data from memory, <CODE>MyFileGetPic</CODE> reads the picture data from disk. (<A HREF=#MARKER-9-91>Listing 7-10 on page 7-21</A> shows how to replace QuickDraw's standard <CODE>StdPutPic</CODE> procedure with one that writes data to a file so that your application can spool a large picture to disk.)<A NAME=MARKER-2-62></A><P>
<B>Listing 7-3  <A NAME=MARKER-9-63></A>Replacing QuickDraw's standard low-level picture-reading routine</B><P>
<PRE>
FUNCTION MyReplaceGetPic: QDProcsPtr;
VAR
   currPort:      GrafPtr;
   customProcs:   QDProcs;
   customCProcs:  CQDProcs;
   savedProcs:    QDProcsPtr;
BEGIN
   GetPort(currPort);
   savedProcs := currPort^.grafProcs;  {save current CQDProcs }
                                       { or QDProcs record}
   IF MyIsColorPort(currPort) THEN     {this is a color graphics port}
   BEGIN
      SetStdCProcs(customCProcs);   {create new CQDProcs record containing }
                                    { standard Color QuickDraw low-level }
                                    { routines}
      customCProcs.getPicProc := @MyFileGetPic; {replace StdGetPic with }
                                                { address of custom }
                                                { low-level routine }
                                                { shown in Listing 7-5}
      currPort^.grafProcs := @customCProcs;  {replace current CQDProcs }
                                             { record}
   END
   ELSE 
   BEGIN                            {this is a basic graphics port}
      SetStdProcs(customProcs);     {create new QDProcs record containing }
                                    { standard basic QuickDraw low-level }
                                    { routines}
      customProcs.getPicProc := @MyFileGetPic;  {replace StdGetPic with }
                                                { address of custom }
                                                { low-level routine }
                                                { shown in Listing 7-5}
      currPort^.grafProcs := @customProcs;   {replace current QDProcs record}
   END;
   MyReplaceGetPic := savedProcs;
END;
</PRE>
 <A HREF=#MARKER-9-64>Listing 7-4</A> shows the application-defined procedure <CODE>MyIsColorPort</CODE>, which <CODE>MyReplaceGetPic</CODE> calls to determine whether to replace the low-level picture-reading routine for a color graphics port or a basic graphics port.<P>
<B>Listing 7-4  <A NAME=MARKER-9-64></A>Determining whether a graphics port is color or basic</B><P>
<PRE>
FUNCTION MyIsColorPort(aPort: GrafPtr): Boolean;
BEGIN
   MyIsColorPort := (aPort^.portBits.rowBytes &lt; 0)
END;
</PRE>
 <A HREF=#MARKER-9-65>Listing 7-5</A> shows the application-defined procedure <CODE>MyFileGetPic</CODE>, which uses the File Manager function <CODE>FSRead</CODE> to read the file with the file reference number assigned to the application-defined global variable <CODE>gPictFileRefNum</CODE>.<P>
<B>Listing 7-5  <A NAME=MARKER-9-65></A>A custom low-level procedure for spooling a picture from disk</B><P>
<PRE>
PROCEDURE MyFileGetPic (dataPtr: Ptr; byteCount: Integer);
VAR
   longCount:  LongInt;
   myErr:      OSErr;
BEGIN
   longCount := byteCount;
   myErr := FSRead(gPictFileRefNum, longCount, dataPtr);
END;
</PRE>
 Your application does not keep track of where <CODE>FSRead</CODE> stops or resumes reading a file. After reading a portion of a file, <CODE>FSRead</CODE> automatically handles where to begin reading next. See <I><A HREF="../Files/Files-2.html">Inside Macintosh: Files</A></I> for more information about using <CODE>FSRead</CODE> and other File Manager routines to retrieve data stored in files.<A NAME=MARKER-2-66></A><A NAME=MARKER-2-67></A><P>
<A NAME=HEADING334-74></A>
<H3>Drawing a Picture Stored in the Scrap</H3>
 <A NAME=MARKER-2-545></A>As described in the chapter "Scrap Manager" in <I><A HREF="../MoreToolbox/MoreToolbox-2.html">Inside Macintosh: More Macintosh Toolbox</A></I>, your application can use the Scrap Manager to copy and paste data within a document created by your application, among different documents created by your application, and among documents created by your application and documents created by other applications. The two standard scrap formats that all Macintosh applications should support are <CODE>'PICT'</CODE> and <CODE>'TEXT'</CODE>. <P>
 <A HREF=#MARKER-9-69>Listing 7-6</A> illustrates the application-defined routine <CODE>MyPastePict</CODE>, which retrieves a picture stored on the scrap. For example, a user may have copied to the Clipboard a picture created in another application and then pasted the picture into the application that defines <CODE>MyPastePict</CODE>. The <CODE>MyPastePict</CODE> procedure uses the Scrap Manager procedure <CODE>GetScrap</CODE> to get a handle to the data stored on the scrap; <CODE>MyPastePict</CODE> then coerces this handle to one of type <CODE>PicHandle</CODE>, which it can pass to the <CODE>DrawPicture</CODE> procedure in order to replay the drawing commands stored in the scrap.<P>
<B>Listing 7-6  <A NAME=MARKER-9-69></A>Pasting in a picture from the scrap</B><P>
<PRE>
PROCEDURE MyPastePict(destRect: Rect);
VAR
   myPic:      PicHandle;
   dataLength: LongInt;
   dontCare:   LongInt;
BEGIN
   myPic := PicHandle(NewHandle(0));   {allocate a handle for the picture}
   dataLength := 
            GetScrap(Handle(myPic),'PICT',dontCare);  {get picture in scrap}
   IF dataLength &gt; 0 THEN {ensure there is PICT data}
   BEGIN
      MyAdjustDestRect(myPic,destRect);   {shown in Listing 7-7}
      DrawPicture(myPic,destRect);
      IF QDError &lt;&gt; noErr THEN
         ; {likely error is that there is insufficient memory}
   END
   ELSE
   ; {handle error for len &lt; or = 0 here}
END;
</PRE>
<A NAME=HEADING334-79></A>
<H3>Defining a Destination Rectangle</H3>
 <A NAME=MARKER-2-70></A>In addition to taking a handle to a picture as one parameter, <CODE>DrawPicture</CODE> also expects a destination rectangle as another parameter. You should specify this destination rectangle in coordinates local to the current graphics port. The <CODE>DrawPicture</CODE> procedure shrinks or stretches the picture as necessary to make it fit into this rectangle.<P>
 <A HREF=#MARKER-9-71>Listing 7-7</A> shows an application-defined routine called <CODE>MyAdjustDestRect</CODE> that centers the picture inside a destination rectangle, which is passed to <CODE>DrawPicture</CODE> when it's time to draw the picture. (<CODE>MyAdjustDestRect</CODE> first ensures that the picture fits inside the destination rectangle by scaling the picture if necessary.)<P>
<B>Listing 7-7  <A NAME=MARKER-9-71></A>Adjusting the destination rectangle for a picture</B><P>
<PRE>
PROCEDURE MyAdjustDestRect(aPict: PicHandle; VAR destRect: Rect);
VAR
   r:                      Rect;
   width, height:          Integer;
   scale, scaleH, scaleV:  Fixed;
BEGIN
   WITH destRect DO BEGIN  {determine width and height of destination rect}
      width := right - left;
      height := bottom - top;
   END;
   r := aPict^^.picFrame;        {get the bounding rectangle of the picture}
   OffsetRect(r, - r.left, - r.top);   {ensure upper-left corner is (0,0)}
   scale := Long2Fix(1);
   scaleH := FixRatio(width,r.right);     {get horizontal and vertical }
   scaleV := FixRatio(height,r.bottom);   { ratios of destination rectangle }
                                          { to bounding rectangle of picture}
   IF scaleH &lt; scale THEN scale := scaleH;   {if bounding rect of picture }
   IF scaleV &lt; scale THEN scale := scaleV;   { is greater than destination }
   IF scale &lt;&gt; Long2Fix(1) THEN              { rect, get scaling factors}
   BEGIN       {scale picture to fit inside destination rectangle}
      r.right := Fix2Long(FixMul(scale,Long2Fix(r.right)));
      r.bottom := Fix2Long(FixMul(scale,Long2Fix(r.bottom)));
    END;
   {next line centers the picture within the destination rectangle}
   OffsetRect(r,(width - r.right) DIV 2,(height - r.bottom) DIV 2);
   destRect := r;
END;
</PRE>
 The application calling <CODE>MyAdjustDestRect</CODE> begins defining a destination rectangle by determining a target area within a window--perhaps the entire content area of a window, or perhaps an area selected by the user within a window. The application passes this rectangle to <CODE>MyAdjustDestRect</CODE>.<P>
 A bounding rectangle is stored in the <CODE>picFrame</CODE> field of the <CODE>Picture</CODE> record for every picture. The <CODE>MyAdjustDestRect</CODE> routine uses the boundaries for the picture to determine whether the picture fits within the destination rectangle. If the picture is larger than the destination rectangle, <CODE>MyAdjustDestRect</CODE> scales the picture to make it fit the destination rectangle.<P>
 The <CODE>MyAdjustDestRect</CODE> routine then centers the picture within the destination rectangle. Finally, <CODE>MyAdjustDestRect</CODE> assigns the boundary rectangle of the centered picture to be the new destination rectangle. By returning a destination rectangle whose dimensions are identical to those of the bounding rectangle for the picture, <CODE>MyAdjustDestRect</CODE> assures that the picture is not stretched when drawn into its window.<P>
 <A NAME=MARKER-2-72></A>To display a picture at a resolution other than the one at which it was created, your application should compute an appropriate destination rectangle by scaling its width and height by the following factor:<P>
 scale factor = destination resolution / source resolution<P>
 For example, if a picture was created at 300 dpi and you want to display it at 75 dpi, then your application should compute the destination rectangle width and height as 1/4 of those of the picture's bounding rectangle. Your application can use the <CODE>GetPictInfo</CODE> function (described on <A HREF=QuickDraw-353.html#MARKER-9-226>page 7-46</A>) to gather information about a picture. The <CODE>PictInfo</CODE> record (described on <A HREF=QuickDraw-341.html#MARKER-9-137>page 7-31</A>) returned by <CODE>GetPictInfo</CODE> returns the picture's resolution in its <CODE>hRes</CODE> and <CODE>vRes</CODE> fields. The <CODE>sourceRect</CODE> field contains the bounding rectangle for displaying the image at its optimal resolution. <A NAME=MARKER-9-528></A><P>
<A NAME=HEADING334-90></A>
<H3>Drawing a Picture Stored in a 'PICT' Resource</H3>
 <A NAME=MARKER-2-74></A><A NAME=MARKER-9-40></A><A NAME=MARKER-2-76></A>To retrieve a picture stored in a <CODE>'PICT'</CODE> resource, specify its resource ID to the <CODE>GetPicture</CODE> function, which returns a handle to the picture. <A HREF=#MARKER-9-77>Listing 7-8</A> illustrates an application-defined routine, called <CODE>MyDrawResPICT</CODE>, that retrieves and draws a picture stored as a resource.<P>
<B>Listing 7-8  <A NAME=MARKER-9-77></A>Drawing a picture stored in a resource file</B><P>
<PRE>
PROCEDURE MyDrawResPICT(destRect: Rect; resID: Integer);
VAR
   myPic:   PicHandle;
BEGIN
   myPic := GetPicture(resID);   {get the picture from the resource fork}
   IF myPic &lt;&gt; NIL THEN BEGIN
      MyAdjustDestRect(myPic,destRect);{see Listing 7-7 on page 7-18}
      DrawPicture(myPic,destRect);
      IF QDError &lt;&gt; noErr THEN
         ; {likely error is that there is insufficient memory}
   END
   ELSE
   ; {handle the error here}
END;
</PRE>
 When you are finished using a picture stored as a <CODE>'PICT'</CODE> resource, you should use the Resource Manager procedure <CODE>ReleaseResource</CODE> instead of the QuickDraw procedure <CODE>KillResource</CODE> to release its memory.<A NAME=MARKER-2-78></A><P>
<DL>
<DT><B>IMPORTANT</B>
<DD>If you retrieve a picture stored in a <CODE>'PICT'</CODE> resource and pass its handle to the Window Manager procedure <CODE>SetWindowPic</CODE>, the Window Manager procedures <CODE>DisposeWindow</CODE> and <CODE>CloseWindow</CODE> do not delete it; instead, you must call <CODE>ReleaseResource</CODE> before calling <CODE>DisposeWindow</CODE> or <CODE>CloseWindow</CODE>.<EM></EM><A NAME=MARKER-2-79></A><A NAME=MARKER-2-42></A><A NAME=MARKER-2-526></A><A NAME=MARKER-2-83></A><A NAME=MARKER-2-84></A>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
<A NAME=HEADING334-96></A>
<H2>Saving Pictures</H2>
 <A NAME=MARKER-2-85></A><A NAME=MARKER-2-86></A><A NAME=MARKER-2-87></A>After creating or changing pictures, your application should allow the user to save them. To save a picture in a <CODE>'PICT'</CODE> file, you should use File Manager routines, such as <CODE>FSpCreate</CODE>, <CODE>FSpOpenDF</CODE>, <CODE>FSWrite</CODE>, and <CODE>FSClose</CODE>. The use of these routines is illustrated in <A HREF=#MARKER-9-88>Listing 7-9</A>, and they are described in detail in the chapter "File Manager" in <I><A HREF="../Files/Files-2.html">Inside Macintosh: Files</A></I>. Remember that the first 512 bytes of a <CODE>'PICT'</CODE> file are reserved for your application's own purposes. As shown in <A HREF=#MARKER-9-88>Listing 7-9</A>, your application should store the data (that is, the <CODE>Picture</CODE> record) after this 512-byte header.<P>
<B>Listing 7-9  <A NAME=MARKER-9-88></A>Saving a picture as a <CODE>'PICT'</CODE> file</B><P>
<PRE>
FUNCTION DoSavePICTAsCmd(picH: PicHandle): OSErr;
LABEL 8,9;
VAR
   myReply:                      StandardFileReply;
   err, ignore:                  OSErr;
   pictFileRefNum:               Integer;
   dataLength, zeroData, count:  LongInt;
BEGIN                {display the default Save dialog box}
   StandardPutFile('Save picture as:','untitled',myReply);
   err := noErr;  {return noErr if the user cancels}
   IF myReply.sfGood THEN 
   BEGIN
      IF NOT myReply.sfReplacing THEN  {create the file if it doesn't exist}
         err := FSpCreate(myReply.sfFile,'WAVE','PICT',smSystemScript);
      IF err &lt;&gt; noErr THEN GOTO 9;
      err := FSpOpenDF(myReply.sfFile,fsRdWrPerm,pictFileRefNum); {open file}
      IF err &lt;&gt; noErr THEN GOTO 8;
      zeroData := 0;
      dataLength := 4;
      FOR count := 1 TO 512 DIV dataLength DO   {write the PICT file header}
         err := FSWrite(pictFileRefNum,dataLength,
                        @zeroData); {for this app, put 0's in header}
      IF err &lt;&gt; noErr THEN GOTO 8;
      dataLength := GetHandleSize(Handle(picH));
      HLock(Handle(picH)); {lock picture handle before writing data}
      err := FSWrite(pictFileRefNum,dataLength,Ptr(picH^)); {write picture }
                                                            { data to file}
       HUnlock(Handle(picH)); {unlock picture handle after writing data}
   END;
   8:
      ignore := FSClose(pictFileRefNum);  {close the file}
   9:
      DoSavePICTAsCmd := err;
END;
</PRE>
 To save a picture in a <CODE>'PICT'</CODE> resource, you should use Resource Manager routines, such as <CODE>FSpOpenResFile</CODE> (to open your application's resource fork), <CODE>ChangedResource</CODE> (to change an existing <CODE>'PICT'</CODE> resource), <CODE>AddResource</CODE> (to add a new <CODE>'PICT'</CODE> resource), <CODE>WriteResource</CODE> (to write the data to the resource), and <CODE>CloseResFile</CODE> and <CODE>ReleaseResource</CODE> (to conclude saving the resource). These routines are described in the chapter "Resource Manager" in <I><A HREF="../MoreToolbox/MoreToolbox-2.html">Inside Macintosh: More Macintosh Toolbox</A></I>.<A NAME=MARKER-2-89></A><P>
 To place a picture in the scrap--for example, in response to the user choosing the Copy command to copy a picture to the Clipboard--use the Scrap Manager function <CODE>PutScrap</CODE>, which is described in the chapter "Scrap Manager" in <I><A HREF="../MoreToolbox/MoreToolbox-2.html">Inside Macintosh: More Macintosh Toolbox</A></I>.<A NAME=MARKER-2-551></A><P>
 For large <CODE>'PICT'</CODE> files, it is useful to spool the picture data to disk instead of writing it all directly into memory. In low-memory conditions, for example, your application might find it useful to create a temporary file on disk for storing drawing instructions; your application can read this information as necessary. The application-defined routine <CODE>MyReplacePutPic</CODE> shown in <A HREF=#MARKER-9-91>Listing 7-10</A> replaces the <CODE>putPicProc</CODE> field of the current graphics port's <CODE>CQDProcs</CODE> record with an application-defined low-level routine, called <CODE>MyFilePutPic</CODE>. While QuickDraw's standard <CODE>StdPutPic</CODE> procedure writes picture data to memory, <CODE>MyFilePutPic</CODE> writes the picture data to disk. (<A HREF=#MARKER-9-63>Listing 7-3 on page 7-14</A> shows how to replace QuickDraw's standard <CODE>StdGetPic</CODE> procedure with one that reads data from a spool file.)<P>
<B>Listing 7-10  <A NAME=MARKER-9-91></A>Replacing QuickDraw's standard low-level picture-writing routine</B><P>
<PRE>
FUNCTION MyReplacePutPic: QDProcsPtr;
VAR
   currPort:      GrafPtr;
   customProcs:   QDProcs;
   customCProcs:  CQDProcs;
   savedProcs:    QDProcsPtr;
BEGIN 
   GetPort(currPort);
   savedProcs := currPort^.grafProcs;  {save QDProcs or CQDProcs record }
                                       { for current graphics port}
   IF MyIsColorPort(currPort) THEN  {see Listing 7-4 on page 7-16}
   BEGIN
      SetStdCProcs(customCProcs);   {create new CQDProcs record containing }
                                    { standard Color QuickDraw low-level }
                                    { routines}

      customCProcs.putPicProc := @MyFilePutPic; {replace StdPutPic with }
                                                { address of custom }
                                                { low-level routine }
                                                { shown in Listing 7-11}
      currPort^.grafProcs := @customCProcs;  {replace current CQDProcs}
   END
   ELSE 
   BEGIN       {perform similar work for a basic graphics port}
      SetStdProcs(customProcs);
      customProcs.putPicProc := @MyFilePutPic;
      currPort^.grafProcs := @customProcs;
   END;
   gPictureSize := 0;   {track the picture size}
   gSpoolPicture := PicHandle(NewHandle(0));
   MyReplacePutPic := savedProcs;         {return saved CQDProcs or QDProcs }
                                    { record for restoring at a later time}
END;
</PRE>
 <A HREF=#MARKER-9-92>Listing 7-11</A> shows <CODE>MyFilePutPic</CODE>, which uses the File Manager function <CODE>FSWrite</CODE> to write picture data to the file with the file reference number assigned to the application-defined global variable <CODE>gPictFileRefNum</CODE>. Your application does not keep track of where <CODE>FSWrite</CODE> stops or resumes writing a file. After writing a portion of a file, <CODE>FSWrite</CODE> automatically handles where to begin writing next.<P>
<B>Listing 7-11  <A NAME=MARKER-9-92></A>A custom low-level routine for spooling a picture to disk</B><P>
<PRE>
PROCEDURE MyFilePutPic (dataPtr: Ptr; byteCount: Integer);
VAR
   dataLength: LongInt;
   myErr: OSErr;
BEGIN
   dataLength := byteCount;
   gPictureSize := gPictureSize + byteCount;
   myErr := FSWrite(gPictFileRefNum, dataLength, dataPtr);
   IF gSpoolPicture &lt;&gt; NIL THEN
   gSpoolPicture^^.picSize := gPictureSize;
END;
</PRE>
<A NAME=HEADING334-108></A>
<H2>Gathering Picture Information</H2>
 <A NAME=MARKER-2-146></A>You can use the Picture Utilities routines to gather extensive information about pictures and to gather color information about pixel maps. You use the <CODE>GetPictInfo</CODE> function to gather information about a single picture, and you use the <CODE>GetPixMapInfo</CODE> function to gather color information about a single pixel map or bitmap. Each of these functions returns color and resolution information in a <CODE>PictInfo</CODE> record (described on <A HREF=QuickDraw-341.html#MARKER-9-137>page 7-31</A>). A <CODE>PictInfo</CODE> record can also contain information about the drawing objects, fonts, and comments in a picture.<P>
 You can also survey multiple pictures, pixel maps, and bitmaps for this information. Use the <CODE>NewPictInfo</CODE> function to begin collecting pictures, pixel maps, and bitmaps for your survey. You also use <CODE>NewPictInfo</CODE> to specify how you would like the color, comment, and font information for the survey returned to you. <P>
 To add the information for a picture to your survey, use the <CODE>RecordPictInfo</CODE> function. To add the information for a pixel map or a bitmap to your survey, use the <CODE>RecordPixMapInfo</CODE> function. The <CODE>RetrievePictInfo</CODE> function collects the information about the pictures, pixel maps, and bitmaps that you have added to your survey. The <CODE>RetrievePictInfo</CODE> function returns this information in a <CODE>PictInfo</CODE> record.<P>
 For example, to use the ColorSync Utilities to match the colors in a single picture to an output device such as a color printer, an application might find it useful to find the <CODE>CMBeginProfile</CODE> picture comment, which marks the beginning of a color profile in a <CODE>Picture</CODE> record. (Color profiles and the ColorSync Utilities are described in <I><A HREF="../ACI/ACI-2.html">Advanced Color Imaging on the Mac OS</A></I>.) <A HREF=#MARKER-9-95>Listing 7-12</A> shows an application-defined routine, called <CODE>MyGetPICTProfileCount</CODE>, that uses <CODE>GetPictInfo</CODE> to record comments in a <CODE>CommentSpec</CODE> record (which is described on <A HREF=QuickDraw-339.html#MARKER-9-119>page 7-29</A>). The <CODE>MyGetPICTProfileCount</CODE> routine uses the <CODE>CommentSpec</CODE> record to determine whether any color profiles are included in the picture as picture comments.<P>
<B>Listing 7-12  <A NAME=MARKER-9-95></A>Looking for color profile comments in a picture</B><P>
<PRE>
FUNCTION MyGetPICTProfileCount (hPICT: PicHandle; VAR count: Integer): OSErr;
VAR
   err:              OSErr;
   thePICTInfo:      PictInfo;
   verb:             Integer;
   colorsRequested:  Integer;
   colorPickMethod:  Integer;
   version:          Integer;
   pCommentSpec:     CommentSpecPtr;
   i:                Integer;
BEGIN
   count := 0;
   verb := recordComments;
   colorsRequested := 0;
   colorPickMethod := systemMethod;
   version := 0;
   err := GetPictInfo(hPICT, thePICTInfo, verb, colorsRequested, 
                      colorPickMethod, version);
   IF ((err = noErr) AND (thePICTInfo.commentHandle &lt;&gt; NIL)) THEN
   BEGIN
      pCommentSpec := thePICTInfo.commentHandle^;
      FOR i := 1 TO thePICTInfo.uniqueComments DO
      BEGIN
         IF (pCommentSpec^.ID = CMBeginProfile) THEN
            BEGIN
               count := pCommentSpec^.count;
               LEAVE;
            END;
         pCommentSpec :=
            CommentSpecPtr(ORD4(pCommentSpec)+Sizeof(CommentSpec));
      END;
      {clean up allocations made by GetPictInfo}
      DisposeHandle(Handle(thePICTInfo.commentHandle));
   END;
   MyGetPICTProfileCount := err;
END;
</PRE>
 <A NAME=MARKER-2-96></A>If you want information about the colors of a picture or pixel map, you indicate to the Picture Utilities how many colors (up to 256) you want to know about, what method to use for selecting the colors, and whether you want the selected colors returned in a <CODE>Palette</CODE> record or <CODE>ColorTable</CODE> record. <P>
 The Picture Utilities provide two color-picking methods: one that gives you the most frequently used colors and one that gives you the widest range of colors. Each has advantages in different situations. For example, suppose the picture of a forest image contains 400 colors, of which 300 are greens, 80 are browns, and the rest are a scattering of golden sunlight effects. If you ask for the 250 most used colors, you will probably receive all greens. If you ask for a range of 250 colors, you will receive an assortment stretching from the greens and golds to the browns, including colors in between that might not actually appear in the image. You can also supply a color-picking method of your own, as described in <A HREF=QuickDraw-360.html#MARKER-9-260>"Application-Defined Routines" beginning on page 7-60</A>.<P>
 Your application can then use the color information returned by the Picture Utilities in conjunction with the Palette Manager to provide the best selection of colors for displaying the picture on an 8-bit indexed device.<P>
<DL>
<DT><B>IMPORTANT</B>
<DD>When you ask for color information about a picture, the Picture Utilities take into account only the version 2 and extended version 2 picture opcodes <CODE>RGBFgCol</CODE>, <CODE>RGBBkCol</CODE>, <CODE>BkPixPat</CODE>, <CODE>PnPixPat</CODE>, <CODE>FillPixPat</CODE>, and <CODE>HiliteColor</CODE> (as well as pixel map or bitmap data). Each occurrence of these opcodes is treated as one pixel, regardless of the number and sizes of the objects drawn with that color. If you need an accurate set of colors from a complex picture, create an image of the picture in an offscreen graphics world and call the <CODE>GetPixMapInfo</CODE> function to obtain color information about that pixel map for that graphics world.<EM></EM><A NAME=MARKER-2-553></A><A NAME=MARKER-8-21></A><A NAME=MARKER-2-147></A>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>

</BLOCKQUOTE>
<HR>
<center>
<A HREF="QuickDraw-333.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="QuickDraw-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="QuickDraw-476.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="QuickDraw-335.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="QuickDraw-3.html">&copy; Apple Computer, Inc.</A><br>7 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>  
