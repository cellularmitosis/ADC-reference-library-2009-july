<!-- Generated by Harlequin WebMaker 2.2.3 (23-Apr-1996)
LispWorks 3.2.2 -->
<HTML> <HEAD>
<TITLE>Closing a File (IM: F)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING28></A>


<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="Files-27.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Files-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Files-390.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="Files-29.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="Files-2.html"><B>Files</B></A> / <BR><DD><A HREF="Files-12.html"><B>Chapter 1 - Introduction to File Management</B></A> / <A HREF="Files-19.html"><B>Using Files</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING28-0></A>
<H2>Closing a File</H2>
 <A NAME=MARKER-9-389></A><A NAME=MARKER-2-207></A><A NAME=MARKER-2-222></A><A NAME=MARKER-2-132></A>In most cases, your application closes a file after a user clicks in a window's close box or chooses the Close command in the File menu. The Close menu command should be active only when there is actually an active window on the desktop. If there is an active window, you need to determine whether it belongs to your application; if so, you need to handle dialog windows and document windows differently, as illustrated in <A HREF=#MARKER-9-210>Listing 1-15</A>.<P>
<B>Listing 1-15  <A NAME=MARKER-9-210></A>Handling the Close menu command</B><P>
<PRE>
FUNCTION DoCloseCmd: OSErr;
VAR
   myWindow:   WindowPtr;
   myData:     MyDocRecHnd;
   myErr:      OSErr;
BEGIN
   myErr := FALSE;
   myWindow := FrontWindow;         {get window to be closed}
   CASE MyGetWindowType(myWindow) OF
      kDAWindow:
         CloseDeskAcc(WindowPeek(myWindow)^.windowKind);
      kMyModelessDialog:
         HideWindow(myWindow);      {for dialogs, hide the window}
      kMyDocWindow:
         BEGIN
            myData := MyDocRecHnd(GetWRefCon(myWindow));
            myErr := DoCloseFile(myData);
            IF myErr = noErr THEN
               DisposeWindow(myWindow);
         END;
      OTHERWISE
         ;
   END;
   DoCloseCmd := myErr;
END;
</PRE>
 The <CODE>DoCloseCmd</CODE> function determines the type of the frontmost window by calling the application-defined function <CODE>MyGetWindowType</CODE>. (See the chapter "Window Manager" in <I><A HREF="../Toolbox/Toolbox-2.html">Inside Macintosh: Macintosh Toolbox Essentials</A></I> for a definition of <CODE>MyGetWindowType</CODE>.) If the window to be closed is a window belonging to a desk accessory, <CODE>DoCloseCmd</CODE> closes the desk accessory. If the window to be closed is a dialog window, this procedure just hides the window. If the window to be closed is a document window, <CODE>DoCloseCmd</CODE> retrieves its document record handle and calls both <CODE>DoCloseFile</CODE> (defined in <BR><A HREF=Files-28.html#MARKER-11-1286>Listing 1-16</A>) and <CODE>DisposeWindow</CODE>. Before you close the file associated with a <BR>window, you should check whether the contents of the window have changed since <BR>the last time the document was saved. If so, you should ask the user whether to save those changes. <A HREF=Files-28.html#MARKER-11-1286>Listing 1-16</A> illustrates one way to do this.<P>
<B>Listing 1-16  <A NAME=MARKER-11-1286></A>Closing a file</B><P>
<PRE>
FUNCTION DoCloseFile (myData: MyDocRecHnd): OSErr;
VAR
   myErr:      OSErr;
   myDialog:   DialogPtr;        {pointer to modal dialog box}
   myItem:     Integer;          {item selected in alert box}
   myPort:     GrafPtr;          {the original graphics port}
CONST
   kSaveChangesDialog = 129;     {resource of Save changes dialog}
BEGIN
   IF myData^^.windowDirty THEN  {see whether window is dirty}
      BEGIN
         myItem := CautionAlert(kSaveChangesDialog, NIL);
         IF myItem = iCancel THEN{user clicked Cancel}
            BEGIN
               DoCloseFile := usrCanceledErr;
               Exit(DoCloseFile);
            END;
         IF myItem = iSave THEN
            myErr := DoSaveCmd;
      END;
   IF myData^^.fileRefNum &lt;&gt; 0 THEN
      BEGIN
         myErr := FSClose(myData^^.fileRefNum);
         IF myErr = noErr THEN
            BEGIN
               myErr := FlushVol(NIL, myData^^.fileFSSpec.vRefNum);
               myData^^.fileRefNum := 0;  {clear the file reference number}
            END;
      END;
   {Dispose of TextEdit record and controls here (code omitted).}
   DisposeHandle(Handle(myData));         {dispose of document record}
   DoCloseFile := myErr;
END;
</PRE>
 If the document is an existing file that has not been changed since it was last saved, your application can simply call the <CODE>FSClose</CODE> function. This routine writes to disk any unwritten data remaining in the volume buffer. The <CODE>FSClose</CODE> function also updates the information maintained on the volume for that file and removes the access path. The information about the file is not actually written to the disk, however, until the volume is flushed, ejected, or unmounted. To keep the file information current, it's a good idea to follow each call to <CODE>FSClose</CODE> with a call to the <CODE>FlushVol</CODE> function.<A NAME=MARKER-2-212></A><A NAME=MARKER-9-518></A><P>
 If the contents of an existing file have been changed, or if a new file is being closed for the first time, your application can call the Dialog Manager routine <CODE>CautionAlert</CODE> (specifying a resource ID of an <CODE>'ALRT'</CODE> template) to ask the user whether or not to save the changes. If the user decides not to save the file, you can just call <CODE>FSClose</CODE> and dispose of the window. Otherwise, <CODE>DoCloseFile</CODE> calls the <CODE>DoSaveCmd</CODE> function to save the file to disk.<A NAME=MARKER-2-239></A><A NAME=MARKER-2-133></A><A NAME=MARKER-2-41></A><A NAME=MARKER-2-250></A><A NAME=MARKER-2-218></A><A NAME=MARKER-9-501></A><P>
</BLOCKQUOTE>
<HR>
<center>
<A HREF="Files-27.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Files-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Files-390.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="Files-29.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="Files-3.html">&copy; Apple Computer, Inc.</A><br>2 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>  
