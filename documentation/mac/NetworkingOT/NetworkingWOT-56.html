<!-- Generated by Harlequin WebMaker 2.2.3 (30-Apr-1996)
Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->
<HTML> <HEAD>
<TITLE>Using TCP/IP Services</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING56></A>
<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->

<!-- Main Body -->

<CENTER>
<P>
<A HREF="NetworkingWOT-55.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="NetworkingWOT-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="NetworkingWOT-491.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A>  <A HREF="NetworkingWOT-57.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html"><B>Inside Macintosh:</B></A> <A HREF="NetworkingWOT-2.html"><B>Networking With Open Transport </B></A> / <A HREF="NetworkingWOT-10.html"><B>Part 1 - Open Transport Essentials</B></A><BR><DD><A HREF="NetworkingWOT-51.html"><B>Chapter 11 - TCP/IP Services</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING56-0></A>
<H1>Using TCP/IP Services<A NAME=MARKER-13-52></A></H1>
 This section describes how to use the Open Transport RawIP interface, how to implement IP multicasting, and how to use a variety of Open Transport endpoint and mapper functions with the TCP/IP protocols. TCP/IP options are described in <A HREF=NetworkingWOT-388.html#MARKER-9-60>"Options"</A>.<P>
<A NAME=HEADING56-2></A>
<H2>Setting Options When Configuring a TCP/IP Provider</H2>
 When you open a TCP/IP provider, you must pass a pointer to a configuration string. If you want to set an option as part of the configuration string, you should translate the option's constant name, given in the header files, into a string that the configuration functions can parse. For the TCP/IP options, <A HREF=#MARKER-9-2>Table 11-2</A> provides the constant name and the value to use in the configuration string.
<TABLE BORDER="0" CELLPADDING=3>
<CAPTION><A NAME=MARKER-9-2></A>Configuration strings for TCP/IP options<A NAME=MARKER-13-3></A> </CAPTION>
<TH>Constant name<TH>Configuration string value<TR>
<TD><CODE>IP_OPTIONS</CODE><TD>"Options"<TR>
<TD><CODE>IP_TOS</CODE><TD>"TOS"<TR>
<TD><CODE>IP_TTL</CODE><TD>"TTL"<TR>
<TD><CODE>IP_RCVDSTADDR</CODE><TD>"RcvDestAddr"<TR>
<TD><CODE>IP_RCVIFADDR</CODE><TD>"RcvIFAddr"<TR>
<TD><CODE>IP_RCVOPTS</CODE><TD>"RcvOpts"<TR>
<TD><CODE>IP_REUSEADDR</CODE><TD>"ReuseAddr"<TR>
<TD><CODE>IP_DONTROUTE</CODE><TD>"DontRoute"<TR>
<TD><CODE>IP_BROADCAST</CODE><TD>"Broadcast"<TR>
<TD><CODE>IP_HDRINCL</CODE><TD>"HdrIncl"<TR>
<TD><CODE>IP_MULTICAST_IP</CODE><TD>"MulticastIF"<TR>
<TD><CODE>IP_MULTICAST_TTL</CODE><TD>"MulticastTTL"<TR>
<TD><CODE>IP_MULTICAST_LOOP</CODE><TD>"MulticastLoop"<TR>
<TD><CODE>IP_ADD_MEMBERSHIP</CODE><TD>"AddMembership"<TR>
<TD><CODE>IP_DROP_MEMBERSHIP</CODE><TD>"DropMembership"<TR>
<TD><CODE>IP_BROADCAST_IF</CODE><TD>"BroadcastIF"<TR>
<TD><CODE>UDP_CHECKSUM</CODE><TD>"Checksum"<TR>
<TD><CODE>UDP_RX_ICMP</CODE><TD>"RxICMP"<TR>
<TD><CODE>TCP_NODELAY</CODE><TD>"NoDelay"<TR>
<TD><CODE>TCP_OOBINLINE</CODE><TD>"OOBInline"<TR>
<TD><CODE>TCB_MAXSEG</CODE><TD>"MaxSeg"<TR>
<TD><CODE>TCP_NOTIFY_THRESHOLD</CODE><TD>"NotifyThreshold"<TR>
<TD><CODE>TCP_ABORT_THRESHOLD</CODE><TD>"AbortThreshold"<TR>
<TD><CODE>TCP_CONN_NOTIFY_THRESHOLD&nbsp;&nbsp;</CODE><TD>"ConnNotifyThreshold"<TR>
<TD><CODE>TCP_CONN_ABORT_THRESHOLD</CODE><TD>"ConnAbortThreshold"<TR>
<TD><CODE>TCP_KEEPALIVE</CODE><TD>"KeepAlive"</TABLE>
<P>
 The network configuration structure and <CODE>OTCreateConfiguration</CODE> function are described in the chapter <A HREF=NetworkingWOT-16.html#MARKER-9-19>"Getting Started"</A> in this book.<P>
<A NAME=HEADING56-5></A>
<H2><A NAME=MARKER-9-53></A>Using RawIP<A NAME=MARKER-13-54></A><A NAME=MARKER-13-55></A></H2>
 The Open Transport TCP/IP software modules provide a RawIP interface to the IP protocol. RawIP behaves for the most part identically to UDP, as a connectionless transactionless interface, but there are a few unique differences.<P>
 You can receive RawIP datagrams using a RawIP endpoint. You can create a RawIP endpoint by passing <CODE>kRawIPName</CODE> to <CODE>OTCreateConfiguration</CODE> and passing that configuration to the <CODE>OTOpenEndpoint</CODE> or <CODE>OTOpenEndpointAsync</CODE> function.<P>
 The RawIP interface facilitates the implementation of new protocols that use IP for datagram delivery. Therefore, in order to use a RawIP endpoint, you must specify a value for the <CODE>protocol</CODE> field in the IP datagram header. RawIP endpoints default to receiving ICMP (protocol 1) packets. You can change this by setting the generic XTI option <CODE>XTI_PROTOTYPE</CODE>, described in the chapter <A HREF=NetworkingWOT-37.html#MARKER-9-21>"Option Management"</A> in this book. The option is a longword that is the IP protocol number to be used by the RawIP endpoint.<P>
 The data delivered to a RawIP endpoint includes the full IP header, which is 20 bytes long if it includes no IP options.<P>
<DL>
<DT><B>WARNING</B>
<DD>If you open a RawIP endpoint, you are responsible for implementing the protocol that is a client of IP running over that endpoint. Because an improperly implemented protocol can cause the host to crash or cause the loss of data on the network, you should exercise caution when using Raw IP.   <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
<A NAME=HEADING56-11></A>
<H3>Receiving RawIP Datagrams </H3>
 Normally, connectionless transactionless endpoints only support binding one endpoint to any given protocol address. RawIP is different in that it allows multiple endpoints to be bound to the same protocol address. <P>
 With one important exception, each RawIP endpoint bound to a specific protocol receives a copy of any inbound packets destined for that protocol.  For example, if several "ping" programs are using ICMP on the same host, each would receive a copy of all inbound ICMP echo datagrams. The exception is that RawIP endpoints do not receive copies of packets addressed to IP protocols TCP (protocol 6) or UDP (protocol 17). This restriction optimizes the delivery of such packets to their corresponding high-level protocols.<P>
 One unusual behavior of RawIP endpoints is that the delivered packets have their <CODE>Total Length</CODE> field modified. The RawIP module subtracts the length of the IP header from the <CODE>Total Length</CODE> field. This behavior brings Open Transport's STREAMS RawIP more in line with RawIP under BSD UNIX. Therefore, you should not rely on the value of the <CODE>Total Length</CODE> field. If you need to know the total length of the packet, use the length as returned in the <CODE>TNetBuf</CODE> structure returned by the <CODE>OTRcvUData</CODE> function.<P>
<A NAME=HEADING56-15></A>
<H3>Sending RawIP Datagrams</H3>
 You can also send RawIP datagrams using a RawIP endpoint. For sending, RawIP endpoints have two modes: a mode in which the RawIP interface generates the header for you and a mode in which you set the header yourself. The <I>header-generated mode</I> is the default, and it is useful if you are only interested in the payload of the RawIP packets you send.<P>
 For applications such as ping (ICMP), you can let the RawIP interface generate the headers using the RawIP endpoint default behavior, such as sending ICMP packets (protocol 1). In this case, you can change the protocol and IP options (such as <CODE>IP_OPTIONS</CODE> and <CODE>IP_TTL)</CODE> using option management functions, as described in the chapter  <A HREF=NetworkingWOT-37.html#MARKER-9-21>"Option Management"</A> in this book.<P>
<A NAME=HEADING56-18></A>
<H3>Manually Setting the IP Header </H3>
 At times, however, the level of control provided by the IP level options is not enough. If you need to set a field in the IP header that is not handled by a defined option, you can do this by switching the RawIP endpoint to what is referred to as the <I>header-included mode</I> and setting up the IP header manually.<P>
 Internally, the RawIP module maintains a state that determines whether it should add an IP header to any outgoing packets. If the state is <CODE>false</CODE> (0), RawIP will automatically generate an IP header for any outgoing packets. If the state is true (1), RawIP expects the data you provide it to contain the IP header. (By default the state is false and RawIP generate headers for you automatically.)<P>
 You can change this bit explicitly using option management. Simply set the IP option <CODE>IP_HDRINCL</CODE> to a 4-byte integer containing either 0 or 1. The IP options are listed in <A HREF=NetworkingWOT-392.html#MARKER-9-82>"IP Options"</A>.<P>
 You can also change this state by changing the IP protocol (using the generic XTI option <CODE>XTI_PROTOTYPE</CODE> option) for the endpoint. If you set the IP protocol to <CODE>IPPROTO_RAW</CODE> (255) or <CODE>IPPROTO_IGMP</CODE> (2), the IP option<CODE>IP_HDRINCL</CODE> state will be set to <CODE>true</CODE>. If you change the IP protocol to any other value, the IP option <CODE>IP_HDRINCL</CODE> state defaults to false. <P>

<DL>
<DT><B>IP protocol information sources</B>
<DD>The IP Protocol option values are defined in Internet Standard 1 "Assigned Numbers," which can be found at <A HREF="ftp://ds.internic.net/std/std1.txt">ftp://ds.internic.net/std/std1.txt</A>. The fields in the IP header are those defined in Internet Standard 5, which can be found at <A HREF="ftp://ds.internic.net/std/std5.txt">ftp://ds.internic.net/std/std5.txt</A>. <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>

<A NAME=HEADING56-25></A>
<H3>Limitations of the Header-Included Mode</H3>
 If you use the header-included mode, you need to be aware of some of its limitations. A number of the fields in the IP header are automatically modified by Open Transport, regardless of what values you set them to. These field names include:<P>
<UL>
<P><LI>Version. This field is forced to a value of 4 to reflect the fact that you're using IP version 4.
<P><LI>IHL. When OT sends a RawIP packet in "header included" mode, it ignores the IHL field value you specify and instead attaches the IP options that were last specified using the IP option <CODE>IP_OPTIONS</CODE>. This prevents you from setting your own IP options by placing them in the IP header and setting IHL appropriately.
<P><LI>Total Length. This field is not touched by RawIP, but it must be less than the link MTU for the packet to be sent. 
<P><LI>Identification. This field value is set to the next ID number in the Open Transport internal sequence.<P>
</UL>
 Flags. The More Fragments (MF) bit and the reserved bit are cleared. The Do Not Fragment (DF) bit is set on all outgoing IP packets. OT uses the DF bit to implement its dynamic path MTU discovery. Because this behavior is implemented below the IP layer, you cannot change this behavior using the RawIP endpoint<P>
<UL>
<P><LI>Fragment Offset. This field is completely overwritten by RawIP.
<P><LI>Header Checksum. The field is set to the correct checksum value. <P>
</UL>
 You need to be careful when setting your own IP header. Even though some fields are automatically "corrected" by Open Transport, it is still possible to generate improperly formatted IP packets using a RawIP endpoint, which can result in loss of network data.<P>
 
<DL>
<DT><B> Note</B><P>
<DD>Path MTU is described in RFC1191 (<A HREF="ftp://ds.internic.net/rfcl/rfc1191.txt">ftp://ds.internic.net/rfcl/rfc1191.txt</A>). <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>

<A NAME=HEADING56-37></A>
<H2>Using IP Multicasting<A NAME=MARKER-13-56></A></H2>
 Open Transport TCP/IP provides IP multicasting level 2, as described in RFC 1112. This feature is only relevant for RawIP and UDP endpoints.<P>
 To join a multicast group, use the <A HREF=NetworkingWOT-392.html#MARKER-9-82><CODE>IP_ADD_MEMBERSHIP</CODE></A> option , passing in a <CODE>TIPAddMulticast</CODE> structure to specify the address and network interface of the group you wish to join. For a multihomed system, you can use the value <CODE>kOTAnyInetAddress</CODE> for the interface address to use the default multicast interface. <P>
 The time-to-live value for outbound multicast data defaults to 1; you can use the <CODE>IP_MULTICAST_TTL</CODE> option to set a different value. The time-to-live value is a hop count: each router that processes the datagram decrements the <A NAME=MARKER-13-57></A>time-to-live and discards the datagram if the value reaches 0. Because every router that receives a multicast packet forwards it, a high time-to-live value for a multicast packet can cause the packet to propagate widely throughout the Internet. Therefore, keep this value as low as possible.<P>
 By default, Open Transport IP loops back multicast datagrams to any member of the group on the sending machine. Pass a value of <CODE>T_NO</CODE> to the option <CODE>IP_MULTICAST_LOOP</CODE> to turn off loopbacks. <P>
<A NAME=HEADING56-42></A>
<H2><A NAME=MARKER-13-58></A><A NAME=MARKER-13-64></A>Querying DNS Servers</H2>
 In addition to the explicit simplified functions that are provided for the most commonly made queries such as name-to-address, address-to-name, system CPU and OS, and mail exchange queries, there is a generic query function, <A NAME=MARKER-13-140></A>OTInetQuery, that you can use for any DNS query.<P>
 The OTInetQuery function allows you to use the Domain Name Resolver (DNR) for generic domain name service (DNS) queries. You can ask for any query type and class, and in response, Open Transport returns as many <CODE><A NAME=MARKER-13-61></A>DNSQueryInfo</CODE> structures as it can fit in the buffer you provide. <P>
 There are three types of <A NAME=MARKER-13-41></A><A NAME=MARKER-13-63></A>responses: answers, authority responses, and additional information, and there are typically several of each type. Each response has its own <CODE>DNSQueryInfo</CODE> structure, with all the answers first, then all the authority records, then all the additional information. Authority responses refer you to DNS servers and other sources that may have helpful information for this answer and additional information responses provide address data for the servers and sources referred to in the authority records. <P>
 If, for example, you use the <CODE>OTInetQuery</CODE> function to find out the IP addresses for a name, you might get back 13 <CODE>DNSQueryInfo</CODE> structures in your answer buffer. Each DNS Query Information structure might then contain 2 IP address structures, 4 authority responses, and 7 additional information responses.<P>
 To help you parse this huge answer buffer, Open Transport provides two optional parameters for the <CODE>OTInetQuery</CODE> function, <CODE>argv</CODE> and <CODE>argvlen</CODE>, that create an array of pointers to the individual responses. <A NAME=MARKER-13-64></A><P>
<A NAME=HEADING56-48></A>
<H2>Avoiding Delay When Rebinding to TCP Connections</H2>
 When a connection closes, TCP imposes a two-minute timeout on binding before the same port can be bound to again. This prevents stale data from corrupting a new connection. This is in strict compliance with the TCP standard.<P>
 You can work around this by using the <CODE>IP_REUSEADDR</CODE> option with the <CODE>OTOptionManagement</CODE> function. If you set this option on all of your listening endpoints before you bind, the limitation should disappear. The <CODE>IP_REUSEADDR</CODE> option allows you to bind multiple connected or closing endpoints to addresses with the same port number. <P>
<DL>
<DT><B>IMPORTANT</B>
<DD>Note that even using the <CODE>IP_REUSEADDR</CODE> option, you can only bind a single endpoint in a state less than connected (that is, listening or unbound endpoints) to the same port at a given time. You can, however, bind any number of connected or closing endpoints.   <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
 The sample code shown in <A HREF=#MARKER-9-65>Listing 11-2</A> sets an option and assigns it to the location referenced by <CODE>value</CODE>. The endpoint is assumed to be in synchronous mode. If an error occurs, the function returns a negative result. If the option could not be read, a positive result (either <CODE>T_FAILURE, T_PARTSUCCESS</CODE>, or <CODE>TREADONLY</CODE>, or <CODE>T_NOTSUPPORT</CODE>) is returned.<P>
<B>Listing 11-2  <A NAME=MARKER-9-65></A>Setting an option value</B><P>
<PRE>
<A NAME=MARKER-0-95></A>static OTResult SetFourByteOption(EndpointRef ep,
                           OTXTILevel level,
                           OTXTIName  name,
                           UInt32   value)
{
   OTResult err;
   TOption  option;
   TOptMgmt request;
   TOptMgmt result;
   
   /* Set up the option buffer to specify the option and value to
         set. */
   option.len  = kOTFourByteOptionSize;
   option.level= level;
   option.name = name;
   option.status = 0;
   option.value[0] = value;

   /* Set up request parameter for OTOptionManagement */
   request.opt.buf= (UInt8 *) &amp;option;
   request.opt.len= sizeof(option);
   request.flags  = T_NEGOTIATE;

   /* Set up reply parameter for OTOptionManagement. */
   result.opt.buf  = (UInt8 *) &amp;option;
   result.opt.maxlen  = sizeof(option);

   
   err = OTOptionManagement(ep, &amp;request, &amp;result);

   if (err == noErr) {
      if (option.status != T_SUCCESS) 
         err = option.status;
   }
            
   return (err);
}
</PRE>
 In the body of the function, we use a <CODE>TOption</CODE> structure to represent the option buffer and initialize its fields to specify the option and value we want to set. Next, we initialize the <CODE>request</CODE> parameter of the <CODE>OTOptionManagement</CODE> function to reference the option buffer we just initialized. The <CODE>length</CODE> field is set to the size of the option buffer and the <CODE>flags</CODE> field is set to <CODE>T_NEGOTIATE</CODE> to specify that we want to set the option value specified in the option buffer.<P>
 You could invoke this function and set the <CODE>IP_REUSEADDR</CODE> option as follows:<P>
<PRE>
<A NAME=MARKER-0-95></A>err = SetFourByteOption(ep, INET_IP, IP_REUSEADDR, true);
</PRE>
<A NAME=HEADING56-58></A>
<H2><A NAME=MARKER-9-68></A>Using General Open Transport Functions With TCP/IP </H2>
 This section describes special considerations you must take into account for Open Transport functions when you use them with the Open Transport TCP/IP implementation. You should be familiar with the function descriptions in the chapters "<A HREF=NetworkingWOT-146.html#MARKER-9-116>"Endpoints Reference</A> and  <A HREF=NetworkingWOT-232.html#MARKER-9-37>"Mappers Reference"</A>in this book before reading this section.<P>
<A NAME=HEADING56-60></A>
<H3>Obtaining Endpoint Data With TCP/IP<A NAME=MARKER-13-69></A></H3>
 The following values can be returned by the <CODE>info</CODE> parameter to the <A NAME=MARKER-13-70></A><CODE>OTOpenEndpoint</CODE>, <A NAME=MARKER-13-71></A><CODE>OTAsyncOpenEndpoint</CODE>, and <A NAME=MARKER-13-72></A><CODE>OTGetEndpointInfo</CODE> functions when used with TCP/IP protocols. <P>
<DL>
<DT><B>IMPORTANT</B>
<DD>The preceding table shows only what values are possible for each protocol. Be sure to to use the <CODE>OTOpenEndpoint</CODE>, <CODE>OTAsyncOpenEndpoint</CODE>, or <CODE>OTGetEndpointInfo</CODE> functions to obtain the current values for these parameters.  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
 These fields and the significance of their values are described in more detail in <A HREF=NetworkingWOT-146.html#MARKER-9-116>"Endpoints Reference"</A>.<P>
<A NAME=HEADING56-64></A>
<H3><A NAME=MARKER-9-73></A>Using Endpoint Functions With TCP/IP</H3>
 This section describes protocol-specific information about functions described in the chapter <A HREF=NetworkingWOT-127.html#MARKER-9-19>"Endpoints Reference"</A>. The functions are listed in the same order that they appear in that chapter.<P>
<A NAME=HEADING56-66></A>
<H4><A NAME=MARKER-9-74></A>OTBind</H4>
 The <A NAME=MARKER-13-75></A><CODE>OTBind</CODE> function associates a local protocol address with the endpoint you specify. Use this function with the TCP and UDP protocols.<P>
 The <CODE>addr</CODE> field of the <CODE>TBind</CODE> structure refers to the local endpoint and so must specifically include a port number. Use an <CODE>InetAddress</CODE> structure, described in <A HREF=NetworkingWOT-380.html#MARKER-9-31>"Internet Address Structure"</A>, to specify this address.<P>
 Because the architecture of Open Transport TCP/IP provides for multihoming (although this feature has not yet been implemented), you can specify an IP address of <CODE>kOTAnyInetAddress</CODE> for the <CODE>addr</CODE> field to indicate that your application or process will accept packets from any TCP/IP interface that the user has configured in the TCP/IP control panel.<P>
 If you bind to an address of <CODE>kOTAnyInetAddress</CODE>, then the <CODE>OTGetProtAddress</CODE> function always returns an IP address of 0. In that case, you must use the <A HREF=NetworkingWOT-407.html#MARKER-9-145><CODE>OTInetGetInterfaceInfo</CODE></A> function  to determine the IP address of a running IP interface. However, if you pass in a valid address with a port number of <CODE>kOTAnyInetAddress</CODE>, the TCP/IP service provider assigns a port for you and the <CODE>OTGetProtAddress</CODE> function returns the assigned port number and the IP address.<P>
 You can use the <CODE>OTInetGetInterfaceInfo</CODE> function to get the IP addresses of all currently configured IP interfaces. Then, if you wish to receive packets from only a single interface, you can bind the endpoint to the address for that interface.<P>
<A NAME=HEADING56-72></A>
<H4><A NAME=MARKER-9-76></A>OTLook</H4>
 The <A NAME=MARKER-13-77></A><CODE>OTLook</CODE> function checks for asynchronous events such as incoming data or connection requests. Use this function with the TCP protocol.<P>
 As soon as a segment with the TCP urgent pointer set (that is, expedited data) enters the TCP receive buffer, TCP posts the <CODE>T_EXDATA</CODE> event. The <CODE>T_EXDATA</CODE> event remains posted until you have retrieved all data up to the byte pointed to by the TCP urgent pointer.<P>
<A NAME=HEADING56-75></A>
<H4><A NAME=MARKER-9-78></A>OTGetProtAddress</H4>
 You use this function with the TCP and UDP protocols.<P>
 If you bind an endpoint to an IP address of <CODE>kOTAnyInetAddress</CODE> in order to accept packets from any valid TCP/IP interface, then the <A NAME=MARKER-13-79></A><CODE>OTGetProtAddress</CODE> function always returns an IP address of 0. This is because in a multihomed machine, there is a separate IP address for each interface, and there's no way for Open Transport to know which one you want. In that case, you must use the <A HREF=NetworkingWOT-407.html#MARKER-9-145><CODE>OTInetGetInterfaceInfo</CODE></A> function  to determine the IP address of a running IP interface. On the other hand, if you bind an endpoint to a specific interface, the <CODE>OTGetProtAddress</CODE> function returns the address of that interface, as expected.<P>
<A NAME=HEADING56-78></A>
<H4><A NAME=MARKER-9-80></A>OTConnect</H4>
 The <A NAME=MARKER-13-81></A><CODE>OTConnect</CODE> function requests a connection to a specified remote endpoint. You can use this function with TCP.<P>
 The <CODE>rcvcall-&gt;addr</CODE> field returns a copy of the <CODE>TNetbuf</CODE> structure you specify in the <CODE>sndcall-&gt;addr</CODE> field. The<CODE> discon-&gt;reason</CODE> field contains a positive error code that indicates why the connection was rejected.<P>
 Because TCP does not allow you to send any application-specific data during the connection establishment phase, you must set the <CODE>sndcall-&gt;udata.len</CODE> field to 0. TCP ignores the value of the <CODE>sndcall-&gt;udata.buf</CODE> field.<P>
 Note that TCP, not the receiving application, confirms the connection. <P>
 As mentioned in the X/Open Transport Interface (XTI) specification, because TCP cannot refuse a connection, <CODE>t_listen()</CODE> and <CODE>t_accept()</CODE> have a semantic which is slightly different from that for ISO providers."<P>
 As a result, an Open Transport TCP server will accept a TCP connection request if the current number of pending connections is less than the queue length (<CODE>qlen</CODE>) for the passive endpoint. Basically, what happens is that TCP connects even before you accept a connection. <P>
 The client, whether in synchronous or asynchronous mode, will immediately receive notice that the connection has been established. For synchronous endpoints, TCP completes the 3-way connection handshake. For asynchronous endpoints, the <CODE>OTRcvConnect</CODE> function must be called to complete the handshake.<P>
 This can result in situations like this: You send an <CODE>OTConnect</CODE> from a TCP client to a TCP server that passively awaits incoming connections, but even before the server responds with the <CODE>OTListen</CODE> and <CODE>OTAccept</CODE> calls, the <CODE>OTConnect</CODE> call completes with no error. At this point, if you examine the client endpoint's state, you will find that it is in the <CODE>T_DATAXFER</CODE> state, which is correct. <P>
<A NAME=HEADING56-87></A>
<H4><A NAME=MARKER-9-82></A>OTRcvConnect</H4>
 The <A NAME=MARKER-13-83></A><CODE>OTRcvConnect</CODE> function reads the status of a previously issued connection request. You can use this function with TCP.<P>
 Because TCP does not allow you to send any application-specific data during the connection establishment phase, you must set the <CODE>call-&gt;udata.maxlen</CODE> field to 0. TCP ignores the value of the <CODE>call-&gt;udata.buf</CODE> field.<P>
 On return, the <CODE>call-&gt;addr</CODE> field points to the Internet address of the endpoint that accepted the connection.<P>
<A NAME=HEADING56-91></A>
<H4><A NAME=MARKER-9-84></A>OTListen</H4>
 The <A NAME=MARKER-13-85></A><CODE>OTListen</CODE> function listens for an incoming connection request. You can use this function with TCP.<P>
 When the <CODE>OTListen</CODE> function successfully completes execution (that is, when you receive the <CODE>T_LISTEN</CODE> event), the <CODE>call</CODE> parameter describes a connection that has already been completed at the TCP level. You use the <CODE>OTAccept</CODE> function to complete a connection at the application level. If you wish to reject a connection, you must call the <CODE>OTSndDisconnect</CODE> function after the <CODE>OTListen</CODE> function successfully completes execution.<P>
 Because TCP does not allow you to send any application-specific data during the connection establishment phase, you must set the <CODE>call-&gt;udata.maxlen</CODE> field to 0. TCP ignores the value of the <CODE>call-&gt;udata.buf</CODE> field.<P>
<A NAME=HEADING56-95></A>
<H4><A NAME=MARKER-9-86></A>OTAccept</H4>
 The <A NAME=MARKER-13-87></A><CODE>OTAccept</CODE> function accepts an incoming connection request. You can use this function with TCP.<P>
 Because TCP does not allow you to send any application-specific data during the connection establishment phase, you must set the <CODE>call-&gt;udata.len</CODE> field to 0. TCP ignores the value of the <CODE>call-&gt;udata.buf</CODE> field.<P>
 If you wish to send either of the association-related options (<CODE>IP_OPTIONS</CODE> or <CODE>IP_TOS</CODE>) with the connection confirmation, you must use the <CODE>OTOptionManagement</CODE> function to set the values of these options before you receive the <CODE>T_LISTEN</CODE> event. TCP has already established a connection when you receive the <CODE>T_LISTEN</CODE> event, and it is too late for the <CODE>OTAccept</CODE> function to negotiate these options.<P>
<A NAME=HEADING56-99></A>
<H4><A NAME=MARKER-9-88></A>OTSndUData</H4>
 The <A NAME=MARKER-13-89></A><CODE>OTSndUData</CODE> function sends data through a connectionless transactionless endpoint. You can use this function with UDP.<P>
 The current value for the maximum size of a RawIP or UDP datagram is returned in the <CODE>info-&gt;tsdu</CODE> parameter of the <CODE>OTOpenEndpoint</CODE>, <CODE>OTAsyncOpenEndpoint</CODE>, and <CODE>OTGetEndpointInfo</CODE> functions.<P>
<A NAME=HEADING56-102></A>
<H4><A NAME=MARKER-9-90></A>OTSnd</H4>
 The <A NAME=MARKER-13-91></A><CODE>OTSnd</CODE> function sends data through a connection-oriented transactionless endpoint. You can use this function with TCP.<P>
 Because it does not support TSDU's, TCP ignores the <CODE>OTSnd</CODE> function's <CODE>T_MORE</CODE> flag. <P>
 If you set the <CODE><A NAME=MARKER-13-92></A>T_EXPEDITED</CODE> flag, you must send at least 1 byte of data. If you call the <CODE>OTSnd</CODE> function with more than 1 byte specified and the <CODE>T_EXPEDITED</CODE> flag set, the TCP urgent pointer points to the last byte of the buffer. <A NAME=MARKER-13-93></A><P>
<A NAME=HEADING56-106></A>
<H4><A NAME=MARKER-9-94></A>OTRcv</H4>
 The <A NAME=MARKER-13-95></A><CODE>OTRcv</CODE> function receives data through a connection-oriented endpoint. You can use this function with TCP.<P>
 Because TCP ignores the <CODE>T_MORE</CODE> flag when it is sending data and does not transmit the flag, you should ignore the <CODE>T_MORE</CODE> flag when receiving normal data. However, if a byte in the data stream is pointed to by the TCP urgent pointer, TCP receives this byte and as many bytes as possible preceding the marked byte with the <CODE>T_EXPEDITED</CODE> flag set. If your buffer is too small to receive all of the expedited data, TCP sets the <CODE>T_MORE</CODE> flag as well. Note that this situation might result in the number of bytes received as expedited data not being equal to the number of bytes sent by the originator as expedited data. <P>
<A NAME=HEADING56-109></A>
<H4><A NAME=MARKER-9-96></A>OTSndDisconnect</H4>
 The <A NAME=MARKER-13-97></A><CODE>OTSndDisconnect</CODE> function initiates an abortive disconnect or rejects a connection request. You can use this function with TCP.<P>
 Because TCP does not allow you to send any application-specific data during a disconnect, you must set the <CODE>call-&gt;udata.len</CODE> field to 0. TCP ignores any data in the <CODE>call-&gt;udata.buf</CODE> field.<P>
<A NAME=HEADING56-112></A>
<H4><A NAME=MARKER-9-98></A>OTRcvDisconnect</H4>
 The <A NAME=MARKER-13-99></A><CODE>OTRcvDisconnect</CODE> function returns information about why a connection attempt failed or an established connection was terminated. You can use this function with TCP.<P>
 Because TCP does not allow you to send any application-specific data during a disconnection, you must set the <CODE>discon-&gt;udata.len</CODE> field to 0. TCP ignores the value of the <CODE>discon-&gt;udata.buf</CODE> field.<P>
 This function returns a positive error code. To obtain the negative error code, subtract that positive value from -3199. <P>
<A NAME=HEADING56-116></A>
<H3>Using Mapper Functions With TCP/IP</H3>
 This section describes protocol-specific information about functions described in the chapter <A HREF=NetworkingWOT-232.html#MARKER-9-37>"Mappers Reference"</A> in this book. The functions are listed in the same order that they appear in that chapter.<P>
<A NAME=HEADING56-118></A>
<H4><A NAME=MARKER-9-100></A>OTRegisterName</H4>
 Because the TCP/IP domain name system does not include a method for clients to register their names on the network, the Open Transport domain name resolver (DNR) does not support the <A NAME=MARKER-13-101></A><CODE>OTRegisterName</CODE> function. If you call this function for a TCP/IP mapper, it will return the <CODE>kOTNotSupportedErr</CODE> result code.<P>
<A NAME=HEADING56-120></A>
<H4><A NAME=MARKER-13-102></A><A NAME=MARKER-9-103></A>OTDeleteName</H4>
 This function is not supported by the TCP/IP domain name resolver (DNR). If you call this function for a TCP/IP mapper, it will return the <CODE>kOTNotSupportedErr</CODE> result code.<P>
<A NAME=HEADING56-122></A>
<H4><A NAME=MARKER-9-104></A>OTLookupName</H4>
 You can use the <A NAME=MARKER-13-105></A><CODE>OTLookupName</CODE> function to resolve a domain name<A NAME=MARKER-13-106></A> to an Internet address. Specify the name as a character string pointed to by the <CODE>request-&gt;udata.buf</CODE> parameter. The name can be just a host name ("otteam"), a partially qualified domain name ("otteam.ssw"), a fully qualified domain name ("otteam.ssw.apple.com."), or an Internet address in dotted-decimal format ("17.202.99.99"), and can optionally include the port number ("otteam.ssw.apple.com:25" or "17.202.99.99:25"). <P>
 The function returns a pointer to the address in the <CODE>reply-&gt;udata.buf</CODE> parameter. The address is in the format of an <A HREF=NetworkingWOT-380.html#MARKER-9-31><CODE>InetAddress</CODE></A> structure , which includes the address type, the port number, and the IP address. If you don't specify a port number, the returned <CODE>InetAddress</CODE> structure contains a port number of 0. You can use this address directly in all Open Transport functions that require an Internet address, such as <CODE>OTConnect</CODE>, <CODE>OTSndUData</CODE>, and <CODE>OTBind</CODE>.<P>
 The <CODE>OTLookupName</CODE> function returns only a single address, regardless of how many addresses are known for a single multihomed host. To obtain a list of up to 10 addresses for a multihomed host, use the <A HREF=NetworkingWOT-395.html#MARKER-9-116><CODE>OTInetStringToAddress</CODE></A> function .<A NAME=MARKER-13-107></A> <P>
 <P>
<HR>
<B>Subtopics</B>
<B><!-- TOC --><DL>
<DT><A HREF="NetworkingWOT-56.html#HEADING56-2">Setting Options When Configuring a TCP/IP Provider</A>
<DD>
<DT><A HREF="NetworkingWOT-56.html#HEADING56-5">Using RawIP</A>
<DD>
<DT><A HREF="NetworkingWOT-56.html#HEADING56-11">Receiving RawIP Datagrams </A>
<DD>
<DT><A HREF="NetworkingWOT-56.html#HEADING56-15">Sending RawIP Datagrams</A>
<DD>
<DT><A HREF="NetworkingWOT-56.html#HEADING56-18">Manually Setting the IP Header </A>
<DD>
<DT><A HREF="NetworkingWOT-56.html#HEADING56-25">Limitations of the Header-Included Mode</A>
<DD>
<DT><A HREF="NetworkingWOT-56.html#HEADING56-37">Using IP Multicasting</A>
<DD>
<DT><A HREF="NetworkingWOT-56.html#HEADING56-42">Querying DNS Servers</A>
<DD>
<DT><A HREF="NetworkingWOT-56.html#HEADING56-48">Avoiding Delay When Rebinding to TCP Connections</A>
<DD>
<DT><A HREF="NetworkingWOT-56.html#HEADING56-58">Using General Open Transport Functions With TCP/IP </A>
<DD>
<DT><A HREF="NetworkingWOT-56.html#HEADING56-60">Obtaining Endpoint Data With TCP/IP</A>
<DD>
<DT><A HREF="NetworkingWOT-56.html#HEADING56-64">Using Endpoint Functions With TCP/IP</A>

<DD>
<DT><A HREF="NetworkingWOT-56.html#HEADING56-116">Using Mapper Functions With TCP/IP</A>

</DL>
</B>
</BLOCKQUOTE>
<HR>
<center>
<A HREF="NetworkingWOT-55.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="NetworkingWOT-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="NetworkingWOT-491.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A>  <A HREF="NetworkingWOT-57.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="NetworkingWOT-4.html">&copy; Apple Computer, Inc.</A><br>15 JAN 1998<P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML> 
