<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>Dynamic Library Programming Topics: Dynamic Library Usage Guidelines</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Dynamic Library Usage Guidelines"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP40001928" title="Dynamic Library Usage Guidelines"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../../Darwin/index.html#//apple_ref/doc/uid/TP30000440-TP30000422" target="_top">Darwin</a> &gt; <a href="../../../../Darwin/RuntimeArchitecture-date.html#//apple_ref/doc/uid/TP30000440-TP30000422-TP30000459" target="_top">Runtime Architecture</a> &gt; <a href="../index.html" target="_top">Dynamic Library Programming Topics</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="DynamicLibraryDesignGuidelines.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="CreatingDynamicLibraries.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>
        
        
        <a name="//apple_ref/doc/uid/TP40001928-SW10" title="Dynamic Library Usage Guidelines"></a><hr /><H1>Dynamic Library Usage Guidelines</H1><p>The dynamic loader compatibility functions provide a portable and efficient way to load code at runtime. However, using the functions incorrectly can degrade application performance. This article shows how to correctly load and use dynamic libraries in your applications.</p><p>Dynamic libraries help to distribute an application’s functionality into distinct modules that can be loaded as they are needed. Dynamic libraries can be loaded either when the application launches or as it runs. Libraries that are loaded at launch time are called <strong>dependent libraries</strong>. Libraries that are loaded at runtime are called <strong>dynamically loaded libraries</strong>. You specify which dynamic libraries your application depends on by linking your application against them. However, it’s more efficient to use dynamic libraries as dynamically loaded libraries instead of dependent libraries. That is, you should open libraries when you’re about to use symbols they export and close them when you’re done. In some cases, the system unloads dynamically loaded libraries when it determines that they aren’t being used. </p><p>This article uses the word <strong>image</strong> to refer to an application file or a dynamic library. Application files contain the application’s code and the code from the static libraries the application uses. The dynamic libraries the application loads at launch time or runtime are separate images.</p>
<!-- This template is being used for both PDF and HTML. -->

    
    <!-- TopicBook.pm uses this template for its miniTOCs, but needs a different title. -->
    <h4>Contents:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="DynamicLibraryUsageGuidelines.html#//apple_ref/doc/uid/TP40001928-SW12">Opening Dynamic Libraries</a>
				
			<br/>
			
        
			
			
				<a href="DynamicLibraryUsageGuidelines.html#//apple_ref/doc/uid/TP40001928-SW9">Using Symbols</a>
				
			<br/>
			
        
			
			
				<a href="DynamicLibraryUsageGuidelines.html#//apple_ref/doc/uid/TP40001928-SW13">Using Weakly Linked Symbols</a>
				
			<br/>
			
        
			
			
				<a href="DynamicLibraryUsageGuidelines.html#//apple_ref/doc/uid/TP40001928-SW11">Using C++ Classes</a>
				
			<br/>
			
        
			
			
				<a href="DynamicLibraryUsageGuidelines.html#//apple_ref/doc/uid/TP40001928-SW23">Using Objective-C Classes</a>
				
			<br/>
			
        
			
			
				<a href="DynamicLibraryUsageGuidelines.html#//apple_ref/doc/uid/TP40001928-SW25">Getting Information on an Address</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP40001928-SW12" title="Opening Dynamic Libraries"></a><h2>Opening Dynamic Libraries</h2><p>The dynamic loader loads an image’s dependent libraries when the image is opened; that is, when an application is loaded or when an dynamic library is opened. The dynamic loader binds references to symbols exported by dependent libraries lazily. Lazy binding means the symbol references are bound only when the image actually uses the symbols. As a debugging measure, you can specify that all references to the exported symbols of a library be bound when the dynamic loader opens the library. You use the <code>gcc -bind_at_load</code> flag when generating the dynamic library.</p><p>To use a dynamic library that is not a dependent library of your image, you use the <code><a href="../../../Reference/MachOReference/Reference/reference.html#//apple_ref/c/func/dlopen" target="_top">dlopen</a></code> function. This function tells the dynamic loader to load a specific dynamic library into the address space of the current process. This function also allows you to specify when the  dynamic loader binds the library’s references to the corresponding exported symbols in its dependent libraries and whether to place the library’s exported symbols in the current process’s global scope or a local scope. This function returns a handle called <strong>library handle</strong>. This handle represents the dynamically loaded library in calls to <code>dlsym</code> (to use an exported symbol) and <code>dlclose</code> (to close the library). The library handle provides <code>dlsym</code> a limited domain within which to search for a symbol (see <span class="content_text"><a href="DynamicLibraryUsageGuidelines.html#//apple_ref/doc/uid/TP40001928-SW9">“Using Symbols”</a></span> for details). The client must call <code>dlclose</code> when it’s finished using the dynamically loaded library (for example, when the module that opened the library has finished its task).</p><p>A dynamic library may itself have dependent libraries. To find out which libraries a dynamic library depends on, use the <code>otool -L</code> command. Before using the library, you must ensure that all its dependent libraries are present in your computer. Otherwise, the dynamic loader doesn’t load your application or library when requested at application launch time or when the library is opened with <code><a href="../../../Reference/MachOReference/Reference/reference.html#//apple_ref/c/func/dlopen" target="_top">dlopen</a></code>.</p><p>A process can open the same dynamic library several times without closing it. The <code>dlopen</code> function returns the same library handle it returned in the first call, but it also increments the reference count associated with the handle. Calls to <code>dlclose</code> decrement the library handle’s reference count. Therefore, you must balance every call to <code>dlopen</code> with a call to <code>dlclose</code>. When the reference count for a library handle reaches 0, the dynamic loader may remove the library from the address space of the application. </p><a name="//apple_ref/doc/uid/TP40001928-SW21" title="The Library Search Process"></a><h3>The Library Search Process</h3><p>The first parameter to <code><a href="../../../Reference/MachOReference/Reference/reference.html#//apple_ref/c/func/dlopen" target="_top">dlopen</a></code> is the name of the dynamic library to open. This may be a filename or a partially or fully qualified pathname. For example, <code>libCelsus.dylib</code> , <code>lib/libCelsus.dylib</code> , or <code>/usr/local/libCelsus.dylib</code>.</p><p>The dynamic loader searches for libraries in the directories specified by a set of environment variables and the process’s current working directory. These variables, when defined, must contain a colon-separated list of pathnames (absolute or relative) in which the dynamic loader searches for libraries. <span class="content_text">Table 1</span> lists the variables.</p><a name="//apple_ref/doc/uid/TP40001928-SW1" title="Table 1Environment variables that define dynamic-loader search paths"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 1&nbsp;&nbsp;</strong>Environment variables that define dynamic-loader search paths</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Environment variable</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Default value</p></th></tr><tr><td  scope="row"><p><code>LD_LIBRARY_PATH</code></p></td><td ><p>No default value</p></td></tr><tr><td  scope="row"><p><code>DYLD_LIBRARY_PATH</code></p></td><td ><p>No default value</p></td></tr><tr><td  scope="row"><p><code>DYLD_FALLBACK_LIBRARY_PATH</code></p></td><td ><p><code>$HOME/lib;/usr/local/lib;/usr/lib</code></p></td></tr></table></div><p>When the library name is a filename (that is, when it doesn’t include directory names), the dynamic loader searches for the library in several locations until it finds it, in the following order:</p><ol class="ol"><li class="li"><p><code>$LD_LIBRARY_PATH</code></p></li><li class="li"><p><code>$DYLD_LIBRARY_PATH</code></p></li><li class="li"><p>The process’s working directory</p></li><li class="li"><p><code>$DYLD_FALLBACK_LIBRARY_PATH</code></p></li></ol><p>When the library name contains at least one directory name, that is, when the name is a pathname (relative or fully qualified), the dynamic loader searches for the library in the following order:</p><ol class="ol"><li class="li"><p><code>$DYLD_LIBRARY_PATH</code> using the filename</p></li><li class="li"><p>The given pathname</p></li><li class="li"><p><code>$DYLD_FALLBACK_LIBRARY_PATH</code> using the filename</p></li></ol><p>For example, say you set the environment variables introduced earlier as shown in the following table.</p><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Environment variable</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Value</p></th></tr><tr><td  scope="row"><p><code>LD_LIBRARY_PATH</code></p></td><td ><p><code>./lib</code></p></td></tr><tr><td  scope="row"><p><code>DYLD_LIBRARY_PATH</code></p></td><td ><p><code>/usr/local/dylibs</code></p></td></tr><tr><td  scope="row"><p><code>DYLD_FALLBACK_LIBRARY_PATH</code></p></td><td ><p><code>/usr/local/lib</code></p></td></tr></table></div><p>Assuming your  application calls <code>dlopen</code> with the filename <code>libCelsus.dylib</code>, the dynamic loader would attempt to open the library using the following pathnames, in order:</p><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Pathname</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Description</p></th></tr><tr><td  scope="row"><p><code>./lib/libCelsus.dylib</code></p></td><td ><p><code>LD_LIBRARY_PATH</code> environment variable</p></td></tr><tr><td  scope="row"><p><code>/usr/local/dylibs/libCelsus.dylib</code></p></td><td ><p><code>DYLD_LIBRARY_PATH</code> environment variable</p></td></tr><tr><td  scope="row"><p><code>libCelsus.dylib</code></p></td><td ><p>Current working directory</p></td></tr><tr><td  scope="row"><p><code>/usr/local/lib/libCelsus.dylib</code></p></td><td ><p><code>DYLD_FALLBACK_LIBRARY_PATH</code> environment variable</p></td></tr></table></div><p>If the application calls <code>dlopen</code> with the pathname <code>/libs/libCelsus.dylib</code>, the dynamic loader tries to find the library using these pathnames, in order:</p><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Pathname</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Description</p></th></tr><tr><td  scope="row"><p><code>/usr/local/dylibs/libCelsus.dylib</code></p></td><td ><p><code>DYLD_LIBRARY_PATH</code> environment variable</p></td></tr><tr><td  scope="row"><p><code>/libs/libCelsus.dylib</code></p></td><td ><p>Path as given</p></td></tr><tr><td  scope="row"><p><code>/usr/local/lib/libCelsus.dylib</code></p></td><td ><p><code>DYLD_FALLBACK_LIBRARY_PATH</code> environment variable</p></td></tr></table></div><a name="//apple_ref/doc/uid/TP40001928-SW22" title="Specifying the Scope and Binding Behavior of Exported Symbols"></a><h3>Specifying the Scope and Binding Behavior of Exported Symbols</h3><p>The second parameter of the <code><a href="../../../Reference/MachOReference/Reference/reference.html#//apple_ref/c/func/dlopen" target="_top">dlopen</a></code> function specifies two properties: the scope of the library's exported symbols in the current process and when to bind the application's references the those symbols.</p><p>Symbol scope directly affects the performance of applications. Therefore, it’s important that you set the appropriate scope for a library you open at runtime.</p><p>A dynamically loaded library’s exported symbols can be in one of two levels of scope in the current process: global and local. The main difference between the scopes is that the symbols in the global scope are available to all images in the process, including other dynamically loaded libraries. Symbols in the local scope can be used only by the image that opened the library. See <span class="content_text"><a href="DynamicLibraryUsageGuidelines.html#//apple_ref/doc/uid/TP40001928-SW9">“Using Symbols”</a></span> for more information.</p><p>When the dynamic loader searches for symbols, it performs string comparisons against every symbol in the search scope. Reducing the number of symbols the dynamic loader has to go through to find the desired symbol improves your application’s performance. Opening all dynamically loaded libraries into the local scope instead of the global scope maximizes symbol search performance.</p><p>You should never need to open a dynamic library into the process’s global scope so that all modules in the application have access to its symbols. Instead, each module that uses the library should open it into its local scope. When done, the module should close the library. If you want the symbols exported by the library to be available to all images in the process, consider making the library a dependent library of the application.</p><p>The parameter used to specify symbol scope is also used to specify when the undefined external symbols of the dynamically loaded library are resolved (or bound with their definitions the library’s own dependent libraries). Undefined external symbols of dynamically loaded libraries can be resolved either immediately or lazily. If a client application uses immediate binding when opening a dynamic library with <code>dlopen</code> , the dynamic loader binds all the undefined external symbols of the dynamically loaded library before returning control to the client application. For example, <span class="content_text">Listing 1</span> shows the log messages the dynamic loader produces when the <code>DYLD_PRINT_BINDINGS</code> environment variable is set and a client application loads a dynamic library called <code>libArt.dylib</code> :</p><a name="//apple_ref/doc/uid/TP40001928-SW2" title="Listing 1Bindings resolved during call to dlopen using immediate binding"></a><p class="codesample"><strong>Listing 1&nbsp;&nbsp;</strong>Bindings resolved during call to <code>dlopen</code> using immediate binding</p><div class="codesample"><table><tr><td scope="row"><pre>dyld: bind: client:_dlopen$lazy_ptr = libSystem.B.dylib:_dlopen<span></span></pre></td></tr><tr><td scope="row"><pre>dyld: bind: libArt.dylib:_dlopen$lazy_ptr = libSystem.B.dylib:_dlopen<span></span></pre></td></tr><tr><td scope="row"><pre>dyld: bind: libArt.dylib:_printf$LDBLStub$lazy_ptr = libA.dylib:_printf$LDBLStub<span></span></pre></td></tr><tr><td scope="row"><pre>dyld: bind: libArt.dylib:_dlerror$lazy_ptr = libSystem.B.dylib:_dlerror<span></span></pre></td></tr><tr><td scope="row"><pre>dyld: bind: libArt.dylib:_dlclose$lazy_ptr = libSystem.B.dylib:_dlclose<span></span></pre></td></tr><tr><td scope="row"><pre>dyld: bind: libArt.dylib:_dlsym$lazy_ptr = libSystem.B.dylib:_dlsym<span></span></pre></td></tr><tr><td scope="row"><pre>dyld: bind: libArt.dylib:___stub_getrealaddr$lazy_ptr = libA.dylib:___stub_getrealaddr<span></span></pre></td></tr><tr><td scope="row"><pre>dyld: bind: libArt.dylib:_NSIsSymbolNameDefinedWithHint$lazy_ptr =<span></span></pre></td></tr><tr><td scope="row"><pre>                            libSystem.B.dylib:_NSIsSymbolNameDefinedWithHint<span></span></pre></td></tr><tr><td scope="row"><pre>dyld: bind: libArt.dylib:_strcpy$lazy_ptr = libSystem.B.dylib:_strcpy<span></span></pre></td></tr><tr><td scope="row"><pre>dyld: bind: libArt.dylib:_NSLookupAndBindSymbolWithHint$lazy_ptr =<span></span></pre></td></tr><tr><td scope="row"><pre>                            libSystem.B.dylib:_NSLookupAndBindSymbolWithHint<span></span></pre></td></tr><tr><td scope="row"><pre>dyld: bind: libArt.dylib:_NSAddressOfSymbol$lazy_ptr =<span></span></pre></td></tr><tr><td scope="row"><pre>                            libSystem.B.dylib:_NSAddressOfSymbol<span></span></pre></td></tr><tr><td scope="row"><pre>dyld: bind: libArt.dylib:_strlen$lazy_ptr = libSystem.B.dylib:_strlen<span></span></pre></td></tr></table></div>	<p>The first log message indicates that the client application’s <code>_dlopen</code> undefined symbol was bound. The remaining messages are the bindings the dynamic loader performs on the dynamic library as part of the loading process before returning control to the calling routine. When using lazy binding, the dynamic loader resolves only the client application’s reference to the <code>dlopen</code> function, returning control to the calling routine much sooner. For more information on dynamic loader logging, see <span class="content_text"><a href="LoggingDynamicLoaderEvents.html#//apple_ref/doc/uid/TP40002077-SW1">“Logging Dynamic Loader Events.”</a></span></p><p>Once a library has been opened with <code>dlopen</code>, the scope defined for it cannot be changed by subsequent calls to <code>dlopen</code> to load the same library. For example, if the process opens a library that hasn’t been loaded into the local scope  and later opens the same library into the global scope, the opened library retains its local status. That is, the symbols the library exports do not become available in the global scope with the latter call. This is true even if the library is closed before reopening it within the same process. </p><div class="importantbox"><a name="//apple_ref/doc/uid/TP40001928-DontLinkElementID_4" title="Important:"></a><p><strong>Important:</strong>&nbsp;All runtime loaded should be opened into the local scope. Adhering to this rule makes finding symbols at runtime as fast as possible.</p><p></p></div><p>Immediate binding slows the loading of dynamic libraries, especially when those libraries contain many undefined external symbols. However, immediate binding can help during development and testing of dynamic libraries because when the dynamic loader cannot resolve all the undefined external symbols of a dynamically loaded library, the application terminates with an error. When deploying the application, however, you should use lazy loading because undefined external symbols are bound only when necessary. Loading dynamic libraries this way can help make your application feel more responsive to its users.</p><p>The external undefined symbols in dependent libraries are bound when they are first used unless the client image’s compile line includes the <code>gcc -bind_at_load</code> option. See the <code><a href="../../../../Darwin/Reference/ManPages/man1/ld.1.html#//apple_ref/doc/man/1/ld" target="_top">ld</a></code> man page for details.</p><a name="//apple_ref/doc/uid/TP40001928-SW9" title="Using Symbols"></a><h2>Using Symbols</h2><p>After opening a dynamic library using <code><a href="../../../Reference/MachOReference/Reference/reference.html#//apple_ref/c/func/dlopen" target="_top">dlopen</a></code>, an image uses the <code><a href="../../../Reference/MachOReference/Reference/reference.html#//apple_ref/c/func/dlsym" target="_top">dlsym</a></code> function to get the address of the desired symbol before using it. This  function takes two parameters. The first one specifies in which libraries the dynamic loader looks for the symbol. The second parameter specifies the name of the symbol. For example:</p><div class="codesample"><table><tr><td scope="row"><pre>symbol_pointer = dlsym(library_handle, "my_symbol")<span></span></pre></td></tr></table></div><p>This invocation tells the dynamic loader to search for a symbol named <code>my_symbol</code> among the symbols exported by the dynamically loaded library represented by the <code>library_handle</code> variable.</p><p>There are three scopes the dynamic loader can search for a symbol: a specific dynamic library, the current image's dependent libraries, and the global scope of the process:</p><ul class="ul"><li class="li"><p><strong>The local scope:</strong> To search the symbols exported by a particular dynamic library that has been loaded using <code>dlopen</code>, you provide <code>dlsym</code> with the handle to that library. This is the most efficient usage model.</p></li><li class="li"><p><strong>The next scope:</strong> This search scope is useful only when a module has interposed a symbol exported by a dependent library. For example, you may need to intercept all calls to a system function to perform bookkeeping before calling the real implementation. In that case, in your custom definition of the function, you get the address of the function you interposed by invoking <code>dlsym</code> with the <code>RTLD_NEXT</code> special handle instead of the handle to a particular library. Such a call returns the address of the function that would have been executed if you hadn’t masked out that implementation with your own. Therefore, only the dependent libraries of the current image are searched; any other libraries, including libraries opened by the image making the <code>dlsym</code> call, are not searched. Also, in a flat namespace, the search starts in the first dependent library listed after the current one when the application was linked.</p></li><li class="li"><p><strong>The global scope:</strong> To search the global scope, you call <code>dlsym</code> with the  <code>RTLD_DEFAULT</code> special handle. The dynamic loader searches the dependent libraries (loaded at launch time) and the dynamically loaded libraries (loaded at runtime with <code>RTLD_GLOBAL</code> ) for the first match of the symbol name given to <code>dlsym</code> . You should avoid performing global symbol searches because they are the most inefficient.</p></li></ul><div class="notebox"><a name="//apple_ref/doc/uid/TP40001928-SW26" title="Note"></a><p><strong>Note:</strong>&nbsp;Name conflicts between dynamic shared libraries are not discovered at compile time, link time, or runtime. The <code>dlsym</code> function uses string matching to find symbols. If two libraries use the same name for a function, the first one that matches the symbol name given to <code>dlsym</code> is returned.</p></div><p>To illustrate the concepts introduced in this section, take the application depicted in <span class="content_text">Figure 1</span>. It shows that the application has two dependent libraries, <code>libArt.dylib</code> and <code>libBus.dylib</code>. The <code>libBus.dylib</code> library itself has two dependent libraries, <code>libBus1.dylib</code> and <code>libBus2.dylib</code>. The <code>libBus1.dylib</code> library has one dependent library, <code>libBus1a.dylib</code>. In addition, there are four dynamic libraries the application doesn’t depend on, <code>libCar.dylib</code>, <code>libCar1.dylib</code>, <code>libDot.dylib</code>, and <code>libDot1.dylib</code>. The <code>libCar1.dylib</code> library is a dependent library of <code>libCar.dylib</code> and <code>libDot1.dylib</code> is a dependent library of <code>libDot.dylib</code>. All the libraries except <code>libArt.dylib</code> export the <code>dependencies</code> function. Each library has a unique implementation of the <code>...name</code> function.</p><br/><div><a name="//apple_ref/doc/uid/TP40001928-SW3" title="Figure 1Application with dependent library hierarchy"></a><p><strong>Figure 1&nbsp;&nbsp;</strong>Application with dependent library hierarchy</p><img src = "../art/dylibhierarchy.gif" alt = "" width="498" height="413"></div><br/><p>The application image can access the exported symbols in <code>libArt.dylib</code> and <code>libBus.dylib</code> directly, as shown in <span class="content_text">Listing 2</span>.</p><a name="//apple_ref/doc/uid/TP40001928-SW4" title="Listing 2Application image using symbols exported by dependent libraries through undefined external references"></a><p class="codesample"><strong>Listing 2&nbsp;&nbsp;</strong>Application image using symbols exported by dependent libraries through undefined external references</p><div class="codesample"><table><tr><td scope="row"><pre>#include &lt;stdio.h><span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>extern char* A_name();          // libArt.dylib<span></span></pre></td></tr><tr><td scope="row"><pre>extern char* dependencies();    // libBus.dylib<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>int main(void) {<span></span></pre></td></tr><tr><td scope="row"><pre>    printf("[%s] libArt.A_name() = %s\n", __FILE__, A_name());<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    printf("[%s] libBus.dependencies() = %s\n", __FILE__, dependencies());<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>The application image, however, cannot directly access the symbols exported by <code>libBus1.dylib</code>, <code>libBus1a.dylib</code>, and <code>libBus2.dylib</code> because those libraries are not dependent libraries of the application image. To gain access to those symbols, the application image has to open the corresponding libraries using <code>dlopen</code>, as shown in <span class="content_text">Listing 3</span>.</p><a name="//apple_ref/doc/uid/TP40001928-SW5" title="Listing 3Application image using a symbol exported by a dynamic library loaded at runtime"></a><p class="codesample"><strong>Listing 3&nbsp;&nbsp;</strong>Application image using a symbol exported by a dynamic library loaded at runtime</p><div class="codesample"><table><tr><td scope="row"><pre>#include &lt;stdio.h><span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;dlfcn.h><span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>int main(void) {<span></span></pre></td></tr><tr><td scope="row"><pre>    void* Bus1a_handle = dlopen("libBus1a.dylib", RTLD_LOCAL);<span></span></pre></td></tr><tr><td scope="row"><pre>    if (Bus1a_handle) {<span></span></pre></td></tr><tr><td scope="row"><pre>        char* (*b1a_name)() = dlsym(Bus1a_handle, "B1a_name");<span></span></pre></td></tr><tr><td scope="row"><pre>        if (b1a_name) {<span></span></pre></td></tr><tr><td scope="row"><pre>            printf("[%s] libBus1a.B1a_name() = %s\n",<span></span></pre></td></tr><tr><td scope="row"><pre>                __FILE__, b1a_name());<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    else {<span></span></pre></td></tr><tr><td scope="row"><pre>        printf("[%s] Unable to open libBus1a.dylib: %s\n",<span></span></pre></td></tr><tr><td scope="row"><pre>            __FILE__, dlerror());<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    dlclose(Bus1a_handle);<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>So far you have seen how to access symbols either through references to imported symbols or by obtaining the address of the desired symbol by calling <code>dlsym</code> with the handle of the corresponding library or with the <code>RTLD_DEFAULT</code> special handle. As mentioned earlier, interposed symbols offer the ability to change the definition of a symbol exported by a dependent library.</p><p>To access the original definition of interposed symbols, you call <code>dlsym</code> with the <code>RTLD_NEXT</code> special handle. <span class="content_text">Listing 4</span> shows the implementation of the <code>dependencies</code> function in the Bus library (the implementation is identical in Bus1 and Bus1a). The function in Bus returns the name of the library (contained in the <code>k_lib_name</code> variable) concatenated with a separator string and the text returned by the next definition of <code>dependencies</code>, which is found in the Bus1 library. The definition in Bus1 concatenates its name with a separator string and the text returned by the definition in Bus1a. The definition in Bus1a is the last that would’ve been found if none of the client images had defined their own version. Therefore, when Bus1a invokes <code>dlsym(RTLD_NEXT, "dependencies")</code> no other definitions for <code>dependencies</code> are found. That’s the end of the interposition hierarchy of the <code>dependencies</code> function.</p><a name="//apple_ref/doc/uid/TP40001928-SW6" title="Listing 4Library image using an interposed symbol"></a><p class="codesample"><strong>Listing 4&nbsp;&nbsp;</strong>Library image using an interposed symbol</p><div class="codesample"><table><tr><td scope="row"><pre>#include &lt;string.h><span></span></pre></td></tr><tr><td scope="row"><pre>static char* k_lib_name = "libBus";<span></span></pre></td></tr><tr><td scope="row"><pre>char* dependencies(void) {<span></span></pre></td></tr><tr><td scope="row"><pre>    char _dependencies[50] = "";<span></span></pre></td></tr><tr><td scope="row"><pre>    strcpy(_dependencies, k_lib_name);<span></span></pre></td></tr><tr><td scope="row"><pre>    char* (*next_dependencies)() =<span></span></pre></td></tr><tr><td scope="row"><pre>        dlsym(RTLD_NEXT, "dependencies");// look for next definition<span></span></pre></td></tr><tr><td scope="row"><pre>    if (next_dependencies) {<span></span></pre></td></tr><tr><td scope="row"><pre>        strncat(_dependencies, ", ",<span></span></pre></td></tr><tr><td scope="row"><pre>            sizeof(_dependencies) - strlen(_dependencies) - 1);<span></span></pre></td></tr><tr><td scope="row"><pre>        strncat(_dependencies, next_dependencies(),<span></span></pre></td></tr><tr><td scope="row"><pre>            sizeof(_dependencies) - strlen(_dependencies) - 1);<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    return strdup(_dependencies);<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>When the application image calls the dependencies function in the Bus library, it obtains the names of all the libraries the Bus library depends on, as shown in <span class="content_text">Listing 5</span>.</p><a name="//apple_ref/doc/uid/TP40001928-SW7" title="Listing 5Application image calling an interposed function"></a><p class="codesample"><strong>Listing 5&nbsp;&nbsp;</strong>Application image calling an interposed function</p><div class="codesample"><table><tr><td scope="row"><pre>#include &lt;stdio.h><span></span></pre></td></tr><tr><td scope="row"><pre>extern char* dependencies();    // libBus.dylib<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>int main(void) {<span></span></pre></td></tr><tr><td scope="row"><pre>    printf("[%s] libBus.dependencies() = %s\n",<span></span></pre></td></tr><tr><td scope="row"><pre>        __FILE__, dependencies());<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40001928-SW13" title="Using Weakly Linked Symbols"></a><h2><a name="//apple_ref/doc/uid/TP40001928-SW20" title="Using Weakly Linked Symbols"></a>Using Weakly Linked Symbols</h2><p>To promote compatibility with earlier or later revisions, a dynamic library may export some or all its public symbols as weakly linked symbols. A <strong>weakly linked symbol</strong> is one for which the compiler generates a weak reference when a client is compiled against a library. Weakly linked symbols may have the <code>weak_import</code> attribute in their declarations in the library’s header files, or the library’s developer may otherwise document which of the library’s public symbols are weakly linked. A third way to identify weakly linked symbols it by executing the command:</p><div class="codesample"><table><tr><td scope="row"><pre>nm -m &lt;client_file> | grep weak<span></span></pre></td></tr></table></div><p>This command lists the weakly linked symbols imported from dependent libraries.</p><p>A weakly linked symbol may or may not be defined by a dependent library. That is, although the symbol is declared in a header file, the corresponding dynamic library file may not contain an implementation of that symbol. <span class="content_text">Listing 6</span> shows how a weakly linked symbol may be declared in a header file for a dynamic library. Clients that use this header file as their interface to the corresponding dependent library are guaranteed that <code>name</code> and <code>set_name</code> are defined. However, <code>clear_name</code> may not be implemented. The dependent library loads successfully whether or not it implements <code>clear_name</code>. But it doesn’t load if it doesn’t define either <code>name</code> or <code>set_name</code> . When the library doesn’t implement a weakly linked symbol, the dynamic loader sets to 0 any client references to the symbol.</p><a name="//apple_ref/doc/uid/TP40001928-SW14" title="Listing 6Header file with a weakly linked symbol declaration"></a><p class="codesample"><strong>Listing 6&nbsp;&nbsp;</strong>Header file with a weakly linked symbol declaration</p><div class="codesample"><table><tr><td scope="row"><pre>/* File: Person.h */<span></span></pre></td></tr><tr><td scope="row"><pre>#define WEAK_IMPORT __attribute__((weak_import))<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>char* name(void);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>void set_name(char* name);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>WEAK_IMPORT<span></span></pre></td></tr><tr><td scope="row"><pre>void clear_name(void);<span></span></pre></td></tr></table></div><p>Weakly linked symbols are used by library developers to maximize the compatibility of a client with earlier or newer versions of a dependent library. For example, a symbol that was implemented in a particular revision of a library may not be available in a later revision. But a client linked against the first revision also works with the second revision. Client developers, however, must ensure the existence of the symbol in the running process before executing it. This mechanism is also used to provide a standard interface to plug-ins, which may or may not implement the entire interface.</p><p><span class="content_text">Listing 7</span> shows code that ensures that a particular function is defined before using it. When the function is not found, the client uses a different function to accomplish the desired task. In this case, the fallback function is not a weakly linked symbol, so no test is required. Other situations may not offer an alternate interface. In such cases the client may not be able to perform the desired task.</p><a name="//apple_ref/doc/uid/TP40001928-SW15" title="Listing 7Using a weakly linked symbol"></a><p class="codesample"><strong>Listing 7&nbsp;&nbsp;</strong>Using a weakly linked symbol</p><div class="codesample"><table><tr><td scope="row"><pre>// Clear the 'name' property.<span></span></pre></td></tr><tr><td scope="row"><pre>if (clear_name) {<span></span></pre></td></tr><tr><td scope="row"><pre>    clear_name();<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre>else {<span></span></pre></td></tr><tr><td scope="row"><pre>    set_name(" ");<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40001928-SW11" title="Using C++ Classes"></a><h2>Using C++ Classes</h2><p>How client developers use a C++ class depends on whether the dynamic library that implements it is loaded when the client is loaded (dependent library) or at a later point (runtime loaded library). Dependent-library classes can be used directly. That is, clients can create and delete objects with the <code>new</code> and <code>delete</code> operators. Classes implemented in libraries loaded at runtime with <code><a href="../../../Reference/MachOReference/Reference/reference.html#//apple_ref/c/func/dlopen" target="_top">dlopen</a></code> are called <strong>runtime loaded classes</strong>.</p><p>A runtime loaded class must be instantiated by the client using that class’s factory functions, declared as part of the class’s interface. <strong>Factory functions</strong> create and destroy instances of a specific class: Constructor functions instantiate objects and destructor functions destroy them. Clients must use factory functions instead of <code>new</code> and <code>delete</code> because the dynamic loader doesn’t have access to a runtime loaded class’s constructors and destructors. When the client calls a factory function, the library invokes the appropriate constructor and destructor on the client’s behalf. After you create an instance of a runtime loaded class, you invoke its member functions the same way you would call them if the class were defined locally.</p><p>The interface for C++ classes implemented in dynamic libraries is made up of at least the class declaration and a set of factory functions. The class interface includes one type definition per constructor function. To use a factory function, you must create an object of the appropriate type and get the address of the function with <code><a href="../../../Reference/MachOReference/Reference/reference.html#//apple_ref/c/func/dlsym" target="_top">dlsym</a></code>. You can then call the factory function to create or destroy an object of the class.</p><p><span class="content_text">Listing 8</span> shows the interface to the Person class, implemented in the Person library.</p><a name="//apple_ref/doc/uid/TP40001928-SW16" title="Listing 8C++ class interface"></a><p class="codesample"><strong>Listing 8&nbsp;&nbsp;</strong>C++ class interface</p><div class="codesample"><table><tr><td scope="row"><pre>/* File: Person.h */<span></span></pre></td></tr><tr><td scope="row"><pre>class Person {<span></span></pre></td></tr><tr><td scope="row"><pre>    private:<span></span></pre></td></tr><tr><td scope="row"><pre>        char _person_name[30];<span></span></pre></td></tr><tr><td scope="row"><pre>    public:<span></span></pre></td></tr><tr><td scope="row"><pre>        Person();<span></span></pre></td></tr><tr><td scope="row"><pre>        Person(char* name);<span></span></pre></td></tr><tr><td scope="row"><pre>        virtual void set_name(char person_name[]);<span></span></pre></td></tr><tr><td scope="row"><pre>        virtual char* name();<span></span></pre></td></tr><tr><td scope="row"><pre>};<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>// Constructor functions and function types.<span></span></pre></td></tr><tr><td scope="row"><pre>extern "C" Person* NewPerson(void);<span></span></pre></td></tr><tr><td scope="row"><pre>typedef Person * Person_creator(void);<span></span></pre></td></tr><tr><td scope="row"><pre>extern "C" Person* NewPersonWithName(char name[]);<span></span></pre></td></tr><tr><td scope="row"><pre>typedef Person * PersonWithName_creator(char name);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>// Destructor function and function type.<span></span></pre></td></tr><tr><td scope="row"><pre>extern "C" void DeletePerson(Person* person);<span></span></pre></td></tr><tr><td scope="row"><pre>typedef void Person_disposer(Person*);<span></span></pre></td></tr></table></div><p>Note that the Person class has two constructor functions, <code>NewPerson</code> and <code>NewPersonWithName</code> . Each function declaration has a corresponding type, <code>Person_creator</code> and <code>PersonWithName_creator</code>. <span class="content_text">Listing 9</span> shows how a client may use the Person library.</p><a name="//apple_ref/doc/uid/TP40001928-SW17" title="Listing 9Client using a C++ runtime loaded class"></a><p class="codesample"><strong>Listing 9&nbsp;&nbsp;</strong>Client using a C++ runtime loaded class</p><div class="codesample"><table><tr><td scope="row"><pre>/* File: Client.cpp */<span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;iostream><span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;dlfcn.h><span></span></pre></td></tr><tr><td scope="row"><pre>#include "Person.h"<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>int main() {<span></span></pre></td></tr><tr><td scope="row"><pre>    using std::cout;<span></span></pre></td></tr><tr><td scope="row"><pre>    using std::cerr;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Open the library.<span></span></pre></td></tr><tr><td scope="row"><pre>    void* lib_handle = dlopen("./libPerson.dylib", RTLD_LOCAL);<span></span></pre></td></tr><tr><td scope="row"><pre>    if (!lib_handle) {<span></span></pre></td></tr><tr><td scope="row"><pre>        exit(EXIT_FAILURE);<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Get the NewPerson function.<span></span></pre></td></tr><tr><td scope="row"><pre>    Person_creator* NewPerson = (Person_creator*)dlsym(lib_handle, "NewPerson");<span></span></pre></td></tr><tr><td scope="row"><pre>    if (!NewPerson) {<span></span></pre></td></tr><tr><td scope="row"><pre>        exit(EXIT_FAILURE);<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Get the NewPersonWithName function.<span></span></pre></td></tr><tr><td scope="row"><pre>    PersonWithName_creator* NewPersonWithName = (PersonWithName_creator*)dlsym(lib_handle, "NewPersonWithName");<span></span></pre></td></tr><tr><td scope="row"><pre>    if (!NewPersonWithName) {<span></span></pre></td></tr><tr><td scope="row"><pre>        exit(EXIT_FAILURE);<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Get the DeletePerson function.<span></span></pre></td></tr><tr><td scope="row"><pre>    Person_disposer* DeletePerson =<span></span></pre></td></tr><tr><td scope="row"><pre>        (Person_disposer*)dlsym(lib_handle, "DeletePerson");<span></span></pre></td></tr><tr><td scope="row"><pre>    if (!DeletePerson) {<span></span></pre></td></tr><tr><td scope="row"><pre>        exit(EXIT_FAILURE);<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Create Person objects.<span></span></pre></td></tr><tr><td scope="row"><pre>    Person* person1 = NewPerson();<span></span></pre></td></tr><tr><td scope="row"><pre>    Person* person2 = NewPersonWithName("Cendrine");<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Use Person objects.<span></span></pre></td></tr><tr><td scope="row"><pre>    person1->set_name("Floriane");<span></span></pre></td></tr><tr><td scope="row"><pre>    cout &lt;&lt; "[" &lt;&lt; __FILE__ &lt;&lt; "] person1->name() = " &lt;&lt; person1->name() &lt;&lt; "\n";<span></span></pre></td></tr><tr><td scope="row"><pre>    person2->set_name("Marcelle");<span></span></pre></td></tr><tr><td scope="row"><pre>    cout &lt;&lt; "[" &lt;&lt; __FILE__ &lt;&lt; "] person2->name() = " &lt;&lt; person2->name() &lt;&lt; "\n";<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Destroy Person objects.<span></span></pre></td></tr><tr><td scope="row"><pre>    DeletePerson(person1);<span></span></pre></td></tr><tr><td scope="row"><pre>    DeletePerson(person2);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Close the library.<span></span></pre></td></tr><tr><td scope="row"><pre>    if (dlclose(lib_handle) != 0) {<span></span></pre></td></tr><tr><td scope="row"><pre>        exit(EXIT_FAILURE);<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    return 0;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40001928-SW23" title="Using Objective-C Classes"></a><h2>Using Objective-C Classes</h2><p>To use an Objective-C class or category implemented in a dynamic library, a client should have an interface to the class or category. With knowledge of the class’s correct interface, the client can create instances of the class that are appropriately typed. Otherwise, the compiler produces warnings for methods with missing declarations.</p><p>The interfaces of Objective-C classes and categories are published in the library’s header files as protocols. Instantiating a class implemented in a dependent library is no different from doing the same for a locally defined class. However, when you load a dynamic library at runtime using <code><a href="../../../Reference/MachOReference/Reference/reference.html#//apple_ref/c/func/dlopen" target="_top">dlopen</a></code>, you must obtain the appropriate class by calling the <code><a href="../../../../Cocoa/Reference/ObjCRuntimeRef/Reference/reference.html#//apple_ref/c/func/objc_getClass" target="_top">objc_getClass</a></code> function.</p><p>For example, <span class="content_text">Listing 10</span> contains the interfaces for the Person class and the Titling category to that class, which are implemented by the Person dynamic library.</p><a name="//apple_ref/doc/uid/TP40001928-SW18" title="Listing 10Interface to the Person class and its Titling category"></a><p class="codesample"><strong>Listing 10&nbsp;&nbsp;</strong>Interface to the Person class and its Titling category</p><div class="codesample"><table><tr><td scope="row"><pre>/* File: Person.h */<span></span></pre></td></tr><tr><td scope="row"><pre>#import &lt;Foundation/Foundation.h><span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>@protocol Person<span></span></pre></td></tr><tr><td scope="row"><pre>- (void)setName:(NSString*)name;<span></span></pre></td></tr><tr><td scope="row"><pre>- (NSString*)name;<span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>@interface Person : NSObject &lt;Person> {<span></span></pre></td></tr><tr><td scope="row"><pre>    @private<span></span></pre></td></tr><tr><td scope="row"><pre>NSString* _person_name;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/* File: Titling.h */<span></span></pre></td></tr><tr><td scope="row"><pre>#import &lt;Foundation/Foundation.h><span></span></pre></td></tr><tr><td scope="row"><pre>#import "Person.h"<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>@protocol Titling<span></span></pre></td></tr><tr><td scope="row"><pre>- (void)setTitle:(NSString*)title;<span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>@interface Person (Titling) &lt;Titling><span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr></table></div><p>A client compiled with these interfaces and linked against the Person library can create objects that implement the interfaces in a very straightforward way, as shown in <span class="content_text">Listing 11</span>.</p><a name="//apple_ref/doc/uid/TP40001928-SW19" title="Listing 11Example of a client that uses the Person library as a dependent library"></a><p class="codesample"><strong>Listing 11&nbsp;&nbsp;</strong>Example of a client that uses the Person library as a dependent library</p><div class="codesample"><table><tr><td scope="row"><pre>/* File: Client.m */<span></span></pre></td></tr><tr><td scope="row"><pre>#import &lt;Foundation/Foundation.h><span></span></pre></td></tr><tr><td scope="row"><pre>#import "Person.h"<span></span></pre></td></tr><tr><td scope="row"><pre>#import "Titling.h"<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>int main() {<span></span></pre></td></tr><tr><td scope="row"><pre>    NSAutoreleasePool* pool = [NSAutoreleasePool new];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Create an instance of Person.<span></span></pre></td></tr><tr><td scope="row"><pre>    Person&lt;Titling>* person = [Person new];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Use person.<span></span></pre></td></tr><tr><td scope="row"><pre>    [person setName:@"Perrine"];<span></span></pre></td></tr><tr><td scope="row"><pre>    NSLog(@"[%s] main: [person name] = %@", __FILE__, [person name]);<span></span></pre></td></tr><tr><td scope="row"><pre>    [person setTitle:@"Ms."];<span></span></pre></td></tr><tr><td scope="row"><pre>    NSLog(@"[%s] main: [person name] = %@", __FILE__, [person name]);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Dispose of the Person instance.<span></span></pre></td></tr><tr><td scope="row"><pre>    [person release];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    [pool release];<span></span></pre></td></tr><tr><td scope="row"><pre>    return EXIT_SUCCESS;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>When the Person library is a runtime loaded library, however, the client must obtain a reference to the Person class from the Objective-C runtime after loading the library, using <code>objc_getClass</code>. It can then use that reference to instantiate a Person object. However, the variable that holds the instance must by typed as an NSObject that implements the Person and Titling protocols to avoid compiler warnings. When done, the client closes the library, as shown in <span class="content_text">“Using Weakly Linked Symbols.”</span></p><a name="//apple_ref/doc/uid/TP40001928-SW24" title="Listing 12Example of a client that uses the Person library as a runtime loaded library"></a><p class="codesample"><strong>Listing 12&nbsp;&nbsp;</strong>Example of a client that uses the Person library as a runtime loaded library</p><div class="codesample"><table><tr><td scope="row"><pre>/* File: Client.m */<span></span></pre></td></tr><tr><td scope="row"><pre>#import &lt;Foundation/Foundation.h><span></span></pre></td></tr><tr><td scope="row"><pre>#import &lt;dlfcn.h><span></span></pre></td></tr><tr><td scope="row"><pre>#import "Person.h"<span></span></pre></td></tr><tr><td scope="row"><pre>#import "Titling.h"<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>int main() {<span></span></pre></td></tr><tr><td scope="row"><pre>    NSAutoreleasePool* pool = [NSAutoreleasePool new];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Open the Person library.<span></span></pre></td></tr><tr><td scope="row"><pre>    void* lib_handle = dlopen("./libPerson.dylib", RTLD_LOCAL);<span></span></pre></td></tr><tr><td scope="row"><pre>    if (!lib_handle) {<span></span></pre></td></tr><tr><td scope="row"><pre>        exit(EXIT_FAILURE);<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Get the Person class (required with runtime loaded libraries).<span></span></pre></td></tr><tr><td scope="row"><pre>    Class Person_class = objc_getClass("Person");<span></span></pre></td></tr><tr><td scope="row"><pre>    if (!Person_class) {<span></span></pre></td></tr><tr><td scope="row"><pre>        exit(EXIT_FAILURE);<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Create an instance of Person.<span></span></pre></td></tr><tr><td scope="row"><pre>    NSObject&lt;Person,Titling>* person = [Person_class new];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Use person.<span></span></pre></td></tr><tr><td scope="row"><pre>    [person setName:@"Perrine LeVan"];<span></span></pre></td></tr><tr><td scope="row"><pre>    NSLog(@"[%s] main: [person name] = %@", __FILE__, [person name]);<span></span></pre></td></tr><tr><td scope="row"><pre>    [person setTitle:@"Ms."];<span></span></pre></td></tr><tr><td scope="row"><pre>    NSLog(@"[%s] main: [person name] = %@", __FILE__, [person name]);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Dispose of person.<span></span></pre></td></tr><tr><td scope="row"><pre>    [person release];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Close the Person library.<span></span></pre></td></tr><tr><td scope="row"><pre>    if (dlclose(lib_handle) != 0) {<span></span></pre></td></tr><tr><td scope="row"><pre>        exit(EXIT_FAILURE);<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    [pool release];<span></span></pre></td></tr><tr><td scope="row"><pre>    return EXIT_SUCCESS;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40001928-SW25" title="Getting Information on an Address"></a><h2>Getting Information on an Address</h2><p>One of the dynamic loader compatibility (DLC) functions, <code><a href="../../../Reference/MachOReference/Reference/reference.html#//apple_ref/c/func/dladdr" target="_top">dladdr</a></code>, provides information on the image and nearest symbol that corresponds to an address. You can use this function to obtain information about the library that exports a particular symbol.</p><p>The information <code>dladdr</code> provides is returned through an output parameter of type <code>Dl_info</code> . These are the names of the structure’s fields as well as their descriptions:</p><ul class="ul"><li class="li"><p><code>dli_fname</code>: The pathname of the image</p></li><li class="li"><p><code>dli_fbase</code>: The base address of the image within the process</p></li><li class="li"><p><code>dli_sname</code>: The name of the symbol with an address that is equal to or lower than the address provided to <code>dladdr</code></p></li><li class="li"><p><code>dli_saddr</code>: The address of the symbol indicated by <code>dli_sname</code></p></li></ul><p><span class="content_text">Listing 13</span> shows how an application image can get information about a symbol:</p><a name="//apple_ref/doc/uid/TP40001928-SW8" title="Listing 13Getting information about a symbol"></a><p class="codesample"><strong>Listing 13&nbsp;&nbsp;</strong>Getting information about a symbol</p><div class="codesample"><table><tr><td scope="row"><pre>#include &lt;stdio.h><span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;dlfcn.h><span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>extern char* dependencies();<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>int main(void) {<span></span></pre></td></tr><tr><td scope="row"><pre>    // Get information on dependencies().<span></span></pre></td></tr><tr><td scope="row"><pre>    Dl_info info;<span></span></pre></td></tr><tr><td scope="row"><pre>    if (dladdr(dependencies, &amp;info)) {<span></span></pre></td></tr><tr><td scope="row"><pre>        printf("[%s] Info on dependencies():\n", __FILE__);<span></span></pre></td></tr><tr><td scope="row"><pre>        printf("[%s]    Pathname: %s\n",         __FILE__, info.dli_fname);<span></span></pre></td></tr><tr><td scope="row"><pre>        printf("[%s]    Base address: %p\n",     __FILE__, info.dli_fbase);<span></span></pre></td></tr><tr><td scope="row"><pre>        printf("[%s]    Nearest symbol: %s\n",   __FILE__, info.dli_sname);<span></span></pre></td></tr><tr><td scope="row"><pre>        printf("[%s]    Symbol address: %p\n",   __FILE__, info.dli_saddr);<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    else {<span></span></pre></td></tr><tr><td scope="row"><pre>        printf("[%s] Unable to find image containing the address %x\n",<span></span></pre></td></tr><tr><td scope="row"><pre>    __FILE__, &amp;dependencies);<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div>

        <br/><br/> 

        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="DynamicLibraryDesignGuidelines.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="CreatingDynamicLibraries.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2009 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2009-02-26<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/DeveloperTools/Conceptual/DynamicLibraries/100-Articles/DynamicLibraryUsageGuidelines.html%3Fid%3DTP40001869-1.6&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/DeveloperTools/Conceptual/DynamicLibraries/100-Articles/DynamicLibraryUsageGuidelines.html%3Fid%3DTP40001869-1.6&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/DeveloperTools/Conceptual/DynamicLibraries/100-Articles/DynamicLibraryUsageGuidelines.html%3Fid%3DTP40001869-1.6&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>
