<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>Plug-in  - Sample Renderer - /Source/SR_Math.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxGraphicsImaging-date.html">Graphics & Imaging</a> &gt; <A HREF="javascript:location.replace('index.html');">Plug-in  - Sample Renderer</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/GraphicsImaging/index.html" target="_blank">Reference Library > Graphics & Imaging</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">Plug-in  - Sample Renderer</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/Source/SR_Math.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/Headers/resource.h</option>
<option value="listing2.html">/Headers/SR.h</option>
<option value="listing3.html">/Headers/SR_ClipUtilities.h</option>
<option value="listing4.html">/Headers/SR_ConfigData.h</option>
<option value="listing5.html">/Headers/SR_MacDialog.h</option>
<option value="listing6.html">/Headers/SR_Marker.h</option>
<option value="listing7.html">/Headers/SR_MarkerRenderer.h</option>
<option value="listing8.html">/Headers/SR_Math.h</option>
<option value="listing9.html">/Headers/SR_PixmapMarkerRenderer.h</option>
<option value="listing10.html">/Headers/SR_PrefixFile.h</option>
<option value="listing11.html">/Headers/SR_Rasterizers.h</option>
<option value="listing12.html">/Headers/SR_WinDialog.h</option>
<option value="listing13.html">/Source/SR.c</option>
<option value="listing14.html">/Source/SR_ClipUtilities.c</option>
<option value="listing15.html">/Source/SR_ConfigData.c</option>
<option value="listing16.html">/Source/SR_Line.c</option>
<option value="listing17.html">/Source/SR_LinePipe.c</option>
<option value="listing18.html">/Source/SR_MacDialog.c</option>
<option value="listing19.html">/Source/SR_Marker.c</option>
<option value="listing20.html">/Source/SR_MarkerRasterize_32.c</option>
<option value="listing21.html">/Source/SR_MarkerRasterize_8.c</option>
<option value="listing22.html">/Source/SR_Math.c</option>
<option value="listing23.html">/Source/SR_PipelineSetup.c</option>
<option value="listing24.html">/Source/SR_PixmapMarker.c</option>
<option value="listing25.html">/Source/SR_PixmapMarkerRasterize_32.c</option>
<option value="listing26.html">/Source/SR_PixmapMarkerRasterize_8.c</option>
<option value="listing27.html">/Source/SR_Point.c</option>
<option value="listing28.html">/Source/SR_PointPipe.c</option>
<option value="listing29.html">/Source/SR_Rasterizers.c</option>
<option value="listing30.html">/Source/SR_Triangle.c</option>
<option value="listing31.html">/Source/SR_WinDialog.c</option></select>
				</p>
				</form>
				<p><strong><a href="Plug-in__-_Sample_Renderer.zip">Download Sample</a></strong> (&#147;Plug-in__-_Sample_Renderer.zip&#148;, 101.9K)<BR>
<strong><a href="Plug-in__-_Sample_Renderer.dmg">Download Sample</a></strong> (&#147;Plug-in__-_Sample_Renderer.dmg&#148;, 165.9K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/****************************************************************************** **                                       ** **   Module:    SR_Math.c                         ** **                                      ** **                                      ** **   Purpose:   Various mathematical utility functions            ** **                                      ** **                                      ** **                                      ** **   Copyright (C) 1996 Apple Computer, Inc.  All rights reserved.      ** **                                      ** **                                      ** *****************************************************************************/#include &lt;assert.h&gt;#include &lt;math.h&gt;#include &quot;QD3D.h&quot;#include &quot;QD3DMath.h&quot;#include &quot;QD3DGeometry.h&quot;#include &quot;SR.h&quot;#include &quot;SR_Math.h&quot;/*===========================================================================*\ * *  Routine:  SRTriangle_GetNormal() * *  Comments:  Compute the face normal for a triangle. If the triangle *        has a normal in its attribute set, use that; otherwise, *        compute the normal from the vertices. *\*===========================================================================*/TQ3Status SRTriangle_GetNormal(  TQ3TriangleData    *triangleData,  TQ3Vector3D      *normal){  assert(triangleData != NULL);      /*   *  Check for face normal for triangle. Use it if it's there, but assume   *  it's normalized, as per the rule.   */  if ((triangleData-&gt;triangleAttributeSet != NULL) &amp;&amp;     (Q3AttributeSet_Get(       triangleData-&gt;triangleAttributeSet,       kQ3AttributeTypeNormal,       normal) == kQ3Success)) {  } else {    /*      *  Otherwise, compute plane normal, and normalize.     */    Q3Point3D_CrossProductTri(      &amp;triangleData-&gt;vertices[0].point,      &amp;triangleData-&gt;vertices[1].point,      &amp;triangleData-&gt;vertices[2].point,      normal);    Q3Vector3D_Normalize(normal, normal);  }    return (kQ3Success);  }/*===========================================================================*\ * *  Routine:  SRMatrix_LUDecomposeSingular3x3() * *  Comments:  Decompose a singular 3x3 matrix &quot;A&quot; into PA = LU. * *        P is the permutation matrix for the row exchanges required *          by pivoting. *        L is a lower triangular matrix with ones on the diagonal. *        U is an upper echelon matrix.  For nonsingular matrices, *          it is upper triangular. * *        Upon return, this routine returns LU in place of the original *        matrix.  U occupies the upper triangular elements.  L occupies *        the elements below the diagonal.  P is represented in &quot;short- *        hand&quot; form by the three-element vector indexPtr.  If the *        number of row exchanges is even, then *rowInterchanges is 1.0, *        otherwise, -1.0.  The rank of the matrix is returned in *rank. * *        To fully understand this routine, read Chapters 1-3 of  *        Gilbert Strang's book, Linear Algebra and Its Applications. *\*===========================================================================*//*  *  Macros for supporting SRMatrix_LUDecomposeSingular3x3  */#define  FLOAT_TOLERANCE    1.0e-5#define EQUALS_ZERO(a,e)   (FABS(a) &lt; (e))#define SWAP(f,g)       \  {             \    float t;       \              \    t = (f);       \    (f) = (g);       \    (g) = t;       \  }void SRMatrix_LUDecomposeSingular3x3(  float   matrix[3][3],  long   indexPtr[3],  float   *rowInterchanges,  long  *rank){  long  i, j;  float  f;  float  pivot;  long  iPivot;  float  max[3];    /* Initialize parameters */  *rowInterchanges = 1.0;  for (i = 0; i &lt; 3; i++) {    indexPtr[i] = i;  }  *rank = 3;    /* Determine magnitude of largest element in each column */  for (j = 0; j &lt; 3; j++) {    max[j] = 0.0;    for (i = 0; i &lt; 3; i++) {      if ((f = FABS(matrix[i][j])) &gt; max[j]) {        max[j] = f;      }    }  }    /*   * Initial knowledge about LU decomposition:   *   *      |1 0 0|      |? ? ?|   *    L = |? 1 0|    U = |? ? ?|   *      |? ? 1|      |? ? ?|   *   *  ? = yet to be determined   *  * = determined final value   *  X = nonzero pivot   */     /* Find the row with the largest pivot in the first column */  for (i = 0, pivot = 0.0, iPivot = 0; i &lt; 3; i++) {    f = matrix[i][0];    if (FABS(f) &gt; pivot) {      pivot = f;      iPivot = i;    }  }    /* Record permutation of rows */  if (iPivot != 0) {    /* Swap row with largest pivot with first row */    for (j = 0; j &lt; 3; j++) {      SWAP(matrix[0][j], matrix[iPivot][j]);    }    SWAP(indexPtr[0],indexPtr[iPivot]);    *rowInterchanges = -(*rowInterchanges);  }    if ((max[0] == 0.0) ||      EQUALS_ZERO(matrix[0][0] / max[0], FLOAT_TOLERANCE)) {    /*     * First column of U is zero:     *     *      |1 0 0|      |0 ? ?|     *    L = |? 1 0|    U = |0 ? ?|     *      |? ? 1|      |0 ? ?|     */    (*rank)--;    matrix[0][0] = 0.0;        /* Find the row with the largest pivot in the second column */    for (i = 0, pivot = 0.0, iPivot = 0; i &lt; 3; i++) {      f = matrix[i][1];      if (FABS(f) &gt; pivot) {        pivot = f;        iPivot = i;      }    }    /* Record permutation of rows */    if (iPivot != 0) {      /* Swap row with largest pivot with first row */      for (j = 0; j &lt; 3; j++) {        SWAP(matrix[0][j], matrix[iPivot][j]);      }      SWAP(indexPtr[0],indexPtr[iPivot]);      *rowInterchanges = -(*rowInterchanges);    }    if ((max[1] == 0.0) ||        EQUALS_ZERO(matrix[0][1] / max[1], FLOAT_TOLERANCE)) {      /*       * Second column of U is zero:       *       *      |1 0 0|      |0 0 ?|       *    L = |? 1 0|    U = |0 0 ?|       *      |? ? 1|      |0 0 ?|       */      (*rank)--;      matrix[0][1] = 0.0;      matrix[1][1] = 0.0;            /* Find the row with the largest pivot in the third column */      for (i = 0, pivot = 0.0, iPivot = 0; i &lt; 3; i++) {        f = matrix[i][2];        if (FABS(f) &gt; pivot) {          pivot = f;          iPivot = i;        }      }        /* Record permutation of rows */      if (iPivot != 0) {        /* Swap row with largest pivot with first row */        for (j = 0; j &lt; 3; j++) {          SWAP(matrix[0][j], matrix[iPivot][j]);        }        SWAP(indexPtr[0],indexPtr[iPivot]);        *rowInterchanges = -(*rowInterchanges);      }      if ((max[2] == 0.0) ||          EQUALS_ZERO(matrix[0][2] / max[2], FLOAT_TOLERANCE)) {        /*         * Third column of U is zero:         *         *      |1 0 0|      |0 0 0|         *    L = |0 1 0|    U = |0 0 0|         *      |0 0 1|      |0 0 0|         */        (*rank)--;        matrix[0][2] = 0.0;        matrix[1][0] = 0.0;        matrix[1][2] = 0.0;        matrix[2][0] = 0.0;        matrix[2][1] = 0.0;        matrix[2][2] = 0.0;      } else {        /*         * Third column of U has a nonzero pivot:         * Need to calculate multiplier of L to         * eliminate third column of of U:         *         *      |1 0 0|      |0 0 X|         *    L = |* 1 0|    U = |0 0 0|         *      |* 0 1|      |0 0 0|         */        matrix[1][0] = matrix[1][2] / matrix[0][2];        matrix[1][2] = 0.0;        matrix[2][0] = matrix[2][2] / matrix[0][2];        matrix[2][1] = 0.0;        matrix[2][2] = 0.0;      }    } else {      /*       * Second column of U has a nonzero pivot:       * Need to calculate multiplier of L to       * eliminate second column of of U:       *       *      |1 0 0|      |0 X *|       *    L = |* 1 0|    U = |0 0 ?|       *      |* ? 1|      |0 0 ?|       */      f = matrix[1][1] / matrix[0][1];      matrix[1][0] = f;      matrix[1][1] = 0.0;      matrix[1][2] = matrix[1][2] - f * matrix[0][2];             f = matrix[2][1] / matrix[0][1];      matrix[2][0] = f;      matrix[2][1] = 0.0;      matrix[2][2] = matrix[2][2] - f * matrix[0][2];      /* Find the row with the largest pivot in the third column */      if (FABS(matrix[1][2]) &lt; FABS(matrix[2][2])) {        iPivot = 2;        /* Swap third row (possessing largest pivot) with second row */        for (j = 0; j &lt; 3; j++) {          SWAP(matrix[1][j], matrix[iPivot][j]);        }        SWAP(indexPtr[1], indexPtr[iPivot]);        *rowInterchanges = -(*rowInterchanges);      } else {        iPivot = 1;      }            if ((max[2] == 0.0) ||          EQUALS_ZERO(matrix[1][2] / max[2], FLOAT_TOLERANCE)) {        /*         * Third column of U has no nonzero pivot.         *         *      |1 0 0|      |0 X *|         *    L = |* 1 0|    U = |0 0 0|         *      |* 0 1|      |0 0 0|         */        (*rank)--;        matrix[1][2] = 0.0;        matrix[2][1] = 0.0;        matrix[2][2] = 0.0;      } else {        /*         * Third column of U has a nonzero pivot.         * Need to calculate multiplier of L to         * eliminate third column of of U:         *         *      |1 0 0|      |0 X *|         *    L = |* 1 0|    U = |0 0 X|         *      |* * 1|      |0 0 0|         */        matrix[2][1] = matrix[2][2] / matrix[1][2];;        matrix[2][2] = 0.0;      }    }  } else {    /*     * First column of U has a nonzero pivot.     * Need to calculate multipliers of L to     * eliminate first column of of U:     *     *      |1 0 0|      |X * *|     *    L = |* 1 0|    U = |0 ? ?|     *      |* ? 1|      |0 ? ?|     */    f = matrix[1][0] / matrix[0][0];    matrix[1][0] = f;    matrix[1][1] = matrix[1][1] - f * matrix[0][1];    matrix[1][2] = matrix[1][2] - f * matrix[0][2];         f = matrix[2][0] / matrix[0][0];    matrix[2][0] = f;    matrix[2][1] = matrix[2][1] - f * matrix[0][1];    matrix[2][2] = matrix[2][2] - f * matrix[0][2];    /* Find the row with the largest pivot in the second column */    if (FABS(matrix[1][1]) &lt; FABS(matrix[2][1])) {      iPivot = 2;      /* Swap third row (possessing largest pivot) with second row */      for (j = 0; j &lt; 3; j++) {        SWAP(matrix[1][j], matrix[iPivot][j]);      }      SWAP(indexPtr[1], indexPtr[iPivot]);      *rowInterchanges = -(*rowInterchanges);    } else {      iPivot = 1;    }        if ((max[1] == 0.0) ||        EQUALS_ZERO(matrix[1][1] / max[1], FLOAT_TOLERANCE)) {      /*       * Second column of U has no nonzero pivot.       *       *      |1 0 0|      |X * *|       *    L = |* 1 0|    U = |0 0 ?|       *      |* ? 1|      |0 0 ?|       */      (*rank)--;      matrix[1][1] = 0.0;        /* Find the row with the largest pivot in the third column */      if (FABS(matrix[1][2]) &lt; FABS(matrix[2][2])) {        iPivot = 2;        /* Swap third row (possessing largest pivot) with second row */        for (j = 0; j &lt; 3; j++) {          SWAP(matrix[1][j], matrix[iPivot][j]);        }        SWAP(indexPtr[1], indexPtr[iPivot]);        *rowInterchanges = -(*rowInterchanges);      } else {        iPivot = 1;      }            if ((max[2] == 0.0) ||          EQUALS_ZERO(matrix[1][2] / max[2], FLOAT_TOLERANCE)) {        /*         * Third column of U has no nonzero pivot.         *         *      |1 0 0|      |X * *|         *    L = |* 1 0|    U = |0 0 0|         *      |* 0 1|      |0 0 0|         */        (*rank)--;        matrix[1][2] = 0.0;        matrix[2][1] = 0.0;        matrix[2][2] = 0.0;      } else {        /*         * Third column of U has a nonzero pivot.         * Need to calculate multiplier of L to         * eliminate third column of of U:         *         *      |1 0 0|      |X * *|         *    L = |* 1 0|    U = |0 0 X|         *      |* * 1|      |0 0 0|         */        matrix[2][1] = matrix[2][2] / matrix[1][2];;        matrix[2][2] = 0.0;      }    } else {      /*       * Second column of U has a nonzero pivot.       * Need to calculate multipliers of L to       * eliminate second column of of U:       *       *      |1 0 0|      |X * *|       *    L = |* 1 0|    U = |0 X *|       *      |* * 1|      |0 0 ?|       */      f = matrix[2][1] / matrix[1][1];      matrix[2][1] = f;      matrix[2][2] = matrix[2][2] - f * matrix[1][2];            if ((max[2] == 0.0) ||          EQUALS_ZERO(matrix[2][2] / max[2], FLOAT_TOLERANCE)) {        /*         * Third column of U has no nonzero pivot.         *         *      |1 0 0|      |X * *|         *    L = |* 1 0|    U = |0 X *|         *      |* * 1|      |0 0 0|         */        (*rank)--;        matrix[2][2] = 0.0;      } else {        /*         * Third column of U has a nonzero pivot.         * The matrix has full rank.         *         *      |1 0 0|      |X * *|         *    L = |* 1 0|    U = |0 X *|         *      |* * 1|      |0 0 X|         */      }    }  }}/*===========================================================================*\ * *  Routine:  SRMatrix_ComputeFlatLand() * *  Comments:  Computes the eye vector in local coordinates and the plane *        equation in world coordinates when the upper-left 3x3 submatrix *        of the local-to-world matrix has a rank of 2.  The eye vector *        in local coordinates can be used for culling, but should not *        be used for lighting because the local-to-world matrix does *        not preserve lengths. * *  Input:    matrix:        the local-to-world matrix *        luDecomp:      the LU decomposition of the upper-left  *                  3x3 submatrix of the local-to-world matrix *        parallelProjection:  true for parallel projections, false for *                  perspective projections *        eyeVectorWC:    the eye vector in world coordinates *                  (required only for parallel projections) *        eyePointWC:      the eye point in world coordinates *                  (required only for perspective projections) * *  Output:    eyeVectorLC:    the eye vector in local coordinates *        flatWorld:      the plane equation in world coordinates *                  to which all geometry is transformed with *                  the normal in the same hemisphere as the  *                  eye * *  Returns:  kQ3Success:      computation completed successfully *        kQ3Failure:      computation could not be completed  *                  successfully * *        To fully understand this routine, read Chapters 1-3 of  *        Gilbert Strang's book, Linear Algebra and Its Applications. *\*===========================================================================*/TQ3Status SRMatrix_ComputeFlatLand(  TQ3Matrix4x4    *matrix,  TQ3Matrix3x3    *luDecomp,  TQ3Boolean      parallelProjection,  TSRVector4D      *eyeVectorWC,  TQ3RationalPoint4D  *eyePointWC,  TSRVector4D      *eyeVectorLC,  TQ3PlaneEquation  *flatWorld){  long      pivot0 = -1;  long      pivot1 = -1;  long      j;  TQ3Vector3D    v0;  TQ3Vector3D    v1;  TQ3Vector3D    v2;  /* Search for the columns of the first two nonzero pivots */  for (j = 0; j &lt; 3; j++) {    if (luDecomp-&gt;value[0][j] != 0.0) {      pivot0 = j;      break;    }  }  if (pivot0 != -1) {    for (j = pivot0 + 1; j &lt; 3; j++) {      if (luDecomp-&gt;value[1][j] != 0.0) {        pivot1 = j;        break;      }    }  }  if (pivot0 == -1 || pivot1 == -1) {    /* Two nonzero pivots not found */    return kQ3Failure;  }  /*   *  Points are represented as row vectors, and they are transformed as   *  follows:  p M = q   *  where M is a homogeneous matrix, and p and q are row vectors.   *  If M is the local-to-world matrix and A is the upper-left 3x3 submatrix   *  of M, then q is in the row space of A (in the absence of translation   *  and assuming that M is affine).  Given a factorization of A as   *  PA = LU, a basis for the row space of A is the basis of U.  Since   *  the rank of A is 2, the first two rows are a basis for U.  The space   *  spanned by these two rows is the plane in WC onto which all 3D geometry    *  in LC is transformed.  The cross product of the two rows is the normal   *  of the plane.  Also note: the nullspace of A is orthogonal to the row    *  space: this one dimensional space is spanned by the normal of the plane   *  in WC.   */  Q3Vector3D_Set(    &amp;v0,     luDecomp-&gt;value[0][0],     luDecomp-&gt;value[0][1],     luDecomp-&gt;value[0][2]);  Q3Vector3D_Set(&amp;v1, 0.0, luDecomp-&gt;value[1][1], luDecomp-&gt;value[1][2]);  Q3Vector3D_Cross(&amp;v0, &amp;v1, &amp;v2);  Q3Vector3D_Normalize(&amp;v2, &amp;flatWorld-&gt;normal);    /*   *  A point on the plane in world coordinates (WC) is given by transforming   *  any point in local coordinates (LC) to WC.  If (0, 0, 0, 1) is the   *  LC point, the WC point is simply the last row of matrix M.  Substitute   *  this into the plane equation to obtain the constant D = - Ax - By - Cz.   */  flatWorld-&gt;constant = - matrix-&gt;value[3][0] * flatWorld-&gt;normal.x              - matrix-&gt;value[3][1] * flatWorld-&gt;normal.y              - matrix-&gt;value[3][2] * flatWorld-&gt;normal.z;    /*   *  Each point in the column space of A has a one-to-one mapping to a point   *  in the row space of A.  In WC, the eye is on one side of the plane or   *  the other.  For the purposes of culling, it makes sense to put the eye   *  in LC on the same side of the plane.  So the eye vector in LC should be   *  orthogonal to the column space of A.  Otherwise, it would be in the    *  column space, which doesn't make sense since the eye is almost never    *  in the row space in WC.  A basis for the column space consists of the    *  columns in A corresponding to those in U with nonzero pivots.   */  Q3Vector3D_Set(    &amp;v0,     matrix-&gt;value[0][pivot0],    matrix-&gt;value[1][pivot0],     matrix-&gt;value[2][pivot0]);  Q3Vector3D_Set(    &amp;v1,     matrix-&gt;value[0][pivot1],     matrix-&gt;value[1][pivot1],     matrix-&gt;value[2][pivot1]);  Q3Vector3D_Cross(&amp;v0, &amp;v1, &amp;v2);  Q3Vector3D_Normalize(&amp;v2, &amp;v2);  SRVector3D_To4D(&amp;v2, eyeVectorLC);    /*   *  We are almost done.  However, the sense of the eye vector in LC and   *  the normal of the plane equation in WC still need to be established.   *  The latter needs to point in the same hemisphere as the eye.   */  if (parallelProjection) {      /* Parallel projection */        SRVector4D_To3D(eyeVectorWC, &amp;v2);    if (Q3Vector3D_Dot(&amp;flatWorld-&gt;normal, &amp;v2) &lt; 0.0) {      /*       *  WC eye vector and plane normal point in opposite directions.       *  Need to reverse the sense of the plane equation.       */      Q3Vector3D_Negate(&amp;flatWorld-&gt;normal, &amp;flatWorld-&gt;normal);      flatWorld-&gt;constant = -flatWorld-&gt;constant;    }  } else {    TQ3Point3D  p0;    TQ3Point3D  p1;        /*  Perspective projection */        /*     *  A WC eye vector can be obtained by subtracting the eye point     *  by a point on the plane.  The LC point (0, 0, 0, 1) transformed     *  to WC is the last row of M.     */    Q3RationalPoint4D_To3D(eyePointWC, &amp;p0);    Q3Point3D_Set(      &amp;p1,       matrix-&gt;value[3][0],       matrix-&gt;value[3][1],       matrix-&gt;value[3][2]);    Q3Point3D_Subtract(&amp;p0, &amp;p1, &amp;v2);    if (Q3Vector3D_Dot(&amp;flatWorld-&gt;normal, &amp;v2) &lt; 0.0) {      /*       *  WC eye vector and plane normal point in opposite directions.       *  Need to reverse the sense of the plane equation.       */      Q3Vector3D_Negate(&amp;flatWorld-&gt;normal, &amp;flatWorld-&gt;normal);      flatWorld-&gt;constant = -flatWorld-&gt;constant;    }  }    /*   * The hard part to comprehend is the method for establishing the sense    * of the eye vector in LC.  We had computed the eye vector by taking   * the cross product of v0 and v1, the two basis vectors for the column    * space.  This gave a right-handed normal vector for the two basis    * vectors.  If v0 and v1 are transformed by A, the two new vectors   * (v0 A) and (v1 A) lie in the row space, which is a plane parallel   * to the plane to which all geometry is transformed in WC.  The   * cross product of (v0 A) and (v1 A) either has the same or opposite   * sense as the normal to the plane, which points in the same hemisphere   * as the eye in WC.  If it is opposite, then the eye vector in LC has   * the opposite sense to the existing orientation.   */  Q3Vector3D_Transform(&amp;v0, matrix, &amp;v0);  Q3Vector3D_Transform(&amp;v1, matrix, &amp;v1);  Q3Vector3D_Cross(&amp;v0, &amp;v1, &amp;v2);  if (Q3Vector3D_Dot(&amp;flatWorld-&gt;normal, &amp;v2) &lt; 0.0) {    /*     * The LC eye vector transformed into WC and plane normal point in      * opposite directions.  Need to reverse the sense of the LC eye     * vector.     */    SRVector4D_Negate(eyeVectorLC, eyeVectorLC);  }    return kQ3Success;}/*===========================================================================*\ * *  Routine:  SRVector4D_Set() * *  Comments:  Set a 4D vector *\*===========================================================================*/TSRVector4D *SRVector4D_Set(  TSRVector4D    *vector4D,  float      x,   float      y,  float      z,   float      w){  assert(vector4D != NULL);    vector4D-&gt;x = x;  vector4D-&gt;y = y;  vector4D-&gt;z = z;  vector4D-&gt;w = w;    return (vector4D);}/*===========================================================================*\ * *  Routine:  SRVector3D_To4D() * *  Comments:  Promote a 3D vector to 4D *\*===========================================================================*/TSRVector4D *SRVector3D_To4D(  const TQ3Vector3D  *vector3D,  TSRVector4D      *result){  assert(vector3D != NULL);  assert(result != NULL);    result-&gt;x = vector3D-&gt;x;  result-&gt;y = vector3D-&gt;y;  result-&gt;z = vector3D-&gt;z;  result-&gt;w = 1.0;    return (result);}/*===========================================================================*\ * *  Routine:  SRVector4D_To3D() * *  Comments:  Homogenize a 4D vector down to 3D *\*===========================================================================*/TQ3Vector3D *SRVector4D_To3D(  const TSRVector4D  *vector4D,  TQ3Vector3D      *result){  float oneOverW;    assert(vector4D != NULL);  assert(result != NULL);    oneOverW = 1.0 / vector4D-&gt;w;    result-&gt;x = vector4D-&gt;x * oneOverW;  result-&gt;y = vector4D-&gt;y * oneOverW;  result-&gt;z = vector4D-&gt;z * oneOverW;  return (result);}/*===========================================================================*\ * *  Routine:  SRVector4D_Negate() * *  Comments:  Negate a 4D vector *\*===========================================================================*/TSRVector4D *SRVector4D_Negate(  const TSRVector4D  *vector4D,  TSRVector4D      *result){  assert(vector4D != NULL);  assert(result != NULL);  result-&gt;x = -vector4D-&gt;x;  result-&gt;y = -vector4D-&gt;y;  result-&gt;z = -vector4D-&gt;z;  result-&gt;w = -vector4D-&gt;w;    return (result);}/*===========================================================================*\ * *  Routine:  SRVector4D_Normalize() * *  Comments:  Normalize a 4D vector *\*===========================================================================*/TSRVector4D *SRVector4D_Normalize(  const TSRVector4D  *vector4D,  TSRVector4D      *result){  float  length, oneOverLength;    assert(vector4D != NULL);  assert(result != NULL);  length = sqrt(vector4D-&gt;x * vector4D-&gt;x +             vector4D-&gt;y * vector4D-&gt;y +               vector4D-&gt;z * vector4D-&gt;z +                 vector4D-&gt;w * vector4D-&gt;w);    /*     *  Check for zero-length vector     */    if (length &lt; kQ3RealZero) {    *result = *vector4D;      return (NULL);  } else {    oneOverLength = 1.0 / length;      result-&gt;x = vector4D-&gt;x * oneOverLength;    result-&gt;y = vector4D-&gt;y * oneOverLength;    result-&gt;z = vector4D-&gt;z * oneOverLength;    result-&gt;w = vector4D-&gt;w * oneOverLength;  }    return (result);}/*===========================================================================*\ * *  Routine:  SRVector4D_Transform() * *  Comments:  Transform a 4D vector by a matrix. *\*===========================================================================*/  TSRVector4D *SRVector4D_Transform(  const TSRVector4D  *vector4D,  const TQ3Matrix4x4  *matrix4x4,  TSRVector4D      *result){  TSRVector4D      s;  const TSRVector4D  *sPtr;    assert(vector4D != NULL);  assert(matrix4x4 != NULL);  assert(result != NULL);  /*   *  Check if caller is bashing the vector   */  if (vector4D == result) {    s = *vector4D;    sPtr = &amp;s;  } else {    sPtr = vector4D;  }      result-&gt;x = sPtr-&gt;x * matrix4x4-&gt;value[0][0] +         sPtr-&gt;y * matrix4x4-&gt;value[1][0] +        sPtr-&gt;z * matrix4x4-&gt;value[2][0] +        sPtr-&gt;w * matrix4x4-&gt;value[3][0];          result-&gt;y = sPtr-&gt;x * matrix4x4-&gt;value[0][1] +        sPtr-&gt;y * matrix4x4-&gt;value[1][1] +        sPtr-&gt;z * matrix4x4-&gt;value[2][1] +        sPtr-&gt;w * matrix4x4-&gt;value[3][1];          result-&gt;z = sPtr-&gt;x * matrix4x4-&gt;value[0][2] +         sPtr-&gt;y * matrix4x4-&gt;value[1][2] +        sPtr-&gt;z * matrix4x4-&gt;value[2][2] +        sPtr-&gt;w * matrix4x4-&gt;value[3][2];          result-&gt;w = sPtr-&gt;x * matrix4x4-&gt;value[0][3] +         sPtr-&gt;y * matrix4x4-&gt;value[1][3] +        sPtr-&gt;z * matrix4x4-&gt;value[2][3] +        sPtr-&gt;w * matrix4x4-&gt;value[3][3];          return (result);}</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/Plug-in__-_Sample_Renderer/listing22.html%3Fid%3DDTS10000120-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/Plug-in__-_Sample_Renderer/listing22.html%3Fid%3DDTS10000120-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/Plug-in__-_Sample_Renderer/listing22.html%3Fid%3DDTS10000120-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>