<!-- Generated by Harlequin WebMaker 2.2.3 (30-Apr-1996)
Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->
<HTML> <HEAD>
<TITLE>Accessing a Resource-Based Profile With a Procedure</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING76></A>


<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->




<!-- Main Body -->

<CENTER>
<P>
<A HREF="ACI-75.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="ACI-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="ACI-122.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="ACI-77.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="ACI-2.html"><B>Advanced Color Imaging on the Mac OS</B></A> / <BR><DD><A HREF="ACI-55.html"><B>Chapter 4 - Developing ColorSync-Supportive Applications</B></A> / <A HREF="ACI-60.html"><B>Developing Your ColorSync-Supportive Application</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING76-0></A>
<H2><A NAME=MARKER-9-163></A>Accessing a Resource-Based Profile With a Procedure</H2>
 The ColorSync Manager provides for multiple concurrent accesses to a single profile through the use of a private data structure called a <I>profile reference</I>. When you call the <CODE>CMOpenProfile</CODE> function to open a profile or the <CODE>CMNewProfile</CODE>, <CODE>CWNewLinkProfile</CODE>, or <CODE>CMCopyProfile</CODE> functions to create or copy a profile, you pass a profile location and the function returns a profile reference. To specify the profile location, you use a structure of type <CODE>CMProfileLocation</CODE>, as described in <A HREF=ACI-64.html#MARKER-9-56>"Opening a Profile and Obtaining a Reference to It" (page 4-17)</A>.<P>
 A ColorSync profile that you open or create is typically stored in one of the following locations:<P>
<UL>
<LI>In a disk file. The <CODE>u</CODE> field (a union) of the <CODE>CMProfileLocation</CODE> data structure contains a file specification for a profile that is disk-file based. This is the most common way to store a ColorSync profile.
<LI>In relocatable memory. The <CODE>u</CODE> field of the profile location data structure contains a handle specification for a profile that is stored in a handle.
<LI>In nonrelocatable memory. The <CODE>u</CODE> field of the profile location data structure contains a pointer specification for a profile that is pointer based.
<LI>In an arbitrary location accessed by a procedure you provide. The <CODE>u</CODE> field of the profile location data structure contains a universal procedure pointer to your access procedure, as well a pointer that may point to data associated with your procedure.<P>
</UL>
 The sample code in <A HREF=#MARKER-9-165>Listing 4-12</A> to <A HREF=#MARKER-9-177>Listing 4-23</A> demonstrates how to use a profile access procedure to provide access to a resource-based profile.<P>
<DL>
<DT><B>Note</B>
<DD>While the following sample code includes some error handling, more complete error handling is left as an exercise for the reader.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
<A NAME=HEADING76-9></A>
<H3><A NAME=MARKER-9-164></A>Defining a Data Structure for a Resource-Based Profile</H3>
 The sample code listings that follow use the application-defined MyResourceLocRec data structure. It stores information to describe a resource-based profile, including<P>
<UL>
<LI>the resource file specification
<LI>the resource type
<LI>the resource ID
<LI>the resource file reference
<LI>the resource handle
<LI>the profile access procedure pointer
<LI>the resource name<P>
</UL>
<PRE>
struct MyResourceLocRec {
   FSSpec         resFileSpec;
   ResType        resType;
   short          resID;
   short          resFileRef;
   Handle         resHandle;
   CMProfileAccessUPPproc;
   Str255         resName;
};
   
typedef struct MyResourceLocRec MyResourceLocRec, *MyResourceLocPtr;
</PRE>
 The ColorSync Manager defines the CMProfileAccessUPP type as follows:<P>
<PRE>
typedef UniversalProcPtr CMProfileAccessUPP;
</PRE>
<A NAME=HEADING76-21></A>
<H3>Setting Up a Location Structure for Procedure Access to a Resource-Based Profile</H3>
 The MyCreateProcedureProfileAccess routine shown in <A HREF=#MARKER-9-165>Listing 4-12</A> sets up a CMProfileLocation structure for procedure access to a resource-based profile. The MyDisposeProcedureProfileAccess routine, shown in <A HREF=#MARKER-9-166>Listing 4-13</A>, disposes of memory allocated by MyCreateProcedureProfileAccess. Your application uses these routines (or similar ones that you write) in the following way:<P>
<OL>
<LI>Before calling a ColorSync routine such as <CODE>CMCopyProfile</CODE>, you call the MyCreateProcedureProfileAccess routine to set up a CMProfileLocation structure that you can pass to the ColorSync routine. The location structure specifies your profile-access procedure and may provide other information as well. A sample profile-access procedure is shown in <A HREF=#MARKER-9-167>Listing 4-14</A>.
<LI>During the course of its operations, ColorSync may call your profile-access procedure many times.
<LI>After the ColorSync routine has completed its operation, and if your application does not need to use the CMProfileLocation structure for another operation, you call the MyDisposeProcedureProfileAccess routine to dispose of memory allocated by MyCreateProcedureProfileAccess.<P>
</OL>
 For the sample MyCreateProcedureProfileAccess routine shown in <A HREF=#MARKER-9-165>Listing 4-12</A>, you pass a pointer to a CMProfileLocation structure to fill in, a pointer to a file specification for the resource file containing the profile resource, the type of the resource, the ID for the resource, and optionally the name of the resource (stored as a Pascal string, where the first byte is a length byte for the string).<P>
<DL>
<DT><B>Note</B>
<DD><A HREF=#MARKER-9-165>Listing 4-12</A> assumes the profile access routine, MyCMProfileAccessProc, is within the scope of the MyCreateProcedureProfileAccess routine. Optionally, you could add a parameter to pass in a procedure pointer for the profile access routine.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
<B>Listing 4-12  <A NAME=MARKER-9-165></A>Setting up a location structure for procedure access to a resource-based profile</B><P>
<PRE>
OSErr MyCreateProcedureProfileAccess (
                           CMProfileLocation *profileLocation,
                           FSSpec *resourceSpec,
                           Str255 resourceName,
                           OSType resourceType,
                           short resourceID)
{
   OSErr          err = noErr;
   MyResourceLocPtrresourceInfo;
   
   /* allocate memory for our private resource info structure */
   resourceInfo = (MyResourceLocPtr) NewPtrClear(sizeof(MyResourceLocRec));
   if (!resourceInfo)
      err = MemError();
      
   if (!err)
   {
      /* set up our private resource info structure */
      resourceInfo-&gt;resFileSpec = *resourceSpec;
      resourceInfo-&gt;resType = resourceType;
      resourceInfo-&gt;resID = resourceID;
      resourceInfo-&gt;resFileRef = 0;
      resourceInfo-&gt;resHandle = 0;
      resourceInfo-&gt;proc = NewCMProfileAccessProc(MyCMProfileAccessProc);
      /* if a resource name was passed in, copy it to the structure;
         since it's a Pascal string, first byte is length;
         note that BlockMoveData is faster than BlockMove for a
         move that involves data only */
      if (resourceName)
         BlockMoveData(resourceName, resourceInfo-&gt;resName,
                     resourceName[0]);
      
      /* set up the profile location structure */
      profileLocation-&gt;locType = cmProcedureBasedProfile;
      profileLocation-&gt;u.procLoc.refCon = (void*) resourceInfo;
      profileLocation-&gt;u.procLoc.proc = resourceInfo-&gt;proc;
   }
   return err;
}
</PRE>
 If the MyCreateProcedureProfileAccess routine is able to set up the profile location pointer for procedure access to a resource-based profile, it returns a value of <CODE>noErr</CODE>.<P>
<A NAME=HEADING76-31></A>
<H3>Disposing of a Resource-Based Profile Access Structure</H3>
 Your application calls the MyDisposeProcedureProfileAccess routine, shown in <A HREF=#MARKER-9-166>Listing 4-13</A>, to dispose of any memory allocated by the MyCreateProcedureProfileAccess routine, shown in <A HREF=#MARKER-9-165>Listing 4-12</A>.<P>
<B>Listing 4-13  <A NAME=MARKER-9-166></A>Disposing of a resource-based profile access structure</B><P>
<PRE>
void MyDisposeProcedureProfileAccess (CMProfileLocation *profileLocation)
{
   DisposeRoutineDescriptor(profileLocation-&gt;u.procLoc.proc);

   /* dispose of our private resource info structure */
   DisposePtr((Ptr)profileLocation-&gt;u.procLoc.refCon);
}
</PRE>
 This routine first disposes of the universal procedure pointer to your profile access procedure, then disposes of the pointer used to store resource data in a MyResourceLocRec structure.<P>
<A NAME=HEADING76-36></A>
<H3>Responding to a Procedure-Based Profile Command</H3>
 For the procedure declaration for a profile access procedure, see MyCMProfileAccessProc <A HREF=#nonexistent-marker>(page 3-172)</A> in <I>Advanced Color Imaging Reference</I>. The ColorSync Manager calls your procedure when the profile is created, initialized, opened, read, updated, or closed, passing a command constant that specifies the current command. Your profile access procedure must be able to respond to each of the following command constants (described in <A HREF=#nonexistent-marker>"Profile Access Procedure Operation Codes"</A> in <I>Advanced Color Imaging Reference</I>):<P>
<PRE>
enum {
   cmOpenReadAccess= 1,
   cmOpenWriteAccess= 2,
   cmReadAccess   = 3,
   cmWriteAccess  = 4,
   cmCloseAccess  = 5,
   cmCreateNewAccess= 6,
   cmAbortWriteAccess= 7,
   cmBeginAccess  = 8,
   cmEndAccess    = 9
};
</PRE>
 The profile access procedure shown in <A HREF=#MARKER-9-167>Listing 4-14</A>, <CODE>MyCMProfileAccessProc</CODE>, consists of a single switch statement, which calls the appropriate routine based on the value of the <CODE>command</CODE> parameter. Each of the nine routines called by <CODE>MyCMProfileAccessProc</CODE> is described and listed in the sections that follow <A HREF=#MARKER-9-167>Listing 4-14</A>, and each refers back to <A HREF=#MARKER-9-167>Listing 4-14</A>.<P>
<B>Listing 4-14  <A NAME=MARKER-9-167></A>Responding to a procedure-based profile command</B><P>
<PRE>
pascal OSErr MyCMProfileAccessProc (long command,
                           long offset,
                           long *sizePtr,
                           void *dataPtr,
                           void *refConPtr)
{
   OSErr err = noErr;
   switch (command)
   {
      case cmBeginAccess:
         err = DoBeginAccess(refConPtr);
         break;
         
      case cmCreateNewAccess:
         err = DoCreateNewAccess(refConPtr);
         break;
      
      case cmOpenReadAccess:
         err = DoOpenReadAccess(refConPtr);
         break;
      
      case cmOpenWriteAccess:
         err = DoOpenWriteAccess(sizePtr, refConPtr);
         break;
         
      case cmReadAccess:
         err = DoReadAccess(offset, sizePtr, dataPtr, refConPtr);
         break;
         
      case cmWriteAccess:
         err = DoWriteAccess(offset, sizePtr, dataPtr, refConPtr);
         break;
      
      case cmCloseAccess:
         err = DoCloseAccess(refConPtr);
         break;
      
      case cmAbortWriteAccess:
         err = DoAbortWriteAccess(refConPtr);
         break;
      
      case cmEndAccess:
         err = DoEndAccess(refConPtr);
         break;
      
      default:
         err = paramErr;
         break;
   }

   return err;
}
</PRE>
 The MyCMProfileAccessProc routine passes its parameter data as necessary to the routines it calls. The parameters have the following values:<P>
<DL>
<DT>command
<DD> A command value indicating the operation to perform. The possible values for command constants are shown elsewhere in this section.
<DT>offset
<DD> For read and write operations, the offset from the beginning of the profile at which to read or write data.
<DT>size
<DD> For the cmReadAccess and cmWriteAccess command constants, a pointer to a value indicating the number of bytes to read or write; for the cmOpenWriteAccess command, the total size of the profile. On output after reading or writing, the actual number of bytes read or written.
<DT>data
<DD> A pointer to a buffer containing data to read or write. On output, for a read operation, contains the data that was read.
<DT>refConPtr
<DD> A reference constant pointer that can store private data for the MyCMProfileAccessProc procedure. For example, <A HREF=#MARKER-9-165>Listing 4-12</A> shows how to set up a location structure for procedure access to a resource-based profile. That routine sets the location structure's refCon field to a pointer to a MyResourceLocRec structure <A HREF=#MARKER-9-164>(page 4-58)</A>. That same structure pointer is passed to the MyCMProfileAccessProc routine in the refConPtr parameter and provides access to all the stored information about the resource location.
</DL>
<A NAME=HEADING76-48></A>
<H3><A NAME=MARKER-9-168></A>Handling the Begin Access Command</H3>
 When the ColorSync Manager needs to signal that it is time to prepare for a session of reading, writing, or both for a procedure-based profile, it invokes the specified profile access procedure with the cmBeginAccess command. This happens, for example, when your application calls the <CODE>CMOpenProfile</CODE> routine, specifying as a location a procedure-based profile.<P>
 When your profile-access procedure is called with the cmBeginAccess command, it performs any required initialization or validation tasks, such as determining whether the data pointed to by the <CODE>refcon</CODE> parameter is valid. If your procedure returns an error (any value except <CODE>noErr</CODE>), the ColorSync Manager will not call your profile access procedure again.<P>
 For the cmBeginAccess command, the sample profile access procedure shown in <A HREF=#MARKER-9-167>Listing 4-14</A> calls the DoBeginAccess routine, shown in <A HREF=#MARKER-9-169>Listing 4-15</A>. DoBeginAccess interprets the <CODE>refcon</CODE> parameter as a MyResourceLocPtr type. If the parameter does not have a resource type of kProcResourceType, DoBeginAccess returns an invalid profile error, which effectively cancels the procedure-based profile access.<P>
<B>Listing 4-15  <A NAME=MARKER-9-169></A>Handling the begin access command</B><P>
<PRE>
static OSErr DoBeginAccess (void *refcon)
{
   OSErr          err;
   MyResourceLocPtrresourceInfo = refcon;
   
   resourceInfo-&gt;resFileRef = 0;

   if (resourceInfo-&gt;resType != kProcResourceType)
      err = cmInvalidProfileLocation;
   else
      err = noErr;
   
   return err;
}
</PRE>
<A NAME=HEADING76-54></A>
<H3>Handling the Create New Access Command</H3>
 When the ColorSync Manager needs to signal that it is time to allocate any required new resources for a procedure-based profile, it invokes the specified profile access procedure with the cmBeginAccess command, as described in <A HREF=#MARKER-9-168>"Handling the Begin Access Command" (page 4-64)</A>. This happens, for example, when your application calls the <CODE>CMCopyProfile</CODE> routine, specifying as a location a procedure-based profile.<P>
 If your profile access procedure returns without error, ColorSync calls the procedure again with the cmCreateNewAccess command. Your procedure then creates a new data stream for the actual physical location of the profile. The size of the profile is not known at this point.<P>
 For the cmCreateNewAccess command, the sample profile access procedure shown in <A HREF=#MARKER-9-167>Listing 4-14</A> calls the DoCreateNewAccess routine. DoCreateNewAccess interprets the <CODE>refcon</CODE> parameter as a MyResourceLocPtr type and calls the Toolbox routine FSpCreateResFile to create an empty resource fork based on the file specification provided by the MyResourceLocPtr type. If the resource fork does not already exist and cannot be created, DoCreateNewAccess returns an error.<P>
 For this example, the file type for a resource-based profile was chosen arbitrarily to be <CODE>'rprf'</CODE>.<P>
<B>Listing 4-16  Handling the create new access command</B><P>
<PRE>
OSErr DoCreateNewAccess (void *refcon)
{
   OSErr          err;
   MyResourceLocPtrresourceInfo = refcon;
   
   FSpCreateResFile(&amp;(resourceInfo-&gt;resFileSpec), '????', 'rprf', 0);
   err = ResError();
   if (err == dupFNErr)
      err = noErr;
      
   return err;
}
</PRE>
<A NAME=HEADING76-61></A>
<H3><A NAME=MARKER-9-170></A>Handling the Open Read Access Command</H3>
 When your application calls a ColorSync routine to read information from a procedure-based profile, the ColorSync Manager first calls your profile access procedure with the cmOpenReadAccess command. ColorSync calls your profile access routine once for each read session. The sample profile access procedure shown in <A HREF=#MARKER-9-167>Listing 4-14</A> calls the DoOpenReadAccess routine.<P>
 The DoOpenReadAccess routine shown in <A HREF=#MARKER-9-171>Listing 4-17</A> uses information from the refcon parameter, interpreted as type MyResourceLocPtr, to open the resource fork for the resource-based profile with read permission. If it can open the resource file, DoOpenReadAccess then attempts to load the profile resource.<P>
 The DoOpenReadAccess routine shows good citizenship by saving the current resource file before performing its operations and restoring the resource file afterward.<P>
<B>Listing 4-17  <A NAME=MARKER-9-171></A>Handling the open read access command</B><P>
<PRE>
static OSErr DoOpenReadAccess (void *refcon)
{
   OSErr          err;
   MyResourceLocPtrresourceInfo = refcon;
   short          currentResFile;
   
   /* save current resource file */
   currentResFile = CurResFile();
   
   /* open the file's resource fork */
   resourceInfo-&gt;resFileRef = FSpOpenResFile(&amp;(resourceInfo-&gt;resFileSpec), fsRdPerm);
   err = ResError();
   
   /* get the resource handle, but don't force it to be loaded into memory */
   if (!err)
   {
      SetResLoad(false);
      resourceInfo-&gt;resHandle = GetResource(resourceInfo-&gt;resType,
                                    resourceInfo-&gt;resID);
      err = ResError();
      SetResLoad(true);
   }

   /* restore previous resource file */
   UseResFile(currentResFile);
   
   return err;
}
</PRE>
<A NAME=HEADING76-67></A>
<H3>Handling the Open Write Access Command</H3>
 When the ColorSync Manager needs to signal that a procedure-based profile should be opened for writing, it invokes the specified profile access procedure with the cmOpenWriteAccess command. This happens, for example, when your application calls the <CODE>CMUpdateProfile</CODE> routine to update a procedure-based profile. The sample profile access procedure shown in <A HREF=#MARKER-9-167>Listing 4-14</A> calls the DoOpenWriteAccess routine.<P>
 The DoOpenWriteAccess routine shown in <A HREF=#MARKER-9-172>Listing 4-18</A> uses information from the refcon parameter, interpreted as type MyResourceLocPtr, to open the resource fork for the resource-based profile with read/write permission. If it can open the resource file, DoOpenWriteAccess then attempts to open the specified profile resource. If it can't open the resource, DoOpenWriteAccess creates a new resource. It then sets the size of the resource based on the passed setProfileSize pointer value and updates the resource file.<P>
 The DoOpenWriteAccess routine shows good citizenship by saving the current resource file before performing its operations and restoring the resource file afterward.<P>
<DL>
<DT><B>Note</B>
<DD>If the cmOpenWriteAccess command succeeds, ColorSync guarantees an eventual call to the profile access procedure with the cmCloseAccess command, possibly after multiple cmWriteAccess commands, and possibly after a cmAbortWriteAccess command.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
<B>Listing 4-18  <A NAME=MARKER-9-172></A>Handling the open write access command</B><P>
<PRE>
static OSErr DoOpenWriteAccess (long *setProfileSize, void *refcon) 
{
   OSErr          err;
   MyResourceLocPtrresourceInfo = refcon;
   Size           resourceSize;
   short          currentResFile;
   
   /* save current resource file */
   currentResFile = CurResFile();

   /* open the file's resource fork */
   resourceInfo-&gt;resFileRef = FSpOpenResFile(&amp;(resourceInfo-&gt;resFileSpec),
                                    fsRdWrPerm);
   err = ResError();
   
   /* get the resource handle, but don't force it to be loaded into memory */
   if (!err)
   {
      SetResLoad(false);
      resourceInfo-&gt;resHandle = GetResource(resourceInfo-&gt;resType,
                                    resourceInfo-&gt;resID);
      err = ResError();
      SetResLoad(true);
   }
   
   /* call GetResourceSizeOnDisk to see if resource is already there */
   if (!err)
   {
      /* get size of the resource */
      resourceSize = GetResourceSizeOnDisk(resourceInfo-&gt;resHandle);
      err = ResError();
   }
   
   /* if the above call to GetResourceSizeOnDisk returns resNotFound, */
   /* then we need to create a new resource */
   if (err == resNotFound)
   {
      /* allocate a temporary handle just so that we can call AddResource */
      resourceInfo-&gt;resHandle = NewHandle(sizeof(long));
      err = MemError();
      
      /* add resource to the file and release the temp handle */
      if (!err)
      {
         AddResource(resourceInfo-&gt;resHandle, resourceInfo-&gt;resType, 
                   resourceInfo-&gt;resID, resourceInfo-&gt;resName);
         err = ResError();
         ReleaseResource(resourceInfo-&gt;resHandle);
      }
      
   /* get the resource handle, but don't force it to be loaded into memory */
      if (!err)
      {
         SetResLoad(false);
         resourceInfo-&gt;resHandle = GetResource(resourceInfo-&gt;resType,
                                       resourceInfo-&gt;resID);
         err = ResError();
         SetResLoad(true);
      }
   }

   /* change the resource size to fit the profile */
   if (!err)
   {
      SetResourceSize(resourceInfo-&gt;resHandle, *setProfileSize);
      err = ResError();
   }
   
   /* force an update of the resource file */
   if (!err)
   {
      UpdateResFile(resourceInfo-&gt;resFileRef);
      err = ResError();
   }
   
   /* restore previous resource file */
   UseResFile(currentResFile);
   
   return err;
}
</PRE>
<A NAME=HEADING76-74></A>
<H3>Handling the Read Access Command</H3>
 When your application calls a ColorSync routine to read information from a procedure-based profile, the ColorSync Manager first calls your profile access procedure with the cmOpenReadAccess command, as described in <A HREF=#MARKER-9-170>"Handling the Open Read Access Command" (page 4-66)</A>. Your profile access routine can be called with the cmReadAccess command at any time after the cmOpenReadAccess command is called. When the sample profile access procedure shown in <A HREF=#MARKER-9-167>Listing 4-14</A> receives the cmReadAccess command, it calls the DoReadAccess routine.<P>
 The DoReadAccess routine shown in <A HREF=#MARKER-9-173>Listing 4-19</A> uses the refcon parameter, interpreted as type MyResourceLocPtr, to get a resource handle for the resource-based profile. From other parameters, it gets values for the offset at which to start reading, the number of bytes to read, and a pointer to a buffer in which to store the data that it reads. It then calls the Toolbox routine ReadPartialResource to do the actual reading.<P>
 If an error occurs while reading, DoReadAccess returns the error.<P>
<B>Listing 4-19  <A NAME=MARKER-9-173></A>Handling the read access command</B><P>
<PRE>
static OSErr DoReadAccess ( long offset,
                     long *sizePtr,
                     void *dataPtr,
                     void *refcon)
{
   OSErr          err;
   MyResourceLocPtrresourceInfo = refcon;

   ReadPartialResource(resourceInfo-&gt;resHandle,
                     offset, dataPtr, *sizePtr);
   err = ResError();
   
   return err;
}
</PRE>
<A NAME=HEADING76-80></A>
<H3>Handling the Write Access Command</H3>
 When your application calls a ColorSync routine that writes information to a procedure-based profile, the ColorSync Manager first calls your profile access procedure with the cmOpenWriteAccess command. The DoOpenWriteAccess routine shown in <A HREF=#MARKER-9-172>Listing 4-18</A> performs certain operations to prepare to write a resource-based profile.<P>
 Your profile access routine can be called with the cmWriteAccess command at any time after the cmOpenWriteAccess command is called. When the sample profile access procedure shown in <A HREF=#MARKER-9-167>Listing 4-14</A> receives the cmWriteAccess command, it calls the DoWriteAccess routine.<P>
 The DoWriteAccess routine shown in <A HREF=#MARKER-9-174>Listing 4-20</A> uses the refcon parameter, interpreted as type MyResourceLocPtr, to get a resource handle for the resource-based profile. From other parameters, it gets values for the offset at which to start writing, the number of bytes to write, and a pointer to a buffer from which to get the data that it writes. It then calls the Toolbox routine WritePartialResource to do the actual writing.<P>
 If an error occurs while writing, DoWriteAccess returns the error.<P>
<DL>
<DT><B>Note</B>
<DD>After ColorSync calls the profile access procedure with the cmWriteAccess command, ColorSync is guaranteed to eventually call the profile access procedure with the cmCloseAccess command--possibly after additional calls with the cmWriteAccess command, and possibly after a call with the cmAbortWriteAccess command.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
<B>Listing 4-20  <A NAME=MARKER-9-174></A>Handling the write access command</B><P>
<PRE>
static OSErr DoWriteAccess (long offset,
                     long *sizePtr,
                     void *dataPtr,
                     void *refcon)
{
   OSErr          err;
   MyResourceLocPtrresourceInfo = refcon;
   
   WritePartialResource(resourceInfo-&gt;resHandle,
                     offset, dataPtr, *sizePtr);
   err = ResError();

   return err;
}
</PRE>
<A NAME=HEADING76-88></A>
<H3>Handling the Close Access Command</H3>
 The ColorSync Manager calls your profile access procedure with the cmCloseAccess command to indicate that reading or writing is finished for the moment. A cmCloseAccess command can be followed by a cmOpenReadAccess command to begin reading again, a cmOpenWriteAccess command to begin writing again, or a cmEndAccess command to terminate the procedure-based profile access.<P>
 The sample profile access procedure shown in <A HREF=#MARKER-9-167>Listing 4-14</A> calls the DoCloseAccess routine.<P>
 The DoCloseAccess routine shown in <A HREF=#MARKER-9-175>Listing 4-21</A> uses information from the refcon parameter, interpreted as type MyResourceLocPtr, to close and update the resource file for the resource-based profile. If DoCloseAccess is unsuccessful, it returns an error value.<P>
<B>Listing 4-21  <A NAME=MARKER-9-175></A>Handling the close access command</B><P>
<PRE>
static OSErr DoCloseAccess (void *refcon)
{
   OSErr          err;
   MyResourceLocPtrresourceInfo = refcon;
   
   /* close and update resource file */
   if (resourceInfo-&gt;resFileRef)
   {   
      CloseResFile(resourceInfo-&gt;resFileRef);
      err = ResError();
      resourceInfo-&gt;resFileRef = 0;
   }
   else err = paramErr;
   
   return err;
}
</PRE>
<A NAME=HEADING76-94></A>
<H3>Handling the Abort Write Access Command</H3>
 If an error occurs between a <CODE>cmOpenWriteAccess</CODE> command and a <CODE>cmCloseAccess</CODE> command, the ColorSync Manager calls your profile access procedure with the <CODE>cmAbortWriteAccess</CODE> command. This allows your access procedure to perform any cleanup necessary for the partially written profile.<P>
 For the <CODE>cmAbortWriteAccess</CODE> command, the sample profile access procedure shown in <A HREF=#MARKER-9-167>Listing 4-14</A> calls the DoAbortWriteAccess routine.<P>
 The DoAbortWriteAccess routine shown in <A HREF=#MARKER-9-176>Listing 4-22</A> uses information from the refcon parameter, interpreted as type MyResourceLocPtr, to call the Toolbox routine RemoveResource to delete the partially written resource. If DoAbortWriteAccess is unsuccessful, it returns an error value.<P>
<DL>
<DT><B>Note</B>
<DD>The ColorSync Manager will call your profile access procedure with the <CODE>cmCloseAccess</CODE> command after a <CODE>cmAbortWriteAccess</CODE> command.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
<B>Listing 4-22  <A NAME=MARKER-9-176></A>Handling the abort write access command</B><P>
<PRE>
static OSErr DoAbortWriteAccess (void *refcon)
{
   OSErr          err;
   MyResourceLocPtrresourceInfo = refcon;
   
   /* delete the resource that we started */
   if (resourceInfo-&gt;resHandle)
   {
      RemoveResource(resourceInfo-&gt;resHandle);
      err = ResError();
   }
   else err = paramErr;
   
   return err;
}
</PRE>
<A NAME=HEADING76-101></A>
<H3>Handling the End Access Command</H3>
 When access to a procedure-based profile is complete, the ColorSync Manager calls your profile access procedure with the <CODE>cmEndAccess</CODE> command. This allows your procedure to do any final cleanup, such as freeing memory allocated by the procedure.<P>
 For the <CODE>cmEndAccess</CODE> command, the sample profile access procedure shown in <A HREF=#MARKER-9-167>Listing 4-14</A> calls the DoEndAccess routine. Because there is no additional memory to free or other cleanup to take care of, the DoEndAccess routine shown in <A HREF=#MARKER-9-177>Listing 4-23</A> does nothing.<P>
<DL>
<DT><B>Note</B>
<DD>The MyCreateProcedureProfileAccess routine, shown in <A HREF=#MARKER-9-165>Listing 4-12</A>, <I>does</I> allocate memory, which is freed by a call to the MyDisposeProcedureProfileAccess routine, shown in <A HREF=#MARKER-9-166>Listing 4-13</A>. Your application calls the MyCreateProcedureProfileAccess routine before calling a ColorSync routine such as <CODE>CMCopyProfile</CODE> with a procedure-based profile. After the copy is complete, your application calls the MyDisposeProcedureProfileAccess routine to perform any necessary deallocation.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
<B>Listing 4-23  <A NAME=MARKER-9-177></A>Handling the end access command</B><P>
<PRE>
pascal OSErr DoEndAccess (void *refcon)
{
   OSErr err = noErr;
   
   return err;
}
</PRE>
</BLOCKQUOTE>
<HR>
<center>
<A HREF="ACI-75.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="ACI-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="ACI-122.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="ACI-77.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="ACI-3.html">&copy; Apple Computer, Inc.</A><br>13 NOV 1996<P>
<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->
</BODY>
</HTML> 
