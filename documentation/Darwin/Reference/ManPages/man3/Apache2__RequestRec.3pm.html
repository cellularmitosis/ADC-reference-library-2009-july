<html><head><title>Mac OS X
 Manual Page For Apache2::RequestRec(3pm)</title>
<style type="text/css"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { font-size: 1px; background: #ffffff; color: #ffffff; } --></style>
<style type="text/css" media="print, aural, braille, embossed, projection, tty"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { display: none; } --></style>
</head><body bgcolor="white">
<a name="//apple_ref/doc/man/3pm/Apache2::RequestRec" title="Mac OS X
 Manual Page for Apache2::RequestRec(3pm)"><a name="//apple_ref/doc/man/3/Apache2::RequestRec" title="Mac OS X
 Manual Page for Apache2::RequestRec(3pm)"><!-- headerDoc=man; indexgroup=Section 3pm; uid="//apple_ref/doc/man/3pm/Apache2::RequestRec"; name=Apache2::RequestRec(3pm) --></a>
<!--#include virtual="/includes/framesetheader"-->
<table width=600><tr><td scope="row">
<!-- begin breadcrumb insert request --><font face="Geneva,Helvetica,Arial" size="1">
 <a target="_top" href="http://developer.apple.com">ADC Home</a> <b>&gt;</b> <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> <b>&gt;</b> <a href="../../../../../reference/index.html#//apple_ref/doc/uid/TP30001281" target="_top">Reference</a> <b>&gt;</b> <!-- a href="" target="_top" -->Mac OS X<!-- /a --> <b>&gt;</b> <a href="../index.html#//apple_ref/doc/framework/manpages" target="_top">Mac OS X Man Pages</a></font>
<!-- end breadcrumb insert request -->
<p>&nbsp;</p>
</td></tr></table>
<!-- end of header -->
<table border="0"  cellpadding="2" cellspacing="2" width="630pt"><tr><td valign="top" height="12" colspan="5" scope="row">
<p style='text-align:justify;'>This document is a Mac OS X manual page.  Manual pages are a command-line technology
for providing documentation.  You can view these manual pages locally using the
<a href="../man1/man.1.html#//apple_ref/doc/man/1/man">man(1)</a> command.
These manual pages come from many different sources, and thus, have a variety of writing
styles.</p>
<p style='text-align:justify;'>For more information about the manual page format, see the manual page for 
<a href="../man5/manpages.5.html#//apple_ref/doc/man/5/manpages">manpages(5)</a>.</p>
</td></tr></table>
<hr />
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row"><pre class="manpages"><tt>
apache_mod_perl-101~38::mod_perl-2.<u></u><b><u>md_perl-10~38:</u></b><b></b><b><u>mod_p</u></b><b></b><b><u>r</u></b><b></b><b><u>l-2.0.</u></b>::docs::api::Apache2::RequestRec(3)



<b>NAME</b>
       Apache2::RequestRec - Perl API for Apache request record accessors

<b>Synopsis</b>
         use Apache2::RequestRec ();

         # set supported by the handler HTTP methods
         $allowed = $r-&gt;allowed();

         # auth type
         $auth_type = $r-&gt;ap_auth_type();

         # QUERY_STRING
         $args = $r-&gt;args();

         # non-parsed-headers handler
         $status = $r-&gt;assbackwards();

         # how many bytes were sent
         $bytes_sent = $r-&gt;bytes_sent();

         # client connection record
         $c = $r-&gt;connection();

         # "Content-Encoding" HTTP response header
         $r-&gt;content_encoding("gzip");

         # the languages of the content
         $languages = $r-&gt;content_languages();

         # "Content-Encoding" HTTP response header
         $r-&gt;content_type('text/plain');

         # special response headers table
         $err_headers_out = $r-&gt;err_headers_out();

         # request mapped filename
         $filename = $r-&gt;filename();

         # request finfo
         $finfo = $r-&gt;finfo();

         # 'SetHandler perl-script' equivalent
         $r-&gt;handler('perl-script');

         # was it a HEAD request?
         $status = $r-&gt;header_only();

         # request input headers table
         $headers_in = $r-&gt;headers_in();

         # request output headers table
         $headers_out = $r-&gt;headers_out();

         # hostname
         $hostname = $r-&gt;hostname();

         # input filters stack
         $input_filters = $r-&gt;input_filters();

         # get the main request obj in a sub-request
         $main_r = $r-&gt;main();

         # what's the current request (GET/POST/etc)?
         $method = $r-&gt;method();

         # what's the current method number?
         $methnum = $r-&gt;method_number();

         # current resource last modified time
         $mtime = $r-&gt;mtime();

         # next request object (in redirect)
         $next_r = $r-&gt;next();

         # there is no local copy
         $r-&gt;no_local_copy();

         # Apache ascii notes table
         $notes = $r-&gt;notes();

         # output filters stack
         $output_filters = $r-&gt;output_filters();

         # PATH_INFO
         $path_info = $r-&gt;path_info();

         # used in configuration directives modules
         $per_dir_config = $r-&gt;per_dir_config();

         # pool with life span of the current request
         $p = $r-&gt;pool();

         # previous request object in the internal redirect
         $prev_r = $r-&gt;prev();

         # connection level input filters stack
         $proto_input_filters = $r-&gt;proto_input_filters();

         # HTTP protocol version number
         $proto_num = $r-&gt;proto_num();

         # connection level output filters stack
         $proto_output_filters = $r-&gt;proto_output_filters();

         # the protocol, the client speaks: "HTTP/1.0", "HTTP/1.1", etc.
         $protocol = $r-&gt;protocol();

         # is it a proxy request
         $status = $r-&gt;proxyreq($val);

         # Time when the request started
         $request_time = $r-&gt;request_time();

         # server object
         $s = $r-&gt;server();

         # response status
         $status = $r-&gt;status();

         # response status line
         $status_line = $r-&gt;status_line();

         # manipulate %ENV of the subprocess
         $r-&gt;subprocess_env;
         $r-&gt;subprocess_env($key =&gt; $val);

         # first HTTP request header
         $request = $r-&gt;the_request();

         # the URI without any parsing performed
         $unparsed_uri = $r-&gt;unparsed_uri();

         # The path portion of the URI
         $uri = $r-&gt;uri();

         # auth username
         $user = $r-&gt;user();

<b>Description</b>
       "Apache2::RequestRec" provides the Perl API for Apache request_rec object.

       The following packages extend the "Apache2::RequestRec" functionality: "Apache2::Access",
       "Apache2::Log", "Apache2::RequestIO", "Apache2::RequestUtil", "Apache2::Response",
       "Apache2::SubRequest" and "Apache2::URI".

<b>API</b>
       "Apache2::RequestRec" provides the following functions and/or methods:

       <b>"allowed"</b>

       Get/set the allowed methods bitmask.

         $allowed      = $r-&gt;allowed();
         $prev_allowed = $r-&gt;allowed($new_allowed);

       obj: $r ( "Apache2::RequestRec object" )
       opt arg1: $new_allowed ( bitmask )
           Set the bitvector.

       ret: $allowed ( bitmask )
           returns $allowed, which is a bitvector of the allowed methods.

           If the $new_allowed argument is passed, the value before the change is returned.

       since: 2.0.00

       A handler must ensure that the request method is one that it is capable of handling.  Generally
       modules should "Apache2::DECLINE" any request methods they do not handle.  Prior to aborting the
       handler like this the handler should set "$r-&gt;allowed" to the list of methods that it is willing to
       handle.  This bitvector is used to construct the "Allow:" header required for "OPTIONS" requests, and
       "Apache2::Const::HTTP_METHOD_NOT_ALLOWED" (405) and "Apache2::Const::HTTP_NOT_IMPLEMENTED" (501)
       status codes.

       Since the default Apache handler deals with the "OPTIONS" method, all response handlers can usually
       decline to deal with "OPTIONS". For example if the response handler handles only "GET" and "POST"
       methods, and not "OPTIONS", it may want to say:

          use Apache2::Const -compile =&gt; qw(OK DECLINED M_GET M_POST M_OPTIONS);
          if ($r-&gt;method_number == Apache2::Const::M_OPTIONS) {
              $r-&gt;allowed($r-&gt;allowed | (1&lt;&lt;Apache2::Const::M_GET) | (1&lt;&lt;Apache2::Const::M_POST));
              return Apache2::Const::DECLINED;
          }

       "TRACE" is always allowed, modules don't need to set it explicitly.

       Since the default_handler will always handle a "GET", a module which does *not* implement "GET"
       should probably return "Apache2::Const::HTTP_METHOD_NOT_ALLOWED".  Unfortunately this means that a
       script "GET" handler can't be installed by mod_actions.

       For example, if the module can handle only POST method it could start with:

          use Apache2::Const -compile =&gt; qw(M_POST HTTP_METHOD_NOT_ALLOWED);
          unless ($r-&gt;method_number == Apache2::Const::M_POST) {
              $r-&gt;allowed($r-&gt;allowed | (1&lt;&lt;Apache2::Const::M_POST));
              return Apache2::Const::HTTP_METHOD_NOT_ALLOWED;
          }

       <b>"ap_auth_type"</b>

       If an authentication check was made, get or set the <u>ap</u><b>_</b><u>auth</u><b>_</b><u>type</u> slot in the request record

         $auth_type = $r-&gt;ap_auth_type();
         $r-&gt;ap_auth_type($newval);

       obj: $r ( "Apache2::RequestRec object" )
       opt arg1: $newval (string)
           If this argument is passed then a new auth type is assigned. For example:

             $r-&gt;auth_type('Basic');

       ret: $auth_type (string)
           If $newval is passed, nothing is returned. Otherwise the current auth type is returned.

       since: 2.0.00

       <u>ap</u><b>_</b><u>auth</u><b>_</b><u>type</u> holds the authentication type that has been negotiated between the client and server
       during the actual request.  Generally, <u>ap</u><b>_</b><u>auth</u><b>_</b><u>type</u> is populated automatically when you call
       "$r-&gt;get_basic_auth_pw" so you don't really need to worry too much about it, but if you want to roll
       your own authentication mechanism then you will have to populate <u>ap</u><b>_</b><u>auth</u><b>_</b><u>type</u> yourself.

       Note that "$r-&gt;ap_auth_type" was "$r-&gt;connection-&gt;auth_type" in the mod_perl 1.0 API.

       <b>"args"</b>

       Get/set the request QUERY string

         $args      = $r-&gt;args();
         $prev_args = $r-&gt;args($new_args);

       obj: $r ( "Apache2::RequestRec object" )
       opt arg1: $new_args ( string )
           Optinally set the new QUERY string

       ret: $args ( string )
           The current QUERY string

           If $new_args was passed, returns the value before the change.

       since: 2.0.00

       <b>"assbackwards"</b>

       When set to a true value, Apache won't send any HTTP response headers allowing you to send any
       headers.

         $status      = $r-&gt;assbackwards();
         $prev_status = $r-&gt;assbackwards($newval);

       obj: $r ( "Apache2::RequestRec object" )
       opt arg1: $newval (integer)
           assign a new state.

       ret: $status (integer)
           current state.

       since: 2.0.00

       If you send your own set of headers, which includes the "Keep-Alive" HTTP response header, you must
       make sure to increment the number of requests served over this connection (which is normally done by
       the core connection output filter "ap_http_header_filter", but skipped when "assbackwards" is
       enabled).

         $r-&gt;connection-&gt;keepalives($r-&gt;connection-&gt;keepalives + 1);

       otherwise code relying on the value of "$r-&gt;connection-&gt;keepalives" may malfunction. For example,
       this counter is used to tell when a new request is coming in over the same connection to a filter
       that wants to parse only HTTP headers (like "Apache2::Filter::HTTPHeadersFixup"). Of course you will
       need to set "$r-&gt;connection-&gt;keepalive(1)" ) as well.

       <b>"bytes_sent"</b>

       The number of bytes sent to the client, handy for logging, etc.

         $bytes_sent = $r-&gt;bytes_sent();

       obj: $r ( "Apache2::RequestRec object" )
       ret: $bytes_sent (integer)
       since: 2.0.00

       Though as of this writing in Apache 2.0 it doesn't really do what it did in Apache 1.3. It's just set
       to the size of the response body.  The issue is that buckets from one request may get buffered and
       not sent during the lifetime of the request, so it's not easy to give a truly accurate count of
       "bytes sent to the network for this response".

       <b>"connection"</b>

       Get the client connection record

         $c = $r-&gt;connection();

       obj: $r ( "Apache2::RequestRec object" )
       ret: $c ( "Apache2::Connection object" )
       since: 2.0.00

       <b>"content_encoding"</b>

       Get/set content encoding (the "Content-Encoding" HTTP header).  Content encodings are string like
       <u>"gzip"</u> or <u>"compress"</u>.

         $ce      = $r-&gt;content_encoding();
         $prev_ce = $r-&gt;content_encoding($new_ce);

       obj: $r ( "Apache2::RequestRec object" )
       opt arg1: $new_ce ( string )
           If passed, sets the content encoding to a new value. It must be a lowercased string.

       ret: $ce ( string )
           The current content encoding.

           If $new_ce is passed, then the previous value is returned.

       since: 2.0.00

       For example, here is how to send a gzip'ed response:

         require Compress::Zlib;
         $r-&gt;content_type("text/plain");
         $r-&gt;content_encoding("gzip");
         $r-&gt;print(Compress::Zlib::memGzip("some text to be gzipped));

       <b>"content_languages"</b>

       Get/set content languages (the "Content-Language" HTTP header).  Content languages are string like
       <u>"en"</u> or <u>"fr"</u>.

         $languages = $r-&gt;content_languages();
         $prev_lang = $r-&gt;content_languages($nev_lang);

       obj: $r ( "Apache2::RequestRec object" )
       opt arg1: $new_lang ( ARRAY ref )
           If passed, sets the content languages to new values. It must be an ARRAY reference of language
           names, like <u>"en"</u> or <u>"fr"</u>

       ret: $languages ( ARRAY ref )
           The current list of content languages, as an ARRAY reference.

           If $new_lang is passed, then the previous value is returned.

       since: 2.0.00

       <b>"content_type"</b>

       Get/set the HTTP response <u>Content-type</u> header value.

         my $content_type      = $r-&gt;content_type();
         my $prev_content_type = $r-&gt;content_type($new_content_type);

       obj: $r ( "Apache2::RequestRec object" )
       opt arg1: $new_content_type (MIME type string)
           Assign a new HTTP response content-type. It will affect the response only if HTTP headers weren't
           sent yet.

       ret: $content_type
           The current content-type value.

           If $new_content_type was passed, the previous value is returned instead.

       since: 2.0.00

       For example, set the "Content-type" header to <u>text/plain</u>.

         $r-&gt;content_type('text/plain');

       If you set this header via the "headers_out" table directly, it will be ignored by Apache. So do not
       do that.

       <b>"err_headers_out"</b>

       Get/set MIME response headers, printed even on errors and persist across internal redirects.

         $err_headers_out = $r-&gt;err_headers_out();

       obj: $r ( "Apache2::RequestRec object" )
       ret: $err_headers_out ( "APR::Table object" )
       since: 2.0.00

       The difference between "headers_out" and "err_headers_out", is that the latter are printed even on
       error, and persist across internal redirects (so the headers printed for "ErrorDocument" handlers
       will have them).

       For example, if a handler wants to return a 404 response, but nevertheless to set a cookie, it has to
       be:

         $r-&gt;err_headers_out-&gt;add('Set-Cookie' =&gt; $cookie);
         return Apache2::Const::NOT_FOUND;

       If the handler does:

         $r-&gt;headers_out-&gt;add('Set-Cookie' =&gt; $cookie);
         return Apache2::Const::NOT_FOUND;

       the "Set-Cookie" header won't be sent.

       <b>"filename"</b>

       Get/set the filename on disk corresponding to this response (the result of the <u>URI</u> <u>--&gt;</u> <u>filename</u>
       translation).

         $filename      = $r-&gt;filename();
         $prev_filename = $r-&gt;filename($new_filename);

       obj: $r ( "Apache2::RequestRec object" )
       opt arg1: $new_filename ( string )
           new value

       ret: $filename ( string )
           the current filename, or the previous value if the optional $new_filename argument was passed

       since: 2.0.00

       Note that if you change the filename after the "PerlMapToStorageHandler" phase was run and expect
       Apache to serve it, you need to update its "stat" record, like so:

         use Apache2::RequestRec ();
         use APR::Finfo ();
         use APR::Const -compile =&gt; qw(FINFO_NORM);
         $r-&gt;filename($newfile);
         $r-&gt;finfo(APR::Finfo::stat($newfile, APR::Const::FINFO_NORM, $r-&gt;pool));

       if you don't, Apache will still try to use the previously cached information about the previously set
       value of the filename.

       <b>"finfo"</b>

       Get and set the <u>finfo</u> request record member:

         $finfo = $r-&gt;finfo();
         $r-&gt;finfo($finfo);

       obj: $r ( "Apache2::RequestRec object" )
       opt arg1: $finfo ( "APR::Finfo object" )
       ret: $finfo ( "APR::Finfo object" )
           Always returns the current object.

           Due to the internal Apache implementation it's not possible to have two different objects
           originating from "$r-&gt;finfo" at the same time. Whenever "$r-&gt;finfo" is updated all objects will
           be updated too to the latest value.

       since: 2.0.00

       Most of the time, this method is used to get the "finfo" member. The only reason you may want to set
       it is you need to use it before the Apache's default map_to_storage phase is called.

       Examples:

          What Apache thinks is the current request filename (post the "PerlMapToStorageHandler" phase):

             use Apache2::RequestRec ();
             use APR::Finfo ();
             print $r-&gt;finfo-&gt;fname;

          Populate the "finfo" member (normally, before the "PerlMapToStorageHandler" phase):

             use APR::Finfo ();
             use APR::Const -compile =&gt; qw(FINFO_NORM);

             my $finfo = APR::Finfo::stat(__FILE__, APR::Const::FINFO_NORM, $r-&gt;pool);
             $r-&gt;finfo($finfo);

       <b>"handler"</b>

       Get/set the equivalent of the "SetHandler" directive.

         $handler      = $r-&gt;handler();
         $prev_handler = $r-&gt;handler($new_handler);

       obj: $r ( "Apache2::RequestRec object" )
       opt arg1: $new_handler ( string )
           the new handler.

       ret: $handler ( string )
           the current handler.

           If $new_handler is passed, the previous value is returned.

       since: 2.0.00

       <b>"header_only"</b>

       Did the client has asked for headers only? e.g. if the request method was <b>HEAD</b>.

         $status = $r-&gt;header_only();

       obj: $r ( "Apache2::RequestRec object" )
       ret: $status ( boolean )
           Returns true if the client is asking for headers only, false otherwise

       since: 2.0.00

       <b>"headers_in"</b>

       Get/set the request MIME headers:

         $headers_in = $r-&gt;headers_in();

       obj: $r ( "Apache2::RequestRec object" )
       ret: $headers_in ( "APR::Table object" )
       since: 2.0.00

       This table is available starting from the "PerlHeaderParserHandler" phase.

       For example you can use it to retrieve the cookie value sent by the client, in the "Cookie:" header:

           my $cookie = $r-&gt;headers_in-&gt;{Cookie} || '';

       <b>"headers_out"</b>

       Get/set MIME response headers, printed only on 2xx responses.

         $headers_out = $r-&gt;headers_out();

       obj: $r ( "Apache2::RequestRec object" )
       ret: $headers_out ( "APR::Table object" )
       since: 2.0.00

       See also "err_headers_out", which allows to set headers for non-2xx responses and persist across
       internal redirects.

       <b>"hostname"</b>

       Host, as set by full URI or Host:

         $hostname = $r-&gt;hostname();
         $prev_hostname = $r-&gt;hostname($new_hostname);

       obj: $r ( "Apache2::RequestRec object" )
       opt arg1: $new_hostname ( string )
           new value

       ret: $hostname ( string )
           the current hostname, or the previous value if the optional $new_hostname argument was passed

       since: 2.0.00

       <b>"input_filters"</b>

       Get/set the first filter in a linked list of request level input filters:

         $input_filters      = $r-&gt;input_filters();
         $prev_input_filters = $r-&gt;input_filters($new_input_filters);

       obj: $r ( "Apache2::RequestRec object" )
       opt arg1: $new_input_filters
           Set a new value

       ret: $input_filters ( "Apache2::Filter object" )
           The first filter in the request level input filters chain.

           If $new_input_filters was passed, returns the previous value.

       since: 2.0.00

       For example instead of using "$r-&gt;read()" to read the POST data, one could use an explicit walk
       through incoming bucket brigades to get that data. The following function "read_post()" does just
       that (in fact that's what "$r-&gt;read()" does behind the scenes):

         use APR::Brigade ();
         use APR::Bucket ();
         use Apache2::Filter ();

         use Apache2::Const -compile =&gt; qw(MODE_READBYTES);
         use APR::Const    -compile =&gt; qw(SUCCESS BLOCK_READ);

         use constant IOBUFSIZE =&gt; 8192;

         sub read_post {
             my $r = shift;

             my $bb = APR::Brigade-&gt;new($r-&gt;pool,
                                        $r-&gt;connection-&gt;bucket_alloc);

             my $data = '';
             my $seen_eos = 0;
             do {
                 $r-&gt;input_filters-&gt;get_brigade($bb, Apache2::Const::MODE_READBYTES,
                                                APR::Const::BLOCK_READ, IOBUFSIZE);

                 for (my $b = $bb-&gt;first; $b; $b = $bb-&gt;next($b)) {
                     if ($b-&gt;is_eos) {
                         $seen_eos++;
                         last;
                     }

                     if ($b-&gt;read(my $buf)) {
                         $data .= $buf;
                     }

                     $b-&gt;remove; # optimization to reuse memory
                 }

             } while (!$seen_eos);

             $bb-&gt;destroy;

             return $data;
         }

       As you can see "$r-&gt;input_filters" gives us a pointer to the last of the top of the incoming filters
       stack.

       <b>"main"</b>

       Get the main request record

         $main_r = $r-&gt;main();

       obj: $r ( "Apache2::RequestRec object" )
       ret: $main_r ( "Apache2::RequestRec object" )
           If the current request is a sub-request, this method returns a blessed reference to the main
           request structure. If the current request is the main request, then this method returns "undef".

           To figure out whether you are inside a main request or a sub-request/internal redirect, use
           "$r-&gt;is_initial_req".

       since: 2.0.00

       <b>"method"</b>

       Get/set the current request method (e.g. "GET", "HEAD", "POST", etc.):

         $method     = $r-&gt;method();
         $pre_method = $r-&gt;method($new_method);

       obj: $r ( "Apache2::RequestRec object" )
       opt arg1: $new_method ( string )
           a new value

       ret: $method ( string )
           The current method as a string

           if $new_method was passed the previous value is returned.

       since: 2.0.00

       <b>"method_number"</b>

       Get/set the HTTP method, issued by the client ("Apache2::Const::M_GET", "Apache2::Const::M_POST",
       etc.)

         $methnum      = $r-&gt;method_number();
         $prev_methnum = $r-&gt;method_number($new_methnum);

       obj: $r ( "Apache2::RequestRec object" )
       opt arg1: $new_methnum ( "Apache2::Const :methods constant" )
           a new value

       ret: $methnum ( "Apache2::Const :methods constant" )
           The current method as a number

           if $new_methnum was passed the previous value is returned.

       since: 2.0.00

       See the "$r-&gt;allowed" entry for examples.

       <b>"mtime"</b>

       Last modified time of the requested resource

         $mtime      = $r-&gt;mtime();
         $prev_mtime = $r-&gt;mtime($new_mtime);

       obj: $r ( "Apache2::RequestRec object" )
       opt arg1: $new_mtime (epoch seconds).
           a new value

       ret: $mtime (epoch seconds).
           the current value

           if $new_mtime was passed the previous value is returned.

       since: 2.0.00

       <b>"next"</b>

       Pointer to the redirected request if this is an external redirect

         $next_r = $r-&gt;next();

       obj: $r ( "Apache2::RequestRec object" )
       ret: $next_r ( "Apache2::RequestRec object" )
           returns a blessed reference to the next (internal) request structure or "undef" if there is no
           next request.

       since: 2.0.00

       <b>"no_local_copy"</b>

       There is no local copy of this response

         $status = $r-&gt;no_local_copy();

       obj: $r ( "Apache2::RequestRec object" )
       ret: $status (integer)
       since: 2.0.00

       Used internally in certain sub-requests to prevent sending "Apache2::Const::HTTP_NOT_MODIFIED" for a
       fragment or error documents. For example see the implementation in <u>modules/filters/mod</u><b>_</b><u>include.c</u>.

       Also used internally in "$r-&gt;meets_conditions" -- if set to a true value, the conditions are always
       met.

       <b>"notes"</b>

       Get/set text notes for the duration of this request. These notes can be passed from one module to
       another (not only mod_perl, but modules in any other language):

         $notes      = $r-&gt;notes();
         $prev_notes = $r-&gt;notes($new_notes);

       obj: $r ( "Apache2::RequestRec object" )
       opt arg1: $new_notes ( "APR::Table object" )
       ret: $notes ( "APR::Table object" )
           the current notes table.

           if the $new_notes argument was passed, returns the previous value.

       since: 2.0.00

       If you want to pass Perl structures, you can use "$r-&gt;pnotes".

       Also see "$c-&gt;notes"

       <b>"output_filters"</b>

       Get the first filter in a linked list of request level output filters:

         $output_filters      = $r-&gt;output_filters();
         $prev_output_filters = $r-&gt;output_filters($new_output_filters);

       obj: $r ( "Apache2::RequestRec object" )
       opt arg1: $new_output_filters
           Set a new value

       ret: $output_filters ( "Apache2::Filter object" )
           The first filter in the request level output filters chain.

           If $new_output_filters was passed, returns the previous value.

       since: 2.0.00

       For example instead of using "$r-&gt;print()" to send the response body, one could send the data
       directly to the first output filter. The following function "send_response_body()" does just that:

         use APR::Brigade ();
         use APR::Bucket ();
         use Apache2::Filter ();

         sub send_response_body {
             my ($r, $data) = @_;

             my $bb = APR::Brigade-&gt;new($r-&gt;pool,
                                        $r-&gt;connection-&gt;bucket_alloc);

             my $b = APR::Bucket-&gt;new($bb-&gt;bucket_alloc, $data);
             $bb-&gt;insert_tail($b);
             $r-&gt;output_filters-&gt;fflush($bb);
             $bb-&gt;destroy;
         }

       In fact that's what "$r-&gt;read()" does behind the scenes. But it also knows to parse HTTP headers
       passed together with the data and it also implements buffering, which the above function does not.

       <b>"path_info"</b>

       Get/set the "PATH_INFO", what is left in the path after the <u>URI</u> <u>--&gt;</u> <u>filename</u> translation:

         $path_info      = $r-&gt;path_info();
         $prev_path_info = $r-&gt;path_info($path_info);

       obj: $r ( "Apache2::RequestRec object" )
       opt arg1: $path_info ( string )
           Set a new value

       ret: $path_info ( string )
           Return the current value.

           If the optional argument $path_info is passed, the previous value is returned.

       since: 2.0.00

       <b>"per_dir_config"</b>

       Get the dir config vector:

         $per_dir_config = $r-&gt;per_dir_config();

       obj: $r ( "Apache2::RequestRec object" )
       ret: $per_dir_config ( "Apache2::ConfVector object" )
       since: 2.0.00

       For an indepth discussion, refer to the Apache Server Configuration Customization in Perl chapter.

       <b>"pool"</b>

       The pool associated with the request

         $p = $r-&gt;pool();

       obj: $r ( "Apache2::RequestRec object" )
       ret: $p ( "APR::Pool object" )
       since: 2.0.00

       <b>"prev"</b>

       Pointer to the previous request if this is an internal redirect

         $prev_r = $r-&gt;prev();

       obj: $r ( "Apache2::RequestRec object" )
       ret: $prev_r ( "Apache2::RequestRec object" )
           a blessed reference to the previous (internal) request structure or "undef" if there is no
           previous request.

       since: 2.0.00

       <b>"proto_input_filters"</b>

       Get the first filter in a linked list of protocol level input filters:

         $proto_input_filters      = $r-&gt;proto_input_filters();
         $prev_proto_input_filters = $r-&gt;proto_input_filters($new_proto_input_filters);

       obj: $r ( "Apache2::RequestRec object" )
       opt arg1: $new_proto_input_filters
           Set a new value

       ret: $proto_input_filters ( "Apache2::Filter object" )
           The first filter in the protocol level input filters chain.

           If $new_proto_input_filters was passed, returns the previous value.

       since: 2.0.00

       "$r-&gt;proto_input_filters" points to the same filter as "$r-&gt;connection-&gt;input_filters".

       <b>"proto_num"</b>

       Get current request's HTTP protocol version number

         $proto_num = $r-&gt;proto_num();

       obj: $r ( "Apache2::RequestRec object" )
       ret: $proto_num (integer)
           current request's HTTP protocol version number, e.g.: HTTP/1.0 == 1000, HTTP/1.1 = 1001

       since: 2.0.00

       <b>"proto_output_filters"</b>

       Get the first filter in a linked list of protocol level output filters:

         $proto_output_filters      = $r-&gt;proto_output_filters();
         $prev_proto_output_filters = $r-&gt;proto_output_filters($new_proto_output_filters);

       obj: $r ( "Apache2::RequestRec object" )
       opt arg1: $new_proto_output_filters
           Set a new value

       ret: $proto_output_filters ( "Apache2::Filter object" )
           The first filter in the protocol level output filters chain.

           If $new_proto_output_filters was passed, returns the previous value.

       since: 2.0.00

       "$r-&gt;proto_output_filters" points to the same filter as "$r-&gt;connection-&gt;output_filters".

       <b>"protocol"</b>

       Get a string identifying the protocol that the client speaks.

         $protocol = $r-&gt;protocol();

       obj: $r ( "Apache2::RequestRec object" )
       ret: $protocl ( string )
           Typical values are "HTTP/1.0" or "HTTP/1.1".

           If the client didn't specify the protocol version, the default is "HTTP/0.9"

       since: 2.0.00

       <b>"proxyreq"</b>

       Get/set the <u>proxyrec</u> request record member and optionally adjust other related fields.

         $status = $r-&gt;proxyreq($val);

       obj: $r ( "Apache2::RequestRec object" )
       opt arg1: $val ( integer )
           0, 1 or none.

       ret: $status ( integer )
           If $val is 0 or 1, the <u>proxyrec</u> member will be set to that value and previous value will be
           returned.

           If $val is not passed, and "$r-&gt;proxyreq" is not true, and the proxy request is matching the
           current vhost (scheme, hostname and port), the <u>proxyrec</u> member will be set to 1 and that value
           will be returned. In addition "$r-&gt;uri" is set to "$r-&gt;unparsed_uri" and "$r-&gt;filename" is set to
           ""modperl-proxy:".$r-&gt;uri". If those conditions aren't true 0 is returned.

       since: 2.0.00

       For example to turn a normal request into a proxy request to be handled on the same server in the
       "PerlTransHandler" phase run:

         my $real_url = $r-&gt;unparsed_uri;
         $r-&gt;proxyreq(1);
         $r-&gt;uri($real_url);
         $r-&gt;filename("proxy:$real_url");
         $r-&gt;handler('proxy-server');

       Also remember that if you want to turn a proxy request into a non-proxy request, it's not enough to
       call:

         $r-&gt;proxyreq(0);

       You need to adjust "$r-&gt;uri" and "$r-&gt;filename" as well if you run that code in
       "PerlPostReadRequestHandler" phase, since if you don't -- "mod_proxy"'s own post_read_request handler
       will override your settings (as it will run after the mod_perl handler).

       <b>"request_time"</b>

       Time when the request started

         $request_time = $r-&gt;request_time();

       obj: $r ( "Apache2::RequestRec object" )
       ret: $request_time (epoch seconds).
       since: 2.0.00

       <b>"server"</b>

       Get the "Apache2::Server" object for the server the request $r is running under.

         $s = $r-&gt;server();

       obj: $r ( "Apache2::RequestRec object" )
       ret: $s ( "Apache2::ServerRec object" )
       since: 2.0.00

       <b>"status"</b>

       Get/set the reply status for the client request.

         $status      = $r-&gt;status();
         $prev_status = $r-&gt;status($new_status);

       obj: $r ( "Apache2::RequestRec object" )
       opt arg1: $new_status ( integer )
           If $new_status is passed the new status is assigned.

           Normally you would use some "Apache2::Const constant", e.g. "Apache2::Const::REDIRECT".

       ret: $newval ( integer )
           The current value.

           If $new_status is passed the old value is returned.

       since: 2.0.00

       Usually you will set this value indirectly by returning the status code as the handler's function
       result.  However, there are rare instances when you want to trick Apache into thinking that the
       module returned an "Apache2::Const::OK" status code, but actually send the browser a non-OK status.
       This may come handy when implementing an HTTP proxy handler.  The proxy handler needs to send to the
       client, whatever status code the proxied server has returned, while returning "Apache2::Const::OK" to
       Apache. e.g.:

         $r-&gt;status($some_code);
         return Apache2::Const::OK

       See also "$r-&gt;status_line", which. if set, overrides "$r-&gt;status".

       <b>"status_line"</b>

       Get/set the response status line.  The status line is a string like "200 Document follows" and it
       will take precedence over the value specified using the "$r-&gt;status()" described above.

         $status_line      = $r-&gt;status_line();
         $prev_status_line = $r-&gt;status_line($new_status_line);

       obj: $r ( "Apache2::RequestRec object" )
       opt arg1: $new_status_line ( string )
       ret: $status_line ( string )
       since: 2.0.00

       When discussing "$r-&gt;status" we have mentioned that sometimes a handler runs to a successful
       completion, but may need to return a different code, which is the case with the proxy server.
       Assuming that the proxy handler forwards to the client whatever response the proxied server has sent,
       it'll usually use "status_line()", like so:

         $r-&gt;status_line($response-&gt;code() . ' ' . $response-&gt;message());
         return Apache2::Const::OK;

       In this example $response could be for example an "HTTP::Response" object, if "LWP::UserAgent" was
       used to implement the proxy.

       This method is also handy when you extend the HTTP protocol and add new response codes. For example
       you could invent a new error code and tell Apache to use that in the response like so:

         $r-&gt;status_line("499 We have been FooBared");
         return Apache2::Const::OK;

       Here 499 is the new response code, and <u>We</u> <u>have</u> <u>been</u> <u>FooBared</u> is the custom response message.

       <b>"subprocess_env"</b>

       Get/set the Apache "subprocess_env" table, or optionally set the value of a named entry.

                      $r-&gt;subprocess_env;
         $env_table = $r-&gt;subprocess_env;

                $r-&gt;subprocess_env($key =&gt; $val);
         $val = $r-&gt;subprocess_env($key);

       obj: $r ( "Apache2::RequestRec object" )
       opt arg1: $key ( string )
       opt arg2: $val ( string )
       ret: "..."
       since: 2.0.00

       When called in VOID context with no arguments, it populate %ENV with special variables (e.g.
       $ENV{QUERY_STRING}) like mod_cgi does.

       When called in a non-VOID context with no arguments, it returns an "APR::Table object".

       When the $key argument (string) is passed, it returns the corresponding value (if such exists, or
       "undef". The following two lines are equivalent:

         $val = $r-&gt;subprocess_env($key);
         $val = $r-&gt;subprocess_env-&gt;get($key);

       When the $key and the $val arguments (strings) are passed, the value is set. The following two lines
       are equivalent:

         $r-&gt;subprocess_env($key =&gt; $val);
         $r-&gt;subprocess_env-&gt;set($key =&gt; $val);

       The "subprocess_env" "table" is used by "Apache2::SubProcess", to pass environment variables to
       externally spawned processes. It's also used by various Apache modules, and you should use this table
       to pass the environment variables. For example if in "PerlHeaderParserHandler" you do:

          $r-&gt;subprocess_env(MyLanguage =&gt; "de");

       you can then deploy "mod_include" and write in <u>.shtml</u> document:

          &lt;!--#if expr="$MyLanguage = en" --&gt;
          English
          &lt;!--#elif expr="$MyLanguage = de" --&gt;
          Deutsch
          &lt;!--#else --&gt;
          Sorry
          &lt;!--#endif --&gt;

       <b>"the_request"</b>

       First HTTP request header

         $request = $r-&gt;the_request();

       obj: $r ( "Apache2::RequestRec object" )
       ret: $request ( string )
           For example:

             GET /foo/bar/my_path_info?args=3 HTTP/1.0

       since: 2.0.00

       <b>"unparsed_uri"</b>

       The URI without any parsing performed

         $unparsed_uri = $r-&gt;unparsed_uri();

       obj: $r ( "Apache2::RequestRec object" )
       ret: $unparsed_uri ( string )
       since: 2.0.00

       If for example the request was:

         GET /foo/bar/my_path_info?args=3 HTTP/1.0

       "$r-&gt;uri" returns:

         /foo/bar/my_path_info

       whereas "$r-&gt;unparsed_uri" returns:

         /foo/bar/my_path_info?args=3

       <b>"uri"</b>

       The path portion of the URI

         $uri         = $r-&gt;uri();
         my $prec_uri = $r-&gt;uri($new_uri);

       obj: $r ( "Apache2::RequestRec object" )
       opt arg1: $new_uri ( string )
       ret: $uri ( string )
       since: 2.0.00

       See the example in the "$r-&gt;unparsed_uri" section.

       <b>"user"</b>

       Get the user name, if an authentication process was successful. Or set it.

         $user      = $r-&gt;user();
         $prev_user = $r-&gt;user($new_user);

       obj: $r ( "Apache2::RequestRec object" )
       opt arg1: $new_user ( string )
           Pass $new_user to set a new value

       ret: $user ( string )
           The current username if an authentication process was successful.

           If $new_user was passed, the previous value is returned.

       since: 2.0.00

       For example, let's print the username passed by the client:

         my ($res, $sent_pw) = $r-&gt;get_basic_auth_pw;
         return $res if $res != Apache2::Const::OK;
         print "User: ", $r-&gt;user;

<b>Unsupported</b> <b>API</b>
       "Apache2::RequestRec" also provides auto-generated Perl interface for a few other methods which
       aren't tested at the moment and therefore their API is a subject to change. These methods will be
       finalized later as a need arises. If you want to rely on any of the following methods please contact
       the the mod_perl development mailing list so we can help each other take the steps necessary to shift
       the method to an officially supported API.

       <b>"allowed_methods"</b>

       META: Autogenerated - needs to be reviewed/completed

       List of allowed methods

         $list = $r-&gt;allowed_methods();

       obj: $r ( "Apache2::RequestRec object" )
       ret: $list ( "Apache2::MethodList object" )
       since: 2.0.00

       META: Apache2::MethodList is not available at the moment

       <b>"allowed_xmethods"</b>

       META: Autogenerated - needs to be reviewed/completed

       Array of extension methods

         $array = $r-&gt;allowed_xmethods();

       obj: $r ( "Apache2::RequestRec object" )
       ret: $array ( "APR::ArrayHeader object" )
       since: 2.0.00

       META: APR::ArrayHeader is not available at the moment

       <b>"request_config"</b>

       Config vector containing pointers to request's per-server config structures

         $ret = $r-&gt;request_config($newval);

       obj: $r ( "Apache2::RequestRec object" )
       opt arg1: $newval ( "Apache2::ConfVector object" )
       since: 2.0.00

       <b>"used_path_info"</b>

       META: Autogenerated - needs to be reviewed/completed

       Flag for the handler to accept or reject path_info on the current request.  All modules should
       respect the AP_REQ_ACCEPT_PATH_INFO and AP_REQ_REJECT_PATH_INFO values, while
       AP_REQ_DEFAULT_PATH_INFO indicates they may follow existing conventions.  This is set to the user's
       preference upon HOOK_VERY_FIRST of the fixups.

         $ret = $r-&gt;used_path_info($newval);

       obj: $r ( "Apache2::RequestRec object" )
       arg1: $newval (integer)
       since: 2.0.00

<b>See</b> <b>Also</b>
       mod_perl 2.0 documentation.

<b>Copyright</b>
       mod_perl 2.0 and its core modules are copyrighted under The Apache Software License, Version 2.0.

<b>Authors</b>
       The mod_perl development team and numerous contributors.



perl v5.8.8                        <!-- a -->apache_mod_permod_perl-2.0.2::docs::api::Apache2::RequestRec(3)<!-- /a -->
</tt></pre>
</td></tr></table>
	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Darwin/Reference/ManPages/man3/Apache2__RequestRec.3pm.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Darwin/Reference/ManPages/man3/Apache2__RequestRec.3pm.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Darwin/Reference/ManPages/man3/Apache2__RequestRec.3pm.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

</body></html>
