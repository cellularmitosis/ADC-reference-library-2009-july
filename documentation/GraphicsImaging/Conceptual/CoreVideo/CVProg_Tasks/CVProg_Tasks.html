<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>Core Video Programming Guide: Core Video Tasks</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Core Video Tasks"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP40001536-CH203" title="Core Video Tasks"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../index.html#//apple_ref/doc/uid/TP30000440-TP30000424" target="_top">Graphics &amp; Imaging</a> &gt; <a href="../../../Video-date.html#//apple_ref/doc/uid/TP30000440-TP30000424-TP40001677" target="_top">Video</a> &gt; <a href="../CVProg_Intro/CVProg_Intro.html#//apple_ref/doc/uid/TP40001536-CH201-DontLinkElementID_26">Core Video Programming Guide</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../CVProg_Concepts/CVProg_Concepts.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../CVProg_Gloss/CVProg_Gloss.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP40001536-CH203-CIHCGHGG" title="Core Video Tasks"></a><h1>Core Video Tasks</h1><p>This chapter describes some common programming tasks used when processing Core Video. The examples in this chapter are written in Objective-C and use Cocoa, but Core Video can be used in a Carbon program as well.</p><p>In most cases, you will want to use the display link to access individual video frames. If your application is involved in generating the actual video frames (for example, if you’re writing a video compressor or creating animated images), you should consider using Core Video buffers to hold your frame data. </p>
<!-- This template is being used for both PDF and HTML. -->

    
    <h4>In this section:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="CVProg_Tasks.html#//apple_ref/doc/uid/TP40001536-CH203-DontLinkElementID_8">Obtaining Frames Using the Display Link</a>
				
			<br/>
			
        
			
			
				<a href="CVProg_Tasks.html#//apple_ref/doc/uid/TP40001536-CH203-DontLinkElementID_12">Manipulating Frames</a>
				
			<br/>
			
        
			
			
				<a href="CVProg_Tasks.html#//apple_ref/doc/uid/TP40001536-CH203-DontLinkElementID_13">Using Core Image Filtering With Core Video</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP40001536-CH203-DontLinkElementID_8" title="Obtaining Frames Using the Display Link"></a><h2>Obtaining Frames Using the Display Link</h2><p>The most common Core Video task is to use the display link to obtain frames of uncompressed video. Your application is then free to manipulate them as it likes before sending the frames to the display.</p><p>For simplicity, assume that all the method calls in this section act on a <code>MyVideoView</code> object, which is subclassed from the <code>NSOpenGLView</code> class:</p><a name="//apple_ref/doc/uid/TP40001536-CH203-BABICIBA" title="Listing 2-1The MyVideoView interface"></a><p class="codesample"><strong>Listing 2-1&nbsp;&nbsp;</strong>The MyVideoView interface</p><div class="codesample"><table><tr><td scope="row"><pre>@interface MyVideoView : NSOpenGLView<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    NSRecursiveLock         *lock;<span></span></pre></td></tr><tr><td scope="row"><pre>    QTMovie                 *qtMovie;<span></span></pre></td></tr><tr><td scope="row"><pre>    QTTime                  movieDuration;<span></span></pre></td></tr><tr><td scope="row"><pre>    QTVisualContextRef      qtVisualContext;<span></span></pre></td></tr><tr><td scope="row"><pre>    CVDisplayLinkRef        displayLink;<span></span></pre></td></tr><tr><td scope="row"><pre>    CVImageBufferRef        currentFrame;<span></span></pre></td></tr><tr><td scope="row"><pre>    CIFilter                *effectFilter;<span></span></pre></td></tr><tr><td scope="row"><pre>    CIContext               *ciContext;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    NSDictionary            *fontAttributes;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    int                     frameCount;<span></span></pre></td></tr><tr><td scope="row"><pre>    int                     frameRate;<span></span></pre></td></tr><tr><td scope="row"><pre>    CVTimeStamp             frameCountTimeStamp;<span></span></pre></td></tr><tr><td scope="row"><pre>    double                  timebaseRatio;<span></span></pre></td></tr><tr><td scope="row"><pre>    BOOL                    needsReshape;<span></span></pre></td></tr><tr><td scope="row"><pre>    id                      delegate;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre>…<span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr></table></div><div class="importantbox"><a name="//apple_ref/doc/uid/TP40001536-CH203-DontLinkElementID_28" title="Important:"></a><p><strong>Important:</strong>&nbsp;OpenGL is not thread-safe. Your application should make sure that it locks the thread when making OpenGL calls, for example by instantiating an NSRecursiveLock object and invoking its <code>lock</code> method. </p><p></p></div><p>For more information about using the <code>NSOpenGLView</code> class, see the example project <em><!--a target="_top" -->Cocoa OpenGL<!--/a--></em>. </p><a name="//apple_ref/doc/uid/TP40001536-CH203-DontLinkElementID_9" title="Setting Up the Display Link"></a><h3>Setting Up the Display Link</h3><p>Setting up a display link involves the following steps:</p><ul class="spaceabove"><li class="li"><p>Create a display link thread.</p></li><li class="li"><p>Bind the link to a specific display. </p></li><li class="li"><p>Register a display output callback. </p></li><li class="li"><p>Starting the display link thread. </p></li></ul><p>The method <code>awakeFromNib</code> in <span class="content_text">Listing 2-2</span> shows how you might implement the display link.</p><a name="//apple_ref/doc/uid/TP40001536-CH203-CIHDBFAE" title="Listing 2-2Setting up a display link"></a><p class="codesample"><strong>Listing 2-2&nbsp;&nbsp;</strong>Setting up a display link</p><div class="codesample"><table><tr><td scope="row"><pre>- (void)awakeFromNib<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    CVReturn            error = kCVReturnSuccess;<span></span></pre></td></tr><tr><td scope="row"><pre>    CGDirectDisplayID   displayID = CGMainDisplayID();<span>// 1</span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    error = CVDisplayLinkCreateWithCGDisplay(displayID, &amp;displayLink);<span>// 2</span></pre></td></tr><tr><td scope="row"><pre>    if(error)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        NSLog(@"DisplayLink created with error:%d", error);<span></span></pre></td></tr><tr><td scope="row"><pre>        displayLink = NULL;<span></span></pre></td></tr><tr><td scope="row"><pre>        return;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    error = CVDisplayLinkSetOutputCallback(displayLink,<span>// 3</span></pre></td></tr><tr><td scope="row"><pre>                                 MyDisplayLinkCallback, self);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>Here is how the code works:</p><ol class="ol"><li class="li"><p>Obtains the Core Graphics display ID for the display you want to associate with this display link. The Core Graphics function <code>CGMainDisplayID</code> simply returns the ID of the user’s main display (that is, the one containing the menu bar).</p></li><li class="li"><p>Creates a display link for the specified display. If desired, you can create a display link that can work with any of the currently active displays by calling <code>CVDisplayLinkCreateWithActiveCGDisplays</code> instead. You must then call <code>CVDisplayLinkSetCurrentCGDisplay</code> to designate a specific display for the display link. </p><p>If the user moves the window containing the video to another monitor, you should update the display link appropriately. In Cocoa you can check the window position when you receive an NSWindowDidMoveNotification notification from a handler such as the following: </p><div class="codesample"><table><tr><td scope="row"><pre>- (void)windowChangedScreen:(NSNotification*)inNotification<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>  NSWindow *window = [mainView window];<span></span></pre></td></tr><tr><td scope="row"><pre>  CGDirectDisplayID displayID = (CGDirectDisplayID)[[[[window screen]<span></span></pre></td></tr><tr><td scope="row"><pre>         deviceDescription] objectForKey:@"NSScreenNumber"] intValue];<span></span></pre></td></tr><tr><td scope="row"><pre>  if((displayID != NULL) &amp;&amp; (mainViewDisplayID != displayID))<span></span></pre></td></tr><tr><td scope="row"><pre>  {<span></span></pre></td></tr><tr><td scope="row"><pre>    CVDisplayLinkSetCurrentCGDisplay(displayLink, displayID);<span></span></pre></td></tr><tr><td scope="row"><pre>    mainViewDisplayID = displayID;<span></span></pre></td></tr><tr><td scope="row"><pre>  }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>In Carbon, you should call the Window Manager function <code>GetWindowGreatestAreaDevice</code> to obtain the <code>GDevice</code> structure for the window’s display. You can then store its device ID with the window and check to see if it has changed whenever your <code>kEventWindowBoundsChanged</code> handler gets called. </p></li><li class="li"><p>Sets the output callback for the display link. This is the function that the display link calls whenever it wants you to output a video frame. This example passes a reference to the instance using this method (that is, <code>self</code>), as user data. For example, if this method is part of the <code>MyVideoView</code> class, the user data is a reference to a <code>MyVideoView</code> instance. </p></li></ol><p>When you are ready to start processing video frames, call <code>CVDisplayLinkStart</code> to activate the display link thread. This thread runs independent of your application process. You should stop the thread by calling <code>CVDisplayLinkStop</code> when your application quits or otherwise stops displaying video. </p><div class="notebox"><a name="//apple_ref/doc/uid/TP40001536-CH203-DontLinkElementID_29" title="Note"></a><p><strong>Note:</strong>&nbsp;In Mac OS X v10.3, you should also stop your display link if Fast User Switching is invoked. In Mac OS X v10.4 and later, the display link is automatically stopped when switching users. </p></div><a name="//apple_ref/doc/uid/TP40001536-CH203-DontLinkElementID_10" title="Initializing Your Video Source"></a><h3>Initializing Your Video Source</h3><p>Before you can begin processing, you must set up your video source to provide frames. The video source can be anything that can supply uncompressed video data as OpenGL textures. For example, this source could be QuickTime, OpenGL, or your own proprietary video frame generator. </p><p>In each case, you need to create an OpenGL context to display the generated video. You pass this to your video source to indicate that this is where you want your video to be displayed. </p><p><span class="content_text">Listing 2-3</span> shows a method that sets up a QuickTime movie to be your video source. </p><a name="//apple_ref/doc/uid/TP40001536-CH203-CHABADIH" title="Listing 2-3Initializing a QuickTime video source"></a><p class="codesample"><strong>Listing 2-3&nbsp;&nbsp;</strong>Initializing a QuickTime video source</p><div class="codesample"><table><tr><td scope="row"><pre>- (id)initWithFilePath:(NSString*)theFilePath <span>// 1</span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    self = [super init];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    OSStatus        theError = noErr;<span></span></pre></td></tr><tr><td scope="row"><pre>    Boolean         active = TRUE;<span></span></pre></td></tr><tr><td scope="row"><pre>    UInt32          trackCount = 0;<span></span></pre></td></tr><tr><td scope="row"><pre>    OSType          theTrackType;<span></span></pre></td></tr><tr><td scope="row"><pre>    Track           theTrack = NULL;<span></span></pre></td></tr><tr><td scope="row"><pre>    Media           theMedia = NULL;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    QTNewMoviePropertyElement newMovieProperties[] = <span>// 2</span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>        {kQTPropertyClass_DataLocation,<span></span></pre></td></tr><tr><td scope="row"><pre>            kQTDataLocationPropertyID_CFStringNativePath,<span></span></pre></td></tr><tr><td scope="row"><pre>            sizeof(theFilePath), &amp;theFilePath, 0},<span></span></pre></td></tr><tr><td scope="row"><pre>        {kQTPropertyClass_NewMovieProperty, kQTNewMoviePropertyID_Active,<span></span></pre></td></tr><tr><td scope="row"><pre>            sizeof(active), &amp;active, 0},<span></span></pre></td></tr><tr><td scope="row"><pre>        {kQTPropertyClass_Context, kQTContextPropertyID_VisualContext,<span></span></pre></td></tr><tr><td scope="row"><pre>            sizeof(qtVisualContext), &amp;qtVisualContext, 0},<span></span></pre></td></tr><tr><td scope="row"><pre>        };<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    theError = QTOpenGLTextureContextCreate( NULL, NULL, <span>// 3</span></pre></td></tr><tr><td scope="row"><pre>        [[NSOpenGLView defaultPixelFormat]<span></span></pre></td></tr><tr><td scope="row"><pre>         CGLPixelFormatObj], NULL, &amp;qtVisualContext);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if(qtVisualContext == NULL)<span></span></pre></td></tr><tr><td scope="row"><pre>     {<span></span></pre></td></tr><tr><td scope="row"><pre>        NSLog(@"QTVisualContext creation failed with error:%d", theError);<span></span></pre></td></tr><tr><td scope="row"><pre>        return NULL;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    theError = NewMovieFromProperties(<span></span></pre></td></tr><tr><td scope="row"><pre>        sizeof(newMovieProperties) / sizeof(newMovieProperties[0]),<span>// 4</span></pre></td></tr><tr><td scope="row"><pre>        newMovieProperties, 0, NULL, &amp;channelMovie);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if(theError)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        NSLog(@"NewMovieFromProperties failed with %d", theError);<span></span></pre></td></tr><tr><td scope="row"><pre>        return NULL;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // setup the movie<span></span></pre></td></tr><tr><td scope="row"><pre>    GoToBeginningOfMovie(channelMovie);<span>// 5</span></pre></td></tr><tr><td scope="row"><pre>    SetMovieRate(channelMovie, 1 &lt;&lt; 16);<span></span></pre></td></tr><tr><td scope="row"><pre>    SetTimeBaseFlags(GetMovieTimeBase(channelMovie), loopTimeBase);<span></span></pre></td></tr><tr><td scope="row"><pre>    trackCount = GetMovieTrackCount(channelMovie);<span></span></pre></td></tr><tr><td scope="row"><pre>    while(trackCount > 0)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        theTrack = GetMovieIndTrack(channelMovie, trackCount);<span></span></pre></td></tr><tr><td scope="row"><pre>        if(theTrack != NULL)<span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>            theMedia = GetTrackMedia(theTrack);<span></span></pre></td></tr><tr><td scope="row"><pre>            if(theMedia != NULL)<span></span></pre></td></tr><tr><td scope="row"><pre>            {<span></span></pre></td></tr><tr><td scope="row"><pre>                GetMediaHandlerDescription(theMedia, &amp;theTrackType, 0, 0);<span></span></pre></td></tr><tr><td scope="row"><pre>                if(theTrackType != VideoMediaType)<span></span></pre></td></tr><tr><td scope="row"><pre>                {<span></span></pre></td></tr><tr><td scope="row"><pre>                    SetTrackEnabled(theTrack, false);<span></span></pre></td></tr><tr><td scope="row"><pre>                }<span></span></pre></td></tr><tr><td scope="row"><pre>            }<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>        trackCount--;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    return self;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>Here is how the code works:</p><ol class="ol"><li class="li"><p>This method takes the file path of the QuickTime movie as its input parameter.</p></li><li class="li"><p>Sets up the movie properties array. These properties specify </p><ul class="ul"><li class="li"><p>the file path to the movie</p></li><li class="li"><p>whether or not the new movie should be active (yes, in this case)</p></li><li class="li"><p>the visual context to associate with this movie. The <code>qtVisualContext</code> variable is an instance variable of this method’s class. </p></li></ul><p>These properties are passed later to the <code>NewMovieFromProperties</code> function. </p></li><li class="li"><p>Creates an OpenGL texture context. This is the abstract destination into which OpenGL textures are drawn. The QuickTime function <code>QTOpenGLTextureContextCreate</code> requires you to pass in a CGLContext and a CGLPixelFormat object. In Cocoa, you can obtain these from the NSOpenGLContext and NSOpenGLPixelFormat objects created when you initialize OpenGL. In Carbon, you can obtain the underlying context and pixel format from the AGLContext and AGLPixelFormat objects using the AGL functions <code>aglGetCGLContext</code> and <code>aglGetCGLPixelFormat</code>.)</p><p>This context, stored in the instance variable <code>qtVisualContext</code> is passed to <code>NewMovieFromProperties</code> to be the visual context into which QuickTime will draw its movies.</p></li><li class="li"><p>Creates the movie. The QuickTime function <code>NewMovieFromProperties</code>, available in Mac OS X v10.4 and later, or QuickTime 7.0 and later, is the preferred way to instantiate movies. </p><p>If you are using Cocoa, you can call the QTKit method <code>movieFromFile</code> instead. </p><p>If for some reason you want to set or change the visual context after creating the movie, you can call the QuickTime function <code>SetMovieVisualContext</code>.</p></li><li class="li"><p>Performs various initializations on the movie. This section is mostly boilerplate code to start the movie at the beginning, at the normal frame rate, and in a continuous loop. The code also loops through the available tracks and turns off any non-video tracks. </p></li></ol><a name="//apple_ref/doc/uid/TP40001536-CH203-DontLinkElementID_11" title="Implementing the Display Link Output Callback Function"></a><h3>Implementing the Display Link Output Callback Function</h3><p>When the display link is running, it periodically calls back to your application each time you should prepare a frame. Your callback function should obtain a frame from the designated video source as an OpenGL texture, and then output it to the screen.</p><p>If you are using object-oriented programming, you will probably want your callback to invoke a method, as shown in <span class="content_text">Listing 2-4</span> and <span class="content_text">Listing 2-5</span>. </p><a name="//apple_ref/doc/uid/TP40001536-CH203-CHACCFHD" title="Listing 2-4Invoking a method from your callback"></a><p class="codesample"><strong>Listing 2-4&nbsp;&nbsp;</strong>Invoking a method from your callback</p><div class="codesample"><table><tr><td scope="row"><pre>CVReturn MyDisplayLinkCallback (<span></span></pre></td></tr><tr><td scope="row"><pre>    CVDisplayLinkRef displayLink,<span></span></pre></td></tr><tr><td scope="row"><pre>    const CVTimeStamp *inNow,<span></span></pre></td></tr><tr><td scope="row"><pre>    const CVTimeStamp *inOutputTime,<span></span></pre></td></tr><tr><td scope="row"><pre>    CVOptionFlags flagsIn,<span></span></pre></td></tr><tr><td scope="row"><pre>    CVOptionFlags *flagsOut,<span></span></pre></td></tr><tr><td scope="row"><pre>    void *displayLinkContext)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre> CVReturn error =<span></span></pre></td></tr><tr><td scope="row"><pre>        [(MyVideoView*) displayLinkContext displayFrame:inOutputTime];<span></span></pre></td></tr><tr><td scope="row"><pre> return error;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>The callback function simply invokes the <code>displayFrame</code> method implemented in the <code>MyVideoView</code> class. An instance of this class is passed to your callback in the <code>displayLinkContext</code> parameter. (The <code>MyVideoView</code> class that displays your frames should be a subclass of <code>NSOpenGLView</code>, as shown in <span class="content_text"><a href="CVProg_Tasks.html#//apple_ref/doc/uid/TP40001536-CH203-BABICIBA">Listing 2-1</a></span>.)</p><a name="//apple_ref/doc/uid/TP40001536-CH203-SW1" title="Listing 2-5Implementing the displayFrame method"></a><p class="codesample"><strong>Listing 2-5&nbsp;&nbsp;</strong>Implementing the displayFrame method</p><div class="codesample"><table><tr><td scope="row"><pre>- (CVReturn)displayFrame:(const CVTimeStamp *)timeStamp<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    CVReturn rv = kCVReturnError;<span></span></pre></td></tr><tr><td scope="row"><pre>    NSAutoreleasePool *pool;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    pool = [[NSAutoreleasePool alloc] init];<span></span></pre></td></tr><tr><td scope="row"><pre>    if([self getFrameForTime:timeStamp])<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        [self drawRect:NSZeroRect];<span></span></pre></td></tr><tr><td scope="row"><pre>        rv = kCVReturnSuccess;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    else<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>       rv = kCVReturnError;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    [pool release];<span></span></pre></td></tr><tr><td scope="row"><pre>    return rv;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr></table></div><p>You obtain the frame for the specified time as an OpenGL texture. <span class="content_text">Listing 2-6</span> shows how you might implement the <code>getFrameForTime</code> method if you were obtaining your video frames from QuickTime. This example assumes that the method is part of a custom <code>MyVideoView</code> class.</p><a name="//apple_ref/doc/uid/TP40001536-CH203-CHAGJHGA" title="Listing 2-6Obtaining frames from QuickTime"></a><p class="codesample"><strong>Listing 2-6&nbsp;&nbsp;</strong>Obtaining frames from QuickTime</p><div class="codesample"><table><tr><td scope="row"><pre>- (BOOL)getFrameForTime:(const CVTimeStamp*)syncTimeStamp<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    CVOpenGLTextureRef      newTextureRef = NULL;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    QTVisualContextTask(qtVisualContext);<span>// 1</span></pre></td></tr><tr><td scope="row"><pre>    if(QTVisualContextIsNewImageAvailable(qtVisualContext, syncTimeStamp))<span>// 2</span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        QTVisualContextCopyImageForTime(qtVisualContext, NULL, syncTimeStamp,<span>// 3</span></pre></td></tr><tr><td scope="row"><pre>                 &amp;newTextureRef);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        CVOpenGLTextureRelease(currentFrame);<span>// 4</span></pre></td></tr><tr><td scope="row"><pre>        currentFrame = newTextureRef;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        CVOpenGLTextureGetCleanTexCoords (<span>// 5</span></pre></td></tr><tr><td scope="row"><pre>                    currentFrame, lowerLeft, lowerRight, upperRight, upperLeft);<span></span></pre></td></tr><tr><td scope="row"><pre>        return YES; // we got a frame from QT<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    else<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        //NSLog(@"No Frame ready");<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    return NO;  // no frame available<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div>	<p>Here is how the code works:</p><ol class="ol"><li class="li"><p>Gives time to the context, allowing it to perform any required housekeeping. You should call this function before obtaining each frame. </p></li><li class="li"><p>Checks to see if a new frame is available for the given time. The requested time, as passed to your callback by the display link, represents not the current time, but the time in the future when the frame will be displayed. </p></li><li class="li"><p>If a frame is available, obtain it as an OpenGL texture. The QuickTime function <code>QTVisualContextCopyImageForTime</code> lets you obtain a frame from QuickTime as any Core Video image buffer type. </p></li><li class="li"><p>Releases the current texture (stored in the instance variable <code>currentFrame</code>) and sets the newly acquired texture to replace it. You should release your OpenGL textures when you are through using them to minimize the likelihood of filling up video memory. </p></li><li class="li"><p>Obtains the coordinates of the clean aperture for the texture. In most cases, these are the texture bounds needed for rendering. </p></li></ol><a name="//apple_ref/doc/uid/TP40001536-CH203-DontLinkElementID_12" title="Manipulating Frames"></a><h2>Manipulating Frames</h2><p>After you have acquired the frame from your video source, it is up to you to decide what to do with it. The frame is given to you as an OpenGL texture, so you can manipulate it with any OpenGL calls. <span class="content_text">Listing 2-7</span> shows how you could set up OpenGL to draw into the view bounds by overriding the standard NSView <code>drawRect</code> method. </p><a name="//apple_ref/doc/uid/TP40001536-CH203-BABJICEA" title="Listing 2-7Displaying OpenGL in a rectangle"></a><p class="codesample"><strong>Listing 2-7&nbsp;&nbsp;</strong>Displaying OpenGL in a rectangle</p><div class="codesample"><table><tr><td scope="row"><pre>- (void)drawRect:(NSRect)theRect<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    [lock lock];    <span>// 1</span></pre></td></tr><tr><td scope="row"><pre>    NSRect      frame = [self frame];<span></span></pre></td></tr><tr><td scope="row"><pre>    NSRect      bounds = [self bounds];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    [[self openGLContext] makeCurrentContext];<span>// 2</span></pre></td></tr><tr><td scope="row"><pre>    if(needsReshape)<span>// 3</span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        GLfloat     minX, minY, maxX, maxY;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        minX = NSMinX(bounds);<span></span></pre></td></tr><tr><td scope="row"><pre>        minY = NSMinY(bounds);<span></span></pre></td></tr><tr><td scope="row"><pre>        maxX = NSMaxX(bounds);<span></span></pre></td></tr><tr><td scope="row"><pre>        maxY = NSMaxY(bounds);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        [self update];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        if(NSIsEmptyRect([self visibleRect])) <span>// 4</span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>            glViewport(0, 0, 1, 1);<span></span></pre></td></tr><tr><td scope="row"><pre>        } else {<span></span></pre></td></tr><tr><td scope="row"><pre>            glViewport(0, 0,  frame.size.width ,frame.size.height);<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>        glMatrixMode(GL_MODELVIEW);<span></span></pre></td></tr><tr><td scope="row"><pre>        glLoadIdentity();<span></span></pre></td></tr><tr><td scope="row"><pre>        glMatrixMode(GL_PROJECTION);<span></span></pre></td></tr><tr><td scope="row"><pre>        glLoadIdentity();<span></span></pre></td></tr><tr><td scope="row"><pre>        glOrtho(minX, maxX, minY, maxY, -1.0, 1.0);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        needsReshape = NO;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    glClearColor(0.0, 0.0, 0.0, 0.0);<span></span></pre></td></tr><tr><td scope="row"><pre>    glClear(GL_COLOR_BUFFER_BIT);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if(!currentFrame)<span>// 5</span></pre></td></tr><tr><td scope="row"><pre>        [self updateCurrentFrame];<span></span></pre></td></tr><tr><td scope="row"><pre>    [self renderCurrentFrame];      <span>// 6</span></pre></td></tr><tr><td scope="row"><pre>    glFlush();<span>// 7</span></pre></td></tr><tr><td scope="row"><pre>    [lock unlock];<span>// 8</span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>Here is how the code works:</p><ol class="ol"><li class="li"><p>Locks the current thread. OpenGL is not thread-safe, so you must make sure that only one thread can make OpenGL calls at any given time. </p></li><li class="li"><p>Sets OpenGL to render into this object’s context. </p></li><li class="li"><p>If the drawing rectangle has been resized, then take steps to update the size of the OpenGL context.</p></li><li class="li"><p>Maps the OpenGL context to the new bounds of the view, if the view is visible. If not, then map the context to be effectively invisible. </p></li><li class="li"><p>Obtains the current frame again if it does not already exist. This situation can occur if the <code>drawRect</code> method is invoked in response to a view resize. </p></li><li class="li"><p>Draws the current frame into the OpenGL context. <code>renderCurrentFrame</code> is the method that holds your custom frame code.</p></li><li class="li"><p>Flushes the drawing to the OpenGL renderer. The frame is then automatically displayed onscreen at the appropriate time. </p></li><li class="li"><p>Unlocks the thread after completing all OpenGL calls. </p></li></ol><p>The <code>renderCurrentFrame</code> method contains the custom processing your application wants to apply to the frame. <span class="content_text">Listing 2-8</span> shows a simple example of how you can implement this method. This example uses Core Image to draw the frame into the OpenGL context.</p><a name="//apple_ref/doc/uid/TP40001536-CH203-BABGGAGD" title="Listing 2-8Drawing a frame"></a><p class="codesample"><strong>Listing 2-8&nbsp;&nbsp;</strong>Drawing a frame</p><div class="codesample"><table><tr><td scope="row"><pre>- (void)renderCurrentFrame<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    NSRect      frame = [self frame];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if(currentFrame)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        CGRect      imageRect;<span></span></pre></td></tr><tr><td scope="row"><pre>        CIImage     *inputImage;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        inputImage = [CIImage imageWithCVImageBuffer:currentFrame];<span>// 1</span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        imageRect = [inputImage extent];<span>// 2</span></pre></td></tr><tr><td scope="row"><pre>        [ciContext drawImage:inputImage <span>// 3</span></pre></td></tr><tr><td scope="row"><pre>                atPoint:CGPointMake(<span></span></pre></td></tr><tr><td scope="row"><pre>                (int)((frame.size.width - imageRect.size.width) * 0.5),<span></span></pre></td></tr><tr><td scope="row"><pre>                (int)((frame.size.height - imageRect.size.height) * 0.5))<span></span></pre></td></tr><tr><td scope="row"><pre>                fromRect:imageRect];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    QTVisualContextTask(qtVisualContext);<span>// 4</span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>Here is how the code works:</p><ol class="ol"><li class="li"><p>Creates a Core Image image from the current frame. The Core Image method <code>ImageWithCVImageBuffer</code> creates the image from any image buffer type (that is, a pixel buffer, OpenGL buffer, or OpenGL texture).</p></li><li class="li"><p>Obtains the bounding rectangle for the image. </p></li><li class="li"><p>Draws the image into a Core Image context. The Core Image method <code>drawImage:atPoint:fromRect</code> draws the frame in the specified visual context at a specified location. </p><p>Before drawing, you must have created a Core Image context that references the same drawing space as the OpenGL context. Doing so allows you to draw into the space using Core Image APIs and then display it using OpenGL. For example, you could add the following code to <span class="content_text"><a href="CVProg_Tasks.html#//apple_ref/doc/uid/TP40001536-CH203-CHABADIH">Listing 2-3</a></span> after creating your OpenGL context :</p><div class="codesample"><table><tr><td scope="row"><pre>/* Create CGColorSpaceRef */<span></span></pre></td></tr><tr><td scope="row"><pre>CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>/* Create CIContext */<span></span></pre></td></tr><tr><td scope="row"><pre>ciContext = [[CIContext contextWithCGLContext:<span></span></pre></td></tr><tr><td scope="row"><pre>                (CGLContextObj)[[self openGLContext] CGLContextObj]<span></span></pre></td></tr><tr><td scope="row"><pre>                pixelFormat:(CGLPixelFormatObj)<span></span></pre></td></tr><tr><td scope="row"><pre>                [[self pixelFormat] CGLPixelFormatObj]<span></span></pre></td></tr><tr><td scope="row"><pre>                options:[NSDictionary dictionaryWithObjectsAndKeys:<span></span></pre></td></tr><tr><td scope="row"><pre>                (id)colorSpace,kCIContextOutputColorSpace,<span></span></pre></td></tr><tr><td scope="row"><pre>                (id)colorSpace,kCIContextWorkingColorSpace,nil]] retain];<span></span></pre></td></tr><tr><td scope="row"><pre>CGColorSpaceRelease(colorSpace);<span></span></pre></td></tr></table></div><p>See <em><a href="../../CoreImaging/index.html#//apple_ref/doc/uid/TP30001185" target="_top">Core Image Programming Guide</a></em> for more information about creating Core Image contexts. </p></li><li class="li"><p>Gives time to the visual context to perform any required housekeeping. You should call <code>QTVisualContextTask</code> once each time through your drawing method. </p></li></ol><a name="//apple_ref/doc/uid/TP40001536-CH203-DontLinkElementID_13" title="Using Core Image Filtering With Core Video"></a><h2>Using Core Image Filtering With Core Video</h2><p>If you want to apply filtering effects to your video, it is often simpler to apply a Core Image filter to them rather than try to implement your own image processing. To do so, you need to obtain your frame as a Core Image image.</p><p>You can load a Core Image filter using the Core Image CIFIlter method <code>filterWithName</code>:</p><div class="codesample"><table><tr><td scope="row"><pre>effectFilter = [[CIFilter filterWithName:@"CILineScreen"] retain];<span></span></pre></td></tr><tr><td scope="row"><pre>[effectFilter setDefaults];<span></span></pre></td></tr></table></div><p>This example loads the standard Core Image line screen filter, but you should use whatever is appropriate for your application.</p><p>After you have loaded the filter, you process your image with it in your drawing method. <span class="content_text">Listing 2-9</span> shows how you could apply a Core Image filter. This listing is identical to <span class="content_text"><a href="CVProg_Tasks.html#//apple_ref/doc/uid/TP40001536-CH203-BABGGAGD">Listing 2-8</a></span> except that it filters the input image before drawing it into the Core Image context. </p><a name="//apple_ref/doc/uid/TP40001536-CH203-BABHGDAJ" title="Listing 2-9Applying a Core Image filter to an image"></a><p class="codesample"><strong>Listing 2-9&nbsp;&nbsp;</strong>Applying a Core Image filter to an image</p><div class="codesample"><table><tr><td scope="row"><pre>- (void)renderCurrentFrameWithFilter<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    NSRect      frame = [self frame];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if(currentFrame)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        CGRect      imageRect;<span></span></pre></td></tr><tr><td scope="row"><pre>        CIImage     *inputImage, *outputImage;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        inputImage = [CIImage imageWithCVImageBuffer:currentFrame];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        imageRect = [inputImage extent];<span></span></pre></td></tr><tr><td scope="row"><pre>        [effectFilter setValue:inputImage forKey:@"inputImage"];<span>// 1</span></pre></td></tr><tr><td scope="row"><pre>        [[[NSGraphicsContext currentContext] CIContext]<span>// 2</span></pre></td></tr><tr><td scope="row"><pre>            drawImage:[effectFilter valueForKey:@"outputImage"]<span></span></pre></td></tr><tr><td scope="row"><pre>            atPoint:CGPointMake((int)<span></span></pre></td></tr><tr><td scope="row"><pre>                ((frame.size.width - imageRect.size.width) * 0.5),<span></span></pre></td></tr><tr><td scope="row"><pre>                (int)((frame.size.height - imageRect.size.height) * 0.5))<span></span></pre></td></tr><tr><td scope="row"><pre>            fromRect:imageRect];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    QTVisualContextTask(qtVisualContext);<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>Here is how the code works:</p><ol class="ol"><li class="li"><p>Sets the CIImage filter to apply to the frame.</p></li><li class="li"><p>Draws the image with the specified filter. </p></li></ol><p>Keep in mind that the Core Image image is immutable; each time you obtain a frame, you must create a new image.</p><p>For more details about creating and using Core Image filters, see <em><a href="../../CoreImaging/index.html#//apple_ref/doc/uid/TP30001185" target="_top">Core Image Programming Guide</a></em>. </p>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../CVProg_Concepts/CVProg_Concepts.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../CVProg_Gloss/CVProg_Gloss.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2004, 2007 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2007-04-03<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/GraphicsImaging/Conceptual/CoreVideo/CVProg_Tasks/CVProg_Tasks.html%3Fid%3DTP40001536-1.3&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/GraphicsImaging/Conceptual/CoreVideo/CVProg_Tasks/CVProg_Tasks.html%3Fid%3DTP40001536-1.3&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/GraphicsImaging/Conceptual/CoreVideo/CVProg_Tasks/CVProg_Tasks.html%3Fid%3DTP40001536-1.3&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>