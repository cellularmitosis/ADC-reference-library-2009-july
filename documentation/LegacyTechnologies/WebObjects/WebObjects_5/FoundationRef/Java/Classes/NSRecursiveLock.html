<html>	<head>		<title>NSRecursiveLock (Java) </title>	</head>	<body bgcolor="#ffffff">		<!-- start of header -->		<!--#include virtual="/includes/framesetheader" -->		<!-- end of header --><!-- start of path --><table cellspacing=0 border=0 width=600 valign="left"><tr><td scope="row"><font face="Geneva,Helvetica,Arial" size="1"><b>PATH<spacer type="horizontal" size="5">&nbsp;</b><a href="../../../../index.html" target="_top">Documentation</a> <b>></b> <a href="../../../webobjects.html" target="_top">WebObjects</a></font></td></tr></table><br><!-- end of path -->		<a href="../FoundationTOC.html"><img src="../Art/up.gif" border="0" alt="Table of Contents"></a> <a name="CBEEJIJF"></a><br>		<h1><font color="#000066"><a name="//apple_ref/java/cl/NSRecursiveLock">NSRecursiveLock</a></font></h1>		<br>		<blockquote>			<dl>				<dt><b>Inherits from: </b>				<dd>Object 			</dl>		</blockquote>		<blockquote>			<dl>				<dt><b>Implements: </b>				<dd>NSLocking 			</dl>		</blockquote>		<blockquote>			<dl>				<dt><b>Package: </b>				<dd>com.webobjects.foundation 			</dl>		</blockquote>		<hr size="4">		<br>		<h2>Class Description</h2>		<hr alt="">		<p>NSRecursiveLock defines a lock that may be acquired multiple times by the same thread without causing a deadlock, a situation where a thread is permanently blocked waiting for itself to relinquish a lock. While the locking thread has one or more locks, all other threads are prevented from accessing the code protected by the lock. Here's an example where a recursive lock functions properly but other lock types would deadlock:</p>		<blockquote>			<pre>NSRecursiveLock theLock = new NSRecursiveLock();...theLock.lock();/* lengthy operations involving global data */theLock.lock();   /* possibly invoked in a subroutine */...theLock.unlock(); /* relinquishes most recent lock */...theLock.unlock(); /* relinquishes the first lock */</pre>		</blockquote>		<br>		<p>Unless <em>theLock</em> was an NSRecursiveLock, a deadlock condition would occur at the second <b>lock</b> message in the example above.</p>		<p>The NSRecursiveLock object keeps track of the recursion count: the number of lock requests that the owning thread has made and not unlocked. This is also the number of times unlock must be invoked to return the lock. To access the recursion count, use the <a href="#//apple_ref/java/instm/NSRecursiveLock/recursionCount">recursionCount</a> method.</p>		<p>The NSLock, NSMultiReaderLock, and NSRecursiveLock classes all adopt the NSLocking protocol and offer various additional features and performance characteristics. See the NSLock and NSMultiReaderLock class descriptions for more information.</p>		<br>		<br>		<br>		<h2>Method Types</h2>		<hr alt="">		<blockquote>			<dl>				<dt>Constructors 				<dl>					<dd><a href="#//apple_ref/java/instm/NSRecursiveLock/NSRecursiveLock">NSRecursiveLock</a> 				</dl>			</dl>			<dl>				<dt>Instance methods 				<dl>					<dd><a href="#//apple_ref/java/instm/NSRecursiveLock/lock">lock</a> 					<dd><a href="#//apple_ref/java/instm/NSRecursiveLock/tryLock">tryLock</a> 					<dd><a href="#//apple_ref/java/instm/NSRecursiveLock/lockBeforeDate">lockBeforeDate</a> 					<dd><a href="#//apple_ref/java/instm/NSRecursiveLock/recursionCount">recursionCount</a> 					<dd><a href="#//apple_ref/java/instm/NSRecursiveLock/toString">toString</a> 					<dd><a href="#//apple_ref/java/instm/NSRecursiveLock/unlock">unlock</a> 				</dl>			</dl>		</blockquote>		<br>		<br>		<h2>Constructors</h2>		<hr alt="">		<a name="CEBDJHCB"></a><br>		<h3><a name="//apple_ref/java/instm/NSRecursiveLock/NSRecursiveLock">NSRecursiveLock</a></h3>		<p><code>public <b>NSRecursiveLock</b>()</code></p>		Creates an NSRecursiveLock. 		<hr width="25%" align="LEFT">		<br>		<br>		<h2>Instance Methods</h2>		<hr alt="">		<a name="CEBFBGGJ"></a><br>		<h3><a name="//apple_ref/java/instm/NSRecursiveLock/lock">lock</a></h3>		<p><code>public void <b>lock</b>()</code></p>		Conformance to <a href="../Interfaces/NSLocking.html#CHCJAGIE">NSLocking</a>. See the method description of <a href="#//apple_ref/java/instm/NSRecursiveLock/lock">lock</a> in the interface description for NSLocking. If the current thread already owns the lock, this method increments the recursion count. 		<hr width="25%" align="LEFT">		<a name="lockBeforeDate_NSRecursiveLock"></a><br>		<h3><a name="//apple_ref/java/instm/NSRecursiveLock/lockBeforeDate">lockBeforeDate</a></h3>		<p><code>public boolean <b>lockBeforeDate</b>(NSTimestamp <em>timestamp</em>)</code></p>		This method is deprecated. Use <code>tryLock(NSTimestamp timestamp)</code> instead. 		<hr width="25%" align="LEFT">		<a name="recursionCount_NSRecursiveLock"></a><br>		<h3><a name="//apple_ref/java/instm/NSRecursiveLock/recursionCount">recursionCount</a></h3>		<p><code>public synchronized long <b>recursionCount</b>()</code></p>		Returns the receiver's recursion count (the number of unlocks needed to return the lock) if the current thread owns the lock. If the current thread is not the owner of the lock, returns zero. 		<hr width="25%" align="LEFT">		<a name="toString_NSRecursiveLock"></a><br>		<h3><a name="//apple_ref/java/instm/NSRecursiveLock/toString">toString</a></h3>		<p><code>public String <b>toString</b>()</code></p>		Returns a string representation of the receiver that includes the thread that owns it and its recursion count. 		<hr width="25%" align="LEFT">		<a name="lock_NSRecursiveLock"></a><br>		<h3><a name="//apple_ref/java/instm/NSRecursiveLock/tryLock">tryLock</a></h3>		<p><code>public boolean <b>tryLock</b>()</code></p>		Attempts to acquire a lock. If the lock is not already taken by another thread, acquires the lock, sets the recursion count to 1 and returns <code>true</code>. If the current thread owns the lock, <b></b>increments the recursion count and returns with a value of <code>true</code>. If the another thread owns the lock, returns <code>false</code> immediately. 		<p><code>public boolean <b>tryLock</b>(long <em>msec</em>)</code></p>		Attempts to acquire a lock for <em>msec</em> milliseconds. If the current thread owns the lock, increments the recursion count and returns <code>true</code>. Otherwise, the thread is blocked until the receiver acquires the lock or <em>msec</em> milliseconds have passed. Returns <code>true</code> if the lock is acquired within this time limit. Returns <code>false</code> if the time limit expires before a lock can be acquired. 		<p><code>public boolean <b>tryLock</b>(NSTimestamp <em>timestamp</em>)</code></p>		Attempts to acquire a lock until the time specified by <em>timestamp</em>. If the current thread owns the lock, increments the recursion count and returns <code>true</code>. Otherwise, the thread is blocked until the receiver acquires the lock or <em>timestamp</em> is reached. Returns <code>true</code> if the lock is acquired within this time limit. Returns <code>false</code> if the time limit expires before a lock can be acquired. 		<hr width="25%" align="LEFT">		<a name="unlock_NSRecursiveLock"></a><br>		<h3><a name="//apple_ref/java/instm/NSRecursiveLock/unlock">unlock</a></h3>		<p><code>public synchronized void <b>unlock</b>()</code></p>		<p><code>public synchronized void <b>unlock</b>(long <em>levels</em>)</code></p>		Decrements the recursion count by <em>levels</em> (decrements the recursion count by one in the no-argument version). If the resulting recursion level is zero, returns the lock. This method throws an Error if the thread that invokes it is not the lock's owner. Invoking this method when the lock count is zero does nothing. 		<hr width="25%" align="LEFT">		<br>		<p>&copy; 2001 Apple Computer, Inc. (Last Published April 17, 2001)</p>		<br>		<a href="../FoundationTOC.html"><img src="../Art/up.gif" border="0" alt="Table of Contents"></a> <!-- start of footer -->		<!--#include virtual="/includes/framesetfooter" -->		<!-- end of footer -->	</body></html>