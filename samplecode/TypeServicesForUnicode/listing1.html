<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>TypeServicesForUnicode - /HIATSUIView.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/Carbon/index.html">Carbon</a> &gt; <a href="../../samplecode/Carbon/idxHumanInterfaceToolbox-date.html">Human Interface Toolbox</a> &gt; <A HREF="javascript:location.replace('index.html');">TypeServicesForUnicode</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">TypeServicesForUnicode</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/HIATSUIView.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/HIATSUIView.c</option>
<option value="listing2.html">/HIATSUIView.h</option>
<option value="listing3.html">/main.c</option>
<option value="listing4.html">/More ATSUI/MoreATSUnicode.cp</option>
<option value="listing5.html">/More ATSUI/MoreATSUnicode.h</option>
<option value="listing6.html">/More ATSUI/MoreATSUnicodeTextBox.cp</option>
<option value="listing7.html">/TypeServicesForUnicode.c</option>
<option value="listing8.html">/TypeServicesForUnicode.h</option></select>
				</p>
				</form>
				<p><strong><a href="TypeServicesForUnicode.zip">Download Sample</a></strong> (&#147;TypeServicesForUnicode.zip&#148;, 1.14M)<BR>
<strong><a href="TypeServicesForUnicode.dmg">Download Sample</a></strong> (&#147;TypeServicesForUnicode.dmg&#148;, 1.44M)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*
*  File:    HIATSUIView.c of TypeServicesForUnicode
* 
*  Contains:  A ready-to-use HIATSUIView which is a custom HIView
*
*          The HIATSUIView handles:
*            - getting and setting the text content
*            - getting and setting the styles
*            - getting and setting the selection
*            - various features like colors, wrapping, framing, justification, and transparency
*            - copying and dragging
*            - scrolling and auto-scrolling
*            - handling of  double-clicks, triple-clicks, quadruple=clicks,
*                      click-and-drag, shift-clicking
*
*  Version:  1.0
* 
*  Created:  11/5/04
*
*  Disclaimer:  IMPORTANT:  This Apple software is supplied to you by Apple Computer, Inc.
*        (&quot;Apple&quot;) in consideration of your agreement to the following terms, and your
*        use, installation, modification or redistribution of this Apple software
*        constitutes acceptance of these terms.  If you do not agree with these terms,
*        please do not use, install, modify or redistribute this Apple software.
*
*        In consideration of your agreement to abide by the following terms, and subject
*        to these terms, Apple grants you a personal, non-exclusive license, under Apple&Otilde;s
*        copyrights in this original Apple software (the &quot;Apple Software&quot;), to use,
*        reproduce, modify and redistribute the Apple Software, with or without
*        modifications, in source and/or binary forms; provided that if you redistribute
*        the Apple Software in its entirety and without modifications, you must retain
*        this notice and the following text and disclaimers in all such redistributions of
*        the Apple Software.  Neither the name, trademarks, service marks or logos of
*        Apple Computer, Inc. may be used to endorse or promote products derived from the
*        Apple Software without specific prior written permission from Apple.  Except as
*        expressly stated in this notice, no other rights or licenses, express or implied,
*        are granted by Apple herein, including but not limited to any patent rights that
*        may be infringed by your derivative works or by other works in which the Apple
*        Software may be incorporated.
*
*        The Apple Software is provided by Apple on an &quot;AS IS&quot; basis.  APPLE MAKES NO
*        WARRANTIES, EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION THE IMPLIED
*        WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY AND FITNESS FOR A PARTICULAR
*        PURPOSE, REGARDING THE APPLE SOFTWARE OR ITS USE AND OPERATION ALONE OR IN
*        COMBINATION WITH YOUR PRODUCTS.
*
*        IN NO EVENT SHALL APPLE BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL OR
*        CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
*        GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
*        ARISING IN ANY WAY OUT OF THE USE, REPRODUCTION, MODIFICATION AND/OR DISTRIBUTION
*        OF THE APPLE SOFTWARE, HOWEVER CAUSED AND WHETHER UNDER THEORY OF CONTRACT, TORT
*        (INCLUDING NEGLIGENCE), STRICT LIABILITY OR OTHERWISE, EVEN IF APPLE HAS BEEN
*        ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*
*  Copyright:  Copyright &copy; 2005 Apple Computer, Inc, All Rights Reserved
*/
//****************************************************
#pragma mark * compilation directives *

//****************************************************
#pragma mark -
#pragma mark * includes &amp; imports *

#include &quot;HIATSUIView.h&quot;
#include &quot;MoreATSUnicode.h&quot;

//****************************************************
#pragma mark -
#pragma mark * typedef's, struct's, enums, defines, etc. *

#define kXMargin IntToFixed(3)

//****************************************************
#pragma mark -
#pragma mark * local (static) function prototypes *

static pascal OSStatus Internal_HIATSUIViewHandler(EventHandlerCallRef inHandlerCallRef, EventRef inEvent, void *inUserData);
static void Internal_HIATSUIViewFreeData(HIATSUIViewData * myData);
static OSStatus Internal_HIATSUIViewPointToOffset(HIATSUIViewData * myData, HIPoint hiPoint, UniCharArrayOffset * prOffset, ItemCount * lineClicked, Boolean * isLeading);
static OSStatus Internal_HIATSUIViewDetermineSelection(HIATSUIViewData * myData, KindOfClick clickKind, Boolean isLeading, Boolean extend, ItemCount lineClicked, UniCharArrayOffset anchor1, UniCharArrayOffset anchor2, UniCharArrayOffset prOffset, UniCharArrayOffset * newStart, UniCharArrayOffset * newEnd);
static HIPoint Internal_HIATSUIViewSanityCheck(HIATSUIViewData * myData, HIPoint where);
static OSStatus Internal_HIATSUIViewMakeCGImage(HIATSUIViewData * myData, UniCharArrayOffset start, UniCharArrayOffset end, CGImageRef *image, CGContextRef *outContext, HIPoint * offset);
static void Internal_HIATSUIViewFreeFunction(void *clientData, const void *data, size_t size);
static void Internal_HIATSUIViewDragSelection(HIATSUIViewData * myData, UniCharArrayOffset anchor1, UniCharArrayOffset anchor2, HIPoint mouseLoc);

//****************************************************
#pragma mark -
#pragma mark * exported globals *

//****************************************************
#pragma mark -
#pragma mark * local (static) globals *

//****************************************************
#pragma mark -
#pragma mark * exported function implementations *

/*****************************************************
*
* HICreateATSUIView(boundsRect, outHIATSUIView) 
*
* Purpose:  Create a HIATSUIView with minimum parameter list,
*           the HIATSUIView can be set up later using other APIs
*
* Inputs:   boundsRect          - the HIRect for our view
*           outHIATSUIView      - returning the created HIView
*
* Returns:  OSStatus            - error code (0 == no error) 
*/
OSStatus HICreateATSUIView(
    const HIRect * boundsRect,          // can be NULL
    HIViewRef * outHIATSUIView)        // cannot be NULL
  {
  OSStatus status;
  HIObjectRef hiObject;
  
  require_action(outHIATSUIView != NULL, exitCreation, status = paramErr);
  *outHIATSUIView = NULL;

  // create the view
  status = HIObjectCreate(GetHIATSUIViewClass(), 0, &amp;hiObject);
  require_noerr(status, exitCreation);
    
  // position the view
  if (boundsRect != NULL)
    {
    status = HIViewSetFrame((HIViewRef)hiObject, boundsRect);
    require_noerr(status, exitCreation);
    }

  // return the view
  *outHIATSUIView = (HIViewRef)hiObject;

exitCreation:
  return status;
  }   // HICreateATSUIView

/*****************************************************
*
* HICreateATSUIViewWithText(boundsRect, theCFString, x, y, numberOfRuns, runLengths, styles, withFrame, wrap, textSize, outHIATSUIView) 
*
* Purpose:  Create a HIATSUIView with full parameter list,
*
* Inputs:   boundsRect          - the HIRect for our view
*           theCFString         - the text
*           x                   - x location, if 0 then a default margin of 3 pixels is used
*           y                   - y location, if 0 then the text will be positionned automatically
*           numberOfRuns        - number of styled runs, if 0 then the following parameters runLengths and styles should both be NULL
*           runLengths          - array containing the length of each run
*           styles              - array containing the style of each run
*           withFrame           - if true then a frawe will be drawn around our bounds
*           wrap                - if true then the text wraps in our bounds, else the width field of the following parameter textSize must be set to non-zero
*           textSize            - if previous parameter is false, then
*                                    on input the width field must be set with the non-zero value of the desired width,
*                                    on output the height field will be set with the value computed by HIATSUIViewBreakLines 
*           outHIATSUIView      - returning the created HIView
*
* Returns:  OSStatus            - error code (0 == no error) 
*/
OSStatus HICreateATSUIViewWithText(
    const HIRect * boundsRect,          // can be NULL
    CFStringRef theCFString,
    Fixed x, Fixed y,                // can be 0
    ItemCount numberOfRuns,            // can be 0
    UniCharCount * runLengths,          // can be NULL
    ATSUStyle * styles,              // can be NULL
    Boolean withFrame,
    Boolean wrap,
    HISize * textSize,              // can be NULL
    HIViewRef * outHIATSUIView)        // can be NULL
  {
  OSStatus status = noErr;
  HIObjectRef hiObject = NULL;
  EventRef theInitializeEvent = NULL;

  require_action(wrap || ( textSize-&gt;width != 0 ), exitCreation, status = paramErr);

  // create the Initialize event
  status = CreateEvent(NULL, kEventClassHIObject, kEventHIObjectInitialize, GetCurrentEventTime(), kEventAttributeUserEvent, &amp;theInitializeEvent);
  require_noerr(status, exitCreation);

  // set all the parameters of the Initialize event
  if (boundsRect != NULL)
    SetEventParameter(theInitializeEvent, kControlCollectionTagBounds, typeHIRect,      sizeof(HIRect),          boundsRect);
  SetEventParameter(  theInitializeEvent, kATSUIViewTextTag,           typeCFStringRef, sizeof(CFStringRef),     &amp;theCFString);
  SetEventParameter(  theInitializeEvent, kATSUIViewXLocTag,           typeUInt32,      sizeof(Fixed),           &amp;x);
  SetEventParameter(  theInitializeEvent, kATSUIViewYLocTag,           typeUInt32,      sizeof(Fixed),           &amp;y);
  SetEventParameter(  theInitializeEvent, kATSUIViewItemCountTag,      typeUInt32,      sizeof(ItemCount),       &amp;numberOfRuns);
  if (runLengths != NULL)
    SetEventParameter(theInitializeEvent, kATSUIViewRunLengthsTag,     typeVoidPtr,     sizeof(UniCharCount *), &amp;runLengths);
  if (styles != NULL)
    SetEventParameter(theInitializeEvent, kATSUIViewStylesTag,         typeVoidPtr,     sizeof(ATSUStyle *),    &amp;styles);
  SetEventParameter(  theInitializeEvent, kATSUIViewFrameTag,          typeBoolean,     sizeof(Boolean),         &amp;withFrame);
  SetEventParameter(  theInitializeEvent, kATSUIViewWrapTag,           typeBoolean,     sizeof(Boolean),         &amp;wrap);
  if (textSize != NULL)
    SetEventParameter(theInitializeEvent, kATSUIViewSizeTag,           typeHISize,      sizeof(HISize),          textSize);

  // create the view with the Initialize event
  status = HIObjectCreate(GetHIATSUIViewClass(), theInitializeEvent, &amp;hiObject);
  require_noerr(status, exitCreation);
  
  // returning the text height
  // HIATSUIViewBreakLines will be called by HIATSUIViewSetText called from the kEventHIObjectInitialize handler
  if (textSize != NULL)
    *textSize = HIATSUIViewGetTextSize((HIViewRef)hiObject);
  
exitCreation:

  // let's cleanup
  if (theInitializeEvent != NULL) ReleaseEvent(theInitializeEvent);
  if (outHIATSUIView != NULL)
    *outHIATSUIView = (HIViewRef)hiObject;

  return status;
  }   // HICreateATSUIViewWithText

/*****************************************************
*
* GetHIATSUIViewClass() 
*
* Purpose:  Registers our custom HIATSUIView view class and installs the appropriate handlers
*
* Inputs:   none
*
* Returns:  our class ID as a CFStringRef
*/
CFStringRef GetHIATSUIViewClass(void)
  {
  // following code is pretty much boiler plate.
  static HIObjectClassRef  theClass;
  
  if (theClass == NULL)
    {
    static EventTypeSpec kFactoryEvents[] =
      {
        { kEventClassHIObject, kEventHIObjectConstruct },
        { kEventClassHIObject, kEventHIObjectInitialize },
        { kEventClassHIObject, kEventHIObjectDestruct },
        { kEventClassScrollable, kEventScrollableGetInfo },
        { kEventClassScrollable, kEventScrollableScrollTo },
        { kEventClassControl, kEventControlDraw },
        { kEventClassControl, kEventControlClick },
        { kEventClassControl, kEventControlHitTest },
        { kEventClassControl, kEventControlTrack },
        { kEventClassControl, kEventControlBoundsChanged }
      };
    
    HIObjectRegisterSubclass(kHIATSUIViewClass, kHIViewClassID, 0, Internal_HIATSUIViewHandler,
                  GetEventTypeCount(kFactoryEvents), kFactoryEvents, 0, &amp;theClass);
    }
  
  return kHIATSUIViewClass;
  }   // GetHIATSUIViewClass

/*****************************************************
*
* HIATSUIViewSetText(theHIATSUIView, theCFString, numberOfRuns, runLengths, styles) 
*
* Purpose:  Sets the text and styles of the ATSUI object
*
* Inputs:   theHIATSUIView      - the view
*           theCFString         - the text
*           numberOfRuns        - number of styled runs, if 0 then the following parameters runLengths and styles should both be NULL
*           runLengths          - array containing the length of each run
*           styles              - array containing the style of each run
*
* Returns:  OSStatus            - error code (0 == no error) 
*/
OSStatus HIATSUIViewSetText(HIViewRef theHIATSUIView, CFStringRef theCFString, ItemCount numberOfRuns, UniCharCount * runLengths, ATSUStyle * styles)
  {
  OSStatus status = noErr;
  
  // accessing our view's private data
  HIATSUIViewData* myData = (HIATSUIViewData*)HIObjectDynamicCast((HIObjectRef)theHIATSUIView, kHIATSUIViewClass);
  require(myData != NULL, CantGetData);

  // First let's get rid of any text and styles if already present
  Internal_HIATSUIViewFreeData(myData);

  // getting the characters
  myData-&gt;uTextLength = CFStringGetLength(theCFString);
  myData-&gt;theUnicodeText = (UniChar *)calloc(myData-&gt;uTextLength, sizeof(UniChar));
  require(myData-&gt;theUnicodeText != NULL, CantAllocateMemory);
  CFStringGetCharacters(theCFString, CFRangeMake(0, myData-&gt;uTextLength), myData-&gt;theUnicodeText);

  // If no style information received then we set at least 1 style
  myData-&gt;numberOfRuns = (numberOfRuns == 0) ? 1 : numberOfRuns;

  // we allocate the runLengths array and set it to either the received parameter of to end of text if none
  myData-&gt;runLengths = (UniCharCount *)calloc(myData-&gt;numberOfRuns, sizeof(UniCharCount));
  require(myData-&gt;runLengths != NULL, CantAllocateMemory);
  if (runLengths == NULL) myData-&gt;runLengths[0] = myData-&gt;uTextLength;
  else memcpy(myData-&gt;runLengths, runLengths, myData-&gt;numberOfRuns * sizeof(UniCharCount));

  // and do the same for the styles using the default style when no parameter received
  myData-&gt;styles = (ATSUStyle *)calloc(myData-&gt;numberOfRuns, sizeof(ATSUStyle));
  require(myData-&gt;styles != NULL, CantAllocateMemory);
  if (styles == NULL)
    {
    ATSUStyle tempS;
    status = ATSUCreateStyle(&amp;tempS);
    require_noerr(status, CantCreateStyle);
    myData-&gt;styles[0] = tempS;
    }
  else memcpy(myData-&gt;styles, styles, myData-&gt;numberOfRuns * sizeof(ATSUStyle));

  // and we create the text layout
  ATSUTextLayout tempTL;
  status = ATSUCreateTextLayoutWithTextPtr(myData-&gt;theUnicodeText, 0, myData-&gt;uTextLength, myData-&gt;uTextLength, myData-&gt;numberOfRuns, myData-&gt;runLengths, myData-&gt;styles, &amp;tempTL);
  require_noerr(status, CantCreateTextLayout);
  myData-&gt;textLayout = tempTL;

  // don't justify the last line
  status = atsuSetLayoutOptions(myData-&gt;textLayout, kATSLineLastNoJustification);
  require_noerr(status, CantCreateTextLayout);
  
  // let's ATSUI deal with characters not-in-our-specified-font
  status = ATSUSetTransientFontMatching(myData-&gt;textLayout, true);
  
  // we changed the text so we need to break it in lines
  HIATSUIViewBreakLines(theHIATSUIView);

CantCreateTextLayout:
CantCreateStyle:
CantAllocateMemory:
CantGetData:
  return status;
  }   // HIATSUIViewSetText

/*****************************************************
*
* HIATSUIViewBreakLines(theHIATSUIView) 
*
* Purpose:  Breaks the text of the ATSUI object in lines according to the desired width
*
* Inputs:   theHIATSUIView      - the view
*
* Returns:  OSStatus            - error code (0 == no error) 
*/
OSStatus HIATSUIViewBreakLines(HIViewRef theHIATSUIView)
  {
  OSStatus status = noErr;
  
  // accessing our view's private data
  HIATSUIViewData* myData = (HIATSUIViewData*)HIObjectDynamicCast((HIObjectRef)theHIATSUIView, kHIATSUIViewClass);
  require(myData != NULL, CantGetData);

  if (myData-&gt;uTextLength == 0) return status; // no text to break, we are probably in construction mode
  
  // Let's free any already allocated measurement-related data
  if (myData-&gt;endOfLines != NULL) { free(myData-&gt;endOfLines); myData-&gt;endOfLines = NULL; }
  if (myData-&gt;lineHeights != NULL) { free(myData-&gt;lineHeights); myData-&gt;lineHeights = NULL; }
  if (myData-&gt;descents != NULL) { free(myData-&gt;descents); myData-&gt;descents = NULL; }
  
  // Let's clear any previous soft breaks
  status = ATSUClearSoftLineBreaks(myData-&gt;textLayout, kATSUFromTextBeginning, kATSUToTextEnd);
  require_noerr(status, CantClearSoftBreakLines);

  // determining which width we want
  ATSUTextMeasurement lineWidth;
  if (myData-&gt;wrap)
    {
    HIRect bounds;
    HIViewGetBounds(theHIATSUIView, &amp;bounds);
    lineWidth = FloatToFixed(bounds.size.width);
    if (myData-&gt;xLocation == 0) lineWidth -= 2 * kXMargin;
    else lineWidth -= ( myData-&gt;xLocation + kXMargin );
    }
  else lineWidth = FloatToFixed(myData-&gt;textSize.width);

  // allocating our arrays
  UniCharArrayOffset offset = 0, endLineOffset;
  ItemCount nbLines = 0;
  ATSUTextMeasurement ascent, descent;
  ItemCount nbAllocated = 200;
  ATSUTextMeasurement * lineHeights = (ATSUTextMeasurement *)calloc(nbAllocated, sizeof(ATSUTextMeasurement));
  require(lineHeights != NULL, CantAllocateMemory);
  ATSUTextMeasurement * descents = (ATSUTextMeasurement *)calloc(nbAllocated, sizeof(ATSUTextMeasurement));
  require(descents != NULL, CantAllocateMemory);
          
  //  line width must be set for flush and justification to work
  status = atsuSetLayoutWidth(myData-&gt;textLayout, lineWidth);        
  require_noerr(status, CantSetLineWidth);
  
  // measure and break each line, thus setting a soft line break that we'll grab back later
  while (offset &lt; myData-&gt;uTextLength)
    {
    status = ATSUBreakLine(myData-&gt;textLayout, offset, lineWidth, true, &amp;endLineOffset);
    if (status == kATSULineBreakInWord) status = noErr;
    require_noerr(status, CantBreakLines);
    
    // it could be that the line width is so narrow that even a single character won't fit.
    // in that case, ATSUBreakLine returns noErr but endLineOffset returns equal to offset.
    // if that's the case, let's break out...
    if (endLineOffset == offset) break;
    
    // let's get ascent &amp; descent to calculate the line height.
    status = ATSUGetUnjustifiedBounds(myData-&gt;textLayout, offset, endLineOffset-offset, NULL, NULL, &amp;ascent, &amp;descent);
    require_noerr(status, CantMeasureText);

    // reallocating our arrays if they are too small
    if (nbAllocated == nbLines)
      {
      nbAllocated += 200;
      lineHeights = (ATSUTextMeasurement *)realloc(lineHeights, nbAllocated * sizeof(ATSUTextMeasurement));
      require(lineHeights != NULL, CantAllocateMemory);
      descents = (ATSUTextMeasurement *)realloc(descents, nbAllocated * sizeof(ATSUTextMeasurement));
      require(descents != NULL, CantAllocateMemory);
      }
    lineHeights[nbLines] = ascent + descent;
    if (nbLines &gt; 0) lineHeights[nbLines] += lineHeights[nbLines-1];
    descents[nbLines] = descent;
    
    // Sanity Check, we are operating in the range 0..32767 in Fixed coordinates
    // if we determine that we overflowed, we truncate the text to the last safe offset
    if (lineHeights[nbLines] &lt; 0)
      {
      myData-&gt;uTextLength = offset; // we stop immediately
      debug_string(&quot;Total text height is bigger than 32767!&quot;); // and alert both the developer and the user
      DialogRef theAlert;
      CreateStandardAlert(kAlertStopAlert, CFSTR(&quot;Total text height is bigger than 32767!&quot;), NULL, NULL, &amp;theAlert);
      RunStandardAlert(theAlert, NULL, NULL);
      }
    else
      {
      offset = endLineOffset;
      nbLines++;
      }
    }
  
  // let's grab back all the soft line breaks in the array we'll keep around
  UniCharArrayOffset * endOfLines = (UniCharArrayOffset *)calloc(nbLines, sizeof(UniCharArrayOffset));
  require(endOfLines != NULL, CantAllocateMemory);
  ItemCount softBreakCount;
  status = ATSUGetSoftLineBreaks(myData-&gt;textLayout, 0, myData-&gt;uTextLength, nbLines, endOfLines, &amp;softBreakCount);

  // the number of softbreaks should always be one less than the number of lines
  // since ATSUBreakLine does not insert a softbreak at the end of the text.
  require( ((status == noErr) &amp;&amp; (softBreakCount == nbLines - 1)), CantSoftBreakLines);
  
  // so let's set the last entry of the array
  endOfLines[softBreakCount] = myData-&gt;uTextLength;

  myData-&gt;endOfLines = endOfLines;
  myData-&gt;lineHeights = lineHeights;
  myData-&gt;descents = descents;
  myData-&gt;numberOfLines = nbLines;

  // for Scrolling
  myData-&gt;textSize.width = FixedToFloat(lineWidth);
  myData-&gt;textSize.height = FixedToFloat(lineHeights[nbLines-1]);

CantSoftBreakLines:
CantMeasureText:
CantBreakLines:
CantSetLineWidth:
CantAllocateMemory:
CantClearSoftBreakLines:
CantGetData:
  return status;
  }   // HIATSUIViewBreakLines

/*****************************************************
*
* HIATSUIViewGetTextLayout(theHIATSUIView) 
*
* Purpose:  Accessor, returns the text layout of the ATSUI object
*
* Inputs:   theHIATSUIView      - the view
*
* Returns:  the text layout as an ATSUTextLayout or NULL if something went wrong
*/
ATSUTextLayout HIATSUIViewGetTextLayout(HIViewRef theHIATSUIView)
  {
  HIATSUIViewData* myData = (HIATSUIViewData*)HIObjectDynamicCast((HIObjectRef)theHIATSUIView, kHIATSUIViewClass);
  return (myData != NULL) ? myData-&gt;textLayout : NULL;
  }   // HIATSUIViewGetTextLayout

/*****************************************************
*
* HIATSUIViewGetStyles(theHIATSUIView, numberOfRuns)
*
* Purpose:  Accessor, returns the styles array of the ATSUI object
*
* Inputs:   theHIATSUIView      - the view
*        numberOfRuns        - returns the number of styles in the array or 0 if something went wrong
*
* Returns:  the styles array or NULL if something went wrong
*/
ATSUStyle * HIATSUIViewGetStyles(HIViewRef theHIATSUIView, ItemCount * numberOfRuns)
  {
  // accessing our view's private data
  HIATSUIViewData* myData = (HIATSUIViewData*)HIObjectDynamicCast((HIObjectRef)theHIATSUIView, kHIATSUIViewClass);

  if (myData == NULL)
    {
    numberOfRuns = 0;
    return NULL;
    }

  *numberOfRuns = myData-&gt;numberOfRuns;
  return myData-&gt;styles;
  }   // HIATSUIViewGetStyles

/*****************************************************
*
* HIATSUIViewSetPosition(theHIATSUIView, x, y)
*
* Purpose:  Sets the x, y position of the text layout in the view local coordinate system
*        Will rebreak the text in lines if needed
*
* Inputs:   theHIATSUIView      - the view
*        x                   - x coordinate in Fixed format
*        y                   - y coordinate in Fixed format
*
* Returns:  OSStatus      - error code (0 == no error) 
*/
OSStatus HIATSUIViewSetPosition(HIViewRef theHIATSUIView, Fixed x, Fixed y)
  {
  OSStatus status = noErr;
  
  // accessing our view's private data
  HIATSUIViewData* myData = (HIATSUIViewData*)HIObjectDynamicCast((HIObjectRef)theHIATSUIView, kHIATSUIViewClass);
  require(myData != NULL, CantGetData);

  // we changed the position so we need to break the text in lines again if we wrap
  Boolean needToBreak = (myData-&gt;wrap) &amp;&amp; (myData-&gt;xLocation != x);

  myData-&gt;xLocation = x;
  myData-&gt;yLocation = y;
  
  if (needToBreak)
    HIATSUIViewBreakLines(theHIATSUIView);

CantGetData:
  return status;
  }   // HIATSUIViewSetPosition

/*****************************************************
*
* HIATSUIViewGetSelection(theHIATSUIView, start, end)
*
* Purpose:  Accessor, returns the range of the current selection
*
* Inputs:   theHIATSUIView      - the view
*        start               - returns the beginning of the selection
*        end                 - returns the end of the selection
*
* Returns:  OSStatus      - error code (0 == no error) 
*/
OSStatus HIATSUIViewGetSelection(HIViewRef theHIATSUIView, UniCharArrayOffset * start, UniCharArrayOffset * end)
  {
  OSStatus status = noErr;
  
  // accessing our view's private data
  HIATSUIViewData* myData = (HIATSUIViewData*)HIObjectDynamicCast((HIObjectRef)theHIATSUIView, kHIATSUIViewClass);
  require(myData != NULL, CantGetData);

  *start = myData-&gt;selectionStart;
  *end = myData-&gt;selectionEnd;

CantGetData:
  return status;
  }   // HIATSUIViewGetSelection

/*****************************************************
*
* HIATSUIViewGetTextAndStyle(theHIATSUIView, start, end, oTextString, oStyleBuffer, oStyleBufferSize)
*
* Purpose:  Returns the text and style informations in a format appropriate for later pasteboard handling
*
* Inputs:   theHIATSUIView      - the view
*        start               - the beginning of the selection
*        end                 - the end of the selection
*        oTextString         - returns the text as a CFString
*        oStyleBuffer        - returns the styles as a flattened block of bytes
*        oStyleBufferSize    - returns the size of that block of bytes
*
* Returns:  OSStatus      - error code (0 == no error) 
*/
OSStatus HIATSUIViewGetTextAndStyle(HIViewRef theHIATSUIView, UniCharArrayOffset start, UniCharArrayOffset end, CFStringRef * oTextString, void ** oStyleBuffer, ByteCount * oStyleBufferSize)
  {
  OSStatus status = noErr;
  CFStringRef textString = NULL;
  void * styleBuffer = NULL;
  ByteCount styleBufferSize = 0;
  ATSUStyleRunInfo * runInfoArray = NULL;
  ATSUStyle * styleArray = NULL;

  require_action(oTextString != NULL, ExitGetTextAndStyle, status = paramErr);
  require_action(oStyleBuffer != NULL, ExitGetTextAndStyle, status = paramErr);
  require_action(oStyleBufferSize != NULL, ExitGetTextAndStyle, status = paramErr);

  // accessing our view's private data
  HIATSUIViewData* myData = (HIATSUIViewData*)HIObjectDynamicCast((HIObjectRef)theHIATSUIView, kHIATSUIViewClass);
  require(myData != NULL, CantGetData);

  // getting the text (that's the easy part...!)
  textString = CFStringCreateWithCharacters(NULL, &amp;myData-&gt;theUnicodeText[start], end - start);
  require(textString != NULL, CantGetText);
  
  // arrays are allocated at maximum size
  runInfoArray = (ATSUStyleRunInfo * )malloc(myData-&gt;numberOfRuns * sizeof(ATSUStyleRunInfo));
  styleArray = (ATSUStyle * )malloc(myData-&gt;numberOfRuns * sizeof(ATSUStyle));

  // setting the content of our arrays, read QD/ATSUnicodeFlattening.h for more details
  ItemCount inr, selnr = 0;
  UniCharArrayOffset txtstart = 0, selstart = start;
  for ( inr = 0; inr &lt; myData-&gt;numberOfRuns; inr++)
    {
    if ((selstart &gt;= txtstart) &amp;&amp; (selstart &lt; txtstart + myData-&gt;runLengths[inr]))
      {
      UniCharArrayOffset minLen;
      if (txtstart + myData-&gt;runLengths[inr] &gt; end)
        minLen = end;
      else
        minLen = txtstart + myData-&gt;runLengths[inr];
      runInfoArray[selnr].runLength = minLen - selstart;
      runInfoArray[selnr].styleObjectIndex = selnr;
      styleArray[selnr] = myData-&gt;styles[inr];
      selstart += runInfoArray[selnr].runLength;
      selnr++;
      if (selstart &gt; end) break;
      }
    txtstart += myData-&gt;runLengths[inr];
    }

  // calling ATSUFlattenStyleRunsToStream a first time to get the size
  status = ATSUFlattenStyleRunsToStream(  kATSUDataStreamUnicodeStyledText,
                            kATSUFlattenOptionNoOptionsMask,
                            selnr,
                            runInfoArray,
                            selnr,
                            styleArray,
                            0,
                            NULL,
                            &amp;styleBufferSize);
  require_noerr(status, CantFlatten);
  
  // allocating our style buffer with that size
  styleBuffer = malloc(styleBufferSize);
  require(styleBuffer != NULL, CantFlatten);

  // calling ATSUFlattenStyleRunsToStream a second time to set the content of the style buffer
  status = ATSUFlattenStyleRunsToStream(  kATSUDataStreamUnicodeStyledText,
                            kATSUFlattenOptionNoOptionsMask,
                            selnr,
                            runInfoArray,
                            selnr,
                            styleArray,
                            styleBufferSize,
                            styleBuffer,
                            NULL);
  require_noerr(status, CantFlatten);

CantFlatten:
CantGetText:
CantGetData:

  if (runInfoArray != NULL) free(runInfoArray);
  if (styleArray != NULL) free(styleArray);
  
  *oTextString = textString;
  *oStyleBuffer = styleBuffer;
  *oStyleBufferSize = styleBufferSize;

ExitGetTextAndStyle:

  return status;
  }   // HIATSUIViewGetTextAndStyle

/*****************************************************
*
* HIATSUIViewPutContentInPasteboard(theHIATSUIView, thePasteboard, start, end)
*
* Purpose:  Puts the content of the selection in the pasteboard which can be either the clipboard or a temporary drag
*
* Inputs:   theHIATSUIView      - the view
*        thePasteboard       - the pasteboard in which we add the data
*        start               - the beginning of the selection
*        end                 - the end of the selection
*
* Returns:  OSStatus      - error code (0 == no error) 
*/
OSStatus HIATSUIViewPutContentInPasteboard(HIViewRef theHIATSUIView, PasteboardRef thePasteboard, UniCharArrayOffset start, UniCharArrayOffset end)
  {
  OSStatus status = noErr;
  CFStringRef textString = NULL;
  void * styleBuffer = NULL;
  ByteCount styleBufferSize = 0;
  CFDataRef textData = NULL;
  UniChar * textBuffer = NULL;
  CFDataRef styleData = NULL;
  CFStringRef ustlUTString = NULL;

  // Sanity Check
  if (start == end) goto EndPutContent;

  // accessing our view's private data
  HIATSUIViewData* myData = (HIATSUIViewData*)HIObjectDynamicCast((HIObjectRef)theHIATSUIView, kHIATSUIViewClass);
  require(myData != NULL, CantGetData);
  
  // clearing the pasteboard first
  status = PasteboardClear(thePasteboard);
  require_noerr(status, CantClearPasteboard);

  // then synchronizing it (read the documentation for more details)
  PasteboardSyncFlags syncFlags = PasteboardSynchronize(thePasteboard);
  require_action( ! (syncFlags &amp; kPasteboardModified), PasteboardNotSynchedAfterClear, status = badPasteboardSyncErr);
  require_action( syncFlags &amp; kPasteboardClientIsOwner, ClientNotPasteboardOwner, status = notPasteboardOwnerErr);

  // getting our text and style information
  status = HIATSUIViewGetTextAndStyle(theHIATSUIView, start, end, &amp;textString, &amp;styleBuffer, &amp;styleBufferSize);
  require_noerr(status, CantGetTextAndStyle);
  
  // setting our text in a CFData container
  CFIndex len = CFStringGetLength(textString);
  
  textBuffer = (UniChar *)malloc(len * sizeof(UniChar));
  require(textBuffer != NULL, CantCreateTextData);
  
  CFStringGetCharacters(textString, CFRangeMake(0, len), textBuffer);
  
  textData = CFDataCreate(NULL, (UInt8 *)textBuffer, len * sizeof(UniChar));
  require(textData != NULL, CantCreateTextData);
  
  // adding that CFData in the pasteboard using the adequate public UTI
  status = PasteboardPutItemFlavor(thePasteboard, (PasteboardItemID)1, CFSTR(&quot;public.utf16-plain-text&quot;), textData, 0);
  require_noerr(status, CantPutItemFlavor);
  
  // setting our styles in a CFData container
  styleData = CFDataCreate(NULL, styleBuffer, styleBufferSize);
  require(styleData != NULL, CantCreateStyleData);
  
  // there is no public UTI for the style information so let's just use the 'ustl' OSType tag
  ustlUTString = UTTypeCreatePreferredIdentifierForTag(kUTTagClassOSType, CFSTR(&quot;ustl&quot;), NULL);
    require(ustlUTString != NULL, CantCreateUTForUSTL);
  
  // adding that CFData in the pasteboard
  status = PasteboardPutItemFlavor(thePasteboard, (PasteboardItemID)2, ustlUTString, styleData, 0);
  require_noerr(status, CantPutItemFlavor);

CantCreateUTForUSTL:
CantCreateStyleData:
CantPutItemFlavor:
CantCreateTextData:
CantGetTextAndStyle:
ClientNotPasteboardOwner:
PasteboardNotSynchedAfterClear:
CantClearPasteboard:
CantGetData:
EndPutContent:

  if (styleData != NULL) CFRelease(styleData);
  if (textData != NULL) CFRelease(textData);
  if (ustlUTString != NULL) CFRelease(ustlUTString);
  if (textString != NULL) CFRelease(textString);
  if (styleBuffer != NULL) free(styleBuffer);
  if (textBuffer != NULL) free(textBuffer);

  return status;
  }   // HIATSUIViewPutContentInPasteboard

/*****************************************************
*
* HIATSUIViewSetSelection(theHIATSUIView, start, end)
*
* Purpose:  Sets the text selection
*
* Inputs:   theHIATSUIView      - the view
*        start               - the beginning of the selection
*        end                 - the end of the selection
*
* Returns:  OSStatus      - error code (0 == no error) 
*/
OSStatus HIATSUIViewSetSelection(HIViewRef theHIATSUIView, UniCharArrayOffset start, UniCharArrayOffset end)
  {
  OSStatus status = noErr;

  // accessing our view's private data
  HIATSUIViewData* myData = (HIATSUIViewData*)HIObjectDynamicCast((HIObjectRef)theHIATSUIView, kHIATSUIViewClass);
  require(myData != NULL, CantGetData);
  
  if (start == kATSUFromTextBeginning) start = 0;
  if (end == kATSUToTextEnd) end = myData-&gt;uTextLength;

  myData-&gt;selectionStart = start;
  myData-&gt;selectionEnd = end;

CantGetData:
  return status;
  }   // HIATSUIViewSetSelection

/*****************************************************
*
* HIATSUIViewSetWithFrame(theHIATSUIView, withFrame)
*
* Purpose:  Sets the frame field of the view's private data to let the kEventControlDraw handler know if a frame is desired or not
*
* Inputs:   theHIATSUIView      - the view
*        withFrame           - true if a frame is desired, false if not
*
* Returns:  OSStatus      - error code (0 == no error) 
*/
OSStatus HIATSUIViewSetWithFrame(HIViewRef theHIATSUIView, Boolean withFrame)
  {
  OSStatus status = noErr;

  // accessing our view's private data
  HIATSUIViewData* myData = (HIATSUIViewData*)HIObjectDynamicCast((HIObjectRef)theHIATSUIView, kHIATSUIViewClass);
  require(myData != NULL, CantGetData);

  myData-&gt;withFrame = withFrame;

CantGetData:
  return status;
  }   // HIATSUIViewSetWithFrame

/*****************************************************
*
* HIATSUIViewSetWrap(theHIATSUIView, wrap, textSize)
*
* Purpose:  Sets the wrap field of the view's private data to let HIATSUIBreakLines know if we wrap the text or not.
*        If no wrap is desired then the textSize parameter is ignored, else it is kept in the view's private data.
*        Will rebreak the text in lines if needed.
*
* Inputs:   theHIATSUIView      - the view
*           wrap                - if true then the text wraps in our bounds, else the width field of the following parameter textSize must be set to non-zero
*           textSize            - if previous parameter is false, then
*                                    on input the width field must be set with the non-zero value of the desired width,
*                                    on output the height field will be set with the value computed by HIATSUIViewBreakLines 
*
* Returns:  OSStatus      - error code (0 == no error) 
*/
OSStatus HIATSUIViewSetWrap(HIViewRef theHIATSUIView, Boolean wrap, HISize * textSize)
  {
  OSStatus status = noErr;

  require_action(wrap || ( textSize-&gt;width != 0 ), ParamErr, status = paramErr);

  // accessing our view's private data
  HIATSUIViewData* myData = (HIATSUIViewData*)HIObjectDynamicCast((HIObjectRef)theHIATSUIView, kHIATSUIViewClass);
  require(myData != NULL, CantGetData);

  Boolean needToBreak = (myData-&gt;wrap != wrap) || ( ( ! wrap ) &amp;&amp; ( myData-&gt;textSize.width != textSize-&gt;width ) );

  myData-&gt;wrap = wrap;
  myData-&gt;textSize = *textSize;
  
  if (needToBreak)
    HIATSUIViewBreakLines(theHIATSUIView);
  
  *textSize = myData-&gt;textSize;

CantGetData:
ParamErr:
  return status;
  }   // HIATSUIViewSetWrap

/*****************************************************
*
* HIATSUIViewGetTextSize(theHIATSUIView)
*
* Purpose:  Accessor, returns the size of the text
*
* Inputs:   theHIATSUIView      - the view
*
* Returns:  the size of the text as a HISize
*/
HISize HIATSUIViewGetTextSize(HIViewRef theHIATSUIView)
  {
  HISize textSize = { 0, 0 };

  // accessing our view's private data
  HIATSUIViewData* myData = (HIATSUIViewData*)HIObjectDynamicCast((HIObjectRef)theHIATSUIView, kHIATSUIViewClass);
  require(myData != NULL, CantGetData);

  textSize = myData-&gt;textSize;

CantGetData:
  return textSize;
  }   // HIATSUIViewGetTextSize

/*****************************************************
*
* HIATSUIViewSetColor(theHIATSUIView, withColor, red, green, blue, alpha)
*
* Purpose:  Sets the color information to let the kEventControlDraw handler know if color is desired or not for the text
*
* Inputs:   theHIATSUIView      - the view
*           withColor           - if true then the following color parameters will be stored in the view's private data and used later
*                       if false, then the color parameters are ignored and the default color (black) will be used for the text
*           red, green,
*        blue, alpha         - color values 
*
* Returns:  OSStatus      - error code (0 == no error) 
*/
OSStatus HIATSUIViewSetColor(HIViewRef theHIATSUIView, Boolean withColor, float red, float green, float blue, float alpha)
  {
  OSStatus status = noErr;

  // accessing our view's private data
  HIATSUIViewData* myData = (HIATSUIViewData*)HIObjectDynamicCast((HIObjectRef)theHIATSUIView, kHIATSUIViewClass);
  require(myData != NULL, CantGetData);

  myData-&gt;withColor = withColor;
  
  if (withColor)
    {
    myData-&gt;color.red = red;
    myData-&gt;color.green = green;
    myData-&gt;color.blue = blue;
    myData-&gt;color.alpha = alpha;
    }

CantGetData:
  return status;
  }   // HIATSUIViewSetColor

/*****************************************************
*
* HIATSUIViewSetBackColor(theHIATSUIView, withColor, red, green, blue, alpha)
*
* Purpose:  Sets the color information to let the kEventControlDraw handler know if color is desired or not for the background of the text
*
* Inputs:   theHIATSUIView      - the view
*           withColor           - if true then the following color parameters will be stored in the view's private data and used later
*                       if false, then the color parameters are ignored and the default color (clear) will be used for the text
*           red, green,
*        blue, alpha         - color values 
*
* Returns:  OSStatus      - error code (0 == no error) 
*/
OSStatus HIATSUIViewSetBackColor(HIViewRef theHIATSUIView, Boolean withColor, float red, float green, float blue, float alpha)
  {
  OSStatus status = noErr;

  // accessing our view's private data
  HIATSUIViewData* myData = (HIATSUIViewData*)HIObjectDynamicCast((HIObjectRef)theHIATSUIView, kHIATSUIViewClass);
  require(myData != NULL, CantGetData);

  myData-&gt;withColor = withColor;

  if (withColor)
    {
    myData-&gt;backColor.red = red;
    myData-&gt;backColor.green = green;
    myData-&gt;backColor.blue = blue;
    myData-&gt;backColor.alpha = alpha;
    }

CantGetData:
  return status;
  }   // HIATSUIViewSetBackColor

/*****************************************************
*
* HIATSUIViewSetAlignment(theHIATSUIView, alignment)
*
* Purpose:  Sets the alignment information for the kEventControlDraw handler
*
* Inputs:   theHIATSUIView      - the view
*           alignment           - Fract value (from kATSUStartAlignment (0, aka left in Roman) to kATSUEndAlignment (0x40000000L, aka right in Roman))
*                        see QD/ATSUnicodeTypes.h for details
*
* Returns:  OSStatus      - error code (0 == no error) 
*/
OSStatus HIATSUIViewSetAlignment(HIViewRef theHIATSUIView, Fract alignment)
  {
  OSStatus status = noErr;

  // accessing our view's private data
  HIATSUIViewData* myData = (HIATSUIViewData*)HIObjectDynamicCast((HIObjectRef)theHIATSUIView, kHIATSUIViewClass);
  require(myData != NULL, CantGetData);

  status = atsuSetLayoutFlushFactor(myData-&gt;textLayout, alignment);

CantGetData:
  return status;
  }   // HIATSUIViewSetAlignment

/*****************************************************
*
* HIATSUIViewSetJustification(theHIATSUIView, justification)
*
* Purpose:  Sets the justification information for the kEventControlDraw handler
*
* Inputs:   theHIATSUIView      - the view
*           justification       - Fract value (from kATSUNoJustification (0) to kATSUFullJustification (0x40000000L))
*                        see QD/ATSUnicodeTypes.h for details
*
* Returns:  OSStatus      - error code (0 == no error) 
*/
OSStatus HIATSUIViewSetJustification(HIViewRef theHIATSUIView, Fract justification)
  {
  OSStatus status = noErr;
  HIATSUIViewData* myData = (HIATSUIViewData*)HIObjectDynamicCast((HIObjectRef)theHIATSUIView, kHIATSUIViewClass);
  require(myData != NULL, CantGetData);

  status = atsuSetLayoutJustFactor(myData-&gt;textLayout, justification);

CantGetData:
  return status;
  }   // HIATSUIViewSetJustification

//****************************************************
#pragma mark -
#pragma mark * local (static) function implementations *

/*****************************************************
*
* Internal_HIATSUIViewHandler(inHandlerCallRef, inEvent, inUserData) 
*
* Purpose:  Event handler that implements our HIATSUIView custom view
*
* Inputs:   inHandlerCallRef    - reference to the current handler call chain
*        inEvent             - the event
*           inUserData          - app-specified data you passed in the call to InstallEventHandler
*
* Returns:  OSStatus            - error code (0 == no error) 
*/
pascal OSStatus Internal_HIATSUIViewHandler(EventHandlerCallRef inHandlerCallRef, EventRef inEvent, void *inUserData)
  {
  OSStatus status = eventNotHandledErr;
  HIATSUIViewData* myData = (HIATSUIViewData*)inUserData;

  switch (GetEventClass(inEvent))
    {
    case kEventClassHIObject:
      switch (GetEventKind(inEvent))
        {
        case kEventHIObjectConstruct:
          {
          // allocate some instance data
          myData = (HIATSUIViewData*) calloc(1, sizeof(HIATSUIViewData));
          
          // get our superclass instance
          HIViewRef epView;
          status = GetEventParameter(inEvent, kEventParamHIObjectInstance, typeHIObjectRef, NULL, sizeof(epView), NULL, &amp;epView);
          
          // remember our superclass in our instance data
          myData-&gt;view = epView;
          // calloc fills our structure with all zeroes which is what we want a default value for all our fields
          // so we don't need to set them to NULL or 0 one by one
          
          // store our instance data into the event
          status = SetEventParameter(inEvent, kEventParamHIObjectInstance, typeVoidPtr, sizeof(myData), &amp;myData);
          break;
          }
          
#pragma mark *   kEventHIObjectInitialize
        case kEventHIObjectInitialize:
          {
          // always begin kEventHIObjectInitialize by calling through to the previous handler
          status = CallNextEventHandler(inHandlerCallRef, inEvent);
          
          // if that succeeded, do our own initialization
          if (status == noErr)
            {
            myData-&gt;color.alpha = 1;

            // retrieving all parameters set either in HICreateATSUIViewWithText or in Interface Builder
            HIRect bounds;
            status = GetEventParameter(inEvent, kControlCollectionTagBounds, typeHIRect, NULL, sizeof(bounds), NULL, &amp;bounds);
            if (status == noErr)
              HIViewSetFrame(myData-&gt;view, &amp;bounds);
            
            Fixed value;
            status = GetEventParameter(inEvent, kATSUIViewXLocTag, typeUInt32, NULL, sizeof(value), NULL, &amp;value);
            if (status == noErr)
              myData-&gt;xLocation = value;
            
            status = GetEventParameter(inEvent, kATSUIViewYLocTag, typeUInt32, NULL, sizeof(value), NULL, &amp;value);
            if (status == noErr)
              myData-&gt;yLocation = value;
            
            Boolean aBool;
            status = GetEventParameter(inEvent, kATSUIViewFrameTag, typeBoolean, NULL, sizeof(aBool), NULL, &amp;aBool);
            if (status == noErr)
              myData-&gt;withFrame = aBool;
            else
              myData-&gt;withFrame = true;

            status = GetEventParameter(inEvent, kATSUIViewWrapTag, typeBoolean, NULL, sizeof(aBool), NULL, &amp;aBool);
            if (status == noErr)
              myData-&gt;wrap = aBool;
            else
              myData-&gt;wrap = true;
            
            HISize theSize;
            status = GetEventParameter(inEvent, kATSUIViewSizeTag, typeHISize, NULL, sizeof(theSize), NULL, &amp;theSize);
            if (status == noErr)
              myData-&gt;textSize = theSize;
            else
              // if there's no wrapping and a width is not provided then we return a paramErr!
              require_action(myData-&gt;wrap, InitializeExit, status = paramErr);
            
            ItemCount numberOfRuns;
            status = GetEventParameter(inEvent, kATSUIViewItemCountTag, typeUInt32, NULL, sizeof(numberOfRuns), NULL, &amp;numberOfRuns);
            if (status != noErr) numberOfRuns = 0;
            
            UniCharCount * runLengths;
            status = GetEventParameter(inEvent, kATSUIViewRunLengthsTag, typeVoidPtr, NULL, sizeof(runLengths), NULL, &amp;runLengths);
            if (status != noErr) runLengths = NULL;
            
            ATSUStyle * styles;
            status = GetEventParameter(inEvent, kATSUIViewStylesTag, typeVoidPtr, NULL, sizeof(styles), NULL, &amp;styles);
            if (status != noErr) styles = NULL;
            
            CFStringRef theText;
            status = GetEventParameter(inEvent, kATSUIViewTextTag, typeCFStringRef, NULL, sizeof(theText), NULL, &amp;theText);
            if (status == noErr)
              status = HIATSUIViewSetText(myData-&gt;view, theText, numberOfRuns, runLengths, styles);
            else
              // we didn't get any text to set but everything else is OK so we return noErr
              status = noErr;
            }

InitializeExit:
          break;
          }
          
        case kEventHIObjectDestruct:
          {
          if (myData != NULL)
            {
            Internal_HIATSUIViewFreeData(myData);
            free(myData);
            }
          status = noErr;
          break;
          }
        
        default:
          break;
        }
      break;

    case kEventClassScrollable:
      switch (GetEventKind(inEvent))
        {
#pragma mark *   kEventScrollableGetInfo
        case kEventScrollableGetInfo:
          {
          // we're being asked to return information about the scrolled view that we set as Event Parameters
          HIRect bounds;
          HIViewGetBounds(myData-&gt;view, &amp;bounds);
          HISize lineSize = { 0, 1 };

          SetEventParameter(inEvent, kEventParamViewSize, typeHISize, sizeof(bounds.size), &amp;bounds.size);
          SetEventParameter(inEvent, kEventParamImageSize, typeHISize, sizeof(myData-&gt;textSize), &amp;myData-&gt;textSize);
          SetEventParameter(inEvent, kEventParamLineSize, typeHISize, sizeof(lineSize), &amp;lineSize);
          SetEventParameter(inEvent, kEventParamOrigin, typeHIPoint, sizeof(myData-&gt;originPoint), &amp;myData-&gt;originPoint);
          status = noErr;
          break;
          }

#pragma mark *   kEventScrollableScrollTo
        case kEventScrollableScrollTo:
          {
          // we're being asked to scroll, we just do a sanity check and ask for a redraw if the location is different
          HIPoint where;
          GetEventParameter(inEvent, kEventParamOrigin, typeHIPoint, NULL, sizeof(where), NULL, &amp;where);

          where = Internal_HIATSUIViewSanityCheck(myData, where);

          if ((myData-&gt;originPoint.y != where.y) || (myData-&gt;originPoint.x != where.x))
            {
            myData-&gt;originPoint = where;
          
            HIViewSetNeedsDisplay(myData-&gt;view, true);
            }
          status = noErr;
          break;
          }
        
        default:
          break;
        }
      break;

    case kEventClassControl:
      switch (GetEventKind(inEvent))
        {
#pragma mark *   kEventControlDraw
        case kEventControlDraw:
          {
          CGContextRef context;
          status = GetEventParameter(inEvent, kEventParamCGContextRef, typeCGContextRef, NULL, sizeof(context), NULL, &amp;context);
          require_noerr(status, ControlDrawExit);

          HIRect bounds;
          HIViewGetBounds(myData-&gt;view, &amp;bounds);

          // dealing with the colors and frame
          if (myData-&gt;withColor)
            {
            CGContextSetRGBFillColor(context, myData-&gt;backColor.red, myData-&gt;backColor.green, myData-&gt;backColor.blue, myData-&gt;backColor.alpha);
            CGContextFillRect(context, bounds);
            CGContextSetRGBFillColor(context, myData-&gt;color.red, myData-&gt;color.green, myData-&gt;color.blue, myData-&gt;color.alpha);
            }

          if (myData-&gt;withFrame)
            CGContextStrokeRect(context, bounds);

          // if there's no text to draw, we're done!
          if (myData-&gt;uTextLength == 0) goto ControlDrawExit;

          // Adjust the transform so the text doesn't draw upside down:
          // ATSUDrawText, for compatibility and legacy reasons, resets the Text Matrix to identity
          // so any pre-setting with CGContextSetTextMatrix is inoperant.
          // Since the text would be drawn upside down because QuickDraw and CoreGraphics (Quartz) have
          // opposite definitions of the direction of y-positive, we still need to reverse the
          // drawing matrix and since the Text Matrix is closed to us, we have to reverse the CTM
          // (Context Transform Matrix) itself, and translate it so that we don't draw outside the
          // visible bounds.
          CGContextSaveGState(context);
          CGContextScaleCTM(context, 1, -1);
          CGContextTranslateCTM(context, 0, myData-&gt;originPoint.y-bounds.size.height);

          // Letting ATSUI know that we draw in a CGContext instead of a QuickDraw port
          ATSUAttributeTag tags[] = { kATSUCGContextTag };
          ByteCount valueSizes[] = { sizeof(CGContextRef) };
          ATSUAttributeValuePtr values[] = { &amp;context };
          status = ATSUSetLayoutControls(myData-&gt;textLayout, 1, tags, valueSizes, values);
          require_noerr(status, ControlDrawExit);
          
          // We start drawing at xLocation, yLocation if non-NULL,
          // else we calculate some reasonable margins
          ATSUTextMeasurement x = myData-&gt;xLocation, y = myData-&gt;yLocation;
          if (y == 0) y = FloatToFixed(bounds.size.height) - myData-&gt;lineHeights[0];
          else y = FloatToFixed(bounds.size.height) - y;
          if (x == 0) x = kXMargin;

          // Optimizing the hilighting since we are working in a CGContext
          // Note: the color in the structure ATSUUnhighlightData below is actually ignored
          //       and the actual color used for hiliting is the one chosen by the User
          //       in the System Preferences
          ATSUUnhighlightData unhilightData = {kATSUBackgroundColor, {0.0, 0.0, 0.0, 0.0}};
          status = ATSUSetHighlightingMethod(myData-&gt;textLayout, kRedrawHighlighting, &amp;unhilightData);
          require_noerr(status, ControlDrawExit);

          // Drawing all the lines, one by one
          // Since we had to reverse and translate the y axis, we need to back-reverse and translate
          // our coordinates to simulate the QuickDraw coordinates
          ItemCount i;
          UniCharArrayOffset lineStart = 0, lineEnd;
          for (i = 0; i &lt; myData-&gt;numberOfLines; i++)
            {
            lineEnd = myData-&gt;endOfLines[i];

            // Performance:
            // Let's draw only the lines which are visible within our bounds
            if (  (myData-&gt;lineHeights[i] &gt;= FloatToFixed(myData-&gt;originPoint.y)) &amp;&amp;
                ( (i == 0) || (myData-&gt;lineHeights[i-1] &lt;= FloatToFixed(myData-&gt;originPoint.y + bounds.size.height)) )  )
              {
              // in a CGContext, we draw the hilighting first so the anti-aliasing works correctly
              // first, let's check if we might have a selection
              if (myData-&gt;selectionStart != myData-&gt;selectionEnd)
                {
                UniCharArrayOffset selStt = 0, selEnd = 0;
                if ((myData-&gt;selectionStart &gt;= lineStart) &amp;&amp; (myData-&gt;selectionStart &lt;= lineEnd))
                  selStt = myData-&gt;selectionStart;
                if ((myData-&gt;selectionEnd &gt;= lineStart) &amp;&amp; (myData-&gt;selectionEnd &lt;= lineEnd))
                  selEnd = myData-&gt;selectionEnd;
                if ((lineStart &gt;= myData-&gt;selectionStart) &amp;&amp; (lineStart &lt;= myData-&gt;selectionEnd))
                  selStt = lineStart;
                if ((lineEnd &gt;= myData-&gt;selectionStart) &amp;&amp; (lineEnd &lt;= myData-&gt;selectionEnd))
                  selEnd = lineEnd;
                if (selEnd != 0)
                  {
                  status = ATSUHighlightText(myData-&gt;textLayout, x, y+myData-&gt;descents[i], selStt, selEnd-selStt);
                  require_noerr(status, ControlDrawExit);
                  }
                }

              status = ATSUDrawText(myData-&gt;textLayout, lineStart, lineEnd-lineStart, x, y+myData-&gt;descents[i]);
              require_noerr(status, ControlDrawExit);
              }

            y -= (myData-&gt;lineHeights[i+1] - myData-&gt;lineHeights[i]);
            lineStart = lineEnd;
            }

          // restoring our context the way we found it when we started
          CGContextRestoreGState(context);

          status = noErr;
ControlDrawExit:
          break;
          }

#pragma mark *   kEventControlHitTest
        case kEventControlHitTest:
          {
          // we need to implement the kEventControlHitTest handler so that our kEventControlTrack handler will be called
          HIPoint mouseLoc;
          status = GetEventParameter(inEvent, kEventParamMouseLocation, typeHIPoint, NULL, sizeof(mouseLoc), NULL, &amp;mouseLoc);
          require_noerr(status, ControlHitTestExit);

          HIRect hiBounds;
          status = HIViewGetBounds(myData-&gt;view, &amp;hiBounds);
          require_noerr(status, ControlHitTestExit);

          ControlPartCode partCode = ( CGRectContainsPoint(hiBounds, mouseLoc) ) ? kControlLabelPart : kControlNoPart;
          status = SetEventParameter(inEvent, kEventParamControlPart, typeControlPartCode, sizeof(partCode), &amp;partCode);
          require_noerr(status, ControlHitTestExit);
  
ControlHitTestExit:
            break;
          }

#pragma mark *   kEventControlClick
        case kEventControlClick:
          {
          // The kEventControlTrack event does not provide the click count as the kEventControlClick event does
          // Since a kEventControlClick event will be sent every time before a kEventControlTrack event, we just
          // store the current click count in our private data.
          myData-&gt;clickCount = 1;
          GetEventParameter(inEvent, kEventParamClickCount, typeUInt32, NULL, sizeof(myData-&gt;clickCount), NULL, &amp;myData-&gt;clickCount);
          status = eventNotHandledErr;
          break;
          }

#pragma mark *   kEventControlTrack
        case kEventControlTrack:
          {
          // getting the location of the click
          HIPoint mouseLoc;
          status = GetEventParameter(inEvent, kEventParamMouseLocation, typeHIPoint, NULL, sizeof(mouseLoc), NULL, &amp;mouseLoc);
          require_noerr(status, ControlTrackExit);
          
          // getting the modifiers of the click
          UInt32 modifiers;
          status = GetEventParameter(inEvent, kEventParamKeyModifiers, typeUInt32, NULL, sizeof(modifiers), NULL, &amp;modifiers);
          require_noerr(status, ControlTrackExit);
          Boolean withShift = ((modifiers &amp; shiftKey) == shiftKey);
          
          // determining where in the text we clicked
          UniCharArrayOffset prOffset;
          Boolean isLeading;
          ItemCount lineClicked;
          status = Internal_HIATSUIViewPointToOffset(myData, mouseLoc, &amp;prOffset, &amp;lineClicked, &amp;isLeading);
          require_noerr(status, ControlTrackExit);

          // Let's get the current selection
          UniCharArrayOffset lastSeen = prOffset, anchor1, anchor2, newStart, newEnd;
          HIATSUIViewGetSelection(myData-&gt;view, &amp;anchor1, &amp;anchor2);
          
          // Now that we now where we clicked, let's change the selection according to modifiers, click count
          KindOfClick nbClicks = ( withShift ) ? myData-&gt;lastKindOfClick : myData-&gt;clickCount;

          // do we have the start of a drag?
          if ((nbClicks == 1) &amp;&amp; (! withShift) &amp;&amp; (prOffset &gt;= anchor1) &amp;&amp; (prOffset &lt;= anchor2) &amp;&amp; (anchor1 != anchor2))
            {
            // Making sure we are starting a drag operation
            Point globalLoc = { (int)mouseLoc.y, (int)mouseLoc.x };
            LocalToGlobal(&amp;globalLoc);
            if (WaitMouseMoved(globalLoc))
              {
              // we do indeed have the start of a drag operation
              Internal_HIATSUIViewDragSelection(myData, anchor1, anchor2, mouseLoc);
              
              // so we need to break out the kEventControlTrack handler
              break;
              }
            }

          // determining the new selection after the first click depending on the click count and the modifiers
          Internal_HIATSUIViewDetermineSelection(myData, nbClicks, isLeading, withShift, lineClicked, anchor1, anchor2, prOffset, &amp;newStart, &amp;newEnd);
          if ((newStart != anchor1) || (newEnd != anchor2))
            {
            HIATSUIViewSetSelection(myData-&gt;view, newStart, newEnd);
            HIViewSetNeedsDisplay(myData-&gt;view, true);
            }
          
          // Memorize the current click count for a possible shift-click later
          if (!withShift) myData-&gt;lastKindOfClick = myData-&gt;clickCount;
          HIATSUIViewGetSelection(myData-&gt;view, &amp;anchor1, &amp;anchor2);
          
          KindOfClick currentKindOfClick = (myData-&gt;lastKindOfClick &gt; myData-&gt;clickCount) ? myData-&gt;lastKindOfClick : myData-&gt;clickCount;
          
          if (myData-&gt;clickCount == kTextClickKind) break; // we already selected everything, no need to drag around...

          // click-and-dragging: using TrackMouseLocation still requires some QuickDraw usage
          Rect qdWindowBounds;
          GetWindowBounds(GetControlOwner(myData-&gt;view), kWindowStructureRgn, &amp;qdWindowBounds);
          MouseTrackingResult mouse = kMouseTrackingMouseDown;
          while (mouse != kMouseTrackingMouseUp)
            {
            // a -1 GrafPtr to TrackMouseLocation yields global coordinates
            Point qdPoint;
            TrackMouseLocation((GrafPtr)-1L, &amp;qdPoint, &amp;mouse);            

            // convert to window-relative coordinates
            HIPoint hiPoint;
            hiPoint.x = qdPoint.h - qdWindowBounds.left;
            hiPoint.y = qdPoint.v - qdWindowBounds.top;
            
            // convert to view-relative coordinates
            HIViewConvertPoint(&amp;hiPoint, NULL, myData-&gt;view);

            // determining where in the text we are now
            Internal_HIATSUIViewPointToOffset(myData, hiPoint, &amp;prOffset, &amp;lineClicked, &amp;isLeading);
          
            if (prOffset != lastSeen)
              {
              lastSeen = prOffset;

              UniCharArrayOffset curStart, curEnd;
              HIATSUIViewGetSelection(myData-&gt;view, &amp;curStart, &amp;curEnd);
              
              // determining the new selection and asking for a refresh, we do not draw in the kEventControlTrack handler!
              Internal_HIATSUIViewDetermineSelection(myData, currentKindOfClick, isLeading, true, lineClicked, anchor1, anchor2, prOffset, &amp;newStart, &amp;newEnd);
              if ((newStart != curStart) || (newEnd != curEnd))
                {
                HIATSUIViewSetSelection(myData-&gt;view, newStart, newEnd);
                HIViewSetNeedsDisplay(myData-&gt;view, true);
                }
              }
            }
          
ControlTrackExit:
          break;
          }

        case kEventControlBoundsChanged:
          {
          // the bounds of our view changed, let's rebreak the lines if we wrap
          if (myData-&gt;wrap)
            HIATSUIViewBreakLines(myData-&gt;view);
          break;
          }

        default:
          break;
        }
      break;
      
    default:
      break;
    }
  
  return status;
  }   // Internal_HIATSUIViewHandler

/*****************************************************
*
* Internal_HIATSUIViewSanityCheck(myData, where) 
*
* Purpose:  Makes sure that we always scroll in a position such that we don't display out-of-bounds content
*
* Inputs:   myData              - the view's private data
*        where               - the point where we are being asked to scroll to
*
* Returns:  the point where it is safe to scroll to
*/
static HIPoint Internal_HIATSUIViewSanityCheck(HIATSUIViewData * myData, HIPoint where)
  {
  HIRect bounds;
  HIViewGetBounds(myData-&gt;view, &amp;bounds);

  if (where.y + bounds.size.height &gt; myData-&gt;textSize.height) 
    where.y = myData-&gt;textSize.height - bounds.size.height;
  if (where.y &lt; 0) where.y = 0;

  if (where.x + bounds.size.width &gt; myData-&gt;textSize.width) 
    where.x = myData-&gt;textSize.width - bounds.size.width;
  if (where.x &lt; 0) where.x = 0;
  
  return where;
  } // Internal_HIATSUIViewSanityCheck

/*****************************************************
*
* Internal_HIATSUIViewPointToOffset(myData, hiPoint, prOffset, lineClicked, isLeading) 
*
* Purpose:  Obtains the text offset for the glyph edge nearest a given point
*
* Inputs:   myData              - the view's private data
*        hiPoint             - the point which text offset we want to know
*        prOffset            - returns the text offset
*        lineClicked         - returns the line number of that offset
*        isLeading           - returns whether the offset produced in prOffset is leading or trailing
*                        see the discussion on ATSUPositionToOffset in QD/ATSUnicodeDrawing.h
*
* Returns:  OSStatus            - error code (0 == no error) 
*/
static OSStatus Internal_HIATSUIViewPointToOffset(HIATSUIViewData * myData, HIPoint hiPoint, UniCharArrayOffset * prOffset, ItemCount * lineClicked, Boolean * isLeading)
  {
  OSStatus status = noErr;
  ItemCount i, found = -1;
  ATSUTextMeasurement base = 0, yLoc = myData-&gt;yLocation;

  require_action(prOffset != NULL, ParamErr, status = paramErr);
  require_action(lineClicked != NULL, ParamErr, status = paramErr);
  require_action(isLeading != NULL, ParamErr, status = paramErr);

  // determining which line was clicked since
  // we need to determine the position of the click in the coordinates of that line
  if (yLoc == 0) yLoc = FloatToFixed(hiPoint.y + myData-&gt;originPoint.y);
  else yLoc = FloatToFixed(hiPoint.y + myData-&gt;originPoint.y) - (yLoc - myData-&gt;lineHeights[0]);
  for (i = 0; (i &lt; myData-&gt;numberOfLines) &amp;&amp; (found == -1); i++)
    if ((base &lt;= yLoc) &amp;&amp; (yLoc &lt; (base = myData-&gt;lineHeights[i])))
      found = i;

  if (found != -1)
    {
    yLoc = yLoc - base + myData-&gt;descents[found];
    ATSUTextMeasurement xLoc = myData-&gt;xLocation;
    if (xLoc == 0) xLoc = kXMargin;
    xLoc = FloatToFixed(hiPoint.x) - xLoc;

    // calling ATSUPositionToOffset to know the offset of the click in the text buffer
    UniCharArrayOffset secOffset;
    *prOffset = ( found == 0 ) ? 0 : myData-&gt;endOfLines[found-1];
    status = ATSUPositionToOffset(myData-&gt;textLayout, xLoc, yLoc, prOffset, isLeading, &amp;secOffset);
    require_noerr(status, CantGetOffset);
    }

CantGetOffset:
  
  *lineClicked = found;

ParamErr:

  return status;
  }   // Internal_HIATSUIViewPointToOffset

/*****************************************************
*
* Internal_HIATSUIViewDetermineSelection(myData, clickKind, isLeading, extend, lineClicked, anchor1, anchor2, prOffset, newStart, newEnd) 
*
* Purpose:  Determines the new selection based on the kind of click, the previous selection, the click location, and other factors
*
* Inputs:   myData              - the view's private data
*        clickKind           - the kind of click (simple, double, triple, quadruple)
*        isLeading           - whether the offset given in prOffset is leading or trailing (see Internal_HIATSUIViewPointToOffset)
*        extend              - selection extension. If first click, true is shift key. If click-and-drag, always true.
*        lineClicked         - the line number of prOffset
*        anchor1             - the current start of the selection
*        anchor2             - the current end of the selection
*        prOffset            - the text offset of the current click
*        newStart            - returns the new start of the selection
*        newEnd              - returns the new end of the selection
*
* Returns:  OSStatus            - error code (0 == no error) 
*/
static OSStatus Internal_HIATSUIViewDetermineSelection(HIATSUIViewData * myData, KindOfClick clickKind, Boolean isLeading, Boolean extend, ItemCount lineClicked, UniCharArrayOffset anchor1, UniCharArrayOffset anchor2, UniCharArrayOffset prOffset, UniCharArrayOffset * newStart, UniCharArrayOffset * newEnd)
  {
  OSStatus status = noErr;
  UniCharArrayOffset tmp1, tmp2;
  switch(clickKind)
    {
    case kCharacterClickKind:
      // simple click, we just have to check for selection extension
      if (extend)
        {
        if (prOffset &lt; anchor1) { *newStart = prOffset; *newEnd = anchor2; }
        else if (prOffset &gt; anchor2) { *newStart = anchor1; *newEnd = prOffset; }
        else if ( (prOffset - anchor1) &lt; (anchor2 - prOffset) ) { *newStart = prOffset; *newEnd = anchor2; }
        else { *newStart = anchor1; *newEnd = prOffset; }
        }
      else
        {
        *newStart = *newEnd = prOffset;
        }
      break;
    case kWordClickKind:
      // let's get the end and the start of the word around the click position
      // the input position needs to be adjusted so that we don't grab the next word by mistake
      // note that leading *must* be true if thePos is the beginning of the text and false if it's the end
      status = ATSUPreviousCursorPosition(myData-&gt;textLayout, ( isLeading ) ? prOffset + 1 : prOffset, kATSUByWord, &amp;tmp1);
      require_noerr(status, SelectionExit);
      status = ATSUNextCursorPosition(myData-&gt;textLayout, tmp1, kATSUByWord, &amp;tmp2);
      require_noerr(status, SelectionExit);
      if (extend)
        {
        *newStart = ( tmp1 &lt; anchor1 ) ? tmp1 : anchor1;
        *newEnd = ( tmp2 &gt; anchor2 ) ? tmp2 : anchor2;
        }
      else
        {
        *newStart = tmp1;
        *newEnd = tmp2;
        }
      break;
    case kLineClickKind:
      // let's get the end and the start of the line around the click position
      tmp1 = ( lineClicked == 0 ) ? 0 : myData-&gt;endOfLines[lineClicked-1];
      tmp2 = myData-&gt;endOfLines[lineClicked];
      if (extend)
        {
        *newStart = ( tmp1 &lt; anchor1 ) ? tmp1 : anchor1;
        *newEnd = ( tmp2 &gt; anchor2 ) ? tmp2 : anchor2;
        }
      else
        {
        *newStart = tmp1;
        *newEnd = tmp2;
        }
      break;
    case kTextClickKind:
      // quadruple-click, we select the whole text unless we get a subsequent shift-click
      // which then probably means that the user wants to reduce the selection
      if (extend)
        {
        if (prOffset &lt; anchor1) { *newStart = prOffset; *newEnd = anchor2; }
        else if (prOffset &gt; anchor2) { *newStart = anchor1; *newEnd = prOffset; }
        else if ( (prOffset - anchor1) &lt; (anchor2 - prOffset) ) { *newStart = prOffset; *newEnd = anchor2; }
        else { *newStart = anchor1; *newEnd = prOffset; }
        }
      else
        {
        // let's select the whole text
        *newStart = 0;
        *newEnd = myData-&gt;uTextLength;
        }
      break;
    }

SelectionExit:

  return status;
  }   // Internal_HIATSUIViewDetermineSelection

/*****************************************************
*
* Internal_HIATSUIViewFreeData(myData) 
*
* Purpose:  Frees all internal buffers and arrays of our view's private data.
*        All fields are reset to NULL in case this function is called twice.
*
* Inputs:   myData              - the view's private data
*
* Returns:  none 
*/
static void Internal_HIATSUIViewFreeData(HIATSUIViewData * myData)
  {
  if (myData-&gt;theUnicodeText != NULL) { free(myData-&gt;theUnicodeText); myData-&gt;theUnicodeText = NULL; }
  if (myData-&gt;endOfLines != NULL) { free(myData-&gt;endOfLines); myData-&gt;endOfLines = NULL; }
  if (myData-&gt;lineHeights != NULL) { free(myData-&gt;lineHeights);myData-&gt;lineHeights = NULL; }
  if (myData-&gt;descents != NULL) { free(myData-&gt;descents);myData-&gt;descents = NULL; }
  if (myData-&gt;runLengths != NULL) { free(myData-&gt;runLengths);myData-&gt;runLengths = NULL; }
  if (myData-&gt;styles != NULL)
    {
    // we need to free each ATSUStyle individually in addition to freeing the array of ATSUStyle
    // since 1 ATSUStyle might be shared by more than 1 run, we need to be careful
    // to not free the same ATSUStyle twice or more.
    ItemCount i;
    for ( i= 0; i &lt; myData-&gt;numberOfRuns; i++)
      if (myData-&gt;styles[i] != NULL)
        {
        ItemCount j;
        for ( j = i+1; j &lt; myData-&gt;numberOfRuns; j++)
          if (myData-&gt;styles[i] == myData-&gt;styles[j])
            myData-&gt;styles[j] = NULL;  // so that we don't try to dispose it again
        ATSUDisposeStyle(myData-&gt;styles[i]);
        }
    free(myData-&gt;styles);
    myData-&gt;styles = NULL;
    }
  if (myData-&gt;textLayout != NULL) { ATSUDisposeTextLayout(myData-&gt;textLayout); myData-&gt;textLayout = NULL; }
  }   // Internal_HIATSUIViewFreeData

/*****************************************************
*
* Internal_HIATSUIViewFreeFunction(clientData, data, size)
*
* Purpose:  Callback function that releases any private data or resources associated with the data provider (CGDataProviderReleaseInfoCallback).
*
* Inputs:   clientData          - pointer to data of any type, or NULL
*        data                - pointer to the array of data that the provider contains
*        size                - value that specifies the number of bytes that the data provider contains
*
* Returns:  none 
*/
static void Internal_HIATSUIViewFreeFunction(void *clientData, const void *data, size_t size)
  {
  free((void *)data);
  }   // Internal_HIATSUIViewFreeFunction

/*****************************************************
*
* Internal_HIATSUIViewMakeCGImage(myData, start, end, image, outContext, offset)
*
* Purpose:  Creates a CGImage that will be used when dragging text
*
* Inputs:   myData              - the view's private data
*        start               - the beginning of the selection
*        end                 - the end of the selection
*        image               - returns the CGImage
*        outContext          - returns the CGContext used by the CGImage
*        offset              - returns the point offset from the mouse to the upper left of the image (see SetDragImageWithCGImage)
*
* Returns:  OSStatus            - error code (0 == no error) 
*/
static OSStatus Internal_HIATSUIViewMakeCGImage(HIATSUIViewData * myData, UniCharArrayOffset start, UniCharArrayOffset end, CGImageRef *image, CGContextRef *outContext, HIPoint * offset)
  {
  *image = NULL;
  *outContext = NULL;
  OSStatus status = noErr;
  void * data = NULL;
  CGContextRef context = NULL;
  CGDataProviderRef cgData = NULL;
  CGImageRef cgImage = NULL;

  require_action(image != NULL, ParamErr, status = paramErr);
  require_action(outContext != NULL, ParamErr, status = paramErr);
  require_action(offset != NULL, ParamErr, status = paramErr);
  
  // determining the first visible character
  ItemCount i = 0;
  while (FloatToFixed(myData-&gt;originPoint.y) &gt; myData-&gt;lineHeights[i]) i++;
  UniCharArrayOffset first = (i == 0) ? 0 : myData-&gt;endOfLines[i-1];
  if (start &lt; first) start = first;
  
  // determining the top of the visible selection
  i = 0;
  while (start &gt; myData-&gt;endOfLines[i]) i++;
  ATSUTextMeasurement top = (i == 0) ? 0 : myData-&gt;lineHeights[i-1];
  ItemCount topLine = i;
  top -= FloatToFixed(myData-&gt;originPoint.y);

  // determining the last visible character
  HIRect bounds;
  HIViewGetBounds(myData-&gt;view, &amp;bounds);
  i = 0;
  while ( (FloatToFixed(myData-&gt;originPoint.y + bounds.size.height) &gt; myData-&gt;lineHeights[i]) &amp;&amp; (i &lt; myData-&gt;numberOfLines) ) i++;
  if (i &gt;= myData-&gt;numberOfLines) i = myData-&gt;numberOfLines - 1;
  UniCharArrayOffset last = myData-&gt;endOfLines[i];
  if (end &gt; last) end = last;

  // determining the bottom of the visible selection
  i = 0;
  while (end &gt;= myData-&gt;endOfLines[i]) i++;
  if (i &gt;= myData-&gt;numberOfLines) i = myData-&gt;numberOfLines - 1;
  ItemCount bottomLine = i;
  ATSUTextMeasurement bottom = myData-&gt;lineHeights[i];
  bottom -= FloatToFixed(myData-&gt;originPoint.y);

  // determining the graphic positions (x coordinate) of the beginning and end of the selection
  SInt32 width, height = (bottom - top) &gt;&gt; 16;
  ATSUCaret mCaret, sCaret;
  Boolean isSplit;
  status = ATSUOffsetToPosition(myData-&gt;textLayout, start, true, &amp;mCaret, &amp;sCaret, &amp;isSplit);
  Fixed startX = mCaret.fX;
  status = ATSUOffsetToPosition(myData-&gt;textLayout, end, true, &amp;mCaret, &amp;sCaret, &amp;isSplit);
  Fixed endX = mCaret.fX;

  // determining the width of the dragging area
  if (topLine == bottomLine)
    {
    width = (endX - startX) &gt;&gt; 16;
    if (width &lt; 0) // Right-to-Left direction
      {
      width = -width;
      endX = startX;
      startX = mCaret.fX;
      }
    offset-&gt;x = offset-&gt;x - (myData-&gt;xLocation &gt;&gt; 16) - (startX &gt;&gt; 16);
    }
  else width = (int)(bounds.size.width);

  // computing the point offset from the mouse to the upper left of the image
  offset-&gt;x = -offset-&gt;x;
  if (myData-&gt;yLocation == 0)
    offset-&gt;y = offset-&gt;y  - (top &gt;&gt; 16);
  else
    offset-&gt;y = offset-&gt;y - (myData-&gt;yLocation &gt;&gt; 16) - (top &gt;&gt; 16) + (myData-&gt;lineHeights[0] &gt;&gt; 16);
  offset-&gt;y = -offset-&gt;y;

  // create a color space
  CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
  require(colorSpace != NULL, CantCreateColorSpace);
  
  // allocating the memory for the actual pixels
  data = malloc(width * height * 4);
  require(data != NULL, CantAllocateData);
  
  // create a bitmap context
  context = CGBitmapContextCreate(data, width, height, 8, width * 4, colorSpace, kCGImageAlphaPremultipliedFirst);
  *outContext = context;
  require(context != NULL, CantCreateContext);

  // create a Data provider using the bitmap context's bitmap data for the drag image
  cgData = CGDataProviderCreateWithData(NULL, data, width * height * 4, Internal_HIATSUIViewFreeFunction);
  require(cgData != NULL, CantCreateDataProvider);
  
  // Create an Image using the Data Provider from the bitmap context.
  cgImage = CGImageCreate(width, height, 8, 32, width * 4, colorSpace, kCGImageAlphaFirst, cgData, NULL, false, kCGRenderingIntentDefault);
  *image = cgImage;
  CGColorSpaceRelease(colorSpace); colorSpace = NULL;
  CGDataProviderRelease(cgData); cgData = NULL;
  require(cgImage != NULL, CantCreateImage);

  // saving the context
  CGContextSaveGState(context);

  // translating the context to the selection area
  if (topLine != bottomLine)
    CGContextTranslateCTM(context, 0, -(bounds.size.height - (bottom &gt;&gt; 16)) + myData-&gt;originPoint.y);
  else
    CGContextTranslateCTM(context, -(startX &gt;&gt; 16), -(bounds.size.height - (bottom &gt;&gt; 16)) + myData-&gt;originPoint.y);

  // Letting ATSUI know that we draw in a CGContext instead of a QuickDraw port
  ATSUAttributeTag tags[] = { kATSUCGContextTag };
  ByteCount valueSizes[] = { sizeof(CGContextRef) };
  ATSUAttributeValuePtr values[] = { &amp;context };
  status = ATSUSetLayoutControls(myData-&gt;textLayout, 1, tags, valueSizes, values);
  require_noerr(status, CantDraw);
  
  // We start drawing at xLocation, yLocation if non-NULL,
  // else we calculate some reasonable margins
  ATSUTextMeasurement x = myData-&gt;xLocation, y = myData-&gt;yLocation;
  if (y == 0) y = FloatToFixed(bounds.size.height) - myData-&gt;lineHeights[0];
  else y = FloatToFixed(bounds.size.height) - y;
  if (x == 0) x = kXMargin;

  // Drawing all the lines, one by one
  // Since we had to reverse and translate the y axis, we need to back-reverse and translate
  // our coordinates to simulate the QuickDraw coordinates
  UniCharArrayOffset lineStart = 0, lineEnd;
  for (i = 0; i &lt; myData-&gt;numberOfLines; i++)
    {
    lineEnd = myData-&gt;endOfLines[i];

    // we do not want to draw any character outside of the selection
    if ((lineStart &lt;= start) &amp;&amp; (start &lt;= lineEnd)) lineStart = start;
    if ((lineStart &lt;= end) &amp;&amp; (end &lt;= lineEnd)) lineEnd = end;

    // Performance:
    // Let's draw only the lines which are visible within our bounds
    if (  (myData-&gt;lineHeights[i] &gt;= FloatToFixed(myData-&gt;originPoint.y)) &amp;&amp;
        ( (i == 0) || (myData-&gt;lineHeights[i-1] &lt;= FloatToFixed(myData-&gt;originPoint.y + bounds.size.height)) )  )
      {
      status = ATSUDrawText(myData-&gt;textLayout, lineStart, lineEnd-lineStart, x, y+myData-&gt;descents[i]);
      require_noerr(status, CantDraw);
      }

    y -= (myData-&gt;lineHeights[i+1] - myData-&gt;lineHeights[i]);
    lineStart = lineEnd;
    }

CantDraw:

  // restoring our context the way we found it when we started
  CGContextRestoreGState(context);
  
  // if we reach here, we keep all our allocations and return 
  return status;

CantCreateImage:
CantCreateDataProvider:
CantCreateContext:
CantAllocateData:
CantCreateColorSpace:

  // if we reach here, something went wrong and we need to deallocate all temps
  if (cgImage != NULL) CGImageRelease(cgImage);
  if (cgData != NULL) CGDataProviderRelease(cgData);
  if (context != NULL) CGContextRelease(context);
  if (data != NULL) free(data);
  if (colorSpace != NULL) CGColorSpaceRelease(colorSpace);

ParamErr:

  return status;
  }   // Internal_HIATSUIViewMakeCGImage

/*****************************************************
*
* Internal_HIATSUIViewDragSelection(myData, start, end, mouseLoc)
*
* Purpose:  Creates a CGImage that will be used when dragging text
*
* Inputs:   myData              - the view's private data
*        start               - the beginning of the selection
*        end                 - the end of the selection
*        mouseLoc            - the coordinate of the click
*
* Returns:  none 
*/
static void Internal_HIATSUIViewDragSelection(HIATSUIViewData * myData, UniCharArrayOffset start, UniCharArrayOffset end, HIPoint mouseLoc)
  {
  OSStatus status = noErr;
  PasteboardRef pasteboard = NULL;
  DragRef drag = NULL;
  RgnHandle theRegion = NULL;
  CGImageRef cgImage = NULL;
  CGContextRef context = NULL;
  
  // creating a temporary pasteboard reference
  status = PasteboardCreate(kPasteboardUniqueName, &amp;pasteboard); 
  require_noerr(status, CantCreatePasteboardForDrag);

  // putting the current selection in that pasteboard
  status = HIATSUIViewPutContentInPasteboard(myData-&gt;view, pasteboard, start, end);
  require_noerr(status, CantAddDataToTheDragPasteboard);

  // creating a drag reference with this pasteboard
  status = NewDragWithPasteboard(pasteboard, &amp;drag); 
  require_noerr(status, CantCreateDrag);

  // the Drag Manager is still Quickdraw-based
  EventRecord convertedEvent;
  convertedEvent.what = mouseDown; 
  GetGlobalMouse(&amp;(convertedEvent.where));
  convertedEvent.modifiers = 0;

  // we need a region even if empty
  theRegion = NewRgn(); 
  require(theRegion != NULL, CantCreateDrag);
  SetEmptyRgn(theRegion);

  // more interestingly, let's have a translucent drag with the selected text as an image
  HIPoint offset = mouseLoc;
  status = Internal_HIATSUIViewMakeCGImage(myData, start, end, &amp;cgImage, &amp;context, &amp;offset);
  require_noerr(status, CantCreateDrag);

  status = SetDragImageWithCGImage(drag, cgImage, &amp;offset, kDragRegionAndImage);
  require_noerr(status, CantCreateDrag);

  // start the drag
  status = TrackDrag(drag, &amp;convertedEvent, theRegion);
  if (status != userCanceledErr)
    require_noerr(status, CantTrackDrag);

CantTrackDrag:
CantCreateDrag:
CantAddDataToTheDragPasteboard:
CantCreatePasteboardForDrag:

  // let's cleanup
  if (theRegion != NULL) DisposeRgn(theRegion);
  if (cgImage != NULL) CGImageRelease(cgImage);
  if (context != NULL) CGContextRelease(context);
  if (drag != NULL) DisposeDrag(drag);
  if (pasteboard != NULL) CFRelease(pasteboard);
  
  return;
  }</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/TypeServicesForUnicode/listing1.html%3Fid%3DDTS10001097-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/TypeServicesForUnicode/listing1.html%3Fid%3DDTS10001097-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/TypeServicesForUnicode/listing1.html%3Fid%3DDTS10001097-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>