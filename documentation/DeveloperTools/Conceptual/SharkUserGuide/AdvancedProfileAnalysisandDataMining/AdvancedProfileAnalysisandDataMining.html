<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>Shark User Guide: Advanced Session Management and Data Mining</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Advanced Session Management and Data Mining"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP40005233-CH7" title="Advanced Session Management and Data Mining"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../index.html#//apple_ref/doc/uid/TP30000440-TP30000436" target="_top">Tools</a> &gt; <a href="../../../Performance-date.html#//apple_ref/doc/uid/TP30000440-TP30000436-TP30000901" target="_top">Performance</a> &gt; <a href="../Introduction/Introduction.html#//apple_ref/doc/uid/TP40005233-CH1-DontLinkElementID_6">Shark User Guide</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../SelectingExecutiontoSampleorTrace/SelectingExecutiontoSampleorTrace.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../CustomConfigurations/CustomConfigurations.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP40005233-CH7-SW2" title="Advanced Session Management and Data Mining"></a><h1>Advanced Session Management and Data Mining</h1><p>Often, the profile analysis windows can provide you with a very helpful view of your application’s behavior using the default settings. However, there are also many tools available in Shark that can help you sort through the large quantity of data that Shark can collect quite quickly. This chapter describes many of the techniques that you can use to adjust how data is presented if the profiles are providing you with too little or too much information.</p>
<!-- This template is being used for both PDF and HTML. -->

    
    <h4>In this section:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="AdvancedProfileAnalysisandDataMining.html#//apple_ref/doc/uid/TP40005233-CH7-SW4">Automatic Symbolication Troubleshooting</a>
				
			<br/>
			
        
			
			
				<a href="AdvancedProfileAnalysisandDataMining.html#//apple_ref/doc/uid/TP40005233-CH7-SW3">Manual Session Symbolication</a>
				
			<br/>
			
        
			
			
				<a href="AdvancedProfileAnalysisandDataMining.html#//apple_ref/doc/uid/TP40005233-CH7-SW51">Managing Sessions</a>
				
			<br/>
			
        
			
			
				<a href="AdvancedProfileAnalysisandDataMining.html#//apple_ref/doc/uid/TP40005233-CH7-SW1">Data Mining</a>
				
			<br/>
			
        
			
			
				<a href="AdvancedProfileAnalysisandDataMining.html#//apple_ref/doc/uid/TP40005233-CH7-SW53">Example: Using Data Mining with a Time Profile</a>
				
			<br/>
			
        
			
			
				<a href="AdvancedProfileAnalysisandDataMining.html#//apple_ref/doc/uid/TP40005233-CH7-SW58">Example: Graphical Analysis using Chart View with a Malloc Trace</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP40005233-CH7-SW4" title="Automatic Symbolication Troubleshooting"></a><h2>Automatic Symbolication Troubleshooting</h2><p>A common problem encountered by Shark users is a profile filled with instruction address ranges, instead of actual names, for all of the symbols (functions) in the program. Shark is very good at finding and using symbol information created by the compiler, but you do need to make sure that the compiler and linker actually record the correct symbol information, or you will be stuck deciphering cryptic address ranges instead of the names that you were expecting. This section explains how to solve some of the most common problems that can prevent Shark from finding and displaying the symbol names in your code.</p><a name="//apple_ref/doc/uid/TP40005233-CH7-SW47" title="Symbol Lookup"></a><h3>Symbol Lookup</h3><p>Shark records samples from the system in both user and supervisor code. In order to look up symbols for user space samples, the corresponding process is temporarily suspended while its memory is examined for symbols. Symbol lookup of user space samples will fail if the option to catch exiting processes (see <span class="content_text"><a href="../GettingStartedwithShark/GettingStartedwithShark.html#//apple_ref/doc/uid/TP40005233-CH2-SW5">“Shark Preferences”</a></span>) is disabled and the process is no longer running. In addition, if you need to profile a task which will exit before profiling is finished, then you should execute it with an absolute path (e.g. <code>/usr/local/bin/foo</code>) rather than a relative path (e.g. <code>../foo</code>). Otherwise you may not be able to examine program code in a Code Browser. Supervisor space symbol lookup is done by reconstructing the kernel and driver memory space from user accessible files: <code>/System/Library/Extensions</code> for drivers and other kernel extensions and <code>/mach_kernel</code> for kernel symbols. Samples from kernel extensions or drivers not in the locations specified on Shark’s Search Paths Preference pane (see <span class="content_text"><a href="../GettingStartedwithShark/GettingStartedwithShark.html#//apple_ref/doc/uid/TP40005233-CH2-SW5">“Shark Preferences”</a></span>) will fail symbol lookup. Developers who download the KernelDebugKit SDK   and mount the disk image are able to see source information for the kernel and base IOKit kernel extension classes (families).</p><p>If symbol lookup fails, Shark may present the missing “symbols” in two different ways. If the memory of the process is readable — for example, a binary that has had its symbols stripped — Shark tries to determine the range of the source function by looking for typical compiler-generated function prologue and epilogue sequences around the address of the sampled instruction. Symbol ranges gathered in this manner are listed as <code>address [length].</code> If the memory of a process is completely unreadable, the sample will be listed with the placeholder symbol <code>address [unreadable].</code></p><a name="//apple_ref/doc/uid/TP40005233-CH7-SW43" title="Debugging Information"></a><h3>Debugging Information</h3><p>In order for Shark to look up symbol information, the sampled application must contain debugging information generated by a compiler or linker.</p><p>It is almost always more useful to profile a release build rather than a debug build because compiler optimizations can drastically alter the performance profile of an application. Debug-style code is most often compiled without any optimizations at all <code>(-O0</code>). This makes debugging simpler, but produces non-optimal code. A profile of unoptimized code is misleading because it will often have different performance bottlenecks than optimized code. </p><a name="//apple_ref/doc/uid/TP40005233-CH7-SW48" title="Xcode"></a><h4>Xcode</h4><p>To generate debugging information in Xcode, select <em>Project→Edit Active</em> Target and go to the <em>GNU C/C++ Compiler</em> panel. Make sure that the <em>Generate Debug Symbols</em> checkbox is enabled. If you want to have your <em>Release</em> style products left unstripped (with symbol information), select the <em>Unstripped Product </em>checkbox.  Make sure that the <code>COPY_PHASE_STRIP</code> variable, if it is defined, is set to <code>NO</code>.</p><a name="//apple_ref/doc/uid/TP40005233-CH7-SW49" title="GCC/XLC/XLF"></a><h4>GCC/XLC/XLF</h4><p>If you are using command-line compilers such as GCC, XLC/XLF, and/or makefiles, use the “-g” compiler flag to specify that debugging information is generated</p><a name="//apple_ref/doc/uid/TP40005233-CH7-SW3" title="Manual Session Symbolication"></a><h2>Manual Session Symbolication</h2><p>It’s common practice for software built for public release to be stripped of debugging information (symbols and source locations). Although this reduces the overall size of the product and helps protect proprietary code against prying eyes, it makes it much more difficult to understand profiles taken with Shark. Shark doesn’t require debugging information to work, but it can be much more helpful if it’s available. In case you record a Shark session and discover that symbols have not been captured, then you can attempt to have Shark add them in afterwards.</p><br/><div><a name="//apple_ref/doc/uid/TP40005233-CH7-SW50" title="Figure 6-1Session Inspector: Symbols"></a><p><strong>Figure 6-1&nbsp;&nbsp;</strong>Session Inspector: Symbols</p><img src = "../Art/SessionSymbols.jpg" alt = "Session Inspector: Symbols" ></div><br/><p>The most common way to “symbolicate” or add symbols (along with other debugging information) to your session is to simply use the <em>File→Symbolicate...</em> command. With this command, you can quickly choose a symbol-rich application binary to attach to your Shark session, even if the original measurement was taken using a symbol-free binary.</p><p>Shark’s <em>Session Inspector</em> window (see <span class="content_text"><a href="../GettingStartedwithShark/GettingStartedwithShark.html#//apple_ref/doc/uid/TP40005233-CH2-SW7">“Session Windows and Files”</a></span>) also allows you to add debugging information to a session. This technique requires more steps, but is recommended if you are adding symbols from a dynamic library used by your application, instead of the application itself, or if you need to selectively add symbols from many different application binary files. The <em>Symbols</em> tab (1) in the window shows you the list of all the profiled executables in the session, along with the libraries and frameworks they were linked with. The <em>Process</em> popup (2) allows you to select the application you’re interested in inspecting or symbolicating. Each row of the table lists the name, version (if available) and creation date of each binary. The full path of each binary is displayed as a tooltip for each entry in the <em>Name</em> column (3). To symbolicate any particular binary, double-click on its entry in the table or select it and click the <em>Symbolicate</em> button (4).</p><p>No matter which way you choose to get here, you will be presented with a <em>Symbolication</em> dialog (<span class="content_text">Figure 2-20</span>).</p><br/><div><a name="//apple_ref/doc/uid/TP40005233-CH7-SW13" title="Figure 6-2Symbolication Dialog"></a><p><strong>Figure 6-2&nbsp;&nbsp;</strong>Symbolication Dialog</p><img src = "../Art/figure2-16.jpg" alt = "Symbolication Dialog" ></div><br/><p>Use this dialog to select a symbol-rich (but otherwise identical) version of the binary you are symbolicating. The version, creation date and size is shown for both the original and selected binary. For maximum flexibility Shark does not restrict what you can select in any way. But it does indicate when something might be wrong with the selection you have made by highlighting potential problems. Ideally, this is the list of attributes that Shark expects for a good match:</p><ul class="ul"><li class="li"><p>The name of the original and symbol-rich binaries should match (for bundles, this is the bundle name). Also, for bundles, the version strings should match.</p></li><li class="li"><p>The creation date of the symbol-rich binary should be the same or earlier than the stripped version.</p></li><li class="li"><p>The size of the symbol-rich binary should be larger than the stripped version.</p></li></ul><p>Shark will warn you if you select a binary that is potentially problematic. If you do happen to select an executable that isn’t a good match, the profile results will be incorrect. <span class="content_text">“Heavy View”</span> and <span class="content_text">“Tree View”</span> show an example session before and after symbolication.</p><br/><div><a name="//apple_ref/doc/uid/TP40005233-CH7-SW14" title="Figure 6-3Before Symbolication"></a><p><strong>Figure 6-3&nbsp;&nbsp;</strong>Before Symbolication</p><img src = "../Art/figure2-17.jpg" alt = "Before Symbolication" ></div><br/><br/><div><a name="//apple_ref/doc/uid/TP40005233-CH7-SW15" title="Figure 6-4After Symbolication"></a><p><strong>Figure 6-4&nbsp;&nbsp;</strong>After Symbolication</p><img src = "../Art/figure2-18.jpg" alt = "After Symbolication" ></div><br/><a name="//apple_ref/doc/uid/TP40005233-CH7-SW51" title="Managing Sessions"></a><h2>Managing Sessions</h2><p>If you have multiple sessions measuring the same application, it is possible to use Shark to compare or merge those sessions with each other.</p><a name="//apple_ref/doc/uid/TP40005233-CH7-SW44" title="Comparing Sessions"></a><h3>Comparing Sessions</h3><p>Shark can be used for tracking performance regressions. Shark allows you to compare the contents of two session files sampling the same process through the <em>File</em>→<em>Compare</em>... menu item (<em>Command-Option-C</em>). Note that processes are identified by name rather than process ID (PID) by default when comparing sessions, so do not change the name of your program between sessions if you want to use this command.</p><p>When used, a new session is created from two existing ones: Session A and Session B. The first session (Session A) is given a negative scaling factor, and the second session (Session B) is given a positive scaling factor. The result of a compare operation is a new session with negative profile entries for more samples in the earlier session (Session A), and positive profile entries for more samples in the later session (Session B).</p><p>The magnitude of the scaling factor is adjusted according to the number of samples in each session so that both sessions are given equal total weight. In the case of comparing two sessions with an equal number of samples, the scaling factor for Session A is -1.0, and for Session B is +1.0.</p><a name="//apple_ref/doc/uid/TP40005233-CH7-SW52" title="Example"></a><h4>Example</h4><p>As an example of how the session comparison algorithm works, let’s say that Session A has 400 samples in process <code>foo</code>, and Session B has 440 samples in process <code>foo</code>. The total weight for process <code>foo</code> in the combined session will be 840. </p><p>If in Session A there were 80 samples for function <code>bar()</code> in process <code>foo</code>, and in Session B there were 120 samples for function <code>bar()</code> in process <code>foo</code>, the value of <code>bar()</code> is 120 – 80 = +40. The value shown for <code>bar()</code> would be (+40 / 840) * 100 = +4.8%. Note that the meaning of percentage is consistent with the standard time profile display — the baseline is the total count for the currently selected scope (system, process or thread).</p><a name="//apple_ref/doc/uid/TP40005233-CH7-SW45" title="Merging Sessions"></a><h3>Merging Sessions</h3><p>If you have profiled the individual components that make up a workload separately, you may want to merge the resulting sessions into a single file. Shark can merge two session files through a process similar to comparing them. The only difference is that each source session file is given a scaling factor of +1.0. Select the <em>File</em>→<em>Merge</em>... menu item (<em>Command-Option-M</em>).</p><a name="//apple_ref/doc/uid/TP40005233-CH7-SW1" title="Data Mining"></a><h2>Data Mining</h2><p>By default, Shark groups samples by symbol (although other groupings such as address, library and source line are also possible using the controls described previously in <span class="content_text"><a href="AdvancedProfileAnalysisandDataMining.html#//apple_ref/doc/uid/TP40005233-CH7-SW4">“Automatic Symbolication Troubleshooting”</a></span>). Although this is often sufficient, judiciously filtering out pieces of a profile can in some cases make it easier to analyze. Data mining allows you to hide samples that may obscure important behavioral or algorithmic characteristics in a profile.</p><a name="//apple_ref/doc/uid/TP40005233-CH7-SW26" title="Callstack Data Mining"></a><h3>Callstack Data Mining</h3><p>In order to understand how to use data mining to better understand your application, it is necessary to first understand a few fundamental concepts about samples and callstacks. Each Shark session contains some number of samples. Each sample contains contextual information such as where and when it was taken (process and thread ID, timestamp) as well as the callstack information for how the sampled thread of execution arrived at the current program counter address. An example of several callstacks is shown in <span class="content_text">Figure 6-5</span>.</p><p>Each callstack is made up of <em>N</em> stack frames (<em>N</em>=4 in the case of Sample 1). Note that when a sample is taken, the program’s stack pointer points to the leaf entry at <em>N</em>-1 (<code>cos</code> in the first sample). When Shark builds up a call tree to analyze how routines call each other, “self” counts in the profile browser are simply the number of samples where this routine is the leaf entry function. Therefore, the “self” count represents the amount of time that code within the function was executing. In contrast, “total” counts are the number of samples where this function appears at <em>any</em> point in a callstack, and therefore represents the summation of a function’s execution time <em>and</em> the time of all functions that it calls.</p><p>Shark can combine samples into call trees in two different ways. <span class="content_text">Figure 6-6</span> depicts the “Heavy” call tree assembled from the example samples, while <span class="content_text">Figure 6-7</span> shows the corresponding “Tree” view. As you can see, the “heavy” view starts from the leaf functions and builds towards the base of the callstack, while the “tree” view starts at the base of the callstack and works down to the leaves. The former view is usually better for finding out which parts of your program are executing most often, while the latter is often better for finding large routines farther down the callstack that call many other routines in the course of their execution. Once you have a clear picture of how callstacks are converted into call trees, it is easier to understand the application of the data mining operations.</p><br/><div><a name="//apple_ref/doc/uid/TP40005233-CH7-SW5" title="Figure 6-5Example Callstacks"></a><p><strong>Figure 6-5&nbsp;&nbsp;</strong>Example Callstacks</p><img src = "../Art/AnalysisSamples.jpg" alt = "Example Callstacks" ></div><br/><br/><div><a name="//apple_ref/doc/uid/TP40005233-CH7-SW6" title="Figure 6-6Heavy View"></a><p><strong>Figure 6-6&nbsp;&nbsp;</strong>Heavy View</p><img src = "../Art/AnalysisHeavy.jpg" alt = "Heavy View" ></div><br/><br/><div><a name="//apple_ref/doc/uid/TP40005233-CH7-SW7" title="Figure 6-7Tree View"></a><p><strong>Figure 6-7&nbsp;&nbsp;</strong>Tree View</p><img src = "../Art/AnalysisTree.jpg" alt = "Tree View" ></div><br/><p>Shark’s Data Mining operations allow you to prune down call trees in order to make them easier to understand. While the small call trees in the preceding figures are fairly simple, in real applications with hundreds and thousands of symbols, the call trees can be huge. As a result, it is often useful to consolidate or prune off sections of the call trees that do not add useful information, in order to simplify the view that Shark provides in controlled ways. For example, you often won’t care about the exact places that samples occur within MacOS X’s extensive libraries — only which of <em>your</em> functions are calling them too much. Data Mining can help with simplifications like this. It is accessible in three different ways.</p><br/><div><a name="//apple_ref/doc/uid/TP40005233-CH7-SW42" title="Figure 6-8Data Mining Advanced Settings"></a><p><strong>Figure 6-8&nbsp;&nbsp;</strong>Data Mining Advanced Settings</p><img src = "../Art/DataMiningAdvanced.jpg" alt = "Data Mining Advanced Settings" ></div><br/><p>The <em>Advanced Settings</em> drawer (<span class="content_text">Figure 6-8</span>), in its lower half, contains the following controls that apply filtering to an entire session. This is a great way for making a few common quick trims to too-complex callstack trees.</p><ol class="ol"><li class="li"><p><strong>Apply Callstack Data Mining</strong>— Global control that toggles the use of all data mining controls en masse, good for quickly comparing your results before and after data mining.</p></li><li class="li"><p><strong>Charge System Libraries to Callers</strong>— Removes any callstack frames from system libraries and frameworks, effectively reassigning time spent in those functions to the callers. This is often quite useful, as you cannot usually modify the system libraries directly, but only your code that calls them. Samples from system libraries that aren’t called from user code, such as the system idle loop, disappear entirely.</p></li><li class="li"><p><strong>Charge Code without Debug Info to Callers</strong>— Removes any callstack frames from code without debugging information, effectively reassigning time spent in those functions to the callers. In a typical development environment, this will effectively show all samples only in source code that you own and compiled using a flag such as ‘–g’ with GCC or XLC, and in the process eliminating a lot of user-level code that you probably do not have control over. Samples from code that isn’t called from debug-friendly code are eliminated entirely.</p></li><li class="li"><p><strong>Hide Weight &lt; N</strong>— Hides any granules that have a total weight less than the specified limit. This macro helps reduce visual noise caused by granules (i.e. symbols) that only trigger a sample or two, making it easier to see the overall profile.</p></li><li class="li"><p><strong>Flatten Recursion</strong>— For each branch in the call tree, this collapses functions that call themselves into a single entry, removing all of the recursive calls entirely from the trace.</p></li><li class="li"><p><strong>Flatten System Libraries</strong>— Chops off the top of callstacks beyond the entry points into system libraries, so that any samples from the libraries are only identified by the entry points. </p></li><li class="li"><p><strong>Remove Supervisor Callstacks</strong>— Completely removes (<em>without</em> charging to the callers) all samples in the profile from supervisor code (kernel and drivers). </p></li><li class="li"><p><strong>Granule List</strong>— Displays a list of particular granules that you have identified for data mining, using the menu controls described next, along with the name of the operation applied to that granule. You can modify the operation used to mine them using the menu associated with this name.</p></li></ol><p>A<em>Data Mining</em> menu appears in the menu bar whenever a Shark session is open. The menu contains the following items that allow you to selectively apply data mining to particular granules in your code:</p><ol class="ol"><li class="li"><p><strong>Charge Symbol <em>X</em> to Callers</strong>— Removes any callstack frames containing the symbol <em>X</em>, and frames of functions called by <em>X</em>, effectively reassigning time spent in those functions to the callers. </p></li><li class="li"><p><strong>Charge Library to <em>X</em> Callers</strong>— Removes any callstack frames containing the specified library, effectively reassigning samples to the callers of the library.</p></li><li class="li"><p><strong>Flatten Library <em>X</em></strong>— Removes all but the first callstack frame for the specified library, attributing all samples in interior functions to the entry points of the library.</p></li><li class="li"><p><strong>Remove Callstacks with Symbol <em>X</em></strong>— All callstacks that contain the specified symbol are removed from the profile; samples in matching callstacks are discarded.</p></li><li class="li"><p><strong>Retain Callstacks with Symbol <em>X</em></strong>— Overrides all of the above operations for any callstack that contains the specified symbol.</p></li><li class="li"><p><strong>Restore All</strong>— Undo all <em>Charge To</em>, <em>Flatten</em>, <em>Remove</em>, and <em>Retain</em> operations.</p></li><li class="li"><p><strong>Focus Symbol <em>X</em></strong>— Makes the specified symbol the root of the call tree; removes symbols and samples above (callers to) this symbol in the call tree and remove callstacks that do not contain this symbol. This allows you to quickly eliminate all samples but those from an interesting part of a program.</p></li><li class="li"><p><strong>Focus Library <em>X</em></strong>— Makes the specified library the root of the call tree; removes symbols and samples above (callers to) this library in the call tree and remove callstacks that do not contain this library.</p></li><li class="li"><p><strong>Focus Callers of Symbol <em>X</em></strong>— Removes functions called by the specified symbol and removes callstacks that do not contain the specified symbol. </p></li><li class="li"><p><strong>Focus Callers of Library <em>X</em></strong>— Removes functions called by the specified library and removes callstacks that do not contain the specified library.</p></li><li class="li"><p><strong>Unfocus All</strong>— Undo all <em>Focus</em> operations. </p></li></ol><p>This same menu appears as a contextual menu on entries in the <em>Heavy</em>, <em>Tree</em> and <em>Callstack</em> results tables. While the mouse is held over a line in a table, you can control-click (or right-click) to bring up the menu, as is shown in (<span class="content_text">Figure 6-9</span>). </p><br/><div><a name="//apple_ref/doc/uid/TP40005233-CH7-SW8" title="Figure 6-9Contextual Data Mining Menu"></a><p><strong>Figure 6-9&nbsp;&nbsp;</strong>Contextual Data Mining Menu</p><img src = "../Art/figure3-5.jpg" alt = "Contextual Data Mining Menu" ></div><br/><a name="//apple_ref/doc/uid/TP40005233-CH7-SW46" title="Perf Count Data Mining"></a><h3>Perf Count Data Mining</h3><p>In addition to data mining based on callstack symbol and library information, it is also possible to filter out samples based on associated performance count information (if available), using the <em>Perf Count Data Mining</em> palette (<span class="content_text">Figure 6-10</span>). The available “perf count” data mining operations are:</p><ul class="spaceabove"><li class="li"><p><strong>Equal (==)</strong>— Removes callstacks with perf counts equal to the specified value.</p></li><li class="li"><p><strong>Not Equal (!=)</strong>— Removes callstacks with perf counts not equal to the specified value.</p></li><li class="li"><p><strong>Greater Than (>)</strong>— Removes callstacks with perf counts greater than the specified value.</p></li><li class="li"><p><strong>Less Than (&lt;)</strong>— Removes callstacks with a perf counts less than the specified value.</p></li></ul><p>The <em>Perf Count Data Mining</em> palette also supplies a global enable/disable toggle, much like the one available with conventional data mining, and check boxes for toggling the visibility of perf count information (the eye column) and whether or not the perf count data is accumulated across processors (the Σ column), on a per-counter basis.</p><br/><div><a name="//apple_ref/doc/uid/TP40005233-CH7-SW9" title="Figure 6-10Perf Count Data Mining Palette"></a><p><strong>Figure 6-10&nbsp;&nbsp;</strong>Perf Count Data Mining Palette</p><img src = "../Art/figure3-6.jpg" alt = "Perf Count Data Mining Palette" ></div><br/><a name="//apple_ref/doc/uid/TP40005233-CH7-SW53" title="Example: Using Data Mining with a Time Profile"></a><h2>Example: Using Data Mining with a Time Profile</h2><p>Our first example uses Shark’s data mining tools to help isolate a performance problem from a time profile of the Sketch demo program. If you want to follow along with the demo, it is available in <code>/Developer/Applications/Examples/AppKit/Sketch</code>.</p><a name="//apple_ref/doc/uid/TP40005233-CH7-SW35" title="A Performance Problem... "></a><h3>A Performance Problem... </h3><ol class="ol"><li class="li"><p>Launch Sketch (located in <code>/Developer/Applications/Examples/AppKit/Sketch/build/</code> after you build the project with Xcode)</p></li><li class="li"><p>Make four shapes as shown in <span class="content_text">Figure 6-11</span></p><div class="item_figure"><a name="//apple_ref/doc/uid/TP40005233-CH7-SW10" title="Figure 6-11Example Shapes"></a><p><strong>Figure 6-11&nbsp;&nbsp;</strong>Example Shapes</p><img src = "../Art/Figure1-1_DMT.jpg" alt = "Figure 1-1" ></div></li><li class="li"><p>Repeat the following steps until the app becomes sluggish (takes a half second or second to select all):</p><ul class="ul"><li class="li"><p>Select All (<em>Command-A</em>)</p></li><li class="li"><p>Copy (<em>Command-C</em>)</p></li><li class="li"><p>Paste (<em>Command-V</em>)</p></li></ul><p>This should take 8-10 times (maybe more) depending on hardware.  When you are done it should look something similar to <span class="content_text">Figure 6-12</span></p><div class="item_figure"><a name="//apple_ref/doc/uid/TP40005233-CH7-SW11" title="Figure 6-12Example Shapes, Replicated"></a><p><strong>Figure 6-12&nbsp;&nbsp;</strong>Example Shapes, Replicated</p><img src = "../Art/Figure1-2.jpg" alt = "Figure 1-2" ></div></li><li class="li"><p>Click in blank area of the window to deselect all the shapes.</p></li><li class="li"><p>Do select all and notice how long it takes for all of them to be selected.  This is a performance problem.</p></li></ol><a name="//apple_ref/doc/uid/TP40005233-CH7-SW54" title="Taking Samples"></a><h3>Taking Samples</h3><ol class="ol"><li class="li"><p>Launch Shark  (in <code>/Developer/Applications/Performance Tools/</code>)</p></li><li class="li"><p>Target your application by selecting the “Sketch” process, as shown in <span class="content_text">Figure 6-13</span>.</p><p>The start button will start and stop sampling.  The Everything/Process pop-up will let you choose whether you wish to sample the entire system or just a single process.  The Time Profile pop-up will let you choose different types of sampling that you can perform. In this case we will switch the System/Process pop-up to Process (to target a single process.)</p><p>This reveals a third pop-up button that you can use to target your application.  Select Sketch from the list of running applications.</p><div class="item_figure"><a name="//apple_ref/doc/uid/TP40005233-CH7-SW12" title="Figure 6-13Sampling a Specific Process"></a><p><strong>Figure 6-13&nbsp;&nbsp;</strong>Sampling a Specific Process</p><img src = "../Art/Figure1-4-Sampling_Specific_Process.jpg" alt = "Sampling a Specific Process" ></div></li><li class="li"><p>Switch back to Sketch and make sure nothing is selected.</p></li><li class="li"><p>Move the Sketch window to expose the Shark window (optional but makes things easier).</p></li><li class="li"><p>Press <em>Option-Escape</em> to start sampling.</p></li><li class="li"><p>Press <em>Command-A</em> to select all and wait for the operation to complete.</p></li><li class="li"><p>Press <em>Option-Escape</em> to stop Sampling and you will get a window that looks like <span class="content_text">Figure 6-14</span>.</p><div class="item_figure"><a name="//apple_ref/doc/uid/TP40005233-CH7-SW55" title="Figure 6-14Default Profile View"></a><p><strong>Figure 6-14&nbsp;&nbsp;</strong>Default Profile View</p><img src = "../Art/Figure1-5-Deafult_Profile_view.jpg" alt = "Default Profile View" ></div></li></ol><a name="//apple_ref/doc/uid/TP40005233-CH7-SW39" title="High Level Analysis"></a><h3>High Level Analysis</h3><p>The session window gives you by default a summary of all the functions that the sampler found samples in and the percentage of the samples that were found there.  So in the example, 14.1% of the samples were found in <code>objc_msgSend</code>. This view is very useful for doing analysis of performance when the bottlenecks occur in leaf functions. As you can see, the above window gives you a lot of detail about where your program is spending time, but unfortunately it is at too low a level to be of use to the developer of Sketch, or even the developers of the Frameworks that Sketch depends on.</p><p>To get at the parts of the program that are of most interest to the developer of Sketch, you can do the following:</p><ol class="ol"><li class="li"><p>In the <em>Window</em> menu, choose <em>Show Advanced Settings...</em>. This will open a drawer with the data mining palette, among other things, as was shown in <span class="content_text"><a href="AdvancedProfileAnalysisandDataMining.html#//apple_ref/doc/uid/TP40005233-CH7-SW2">“Advanced Session Management and Data Mining.”</a></span> We will go over each of these areas in more detail later. For now, let's turn on a couple of cool features. In the <em>Profile Analysis Palette</em>, do the following:</p><ul class="ul"><li class="li"><p>Click on the <em>Stats Display</em> pop-up and select <em>Value</em>.  This lets you the actual counts for the samples rather than percentage.  This may be more intuitive for some users than weighting by %, especially while you are going through this tutorial.  Use whichever you prefer.</p></li><li class="li"><p> Click on the <em>Weight by:</em> pop-up and select <em>Time</em>.  You will see the samples displayed as the time spent in that function rather than counts.</p></li><li class="li"><p>Check the <em>Color by Library</em> checkbox. This will display the text of symbols and library names in different colors based on the library they came from.  This is handy for visually identifying groups of related functions.</p></li></ul></li><li class="li"><p>In the <em>Data Mining Palette</em> box, check <em>Charge System Libraries to Callers</em>. This will eliminate system libraries and frameworks, and charge the cost of their calls to  the application level functions or methods that are calling them.</p></li><li class="li"><p>Click on the callstack <img src = "../Art/call_stack_button.jpg" alt = "Call Stack Button" > button on the lower right corner of the table to reveal the callstack pane, as shown in <span class="content_text">Figure 6-15</span>.  As you click on symbols on the left, the callstack pane will show you the stack leading up to the selected symbol.  Since system libraries and frameworks were filtered out in the previous step, you will only see your application's symbols. Note that if you click on a symbol in the callstack pane, the outline on the left will automatically expand the outline to show that symbol.</p><div class="item_figure"><a name="//apple_ref/doc/uid/TP40005233-CH7-SW18" title="Figure 6-15Navigation Via the Call-Stack Pane"></a><p><strong>Figure 6-15&nbsp;&nbsp;</strong>Navigation Via the Call-Stack Pane</p><img src = "../Art/Figure1-7-Navigation.jpg" alt = "Navigation Via the Call-Stack Pane" ></div></li><li class="li"><p>Click on the <img src = "../Art/Heavy.jpg" alt = "Heavy" > pop-up menu on the lower right corner of the window and select <img src = "../Art/Heavy_Tree.jpg" alt = "Heavy and Tree" > to split it in half.  The top half will continue to show the Heavy View ("Bottom-Up View") of the samples and the bottom will show the Tree View ("Top-Down View").</p><p>If you click on the symbol main in the bottom pane, you will see that the callstack view on the right will show the stack, as shown in <span class="content_text">Figure 6-16</span>. This view will control navigation for whichever outline that was last selected</p><div class="item_figure"><a name="//apple_ref/doc/uid/TP40005233-CH7-SW19" title="Figure 6-16Navigation Via the Call-Stack Pane with Tree View"></a><p><strong>Figure 6-16&nbsp;&nbsp;</strong>Navigation Via the Call-Stack Pane with Tree View</p><img src = "../Art/Figure1-8-Navigation.jpg" alt = "Navigation Via the Call-Stack Pane" ></div></li><li class="li"><p>Looking at this outline, we see there are two areas where a lot of time is being spent: <code>-[SKTGraphicView drawRect:]</code> and  <code>-[SKTGraphicView selectAll:]</code>.  Let's look at the <code>selectAll</code> method first.   </p></li></ol><a name="//apple_ref/doc/uid/TP40005233-CH7-SW40" title="Analysis Via Source Navigation"></a><h3>Analysis Via Source Navigation</h3><p>The following is an example of doing interior analysis across a few levels of function calls.</p><ol class="ol"><li class="li"><p>Open up the tree view as shown in <span class="content_text">Figure 6-16</span>.</p></li><li class="li"><p>Double click on the symbol <code>-[SKTGraphicView selectAll:]</code> in the tree view above. You will see a source window that looks like <span class="content_text">Figure 6-17</span></p><div class="item_figure"><a name="//apple_ref/doc/uid/TP40005233-CH7-SW20" title="Figure 6-17Source View: SKTGraphicView selectAll"></a><p><strong>Figure 6-17&nbsp;&nbsp;</strong>Source View: SKTGraphicView selectAll</p><img src = "../Art/Figure1-10-Source_View.jpg" alt = "Source View" ></div><p>The code browser uses yellow to indicate sample counts that occur in this function or functions called by that function.</p></li><li class="li"><p>Double-click on the yellow colored line to navigate to the function (performSelector) called here.  When the new source window comes up, double-click in the yellow area marked with 2.7 s. This will display the counts for this code, which should look like <span class="content_text">Figure 6-18</span>:</p><div class="item_figure"><a name="//apple_ref/doc/uid/TP40005233-CH7-SW21" title="Figure 6-18Source View: NSObject"></a><p><strong>Figure 6-18&nbsp;&nbsp;</strong>Source View: NSObject</p><img src = "../Art/Figure1-11-Source_View.jpg" alt = "Source View" ></div><p>Before we go on, please notice that this is a <code>for</code> loop that iterates over all the items in the array, which in this case is the array of all the graphic objects stored in Sketch's model.</p></li><li class="li"><p>Double-click on the yellow colored line <code>[self performSelector: sel withObject:[array ObjectAtIndex:i]];</code> and you'll get <span class="content_text">Figure 6-19</span>:</p><div class="item_figure"><a name="//apple_ref/doc/uid/TP40005233-CH7-SW22" title="Figure 6-19Source View: SKTGraphicView selectGraphic"></a><p><strong>Figure 6-19&nbsp;&nbsp;</strong>Source View: SKTGraphicView selectGraphic</p><img src = "../Art/Figure1-12-Source_View.jpg" alt = "Source View" ></div><p>There are several hotspots here:</p><ul class="simple-spaceabove"><li><p>At line 116, there is a call to <code>indexOfObjectIdenticalTo:graphic</code>. This is a linear search of the selected graphics. Since we are doing a "select all" operation, this is a linear search inside of a linear search. You have just found a fundamentally O(N<sup>2</sup>) operation. Interestingly, this is not where most of the time is being spent.</p></li><li><p>The operation in lines 118 and 119 appears to be an expensive framework call.  This should be hoisted out of the <code>performSelector: OnEachObjectInArray</code> loop and done once, if possible. If we were the framework developers, it might also be interesting to investigate why these calls are so costly.</p></li><li><p>Line 121 shows a call out to <code>-[SKTGraphicView invalidateGraphic]</code>.  Let's dig deeper into this since this is in Sketch's code.</p></li></ul></li><li class="li"><p>Double-click on <code>[self invalidateGraphic:graphic];</code> and you'll get <span class="content_text">Figure 6-20</span>. This contains one line of expensive code that tests for nested objects.</p><div class="item_figure"><a name="//apple_ref/doc/uid/TP40005233-CH7-SW23" title="Figure 6-20Source View: SKTGraphicView invalidateGraphic"></a><p><strong>Figure 6-20&nbsp;&nbsp;</strong>Source View: SKTGraphicView invalidateGraphic</p><img src = "../Art/Figure1-13-Source_View.jpg" alt = "Source View" ></div></li></ol><p>It is interesting to note that even with this fairly quick analysis we have already identified several glaring problems. The first problem we found was O(N<sup>2</sup>) behavior introduced by our code implementation hiding within functions and the use of abstraction.  In general it is good to create and use abstraction in your coding.  However, doing so can unintentionally introduce unnecessary performance pitfalls.  Each of these functions is well conceived locally, but when they are used together they combine to have poor scalability. Second, we used expensive framework calls (in this case, to the undo manager) inside of a loop. Since undoing each step of a “select all” operation really isn’t necessary, the expensive call can be moved up to a higher level, in order to just undo all of the selects at once. This is an example of hoisting functionality to a higher level in the execution tree. Finally, the <code>invalidateGraphic</code> routine was doing some heavyweight testing, and it would clearly be worthwhile to see if we can move this testing outside of the inner loops, if possible.</p><a name="//apple_ref/doc/uid/TP40005233-CH7-SW56" title="Introduction To Focusing"></a><h3>Introduction To Focusing</h3><p>This example will take us through analyzing the behavior of drawing the selected rectangles.  Here, we will develop ideas for analyzing larger and more complex programs (or frameworks) that involve multiple libraries. In doing so, we will introduce the Analysis menu/context menu and the ideas of focusing and filtering. This example will use system frameworks to demonstrate the ideas but the principles apply just as well to any large-scale application built as a collection of modules.</p><ol class="ol"><li class="li"><p>Close all the source windows from the analysis of <code>-[SKTGraphicView selectAll:]</code> by clicking on the close buttons in the tabs of the tab view.</p></li><li class="li"><p>Switch to the profile tab and do option click on the top most disclosure triangle to close all of the triangles.</p></li><li class="li"><p>Open the first two levels so it looks like <span class="content_text">Figure 6-21</span>:</p><div class="item_figure"><a name="//apple_ref/doc/uid/TP40005233-CH7-SW24" title="Figure 6-21Tree view before focusing"></a><p><strong>Figure 6-21&nbsp;&nbsp;</strong>Tree view before focusing</p><img src = "../Art/Figure1-14.jpg" alt = "Figure 1-14" ></div></li><li class="li"><p>Select <code>-[SKTGraphicView drawRect:]</code> and control-click to bring up a contextual menu which contains the focus and exclusion operations available in Shark (the operations in this menu are also available via the <em>Data Mining</em> Menu in the menu bar).  It looks like <span class="content_text">Figure 6-22</span>.</p><div class="item_figure"><a name="//apple_ref/doc/uid/TP40005233-CH7-SW25" title="Figure 6-22Data Mining Contextual Menu"></a><p><strong>Figure 6-22&nbsp;&nbsp;</strong>Data Mining Contextual Menu</p><img src = "../Art/Figure1-15-Data_Mining_Contextual.jpg" alt = "Data Mining Contextual Menu" ></div><p>In this tutorial we'll describe and demonstrate a few of them as well. A full description of these operations is given in <span class="content_text"><a href="AdvancedProfileAnalysisandDataMining.html#//apple_ref/doc/uid/TP40005233-CH7-SW26">“Callstack Data Mining.”</a></span></p></li><li class="li"><p>Choose "Focus Symbol <code>-[SKTGraphicView drawRect:]</code>"  and you will get something that looks like <span class="content_text">Figure 6-23</span></p><div class="item_figure"><a name="//apple_ref/doc/uid/TP40005233-CH7-SW27" title="Figure 6-23After Focus Symbol -[SKTGraphicView drawRect:]"></a><p><strong>Figure 6-23&nbsp;&nbsp;</strong>After Focus Symbol -[SKTGraphicView drawRect:]</p><img src = "../Art/Figure1-16-After_Focus.jpg" alt = "After Focus Symbol -[SKTGraphic View drawRect:]" ></div><p>The bottom pane (Tree view) is now rooted on the symbol that we focused on and the items in the top pane (Heavy view) have changed to reflect only the leaf times relative to the execution tree under this new root. In the Heavy view, we see that the most time is spent in <code>-[SKTGraphic drawHandleAtPoint: inView]</code>. We'll come back to this in a bit.</p><p>It is also worth noting that if you look in the <em>Advanced Settings</em> drawer at the bottom of the data mining controls (you may need to scroll down the drawer if your document window is small), you will see an entry for the symbol you just focused in the list of symbols.  You can change the focus behavior here at any time by clicking in the pop-up next to the symbol name.  
</p></li><li class="li"><p>Expand <code>-[SKTGraphicView drawRect:]</code> in the bottom outline a few times until it looks likes like<span class="content_text">Figure 6-24</span>:</p><div class="item_figure"><a name="//apple_ref/doc/uid/TP40005233-CH7-SW28" title="Figure 6-24After focus and expansion"></a><p><strong>Figure 6-24&nbsp;&nbsp;</strong>After focus and expansion</p><img src = "../Art/Figure1-17.jpg" alt = "Figure 1-17" ></div><p>There are two interesting things here:</p><ul class="ul"><li class="li"><p>The self time is pretty large in this function</p></li><li class="li"><p>A lot of time is spent in <code>-[SKTGraphic drawHandleAtPoint: inView]</code></p></li></ul><p>Let's look at the self time first.</p></li><li class="li"><p>Double click on <code>-[SKTGraphic drawInView:isSelected]</code> to see the source, as shown in <span class="content_text">Figure 6-25</span>:</p><div class="item_figure"><a name="//apple_ref/doc/uid/TP40005233-CH7-SW29" title="Figure 6-25Source View: SKTGraphic drawInView:isSelected:"></a><p><strong>Figure 6-25&nbsp;&nbsp;</strong>Source View: SKTGraphic drawInView:isSelected:</p><img src = "../Art/Figure1-18-Source_View.jpg" alt = "Source View" ></div><p>Here we see that time is split pretty evenly between the AppKit graphics primitive <code>[path stroke]</code> and the call to <code>-[SKTGraphic drawHandleAtPoint: inView]</code>. The only option for a developer to deal with the AppKit graphics primitive is to consider using raw Quartz calls, an option that we'll look into using NSBezierPath a bit later. For now, let's take a look at <code>-[SKTGraphic drawHandleAtPoint:inView]</code>.</p></li><li class="li"><p>Double click on line 406 on the text <code>-[self drawHandlesInView: view]</code> and you'll get <span class="content_text">Figure 6-26</span>:</p><div class="item_figure"><a name="//apple_ref/doc/uid/TP40005233-CH7-SW30" title="Figure 6-26Source View: SKGraphic drawHandlesInView:"></a><p><strong>Figure 6-26&nbsp;&nbsp;</strong>Source View: SKGraphic drawHandlesInView:</p><img src = "../Art/Figure1-19-SKGraphic.jpg" alt = "-[SKGraphic drawHandlesAtPoint:inView]" ></div><p>This continues on with other calls to <code>[self drawHandleAtPoint: inView]</code>, so it's been elided for brevity.</p></li><li class="li"><p>Double click on line 502 in the text <code>[self drawHandleAtPoint: ...]</code> and it will take you to the code for <code>[SKTGraphicview drawHandleAtPoint: ...]</code> which is shown in <span class="content_text">Figure 6-27</span></p><div class="item_figure"><a name="//apple_ref/doc/uid/TP40005233-CH7-SW31" title="Figure 6-27Source View: SKGraphic drawHandleAtPoint:inView:"></a><p><strong>Figure 6-27&nbsp;&nbsp;</strong>Source View: SKGraphic drawHandleAtPoint:inView:</p><img src = "../Art/Figure1-20.jpg" alt = "-[SKGraphic drawHandleAtPoint:inView]" ></div><p>Here we see another call into an NS drawing primitive. At this point, if you are a developer, your only option is to investigate using other graphics primitives such as direct calls to Quartz. In this example we'll do some further analysis to show some techniques useful for analyzing larger apps and frameworks.
</p></li></ol><a name="//apple_ref/doc/uid/TP40005233-CH7-SW57" title="Dig Deeper by Charging Costs"></a><h3>Dig Deeper by Charging Costs</h3><p>To dig deeper we will turn off “Charge System Libraries to Callers” and go through a more step-by-step analysis of what is involved in drawing the shapes for Sketch. This will be focus more on demonstrating various data mining operations and less on particular issues in the frameworks.</p><ol class="ol"><li class="li"><p>Go to the filter box in the advanced drawer and un-check the "Charge System Libraries to Callers" checkbox. Since we are still focused on <code>-[SKTGraphicView drawRect:]</code> we avoid seeing all the framework code that went brought us to that draw routine, and thereby avoid being overwhelmed with symbols. In the heavy view you will now find all sorts of system symbols, so we may need some help to make sense of these. A powerful tool for pruning useless symbols is “Filter Library.”</p></li><li class="li"><p>We're going to work with the “Heavy View” (the upper profile) for a bit.  So click the <img src = "../Art/Heavy_Tree.jpg" alt = "Heavy and Tree" >and set it back to <img src = "../Art/Heavy.jpg" alt = "Heavy" >.</p></li><li class="li"><p>Select the first symbol in the upper profile, as shown in <span class="content_text">Figure 6-28</span>.</p><div class="item_figure"><a name="//apple_ref/doc/uid/TP40005233-CH7-SW32" title="Figure 6-28Heavy View of Focused Sketch"></a><p><strong>Figure 6-28&nbsp;&nbsp;</strong>Heavy View of Focused Sketch</p><img src = "../Art/Figure1-21.jpg" alt = "Figure 1-21" ></div><p>Notice that the stack view on the right shows a backtrace leading up to our old friend <code>-[SKTGraphicView drawRect:]</code>.</p></li><li class="li"><p>In the callstack view on the right click on  <code>-[SKTGraphicView drawRect:]</code> and you'll get <span class="content_text">Figure 6-29</span>:</p><div class="item_figure"><a name="//apple_ref/doc/uid/TP40005233-CH7-SW33" title="Figure 6-29Expanded Heavy View of Focused Sketch"></a><p><strong>Figure 6-29&nbsp;&nbsp;</strong>Expanded Heavy View of Focused Sketch</p><img src = "../Art/Figure1-22.jpg" alt = "Figure 1-22" ></div><p>Suppose we are interested in understanding the calls made into CoreGraphics. This is challenging because AppKit calls CoreGraphics, which calls libRIP.A.dylib, which then calls back into CoreGraphics.  This is a lot of interdependency to sort out.</p><p>Fortunately there is a way to hide this complexity and see just what we are interested in.  We use what are called the exclusion commands.  One of the most powerful ones is “Charge Library.”  This command tells Shark to hide all functions in a particular library and charge the costs of those functions to the functions calling into that library. We'll show this in action in our example:</p></li><li class="li"><p>In the left hand outline select the symbol <code>ripd_mark</code> and control+click on it to bring up the data mining contextual menu. Choose "Charge Library <strong>libRIP.A.dylib</strong>" and you get <span class="content_text">Figure 6-30</span>:</p><div class="item_figure"><a name="//apple_ref/doc/uid/TP40005233-CH7-SW16" title="Figure 6-30After Charge Library libRIP.A.dylib"></a><p><strong>Figure 6-30&nbsp;&nbsp;</strong>After Charge Library libRIP.A.dylib</p><img src = "../Art/Figure1-24-After_Charge.jpg" alt = "After Charge Library libRIP.A.dylib" ></div><p>Notice that the symbols for <strong>libRIP.A.dylib</strong> are gone from the samples. Now this is a bit cleaner, but there are still multiple layers in CoreGraphics.  Notice that we have <code>CGContextDrawPath</code> both in the caller chain to <code>vecCGSColorMaskCopyARGB8888</code> and as a leaf function.  What we really want to see is how much time we're spending in <code>CGContextDrawPath</code>.  </p><p>This is most easily accomplished with “Flatten Library.”  “Flatten Library” is similar to “Charge Library,” except that it leaves the first function (entry point) into the library intact.  It in effect collapses the library down to just its entry points. There is a quick click button in the <em>Advanced Settings</em> Drawer’s Data Mining Palette that lets you flatten all system libraries.  This is a good quick shortcut for flattening all the system libraries, which greatly simplifies your trace in one shot.</p></li><li class="li"><p>Do a control+click on <code>vecCGSColorMaskCopyARGB8888</code> and choose "Flatten Library <strong>CoreGraphics</strong>"  and you'll get <span class="content_text">Figure 6-31</span></p><div class="item_figure"><a name="//apple_ref/doc/uid/TP40005233-CH7-SW17" title="Figure 6-31After Flatten Library"></a><p><strong>Figure 6-31&nbsp;&nbsp;</strong>After Flatten Library</p><img src = "../Art/Figure1-26.jpg" alt = "After Flatten Library" ></div><p>Now this is getting interesting.  Time spent has converged into <code>CGContextFillRect</code>  and <code>CGContextDrawPath</code>. These two call trees represent the two different places we saw hot spots in our top down analysis.  But now we have exposed more detail.  The CoreGraphics team could now choose to use the “Focus on Symbol” commands to study either piece of the execution tree in detail.</p></li></ol><p>This example is a bit simplistic, but it shows the power of the exclusion operations to strip out unnecessary information and identify where the real choke points are in the middle part of the execution tree. Please note that using the data mining operations does not change the underlying sample data that you've recorded.  It just changes how the data is displayed, and so you can always remove all data mining choosing “Restore All” and “Unfocus All” from the Data Mining Menu at any time. As you master the use of these operations, you will learn how to identify the dynamic behavior of complex programs and frameworks faster than you ever thought possible.</p><a name="//apple_ref/doc/uid/TP40005233-CH7-SW58" title="Example: Graphical Analysis using Chart View with a Malloc Trace"></a><h2>Example: Graphical Analysis using Chart View with a Malloc Trace</h2><p>The previous example demonstrated how to use various filtering/focusing data mining techniques to identify hot spots in your program.  All of these also apply to sampling by malloc events (heap tracing), in addition to samples obtained by time profiling.</p><p>However, <em>graphical analysis</em> is also a useful technique for examining the results Shark provides, when used in conjunction with the time based analysis described previously. This technique involves looking at the actual execution pattern using Shark’s <em>Chart</em> view tab (see <span class="content_text"><a href="../TimeProfiling/TimeProfiling.html#//apple_ref/doc/uid/TP40005233-CH3-SW21">“Chart View ”</a></span>). While time analysis helps us prioritize which areas of complexity we wish to attack first, graphical analysis helps us identify the patterns of complexity within these regions in a way that just doesn't come through when looking at the “average” summaries seen in the profile browsers. While this concept applies to all configurations, it is particularly critical with the <em>Malloc Trace</em> configuration (see <span class="content_text"><a href="../OtherProfilingandTracingTechniques/OtherProfilingandTracingTechniques.html#//apple_ref/doc/uid/TP40005233-CH6-SW16">“Malloc Trace”</a></span>), because analyzing the precise memory allocation/deallocation patterns, and determining which calls are causing these allocations and deallocations, is often more important than just looking at the averages seen with the browsers.</p><p>Please note an important distinction between malloc tracing and time profiling. With time profiling, you generally want choose a data set that will take an interestingly long amount of time so that you can get a good set of samples.  In contrast, with exact tracing you generally want to scale back your operation size so that you do one operation on just a few items, in order to keep the number of trace elements manageable.</p><p>This example uses the same Sketch demo build environment as the previous one. Complete that one up to the end of <span class="content_text"><a href="AdvancedProfileAnalysisandDataMining.html#//apple_ref/doc/uid/TP40005233-CH7-SW35">“A Performance Problem... ”</a></span> if you have not already gone through it in order to follow along.</p><a name="//apple_ref/doc/uid/TP40005233-CH7-SW59" title="Taking Samples"></a><h3>Taking Samples</h3><ol class="ol"><li class="li"><p>Switch to “Sketch” with your array of replicated shapes from <span class="content_text"><a href="AdvancedProfileAnalysisandDataMining.html#//apple_ref/doc/uid/TP40005233-CH7-SW35">“A Performance Problem... .”</a></span> Do a “Select All” to select all of the shapes before continuing.</p></li><li class="li"><p>Launch Shark  (in <code>/Developer/Applications/Performance Tools/</code>).</p></li><li class="li"><p>Target your application and choose “Malloc Trace” instead of “Time Profile,” as with <span class="content_text">Figure 6-32</span>.</p><div class="item_figure"><a name="//apple_ref/doc/uid/TP40005233-CH7-SW34" title="Figure 6-32Malloc Trace Main Window"></a><p><strong>Figure 6-32&nbsp;&nbsp;</strong>Malloc Trace Main Window</p><img src = "../Art/Figure2-3-Main_Window.jpg" alt = "Main Window" ></div></li><li class="li"><p>Switch back to Sketch.</p></li><li class="li"><p>Move the Sketch window to expose the Shark window (optional but makes things easier).</p></li><li class="li"><p>Make sure everything is selected.</p></li><li class="li"><p>Press <em>Option+Escape</em> to start sampling.</p></li><li class="li"><p>Choose <em>Edit→Copy</em> and wait for the menu bar highlight to go away.</p></li><li class="li"><p>Press <em>Option+Escape</em> to stop Sampling.</p></li><li class="li"><p>Hit <em>Command-1</em> to switch the weighting to by count (or do it via the Weighting popup in the <em>Advanced Settings</em> drawer).</p></li></ol><p>The window should look like <span class="content_text">Figure 6-33</span>, if you have gone through Tutorial 1 first. Otherwise, it will look similar but not exactly the same.</p><br/><div><a name="//apple_ref/doc/uid/TP40005233-CH7-SW36" title="Figure 6-33Result of Malloc Sampling"></a><p><strong>Figure 6-33&nbsp;&nbsp;</strong>Result of Malloc Sampling</p><img src = "../Art/Figure2-4-Result_of_Malloc.jpg" alt = "Result of Malloc Sampling" ></div><br/><a name="//apple_ref/doc/uid/TP40005233-CH7-SW60" title="Graphical Analysis of a Malloc Trace"></a><h3>Graphical Analysis of a Malloc Trace</h3><ol class="ol"><li class="li"><p>Click on the <em>Chart</em> Tab and you'll get a window that looks like <span class="content_text">Figure 6-34</span>.</p><div class="item_figure"><a name="//apple_ref/doc/uid/TP40005233-CH7-SW37" title="Figure 6-34Chart View"></a><p><strong>Figure 6-34&nbsp;&nbsp;</strong>Chart View</p><img src = "../Art/Figure2-5-Chart_View.jpg" alt = "Chart View" ></div><p>The lower graph a standard plot of the callstacks, with sample number on the X axis and stack depth on the Y axis, while the upper graph is a plot of the size of each allocated block plotted against the sample number.</p><p>This plot is useful for identifying repeated execution paths in your code due to the fact that execution trees leave a form of “fingerprint” that is often quite readily visible. Basically, if you see similar patterns in the graph, it is a strong indication that you are going through the same code path.  It may be acting on different data each time, but these repeated patterns often represent good opportunities for improving performance.  Often, you can hoist some computation outside of the innermost loop in each nesting and make the actual work done in the loop smaller while performing the same actual work.  This kind of change would show up in the graph by reducing the size and the complexity of the repeated structure.</p><p>Let's show an example of a repeated structure.</p></li><li class="li"><p>Select the first hump just before sample 6,000 and enlarge it, as shown in <span class="content_text">Figure 6-35</span>:</p><div class="item_figure"><a name="//apple_ref/doc/uid/TP40005233-CH7-SW38" title="Figure 6-35Place to Select"></a><p><strong>Figure 6-35&nbsp;&nbsp;</strong>Place to Select</p><img src = "../Art/Figure2-6-Place_to_Select.jpg" alt = "Place to Select" ></div><p>The yellow indicates the tenure of different stack frames.  Stack frame 0 is main and it is active the entire time.  As you get deeper into the stack the tenures get narrower and narrower.  Tall skinny spikes of yellow indicate deep chains of calls that do little work and this should be avoided.</p></li><li class="li"><p>Now use the slider on the bottom left of the window to adjust zoom.  Play with this a bit.  As you zoom in and out you'll see that there are multiple levels of unfolding complexity — much like a fractal.  Here is a sequence of zooms that show complexity at different levels:</p><div class="item_figure"><img src = "../Art/top_chart.jpg" alt = "Chart view zooming, view #1" ></div><div class="item_figure"><img src = "../Art/bottom_chart.jpg" alt = "Chart view zooming, view #2" ></div><p>It is a good idea to explore around your execution trace and identify every range of repeated structure and understand what it is doing in each case. The reason this has a fractal like quality is that Mac OS X’s library calls have many layers of libraries that encapsulate one another.  Each of these layers can introduce levels of iteration that is nested inside of other layers. This is like the problem with the nested iteration that we showed in <span class="content_text"><a href="AdvancedProfileAnalysisandDataMining.html#//apple_ref/doc/uid/TP40005233-CH7-SW40">“Analysis Via Source Navigation,”</a></span> but on a system wide scale. In order to drastically improve performance you must attack this problem of complexity creep and eliminate it as much as possible. Application developers obviously can't fix framework issues, but they can strive to eliminate similar complexity issues in their libraries.</p></li><li class="li"><p>We'll finish up with another good application of this graphical analysis. Click on the call stack <img src = "../Art/call_stack_button.jpg" alt = "call stack button" > button to reveal the call stack for this sample, as shown in <span class="content_text">Figure 6-36</span>:</p><div class="item_figure"><a name="//apple_ref/doc/uid/TP40005233-CH7-SW41" title="Figure 6-36Graph View with Call-Stack Pane"></a><p><strong>Figure 6-36&nbsp;&nbsp;</strong>Graph View with Call-Stack Pane</p><img src = "../Art/Figure2-7-Graph_View.jpg" alt = "Graph View with Call-Stack Pane" ></div><p>Using the callstack view, notice that a bunch of XML parsing to build up some kind of <em>NSPrintInfo</em> is occurring.  This is surprising since all we did was a clipboard copy.  In fact, all of the malloc events from about 5,000 to 15,000 are involved with manipulating printer stuff. It turns out that this is due to Sketch actually exporting a full PDF onto the clipboard rather than using a “promise” that it has material to put there if the user actually switches applications and then performs a “paste” operation — the uncommon case, generally. This is a great example of how doing something fairly innocuous at the application level can cause the system libraries to do a lot of extra work. It is also a great example of a cross-library problem that needs to be optimized on multiple levels, ranging from the application to the printing framework to the XML parsing code.)
</p></li></ol>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../SelectingExecutiontoSampleorTrace/SelectingExecutiontoSampleorTrace.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../CustomConfigurations/CustomConfigurations.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2008 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2008-04-14<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/DeveloperTools/Conceptual/SharkUserGuide/AdvancedProfileAnalysisandDataMining/AdvancedProfileAnalysisandDataMining.html%3Fid%3DTP40005233-2.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/DeveloperTools/Conceptual/SharkUserGuide/AdvancedProfileAnalysisandDataMining/AdvancedProfileAnalysisandDataMining.html%3Fid%3DTP40005233-2.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/DeveloperTools/Conceptual/SharkUserGuide/AdvancedProfileAnalysisandDataMining/AdvancedProfileAnalysisandDataMining.html%3Fid%3DTP40005233-2.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>