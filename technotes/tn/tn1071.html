<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"			"http://www.w3.org/TR/REC-html40/loose.dtd"><HTML><!-- Template 03-24-01 --><HEAD><LINK REL="stylesheet" HREF="../../adcstyle.css" TYPE="text/css"><LINK REL="stylesheet" HREF="../../style.css" TYPE="text/css">   <title>Technical Note TN1071: Working with Multiprocessing Services</title>       <meta name="keywords" content="Mac OS 8 Apple Multiprocessing APItasks MPProcessors">    <meta name="Description" content="Technical Note TN1071: have creator write a brief descriptionhere."><meta name="categories" content="Processes"><meta name="week-posted" content="Feb 28, 2000 - Mar 3, 2000"><LINK REL="stylesheet" HREF="../../css/adcstyle.css" TYPE="text/css"><script language="JavaScript" type="text/javascript" src="../../js/adc.js"></script></HEAD><BODY BGCOLOR="#FFFFFF"><a name="//apple_ref/doc/uid/DTS10002912" title="Working with Multiprocessing Services"></a><A NAME="top"></A><!-- begin_header_information --><!--#include virtual="/adcnavbar" --><p><a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../technicalnotes/index.html">Technical Notes</a> &gt; <a href="../../technicalnotes/Carbon/index.html">Carbon</a> &gt; <a href="../../technicalnotes/Carbon/idxProcessManagement-date.html">Process Management</a> &gt; </p><!-- end_header_information --><!-- bottom_of_header_marker_comment --><!-- top_of_titles_marker_comment --><CENTER><table width="600" cellpadding="0" cellspacing="0" border="0">
<tr><td align="left" scope="row">
<h1>
<div id="pagehead">Technical Note TN1071</div>
<div id="pageheadsub">Working with Multiprocessing Services</div>
</h1>
</td></tr></table></CENTER><!-- bottom_of_titles_marker_comment --><CENTER><TABLE BORDER=0 CELLSPACING=1 WIDTH=600><TR><td align="left"> <!-- begin_header_box --> <table width="600" cellpadding="0" cellspacing="0" border="0">	<tr>		<td width=300 valign="top" align=left scope="row">			<table border="0" width="300" cellpadding="0" cellspacing="0">			<tr>                        <td width=300 align=left> <img src="images/tnmenutop.gif" alt="" align="bottom" width=300 height=7></td>				</tr>				<tr bgcolor="#e6e6e6">					<td background="images/tnmenubody.gif" width=300 align=left>						<span id="menutitle">							CONTENTS                             <br>                            <br>						</span>					</td>				</tr>				<tr bgcolor="#e6e6e6">					<td background="images/tnmenubody.gif" width=300 align=left><!-- begin_toc --><p id="menutext"><A HREF = "#aboutmpservices">Overview</A><BR><BR><A HREF = "#usingmpservices">Access to Multiprocessing Services</A><BR><BR><A HREF = "#tasks">Preemptive Tasks</a><BR><BR><A HREF = "#intertcomm">Intertask Communications</a><BR><BR><A HREF = "#itcqueues">Queues</a><BR><BR><A HREF = "#itcegroups">Event Groups</a><BR><BR><A HREF = "#interruptcomm">Interrupt-Level Communications</a><BR><BR><A HREF = "#interruptcommexample">Example: sending a message to an interrupt task</a><BR><BR><A HREF = "#resmgmt">Resource Management</a><BR><BR><A HREF = "#itcsems">Semaphores</a><BR><BR><A HREF = "#itccrits">Critical regions</a><BR><BR><A HREF = "#tipsntricks">Tips &amp; Tricks</A><BR><BR> <A HREF="#References">References</A><br><BR><A HREF="#Downloads">Downloadables</A></p>                  <!-- end_toc --> 								</td>				</tr>				<tr>					<td width=300 align=left scope="row">						<img src="images/tnmenubottom.gif" alt="" width=300 height=16>					</td>				</tr>			</table>		</td>		<td width=300 valign="top" align=left>			<!-- begin_intro_text -->            <P id = "introtext">This Technote    discusses some techniques for use with Apple's    Multiprocessing Services Library.  Methods for sharing    information between tasks are discussed and several    examples are provided that show how to implement    the techniques discussed.</p><P id = "introtext">This Technote is primarily directed at developers    interested in using Apple's Multiprocessing Services    routines.</P><!-- end_intro_text --><!-- begin_date --><h3>&nbsp;Updated: [Mar 20 2000]</h3><!-- end_date -->                </TD>             </TR>          </TABLE>          <!-- end_header_box --> <BR><BR><hr width=500 align=center>          <BR><BR> <!-- begin_content --><A NAME="aboutmpservices"></A>    <H2>Overview</H2>    <P>Multiprocessing Services provides a set of routines that allow    an application to create separate threads of execution called    preemptive tasks.  Preemptive tasks run simultaneously with the    rest of the operating system and are given processor time based    on an interrupt-driven scheduling algorithm.  Unlike thread manager    tasks, the execution of preemptive tasks does not rely on other    tasks explicitly yielding processor time by calling either the    Event Manager routine <CODE>WaitNextEvent</CODE> or the Thread    Manager routine <CODE>YieldToAnyThread</CODE>.</P>    <P>Tasks are preemptively scheduled using whatever processors are    available to the system.  It is not necessary for a machine to be    equipped with more than one processor for an application to take    advantage of the preemptive process scheduling facilities provided    by Multiprocessing Services.  Even if a machine is only equipped    with one processor, it is possible for an application to schedule    and run many simultaneous preemptive tasks.</P>    <P>Multiprocessing Services provides facilities for creating    and scheduling tasks along with routines for communicating between    tasks.  Although access to operating system resources is limited    from preemptive tasks, at the time of this writing, it is possiblefor tasks    to allocate memory, make synchronous file manager calls, call    deferred tasks, and make remote calls the operating system.</P><P><A HREF = "#top">Back to top</a></p>    <A NAME="usingmpservices"></A>    <H2>Access to Multiprocessing Services</H2>    <P>For your application to use Multiprocessing Services, your    application must be linked with either CarbonLib or the    Multiprocessing Services shared library, "MPLibrary".    For best results, when linking with "MPLibrary", your application    should use weak links to the Multiprocessing Services routines and then    use the <CODE>MPLibraryIsLoaded</CODE>    function call to determine if the library is available for    your application to use.  If <CODE>MPLibraryIsLoaded</CODE> returns    true, then your application can use the Multiprocessing Services    routines and perform preemptive multitasking operations.  Otherwise,    when <CODE>MPLibraryIsLoaded</CODE> returns false, your application    should use single threaded processing techniques.</P>    <P>All applications using the Multiprocessing Services routines should    call the <CODE>MPLibraryIsLoaded</CODE> routine to determine if    Multiprocessing Services is available.  This is for two reasons: </P>    <OL TYPE="1" START="0">    <LI><CODE>MPLibraryIsLoaded</CODE> may perform some initialization    operations that must be done before other Multiprocessing Services    calls can be made.<BR><BR></LI>    <LI>Although CarbonLib exports the symbols required to link your    application with Multiprocessing Services, that does not necessarily    imply that those routines are available in the context where CarbonLib    is running.  The call to <CODE>MPLibraryIsLoaded</CODE> will tell your    application if those routines are available for your application    to use.<BR><BR></LI>    </OL><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>Developers linking with CarbonLib who would like to call the routine    <CODE>DTInstall</CODE> from a preemptive task, should make sure that    CarbonLib&nbsp;1.0.2 or later is installed at runtime.</P></TD></TR></TABLE></CENTER><BR><P><A HREF = "#top">Back to top</a></p>    <A NAME="tasks"></A>    <H2>Preemptive Tasks</H2>    <P>Preemptive tasks are single parameter routines that return aresult of    type <CODE>OSStatus</CODE>.  Once a task has been created it will run    preemptively until it returns a result or until it is explicitlyterminated.    Tasks are free to perform any type of processing operations theyrequire,    however do not have access to the 680x0 emulator. Therefore, it is not    possible to place calls to operating system routines that may    make use of the 680x0 emulator.  A listing of specific Operating system    routines that can be called by tasks can be found in the document    <a href="../../documentation/Carbon/oss/MultiPServices/multiprocessingservices.html">Adding Multitasking Capability to Applications UsingMultiprocessing Services</a>.    </P>    <P>Listing 1 shows a simple task that creates a SimpleText file containing    1000 lines of text containing the string "Hello World\n".  In this task, a    number of the "safe" file manager calls are used to create a file, open its    data fork, and write a bunch of strings to the file.  When called, this task    will run  in the background (during mouse clicks, menu selections,    et cetera) until it completes.  During that time, the application that created    this task (and all other applications) will be free to perform any other    processing operations it desires.</P>    <BR><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>OSStatus ExampleTask( void *parameter ) {    FSSpec *theFile;    short refnum;    Boolean created;    long i;         /* the parameter is a FSSpec pointer */    theFile = (FSSpec *) parameter;        /* set up locals */    refnum = 0;    created = false;        /* create a file */    err = <a href="../../documentation/mac/Files/Files-191.html">FSpCreate</A>(theFile, 'ttxt', 'TEXT', smSystemScript);    if (err != noErr) goto bail;    created = true;        /* open the file for writing */    err =  <a href="../../documentation/mac/Files/Files-188.html">FSpOpenDF</A>(theFile, fsRdWrPerm, &amp;refnum);    if (err != noErr) goto bail;        /* write out the string 1000 times*/    for (i=0; i&lt;1000; i++) {        err = <a href="../../documentation/mac/Files/Files-128.html">FSWrite</A>(refnum, (count = 12, &amp;count), "Hello World\n");        if (err != noErr) goto bail;    }        /* close the file and leave */    <a href="../../documentation/mac/Files/Files-44.html">FSClose</A>(refnum);    return noErr;bail:    if (refnum != 0) <a href="../../documentation/mac/Files/Files-44.html">FSClose</A>(refnum);    if (created) <a href="../../documentation/mac/Files/Files-193.html">FSpDelete</A>(theFile);    return err;}</pre>	</TD></TR><TR>	<td align="left"><P><b>Listing 1.</b> A task that creates a SimpleText file containingthe string    "Hello World\n".</p>	</TD></TR></TABLE></CENTER>       <P>The single parameter passed to a task is provided by the caller    when the task is created using the <CODE>MPCreateTask</CODE> routine.    As shown in listing 1 and 2, oftentimes the parameter passed    to a task will be a pointer to a structure containing information relevant    to the operations the task has been designed to perform.    In Listing 1, the task assumes that the parameter is a pointer to a    <CODE>FSSpec</CODE> record that refers to a file the task should create.    The code snippet shown in Listing 2 illustrates how to pass    a pointer to a <CODE>FSSpec</CODE> record to the task when calling    the <CODE>MPCreateTask</CODE> routine.</P>    <BR><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>OSStatus err;FSSpec targetFile;MPTaskID taskID;    /* make a file spec for the target file */err = <a href="../../documentation/mac/Files/Files-205.html">FSMakeFSSpec</A>(0, 0, "\pExample File", &amp;targetFile);    /* if the file does not exist, call the task to create it */if (err == fnfErr) {        /* create the task */    err = MPCreateTask( ExampleTask,        &amp;targetFile, /* the parameter passed to the task */        0, /* use the default stack size - 4K */        0, /* no notification queue */        NULL, NULL, /* result parameters - unused */        0, /* no special task flags */        &amp;taskID );}</pre>	</TD></TR><TR>	<td align="left"><P><b>Listing 2.</b>  A small sequence of statements that calls the<code>ExampleTask</code> from Listing 1.</p>	</TD></TR></TABLE></CENTER>       <P>Of course, callers will want to know the result codes returned    by the tasks they create.  To allow for this, Multiprocessing    Services provides a mechanism where the result code returned by    the task can be passed back to the caller.  However, this cannot    be done directly as often the time required for a task to execute    cannot be determined beforehand.  So, to allow Multiprocessing    Services to pass back the result returned by the task to its caller,    it is possible to designate a queue, by providing it as a parameter    to the <CODE>MPCreateTask</CODE> call,  that will be used for communicating    the task's result back to the caller.  Figure 3 illustrates how one    would set up such a queue and provide it as a parameter    to <CODE>MPCreateTask</CODE>.</P>    <BR><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>OSStatus err;FSSpec targetFile;MPTaskID taskID;MPQueueID taskQueue;    /* create a queue for the task to communicate    results back to the caller */err = MPCreateQueue( &amp;taskQueue );if (err != noErr) goto your_error_handler;    /* make a file spec for the target file */err = <a href="../../documentation/mac/Files/Files-205.html">FSMakeFSSpec</A>(0, 0, "\pExample File", &amp;targetFile);    /* if the file does not exist, call the task to create it */if (err == fnfErr) {        /* create the task */    err = MPCreateTask( ExampleTask,        &amp;targetFile, /* the parameter passed to the task */        0, /* use the default stack size - 4K */        taskQueue, /* the task's notification queue */        NULL, NULL, /* first 64 bits of result */        0, /* no special task flags */        &amp;taskID );}</pre>	</TD></TR><TR>	<td align="left"><P><b>Listing 3.</b>  A sequence of statements that calls the Exampletask    shown in Listing 1.  This listing illustrates how to provide a task    notification queue when a task is created so the result code returned    by the task can be discovered after the task has completed.</p>	</TD></TR></TABLE></CENTER>        <P>If a task notification queue is provided as a parameter to the    <CODE>MPCreateTask</CODE> routine, then this queue will be used tocommunicate    any result codes returned by the task to its caller.  As shown    in Listing 4, the task's result code is returned in the third    <CODE>MPWaitOnQueue</CODE> result parameter.</P>    <BR><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>    Boolean complete;    OSStatus err;    complete = (MPWaitOnQueue(taskQueue,        NULL, NULL, /* first 64 bits of result from MPCreateTask */        (void**) &amp;err, /* the result code returned by the task */        kDurationImmediate) == noErr);    if (complete) {        /* the task is complete and has returned the error code        that has been copied into err... */</pre>	</TD></TR><TR>	<td align="left"><P><b>Listing 4.</b> Using a task's notification queue to find the    result code returned by the task.</p>	</TD></TR></TABLE></CENTER>        <P>Task notification queues are necessary in some cases.  For instance,    calling <CODE>MPTerminateTask</CODE> does not immediately destroy atask, nor does    it stop the task from executing.  Instead,<CODE>MPTerminateTask</CODE> will schedule    the task for termination.  The actual operations involved interminating    the task will happen as soon as the task scheduler is able toremove the    task from the active task queue.  As such, a task may remainexecuting for    some time after <CODE>MPTerminateTask</CODE> has been called. But,once the task has    been stopped and disposed of, Multiprocessing Services will notify the    caller of this fact by placing a result in the task's notificationqueue.    It will not be safe for the caller to assume the task is not running    until this result arrives.</P>    <P>In general, <CODE>MPTerminateTask</CODE> should be avoided andonly used in    exceptional circumstances.  Well-written tasks and Multiprocessing    Services clients should never need to use this routine.  However, in    unusual circumstances where it is necessary to terminate a task    by calling <CODE>MPTerminateTask</CODE>, you must use a tasknotification queue    to determine when the task has actually terminated.</P><P><A HREF = "#top">Back to top</a></p>    <A NAME="intertcomm"></A>    <H2>Intertask Communications</H2>    <P>Multiprocessing services provides a number of facilities    that can be used for communication between tasks.  These facilities    and how they can be used are discussed in this section.  Whenever    possible, applications should use these methods for communication    between tasks.  Other methods, such as polling global variables,    are inefficient and often lead to difficult-to-track-down    bugs.  The methods discussed in this section are fast, efficient,    and they provide a well-defined set of operations for passing messages    or communicating state information between tasks.</P>    <BR>    <BR>    <A NAME="itcqueues"></A>    <H3>Queues</H3>    <P>Queues are first-in-first-out message buffers designed    for passing 96-bit messages between tasks.  Each message    is formatted as a group of three 32-bit integers.  The format    of the data passed between tasks is entirely up to the    programmer. Here, the only requirement is that all tasks    accessing the same queue agree on the format of the    data being stored in the queue.</P>    <P>Inserting and extracting elements is an atomic    operation - many tasks can try to extract the next message    from a given queue, but only one will successfully obtain it.</P>    <P>Listing 5 illustrates how a queue can be used to pass commands    to a server task for background processing.  Here, the server task    extracts messages from a queue and then it performs processing    operations based on a dispatching mechanism.</P>    <BR><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>enum {    kRunLongComplexTask,    kQuickTask,    kShutDown};OSStatus ExampleServerTask( void *parameter ) {    MPQueueID commandQueue;    Boolean processingCommands;    long theCommand, param1, param2;         /* task parameter is the command queue ID */    commandQueue = (MPQueueID) parameter;        /* set up locals */    processingCommands = true;    err = noErr;        /* process commands */    while (processingCommands) {            /* get the next command from the queue */        err = MPWaitOnQueue(commandQueue,            (void**) &amp;theCommand, /* the first parameter is the command */            (void**) &amp;param1, /* the next two parameters are arguments.. */            (void**) &amp;param2,            kDurationForever);        if (err != noErr) break;            /* process the command */        switch (theCommand) {            case kRunLongComplexTask:                PerformSomeComplexAction(param1, param2);                break;            case kQuickTask:                PerformSomeSimpleAction(param1, param2);                break;            case kShutDown:                processingCommands = false;                break;        }    }        /* release the command queue */    MPDeleteQueue(commandQueue);        /* any result codes will be returned in the task's        notification queue. See listing 4 for an example        showing how to retrieve this result code. */    return err;}</pre>	</TD></TR><TR>	<td align="left"><P><b>Listing 5.</b> A sample server task receiving commands by wayof a queue.</p>	</TD></TR></TABLE></CENTER>       <P>The server task shown in listing 5 assumes    that messages placed in the queue have a particular format.Specifically,    the first 32-bit integer is a command selector and the next two 32-bit    integers are additional parameters that may or may not be used    in command processing.  As the server task assumes this will be the    format for all messages placed in the queue, it is useful to have a    single routine that formats queue entries according to this agreed    upon format when sending messages to the server task.  The routine    shown in Listing 6 provides this mechanism.</P>    <BR><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>MPQueueID gServerCommandQueue;OSStatus SendCommandToServerTask(long theCommand, long param1, long param2) {    return MPNotifyQueue(gServerCommandQueue,        (void*) theCommand, /* the first parameter is the command */        (void*) param1, /* the next two parameters are arguments... */        (void*) param2);}</pre>	</TD></TR><TR>	<td align="left"><P><b>Listing 6.</b> A routine for sending commands to the server task    shown in listing 5.</p>	</TD></TR></TABLE></CENTER>       <P>Often it is best to "wrap" the routine used to place commands    in a server task's command queue in this manner rather than    calling <CODE>MPNotifyQueue</CODE> directly to send commands    to the server task.  Adding the additional layer of abstraction    reduces code maintenance requirements should the format of the    messages in the queue change.</P>        <A NAME="itcegroups"></A>    <H3>Event Groups</H3>    <P>Event groups are the fastest method available for communications    between tasks.  An event group is a 32-bit integer.  Each bit in that    integer is used to represent an individual event.  Event groups    can be used as a mechanism for sending simple boolean messages    to tasks.  When used in this way, each bit in the event group    represents a message.</P>    <P>Unlike queues, where messages are received one at a time,    it is possible that several "event" messages may be received    simultaneously in one call to <CODE>MPWaitForEvent</CODE>.  Inother words,    several events may accumulate in an event group between calls    to <CODE>MPWaitForEvent</CODE>.  As a result, code responsible fordecoding    and responding to events returned by <CODE>MPWaitForEvent</CODE>must be    aware of the fact that more than one event may be returned by    any given call. The event handler shown in listing 7 illustrates    an appropriate way to handle event groups returned by    <CODE>MPWaitForEvent</CODE>.</P>    <BR><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>/* each event is defined as a single bit in the event group. */enum {    kDanglingPointerDetected = (1&lt;&lt;0),    kUnlockedHandleSighted = (1&lt;&lt;1),    kResEditDetected = (1&lt;&lt;2),    kSelfDestruct = (1&lt;&lt;3)};OSStatus ExampleEventHandlerTask( void *parameter ) {    MPEventID eventGroup;    Boolean processingEvents;    MPEventFlags theFlags;         /* task parameter is an event group */    eventGroup = (MPEventID) parameter;        /* set up locals */    processingEvents = true;    err = noErr;        /* process events */    while (processingEvents) {            /* get the next event */        err = MPWaitForEvent(eventGroup, &amp;theFlags, kDurationForever);        if (err != noErr) break;            /* more than one flag may be set in each            event we retrieve.  As such, we do separate            processing for each flag, but we do not            assume that flags are mutually exclusive. */        if ((theFlags &amp; kDanglingPointerDetected) != 0) {            ShieldsUp();        }        if ((theFlags &amp; kUnlockedHandleSighted) != 0) {            PhasersOnStun();        }        if ((theFlags &amp; kResEditDetected) != 0) {            EngageHelmets();        }        if ((theFlags &amp; kSelfDestruct) != 0) {            processingEvents = false;        }    }        /* release the event group */    MPDeleteEvent(eventGroup);        /* any result codes will be returned in the task's        notification queue. See listing 4 for an example        showing how to retrieve this result code. */    return err;}</pre>	</TD></TR><TR>	<td align="left"><P><b>Listing 7.</b>A sample server task receiving commands by wayof an event group.</p>	</TD></TR></TABLE></CENTER>        <P>As event groups are the fastest method for passing messages    between tasks, their use should always be considered.  If the    messages your task is designed to handle do <U>not</U> need    to be processed in any particular order, then event groups are    probably the best method for sending commands to your task.    On the other hand, if the commands you are sending to your    task must be processed in a definite order (or you must    send additional data along with the command), then you    should use a queue to send commands to your task.</P><P><A HREF = "#top">Back to top</a></p>    <A NAME="interruptcomm"></A>    <H2>Interrupt-Level Communications</H2>    <P>Often it is desirable to communicate between code running at    different execution levels.  For example, an application may    want to send information from its main thread to a task.  This    section discusses the issues involved in communications between    different types of tasks and it provides an example illustrating    how a preemptive task can send messages to an interrupt-level    task.  For the purposes of this discussion, we will define thefollowing    three task types and discuss methods that can be used to communicate    between them: </P>    <OL TYPE="1" START="1">        <LI><B>Interrupt Level</B>. This describes any thread of execution that         occurs as a result of an interrupt, including hardware interrupt handlers        and Deferred tasks running in the classic cooperative environment.<BR><BR></LI>        <LI><B>System-Task Level</B>. This describes the classic application's        main thread of execution and Thread Manager tasks.<BR><BR></LI>        <LI><B>Preemptive-Task Level</B>. This refers to a thread of execution,        a preemptive task, created by Multiprocessing Services.<BR><BR></LI>    </OL>    <P>Table 1 lists the various methods that can be used for communicating    between tasks running at different execution levels.  Perhaps the most    complex of the types of communication that can be done here is sending    a message from a preemptive task to a classic interrupt-level task.    The other ones are straight forward, but, as this one is complex, a    sample of how it can be done is provided in listing 8, listing 9, and    listing 10.</P>    <BR>      <b>Table 1</b>. Methods for communicating between different execution        levels for Mac OS applications.<BR>      <table width="500" border="1">        <tr>          <td width=96 align=left scope="row">             <p>&nbsp;</p>          </td>          <td colspan=3 align=left>            <div align="center"><b>The Destination Task is operating at: </b></div>          </td>        </tr>        <tr>          <td width=96 align=left scope="row">             <div align="center"><b>The Source Task is operating at: </b></div>          </td>          <td width=131 align=left>             <div align="center">Interrupt Level</div>          </td>          <td width=119 align=left>             <div align="center">System-Task Level</div>          </td>          <td width=126 align=left>             <div align="center">Preemptive-Task Level</div>          </td>        </tr>        <tr>          <td width=96 align=left scope="row">Interrupt Level</td>          <td rowspan=2 width=131 align=left>Use the <CODE>Enqueue</CODE> routine to add             messages to an O.S.&nbsp;queue, use the <CODE>Dequeue</CODE> routine             poll for messages in the interrupt routine.</td>          <td width=119 align=left>Use the <CODE>Enqueue</CODE> routine to add messages to             an O.S.&nbsp;queue, use the <CODE>Dequeue</CODE> routine to poll for             messages.</td>          <td width=126 align=left>Call <CODE>MPNotifyQueue</CODE> to add messages to the             queue and call <CODE>MPWaitOnQueue</CODE> to extract messages. <CODE>MPSetQueueReserve</CODE>             must be called to ensure there is space in the queue before adding             messages to it at interrupt time.</td>        </tr>        <tr>          <td width=96 align=left scope="row">System-Task Level</td>          <td width=119 align=left>Any queue mechanism will do. The nature of system-task             level ensures mutual exclusion between threads operating at this level.</td>          <td rowspan=2 width=126 align=left>Call <CODE>MPNotifyQueue</CODE> to add messages             to the queue and call <CODE>MPWaitOnQueue</CODE> to extract messages.</td>        </tr>        <tr>          <td width=96 align=left scope="row">Preemptive-Task Level</td>          <td width=131 align=left>Call <CODE>Enqueue</CODE> from a deferred task to insert             messages into an O.S.&nbsp;queue, use the <CODE>Dequeue</CODE> routine             to poll for messages in the interrupt routine.</td>          <td width=119 align=left>Use <CODE>MPNotifyQueue</CODE> to add messages to a queue,             and use the <CODE>MPWaitOnQueue</CODE> (specifying an immediate duration)             to poll the queue for messages.</td>        </tr>      </table>    <BR>    <BR>    <A NAME="interruptcommexample"></A>    <H3>Example: sending a message to an interrupt task</H3>    <P>In this example, message records are kept in two queues: the unused    message buffers available are kept in a Multiprocessing    Services queue and the message buffers containing data to be read by    the interrupt task are stored in an O.S. Queue.  Whenever thepreemptive task needs    to send a message to the interrupt routine, it can extract anunused message    buffer from the Multiprocessing Services queue, copy some data to it,    and then place the buffer in the O.S. Queue.  The currentimplementation of    Multiprocessing Services does not allow preemptive tasks to call    <CODE>Enqueue</CODE> directly so instead this sample calls<CODE>Enqueue</CODE>    from a deferred task that is installed by the preemptive task.</P>    <P>The interrupt routine extracts messages from the O.S. Queue and once it has    finished with a message, it places the message back into theMultiprocessing    Services queue so it can be used again by the preemptive task.Listing 8    contains the steps needed to set up the structures and variablesused in this    example.</P>    <BR><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>#define kMaxMessages 20#define kMessageSize 256    /* the MessageRecord structure is defined as the    primary mechanism to storing messages.  */typedef struct MessageRecord MessageRecord;typedef MessageRecord, *MessageRecPtr;struct MessageRecord {        /* os queue element field at offset zero.  It's        placed here so we can easily coerce a MessageRecPtr        to a QElemPtr and vice versa. */    QElem qLinkField;        /* deferred task record we will used for        adding this record to the os queue.*/    DeferredTask eltTask;        /* the message buffer */    unsigned char messageData[kMessageSize];};    /* pointer to the storage area we're using for messages */MessageRecPtr gMsgStorage;    /* a queue of free buffers */MPQueueID gFreeMessageQueue;    /* our message queue */QHdr gMessageOSQueue;    /* deferred task upp */DeferredTaskUPP gInstallMessageDT;/* InstallBufferDT is the deferred task we use    for installing messages.  This routine assumes    that its parameter is a pointer to the message    record that is to be installed. */static pascal void InstallBufferDT(long dtParam) {    MessageRecPtr theElt;        /* get a pointer to the message */    theElt = (MessageRecPtr) dtParam;        /* initialize its fields */    theElt-&gt;qLinkField.qLink = NULL;    theElt-&gt;qLinkField.qType = 0;        /* add the message to the message queue */    <a href="../../documentation/mac/OSUtilities/OSUtilities-155.html">Enqueue</A>((QElemPtr) theElt, &amp;gMessageOSQueue);        /* in some cases, it may be useful to do        additional processing at this point.  For        instance, you may wish to restart a send        operation that ran out of data, etc... */}/* SetUpInstallUPP is a remote procedure call used to    set up the universal procedure pointer for the    deferred task. This is done in a remote procedure    call as the NewDeferredTaskUPP call is not listed    as a macro/call that can be made from preemptive tasks.*/static void *SetUpInstallUPP(void *parameter) {    gInstallMessageDT = NewDeferredTaskUPP(InstallBufferDT);    return NULL;}/* InitMessageQueue is called to set up the message queue    and related variables.  The purpose of this routine is    to illustrate what steps need to be done to prepare    for sending messages from a preemptive task to an interrupt    task using an O.S. Queue. */OSStatus InitMessageQueue(void) {    OSStatus err;    long i;    MessageRecPtr rover;        /* initialize our variables */    gFreeMessageQueue = 0;    MPBlockClear(&amp;gMessageOSQueue, sizeof(gMessageOSQueue));        /* allocate our message storage */    gMsgStorage = (MessageRecPtr) MPAllocateAligned(        sizeof(MPSBufferElement) * kMaxMessages,        kMPAllocateDefaultAligned,        kMPAllocateClearMask);    if (gMsgStorage == NULL) { err = memFullErr; goto bail; }        /* allocate the free message queue */    err = MPCreateQueue(&amp;gFreeMessageQueue);    if (err != noErr) goto bail;        /* pre-allocate  kMaxMessages slots in the queue */    err = MPSetQueueReserve(gFreeMessageQueue, kMaxMessages);    if (err != noErr) goto bail;        /* add message records to the free message queue */    for (rover = gMsgStorage, i=0; i &lt; kMaxMessages; i++, rover++) {        err = MPNotifyQueue(gFreeMessageQueue, (void*) rover, NULL, NULL);        if (err != noErr) goto bail;    }        /* set up the upp for the install deferred task */    MPRemoteCall(SetUpInstallUPP, NULL, kMPOwningProcessRemoteContext);        /* done */    return noErr;bail:    if (gFreeMessageQueue != 0) MPDeleteQueue(gFreeMessageQueue);    if (gMsgStorage != NULL) MPFree(gMsgStorage);    return err;}</pre>	</TD></TR><TR>	<td align="left"><P><b>Listing 8.</b> Setting up variables and storage for sendingmessages    to an interrupt task using an O.S. queue.</p>	</TD></TR></TABLE></CENTER>       <P>Once the necessary structures and variables have been set up,sending    a message from a preemptive task to an interrupt task is simply amatter    of obtaining a message buffer from the free message buffer queue,    copying some data to it, and then calling the<CODE>InstallBufferDT</CODE> deferred    task to install the message in the O.S. Queue.  This method will not    require any storage allocations inside of the preemptive task    or inside of the interrupt-level task (where that is not possible), but    it provides a reasonably dynamic method for passing information between    the two routines.  Also, if all of the message buffers are currently in    the O.S. queue, the call to <CODE>MPWaitOnQueue</CODE> shown inlisting 9    will wait until such a time as when the interrupt task places abuffer into    the free message buffer queue.</P>    <BR><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>OSStatus SendMessageToInterruptTask(unsigned char *message) {    MessageRecPtr theMessage;    OSStatus err;        /* get a message from the free queue */    err = MPWaitOnQueue(gFreeMessageQueue,        (void **) &amp;theMessage,        NULL, NULL, kDurationForever);    if (err != noErr) return err;        /* copy the data to the message record */    MPBlockCopy(message, theMessage-&gt;messageData, kMessageSize);        /* call the deferred task to install it */    theMessage-&gt;eltTask.qLink = NULL;    theMessage-&gt;eltTask.qType = dtQType;    theMessage-&gt;eltTask.dtFlags = 0;    theMessage-&gt;eltTask.dtAddr = gInstallMessageDT;    theMessage-&gt;eltTask.dtParam = (long) theMessage;    theMessage-&gt;eltTask.dtReserved = 0;    err = <a href="../../documentation/mac/Processes/Processes-130.html">DTInstall</A>(&amp;theMessage-&gt;eltTask);        /* done */    return err;}</pre>	</TD></TR><TR>	<td align="left"><P><b>Listing 9.</b> Sending a message from a preemptive task to an    interrupt task using an O.S. Queue.</p>	</TD></TR></TABLE></CENTER>       <P>Inside of the interrupt routine, messages can be extracted from    the queue using the <CODE>Dequeue</CODE> routine.  Once the messagehas been    processed, the interrupt task can call <CODE>MPNotifyQueue</CODE>to add the    message back into the free message buffer queue so it will be    available to the preemptive task.  Listing 10 illustrates one way    an interrupt routine would extract messages from the O.S. Queue    and return them to the free message buffer queue once they are    no longer needed.</P>    <BR><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>    MessageRecPtr theMessage;    theMessage = (MessageRecPtr) gMessageOSQueue.qHead;    if (theMessage != NULL) {        if (<a href="../../documentation/mac/OSUtilities/OSUtilities-156.html">Dequeue</A>((QElemPtr) theMessage, &amp;gMessageOSQueue) == noErr) {            /* perform some operations using the message... */                /* add the message back into the free queue */            MPNotifyQueue(gFreeMessageQueue, (void*) theMessage, NULL, NULL);        }    }</pre>	</TD></TR><TR>	<td align="left"><P><b>Listing 10.</b>  Receiving a message from a preemptive task inside    of an interrupt task.</p>	</TD></TR></TABLE></CENTER>   <P><A HREF = "#top">Back to top</a></p>    <A NAME="resmgmt"></A>    <H2>Resource Management</H2>    <P>Oftentimes when many preemptive tasks are engaged in a complex    task, there must be a mechanism in place to ensure the number of    tasks attempting to utilize a limited number of resources does not    outnumber the actual number of resources available.  For example,    if we have ten tasks and two printers, and each one of those tasks    must print from time to time, then a mechanism must be in place to    ensure that no more than two tasks will be using the printers at any    given time.</P>    <BR>    <A NAME="itcsems"></A>    <H3>Semaphores</H3>    <P>Semaphores allow you to restrict access to resources in a way    that ensures that only a certain number of tasks may access a    particular resource at any given time.</P>    <BR>    <A NAME="itccrits"></A>    <H3>Critical regions</H3>    <P>Critical regions are a special type of semaphore that    allow you to restrict access to a particular resource    (section of code) to a single execution thread.</P><P><A HREF = "#top">Back to top</a></p>    <A NAME="tipsntricks"></A>    <H2>Tips &amp; Tricks</H2>    <UL>        <LI>If there is a need to call a toolbox routine from anpreemptive        task, first check to see if the toolbox routine is interrupt        safe.  If it is, then call it using a deferred task rather        than using a remote procedure call.  Deferred tasks have alower        latency time than remote procedure calls.  As a result, your        code will run quicker and will not be subject to any of the        unpredictable delays associated with using remote procedure        calls.<BR><BR></LI>        <LI>With the above tip in mind, it is worth mentioning that        most of Open Transport can be called from deferredtasks.<BR><BR></LI>        <LI>Avoid using global variables for sharing informationbetween        tasks.  Doing so can lead to bugs that are difficult to track        down.  Use the routines provided by Multiprocessing services        to share data between tasks.<BR><BR></LI>        <LI>With Multiprocessing Services 2.1 and later, it is safe to        call <CODE>MPSignalSemaphore</CODE> and <CODE>MPSetEvent</CODE>        at interrupt time. It is also possible to call<CODE>MPNotifyQueue</CODE>        at interrupt time if <CODE>MPSetQueueReserve</CODE> hasbeen called        to reserve sufficient space in the queue.<BR><BR></LI>        <LI>Event groups are the fastest way to send informationbetween        tasks.  Always consider the possibility of using them instead        of queues.<BR><BR></LI>        <LI>Task implementation and design should assume that other        tasks are running simultaneously.  When there are resources        that are shared between tasks, access to them should becontrolled        using the resource management facilities.<BR><BR></LI>    </UL><P><A HREF = "#top">Back to top</a></p>    <A NAME="References"></A>    <H2>References</H2>    <a href="http://developer.apple.com/sdk/index.html">    Multiprocessing SDK.</A><BR>    <a href="../../documentation/Carbon/oss/MultiPServices/multiprocessingservices.html">    Multiprocessing Services Online Documentation.</A><BR><P><A HREF="#top">Back to top</A></p> <A NAME=Downloads></A>                  <H2>Downloadables</H2>                  <TABLE BORDER=0 CELLPADDING=3 WIDTH="500">            <TR>               <td width=50 align=left>                  <P ALIGN=center><img src="images/acrobatsmall.gif" width=22 height=23 align=middle alt="Acrobat"></P>               </TD>               <td align="left">                  <P>Acrobat version of this Note (68K).</P>               </TD>               <td width=60 align=left>                  <P><A HREF="pdf/tn1071.pdf">Download</A></P>               </TD>            </TR></TABLE><P><A HREF="#top">Back to top</A></P></TD></TR></table></center><!-- begin_footer_information -->	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/technotes/tn/tn1071.html%3Fid%3DDTS10002912-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/technotes/tn/tn1071.html%3Fid%3DDTS10002912-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/technotes/tn/tn1071.html%3Fid%3DDTS10002912-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>
<!--#include virtual="/includes/footer"--><!-- end_footer_information --></BODY></HTML>