PROGRAM SCSIInquiry;(*	MPW tool that tries to make a SCSI inquiry command to my HD80SC (SCSI ID 5)	3/17/91Useful MPW commands:open Internal:MPW:SCSIInquiry.pprint 'Internal:MPW:SCSIInquiry.p'	-b2 -h -md -font Courier -size 7pasmat -d SCSIInquiry.p SCSIInquiry.pasmattedpascal {MPW}SCSIInquiry.plink -w -c "MPS " -t MPST 		"{MPW}"SCSIInquiry.p.o 		  "{Libraries}"Interface.o 		  "{Libraries}"Runtime.o 		  "{PLibraries}"Paslib.o 		  "{PLibraries}"SANELib.o 		  -o SCSIInquirysave SCSIInquiry.pSCSIInquiry*)	USES Memtypes, QuickDraw, OSIntf, ToolIntf, PackIntf, SANE, SCSI,		{$U Internal:MPW:MBLibsIncl.:WLW} WLW;	CONST		kVersion = '3/18/91 17:18 PM';		kInquirySize = $FF;		kInquiryCMD = $12;		kVendorIDSize = 8;		kProductIDSize = 16;		kRevisionSize = 4;	TYPE		InquiryResponse = PACKED RECORD			DeviceType: byte; {0}			DeviceQualifier: byte; {1}			Version: byte; {2}			RseponseFormat: byte; {3}			AdditionalLength: byte; {4}			VendorUse1: byte; {5}			Reserved1: integer; {6-7}			VendorID: PACKED ARRAY [1..kVendorIDSize] OF char; {8-15}			ProductID: PACKED ARRAY [1..kProductIDSize] OF char; {16-31}			Revision: PACKED ARRAY [1..kRevisionSize] OF char; {32-35}			VendorUse2: PACKED ARRAY [1..20] OF byte; {36-55}			Reserved2: PACKED ARRAY [1..42] OF byte; {56-97}			VendorUse3: PACKED ARRAY [1..158] OF byte; {98-255}			END;		InquiryResponsePtr = ^InquiryResponse;	VAR		gTargetID: integer; {my hd 80SC SCSI ID = 5}		gTIB: PACKED ARRAY [0..1] OF SCSIInstr;		gErr: OSErr;		gCMD: PACKED ARRAY [0..5] OF byte;		gResponse: InquiryResponse;		gCounter: integer;		gWaitTime: LONGINT;		gReturnedStat: integer;		gReturnedMessage: integer;		gGotSCSIBus, gTimedOut: BOOLEAN;		gNumTries: integer;		{-------------------------------------}		{	   Main Program 				  }		{-------------------------------------}	BEGIN		writeln;		writeln('SCSI inquiry Test.  Version: ', kVersion);		writeln;		{set up the TIBs}		{scNoInc=move count (scParam2) bytes to/from buffer (scParam1), don't increment bufr}		gTIB[0].scOpcode := scNoInc;		gTIB[0].scParam1 := LONGINT(@gResponse); {pointer to buffer}		gTIB[0].scParam2 := kInquirySize; {"count", or no. of bytes to move}		{scStop=stop the pseudo-pgm, rtn to calling SCSI Mgr rtne}		gTIB[1].scOpcode := scStop;		gTIB[1].scParam1 := LONGINT(NIL);		gTIB[1].scParam2 := LONGINT(NIL);		{set up the command buffer with the INQUIRY command}		gCMD[0] := kInquiryCMD;		gCMD[1] := 0;		gCMD[2] := 0;		gCMD[3] := 0;		gCMD[4] := kInquirySize;		gCMD[5] := 0;		gWaitTime := 4;		gTargetID := 5; {I know my external's hard disk's ID}		writeln('------------------------------------------');		writeln('testing SCSI ID: ', gTargetID);		writeln('------------------------------------------');		writeln;		{try to arbitrate and select.  To fall out of the repeat loop, we}		{have to sucessfully do both, or time out some number of times}		{(at which point we clean up and quit)}		gNumTries := 0;		gGotSCSIBus := False;		gTimedOut := False;				REPEAT			gErr := SCSIGet;			IF gErr = noErr THEN BEGIN				gErr := SCSISelect(gTargetID);				IF gErr = noErr THEN BEGIN					gGotSCSIBus := True;				END				ELSE BEGIN					writeln('SCSISelect Err: ', gErr);				END			END			ELSE BEGIN				writeln('SCSIGet Err: ', gErr);			END;			{only tolerate so many errors trying to get and/or select}			gNumTries := gNumTries + 1;			IF gNumTries >= 5 THEN				gTimedOut := True;		UNTIL gGotSCSIBus OR gTimedOut;		IF gGotSCSIBus THEN BEGIN			gErr := SCSICmd(@gCMD, 6);			IF gErr = noErr THEN BEGIN				gErr := SCSIRead(@gTIB);				IF gErr = noErr THEN BEGIN					debugStr('after SCSIRead(@gTIB); REBOOT!');				END				ELSE BEGIN					writeln('SCSIRead err: ', gErr);				END			END			ELSE BEGIN				gErr := SCSIComplete(gReturnedStat, gReturnedMessage, gWaitTime);				writeln('SCSICmd err: ', gErr);			END;		END		ELSE BEGIN			writeln('Timed out');		END;		gErr := SCSIComplete(gReturnedStat, gReturnedMessage, gWaitTime);		writeln('ReturnedStat, ReturnedMessage = ', gReturnedStat, gReturnedMessage);		writeln;		WITH gResponse DO BEGIN			writeln('VendorID:');			FOR gCounter := 1 TO kVendorIDSize DO				write(VendorID[gCounter]);			writeln;			writeln;			writeln('ProductID:');			FOR gCounter := 1 TO kProductIDSize DO				write(ProductID[gCounter]);			writeln;			writeln;			writeln('Revision:');			FOR gCounter := 1 TO kRevisionSize DO				write(Revision[gCounter]);			writeln;		END;		writeln;		writeln('goodbye');	END.