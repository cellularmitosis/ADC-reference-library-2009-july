<!-- Generated by Harlequin WebMaker 2.2.3 (30-Apr-1996)
Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->
<HTML> <HEAD>
<TITLE>Recipes--Scripting (MacApp PG)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING93></A>


<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="MacAppProgGuide-92.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="MacAppProgGuide-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="MacAppProgGuide-158.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="MacAppProgGuide-94.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="MacAppProgGuide-2.html"><B>Programmer's Guide to MacApp</B></A> / <A HREF="MacAppProgGuide-78.html"><B>Part 2 - Working With MacApp</B></A><BR><DD><A HREF="MacAppProgGuide-91.html"><B>Chapter 14 - Working With Scripting</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING93-0></A>
<H1><A NAME=MARKER-2-27></A>Recipes--Scripting</H1>
 The recipes and sample code in this section describe how to support Apple events in your application, how to define a recordable command class, how to set object properties with Apple events, how to support a custom Apple event, how to write a simple script that can be attached to window objects in your application, how to initialize MacApp's scripting support to use a custom subclass of <CODE>TOSADispatcher</CODE>, and how to override the <CODE>GetContainedObject</CODE> method to look for contained objects matching a type you are interested in.<P>
<A NAME=HEADING93-2></A>
<H2><A NAME=MARKER-2-28></A><A NAME=MARKER-9-29></A>Supporting Apple Events in Your Application--A General Outline</H2>
 A MacApp application is scriptable by default, since it automatically supports the four required Apple events plus a number of events from the Core suite. MacApp's scripting support is initialized automatically from the <CODE>IApplication</CODE> method, so it requires no special initialization by your application.<P>
 This outline describes the steps most MacApp applications take to add support for additional Apple events or to modify MacApp's default behavior. To provide additional scripting support in your application, you perform these steps:<P>
<OL>
<LI>Factor your application. <I>Factoring</I> consists of <P>
<UL>
<LI>separating code that controls the user interface from code that responds to user actions
<LI>breaking functions into discrete operations that can be implemented as separate tasks<P>
For more information, see <A HREF=MacAppProgGuide-49.html#MARKER-9-44>"Factoring," beginning on page 143</A>.<P>
</UL>
<LI>Establish an event suite by identifying the additional Apple events your application will support, or the ones it will modify (see <A HREF=MacAppProgGuide-49.html#MARKER-9-41>page 142</A>).
<LI>Define an <CODE>'aete'</CODE> resource for your new or modified events. The easiest way to do this is to copy and modify MacApp's default <CODE>'aete'</CODE> resource. The <CODE>'aete'</CODE> resource provides information to a scripting component about the Apple events an application supports and about the human-language terminology associated with those events. (See <A HREF=#MARKER-9-40>"Define an 'aete' Resource," beginning on page 356</A>.)
<LI>Define one or more <CODE>'aedt'</CODE> resources for your custom Apple events. An <CODE>'aedt'</CODE> resource maps a received Apple event (by class ID and descriptor type) to a MacApp command number. (See <A HREF=#MARKER-9-43>"Define an 'aedt' Resource for the Custom Event," beginning on page 362</A>.)
<LI>Identify the classes you will use to handle your custom events. If those classes don't descend from classes that already use the mixin class <CODE>MScriptableObject</CODE>, add it to their definition.<P>
When you mix in <CODE>MScriptableObject</CODE> to a class, the constructor for that class should initialize <CODE>MScriptableObject</CODE> with a unique object model class ID. For example, MacApp's <CODE>TFile</CODE> class implements its constructor method as follows:<P>
<pre>TFile::TFile()<BR> : MScriptableObject(cFile)<BR>{<BR> .<BR> .<BR> .<BR>}</pre><P>
This code sets the <CODE>fOMClassID</CODE> field of the <CODE>TFile</CODE> class (inherited from the <CODE>MScriptableObject</CODE> class) to <CODE>cFile</CODE>. This field is used by methods such as <CODE>CountContainedObjects</CODE>, <CODE>GetObjectProperty</CODE>, and <CODE>MakeObjectSpecifier</CODE>.
<LI>Determine which properties of your objects can be set by Apple events. Override the <CODE>GetObjectProperty</CODE> and <CODE>SetObjectProperty</CODE> methods of <CODE>MScriptableObject</CODE> to get and set those properties. You may also have to override the <CODE>GetSetPropertyInfo</CODE> method. (See <A HREF=#MARKER-9-37>"Recipe--Setting Object Properties With Apple Events," beginning on page 355</A>.)
<LI>Optionally override other methods of <CODE>MScriptableObject</CODE> so your scriptable classes can describe themselves to the Object Support Library (OSL). This can include overriding the <CODE>GetContainedObject</CODE>, <CODE>GetIndContainedObject</CODE>, and <CODE>CountContainedObjects</CODE> methods. (See <A HREF=#MARKER-9-54>"Recipe--Overriding the GetContainedObject Method," beginning on page 368</A>.)
<LI>Override the <CODE>MScriptableObject::DoScriptCommand</CODE> method to add support for your custom events. In the <CODE>DoScriptCommand</CODE> method you typically create a command to perform the operation specified by an Apple event. (See <A HREF=#MARKER-9-44>"Override DoScriptCommand to Handle the Custom Event," beginning on page 364</A>.)
<LI>To handle core events, override additional methods in <CODE>MScriptableObject</CODE>, such as <CODE>DoAEMove</CODE>, <CODE>DoAEOpen</CODE>, <CODE>DoAEClose</CODE>, and so on. (Some of these methods are overridden in MacApp classes. For example, the <CODE>TWindow</CODE> class provides a <CODE>DoAEMove</CODE> method.)
<LI>To perform a recordable operation, define a command class that descends from <CODE>TCommand</CODE> (or one of MacApp's many predefined subclasses). Override the <CODE>MakeAppleEvent</CODE> method to create an Apple event that describes the command operation.<A NAME=MARKER-2-30></A><P>
</OL>
<A NAME=HEADING93-21></A>
<H2><A NAME=MARKER-2-31></A><A NAME=MARKER-9-32></A>Recipe--Defining a Recordable Command Class</H2>
 MacApp's <CODE>TCommand</CODE> class contains support for sending an Apple event that describes the command operation. Sending an Apple event makes the operation recordable and allows attached scripts to respond to the command. You can read more about this topic in <A HREF=MacAppProgGuide-44.html#MARKER-9-167>"Command Objects and Apple Events," beginning on page 120</A>. This recipe adds scripting-related information to the recipe for implementing an undoable Zoom In menu command, which begins on <A HREF=MacAppProgGuide-111.html#MARKER-9-34>page 334</A>.<P>
 To define a recordable command class, you perform these steps:<P>
<OL>
<LI>Follow all five steps shown in <A HREF=MacAppProgGuide-111.html#MARKER-9-34>"Recipe--Implementing an Undoable Zoom In Menu Command," beginning on page 334</A>:<P>
<UL>
<LI>Define a command-number constant for the Zoom In menu item.
<LI>Add the Zoom In menu item to a <CODE>'CMNU'</CODE> resource in your resource file.
<LI>Implement a command class that handles Zoom In and override the <CODE>DoIt</CODE>, <CODE>UndoIt</CODE>, and <CODE>RedoIt</CODE> methods.
<LI> Override the <CODE>DoSetupMenus</CODE> method in the view class to enable the Zoom In menu item when appropriate.
<LI> Override the <CODE>DoMenuCommand</CODE> method in the document class to create and post a command object to perform the zoom operation.<P>
Each of these steps is described in the recipe for an undoable Zoom In menu command.<P>
</UL>
</OL>
 You also perform this additional step:<P>
<OL>
<LI>Override the <CODE>MakeAppleEvent</CODE> method in the <CODE>TZoomInCommand</CODE> class.<P>
</OL>
 The sample code in this recipe is from the IconEdit application.<P>
<A NAME=HEADING93-34></A>
<H3>Override MakeAppleEvent in the TZoomInCommand Class</H3>
 The <CODE>TCommand::MakeAppleEvent</CODE> method creates an Apple event that describes the command operation. For the <CODE>TZoomInCommand</CODE> class, the operation is zooming in on an icon. The <CODE>TZoomInCommand</CODE> class is shown in <A HREF=MacAppProgGuide-90.html#MARKER-9-31>"Implement a Command Class That Handles Zoom In," beginning on page 335</A>.<P>
 For the <CODE>TZoomInCommand</CODE> class, the <CODE>MakeAppleEvent</CODE> method is defined as follows:<P>
<PRE>
TAppleEvent * TZoomInCommand::MakeAppleEvent() // Override.
{
   CTempDescdirectObjectDesc;
   TAppleEvent * theZoomInAppleEvent = new TAppleEvent;

   theZoomInAppleEvent-&gt;IAppleEvent(kAEIconEditClass, kAEZoomInID,
                              gServerAddress, kAENoReply);
   fIconDocument-&gt;MakeObjectSpecifier(directObjectDesc,
                           fIconDocument-&gt;GetSpecifierForm());
   theZoomInAppleEvent-&gt;WriteParameter(keyDirectObject,
                              directObjectDesc);
   return theZoomInAppleEvent;
}
</PRE>
 This method first creates a new <CODE>TAppleEvent</CODE> object and initializes it for the Zoom In command. The constant kAENoReply indicates that no reply to the Apple event is expected. The constants kAEIconEditClass and kAEZoomInID are defined as follows:<P>
<PRE>
const OSType kAEIconEditClass = 'ICED'; // Event class.
const OSType kAEZoomInID = 'ZmIn';// Event ID.
</PRE>
 For more information on how event class and ID constants are used, see <A HREF=#MARKER-9-43>"Define an 'aedt' Resource for the Custom Event," beginning on page 362</A>.<P>
 The <A NAME=MARKER-2-33></A>MakeAppleEvent method next asks its document to create an object specifier (see <A HREF=MacAppProgGuide-92.html#MARKER-9-25>page 350</A>), then writes the specifier to the Apple event. The result is a Zoom In Apple event that specifies an icon document object to be zoomed.<P>
<DL>
<DT><B>Note</B>
<DD>The TDocument::<A NAME=MARKER-2-34></A>GetSpecifierForm method returns <CODE>formName</CODE>, so the object specifier identifies the document by name.<A NAME=MARKER-2-35></A><EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
<A NAME=HEADING93-43></A>
<H2><A NAME=MARKER-2-36></A><A NAME=MARKER-9-37></A>Recipe--Setting Object Properties With Apple Events</H2>
 This recipe depends on MacApp's built-in support for handling set property Apple events. To understand how that support works, you should read about the <CODE>TSetPropertyCommand</CODE> and <CODE>TPropertyAccessor</CODE> classes, beginning on <A HREF=MacAppProgGuide-52.html#MARKER-9-134>page 155</A>.<P>
 To add support to a class to set object properties based on received Apple events, you perform the following steps:<P>
<OL>
<LI>Identify the property or properties the class will support.
<LI>Define an <CODE>'aete'</CODE> resource with information on the class and the properties that can be set by Apple events.
<LI>Mix in the <CODE>MScriptableObject</CODE> class (if it isn't already mixed in).
<LI>Initialize <CODE>MScriptableObject</CODE> with an object model class ID for the class.
<LI>Override the <CODE>GetObjectProperty</CODE> and <CODE>SetObjectProperty</CODE> methods.
<LI>If necessary, override the <CODE>GetSetPropertyInfo</CODE> method.<P>
</OL>
 The sample code shown in this recipe is from the IconEdit application.<P>
<A NAME=HEADING93-53></A>
<H3>Identify the Property or Properties the Class Will Support</H3>
 Apple event object classes may have one or more properties. A property is identified by a four-character property ID, which can also be represented by a constant. Constants for properties always begin with the letter "p". Many are defined in the header file <CODE>AERegistry.h</CODE>. <A HREF=#MARKER-9-39>Table 14-1</A> lists the constant names and property IDs for some common properties. You can read more about properties in <I><A HREF="../IAC/IAC-2.html">Inside Macintosh: Interapplication Communication</A></I>.<P>
 The IconEdit application supports <CODE>pColor</CODE> as a property that specifies the current icon color of an object based on the <CODE>TIconDocument</CODE> class.<P>
<B>Table 14-1  <A NAME=MARKER-2-38></A><A NAME=MARKER-9-39></A>
<TABLE BORDER="0" CELLPADDING=3><TH ALIGN=LEFT>Property<TH>Property ID<TH>Description<TR>
<TD><CODE>pBounds</CODE><TD><CODE>'pbnd'</CODE><TD>Coordinates of a window<TR>
<TD><CODE>pClass</CODE><TD><CODE>'pcls'</CODE><TD>Class ID of an Apple event object<TR>
<TD><CODE>pColor</CODE><TD><CODE>'colr'</CODE><TD>Text color<TR>
<TD><CODE>pFillColor</CODE><TD><CODE>'flcl'</CODE><TD>Fill color<TR>
<TD><CODE>pFont</CODE><TD><CODE>'font'</CODE><TD>Font<TR>
<TD><CODE>pIsModal</CODE><TD><CODE>'pmod'</CODE><TD>Indicates whether a window is modal<TR>
<TD><CODE>pName</CODE><TD><CODE>'pnam'</CODE><TD>Name of an Apple event object<TR>
<TD><CODE>pScriptTag</CODE><TD><CODE>'psct'</CODE><TD>Script system identifier<TR>
<TD><CODE>pTextPointSize</CODE><TD><CODE>'ptps'</CODE><TD>Point size<TR>
<TD><CODE>pTextStyle</CODE><TD><CODE>'txst'</CODE><TD>Text style<TR>
<TD><CODE>pVisible</CODE><TD><CODE>'pvis'</CODE><TD>Indicates whether a window is visible</TABLE>
Common object properties</B><P>
 MacApp classes that mix in <CODE>MScriptableObject</CODE> override the <CODE>GetObjectProperty</CODE> and <CODE>SetObjectProperty</CODE> methods to get and set the object properties they support. For example, the <CODE>TWindow</CODE> class returns the <CODE>pClass</CODE>, <CODE>pBounds</CODE>, <CODE>pName</CODE>, <CODE>pHasCloseBox</CODE>, <CODE>pHasTitleBar</CODE>, <CODE>pIsModal</CODE>, <CODE>pIsResizable</CODE>, <CODE>pIsZoomable</CODE>, <CODE>pIsZoomed</CODE>, and <CODE>pSelection</CODE> properties in its <CODE>GetObjectProperty</CODE> method. In its <CODE>SetObjectProperty</CODE> method, it can handle <CODE>pBounds</CODE>, <CODE>pName</CODE>, and <CODE>pIsZoomed</CODE> (the other properties are read only). As a result, you can use a script to read or set many window properties without writing any additional application code.<P>
<A NAME=HEADING93-58></A>
<H3><A NAME=MARKER-9-40></A>Define an 'aete' Resource</H3>
 An <CODE>'aete'</CODE> resource provides information to a scripting component about the Apple events an application supports and about the human-language terminology to associate with those events.<P>
 The best way to supply information about your custom events is to copy MacApp's default <CODE>'aete'</CODE> resource, located in the file <CODE>Defaults.r</CODE>, add it to your application's resource definition file, and modify it to include your custom events.<P>
 The IconEdit application modifies MacApp's default <CODE>'aete'</CODE> resource to add an icon suite of supported Apple events. The following code, from the file <CODE>IconEdit.r</CODE>, shows the part of IconEdit's <CODE>'aete'</CODE> resource that allows an icon document to handle the color property:<P>
<PRE>
{  /* array Classes: 1 elements */
   /* [1] */
   &quot;document&quot;, cDocument, &quot;IconEdit document&quot;,
   {  /* array Properties: 1 elements */
      /* [1] */
      &quot;icon_color&quot;,
      pColor,
      cRGBColor,
      &quot;color in which the icon is drawn&quot;,
      reserved,
      singleItem,
      notEnumerated,
      readWrite,
      Reserved8,
      noApostrophe,
      notFeminine,
      notMasculine,
      singular
   },
   {  /* array Elements: 0 elements */
   }
},
</PRE>
 For more information about the format of an <CODE>'aete'</CODE> resource, see the "Apple Event Terminology Resources" chapter of <I><A HREF="../IAC/IAC-2.html">Inside Macintosh: Interapplication Communication</A></I>.<P>
<A NAME=HEADING93-64></A>
<H3>Mix in the MScriptableObject Class</H3>
 Your class that gets and sets object properties must mix in <A NAME=MARKER-2-41></A><CODE>MScriptableObject</CODE> unless it descends from a class that already mixes in <CODE>MScriptableObject</CODE>. The <CODE>TIconDocument</CODE> class is a descendant of the <CODE>TDocument</CODE> class, which mixes in MScriptableObject. The <CODE>TDocument</CODE> class is declared as follows to mix in MScriptableObject:<P>
<PRE>
class TDocument : public TCommandHandler, public MScriptableObject
</PRE>
<A NAME=HEADING93-67></A>
<H3>Initialize MScriptableObject With an Object Model Class ID</H3>
 If your class that gets and sets object properties doesn't already mix in <CODE>MScriptableObject</CODE>, the constructor for your class should initialize <CODE>MScriptableObject</CODE> with a unique object model ID. For example, the constructor method for the <CODE>TDocument</CODE> class is implemented as follows:<P>
<PRE>
TDocument::TDocument()
   : MScriptableObject(cDocument),
   fTitle(gEmptyString),
   fWindowList(NULL),
      .
      .
      .
{
}
</PRE>
 This implementation demonstrates a C++ mechanism for supplying a method with a list of default values. The line<P>
  : MScriptableObject(cDocument),<P>
 invokes a constructor for MScriptableObject and initializes the <CODE>fOMClassID</CODE> field to <CODE>cDocument</CODE>. The subsequent lines initialize fields of the <CODE>TDocument</CODE> class.<P>
<A NAME=HEADING93-73></A>
<H3>Override GetObjectProperty and SetObjectProperty </H3>
 Your class that supports modifying object properties with Apple events overrides the <CODE>GetObjectProperty</CODE> and <CODE>SetObjectProperty</CODE> methods to get and set the properties it works with. For the <CODE>TIconDocument</CODE> class, these methods look for the <CODE>pColor</CODE> property. For any other property, they call <CODE>Inherited</CODE>.<P>
<PRE>
Boolean TIconDocument::GetObjectProperty(CAEDesc&amp; thePropertyValue,
                                 DescType whichProperty,
                           const CAEDesc&amp; desiredType)
{
   Boolean hasProperty = TRUE;
   
   switch (whichProperty)
   {
      case pColor:
         thePropertyValue.PutRGBColor(fColor); // Set color.
         break;
         
      default:
         hasProperty = Inherited::GetObjectProperty(
                  thePropertyValue, whichProperty, desiredType);
         break;
   }
   return hasProperty;
}
</PRE>
 The GetObjectProperty method gets the document's icon color from the <CODE>fColor</CODE> field and writes it to the passed descriptor object, <CODE>thePropertyValue</CODE>.<P>
<PRE>
void TIconDocument::SetObjectProperty(
                     const CAEDesc&amp; thePropertyValue,
                           DescType whichProperty)
{
   switch(whichProperty)
   {
      case pColor:
         thePropertyValue.GetRGBColor(fColor);
         this-&gt;RedrawViews();
         break;

      default:
         Inherited::SetObjectProperty(thePropertyValue,
                                 whichProperty);
         break;
   }
}
</PRE>
 The SetObjectProperty method writes the color from the passed descriptor object, <CODE>thePropertyValue</CODE>, to the document's <CODE>fColor</CODE> field. It then calls the <CODE>RedrawViews</CODE> method to force the icon to be redrawn with the new color.<P>
<A NAME=HEADING93-79></A>
<H3>If Necessary, Override GetSetPropertyInfo </H3>
 The <CODE>GetSetPropertyInfo</CODE> method is described in <A HREF=MacAppProgGuide-52.html#MARKER-9-134>"The TSetPropertyCommand Class," beginning on page 155</A>. Your class overrides <CODE>GetSetPropertyInfo</CODE> only if it needs to change the default values supplied by the <CODE>MScriptableObject</CODE> class. The TIconDocument class overrides <CODE>GetSetPropertyInfo</CODE> to supply a command number:<P>
<PRE>
void TIconDocument::GetSetPropertyInfo(DescTypewhichProperty,
                              CommandNumber&amp;cmdNum,
                              Boolean&amp;    canUndo,
                              Boolean&amp;    causesChange,
                              TCommandHandler* &amp;theContext)
{
   switch(whichProperty)
   {
      case pColor:
         cmdNum = cSetColor;
         canUndo = TRUE;
         causesChange = TRUE;
         theContext = this;
         break;
      
      default:
         Inherited::GetSetPropertyInfo(whichProperty, cmdNum,
                        canUndo, causesChange, theContext);
         break;
   }
}
</PRE>
 The icon document sets only the <CODE>pColor</CODE> property, so for any other property this method just calls <CODE>Inherited</CODE>.<P>
<A NAME=HEADING93-83></A>
<H2>Recipe--Supporting a Custom Apple Event</H2>
 To support a custom Apple event (or any number of them), your application performs many of the steps shown in the general outline beginning on <A HREF=#MARKER-9-29>page 351</A>. This recipe shows how the IconEdit application supports a Zoom In event.<P>
 To use a custom Apple event in your application, you perform these steps:<P>
<OL>
<LI>Identify the custom event to be supported.
<LI>Describe the custom event in your application's <CODE>'aete'</CODE> resource.
<LI>Define an <CODE>'aedt'</CODE> resource for the custom event.
<LI>Make sure the class that handles the custom event mixes in the <CODE>MScriptableObject</CODE> class.
<LI>If necessary, override methods of <CODE>MScriptableObject</CODE> so that your scriptable class can describe itself to the OSL.
<LI>Override the <CODE>MScriptableObject::DoScriptCommand</CODE> method to handle the custom event.<P>
</OL>
 The sample code shown in this recipe is from the IconEdit application.<P>
<A NAME=HEADING93-93></A>
<H3><A NAME=MARKER-9-42></A>Identify the Custom Apple Event</H3>
 The IconEdit application defines custom events to invert an icon, zoom in and zoom out on an icon, and draw or erase the points in an icon. This recipe examines the Zoom In event.<P>
<A NAME=HEADING93-95></A>
<H3>Define an 'aete' Resource That Includes the Custom Event</H3>
 An <CODE>'aete'</CODE> resource provides information to a scripting component about the Apple events an application supports, and about the human-language terminology to associate with those events. You can copy MacApp's default <CODE>'aete'</CODE> resource, located in the file <CODE>Defaults.r</CODE>, add it to your application's resource definition file, and modify it to include your custom events.<P>
 The IconEdit application modifies MacApp's default <CODE>'aete'</CODE> resource to add an Icon suite of supported Apple events. The following code, from the file <CODE>IconEdit.r</CODE>, shows the part of IconEdit's <CODE>'aete'</CODE> resource that allows an icon document to handle the Zoom In event:<P>
<PRE>
/* [2] */
&quot;zoom_in&quot;,
&quot;increases the magnification of the target document&quot;,
'ICED',
'ZmIn',
noReply, &quot;&quot;, replyOptional, singleItem, notEnumerated,
notTightBindingFunction, Reserved8, verbEvent, Reserved3,
typeObjectSpecifier,
&quot;the document to zoom into&quot;,
directParamRequired, singleItem, notEnumerated,
doesntChangeState, Reserved12,
{  /* array OtherParams: 0 elements */
}
</PRE>
 For more information about the format of an <CODE>'aete'</CODE> resource, see the "Apple Event Terminology Resources" chapter of <I><A HREF="../IAC/IAC-2.html">Inside Macintosh: Interapplication Communication</A></I>.<P>
<A NAME=HEADING93-100></A>
<H3><A NAME=MARKER-9-43></A>Define an 'aedt' Resource for the Custom Event</H3>
 MacApp uses resources of type <CODE>'aedt'</CODE> to install Apple event callback routines for an application's custom events (see <A HREF=MacAppProgGuide-52.html#MARKER-9-87>"InstallDispatchHandlers," beginning on page 151</A>). An <CODE>'aedt'</CODE> resource is an array of entries, each of which maps an Apple event class and ID pair to a MacApp command number.<P>
 To handle a custom Apple event in your application, you define an Apple event class and ID for the event, as well as a command number to associate with them. Then you add an <CODE>'aedt'</CODE> resource to your resource definition file and include an entry for the event. You can store as many entries as you want in one <CODE>'aedt'</CODE> resource, and you can have multiple <CODE>'aedt'</CODE> resources.<P>
 The IconEdit application defines the following 'aedt' resource in the file <CODE>IconEdit.r</CODE> to support Apple events specifying the operations to invert, zoom in, zoom out, and draw points:<P>
<PRE>
resource 'aedt' (kAEIconEditDispatchTable, 
#if qNames
   &quot;IconEdit Events&quot;,
#endif
   purgeable) {
   {  /* array: 4 elements */
      /* [1] */
      'ICED', 'INVT', 1002,
      /* [2] */
      'ICED', 'ZmIn', 1000,
      /* [3] */
      'ICED', 'ZmOt', 1001,
      /* [4] */
      'ICED', 'DrPt', 1003
   }
};
</PRE>
 The IconEdit application defines the following constants for working with its custom Apple events (the <CODE>IconEdit.r</CODE> resource file ought to define similar constants and use them in the <CODE>'aedt'</CODE> resource shown above):<P>
<PRE>
const OSType kSignature ='ICED'; // Application signature.

const OSType kAEInvertID = 'INVT';// Custom Apple event IDs.
const OSType kAEZoomInID = 'ZmIn';
const OSType kAEZoomOutID = 'ZmOt';
const OSType kAEDrawPoints = 'DrPt';

const CommandNumber cZoomIn=1000;// Zoom In menu command.
const CommandNumber cZoomOut=1001;// Zoom Out menu command.
const CommandNumber cInvert=1002;// Invert menu command.
const CommandNumber cDrawCommand =1003;// Drawing in the icon view.
const CommandNumber cDrawPointsCommand = 1004;// Set point Apple event.
</PRE>
<A NAME=HEADING93-107></A>
<H3>Add the Mixin Class MScriptableObject </H3>
 MacApp dispatches Apple events through a global Apple event dispatcher object, described in <A HREF=MacAppProgGuide-52.html#MARKER-9-77>"Dispatching Apple Events," beginning on page 150</A>. The event dispatcher expects the specified objects to be descendants of <CODE>MScriptableObject</CODE>, a MacApp mixin class with fields and methods for working with Apple events.<P>
 Several MacApp classes, including <CODE>TDocument</CODE> and <CODE>TWindow</CODE>, already use <CODE>MScriptableObject</CODE>. If you define a class that handles Apple events and doesn't descend from a class that already uses <CODE>MScriptableObject</CODE>, you should add <CODE>MScriptableObject</CODE> to the class definition.<P>
 The <CODE>TIconDocument</CODE> class is a descendant of the <CODE>TDocument</CODE> class, which is declared as follows:<P>
<PRE>
class TDocument : public TCommandHandler, public MScriptableObject
</PRE>
<A NAME=HEADING93-112></A>
<H3>If Necessary, Override Certain Methods of MScriptableObject</H3>
 MacApp's global Apple event dispatcher object calls routines of the Object Support Library to help resolve the object specified by the event. The OSL uses callback routines in the event dispatcher object to ask objects to describe themselves.<P>
 To aid in this process, your classes that handle Apple events may need to override methods of <CODE>MScriptableObject</CODE> (such as <CODE>GetContainedObject</CODE>, <CODE>GetIndContainedObject</CODE>, and <CODE>CountContainedObjects</CODE>) to describe their elements. This information can help determine if the document matches the one specified by an Apple event. For an example of how to override the <CODE>GetContainedObject</CODE> method, see <A HREF=#MARKER-9-54>"Recipe--Overriding the GetContainedObject Method," beginning on page 368</A>.<P>
<A NAME=HEADING93-115></A>
<H3><A NAME=MARKER-9-44></A>Override DoScriptCommand to Handle the Custom Event</H3>
 When MacApp identifies the object specified by an Apple event, it calls the <CODE>DoScriptCommand</CODE> method of that object. The class that handles your custom Apple event overrides <CODE>DoScriptCommand</CODE> to handle events it knows about.<P>
 The <CODE>TIconDocument</CODE> class overrides <A NAME=MARKER-2-45></A><CODE>DoScriptCommand</CODE> and supplies the following code to create a command to zoom in on an icon:<P>
<PRE>
case cZoomIn:
      TZoomInCommand * theZoomInCommand = new TZoomInCommand();
      theZoomInCommand-&gt;IZoomInCommand(this);
      theZoomInCommand-&gt;Process();
   break;
</PRE>
 Note that this code does not set the command's <CODE>fUseAppleEvent</CODE> field to <CODE>TRUE</CODE>. Because the Zoom In command is being created in response to an Apple event, there is no need to send an Apple event to show that the operation was performed. The <CODE>TZoomInCommand</CODE> class is described in <A HREF=#MARKER-9-32>"Recipe--Defining a Recordable Command Class," beginning on page 353</A>.<A NAME=MARKER-2-46></A><P>
<A NAME=HEADING93-120></A>
<H2><A NAME=MARKER-2-47></A><A NAME=MARKER-9-48></A>Recipe--Attaching a Script to Objects in Your Application</H2>
 <A HREF=MacAppProgGuide-53.html#MARKER-9-154>"Attaching Scripts," beginning on page 158</A>, describes MacApp's mechanism for attaching scripts to objects in your application. MacApp provides true attachability through its Apple-event-dispatching mechanism and its <CODE>MScriptableObject</CODE> class--that is, a script can be attached to an object, and any Apple events specifying that object will first be dispatched to the attached script.<P>
 You attach a script to an object that mixes in MScriptableObject by calling the <CODE>SetObjectProperty</CODE> method and passing two values: a <CODE>CAEDesc</CODE> value that describes the script and a <CODE>DescType</CODE> value that specifies the <CODE>pScript</CODE> property. Since many MacApp classes already mix in MScriptableObject, you can attach scripts to objects based on these classes (or on subclasses you define) without writing any additional application code.<P>
 When a script is attached to any object in the application, MacApp's global Apple event dispatcher object installs a callback routine to predispatch Apple events. The predispatch routine gives attached scripts a chance to handle Apple events dispatched by the application, whether they are generated internally or received from an outside source.<P>
 The following is a simple script that you can run from the Script Editor application. It attaches a script to each open window in the DemoText sample application. When you close a window with the script attached, the script intercepts the close operation and forces the document to be saved.<P>
<PRE>
script forceSaveOnClose
   
   on close of theCloseObj saving savingValue
      display dialog &quot;Entering Script&quot;
      display dialog &quot;The original saving value:&quot;
      display dialog savingValue
      set savingValue to yes
      display dialog &quot;The new saving value:&quot;
      display dialog savingValue
      set savingFile to a reference to file &quot;YourHardDisk:YourSaveFolder:SavedFile&quot;
      continue close of theCloseObj saving savingValue saving in savingFile
      display dialog &quot;Finished  - Exiting Script&quot;
   end close
   
end script

on run
   set the script of every window of application &quot;DemoText&quot; to forceSaveOnClose
end run
</PRE>
 To test this script, you perform the following steps:<P>
<OL>
<LI>Build a version of the DemoText application that includes MacApp's attachability support.<P>
To enable attachability in your application, you must build the application with the <CODE>qAttachable</CODE> flag set to <CODE>TRUE</CODE>. <A HREF=MacAppProgGuide-152.html#MARKER-9-30>"Common Command-Line Options," beginning on page 678</A>, describes how to build your application with attachability or without it, using MPW's MABuild system.
<LI>Run the DemoText application. Open one or more windows.
<LI>Run the Script Editor application.
<LI>Open a new script window.
<LI>Copy the script shown above into the script window.
<LI>Change "DemoText" to match the current name of the application on your computer (for example, "DemoTextPPC_nd").
<LI>Change "<I>YourHardDisk<CODE>:YourSaveFolder:</CODE></I>" to specify a disk and folder location on your current machine. If desired, change "<CODE>SavedFile</CODE>" to a different filename.
<LI>Click the Run button to run the script.<P>
</OL>
 This script attaches the <CODE>forceSaveOnClose</CODE> script to each open window in the DemoText application (actually, to each window's document).<P>
<A NAME=HEADING93-137></A>
<H3>How MacApp Attaches the Script</H3>
 When you run the script with Script Editor, the line<P>
<PRE>
set the script of every window of application &quot;DemoText&quot;
   to forceSaveOnClose
</PRE>
 sends an Apple event to the DemoText application, telling it to set the <CODE>pScript</CODE> property of each window to the <CODE>forceSaveOnClose</CODE> script. The mechanism for setting object properties is described in <A HREF=MacAppProgGuide-48.html#MARKER-9-19>Chapter 6, "Scripting,"</A> beginning on <A HREF=MacAppProgGuide-52.html#MARKER-9-134>page 155</A> (in the sections describing the <CODE>TSetPropertyCommand</CODE> and <CODE>TPropertyAccessor</CODE> classes) and in <A HREF=#MARKER-9-37>"Recipe--Setting Object Properties With Apple Events," beginning on page 355</A>.<P>
 When MacApp receives the Apple event, it creates a list containing a <CODE><A NAME=MARKER-2-49></A>TPropertyAccessor</CODE> object for each open window and uses the list to initialize a <CODE><A NAME=MARKER-2-50></A>TSetPropertyCommand</CODE> object. The <CODE>TSetPropertyCommand</CODE> object uses MacApp's attachability mechanism (<A HREF=MacAppProgGuide-53.html#MARKER-9-154>page 158</A>) to attach the script to each window.<P>
<DL>
<DT><B>Note</B>
<DD>When you attach a script to a window object by setting the <CODE>pScript</CODE> property, the window defers to its document, so the script is actually attached to the document.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
 MacApp even automates saving a script when you close the document it is attached to. When you save a DemoText document with the <CODE>forceSaveOnClose</CODE> script attached, the script is automatically saved in the document's resource fork (unless you change the value of the document's <A NAME=MARKER-2-51></A><CODE>fSaveAttachedScript</CODE> field to <CODE>FALSE</CODE>). When you open the document, it automatically reads the script, creates a script object, and attaches it to the document object.<P>
<A NAME=HEADING93-144></A>
<H3>What Happens When the Script Is Executed</H3>
 When you close a window in the DemoText application, MacApp creates and posts a <CODE>TCloseFileDocCommand</CODE>. When the command is processed, it sends a <CODE>kAEClose</CODE> Apple event that specifies the document to be closed.<P>
 If a script is attached to any object in the application, MacApp's global Apple event dispatcher object attempts to predispatch each Apple event for handling by an attached script. In this case, the predispatch handler method dispatches the Apple event to the document's attached script.<P>
 The <CODE>forceSaveOnClose</CODE> script gains control after the user has been asked whether to save the document. The <CODE>forceSaveOnClose</CODE> script then performs the following actions (assuming you don't cancel the script and no errors are encountered):<P>
<UL>
<LI>It displays the alert "Entering Script".
<LI>It displays the user's original save choice ("yes" if the user chose to save, "no" if the user chose not to save the document).
<LI>It sets the save choice to "yes" and displays the new choice.
<LI>It saves the file to the specified location.
<LI>It displays the alert "Finished - Exiting Script".<P>
</UL>
<A NAME=HEADING93-153></A>
<H3>Where You Go From Here</H3>
 This recipe presents a simple script that hard-codes the name and location of the saved file and contains no error checking. Yet it demonstrates how attached scripts can greatly alter the behavior of a MacApp application. For example, a user can attach a similar script to a document representing an office form, so that every time the document is saved, the default behavior is overridden and the document is backed up to a server. <P>
 Other uses for attached scripts are limited only by your imagination and the diabolical cunning of your end users.<A NAME=MARKER-2-52></A><P>
<A NAME=HEADING93-156></A>
<H2><A NAME=MARKER-2-77></A><A NAME=MARKER-9-54></A>Recipe--Overriding the GetContainedObject Method</H2>
 When your application receives an Apple event, MacApp attempts to dispatch the event to the specified object. (Object specifiers are described beginning on <A HREF=MacAppProgGuide-92.html#MARKER-9-25>page 350</A>.) During the dispatching process, the OSL makes callbacks to methods of MacApp's global Apple event dispatcher object, attempting to identify the Apple event object with the specified properties.<P>
 As part of this process, the <CODE>TOSADispatcher::ObjectAccessor</CODE> method makes the following call:<P>
<PRE>
resultObject = containerObject-&gt;GetContainedObject(
                           desiredClass, form, selectionData);
</PRE>
 GetContainedObject is a method of <CODE>MScriptableObject</CODE>, so it can be overridden by any class that mixes in <CODE>MScriptableObject</CODE>. The ultimate container (the first object queried by the OSL when resolving an object specifier) is the application object. The <CODE>TApplication</CODE> class overrides GetContainedObject to look for contained files. If the desired object is not a file, it calls <CODE>Inherited</CODE>, which results in a call to <CODE>MScriptableObject::GetContainedObject</CODE>. That method looks for contained objects matching the desired name, relative position, range, unique ID, or absolute position.<P>
 To override the <CODE>GetContainedObject</CODE> method to return contained objects that match a form you are interested in, you perform the following steps:<P>
<OL>
<LI>Define a class that mixes in the <CODE>MScriptableObject</CODE> class.
<LI>Provide an override version of the <CODE>GetContainedObject</CODE> method.<P>
</OL>
 The sample code shown in this recipe is taken from the MacApp <CODE>TWindow</CODE> class.<P>
<A NAME=HEADING93-165></A>
<H3>Define a Class That Mixes In the MScriptableObject Class</H3>
 To override the <CODE>GetContainedObject</CODE> method, your class must descend from the <CODE>MScriptableObject</CODE> class or the <CODE>MDefaultScriptableObject</CODE> class, or from a class that mixes in one of those classes. Many MacApp classes (including <CODE>TApplication</CODE>, <CODE>TDocument</CODE>, and <CODE>TWindow</CODE>) mix in one of these classes, so you don't have to write any additional code for your application, document, or window classes to mix in the <CODE>MScriptableObject</CODE> class.<P>
<A NAME=HEADING93-167></A>
<H3>Provide an Override Version of the GetContainedObject Method</H3>
 Your version of <CODE>GetContainedObject</CODE> should check for a contained object matching the form or forms it is interested in. If it doesn't find one, it should call MScriptableObject::GetContainedObject. The following is the GetContainedObject method from MacApp's <CODE>TWindow</CODE> class:<P>
<PRE>
MScriptableObject* TWindow::GetContainedObject(
                              DescType    desiredType,
                              DescType    selectionForm,
                              const CAEDesc&amp;selectionData)
{
   MScriptableObject * result = NULL;
   if (this-&gt;IsShown() &amp;&amp; !fFloats)
   {
      if (gApplication-&gt;IsDocumentClass(desiredType))
         result = fDocument;
      else if (fDocument &amp;&amp; (desiredType != cProperty)
               &amp;&amp; (desiredType != this-&gt;GetOMClass()))
         result = fDocument-&gt;GetContainedObject(desiredType,
                              selectionForm, selectionData);
   }
   
   if (!result)
      result = MScriptableObject::GetContainedObject(desiredType,
                              selectionForm, selectionData);
      
   return result;
}
</PRE>
 This code checks whether the desired type is a document or a property. If the desired type is a document (determined by calling the application object's <CODE>IsDocumentClass</CODE> method), this method returns the window's <CODE>fDocument</CODE> reference as the contained object. If the desired type is a property, it gives its document a chance to return the contained object. If the desired type is neither a document or a property, it calls the MScriptableObject::GetContainedObject method to look for other types.<A NAME=MARKER-2-55></A><P>
<A NAME=HEADING93-171></A>
<H2><A NAME=MARKER-2-56></A><A NAME=MARKER-9-57></A>Recipe--Installing a Custom Subclass of TOSADispatcher</H2>
 By default, MacApp's scripting support creates a global Apple event dispatcher object (accessed through TOSADispatcher::fgDispatcher) of type <CODE>TOSADispatcher</CODE>. However, you can define a custom subclass of <CODE>TOSADispatcher</CODE> and cause MacApp to use your type instead. When you create a custom Apple event dispatcher, you still access it through TOSADispatcher::fgDispatcher.<P>
 To install a custom subclass of <CODE>TOSADispatcher</CODE>, you perform the following steps:<P>
<OL>
<LI>Define your custom subclass of <CODE>TOSADispatcher</CODE> (not shown).
<LI>Register your custom subclass.
<LI>Call the <CODE>InitUScripting</CODE> method of your custom subclass.<P>
</OL>
 The sample code shown in this recipe is for a generic application.<P>
<A NAME=HEADING93-178></A>
<H3>Define a Custom Subclass of TOSADispatcher</H3>
 Several other recipes describe how to define a class, including <A HREF=MacAppProgGuide-135.html#MARKER-9-35>"Recipe--Defining a Class," beginning on page 277</A>, and <A HREF=MacAppProgGuide-111.html#MARKER-9-34>"Recipe--Defining a Subclass of TApplication," beginning on page 289</A>. This recipe assumes that you have defined a custom subclass of <CODE>TOSADispatcher</CODE> named <CODE>T<I>YourOSADispatcher</I></CODE>.<P>
<A NAME=HEADING93-180></A>
<H3>Register Your Custom Subclass</H3>
 You must register your custom subclass of <CODE>TOSADispatcher</CODE> so that the <CODE>InitUScripting</CODE> method will be able to create an instance of your class. You register your custom class with the following line:<P>
<PRE>
MA_REGISTER_CLASS(TYourOSADispatcher);
</PRE>
<A NAME=HEADING93-183></A>
<H3>Call the InitUScripting Method of Your Custom Subclass</H3>
 You need to call the <CODE>InitUScripting</CODE> method of your custom subclass <I>before</I> calling <CODE>IApplication</CODE>. A reasonable place to do so is in your <CODE>main</CODE> function or in the initialization method of your application class, using code like the following:<P>
<PRE>
void TYourApplication::IYourApplication()
{
   // Init your custom dispatcher BEFORE calling IApplication.
   TYourOSADispatcher::InitUScripting(&amp;TYourOSADispatcher::fgClassDesc);

   this-&gt;IApplication(kFileType, kSignature);

   // Additional application initialization code, if necessary.
}
</PRE>
 When I<I>Your</I>Application calls <CODE>T<I>YourOSADispatcher</I></CODE>::<CODE>InitUScripting</CODE>, the <CODE>InitUScripting</CODE> method creates an instance of <CODE>T<I>YourOSADispatcher</I></CODE> and stores a reference to it in the static global variable <CODE>T<I>YourOSADispatcher</I></CODE>::<CODE>fgDispatcher</CODE>.<A NAME=MARKER-10-8></A><A NAME=MARKER-2-58></A><P>
<DL>
<DT><B>Note</B>
<DD>If you skip this step, <CODE>InitUScripting</CODE> will create an instance of <CODE>TOSADispatcher</CODE> rather than an instance of your custom class, <CODE>T<I>YourOSADispatcher</I></CODE>.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
</BLOCKQUOTE>
<HR>
<center>
<A HREF="MacAppProgGuide-92.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="MacAppProgGuide-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="MacAppProgGuide-158.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="MacAppProgGuide-94.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="MacAppProgGuide-3.html">&copy; Apple Computer, Inc.</A><br>25 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>  
