<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>7Edit - /Source/SVAERecording.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxMacOS9Earlier-date.html">Mac OS 9 & Earlier</a> &gt; <A HREF="javascript:location.replace('index.html');">7Edit</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/Carbon/idxInterapplicationCommunication-date.html" target="_blank">Carbon > Interapplication Communication</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">7Edit</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/Source/SVAERecording.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/Source/DebugUtils.c</option>
<option value="listing2.html">/Source/DebugUtils.h</option>
<option value="listing3.html">/Source/Offscreen.c</option>
<option value="listing4.html">/Source/Offscreen.h</option>
<option value="listing5.html">/Source/SVAEAccessors.c</option>
<option value="listing6.html">/Source/SVAEAccessors.h</option>
<option value="listing7.html">/Source/SVAEClone.c</option>
<option value="listing8.html">/Source/SVAEClone.h</option>
<option value="listing9.html">/Source/SVAEClose.c</option>
<option value="listing10.html">/Source/SVAEClose.h</option>
<option value="listing11.html">/Source/SVAECoercions.c</option>
<option value="listing12.html">/Source/SVAECoercions.h</option>
<option value="listing13.html">/Source/SVAECompare.c</option>
<option value="listing14.html">/Source/SVAECompare.h</option>
<option value="listing15.html">/Source/SVAECopy.c</option>
<option value="listing16.html">/Source/SVAECopy.h</option>
<option value="listing17.html">/Source/SVAECountElements.c</option>
<option value="listing18.html">/Source/SVAECountElements.h</option>
<option value="listing19.html">/Source/SVAECreate.c</option>
<option value="listing20.html">/Source/SVAECreate.h</option>
<option value="listing21.html">/Source/SVAECut.c</option>
<option value="listing22.html">/Source/SVAECut.h</option>
<option value="listing23.html">/Source/SVAEDelete.c</option>
<option value="listing24.html">/Source/SVAEDelete.h</option>
<option value="listing25.html">/Source/SVAEGetData.c</option>
<option value="listing26.html">/Source/SVAEGetData.h</option>
<option value="listing27.html">/Source/SVAEGetDataSize.c</option>
<option value="listing28.html">/Source/SVAEGetDataSize.h</option>
<option value="listing29.html">/Source/SVAEMove.c</option>
<option value="listing30.html">/Source/SVAEMove.h</option>
<option value="listing31.html">/Source/SVAEObjectsExist.c</option>
<option value="listing32.html">/Source/SVAEObjectsExist.h</option>
<option value="listing33.html">/Source/SVAEPaste.c</option>
<option value="listing34.html">/Source/SVAEPaste.h</option>
<option value="listing35.html">/Source/SVAERecording.c</option>
<option value="listing36.html">/Source/SVAERecording.h</option>
<option value="listing37.html">/Source/SVAERevert.c</option>
<option value="listing38.html">/Source/SVAERevert.h</option>
<option value="listing39.html">/Source/SVAESave.c</option>
<option value="listing40.html">/Source/SVAESave.h</option>
<option value="listing41.html">/Source/SVAESelect.c</option>
<option value="listing42.html">/Source/SVAESelect.h</option>
<option value="listing43.html">/Source/SVAESetData.c</option>
<option value="listing44.html">/Source/SVAESetData.h</option>
<option value="listing45.html">/Source/SVAETextUtils.c</option>
<option value="listing46.html">/Source/SVAETextUtils.h</option>
<option value="listing47.html">/Source/SVAEWindowUtils.c</option>
<option value="listing48.html">/Source/SVAEWindowUtils.h</option>
<option value="listing49.html">/Source/SVAppleEvents.c</option>
<option value="listing50.html">/Source/SVAppleEvents.h</option>
<option value="listing51.html">/Source/SVDrag.c</option>
<option value="listing52.html">/Source/SVDrag.h</option>
<option value="listing53.html">/Source/SVEditAEUtils.c</option>
<option value="listing54.html">/Source/SVEditAEUtils.h</option>
<option value="listing55.html">/Source/SVEditFile.c</option>
<option value="listing56.html">/Source/SVEditFile.h</option>
<option value="listing57.html">/Source/SVEditGlobals.c</option>
<option value="listing58.html">/Source/SVEditGlobals.h</option>
<option value="listing59.html">/Source/SVEditMain.c</option>
<option value="listing60.html">/Source/SVEditMain.h</option>
<option value="listing61.html">/Source/SVEditPrinting.c</option>
<option value="listing62.html">/Source/SVEditPrinting.h</option>
<option value="listing63.html">/Source/SVEditUtils.c</option>
<option value="listing64.html">/Source/SVEditUtils.h</option>
<option value="listing65.html">/Source/SVEditWindow.c</option>
<option value="listing66.html">/Source/SVEditWindow.h</option>
<option value="listing67.html">/Source/SVToken.h</option></select>
				</p>
				</form>
				<p><strong><a href="7Edit.zip">Download Sample</a></strong> (&#147;7Edit.zip&#148;, 205.9K)<BR>
<strong><a href="7Edit.dmg">Download Sample</a></strong> (&#147;7Edit.dmg&#148;, 251.7K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*  File:    SVAERecording.c  Contains:    Written by: Original version by Jon Lansdell and Nigel Humphreys.        3.1 updates by Greg Sutton.  Copyright:  Copyright &copy; 1995-1999 by Apple Computer, Inc., All Rights Reserved.        You may incorporate this Apple sample source code into your program(s) without        restriction. This Apple sample source code has been provided &quot;AS IS&quot; and the        responsibility for its operation is yours. You are not permitted to redistribute        this Apple sample source code as &quot;Apple sample source code&quot; after having made        changes. If you're going to re-distribute the source, we require that you make        it clear in the source that the code was descended from Apple sample source        code, but that you've made changes.  Change History (most recent first):        7/20/1999  Karl Groethe  Updated for Metrowerks Codewarror Pro 2.1        */#include &quot;SVAERecording.h&quot;#include &quot;SVEditAEUtils.h&quot;#include &quot;SVEditUtils.h&quot;#include &quot;SVAEWindowUtils.h&quot;#include &quot;SVAETextUtils.h&quot;#include &quot;SVAppleEvents.h&quot;#include &lt;AEPackObject.h&gt;#include &lt;TextUtils.h&gt;static short   gBigBrother;static char    *gTypingBuffer;static short   gCharsInBuffer;static AEDesc  gTypingTargetObject;OSErr  InstallRecordingHandlers(void){  OSErr  err;    gBigBrother = 0;  gCharsInBuffer = 0;  gTypingBuffer = (char *)NewPtr(32000);  gTypingTargetObject.dataHandle = 0;    err = AEInstallEventHandler( kCoreEventClass, kAENotifyStartRecording, NewAEEventHandlerProc(HandleStartRecording), noRefCon, false);  err = AEInstallEventHandler( kCoreEventClass, kAENotifyStopRecording, NewAEEventHandlerProc(HandleStopRecording), noRefCon, false);  return(err);}pascal OSErr HandleStartRecording(const AppleEvent *theAppleEvent,                                AppleEvent *reply,                                long       handlerRefCon)    {#pragma unused (reply,handlerRefCon)  OSErr myErr;  gBigBrother++;  myErr = GotRequiredParams(theAppleEvent);  return(myErr);  } // HandleStartRecordingpascal OSErr HandleStopRecording(const AppleEvent *theAppleEvent,                               AppleEvent *reply,                               long handlerRefCon)    {#pragma unused (theAppleEvent,reply,handlerRefCon)  gBigBrother--;  return(noErr);} // HandleStopRecording// Make an object specifier for a window given the WindowPtrOSErr  MakeWindowObj(WindowPtr theWindow, AEDesc *result){  AEDesc  nullDesc = {typeNull, NULL},      absoluteDesc = {typeNull, NULL};  long  windowIndex;  OSErr  err;    windowIndex = GetNthWindowOfWindowPtr(theWindow);  if (! windowIndex)    return(errAENoSuchObject);    err = AECreateDesc(typeInteger,(Ptr)&amp;windowIndex, sizeof(windowIndex), &amp;absoluteDesc);  if (noErr != err) goto done;    err = CreateObjSpecifier(cWindow, &amp;nullDesc, formAbsolutePosition,                        &amp;absoluteDesc, false, result);done:  if (absoluteDesc.dataHandle)    AEDisposeDesc(&amp;absoluteDesc);    return(err);} // MakeWindowObj// Make an object specifier for a document given the WindowPtrOSErr  MakeDocumentObj(WindowPtr theWindow, AEDesc *result){  AEDesc  nullDesc = {typeNull, NULL},      absoluteDesc = {typeNull, NULL};  long  windowIndex;  OSErr  err;    windowIndex = GetNthWindowOfWindowPtr(theWindow);  if (! windowIndex)    return(errAENoSuchObject);    err = AECreateDesc(typeInteger,(Ptr)&amp;windowIndex, sizeof(windowIndex), &amp;absoluteDesc);  if (noErr != err) goto done;    err = CreateObjSpecifier(cDocument, &amp;nullDesc, formAbsolutePosition,                        &amp;absoluteDesc, false, result);done:  if (absoluteDesc.dataHandle)    AEDisposeDesc(&amp;absoluteDesc);    return(err);} // MakeDocumentObjOSErr  MakeTextObjFromToken(TextToken* theToken, AEDesc* result){  OSErr  err;  err = GetTextTokenObjectSpecifier(theToken, result);    return(err);}OSErr  MakeSelectedTextObj(WindowPtr theWindow, TEHandle theTextEditHandle, AEDesc* result){  return( MakeTextObj(theWindow, (**theTextEditHandle).selStart,              (**theTextEditHandle).selEnd, result));} // MakeSelectedTextObjOSErr  MakeTextObj(WindowPtr theWindow, short selStart, short selEnd, AEDesc* result){  TextToken  aToken;  OSErr    err;    aToken.tokenWindow = theWindow;  aToken.tokenOffset = selStart + 1;  aToken.tokenLength = selEnd - selStart;  err = MakeTextObjFromToken(&amp;aToken, result);  return(err);}OSErr  SendSelectionEvent(DPtr docPtr){  AEAddressDesc  ourAddress = {typeNull, NULL};  AppleEvent    selectEvent = {typeNull, NULL},          ignoreReply = {typeNull, NULL};  AEDesc      textObj = {typeNull, NULL};  OSErr      err;  err = MakeSelfAddress(&amp;ourAddress);  if (noErr != err) goto done;      // Build an object to represent the current document's selection    // MakeSelectedTextObj  err = MakeSelectedTextObj(docPtr-&gt;theWindow, docPtr-&gt;theText, &amp;textObj);  if (noErr != err) goto done;    err = AECreateAppleEvent(kAEMiscStandards, kAESelect, &amp;ourAddress, 0, 0, &amp;selectEvent);    if (noErr != err) goto done;      // add parameter  err = AEPutParamDesc(&amp;selectEvent, keyDirectObject, &amp;textObj);  if (noErr != err) goto done;              // and now send the message  err = AESend(&amp;selectEvent, &amp;ignoreReply, kAENoReply, kAEHighPriority, kAEDefaultTimeout, NULL, NULL);  if (noErr != err) goto done;done:    if (ourAddress.dataHandle)     AEDisposeDesc(&amp;ourAddress);  if (selectEvent.dataHandle)     AEDisposeDesc(&amp;selectEvent);  if (ignoreReply.dataHandle)     AEDisposeDesc(&amp;ignoreReply);  if (textObj.dataHandle)     AEDisposeDesc(&amp;textObj);  return(err);}void  DoEditCommand(DPtr theDocument, editCommandType whatCommand){  AEAddressDesc  ourAddress = {typeNull, NULL};  AppleEvent    editCommandEvent = {typeNull, NULL},          ignoreReply = {typeNull, NULL};  AEEventID    theEventID;  AEEventClass  theEventClass;  OSErr      err;    err = SendSelectionEvent(theDocument);  if (noErr != err) goto done;    // Now create and send the appropriate cut, copy, paste or clear AppleEvent    switch (whatCommand)  {    case  editCutCommand:      theEventID = kAECut;      theEventClass = kAEMiscStandards;      break;          case  editCopyCommand:      theEventID = kAECopy;      theEventClass = kAEMiscStandards;      break;    case  editPasteCommand:      theEventID = kAEPaste;      theEventClass = kAEMiscStandards;      break;    case  editClearCommand:      theEventID = kAEDelete;      theEventClass = kAECoreSuite;      break;  }    err = MakeSelfAddress(&amp;ourAddress);  if (noErr != err) goto done;        err = AECreateAppleEvent(theEventClass, theEventID, &amp;ourAddress, 0, 0, &amp;editCommandEvent);    if (noErr != err) goto done;          // and now Send the message  err = AESend(&amp;editCommandEvent, &amp;ignoreReply, kAENoReply, kAEHighPriority, kAEDefaultTimeout, NULL, NULL);    done:  if (ourAddress.dataHandle)     AEDisposeDesc(&amp;ourAddress);  if (editCommandEvent.dataHandle)     AEDisposeDesc(&amp;editCommandEvent);  if (ignoreReply.dataHandle)     AEDisposeDesc(&amp;ignoreReply);} // DoEditCommandvoid  IssueCutCommand(DPtr theDocument){        DoEditCommand(theDocument, editCutCommand);} void  IssueCopyCommand(DPtr theDocument){  DoEditCommand(theDocument, editCopyCommand);}void  IssuePasteCommand(DPtr theDocument){  DoEditCommand(theDocument, editPasteCommand);  }void  IssueClearCommand(DPtr theDocument){  DoEditCommand(theDocument, editClearCommand);  }// ---------------------------------------------------------------------//  Name :     SendAESetObjProp//  Function :  Creates a property object from an object,//        a property type and its data and sends it to//        the requested address, and cleans up zapping params too// ---------------------------------------------------------------------OSErr  SendAESetObjProp(AEDesc *theObj, DescType theProp, AEDesc *theData, AEAddressDesc *toWhom){  AEDesc    propObjSpec;  AppleEvent  myAppleEvent;  AppleEvent  defReply;  OSErr    myErr;  OSErr    ignoreErr;  AEDesc    theProperty;      // create an object spec that represents the property of the given object    myErr = AECreateDesc(typeType, (Ptr)&amp;theProp, sizeof(theProp), &amp;theProperty);  if (myErr==noErr)    myErr = CreateObjSpecifier(cProperty, theObj, formPropertyID,                    &amp;theProperty, true, &amp;propObjSpec);        // create event    if (myErr==noErr)    myErr = AECreateAppleEvent(kAECoreSuite, kAESetData, toWhom, 0, 0, &amp;myAppleEvent);      // add prop obj spec to the event    if (myErr==noErr)    myErr = AEPutParamDesc(&amp;myAppleEvent, keyDirectObject, &amp;propObjSpec);    // add prop data to the event    if (myErr==noErr)    myErr = AEPutParamDesc(&amp;myAppleEvent,keyAEData, theData);    // send event    if (myErr==noErr)    myErr = AESend(&amp;myAppleEvent, &amp;defReply, kAENoReply+kAEAlwaysInteract,                  kAENormalPriority, kAEDefaultTimeout, nil, nil);    if (myAppleEvent.dataHandle)    ignoreErr = AEDisposeDesc(&amp;myAppleEvent);      if (&amp;propObjSpec.dataHandle)    ignoreErr = AEDisposeDesc(&amp;propObjSpec);    if (theData-&gt;dataHandle)    ignoreErr = AEDisposeDesc(theData);    if (toWhom-&gt;dataHandle)    ignoreErr = AEDisposeDesc(toWhom);    return(myErr);} // SendAESetObjPropvoid  IssueFontCommand(DPtr theDocument, short theItem){  Str255      name;  AEDesc      strDesc;  AEAddressDesc  theAddress;  AEDesc      selTextObj;  OSErr      err;      err = MakeSelfAddress(&amp;theAddress);    err = MakeSelectedTextObj(theDocument-&gt;theWindow, theDocument-&gt;theText, &amp;selTextObj);    GetMenuItemText(myMenus[fontM], theItem, name);    if (err==noErr)    err  = AECreateDesc(typeChar, (Ptr)&amp;name[1], name[0], &amp;strDesc);    if (err==noErr)    err  = SendAESetObjProp(&amp;selTextObj, pFont, &amp;strDesc, &amp;theAddress);                              }// Window property routinesvoid  IssueZoomCommand(WindowPtr whichWindow, short whichPart){  Boolean       zoomBool;  AEDesc        zoomDesc;  AEAddressDesc selfAddr;  AEDesc        frontWinObj;  OSErr         err;  err = MakeSelfAddress(&amp;selfAddr);    err = MakeWindowObj(whichWindow, &amp;frontWinObj);    zoomBool = (whichPart==inZoomOut);  err = AECreateDesc(typeBoolean, (Ptr)&amp;zoomBool, sizeof(zoomBool), &amp;zoomDesc);                        err = SendAESetObjProp(&amp;frontWinObj, pIsZoomed, &amp;zoomDesc, &amp;selfAddr);                              } // IssueZoomCommandvoid  IssueCloseCommand(WindowPtr whichWindow){  AEAddressDesc  selfAddr;  AEDesc         frontWinObj;  OSErr          err;  OSErr          ignoreErr;  AppleEvent     closeCommandEvent;  AppleEvent     ignoreReply;  frontWinObj.dataHandle = nil;    err = MakeSelfAddress(&amp;selfAddr);    err = MakeWindowObj(whichWindow, &amp;frontWinObj);                              err = AECreateAppleEvent( kAECoreSuite, kAEClose, &amp;selfAddr, 0, 0, &amp;closeCommandEvent) ;            // add parameter - the window to close    if (err==noErr)     err = AEPutParamDesc(&amp;closeCommandEvent, keyDirectObject, &amp;frontWinObj);      if (err==noErr)     err = AESend(&amp;closeCommandEvent,&amp;ignoreReply,kAENoReply+kAEAlwaysInteract,kAEHighPriority,10000,nil, nil);    if (closeCommandEvent.dataHandle)     ignoreErr = AEDisposeDesc(&amp;closeCommandEvent);    if (selfAddr.dataHandle)     ignoreErr = AEDisposeDesc(&amp;selfAddr);      if (frontWinObj.dataHandle)     ignoreErr = AEDisposeDesc(&amp;frontWinObj);    } // IssueCloseCommandvoid  IssueSizeWindow(WindowPtr whichWindow, short newHSize, short newVSize){  Rect          sizeRect;  Rect          contentRect;  short         edgeSize;  AEDesc        sizeDesc;  AEAddressDesc selfAddr;  AEDesc        frontWinObj;  OSErr         err;  sizeRect    = (**(((WindowPeek)whichWindow)-&gt;strucRgn)).rgnBBox;  contentRect = (**(((WindowPeek)whichWindow)-&gt;contRgn)).rgnBBox;    edgeSize = sizeRect.right-sizeRect.left-(contentRect.right-contentRect.left);  sizeRect.right = sizeRect.left+newHSize+edgeSize;    edgeSize = sizeRect.bottom-sizeRect.top-(contentRect.bottom-contentRect.top);  sizeRect.bottom = sizeRect.top+newVSize+edgeSize;    err = MakeSelfAddress(&amp;selfAddr);    err = MakeWindowObj(whichWindow, &amp;frontWinObj);    if (err==noErr)    err = AECreateDesc(typeQDRectangle, (Ptr)&amp;sizeRect, sizeof(sizeRect), &amp;sizeDesc);    if (err==noErr)    err  = SendAESetObjProp(&amp;frontWinObj, pBounds, &amp;sizeDesc, &amp;selfAddr);                              } // IssueSizeWindowvoid  IssueMoveWindow(WindowPtr whichWindow, Rect sizeRect){  AEDesc        sizeDesc;  AEAddressDesc selfAddr;  AEDesc        frontWinObj;  OSErr         err;  err = MakeSelfAddress(&amp;selfAddr);    err = MakeWindowObj(whichWindow, &amp;frontWinObj);      if (err==noErr)    err = AECreateDesc(typeQDRectangle, (Ptr)&amp;sizeRect, sizeof(sizeRect), &amp;sizeDesc);    if (err==noErr)        err = SendAESetObjProp(&amp;frontWinObj, pBounds, &amp;sizeDesc, &amp;selfAddr);                              } // IssueMoveWindowvoid  IssuePageSetupWindow(WindowPtr whichWindow, TPrint thePageSetup){  AEDesc        sizeDesc;  AEAddressDesc selfAddr;  AEDesc        frontWinObj;  OSErr         err;  err = MakeSelfAddress(&amp;selfAddr);    err = MakeWindowObj(whichWindow, &amp;frontWinObj);    if (err==noErr)    err = AECreateDesc(typeTPrint, (Ptr)&amp;thePageSetup, sizeof(thePageSetup), &amp;sizeDesc);                         if (err==noErr)    err = SendAESetObjProp(&amp;frontWinObj, pPageSetup, &amp;sizeDesc, &amp;selfAddr);                                                       } //IssuePageSetupWindowvoid IssuePrintWindow(WindowPtr whichWindow, Boolean useDialog){  AEAddressDesc selfAddr;  AEDesc        frontWinObj;  OSErr         err;  OSErr         ignoreErr;  AppleEvent    printCommandEvent;  AppleEvent    ignoreReply;  AESendMode    sendModeFlags;  err = MakeSelfAddress(&amp;selfAddr);    err = MakeWindowObj(whichWindow, &amp;frontWinObj);                              err = AECreateAppleEvent(kCoreEventClass, kAEPrintDocuments, &amp;selfAddr, 0, 0, &amp;printCommandEvent) ;          //  add parameter - the window to print  if (err==noErr)     err = AEPutParamDesc(&amp;printCommandEvent, keyDirectObject, &amp;frontWinObj);      if (err==noErr)  {    sendModeFlags = kAENoReply;    if (useDialog)      sendModeFlags = sendModeFlags + kAEAlwaysInteract;    else      sendModeFlags = sendModeFlags + kAENeverInteract;    err = AESend(&amp;printCommandEvent,&amp;ignoreReply,sendModeFlags,kAEHighPriority,10000,nil, nil);  }    if (printCommandEvent.dataHandle)    ignoreErr = AEDisposeDesc(&amp;printCommandEvent);    if (frontWinObj.dataHandle)     err = AEDisposeDesc(&amp;frontWinObj);      if (selfAddr.dataHandle)     err = AEDisposeDesc(&amp;selfAddr);    } // IssuePrintWindowOSErr  IssueAEOpenDoc(FSSpec myFSSpec)// send OpenDocs AppleEvent to myself, with a one-element list// containing the given file spec//// NOTES : the core AEOpenDocs event is defined as taking a list of//    aliases (not file specs) as its direct parameter.  However,//    we can send the file spec instead and depend on AppleEvents'//    automatic coercion.  In fact, we don't really even have to put //    in a list; AppleEvents will coerce a descriptor into a 1-element//    list if called for.  In this routine, though, we'll make the//    list for demonstration purposes.{  AppleEvent    myAppleEvent;  AppleEvent    defReply;  AEDescList    docList;  AEAddressDesc selfAddr;  OSErr         myErr;  OSErr         ignoreErr;    myAppleEvent.dataHandle = nil;  docList.dataHandle  = nil;  selfAddr.dataHandle = nil;  defReply.dataHandle = nil;      //  Create empty list and add one file spec  myErr = AECreateList(nil,0,false, &amp;docList);    if (myErr==noErr)     myErr = AEPutPtr(&amp;docList,1,typeFSS,(Ptr)&amp;myFSSpec,sizeof(myFSSpec));      //  Create a self address to send it to  if (myErr==noErr)     myErr = MakeSelfAddress(&amp;selfAddr);      if (myErr==noErr)     myErr = AECreateAppleEvent(kCoreEventClass, kAEOpenDocuments, &amp;selfAddr,                kAutoGenerateReturnID,  kAnyTransactionID, &amp;myAppleEvent);  //  Put Params into our event and send it  if (myErr == noErr)     myErr = AEPutParamDesc(&amp;myAppleEvent, keyDirectObject, &amp;docList);  myErr = AESend(&amp;myAppleEvent, &amp;defReply, kAENoReply+kAEAlwaysInteract, kAENormalPriority,                                   kAEDefaultTimeout, nil, nil);      if (selfAddr.dataHandle)     ignoreErr = AEDisposeDesc(&amp;selfAddr);      if (myAppleEvent.dataHandle)     ignoreErr = AEDisposeDesc(&amp;myAppleEvent);      if (docList.dataHandle)     ignoreErr = AEDisposeDesc(&amp;docList);      return(myErr);  } // IssueAEOpenDocvoid  IssueAENewWindow(void)// send the New Element event to myself with a null container{  AppleEvent    myAppleEvent;  AppleEvent    defReply;  AEAddressDesc selfAddr;  OSErr         myErr;  OSErr         ignoreErr;  DescType      elemClass;    myAppleEvent.dataHandle = nil;    //  Create the address of us    myErr = MakeSelfAddress(&amp;selfAddr);    //  create event     myErr = AECreateAppleEvent(kAECoreSuite, kAECreateElement, &amp;selfAddr,                  kAutoGenerateReturnID, kAnyTransactionID, &amp;myAppleEvent);    //  attach desired class of new element    elemClass = cWindow;    if (myErr == noErr)     myErr = AEPutParamPtr(&amp;myAppleEvent, keyAEObjectClass, typeType,                    (Ptr)&amp;elemClass, sizeof(elemClass));      //  send the event     if (myErr == noErr)     myErr = AESend(&amp;myAppleEvent, &amp;defReply, kAENoReply+kAENeverInteract,              kAENormalPriority, kAEDefaultTimeout, nil, nil);  //  Clean up - reply never created so don't throw away  if (selfAddr.dataHandle)     ignoreErr = AEDisposeDesc(&amp;selfAddr);      if (myAppleEvent.dataHandle)     ignoreErr = AEDisposeDesc(&amp;myAppleEvent);        } // IssueAENewWindowOSErr  IssueSaveCommand(WindowPtr theWindow, FSSpecPtr where)// send an AppleEvent Save Event to myself{  AEDesc        windowObj;  AppleEvent    myAppleEvent;  AppleEvent    defReply;  OSErr         myErr;  OSErr         ignoreErr;  AEAddressDesc selfAddr;      windowObj.dataHandle = nil;  myAppleEvent.dataHandle = nil;    myErr = MakeWindowObj(theWindow, &amp;windowObj);          if (myErr==noErr)     myErr = MakeSelfAddress(&amp;selfAddr);      //  Build event  if (myErr == noErr)     myErr = AECreateAppleEvent(kAECoreSuite, kAESave, &amp;selfAddr,              kAutoGenerateReturnID, kAnyTransactionID, &amp;myAppleEvent);      //  say which window  if (myErr==noErr)     myErr = AEPutParamDesc(&amp;myAppleEvent, keyDirectObject, &amp;windowObj);    //  add optional file param if we need to  if (where)     if (myErr==noErr)       myErr = AEPutParamPtr(&amp;myAppleEvent, keyAEDestination, typeFSS,                          (Ptr)where, sizeof(FSSpec));      // send the event  if (myErr==noErr)     myErr  = AESend(&amp;myAppleEvent, &amp;defReply, kAENoReply+kAENeverInteract,                  kAENormalPriority, kAEDefaultTimeout, nil, nil);      if (selfAddr.dataHandle)     ignoreErr = AEDisposeDesc(&amp;selfAddr);      if (windowObj.dataHandle)     ignoreErr = AEDisposeDesc(&amp;windowObj);      if (myAppleEvent.dataHandle)     myErr = AEDisposeDesc(&amp;myAppleEvent);      return(myErr);}  // IssueSaveCommandOSErr  IssueRevertCommand(WindowPtr theWindow)  // send an AppleEvent Revert Event to myself{  AEDesc        windowObj;  AppleEvent    myAppleEvent;  AppleEvent    defReply;  OSErr         myErr;  OSErr         ignoreErr;  AEAddressDesc selfAddr;    windowObj.dataHandle = nil;  myAppleEvent.dataHandle = nil;    myErr = MakeWindowObj(theWindow, &amp;windowObj);          if (myErr==noErr)     myErr = MakeSelfAddress(&amp;selfAddr);      // Build event    if (myErr == noErr)     myErr  = AECreateAppleEvent(kAEMiscStandards, kAERevert, &amp;selfAddr,                  kAutoGenerateReturnID, kAnyTransactionID, &amp;myAppleEvent);  // say which window    if (myErr == noErr)     myErr = AEPutParamDesc(&amp;myAppleEvent, keyDirectObject, &amp;windowObj);  //  send the event  if (myErr==noErr)     myErr  = AESend(&amp;myAppleEvent, &amp;defReply, kAENoReply+kAENeverInteract,                kAENormalPriority, kAEDefaultTimeout, nil, nil);      if (windowObj.dataHandle)     ignoreErr = AEDisposeDesc(&amp;windowObj);      if (myAppleEvent.dataHandle)     ignoreErr = AEDisposeDesc(&amp;myAppleEvent);      if (selfAddr.dataHandle)     ignoreErr = AEDisposeDesc(&amp;selfAddr);      return(myErr);} // IssueRevertCommand// ----------------------------------------------------//  Name :     IssueQuitCommand//  Purpose :  Sends self a Quit AppleEvent// ----------------------------------------------------OSErr  IssueQuitCommand(void){  AppleEvent    myAppleEvent;  AppleEvent    defReply;  OSErr         myErr;  OSErr         ignoreErr;  AEAddressDesc selfAddr;  DescType      mySaveOpt;    myAppleEvent.dataHandle = nil;  selfAddr.dataHandle     = nil;              myErr = MakeSelfAddress(&amp;selfAddr);      //  Build event    if (myErr == noErr)     myErr  = AECreateAppleEvent(kCoreEventClass, kAEQuitApplication, &amp;selfAddr,                    kAutoGenerateReturnID, kAnyTransactionID, &amp;myAppleEvent);  //  say which save option    mySaveOpt = kAEAsk;    if (myErr == noErr)     myErr = AEPutParamPtr(&amp;myAppleEvent, keyAESaveOptions, typeEnumerated,                        (Ptr)&amp;mySaveOpt, sizeof(mySaveOpt));  //  send the event  if (myErr==noErr)     myErr  = AESend(&amp;myAppleEvent, &amp;defReply, kAENoReply+kAEAlwaysInteract,                  kAENormalPriority, kAEDefaultTimeout, nil, nil);            if (myAppleEvent.dataHandle)     ignoreErr = AEDisposeDesc(&amp;myAppleEvent);      if (selfAddr.dataHandle)     ignoreErr = AEDisposeDesc(&amp;selfAddr);      return(myErr);} // IssueQuitCommand#define kOK 1#define kCancel 2#define kOtherSize 4#define kOutlineItem 5Boolean  PoseSizeDialog(long *whatSize){  GrafPtr   savedPort;  DialogPtr aDialog;  Str255    aString;  short     itemHit;  GetPort(&amp;savedPort);  aDialog = GetNewDialog(1004, nil, (WindowPtr)-1);  ShowWindow(aDialog);  SetPort(aDialog);    AdornDefaultButton(aDialog, kOutlineItem);       //set the edittext button to contain the right size  NumToString(*whatSize, aString);  SetText(aDialog, kOtherSize, aString);   do  {    ModalDialog(nil, &amp;itemHit);  } while ((itemHit!=kOK) &amp;&amp; (itemHit!=kCancel));    if (itemHit == kOK)     RetrieveText(aDialog, kOtherSize, aString);  DisposeDialog(aDialog);  SetPort(savedPort);    if (itemHit == kOK)   {    // set the new size of the text    StringToNum(aString, whatSize);    if ((*whatSize&lt;1) || (*whatSize&gt;2000))       *whatSize = 12;  }  return(itemHit == kOK);}void  IssueSizeCommand(DPtr theDocument,short theItem){  Str255        name;  AEDesc        sizeDesc;  AEAddressDesc theAddress;  OSErr         err;  AEDesc        selTextObj;      // Vars to do with menu processing  short     lastSize;  short     upItem;  short     downItem;  short     otherItem;  long      theSize;  TextStyle theStyle;  short     lineHeight;  short     fontAscent;      err = MakeSelfAddress(&amp;theAddress);    err = MakeSelectedTextObj(theDocument-&gt;theWindow, theDocument-&gt;theText, &amp;selTextObj);        // check if the item is on the Size menu    // remembering that we can add and delete items from it  lastSize  = CountMItems(myMenus[sizeM]) - 5;  upItem    = lastSize + 2;  downItem  = upItem + 1;  otherItem = downItem + 2;    TEGetStyle((**(theDocument-&gt;theText)).selStart, &amp;theStyle, &amp;lineHeight,                      &amp;fontAscent, theDocument-&gt;theText);    GetMenuItemText(myMenus[sizeM], theItem, name);   if (theItem &lt;= lastSize)  {    GetMenuItemText(myMenus[sizeM], theItem, name);    StringToNum(name, &amp;theSize);  }  else if (theItem == upItem)      theSize = theStyle.tsSize + 1;  else if (theItem == downItem)    theSize = theStyle.tsSize - 1;  else if (theItem == otherItem)   {    theSize = theStyle.tsSize;    if (!PoseSizeDialog(&amp;theSize))      return;  }  if (err==noErr)    err = CreateOffsetDescriptor(theSize, &amp;sizeDesc);    if (err==noErr)    err = SendAESetObjProp(&amp;selTextObj, pPointSize, &amp;sizeDesc, &amp;theAddress);} // IssueSizeCommandvoid  IssueStyleCommand(DPtr theDocument, short theItem){  Style         theFace;  OSErr         err;  AEDesc        result;  AEAddressDesc selfAddr;  AEDesc        selTextObj;  TextStyle     theStyle;  short         lineHeight;  short         fontAscent;      TEGetStyle((**(theDocument-&gt;theText)).selStart, &amp;theStyle,                &amp;lineHeight, &amp;fontAscent, theDocument-&gt;theText);    theFace = 0;  switch (theItem)  {    case cPlain:      theFace = 0;        break;    case cBold:      theFace = bold;        break;    case cItalic:      theFace = italic;        break;    case cUnderline:      theFace = underline;        break;    case cOutline:      theFace = outline;        break;    case cShadow:      theFace = shadow;        break;    case cCondense:      theFace = condense;        break;    case cExtend:      theFace = extend;        break;  } // of switch  if (theFace==0)    err = BuildTypeTextStylesDesc(0, bold+italic+underline+outline+shadow+condense+extend, &amp;result);  else if (theFace &amp; theStyle.tsFace)    err = BuildTypeTextStylesDesc(0, theFace, &amp;result);  else    err = BuildTypeTextStylesDesc(theFace, 0, &amp;result);    err = MakeSelfAddress(&amp;selfAddr);    if (err==noErr)    err = MakeSelectedTextObj(theDocument-&gt;theWindow, theDocument-&gt;theText, &amp;selTextObj);    if (err==noErr)    err = SendAESetObjProp(&amp;selTextObj, pTextStyles, &amp;result, &amp;selfAddr);} // IssueStyleCommandOSErr  IssueSetDataObjToBufferContents(const AEDesc* theObj){   OSErr      myErr;  OSErr      ignoreErr;  AEAddressDesc  theAddress;  AppleEvent    myAppleEvent;  AppleEvent    defReply;  myErr = MakeSelfAddress(&amp;theAddress);    // create event    if (myErr==noErr)    myErr = AECreateAppleEvent(kAECoreSuite, kAESetData, &amp;theAddress,                            0, 0, &amp;myAppleEvent);      // add prop obj spec to the event    if (myErr==noErr)    myErr = AEPutParamDesc(&amp;myAppleEvent, keyDirectObject, theObj);    // add prop data to the event    if (myErr==noErr)    myErr = AEPutParamPtr(&amp;myAppleEvent, keyAEData, typeChar,                  (Ptr)gTypingBuffer, gCharsInBuffer);                            // send event    if (myErr==noErr)   if (gRecordingImplemented)     myErr = AESend(&amp;myAppleEvent, &amp;defReply, kAENoReply+kAEDontExecute,                   kAENormalPriority, kAEDefaultTimeout, nil, nil);  if (theAddress.dataHandle)    ignoreErr = AEDisposeDesc(&amp;theAddress);      if (myAppleEvent.dataHandle)    ignoreErr = AEDisposeDesc(&amp;myAppleEvent);      return(myErr);}void  AddKeyToTypingBuffer(DPtr theDocument, char theKey){  OSErr myErr;  OSErr ignoreErr;    if (theKey==BS || theKey==FS || theKey==GS || theKey==RS || theKey==US)  {    FlushAndRecordTypingBuffer();    if (theKey==BS)    {      if ((**theDocument-&gt;theText).selStart!=(**theDocument-&gt;theText).selEnd)      {        myErr = MakeTextObj(theDocument-&gt;theWindow,                  (**theDocument-&gt;theText).selStart,                  (**theDocument-&gt;theText).selEnd,                  &amp;gTypingTargetObject);      }      else      {        myErr = MakeTextObj(theDocument-&gt;theWindow,                  (**theDocument-&gt;theText).selStart-1,                  (**theDocument-&gt;theText).selStart,                  &amp;gTypingTargetObject);      }                myErr = IssueSetDataObjToBufferContents(&amp;gTypingTargetObject);            ignoreErr = AEDisposeDesc(&amp;gTypingTargetObject);            gTypingTargetObject.dataHandle = nil;    }  }  else  {    if (gCharsInBuffer==0)      myErr = MakeSelectedTextObj(theDocument-&gt;theWindow, theDocument-&gt;theText,                                  &amp;gTypingTargetObject);    gTypingBuffer[gCharsInBuffer++] = theKey;  }}void  FlushAndRecordTypingBuffer(void){   OSErr  myErr;  OSErr  ignoreErr;  if (gCharsInBuffer != 0)  {    myErr = IssueSetDataObjToBufferContents(&amp;gTypingTargetObject);        if (gTypingTargetObject.dataHandle)      ignoreErr = AEDisposeDesc(&amp;gTypingTargetObject);  }      gCharsInBuffer = 0;  gTypingTargetObject.dataHandle = 0;}  void  StyleTokConst(short theStyleItem, DescType *thekConst){  switch (theStyleItem)  {    case bold:      *thekConst = kAEBold;      break;          case italic:      *thekConst = kAEItalic;      break;          case underline:      *thekConst = kAEUnderline;      break;          case outline:      *thekConst = kAEOutline;      break;          case shadow:      *thekConst = kAEShadow;      break;          case condense:      *thekConst = kAECondensed;      break;          case extend:      *thekConst = kAEExpanded;      break;  }} // StyleTokConstOSErr  BuildTypeTextStylesDesc(Style onStyles, Style offStyles, AEDesc *resultDesc){  OSErr     myErr;  OSErr     ignoreErr;  short     myStyleItem;  DescType  styleConst;  AEDesc    onStylesDesc;  AEDesc    offStylesDesc;  AEDesc    dataDesc;    onStylesDesc.dataHandle  = nil;  offStylesDesc.dataHandle = nil;  dataDesc.dataHandle  = nil;  myErr = AECreateList(nil, 0, true,  &amp;dataDesc);    myErr = AECreateList(nil, 0, false, &amp;onStylesDesc);  myErr = AECreateList(nil, 0, false, &amp;offStylesDesc);    for (myStyleItem = bold; myStyleItem&lt;=extend; myStyleItem = myStyleItem &lt;&lt;1)    if (myErr==noErr)    {      StyleTokConst(myStyleItem, &amp;styleConst);      if (myStyleItem &amp; onStyles)        myErr = AEPutPtr(&amp;onStylesDesc,                  0,        // add to end of list                  typeEnumerated, // text for style name                  (Ptr)&amp;styleConst,                  sizeof(styleConst));            if (myStyleItem &amp; offStyles)        myErr = AEPutPtr(&amp;offStylesDesc,                  0,        // add to end of list                  typeEnumerated, // text for style name                  (Ptr)&amp;styleConst,                  sizeof(styleConst));    }    if (myErr==noErr)    myErr = AEPutKeyDesc(&amp;dataDesc, keyAEOnStyles,  &amp;onStylesDesc);    if (myErr==noErr)    myErr = AEPutKeyDesc(&amp;dataDesc, keyAEOffStyles, &amp;offStylesDesc);    if (myErr==noErr)    myErr = AECoerceDesc(&amp;dataDesc, typeTextStyles, resultDesc);      if (onStylesDesc.dataHandle)    ignoreErr = AEDisposeDesc(&amp;onStylesDesc);      if (offStylesDesc.dataHandle)    ignoreErr = AEDisposeDesc(&amp;offStylesDesc);      if (dataDesc.dataHandle)    ignoreErr = AEDisposeDesc(&amp;dataDesc);  return(myErr);}OSErr  BuildTextStylesDesc(Style theStyle, AEDesc *resultDesc){  short     myStyleItem;  Style     onStyles;  Style     offStyles;        onStyles  = 0;  offStyles = 0;    for (myStyleItem = bold; myStyleItem&lt;=extend; myStyleItem = myStyleItem &lt;&lt;1)  {    if (myStyleItem &amp; theStyle)      onStyles  = onStyles  + myStyleItem;    else      offStyles = offStyles + myStyleItem;  }  return(BuildTypeTextStylesDesc(onStyles, offStyles, resultDesc));  } // BuildTextStylesDesc    OSErr  BuildStyledTextDesc(TEHandle theHTE, short start, short howLong, AEDesc *resultDesc){  AEDesc       listDesc;  short        oldSelStart;  short        oldSelEnd;  StScrpHandle myStScrpHandle;  OSErr        myErr;  OSErr        ignoreErr;    listDesc.dataHandle = nil;    oldSelStart = (**theHTE).selStart;  oldSelEnd   = (**theHTE).selEnd;    TESetSelect(start-1, start+howLong-2, theHTE);    myErr = AECreateList(nil, 0, true,  &amp;listDesc);    HLock((Handle)(**theHTE).hText);                             if (myErr == noErr)    myErr = AEPutKeyPtr(&amp;listDesc, keyAEText, typeChar,              (Ptr)&amp;(*(**theHTE).hText)[start-1], howLong);                          HUnlock((Handle)(**theHTE).hText);    myStScrpHandle = TEGetStyleScrapHandle(theHTE);    if (myStScrpHandle)  {    HLock((Handle)myStScrpHandle);        if (myErr==noErr)      myErr = AEPutKeyPtr(&amp;listDesc, keyAEStyles, typeScrapStyles,                  (Ptr)*myStScrpHandle, GetHandleSize((Handle)myStScrpHandle));          HUnlock((Handle)myStScrpHandle);  }    else    myErr = AEPutKeyPtr(&amp;listDesc, keyAEStyles, typeScrapStyles, (Ptr)nil, 0);    if (myErr==noErr)    myErr = AECoerceDesc(&amp;listDesc, typeStyledText, resultDesc); // should be typeIntlText    if (listDesc.dataHandle)    ignoreErr = AEDisposeDesc(&amp;listDesc);    TESetSelect(oldSelStart, oldSelEnd, theHTE);    return(myErr);}</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/7Edit/listing35.html%3Fid%3DDTS10000200-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/7Edit/listing35.html%3Fid%3DDTS10000200-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/7Edit/listing35.html%3Fid%3DDTS10000200-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>