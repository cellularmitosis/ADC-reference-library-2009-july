<html><head><title></title></head>

<body bgcolor="#ffffff">

 

 

<h2><a name="//apple_ref/occ/cl/EOMasterPeerAssociation">EOMasterPeerAssociation</a>

 <BR>

</h2>

<p><B>Inherits From:</B><BR>  

EOMasterDetailAssociation : EOAssociation : EODelayedObserver : NSObject



<p><B>Conforms To:</B>

NSCoding (EOAssociation)<br>

EOObserving (EODelayedObserver)<br>

NSObject (NSObject)



<p><B>Declared in:</B>

EOInterface/EOMasterDetailAssociation.h



<p><h3>Class At a Glance:</h3>

<p><dl><dt><h4>Purpose</h4>

</dl>An EOMasterPeerAssociation binds one EODisplayGroup (the detail) to a relationship in another (the master), so that the detail EODisplayGroup contains objects corresponding to a relationship of the object selected in the master. The EODisplayGroups' data sources operate independently of each other, meaning insertions and deletions in the detail EODisplayGroup don't affect the corresponding relationship property of the selected object in the master EODisplayGroup.<p>

<dl><dt><h4>Usable With</h4>

</dl>EODisplayGroups whose data sources are <em>not</em> EODetailDataSources<p>

<dl><dt><h4>Aspects</h4>

</dl><dl><dt>parent

<dl><dt>A relationship from the master EODisplayGroup.

</dl></dl><dl><dt><h4>Object Keys Taken</h4>

<dl><dt>None

</dl></dl><p>

<a name="74">

<a name="description"></a>

<h3>Class Description </h3>

</a>An EOMasterPeerAssociation binds two EODisplayGroups together in a master-detail relationship, where the detail EODisplayGroup shows the destination objects for the relationship of the master EODisplayGroup. In this arrangement, the detail EODisplayGroup's data source is an independent EODataSource. Detail objects are fetched independently from the detail's data source, which means that changes to one EODisplayGroup aren't automatically reflected in the other. To update the other EODisplayGroup, it's necessary to save the changes made and then have the other EODisplayGroup fetch its objects anew.<p>

Master-peer setups display these advantages over master-detail setups:<p>

<ul><li>You can use them to display the destination objects for relationships that are defined in the model but not declared as class properties. This is typically done for rarely accessed information-or information that's costly to access. By not defining the relationship as a class property, the destination objects aren't stored as instance variables in the source objects, which saves memory and the cost of constructing faults for the relationship.<p><li>Because the detail EODisplayGroup fetches objects with its own EODataSource, you can configure the detail EODataSource with an auxiliary EOQualifier to limit the objects fetched. This further reduces the cost of fetching data.<p></ul>Generally, though, master-peer setups are only appropriate when no insertions or deletions will be made in the detail EODisplayGroup. For a master-detail relationship that reflects changes between two EODisplayGroups, including insertions and deletions, use an EOMasterDetailAssociation. <p>

<a name="80">

<h3> Example</h3>

</a>Suppose you have a master EODisplayGroup that presents Movie objects and a detail EODisplayGroup that presents Talent objects. An EOMasterPeerAssociation between the two, bound to the "directors" key, causes the Talent EODisplayGroup to contain the directors for the first Movie object selected in the Movie EODisplayGroup. Inserting a new director into the detail EODisplayGroup, however, doesn't change the relationship property of the selected Movie object.<p>



 

 





<i>Copyright &#169; 1997, Apple Computer, Inc.   All rights

reserved.</i>



<!-- Last updated: 10/14/97 19:24:16 -->



</body>

</html>

