<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>Thread Manager Reference</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Thread Manager Reference"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP30000084-DontLinkChapterID_1" title="Thread Manager Reference"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../../reference/index.html#//apple_ref/doc/uid/TP30001281" target="_top">Reference</a> &gt; <a href="../../../../../reference/Carbon/index.html#//apple_ref/doc/uid/TP30001281-TP30000420" target="_top">Carbon</a> &gt; <a href="../../../../../reference/Carbon/idxProcessManagement-date.html#//apple_ref/doc/uid/TP30001281-TP30000420-TP30000456" target="_top">Process Management</a> &gt; <a href="../index.html" target="_top">Thread Manager Reference</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <!-- Previous button --><span style="margin-left: 8px"><a href="../DeprecationAppendix/AppendixADeprecatedAPI.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP30000084-DontLinkChapterID_1-DontLinkElementID_3" title="Thread Manager Reference"></a><h1>Thread Manager Reference</h1><div class="spec_sheet_info_box"><table cellspacing="0" class="specbox"><tr><td scope="row"><strong><span style="white-space: nowrap;">Framework</span></strong></td><td><div style="margin-bottom:1px"> <a href="../../SpotlightReference_Collection/index.html#//apple_ref/doc/uid/TP40003857" target="_top">CoreServices</a>/CoreServices.h</div></td></tr><tr><td scope="row"><strong><span style="white-space: nowrap;">Declared in</span></strong></td><td><div style="margin-bottom:1px"><span class="content_text">Threads.h</span><br/></div></td></tr></table></div><br/><a name="//apple_ref/doc/uid/TP30000084-CH201-DontLinkElementID_1" title="Overview"></a><h2>Overview</h2><p>You can use the Thread Manager to provide cooperatively scheduled threads, or multiple points of execution, in an application. You can think of the Thread Manager as an enhancement to the classic Mac OS Process Manager, which governs how applications work together in the Mac OS cooperative multitasking environment. </p><div class="importantbox"><a name="//apple_ref/doc/uid/TP30000084-CH201-DontLinkElementID_4" title="Important:"></a><p><strong>Important:</strong>&nbsp;Active development with the Thread Manager is not recommended. The API is intended only for developers who are porting their applications to Mac OS X and whose code relies on the cooperative threading model. If you are writing a new Carbon application, you should use POSIX threads or the Multiprocessing Services API instead. See <em><a href="../../../../Cocoa/Conceptual/Multithreading/index.html#//apple_ref/doc/uid/10000057i" target="_top">Threading Programming Guide</a></em> for more information.</p><p></p></div><p>Consider using the Thread Manager for applications with more than one thread if these threads can execute only in the cooperative multitasking environment of the classic Mac OS Process Manager.  </p><p>Alternatively, you should consider using the Multiprocessing Services to implement separate paths of execution for tasks that are reentrant and can therefore can be preemptively scheduled. </p><p>Using Thread Manager routines, you can create threads and thread pools and set them up to run; turn scheduling on and off; work with stacks; create dialog boxes that yield control to other threads; pass information between threads; install custom scheduling and context-switching functions; and use threads to make asynchronous I/O calls. </p><p>The Thread Manager provides only cooperative threading for PowerPC applications. Applications can use the Multiprocessing Services API to create preemptively scheduled tasks.</p><p>Note that several Thread Manager functions that did not require you to pass universal procedure pointers (UPPs) for callbacks now require them in Carbon. See the Carbon Porting Notes for more information. </p>






<a name="//apple_ref/doc/uid/TP30000084-DontLinkChapterID_1-DontLinkElementID_2" title="Functions by Task"></a><h2>Functions by Task</h2>
<a name="//apple_ref/doc/uid/TP30000084-CH1g-129757" title="Creating and Disposing of Threads"></a><a name="//apple_ref/doc/uid/TP30000084-CH1g-TPXREF104" title="Creating and Disposing of Threads"></a>
    
    <h3 class="tasks">Creating and Disposing of Threads</h3>
        
    <ul class="tooltip">
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/DisposeThread">DisposeThread</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Deletes a thread when it finishes executing. '/>
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/NewThread">NewThread</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Creates a new thread or allocates one from the existing pool of threads.'/>
            </span></li>
    </ul>


<a name="//apple_ref/doc/uid/TP30000084-CH1g-130486" title="Creating and Getting Information About Thread Pools"></a><a name="//apple_ref/doc/uid/TP30000084-CH1g-TPXREF105" title="Creating and Getting Information About Thread Pools"></a>
    
    <h3 class="tasks">Creating and Getting Information About Thread Pools</h3>
        
    <ul class="tooltip">
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/CreateThreadPool">CreateThreadPool</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Creates a pool of threads for your application. '/>
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/GetDefaultThreadStackSize">GetDefaultThreadStackSize</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Determines the default stack size required by a thread. '/>
            </span></li>
            
            
    <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="../DeprecationAppendix/AppendixADeprecatedAPI.html#//apple_ref/c/func/GetFreeThreadCount">GetFreeThreadCount</a></code>&#032;&#032;<font color="red">Deprecated in Mac OS X v10.3</font>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Determines how many threads are available to be allocated in a thread pool. &#032;(<font color="red">Deprecated.</font>&#032;There is no replacement.)'/>
            </span></li><li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="../DeprecationAppendix/AppendixADeprecatedAPI.html#//apple_ref/c/func/GetSpecificFreeThreadCount">GetSpecificFreeThreadCount</a></code>&#032;&#032;<font color="red">Deprecated in Mac OS X v10.3</font>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Determines how many threads with a stack size equal to or greater than the specified size are available to be allocated in a thread pool. &#032;(<font color="red">Deprecated.</font>&#032;There is no replacement.)'/>
            </span></li></ul>


<a name="//apple_ref/doc/uid/TP30000084-CH1g-131366" title="Getting Information About Specific Threads"></a><a name="//apple_ref/doc/uid/TP30000084-CH1g-TPXREF106" title="Getting Information About Specific Threads"></a>
    
    <h3 class="tasks">Getting Information About Specific Threads</h3>
        
    <ul class="tooltip">
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/GetCurrentThread">GetCurrentThread</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Obtains the thread ID of the currently executing thread.'/>
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/GetThreadState">GetThreadState</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Obtains the state of a thread.'/>
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/ThreadCurrentStackSpace">ThreadCurrentStackSpace</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Determines the amount of stack space that is available for any thread in your application. '/>
            </span></li>
    </ul>


<a name="//apple_ref/doc/uid/TP30000084-CH1g-131922" title="Getting Information and Scheduling Threads During Interrupts"></a><a name="//apple_ref/doc/uid/TP30000084-CH1g-TPXREF107" title="Getting Information and Scheduling Threads During Interrupts"></a>
    
    <h3 class="tasks">Getting Information and Scheduling Threads During Interrupts</h3>
        
    <ul class="tooltip">
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/GetThreadCurrentTaskRef">GetThreadCurrentTaskRef</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Obtains a thread task reference.'/>
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/GetThreadStateGivenTaskRef">GetThreadStateGivenTaskRef</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Obtains the state of a thread when your application is not necessarily the current process—for example, during execution of an interrupt function. '/>
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/SetThreadReadyGivenTaskRef">SetThreadReadyGivenTaskRef</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Changes the state of a thread from stopped to ready when your application is not the current process.'/>
            </span></li>
    </ul>


<a name="//apple_ref/doc/uid/TP30000084-CH1g-132571" title="Installing Custom Scheduling, Switching, Terminating, and Debugging Functions"></a><a name="//apple_ref/doc/uid/TP30000084-CH1g-TPXREF108" title="Installing Custom Scheduling, Switching, Terminating, and Debugging Functions"></a>
    
    <h3 class="tasks">Installing Custom Scheduling, Switching, Terminating, and Debugging Functions</h3>
        
    <ul class="tooltip">
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/SetDebuggerNotificationProcs">SetDebuggerNotificationProcs</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Installs functions that notify the debugger when a thread is created, disposed of, or scheduled.'/>
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/SetThreadScheduler">SetThreadScheduler</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Installs a custom scheduling function (custom scheduler).'/>
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/SetThreadSwitcher">SetThreadSwitcher</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Installs a custom context-switching function for any thread.'/>
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/SetThreadTerminator">SetThreadTerminator</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Installs a custom thread-termination function for a thread.'/>
            </span></li>
    </ul>


<a name="//apple_ref/doc/uid/TP30000084-CH1g-133691" title="Preventing Scheduling"></a><a name="//apple_ref/doc/uid/TP30000084-CH1g-TPXREF109" title="Preventing Scheduling"></a>
    
    <h3 class="tasks">Preventing Scheduling</h3>
        
    <ul class="tooltip">
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/SetThreadStateEndCritical">SetThreadStateEndCritical</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Changes the state of the current thread and exits that thread’s critical section at the same time. '/>
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/ThreadBeginCritical">ThreadBeginCritical</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Indicates that the thread is entering a critical code section.'/>
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/ThreadEndCritical">ThreadEndCritical</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Indicates that the thread is leaving a critical code section.'/>
            </span></li>
    </ul>


<a name="//apple_ref/doc/uid/TP30000084-CH1g-134276" title="Scheduling Threads"></a><a name="//apple_ref/doc/uid/TP30000084-CH1g-TPXREF110" title="Scheduling Threads"></a>
    
    <h3 class="tasks">Scheduling Threads</h3>
        
    <ul class="tooltip">
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/SetThreadState">SetThreadState</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Changes the state of any thread.'/>
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/YieldToAnyThread">YieldToAnyThread</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Relinquishes the current thread’s control.'/>
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/YieldToThread">YieldToThread</a></code>
                
					<img src="../../../../Resources/Images/info_icon.jpg" width="10" height="10" border="0" class="tooltipicon" abstract='Relinquishes the current thread’s control to a particular thread.'/>
            </span></li>
    </ul>


<a name="//apple_ref/doc/uid/TP30000084-CH1g-134959" title="Miscellaneous"></a><a name="//apple_ref/doc/uid/TP30000084-CH1g-TPXREF111" title="Miscellaneous"></a>
    
    <h3 class="tasks">Miscellaneous</h3>
        
    <ul class="tooltip">
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/DisposeDebuggerDisposeThreadUPP">DisposeDebuggerDisposeThreadUPP</a></code>
                
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/DisposeDebuggerNewThreadUPP">DisposeDebuggerNewThreadUPP</a></code>
                
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/DisposeDebuggerThreadSchedulerUPP">DisposeDebuggerThreadSchedulerUPP</a></code>
                
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/DisposeThreadEntryUPP">DisposeThreadEntryUPP</a></code>
                
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/DisposeThreadSchedulerUPP">DisposeThreadSchedulerUPP</a></code>
                
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/DisposeThreadSwitchUPP">DisposeThreadSwitchUPP</a></code>
                
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/DisposeThreadTerminationUPP">DisposeThreadTerminationUPP</a></code>
                
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/InvokeDebuggerDisposeThreadUPP">InvokeDebuggerDisposeThreadUPP</a></code>
                
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/InvokeDebuggerNewThreadUPP">InvokeDebuggerNewThreadUPP</a></code>
                
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/InvokeDebuggerThreadSchedulerUPP">InvokeDebuggerThreadSchedulerUPP</a></code>
                
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/InvokeThreadEntryUPP">InvokeThreadEntryUPP</a></code>
                
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/InvokeThreadSchedulerUPP">InvokeThreadSchedulerUPP</a></code>
                
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/InvokeThreadSwitchUPP">InvokeThreadSwitchUPP</a></code>
                
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/InvokeThreadTerminationUPP">InvokeThreadTerminationUPP</a></code>
                
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/NewDebuggerDisposeThreadUPP">NewDebuggerDisposeThreadUPP</a></code>
                
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/NewDebuggerNewThreadUPP">NewDebuggerNewThreadUPP</a></code>
                
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/NewDebuggerThreadSchedulerUPP">NewDebuggerThreadSchedulerUPP</a></code>
                
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/NewThreadEntryUPP">NewThreadEntryUPP</a></code>
                
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/NewThreadSchedulerUPP">NewThreadSchedulerUPP</a></code>
                
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/NewThreadSwitchUPP">NewThreadSwitchUPP</a></code>
                
            </span></li>
            <li class="tooltip"><span onMouseOut="hidetip()" onMouseOver="showtip(this,event);">
                
                <code><a href="reference.html#//apple_ref/c/func/NewThreadTerminationUPP">NewThreadTerminationUPP</a></code>
                
            </span></li>
    </ul>

<a name="//apple_ref/doc/uid/TP30000084-CH1g-129736" title="Functions"></a><a name="//apple_ref/doc/uid/TP30000084-CH1g-TPXREF103" title="Functions"></a><h2>Functions</h2>


















































<a name="//apple_ref/c/func/CreateThreadPool" title="CreateThreadPool"></a><a name="//apple_ref/doc/c_ref/CreateThreadPool" title="CreateThreadPool"></a><a name="//apple_ref/doc/uid/TP30000084-CH1g-F00806" title="CreateThreadPool"></a>
<a name="//apple_ref/doc/uid/TP30000084-CH1g-DontLinkElementID_6"></a><h3 class="tight">CreateThreadPool</h3>
<p class="spaceabove">Creates a pool of threads for your application. </p>
<p class="spaceabove"><pre>
OSErr CreateThreadPool (
   <a href="reference.html#//apple_ref/doc/c_ref/ThreadStyle">ThreadStyle</a> threadStyle,
   <!--a-->SInt16<!--/a--> numToCreate,
   <a href="../../../../QuickTime/Reference/QTRef_DataTypes/Reference/reference.html#//apple_ref/doc/c_ref/Size" target="_top">Size</a> stackSize
);
</pre></p>
<h5 class="tight">Parameters</h5><dl class="termdef">
<dt><em>threadStyle</em></dt>
<dd><p>The type of thread to create for this set of threads in the pool. Cooperative is the only type that you can specify. Historically, the Thread Manger supported two types of threads, preemptive and cooperative. However, due to severe limitations on their use, the Thread Manager no longer supports preemptive threads. </p></dd>
<dt><em>numToCreate</em></dt>
<dd><p>The number of threads to create for the pool. </p></dd>
<dt><em>stackSize</em></dt>
<dd><p>The stack size for this set of threads in the pool. This stack must be large enough to handle saved thread context, normal application stack usage, interrupt handling functions, and CPU exceptions. Specify a stack size of 0 to request the Thread Manager’s default stack size for the specified type of thread. </p></dd></dl>
<h5 class="tight">Return Value</h5>
<p>A result code. See <span class="content_text"><a href="reference.html#//apple_ref/doc/uid/TP30000084-CH5g-RCM0102">“Thread Manager Result Codes.”</a></span></p>
<h5 class="tight">Discussion</h5>
<p>The <code>CreateThreadPool</code> function creates the specified number of threads with the specified stack requirements. It places the threads that it creates into a pool for use by your application.</p>
<p>When you call <code>CreateThreadPool</code>, if the Thread Manager is unable to create all the threads that you specify, it does not create any at all and returns the <code>memFullErr</code> result code.</p>
<p>The threads in the pool are indistinguishable except by stack size. That is, you cannot refer to them individually. When you want to use a thread to execute some code in your application, you allocate a thread of a specific size from the pool using the <code>NewThread</code> function. The <code>NewThread</code> function assigns a thread ID to the thread and specifies the function that is the entry point to the thread.</p>
<p>Note that it is not strictly necessary to create a pool of threads before allocating a thread. If you wish, you can use the <code>NewThread</code> function to create and allocate a thread in one step. The advantage of using <code>CreateThreadPool</code> is that you can allocate memory for threads early in your application’s execution before memory is used or fragmented.</p>
<p>Before making any calls to <code>CreateThreadPool</code>, be certain that you first have called the Memory Manager function <code>MaxApplZone</code> to extend the application heap to its limit. You must call <code>MaxApplZone</code> from the main application thread before any other threads in your application run.</p>
<p>To allocate a thread from the pool created with <code>CreateThreadPool</code>, use the  <code><a href="reference.html#//apple_ref/c/func/NewThread">NewThread</a></code>  function.</p><h5 class="tight">Special Considerations</h5><p>Active development with the Thread Manager is not recommended. The API is intended only for developers who are porting their applications to Mac OS X and whose code relies on the cooperative threading model. If you are writing a new Carbon application, you should use POSIX threads or the Multiprocessing Services API instead. See <em><a href="../../../../Cocoa/Conceptual/Multithreading/index.html#//apple_ref/doc/uid/10000057i" target="_top">Threading Programming Guide</a></em> for more information.</p>
<h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.0 and later.</li></ul><h5 class="tight">Declared In</h5><code>Threads.h</code><a name="//apple_ref/c/func/DisposeDebuggerDisposeThreadUPP" title="DisposeDebuggerDisposeThreadUPP"></a><a name="//apple_ref/doc/c_ref/DisposeDebuggerDisposeThreadUPP" title="DisposeDebuggerDisposeThreadUPP"></a><a name="//apple_ref/doc/uid/TP30000084-CH1g-F11249" title="DisposeDebuggerDisposeThreadUPP"></a>
<a name="//apple_ref/doc/uid/TP30000084-CH1g-DontLinkElementID_7"></a><h3 class="tight">DisposeDebuggerDisposeThreadUPP</h3>
<p class="spaceabove"></p>
<p class="spaceabove"><pre>
void DisposeDebuggerDisposeThreadUPP (
   <a href="reference.html#//apple_ref/doc/c_ref/DebuggerDisposeThreadUPP">DebuggerDisposeThreadUPP</a> userUPP
);
</pre></p>
<h5 class="tight">Parameters</h5><dl class="termdef">
<dt><em>userUPP</em></dt>
<dd></dd></dl><h5 class="tight">Special Considerations</h5><p>Active development with the Thread Manager is not recommended. The API is intended only for developers who are porting their applications to Mac OS X and whose code relies on the cooperative threading model. If you are writing a new Carbon application, you should use POSIX threads or the Multiprocessing Services API instead. See <em><a href="../../../../Cocoa/Conceptual/Multithreading/index.html#//apple_ref/doc/uid/10000057i" target="_top">Threading Programming Guide</a></em> for more information.</p>
<h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.0 and later.</li></ul><h5 class="tight">Declared In</h5><code>Threads.h</code><a name="//apple_ref/c/func/DisposeDebuggerNewThreadUPP" title="DisposeDebuggerNewThreadUPP"></a><a name="//apple_ref/doc/c_ref/DisposeDebuggerNewThreadUPP" title="DisposeDebuggerNewThreadUPP"></a><a name="//apple_ref/doc/uid/TP30000084-CH1g-F11250" title="DisposeDebuggerNewThreadUPP"></a>
<a name="//apple_ref/doc/uid/TP30000084-CH1g-DontLinkElementID_8"></a><h3 class="tight">DisposeDebuggerNewThreadUPP</h3>
<p class="spaceabove"></p>
<p class="spaceabove"><pre>
void DisposeDebuggerNewThreadUPP (
   <a href="reference.html#//apple_ref/doc/c_ref/DebuggerNewThreadUPP">DebuggerNewThreadUPP</a> userUPP
);
</pre></p>
<h5 class="tight">Parameters</h5><dl class="termdef">
<dt><em>userUPP</em></dt>
<dd></dd></dl><h5 class="tight">Special Considerations</h5><p>Active development with the Thread Manager is not recommended. The API is intended only for developers who are porting their applications to Mac OS X and whose code relies on the cooperative threading model. If you are writing a new Carbon application, you should use POSIX threads or the Multiprocessing Services API instead. See <em><a href="../../../../Cocoa/Conceptual/Multithreading/index.html#//apple_ref/doc/uid/10000057i" target="_top">Threading Programming Guide</a></em> for more information.</p>
<h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.0 and later.</li></ul><h5 class="tight">Declared In</h5><code>Threads.h</code><a name="//apple_ref/c/func/DisposeDebuggerThreadSchedulerUPP" title="DisposeDebuggerThreadSchedulerUPP"></a><a name="//apple_ref/doc/c_ref/DisposeDebuggerThreadSchedulerUPP" title="DisposeDebuggerThreadSchedulerUPP"></a><a name="//apple_ref/doc/uid/TP30000084-CH1g-F11251" title="DisposeDebuggerThreadSchedulerUPP"></a>
<a name="//apple_ref/doc/uid/TP30000084-CH1g-DontLinkElementID_9"></a><h3 class="tight">DisposeDebuggerThreadSchedulerUPP</h3>
<p class="spaceabove"></p>
<p class="spaceabove"><pre>
void DisposeDebuggerThreadSchedulerUPP (
   <a href="reference.html#//apple_ref/doc/c_ref/DebuggerThreadSchedulerUPP">DebuggerThreadSchedulerUPP</a> userUPP
);
</pre></p>
<h5 class="tight">Parameters</h5><dl class="termdef">
<dt><em>userUPP</em></dt>
<dd></dd></dl><h5 class="tight">Special Considerations</h5><p>Active development with the Thread Manager is not recommended. The API is intended only for developers who are porting their applications to Mac OS X and whose code relies on the cooperative threading model. If you are writing a new Carbon application, you should use POSIX threads or the Multiprocessing Services API instead. See <em><a href="../../../../Cocoa/Conceptual/Multithreading/index.html#//apple_ref/doc/uid/10000057i" target="_top">Threading Programming Guide</a></em> for more information.</p>
<h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.0 and later.</li></ul><h5 class="tight">Declared In</h5><code>Threads.h</code><a name="//apple_ref/c/func/DisposeThread" title="DisposeThread"></a><a name="//apple_ref/doc/c_ref/DisposeThread" title="DisposeThread"></a><a name="//apple_ref/doc/uid/TP30000084-CH1g-F01173" title="DisposeThread"></a>
<a name="//apple_ref/doc/uid/TP30000084-CH1g-DontLinkElementID_10"></a><h3 class="tight">DisposeThread</h3>
<p class="spaceabove">Deletes a thread when it finishes executing. </p>
<p class="spaceabove"><pre>
OSErr DisposeThread (
   <a href="reference.html#//apple_ref/doc/c_ref/ThreadID">ThreadID</a> threadToDump,
   void *threadResult,
   <!--a-->Boolean<!--/a--> recycleThread
);
</pre></p>
<h5 class="tight">Parameters</h5><dl class="termdef">
<dt><em>threadToDump</em></dt>
<dd><p>The thread ID of the thread to delete. </p></dd>
<dt><em>threadResult</em></dt>
<dd><p>A pointer to the thread’s result. The <code>DisposeThread</code> function places this result to an address which you originally specify with the <code>threadResult</code> parameter of the <code>NewThread</code> function when you create or allocate the thread. Pass a value of <code>NULL</code> if you are not interested in obtaining a function result. </p></dd>
<dt><em>recycleThread</em></dt>
<dd><p>A Boolean value that specifies whether to return the thread to the allocation pool or to remove it entirely. Specify <code>False</code> to dispose of the thread entirely and <code>True</code> to return it to the thread pool. </p></dd></dl>
<h5 class="tight">Return Value</h5>
<p>A result code. See <span class="content_text"><a href="reference.html#//apple_ref/doc/uid/TP30000084-CH5g-RCM0102">“Thread Manager Result Codes.”</a></span></p>
<h5 class="tight">Discussion</h5>
<p>When a thread finishes executing, the Thread Manager automatically calls <code>DisposeThread</code> to delete it. Therefore, the only reason for you to explicitly call <code>DisposeThread</code> is to recycle a terminating thread. To do so, set the <code>recycleThread</code> parameter to <code>True</code>. The Thread Manager clears out the thread’s internal data structure, resets it, and puts the thread in the thread pool where it can be used again as necessary. </p>
<p>The <code>DisposeThread</code> function sets the <code>threadResult</code> parameter to the thread’s function result. You allocate the storage for the thread result when you create or allocate a thread with the <code>NewThread</code> function.</p>
<p>You cannot explicitly dispose of the main application thread. If you attempt to do so, <code>DisposeThread</code> returns the <code>threadProtocolErr</code> result code.</p>
<p>When your application terminates, the Thread Manager calls <code>DisposeThread</code> to terminate any active threads. It terminates stopped and ready threads first but in no special order. It terminates the currently running thread last. This thread should always be the main application thread. </p>
<p>To install a callback function to do special cleanup when a thread terminates, use the  <code><a href="reference.html#//apple_ref/c/func/SetThreadTerminator">SetThreadTerminator</a></code>  function. </p><h5 class="tight">Special Considerations</h5><p>Active development with the Thread Manager is not recommended. The API is intended only for developers who are porting their applications to Mac OS X and whose code relies on the cooperative threading model. If you are writing a new Carbon application, you should use POSIX threads or the Multiprocessing Services API instead. See <em><a href="../../../../Cocoa/Conceptual/Multithreading/index.html#//apple_ref/doc/uid/10000057i" target="_top">Threading Programming Guide</a></em> for more information.</p>
<h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.0 and later.</li></ul><h5 class="tight">Declared In</h5><code>Threads.h</code><a name="//apple_ref/c/func/DisposeThreadEntryUPP" title="DisposeThreadEntryUPP"></a><a name="//apple_ref/doc/c_ref/DisposeThreadEntryUPP" title="DisposeThreadEntryUPP"></a><a name="//apple_ref/doc/uid/TP30000084-CH1g-F11476" title="DisposeThreadEntryUPP"></a>
<a name="//apple_ref/doc/uid/TP30000084-CH1g-DontLinkElementID_11"></a><h3 class="tight">DisposeThreadEntryUPP</h3>
<p class="spaceabove"></p>
<p class="spaceabove"><pre>
void DisposeThreadEntryUPP (
   <a href="reference.html#//apple_ref/doc/c_ref/ThreadEntryUPP">ThreadEntryUPP</a> userUPP
);
</pre></p>
<h5 class="tight">Parameters</h5><dl class="termdef">
<dt><em>userUPP</em></dt>
<dd></dd></dl><h5 class="tight">Special Considerations</h5><p>Active development with the Thread Manager is not recommended. The API is intended only for developers who are porting their applications to Mac OS X and whose code relies on the cooperative threading model. If you are writing a new Carbon application, you should use POSIX threads or the Multiprocessing Services API instead. See <em><a href="../../../../Cocoa/Conceptual/Multithreading/index.html#//apple_ref/doc/uid/10000057i" target="_top">Threading Programming Guide</a></em> for more information.</p>
<h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.0 and later.</li></ul><h5 class="tight">Declared In</h5><code>Threads.h</code><a name="//apple_ref/c/func/DisposeThreadSchedulerUPP" title="DisposeThreadSchedulerUPP"></a><a name="//apple_ref/doc/c_ref/DisposeThreadSchedulerUPP" title="DisposeThreadSchedulerUPP"></a><a name="//apple_ref/doc/uid/TP30000084-CH1g-F11477" title="DisposeThreadSchedulerUPP"></a>
<a name="//apple_ref/doc/uid/TP30000084-CH1g-DontLinkElementID_12"></a><h3 class="tight">DisposeThreadSchedulerUPP</h3>
<p class="spaceabove"></p>
<p class="spaceabove"><pre>
void DisposeThreadSchedulerUPP (
   <a href="reference.html#//apple_ref/doc/c_ref/ThreadSchedulerUPP">ThreadSchedulerUPP</a> userUPP
);
</pre></p>
<h5 class="tight">Parameters</h5><dl class="termdef">
<dt><em>userUPP</em></dt>
<dd></dd></dl><h5 class="tight">Special Considerations</h5><p>Active development with the Thread Manager is not recommended. The API is intended only for developers who are porting their applications to Mac OS X and whose code relies on the cooperative threading model. If you are writing a new Carbon application, you should use POSIX threads or the Multiprocessing Services API instead. See <em><a href="../../../../Cocoa/Conceptual/Multithreading/index.html#//apple_ref/doc/uid/10000057i" target="_top">Threading Programming Guide</a></em> for more information.</p>
<h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.0 and later.</li></ul><h5 class="tight">Declared In</h5><code>Threads.h</code><a name="//apple_ref/c/func/DisposeThreadSwitchUPP" title="DisposeThreadSwitchUPP"></a><a name="//apple_ref/doc/c_ref/DisposeThreadSwitchUPP" title="DisposeThreadSwitchUPP"></a><a name="//apple_ref/doc/uid/TP30000084-CH1g-F11478" title="DisposeThreadSwitchUPP"></a>
<a name="//apple_ref/doc/uid/TP30000084-CH1g-DontLinkElementID_13"></a><h3 class="tight">DisposeThreadSwitchUPP</h3>
<p class="spaceabove"></p>
<p class="spaceabove"><pre>
void DisposeThreadSwitchUPP (
   <a href="reference.html#//apple_ref/doc/c_ref/ThreadSwitchUPP">ThreadSwitchUPP</a> userUPP
);
</pre></p>
<h5 class="tight">Parameters</h5><dl class="termdef">
<dt><em>userUPP</em></dt>
<dd></dd></dl><h5 class="tight">Special Considerations</h5><p>Active development with the Thread Manager is not recommended. The API is intended only for developers who are porting their applications to Mac OS X and whose code relies on the cooperative threading model. If you are writing a new Carbon application, you should use POSIX threads or the Multiprocessing Services API instead. See <em><a href="../../../../Cocoa/Conceptual/Multithreading/index.html#//apple_ref/doc/uid/10000057i" target="_top">Threading Programming Guide</a></em> for more information.</p>
<h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.0 and later.</li></ul><h5 class="tight">Declared In</h5><code>Threads.h</code><a name="//apple_ref/c/func/DisposeThreadTerminationUPP" title="DisposeThreadTerminationUPP"></a><a name="//apple_ref/doc/c_ref/DisposeThreadTerminationUPP" title="DisposeThreadTerminationUPP"></a><a name="//apple_ref/doc/uid/TP30000084-CH1g-F11479" title="DisposeThreadTerminationUPP"></a>
<a name="//apple_ref/doc/uid/TP30000084-CH1g-DontLinkElementID_14"></a><h3 class="tight">DisposeThreadTerminationUPP</h3>
<p class="spaceabove"></p>
<p class="spaceabove"><pre>
void DisposeThreadTerminationUPP (
   <a href="reference.html#//apple_ref/doc/c_ref/ThreadTerminationUPP">ThreadTerminationUPP</a> userUPP
);
</pre></p>
<h5 class="tight">Parameters</h5><dl class="termdef">
<dt><em>userUPP</em></dt>
<dd></dd></dl><h5 class="tight">Special Considerations</h5><p>Active development with the Thread Manager is not recommended. The API is intended only for developers who are porting their applications to Mac OS X and whose code relies on the cooperative threading model. If you are writing a new Carbon application, you should use POSIX threads or the Multiprocessing Services API instead. See <em><a href="../../../../Cocoa/Conceptual/Multithreading/index.html#//apple_ref/doc/uid/10000057i" target="_top">Threading Programming Guide</a></em> for more information.</p>
<h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.0 and later.</li></ul><h5 class="tight">Declared In</h5><code>Threads.h</code><a name="//apple_ref/c/func/GetCurrentThread" title="GetCurrentThread"></a><a name="//apple_ref/doc/c_ref/GetCurrentThread" title="GetCurrentThread"></a><a name="//apple_ref/doc/uid/TP30000084-CH1g-F01708" title="GetCurrentThread"></a>
<a name="//apple_ref/doc/uid/TP30000084-CH1g-DontLinkElementID_15"></a><h3 class="tight">GetCurrentThread</h3>
<p class="spaceabove">Obtains the thread ID of the currently executing thread.</p>
<p class="spaceabove"><pre>
OSErr GetCurrentThread (
   <a href="reference.html#//apple_ref/doc/c_ref/ThreadID">ThreadID</a> * currentThreadID
);
</pre></p>
<h5 class="tight">Parameters</h5><dl class="termdef">
<dt><em>currentThreadID</em></dt>
<dd><p>On return, a pointer to the thread ID of the current thread. </p></dd></dl>
<h5 class="tight">Return Value</h5>
<p>A result code. See <span class="content_text"><a href="reference.html#//apple_ref/doc/uid/TP30000084-CH5g-RCM0102">“Thread Manager Result Codes.”</a></span></p>
<h5 class="tight">Discussion</h5>
<p>You can use the thread ID obtained by <code>GetCurrentThread</code> in functions such as <code>GetThreadState</code> and <code>SetThreadState</code> to get and set the state of a thread. </p><h5 class="tight">Special Considerations</h5><p>Active development with the Thread Manager is not recommended. The API is intended only for developers who are porting their applications to Mac OS X and whose code relies on the cooperative threading model. If you are writing a new Carbon application, you should use POSIX threads or the Multiprocessing Services API instead. See <em><a href="../../../../Cocoa/Conceptual/Multithreading/index.html#//apple_ref/doc/uid/10000057i" target="_top">Threading Programming Guide</a></em> for more information.</p>
<h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.0 and later.</li></ul><h5 class="tight">Declared In</h5><code>Threads.h</code><a name="//apple_ref/c/func/GetDefaultThreadStackSize" title="GetDefaultThreadStackSize"></a><a name="//apple_ref/doc/c_ref/GetDefaultThreadStackSize" title="GetDefaultThreadStackSize"></a><a name="//apple_ref/doc/uid/TP30000084-CH1g-F01719" title="GetDefaultThreadStackSize"></a>
<a name="//apple_ref/doc/uid/TP30000084-CH1g-DontLinkElementID_16"></a><h3 class="tight">GetDefaultThreadStackSize</h3>
<p class="spaceabove">Determines the default stack size required by a thread. </p>
<p class="spaceabove"><pre>
OSErr GetDefaultThreadStackSize (
   <a href="reference.html#//apple_ref/doc/c_ref/ThreadStyle">ThreadStyle</a> threadStyle,
   <a href="../../../../QuickTime/Reference/QTRef_DataTypes/Reference/reference.html#//apple_ref/doc/c_ref/Size" target="_top">Size</a> *stackSize
);
</pre></p>
<h5 class="tight">Parameters</h5><dl class="termdef">
<dt><em>threadStyle</em></dt>
<dd><p>The type of thread to get information about. Cooperative is the only type that you can specify. Historically, the Thread Manger supported two types of threads, preemptive and cooperative, but the Thread Manager no longer supports preemptive threads. </p></dd>
<dt><em>stackSize</em></dt>
<dd><p>On return, a pointer to the default stack size (in bytes). When you create a thread pool or an individual thread, this is the stack size that the Thread Manager allocates when you specify the default size. </p></dd></dl>
<h5 class="tight">Return Value</h5>
<p>A result code. See <span class="content_text"><a href="reference.html#//apple_ref/doc/uid/TP30000084-CH5g-RCM0102">“Thread Manager Result Codes.”</a></span></p>
<h5 class="tight">Discussion</h5>
<p>Keep in mind that the default stack size is not an absolute value that you must use but is a rough estimate.</p>
<p>To determine how much stack space is available for a particular thread, use the  <code><a href="reference.html#//apple_ref/c/func/ThreadCurrentStackSpace">ThreadCurrentStackSpace</a></code>  function. </p><h5 class="tight">Special Considerations</h5><p>Active development with the Thread Manager is not recommended. The API is intended only for developers who are porting their applications to Mac OS X and whose code relies on the cooperative threading model. If you are writing a new Carbon application, you should use POSIX threads or the Multiprocessing Services API instead. See <em><a href="../../../../Cocoa/Conceptual/Multithreading/index.html#//apple_ref/doc/uid/10000057i" target="_top">Threading Programming Guide</a></em> for more information.</p>
<h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.0 and later.</li></ul><h5 class="tight">Declared In</h5><code>Threads.h</code><a name="//apple_ref/c/func/GetThreadCurrentTaskRef" title="GetThreadCurrentTaskRef"></a><a name="//apple_ref/doc/c_ref/GetThreadCurrentTaskRef" title="GetThreadCurrentTaskRef"></a><a name="//apple_ref/doc/uid/TP30000084-CH1g-F02047" title="GetThreadCurrentTaskRef"></a>
<a name="//apple_ref/doc/uid/TP30000084-CH1g-DontLinkElementID_19"></a><h3 class="tight">GetThreadCurrentTaskRef</h3>
<p class="spaceabove">Obtains a thread task reference.</p>
<p class="spaceabove"><pre>
OSErr GetThreadCurrentTaskRef (
   <a href="reference.html#//apple_ref/doc/c_ref/ThreadTaskRef">ThreadTaskRef</a> *threadTRef
);
</pre></p>
<h5 class="tight">Parameters</h5><dl class="termdef">
<dt><em>threadTRef</em></dt>
<dd><p>On return, a pointer to a thread task reference. </p></dd></dl>
<h5 class="tight">Return Value</h5>
<p>A result code. See <span class="content_text"><a href="reference.html#//apple_ref/doc/uid/TP30000084-CH5g-RCM0102">“Thread Manager Result Codes.”</a></span></p>
<h5 class="tight">Discussion</h5>
<p>The thread task reference is somewhat of a misnomer because it identifies your application context, not a particular thread. Identifying your application context is necessary in situations where you aren’t guaranteed that your application is the current context—such as during the execution of an interrupt function. In such cases, you need both the thread ID to identify the thread and the thread task reference to identify the application context.</p>
<p>After you obtain the thread task reference, you can use it in the  <code><a href="reference.html#//apple_ref/c/func/GetThreadStateGivenTaskRef">GetThreadStateGivenTaskRef</a></code>  and  <code><a href="reference.html#//apple_ref/c/func/SetThreadReadyGivenTaskRef">SetThreadReadyGivenTaskRef</a></code>  functions to get and set information about specific threads in your application at times when you are not guaranteed that your application is the current context.</p>
<p>To get information about a thread when your application is not the current process, use the <code>GetThreadStateGivenTaskRef</code> function.</p>
<p>To change the state of a thread from stopped to ready when your application is not the current process, use the <code>SetThreadReadyGivenTaskRef</code> function. </p><h5 class="tight">Special Considerations</h5><p>Active development with the Thread Manager is not recommended. The API is intended only for developers who are porting their applications to Mac OS X and whose code relies on the cooperative threading model. If you are writing a new Carbon application, you should use POSIX threads or the Multiprocessing Services API instead. See <em><a href="../../../../Cocoa/Conceptual/Multithreading/index.html#//apple_ref/doc/uid/10000057i" target="_top">Threading Programming Guide</a></em> for more information.</p>
<h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.0 and later.</li></ul><h5 class="tight">Declared In</h5><code>Threads.h</code><a name="//apple_ref/c/func/GetThreadState" title="GetThreadState"></a><a name="//apple_ref/doc/c_ref/GetThreadState" title="GetThreadState"></a><a name="//apple_ref/doc/uid/TP30000084-CH1g-F02048" title="GetThreadState"></a>
<a name="//apple_ref/doc/uid/TP30000084-CH1g-DontLinkElementID_20"></a><h3 class="tight">GetThreadState</h3>
<p class="spaceabove">Obtains the state of a thread.</p>
<p class="spaceabove"><pre>
OSErr GetThreadState (
   <a href="reference.html#//apple_ref/doc/c_ref/ThreadID">ThreadID</a> threadToGet,
   <a href="reference.html#//apple_ref/doc/c_ref/ThreadState">ThreadState</a> *threadState
);
</pre></p>
<h5 class="tight">Parameters</h5><dl class="termdef">
<dt><em>threadToGet</em></dt>
<dd><p>The thread ID of the thread about which you want information. </p></dd>
<dt><em>threadState</em></dt>
<dd><p>On return, a pointer to the state of the thread specified by <code>threadToGet</code>. </p></dd></dl>
<h5 class="tight">Return Value</h5>
<p>A result code. See <span class="content_text"><a href="reference.html#//apple_ref/doc/uid/TP30000084-CH5g-RCM0102">“Thread Manager Result Codes.”</a></span></p>
<h5 class="tight">Discussion</h5>
<p>A thread can be in one of three states: ready to execute ( <code>kReadyThreadState</code>), stopped ( <code>kStoppedThreadState</code>), or executing ( <code>kRunningThreadState</code>). </p>
<p>To change the state of a specified thread, use  <code><a href="reference.html#//apple_ref/c/func/SetThreadState">SetThreadState</a></code>. </p><h5 class="tight">Special Considerations</h5><p>Active development with the Thread Manager is not recommended. The API is intended only for developers who are porting their applications to Mac OS X and whose code relies on the cooperative threading model. If you are writing a new Carbon application, you should use POSIX threads or the Multiprocessing Services API instead. See <em><a href="../../../../Cocoa/Conceptual/Multithreading/index.html#//apple_ref/doc/uid/10000057i" target="_top">Threading Programming Guide</a></em> for more information.</p>
<h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.0 and later.</li></ul><h5 class="tight">Declared In</h5><code>Threads.h</code><a name="//apple_ref/c/func/GetThreadStateGivenTaskRef" title="GetThreadStateGivenTaskRef"></a><a name="//apple_ref/doc/c_ref/GetThreadStateGivenTaskRef" title="GetThreadStateGivenTaskRef"></a><a name="//apple_ref/doc/uid/TP30000084-CH1g-F02049" title="GetThreadStateGivenTaskRef"></a>
<a name="//apple_ref/doc/uid/TP30000084-CH1g-DontLinkElementID_21"></a><h3 class="tight">GetThreadStateGivenTaskRef</h3>
<p class="spaceabove">Obtains the state of a thread when your application is not necessarily the current process—for example, during execution of an interrupt function. </p>
<p class="spaceabove"><pre>
OSErr GetThreadStateGivenTaskRef (
   <a href="reference.html#//apple_ref/doc/c_ref/ThreadTaskRef">ThreadTaskRef</a> threadTRef,
   <a href="reference.html#//apple_ref/doc/c_ref/ThreadID">ThreadID</a> threadToGet,
   <a href="reference.html#//apple_ref/doc/c_ref/ThreadState">ThreadState</a> *threadState
);
</pre></p>
<h5 class="tight">Parameters</h5><dl class="termdef">
<dt><em>threadTRef</em></dt>
<dd><p>The thread task reference of the application containing the thread whose state you want to determine. </p></dd>
<dt><em>threadToGet</em></dt>
<dd><p>The thread ID of the thread whose state you want to determine. </p></dd>
<dt><em>threadState</em></dt>
<dd><p>A pointer to a thread state variable in which the function places the state of the specified thread. </p></dd></dl>
<h5 class="tight">Return Value</h5>
<p>A result code. See <span class="content_text"><a href="reference.html#//apple_ref/doc/uid/TP30000084-CH5g-RCM0102">“Thread Manager Result Codes.”</a></span></p>
<h5 class="tight">Discussion</h5>
<p>You can use <code>GetThreadStateGivenTaskRef</code> at times when you aren’t guaranteed that your application is the current context, such as during execution of an interrupt function. In such cases you must identify the thread task reference (the application context) as well as the thread ID. </p>
<p>To determine the thread task reference (application context) for your application, use the  <code><a href="reference.html#//apple_ref/c/func/GetThreadCurrentTaskRef">GetThreadCurrentTaskRef</a></code>  function.</p>
<p>To change the state of a thread from stopped to ready when your application is not the current process, use the  <code><a href="reference.html#//apple_ref/c/func/SetThreadReadyGivenTaskRef">SetThreadReadyGivenTaskRef</a></code>  function. </p><h5 class="tight">Special Considerations</h5><p>Active development with the Thread Manager is not recommended. The API is intended only for developers who are porting their applications to Mac OS X and whose code relies on the cooperative threading model. If you are writing a new Carbon application, you should use POSIX threads or the Multiprocessing Services API instead. See <em><a href="../../../../Cocoa/Conceptual/Multithreading/index.html#//apple_ref/doc/uid/10000057i" target="_top">Threading Programming Guide</a></em> for more information.</p>
<h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.0 and later.</li></ul><h5 class="tight">Declared In</h5><code>Threads.h</code><a name="//apple_ref/c/func/InvokeDebuggerDisposeThreadUPP" title="InvokeDebuggerDisposeThreadUPP"></a><a name="//apple_ref/doc/c_ref/InvokeDebuggerDisposeThreadUPP" title="InvokeDebuggerDisposeThreadUPP"></a><a name="//apple_ref/doc/uid/TP30000084-CH1g-F11690" title="InvokeDebuggerDisposeThreadUPP"></a>
<a name="//apple_ref/doc/uid/TP30000084-CH1g-DontLinkElementID_22"></a><h3 class="tight">InvokeDebuggerDisposeThreadUPP</h3>
<p class="spaceabove"></p>
<p class="spaceabove"><pre>
void InvokeDebuggerDisposeThreadUPP (
   <a href="reference.html#//apple_ref/doc/c_ref/ThreadID">ThreadID</a> threadDeleted,
   <a href="reference.html#//apple_ref/doc/c_ref/DebuggerDisposeThreadUPP">DebuggerDisposeThreadUPP</a> userUPP
);
</pre></p>
<h5 class="tight">Parameters</h5><dl class="termdef">
<dt><em>userUPP</em></dt>
<dd></dd></dl><h5 class="tight">Special Considerations</h5><p>Active development with the Thread Manager is not recommended. The API is intended only for developers who are porting their applications to Mac OS X and whose code relies on the cooperative threading model. If you are writing a new Carbon application, you should use POSIX threads or the Multiprocessing Services API instead. See <em><a href="../../../../Cocoa/Conceptual/Multithreading/index.html#//apple_ref/doc/uid/10000057i" target="_top">Threading Programming Guide</a></em> for more information.</p>
<h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.0 and later.</li></ul><h5 class="tight">Declared In</h5><code>Threads.h</code><a name="//apple_ref/c/func/InvokeDebuggerNewThreadUPP" title="InvokeDebuggerNewThreadUPP"></a><a name="//apple_ref/doc/c_ref/InvokeDebuggerNewThreadUPP" title="InvokeDebuggerNewThreadUPP"></a><a name="//apple_ref/doc/uid/TP30000084-CH1g-F11691" title="InvokeDebuggerNewThreadUPP"></a>
<a name="//apple_ref/doc/uid/TP30000084-CH1g-DontLinkElementID_23"></a><h3 class="tight">InvokeDebuggerNewThreadUPP</h3>
<p class="spaceabove"></p>
<p class="spaceabove"><pre>
void InvokeDebuggerNewThreadUPP (
   <a href="reference.html#//apple_ref/doc/c_ref/ThreadID">ThreadID</a> threadCreated,
   <a href="reference.html#//apple_ref/doc/c_ref/DebuggerNewThreadUPP">DebuggerNewThreadUPP</a> userUPP
);
</pre></p>
<h5 class="tight">Parameters</h5><dl class="termdef">
<dt><em>userUPP</em></dt>
<dd></dd></dl><h5 class="tight">Special Considerations</h5><p>Active development with the Thread Manager is not recommended. The API is intended only for developers who are porting their applications to Mac OS X and whose code relies on the cooperative threading model. If you are writing a new Carbon application, you should use POSIX threads or the Multiprocessing Services API instead. See <em><a href="../../../../Cocoa/Conceptual/Multithreading/index.html#//apple_ref/doc/uid/10000057i" target="_top">Threading Programming Guide</a></em> for more information.</p>
<h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.0 and later.</li></ul><h5 class="tight">Declared In</h5><code>Threads.h</code><a name="//apple_ref/c/func/InvokeDebuggerThreadSchedulerUPP" title="InvokeDebuggerThreadSchedulerUPP"></a><a name="//apple_ref/doc/c_ref/InvokeDebuggerThreadSchedulerUPP" title="InvokeDebuggerThreadSchedulerUPP"></a><a name="//apple_ref/doc/uid/TP30000084-CH1g-F11692" title="InvokeDebuggerThreadSchedulerUPP"></a>
<a name="//apple_ref/doc/uid/TP30000084-CH1g-DontLinkElementID_24"></a><h3 class="tight">InvokeDebuggerThreadSchedulerUPP</h3>
<p class="spaceabove"></p>
<p class="spaceabove"><pre>
<a href="reference.html#//apple_ref/doc/c_ref/ThreadID">ThreadID</a> InvokeDebuggerThreadSchedulerUPP (
   <!--a-->SchedulerInfoRecPtr<!--/a--> schedulerInfo,
   <a href="reference.html#//apple_ref/doc/c_ref/DebuggerThreadSchedulerUPP">DebuggerThreadSchedulerUPP</a> userUPP
);
</pre></p>
<h5 class="tight">Parameters</h5><dl class="termdef">
<dt><em>schedulerInfo</em></dt>
<dd></dd>
<dt><em>userUPP</em></dt>
<dd></dd></dl>
<h5 class="tight">Return Value</h5>
<p>See the description of the <code>ThreadID</code> data type.</p><h5 class="tight">Special Considerations</h5><p>Active development with the Thread Manager is not recommended. The API is intended only for developers who are porting their applications to Mac OS X and whose code relies on the cooperative threading model. If you are writing a new Carbon application, you should use POSIX threads or the Multiprocessing Services API instead. See <em><a href="../../../../Cocoa/Conceptual/Multithreading/index.html#//apple_ref/doc/uid/10000057i" target="_top">Threading Programming Guide</a></em> for more information.</p>
<h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.0 and later.</li></ul><h5 class="tight">Declared In</h5><code>Threads.h</code><a name="//apple_ref/c/func/InvokeThreadEntryUPP" title="InvokeThreadEntryUPP"></a><a name="//apple_ref/doc/c_ref/InvokeThreadEntryUPP" title="InvokeThreadEntryUPP"></a><a name="//apple_ref/doc/uid/TP30000084-CH1g-F11917" title="InvokeThreadEntryUPP"></a>
<a name="//apple_ref/doc/uid/TP30000084-CH1g-DontLinkElementID_25"></a><h3 class="tight">InvokeThreadEntryUPP</h3>
<p class="spaceabove"></p>
<p class="spaceabove"><pre>
<!--a-->voidPtr<!--/a--> InvokeThreadEntryUPP (
   void *threadParam,
   <a href="reference.html#//apple_ref/doc/c_ref/ThreadEntryUPP">ThreadEntryUPP</a> userUPP
);
</pre></p>
<h5 class="tight">Parameters</h5><dl class="termdef">
<dt><em>userUPP</em></dt>
<dd></dd></dl><h5 class="tight">Special Considerations</h5><p>Active development with the Thread Manager is not recommended. The API is intended only for developers who are porting their applications to Mac OS X and whose code relies on the cooperative threading model. If you are writing a new Carbon application, you should use POSIX threads or the Multiprocessing Services API instead. See <em><a href="../../../../Cocoa/Conceptual/Multithreading/index.html#//apple_ref/doc/uid/10000057i" target="_top">Threading Programming Guide</a></em> for more information.</p>
<h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.0 and later.</li></ul><h5 class="tight">Declared In</h5><code>Threads.h</code><a name="//apple_ref/c/func/InvokeThreadSchedulerUPP" title="InvokeThreadSchedulerUPP"></a><a name="//apple_ref/doc/c_ref/InvokeThreadSchedulerUPP" title="InvokeThreadSchedulerUPP"></a><a name="//apple_ref/doc/uid/TP30000084-CH1g-F11918" title="InvokeThreadSchedulerUPP"></a>
<a name="//apple_ref/doc/uid/TP30000084-CH1g-DontLinkElementID_26"></a><h3 class="tight">InvokeThreadSchedulerUPP</h3>
<p class="spaceabove"></p>
<p class="spaceabove"><pre>
<a href="reference.html#//apple_ref/doc/c_ref/ThreadID">ThreadID</a> InvokeThreadSchedulerUPP (
   <!--a-->SchedulerInfoRecPtr<!--/a--> schedulerInfo,
   <a href="reference.html#//apple_ref/doc/c_ref/ThreadSchedulerUPP">ThreadSchedulerUPP</a> userUPP
);
</pre></p>
<h5 class="tight">Parameters</h5><dl class="termdef">
<dt><em>schedulerInfo</em></dt>
<dd></dd>
<dt><em>userUPP</em></dt>
<dd></dd></dl>
<h5 class="tight">Return Value</h5>
<p>See the description of the <code>ThreadID</code> data type.</p><h5 class="tight">Special Considerations</h5><p>Active development with the Thread Manager is not recommended. The API is intended only for developers who are porting their applications to Mac OS X and whose code relies on the cooperative threading model. If you are writing a new Carbon application, you should use POSIX threads or the Multiprocessing Services API instead. See <em><a href="../../../../Cocoa/Conceptual/Multithreading/index.html#//apple_ref/doc/uid/10000057i" target="_top">Threading Programming Guide</a></em> for more information.</p>
<h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.0 and later.</li></ul><h5 class="tight">Declared In</h5><code>Threads.h</code><a name="//apple_ref/c/func/InvokeThreadSwitchUPP" title="InvokeThreadSwitchUPP"></a><a name="//apple_ref/doc/c_ref/InvokeThreadSwitchUPP" title="InvokeThreadSwitchUPP"></a><a name="//apple_ref/doc/uid/TP30000084-CH1g-F11919" title="InvokeThreadSwitchUPP"></a>
<a name="//apple_ref/doc/uid/TP30000084-CH1g-DontLinkElementID_27"></a><h3 class="tight">InvokeThreadSwitchUPP</h3>
<p class="spaceabove"></p>
<p class="spaceabove"><pre>
void InvokeThreadSwitchUPP (
   <a href="reference.html#//apple_ref/doc/c_ref/ThreadID">ThreadID</a> threadBeingSwitched,
   void *switchProcParam,
   <a href="reference.html#//apple_ref/doc/c_ref/ThreadSwitchUPP">ThreadSwitchUPP</a> userUPP
);
</pre></p>
<h5 class="tight">Parameters</h5><dl class="termdef">
<dt><em>userUPP</em></dt>
<dd></dd></dl><h5 class="tight">Special Considerations</h5><p>Active development with the Thread Manager is not recommended. The API is intended only for developers who are porting their applications to Mac OS X and whose code relies on the cooperative threading model. If you are writing a new Carbon application, you should use POSIX threads or the Multiprocessing Services API instead. See <em><a href="../../../../Cocoa/Conceptual/Multithreading/index.html#//apple_ref/doc/uid/10000057i" target="_top">Threading Programming Guide</a></em> for more information.</p>
<h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.0 and later.</li></ul><h5 class="tight">Declared In</h5><code>Threads.h</code><a name="//apple_ref/c/func/InvokeThreadTerminationUPP" title="InvokeThreadTerminationUPP"></a><a name="//apple_ref/doc/c_ref/InvokeThreadTerminationUPP" title="InvokeThreadTerminationUPP"></a><a name="//apple_ref/doc/uid/TP30000084-CH1g-F11920" title="InvokeThreadTerminationUPP"></a>
<a name="//apple_ref/doc/uid/TP30000084-CH1g-DontLinkElementID_28"></a><h3 class="tight">InvokeThreadTerminationUPP</h3>
<p class="spaceabove"></p>
<p class="spaceabove"><pre>
void InvokeThreadTerminationUPP (
   <a href="reference.html#//apple_ref/doc/c_ref/ThreadID">ThreadID</a> threadTerminated,
   void *terminationProcParam,
   <a href="reference.html#//apple_ref/doc/c_ref/ThreadTerminationUPP">ThreadTerminationUPP</a> userUPP
);
</pre></p>
<h5 class="tight">Parameters</h5><dl class="termdef">
<dt><em>userUPP</em></dt>
<dd></dd></dl><h5 class="tight">Special Considerations</h5><p>Active development with the Thread Manager is not recommended. The API is intended only for developers who are porting their applications to Mac OS X and whose code relies on the cooperative threading model. If you are writing a new Carbon application, you should use POSIX threads or the Multiprocessing Services API instead. See <em><a href="../../../../Cocoa/Conceptual/Multithreading/index.html#//apple_ref/doc/uid/10000057i" target="_top">Threading Programming Guide</a></em> for more information.</p>
<h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.0 and later.</li></ul><h5 class="tight">Declared In</h5><code>Threads.h</code><a name="//apple_ref/c/func/NewDebuggerDisposeThreadUPP" title="NewDebuggerDisposeThreadUPP"></a><a name="//apple_ref/doc/c_ref/NewDebuggerDisposeThreadUPP" title="NewDebuggerDisposeThreadUPP"></a><a name="//apple_ref/doc/uid/TP30000084-CH1g-F12002" title="NewDebuggerDisposeThreadUPP"></a>
<a name="//apple_ref/doc/uid/TP30000084-CH1g-DontLinkElementID_29"></a><h3 class="tight">NewDebuggerDisposeThreadUPP</h3>
<p class="spaceabove"></p>
<p class="spaceabove"><pre>
<a href="reference.html#//apple_ref/doc/c_ref/DebuggerDisposeThreadUPP">DebuggerDisposeThreadUPP</a> NewDebuggerDisposeThreadUPP (
   <a href="reference.html#//apple_ref/doc/c_ref/DebuggerDisposeThreadProcPtr">DebuggerDisposeThreadProcPtr</a> userRoutine
);
</pre></p>
<h5 class="tight">Parameters</h5><dl class="termdef">
<dt><em>userRoutine</em></dt>
<dd></dd></dl>
<h5 class="tight">Return Value</h5>
<p>See the description of the <code>DebuggerDisposeThreadUPP</code> data type.</p><h5 class="tight">Special Considerations</h5><p>Active development with the Thread Manager is not recommended. The API is intended only for developers who are porting their applications to Mac OS X and whose code relies on the cooperative threading model. If you are writing a new Carbon application, you should use POSIX threads or the Multiprocessing Services API instead. See <em><a href="../../../../Cocoa/Conceptual/Multithreading/index.html#//apple_ref/doc/uid/10000057i" target="_top">Threading Programming Guide</a></em> for more information.</p>
<h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.0 and later.</li></ul><h5 class="tight">Declared In</h5><code>Threads.h</code><a name="//apple_ref/c/func/NewDebuggerNewThreadUPP" title="NewDebuggerNewThreadUPP"></a><a name="//apple_ref/doc/c_ref/NewDebuggerNewThreadUPP" title="NewDebuggerNewThreadUPP"></a><a name="//apple_ref/doc/uid/TP30000084-CH1g-F12003" title="NewDebuggerNewThreadUPP"></a>
<a name="//apple_ref/doc/uid/TP30000084-CH1g-DontLinkElementID_30"></a><h3 class="tight">NewDebuggerNewThreadUPP</h3>
<p class="spaceabove"></p>
<p class="spaceabove"><pre>
<a href="reference.html#//apple_ref/doc/c_ref/DebuggerNewThreadUPP">DebuggerNewThreadUPP</a> NewDebuggerNewThreadUPP (
   <a href="reference.html#//apple_ref/doc/c_ref/DebuggerNewThreadProcPtr">DebuggerNewThreadProcPtr</a> userRoutine
);
</pre></p>
<h5 class="tight">Parameters</h5><dl class="termdef">
<dt><em>userRoutine</em></dt>
<dd></dd></dl>
<h5 class="tight">Return Value</h5>
<p>See the description of the <code>DebuggerNewThreadUPP</code> data type.</p><h5 class="tight">Special Considerations</h5><p>Active development with the Thread Manager is not recommended. The API is intended only for developers who are porting their applications to Mac OS X and whose code relies on the cooperative threading model. If you are writing a new Carbon application, you should use POSIX threads or the Multiprocessing Services API instead. See <em><a href="../../../../Cocoa/Conceptual/Multithreading/index.html#//apple_ref/doc/uid/10000057i" target="_top">Threading Programming Guide</a></em> for more information.</p>
<h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.0 and later.</li></ul><h5 class="tight">Declared In</h5><code>Threads.h</code><a name="//apple_ref/c/func/NewDebuggerThreadSchedulerUPP" title="NewDebuggerThreadSchedulerUPP"></a><a name="//apple_ref/doc/c_ref/NewDebuggerThreadSchedulerUPP" title="NewDebuggerThreadSchedulerUPP"></a><a name="//apple_ref/doc/uid/TP30000084-CH1g-F12004" title="NewDebuggerThreadSchedulerUPP"></a>
<a name="//apple_ref/doc/uid/TP30000084-CH1g-DontLinkElementID_31"></a><h3 class="tight">NewDebuggerThreadSchedulerUPP</h3>
<p class="spaceabove"></p>
<p class="spaceabove"><pre>
<a href="reference.html#//apple_ref/doc/c_ref/DebuggerThreadSchedulerUPP">DebuggerThreadSchedulerUPP</a> NewDebuggerThreadSchedulerUPP (
   <a href="reference.html#//apple_ref/doc/c_ref/DebuggerThreadSchedulerProcPtr">DebuggerThreadSchedulerProcPtr</a> userRoutine
);
</pre></p>
<h5 class="tight">Parameters</h5><dl class="termdef">
<dt><em>userRoutine</em></dt>
<dd></dd></dl>
<h5 class="tight">Return Value</h5>
<p>See the description of the <code>DebuggerThreadSchedulerUPP</code> data type.</p><h5 class="tight">Special Considerations</h5><p>Active development with the Thread Manager is not recommended. The API is intended only for developers who are porting their applications to Mac OS X and whose code relies on the cooperative threading model. If you are writing a new Carbon application, you should use POSIX threads or the Multiprocessing Services API instead. See <em><a href="../../../../Cocoa/Conceptual/Multithreading/index.html#//apple_ref/doc/uid/10000057i" target="_top">Threading Programming Guide</a></em> for more information.</p>
<h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.0 and later.</li></ul><h5 class="tight">Declared In</h5><code>Threads.h</code><a name="//apple_ref/c/func/NewThread" title="NewThread"></a><a name="//apple_ref/doc/c_ref/NewThread" title="NewThread"></a><a name="//apple_ref/doc/uid/TP30000084-CH1g-F04260" title="NewThread"></a>
<a name="//apple_ref/doc/uid/TP30000084-CH1g-DontLinkElementID_32"></a><h3 class="tight">NewThread</h3>
<p class="spaceabove">Creates a new thread or allocates one from the existing pool of threads.</p>
<p><i style="background-color: #e9e9e9; padding: 5px; margin-top: 10px; margin-bottom:5px;">Modified</i></p>
<p class="spaceabove"><pre>
OSErr NewThread (
   <a href="reference.html#//apple_ref/doc/c_ref/ThreadStyle">ThreadStyle</a> threadStyle,
   <a href="reference.html#//apple_ref/doc/c_ref/ThreadEntryTPP">ThreadEntryTPP</a> threadEntry,
   void *threadParam,
   <a href="../../../../QuickTime/Reference/QTRef_DataTypes/Reference/reference.html#//apple_ref/doc/c_ref/Size" target="_top">Size</a> stackSize,
   <a href="reference.html#//apple_ref/doc/c_ref/ThreadOptions">ThreadOptions</a> options,
   void **threadResult,
   <a href="reference.html#//apple_ref/doc/c_ref/ThreadID">ThreadID</a> *threadMade
);
</pre></p>
<h5 class="tight">Parameters</h5><dl class="termdef">
<dt><em>threadStyle</em></dt>
<dd><p>The type of thread to create. Cooperative is the only type that you can specify. Historically, the Thread Manger supported two types of threads, preemptive and cooperative, but the Thread Manager no longer supports preemptive threads. </p></dd>
<dt><em>threadEntry</em></dt>
<dd><p>A pointer to the thread entry function. </p></dd>
<dt><em>threadParam</em></dt>
<dd><p>A pointer to a value that the Thread Manager passes as a parameter to the thread entry function. Specify <code>NULL</code> if you are passing no information. </p></dd>
<dt><em>stackSize</em></dt>
<dd><p>The stack size (in bytes) to allocate for this thread. This stack must be large enough to handle saved thread context, normal application stack usage, interrupt handling functions, and CPU exceptions. Specify a stack size of 0 (zero) to request the Thread Manager’s default stack size. </p></dd>
<dt><em>options</em></dt>
<dd><p>Options that define characteristics of the new thread. See the <code><a href="reference.html#//apple_ref/c/tdef/ThreadOptions">Thread Option Constants</a></code> data type for details on the options. You sum the options together to create a single <code>options</code> parameter. </p></dd>
<dt><em>threadResult</em></dt>
<dd><p><code></code>On return, a pointer to the address of a location to hold the function result provided by the <code><a href="reference.html#//apple_ref/c/tdef/ThreadOptions">Thread Option Constants</a></code> function when the thread terminates. Specify <code>NULL</code> for this parameter if you are not interested in the function result.</p></dd>
<dt><em>threadMade</em></dt>
<dd><p>On return, a pointer to the thread ID of the newly created or allocated thread. If there is an error, <code>threadMade</code> points to a value of <code>kNoThreadID</code>. </p></dd></dl>
<h5 class="tight">Return Value</h5>
<p>A result code. See <span class="content_text"><a href="reference.html#//apple_ref/doc/uid/TP30000084-CH5g-RCM0102">“Thread Manager Result Codes.”</a></span></p>
<h5 class="tight">Discussion</h5>
<p>The <code>NewThread</code> function obtains a thread ID that you can use in other Thread Manager functions to identify the thread. If you want to allocate a thread from the pool of threads, specify the <code>kUsePremadeThread</code> option of the <code>options</code> parameter. Otherwise, <code>NewThread</code> creates a new thread.</p>
<p>When you request a thread from the existing pool, the Thread Manager allocates one that best fits your specified stack size. If you specify the <code>kExactMatchThread</code> option of the <code>options</code> parameter, the Thread Manager allocates a thread whose stack exactly matches your stack-size requirement or, if it can’t allocate one because no such thread exists, it returns the <code>threadTooManyReqsErr</code> result code.</p>
<p>Before making any calls to <code>NewThread</code>, be certain that you first have called the Memory Manager function <code>MaxApplZone</code> to extend the application heap to its limit. You must call <code>MaxApplZone</code> from the main application thread before any other threads in your application run. </p>
<p>When you call the <code>NewThread</code> function, you pass, as the <code>threadEntry</code> parameter, a pointer to the name of the entry function to the thread. When the newly created thread runs initially, it begins by executing this function.</p>
<p>You can use the <code>threadParam</code> parameter to pass thread-specific information to a newly created or allocated thread. In the data structure pointed to by this parameter, you could place something like A5 information or the address of a window to update. You could also use this parameter to specify a place for a thread’s local storage.</p>
<p>Be sure to create the storage for the <code>threadResult</code> parameter in a place that is guaranteed to be available when the thread terminates—for example, in an application global variable or in a local variable of the application’s main function (the main thread, by definition, cannot be disposed of so it is always available). Do not create the storage in a local variable of a subfunction that completes before the thread terminates or the storage will become invalid.</p>
<p>For Carbon applications, the pointer to your thread entry function must be a universal procedure pointer (UPP).</p>
<p>To dispose of a thread, use the DisposeThread function.</p>
<p>See the description of the  <code><a href="reference.html#//apple_ref/c/tdef/ThreadOptions">Thread Option Constants</a></code>  data type for details on the characteristics you can specify in the <code>options</code> parameter.</p>
<p>For more information about the thread entry function, see the  <code><a href="reference.html#//apple_ref/c/tdef/ThreadEntryProcPtr">ThreadEntryProcPtr</a></code>  function. </p><h5 class="tight">Special Considerations</h5><p>Active development with the Thread Manager is not recommended. The API is intended only for developers who are porting their applications to Mac OS X and whose code relies on the cooperative threading model. If you are writing a new Carbon application, you should use POSIX threads or the Multiprocessing Services API instead. See <em><a href="../../../../Cocoa/Conceptual/Multithreading/index.html#//apple_ref/doc/uid/10000057i" target="_top">Threading Programming Guide</a></em> for more information.</p>

<h5 class="tight">Carbon Porting Notes</h5>
<p>For Carbon applications, you must create and pass a universal procedure pointer (UPP) to specify the new thread  callback. Use the <code><a href="reference.html#//apple_ref/c/func/NewThreadEntryUPP">NewThreadEntryUPP</a></code> and <code><a href="reference.html#//apple_ref/c/func/DisposeThreadEntryUPP">DisposeThreadEntryUPP</a></code> functions to create and remove the UPP.</p><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.0 and later.</li></ul><h5 class="tight">Declared In</h5><code>Threads.h</code><a name="//apple_ref/c/func/NewThreadEntryUPP" title="NewThreadEntryUPP"></a><a name="//apple_ref/doc/c_ref/NewThreadEntryUPP" title="NewThreadEntryUPP"></a><a name="//apple_ref/doc/uid/TP30000084-CH1g-F12230" title="NewThreadEntryUPP"></a>
<a name="//apple_ref/doc/uid/TP30000084-CH1g-DontLinkElementID_33"></a><h3 class="tight">NewThreadEntryUPP</h3>
<p class="spaceabove"></p>
<p class="spaceabove"><pre>
<a href="reference.html#//apple_ref/doc/c_ref/ThreadEntryUPP">ThreadEntryUPP</a> NewThreadEntryUPP (
   <a href="reference.html#//apple_ref/doc/c_ref/ThreadEntryProcPtr">ThreadEntryProcPtr</a> userRoutine
);
</pre></p>
<h5 class="tight">Parameters</h5><dl class="termdef">
<dt><em>userRoutine</em></dt>
<dd></dd></dl>
<h5 class="tight">Return Value</h5>
<p>See the description of the <code>ThreadEntryUPP</code> data type.</p><h5 class="tight">Special Considerations</h5><p>Active development with the Thread Manager is not recommended. The API is intended only for developers who are porting their applications to Mac OS X and whose code relies on the cooperative threading model. If you are writing a new Carbon application, you should use POSIX threads or the Multiprocessing Services API instead. See <em><a href="../../../../Cocoa/Conceptual/Multithreading/index.html#//apple_ref/doc/uid/10000057i" target="_top">Threading Programming Guide</a></em> for more information.</p>
<h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.0 and later.</li></ul><h5 class="tight">Declared In</h5><code>Threads.h</code><a name="//apple_ref/c/func/NewThreadSchedulerUPP" title="NewThreadSchedulerUPP"></a><a name="//apple_ref/doc/c_ref/NewThreadSchedulerUPP" title="NewThreadSchedulerUPP"></a><a name="//apple_ref/doc/uid/TP30000084-CH1g-F12231" title="NewThreadSchedulerUPP"></a>
<a name="//apple_ref/doc/uid/TP30000084-CH1g-DontLinkElementID_34"></a><h3 class="tight">NewThreadSchedulerUPP</h3>
<p class="spaceabove"></p>
<p class="spaceabove"><pre>
<a href="reference.html#//apple_ref/doc/c_ref/ThreadSchedulerUPP">ThreadSchedulerUPP</a> NewThreadSchedulerUPP (
   <a href="reference.html#//apple_ref/doc/c_ref/ThreadSchedulerProcPtr">ThreadSchedulerProcPtr</a> userRoutine
);
</pre></p>
<h5 class="tight">Parameters</h5><dl class="termdef">
<dt><em>userRoutine</em></dt>
<dd></dd></dl>
<h5 class="tight">Return Value</h5>
<p>See the description of the <code>ThreadSchedulerUPP</code> data type.</p><h5 class="tight">Special Considerations</h5><p>Active development with the Thread Manager is not recommended. The API is intended only for developers who are porting their applications to Mac OS X and whose code relies on the cooperative threading model. If you are writing a new Carbon application, you should use POSIX threads or the Multiprocessing Services API instead. See <em><a href="../../../../Cocoa/Conceptual/Multithreading/index.html#//apple_ref/doc/uid/10000057i" target="_top">Threading Programming Guide</a></em> for more information.</p>
<h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.0 and later.</li></ul><h5 class="tight">Declared In</h5><code>Threads.h</code><a name="//apple_ref/c/func/NewThreadSwitchUPP" title="NewThreadSwitchUPP"></a><a name="//apple_ref/doc/c_ref/NewThreadSwitchUPP" title="NewThreadSwitchUPP"></a><a name="//apple_ref/doc/uid/TP30000084-CH1g-F12232" title="NewThreadSwitchUPP"></a>
<a name="//apple_ref/doc/uid/TP30000084-CH1g-DontLinkElementID_35"></a><h3 class="tight">NewThreadSwitchUPP</h3>
<p class="spaceabove"></p>
<p class="spaceabove"><pre>
<a href="reference.html#//apple_ref/doc/c_ref/ThreadSwitchUPP">ThreadSwitchUPP</a> NewThreadSwitchUPP (
   <a href="reference.html#//apple_ref/doc/c_ref/ThreadSwitchProcPtr">ThreadSwitchProcPtr</a> userRoutine
);
</pre></p>
<h5 class="tight">Parameters</h5><dl class="termdef">
<dt><em>userRoutine</em></dt>
<dd></dd></dl>
<h5 class="tight">Return Value</h5>
<p>See the description of the <code>ThreadSwitchUPP</code> data type.</p><h5 class="tight">Special Considerations</h5><p>Active development with the Thread Manager is not recommended. The API is intended only for developers who are porting their applications to Mac OS X and whose code relies on the cooperative threading model. If you are writing a new Carbon application, you should use POSIX threads or the Multiprocessing Services API instead. See <em><a href="../../../../Cocoa/Conceptual/Multithreading/index.html#//apple_ref/doc/uid/10000057i" target="_top">Threading Programming Guide</a></em> for more information.</p>
<h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.0 and later.</li></ul><h5 class="tight">Declared In</h5><code>Threads.h</code><a name="//apple_ref/c/func/NewThreadTerminationUPP" title="NewThreadTerminationUPP"></a><a name="//apple_ref/doc/c_ref/NewThreadTerminationUPP" title="NewThreadTerminationUPP"></a><a name="//apple_ref/doc/uid/TP30000084-CH1g-F12233" title="NewThreadTerminationUPP"></a>
<a name="//apple_ref/doc/uid/TP30000084-CH1g-DontLinkElementID_36"></a><h3 class="tight">NewThreadTerminationUPP</h3>
<p class="spaceabove"></p>
<p class="spaceabove"><pre>
<a href="reference.html#//apple_ref/doc/c_ref/ThreadTerminationUPP">ThreadTerminationUPP</a> NewThreadTerminationUPP (
   <a href="reference.html#//apple_ref/doc/c_ref/ThreadTerminationProcPtr">ThreadTerminationProcPtr</a> userRoutine
);
</pre></p>
<h5 class="tight">Parameters</h5><dl class="termdef">
<dt><em>userRoutine</em></dt>
<dd></dd></dl>
<h5 class="tight">Return Value</h5>
<p>See the description of the <code>ThreadTerminationUPP</code> data type.</p><h5 class="tight">Special Considerations</h5><p>Active development with the Thread Manager is not recommended. The API is intended only for developers who are porting their applications to Mac OS X and whose code relies on the cooperative threading model. If you are writing a new Carbon application, you should use POSIX threads or the Multiprocessing Services API instead. See <em><a href="../../../../Cocoa/Conceptual/Multithreading/index.html#//apple_ref/doc/uid/10000057i" target="_top">Threading Programming Guide</a></em> for more information.</p>
<h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.0 and later.</li></ul><h5 class="tight">Declared In</h5><code>Threads.h</code><a name="//apple_ref/c/func/SetDebuggerNotificationProcs" title="SetDebuggerNotificationProcs"></a><a name="//apple_ref/doc/c_ref/SetDebuggerNotificationProcs" title="SetDebuggerNotificationProcs"></a><a name="//apple_ref/doc/uid/TP30000084-CH1g-F06794" title="SetDebuggerNotificationProcs"></a>
<a name="//apple_ref/doc/uid/TP30000084-CH1g-DontLinkElementID_37"></a><h3 class="tight">SetDebuggerNotificationProcs</h3>
<p class="spaceabove">Installs functions that notify the debugger when a thread is created, disposed of, or scheduled.</p>
<p><i style="background-color: #e9e9e9; padding: 5px; margin-top: 10px; margin-bottom:5px;">Modified</i></p>
<p class="spaceabove"><pre>
OSErr SetDebuggerNotificationProcs (
   <a href="reference.html#//apple_ref/doc/c_ref/DebuggerNewThreadTPP">DebuggerNewThreadTPP</a> notifyNewThread,
   <a href="reference.html#//apple_ref/doc/c_ref/DebuggerDisposeThreadTPP">DebuggerDisposeThreadTPP</a> notifyDisposeThread,
   <a href="reference.html#//apple_ref/doc/c_ref/DebuggerThreadSchedulerTPP">DebuggerThreadSchedulerTPP</a> notifyThreadScheduler
);
</pre></p>
<h5 class="tight">Parameters</h5><dl class="termdef">
<dt><em>notifyNewThread</em></dt>
<dd><p>A pointer to the callback function that notifies the debugger when a thread is created. </p></dd>
<dt><em>notifyDisposeThread</em></dt>
<dd><p>A pointer to the callback function that notifies the debugger when a thread is disposed of. This function is called whether you manually dispose of a thread with the <code>DisposeThread</code> function or if a thread disposes of itself automatically when it returns from its highest level of code. </p></dd>
<dt><em>notifyThreadScheduler</em></dt>
<dd><p>A pointer to the callback function that notifies the debugger when a thread is scheduled. </p></dd></dl>
<h5 class="tight">Return Value</h5>
<p>A result code. See <span class="content_text"><a href="reference.html#//apple_ref/doc/uid/TP30000084-CH5g-RCM0102">“Thread Manager Result Codes.”</a></span></p>
<h5 class="tight">Discussion</h5>
<p>You generally use this function only during development of an application.</p>
<p>The <code>SetDebuggerNotificationProcs</code> function installs three separate callback functions that return the thread ID of a newly created thread, the thread ID of a newly disposed of thread, and the thread ID of a newly scheduled thread. </p>
<p>The <code>SetDebuggerNotificationProcs</code> function always installs all three of the debugging functions. You cannot set only one or two of these functions, nor can you chain them together. These restrictions ensure that the function that calls <code>SetDebuggerNotificationProcs</code> owns all three of the debugging functions. If you want to prevent one or two of these debugging functions from being called, you can do so by setting them to <code>NULL</code>.</p>
<p>To guarantee that the debugger is getting an accurate view of scheduling, the Thread Manager doesn’t call the scheduling-notification callback function until both the generic Thread Manager scheduler and any custom thread scheduler have decided on a thread to schedule.</p>
<p>For Carbon applications, the pointers you pass to specify the callbacks must be universal procedure pointers (UPPs).</p>
<p>To create or allocate a new thread, use the  <code><a href="reference.html#//apple_ref/c/func/NewThread">NewThread</a></code>  function.</p>
<p>To dispose of a thread, use the <code>DisposeThread</code> function.</p>
<p>To schedule a thread, you can use a yield function such as  <code><a href="reference.html#//apple_ref/c/func/YieldToAnyThread">YieldToAnyThread</a></code>  or  <code><a href="reference.html#//apple_ref/c/func/YieldToThread">YieldToThread</a></code>  or a function to change the state of a thread, such as  <code><a href="reference.html#//apple_ref/c/func/SetThreadState">SetThreadState</a></code>. </p><h5 class="tight">Special Considerations</h5><p>Active development with the Thread Manager is not recommended. The API is intended only for developers who are porting their applications to Mac OS X and whose code relies on the cooperative threading model. If you are writing a new Carbon application, you should use POSIX threads or the Multiprocessing Services API instead. See <em><a href="../../../../Cocoa/Conceptual/Multithreading/index.html#//apple_ref/doc/uid/10000057i" target="_top">Threading Programming Guide</a></em> for more information.</p>

<h5 class="tight">Carbon Porting Notes</h5>
<p>For Carbon applications, you must create and pass a universal procedure pointer (UPP) to specify the notification callbacks. You must use the designated UPP creation and disposal functions. For example, for the new thread notifier, you call the <code><a href="reference.html#//apple_ref/c/func/NewDebuggerNewThreadUPP">NewDebuggerNewThreadUPP</a></code> and <code><a href="reference.html#//apple_ref/c/func/DisposeDebuggerNewThreadUPP">DisposeDebuggerNewThreadUPP</a></code> functions. </p><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.0 and later.</li></ul><h5 class="tight">Declared In</h5><code>Threads.h</code><a name="//apple_ref/c/func/SetThreadReadyGivenTaskRef" title="SetThreadReadyGivenTaskRef"></a><a name="//apple_ref/doc/c_ref/SetThreadReadyGivenTaskRef" title="SetThreadReadyGivenTaskRef"></a><a name="//apple_ref/doc/uid/TP30000084-CH1g-F06999" title="SetThreadReadyGivenTaskRef"></a>
<a name="//apple_ref/doc/uid/TP30000084-CH1g-DontLinkElementID_38"></a><h3 class="tight">SetThreadReadyGivenTaskRef</h3>
<p class="spaceabove">Changes the state of a thread from stopped to ready when your application is not the current process.</p>
<p class="spaceabove"><pre>
OSErr SetThreadReadyGivenTaskRef (
   <a href="reference.html#//apple_ref/doc/c_ref/ThreadTaskRef">ThreadTaskRef</a> threadTRef,
   <a href="reference.html#//apple_ref/doc/c_ref/ThreadID">ThreadID</a> threadToSet
);
</pre></p>
<h5 class="tight">Parameters</h5><dl class="termdef">
<dt><em>threadTRef</em></dt>
<dd><p>The thread task reference of the application containing the thread whose state you want to change. </p></dd>
<dt><em>threadToSet</em></dt>
<dd><p>The thread ID of the thread whose state you want to change. </p></dd></dl>
<h5 class="tight">Return Value</h5>
<p>A result code. See <span class="content_text"><a href="reference.html#//apple_ref/doc/uid/TP30000084-CH5g-RCM0102">“Thread Manager Result Codes.”</a></span></p>
<h5 class="tight">Discussion</h5>
<p>When you mark a thread as ready to run with this function, the Thread Manager does not put it immediately into the scheduling queue but does so the next time it reschedules threads. </p>
<p>You can use <code>SetThreadStateGivenTaskRef</code> at times when you aren’t guaranteed that your application is the current context, such as during execution of an interrupt function. In such cases you must identify the thread task reference (the application context) as well as the thread ID.</p>
<p>You obtain the thread task reference for your application with the  <code><a href="reference.html#//apple_ref/c/func/GetThreadCurrentTaskRef">GetThreadCurrentTaskRef</a></code>  function.</p>
<p>The <code>SetThreadReadyGivenTaskRef</code> function allows you to do one thing only—change a thread from stopped to ready to execute. You cannot change the state of an executing thread to ready or stopped, nor can you change the state of a ready thread to executing or stopped with this call.</p>
<p>To determine the state of a thread when your application is not the current process, use the  <code><a href="reference.html#//apple_ref/c/func/GetThreadStateGivenTaskRef">GetThreadStateGivenTaskRef</a></code>  function. </p><h5 class="tight">Special Considerations</h5><p>Active development with the Thread Manager is not recommended. The API is intended only for developers who are porting their applications to Mac OS X and whose code relies on the cooperative threading model. If you are writing a new Carbon application, you should use POSIX threads or the Multiprocessing Services API instead. See <em><a href="../../../../Cocoa/Conceptual/Multithreading/index.html#//apple_ref/doc/uid/10000057i" target="_top">Threading Programming Guide</a></em> for more information.</p>
<h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.0 and later.</li></ul><h5 class="tight">Declared In</h5><code>Threads.h</code><a name="//apple_ref/c/func/SetThreadScheduler" title="SetThreadScheduler"></a><a name="//apple_ref/doc/c_ref/SetThreadScheduler" title="SetThreadScheduler"></a><a name="//apple_ref/doc/uid/TP30000084-CH1g-F07000" title="SetThreadScheduler"></a>
<a name="//apple_ref/doc/uid/TP30000084-CH1g-DontLinkElementID_39"></a><h3 class="tight">SetThreadScheduler</h3>
<p class="spaceabove">Installs a custom scheduling function (custom scheduler).</p>
<p><i style="background-color: #e9e9e9; padding: 5px; margin-top: 10px; margin-bottom:5px;">Modified</i></p>
<p class="spaceabove"><pre>
OSErr SetThreadScheduler (
   <a href="reference.html#//apple_ref/doc/c_ref/ThreadSchedulerTPP">ThreadSchedulerTPP</a> threadScheduler
);
</pre></p>
<h5 class="tight">Parameters</h5><dl class="termdef">
<dt><em>threadScheduler</em></dt>
<dd><p>A pointer to a custom scheduler. Specify <code>NULL</code> if you want to remove an installed custom scheduler and use the default Thread Manager scheduling mechanism. </p></dd></dl>
<h5 class="tight">Return Value</h5>
<p>A result code. See <span class="content_text"><a href="reference.html#//apple_ref/doc/uid/TP30000084-CH5g-RCM0102">“Thread Manager Result Codes.”</a></span></p>
<h5 class="tight">Discussion</h5>
<p>The <code>SetThreadScheduler</code> function installs a custom scheduler that runs in conjunction with the default Thread Manager scheduling mechanism. The Thread Manager uses a scheduler information structure to pass the custom scheduler the ID of the current thread and the ID of the thread that the Thread Manager has scheduled to run next. </p>
<p>A custom scheduler should return to the Thread Manager the ID of the thread that it determines to schedule. If it does not determine a particular thread to schedule, it should return the constant <code>kNoThreadID</code> and the Thread Manager default scheduling mechanism schedules the next thread. </p>
<p>If you already have a custom scheduler installed when you call <code>SetThreadScheduler</code>, it replaces the old one with a new one. If you want to remove your custom scheduler and return to using the default Thread Manager scheduling mechanism, call <code>SetThreadScheduler</code> and specify a value of <code>NULL</code> for the parameter.</p>
<p>The <code>SetThreadScheduler</code> function automatically disables scheduling to avoid any reentrancy problems with the custom scheduling function. Therefore, in your custom scheduling function, you should make no yield calls or other calls that would cause scheduling to occur.</p>
<p>For Carbon applications, the pointer to your thread scheduler function must be a universal procedure pointer (UPP). </p>
<p>For more information on the custom scheduling function, see the  <code><a href="reference.html#//apple_ref/c/tdef/ThreadSchedulerProcPtr">ThreadSchedulerProcPtr</a></code>  function. </p><h5 class="tight">Special Considerations</h5><p>Active development with the Thread Manager is not recommended. The API is intended only for developers who are porting their applications to Mac OS X and whose code relies on the cooperative threading model. If you are writing a new Carbon application, you should use POSIX threads or the Multiprocessing Services API instead. See <em><a href="../../../../Cocoa/Conceptual/Multithreading/index.html#//apple_ref/doc/uid/10000057i" target="_top">Threading Programming Guide</a></em> for more information.</p>

<h5 class="tight">Carbon Porting Notes</h5>
<p>For Carbon applications, you must create and pass a universal procedure pointer (UPP) to specify the thread scheduler callback. Use the <code><a href="reference.html#//apple_ref/c/func/NewThreadSchedulerUPP">NewThreadSchedulerUPP</a></code> and <code><a href="reference.html#//apple_ref/c/func/DisposeThreadSchedulerUPP">DisposeThreadSchedulerUPP</a></code> functions to create and remove the UPP.</p><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.0 and later.</li></ul><h5 class="tight">Declared In</h5><code>Threads.h</code><a name="//apple_ref/c/func/SetThreadState" title="SetThreadState"></a><a name="//apple_ref/doc/c_ref/SetThreadState" title="SetThreadState"></a><a name="//apple_ref/doc/uid/TP30000084-CH1g-F07001" title="SetThreadState"></a>
<a name="//apple_ref/doc/uid/TP30000084-CH1g-DontLinkElementID_40"></a><h3 class="tight">SetThreadState</h3>
<p class="spaceabove">Changes the state of any thread.</p>
<p class="spaceabove"><pre>
OSErr SetThreadState (
   <a href="reference.html#//apple_ref/doc/c_ref/ThreadID">ThreadID</a> threadToSet,
   <a href="reference.html#//apple_ref/doc/c_ref/ThreadState">ThreadState</a> newState,
   <a href="reference.html#//apple_ref/doc/c_ref/ThreadID">ThreadID</a> suggestedThread
);
</pre></p>
<h5 class="tight">Parameters</h5><dl class="termdef">
<dt><em>threadToSet</em></dt>
<dd><p>The thread ID of the thread whose state is to be changed. </p></dd>
<dt><em>newState</em></dt>
<dd><p>The new state for the thread. You can specify ready to execute (<code>kReadyThreadState</code>), stopped (<code>kStoppedThreadState</code>), or executing (<code>kRunningThreadState</code>). </p></dd>
<dt><em>suggestedThread</em></dt>
<dd><p>The thread ID of the next thread to run. You specify this thread if you are changing the state of the currently executing thread to stopped or ready to run. Pass <code>kNoThreadID</code> if you do not want to specify a particular thread to run next. In this case, the Thread Manager schedules the next available thread to run.</p></dd></dl>
<h5 class="tight">Return Value</h5>
<p>A result code. See <span class="content_text"><a href="reference.html#//apple_ref/doc/uid/TP30000084-CH5g-RCM0102">“Thread Manager Result Codes.”</a></span></p>
<h5 class="tight">Discussion</h5>
<p>The effect of <code>SetThreadState</code> depends on whether the thread you specify for changing is the currently executing thread or another thread. If you specify the current thread and thus change the state to stopped or ready, <code>SetThreadState</code> invokes the Thread Manager scheduling mechanism. The current thread relinquishes control (it is put in the state you specify, stopped or ready) and the Thread Manager schedules the thread that you specify with the <code>suggestedThread</code> parameter. If this thread is unavailable for running, or if you passed <code>kNoThreadID</code>, the Thread Manager schedules the next available thread.</p>
<p>If you change the state of the current thread to ready, the Thread Manager suspends it awaiting  of the CPU. When it is rescheduled, <code>SetThreadState</code> regains control and returns to the function that called it. </p>
<p>If you have installed a custom scheduler, the Thread Manager passes it the thread ID of the suspended thread.</p>
<p>If you specify a thread other than the currently executing thread, no rescheduling occurs. If you change the state from ready to stopped, the thread is removed from the scheduling queue. The Thread Manager does not schedule this thread for execution again until you change its state to ready. On the other hand, if you change the state from stopped to ready, you have in effect put the thread in the scheduling queue, and the Thread Manager gives it CPU time as soon as it reaches the top of the scheduling queue.</p>
<p>Threads must yield in the CPU addressing mode (24-bit or 32-bit) in which the application was launched.</p>
<p>To obtain the state of any thread, use the  <code><a href="reference.html#//apple_ref/c/func/GetThreadState">GetThreadState</a></code>  function. </p>
<p>To relinquish control to the next available thread, use the  <code><a href="reference.html#//apple_ref/c/func/YieldToAnyThread">YieldToAnyThread</a></code>  function. To relinquish control to a specific thread, use the  <code><a href="reference.html#//apple_ref/c/func/YieldToThread">YieldToThread</a></code>  function.</p>
<p>To set the state of the current thread before it exits a critical section of code, use the  <code><a href="reference.html#//apple_ref/c/func/SetThreadStateEndCritical">SetThreadStateEndCritical</a></code>  function. </p><h5 class="tight">Special Considerations</h5><p>Active development with the Thread Manager is not recommended. The API is intended only for developers who are porting their applications to Mac OS X and whose code relies on the cooperative threading model. If you are writing a new Carbon application, you should use POSIX threads or the Multiprocessing Services API instead. See <em><a href="../../../../Cocoa/Conceptual/Multithreading/index.html#//apple_ref/doc/uid/10000057i" target="_top">Threading Programming Guide</a></em> for more information.</p>
<h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.0 and later.</li></ul><h5 class="tight">Declared In</h5><code>Threads.h</code><a name="//apple_ref/c/func/SetThreadStateEndCritical" title="SetThreadStateEndCritical"></a><a name="//apple_ref/doc/c_ref/SetThreadStateEndCritical" title="SetThreadStateEndCritical"></a><a name="//apple_ref/doc/uid/TP30000084-CH1g-F07002" title="SetThreadStateEndCritical"></a>
<a name="//apple_ref/doc/uid/TP30000084-CH1g-DontLinkElementID_41"></a><h3 class="tight">SetThreadStateEndCritical</h3>
<p class="spaceabove">Changes the state of the current thread and exits that thread’s critical section at the same time. </p>
<p class="spaceabove"><pre>
OSErr SetThreadStateEndCritical (
   <a href="reference.html#//apple_ref/doc/c_ref/ThreadID">ThreadID</a> threadToSet,
   <a href="reference.html#//apple_ref/doc/c_ref/ThreadState">ThreadState</a> newState,
   <a href="reference.html#//apple_ref/doc/c_ref/ThreadID">ThreadID</a> suggestedThread
);
</pre></p>
<h5 class="tight">Parameters</h5><dl class="termdef">
<dt><em>threadToSet</em></dt>
<dd><p>The thread ID of the thread whose state is to be changed. </p></dd>
<dt><em>newState</em></dt>
<dd><p>The new state for the thread. You can specify ready to execute (<code>kReadyThreadState</code>), stopped (<code>kStoppedThreadState</code>) or executing (<code>kRunningThreadState</code>). </p></dd>
<dt><em>suggestedThread</em></dt>
<dd><p>The thread ID of the next thread to run. You specify this thread if you are changing the state of the currently executing thread to stopped or ready to run. Pass <code>kNoThreadID</code> if you do not want to specify a particular thread to run next. In this case, the Thread Manager schedules the next available thread to run.</p></dd></dl>
<h5 class="tight">Return Value</h5>
<p>A result code. See <span class="content_text"><a href="reference.html#//apple_ref/doc/uid/TP30000084-CH5g-RCM0102">“Thread Manager Result Codes.”</a></span></p>
<h5 class="tight">Discussion</h5>
<p>The <code>SetThreadStateEndCritical</code> function does in one step the same thing that <code>ThreadEndCritical</code> and <code>SetThreadState</code> functions do in two steps.</p>
<p>Historically, the primary purpose of the <code>SetThreadStateEndCritical</code> function was to close the scheduling window at the end of a critical section. A preemptive thread that was waiting while the critical section of code was executing could begin executing before you changed the state of the current thread to stopped with the <code>SetThreadState</code> function. Obviously, because the Thread Manager no longer supports preemptive threads, this function is no longer necessary to close the scheduling window, but you can still use it to change the state of a thread and exit a critical section in one step instead of two. </p>
<p>When you change the state of the currently executing thread, the Thread Manager schedules the thread you specify with the <code>suggestedThread</code> parameter. If this thread is unavailable or if you pass <code>kNoThreadID</code>, the Thread Manager schedules the next available thread.</p>
<p>To mark a section of code as critical, use the  <code><a href="reference.html#//apple_ref/c/func/ThreadBeginCritical">ThreadBeginCritical</a></code>  and the  <code><a href="reference.html#//apple_ref/c/func/ThreadEndCritical">ThreadEndCritical</a></code>  functions.</p>
<p>To change the state of any thread, use the  <code><a href="reference.html#//apple_ref/c/func/SetThreadState">SetThreadState</a></code>  function. </p><h5 class="tight">Special Considerations</h5><p>Active development with the Thread Manager is not recommended. The API is intended only for developers who are porting their applications to Mac OS X and whose code relies on the cooperative threading model. If you are writing a new Carbon application, you should use POSIX threads or the Multiprocessing Services API instead. See <em><a href="../../../../Cocoa/Conceptual/Multithreading/index.html#//apple_ref/doc/uid/10000057i" target="_top">Threading Programming Guide</a></em> for more information.</p>
<h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.0 and later.</li></ul><h5 class="tight">Declared In</h5><code>Threads.h</code><a name="//apple_ref/c/func/SetThreadSwitcher" title="SetThreadSwitcher"></a><a name="//apple_ref/doc/c_ref/SetThreadSwitcher" title="SetThreadSwitcher"></a><a name="//apple_ref/doc/uid/TP30000084-CH1g-F07003" title="SetThreadSwitcher"></a>
<a name="//apple_ref/doc/uid/TP30000084-CH1g-DontLinkElementID_42"></a><h3 class="tight">SetThreadSwitcher</h3>
<p class="spaceabove">Installs a custom context-switching function for any thread.</p>
<p><i style="background-color: #e9e9e9; padding: 5px; margin-top: 10px; margin-bottom:5px;">Modified</i></p>
<p class="spaceabove"><pre>
OSErr SetThreadSwitcher (
   <a href="reference.html#//apple_ref/doc/c_ref/ThreadID">ThreadID</a> thread,
   <a href="reference.html#//apple_ref/doc/c_ref/ThreadSwitchTPP">ThreadSwitchTPP</a> threadSwitcher,
   void *switchProcParam,
   <!--a-->Boolean<!--/a--> inOrOut
);
</pre></p>
<h5 class="tight">Parameters</h5><dl class="termdef">
<dt><em>thread</em></dt>
<dd><p>The thread ID of the thread to associate with a context-switching function. </p></dd>
<dt><em>threadSwitcher</em></dt>
<dd><p>A pointer to the context-switching function. </p></dd>
<dt><em>switchProcParam</em></dt>
<dd><p>A pointer to a thread-specific parameter that you pass to the context-switching function. </p></dd>
<dt><em>inOrOut</em></dt>
<dd><p>A Boolean value that indicates whether the Thread Manager calls the context-switching function when the specified thread switches in (<code>True</code>) or when it is switched out by another thread (<code>False</code>). </p></dd></dl>
<h5 class="tight">Return Value</h5>
<p>A result code. See <span class="content_text"><a href="reference.html#//apple_ref/doc/uid/TP30000084-CH5g-RCM0102">“Thread Manager Result Codes.”</a></span></p>
<h5 class="tight">Discussion</h5>
<p>The custom switching function allows you to save context information in addition to the default context information that the Thread Manager automatically saves when it switches contexts. The default context information consists of the CPU registers, the FPU registers (if any), and the location of the thread’s context. </p>
<p>You must actually define two context-switching functions, one for leaving a thread and another for entering a thread. When leaving a thread, you call the outer context-switching function to save additional context information. When reentering a thread, you call the inner context-switching function to restore the extra information that was saved on exit. Use the <code>inOrOut</code> parameter of the <code>SetThreadSwitcher</code> function to specify which type of context-switching function is being installed. </p>
<p>You can pass a different <code>switchProcParam</code> parameter to each thread, which allows you to write a single, application-wide custom switching function and then pass any thread-specific information when the Thread Manager calls the switching function for that thread.</p>
<p>The <code>SetThreadSwitcher</code> function automatically disables scheduling to avoid any reentrancy problems with the custom switching function. Therefore, in the custom switching function, you should make no yield calls or other calls that would cause scheduling to occur.</p>
<p>For Carbon applications, the pointer to your thread switcher function must be a universal procedure pointer (UPP).</p>
<p>For more information on the custom context-switching function, see the  <code><a href="reference.html#//apple_ref/c/tdef/ThreadSwitchProcPtr">ThreadSwitchProcPtr</a></code>  function. </p><h5 class="tight">Special Considerations</h5><p>Active development with the Thread Manager is not recommended. The API is intended only for developers who are porting their applications to Mac OS X and whose code relies on the cooperative threading model. If you are writing a new Carbon application, you should use POSIX threads or the Multiprocessing Services API instead. See <em><a href="../../../../Cocoa/Conceptual/Multithreading/index.html#//apple_ref/doc/uid/10000057i" target="_top">Threading Programming Guide</a></em> for more information.</p>

<h5 class="tight">Carbon Porting Notes</h5>
<p>For Carbon applications, you must create and pass a universal procedure pointer (UPP) to specify the thread switcher callback. Use the <code><a href="reference.html#//apple_ref/c/func/NewThreadSwitchUPP">NewThreadSwitchUPP</a></code> and <code><a href="reference.html#//apple_ref/c/func/DisposeThreadSwitchUPP">DisposeThreadSwitchUPP</a></code> functions to create and remove the UPP.</p><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.0 and later.</li></ul><h5 class="tight">Declared In</h5><code>Threads.h</code><a name="//apple_ref/c/func/SetThreadTerminator" title="SetThreadTerminator"></a><a name="//apple_ref/doc/c_ref/SetThreadTerminator" title="SetThreadTerminator"></a><a name="//apple_ref/doc/uid/TP30000084-CH1g-F07004" title="SetThreadTerminator"></a>
<a name="//apple_ref/doc/uid/TP30000084-CH1g-DontLinkElementID_43"></a><h3 class="tight">SetThreadTerminator</h3>
<p class="spaceabove">Installs a custom thread-termination function for a thread.</p>
<p><i style="background-color: #e9e9e9; padding: 5px; margin-top: 10px; margin-bottom:5px;">Modified</i></p>
<p class="spaceabove"><pre>
OSErr SetThreadTerminator (
   <a href="reference.html#//apple_ref/doc/c_ref/ThreadID">ThreadID</a> thread,
   <a href="reference.html#//apple_ref/doc/c_ref/ThreadTerminationTPP">ThreadTerminationTPP</a> threadTerminator,
   void *terminationProcParam
);
</pre></p>
<h5 class="tight">Parameters</h5><dl class="termdef">
<dt><em>thread</em></dt>
<dd><p>The thread ID of the thread to associate with the thread-termination function. </p></dd>
<dt><em>threadTerminator</em></dt>
<dd><p>A pointer to the thread-termination function. </p></dd>
<dt><em>terminationProcParam</em></dt>
<dd><p>A pointer to a thread-specific parameter that you pass to the thread-termination function. </p></dd></dl>
<h5 class="tight">Return Value</h5>
<p>A result code. See <span class="content_text"><a href="reference.html#//apple_ref/doc/uid/TP30000084-CH5g-RCM0102">“Thread Manager Result Codes.”</a></span></p>
<h5 class="tight">Discussion</h5>
<p>The Thread Manager calls the custom termination function whenever the specified thread completes execution of its code or when you manually dispose of the thread with the  <code><a href="reference.html#//apple_ref/c/func/DisposeThread">DisposeThread</a></code>  function. </p>
<p>You can pass a different <code>terminationProcParam</code> parameter to each thread, which allows you to write a single, application-wide custom thread-termination function and then pass any thread-specific information when the Thread Manager calls the termination function for that thread.</p>
<p>For Carbon applications, the pointer to your thread terminator function must be a universal procedure pointer (UPP).</p>
<p>For more information on the custom thread-termination function, see the  <code><a href="reference.html#//apple_ref/c/tdef/ThreadTerminationProcPtr">ThreadTerminationProcPtr</a></code>  function. </p><h5 class="tight">Special Considerations</h5><p>Active development with the Thread Manager is not recommended. The API is intended only for developers who are porting their applications to Mac OS X and whose code relies on the cooperative threading model. If you are writing a new Carbon application, you should use POSIX threads or the Multiprocessing Services API instead. See <em><a href="../../../../Cocoa/Conceptual/Multithreading/index.html#//apple_ref/doc/uid/10000057i" target="_top">Threading Programming Guide</a></em> for more information.</p>

<h5 class="tight">Carbon Porting Notes</h5>
<p>For Carbon applications, you must create and pass a universal procedure pointer (UPP) to specify the thread terminator callback. Use the <code><a href="reference.html#//apple_ref/c/func/NewThreadTerminationUPP">NewThreadTerminationUPP</a></code> and <code><a href="reference.html#//apple_ref/c/func/DisposeThreadTerminationUPP">DisposeThreadTerminationUPP</a></code> functions to create and remove the UPP.</p><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.0 and later.</li></ul><h5 class="tight">Declared In</h5><code>Threads.h</code><a name="//apple_ref/c/func/ThreadBeginCritical" title="ThreadBeginCritical"></a><a name="//apple_ref/doc/c_ref/ThreadBeginCritical" title="ThreadBeginCritical"></a><a name="//apple_ref/doc/uid/TP30000084-CH1g-F07879" title="ThreadBeginCritical"></a>
<a name="//apple_ref/doc/uid/TP30000084-CH1g-DontLinkElementID_44"></a><h3 class="tight">ThreadBeginCritical</h3>
<p class="spaceabove">Indicates that the thread is entering a critical code section.</p>
<p class="spaceabove"><pre>
OSErr ThreadBeginCritical (
   void
);
</pre></p>
<h5 class="tight">Return Value</h5>
<p>A result code. See <span class="content_text"><a href="reference.html#//apple_ref/doc/uid/TP30000084-CH5g-RCM0102">“Thread Manager Result Codes.”</a></span></p>
<h5 class="tight">Discussion</h5>
<p>The <code>ThreadBeginCritical</code> function disables scheduling by marking the beginning of a section of critical code. That is, no other threads in the current application can run—even if the current thread yields control—until the current thread exits the critical section (by calling the <code>ThreadEndCritical</code> function). Disabling scheduling allows the currently executing function to look at or change shared or global data safely. You can nest critical sections within a thread.</p>
<p>To mark the end of a critical code section and turn scheduling back on, use the  <code><a href="reference.html#//apple_ref/c/func/ThreadEndCritical">ThreadEndCritical</a></code>  function. If you also need to set the state of the current thread before scheduling is turned back on, use the  <code><a href="reference.html#//apple_ref/c/func/SetThreadStateEndCritical">SetThreadStateEndCritical</a></code>  function.  </p><h5 class="tight">Special Considerations</h5><p>Active development with the Thread Manager is not recommended. The API is intended only for developers who are porting their applications to Mac OS X and whose code relies on the cooperative threading model. If you are writing a new Carbon application, you should use POSIX threads or the Multiprocessing Services API instead. See <em><a href="../../../../Cocoa/Conceptual/Multithreading/index.html#//apple_ref/doc/uid/10000057i" target="_top">Threading Programming Guide</a></em> for more information.</p>
<h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.0 and later.</li></ul><h5 class="tight">Declared In</h5><code>Threads.h</code><a name="//apple_ref/c/func/ThreadCurrentStackSpace" title="ThreadCurrentStackSpace"></a><a name="//apple_ref/doc/c_ref/ThreadCurrentStackSpace" title="ThreadCurrentStackSpace"></a><a name="//apple_ref/doc/uid/TP30000084-CH1g-F07880" title="ThreadCurrentStackSpace"></a>
<a name="//apple_ref/doc/uid/TP30000084-CH1g-DontLinkElementID_45"></a><h3 class="tight">ThreadCurrentStackSpace</h3>
<p class="spaceabove">Determines the amount of stack space that is available for any thread in your application. </p>
<p class="spaceabove"><pre>
OSErr ThreadCurrentStackSpace (
   <a href="reference.html#//apple_ref/doc/c_ref/ThreadID">ThreadID</a> thread,
   <a href="../../../../QuickTime/Reference/QTRef_DataTypes/Reference/reference.html#//apple_ref/doc/c_ref/ByteCount" target="_top">ByteCount</a> *freeStack
);
</pre></p>
<h5 class="tight">Parameters</h5><dl class="termdef">
<dt><em>thread</em></dt>
<dd><p>The thread ID of the thread about which you want information. </p></dd>
<dt><em>freeStack</em></dt>
<dd><p>On return, a pointer to the amount of stack space (in bytes) that is available to the specified thread. </p></dd></dl>
<h5 class="tight">Return Value</h5>
<p>A result code. See <span class="content_text"><a href="reference.html#//apple_ref/doc/uid/TP30000084-CH5g-RCM0102">“Thread Manager Result Codes.”</a></span></p>
<h5 class="tight">Discussion</h5>
<p>This function is primarily useful during debugging since you determine the maximum amount of stack space you need for any particular thread before you ship your application. However, if your application calls a recursive function that could call itself many times, you might want to use <code>ThreadCurrentStackSpace</code> to keep track of the stack space and take appropriate action if it becomes too low. </p>
<p>To determine the default size that the Thread Manager assigns to threads use the  <code><a href="reference.html#//apple_ref/c/func/GetDefaultThreadStackSize">GetDefaultThreadStackSize</a></code>  function. </p><h5 class="tight">Special Considerations</h5><p>Active development with the Thread Manager is not recommended. The API is intended only for developers who are porting their applications to Mac OS X and whose code relies on the cooperative threading model. If you are writing a new Carbon application, you should use POSIX threads or the Multiprocessing Services API instead. See <em><a href="../../../../Cocoa/Conceptual/Multithreading/index.html#//apple_ref/doc/uid/10000057i" target="_top">Threading Programming Guide</a></em> for more information.</p>
<h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.0 and later.</li></ul><h5 class="tight">Declared In</h5><code>Threads.h</code><a name="//apple_ref/c/func/ThreadEndCritical" title="ThreadEndCritical"></a><a name="//apple_ref/doc/c_ref/ThreadEndCritical" title="ThreadEndCritical"></a><a name="//apple_ref/doc/uid/TP30000084-CH1g-F07881" title="ThreadEndCritical"></a>
<a name="//apple_ref/doc/uid/TP30000084-CH1g-DontLinkElementID_46"></a><h3 class="tight">ThreadEndCritical</h3>
<p class="spaceabove">Indicates that the thread is leaving a critical code section.</p>
<p class="spaceabove"><pre>
OSErr ThreadEndCritical (
   void
);
</pre></p>
<h5 class="tight">Return Value</h5>
<p>A result code. See <span class="content_text"><a href="reference.html#//apple_ref/doc/uid/TP30000084-CH5g-RCM0102">“Thread Manager Result Codes.”</a></span></p>
<h5 class="tight">Discussion</h5>
<p>After a call to the Thread, all scheduling operations are now available to the application.</p>
<p>Use the  <code><a href="reference.html#//apple_ref/c/func/ThreadBeginCritical">ThreadBeginCritical</a></code>  function to mark the beginning of a critical code section and turn scheduling off.</p>
<p>If you need to set the state of the current thread before scheduling is turned back on, use the  <code><a href="reference.html#//apple_ref/c/func/SetThreadStateEndCritical">SetThreadStateEndCritical</a></code>  function.  </p><h5 class="tight">Special Considerations</h5><p>Active development with the Thread Manager is not recommended. The API is intended only for developers who are porting their applications to Mac OS X and whose code relies on the cooperative threading model. If you are writing a new Carbon application, you should use POSIX threads or the Multiprocessing Services API instead. See <em><a href="../../../../Cocoa/Conceptual/Multithreading/index.html#//apple_ref/doc/uid/10000057i" target="_top">Threading Programming Guide</a></em> for more information.</p>
<h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.0 and later.</li></ul><h5 class="tight">Declared In</h5><code>Threads.h</code><a name="//apple_ref/c/func/YieldToAnyThread" title="YieldToAnyThread"></a><a name="//apple_ref/doc/c_ref/YieldToAnyThread" title="YieldToAnyThread"></a><a name="//apple_ref/doc/uid/TP30000084-CH1g-F08224" title="YieldToAnyThread"></a>
<a name="//apple_ref/doc/uid/TP30000084-CH1g-DontLinkElementID_47"></a><h3 class="tight">YieldToAnyThread</h3>
<p class="spaceabove">Relinquishes the current thread’s control.</p>
<p class="spaceabove"><pre>
OSErr YieldToAnyThread (
   void
);
</pre></p>
<h5 class="tight">Return Value</h5>
<p>A result code. See <span class="content_text"><a href="reference.html#//apple_ref/doc/uid/TP30000084-CH5g-RCM0102">“Thread Manager Result Codes.”</a></span></p>
<h5 class="tight">Discussion</h5>
<p>The <code>YieldToAnyThread</code> function invokes the Thread Manager’s scheduling mechanism. The current thread relinquishes control and the Thread Manager schedules the next available thread.</p>
<p>The current thread is suspended in the ready state and awaits rescheduling when the CPU is available. When the suspended thread is scheduled again, <code>YieldToAnyThread</code> regains control and returns to the function that called it.</p>
<p>If you have installed a custom scheduler, the Thread Manager passes it the thread ID of the suspended thread.</p>
<p>In each thread you must make one or more strategically placed calls to relinquish control to another thread. You can either make this yield call or another yield call such as <code>YieldToThread</code>; or you can make a call such as <code>SetThreadState</code> to explicitly change the state of the thread.</p>
<p>Threads must yield in the CPU addressing mode (24-bit or 32-bit) in which the application was launched.</p>
<p>To relinquish control to a specific thread, use the  <code><a href="reference.html#//apple_ref/c/func/YieldToThread">YieldToThread</a></code>  function.</p>
<p>To change the state of a specified thread, use the  <code><a href="reference.html#//apple_ref/c/func/SetThreadState">SetThreadState</a></code>  function. </p><h5 class="tight">Special Considerations</h5><p>Active development with the Thread Manager is not recommended. The API is intended only for developers who are porting their applications to Mac OS X and whose code relies on the cooperative threading model. If you are writing a new Carbon application, you should use POSIX threads or the Multiprocessing Services API instead. See <em><a href="../../../../Cocoa/Conceptual/Multithreading/index.html#//apple_ref/doc/uid/10000057i" target="_top">Threading Programming Guide</a></em> for more information.</p>
<h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.0 and later.</li></ul><h5 class="tight">Declared In</h5><code>Threads.h</code><a name="//apple_ref/c/func/YieldToThread" title="YieldToThread"></a><a name="//apple_ref/doc/c_ref/YieldToThread" title="YieldToThread"></a><a name="//apple_ref/doc/uid/TP30000084-CH1g-F08225" title="YieldToThread"></a>
<a name="//apple_ref/doc/uid/TP30000084-CH1g-DontLinkElementID_48"></a><h3 class="tight">YieldToThread</h3>
<p class="spaceabove">Relinquishes the current thread’s control to a particular thread.</p>
<p class="spaceabove"><pre>
OSErr YieldToThread (
   <a href="reference.html#//apple_ref/doc/c_ref/ThreadID">ThreadID</a> suggestedThread
);
</pre></p>
<h5 class="tight">Parameters</h5><dl class="termdef">
<dt><em>suggestedThread</em></dt>
<dd><p>The ID of the thread to yield control to. </p></dd></dl>
<h5 class="tight">Return Value</h5>
<p>A result code. See <span class="content_text"><a href="reference.html#//apple_ref/doc/uid/TP30000084-CH5g-RCM0102">“Thread Manager Result Codes.”</a></span></p>
<h5 class="tight">Discussion</h5>
<p>The <code>YieldToThread</code> function invokes the Thread Manager’s scheduling mechanism. The current thread relinquishes control and passes the thread ID of a thread for the Thread Manager to schedule. The Thread Manager schedules this thread if it is available. Otherwise, the Thread Manager schedules the next available thread.</p>
<p>The current thread is suspended in the ready state and awaits rescheduling when the CPU is available. When the suspended thread is scheduled again, <code>YieldToThread</code> regains control and returns to the function that called it.</p>
<p>If you have installed a custom scheduler, the Thread Manager passes it the thread ID of the suspended thread.</p>
<p>In each thread you must make one or more strategically placed calls to relinquish control to another thread. You can either make this yield call or another yield call such as <code>YieldToAnyThread</code>; or you can make a call such as <code>SetThreadState</code> to explicitly change the state of the thread.</p>
<p>Threads must yield in the CPU addressing mode (24-bit or 32-bit) in which the application was launched.</p>
<p>To relinquish control without naming a specific thread, use the  <code><a href="reference.html#//apple_ref/c/func/YieldToAnyThread">YieldToAnyThread</a></code>  function.</p>
<p>To change the state of a specified thread, use the  <code><a href="reference.html#//apple_ref/c/func/SetThreadState">SetThreadState</a></code>  function. </p><h5 class="tight">Special Considerations</h5><p>Active development with the Thread Manager is not recommended. The API is intended only for developers who are porting their applications to Mac OS X and whose code relies on the cooperative threading model. If you are writing a new Carbon application, you should use POSIX threads or the Multiprocessing Services API instead. See <em><a href="../../../../Cocoa/Conceptual/Multithreading/index.html#//apple_ref/doc/uid/10000057i" target="_top">Threading Programming Guide</a></em> for more information.</p>
<h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.0 and later.</li></ul><h5 class="tight">Declared In</h5><code>Threads.h</code><a name="//apple_ref/doc/uid/TP30000084-CH2g-138267" title="Callbacks"></a><a name="//apple_ref/doc/uid/TP30000084-CH2g-TPXREF112" title="Callbacks"></a><h2>Callbacks</h2>







<a name="//apple_ref/c/tdef/DebuggerDisposeThreadProcPtr" title="DebuggerDisposeThreadProcPtr"></a><a name="//apple_ref/doc/c_ref/DebuggerDisposeThreadProcPtr" title="DebuggerDisposeThreadProcPtr"></a><a name="//apple_ref/doc/uid/TP30000084-CH2g-F09655" title="DebuggerDisposeThreadProcPtr"></a><a name="//apple_ref/doc/uid/TP30000084-CH2g-DontLinkElementID_49"></a><h3 class="tight">DebuggerDisposeThreadProcPtr</h3>
<p class="spaceabove">Defines a pointer to a dispose thread debugging
callback function.  A dispose thread debugging callback function
is a debugging function that the Thread Manager calls whenever it
disposes of a thread.</p>
<p class="spaceabove"><pre>
typedef void (*DebuggerDisposeThreadProcPtr)
(
   <a href="reference.html#//apple_ref/doc/c_ref/ThreadID">ThreadID</a> threadDeleted
);
</pre></p>
<p>If you name your function <code>MyDebuggerDisposeThreadProc</code>,
you would declare it like this:</p>
<p><pre>
void MyDebuggerDisposeThreadProcPtr (
   <a href="reference.html#//apple_ref/doc/c_ref/ThreadID">ThreadID</a> threadDeleted
);
</pre></p>
<h5 class="tight">Parameters</h5><dl class="termdef">
<dt><em>threadDeleted</em></dt>
<dd><p>The thread ID of the thread being disposed
of. </p></dd></dl>
<h5 class="tight">Return Value</h5>

<h5 class="tight">Discussion</h5>
<p>The <code>MyDebuggerDisposeThreadCallback</code> function
is one of three debugging functions that you can install with the
 <code><a href="reference.html#//apple_ref/c/func/SetDebuggerNotificationProcs">SetDebuggerNotificationProcs</a></code> 
function. The Thread Manager calls <code>MyDebuggerDisposeThreadCallback</code> whenever
an application disposes of a thread. The thread manager calls this
debugging function whether you manually call  <code><a href="reference.html#//apple_ref/c/func/DisposeThread">DisposeThread</a></code>  to dispose of a thread
or if a thread finishes executing its code and the Thread Manager
automatically disposes of it. </p><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.0 and later.</li></ul><h5 class="tight">Declared In</h5><code>Threads.h</code><a name="//apple_ref/c/tdef/DebuggerNewThreadProcPtr" title="DebuggerNewThreadProcPtr"></a><a name="//apple_ref/doc/c_ref/DebuggerNewThreadProcPtr" title="DebuggerNewThreadProcPtr"></a><a name="//apple_ref/doc/uid/TP30000084-CH2g-F09656" title="DebuggerNewThreadProcPtr"></a><a name="//apple_ref/doc/uid/TP30000084-CH2g-DontLinkElementID_50"></a><h3 class="tight">DebuggerNewThreadProcPtr</h3>
<p class="spaceabove">Defines a pointer to a new thread debugging callback
function.  A new thread debugging callback function is a debugging
function that the Thread Manager calls whenever it creates a new
thread.</p>
<p class="spaceabove"><pre>
typedef void (*DebuggerNewThreadProcPtr)
(
   <a href="reference.html#//apple_ref/doc/c_ref/ThreadID">ThreadID</a> threadCreated
);
</pre></p>
<p>If you name your function <code>MyDebuggerNewThreadProc</code>,
you would declare it like this:</p>
<p><pre>
void MyDebuggerNewThreadProcPtr (
   <a href="reference.html#//apple_ref/doc/c_ref/ThreadID">ThreadID</a> threadCreated
);
</pre></p>
<h5 class="tight">Parameters</h5><dl class="termdef">
<dt><em>threadCreated</em></dt>
<dd><p>The thread ID of the thread being created. </p></dd></dl>
<h5 class="tight">Return Value</h5>

<h5 class="tight">Discussion</h5>
<p>The <code>MyDebuggerNewThreadCallback</code> function
is one of three debugging functions that you can install with the
 <code><a href="reference.html#//apple_ref/c/func/SetDebuggerNotificationProcs">SetDebuggerNotificationProcs</a></code> 
function. The Thread Manager calls <code>MyDebuggerNewThreadCallback</code> whenever
an application creates or allocates a new thread with the  <code><a href="reference.html#//apple_ref/c/func/NewThread">NewThread</a></code>  function.
The Thread Manager does not call <code>MyDebuggerNewThreadCallback</code> when
an application creates a thread pool with the <code>CreateThreadPool</code> function. </p><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.0 and later.</li></ul><h5 class="tight">Declared In</h5><code>Threads.h</code><a name="//apple_ref/c/tdef/DebuggerThreadSchedulerProcPtr" title="DebuggerThreadSchedulerProcPtr"></a><a name="//apple_ref/doc/c_ref/DebuggerThreadSchedulerProcPtr" title="DebuggerThreadSchedulerProcPtr"></a><a name="//apple_ref/doc/uid/TP30000084-CH2g-F09657" title="DebuggerThreadSchedulerProcPtr"></a><a name="//apple_ref/doc/uid/TP30000084-CH2g-DontLinkElementID_51"></a><h3 class="tight">DebuggerThreadSchedulerProcPtr</h3>
<p class="spaceabove">Defines a pointer to a thread scheduler debugging
callback function.  A thread scheduler debugging callback function
is a debugging function that the Thread Manager calls whenever a
thread is scheduled.</p>
<p class="spaceabove"><pre>
typedef ThreadID (*DebuggerThreadSchedulerProcPtr)
(
   <!--a-->SchedulerInfoRecPtr<!--/a--> schedulerInfo
);
</pre></p>
<p>If you name your function <code>MyDebuggerThreadSchedulerProc</code>,
you would declare it like this:</p>
<p><pre>
ThreadID MyDebuggerThreadSchedulerProcPtr
(
   <!--a-->SchedulerInfoRecPtr<!--/a--> schedulerInfo
);
</pre></p>
<h5 class="tight">Parameters</h5><dl class="termdef">
<dt><em>schedulerInfo</em></dt>
<dd><p>A pointer to a scheduler information structure
that the <code>SetDebuggerNotificationProcs</code> function
passes to the <code>MyDebuggerThreadSchedulerCallback</code> function.
Among other information, the scheduler information structure contains
the ID of the current thread and the ID of the thread that the Thread
Manager has scheduled to run next. </p></dd></dl>
<h5 class="tight">Return Value</h5>
<p>See the description of the <code>ThreadID</code> data type.</p>
<h5 class="tight">Discussion</h5>
<p>The <code>MyDebuggerThreadSchedulerCallback</code> function
is one of three debugging functions that you can install with the
 <code><a href="reference.html#//apple_ref/c/func/SetDebuggerNotificationProcs">SetDebuggerNotificationProcs</a></code> 
function. The Thread Manager calls <code>MyDebuggerThreadSchedulerCallback</code> whenever
an application schedules a new thread to run. The <code>MyDebuggerThreadSchedulerCallback</code> function
gets the last look at the thread being scheduled&#8212;that is, the
Thread Manager calls this function after the Thread Manager default
scheduling mechanism and a custom scheduler, if you have installed
one, decide on the next thread to schedule. </p>
<p>If you wish, you can use this debugging callback function
to schedule a different thread than that chosen by the Thread Manager
and any custom scheduling function. The <code>MyDebuggerThreadSchedulerCallback</code> returns
the thread ID of the next thread to schedule. The <code>MyDebuggerThreadSchedulerCallback</code> can
specify <code>kNoThreadID</code> for
the thread ID if you do not want to change the decision of the Thread
Manager default scheduler or a custom scheduler.</p>
<p>To schedule a thread, use functions such as  <code><a href="reference.html#//apple_ref/c/func/YieldToAnyThread">YieldToAnyThread</a></code> ,  <code><a href="reference.html#//apple_ref/c/func/YieldToThread">YieldToThread</a></code> , and  <code><a href="reference.html#//apple_ref/c/func/SetThreadState">SetThreadState</a></code>. </p><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.0 and later.</li></ul><h5 class="tight">Declared In</h5><code>Threads.h</code><a name="//apple_ref/c/tdef/ThreadEntryProcPtr" title="ThreadEntryProcPtr"></a><a name="//apple_ref/doc/c_ref/ThreadEntryProcPtr" title="ThreadEntryProcPtr"></a><a name="//apple_ref/doc/uid/TP30000084-CH2g-F09658" title="ThreadEntryProcPtr"></a><a name="//apple_ref/doc/uid/TP30000084-CH2g-DontLinkElementID_52"></a><h3 class="tight">ThreadEntryProcPtr</h3>
<p class="spaceabove">Defines a pointer to a thread entry callback
function.  Your thread entry callback function provides an entry
point to a thread that you create in your application.</p>
<p class="spaceabove"><pre>
typedef voidPtr (*ThreadEntryProcPtr)
(
   void * threadParam
);
</pre></p>
<p>If you name your function <code>MyThreadEntryProc</code>,
you would declare it like this:</p>
<p><pre>
voidPtr MyThreadEntryProcPtr (
   void * threadParam
);
</pre></p>
<h5 class="tight">Parameters</h5><dl class="termdef">
<dt><em>threadParam</em></dt>
<dd><p>A pointer to a <code>void</code> data
structure passed to this function by the <code>NewThread</code> function. </p></dd></dl>
<h5 class="tight">Return Value</h5>

<h5 class="tight">Discussion</h5>
<p>When you create or allocate a new thread with the <code>NewThread</code> function,
you pass the name of this entry function. You also pass a parameter
that the Thread Manager passes on to the <code>MyThreadEntryCallback</code> function.
You can use this parameter to pass thread-specific information to
the newly created or allocated thread. For example, you could pass something
like A5 information or the address of a window to update. Or you
could use this parameter to specify local storage for a thread that
other threads could access. </p>
<p>When the code in a thread finishes executing, the Thread Manager
automatically calls the  <code><a href="reference.html#//apple_ref/c/func/DisposeThread">DisposeThread</a></code> 
function to dispose of the thread. The <code>MyThreadEntryCallback</code> function passes
its function result to <code>DisposeThread</code>.
The <code>DisposeThread</code> function
passes this result back to the <code>NewThread</code> function
that called <code>MyThreadEntryCallback</code> to
begin with.</p>
<p>This mechanism allows you to spawn a thread that does some
work and then continue with your original thread. When the spawned
thread is finished doing its work&#8212;for example a calculation&#8212;it
returns the result to the original thread.  </p><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.0 and later.</li></ul><h5 class="tight">Declared In</h5><code>Threads.h</code><a name="//apple_ref/c/tdef/ThreadSchedulerProcPtr" title="ThreadSchedulerProcPtr"></a><a name="//apple_ref/doc/c_ref/ThreadSchedulerProcPtr" title="ThreadSchedulerProcPtr"></a><a name="//apple_ref/doc/uid/TP30000084-CH2g-F09659" title="ThreadSchedulerProcPtr"></a><a name="//apple_ref/doc/uid/TP30000084-CH2g-DontLinkElementID_53"></a><h3 class="tight">ThreadSchedulerProcPtr</h3>
<p class="spaceabove">Defines a pointer to a thread scheduler callback
function.  Your thread scheduler callback function supplements the
Thread Manager default scheduling mechanism.</p>
<p class="spaceabove"><pre>
typedef ThreadID (*ThreadSchedulerProcPtr)
(
   <!--a-->SchedulerInfoRecPtr<!--/a--> schedulerInfo
);
</pre></p>
<p>If you name your function <code>MyThreadSchedulerProc</code>,
you would declare it like this:</p>
<p><pre>
ThreadID MyThreadSchedulerProcPtr (
   <!--a-->SchedulerInfoRecPtr<!--/a--> schedulerInfo
);
</pre></p>
<h5 class="tight">Parameters</h5><dl class="termdef">
<dt><em>schedulerInfo</em></dt>
<dd><p>A pointer to the scheduler information structure
that the Thread Manager uses to pass information to <code>MyThreadSchedulerCallback</code>. </p></dd></dl>
<h5 class="tight">Return Value</h5>
<p>See the description of the <code>ThreadID</code> data type.</p>
<h5 class="tight">Discussion</h5>
<p>The <code>MyThreadSchedulerCallback</code> function
does not supplant the Thread Manager scheduling mechanism but rather
works in conjunction with it.</p>
<p>Whenever scheduling occurs, the Thread Manager passes a scheduler
information structure to <code>MyThreadSchedulerCallback</code>.
Among other information, the scheduler information structure contains
the thread ID of the current thread and the thread ID of the thread
that the application has scheduled to run next. </p>
<p>The <code>MyThreadSchedulerCallback</code> function
returns to the Thread Manager the thread ID of the thread that it
has chosen to schedule and the Thread Manager does the actual scheduling.
If <code>MyThreadSchedulerCallback</code> decides
not to schedule a thread, it returns the constant <code>kNoThreadID</code> and
the Thread Manager default scheduling mechanism schedules the next
thread.</p>
<p>When the <code>SetThreadScheduler</code> function
installs the custom scheduler, it automatically disables scheduling
to avoid any reentrancy problems. Therefore, in the custom scheduler, you
should make no yield calls or other calls that would cause scheduling
to occur.  </p><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.0 and later.</li></ul><h5 class="tight">Declared In</h5><code>Threads.h</code><a name="//apple_ref/c/tdef/ThreadSwitchProcPtr" title="ThreadSwitchProcPtr"></a><a name="//apple_ref/doc/c_ref/ThreadSwitchProcPtr" title="ThreadSwitchProcPtr"></a><a name="//apple_ref/doc/uid/TP30000084-CH2g-F09660" title="ThreadSwitchProcPtr"></a><a name="//apple_ref/doc/uid/TP30000084-CH2g-DontLinkElementID_54"></a><h3 class="tight">ThreadSwitchProcPtr</h3>
<p class="spaceabove">Defines a pointer to a thread switch callback
function.  Your thread switch callback function adds to the thread
context information that the Thread Manager saves and restores.</p>
<p class="spaceabove"><pre>
typedef void (*ThreadSwitchProcPtr) (
   <a href="reference.html#//apple_ref/doc/c_ref/ThreadID">ThreadID</a> threadBeingSwitched,
   void * switchProcParam
);
</pre></p>
<p>If you name your function <code>MyThreadSwitchProc</code>,
you would declare it like this:</p>
<p><pre>
void MyThreadSwitchProcPtr (
   <a href="reference.html#//apple_ref/doc/c_ref/ThreadID">ThreadID</a> threadBeingSwitched,
   void * switchProcParam
);
</pre></p>
<h5 class="tight">Parameters</h5><dl class="termdef">
<dt><em>threadBeingSwitched</em></dt>
<dd><p>The thread ID of the thread whose context
is being switched. </p></dd>
<dt><em>switchProcParam</em></dt>
<dd><p>A pointer to a parameter that the <code>SetThreadSwitcher</code> function
passes to <code>MyThreadSwitchCallback</code>. </p></dd></dl>
<h5 class="tight">Return Value</h5>

<h5 class="tight">Discussion</h5>
<p>The custom switching function allows you to save and restore
context information in addition to the default context information
that the Thread Manager automatically saves and restores when it
switches contexts. You must actually define two context-switching functions,
one for leaving a thread and another for entering a thread. When
leaving a thread, you call the outer context-switching function
to save additional context information. When reentering a thread,
you call the inner context-switching function to restore the extra
information that was saved on exit.</p>
<p>The default context information consists of the CPU registers,
the FPU registers (if any), and the location of the thread&#8217;s context.</p>
<p>When the <code>SetThreadSwitcher</code> function
installs the custom switching function, it automatically disables
scheduling to avoid any reentrancy problems. Therefore, in the custom
switching function, you should make no yield calls or other calls
that would cause scheduling to occur.  </p><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.0 and later.</li></ul><h5 class="tight">Declared In</h5><code>Threads.h</code><a name="//apple_ref/c/tdef/ThreadTerminationProcPtr" title="ThreadTerminationProcPtr"></a><a name="//apple_ref/doc/c_ref/ThreadTerminationProcPtr" title="ThreadTerminationProcPtr"></a><a name="//apple_ref/doc/uid/TP30000084-CH2g-F09661" title="ThreadTerminationProcPtr"></a><a name="//apple_ref/doc/uid/TP30000084-CH2g-DontLinkElementID_55"></a><h3 class="tight">ThreadTerminationProcPtr</h3>
<p class="spaceabove">Defines a pointer to a thread termination callback
function.  Your thread termination callback function does additional
cleanup when the code in a thread finishes executing.</p>
<p class="spaceabove"><pre>
typedef void (*ThreadTerminationProcPtr)
(
   <a href="reference.html#//apple_ref/doc/c_ref/ThreadID">ThreadID</a> threadTerminated,
   void * terminationProcParam
);
</pre></p>
<p>If you name your function <code>MyThreadTerminationProc</code>,
you would declare it like this:</p>
<p><pre>
void MyThreadTerminationProcPtr (
   <a href="reference.html#//apple_ref/doc/c_ref/ThreadID">ThreadID</a> threadTerminated,
   void * terminationProcParam
);
</pre></p>
<h5 class="tight">Parameters</h5><dl class="termdef">
<dt><em>threadTerminated</em></dt>
<dd><p>The thread ID of the thread being disposed
of. </p></dd>
<dt><em>terminationProcParam</em></dt>
<dd><p>A pointer to a <code>void</code> data
structure that the <code>SetThreadTerminator</code> function passes
to <code>MyThreadTerminationCallback</code>. </p></dd></dl>
<h5 class="tight">Return Value</h5>

<h5 class="tight">Discussion</h5>
<p>You use the <code>SetThreadTerminator</code> function
to install the <code>MyThreadTerminationCallback</code> custom
termination function. The custom termination function allows you
to do additional cleanup when the code in a thread finishes executing
or when you call the  <code><a href="reference.html#//apple_ref/c/func/DisposeThread">DisposeThread</a></code>  function
to manually dispose of a thread.</p>
<p></p><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.0 and later.</li></ul><h5 class="tight">Declared In</h5><code>Threads.h</code><a name="//apple_ref/doc/uid/TP30000084-CH3g-106193" title="Data Types"></a><a name="//apple_ref/doc/uid/TP30000084-CH3g-TPXREF114" title="Data Types"></a><h2>Data Types</h2>
<a name="//apple_ref/c/tdef/DebuggerDisposeThreadUPP" title="DebuggerDisposeThreadUPP"></a><a name="//apple_ref/doc/c_ref/DebuggerDisposeThreadUPP" title="DebuggerDisposeThreadUPP"></a><a name="//apple_ref/doc/uid/TP30000084-CH3g-C003433" title="DebuggerDisposeThreadUPP"></a><a name="//apple_ref/doc/uid/TP30000084-CH3g-DontLinkElementID_56"></a><h3 class="tight">DebuggerDisposeThreadUPP</h3>
<p class="spaceabove"></p>
<p class="spaceabove"><pre>
typedef <a href="reference.html#//apple_ref/doc/c_ref/DebuggerDisposeThreadProcPtr">DebuggerDisposeThreadProcPtr</a> DebuggerDisposeThreadUPP;
</pre></p>
<h5 class="tight">Discussion</h5>
<p>For more information, see the description of the DebuggerDisposeThreadUPP () callback function.</p><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.0 and later.</li></ul><h5 class="tight">Declared In</h5><code>Threads.h</code>
<a name="//apple_ref/c/tdef/DebuggerDisposeThreadTPP" title="DebuggerDisposeThreadTPP"></a><a name="//apple_ref/doc/c_ref/DebuggerDisposeThreadTPP" title="DebuggerDisposeThreadTPP"></a><a name="//apple_ref/doc/uid/TP30000084-CH3g-C008008" title="DebuggerDisposeThreadTPP"></a><a name="//apple_ref/doc/uid/TP30000084-CH3g-DontLinkElementID_57"></a><h3 class="tight">DebuggerDisposeThreadTPP</h3>
<p class="spaceabove"></p>
<p class="spaceabove"><pre>
typedef <a href="reference.html#//apple_ref/doc/c_ref/DebuggerDisposeThreadUPP">DebuggerDisposeThreadUPP</a> DebuggerDisposeThreadTPP;
</pre></p>
<h5 class="tight">Discussion</h5><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.0 and later.</li></ul><h5 class="tight">Declared In</h5><code>Threads.h</code>
<a name="//apple_ref/c/tdef/DebuggerNewThreadTPP" title="DebuggerNewThreadTPP"></a><a name="//apple_ref/doc/c_ref/DebuggerNewThreadTPP" title="DebuggerNewThreadTPP"></a><a name="//apple_ref/doc/uid/TP30000084-CH3g-C008009" title="DebuggerNewThreadTPP"></a><a name="//apple_ref/doc/uid/TP30000084-CH3g-DontLinkElementID_58"></a><h3 class="tight">DebuggerNewThreadTPP</h3>
<p class="spaceabove"></p>
<p class="spaceabove"><pre>
typedef <a href="reference.html#//apple_ref/doc/c_ref/DebuggerNewThreadUPP">DebuggerNewThreadUPP</a> DebuggerNewThreadTPP;
</pre></p>
<h5 class="tight">Discussion</h5><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.0 and later.</li></ul><h5 class="tight">Declared In</h5><code>Threads.h</code>
<a name="//apple_ref/c/tdef/DebuggerNewThreadUPP" title="DebuggerNewThreadUPP"></a><a name="//apple_ref/doc/c_ref/DebuggerNewThreadUPP" title="DebuggerNewThreadUPP"></a><a name="//apple_ref/doc/uid/TP30000084-CH3g-C003434" title="DebuggerNewThreadUPP"></a><a name="//apple_ref/doc/uid/TP30000084-CH3g-DontLinkElementID_59"></a><h3 class="tight">DebuggerNewThreadUPP</h3>
<p class="spaceabove"></p>
<p class="spaceabove"><pre>
typedef <a href="reference.html#//apple_ref/doc/c_ref/DebuggerNewThreadProcPtr">DebuggerNewThreadProcPtr</a> DebuggerNewThreadUPP;
</pre></p>
<h5 class="tight">Discussion</h5>
<p>For more information, see the description of the DebuggerNewThreadUPP () callback function.</p><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.0 and later.</li></ul><h5 class="tight">Declared In</h5><code>Threads.h</code>
<a name="//apple_ref/c/tdef/DebuggerThreadSchedulerUPP" title="DebuggerThreadSchedulerUPP"></a><a name="//apple_ref/doc/c_ref/DebuggerThreadSchedulerUPP" title="DebuggerThreadSchedulerUPP"></a><a name="//apple_ref/doc/uid/TP30000084-CH3g-C003435" title="DebuggerThreadSchedulerUPP"></a><a name="//apple_ref/doc/uid/TP30000084-CH3g-DontLinkElementID_60"></a><h3 class="tight">DebuggerThreadSchedulerUPP</h3>
<p class="spaceabove"></p>
<p class="spaceabove"><pre>
typedef <a href="reference.html#//apple_ref/doc/c_ref/DebuggerThreadSchedulerProcPtr">DebuggerThreadSchedulerProcPtr</a> DebuggerThreadSchedulerUPP;
</pre></p>
<h5 class="tight">Discussion</h5>
<p>For more information, see the description of the DebuggerThreadSchedulerUPP () callback function.</p><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.0 and later.</li></ul><h5 class="tight">Declared In</h5><code>Threads.h</code>
<a name="//apple_ref/c/tdef/DebuggerThreadSchedulerTPP" title="DebuggerThreadSchedulerTPP"></a><a name="//apple_ref/doc/c_ref/DebuggerThreadSchedulerTPP" title="DebuggerThreadSchedulerTPP"></a><a name="//apple_ref/doc/uid/TP30000084-CH3g-C008010" title="DebuggerThreadSchedulerTPP"></a><a name="//apple_ref/doc/uid/TP30000084-CH3g-DontLinkElementID_61"></a><h3 class="tight">DebuggerThreadSchedulerTPP</h3>
<p class="spaceabove"></p>
<p class="spaceabove"><pre>
typedef <a href="reference.html#//apple_ref/doc/c_ref/DebuggerThreadSchedulerUPP">DebuggerThreadSchedulerUPP</a> DebuggerThreadSchedulerTPP;
</pre></p>
<h5 class="tight">Discussion</h5><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.0 and later.</li></ul><h5 class="tight">Declared In</h5><code>Threads.h</code>
<a name="//apple_ref/c/tdef/SchedulerInfoRec" title="SchedulerInfoRec"></a><a name="//apple_ref/doc/c_ref/SchedulerInfoRec" title="SchedulerInfoRec"></a><a name="//apple_ref/doc/uid/TP30000084-CH3g-C002018" title="SchedulerInfoRec"></a>
<a name="//apple_ref/doc/uid/TP30000084-CH3g-DontLinkElementID_62"></a><h3 class="tight">SchedulerInfoRec</h3>
<p class="spaceabove"></p>
<p class="spaceabove"><pre>
struct SchedulerInfoRec {
   UInt32 InfoRecSize;
   <a href="reference.html#//apple_ref/doc/c_ref/ThreadID">ThreadID</a> CurrentThreadID;
   <a href="reference.html#//apple_ref/doc/c_ref/ThreadID">ThreadID</a> SuggestedThreadID;
   <a href="reference.html#//apple_ref/doc/c_ref/ThreadID">ThreadID</a> InterruptedCoopThreadID;
};
typedef struct SchedulerInfoRec SchedulerInfoRec;
typedef SchedulerInfoRec * SchedulerInfoRecPtr;
</pre></p>
<h5 class="tight">Fields</h5><dl class="termdef">
<dt><code>InfoRecSize</code></dt>
<dd><p>The size of the structure. </p></dd>
<dt><code>CurrentThreadID</code></dt>
<dd><p><code></code>The thread ID of the current thread. </p></dd>
<dt><code>SuggestedThreadID</code></dt>
<dd><p><code></code>The thread ID of the thread that the application has suggested to run.</p></dd>
<dt><code>InterruptedCoopThreadID</code></dt>
<dd><p>Historically, the thread ID of a preempted cooperative thread if a cooperative thread has been interrupted and has not yet resumed execution. Because it no longer supports preemptive threads, the Thread Manager always passes the constant <code>kNoThreadID</code> to indicate that there is no thread that has been interrupted.</p></dd></dl>
<h5 class="tight">Discussion</h5>
<p>You can, if you wish, use the  <code><a href="reference.html#//apple_ref/c/func/SetThreadScheduler">SetThreadScheduler</a></code>  function to install a custom scheduling function to work in conjunction with the default Thread Manager scheduling mechanism. The Thread Manager uses the scheduler information structure to pass information to the custom scheduling function that allows it to decide which thread, if any, to schedule next. </p><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.0 and later.</li></ul><h5 class="tight">Declared In</h5><code>Threads.h</code>
<a name="//apple_ref/c/tdef/ThreadEntryTPP" title="ThreadEntryTPP"></a><a name="//apple_ref/doc/c_ref/ThreadEntryTPP" title="ThreadEntryTPP"></a><a name="//apple_ref/doc/uid/TP30000084-CH3g-C008207" title="ThreadEntryTPP"></a><a name="//apple_ref/doc/uid/TP30000084-CH3g-DontLinkElementID_63"></a><h3 class="tight">ThreadEntryTPP</h3>
<p class="spaceabove"></p>
<p class="spaceabove"><pre>
typedef <a href="reference.html#//apple_ref/doc/c_ref/ThreadEntryUPP">ThreadEntryUPP</a> ThreadEntryTPP;
</pre></p>
<h5 class="tight">Discussion</h5><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.0 and later.</li></ul><h5 class="tight">Declared In</h5><code>Threads.h</code>
<a name="//apple_ref/c/tdef/ThreadEntryUPP" title="ThreadEntryUPP"></a><a name="//apple_ref/doc/c_ref/ThreadEntryUPP" title="ThreadEntryUPP"></a><a name="//apple_ref/doc/uid/TP30000084-CH3g-C003652" title="ThreadEntryUPP"></a><a name="//apple_ref/doc/uid/TP30000084-CH3g-DontLinkElementID_64"></a><h3 class="tight">ThreadEntryUPP</h3>
<p class="spaceabove"></p>
<p class="spaceabove"><pre>
typedef <a href="reference.html#//apple_ref/doc/c_ref/ThreadEntryProcPtr">ThreadEntryProcPtr</a> ThreadEntryUPP;
</pre></p>
<h5 class="tight">Discussion</h5>
<p>For more information, see the description of the ThreadEntryUPP () callback function.</p><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.0 and later.</li></ul><h5 class="tight">Declared In</h5><code>Threads.h</code>
<a name="//apple_ref/c/tdef/ThreadSchedulerTPP" title="ThreadSchedulerTPP"></a><a name="//apple_ref/doc/c_ref/ThreadSchedulerTPP" title="ThreadSchedulerTPP"></a><a name="//apple_ref/doc/uid/TP30000084-CH3g-C008208" title="ThreadSchedulerTPP"></a><a name="//apple_ref/doc/uid/TP30000084-CH3g-DontLinkElementID_65"></a><h3 class="tight">ThreadSchedulerTPP</h3>
<p class="spaceabove"></p>
<p class="spaceabove"><pre>
typedef <a href="reference.html#//apple_ref/doc/c_ref/ThreadSchedulerUPP">ThreadSchedulerUPP</a> ThreadSchedulerTPP;
</pre></p>
<h5 class="tight">Discussion</h5><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.0 and later.</li></ul><h5 class="tight">Declared In</h5><code>Threads.h</code>
<a name="//apple_ref/c/tdef/ThreadSchedulerUPP" title="ThreadSchedulerUPP"></a><a name="//apple_ref/doc/c_ref/ThreadSchedulerUPP" title="ThreadSchedulerUPP"></a><a name="//apple_ref/doc/uid/TP30000084-CH3g-C003653" title="ThreadSchedulerUPP"></a><a name="//apple_ref/doc/uid/TP30000084-CH3g-DontLinkElementID_66"></a><h3 class="tight">ThreadSchedulerUPP</h3>
<p class="spaceabove"></p>
<p class="spaceabove"><pre>
typedef <a href="reference.html#//apple_ref/doc/c_ref/ThreadSchedulerProcPtr">ThreadSchedulerProcPtr</a> ThreadSchedulerUPP;
</pre></p>
<h5 class="tight">Discussion</h5>
<p>For more information, see the description of the ThreadSchedulerUPP () callback function.</p><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.0 and later.</li></ul><h5 class="tight">Declared In</h5><code>Threads.h</code>
<a name="//apple_ref/c/tdef/ThreadSwitchTPP" title="ThreadSwitchTPP"></a><a name="//apple_ref/doc/c_ref/ThreadSwitchTPP" title="ThreadSwitchTPP"></a><a name="//apple_ref/doc/uid/TP30000084-CH3g-C008209" title="ThreadSwitchTPP"></a><a name="//apple_ref/doc/uid/TP30000084-CH3g-DontLinkElementID_67"></a><h3 class="tight">ThreadSwitchTPP</h3>
<p class="spaceabove"></p>
<p class="spaceabove"><pre>
typedef <a href="reference.html#//apple_ref/doc/c_ref/ThreadSwitchUPP">ThreadSwitchUPP</a> ThreadSwitchTPP;
</pre></p>
<h5 class="tight">Discussion</h5><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.0 and later.</li></ul><h5 class="tight">Declared In</h5><code>Threads.h</code>
<a name="//apple_ref/c/tdef/ThreadSwitchUPP" title="ThreadSwitchUPP"></a><a name="//apple_ref/doc/c_ref/ThreadSwitchUPP" title="ThreadSwitchUPP"></a><a name="//apple_ref/doc/uid/TP30000084-CH3g-C003654" title="ThreadSwitchUPP"></a><a name="//apple_ref/doc/uid/TP30000084-CH3g-DontLinkElementID_68"></a><h3 class="tight">ThreadSwitchUPP</h3>
<p class="spaceabove"></p>
<p class="spaceabove"><pre>
typedef <a href="reference.html#//apple_ref/doc/c_ref/ThreadSwitchProcPtr">ThreadSwitchProcPtr</a> ThreadSwitchUPP;
</pre></p>
<h5 class="tight">Discussion</h5>
<p>For more information, see the description of the ThreadSwitchUPP () callback function.</p><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.0 and later.</li></ul><h5 class="tight">Declared In</h5><code>Threads.h</code>
<a name="//apple_ref/c/tdef/ThreadTaskRef" title="ThreadTaskRef"></a><a name="//apple_ref/doc/c_ref/ThreadTaskRef" title="ThreadTaskRef"></a><a name="//apple_ref/doc/uid/TP30000084-CH3g-BAJCDHHA" title="ThreadTaskRef"></a><a name="//apple_ref/doc/uid/TP30000084-CH3g-DontLinkElementID_69"></a><h3 class="tight">ThreadTaskRef</h3>
<p class="spaceabove">Represents a thread task reference.</p>
<p class="spaceabove"><pre>
typedef void* ThreadTaskRef;
</pre></p>
<h5 class="tight">Discussion</h5>
<p>In certain cases, such as during execution of an interrupt function, your application is not guaranteed to be the current process. Since threads are defined within an application context, it follows that in cases such as these, you cannot get or set information about any particular threads in your application unless you have a way of identifying the application context. The thread task reference gives you a way of doing this. </p>
<p>You can obtain the thread task reference by calling <code><a href="reference.html#//apple_ref/c/func/GetThreadCurrentTaskRef">GetThreadCurrentTaskRef</a></code> at a time when you know your application is the current context. Later, during execution of an interrupt function, you can use the thread task reference to identify your application. For example, you can pass the thread task reference to functions such as <code><a href="reference.html#//apple_ref/c/func/GetThreadStateGivenTaskRef">GetThreadStateGivenTaskRef</a></code> and <code><a href="reference.html#//apple_ref/c/func/SetThreadReadyGivenTaskRef">SetThreadReadyGivenTaskRef</a></code> in an interrupt function to get and set information about the state of particular threads in your application. </p><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.0 and later.</li></ul><h5 class="tight">Declared In</h5><code>Threads.h</code>
<a name="//apple_ref/c/tdef/ThreadTerminationTPP" title="ThreadTerminationTPP"></a><a name="//apple_ref/doc/c_ref/ThreadTerminationTPP" title="ThreadTerminationTPP"></a><a name="//apple_ref/doc/uid/TP30000084-CH3g-C008210" title="ThreadTerminationTPP"></a><a name="//apple_ref/doc/uid/TP30000084-CH3g-DontLinkElementID_70"></a><h3 class="tight">ThreadTerminationTPP</h3>
<p class="spaceabove"></p>
<p class="spaceabove"><pre>
typedef <a href="reference.html#//apple_ref/doc/c_ref/ThreadTerminationUPP">ThreadTerminationUPP</a> ThreadTerminationTPP;
</pre></p>
<h5 class="tight">Discussion</h5><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.0 and later.</li></ul><h5 class="tight">Declared In</h5><code>Threads.h</code>
<a name="//apple_ref/c/tdef/ThreadTerminationUPP" title="ThreadTerminationUPP"></a><a name="//apple_ref/doc/c_ref/ThreadTerminationUPP" title="ThreadTerminationUPP"></a><a name="//apple_ref/doc/uid/TP30000084-CH3g-C003655" title="ThreadTerminationUPP"></a><a name="//apple_ref/doc/uid/TP30000084-CH3g-DontLinkElementID_71"></a><h3 class="tight">ThreadTerminationUPP</h3>
<p class="spaceabove"></p>
<p class="spaceabove"><pre>
typedef <a href="reference.html#//apple_ref/doc/c_ref/ThreadTerminationProcPtr">ThreadTerminationProcPtr</a> ThreadTerminationUPP;
</pre></p>
<h5 class="tight">Discussion</h5>
<p>For more information, see the description of the ThreadTerminationUPP () callback function.</p><h5 class="tight">Availability</h5><ul class="availability"><li class="availability">Available in Mac OS X v10.0 and later.</li></ul><h5 class="tight">Declared In</h5><code>Threads.h</code><a name="//apple_ref/doc/uid/TP30000084-CH4g-108000" title="Constants"></a><a name="//apple_ref/doc/uid/TP30000084-CH4g-TPXREF115" title="Constants"></a><h2>Constants</h2>
<a name="//apple_ref/c/tdef/ThreadID" title="Thread ID Constants" role="Enum"></a><a name="//apple_ref/doc/c_ref/ThreadID" title="Thread ID Constants" role="Enum"></a><a name="//apple_ref/doc/uid/TP30000084-CH4g-C006384" title="Thread ID Constants" role="Enum"></a><a name="//apple_ref/doc/uid/TP30000084-CH4g-DontLinkElementID_72"></a><h3 class="tight">Thread ID Constants</h3>
<p class="spaceabove">The <code>ThreadID</code> data
type defines the thread ID. </p>
<p class="spaceabove"><pre>
typedef UInt32 ThreadID;
enum {
   <a href="reference.html#//apple_ref/doc/c_ref/kNoThreadID">kNoThreadID</a> = 0,
   <a href="reference.html#//apple_ref/doc/c_ref/kCurrentThreadID">kCurrentThreadID</a> = 1,
   <a href="reference.html#//apple_ref/doc/c_ref/kApplicationThreadID">kApplicationThreadID</a> = 2
};
</pre></p>
<h5 class="tight">Constants</h5><dl class="termdef">
<a name="//apple_ref/c/econst/kNoThreadID" title="kNoThreadID"></a><a name="//apple_ref/doc/c_ref/kNoThreadID" title="kNoThreadID"></a><a name="//apple_ref/doc/uid/TP30000084-CH4g-DontLinkElementID_73"></a><dt><code>kNoThreadID</code></dt>
<dd><p>Indicates no thread; for example, you can use
a function such as <code><a href="reference.html#//apple_ref/c/func/SetThreadState">SetThreadState</a></code> to
put the current thread in the stopped state and pass <code>kNoThreadID</code> to
indicate that you don&#8217;t care which thread runs next.</p><p>Available in Mac OS X v10.0 and later.</p><p>Declared in <code>Threads.h</code>.</p></dd>
<a name="//apple_ref/c/econst/kCurrentThreadID" title="kCurrentThreadID"></a><a name="//apple_ref/doc/c_ref/kCurrentThreadID" title="kCurrentThreadID"></a><a name="//apple_ref/doc/uid/TP30000084-CH4g-DontLinkElementID_74"></a><dt><code>kCurrentThreadID</code></dt>
<dd><p>Identifies the currently executing thread.</p><p>Available in Mac OS X v10.0 and later.</p><p>Declared in <code>Threads.h</code>.</p></dd>
<a name="//apple_ref/c/econst/kApplicationThreadID" title="kApplicationThreadID"></a><a name="//apple_ref/doc/c_ref/kApplicationThreadID" title="kApplicationThreadID"></a><a name="//apple_ref/doc/uid/TP30000084-CH4g-DontLinkElementID_75"></a><dt><code>kApplicationThreadID</code></dt>
<dd><p>Identifies the main application thread this
is the cooperative thread that the Thread Manager creates at launch
time. You cannot dispose of this thread. All applications&#8212;even
those that are not aware of the Thread Manager&#8212;have one main application
thread. The Thread Manager assumes that the main application thread
is responsible for event gathering when an operating-system event
occurs, the Thread Manager schedules the main application thread
as the next thread to execute. </p><p>Available in Mac OS X v10.0 and later.</p><p>Declared in <code>Threads.h</code>.</p></dd></dl>
<h5 class="tight">Discussion</h5>
<p>The Thread Manager assigns a thread ID to each thread that
you create or allocate with the  <code><a href="reference.html#//apple_ref/c/func/NewThread">NewThread</a></code> function. The thread ID uniquely
identifies a thread within an application context. You can use the
thread ID in functions that schedule execution of a particular thread,
dispose of a thread, and get and set information about a thread;
for example, you pass the thread ID to functions such as <code><a href="reference.html#//apple_ref/c/func/YieldToThread">YieldToThread</a></code> , <code><a href="reference.html#//apple_ref/c/func/DisposeThread">DisposeThread</a></code> , and <code><a href="reference.html#//apple_ref/c/func/GetThreadState">GetThreadState</a></code> . </p>
<p>In addition to the specific thread IDs that the <code>NewThread</code> function
returns, you can use the three Thread Manager constants described
here. </p>
<a name="//apple_ref/c/tdef/ThreadOptions" title="Thread Option Constants" role="Enum"></a><a name="//apple_ref/doc/c_ref/ThreadOptions" title="Thread Option Constants" role="Enum"></a><a name="//apple_ref/doc/uid/TP30000084-CH4g-C006385" title="Thread Option Constants" role="Enum"></a><a name="//apple_ref/doc/uid/TP30000084-CH4g-DontLinkElementID_76"></a><h3 class="tight">Thread Option Constants</h3>
<p class="spaceabove"></p>
<p class="spaceabove"><pre>
typedef UInt32 ThreadOptions;
enum {
   <a href="reference.html#//apple_ref/doc/c_ref/kNewSuspend">kNewSuspend</a> = (1 &lt;&lt; 0),
   <a href="reference.html#//apple_ref/doc/c_ref/kUsePremadeThread">kUsePremadeThread</a> = (1 &lt;&lt; 1),
   <a href="reference.html#//apple_ref/doc/c_ref/kCreateIfNeeded">kCreateIfNeeded</a> = (1 &lt;&lt; 2),
   <a href="reference.html#//apple_ref/doc/c_ref/kFPUNotNeeded">kFPUNotNeeded</a> = (1 &lt;&lt; 3),
   <a href="reference.html#//apple_ref/doc/c_ref/kExactMatchThread">kExactMatchThread</a> = (1 &lt;&lt; 4)
};
</pre></p>
<h5 class="tight">Constants</h5><dl class="termdef">
<a name="//apple_ref/c/econst/kNewSuspend" title="kNewSuspend"></a><a name="//apple_ref/doc/c_ref/kNewSuspend" title="kNewSuspend"></a><a name="//apple_ref/doc/uid/TP30000084-CH4g-DontLinkElementID_77"></a><dt><code>kNewSuspend</code></dt>
<dd><p>Begin a new thread in the stopped state.</p><p>Available in Mac OS X v10.0 and later.</p><p>Declared in <code>Threads.h</code>.</p></dd>
<a name="//apple_ref/c/econst/kUsePremadeThread" title="kUsePremadeThread"></a><a name="//apple_ref/doc/c_ref/kUsePremadeThread" title="kUsePremadeThread"></a><a name="//apple_ref/doc/uid/TP30000084-CH4g-DontLinkElementID_78"></a><dt><code>kUsePremadeThread</code></dt>
<dd><p>Use a thread from the existing supply.</p><p>Available in Mac OS X v10.0 and later.</p><p>Declared in <code>Threads.h</code>.</p></dd>
<a name="//apple_ref/c/econst/kCreateIfNeeded" title="kCreateIfNeeded"></a><a name="//apple_ref/doc/c_ref/kCreateIfNeeded" title="kCreateIfNeeded"></a><a name="//apple_ref/doc/uid/TP30000084-CH4g-DontLinkElementID_79"></a><dt><code>kCreateIfNeeded</code></dt>
<dd><p>Create a new thread if one with the proper
style and stack size requirements does not exist.</p><p>Available in Mac OS X v10.0 and later.</p><p>Declared in <code>Threads.h</code>.</p></dd>
<a name="//apple_ref/c/econst/kFPUNotNeeded" title="kFPUNotNeeded"></a><a name="//apple_ref/doc/c_ref/kFPUNotNeeded" title="kFPUNotNeeded"></a><a name="//apple_ref/doc/uid/TP30000084-CH4g-DontLinkElementID_80"></a><dt><code>kFPUNotNeeded</code></dt>
<dd><p>Do not save the FPU context. This saves time
when switching contexts. Note, however, that for PowerPC threads,
the Thread Manager always saves the FPU registers regardless of
how you set this option. Because the PowerPC microprocessor uses
the FPU registers for optimizations, they could contain necessary
information.</p><p>Available in Mac OS X v10.0 and later.</p><p>Declared in <code>Threads.h</code>.</p></dd>
<a name="//apple_ref/c/econst/kExactMatchThread" title="kExactMatchThread"></a><a name="//apple_ref/doc/c_ref/kExactMatchThread" title="kExactMatchThread"></a><a name="//apple_ref/doc/uid/TP30000084-CH4g-DontLinkElementID_81"></a><dt><code>kExactMatchThread</code></dt>
<dd><p>Allocate a thread from the pool only if it
exactly matches the stack-size request. Without this option, a thread
is allocated that best fits the request&#8212;that is, a thread whose
stack is greater than or equal to the requested size. </p><p>Available in Mac OS X v10.0 and later.</p><p>Declared in <code>Threads.h</code>.</p></dd></dl>
<h5 class="tight">Discussion</h5>
<p>When you create or allocate a new thread with the <code><a href="reference.html#//apple_ref/c/func/NewThread">NewThread</a></code> function,
you can specify thread options that define certain characteristics
of the thread, using the  values described here. To specify more
than one option, you sum them together and pass them as a single parameter
to the <code>NewThread</code> function.</p>
<p>The <code>ThreadOptions</code> data
type defines the thread options.  </p>
<a name="//apple_ref/c/tdef/ThreadState" title="Thread State Constants" role="Enum"></a><a name="//apple_ref/doc/c_ref/ThreadState" title="Thread State Constants" role="Enum"></a><a name="//apple_ref/doc/uid/TP30000084-CH4g-C006386" title="Thread State Constants" role="Enum"></a><a name="//apple_ref/doc/uid/TP30000084-CH4g-DontLinkElementID_82"></a><h3 class="tight">Thread State Constants</h3>
<p class="spaceabove"></p>
<p class="spaceabove"><pre>
typedef UInt16 ThreadState;
enum {
   <a href="reference.html#//apple_ref/doc/c_ref/kReadyThreadState">kReadyThreadState</a> = 0,
   <a href="reference.html#//apple_ref/doc/c_ref/kStoppedThreadState">kStoppedThreadState</a> = 1,
   <a href="reference.html#//apple_ref/doc/c_ref/kRunningThreadState">kRunningThreadState</a> = 2
};
</pre></p>
<h5 class="tight">Constants</h5><dl class="termdef">
<a name="//apple_ref/c/econst/kReadyThreadState" title="kReadyThreadState"></a><a name="//apple_ref/doc/c_ref/kReadyThreadState" title="kReadyThreadState"></a><a name="//apple_ref/doc/uid/TP30000084-CH4g-DontLinkElementID_83"></a><dt><code>kReadyThreadState</code></dt>
<dd><p>The thread is ready to run.</p><p>Available in Mac OS X v10.0 and later.</p><p>Declared in <code>Threads.h</code>.</p></dd>
<a name="//apple_ref/c/econst/kStoppedThreadState" title="kStoppedThreadState"></a><a name="//apple_ref/doc/c_ref/kStoppedThreadState" title="kStoppedThreadState"></a><a name="//apple_ref/doc/uid/TP30000084-CH4g-DontLinkElementID_84"></a><dt><code>kStoppedThreadState</code></dt>
<dd><p>The thread is stopped and not ready to run.</p><p>Available in Mac OS X v10.0 and later.</p><p>Declared in <code>Threads.h</code>.</p></dd>
<a name="//apple_ref/c/econst/kRunningThreadState" title="kRunningThreadState"></a><a name="//apple_ref/doc/c_ref/kRunningThreadState" title="kRunningThreadState"></a><a name="//apple_ref/doc/uid/TP30000084-CH4g-DontLinkElementID_85"></a><dt><code>kRunningThreadState</code></dt>
<dd><p>The thread is running.</p><p>Available in Mac OS X v10.0 and later.</p><p>Declared in <code>Threads.h</code>.</p></dd></dl>
<h5 class="tight">Discussion</h5>
<p>The Thread Manager functions which get and set information
about the state of a thread, such as <code><a href="reference.html#//apple_ref/c/func/GetThreadState">GetThreadState</a></code> and <code><a href="reference.html#//apple_ref/c/func/SetThreadState">SetThreadState</a></code> , use these values. </p>
<a name="//apple_ref/c/tdef/ThreadStyle" title="Thread Style Constants" role="Enum"></a><a name="//apple_ref/doc/c_ref/ThreadStyle" title="Thread Style Constants" role="Enum"></a><a name="//apple_ref/doc/uid/TP30000084-CH4g-C006387" title="Thread Style Constants" role="Enum"></a><a name="//apple_ref/doc/uid/TP30000084-CH4g-DontLinkElementID_86"></a><h3 class="tight">Thread Style Constants</h3>
<p class="spaceabove"></p>
<p class="spaceabove"><pre>
typedef UInt32 ThreadStyle;
enum {
   <a href="reference.html#//apple_ref/doc/c_ref/kCooperativeThread">kCooperativeThread</a> = 1<!--a-->L<!--/a--> &lt;&lt; 0,
   <a href="reference.html#//apple_ref/doc/c_ref/kPreemptiveThread">kPreemptiveThread</a> = 1<!--a-->L<!--/a--> &lt;&lt; 1
};
</pre></p>
<h5 class="tight">Constants</h5><dl class="termdef">
<a name="//apple_ref/c/econst/kCooperativeThread" title="kCooperativeThread"></a><a name="//apple_ref/doc/c_ref/kCooperativeThread" title="kCooperativeThread"></a><a name="//apple_ref/doc/uid/TP30000084-CH4g-DontLinkElementID_87"></a><dt><code>kCooperativeThread</code></dt>
<dd><p>Available in Mac OS X v10.0 and later.</p><p>Declared in <code>Threads.h</code>.</p></dd>
<a name="//apple_ref/c/econst/kPreemptiveThread" title="kPreemptiveThread"></a><a name="//apple_ref/doc/c_ref/kPreemptiveThread" title="kPreemptiveThread"></a><a name="//apple_ref/doc/uid/TP30000084-CH4g-DontLinkElementID_88"></a><dt><code>kPreemptiveThread</code></dt>
<dd><p>Available in Mac OS X v10.0 and later.</p><p>Declared in <code>Threads.h</code>.</p></dd></dl>
<h5 class="tight">Discussion</h5>
<p>Historically, the Thread Manager defined two types of threads
to run in an application context: cooperative and preemptive, but
now it supports only cooperative threads.</p>
<p>Although the Thread Manager only supports a single type of
thread, many Thread Manager functions (for historical reasons) require
you to use the thread type to specify the type of the thread. </p>
<p>The <code>ThreadStyle</code> data
type specifies the type of a thread. </p>
<p>Because there is only one type of thread (cooperative) the
thread type accepts a single value, <code>kCooperativeThread</code>. </p><a name="//apple_ref/doc/uid/TP30000084-CH5g-RCM0102" title="Result Codes"></a><h2><a name="//apple_ref/doc/uid/TP30000084-CH5g-108991" title="Result Codes"></a><a name="//apple_ref/doc/uid/TP30000084-CH5g-TPXREF116" title="Result Codes"></a>Result Codes</h2>
<p>The most common result codes returned by Thread Manager are
listed below.</p>


<div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><tr><th scope="col" align="left"><strong>Result Code</strong></th><th scope="col" align="left"><strong>Value</strong></th><th scope="col" align="left"><strong>Description</strong></th></tr>
<tr>
<a name="//apple_ref/doc/uid/TP30000084-CH5g-DontLinkElementID_89"></a><td valign="top" scope="row"><a name="//apple_ref/c/econst/threadTooManyReqsErr" title="threadTooManyReqsErr"></a><a name="//apple_ref/doc/c_ref/threadTooManyReqsErr" title="threadTooManyReqsErr"></a><code>threadTooManyReqsErr</code></td>
<td align="right" valign="top" class="content_text noWrap">-617</td>
<td valign="top" class="content_text"><p>Available in Mac OS X v10.0 and later.</p></td>
</tr>
<tr>
<a name="//apple_ref/doc/uid/TP30000084-CH5g-DontLinkElementID_90"></a><td valign="top" scope="row"><a name="//apple_ref/c/econst/threadNotFoundErr" title="threadNotFoundErr"></a><a name="//apple_ref/doc/c_ref/threadNotFoundErr" title="threadNotFoundErr"></a><code>threadNotFoundErr</code></td>
<td align="right" valign="top" class="content_text noWrap">-618</td>
<td valign="top" class="content_text"><p>Available in Mac OS X v10.0 and later.</p></td>
</tr>
<tr>
<a name="//apple_ref/doc/uid/TP30000084-CH5g-DontLinkElementID_91"></a><td valign="top" scope="row"><a name="//apple_ref/c/econst/threadProtocolErr" title="threadProtocolErr"></a><a name="//apple_ref/doc/c_ref/threadProtocolErr" title="threadProtocolErr"></a><code>threadProtocolErr</code></td>
<td align="right" valign="top" class="content_text noWrap">-619</td>
<td valign="top" class="content_text"><p>Available in Mac OS X v10.0 and later.</p></td>
</tr>
</table></div><a name="//apple_ref/doc/uid/TP30000084-CH6g-129718" title="Gestalt Constants"></a><a name="//apple_ref/doc/uid/TP30000084-CH6g-TPXREF102" title="Gestalt Constants"></a><h2>Gestalt Constants</h2><p>You can check for version and feature availability
information by using the  Thread Manager selectors defined in the
Gestalt Manager.  For more information see Inside Mac OS X: Gestalt
Manager Reference.</p>


        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <!-- Previous button --><span style="margin-left: 8px"><a href="../DeprecationAppendix/AppendixADeprecatedAPI.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2007 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2007-04-04<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Carbon/Reference/Thread_Manager/Reference/reference.html%3Fid%3DTP30000084-3.1&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Carbon/Reference/Thread_Manager/Reference/reference.html%3Fid%3DTP30000084-3.1&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Carbon/Reference/Thread_Manager/Reference/reference.html%3Fid%3DTP30000084-3.1&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>