//	ULookupCommand.cp// 	Copyright © 1991-92 by Apple Computer, Inc. All rights reserved.//	Kent Sandvik DTS//	This file contains all the member functions for TLookupCommand,//	for instance the PPC browsing handling.////	<1>		khs		1.0		First final version#ifndef __ULOOKUPCOMMAND__#include "ULookupCommand.h"#endif#ifndef __UAEDOCUMENT__#include "UAEDocument.h"#endif//	METHODS://	Empty constructor - for avoiding ptabs in global data space#undef Inherited#define Inherited TCommand#pragma segment AResDefineClass(TLookupCommand, TCommand);TLookupCommand::TLookupCommand(){}//	Initialize TLookupCommand, used for opening the PPCBrowser window#pragma segment ASelCommandvoid TLookupCommand::ILookupCommand(CommandNumber theNum,										   TAEDocument* theDoc){	fDocument = theDoc;	this->ICommand(theNum, NULL, kCantUndo, kDoesNotCauseChange, NULL);}//	MyPPCBrowserFilter - filter for the PPC Browser with information//	about what to look for over the network, i.e. who we can talk with.// 	Thanks to Eric Soldan and his Kibitz application for the tips//	on how to implement this function.#pragma segment ASelCommandpascal  Boolean MyPPCBrowserFilter(LocationNamePtr/*theLocation*/,										 PortInfoPtr thePortInfo){	OSType type;	if (thePortInfo->name.portKindSelector == ppcByString)	// go through every PPC port, and select the one that has the right signature	{		BlockMove(thePortInfo->name.u.portTypeStr + 1, Ptr(&type), sizeof(type));		// The BlockMove is so that we don't get an address error		// on a 68000-based machine due to referencing a long at		// an odd-address.		if (type == kSignature)			return TRUE;						// found node	}	return FALSE;								// did not see any}//	Do a PPC Browser lookup of existing nodes that talk the same protocol,//	i.e. an open application with the same signature#pragma segment ADoCommandvoid TLookupCommand::DoIt(){	FailInfo fi;	TargetID theTargetID;	PortInfoRec thePortInfo;	AEAddressDesc targetAddress;	CStr255 thePrompt = "Find node you want to examine";	CStr255 theType = "AEGestalt Nodes";	CStr255 windowTitle;	PPCFilterUPP myPPCFilterUPP;		Try(fi)	{	    myPPCFilterUPP = NewPPCFilterProc(MyPPCBrowserFilter);		FailOSErr(PPCBrowser(thePrompt, theType, FALSE, &(theTargetID.location), &thePortInfo, myPPCFilterUPP, (CStr255)""));		DisposeRoutineDescriptor(myPPCFilterUPP);		fi.Success();	}	else	{		fDocument->fOKNode = FALSE;		if (fi.error == userCanceledErr)			return;		else			fi.ReSignal();	}	// signal in document we found OK node	fDocument->fOKNode = TRUE;	// enable the report button in document as well	fDocument->fReportButton->DimState(FALSE, TRUE);	// get the AE Address	theTargetID.name = thePortInfo.name;	FailOSErr(AECreateDesc(typeTargetID, Ptr(&theTargetID), sizeof(theTargetID), &targetAddress));	fDocument->fAEGestaltAddress = targetAddress;	// fix window title, so it will have the title of the port name	switch (theTargetID.location.locationKindSelector)	{		case ppcNoLocation:						// my own machine			fDocument->SetTitle(CStr255("This is a local node"));			break;		case ppcNBPLocation:					// we are handling this case			BlockMove(&theTargetID.location.u.nbpEntity.objStr, &windowTitle, 33);			fDocument->SetTitle(windowTitle);			break;		case ppcNBPTypeLocation:				// not handling it yet			break;	}	//	Words of wisdom, the nbpEntity record is trash if the PPC selection is on the same	//	local node. It is very important to check the locationKindSelector (as above) and	//	only use the npbEntity record when we have a ppcNBPLocation!!! See IM VI-7 for more	//	information about this (it's well hidden!)}