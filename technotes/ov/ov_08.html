<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"			"http://www.w3.org/TR/REC-html40/loose.dtd"><html><head><LINK REL="stylesheet" HREF="../../adcstyle.css" TYPE="text/css"><LINK REL="stylesheet" HREF="../../style.css" TYPE="text/css"><title>Technical Note OV08: Managerial Abuse</title><meta name="keywords" content="Mac OS 8 Resource Manager List Dialog textEdit abuse misuse"><meta name="Description" content="Technical Note OV08: This Technical Note presents an overviewof commonly abused Macintosh operating system built-in Managers.The Resource Manager, TextEdit package, List Manager, andDialog Manager are discussed and the discussion touches onsuch topics as how these managers are abused and the performancecosts of this abuse.">                                       <meta name="categories" content="Overview"><meta name="week-posted" content="Aug 1, 1988 - Aug 5, 1988"><LINK REL="stylesheet" HREF="../../css/adcstyle.css" TYPE="text/css"><script language="JavaScript" type="text/javascript" src="../../js/adc.js"></script></HEAD><BODY BGCOLOR="#FFFFFF"><a name="//apple_ref/doc/uid/DTS10002606" title="Managerial Abuse"></a><A NAME="top"></A><!-- top_of_header_marker_comment --><!-- begin_header_information --><!--#include virtual="/adcnavbar" --><p><a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../technicalnotes/index.html">Technical Notes</a> &gt; <a href="../../technicalnotes/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../technicalnotes/LegacyTechnologies/idxCarbon-date.html">Carbon</a> &gt; </p><div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/Carbon/idxDesignGuidelines-date.html" target="_blank">Carbon > Design Guidelines</a></li>
	</ul>
</div>




</div></div></div><!-- end_header_information --><!-- bottom_of_header_marker_comment --><!-- top_of_titles_marker_comment --><CENTER><table width="600" cellpadding="0" cellspacing="0" border="0">
<tr><td align="left" scope="row">
<h1>
<div id="pagehead">Technical Note OV08</div>
<div id="pageheadsub">Managerial Abuse</div>
</h1>
</td></tr></table></CENTER><!-- bottom_of_titles_marker_comment --><CENTER><TABLE BORDER=0 CELLSPACING=1 WIDTH=600><TR><td align="left"><!-- begin_header_box --><table width="600" cellpadding="0" cellspacing="0" border="0">    <tr>        <td width=300 valign="top" align=left scope="row">            <table border="0" width="300" cellpadding="0" cellspacing="0">			<tr>                        <td width=300 align=left> <img src="images/tnmenutop.gif" alt="" align="bottom" width=300 height=7></td>                </tr>                <tr bgcolor="#e6e6e6">                    <td background="images/tnmenubody.gif" width=300 align=left>                                         <span id="menutitle">                            CONTENTS                             <br>                            <br>                        </span>                    </td>                </tr>                <tr bgcolor="#e6e6e6">                    <td background="images/tnmenubody.gif" width=300 align=left>					<!-- begin_toc -->										<p id="menutext">					<A HREF="#Section1">Introduction</A><br><br><A HREF="#Section2">No free database</A><br><br><A HREF="#Section3">Words to live by</A><br><br><A HREF="#Section4">Checking lists twice</A><br><br><A HREF="#Section4">Dialog with the Devil</A><br><br><A HREF="#References">References</A><br><br>	 <A HREF="#Downloads">Downloadables</A></P>                   <!-- end_toc -->                  </td>                </tr>                <tr>                    <td width=300 align=left scope="row">                        <img src="images/tnmenubottom.gif" alt="" width=300 height=16>                    </td>                </tr>            </table>        </td>        <td width=300 valign="top" align=left><!-- begin_intro_text --><P id = "introtext">When using the various pieces of the Macintosh operating system there is atemptation to try to stretch the built-in Managers too far. Developers should be aware of the intended purpose of the various Managers and beware of using them for things that they were not designed to handle. If extended beyond their design goals, they will become slow and unwieldy.</p><!-- end_intro_text --><!-- begin_date --><h3 align=center>[Aug 01 1988]</h3><!-- end_date -->                </TD>             </TR>          </TABLE>          <!-- end_table_box --> <BR><BR>          <hr width=500 align=center>          <BR><BR>          <!-- begin_content -->        <A NAME=Section1></A><h2>Introduction</h2><p>Managers to avoid abusing, and the type of abuse:</p><p>1) The Resource Manager is <b>not</b> a database.</p><p>2) The TextEdit package is <b>not</b> a word processor.</p><p>3) The List Manager is <b>not</b> a spreadsheet.</p><p>4) The Dialog Manager is <b>not</b> a user interface.</p><P><A HREF="#top">Back to top</A></P><a name="Section2"></a><h2>No free database</h2><p>After using the Resource Manager for a short time, its virtues become apparent:it is very flexible, it is easy to use, it gives disk based I/O with no extra calls, data can be extracted by either name or ID number, and the data is stored transparently so the caller can pretend the data is always available in a virtual memory fashion. With such wide ranging advantages, it would seem that the Resource Manager should be used for everything. It should be apparent that the TANSTAAFL (There Ain't No Such Thing As A Free Lunch) philosophy applies to the Resource Manager as well. If overextended, the Resource Manager will become slow and unusable.</p><p>The Resource Manager is not a database, nor is it a good way to store user data.  Although it can be used to store very small amounts of data, such as configuration data, and features some of the same characteristics of databases in general, the Resource Manager is a specialized tool designed specifically for the types of things that the Macintosh System needs. Its main virtue for system use is that a large variety of data can be stored on disk, and accessedwhen needed. This is a primitive form of virtual memory which extends the power of the system beyond what the RAM supplies. Remembering that the Resource Manager was written in an era of 128K RAM, it should be apparent that it is optimized to use as little RAM as possible.</p><p>The Resource Manager uses a simple data structure for accessing the data in thefile. Examining the Resource Manager file format can show some of the tradeoffs expected. For instance, there is a linearly accessed table which describes all of the possible resource types that are in the current file. Without too much thought it should be apparent that if a file is created with thousands of different resource types then access to those resources will be slow. The reason?  Each access requires scanning a linear array. There is no hashing technique used on the resource types.</p><p>There is a similar linear table for the resource IDs themselves. Based on theprevious discussion it should also be apparent that if there are thousands ofresources of a specific type that the access time will become much larger. Itwill be imperceptible on a single access of a resource, but for thousands ofaccesses to the resource file the time spent traversing the linear list willimpact the overall speed of the program. The user will not be pleased.</p><p>Increasing the slowness by having too many resources as well as too many typeswill encourage the user to file the program in a ground based circular storage facility.</p><p>As stated in<A HREF = "../tb/tb_18.html">M.TB.MaxResInFile</a>, there is a limit of about 2700 resources in a given file due to the way the resources are stored. The performance penaltywill arrive sooner, and the dividing line for where it is "too slow" is a personal preference. As a rule of thumb, if the program has the ability to store more than about 500 resources total (both IDsand types), then consideration should be given to using the Data Fork instead. In particular, ifthe program allows the user to create data files, do not use the Resource Manager to store the user data. The users will always overextend the use of a program. Plan for it, and avoid making obviously bad decisions. For large amounts of data, the File Manager is the place to look. If the program wants to allow simultaneous (multi-user) access with read and write privileges to data files, then do not use the Resource Manager.  Because it caches data, the Resource Manager cannot be relied upon as a multi-user database - even for small amounts of data. This is because there is no way to tell the Resource Manager its cache is invalid.</p><p>Don't be fooled by a convenient interface. The Resource Manager is not adatabase, nor is it a file system.</p><P><A HREF="#top">Back to top</A></P><a name="Section3"></a><h2>Words to live by</h2><p>Looking at the TextEdit package can give the impression that there is a fullfeatured word processing system built in. This is even more true now that TextEdit has been extended to support various styles and fonts. Unfortunately, appearances are deceiving, and TextEdit is not up to the job of being a word processor. Looking through the documentation shows that there is a 32,767 character limit on the text in a TextEdit record. The <code>teLength</code> isdefined as an <code>Integer</code>. Another more subtle limit is the drawing limit of the rectangles surrounding the text. The <code>destRect</code> and <code>viewRect</code> both surround the complete TextEdit record. Using some rather rough approximations, there is an upper limit of about 40 pages of text that can be supported in the QuickDraw rectangle. This is quite a lot for some applications, but is not very many when looking at the job typically required of a word processor. Users do not enjoy breaking their documents into multiple pieces.</p><p>There are some other programmatic limitations, not the least of which isperformance. TextEdit will become quite sluggish with large blocks of data. After 2,000-4,000 characters have been stored in a TextEdit record, the performance will have slowed to an unacceptable level. It is notable that the <code>lineStarts</code> array is a linear array of offsets into the edit record. If the data towards the end of the data record (high in the record) changes, the offsets have to be changed. This can involve updating thousands of <code>Integer</code> offsets for every character typed. If the different font, size and style information is tacked on top of all that, the performance can be expected to suffer with large blocks of text. Make no mistake about it, a full Macintosh style word processor is not an easy thing to write. TextEdit was not designed to handle large documents. It was designed as a simple field editor for the Dialog Manager, and extended from there. It was never intended to handle the large jobs expected of a word processor.</p><p>In order to perform the operations required of a word processor it is necessaryto use QuickDraw extensively. The expected Macintosh selection approach with autoscrolling, typing over selected text, cut/copy/paste, and so on are best implemented using QuickDraw directly. How the text is stored internally is the primary determining factor on how the word processor will perform.</p><p>Don't be fooled by how easy it is to implement simple editing in anapplication. TextEdit is not a word processor.</p><P><A HREF="#top">Back to top</A></P><a name="Section4"></a><h2>Checking lists twice</h2><p>The List Manager appears to be a cell oriented display tool, allowing the easycreation of a spreadsheet interface using system calls. The rich interface to the manager makes it easy to handle arbitrary lists of data. Or does it? Although the List Manager is very flexible, easy to use, and general enough to handle graphic elements, its performance becomes unacceptable with relatively modest amounts of data. A one-dimensional list (like the files list in StdFile) can be done very well using the List Manager, but with several thousand items in the list, the performance may not be sufficient. This rarely happens in StdFile of course, and StdFile was the father of the List Manager. Here again, the tool was designed with a specific concept in mind, not to be the ultimate tool for handling any possible arbitrary data. A two-dimensional list of data will become too slow to use with an array as small as 10x100. This can hardly be expected to satisfy the user of a spreadsheet, since one "power" criteria is always the number of cells available.</p><p>Why so slow? As above, examining the data structures used by the List Managercan tell a lot about the expected performance and limitations. Notably the <code>cellArray</code> used to offset to each cell's data is an old friend, a linear array of <code>Integer</code> offsets. It should come as no surprise that inserting or deleting data from the middle of this array is slow. In order to do those functions the List Manager has to update the <code>Integer</code> offsetsin the array each time. It has to step through each element on the linear arrayof offsets which will take some time on several thousand elements.</p><p>The <code>maxIndex</code> field of the ListRec is also notable since it is an<code>Integer</code> as well. The lists of data can be no more than 32K bytes insize, which could be somewhat limiting to a user.</p><p>In addition, the List Manager is very general purpose, making it necessary forit to protect itself from bad data whenever possible. It needs to check thebounds of any rectangles it uses for example. It tries to minimize drawing outof bounds, so it checks each cell as it is drawn to be sure that it is onscreen. Extra validity checks take some small, but finite, time. As the numberof elements grows, the time adds up until it becomes a performance problem.Another limitation brought out by the data structure is the<code>listDefProc</code>, the list definition procedure. Since the List Manager isdesigned to be as general purpose as possible, it was necessary to add theability to plug in a new defproc. This has ramifications for speed, however,since all drawing has to go through the bottleneck of the defproc. It won'tcost much each time, but it will add up over a large number of cells.</p><p>In order to get high performance out of this type of display, it is generallynecessary to have as much precalculated as possible. This usually means havingdata structures which maintain themselves as much as possible, and which do notrequire changing anything outside of their single cell, thus avoiding impactingthe entire display. Linear arrays don't come under this category, since anychange impacts all the other cell data in the list. To create a highperformance spreadsheet it is usually necessary to go to the QuickDraw levelinside of a standard window. It is not typically necessary to be fully generalfor a specific type of data, so the performance can be improved merely byknowing the type of data expected. To handle large lists of data, the datashould be stored in powerful data structures, and displayed with customroutines that know the best way to draw the data.</p><p>Don't be fooled by the richness and general purpose interface to the ListManager. The List Manager is not a spreadsheet.</p><P><A HREF="#top">Back to top</A></P><a name="Section5"></a><h2>Dialog with the Devil</h2><p>The Dialog Manager is very attractive. It looks like it will handle windowsautomatically with no programmer intervention, and can handle a wide variety ofelements. It seems to handle controls, static text, editable text, and providesa way to display graphic elements as well. It must be the best possible worldsince the interface is very straightforward, and so much is done for thecaller. At last, a superbly general purpose manager that can be used for anyinterface. Suddenly, reality rears its ugly head again, and it is interestingto note that this free lunch actually requires more work than doing the samejob using the Window Manager, QuickDraw, TextEdit, and the Control Manager.Why? There is a hidden cost in terms of getting the Dialog Manager to doexactly the desired task. Here again, if the end result is supposed to be asimple dialog with a few controls, the Dialog Manager is suited to the job.That is what it was written to do. It was not designed as a way to handle thefull interface for applications.</p><p>As an example of a hidden cost, what if the interface requires that the programbe able to handle a disk inserted event? If this is part of a <code>ModalDialog</code>, that requires passing a special <code>filterProc</code> to the dialog when it is called. It is now necessary to fully understand how the proc gets called, what is legal, and what the proc is required to do. That may not be too hard, but it is time spent on something that has nothing to do with getting the job done; it is only time spent understanding how the Dialog Manager works.</p><p>Another example is adding something to a dialog which requires special setupand update routines.  Here again, it is not too hard to figure out, but it istime spent trying to tell the Dialog Manager what should be done. There areliterally hundreds of these special cases and tough, small problems when tryingto extend a dialog past a simple interface. Hundreds of Mac programmers havewasted hundreds (thousands?) of hours finding ways to coerce the Dialog Managerinto running a window in a special way.</p><p>How about adding a special control to a dialog? Seems straightforward... Howabout making it modeless instead? How about moving some items in the dialog offscreen? How about moving an EditText item off screen? How about wanting tochange the dialog template before the dialog is used? How about all of theabove all at the same time?</p><p>How about skipping it and using the Window Manager instead?</p><p>There are a number of performance penalties for large dialogs as well. A dialogwith 50 radio buttons will be unacceptably slow. It should be noted that theDialog Manager cannot know the desired purpose of the buttons, so it cannot setthe button, nor clear another in the same set. In order to implement the actualradio button aspect of a set of controls, it has to be done by the callingprogram. At this point, the only thing the Dialog Manager is handling is thecreation and drawing of the controls, which can easily be done with<code>GetNewControl</code> and <code>DrawControls</code>. The Dialog Manager actuallygets in the way of a more complex interface. Looking into the data structuresshows that the list of items in a dialog is a linear list. Also of note is thatthere are no offsets to the various items! This is significant because it meansthat the Dialog Manager has to drive through the entire list of items for everysingle operation it performs. If it gets an update event it has to traverse thelist. If it gets a mouse event it has to traverse the list. This cannot beexpected to be fast with 100 items.</p><p>Another performance problem for some programmers is the simple drawing schemeused by the Dialog Manager. If a dialog has some items that are offscreen, theyget drawn during update events anyway. The Dialog Manager will traverse thelist and draw each item, whether it is on screen or not. This comes from theoriginal design of the Dialog Manager, in that it was never intended to handlehundreds of items, or items off screen.</p><p>Some rules of thumb: If there are more than 20 items in the dialog it should bea standard window. If a complicated control like a scroll bar is needed, itshould be a standard window. If there are items offscreen, it should be astandard window. If there is a pictorial indicator like a progress indicator,it should be a standard window. If it is a modeless dialog it should be astandard window. If any of the items are movable in the dialog, it should be astandard window. If it is necessary to use a <code>filterProc</code> to addfunctionality, it should be a standard window.  If in doubt, it should probablybe a standard window.</p><p>Handling a dialog with the Window Manager is very straightforward, much more sothan trying to get around the Dialog Manager. There is the standard main event loop,and a conventional case statement to handle the events of interest. If there are controls in the window, they are easily handled with Control Manager calls. Any special items can be added to the case statement with no tricks. Overall there is more code to write, but the code is much less complex (read as: easier to figure out, easier to debug, easier to maintain). In addition, when extra items have to be added to the window, there is an easy-to-find, logical place to add the code. With the Dialog Manager there may be hidden difficulties.</p><p>The Dialog Manager is very powerful, but to use the power it is necessary touse all sorts of hooks, procs, special items, and special calling sequences. Asexpected, only the interfaces to these things are described in <i>Inside Macintosh</i>. The sequence of events is the costly part. For an example of how to add a <code>userItem</code> to a dialog, examine <A HREF = "../tb/tb_27.html">M.TB.DialogUserItems</a>. Note that it is not particularly simple to understand. Contrast that with the <code>FillRect/FrameRect</code> calls in the code that handles update events in a normal window.</p><p>The Window Manager is more powerful than the Dialog Manager. The Dialog Manageruses the Window Manager. The Window Manager is much more straightforward to use since it follows the conventional Macintosh event model. That model is easier to understand and easier to extend. There are more calls to make, but the overall use is much simpler. There are very few special tricks needed to make any conceivable interface in a window.</p><p>Don't be lured in by the "powerful" Dialog Manager calls, tricky hooks, andfilter procedures. The Dialog Manager is not a user interface.</p><P><A HREF="#top">Back to top</A></P><a name="References"></a><h2>References</h2><p>The Resource Manager</p><p>TextEdit</p><p>The List Manager</p><p>The Dialog Manager</p><p><A HREF = "../tb/tb_18.html">M.TB.MaxResInFile</a></p><p><A HREF = "../tb/tb_27.html">M.TB.DialogUserItems</a></p> <P><A HREF="#top">Back to top</A></P>         <P><A NAME=Downloads></A></P>                  <H2>Downloadables</H2>                  <TABLE BORDER=0 CELLPADDING=3 WIDTH="100%">            <TR>               <td width=50 align=left>                  <P ALIGN=center><img src="images/acrobatsmall.gif" width=22 height=23 align=middle alt="Acrobat gif"></P>               </TD>               <td align="left">                  <P>Acrobat version of this Note (52K).</P>               </TD>               <td width=60 align=left>                  <P><A HREF="pdf/ov_08.pdf">Download</A></P>               </TD>            </TR>                    </TABLE>         <BR></TD></TR></table></center><!-- begin_footer_information -->	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/technotes/ov/ov_08.html%3Fid%3DDTS10002606-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/technotes/ov/ov_08.html%3Fid%3DDTS10002606-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/technotes/ov/ov_08.html%3Fid%3DDTS10002606-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>
<!--#include virtual="/includes/footer"--><!-- end_footer_information --></BODY></HTML>