<!-- Generated by Harlequin WebMaker 2.2.3 (23-Apr-1996)
LispWorks 3.2.2 -->
<HTML> <HEAD>
<TITLE>Writing a Device Driver(IM: D)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING14></A>


<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->




<!-- Main Body -->

<CENTER>
<P>
<A HREF="Devices-13.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Devices-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Devices-328.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="Devices-15.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="Devices-2.html"><B>Devices</B></A> / <BR><DD><A HREF="Devices-10.html"><B>Chapter 1 - Device Manager</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING14-0></A>
<H1><A NAME=MARKER-9-113></A>Writing a Device Driver</H1>
 <A NAME=MARKER-9-120></A>This section shows you how to write a basic device driver--one that can respond to Device Manager requests. Although you will need to write some assembly-language interface code, you can write your device driver routines in a high-level language.<P>
 Before you decide to write your own device driver, you should consider whether your task can be more easily accomplished using one of the standard Macintosh drivers described in this book or other <I>Inside Macintosh</I> volumes. In general, you should consider writing a device driver only if your hardware device or system service needs to be accessed at unpredictable times or by more than one application.<P>
 For example, if you develop a new output device that you want to make available to any application, you might need to write a custom driver. On the other hand, if your product is a specialized device that can only be used by your application, it may be easier to control the device using private code within your application.<P>
 This section describes how to<P>
<UL>
<LI>create a driver resource
<LI>write the code in your driver resource so that it responds appropriately to Device Manager requests
<LI>handle the special requirements of asynchronous I/O
<LI>install and initialize your driver<P>
</UL>
<A NAME=HEADING14-9></A>
<H2><A NAME=MARKER-2-115></A><A NAME=MARKER-9-116></A>Creating a Driver Resource</H2>
 You will probably want to store your device driver in a driver resource, although if you are writing a driver for a slot device, you might want to store your driver in an sResource data structure in the declaration ROM of the expansion card. See the chapter <A HREF=Devices-53.html#MARKER-9-26>"Slot Manager"</A> in this book for information about sResource data structures.<P>
 Storing your driver in a driver resource allows the Device Manager to load your driver code into memory and install a device control entry for your driver in the unit table. Like all resources, your driver resource has a resource type, a resource ID, a resource name, and resource attributes.<P>
<UL>
<LI>The resource type must be <CODE>'DRVR'</CODE> if you plan to use the Device Manager to load your driver into memory. If you write your own routine to load the driver, you can choose a different resource type.
<LI>The resource ID determines where in the unit table the Device Manager installs the driver's device control entry. Because you must choose the resource ID when creating your driver resource, you cannot know which unit numbers are available until you open your driver. Therefore, your driver-opening routine must find an empty location in the unit table and change the resource ID accordingly. <A HREF=#MARKER-9-180>"Installing a Device Driver" on page 1-38</A> discusses appropriate values for the resource ID.
<LI>The resource name should be the same as the driver name because the Device Manager calls <CODE>GetNamedResource</CODE> using this name if it can't find the driver in the unit table. A driver name consists of a period (.) followed by any sequence of 1 to 255 printing characters. The Device Manager ignores case (but not diacritical marks) when comparing names.
<LI>The resource attributes of your driver resource depend on your driver. A typical driver might have these attributes: locked, since most drivers contain code that is called at interrupt time; in the system heap, so that the driver exists over launches of applications; and preloaded, which makes resource loading slightly more efficient.<P>
</UL>
 A driver resource has two parts:<P>
<UL>
<LI>a driver header that contains information about the driver
<LI>the routines that do the work of the driver<P>
</UL>
 <A NAME=MARKER-2-31></A><A NAME=MARKER-2-42></A>The driver header contains a few words of flags and other data, offsets to the driver's routines, and an optional driver name. <A HREF=#MARKER-9-119>Figure 1-9</A> shows the format of a driver header. <P>
<B>Figure 1-9  <A NAME=MARKER-9-119></A>The driver header</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/DEV-L-12.jpg"><p>
 <A NAME=MARKER-9-120></A>The elements of the driver header are:<P>
<DL>
<DT><B>Element Description</B>
<DT><CODE>drvrFlags</CODE>
<DD> <A NAME=MARKER-2-150></A><A NAME=MARKER-2-151></A>Flags in the high-order byte of this field specify certain characteristics of the driver.<DFN> </DFN>These flags are copied to the high-order byte of the <CODE>dCtlFlags</CODE> field of the device control entry when the driver is opened. You can use the constants shown in <A HREF=#MARKER-9-123>Listing 1-6</A> to set or test the flags in this field.<DFN>
<TABLE BORDER="0" CELLPADDING=3><TH ALIGN=LEFT><B></B><TH>Name<TH>Bit<TH>Meaning<TR>
<TD>&nbsp;<TD><CODE>dReadEnable</CODE><TD>8<TD>Set if the driver can respond to read requests.<TR>
<TD>&nbsp;<TD><CODE>dWritEnable</CODE><TD>9<TD>Set if the driver can respond to write requests.<TR>
<TD>&nbsp;<TD><CODE>dCtlEnable</CODE><TD>10<TD>Set if the driver can respond to control requests.<TR>
<TD>&nbsp;<TD>dStatEnable<TD>11<TD>Set if the driver can respond to status requests.<TR>
<TD>&nbsp;<TD>dNeedGoodbye<TD>12<TD>Set if the driver needs to be called before the application heap is reinitialized.<TR>
<TD>&nbsp;<TD>dNeedTime<TD>13<TD>Set if the driver needs time for performing periodic tasks.<TR>
<TD>&nbsp;<TD>dNeedLock<TD>14<TD>Set if the driver needs to be locked in memory as soon as it is opened.</TABLE>
</DFN>
<DT><CODE>drvrDelay</CODE>
<DD> If the <CODE>dNeedTime</CODE> flag is set, this field contains the requested number of ticks between periodic actions. This value is approximate and should not be used as a timing reference.
<DT><CODE>drvrEMask</CODE>
<DD> Used only by desk accessories, this field contains an event mask. See <A HREF=Devices-16.html#MARKER-9-199>"Writing a Desk Accessory" on page 1-49</A> for information about this field.
<DT><CODE>drvrMenu</CODE>
<DD>  Used only by desk accessories, this field contains a menu ID. See <A HREF=Devices-16.html#MARKER-9-199>"Writing a Desk Accessory" on page 1-49</A> for more information.
<DT><CODE>drvrOpen</CODE>
<DD> The offset of the driver's open routine, relative to offset 0 of the driver header.
<DT><CODE>drvrPrime</CODE>
<DD> The offset of the driver's prime routine.
<DT><CODE>drvrCtl</CODE>
<DD> The offset of the driver's control routine.
<DT><CODE>drvrStatus</CODE>
<DD> The offset of the driver's status routine.
<DT><CODE>drvrClose</CODE>
<DD> The offset of the driver's close routine.
<DT><CODE>drvrName</CODE>
<DD> A Pascal string containing the driver's name, up to 255 characters.
</DL>
 See the section <A HREF=#MARKER-9-141>"Entering and Exiting From Driver Routines" on page 1-29</A> for more information about the routine offsets.<P>
<DL>
<DT><B>Note</B>
<DD>Your driver routines, which follow the driver header, must be aligned on a word boundary.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
<B>Listing 1-6  <A NAME=MARKER-9-123></A>Driver flag constants</B><P>
<PRE>
enum {
   /* flags used in the driver header and device control entry */
   dNeedLockMask    = 0x4000, /* set if driver must be locked in memory as
                                 soon as it's opened */ 
   dNeedTimeMask    = 0x2000, /* set if driver needs time for performing
                                 periodic tasks */ 
   dNeedGoodByeMask = 0x1000, /* set if driver needs to be called before the
                                 application heap is initialized */ 
   dStatEnableMask  = 0x0800, /* set if driver responds to status requests */ 
   dCtlEnableMask   = 0x0400, /* set if driver responds to control requests */ 
   dWritEnableMask  = 0x0200, /* set if driver responds to write requests */ 
   dReadEnableMask  = 0x0100, /* set if driver responds to read requests */ 
};
</PRE>
 <A NAME=MARKER-2-53></A><A NAME=MARKER-2-54></A><A NAME=MARKER-2-51></A><A NAME=MARKER-2-50></A>The <CODE>dReadEnable</CODE>, <CODE>dWritEnable</CODE>, <CODE>dCtlEnable</CODE>, and <CODE>dStatEnable</CODE> flags indicate which Device Manager requests the device driver can respond to. The next section, <A HREF=#MARKER-9-139>"Responding to the Device Manager,"</A> describes these routines in detail. <P>
 <A NAME=MARKER-2-66></A>Drivers in the application heap are lost when the heap is reinitialized. If you set the <CODE>dNeedGoodbye</CODE> flag, the Device Manager calls your driver before the heap is reinitialized so that you can perform any clean-up actions. See <A HREF=#MARKER-9-160>"Writing Control and Status Routines," beginning on page 1-34</A>, for information about using this flag. <P>
 <A NAME=MARKER-2-70></A><A NAME=MARKER-2-69></A>You set the <CODE>dNeedTime</CODE> flag if your device driver needs to perform some action periodically. For example, a network driver may want to poll its input buffer every 5 seconds to see if it has received any messages. The value of the <CODE>drvrDelay</CODE> field indicates how many ticks should pass between periodic actions. For example, a value of 0 in the <CODE>drvrDelay</CODE> field indicates that the action should happen as often as possible, a value of 1 means it should happen every sixtieth of a second, a value of 2 means at most every thirtieth of a second, and so on. Whether the action actually occurs this frequently depends on how often an application calls <CODE>WaitNextEvent</CODE> or <CODE>SystemTask</CODE>. See <A HREF=#MARKER-9-160>"Writing Control and Status Routines," beginning on page 1-34</A>, for information about using this flag.<P>
<DL>
<DT><B>Note</B>
<DD><A NAME=MARKER-9-131></A>If you do not want your driver to depend on applications to call <CODE>WaitNextEvent</CODE> or <CODE>SystemTask</CODE>, you can perform actions periodically by installing a VBL task, a Deferred Task Manager task, a Time Manager task, or a Notification Manager task. For more information, see <I><A HREF="../Processes/Processes-2.html">Inside Macintosh: Processes</A></I>.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
 <A NAME=MARKER-9-103></A>You need to set the <CODE>dNeedLock</CODE> flag if your device driver's code must be locked in memory. In particular, you need to set this flag in these two cases:<P>
<UL>
<LI>If any part of your driver's code can be called at interrupt time. Because the Operating System may perform memory management at interrupt time, your driver must be locked to prevent it from being moved. 
<LI>If your driver provides the Operating System with a pointer to any part of its code. For example, if your driver uses the Device Manager to call another driver, you might provide the Device Manager with a pointer to a completion routine. If that completion routine is in your driver code, your driver code must be locked. Otherwise, that pointer might not be valid when the Device Manager calls the completion routine.<P>
</UL>
 <A NAME=MARKER-2-133></A>You can create your driver header in these ways:<P>
<UL>
<LI>You can use a resource compiler. See <A HREF=Devices-50.html#MARKER-9-392>"Resources" on page 1-89</A> for the Rez format of the driver resource.
<LI>You can use the <CODE>DC</CODE> instruction, as shown in <A HREF=#MARKER-9-134>Listing 1-7</A>, to position the header information directly in your assembly language code.<P>
</UL>
<B>Listing 1-7  <A NAME=MARKER-9-134></A>An assembly-language driver header</B><P>
<PRE>
DHeader
DFlags   DC.W  0                  ;set by MyDriverOpen
DDelay   DC.W  0                  ;none
DEMask   DC.W  0                  ;DA event mask
DMenu    DC.W  0                  ;no menu
         DC.W  DOpen - DHeader    ;offset to Open
         DC.W  DPrime - DHeader   ;offset to Prime
         DC.W  DControl - DHeader ;offset to Control
         DC.W  DStatus - DHeader  ;offset to Status
         DC.W  DClose - DHeader   ;offset to Close
Name     DC.B  '.MYDRIVER'        ;driver name
         ALIGN 2                  ;word alignment
</PRE>
 <A NAME=MARKER-2-166></A><A NAME=MARKER-2-175></A>In this example, the <CODE>drvrFlags</CODE> word is cleared to 0 because the flags are set by the <CODE>MyDriverOpen</CODE> function, shown in <A HREF=#MARKER-9-147>Listing 1-9 on page 1-32</A>. This is an implementation decision--you can set the flags in the driver header or in your driver's open routine. The <CODE>drvrDelay</CODE> field is set to 0 because this driver does not perform any periodic actions using the <CODE>SystemTask</CODE> function. The <CODE>drvrEMask</CODE> and <CODE>drvrMenu</CODE> fields are set to 0, as this driver is not a desk accessory. The next five fields contain offsets to the driver routines, defined in the next section, <A HREF=#MARKER-9-139>"Responding to the Device Manager."</A> The header ends with the driver name and the word alignment directive.<A NAME=MARKER-2-137></A><P>
<A NAME=HEADING14-51></A>
<H2><A NAME=MARKER-9-138></A><A NAME=MARKER-9-139></A>Responding to the Device Manager</H2>
 The Device Manager calls a driver routine by setting up registers and jumping to the address indicated by the routine's offset in the driver header. <P>
<UL>
<LI>Register A0 contains a pointer to the parameter block. 
<LI>Register A1 contains a pointer to the driver's device control entry.<P>
</UL>
 This interface requires you to use some assembly language when writing a driver. However, you can write your driver routines in a high-level language if you provide an assembly-language dispatching mechanism that acts as an interface between the Device Manager and your driver routines.<P>
 The next few sections discuss how you can provide a dispatching routine and how you can implement your driver routines in a high-level language.<P>
<A NAME=HEADING14-57></A>
<H3><A NAME=MARKER-2-323></A><A NAME=MARKER-9-141></A>Entering and Exiting From Driver Routines</H3>
 <A HREF=#MARKER-9-142>Listing 1-8</A> shows an assembly-language dispatching routine that you can use as an interface between the Device Manager and your high-level language driver routines. This example properly handles synchronous, asynchronous, and immediate requests, as well as the special cases of open, close, and <CODE>KillIO</CODE>.<P>
<B>Listing 1-8  <A NAME=MARKER-9-142></A>An assembly-language dispatching routine</B><P>
<PRE>
DOpen
      MOVEM.L  A0-A1,-(SP)    ;save ParmBlkPtr, DCtlPtr across function call
      MOVEM.L  A0-A1,-(SP)    ;push ParmBlkPtr, DCtlPtr for C
      BSR      MyDriverOpen   ;call linked C function
      ADDQ     #8,SP          ;clean up the stack
      MOVEM.L  (SP)+,A0-A1    ;restore ParmBlkPtr, DCtlPtr
      RTS                     ;open is always immediate, must return via RTS

DPrime
      MOVEM.L  A0-A1,-(SP)    ;save ParmBlkPtr, DCtlPtr across function call
      MOVEM.L  A0-A1,-(SP)    ;push ParmBlkPtr, DCtlPtr for C
      BSR      MyDriverPrime  ;call linked C function
      ADDQ     #8,SP          ;clean up the stack
      MOVEM.L  (SP)+,A0-A1    ;restore ParmBlkPtr, DCtlPtr
      BRA.B    IOReturn

DControl
      MOVEM.L  A0-A1,-(SP)    ;save ParmBlkPtr, DCtlPtr across function call
      MOVEM.L  A0-A1,-(SP)    ;push ParmBlkPtr, DCtlPtr for C
      BSR      MyDriverControl;call linked C function
      ADDQ     #8,SP          ;clean up the stack
      MOVEM.L  (SP)+,A0-A1    ;restore ParmBlkPtr, DCtlPtr
      CMPI.W   #killCode,csCode(A0) ;test for KillIO call (special case)
      BNE.B    IOReturn
      RTS                     ;KillIO must always return via RTS

DStatus
      MOVEM.L  A0-A1,-(SP)    ;save ParmBlkPtr, DCtlPtr across function call
      MOVEM.L  A0-A1,-(SP)    ;push ParmBlkPtr, DCtlPtr for C
      BSR      MyDriverStatus ;call linked C function
      ADDQ     #8,SP          ;clean up the stack
      MOVEM.L  (SP)+,A0-A1    ;restore ParmBlkPtr, DCtlPtr

IOReturn
      MOVE.W   ioTrap(A0),D1
      BTST     #noQueueBit,D1 ;immediate calls are not queued, and must RTS
      BEQ.B    @Queued        ;branch if queued

@NotQueued
      TST.W    D0             ;test asynchronous return result
      BLE.B    @ImmedRTS      ;result must be \xBE0
      CLR.W    D0             ;&quot;in progress&quot; result (&gt; 0) not passed back

@ImmedRTS
      MOVE.W   D0,ioResult(A0)   ;for immediate calls you must explicitly 
                                 ; place the result in the ioResult field
      RTS

@Queued
      TST.W    D0             ;test asynchronous return result
      BLE.B    @MyIODone      ;I/O is complete if result \xBE 0
      CLR.W    D0             ;&quot;in progress&quot; result (&gt; 0) not passed back
      RTS

@MyIODone
      MOVE.L   JIODone,-(SP)  ;push IODone jump vector onto stack
      RTS

DClose
      MOVEM.L  A0-A1,-(SP)    ;save ParmBlkPtr, DCtlPtr across function call
      MOVEM.L  A0-A1,-(SP)    ;push ParmBlkPtr, DCtlPtr for C
      BSR      MyDriverClose  ;call linked C function
      ADDQ     #8,SP          ;clean up the stack
      MOVEM.L  (SP)+,A0-A1    ;restore ParmBlkPtr, DCtlPtr
      RTS                     ;close is always immediate, must return via RTS
</PRE>
 In this example, <CODE>DOpen</CODE>, <CODE>DPrime</CODE>, <CODE>DControl</CODE>, <CODE>DStatus</CODE>, and <CODE>DClose</CODE> are the five entry points that the Device Manager locates using the offsets defined in the driver header. These in turn call the actual driver routines, which are written in C. The C functions return a result code if the I/O completed, or a positive value (usually 1) if the I/O is being handled asynchronously.<P>
 When the driver routine returns, the dispatching routine removes the parameters from the stack, restores the A0 and A1 registers, and then returns control to the Device Manager in one of two ways:<P>
<UL>
<LI><A NAME=MARKER-2-143></A>Calling the <CODE>IODone</CODE> routine. This routine, described in detail on <A HREF=Devices-47.html#MARKER-9-386>page 1-87</A>, indicates to the Device Manager that the request is complete. The Device Manager removes the request from the I/O queue and calls the completion routine, if any. This is the normal method of returning from driver prime, control, and status routines.
<LI>Returning with an <CODE>RTS</CODE> instruction. Use this method when you do not want the Device Manager to remove the request from the I/O queue. There are three cases where the <CODE>RTS</CODE> instruction should be used:<P>
<UL>
<LI>Returning from an asynchronous request that is not yet complete. After your device driver begins an asynchronous operation, it should return control to the Device Manager with an <CODE>RTS</CODE> instruction. The device driver can regain control of the processor using an interrupt handler, VBL task, or other method, and jump to <CODE>IODone</CODE> when the request is complete.
<LI>Returning from an immediate request. Because the Device Manager does not queue immediate requests, they should always return with an <CODE>RTS</CODE> instruction.
<LI>Returning from open, close, and <CODE>KillIO</CODE> requests. These requests are never queued and should always return with an <CODE>RTS</CODE> instruction.<P>
</UL>
</UL>
 To use this dispatching routine you would place it after the driver header in your assembly-language source file, and link it to your C-language driver routines. <A HREF=#MARKER-9-134>Listing 1-7 on page 1-28</A> shows the driver header. Sample driver routines are presented in the following sections.<P>
<A NAME=HEADING14-69></A>
<H3><A NAME=MARKER-9-144></A>Writing Open and Close Routines</H3>
 <A NAME=MARKER-2-99></A>You must provide both an open routine and a close routine for your device driver. The open routine should allocate any private storage your driver requires and place a handle to this storage in the <CODE>dCtlStorage</CODE> field of the device control entry. After allocating memory, the open routine should perform any other preparation required by your driver.<P>
 If your open routine installs an interrupt handler, you may want to store a pointer to the device control entry in private storage where it will be available for the interrupt handler. The section <A HREF=#MARKER-9-173>"Handling Asynchronous I/O" on page 1-37</A> discusses interrupt handling in more detail.<P>
 <A HREF=#MARKER-9-147>Listing 1-9</A> shows a sample open routine, <CODE>MyDriverOpen</CODE>. This function begins by checking whether the driver is already open (by examining the contents of the <CODE>dCtlStorage</CODE> field of the device control entry). If the driver is not already open, the<CODE> MyDriverOpen</CODE> function sets the appropriate flags in the device control entry and allocates memory in the system heap for private storage. The private storage of the driver in this example contains two fields, <CODE>byteCount</CODE> and <CODE>lastErr</CODE>, which store information about the last I/O function. The prime, control, and status routines described in the following sections use these fields.<P>
 If the <CODE>MyDriverOpen</CODE> function fails to allocate memory for private storage, it returns the <CODE>openErr</CODE> result code, which notifies the Device Manager that the driver did not open.<P>
<B>Listing 1-9  <A NAME=MARKER-9-147></A>Example driver open routine<A NAME=MARKER-2-125></A><A NAME=MARKER-2-169></A></B><P>
<PRE>
struct MyDriverGlobals {
   short    byteCount;
   short    lastErr;
};
typedef struct MyDriverGlobals MyDriverGlobals;
typedef struct MyDriverGlobals *MyDriverGlobalsPtr, **MyDriverGlobalsHdl;

OSErr MyDriverOpen(IOParamPtr pb, DCtlPtr dce)
{
   if (dce-&gt;dCtlStorage == nil) 
   {
      /* set up flags in the device control entry */
      dce-&gt;dCtlFlags |= (dCtlEnableMask | dStatEnableMask | dWritEnableMask |
                         dReadEnableMask | dNeedLockMask | dRAMBasedMask );
               
      /* initialize dCtlStorage */
      dce-&gt;dCtlStorage = NewHandleSysClear(sizeof(MyDriverGlobals));
      if (dce-&gt;dCtlStorage == nil)
         return(openErr);
      else
         return(noErr);
   }
   else
   {
      /* the driver is already open */
      return(noErr);
   }
}
</PRE>
 The close routine must reverse the effects of the open routine by releasing any memory allocated by the driver, removing interrupt handlers, removing any VBL or Time Manager tasks, and replacing changed interrupt vectors. If the close routine cannot complete the close request, it should return the <CODE>closErr</CODE> result code and the driver should continue to operate normally.<P>
 The Device Manager does not dispose of the device control entry when a driver is closed. If you want to save any information about the operational state of the driver until the next time the driver is opened, you can store a handle to the information in the <CODE>dCtlStorage</CODE> field of the device control entry.<P>
 <A HREF=#MARKER-9-150>Listing 1-10</A> shows a sample close routine, <CODE>MyDriverClose</CODE>. Because this device <BR>driver does not need to store any information until the next time it is opened, the <CODE>MyDriverClose</CODE> function disposes of the private storage allocated by <CODE>MyDriverOpen</CODE>.<P>
<B>Listing 1-10  <A NAME=MARKER-9-150></A>Example driver close routine<A NAME=MARKER-2-165></A><A NAME=MARKER-2-161></A></B><P>
<PRE>
OSErr MyDriverClose(IOParamPtr pb, DCtlPtr dce)
{
   if (dce-&gt;dCtlStorage != nil)
   {
      DisposeHandle(dce-&gt;dCtlStorage);
      dce-&gt;dCtlStorage = nil;
   }
   return(noErr);
}
</PRE>
<A NAME=HEADING14-81></A>
<H3><A NAME=MARKER-9-153></A>Writing a Prime Routine</H3>
 <A NAME=MARKER-2-100></A>The prime routine implements I/O requests. You can write your prime routine to execute synchronously or asynchronously. While a synchronous prime routine completes an entire I/O request before returning to the Device Manager, an asynchronous prime routine can begin an I/O transaction but return to the Device Manager before the request is complete. In this case, the I/O request continues to be executed, typically when more data is available, by other routines such as interrupt handlers or completion routines. <A HREF=#MARKER-9-173>"Handling Asynchronous I/O" on page 1-37</A> discusses how to complete an asynchronous prime routine.<P>
 The Device Manager indicates whether it is requesting a read or a write operation by placing one of the following constants in the low-order byte of the <CODE>ioTrap</CODE> field of the parameter block:<P>
<PRE>
enum {
   aRdCmd   = 2,  /* read operation requested */
   aWrCmd   = 3   /* write operation requested */
};
</PRE>
 <A NAME=MARKER-2-155></A><A NAME=MARKER-2-156></A>The Device Manager includes two routines, <CODE>Fetch</CODE> and <CODE>Stash</CODE>, that provide low-level support for reading and writing characters to and from data buffers. Use of these routines is optional. <A HREF=Devices-42.html#MARKER-9-375>"Writing and Installing Device Drivers," beginning on page 1-82</A>, describes these functions.<P>
 The <CODE>Fetch</CODE> and <CODE>Stash</CODE> routines update the <CODE>ioActCount</CODE> field of the parameter block. If you do not use these routines, you are responsible for updating this field. <P>
 If your driver serves a block device, you should update the <CODE>dCtlPosition</CODE> field of the device control entry. <P>
 <A HREF=#MARKER-9-157>Listing 1-11</A> shows a sample prime routine. This routine determines whether a read or write operation is being requested, then calls the appropriate function. The reading and writing functions, which are not shown here, would transfer the data to or from the hardware device.<P>
<B>Listing 1-11  <A NAME=MARKER-9-157></A>Example driver prime routine<A NAME=MARKER-2-126></A><A NAME=MARKER-2-158></A></B><P>
<PRE>
OSErr MyDriverPrime(IOParamPtr pb, DCtlPtr dce)
{
   MyDriverGlobalsHdl   dStore;
   short                callType;
   long                 numBytes;
   short                myErr;

   dStore = (MyDriverGlobalsHdl)dce-&gt;dCtlStorage;
   numBytes = pb-&gt;ioReqCount;
   callType = 0x00ff &amp; pb-&gt;ioTrap; /* get the low byte */
   switch (callType)
   {
      case aRdCmd:
         myErr = MyReadBytes(pb-&gt;ioBuffer, numBytes);
         break;
      case aWrCmd:
         myErr = MyWriteBytes(pb-&gt;ioBuffer, numBytes);
         break;
   }
   (*dStore)-&gt;byteCount = numBytes; /* save in private storage */
   (*dStore)-&gt;lastErr = myErr;
   pb-&gt;ioActCount = numBytes; /* update parameter block field */
   return(myErr);
}
</PRE>
 After obtaining a handle to the device driver's private storage from the dCtlStorage field of the device control entry, the <CODE>MyDriverPrime</CODE> function examines the low-order byte of the <CODE>ioTrap</CODE> field of the parameter block to determine whether the Device Manager is requesting a read operation or a write operation. <CODE>MyDriverPrime</CODE> then calls either the <CODE>MyReadBytes</CODE> or <CODE>MyWriteBytes</CODE> function to move the requested number of bytes to or from the buffer designated by the parameter block.<P>
 The <CODE>MyDriverPrime</CODE> function stores the result code and byte count in its private storage. These values will be used by the example control and status routines described in the next section. Finally, <CODE>MyDriverPrime</CODE> updates the <CODE>ioActCount</CODE> field of the parameter block and returns the result code.<P>
<A NAME=HEADING14-93></A>
<H3><A NAME=MARKER-9-160></A>Writing Control and Status Routines</H3>
 <A NAME=MARKER-2-161></A>Control and status routines are usually used to send and receive driver-specific information. However, you can use these routines for any kind of data transfer as long as you implement the minimum functionality described in this section. Like the prime routine, the control and status routines that you write can execute synchronously or asynchronously. <P>
 The Device Manager passes information to the control routine in the <CODE>csCode</CODE> and <CODE>csParam</CODE> fields of the parameter block. The <CODE>csCode</CODE> field specifies the type of control request and the <CODE>csParam</CODE> field contains any additional information. The <CODE>csCode</CODE> values<BR>-32767 through 127 are reserved by Apple Computer, Inc. Within this range, the following constant values are defined for use by all device drivers:
<TABLE BORDER="0" CELLPADDING=3><TH ALIGN=LEFT>Constant name<TH>Value<TH>Meaning<TR>
<TD><A NAME=MARKER-4-2></A>killCode<TD>1<TD><CODE>KillIO</CODE> requested<TR>
<TD><A NAME=MARKER-4-3></A>goodbye<TD>-1<TD>Heap being reinitialized<TR>
<TD><A NAME=MARKER-4-4></A>accRun<TD>65<TD>Time for periodic action </TABLE>
<P>
 <A NAME=MARKER-2-162></A><A NAME=MARKER-2-129></A>When the Device Manager receives a <CODE>KillIO</CODE> request, it removes every parameter block from the driver I/O queue. If your driver responds to any requests asynchronously, the part of your driver that completes asynchronous requests (for example, an interrupt handler) might expect the parameter block for the pending request to be at the head of the queue. The Device Manager notifies your driver of <CODE>KillIO</CODE> requests so that it can take the appropriate actions to stop work on the pending request. Your driver must return control to the Device Manager by means of an <CODE>RTS</CODE> instruction and not by jumping to the <CODE>IODone</CODE> routine.<P>
 <A NAME=MARKER-2-164></A>If you set the <CODE>dNeedGoodbye</CODE> flag in the <CODE>drvrFlags</CODE> field of the driver header (or the <CODE>dCtlFlags</CODE> field of the device control entry), the Device Manager will call your control routine with the value <CODE>goodbye</CODE> in the <CODE>csCode</CODE> parameter before the heap is reinitialized. You driver can respond by performing any clean-up actions necessary before heap reinitialization.<P>
 <A NAME=MARKER-2-130></A>If you set the <CODE>dNeedTime</CODE> flag in the <CODE>drvrFlags</CODE> field of the driver header (or the <CODE>dCtlFlags</CODE> field of the device control entry), the Event Manager will periodically call your control routine with the value <CODE>accRun</CODE> in the <CODE>csCode</CODE> parameter. Because these calls are immediate, your driver must be reentrant to handle them properly. For more information about the <CODE>dNeedTime</CODE> flag and periodic actions, see the description of the driver header, beginning on <A HREF=#MARKER-9-120>page 1-25</A>.<P>
 Your control routine must return the <CODE>controlErr</CODE> result code for any <CODE>csCode</CODE> values that are not supported. You can define driver-specific <CODE>csCode</CODE> values if necessary, as long as they are outside the range reserved by Apple Computer, Inc.<P>
 <A HREF=#MARKER-9-166>Listing 1-12</A> shows a sample control routine, <CODE>MyDriverControl</CODE>. This function interprets the driver-specific <CODE>csCode</CODE> value of <CODE>kClearAll</CODE> as a command to clear the information saved in the driver's private storage by the <CODE>MyDriverPrime</CODE> routine.<P>
<B>Listing 1-12  <A NAME=MARKER-9-166></A>Example driver control routine<A NAME=MARKER-2-131></A><A NAME=MARKER-2-155></A></B><P>
<PRE>
OSErr MyDriverControl(CntrlParamPtr pb, DCtlPtr dce)
{
   MyDriverGlobalsHdl   dStore;

   dStore = (MyDriverGlobalsHdl)dce-&gt;dCtlStorage;
   switch (pb-&gt;csCode)
   {
      case kClearAll:
         (*dStore)-&gt;byteCount = 0;
         (*dStore)-&gt;lastErr = 0;
         return(noErr);
      default: /* always return controlErr for unknown csCode */
         return(controlErr);
   }
}
</PRE>
 Your status routine should work in a similar manner. The Device Manager uses the <CODE>csCode</CODE> field to specify the type of status information requested. The status routine should respond to whatever requests are appropriate for your driver and return the error code <CODE>statusErr</CODE> for any unsupported <CODE>csCode</CODE> value.<P>
 The Device Manager interprets a status request with a <CODE>csCode</CODE> value of 1 as a special case. When the Device Manager receives such a status request, it returns a handle to the driver's device control entry. Your driver's status routine never sees this request.<P>
 <A HREF=#MARKER-9-169>Listing 1-13</A> shows a sample status routine, <CODE>MyDriverStatus</CODE>, that implements two driver-specific status requests, <CODE>kByteCount</CODE> and <CODE>kLastErr</CODE>. When <CODE>MyDriverStatus</CODE> receives one of these requests, it returns the byte count or error code values saved in private storage by the <CODE>MyDriverPrime</CODE> routine. <CODE>MyDriverStatus</CODE> returns this information in the <CODE>csParam</CODE> field.<P>
<B>Listing 1-13  <A NAME=MARKER-9-169></A>Example driver status routine<A NAME=MARKER-2-132></A><A NAME=MARKER-2-153></A></B><P>
<PRE>
OSErr MyDriverStatus(CntrlParamPtr pb, DCtlPtr dce)
{
   MyDriverGlobalsHdl   dStore;

   dStore = (MyDriverGlobalsHdl)dce-&gt;dCtlStorage;
   switch (pb-&gt;csCode)
   {
      case kByteCount:
         pb-&gt;csParam[0] = (*dStore)-&gt;byteCount;
         return(noErr);
      case kLastErr:
         pb-&gt;csParam[0] = (*dStore)-&gt;lastErr;
         return(noErr);
      default: /* always return statusErr for unknown csCode */
         return(statusErr);
   }
}
</PRE>
<A NAME=HEADING14-108></A>
<H2><A NAME=MARKER-2-192></A><A NAME=MARKER-9-173></A>Handling Asynchronous I/O</H2>
 <A NAME=MARKER-2-134></A><A NAME=MARKER-2-133></A>If you design any of your driver routines to execute asynchronously, you must provide a mechanism for your driver to complete the requests. Some examples of routines that you might use are:<P>
<UL>
<LI><A NAME=MARKER-2-183></A>Completion routines. Your driver routine could call another driver to start the data transfer. In this case, you can provide that driver with a completion routine. When the other driver completes the request, the Device Manager executes the completion routine. In the completion routine, you could call the other driver again to execute the next part of the I/O operation. When the entire operation is complete, the completion routine should return by calling the <CODE>IODone</CODE> routine.
<LI><A NAME=MARKER-2-184></A>Interrupt handlers. If your driver serves a hardware device that generates interrupts, you can create an interrupt handler that responds to these interrupts. Your interrupt handler must clear the source of the interrupt and return as quickly as possible, while preserving all registers other than D0 through D3 and A0 through A3. For more information about interrupts and how to install an interrupt handler, see <I><A HREF="../Processes/Processes-2.html">Inside Macintosh: Processes</A></I> and <I>Designing Cards and Drivers for the Macintosh Family</I>, third edition<I>.</I>
<LI>VBL, Time Manager, and Deferred Task Manager tasks. Installing any of these tasks ensures that your driver receives system time at some point in the future. During this time, you can check to see if the I/O operation is ready to continue.<P>
</UL>
 If your driver serves a device on a NuBus<Superscript>\x81<EM></EM> expansion card, you might want to use slot interrupts to signal your driver. When a NuBus card device signals a slot interrupt, the CPU can quickly detect which card requested the interrupt service, but not which device on the card. To determine which device caused the interrupt, the system uses a polling procedure. Your driver should provide a polling routine that checks if the device it serves caused the current interrupt, and if so, calls the proper driver routine to handle the interrupt. The Slot Manager maintains a queue of these polling routines for each slot. Your driver can install an element in this queue using the Slot Manager function <CODE>SIntInstall</CODE>. You can remove a queue element with the <CODE>SIntRemove</CODE> function. See the chapter <A HREF=Devices-53.html#MARKER-9-26>"Slot Manager"</A> in this book for information about these functions.<P>
 <A NAME=MARKER-2-159></A>You should observe these guidelines when writing or using asynchronous routines:<P>
<UL>
<LI>Once you pass a parameter block to an asynchronous routine it is out of your control. You should not examine or change the parameter block until your completion routine is called because you have no way of knowing the state of the parameter block.
<LI>Do not dispose of or reuse a parameter block until the asynchronous request is completed. For example, if you declare the parameter block as a local variable, your function cannot return until the request is complete because local variables are allocated on the stack and released when a function returns.
<LI>Use a completion routine to determine when an asynchronous routine has completed, rather than polling the <CODE>ioResult</CODE> field of the parameter block. Polling the <CODE>ioResult</CODE> field is not efficient and defeats the purpose of asynchronous operation.<A NAME=MARKER-2-67></A><P>
</UL>
<A NAME=HEADING14-118></A>
<H2><A NAME=MARKER-9-180></A>Installing a Device Driver</H2>
 <A NAME=MARKER-2-119></A>There are a variety of ways to install a device driver, depending on where the driver code is stored and how much control you want over the installation process.<P>
<UL>
<LI>You can store the device driver in a resource within an application and have the application install the driver.
<LI>You can store the device driver, and the code to install it, in a system extension file. See the chapter "Start Manager"<I> </I>in <I><A HREF="../OSUtilities/OSUtilities-2.html">Inside Macintosh: Operating System Utilities</A></I> for information about creating system extensions.
<LI>You can store the device driver in the declaration ROM of an expansion card. Slot device drivers can be designed to load automatically at startup, or you can use the Slot Manager <CODE>SGetDriver</CODE> function to load the driver into memory. Refer to <I>Designing Cards and Drivers for the Macintosh Family</I>, third edition, for information about writing and installing slot device drivers.<P>
</UL>
 If you store your driver in a resource of type <CODE>'DRVR'</CODE> you can use the <CODE>OpenDriver</CODE> or <CODE>PBOpen</CODE> functions to install and open your driver. If you need more control over the installation process, you can use the <CODE>DriverInstall</CODE> function to create the device control entry and add it to the unit table, or you can create the device control entry yourself, install it in the unit table, and then use <CODE>OpenDriver</CODE> or <CODE>PBOpen</CODE> to open the driver. If the driver is already installed in the unit table, <CODE>OpenDriver</CODE> and <CODE>PBOpen</CODE> simply call the driver's open routine and return the driver reference number.<P>
 If you want to use the <CODE>OpenDriver</CODE> function to install your driver, you are responsible for examining the unit table and changing your driver resource ID so that the <CODE>OpenDriver</CODE> function installs your driver in an empty location in the unit table. If the handle at a given unit number is <CODE>nil</CODE>, there is no device control entry installed in that position. You can install your device control entry in any empty location in the unit table that is not listed as reserved by Apple Computer, Inc. <A HREF=#MARKER-9-5>Table 1-2</A> summarizes the unit numbers reserved for specific purposes.
<TABLE BORDER="0" CELLPADDING=3>
<CAPTION><A NAME=MARKER-9-5></A><B>Table 1-2 Reserved unit numbers</B><A NAME=MARKER-2-136></A></CAPTION>
<TH>Unit number range<TH>Reference number range<TH>Purpose<TR>
<TD>0 through 11<TD>-1 through -12<TD>Reserved for serial, disk, AppleTalk, printer, and other drivers<TR>
<TD>12 through 31<TD>-13 through -32<TD>Available for desk accessories<TR>
<TD>32 through 38<TD>-33 through -39<TD>Available for SCSI devices<TR>
<TD>39 through 47<TD>-40 through -48<TD>Reserved <TR>
<TD>48 through 127<TD>-49 through -128<TD>Available for slot and other drivers</TABLE>
<P>
 <A NAME=MARKER-9-135></A><A HREF=#MARKER-9-183>Listing 1-14</A> shows a method of searching the unit table for an appropriate location to install your driver. The <CODE>MyOpenDriver</CODE> function in <A HREF=Devices-13.html#MARKER-9-100>Listing 1-1 on page 1-18</A> calls this function and then uses the <CODE>OpenDriver</CODE> function to install and open the device driver.<P>
<B>Listing 1-14  <A NAME=MARKER-9-183></A>Finding space in the unit table</B><P>
<PRE>
short MyFindSpaceInUnitTable(void);
{
   Ptr      curUTableBase, newUTableBase;
   short    curUTableEntries, newUTableEntries;
   short    refNum, unitNum;
   
   /* get current unit table values from low memory globals */
   curUTableEntries = *(short*)UnitNtryCnt;
   curUTableBase = *(Ptr*)UTableBase;
   
   /* search for empty space in the current unit table */
   for ( unitNum = curUTableEntries - 1; 
         unitNum &gt;= 48; /* lowest available unit number */
         unitNum-- )
   {
      refNum = ~(unitNum);
      if (GetDCtlEntry(refNum) == nil)
         return(unitNum); /* found a space */
   }
   
   /* no space in the current table, so make a new one */
   
   /* increase the size of the table by 16 (an arbitrary value) */
   newUTableEntries = curUTableEntries + 16;
   
   /* allocate space for the new table */
   newUTableBase = 
      NewPtrSysClear((long)newUTableEntries * sizeof(Handle));
   if (newUTableBase == nil)
      return(memErr);
   
   /* copy the old table to the new table */
   BlockMove(curUTableBase, newUTableBase, 
             (long)curUTableEntries * sizeof(Handle));
   
   /* set the new unit table values in low memory */
   *(Ptr*)UTableBase = newUTableBase;
   *(short*)UnitNtryCnt = newUTableEntries;
   
   unitNum = newUTableEntries - 1;
   return(unitNum); 
}
</PRE>
 Although rare, it is possible for the unit table to become completely full. If the MyFindSpaceInUnitTable function does not find an empty unit table entry, it creates a larger unit table and copies the contents of the old unit table into the new one. To avoid the need for every driver to create a larger table, this function increases the size of the table by 16 entries--a reasonable amount in most cases. <P>
 The MyFindSpaceInUnitTable function does not need to disable interrupts when changing the values of the <A NAME=MARKER-2-184></A><CODE>UTableBase</CODE> and <A NAME=MARKER-2-185></A><CODE>UnitNtryCnt</CODE> system global variables because both unit tables are valid and drivers are not opened or closed at interrupt time.<P>
 Note that this function does not check for empty locations in the space reserved for desk accessories or SCSI drivers. You may wish to modify the function if you are installing one of these.<P>
<HR>
<B>Subtopics</B>
<B><!-- TOC --><DL>
<DT><A HREF="Devices-14.html#HEADING14-9">Creating a Driver Resource</A>
<DD>
<DT><A HREF="Devices-14.html#HEADING14-51">Responding to the Device Manager</A>
<DD>
<DT><A HREF="Devices-14.html#HEADING14-57">Entering and Exiting From Driver Routines</A>
<DD>
<DT><A HREF="Devices-14.html#HEADING14-69">Writing Open and Close Routines</A>
<DD>
<DT><A HREF="Devices-14.html#HEADING14-81">Writing a Prime Routine</A>
<DD>
<DT><A HREF="Devices-14.html#HEADING14-93">Writing Control and Status Routines</A>
<DD>
<DT><A HREF="Devices-14.html#HEADING14-108">Handling Asynchronous I/O</A>
<DD>
<DT><A HREF="Devices-14.html#HEADING14-118">Installing a Device Driver</A>
<DD>
</DL>
</B>
</BLOCKQUOTE>
<HR>
<center>
<A HREF="Devices-13.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Devices-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Devices-328.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="Devices-15.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="Devices-3.html">&copy; Apple Computer, Inc.</A><br>3 JUL 1996</center></font><P>
<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->
</BODY>
</HTML>  
