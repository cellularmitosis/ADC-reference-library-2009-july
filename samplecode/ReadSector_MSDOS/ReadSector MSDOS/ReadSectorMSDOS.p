(*	File:		ReadSectorMSDOS.p		Description:The question was: "I need to write an external file system for floppies				formatted like MS-DOS floppies, but with a different directory structure				on them."				The answer was: "Don't even think of writing an external file 				system (now)!".				Instead, convince yourself that reading and writing physical 				sectors on MS-DOS floppies is easy, and that you can implement				the required functionality within your application (as Apple 				File Exchange does).	Author:		JM	Copyright: 	Copyright: © 1992-1999 by Apple Computer, Inc.				all rights reserved.		Disclaimer:	You may incorporate this sample code into your applications without				restriction, though the sample code has been provided "AS IS" and the				responsibility for its operation is 100% yours.  However, what you are				not permitted to do is to redistribute the source as "DSC Sample Code"				after having made changes. If you're going to re-distribute the source,				we require that you make it clear in the source that the code was				descended from Apple Sample Code, but that you've made changes.		Change History (most recent first):				6/24/99	Updated for Metrowerks Codewarror Pro 2.1(KG)				1/92	Written for THINK Pascal(JM)*)program ReadSectorMSDOS;  	uses		Types,		Sound,		ToolUtils,		Devices;	const		cDriveNum = 1;  { internal drive }		cSectorSize = 512;		cSectorsPerTrack = 9;  { or 18, for HD disks }		cSides = 2;  { double-sided only, for now }	var		gSectBuffer: Ptr;	procedure BailOut (msg: Str255; err: Integer);	begin		if err <> 0 then			Writeln(msg, ' (', err : 6, ')')		else			Writeln(msg);		Writeln('(click mouse to quit)');		SysBeep(20);		repeat		until Button;		err := Eject(nil, cDriveNum);		ExitToShell;	end;	procedure Initialize;		var			r: Rect;	begin		SetRect(r, 10, 50, 460, 300);		(*SetTextRect(r);*)		(*ShowText;*)		gSectBuffer := NewPtr(cSectorSize);		if gSectBuffer = nil then			BailOut('not enough memory ', MemError);	end;	function FloppyInserted (drive: Integer): Boolean;		var			volumeName: Str255;			vRefNum: Integer;			freeBytes: Longint;			err: OsErr;			evt: EventRecord;			endRepeat: Boolean;	begin		err := Eject(nil, drive);  { make clear something will happen to the drive }		repeat			volumeName := '?';			err := GetVinfo(drive, @volumeName, vRefnum, freeBytes);			if err = nsvErr then  { no such volume }				begin					SysBeep(20);					Writeln('insert floppy in the internal drive');					Writeln('(if you have a SuperDrive , even an MS - DOS one !) ');					Writeln('or click the mouse to quit');					Writeln;					endRepeat := false;					repeat						if GetNextEvent(everyEvent, evt) then							endRepeat := (evt.what in [mouseDown, diskEvt]);					until endRepeat;					if evt.what = mouseDown then						begin							err := Eject(nil, drive);  { for convenience, just in case }							ExitToShell;						end					else						err := BitShift(evt.message, -16);  { is currently "extFSErr" for MS-DOS floppies }				end;		until err <> nsvErr;		FloppyInserted := (err <> nsvErr);  { should be more careful here! }	end;	procedure ReadSector (t, f, n: Integer; p: Ptr);{ read sector <n> on face <f> of track <t> into buffer <p> }		var			paramBlock: ParamBlockRec;			trackSize: Longint;			err: OsErr;	begin		trackSize := cSectorSize * cSectorsPerTrack;		with paramBlock do			begin				ioCompletion := nil;				ioVRefnum := cDriveNum;				ioRefnum := -5;				ioBuffer := p;				ioReqCount := cSectorSize;				ioPosMode := fsFromStart;				ioPosOffset := trackSize * (cSides * t + f) + cSectorSize * n;			end;		err := PBReadSync(@paramBlock);		if err <> noErr then			BailOut('PBRead returns ', err);	end;	procedure DisplaySector (t, f, n: Integer; p: Ptr);		var			i: Integer;			c: Char;			p0: Ptr;		function Hex (b: SignedByte): Str255;			var				hx: string[16];				s: str255;		begin			s := 'xx';			hx := '0123456789ABCDEF';			s[1] := hx[1 + BitAnd(BitShift(b, -4), $0F)];			s[2] := hx[1 + BitAnd(b, $0F)];			Hex := s;		end;	begin		p0 := p;		Writeln('Track ', t : 2, '  -- face ', f : 1, ' -- sector ', n : 2, ' (first 16 bytes):');		for i := 0 to 15 do			begin				Write(Hex(p^), ' ');				p := Ptr(Longint(p) + 1);			end;		Write('   ');		p := p0;		for i := 0 to 15 do			begin				c := chr(p^);				if ord(c) > 31 then					Write(c)				else					Write('.');				p := Ptr(Longint(p) + 1);			end;		Writeln;		Writeln;	end;	procedure DemoTime;		var			track: 0..79;			side: 0..1;			sector: 0..8;  { cSectorsPerTrack - 1 }	begin		track := 0;		side := 0;		sector := 0;		ReadSector(track, side, sector, gSectBuffer);		DisplaySector(track, side, sector, gSectBuffer);		BailOut('That''s all folks', 0);	end;begin	Initialize;	if FloppyInserted(cDriveNum) then		DemoTime;end.