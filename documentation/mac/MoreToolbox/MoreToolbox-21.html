<!-- Generated by Harlequin WebMaker 2.2.3 (23-Apr-1996)
LispWorks 3.2.2 -->
<HTML> <HEAD>
<TITLE>Reading and Manipulating Resources (IM: MTb)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING21></A>


<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="MoreToolbox-20.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="MoreToolbox-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="MoreToolbox-513.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="MoreToolbox-22.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="MoreToolbox-2.html"><B>More Macintosh Toolbox</B></A> / <BR><DD><A HREF="MoreToolbox-9.html"><B>Chapter 1 - Resource Manager</B></A> / <A HREF="MoreToolbox-16.html"><B>Using the Resource Manager</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING21-0></A>
<H2><A NAME=MARKER-9-167></A>Reading and Manipulating Resources</H2>
 <A NAME=MARKER-2-108></A>The Resource Manager provides a number of routines that read resources from a resource fork. When you request a resource, the Resource Manager follows the search path described in <A HREF=MoreToolbox-14.html#MARKER-9-104>"Search Path for Resources" on page 1-8</A>. That is, the Resource Manager searches each resource fork open to your application, beginning with the current resource file, and continues until it either finds the resource or reaches the end of the chain. <A NAME=MARKER-2-284></A><P>
 You can change where the Resource Manager starts its search using the <CODE>UseResFile</CODE> procedure. (See the previous section, <A HREF=MoreToolbox-20.html#MARKER-9-161>"Specifying the Current Resource File,"</A> for details.) You can limit the search to only the current resource file by using the Resource Manager routines that contain a "1" in their names, such as <CODE>Get1Resource</CODE>, <CODE>Get1NamedResource</CODE>, <CODE>Get1IndResource</CODE>, <CODE>Unique1ID</CODE>, and <CODE>Count1Resources</CODE>.<P>
 To get a resource, you can specify it by its resource type and resource ID or by its resource type and resource name. By convention, most applications refer to a resource by its resource type and resource ID, rather than by its resource type and resource name.<P>
 You can use the <CODE>SetResLoad</CODE> procedure to enable and disable automatic loading of resource data into memory for routines that return handles to resources. Such routines normally read the resource data into memory if it's not already there. This is the default setting and the effect of calling <CODE>SetResLoad</CODE> with the <CODE>load</CODE> parameter set to <CODE>TRUE</CODE>. If you call <CODE>SetResLoad</CODE> with the <CODE>load</CODE> parameter set to <CODE>FALSE</CODE>, subsequent calls to routines that return handles to resources will not load the resource data into memory. Instead, such routines return a handle whose master pointer is set to <CODE>NIL</CODE> unless the resource is already in memory. This setting is useful when you want to read from the resource map without reading the resource data into memory. To read the resource data into memory after a call to <CODE>SetResLoad</CODE> with the <CODE>load</CODE> parameter set to <CODE>FALSE</CODE>, call <CODE>LoadResource</CODE>.<P>
<DL>
<DT><B>WARNING</B>
<DD>If you call <CODE>SetResLoad</CODE> with the <CODE>load</CODE> parameter set to <CODE>FALSE</CODE>, be sure to call <CODE>SetResLoad</CODE> with the <CODE>load</CODE> parameter set to <CODE>TRUE</CODE> as soon as possible. Other parts of system software that call the Resource Manager rely on the default setting (the <CODE>load</CODE> parameter set to <CODE>TRUE</CODE>), and some routines won't work if resources are not loaded automatically.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
 In addition to the <CODE>SetResLoad</CODE> procedure, you can use the preloaded attribute of an individual resource to control loading of that resource's data into memory. The Resource Manager loads a resource into memory when it first opens a resource fork if the resource's preloaded attribute is set. <P>
<DL>
<DT><B>Note</B>
<DD>If both the preloaded attribute and the locked attribute are set, the Resource Manager loads the resource as low in the heap as possible.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
 Here's an example of a situation in which an application might need to read a resource. The SurfWriter application always saves the last position of a document window when the user saves the document, storing this information in a resource that it has defined for this purpose. SurfWriter defines a resource with resource type rWinState and resource ID <CODE>kLastWinStateID</CODE> to store information about the window (its position and its state--that is, either the user state or the standard state). SurfWriter's window state resource has this format, defined by a record of type <CODE>MyWindowState</CODE>:<P>
<PRE>
TYPE MyWindowState =
   RECORD
      userStateRect: Rect;    {user state rectangle}
      zoomState:     Boolean; {window state: TRUE = standard; }
                              {              FALSE = user}
   END;
   MyWindowStatePtr = ^MyWindowState;
   MyWindowStateHnd = ^MyWindowStatePtr;
</PRE>
 <A HREF=#MARKER-9-170>Listing 1-9</A> shows a procedure called <CODE>MySetWindowPosition</CODE> that the SurfWriter application uses in the process of opening a document. The SurfWriter application stores the last location of a document in its window state resource. When SurfWriter opens the document again, it uses <CODE>MySetWindowPosition</CODE> to read the document's window state resource and uses the resource data to set the window's location.<P>
<B>Listing 1-9  <A NAME=MARKER-9-170></A>Getting a resource from a document file<A NAME=MARKER-2-378></A></B><P>
<PRE>
PROCEDURE MySetWindowPosition (myWindow: WindowPtr);
VAR
   myData:              MyDocRecHnd;
   lastUserStateRect:   Rect;
   stdStateRect:        Rect;
   curStateRect:        Rect;
   myRefNum:            Integer;
   myStateHandle:       MyWindowStateHnd;
   resourceGood:        Boolean;
   savePort:            GrafPtr;
   myErr:               OSErr;
BEGIN
   myData := MyDocRecHnd(GetWRefCon(myWindow));    {get document record}
   HLock(Handle(myData));        {lock the record while manipulating it}
   {open the resource fork and get its file reference number}
   myRefNum := FSpOpenResFile(myData^^.fileFSSpec, fsRdWrPerm);
   myErr := ResError;
   IF myErr &lt;&gt; noErr THEN
      Exit(MySetWindowPosition);
   {get handle to rectangle that describes document's last window position}
   myStateHandle := MyWindowStateHnd(Get1Resource(rWinState,
                                                   kLastWinStateID));
   IF myStateHandle &lt;&gt; NIL THEN                 {handle to data succeeded}
   BEGIN    {retrieve the saved user state}
      lastUserStateRect := myStateHandle^^.userStateRect;
      resourceGood := TRUE;
   END
   ELSE
   BEGIN
      lastUserStateRect.top := 0;   {force MyVerifyPosition to calculate }
      resourceGood := FALSE;        { the default position}
   END;



   {verify that user state is practical and calculate new standard state}
   MyVerifyPosition(myWindow, lastUserStateRect, stdStateRect);
   IF resourceGood THEN                   {document had state resource}
      IF myStateHandle^^.zoomState THEN   {if window was in standard state }
         curStateRect := stdStateRect     { when saved, display it in }
                                          { newly calculated standard state}
      ELSE                 {otherwise, current state is the user state}
         curStateRect := lastUserStateRect
   ELSE                                   {document had no state resource}
      curStateRect := lastUserStateRect;  {use default user state}
   {move window}
   MoveWindow(myWindow, curStateRect.left, curStateRect.top, FALSE);
   {convert to local coordinates and resize window}
   GetPort(savePort);
   SetPort(myWindow);
   GlobalToLocal(curStateRect.topLeft);
   GlobalToLocal(curStateRect.botRight);
   SizeWindow(myWindow, curStateRect.right, curStateRect.bottom, TRUE);
   IF resourceGood THEN    {reset user state and standard }
   BEGIN                   { state--SizeWindow may have changed them}
      MySetWindowUserState(myWindow, lastUserStateRect);
      MySetWindowStdState(myWindow, stdStateRect);
   END;
   ReleaseResource(Handle(myStateHandle));         {clean up}
   CloseResFile(myRefNum);
   HUnlock(Handle(myData));
   SetPort(savePort);
END;
</PRE>
 The <CODE>MySetWindowPosition</CODE> procedure uses the <CODE>FSpOpenResFile</CODE> function to open the document's resource fork, then uses <CODE>Get1Resource</CODE> to get a handle to the resource that contains information about the window's last position. The procedure can then verify that the saved position is practical and move the window to that position.<P>
 Note that when a Resource Manager routine returns a handle to a resource, the routine returns the resource using the <CODE>Handle</CODE> data type. You usually define a data type (such as <CODE>MyWindowState</CODE>) to access the resource's data. If you also define a handle to your defined data type (such as <CODE>MyWindowStateHnd</CODE>), you need to coerce the returned handle to the appropriate type, as shown in this line from <A HREF=#MARKER-9-170>Listing 1-9</A>:<A NAME=MARKER-2-100></A><P>
<PRE>
myStateHandle := MyWindowStateHnd(Get1Resource(rWinState, kLastWinStateID));
</PRE>
 If you use this method, you also need to coerce your defined handle back to a handle of type <CODE>Handle</CODE> when you use other Resource Manager routines. For example, after it has finished moving the window, <CODE>MySetWindowPosition</CODE> uses <CODE>ReleaseResource</CODE> to release the memory allocated to the resource's data (which also sets the master pointer of the resource's handle in the resource map in memory to <CODE>NIL</CODE>). As shown in this line from <A HREF=#MARKER-9-170>Listing 1-9</A>, SurfWriter coerces the defined handle back to a handle:<P>
<PRE>
ReleaseResource(Handle(myStateHandle));
</PRE>
 After releasing the resource data's memory, <CODE>MySetWindowPosition</CODE> uses the <CODE>CloseResFile</CODE> procedure to close the resource fork.<P>
<DL>
<DT><B>Note</B>
<DD><A HREF=#MARKER-9-170>Listing 1-9</A> assumes the window state resource is not purgeable. If it were, <CODE>MySetWindowPosition</CODE> would need to call <CODE>LoadResource</CODE> before accessing the data in the resource.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
 The Resource Manager also provides routines that let you index through all resources of a given type (for example, using <CODE>CountResources</CODE> and <CODE>GetIndResource</CODE>). This can be useful whenever you want to read all the resources of a given type.<P>
 <A HREF=#MARKER-9-174>Listing 1-10</A> shows an application-defined procedure that allows a user to open a file that contains sound resources. The SurfWriter application opens the specified file, counts the number of <CODE>'snd '</CODE> resources in the file, then performs an operation on each <CODE>'snd '</CODE> resource (adding the name of each resource to its Sounds menu). <A NAME=MARKER-9-188></A><P>
<B>Listing 1-10  <A NAME=MARKER-9-174></A>Counting and indexing through resources <A NAME=MARKER-9-410></A></B><P>
<PRE>
PROCEDURE MyDoOpenSoundResources;
VAR
   mySFReply:     StandardFileReply;{reply record}
   myNumTypes:    Integer;          {number of types to display}
   myTypeList:    SFTypeList;       {file type of files}
   myRefNum:      Integer;          {resource file reference no}
   mySndHandle:   Handle;           {handle to sound resource}
   numberOfSnds:  Integer;          {# of sounds in resource file}
   index:         Integer;          {index of sound resource}
   resName:       Str255;           {name of sound resource}
   curRes:        Integer;          {saved current resource file}
   myType:        ResType;          {resource type}
   myResID:       Integer;          {resource ID of snd resource}
   myWindow:      WindowPtr;        {window pointer}
   menu:          MenuHandle;       {handle to Sounds menu}
   myErr:         OSErr;            {error information}


BEGIN
   curRes := CurResFile;
   myWindow := FrontWindow;
   MyDoActivate(myWindow, FALSE);   {deactivate front window}
   myTypeList[0] := 'SFSD';         {show files of this type}
   myNumTypes := 1;  
   {let user choose a file that contains sound resources}
   StandardGetFile(NIL, myNumTypes, myTypeList, mySFReply);
   IF mySFReply.sfGood = TRUE THEN
   BEGIN
      myRefNum := FSpOpenResFile(mySFReply.sfFile, fsRdWrPerm);
      IF myRefNum = -1 THEN 
         DoError;
      menu := GetMenuHandle(mSounds);
      numberOfSnds := Count1Resources('snd ');  
      FOR index := 1 TO numberOfSnds DO
      BEGIN {the loop}
         mySndHandle := Get1IndResource('snd ', index);  
         IF mySndHandle = NIL THEN
            DoError
         ELSE
         BEGIN
            GetResInfo(mySndHandle, myResID, myType, resName);
            AppendMenu(menu, resName);
            ReleaseResource(mySndHandle);
         END;  {of mySndHandle &lt;&gt; NIL}
      END;  {of the loop}
   UseResFile(curRes);
   gSoundResFileRefNum := myRefNum;
   END;  {of sfReply.good}
END;
</PRE>
 After the user selects a file that contains SurfWriter sound resources (that is, a file of type <CODE>'SFSD'</CODE>), the <CODE>MyDoOpenSoundResources</CODE> procedure calls <CODE>FSpOpenResFile</CODE> to open the file's resource fork and obtain its file reference number. (If <CODE>FSpOpenResFile</CODE> fails to open the resource fork, it returns -1 instead of a file reference number.) The <CODE>MyDoOpenSoundResources</CODE> procedure then uses the <CODE>Count1Resources</CODE> function to count the number of <CODE>'snd '</CODE> resources in the resource fork. It can then index through the resources one at a time, using <CODE>Get1IndResource</CODE> to open each resource, <CODE>GetResInfo</CODE> to get the resource's name, and <CODE>AppendMenu</CODE> to append each name to SurfWriter's Sounds menu. <A NAME=MARKER-9-99></A> <A NAME=MARKER-9-111></A><P>
<DL>
<DT><B>Note</B>
<DD>In most situations, you can use the Menu Manager procedure <CODE>AppendResMenu</CODE> to add names of resources to a menu. See <I><A HREF="../Toolbox/Toolbox-2.html">Inside Macintosh: Macintosh Toolbox Essentials</A></I> for details.<EM></EM>   <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
</BLOCKQUOTE>
<HR>
<center>
<A HREF="MoreToolbox-20.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="MoreToolbox-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="MoreToolbox-513.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="MoreToolbox-22.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="MoreToolbox-3.html">&copy; Apple Computer, Inc.</A><br>6 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>   
