<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>Core Image Programming Guide: Core Image Concepts</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Core Image Concepts"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP30001185-CH202" title="Core Image Concepts"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../index.html#//apple_ref/doc/uid/TP30000440-TP30000424" target="_top">Graphics &amp; Imaging</a> &gt; <a href="../../../Quartz-date.html#//apple_ref/doc/uid/TP30000440-TP30000424-TP30000559" target="_top">Quartz</a> &gt; <a href="../ci_intro/ci_intro.html#//apple_ref/doc/uid/TP30001185-CH201-TPXREF101">Core Image Programming Guide</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../ci_intro/ci_intro.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../ci_tasks/ci_tasks.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP30001185-CH202-TPXREF101" title="Core Image Concepts"></a><h1>Core Image Concepts</h1><p>Core Image is an extensible architecture available starting in Mac OS X v10.4 for near real-time, pixel-accurate image processing of graphics as well as video. You can perform the following types of operations by using filters that are bundled in Core Image or that you or another developer create: </p><ul class="ul"><li class="li"><p>Crop images.</p></li><li class="li"><p>Correct color, such as perform white point adjustment.</p></li><li class="li"><p>Apply color effects, such as sepia tone.</p></li><li class="li"><p>Blur or sharpen images.</p></li><li class="li"><p>Composite images.</p></li><li class="li"><p>Warp or transform the geometry of an image.</p></li><li class="li"><p>Generate color, checkerboard patterns, Gaussian gradients, and other pattern images.</p></li><li class="li"><p>Add transition effects to images or video.</p></li><li class="li"><p>Provide real-time color adjustment on video.</p></li></ul><p><span class="content_text">Figure 1-1</span> gives a general idea of where Core Image fits with other graphics technologies in Mac OS X. Core Image is integrated with these technologies, allowing you to use them together to achieve a wide range of results. For example, you can use Core Image to process images created in Quartz 2D (Core Graphics) and textures created in OpenGL. You can also apply Core Image filters to video played using Core Video.</p><br/><div><a name="//apple_ref/doc/uid/TP30001185-CH202-BCIIDDFA" title="Figure 1-1Core Image in relation to other graphics technologies"></a><p><strong>Figure 1-1&nbsp;&nbsp;</strong>Core Image in relation to other graphics technologies</p><img src = "../art/graphics_arch.gif" alt = "Core Image in relation to other graphics technologies" width="305" height="158"></div><br/><p>This chapter provides an overview of the Core Image technology and describes how you can use the programming interface in your application. It also discusses how Core Image works behind the scenes to achieve fast, stunning, near real-time image processing.</p>
<!-- This template is being used for both PDF and HTML. -->

    
    <h4>In this section:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="ci_concepts.html#//apple_ref/doc/uid/TP30001185-CH202-SW2">Core Image and the GPU</a>
				
			<br/>
			
        
			
			
				<a href="ci_concepts.html#//apple_ref/doc/uid/TP30001185-CH202-BCIHDIEG">Filter Clients and Filter Creators</a>
				
			<br/>
			
        
			
			
				<a href="ci_concepts.html#//apple_ref/doc/uid/TP30001185-CH202-SW5">The Processing Path</a>
				
			<br/>
			
        
			
			
				<a href="ci_concepts.html#//apple_ref/doc/uid/TP30001185-CH202-SW1">Coordinate Spaces</a>
				
			<br/>
			
        
			
			
				<a href="ci_concepts.html#//apple_ref/doc/uid/TP30001185-CH202-BCIGEFIE">The Region of Interest</a>
				
			<br/>
			
        
			
			
				<a href="ci_concepts.html#//apple_ref/doc/uid/TP30001185-CH202-BCIGFIEI">Executable and Nonexecutable Filters</a>
				
			<br/>
			
        
			
			
				<a href="ci_concepts.html#//apple_ref/doc/uid/TP30001185-CH202-BCIDAIEJ">Color Components and Premultiplied Alpha</a>
				
			<br/>
			
        
			
			
				<a href="ci_concepts.html#//apple_ref/doc/uid/TP30001185-CH202-SW7">See Also</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP30001185-CH202-SW2" title="Core Image and the GPU"></a><h2>Core Image and the GPU</h2><p>Up until now OpenGL, the industry standard for high performance 2D and 3D graphics, has been the primary gateway to the graphics processing unit (GPU). If you wanted to use the GPU for image processing, you needed to know OpenGL Shading Language. Core Image changes all that. With Core Image, you don’t need to know the details of OpenGL to harness the power of the GPU for image processing. Core Image handles OpenGL buffers and state management for you automatically. If for some reason a GPU is not available, Core Image uses a CPU fallback to ensure that your application runs. Core Image operations are opaque to you; your software just works.</p><p>Core Image hides the details of low-level graphics processing by providing an easy-to-use application programming interface (API) implemented in the Objective-C language. The Core Image API is part of the Quartz Core framework (<code>QuartzCore.framework</code>). You can use Core Image from the Cocoa and Carbon frameworks by linking to this framework.</p><a name="//apple_ref/doc/uid/TP30001185-CH202-BCIHDIEG" title="Filter Clients and Filter Creators"></a><h2>Filter Clients and Filter Creators</h2><p>Core Image is designed for two types of developers—filter clients and filter creators. If you plan only to use Core Image filters, you are a <strong>filter client</strong>. If you plan to write your own filter, you are a <strong>filter creator</strong>. This section describes Core Image filters from the perspective of each type of developer, and provides an overview of what each needs to know to use Core Image.</p><p>Core Image comes with over 100 built-in filters ready to use by filter clients who want to support image processing in their application. <em><a href="../../../Reference/CoreImageFilterReference/index.html#//apple_ref/doc/uid/TP40004346" target="_top">Core Image Filter Reference</a></em> describes these filters. The list of built-in filters can change, so for that reason, Core Image provides methods that let you query the system for the available filters. You can also load filters that third-party developers package as image units. You’ll read more about image units later in this chapter.</p><p>You can get a list of all filters or narrow your query to get filters that fit a particular category, such as distortion filters or filters that work with video. A <strong>filter category</strong> specifies the type of effect—blur, distortion, generator, and so forth—or its intended use—still images, video, nonsquare pixels, and so on. A filter can be a member of more than one category. A filter also has a <strong>display name</strong>, which is the name that should be shown in the user interface and a <strong>filter name</strong>, which is the name you use to access the filter programmatically. You’ll see how to perform queries in <span class="content_text"><a href="../ci_tasks/ci_tasks.html#//apple_ref/doc/uid/TP30001185-CH203-TPXREF101">“Using Core Image Filters.”</a></span> </p><p>Most filters have one or more <strong>input parameters</strong> that let you control how processing is done. Each input parameter has an <strong>attribute class</strong> that specifies its data type, such as <code>NSNumber</code>. An input parameter can optionally have other attributes, such as its default value, the allowable minimum and maximum values, the display name for the parameter, and any other attributes that are described in <span class="content_text"><!--a target="_top" -->CIFilter<!--/a--></span>.</p><p>For example, the color monochrome filter has three input parameters—the image to process, a monochrome color, and the color intensity. You supply the image and have the option to set a color and color intensity. Most filters, including the color monochrome filter, have default values for each nonimage input parameter. Core Image uses the default values to process your image if you choose not to supply your own values for the input parameters. </p><p>Filter attributes are stored as key-value pairs. The key is a constant that identifies the attribute and the value is the setting associated with the key. Core Image attribute values are typically one of the following data types: </p><ul class="ul"><li class="li"><p>Strings (<code>NSString</code> objects), which are used for such things as display names.</p></li><li class="li"><p>Floating-point numbers (<code>NSNumber</code> data type), which are used to specify scalar values such as intensity levels and radii.</p></li><li class="li"><p>Vectors (<code>CIVector</code> objects), which can have 2, 3, or 4 elements, each of which is a floating-point number. These are used to specify positions, areas, and color values.</p></li><li class="li"><p>Colors (<code>CIColor</code> objects), which specify color values and a color space to interpret the values in.</p></li><li class="li"><p>Images (<code>CIImage</code> objects), which are lightweight objects that specify image “recipes.”</p></li><li class="li"><p>Transforms (<code>NSAffineTransform</code> objects), which specify an affine transformation to apply to an image.</p></li></ul><p>Core Image uses key-value coding, which means you can get and set values for the attributes of a filter by using the methods provided by the <code>NSKeyValueCoding</code> protocol.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP30001185-CH202-SW3" title="Note"></a><p><strong>Note:</strong>&nbsp;Key-value coding is a mechanism for accessing the properties of objects in Objective-C. To use Core Image effectively, you need to be familiar with the <code>NSKeyValueCoding</code> protocol. For more information, see <em><a href="../../../../Cocoa/Conceptual/KeyValueCoding/index.html#//apple_ref/doc/uid/10000107i" target="_top">Key-Value Coding Programming Guide</a></em>.</p></div><p>Let’s take a closer look at the components of a typical filter, as shown in <span class="content_text">Figure 1-2</span>. The shaded area of the figure indicates parts that are “under the hood”—the parts that a filter client does not need to know anything about but which a filter creator must understand. The portion that’s not shaded shows two methods—<code>attributes</code> and <code>outputImage</code>—that the filter client calls. The filter’s <code>attributes</code> method is what you call to obtain a list of the filter attributes discussed previously, including the filter’s input parameters and the string that you can use to display the filter name in the user interface. The <code>outputImage</code> method assembles and stores the calculations necessary to produce an image but does not actually cause Core Image to process the image. That’s because Core Image uses <strong>lazy evaluation</strong>. In other words, Core Image doesn’t process any image until it comes time to actually paint the processed pixels to a destination. All the <code>outputImage</code> method does is to assemble the calculations that Core Image needs when the time comes, and store the calculations (or, image “recipe”) in a <code>CIImage</code> object. The actual image is only rendered (and hence, the calculations performed) if there is an explicit call to an image-drawing method, such as <code><a href="../../../Reference/QuartzCoreFramework/Classes/CIContext_Class/Reference/Reference.html#//apple_ref/occ/instm/CIContext/drawImage:atPoint:fromRect:" target="_top">drawImage:atPoint:fromRect:</a></code> or <code><a href="../../../Reference/QuartzCoreFramework/Classes/CIContext_Class/Reference/Reference.html#//apple_ref/occ/instm/CIContext/drawImage:inRect:fromRect:" target="_top">drawImage:inRect:fromRect:</a></code>.</p><br/><div><a name="//apple_ref/doc/uid/TP30001185-CH202-BCICEGDA" title="Figure 1-2The components of a typical filter"></a><p><strong>Figure 1-2&nbsp;&nbsp;</strong>The components of a typical filter</p><img src = "../art/filter_anatomy.gif" alt = "The components of a typical filter" width="452" height="233"></div><br/><p>Core Image stores the calculations until your application issues a command to draw the image. At that time, Core Image calculates the results. Lazy evaluation is one of the practices that makes Core Image fast and efficient. At rendering time, Core Image can see if more than one filter needs to be applied to an image. If so, it can concatenate multiple “recipes” into one operation, which means each pixel is processed once rather than many times. <span class="content_text">Figure 1-3</span> illustrates how lazy evaluation can make image processing more efficient for multiple operations. The final image is a scaled-down version of the original. For the case of a large image, applying color adjustment before scaling down the image requires more processing power than scaling down the image and then applying color adjustment. Because Core Image waits until the last possible moment to apply filters, it can perform these operations in reverse order, which is more efficient.</p><br/><div><a name="//apple_ref/doc/uid/TP30001185-CH202-BCIIHBED" title="Figure 1-3A work flow that can benefit from lazy evaluation"></a><p><strong>Figure 1-3&nbsp;&nbsp;</strong>A work flow that can benefit from lazy evaluation</p><img src = "../art/ci_ill1.gif" alt = "A work flow that can benefit from lazy evaluation" width="393" height="125"></div><br/><p>For the filter creator, the most exciting component of a filter is the kernel, which is at the heart of every filter. The <strong>kernel</strong> specifies the calculations that are performed on each source image pixel. Kernel calculations can be very simple or complex. A very simple kernel for a “do nothing” filter could simply return the source pixel:</p><p><code>destination pixel = source pixel</code></p><p>Filter creators use a variant of OpenGL Shading Language (glslang) to specify per-pixel calculations. (See <em><a href="../../../Reference/CIKernelLangRef/index.html#//apple_ref/doc/uid/TP40004397" target="_top">Core Image Kernel Language Reference</a></em>.) The kernel is opaque to a filter client. A filter can actually use several kernel routines, passing the output of one to the input of another. For instructions on how to write a custom filter, see <span class="content_text"><a href="../ci_custom_filters/ci_custom_filters.html#//apple_ref/doc/uid/TP30001185-CH207-CJBEDHHH">“Creating a Custom Filter.”</a></span></p><div class="notebox"><a name="//apple_ref/doc/uid/TP30001185-CH202-SW4" title="Note"></a><p><strong>Note:</strong>&nbsp; A kernel is the actual routine, written using the Core Image variant of glslang, that a filter uses to process pixels. A <code>CIKernel</code> object is a Core Image object that contains a kernel routine. When you create a filter, you’ll see that the kernel routine exists in its own file—one that has a <code>.cikernel</code> extension. You create a <code>CIKernel</code> object programmatically by passing a string that contains the kernel routine.</p></div><p>Filter creators can make their custom filters available to any application by packaging them as a plug-in, or <strong>image unit</strong>, using the architecture specified by the <code><!--a target="_top" -->NSBundle<!--/a--></code>  class. An image unit can contain more than one filter, as shown in <span class="content_text">Figure 1-4</span>. For example, you could write a set of filters that perform different kinds of edge detection and package them as a single image unit. Filter clients can use the Core Image API to load the image unit and to obtain a list of the filters contained in that image unit. See <span class="content_text"><a href="../ci_tasks/ci_tasks.html#//apple_ref/doc/uid/TP30001185-CH203-SW2">“Loading Image Units”</a></span> for basic information. See <em><a href="../../ImageUnitTutorial/index.html#//apple_ref/doc/uid/TP40004531" target="_top">Image Unit Tutorial</a></em> for in-depth examples and detailed information on writing filters and packaging them as standalone image units.</p><br/><div><a name="//apple_ref/doc/uid/TP30001185-CH202-BCIGCDHD" title="Figure 1-4An image unit contains packaging information along with one or more filter definitions"></a><p><strong>Figure 1-4&nbsp;&nbsp;</strong>An image unit contains packaging information along with one or more filter definitions</p><img src = "../art/contents_image_unit.gif" alt = "An image unit contains packaging information along with one or more filter definitions" width="254" height="130"></div><br/><a name="//apple_ref/doc/uid/TP30001185-CH202-SW5" title="The Processing Path"></a><h2>The Processing Path</h2><p><span class="content_text">Figure 1-5</span> shows the pixel processing path for a filter that operates on two sources images. Source images are always specified as <code>CIImage</code> objects. Core Image provides a variety of ways to get image data. You can supply a URL to an image, read raw image data (using the <code><!--a target="_top" -->NSData<!--/a--></code> class), or convert a Quartz 2D image (<code><a href="../../../Reference/CGContext/Reference/reference.html#//apple_ref/c/tdef/CGContextRef" target="_top">CGContextRef</a></code>), an OpenGL texture, or a Core Video image buffer (<code><a href="../../../Reference/CoreVideoRef/Reference/reference.html#//apple_ref/c/tdef/CVImageBufferRef" target="_top">CVImageBufferRef</a></code>) to a <code>CIImage</code> object.</p><p>Note that the actual number of input images, and whether or not the filter requires an input image, depends on the filter. Filters are very flexible—a filter can:</p><ul class="ul"><li class="li"><p>Work without an input image. Some filters generate an image based on input parameters that aren’t images. (For example, see the <code>CICheckerboardGenerator</code> and <code>CIConstantColorGenerator</code> filters in <em><a href="../../../Reference/CoreImageFilterReference/index.html#//apple_ref/doc/uid/TP40004346" target="_top">Core Image Filter Reference</a></em>.)</p></li><li class="li"><p>Require one image. (For example, see the <code>CIColorPosterize</code> and <code>CICMYKHalftone</code> filters in <em><a href="../../../Reference/CoreImageFilterReference/index.html#//apple_ref/doc/uid/TP40004346" target="_top">Core Image Filter Reference</a></em>.)</p></li><li class="li"><p>Require two or more images. Filters that composite images or use the values in one image to control how the pixels in another image are processed typically require two or more images. One input image can act as a shading image, an image mask, a background image, or provide a source of lookup values that control some aspect of how the other image is processed. (For example, see the <code>CIShadedMaterial</code>  filter in <em><a href="../../../Reference/CoreImageFilterReference/index.html#//apple_ref/doc/uid/TP40004346" target="_top">Core Image Filter Reference</a></em>.) </p></li></ul><p>When you process an image, it is your responsibility to create a <code>CIImage</code> object that contains the appropriate input data.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP30001185-CH202-SW6" title="Note"></a><p><strong>Note:</strong>&nbsp; Although a <code>CIImage</code> object has image data associated with it, it is not an image. You can think of a <code>CIImage</code> object as an image “recipe.” A <code>CIImage</code> object has all the information necessary to produce an image, but Core Image doesn’t actually render an image until it is told to do so. This “lazy evaluation” method (see <span class="content_text"><a href="ci_concepts.html#//apple_ref/doc/uid/TP30001185-CH202-BCIHDIEG">“Filter Clients and Filter Creators”</a></span>) allows Core Image to operate as efficiently as possible.</p></div><br/><div><a name="//apple_ref/doc/uid/TP30001185-CH202-BCICJFAI" title="Figure 1-5The pixel processing path"></a><p><strong>Figure 1-5&nbsp;&nbsp;</strong>The pixel processing path</p><img src = "../art/pixel_processing_path.gif" alt = "The pixel processing path" width="259" height="258"></div><br/><p>Pixels from each source image are fetched by a <code>CISampler</code> object, or simply a sampler. As its name suggests, a <strong>sampler</strong> retrieves samples of an image and provides them to a kernel. A filter creator provides a sampler for each source image. Filter clients don’t need to know anything about samplers.</p><p>A sampler defines:</p><ul class="ul"><li class="li"><p>A coordinate transform, which can be the identity transform if no transformation is needed.</p></li><li class="li"><p>An interpolation mode, which can be nearest neighbor sampling or bilinear interpolation (which is the default).</p></li><li class="li"><p>A wrapping mode that specifies how to produce pixels when the sampled area is outside of the source image—either to use transparent black or clamp to the extent.</p></li></ul><p>The filter creator defines the per-pixel image processing calculations in the kernel, but Core Image handles the actual implementation of those calculations. Core Image determines whether the calculations are performed using the GPU or the CPU. Core Image implements hardware rasterization through OpenGL. It implements software rasterization through an emulation environment specifically tuned for evaluating fragment programs with nonprojective texture lookups over large quadrilaterals (quads).</p><p>Although the pixel processing path is from source image to destination, the calculation path that Core Image uses begins at the destination and works its way back to the source pixels, as shown in <span class="content_text">Figure 1-6</span>. This backward calculation might seem unwieldy, but it actually minimizes the number of pixels used in any calculation. The alternative, which Core Image does not use, is the brute force method of processing all source pixels, then later deciding what’s needed for the destination. Let’s take a closer look at <span class="content_text">Figure 1-6</span>.</p><br/><div><a name="//apple_ref/doc/uid/TP30001185-CH202-BCIGJEBF" title="Figure 1-6The Core Image calculation path"></a><p><strong>Figure 1-6&nbsp;&nbsp;</strong>The Core Image calculation path</p><img src = "../art/dod_calculation_path.gif" alt = "The Core Image calculation path" width="485" height="322"></div><br/><p>Assume that the filter in <span class="content_text">Figure 1-6</span> performs some kind of compositing operation, such as source-over compositing. The filter client wants to overlap the two images, so that only a small portion of each image is composited to achieve the result shown at the left side of the figure. By looking ahead to what the destination ought to be, Core Image can determine which data from the source images effect the final image and then restrict calculations only to those source pixels. As a result, the samplers fetch samples only from shaded areas in the source images shown in <span class="content_text">Figure 1-6</span>. </p><p>Note the box in the figure that’s labeled <strong>domain of definition</strong>. The domain of definition is simply a way to further restrict calculations. It is an area outside of which all pixels are transparent (that is, the alpha component is equal to 0). In this example, the domain of definition coincides exactly with the destination image. Core Image lets you supply a <code>CIFilterShape</code> object to define this area. The <code>CIFilterShape</code> class provides a number of methods that can define rectangular shapes, transform shapes, and perform inset, union, and intersection operations on shapes. For example, if you define a filter shape using a rectangle that is smaller than the shaded area shown in <span class="content_text">Figure 1-6</span>, then Core Image uses that information to further restrict the source pixels used in the calculation.</p><p>Core Image promotes efficient processing in other ways. It performs intelligent caching and compiler optimizations that make it well suited for such tasks as real-time video control. It caches intermediate results for any data set that is evaluated repeatedly. Core Image evicts data in least-recently-used order whenever adding a new image would cause the cache to grow too large, which means objects that are reused frequently remain in the cache, while those used once in a while might be moved in and out of the cache as needed. Your application benefits from Core Image caching without needing to know the details of how caching is implemented. However, you get the best performance by reusing objects (images, contexts, and so forth) whenever you can.</p><p>Core Image also gets great performance by using traditional compilation techniques at the kernel and pass levels. The method Core Image uses to allocate registers minimizes the number of temporary registers (per kernel) and temporary pixel buffers (per filter graph). The compiler performs CSE and peephole optimization and automatically distinguishes between reading data-dependent textures, which are based on previous calculations, and those that are not data-dependent. Again, you don’t need to concern yourself with the details of the compilation techniques. The important point is that Core Image is hardware savvy; it uses the power of the GPU whenever it can, and it does so in smart ways. </p><a name="//apple_ref/doc/uid/TP30001185-CH202-SW1" title="Coordinate Spaces "></a><h2>Coordinate Spaces </h2><p>Core Image performs operations in a device-independent working space, similar in concept to what’s shown in <span class="content_text">Figure 1-7</span>. The Core Image working space is, in theory, infinite in extent. A point in working space is represented by a coordinate pair (<em>x</em>, <em>y</em>), where <em>x</em> represents the location along the horizontal axis and <em>y</em> represents the location along the vertical axis. Coordinates are floating-point values. By default, the origin is point (0,0). </p><p>When Core Image reads images, it translates the pixel locations into device-independent working space coordinates. When it is time to display a processed image, Core Image translates the working space coordinates to the appropriate coordinates for the destination, such as a display. </p><br/><div><a name="//apple_ref/doc/uid/TP30001185-CH202-BCIEFIFH" title="Figure 1-7Core Image performs image operations in a device-independent working space"></a><p><strong>Figure 1-7&nbsp;&nbsp;</strong>Core Image performs image operations in a device-independent working space</p><img src = "../art/ci_ill4.gif" alt = "Core Image performs image operations in a device-independent working space" width="218" height="139"></div><br/><p>When you write your own filters, you need to be familiar with two coordinate spaces—the destination coordinate space and the sampler space. The destination coordinate space represents the image you are rendering to. The sampler space represents what you are texturing from (another image, a lookup table, and so on). You obtain the current location in destination space using the <code>destCoord</code> function whereas the <code>samplerCoord</code> function provides the current location in sample space. (See <em><a href="../../../Reference/CIKernelLangRef/index.html#//apple_ref/doc/uid/TP40004397" target="_top">Core Image Kernel Language Reference</a></em>.)</p><p>Keep in mind that if your source data is tiled, the sampler coordinates have an offset (dx/dy). If your sample coordinates have an offset, it may be necessary for you to convert the destination location to the sampler location using the function <code>samplerTransform</code>. </p><a name="//apple_ref/doc/uid/TP30001185-CH202-BCIGEFIE" title="The Region of Interest"></a><h2>The Region of Interest</h2><p>Although not explicitly labeled in <span class="content_text"><a href="ci_concepts.html#//apple_ref/doc/uid/TP30001185-CH202-BCIGJEBF">Figure 1-6</a></span>, the shaded area in each of the source images is the <strong>region of interest</strong> for samplers depicted in the figure. The region of interest, or ROI, defines the area in the source from which a sampler takes pixel information to provide to the kernel for processing. If you are a filter client, you don’t need to concern yourself with the ROI. But if you are a filter creator, you’ll want to understand the relationship between the region of interest and the domain of definition.</p><p>Recall that the domain of definition describes the bounding shape of a filter. In theory, this shape can be without bounds. Consider, for example, a filter that creates a repeating pattern that could extend to infinity.</p><p>The ROI and the domain of definition can relate to each other in the following ways:</p><ul class="ul"><li class="li"><p>They coincide exactly—there is a 1:1 mapping between source and destination. For example, a hue filter processes a pixel from the working space coordinate (<em>r</em>,<em>s</em>) in the ROI to produce a pixel at the working space coordinate (<em>r</em>,<em>s</em>) in the domain of definition.</p></li><li class="li"><p>They are dependent on each other, but modulated in some way. Some of the most interesting filters—blur and distortion, for example—use many source pixels in the calculation of one destination pixel. For example, a distortion filter might use a pixel (<em>r</em>,<em>s</em>) and its neighbors from the working coordinate space in the ROI to produce a single pixel (<em>r</em>,<em>s</em>) in the domain of definition. </p></li><li class="li"><p>The domain of definition is calculated from values in a lookup table that are provided by the sampler. The location of values in the map or table are unrelated to the working space coordinates in the source image and the destination. A value located at (<em>r</em>,<em>s</em>) in a shading image does not need to be the value that produces a pixel at the working space coordinate (<em>r</em>,<em>s</em>) in the domain of definition. Many filters use values provided in a shading image or lookup table in combination with an image source. For example, a color ramp or a table that approximates a function, such as the <code>arcsin</code> function, provides values that are unrelated to the notion of working coordinates.</p></li></ul><p>Unless otherwise instructed, Core Image assumes that the ROI and the domain of definition coincide. If you write a filter for which this assumption doesn’t hold, you need to provide Core Image with a routine that calculates the ROI for a particular sampler.</p><p>See <span class="content_text"><a href="../ci_custom_filters/ci_custom_filters.html#//apple_ref/doc/uid/TP30001185-CH207-CJBECAEC">“Supplying an ROI Function”</a></span> for more information.</p><a name="//apple_ref/doc/uid/TP30001185-CH202-BCIGFIEI" title="Executable and Nonexecutable Filters"></a><h2>Executable and Nonexecutable Filters</h2><p>You can categorize custom Core Image filters on the basis of whether or not they require an auxiliary binary executable to be loaded into the address space of the client application. As you use the Core Image API, you’ll notice that these are simply referred to as <strong>executable</strong> and <strong>nonexecutable</strong>. Filter creators can choose to write either kind of filter. Filter clients can choose to use only nonexecutable or to use both kinds of filters. </p><p>Security is the primary motivation for distinguishing CPU executable and CPU nonexecutable filters. Nonexecutable filters consist only of a Core Image kernel program to describe the filter operation. In contrast, an executable filter also contains machine code that runs on the CPU. Core Image kernel programs run within a restricted environment and cannot pose as a virus, Trojan horse, or other security threat, whereas arbitrary code that runs on the CPU can.</p><p>Nonexecutable filters have special requirements, one of which is that nonexecutable filters must be packaged as part of an image unit. Filter creators can read <span class="content_text"><a href="../ci_custom_filters/ci_custom_filters.html#//apple_ref/doc/uid/TP30001185-CH207-CJBFHGGC">“Writing Nonexecutable Filters”</a></span> for more information. Filter clients can find information on loading each kind of filter in <span class="content_text"><a href="../ci_tasks/ci_tasks.html#//apple_ref/doc/uid/TP30001185-CH203-SW2">“Loading Image Units.”</a></span></p><a name="//apple_ref/doc/uid/TP30001185-CH202-BCIDAIEJ" title="Color Components and Premultiplied Alpha"></a><h2>Color Components and Premultiplied Alpha</h2><p><strong>Premultiplied alpha</strong> is a term used to describe a source color, the components of which have already been multiplied by an alpha value. Premultiplying speeds up the rendering of an image by eliminating the need to perform a multiplication operation for each color component. For example, in an RGB color space, rendering an image with premultiplied alpha eliminates three multiplication operations (red times alpha, green times alpha, and blue times alpha) for each pixel in the image.</p><p>Filter creators must supply Core Image with color components that are premultiplied by the alpha value. Otherwise, the filter behaves as if the alpha value for a color component is 1.0. Making sure color components are premultiplied is important for filters that manipulate color.</p><p>By default, Core Image assumes that processing nodes are 128 bits-per-pixel, linear light, premultiplied RGBA floating-point values that use the GenericRGB color space. You can specify a different working color space by providing a Quartz 2D CGColorSpace object. Note that the working color space must be RGB-based. If you have YUV data as input (or other data that is not RGB-based), you can use ColorSync functions to convert to the working color space. (See <em><a href="../../drawingwithquartz2d/index.html#//apple_ref/doc/uid/TP30001066" target="_top">Quartz 2D Programming Guide</a></em> for information on creating and using CGColorspace objects.)</p><p>With 8-bit YUV 4:2:2 sources, Core Image can process 240 HD layers per gigabyte. Eight-bit YUV is the native color format for video source such as DV, MPEG, uncompressed D1, and JPEG. You need to convert YUV color spaces to an RGB color space for Core Image.</p><a name="//apple_ref/doc/uid/TP30001185-CH202-SW7" title="See Also"></a><h2>See Also</h2><p>Shantzis, Michael A., “A Model for Efficient and Flexible Image Computing,” (1994), <em>Proceedings of the 21st Annual Conference on Computer Graphics and Interactive Techniques</em>.</p><p>Smith, Alvy Ray, “Image Compositing Fundamentals,” Memo 4, Microsoft, July 1995. Available from <span class="content_text"><a href="ftp://ftp.alvyray.com/Acrobat/4_Comp.pdf" target="_blank">ftp://ftp.alvyray.com/Acrobat/4_Comp.pdf</a></span></p>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../ci_intro/ci_intro.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../ci_tasks/ci_tasks.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2004, 2008 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2008-06-09<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/GraphicsImaging/Conceptual/CoreImaging/ci_concepts/ci_concepts.html%3Fid%3DTP30001185-4.3&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/GraphicsImaging/Conceptual/CoreImaging/ci_concepts/ci_concepts.html%3Fid%3DTP30001185-4.3&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/GraphicsImaging/Conceptual/CoreImaging/ci_concepts/ci_concepts.html%3Fid%3DTP30001185-4.3&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>