<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>Imageer - /source/menu.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxGraphicsImaging-date.html">Graphics & Imaging</a> &gt; <A HREF="javascript:location.replace('index.html');">Imageer</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/GraphicsImaging/index.html" target="_blank">Reference Library > Graphics & Imaging</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">Imageer</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/source/menu.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/source/doevent.c</option>
<option value="listing2.html">/source/eventloop.c</option>
<option value="listing3.html">/source/fileCache.c</option>
<option value="listing4.html">/source/fileIO.c</option>
<option value="listing5.html">/source/gxGraphics.c</option>
<option value="listing6.html">/source/Imageer.app.h</option>
<option value="listing7.html">/source/Imageer.protos.h</option>
<option value="listing8.html">/source/Imageer.r</option>
<option value="listing9.html">/source/imageFilter.c</option>
<option value="listing10.html">/source/menu.c</option>
<option value="listing11.html">/source/offscrnGraphics.c</option>
<option value="listing12.html">/source/PreCompiledHeaders.c</option>
<option value="listing13.html">/source/start.c</option>
<option value="listing14.html">/source/windows.c</option></select>
				</p>
				</form>
				<p><strong><a href="Imageer.zip">Download Sample</a></strong> (&#147;Imageer.zip&#148;, 161.4K)<BR>
<strong><a href="Imageer.dmg">Download Sample</a></strong> (&#147;Imageer.dmg&#148;, 243.1K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/****************************************************//*                          *//*  File:    menu.c                *//*                          *//*  Program:  Imageer                *//*                          *//*  By:      Jason Hodges-Harris          *//*                          *//*  Created:  26/10/95  00:00:00 AM        *//*                          *//*  Version:  1.0.0d3                *//*                          *//*  Copyright:  &copy; 1995-96 Apple Computer, Inc.,    */ /*          all rights reserved.      */    /*                          *//****************************************************//**** Macintosh Toolbox Headers *****/#ifndef __DESK__#include &lt;Desk.h&gt;#endif#ifndef __ERRORS__#include &lt;Errors.h&gt;#endif#ifndef __GXENVIRONMENT__#include &lt;GXEnvironment.h&gt;#endif#ifndef __MEMORY__#include &lt;Memory.h&gt;#endif#ifndef __MENUS__#include &lt;Menus.h&gt;#endif#ifndef __QUICKDRAW__#include &lt;QuickDraw.h&gt;#endif#ifndef __TEXTUTILS__#include &lt;TextUtils.h&gt;#endif#ifndef __TOOLUTILS__#include &lt;ToolUtils.h&gt;#endif#ifndef __WINDOWS__#include &lt;Windows.h&gt;#endif/****   Application headers and prototypes   ****/#ifndef __IMAGEERAPPHEADER__#include &quot;Imageer.app.h&quot;#endif#ifndef __IMAGEERPROTOSHEADER__#include &quot;Imageer.protos.h&quot;#endif/***** Global Variables *****/extern Boolean      gDone;          // program loop test conditionextern Boolean      gQDGXtrue;        // QuickDraw GX presentextern short      gNumOpenWindows;    //  number of open document windows// Initialise the application menubar.#pragma segment Menuvoid MenuBarInit (void){  SetMenuBar (GetNewMBar(rMenuBar));  AddResMenu (GetMHandle(mApple),'DRVR');  AddSubMenu(mBrightness);  AddSubMenu(mContrast);  AddSubMenu(mColor);  DrawMenuBar();}// Sets the menubar to the default settings during the application initialisation phase.#pragma segment Menuvoid  DoAdjustMenus(void){    DoAdjustFileMenu();    DoAdjustEditMenu();    DoAdjustWindowsMenu();    DoAdjustFilterMenu();    DoAdjustEffectsMenu();    DoAdjustModelMenu();    DrawMenuBar();  return;}// The DoMenuCommand() function performs all of the handling of // the user's interaction with the application#pragma segment Menuvoid  DoMenuCommand(long menuResult){  ImageDocHndl     theWindDocHndl;  WindowPtr      oldPort,            window,            theNextWindow;  MenuHandle      theMenu;  Str255        daName,            theItemString,            theResString;  OSErr        error = noErr;  short        menuID,            menuItem,            daRefNum,            count;    menuID   = HiWord(menuResult);  menuItem = LoWord(menuResult);  switch (menuID)   {    case mApple:        // Apple menubar items      switch (menuItem)       {        /* Display the application about box.           App name, copyright etc. */        case iAbout:              DisplayAlert (rAboutBox,0,0);        break;        // handle all menubar Desk Accessories.        default:                GetItem(GetMHandle(mApple), menuItem, daName);          daRefNum = OpenDeskAcc(daName);        break;      }    break;    case mFile:            // File menubar items      switch (menuItem)       {        case iOpen:          theMenu = GetMHandle(mModel);          GetMenuItemText(theMenu,iUseQDGX,theItemString);            GetIndString (theResString,rImageModel,iUseQuickDrawGX);          if (!EqualString(theItemString,theResString,true,true))            SetMenuItemText (theMenu,iUseQDGX,theResString);  // reset menu item          /**** default to Color QD. QDGX file type not yet supported for file load ****/          error = LoadSupportedImage();          if (!error)          {            if (ColorWindowVisible())            {              window = FrontWindow();              theWindDocHndl = (ImageDocHndl)GetWRefCon(window);              UpdateColorsWindPalette(theWindDocHndl, window);            }            theMenu = GetMHandle(mFile);            if (((**theMenu).enableFlags &amp; 4) == 0)  // test if Close menu item enabled            {              EnableItem(theMenu,iClose);              EnableItem(theMenu,iCloseAll);              EnableItem(theMenu,iSaveAs);              EnableItem(theMenu,iRevert);              EnableItem(GetMHandle(mWindow),iColors);              theMenu = GetMHandle(mFilters);              for (count = iSmoothFilter;count &lt;= iHiPassFilter; ++count)                EnableItem(theMenu,count);              theMenu = GetMHandle(mEffects);              for (count = iInvert;count &lt;= iRotate180; ++count)                EnableItem(theMenu,count);            }          }        break;        case iClose:          window = FrontWindow();          if (window)            DisposeImageWindow (window);        break;        case iCloseAll:          window = FrontWindow();          while (window)          {            theNextWindow = &amp;((WindowPeek)window)-&gt;nextWindow-&gt;port;            DisposeImageWindow (window);            window = theNextWindow;          }        break;        case iSave:          window = FrontWindow();          if (window)          {            theWindDocHndl = (ImageDocHndl)GetWRefCon(window);            if (!(**theWindDocHndl).isColorsWindow)              error = SaveSupportedImageFile(theWindDocHndl);          }        break;        case iSaveAs:          window = FrontWindow();          if (window)          {            theWindDocHndl = (ImageDocHndl)GetWRefCon(window);            if (!(**theWindDocHndl).isColorsWindow)              error = SaveSupportedImageFile(theWindDocHndl);          }        break;        case iRevert:          window = FrontWindow();          theWindDocHndl = (ImageDocHndl)GetWRefCon(window);          if (!(*theWindDocHndl)-&gt;isColorsWindow)            error = RevertToSavedFile(theWindDocHndl, window);          if (error)            DisplayAlert(rGenWarning,rFileIOMessages,iRevertFileFail);          if (ColorWindowVisible())          {            if (!(*theWindDocHndl)-&gt;isUsingQDGX)              UpdateColorsWindPalette(theWindDocHndl, window);          }        break;        case iQuit:          window = FrontWindow();          while (window)          {            DisposeImageWindow (window);            window = FrontWindow();          }          gDone=true;        break;      }      break;    /*  Edit menubar options. */    case mEdit:          switch (menuItem)       {        case iUndo:          window = FrontWindow();          if (window)          {            theWindDocHndl = (ImageDocHndl)GetWRefCon(window);            if (!(**theWindDocHndl).isColorsWindow &amp;&amp; (**theWindDocHndl).theUndoState)            {              if ((*theWindDocHndl)-&gt;isUsingQDGX)              {                RestoreOldTransformCopy(theWindDocHndl,true);              }              else              {                error = LoadTempImageFile(theWindDocHndl);                GetPort (&amp;oldPort);                SetPort(window);                InvalRect(&amp;window-&gt;portRect);                SetPort(oldPort);                if (ColorWindowVisible())                  UpdateColorsWindPalette(theWindDocHndl, window);              }            }          }        break;                case iCut:        break;                case iCopy:        break;                case iPaste:        break;      }    break;        case mWindow:      switch (menuItem)      {        case iColors:        theMenu = GetMHandle(mWindow);          if (((**theMenu).enableFlags &amp; 1) == 1)  // test for Window menu Colors item enabled          {            GetMenuItemText(theMenu,iColors,theItemString);              GetIndString (theResString,rMenuItems,iHideColors);            if (EqualString(theItemString,theResString,true,true))              DisposeColorsWindow();            else              CreateColorsWindow();          }        break;        default:          theMenu = GetMHandle(mWindow);          window = FrontWindow();          while (window)          {            theWindDocHndl = (ImageDocHndl)GetWRefCon(window);            if (menuItem == (**theWindDocHndl).theMenuItem)            {              if (window != FrontWindow())                SetUndoItemText((*theWindDocHndl)-&gt;theUndoState);              if ((*theWindDocHndl)-&gt;isUsingQDGX)                SetMenuItemAvailable(true);              else                SetMenuItemAvailable(false);              SetItemMark(theMenu,(**theWindDocHndl).theMenuItem,0x12);              SelectWindow (window);            }            else              SetItemMark(theMenu,(**theWindDocHndl).theMenuItem,0x00);            theNextWindow = &amp;((WindowPeek)window)-&gt;nextWindow-&gt;port;            window = theNextWindow;          }        break;      }    break;    case mFilters:      switch (menuItem)      {        case iSmoothFilter:          window = FrontWindow();          if (window)          {            theWindDocHndl = (ImageDocHndl)GetWRefCon(window);            if (!(**theWindDocHndl).isColorsWindow)              if (!(*theWindDocHndl)-&gt;isUsingQDGX)              {                SaveTempImageFile(theWindDocHndl, kPixMapOp);                SetUndoItemText(kCanUndo);                error = ImageSmoothFilter(theWindDocHndl, window);                if (error)                {                  RemoveTempFile(theWindDocHndl, true, false);                  SetUndoItemText(kCannotUndo);                  (*theWindDocHndl)-&gt;theUndoState = kCannotUndo;                }                  if (ColorWindowVisible())                  UpdateColorsWindPalette(theWindDocHndl, window);              }          }        break;        case iHiPassFilter:          window = FrontWindow();          if (window)          {            theWindDocHndl = (ImageDocHndl)GetWRefCon(window);            if (!(**theWindDocHndl).isColorsWindow)              if (!(*theWindDocHndl)-&gt;isUsingQDGX)              {                SaveTempImageFile(theWindDocHndl, kPixMapOp);                error = ImageHiPassFilter(theWindDocHndl, window);                if (error)                {                  RemoveTempFile(theWindDocHndl, true, false);                  SetUndoItemText(kCannotUndo);                  (*theWindDocHndl)-&gt;theUndoState = kCannotUndo;                }                  if (ColorWindowVisible())                  UpdateColorsWindPalette(theWindDocHndl, window);              }          }        break;      }    break;    case mEffects:      switch (menuItem)      {        case iInvert:          window = FrontWindow();          if (window)          {            theWindDocHndl = (ImageDocHndl)GetWRefCon(window);            if (!(**theWindDocHndl).isColorsWindow)              if ((**theWindDocHndl).isUsingQDGX)              {                (*theWindDocHndl)-&gt;theGXUndoType = kGXinkTransform;                SaveTransformCopy(theWindDocHndl, true);                GxShapeInkInvert (theWindDocHndl, window);    // Use QDGX              }              else              {                error = ColorImageInverter (theWindDocHndl, window);  // Use Color QD                (*theWindDocHndl)-&gt;theUndoState = kCanUndo;                if (error)                {                  RemoveTempFile(theWindDocHndl, true, false);                  SetUndoItemText(kCannotUndo);                  (*theWindDocHndl)-&gt;theUndoState = kCannotUndo;                }                  if (ColorWindowVisible())                  UpdateColorsWindPalette(theWindDocHndl, window);              }          }        break;        case iMirrorXaxis:          window = FrontWindow();          if (window)          {            theWindDocHndl = (ImageDocHndl)GetWRefCon(window);            if (!(**theWindDocHndl).isColorsWindow)              if ((**theWindDocHndl).isUsingQDGX)              {                (*theWindDocHndl)-&gt;theGXUndoType = kGXshapeTransform;                SaveTransformCopy(theWindDocHndl, true);                MirrorGxShape(theWindDocHndl, window, true);  // Use QDGX              }              else              {                SaveTempImageFile(theWindDocHndl, kPixMapOp);                error = MirrorImageHorizontal(theWindDocHndl, window);  // Use Color QD                if (error)                {                  RemoveTempFile(theWindDocHndl, true, false);                  SetUndoItemText(kCannotUndo);                  (*theWindDocHndl)-&gt;theUndoState = kCannotUndo;                }                }          }        break;        case iMirrorYaxis:          window = FrontWindow();          if (window)          {            theWindDocHndl = (ImageDocHndl)GetWRefCon(window);            if (!(**theWindDocHndl).isColorsWindow)              if ((**theWindDocHndl).isUsingQDGX)              {                (*theWindDocHndl)-&gt;theGXUndoType = kGXshapeTransform;                SaveTransformCopy(theWindDocHndl, true);                MirrorGxShape(theWindDocHndl, window, false);  // Use QDGX              }              else              {                SaveTempImageFile(theWindDocHndl, kPixMapOp);                error = MirrorImageVertical (theWindDocHndl, window);  // Use Color QD                if (error)                {                  RemoveTempFile(theWindDocHndl, true, false);                  SetUndoItemText(kCannotUndo);                  (*theWindDocHndl)-&gt;theUndoState = kCannotUndo;                }                }          }        break;        case iRotate180:          window = FrontWindow();          if (window)          {            theWindDocHndl = (ImageDocHndl)GetWRefCon(window);            if (!(**theWindDocHndl).isColorsWindow)              if ((**theWindDocHndl).isUsingQDGX)              {                (*theWindDocHndl)-&gt;theGXUndoType = kGXshapeTransform;                SaveTransformCopy(theWindDocHndl, true);                RotateGxShape(theWindDocHndl,window,ff(180)); // Use QDGX              }              else              {                SaveTempImageFile(theWindDocHndl, kPixMapOp);                error = RotateImage180 (theWindDocHndl, window);    // Use Color QD                if (error)                {                  RemoveTempFile(theWindDocHndl, true, false);                  SetUndoItemText(kCannotUndo);                  (*theWindDocHndl)-&gt;theUndoState = kCannotUndo;                }                }          }        break;      }    break;    case mBrightness:    /****  Brightness sub menu  ****/      switch (menuItem)      {        case iLighter:          window = FrontWindow();          if (window)          {            theWindDocHndl = (ImageDocHndl)GetWRefCon(window);            if (!(**theWindDocHndl).isColorsWindow)              if ((**theWindDocHndl).isUsingQDGX)              {                (*theWindDocHndl)-&gt;theGXUndoType = kGXinkTransform;                SaveTransformCopy(theWindDocHndl, true);                GxShapeInkBrightness (theWindDocHndl, window, true); // Use QDGX              }              else              {                ImageBrightness(theWindDocHndl, window,true);    // Use Color QD                if (ColorWindowVisible())                  UpdateColorsWindPalette(theWindDocHndl, window);              }          }        break;        case iDarker:          window = FrontWindow();          if (window)          {            theWindDocHndl = (ImageDocHndl)GetWRefCon(window);            if (!(**theWindDocHndl).isColorsWindow)              if ((**theWindDocHndl).isUsingQDGX)              {                (*theWindDocHndl)-&gt;theGXUndoType = kGXinkTransform;                SaveTransformCopy(theWindDocHndl, true);                GxShapeInkBrightness (theWindDocHndl, window, false); // Use QDGX              }              else              {                ImageBrightness(theWindDocHndl, window,false);    // Use Color QD                if (ColorWindowVisible())                  UpdateColorsWindPalette(theWindDocHndl, window);              }          }        break;      }    break;    case mContrast:    /****  Contrast sub menu  ****/      switch (menuItem)      {        case iIncrease:          window = FrontWindow();          if (window)          {            theWindDocHndl = (ImageDocHndl)GetWRefCon(window);            if (!(**theWindDocHndl).isColorsWindow)              if  (!(**theWindDocHndl).isUsingQDGX)              {                ImageContrast(theWindDocHndl, window,true);                if (ColorWindowVisible())                  UpdateColorsWindPalette(theWindDocHndl, window);              }          }        break;        case iDecrease:          window = FrontWindow();          if (window)          {            theWindDocHndl = (ImageDocHndl)GetWRefCon(window);            if (!(**theWindDocHndl).isColorsWindow)              if  (!(**theWindDocHndl).isUsingQDGX)              {                ImageContrast(theWindDocHndl, window,false);                if (ColorWindowVisible())                  UpdateColorsWindPalette(theWindDocHndl, window);              }          }        break;      }    break;    case mColor:    /****  Color Component sub menu  ****/      switch (menuItem)      {        case iRedColorComp:          window = FrontWindow();          if (window)          {            theWindDocHndl = (ImageDocHndl)GetWRefCon(window);            if (!(**theWindDocHndl).isColorsWindow)              if ((**theWindDocHndl).isUsingQDGX)              {                (*theWindDocHndl)-&gt;theGXUndoType = kGXinkTransform;                SaveTransformCopy(theWindDocHndl, true);                RGBColorComponent (theWindDocHndl, window, kRedComp); // Use QDGX              }              else              {                RemoveColorComponent(theWindDocHndl, window, kRedComp);    // Use Color QD                if (ColorWindowVisible())                  UpdateColorsWindPalette(theWindDocHndl, window);              }          }        break;        case iGreenColorComp:          window = FrontWindow();          if (window)          {            theWindDocHndl = (ImageDocHndl)GetWRefCon(window);            if (!(**theWindDocHndl).isColorsWindow)              if ((**theWindDocHndl).isUsingQDGX)              {                (*theWindDocHndl)-&gt;theGXUndoType = kGXinkTransform;                SaveTransformCopy(theWindDocHndl, true);                RGBColorComponent (theWindDocHndl, window, kGreenComp); // Use QDGX              }              else              {                RemoveColorComponent(theWindDocHndl, window, kGreenComp);    // Use Color QD                if (ColorWindowVisible())                  UpdateColorsWindPalette(theWindDocHndl, window);              }          }        break;        case iBlueColorComp:          window = FrontWindow();          if (window)          {            theWindDocHndl = (ImageDocHndl)GetWRefCon(window);            if (!(**theWindDocHndl).isColorsWindow)              if ((**theWindDocHndl).isUsingQDGX)              {                (*theWindDocHndl)-&gt;theGXUndoType = kGXinkTransform;                SaveTransformCopy(theWindDocHndl, true);                RGBColorComponent (theWindDocHndl, window, kBlueComp); // Use QDGX              }              else              {                RemoveColorComponent(theWindDocHndl, window, kBlueComp);    // Use Color QD                if (ColorWindowVisible())                  UpdateColorsWindPalette(theWindDocHndl, window);              }          }        break;      }    break;    case mModel:      error = SetImagingModel();      switch (error)      {        case kCannotConvertToGX:          DisplayAlert(rGenWarning,rQDGXmessages,iCannotConvToGX);        break;        case kCannotConvertToQD:          DisplayAlert(rGenWarning,rQDGXmessages,iCannotSwitchGX);        break;      }    break;  }  HiliteMenu(0);    // Unhighlight what MenuSelect (or MenuKey) hilited.}/****  Adjust the file menubar items  ****/#pragma segment Menuvoid  DoAdjustFileMenu(void){  MenuHandle      menu;  short        theItem;  menu = GetMHandle(mFile);  for (theItem = iClose;theItem&lt;=iRevert;++theItem)    DisableItem (menu,theItem);  return;}/****  Adjust the Edit menu bar items. Currently as these items   are disabled as they're not supported.  ****/#pragma segment Menuvoid  DoAdjustEditMenu(void){  MenuHandle    menu;  short      i;    menu = GetMHandle(mEdit);  for (i = iCut; i &lt;= iPaste; ++i)    DisableItem(menu, i);  return;}#pragma segment Menuvoid  DoAdjustWindowsMenu(void){  DisableItem(GetMHandle(mWindow),iColors);  return;}#pragma segment Menuvoid  DoAdjustFilterMenu(void){  MenuHandle    menu;  short      i;    menu = GetMHandle(mFilters);  for (i = iSmoothFilter; i &lt;= iHiPassFilter; ++i)    DisableItem(menu, i);  return;}#pragma segment Menuvoid  DoAdjustEffectsMenu(void){  MenuHandle    menu;  short      i;    menu = GetMHandle(mEffects);  for (i = iInvert; i &lt;= iRotate180; ++i)    DisableItem(menu, i);  return;}#pragma segment Menuvoid  DoAdjustModelMenu(void){  MenuHandle    menu;    menu = GetMHandle(mModel);  /****  Disable the use QDGX menu option if not installed  ****/  if (!gQDGXtrue)    DisableItem(menu,iUseQDGX);  return;}/****  Add Document Window to Window Menu list  ****/#pragma segment MenuOSErr  AddDocNameToMenu (ImageDocHndl theWindDocHndl){  ImageDocHndl    theFoundDocHndl;  MenuHandle      theMenu;  WindowPtr      theWindow;  WindowRecord    *theNextWindow;  OSErr        error = noErr;    theMenu = GetMHandle(mWindow);  InsertMenuItem(theMenu,(**theWindDocHndl).theImageFileReply.sfFile.name,gNumOpenWindows+2); // place after 2 item offset  SetItemMark(theMenu,gNumOpenWindows+3,0x12);  // place tick mark against opened window menu item  if (gNumOpenWindows)  {    theWindow = FrontWindow();    theNextWindow = ((WindowPeek)theWindow)-&gt;nextWindow;    theFoundDocHndl = (ImageDocHndl)GetWRefCon(&amp;(theNextWindow-&gt;port));    SetItemMark(theMenu,(**theFoundDocHndl).theMenuItem,0x00);  }  gNumOpenWindows++;  (**theWindDocHndl).theMenuItem = gNumOpenWindows+2; // 2 item offset as window list starts at item 3  DrawMenuBar();  return  error;}/****  Delete Document Window from Window Menu list  ****/#pragma segment MenuOSErr  DeleteDocNameFromMenu (ImageDocHndl theWindDocHndl){  ImageDocHndl    theFoundDocHndl;  MenuHandle      theMenu;  WindowPtr      theWindow,            theNextWindow;  OSErr        error = noErr;    theMenu = GetMHandle(mWindow);  DeleteMenuItem(theMenu,(**theWindDocHndl).theMenuItem);  error = RearrangeMenuItems(theWindDocHndl);  gNumOpenWindows--;  if (gNumOpenWindows)  {    theWindow = FrontWindow();    theNextWindow = &amp;((WindowPeek)theWindow)-&gt;nextWindow-&gt;port;    theFoundDocHndl = (ImageDocHndl)GetWRefCon(theNextWindow);    SetItemMark(theMenu,(**theFoundDocHndl).theMenuItem,0x12);  }  DrawMenuBar();  return  error;}/****  Rearrange items in Windows Menu list after document window closed  ****/#pragma segment MenuOSErr  RearrangeMenuItems(ImageDocHndl theWindDocHndl){  ImageDocHndl    theDocRefCon;  WindowPtr      theWindow,            theNextWindow;  OSErr        error = noErr;  short        deletedItemValue;    deletedItemValue = (**theWindDocHndl).theMenuItem;  theWindow = FrontWindow();  while (theWindow)  {    theDocRefCon=(ImageDocHndl)GetWRefCon(theWindow);    if ((**theDocRefCon).theMenuItem &gt; deletedItemValue)      (**theDocRefCon).theMenuItem--;      theNextWindow = &amp;((WindowPeek)theWindow)-&gt;nextWindow-&gt;port;    theWindow = theNextWindow;  }  return  error;}/****  Update ticked item in Window menu list ****/#pragma segment MenuOSErr  SetCurrentWindowMark(WindowPtr  theWindow){  ImageDocHndl    theFoundDocHndl;  MenuHandle      theMenu;  WindowPtr      theFrontWindow;  OSErr        error = noErr;  theFrontWindow = FrontWindow();  if(theWindow != theFrontWindow)  {    theMenu = GetMHandle(mWindow);    if (gNumOpenWindows)    {      theFoundDocHndl = (ImageDocHndl)GetWRefCon(theFrontWindow);      SetItemMark(theMenu,(**theFoundDocHndl).theMenuItem,0x00);    }    theFoundDocHndl = (ImageDocHndl)GetWRefCon(theWindow);    SetItemMark(theMenu,(**theFoundDocHndl).theMenuItem,0x12);  // place tick mark against opened window menu item  }    return noErr;}/****  Place hierarchical sub menu into menu list  ****/#pragma segment Menuvoid  AddSubMenu(short menuID){  MenuHandle    theSubMenu;    theSubMenu = GetMenu(menuID);  InsertMenu(theSubMenu,-1);}/****  Disable menu items for progress Dialog  ****/#pragma segment Menuvoid  DisableAllMenus(Boolean  isDisabled){  if (isDisabled)  {    DisableItem(GetMHandle(mFile),0);    DisableItem(GetMHandle(mWindow),0);    DisableItem(GetMHandle(mFilters),0);    DisableItem(GetMHandle(mEffects),0);    DisableItem(GetMHandle(mModel),0);  }  else  {    EnableItem(GetMHandle(mFile),0);    EnableItem(GetMHandle(mWindow),0);    EnableItem(GetMHandle(mFilters),0);    EnableItem(GetMHandle(mEffects),0);    EnableItem(GetMHandle(mModel),0);  }  DrawMenuBar();}/****  Set imaging model  ****/#pragma segment MenuOSErr  SetImagingModel(void){  ImageDocHndl     theDocHndl;  MenuHandle      theMenu;  WindowPtr      theWindow;  Str255        theItemString,            theResString;  OSErr        error = noErr;  theWindow = FrontWindow();  theMenu = GetMHandle(mModel);  GetMenuItemText(theMenu,iUseQDGX,theItemString);    GetIndString (theResString,rImageModel,iUseQuickDrawGX);  if (theWindow)  {    theDocHndl = (ImageDocHndl)GetWRefCon(theWindow);    if (!(**theDocHndl).isColorsWindow)    {      if (!EqualString(theItemString,theResString,true,true))        return kCannotConvertToQD;      else      {        GetIndString (theItemString,rImageModel,iUseColorQD);        SetMenuItemText (theMenu,iUseQDGX,theItemString);                (**theDocHndl).isUsingQDGX = true;        /****  Code to Convert current window image to QDGX object  ****/                    /****  Create QDGX view objects  ****/        error = CreateGXviewPorts(theDocHndl, theWindow);        if (!error)          error |= ConvPixMapToGXShape(theDocHndl, theWindow);        if (error)          error =  kCannotConvertToGX;        else        {          /****  Remove color Quickdraw information not required  ****/          if ((*theDocHndl)-&gt;theImageWorld)            DisposeGWorld((*theDocHndl)-&gt;theImageWorld);          if ((*theDocHndl)-&gt;hasUndoTemp)            RemoveTempFile(theDocHndl, true, false);          if ((*theDocHndl)-&gt;hasRedoTemp)            RemoveTempFile(theDocHndl, false, true);          SetMenuItemAvailable(true);        }            }    }  }  else  {    if (EqualString(theItemString,theResString,true,true))    {      GetIndString (theItemString,rImageModel,iUseColorQD);      SetMenuItemText (theMenu,iUseQDGX,theItemString);              SetMenuItemAvailable(true);    }    else    {      GetIndString (theItemString,rImageModel,iUseQuickDrawGX);      SetMenuItemText (theMenu,iUseQDGX,theItemString);              SetMenuItemAvailable(false);    }  }  return error;}/****  Set state of Undo menu item  ****/#pragma segment Menuvoid  SetUndoItemText(short canUndo){  MenuHandle    theMenu;  Str255      theString;    theMenu = GetMHandle(mEdit);  switch (canUndo)  {    case kCannotUndo:      GetIndString (theString,rMenuItems,iOpCantUndo);      SetMenuItemText (theMenu,iUndo,theString);    break;    case kCanUndo:      GetIndString (theString,rMenuItems,iOpUndo);      SetMenuItemText (theMenu,iUndo,theString);    break;    case kCanRedo:      GetIndString (theString,rMenuItems,iOpRedo);      SetMenuItemText (theMenu,iUndo,theString);    break;  }  DrawMenuBar();}/****  Set state of supported menu items for current image window / model ****/#pragma segment Menuvoid  SetMenuItemAvailable(Boolean isQDGX){  MenuHandle    theFilterMenu;    theFilterMenu = GetMHandle(mFilters);  if (isQDGX)  {    DisableItem(theFilterMenu, 0);  }  else  {    EnableItem(theFilterMenu, 0);  }    DrawMenuBar();}</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/Imageer/listing10.html%3Fid%3DDTS10000150-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/Imageer/listing10.html%3Fid%3DDTS10000150-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/Imageer/listing10.html%3Fid%3DDTS10000150-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>