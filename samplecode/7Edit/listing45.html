<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>7Edit - /Source/SVAETextUtils.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../samplecode/LegacyTechnologies/idxMacOS9Earlier-date.html">Mac OS 9 & Earlier</a> &gt; <A HREF="javascript:location.replace('index.html');">7Edit</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/Carbon/idxInterapplicationCommunication-date.html" target="_blank">Carbon > Interapplication Communication</a></li>
	</ul>
</div>




</div></div></div>

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">7Edit</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/Source/SVAETextUtils.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/Source/DebugUtils.c</option>
<option value="listing2.html">/Source/DebugUtils.h</option>
<option value="listing3.html">/Source/Offscreen.c</option>
<option value="listing4.html">/Source/Offscreen.h</option>
<option value="listing5.html">/Source/SVAEAccessors.c</option>
<option value="listing6.html">/Source/SVAEAccessors.h</option>
<option value="listing7.html">/Source/SVAEClone.c</option>
<option value="listing8.html">/Source/SVAEClone.h</option>
<option value="listing9.html">/Source/SVAEClose.c</option>
<option value="listing10.html">/Source/SVAEClose.h</option>
<option value="listing11.html">/Source/SVAECoercions.c</option>
<option value="listing12.html">/Source/SVAECoercions.h</option>
<option value="listing13.html">/Source/SVAECompare.c</option>
<option value="listing14.html">/Source/SVAECompare.h</option>
<option value="listing15.html">/Source/SVAECopy.c</option>
<option value="listing16.html">/Source/SVAECopy.h</option>
<option value="listing17.html">/Source/SVAECountElements.c</option>
<option value="listing18.html">/Source/SVAECountElements.h</option>
<option value="listing19.html">/Source/SVAECreate.c</option>
<option value="listing20.html">/Source/SVAECreate.h</option>
<option value="listing21.html">/Source/SVAECut.c</option>
<option value="listing22.html">/Source/SVAECut.h</option>
<option value="listing23.html">/Source/SVAEDelete.c</option>
<option value="listing24.html">/Source/SVAEDelete.h</option>
<option value="listing25.html">/Source/SVAEGetData.c</option>
<option value="listing26.html">/Source/SVAEGetData.h</option>
<option value="listing27.html">/Source/SVAEGetDataSize.c</option>
<option value="listing28.html">/Source/SVAEGetDataSize.h</option>
<option value="listing29.html">/Source/SVAEMove.c</option>
<option value="listing30.html">/Source/SVAEMove.h</option>
<option value="listing31.html">/Source/SVAEObjectsExist.c</option>
<option value="listing32.html">/Source/SVAEObjectsExist.h</option>
<option value="listing33.html">/Source/SVAEPaste.c</option>
<option value="listing34.html">/Source/SVAEPaste.h</option>
<option value="listing35.html">/Source/SVAERecording.c</option>
<option value="listing36.html">/Source/SVAERecording.h</option>
<option value="listing37.html">/Source/SVAERevert.c</option>
<option value="listing38.html">/Source/SVAERevert.h</option>
<option value="listing39.html">/Source/SVAESave.c</option>
<option value="listing40.html">/Source/SVAESave.h</option>
<option value="listing41.html">/Source/SVAESelect.c</option>
<option value="listing42.html">/Source/SVAESelect.h</option>
<option value="listing43.html">/Source/SVAESetData.c</option>
<option value="listing44.html">/Source/SVAESetData.h</option>
<option value="listing45.html">/Source/SVAETextUtils.c</option>
<option value="listing46.html">/Source/SVAETextUtils.h</option>
<option value="listing47.html">/Source/SVAEWindowUtils.c</option>
<option value="listing48.html">/Source/SVAEWindowUtils.h</option>
<option value="listing49.html">/Source/SVAppleEvents.c</option>
<option value="listing50.html">/Source/SVAppleEvents.h</option>
<option value="listing51.html">/Source/SVDrag.c</option>
<option value="listing52.html">/Source/SVDrag.h</option>
<option value="listing53.html">/Source/SVEditAEUtils.c</option>
<option value="listing54.html">/Source/SVEditAEUtils.h</option>
<option value="listing55.html">/Source/SVEditFile.c</option>
<option value="listing56.html">/Source/SVEditFile.h</option>
<option value="listing57.html">/Source/SVEditGlobals.c</option>
<option value="listing58.html">/Source/SVEditGlobals.h</option>
<option value="listing59.html">/Source/SVEditMain.c</option>
<option value="listing60.html">/Source/SVEditMain.h</option>
<option value="listing61.html">/Source/SVEditPrinting.c</option>
<option value="listing62.html">/Source/SVEditPrinting.h</option>
<option value="listing63.html">/Source/SVEditUtils.c</option>
<option value="listing64.html">/Source/SVEditUtils.h</option>
<option value="listing65.html">/Source/SVEditWindow.c</option>
<option value="listing66.html">/Source/SVEditWindow.h</option>
<option value="listing67.html">/Source/SVToken.h</option></select>
				</p>
				</form>
				<p><strong><a href="7Edit.zip">Download Sample</a></strong> (&#147;7Edit.zip&#148;, 205.9K)<BR>
<strong><a href="7Edit.dmg">Download Sample</a></strong> (&#147;7Edit.dmg&#148;, 251.7K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*  File:    SVAETextUtils.c  Contains:    Written by: Original version by Jon Lansdell and Nigel Humphreys.        3.1 updates by Greg Sutton.  Copyright:  Copyright &copy; 1995-1999 by Apple Computer, Inc., All Rights Reserved.        You may incorporate this Apple sample source code into your program(s) without        restriction. This Apple sample source code has been provided &quot;AS IS&quot; and the        responsibility for its operation is yours. You are not permitted to redistribute        this Apple sample source code as &quot;Apple sample source code&quot; after having made        changes. If you're going to re-distribute the source, we require that you make        it clear in the source that the code was descended from Apple sample source        code, but that you've made changes.  Change History (most recent first):              7/20/1999  Karl Groethe  Updated for Metrowerks Codewarror Pro 2.1        */#include &quot;SVAETextUtils.h&quot;#include &quot;SVEditAEUtils.h&quot;#include &quot;SVEditWindow.h&quot;    // for DPtrFromWindowPtr()#include &quot;SVAERecording.h&quot;#include &lt;AEPackObject.h&gt;// ----------------------------------------------------------------------------------//  Name:    PutStyledTextFromDescIntoTEHandle//  Purpose: Takes the text in an AEDesc containing typeIntlText and puts it in//           a styled text edit record at the current insertion point.//           Looks for typeIntlText, typeStyledText, typeChar in that order.// ----------------------------------------------------------------------------------OSErr  PutStyledTextFromDescIntoTEHandle(const AEDesc *sourceTextDesc, TEHandle theHTE){  AEDesc styledTextDesc;  AEDesc textStyleDesc;  AEDesc rawTextDesc;  OSErr  myErr;  OSErr  ignoreErr;    styledTextDesc.dataHandle = nil;  textStyleDesc.dataHandle  = nil;  rawTextDesc.dataHandle    = nil;    //  Coerce to an AERecord and then extract the parts of the  //  styled text - works for typeIntlText, typeStyledText  myErr = AECoerceDesc(sourceTextDesc, typeAERecord, &amp;styledTextDesc);    if (noErr == myErr)  {        myErr = AEGetKeyDesc(&amp;styledTextDesc,                         keyAEText,                         typeChar,                         &amp;rawTextDesc);                             myErr = AEGetKeyDesc(&amp;styledTextDesc,                         keyAEStyles,                         typeScrapStyles,                         &amp;textStyleDesc);  }  else  {    myErr = AECoerceDesc(sourceTextDesc, typeChar, &amp;rawTextDesc);        textStyleDesc.dataHandle = NULL; // so that TEStylInsert acts like TEInsert          }        HLock((Handle)rawTextDesc.dataHandle);    TEDelete(theHTE);          // Insert over current selection  TEStyleInsert((const void *) (*rawTextDesc.dataHandle),                     GetHandleSize(rawTextDesc.dataHandle),                       (StScrpHandle) textStyleDesc.dataHandle,                         theHTE);                 HUnlock((Handle)rawTextDesc.dataHandle);    if (textStyleDesc.dataHandle)    ignoreErr = AEDisposeDesc(&amp;textStyleDesc);    if (rawTextDesc.dataHandle)    ignoreErr = AEDisposeDesc(&amp;rawTextDesc);    if (styledTextDesc.dataHandle)    ignoreErr = AEDisposeDesc(&amp;styledTextDesc);      return(myErr);}TEHandle  TEHandleFromWindow(WindowPtr theWindow){  DPtr    docPtr;  TEHandle  result = NULL;    if (! theWindow)    return(NULL);    docPtr = DPtrFromWindowPtr(theWindow);    if (docPtr)    result = docPtr-&gt;theText;      return(result);}TEHandle  TEHandleFromTextToken(TextToken* aToken){  if (! aToken)    return(NULL);      return(TEHandleFromWindow(aToken-&gt;tokenWindow));}OSErr  GetInsertDescFromInsertHere(AEDesc* insertHereDesc, AEDesc* insertDesc, DescType* insertType){  AEDesc    insertRec = {typeNull, NULL},        objectSpec = {typeNull, NULL};  DescType  returnedType;  Size    actualSize;  OSErr    err;   switch (insertHereDesc-&gt;descriptorType)   {     case typeInsertionLoc:       err = AECoerceDesc(insertHereDesc, typeAERecord, &amp;insertRec);       if (noErr != err) goto done;              err = AEGetKeyPtr(&amp;insertRec, keyAEPosition, typeEnumeration, &amp;returnedType,                     (Ptr)insertType, sizeof(insertType), &amp;actualSize);       if (noErr != err) goto done;      err = AEGetKeyDesc(&amp;insertRec, keyAEObject, typeWildCard, &amp;objectSpec);      if (objectSpec.descriptorType != typeNull)      {        err = AEResolve(&amp;objectSpec, kAEIDoMinimum, insertDesc);        if (err != noErr) goto done;      }       break;        case typeObjectSpecifier:       err = AEResolve(insertHereDesc, kAEIDoMinimum, insertDesc);       if (noErr != err) goto done;       *insertType = insertDesc-&gt;descriptorType;       break;            case typeNull:          // No insertion location given       *insertType = typeNull;       break;            default:            // Just copy the descriptor       err = AEDuplicateDesc(insertHereDesc, insertDesc);       if (noErr != err) goto done;       *insertType = insertDesc-&gt;descriptorType;   }    done:   if (insertRec.dataHandle)     AEDisposeDesc(&amp;insertRec);   if (objectSpec.dataHandle)     AEDisposeDesc(&amp;objectSpec);      return(err);}// This routine returns an enumerated type describing the relative position// of one TextToken to another.TokenWithinType  TokenWithinToken(TextToken* container, TextToken* token, short* numPartial){  TokenWithinType    result;  if (token-&gt;tokenOffset + token-&gt;tokenLength &lt; container-&gt;tokenOffset)    result = kTokenBefore;  else if (container-&gt;tokenOffset + container-&gt;tokenLength &lt; token-&gt;tokenOffset)    result = kTokenAfter;  else if (token-&gt;tokenOffset &gt;= container-&gt;tokenOffset        &amp;&amp; token-&gt;tokenOffset + token-&gt;tokenLength &lt;= container-&gt;tokenOffset + container-&gt;tokenLength)    result = kTokenWithin;  else if (token-&gt;tokenOffset &lt; container-&gt;tokenOffset)  {    result = kTokenPartialBefore;    if (numPartial)      *numPartial = token-&gt;tokenOffset + token-&gt;tokenLength - container-&gt;tokenOffset;  }  else  {    result = kTokenPartialAfter;    if (numPartial)      *numPartial = container-&gt;tokenOffset + container-&gt;tokenLength - token-&gt;tokenOffset;  }    return(result);}OSErr  TextTokenFromWindowToken(WindowToken* theWindowToken, TextToken* theTextToken){  DPtr    docPtr;  docPtr = DPtrFromWindowPtr(theWindowToken-&gt;tokenWindow);  if (! docPtr)    return(errAENoSuchObject);      // Create our text token  theTextToken-&gt;tokenWindow = theWindowToken-&gt;tokenWindow;    theTextToken-&gt;tokenOffset = 1;                // Start at 1  theTextToken-&gt;tokenLength = (**docPtr-&gt;theText).teLength;  // through whole length    return(noErr);}OSErr  TextTokenFromWindowDesc(AEDesc* windowDesc, TextToken* theToken){  AEDesc      aDesc = {typeNull, NULL};  WindowToken    aWindowToken;  Size      actualSize;  OSErr      err;    err = AECoerceDesc(windowDesc, typeMyWndw, &amp;aDesc);  if (noErr != err) goto done;      GetRawDataFromDescriptor(&amp;aDesc, (Ptr)&amp;aWindowToken,                  sizeof(aWindowToken), &amp;actualSize);  err = TextTokenFromWindowToken(&amp;aWindowToken, theToken);  done:    if (aDesc.dataHandle)    AEDisposeDesc(&amp;aDesc);  return(err);}OSErr  TextDescFromWindowToken(WindowToken* theWindowToken, AEDesc* textDesc){  TextToken  aToken;  OSErr    err;    err = TextTokenFromWindowToken(theWindowToken, &amp;aToken);  if (noErr != err) goto done;    err = AECreateDesc(typeMyText, (Ptr)&amp;aToken, sizeof(aToken), textDesc);done:  return(err);}OSErr  TextDescFromWindowDesc(AEDesc* windowDesc, AEDesc* textDesc){  TextToken  aToken;  OSErr    err;    err = TextTokenFromWindowDesc(windowDesc, &amp;aToken);  if (noErr != err) goto done;    err = AECreateDesc(typeMyText, (Ptr)&amp;aToken, sizeof(aToken), textDesc);done:  return(err);}void MoveToNonSpace(short *start, short limit, charsHandle myChars)  // Treats space, comma, full stop, ; and : as space chars{   short x;  while (*start &lt;= limit) {    x = (**myChars)[*start];    if (IsWhiteSpace(x))      (*start) +=1;    else      return;  }}  void  MoveToSpace(short *start, short limit, charsHandle myChars)  // Treats space,comma, full stop, ; and : as space chars{   short x;    while (*start &lt;= limit)  {    x = (**myChars)[*start];    if (! IsWhiteSpace(x))      (*start)++;    else      return;  }}void  MoveToEndOfParagraph(short *start, short limit, charsHandle myChars)  //  Treats CR as end of paragraph{   short x;    while (*start &lt;= limit)  {    x = (**myChars)[*start];    if (! IsParagraphDelimiter(x))    // had x != CR      (*start)++;    else      return;  }}// This routine counts the given elementType between startAt and OSErr  CountTextElements(TEHandle inTextHandle, short startAt,                short forHowManyChars, DescType elementType, short* result){  charsHandle  theChars;  short       limit,        start;  OSErr    err = noErr;  switch (elementType)  {    case cInsertionPoint:  // Always one more insertion location than characters      *result = forHowManyChars + 1;      break;          case cChar:      // Easy      *result = forHowManyChars;      break;          case cText:        *result = 1;      break;        case cWord:      // Cycle through - counting    case cParagraph:      theChars = (charsHandle)(**inTextHandle).hText;      start = startAt - 1;          // Convert to zero based      limit = start + forHowManyChars - 1;  // when passed one based      *result  = 0;      MoveToNonSpace(&amp;start, limit, theChars);      while (start &lt;= limit)      {        (*result)++;        switch (elementType)        {          case cWord:            MoveToSpace(&amp;start, limit, theChars);            break;                      case cParagraph:            MoveToEndOfParagraph(&amp;start, limit, theChars);            break;        }        MoveToNonSpace(&amp;start, limit, theChars);      }      break;      default:      *result = -1;      err = errAEBadKeyForm;  }    return(err);} // CountTextElementsOSErr  GetDescOfNthTextElement(short index, DescType elementType,                    TextToken* containerToken, AEDesc* result){  DPtr        docPtr;  TextToken  theToken;  short    start,        maxChars,        elementCount,        limit,        elementStart;  charsHandle  theChars;  OSErr    err;    if (! containerToken)    return(errAEEmptyListContainer);  docPtr = DPtrFromWindowPtr(containerToken-&gt;tokenWindow);  start = containerToken-&gt;tokenOffset - 1;  // Zero based  maxChars = containerToken-&gt;tokenLength;  err = CountTextElements(docPtr-&gt;theText, containerToken-&gt;tokenOffset,                    maxChars, elementType, &amp;elementCount);  if (noErr != err) return(err);    if (index &lt; 0)            // Change a negative index to positive    index = elementCount + index + 1;      if (index &gt; elementCount)      // Got given an index out of range    return(errAEIllegalIndex);          // Set the window that the token relates to  theToken.tokenWindow = containerToken-&gt;tokenWindow;  switch (elementType)  {    case cInsertionPoint:      theToken.tokenOffset = start + index - 1;      theToken.tokenLength = 0;      break;          case cChar:    // Easy - just the start point + the index      theToken.tokenOffset = start + index;      theToken.tokenLength = 1;      break;          case cText:        theToken.tokenOffset = start + index;      theToken.tokenLength = maxChars;      break;          case cWord:    case cParagraph:      theChars = (charsHandle)(**(docPtr-&gt;theText)).hText;      limit = start + maxChars - 1;      MoveToNonSpace(&amp;start, limit, theChars);      while ((start &lt;= limit) &amp;&amp; (index &gt; 0))      {        index--;        elementStart = start;        switch (elementType)        {          case cWord:            MoveToSpace(&amp;start, limit, theChars);            break;                      case cParagraph:            MoveToEndOfParagraph(&amp;start, limit, theChars);            break;        }        theToken.tokenLength = start - elementStart;        MoveToNonSpace(&amp;start, limit, theChars);      }      theToken.tokenOffset = elementStart + 1;  // Convert to one based      break;  }  err = AECreateDesc(typeMyText, (Ptr)&amp;theToken, sizeof(theToken), result);  return(err);}char  GetTEHChar(TEHandle aTEH, short offset){  char  result;    offset--;    // This is now 0 based  if (offset &lt; 0 || offset &gt;= (*aTEH)-&gt;teLength)    return('\0');      result = *(char *)((*(**aTEH).hText) + offset);    return(result);}Boolean    IsAtStart(TextToken* theToken){  Boolean  result;          // Is at start if offset is at 1  result = (theToken-&gt;tokenOffset == 1);    return(result);}Boolean    IsAtEnd(TextToken* theToken){  TEHandle  aTEH;  Boolean    result;    aTEH = TEHandleFromTextToken(theToken);          // Does it go to the end?  result = (theToken-&gt;tokenOffset + theToken-&gt;tokenLength &gt;= (**aTEH).teLength);    return(result);}Boolean    IsWhiteSpace(short aChar){  Boolean  result;  result = (aChar == ' ' || aChar == ',' || aChar == '.'        || aChar == ':' || aChar == LF || aChar == CR);           return(result);}Boolean    IsParagraphDelimiter(short aChar){  Boolean  result;  result = (aChar == CR);           return(result);}Boolean    IsContentsToken(TextToken* theToken){  return(IsAtStart(theToken) &amp;&amp; IsAtEnd(theToken));}Boolean    IsParagraphToken(TextToken* theToken, short* start, short* end){  TEHandle  aTEH;  OSErr    err;  short    number;  Boolean    fStart,        fEnd,        result;  //  if (IsContentsToken(theToken))  // So we don't start and end //    return(false);      aTEH = TEHandleFromTextToken(theToken);                      // What about having CR's before end??                  // - then it's just more paragraphs?                  // - in STE yes - ahhh it'll be okay      fStart = IsAtStart(theToken) || IsParagraphDelimiter(GetTEHChar(aTEH, theToken-&gt;tokenOffset - 1));  fEnd = IsAtEnd(theToken) || IsParagraphDelimiter(GetTEHChar(aTEH, theToken-&gt;tokenOffset + theToken-&gt;tokenLength));    if (fStart &amp;&amp; fEnd)  {    // need to do a count of the paragraphs        err = CountTextElements(aTEH, theToken-&gt;tokenOffset,              theToken-&gt;tokenLength, cParagraph, &amp;number);    // count text elements before it i.e. offset == 0 limit == theToken-&gt;tokenOffset        if (IsAtStart(theToken))      *start = 1;    else    {        // From beginning to charracter before start of paragraph      err = CountTextElements(aTEH, 1,theToken-&gt;tokenOffset - 1, cParagraph, start);      (*start)++;    }        *end = *start + number - 1;        result = true;  }  else    result = false;    return(result);}Boolean    IsWordToken(TextToken* theToken, short* start, short* end){  TEHandle  aTEH;  OSErr    err;  short    number;  Boolean    fStart,        fEnd,        result;  //  if (IsContentsToken(theToken) || IsParagraphToken(theToken, start, end))//    return(false);    aTEH = TEHandleFromTextToken(theToken);                      // What about having CR's before end??                  // - then it's just more paragraphs?                  // - in STE yes - ahhh it'll be okay      fStart = IsAtStart(theToken) || IsWhiteSpace(GetTEHChar(aTEH, theToken-&gt;tokenOffset - 1));  fEnd = IsAtEnd(theToken) || IsWhiteSpace(GetTEHChar(aTEH, theToken-&gt;tokenOffset + theToken-&gt;tokenLength));    if (fStart &amp;&amp; fEnd)  {    // need to do a count of the words        err = CountTextElements(aTEH, theToken-&gt;tokenOffset,              theToken-&gt;tokenLength, cWord, &amp;number);    // count text elements before it i.e. offset == 0 limit == theToken-&gt;tokenOffset        if (IsAtStart(theToken))      *start = 1;    else    {        // From beginning to charracter before start of word      err = CountTextElements(aTEH, 1, theToken-&gt;tokenOffset - 1, cWord, start);      (*start)++;    }        *end = *start + number - 1;        result = true;  }  else    result = false;    return(result);}DescType  GetTextTokenType(TextToken* theToken, short* start, short* end){  DescType  result;    *start = *end = -1;          // Just set to the same value  if (! theToken-&gt;tokenLength)  {    result = cInsertionPoint;  }  else if (IsContentsToken(theToken))  {    result = pContents;  }  else if (IsParagraphToken(theToken, start, end))  {    result = cParagraph;  }  else if (IsWordToken(theToken, start, end))  {    result = cWord;  }  else  {    result = cChar;    *start = theToken-&gt;tokenOffset;    *end = theToken-&gt;tokenOffset + theToken-&gt;tokenLength - 1;  }    return(result);}OSErr  MakeContentsSpecifier(TextToken* theToken, AEDesc* result){  AEDesc    docSpec = {typeNull, NULL},        contentsDesc = {typeNull, NULL};  DescType  propertyID;  OSErr    err;  err = MakeDocumentObj(theToken-&gt;tokenWindow, &amp;docSpec);  if (noErr != err) goto done;    propertyID = pContents;  err = AECreateDesc(typeType, (Ptr)&amp;propertyID, sizeof(DescType), &amp;contentsDesc);  if (err != noErr) goto done;  err = CreateObjSpecifier(cProperty, &amp;docSpec, formPropertyID, &amp;contentsDesc, false, result);done:  if (docSpec.dataHandle)    AEDisposeDesc(&amp;docSpec);  if (contentsDesc.dataHandle)    AEDisposeDesc(&amp;contentsDesc);    return(err);}OSErr  MakeAbsoluteTextSpecifier(WindowPtr theWindow, DescType textType, long index, AEDesc* result){  AEDesc    docSpec = {typeNull, NULL},        absoluteDesc = {typeNull, NULL};  OSErr    err;    if (theWindow)  {    err = MakeDocumentObj(theWindow, &amp;docSpec);    if (noErr != err) goto done;  }  // else just use the NULL'ed value  err = AECreateDesc(typeLongInteger, (Ptr)&amp;index, sizeof(index), &amp;absoluteDesc);  if (err != noErr) goto done;  err = CreateObjSpecifier(textType, &amp;docSpec, formAbsolutePosition,                          &amp;absoluteDesc, false, result);done:  if (docSpec.dataHandle)    AEDisposeDesc(&amp;docSpec);  if (absoluteDesc.dataHandle)    AEDisposeDesc(&amp;absoluteDesc);    return(err);}OSErr  MakeInsertionPointSpecifier(TextToken* theToken, AEDesc* result){  AEDesc    relativeToSpec,        relativeDesc;  DescType  relativeType;  OSErr    err;  if (IsAtStart(theToken))      // Before contents (whether there are any or not)  {    relativeType = kAEPrevious;    err = MakeContentsSpecifier(theToken, &amp;relativeToSpec);  }  else if (IsAtEnd(theToken))      // After last character  {    relativeType = kAENext;    //err = MakeContentsSpecifier(theToken, &amp;relativeToSpec);    err = MakeAbsoluteTextSpecifier(theToken-&gt;tokenWindow, cChar, -1, &amp;relativeToSpec);  }  else                // Has a character it can go before  {    relativeType = kAEPrevious;    err = MakeAbsoluteTextSpecifier(theToken-&gt;tokenWindow, cChar, theToken-&gt;tokenOffset, &amp;relativeToSpec);  }  if (noErr != err) goto done;      err = AECreateDesc(typeEnumerated, &amp;relativeType, sizeof(relativeType), &amp;relativeDesc);  if (noErr != err) goto done;  err = CreateObjSpecifier(cInsertionPoint, &amp;relativeToSpec, formRelativePosition,                                               &amp;relativeDesc, false, result);done:  if (relativeToSpec.dataHandle)    AEDisposeDesc(&amp;relativeToSpec);  if (relativeDesc.dataHandle)    AEDisposeDesc(&amp;relativeDesc);  return(err);}OSErr  GetIndexSpecifier(TextToken* theToken, DescType textType, long index, AEDesc* result){  OSErr  err;  switch (textType)  {    case cInsertionPoint:      err = MakeInsertionPointSpecifier(theToken, result);      break;          case pContents:      err = MakeContentsSpecifier(theToken, result);      break;          case cParagraph:    case cWord:    case cChar:      err = MakeAbsoluteTextSpecifier(theToken-&gt;tokenWindow, textType, index, result);      break;        default:      err = errAETypeError;  }    return(err);}OSErr  GetTextTokenObjectSpecifier(TextToken* theToken, AEDesc* result){  AEDesc    docSpec = {typeNull, NULL},        startSpec = {typeNull, NULL},        endSpec = {typeNull, NULL},        rangeDesc = {typeNull, NULL};  DescType  textType;  short    start,        end;  OSErr    err;    textType = GetTextTokenType(theToken, &amp;start, &amp;end);    err = GetIndexSpecifier(theToken, textType, start, &amp;startSpec);  if (noErr != err) goto done;  if (start != end)    // Sort out rest of range specifier  {    err = GetIndexSpecifier(theToken, textType, end, &amp;endSpec);    if (noErr != err) goto done;        err = CreateRangeDescriptor(&amp;startSpec, &amp;endSpec, false, &amp;rangeDesc);    if (noErr != err) goto done;    err = MakeDocumentObj(theToken-&gt;tokenWindow, &amp;docSpec);    if (noErr != err) goto done;    err = CreateObjSpecifier(cText, &amp;docSpec, formRange, &amp;rangeDesc, false, result);  }  else    err = AEDuplicateDesc(&amp;startSpec, result);  done:  if (docSpec.dataHandle)    AEDisposeDesc(&amp;docSpec);  if (startSpec.dataHandle)    AEDisposeDesc(&amp;startSpec);  if (endSpec.dataHandle)    AEDisposeDesc(&amp;endSpec);  if (rangeDesc.dataHandle)    AEDisposeDesc(&amp;rangeDesc);  return(err);}</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/7Edit/listing45.html%3Fid%3DDTS10000200-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/7Edit/listing45.html%3Fid%3DDTS10000200-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/7Edit/listing45.html%3Fid%3DDTS10000200-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>