<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>The Objective-C 2.0 Programming Language: Declared Properties</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Declared Properties"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP30001163-CH17" title="Declared Properties"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../index.html#//apple_ref/doc/uid/TP30000440-TP30000416" target="_top">Cocoa</a> &gt; <a href="../../../ObjectiveCLanguage-date.html#//apple_ref/doc/uid/TP30000440-TP30000416-TP30000856" target="_top">Objective-C Language</a> &gt; <a href="../Introduction/introObjectiveC.html#//apple_ref/doc/uid/TP30001163-CH1-SW2">The Objective-C 2.0 Programming Language</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="ocAllocInit.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="ocCategories.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP30001163-CH17-SW1" title="Declared Properties"></a><h1>Declared Properties</h1><p>The Objective-C “declared properties” feature provides a simple way to declare and implement an object’s accessor methods.</p>
<!-- This template is being used for both PDF and HTML. -->

    
    <h4>In this section:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="ocProperties.html#//apple_ref/doc/uid/TP30001163-CH17-SW13">Overview</a>
				
			<br/>
			
        
			
			
				<a href="ocProperties.html#//apple_ref/doc/uid/TP30001163-CH17-SW14">Property Declaration and Implementation</a>
				
			<br/>
			
        
			
			
				<a href="ocProperties.html#//apple_ref/doc/uid/TP30001163-CH17-SW17">Using Properties</a>
				
			<br/>
			
        
			
			
				<a href="ocProperties.html#//apple_ref/doc/uid/TP30001163-CH17-SW4">Subclassing with Properties</a>
				
			<br/>
			
        
			
			
				<a href="ocProperties.html#//apple_ref/doc/uid/TP30001163-CH17-SW12">Performance and Threading</a>
				
			<br/>
			
        
			
			
				<a href="ocProperties.html#//apple_ref/doc/uid/TP30001163-CH17-SW3">Runtime Difference</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP30001163-CH17-SW13" title="Overview"></a><h2>Overview</h2><p>There are two aspects to this language feature: the syntactic elements you use to specify and optionally synthesize <strong>declared properties</strong>, and a related syntactic element that is described in <span class="content_text"><a href="ocObjectsClasses.html#//apple_ref/doc/uid/TP30001163-CH11-SW17">“Dot Syntax.”</a></span> </p><p>You typically access an object’s properties (in the sense of its attributes and relationships) through a pair of accessor (getter/setter) methods. By using accessor methods, you adhere to the principle of encapsulation (see <span class="content_text"><a href="../../OOP_ObjC/Articles/ooObjectModel.html#//apple_ref/doc/uid/TP40005149-CH5-86316" target="_top">“Mechanisms Of Abstraction”</a></span> in <em><a href="../../OOP_ObjC/index.html#//apple_ref/doc/uid/TP40005149" target="_top">Object-Oriented Programming with Objective-C</a></em> > <span class="content_text"><a href="../../OOP_ObjC/Articles/ooObjectModel.html#//apple_ref/doc/uid/TP40005149-CH5" target="_top">The Object Model</a></span>). You can exercise tight control of the behavior of the getter/setter pair and the underlying state management while clients of the API remain insulated from the implementation changes.</p><p>Although using accessor methods has significant advantages, writing accessor methods is nevertheless a tedious process—particularly if you have to write code to support both garbage collected and reference counted environments. Moreover, aspects of the property that may be important to consumers of the API are left obscured—such as whether the accessor methods are thread-safe or whether new values are copied when set.</p><p>Declared properties address the problems with standard accessor methods by providing the following features:</p><ul class="ul"><li class="li"><p>The property declaration provides a clear, explicit specification of how the accessor methods behave.</p></li><li class="li"><p>The compiler can synthesize accessor methods for you, according to the specification you provide in the declaration. This means you have less code to write and maintain.</p></li><li class="li"><p>Properties are represented syntactically as identifiers and are scoped, so the compiler can detect use of undeclared properties. </p></li></ul><a name="//apple_ref/doc/uid/TP30001163-CH17-SW14" title="Property Declaration and Implementation"></a><h2>Property Declaration and Implementation</h2><p>There are two parts to a declared property, its declaration and its implementation. </p><a name="//apple_ref/doc/uid/TP30001163-CH17-SW18" title="Property Declaration"></a><h3>Property Declaration</h3><p>A property declaration begins with the keyword <code>@property</code>. <code>@property</code> can appear anywhere in the method declaration list found in the <code>@interface</code> of a class. <code>@property</code> can also appear in the declaration of a protocol or category (protocols and categories are described in <span class="content_text"><a href="ocProtocols.html#//apple_ref/doc/uid/TP30001163-CH15-SW1">“Protocols”</a></span> and <span class="content_text"><a href="ocCategories.html#//apple_ref/doc/uid/TP30001163-CH20-SW1">“Categories and Extensions”</a></span> respectively).</p><dl class="termdef">	<dt><code>@property(attributes) type name;</code></dt><dd><p><code>@property</code> declares a property. An optional parenthesized set of attributes provides additional details about the storage semantics and other behaviors of the property—see <span class="content_text"><a href="ocProperties.html#//apple_ref/doc/uid/TP30001163-CH17-SW2">“Property Declaration Attributes”</a></span> for possible values. Like any other Objective-C type, each property has a type specification and a name.</p></dd></dl><p><span class="content_text">Listing 4-1</span> illustrates the declaration of a simple property.</p><a name="//apple_ref/doc/uid/TP30001163-CH17-SW5" title="Listing 4-1Declaring a simple property"></a><p class="codesample"><strong>Listing 4-1&nbsp;&nbsp;</strong>Declaring a simple property</p><div class="codesample"><table><tr><td scope="row"><pre>@interface MyClass : NSObject<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    float value;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre>@property float value;<span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr></table></div><p>You can think of a property declaration as being equivalent to declaring two accessor methods. Thus</p><div class="codesample"><table><tr><td scope="row"><pre>@property float value;<span></span></pre></td></tr></table></div><p>is equivalent to:</p><div class="codesample"><table><tr><td scope="row"><pre>- (float)value;<span></span></pre></td></tr><tr><td scope="row"><pre>- (void)setValue:(float)newValue;<span></span></pre></td></tr></table></div><p>A property declaration, however, provides additional information about how the accessor methods are implemented (as described in <span class="content_text"><a href="ocProperties.html#//apple_ref/doc/uid/TP30001163-CH17-SW2">“Property Declaration Attributes”</a></span>).</p><a name="//apple_ref/doc/uid/TP30001163-CH17-SW2" title="Property Declaration Attributes"></a><h3>Property Declaration Attributes</h3><p>You can decorate a property with attributes by using the form <code>@property(attribute [, attribute2, ...])</code>. Like methods, properties are scoped to their enclosing interface declaration. For property declarations that use a comma delimited list of variable names, the property attributes apply to all of the named properties.</p><p>If you use the <code>@synthesize</code> directive to tell the compiler to create the accessor method(s), the code it generates matches the specification given by the keywords. If you implement the accessor method(s) yourself, you should ensure that it matches the specification (for example, if you specify <code>copy</code> you must make sure that you do copy the input value in the setter method).</p><a name="//apple_ref/doc/uid/TP30001163-CH17-SW25" title="Accessor Method Names"></a><h4>Accessor Method Names</h4><p>The default names for the getter and setter methods associated with a property are <em>propertyName</em> and <code>set</code><em>PropertyName</em><code>:</code> respectively—for example, given a property “foo”, the accessors would be <code>foo</code> and <code>setFoo:</code>. The following attributes allow you to specify custom names instead. They are both optional and may appear with any other attribute (except for <code>readonly</code> in the case of <code>setter=</code>). </p><dl class="termdef">	<dt><code>getter=getterName</code></dt><dd><p>Specifies the name of the get accessor for the property. The getter must return a type matching the property’s type and take no arguments.</p></dd><dt><code>setter=setterName</code></dt><dd><p>Specifies the name of the set accessor for the property. The setter method must take a single argument of a type matching the property’s type and must return <code>void</code>.</p><p>If you specify that a property is <code>readonly</code> then also specify a setter with <code>setter=</code>, you will get a compiler warning.</p></dd></dl><p>Typically you should specify accessor method names that are key-value coding compliant (see <em><a href="../../KeyValueCoding/index.html#//apple_ref/doc/uid/10000107i" target="_top">Key-Value Coding Programming Guide</a></em>)—a common reason for using the <code>getter</code> decorator is to adhere to the <code>is</code><em>PropertyName</em> convention for Boolean values.</p><a name="//apple_ref/doc/uid/TP30001163-CH17-SW26" title="Writability"></a><h4>Writability</h4><p>These attributes specify whether or not a property has an associated set accessor. They are mutually exclusive.</p><dl class="termdef">	<dt><code>readwrite</code></dt><dd><p>Indicates that the property should be treated as read/write. This is the default.</p><p>Both a getter and setter method will be required in the <code>@implementation</code>. If you use <code>@synthesize</code> in the implementation block, the getter and setter methods are synthesized.</p></dd><dt><code>readonly</code></dt><dd><p>Indicates that the property is read-only.</p><p>If you specify <code>readonly</code>, only a getter method is required in the <code>@implementation</code>. If you use <code>@synthesize</code> in the implementation block, only the getter method is synthesized. Moreover, if you attempt to assign a value using the dot syntax, you get a compiler error.</p></dd></dl><a name="//apple_ref/doc/uid/TP30001163-CH17-SW27" title="Setter Semantics"></a><h4>Setter Semantics</h4><p>These attributes specify the semantics of a set accessor. They are mutually exclusive. </p><dl class="termdef">	<dt><code>assign</code></dt><dd><p>Specifies that the setter uses simple assignment. This is the default.</p></dd><dt><code>retain</code></dt><dd><p>Specifies that <code><a href="../../../Reference/Foundation/Protocols/NSObject_Protocol/Reference/NSObject.html#//apple_ref/occ/intfm/NSObject/retain" target="_top">retain</a></code> should be invoked on the object upon assignment. (The default is <code>assign</code>.)</p><p>The previous value is sent a <code><a href="../../../Reference/Foundation/Protocols/NSObject_Protocol/Reference/NSObject.html#//apple_ref/occ/intfm/NSObject/release" target="_top">release</a></code> message.</p><p>This attribute is valid only for Objective-C object types. (You cannot specify <code>retain</code> for Core Foundation objects—see <span class="content_text"><a href="ocProperties.html#//apple_ref/doc/uid/TP30001163-CH17-SW10">“Core Foundation.”</a></span>)</p></dd><dt><code>copy</code></dt><dd><p>Specifies that a copy of the object should be used for assignment.  (The default is <code>assign</code>.)</p><p>The previous value is sent a <code><a href="../../../Reference/Foundation/Protocols/NSObject_Protocol/Reference/NSObject.html#//apple_ref/occ/intfm/NSObject/release" target="_top">release</a></code> message.</p><p>The copy is made by invoking the <code><a href="../../../Reference/Foundation/Classes/NSObject_Class/Reference/Reference.html#//apple_ref/occ/instm/NSObject/copy" target="_top">copy</a></code> method. This attribute is valid only for object types, which must implement the <code>NSCopying</code> protocol. For further discussion, see <span class="content_text"><a href="ocProperties.html#//apple_ref/doc/uid/TP30001163-CH17-SW32">“Copy.”</a></span></p></dd></dl><p>Different constraints apply depending on whether or not you use garbage collection:</p><ul class="spaceabove"><li class="li"><p>If you do not use garbage collection, for object properties you must explicitly specify one of <code>assign</code>, <code>retain</code> or <code>copy</code>—otherwise you will get a compiler warning. (This encourages you to think about what memory management behavior you want and type it explicitly.)</p><p>To decide which you should choose, you need to understand Cocoa’s memory management policy (see <em><a href="../../MemoryMgmt/index.html#//apple_ref/doc/uid/10000011i" target="_top">Memory Management Programming Guide for Cocoa</a></em>). </p></li><li class="li"><p>If you use garbage collection, you don't get a warning if you use the default (that is, if you don’t specify any of <code>assign</code>, <code>retain</code> or <code>copy</code>) unless the property's type is a class that conforms to <code>NSCopying</code>. The default is usually what you want; if the property type can be copied, however, to preserve encapsulation you often want to make a private copy of the object.</p></li></ul><a name="//apple_ref/doc/uid/TP30001163-CH17-SW28" title="Atomicity"></a><h4>Atomicity</h4><p>This attribute specifies that accessor methods are not atomic. (There is no keyword to denote atomic.)</p><dl class="termdef">	<dt><code>nonatomic</code></dt><dd><p>Specifies that accessors are non-atomic. <em>By default, accessors are atomic.</em> </p></dd></dl><p>Properties are atomic by default so that synthesized accessors provide robust access to properties in a multi-threaded environment—that is, the value returned from the getter or set via the setter is always fully retrieved or set regardless of what other threads are executing concurrently. For more details, see <span class="content_text"><a href="ocProperties.html#//apple_ref/doc/uid/TP30001163-CH17-SW12">“Performance and Threading.”</a></span></p><p>If you do not specify <code>nonatomic</code>, then in a reference counted environment a synthesized get accessor for an object property uses a lock and retains and autoreleases the returned value—the implementation will be similar to the following:</p><div class="codesample"><table><tr><td scope="row"><pre>[_internal lock]; // lock using an object-level lock<span></span></pre></td></tr><tr><td scope="row"><pre>id result = [[value retain] autorelease];<span></span></pre></td></tr><tr><td scope="row"><pre>[_internal unlock];<span></span></pre></td></tr><tr><td scope="row"><pre>return result;<span></span></pre></td></tr></table></div><p>If you specify <code>nonatomic</code>, then a synthesized accessor for an object property simply returns the value directly.</p><a name="//apple_ref/doc/uid/TP30001163-CH17-SW20" title="Markup and Deprecation"></a><h4>Markup and Deprecation</h4><p>Properties support the full range of C style decorators. Properties can be deprecated and support <code>__attribute__</code> style markup, as illustrated in the following example:</p><div class="codesample"><table><tr><td scope="row"><pre>@property CGFloat x<span></span></pre></td></tr><tr><td scope="row"><pre>AVAILABLE_MAC_OS_X_VERSION_10_1_AND_LATER_BUT_DEPRECATED_IN_MAC_OS_X_VERSION_10_4;<span></span></pre></td></tr><tr><td scope="row"><pre>@property CGFloat y __attribute__((...));<span></span></pre></td></tr></table></div><p>If you want to specify that a property is an Interface Builder outlet, you can use the <code>IBOutlet</code> identifier:</p><div class="codesample"><table><tr><td scope="row"><pre>@property (nonatomic, retain) IBOutlet NSButton *myButton;<span></span></pre></td></tr></table></div><p><code>IBOutlet</code> is not, though, a formal part of the list of attributes.</p><p>If you use garbage collection, you can use the storage modifiers <code>__weak</code> and <code>__strong</code> in a property’s declaration:</p><div class="codesample"><table><tr><td scope="row"><pre>@property (nonatomic, retain) __weak Link *parent;<span></span></pre></td></tr></table></div><p>but again they are not a formal part of the list of attributes.</p><a name="//apple_ref/doc/uid/TP30001163-CH17-SW9" title="Property Implementation Directives"></a><h3>Property Implementation Directives</h3><p>You can use the <code>@synthesize</code> and <code>@dynamic</code> directives in <code>@implementation</code> blocks to trigger specific compiler actions. Note that neither is <em>required</em> for any given <code>@property</code> declaration.</p><div class="importantbox"><a name="//apple_ref/doc/uid/TP30001163-CH17-DontLinkElementID_4" title="Important:"></a><p><strong>Important:</strong>&nbsp;If you do not specify either <code>@synthesize</code> or <code>@dynamic</code> for a particular property, you must provide a getter and setter (or just a getter in the case of a <code>readonly</code> property) method implementation for that property.</p><p></p></div><dl class="termdef">	<dt><code>@synthesize</code></dt><dd><p>You use the <code>@synthesize</code> keyword to tell the compiler that it should synthesize the setter and/or getter methods for the property if you do not supply them within the <code>@implementation</code> block. </p><a name="//apple_ref/doc/uid/TP30001163-CH17-SW11" title="Listing 4-2Using @synthesize"></a><p class="codesample"><strong>Listing 4-2&nbsp;&nbsp;</strong>Using @synthesize</p><div class="codesample"><table><tr><td scope="row"><pre>@interface MyClass : NSObject<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    NSString *value;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre>@property(copy, readwrite) NSString *value;<span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>@implementation MyClass<span></span></pre></td></tr><tr><td scope="row"><pre>@synthesize value;<span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr></table></div><p>You can use the form <code>property=ivar</code> to indicate that a particular instance variable should be used for the property, for example:</p><div class="codesample"><table><tr><td scope="row"><pre>@synthesize firstName, lastName, age = yearsOld;<span></span></pre></td></tr></table></div><p>This specifies that the accessor methods for <code>firstName</code>, <code>lastName</code>, and <code>age</code> should be synthesized and that the property <code>age</code> is represented by the instance variable <code>yearsOld</code>. Other aspects of the synthesized methods are determined by the optional attributes (see <span class="content_text"><a href="ocProperties.html#//apple_ref/doc/uid/TP30001163-CH17-SW2">“Property Declaration Attributes”</a></span>).</p><p>There are differences in the behavior that depend on the runtime (see also <span class="content_text"><a href="ocProperties.html#//apple_ref/doc/uid/TP30001163-CH17-SW3">“Runtime Difference”</a></span>):</p><ul class="termdef"><li class="termdef"><p>For the legacy runtimes, instance variables must already be declared in the <code>@interface</code> block. If an instance variable of the same name and compatible type as the property exists, it is used—otherwise, you get a compiler error.</p></li><li class="termdef"><p>For the modern runtimes (see <span class="content_text"><a href="../../ObjCRuntimeGuide/Articles/ocrtVersionsPlatforms.html#//apple_ref/doc/uid/TP40008048-CH106" target="_top">Runtime Versions and Platforms</a></span> in <em><a href="../../ObjCRuntimeGuide/index.html#//apple_ref/doc/uid/TP40008048" target="_top">Objective-C 2.0 Runtime Programming Guide</a></em>), instance variables are synthesized as needed. If an instance variable of the same name already exists, it is used.</p></li></ul></dd><dt><code>@dynamic</code></dt><dd><p>You use the <code>@dynamic</code> keyword to tell the compiler that you will fulfill the API contract implied by a property either by providing method implementations directly or at runtime using other mechanisms such as dynamic loading of code or dynamic method resolution. The example shown in <span class="content_text">Listing 4-3</span> illustrates using direct method implementations—it is equivalent to the example given in <span class="content_text"><a href="ocProperties.html#//apple_ref/doc/uid/TP30001163-CH17-SW11">Listing 4-2</a></span>.</p><a name="//apple_ref/doc/uid/TP30001163-CH17-SW8" title="Listing 4-3Using @dynamic with direct method implementations"></a><p class="codesample"><strong>Listing 4-3&nbsp;&nbsp;</strong>Using @dynamic with direct method implementations</p><div class="codesample"><table><tr><td scope="row"><pre>@interface MyClass : NSObject<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    NSString *value;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre>@property(copy, readwrite) NSString *value;<span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>// assume using garbage collection<span></span></pre></td></tr><tr><td scope="row"><pre>@implementation MyClass<span></span></pre></td></tr><tr><td scope="row"><pre>@dynamic value;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (NSString *)value {<span></span></pre></td></tr><tr><td scope="row"><pre>    return value;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (void)setValue:(NSString *)newValue {<span></span></pre></td></tr><tr><td scope="row"><pre>    if (newValue != value) {<span></span></pre></td></tr><tr><td scope="row"><pre>        value = [newValue copy];<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr></table></div></dd></dl><a name="//apple_ref/doc/uid/TP30001163-CH17-SW17" title="Using Properties"></a><h2>Using Properties</h2><a name="//apple_ref/doc/uid/TP30001163-CH17-SW6" title="Supported Types"></a><h3>Supported Types</h3><p>You can declare a property for any Objective-C class, Core Foundation data type, or “plain old data” (POD) type (see <span class="content_text"><a href="http://www.fnal.gov/docs/working-groups/fpcltf/Pkg/ISOcxx/doc/POD.html" target="_blank">C++ Language Note: POD Types</a></span>). For constraints on using Core Foundation types, however, see <span class="content_text"><a href="ocProperties.html#//apple_ref/doc/uid/TP30001163-CH17-SW10">“Core Foundation.”</a></span></p><a name="//apple_ref/doc/uid/TP30001163-CH17-SW19" title="Property Re-declaration"></a><h3>Property Re-declaration</h3><p>You can re-declare a property in a subclass, but (with the exception of <code>readonly</code> vs. <code>readwrite</code>) you must repeat its attributes in whole in the subclasses. The same holds true for a property declared in a category or protocol—while the property may be redeclared in a category or protocol, the property’s attributes must be repeated in whole.</p><p>If you declare a property in one class as <code>readonly</code>, you can redeclare it as <code>readwrite</code> in a class extension (see <span class="content_text"><a href="ocCategories.html#//apple_ref/doc/uid/TP30001163-CH20-SW2">“Extensions”</a></span>), a protocol, or a subclass—see <span class="content_text"><a href="ocProperties.html#//apple_ref/doc/uid/TP30001163-CH17-SW4">“Subclassing with Properties.”</a></span> In the case of a class extension redeclaration, the fact that the property was redeclared prior to any <code>@synthesize</code> statement will cause the setter to be synthesized. The ability to redeclare a read-only property as read/write enables two common implementation patterns: a mutable subclass of an immutable class (<code>NSString</code>, <code>NSArray</code>, and <code>NSDictionary</code> are all examples) and a property that has public API that is <code>readonly</code> but a private <code>readwrite</code> implementation internal to the class. The following example shows using a class extension to provide a property that is declared as read-only in the public header but is redeclared privately as read/write.</p><div class="codesample"><table><tr><td scope="row"><pre>// public header file<span></span></pre></td></tr><tr><td scope="row"><pre>@interface MyObject : NSObject {<span></span></pre></td></tr><tr><td scope="row"><pre>    NSString *language;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre>@property (readonly, copy) NSString *language;<span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>// private implementation file<span></span></pre></td></tr><tr><td scope="row"><pre>@interface MyObject ()<span></span></pre></td></tr><tr><td scope="row"><pre>@property (readwrite, copy) NSString *language;<span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>@implementation MyObject<span></span></pre></td></tr><tr><td scope="row"><pre>@synthesize language;<span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP30001163-CH17-SW32" title="Copy"></a><h3>Copy</h3><p>If you use the <code>copy</code> declaration attribute, you specify that a value is copied during assignment. If you synthesize the corresponding accessor, the synthesized method uses the <code>copy</code> method. This is useful for attributes such as string objects where there is a possibility that the new value passed in a setter may be mutable (for example, an instance of <code>NSMutableString</code>) and you want to ensure that your object has its own private immutable copy. For example, if you declare a property as follows:</p><div class="codesample"><table><tr><td scope="row"><pre>@property (nonatomic, copy) NSString *string;<span></span></pre></td></tr></table></div><p>then the synthesized setter method is similar to the following:</p><div class="codesample"><table><tr><td scope="row"><pre>-(void)setString:(NSString *)newString {<span></span></pre></td></tr><tr><td scope="row"><pre>    if (string != newString) {<span></span></pre></td></tr><tr><td scope="row"><pre>        [string release];<span></span></pre></td></tr><tr><td scope="row"><pre>        string = [newString copy];<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>Although this works well for strings, it may present a problem if the attribute is a collection such as an array or a set. Typically you want such collections to be mutable, but the <code>copy</code> method returns an <em>immutable</em> version of the collection. In this situation, you have to provide your own implementation of the setter method, as illustrated in the following example.</p><div class="codesample"><table><tr><td scope="row"><pre>@interface MyClass : NSObject {<span></span></pre></td></tr><tr><td scope="row"><pre>    NSMutableArray *myArray;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre>@property (nonatomic, copy) NSMutableArray *myArray;<span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>@implementation MyClass<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>@synthesize myArray;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (void)setMyArray:(NSMutableArray *)newArray {<span></span></pre></td></tr><tr><td scope="row"><pre>    if (myArray != newArray) {<span></span></pre></td></tr><tr><td scope="row"><pre>        [myArray release];<span></span></pre></td></tr><tr><td scope="row"><pre>        myArray = [newArray mutableCopy];<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP30001163-CH17-SW16" title="dealloc"></a><h3>dealloc</h3><p>Declared properties fundamentally take the place of accessor method declarations; when you synthesize a property, the compiler only creates any absent accessor methods. There is no direct interaction with the <code>dealloc</code> method—properties are <em>not</em> automatically released for you. Declared properties do, however, provide a useful way to cross-check the implementation of your <code>dealloc</code> method: you can look for all the property declarations in your header file and make sure that object properties not marked <code>assign</code> are released, and those those marked <code>assign</code> are not released.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP30001163-CH17-SW23" title="Note"></a><p><strong>Note:</strong>&nbsp;Typically in a <code>dealloc</code> method you should release object instance variables directly (rather than invoking a set accessor and passing <code>nil</code> as the parameter), as illustrated in this example:</p><div class="codesample"><table><tr><td scope="row"><pre>- (void)dealloc {<span></span></pre></td></tr><tr><td scope="row"><pre>    [property release];<span></span></pre></td></tr><tr><td scope="row"><pre>    [super dealloc];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div>If you are using the modern runtime and synthesizing the instance variable, however, you cannot access the instance variable directly, so you must invoke the accessor method:</p><div class="codesample"><table><tr><td scope="row"><pre>- (void)dealloc {<span></span></pre></td></tr><tr><td scope="row"><pre>    [self setProperty:nil];<span></span></pre></td></tr><tr><td scope="row"><pre>    [super dealloc];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div></div><a name="//apple_ref/doc/uid/TP30001163-CH17-SW10" title="Core Foundation"></a><h3>Core Foundation</h3><p>As noted in <span class="content_text"><a href="ocProperties.html#//apple_ref/doc/uid/TP30001163-CH17-SW2">“Property Declaration Attributes,”</a></span> you cannot specify the <code>retain</code> attribute for non-object types. If, therefore, you declare a property whose type is a CFType and synthesize the accessors as illustrated in the following example:</p><div class="codesample"><table><tr><td scope="row"><pre>@interface MyClass : NSObject<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    CGImageRef myImage;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre>@property(readwrite) CGImageRef myImage;<span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>@implementation MyClass<span></span></pre></td></tr><tr><td scope="row"><pre>@synthesize myImage;<span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr></table></div><p>then in a reference counted  environment the generated set accessor will simply assign the new value to the instance variable (the new value is not retained and the old value is not released). This is typically incorrect, so you should not synthesize the methods, you should implement them yourself.</p><p>In a garbage collected environment, if the variable is declared <code>__strong</code>:</p><div class="codesample"><table><tr><td scope="row"><pre>...<span></span></pre></td></tr><tr><td scope="row"><pre>__strong CGImageRef myImage;<span></span></pre></td></tr><tr><td scope="row"><pre>...<span></span></pre></td></tr><tr><td scope="row"><pre>@property CGImageRef myImage;<span></span></pre></td></tr></table></div><p>then the accessors are synthesized appropriately—the image will not be CFRetain'd, but the setter will trigger a write barrier. </p><a name="//apple_ref/doc/uid/TP30001163-CH17-SW21" title="Example"></a><h3>Example</h3><p>The following example illustrates the use of properties in several different ways:</p><ul class="spaceabove"><li class="li"><p>The Link protocol declares a property, <code>next</code>.</p></li><li class="li"><p>MyClass adopts the Link protocol so implicitly also declares the property <code>next</code>. MyClass also declares several other properties.</p></li><li class="li"><p><code>creationTimestamp</code> and <code>next</code> are synthesized but use existing instance variables with different names;</p></li><li class="li"><p><code>name</code> is synthesized, and uses instance variable synthesis (recall that instance variable synthesis is not supported using the legacy runtime—see <span class="content_text"><a href="ocProperties.html#//apple_ref/doc/uid/TP30001163-CH17-SW9">“Property Implementation Directives”</a></span> and <span class="content_text"><a href="ocProperties.html#//apple_ref/doc/uid/TP30001163-CH17-SW3">“Runtime Difference”</a></span>);</p></li><li class="li"><p><code>gratuitousFloat</code> has a <code>dynamic</code> directive—it is supported using direct method implementations; </p></li><li class="li"><p><code>nameAndAge</code> does not have a <code>dynamic</code> directive, but this is the default value; it is supported using a direct method implementation (since it is read-only, it only requires a getter) with a specified name (<code>nameAndAgeAsString</code>).</p></li></ul><a name="//apple_ref/doc/uid/TP30001163-CH17-SW22" title="Listing 4-4Declaring properties for a class"></a><p class="codesample"><strong>Listing 4-4&nbsp;&nbsp;</strong>Declaring properties for a class</p><div class="codesample"><table><tr><td scope="row"><pre>@protocol Link<span></span></pre></td></tr><tr><td scope="row"><pre>@property id &lt;Link> next;<span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>@interface MyClass : NSObject &lt;Link><span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    NSTimeInterval intervalSinceReferenceDate;<span></span></pre></td></tr><tr><td scope="row"><pre>    CGFloat gratuitousFloat;<span></span></pre></td></tr><tr><td scope="row"><pre>    id &lt;Link> nextLink;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre>@property(readonly) NSTimeInterval creationTimestamp;<span></span></pre></td></tr><tr><td scope="row"><pre>@property(copy) __strong NSString *name;<span></span></pre></td></tr><tr><td scope="row"><pre>@property CGFloat gratuitousFloat;<span></span></pre></td></tr><tr><td scope="row"><pre>@property(readonly, getter=nameAndAgeAsString) NSString *nameAndAge;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>@implementation MyClass<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>@synthesize creationTimestamp = intervalSinceReferenceDate, name;<span></span></pre></td></tr><tr><td scope="row"><pre>// synthesizing 'name' is an error in legacy runtimes<span></span></pre></td></tr><tr><td scope="row"><pre>// in modern runtimes, the instance variable is synthesized<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>@synthesize next = nextLink;<span></span></pre></td></tr><tr><td scope="row"><pre>// uses instance variable "nextLink" for storage<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>@dynamic gratuitousFloat;<span></span></pre></td></tr><tr><td scope="row"><pre>// will warn unless -gratuitousFloat and -setGratuitousFloat: occur in @implementation<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (CGFloat)gratuitousFloat {<span></span></pre></td></tr><tr><td scope="row"><pre>    return gratuitousFloat;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre>- (void)setGratuitousFloat:(CGFloat)aValue {<span></span></pre></td></tr><tr><td scope="row"><pre>    gratuitousFloat = aValue;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (NSString *)nameAndAgeAsString {<span></span></pre></td></tr><tr><td scope="row"><pre>    return [NSString stringWithFormat:@"%@ (%fs)", [self name],<span></span></pre></td></tr><tr><td scope="row"><pre>               [NSDate timeIntervalSinceReferenceDate] - intervalSinceReferenceDate];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre> - (id)init {<span></span></pre></td></tr><tr><td scope="row"><pre>    if (self = [super init]) {<span></span></pre></td></tr><tr><td scope="row"><pre>        intervalSinceReferenceDate = [NSDate timeIntervalSinceReferenceDate];<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    return self;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (void)dealloc {<span></span></pre></td></tr><tr><td scope="row"><pre>    [nextLink release];<span></span></pre></td></tr><tr><td scope="row"><pre>    [name release];<span></span></pre></td></tr><tr><td scope="row"><pre>    [super dealloc];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP30001163-CH17-SW4" title="Subclassing with Properties"></a><h2>Subclassing with Properties</h2><p>You can override a <code>readonly</code> property to make it writable. For example, you could define a class <code>MyInteger</code> with a <code>readonly</code> property, <code>value</code>: </p><div class="codesample"><table><tr><td scope="row"><pre>@interface MyInteger : NSObject<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    NSInteger value;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre>@property(readonly) NSInteger value;<span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>@implementation MyInteger<span></span></pre></td></tr><tr><td scope="row"><pre>@synthesize value;<span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr></table></div><p>You could then implement a subclass, <code>MyMutableInteger</code>, which redefines the property to make it writable:</p><div class="codesample"><table><tr><td scope="row"><pre>@interface MyMutableInteger : MyInteger<span></span></pre></td></tr><tr><td scope="row"><pre>@property(readwrite) NSInteger value;<span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>@implementation MyMutableInteger<span></span></pre></td></tr><tr><td scope="row"><pre>@dynamic value;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>- (void)setValue:(NSInteger)newX {<span></span></pre></td></tr><tr><td scope="row"><pre>    value = newX;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP30001163-CH17-SW12" title="Performance and Threading"></a><h2>Performance and Threading</h2><p>If you supply your own method implementation, the fact that you declared a property has no effect on its efficiency or thread safety. </p><p>If you use synthesized properties, the method implementations generated by the compiler depend on the specification you supply. The declaration attributes that affect performance and threading are <code>retain</code>, <code>assign</code>, <code>copy</code>, and <code>nonatomic</code>. The first three of these affect only the implementation of the assignment part of the set method, as <em>illustrated</em> below (the implementation may not be exactly as shown):</p><div class="codesample"><table><tr><td scope="row"><pre>// assign<span></span></pre></td></tr><tr><td scope="row"><pre>property = newValue;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>// retain<span></span></pre></td></tr><tr><td scope="row"><pre>if (property != newValue) {<span></span></pre></td></tr><tr><td scope="row"><pre>    [property release];<span></span></pre></td></tr><tr><td scope="row"><pre>    property = [newValue retain];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>// copy<span></span></pre></td></tr><tr><td scope="row"><pre>if (property != newValue) {<span></span></pre></td></tr><tr><td scope="row"><pre>    [property release];<span></span></pre></td></tr><tr><td scope="row"><pre>    property = [newValue copy];<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>The effect of the <code>nonatomic</code> attribute depends on the environment. By default, the synthesized accessors are atomic. In a reference counted environment, guaranteeing atomic behavior requires the use of a lock; moreover a returned object is retained and autoreleased, as illustrated in <span class="content_text"><a href="ocProperties.html#//apple_ref/doc/uid/TP30001163-CH17-SW28">“Atomicity.”</a></span> If such accessors are invoked frequently, this may have a significant impact on performance. In a garbage collected environment, most synthesized methods are atomic without incurring this overhead.</p><p>It is important to understand that the goal of the atomic implementation is to provide <em>robust</em> accessors—it does not guarantee <em>correctness</em> of your code. Although “atomic” means that access to the <em>property</em> is thread-safe, simply making all the properties in your class atomic does not mean that your <em>class</em> or more generally your object graph is “thread safe”—thread safety cannot be expressed at the level of individual accessor methods. For more about multi-threading, see <em><a href="../../Multithreading/index.html#//apple_ref/doc/uid/10000057i" target="_top">Threading Programming Guide</a></em>.</p><a name="//apple_ref/doc/uid/TP30001163-CH17-SW3" title="Runtime Difference"></a><h2>Runtime Difference</h2><p>In general the behavior of properties is identical on all runtimes (see <span class="content_text"><a href="../../ObjCRuntimeGuide/Articles/ocrtVersionsPlatforms.html#//apple_ref/doc/uid/TP40008048-CH106" target="_top">Runtime Versions and Platforms</a></span> in <em><a href="../../ObjCRuntimeGuide/index.html#//apple_ref/doc/uid/TP40008048" target="_top">Objective-C 2.0 Runtime Programming Guide</a></em>). There is one key difference: the modern runtime supports instance variable synthesis whereas the legacy runtime does not.</p><p>For <code>@synthesize</code> to work in the legacy runtime, you must either provide an instance variable with the same name and compatible type of the property or specify another existing instance variable in the <code>@synthesize</code> statement. With the modern runtime, if you do not provide an instance variable, the compiler adds one for you. For example, given the following class declaration and implementation:</p><div class="codesample"><table><tr><td scope="row"><pre>@interface MyClass : NSObject {<span></span></pre></td></tr><tr><td scope="row"><pre>    float sameName;<span></span></pre></td></tr><tr><td scope="row"><pre>    float otherName;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre>@property float sameName;<span></span></pre></td></tr><tr><td scope="row"><pre>@property float differentName;<span></span></pre></td></tr><tr><td scope="row"><pre>@property float noDeclaredIvar;<span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>@implementation MyClass<span></span></pre></td></tr><tr><td scope="row"><pre>@synthesize sameName;<span></span></pre></td></tr><tr><td scope="row"><pre>@synthesize differentName=otherName;<span></span></pre></td></tr><tr><td scope="row"><pre>@synthesize noDeclaredIvar;<span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr></table></div><p>the compiler for the legacy runtime would generate an error at <code>@synthesize noDeclaredIvar;</code> whereas the compiler for the modern runtime would add an instance variable to represent <code>noDeclaredIvar</code>.</p>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="ocAllocInit.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="ocCategories.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2009 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2009-05-06<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Cocoa/Conceptual/ObjectiveC/Articles/ocProperties.html%3Fid%3DTP30001163-4.9&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Cocoa/Conceptual/ObjectiveC/Articles/ocProperties.html%3Fid%3DTP30001163-4.9&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Cocoa/Conceptual/ObjectiveC/Articles/ocProperties.html%3Fid%3DTP30001163-4.9&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>