<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>DNSServiceDiscovery Mach-Based API (Not Recommended): Bonjour Overview</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Bonjour Overview"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	<meta name="ROBOTS" content="NOINDEX"/>
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP30001129-CH204" title="Bonjour Overview"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../index.html#//apple_ref/doc/uid/TP30000440-TP30000429" target="_top">Networking</a> &gt; <a href="../../../Bonjour-date.html#//apple_ref/doc/uid/TP30000440-TP30000429-TP30000566" target="_top">Bonjour</a> &gt; <a href="../introduction/intro_mach.html#//apple_ref/doc/uid/TP30001129-CH203-DontLinkElementID_8">DNSServiceDiscovery Mach-Based API (Not Recommended)</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../introduction/intro_mach.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../tasks/tasks_mach.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        <script type="text/javascript" language="JavaScript">placeWatermark()</script>
<div id="legacyOuterWrapper"><div align="center" id="watermark">
<div class="legacybox">
<h1>Legacy Document<span class="closebutton"><a href="javascript:closeWatermark()"><img src="../../../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>
        <a name="//apple_ref/doc/uid/TP30001129-CH204-DontLinkElementID_4" title="Bonjour Overview"></a><h1><a name="//apple_ref/doc/uid/TP30001129-CH204-BCIDBAEJ" title="Bonjour Overview"></a>Bonjour Overview</h1>
<p>Bonjour is a powerful new system for finding
and publishing network services, such as Web servers, file servers,
and printers, on Internet Protocol (IP) networks. This system adds
the simplicity and ease-of-use of AppleTalk to the power of IP network
services. </p>
<p>Bonjour is Apple&#8217;s implementation of zero-configuration
networking over IP and is based on IETF standard protocols (IP,
ARP, DNS, etc.). Bonjour comes out of the work of the IERF Zeroconf
Working Group.</p>
<p>This section describes some of the problems that Bonjour
solves and how it solves them.</p>

<!-- This template is being used for both PDF and HTML. -->

    
    <h4>In this section:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="concepts_mach.html#//apple_ref/doc/uid/TP30001129-CH204-TPXREF107">Why Bonjour?</a>
				
			<br/>
			
        
			
			
				<a href="concepts_mach.html#//apple_ref/doc/uid/TP30001129-CH204-TPXREF109">What is Bonjour?</a>
				
			<br/>
			
        
			
			
				<a href="concepts_mach.html#//apple_ref/doc/uid/TP30001129-CH204-TPXREF116">Programming in Bonjour</a>
				
			<br/>
			
        
			
			
				<a href="concepts_mach.html#//apple_ref/doc/uid/TP30001129-CH204-BBCGEJIE">Bonjour and Domain Names</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP30001129-CH204-197814" title="Why Bonjour?"></a><a name="//apple_ref/doc/uid/TP30001129-CH204-TPXREF107" title="Why Bonjour?"></a><h2>Why Bonjour?</h2>
<p>Over the last twenty years, a large number of wide-area networking
protocols have appeared and disappeared. In recent years, Internet
protocol (IP) has become the single predominant standard on every
computing platform. The majority of computers, and many other network
devices, all speak a common language. For wide-area networks and the
Internet, IP protocol is all you need.</p>
<p>On local area networks (LANs) however, a few other protocols
live on. To work on as many local networks as possible, printers
and applications such as multiplayer games must support not only
IP, but also AppleTalk or Windows Netbeui, or perhaps all three. While
IP has emerged as a unifying protocol for wide area networks and
the Internet, it is not a universal standard on local networks,
especially small networks and home networks. Why?</p>
<p>The answer is simple: these networks don&#8217;t often have dedicated
address and name servers (DHCP and DNS) or a real system administrator. </p>
<p>For IP to work, every device needs a unique address. To make
this happen, either everyone must agree on static IP addresses and
manually type them in, or someone must set up a DHCP server or similar
service to dynamically allocate addresses to clients. To refer to services
by name, someone must set up a DNS server to perform the name-to-address translation,
and, typically, use &#8220;well known ports&#8221; for specific types of
services. To use a service, network users have to know it&#8217;s name,
so when a service is added, everyone needs to be notified. Someone
with a lot of knowledge has to set all this up and maintain it.</p>
<p>More and more, people that do not fit the traditional role
of the network administrator are setting up networks. Families are
setting up home networks so they can share printers, files, and
Internet connections. Peers meeting at conferences are setting up
ad-hoc networks to exchange data. Even inside well-managed corporate
networks, employees are adding devices to and removing devices from
their local subnets. Currently, all these activities require manual
configuration of IP addresses and names.</p>
<p>This new breed of network administrator does not want to configure
subnet masks or DNS servers. Even a highly competent network administrator
doesn&#8217;t want to send email to every employee every time a printer
is added to the network. Printer manufacturers and game publishers
don&#8217;t want to support multiple protocol stacks on a $50 product.
People need to be able to plug in a printer, or plug two laptops
together, or look for a file server or game server on the local
network, without wasting time trying to get the configuration right.</p>
<p>Once the configuration of devices on an IP network is right,
the user needs to know the exact name of any printer or other service
in order to use it. That&#8217;s better than typing in an IP address,
but it doesn&#8217;t help the user find services he or she doesn&#8217;t
already know about. And it doesn&#8217;t forgive spelling errors. Browsing
for available services is often simply impossible. A large number
of IP service browsing protocols have appeared and disappeared,
but none has achieved critical mass.</p>
<p>Before the emergence of IP as the preeminent interoperative
networking protocol, AppleTalk solved the configuration and usage
problems that continue to hinder IP today. With AppleTalk, users
can simply browse for a service and click to choose it. For example, if
you connect a group of Macintosh computers running Mac OS 9 or earlier
with an Ethernet hub, they can instantly see all the available printers,
file servers, and other services available on the local network.
All this happens without centralized allocation of network addresses,
without a centralized name server, and without a centralized repository
of available services.</p>
<p>People need a simple and reliable way to configure and browse
for services over IP networks. They want to discover available services
and choose one from a list, instead of having to know each service&#8217;s
name or IP address in advance. It is in everyone&#8217;s interest for
IP to have this capability. This is exactly the capability that
Bonjour provides.</p>
<a name="//apple_ref/doc/uid/TP30001129-CH204-203008" title="Zero Configuration: An Example"></a><a name="//apple_ref/doc/uid/TP30001129-CH204-TPXREF108" title="Zero Configuration: An Example"></a><h3>Zero Configuration: An Example</h3>
<p>The potential for zero-configuration IP networking is tremendous.
Consider the everyday task of printing. Once a printer is configured
on your computer, it&#8217;s simply a matter of choosing an application&#8217;s
Print command.</p>
<p>Take your laptop to a client&#8217;s company, or a neighbor&#8217;s
house, and try to print something. If they have a printer that supports
Bonjour protocols, printing is just as easy as it was on your
local network. To print, connect an Ethernet cable from your laptop
to your client&#8217;s LAN and start up your laptop. Or start up your
laptop and it instantly finds your neighbor&#8217;s home wireless network.
Either way, your laptop automatically discovers any available printers.
You open the document, choose the Print command, and every available
printer appears in the Print dialog. You select a printer, click
Print, and the document prints.</p>
<p>Or say you want to play a network game with a friend. You
open the game, and your friend&#8217;s copy of the game instantly sees
your copy over the network. Or if you have a music sharing application
on both computers, the programs themselves can discover each other and
instantly swap songlists. Similarly, if you have a shared folder
or have personal Web sharing turned on, your shared files and Web
pages are instantly available to others. </p>
<p>This scenario is illustrated in <span class="content_text"><a href="concepts_mach.html#//apple_ref/doc/uid/TP30001129-CH204-197909">Figure 1-1</a></span>. In step 1, you open
up your laptop in your neighbor&#8217;s house, and the laptop either
obtains an address from the DHCP server in the router or, in the
absence of a DHCP server, assigns itself an available local address.
In step 2, the network is queried for available printers so that
when you open the Print dialog, your neighbor&#8217;s printer is listed.
Finally, in step 3, you turn on music sharing on your computer,
and your neighbor&#8217;s computer sees it and connects.</p>
<p>These are just a few of the existing applications that can
benefit from zero-configuration IP networking. Zero-configuration
IP networking has the potential to enhance contact management, PDA
synchronization, distributed processing, and many other network applications.
Additionally, zero-configuration IP networking opens the door for
a whole new class of IP-enabled digital devices.</p>
<br/><div><a name="//apple_ref/doc/uid/TP30001129-CH204-197909" title="Figure 1-1A typical zero-configuration networking session"></a><a name="//apple_ref/doc/uid/TP30001129-CH204-BCIIAIFI" title="Figure 1-1A typical zero-configuration networking session"></a><p><strong>Figure 1-1&nbsp;&nbsp;</strong>A typical zero-configuration networking
session</p><img src = "../art/about_01example.gif" alt = "" width="488" height="460"></div><br/>
<a name="//apple_ref/doc/uid/TP30001129-CH204-197936" title="What is Bonjour?"></a><a name="//apple_ref/doc/uid/TP30001129-CH204-TPXREF109" title="What is Bonjour?"></a><h2>What is Bonjour?</h2>
<p>Bonjour is Apple&#8217;s proposal for zero-configuration networking
over IP. Bonjour comes out of the work of the ZEROCONF Working
Group, part of the Internet Engineering Task Force (IETF). The ZEROCONF
Working Group&#8217;s requirements and proposed solutions essentially
cover three areas:</p>
<ul class="ul"><li class="li"><p>addressing (allocating IP addresses to hosts)</p></li>
<li class="li"><p>naming (using names to refer to hosts instead of IP addresses)</p></li>
<li class="li"><p>service discovery (finding services on the network automatically)</p></li></ul>
<p>Bonjour has a zero-configuration solution for all three
of these areas, as described in the following three sections.</p>
<p>Bonjour allows service providers, hardware manufacturers,
and application programmers to support a single network protocol&#8212;IP&#8212;while
breaking new ground in ease of use.</p>
<p>Network users no longer have to assign IP addresses, assign
host names, or even type in names to access services on the network.
Users simply ask to see what network services are available, and
choose from the list.</p>
<p>In many ways, this kind of browsing is even more powerful
for applications than for users. Applications can automatically
detect services they need or other applications they can interact
with, allowing automatic connection, communication, and data exchange,
without requiring user intervention.</p>
<a name="//apple_ref/doc/uid/TP30001129-CH204-197988" title="Addressing"></a><a name="//apple_ref/doc/uid/TP30001129-CH204-TPXREF110" title="Addressing"></a><h3>Addressing</h3>
<p>The addressing problem is solved by self-assigned link-local
addressing. Link-local addressing uses a range of addresses reserved
for the local network, typically a small LAN or a single LAN segment. </p>
<p>Self-assigned addressing is simply picking a random IP address
in the link-local range and testing it. If the address in not use,
it is now your local address. If it is already in use, pick another
address and try again.</p>
<p>Note: Two hosts are considered to be on the same local link
if, when one host sends packets to the other, the entire link-layer
payload (the content of the packet as represented in the physical
network, such as Ethernet) arrives unmodified. In practice, on an
Ethernet network, this means that no IP router touches the packet
between the two hosts. </p>
<p>Self-assigned link-local addressing has already shipped on
IPv4 starting with Mac OS 8.5, Windows 98, and Mac OS X version
10.0. The IPv6 specification includes self-assigned link-local addressing.</p>
<p>Any user or service on a computer that supports self-assigned
link-local addressing benefits from this feature automatically.
When your host computer encounters a local network, it finds an
unused local address and adopts it. No action on your part is required.</p>
<p>Hardware manufacturers should implement self-assigned link-local
addressing on their devices to obtain the full benefit of Bonjour.</p>
<a name="//apple_ref/doc/uid/TP30001129-CH204-198027" title="Naming"></a><a name="//apple_ref/doc/uid/TP30001129-CH204-BBCJFDFF" title="Naming"></a><h3>Naming</h3>
<p>The proposed solution for name-to-address translation on a
local network uses multicast DNS (mDNS), in which DNS-format queries
are sent over the local network using IP multicast. Because these
DNS queries are sent to a multicast address, no single DNS server with
global knowledge is required to answer the queries. Each service
or device can provide its own DNS capability&#8212;when it sees a query
for its own name, it provides a DNS response with its own address.</p>
<p>Bonjour goes a bit further. It includes a responder that
handles mDNS queries for any network service on the host computer.
This relieves your application of the need to interpret and respond
to mDNS messages. Just register your service with the Bonjour mDNS
responder, and any queries for your name will be directed to your
address automatically.</p>
<div class="notebox"><a name="//apple_ref/doc/uid/TP30001129-CH204-DontLinkElementID_5" title="Note"></a><p><strong>Note:</strong>&nbsp;Registration
is performed using one of the Bonjour APIs. This is available
only to services running on the host computer. Services running
on other devices, such as printers, need to implement a simple mDNS
responder that handles queries for services provided by that device.</p></div>
<p>For name-to-address translation to work properly, you need
a unique name on the local network. Unlike conventional DNS host
names, the local name only has significance on the local network
or LAN segment. You can self-assign a local name the same way you self-assign
a local address&#8212;choose one; if it&#8217;s not already in use, it&#8217;s
yours:</p>
<ul class="spaceabove"><li class="li"><p>Hardware manufacturers determine whether their
chosen name is already use by sending an mDNS query for that name
and looking for any response. If there is a response, choose another
name. Devices without a user interface append an incrementally larger
number to a default name until the name is unique. For example, if
a printer with the default name <code>XYZ-LaserPrinter</code> attaches
to a local network with two other identical printers already installed,
it tests for <code>XYZ-LaserPrinter</code>,
then <code>XYZ-LaserPrinter2</code>,
then <code>XYZ-LaserPrinter3</code>,
which is unused and becomes its name.</p></li>
<li class="li"><p>Software services provide a local name when they register
with Bonjour. If the provided name is already in use, Bonjour
returns an error, and the service chooses another name.</p></li></ul>
<p>Starting with Mac OS X version 10.2, users can set a local
host name for their computers&#8212;the Local Hostname setting in the
Sharing pane of System Preferences. The host name can be used anywhere
a conventional DNS host name is used&#8212;Web browsers, command line tools,
and so on. To indicate to the system that the name is a local host
name, append a dot (<code>.</code>)
and <code>local.</code> to the host
name &#8212; <code>Steve.local</code>.
is an example of a local host name.</p>
<div class="importantbox"><a name="//apple_ref/doc/uid/TP30001129-CH204-DontLinkElementID_6" title="Important:"></a><p><strong>Important:</strong>&nbsp;

The first dot acts as a separator. The dot at the end
of <code>local.</code> is required
to prevent applications from searching for local services outside
the local network.</p><p></p></div>
<p>For example, if a user types <code>steve.local.</code> into
a Web browser, this tells the system to multicast the request for <code>steve</code> on
the local network instead of sending it to the conventional DNS
server. If a Bonjour-enabled computer named <code>steve</code> is
on the local network, the user&#8217;s browser is sent the correct IP
address for it. This allows users to access local hosts and services
without a conventional DNS server.</p>
<div class="notebox"><a name="//apple_ref/doc/uid/TP30001129-CH204-DontLinkElementID_7" title="Note"></a><p><strong>Note:</strong>&nbsp;Users can avoid
typing <code>.local.</code> after
Bonjour host names by entering <code>local</code> in
the Search Domains section of the Network pane in System Preferences,
along with any other DNS domains such as <code>apple.com</code> or <code>earthlink.net</code>.
An unqualified name, such as <code>steve</code>,
is searched for in successive domains listed in the Search Domains section
of the Network pane, in this case <code>steve.apple.com</code>, <code>steve.earthlink.net</code>,
and <code>steve.local</code>.</p></div>
<p>For more information, see <span class="content_text"><a href="concepts_mach.html#//apple_ref/doc/uid/TP30001129-CH204-198407">“Bonjour and Domain Names.”</a></span></p>
<a name="//apple_ref/doc/uid/TP30001129-CH204-198168" title="Service Discovery"></a><a name="//apple_ref/doc/uid/TP30001129-CH204-TPXREF111" title="Service Discovery"></a><h3>Service Discovery</h3>
<p>The final element of Bonjour is service discovery. Service
discovery allows applications to find all available instances of
a particular type of service and to maintain a list of named services.
The application can then resolve a named instance of a service to
an IP address and port number, as described in <span class="content_text"><a href="concepts_mach.html#//apple_ref/doc/uid/TP30001129-CH204-198027">“Naming.”</a></span> </p>
<p>The list of named services provides a layer of indirection
between a service and its current IP address. Indirection enables
applications to keep a persistent list of available services and
resolve an actual network address just prior to actually using a
service. The list allows services to be relocated dynamically without
generating a lot of network traffic announcing the change.</p>
<p>Service discovery in Bonjour is accomplished by &#8220;browsing.&#8221;
An mDNS query is sent out for a given service type and domain, and
any matching servers reply with their names. The result is a list
of available services to choose from.</p>
<p>This is very different from the traditional device-centric
idea of network services. For someone who deals with servers, network
devices, and network programming, it is easy to get in the habit
of thinking about services in terms of physical hardware. In this device-centric
view, the network consists of a number of devices or hosts, each
with a set of services. For example, the network might consist of
a server machine and several client machines. In a device-centric
browsing scheme, a client queries the server for what services it
is running, gets back a list (FTP, HTTP, and so on), and decides
which service to use. The interface reflects the way the physical
system is organized. But this is not necessarily what the user logically
wants or needs.</p>
<p>Users typically want to accomplish a certain task, not query
a list of devices to find out what services are running. It makes
far more sense for a client to ask a single question: &#8220;What print
services are available?&#8221; than to query each available device with
the question, &#8220;What services are you running?&#8221; and sift through
the results looking for printers. The device-centric approach is
not only time-consuming, it generates a tremendous amount of network
traffic, most of it useless. The service-centric approach sends
a single query, generating only relevant replies.</p>
<p>Additionally, services are not tied to specific IP addresses
or even host names. For example, a website may be hosted by multiple
servers with different addresses. Within an organization, network
administrators may need to move a service from one server to another
to help balance the load. If clients store the host name (as in
most cases they now do), they will not be able to connect if the
service moves to a different host.</p>
<p>Bonjour takes the service-oriented view. Queries are made
according to the type of service needed, not the hosts providing
them. Applications store service names, not addresses, so if the
IP address, port number, or even host name has changed, the application
can still connect. By concentrating on services rather than devices,
the user&#8217;s browsing experience is made more useful and trouble-free.</p>
<a name="//apple_ref/doc/uid/TP30001129-CH204-198216" title="Avoiding &amp;#8220;Chattiness&amp;#8221;"></a><a name="//apple_ref/doc/uid/TP30001129-CH204-TPXREF112" title="Avoiding &amp;#8220;Chattiness&amp;#8221;"></a><h3>Avoiding &#8220;Chattiness&#8221;</h3>
<p>Server-free addressing, naming, and service discovery have
the potential to create a significant amount of excess network traffic,
but Bonjour takes a number of steps to reduce this traffic to
a minimum. This allows Bonjour to attain AppleTalk&#8217;s ease of
use while avoiding any unnecessary &#8220;chattiness.&#8221;</p>
<p>Bonjour makes use of several mechanisms for reducing zero-configuration
overhead, including caching, suppression of duplicate responses,
exponential back-off, and service announcement, as described in
the following sections.</p>
<a name="//apple_ref/doc/uid/TP30001129-CH204-198234" title="Caching"></a><a name="//apple_ref/doc/uid/TP30001129-CH204-TPXREF113" title="Caching"></a><h4>Caching</h4>
<p>Bonjour uses a cache of multicast packets to prevent hosts
from requesting information that has already been requested. For
example, when one host requests, say, a list of LPR print spoolers,
the list of printers comes back via multicast, so all local hosts
see it. The next time a host needs a list of print spoolers, it
already has the list in its cache and does not need to reissue the
query. The multicast DNS responder is responsible for maintaining
the cache; application developers do not need to do anything to
maintain it.</p>
<a name="//apple_ref/doc/uid/TP30001129-CH204-203456" title="Suppression of Duplicate Responses"></a><a name="//apple_ref/doc/uid/TP30001129-CH204-TPXREF114" title="Suppression of Duplicate Responses"></a><h4>Suppression of Duplicate Responses</h4>
<p>To prevent repeated answers to the same query, Bonjour
service queries include a list of known answers. For example, if
a host is browsing for printers, the first query includes no print
services and gets, say, twelve replies from available print servers.
The next time the host queries for print services, the query includes
a list of known servers. Print servers already on the list do not
respond.</p>
<p>Bonjour suppresses duplicate responses in another way.
If a host is about to respond, and notices that another host has
already responded with the same information, the host suppresses
its response.</p>
<p>Application developers do not need to take any action to suppress
duplicate responses. Bonjour takes care of duplicate response
suppression.</p>
<a name="//apple_ref/doc/uid/TP30001129-CH204-203473" title="Exponential Back-off and Service Announcement"></a><a name="//apple_ref/doc/uid/TP30001129-CH204-TPXREF115" title="Exponential Back-off and Service Announcement"></a><h4>Exponential Back-off and Service Announcement</h4>
<p>When a host is browsing for services, it does not continually
send queries to see if new services are available. Instead, the
host issues an initial query and sends subsequent queries exponentially
less often: after 1 second, 2 seconds, 4 seconds, 8 seconds, and
so on, up to a maximum interval of one hour.</p>
<p>This does not mean that it can take over an hour for a browser
to see a new service. When a service starts up on the network, it
announces its presence with the same exponential back-off algorithm.
This way, network traffic for service announcement and discovery
is kept to a minimum, but new services are seen very quickly.</p>
<p>Services running on a Bonjour-equipped host are announced
automatically when they register with the mDNS responder. Services
running on other hardware, such as printers, should implement service
announcement with exponential back-off to take full advantage of
Bonjour.</p>
<a name="//apple_ref/doc/uid/TP30001129-CH204-198324" title="Programming in Bonjour"></a><a name="//apple_ref/doc/uid/TP30001129-CH204-TPXREF116" title="Programming in Bonjour"></a><h2>Programming in Bonjour</h2>
<p>Bonjour provides API support that enables applications
to register services they offer, browse for services on the network,
and obtain the current IP address and port of a given service instance.
Bonjour takes care of the low-level tasks behind these operations, such
as announcing registered services, sending mDNS queries, tracking
responses, and providing name-to-address translation for named services. </p>
<p>Four APIs are available:</p>
<ul class="ul"><li class="li"><p>NSNetServices API, a Cocoa framework</p></li>
<li class="li"><p>CFNetServices API, a Carbon framework</p></li>
<li class="li"><p>Mach-based DNSServiceDiscovery API (described in this document
and deprecated in favor of the socket-based DNSServiceDiscovery
API)</p></li>
<li class="li"><p>Socket-based DNSServiceDiscovery API</p></li></ul>
<p>Cocoa programmers (Objective C) should use the NSNetServices
API. However, Cocoa programmers who need to exercise finer control
over events than offered by the NSNetServices API may want to use
the DNSServiceDiscovery API.</p>
<p>Carbon programmers (C/C++) should use the CFNetServices API.
Carbon programmers who are comfortable working with Mac OS X at
the Mach level may find the Mach-based DNSServiceDiscovery API simpler
to use for some applications. Note, however, that the Mach-based
DNSServiceDiscovery API is deprecated, and developers are encouraged
to use the new socket-based API.</p>
<p>Darwin programmers should use the socket-based DNSServiceDiscovery
API.</p>
<p>Documentation on all four Bonjour APIs can be found in <span class="content_text"><a href="../../../Bonjour-date.html#//apple_ref/doc/uid/TP30000429-TP30000566" target="_top">Bonjour Documentation </a></span>on the ADC website.</p>
<p>Sample code, links to specifications, and other resources
are available at <span class="content_text"><a href="http://developer.apple.com/networking/bonjour/" target="_top">http://developer.apple.com/networking/bonjour/</a></span><code></code>.</p>
<p>Hardware developers should examine the sample code for an
mDNS responder provided at <span class="content_text"><a href="http://developer.apple.com/darwin" target="_top">http://developer.apple.com/darwin</a></span><code></code>.</p>
<a name="//apple_ref/doc/uid/TP30001129-CH204-198407" title="Bonjour and Domain Names"></a><a name="//apple_ref/doc/uid/TP30001129-CH204-BBCGEJIE" title="Bonjour and Domain Names"></a><h2>Bonjour and Domain Names</h2>
<p>Bonjour names for service instances and
service types are related to Domain Name System (DNS) domain names.
This section explains DNS domain names, the Bonjour local &#8220;domain,&#8221;
and the naming rules for Bonjour service instances and service
types.</p>
<a name="//apple_ref/doc/uid/TP30001129-CH204-198424" title="Domain Names and DNS"></a><a name="//apple_ref/doc/uid/TP30001129-CH204-TPXREF117" title="Domain Names and DNS"></a><h3>Domain Names and DNS</h3>
<p>DNS uses a specific-to-general naming scheme for domain names.
The most general domain is <code>.</code> (&#8220;dot&#8221;),
called the <strong></strong><strong>root domain</strong>, which
is akin to the root directory <code>/</code> in
a UNIX file system. Every other domain falls in a hierarchy below
the root domain. For example, the name <code>www.apple.com.</code> is
within the <strong>second-level domain</strong> <code>apple.com.</code>,
which is within the <strong>top-level domain</strong> <code>com.</code>,
which in turn is part of <code>.</code> (&#8220;dot&#8221;),
the root domain. <span class="content_text">Figure 1-2</span> shows an abridged version of this hierarchy. </p>
<br/><div><a name="//apple_ref/doc/uid/TP30001129-CH204-202753" title="Figure 1-2Part of the Internet Domain Name System, augmented for Bonjour"></a><a name="//apple_ref/doc/uid/TP30001129-CH204-BAJEAEDF" title="Figure 1-2Part of the Internet Domain Name System, augmented for Bonjour"></a><p><strong>Figure 1-2&nbsp;&nbsp;</strong>Part of the Internet Domain Name System,
augmented for Bonjour</p><img src = "../art/names_01dns.gif" alt = "" width="388" height="179"></div><br/>
<p>At the top of the inverted tree is the root domain. Below
it are some of the top-level domains: <code>com.</code>, <code>edu.</code>,
and <code>org.</code>, and the local
Bonjour &#8220;domain&#8221; <code>local.</code>,
discussed further in <span class="content_text"><a href="concepts_mach.html#//apple_ref/doc/uid/TP30001129-CH204-202537">“Bonjour and the Local Link.”</a></span> Below the top level are a few
second-level domains, <code>apple</code>, <code>darwin</code>,
and <code>zeroconf</code>. The tree
can extend infinitely downward with, for example, <code>www</code>,
at the third level.</p>
<p>You may have noticed that the trailing dot is left off of
most domain names. The trailing dot does, however, have meaning.
A domain name ending in a trailing period, such as <code>www.apple.com.</code>,
is known as a <strong>fully qualified domain name</strong>, much
like an absolute path (such as <code>/usr/bin</code>)
in a UNIX file system.</p>
<p>If you type <code>wibble.apple.com</code> into
your Web browser (without the trailing dot), the system will treat
it as an unqualified (partial) name and append the names from your
list of search domains, such as <code>apple.com.</code>, <code>earthlink.net.</code>, <code>myschool.edu</code>.,
etc. The system will first try to append <code>.</code> (&#8220;dot,&#8221;
the root domain), but if the name <code>wibble.apple.com.</code> doesn&#8217;t
exist, it will continue down the list and try <code>wibble.apple.com.apple.com.</code>, <code>wibble.apple.com.earthlink.net.</code>, <code>wibble.apple.com.myschool.edu.</code>,
and so on, which is almost certainly not what you wanted.</p>
<a name="//apple_ref/doc/uid/TP30001129-CH204-202537" title="Bonjour and the Local Link"></a><a name="//apple_ref/doc/uid/TP30001129-CH204-CJBDIAHA" title="Bonjour and the Local Link"></a><h3>Bonjour and the Local Link</h3>
<p>Bonjour protocols deal in large part with the part of the
network called the <strong>local link</strong>. A host&#8217;s local
link, or <strong>link-local network</strong>, includes itself
and all other hosts that can exchange packets without IP header
data being modified. In practice, this includes all hosts not separated
by a router. </p>
<p>On Bonjour systems, <code>local.</code> is
used to indicate a name that should be looked up using an IP multicast
query on the local IP network.</p>
<p>Note that <code>local.</code> is
not really a domain. You can think of <code>local.</code> as
a pseudo-domain. It differs from conventional DNS domains in a fundamental
way: names within other domains are globally unique; link-local
domain names are not. There is only one logical DNS entry in the
world named <code>www.apple.com.</code>,
and because of the way DNS works, there can be only one. Host names
ending in <code>local.</code>, on
the other hand, are managed by a collection of multicast DNS responders
on the local network, so the naming scope is just that: local. There
can easily be two hosts named <code>meow.local.</code> in
the world, or even the same building, just not on the same local
network. </p>
<p>Globally unique names are important and useful&#8212;in fact,
they are one of the significant achievements of the Internet&#8212;but
they require a certain level of administrative effort to set up
and maintain. Local names are useful only on the local network,
but in cases where that is adequate, they provide a way to refer
to network devices using names instead of IP numbers, and of course
they require less effort and expense to coordinate than globally unique
names. </p>
<p>Globally unique names are particularly useful on local networks
that have no connection to the global Internet, either by design
or because of interruption, and on small, temporary networks, such
as a pair of computers linked by a crossover cable, or a few people
playing network games using laptops on the wireless network of a
home or cafe.</p>
<p>If a name collision on the local network occurs, a Bonjour
host finds a new name automatically (in the case of a device without
a screen) or by asking the user (in the case of a personal computer).</p>
<a name="//apple_ref/doc/uid/TP30001129-CH204-198642" title="Bonjour Names for Existing Service Types"></a><a name="//apple_ref/doc/uid/TP30001129-CH204-TPXREF118" title="Bonjour Names for Existing Service Types"></a><h3>Bonjour Names for Existing Service
Types</h3>
<p>Bonjour service types are named according to the existing
Internet standard for IP services. The Internet Assigned Numbers
Authority (IANA) keeps a registry of TCP and UDP protocol names
and ports assigned to each, and Bonjour services are named according
to this list. The list used by Mac OS X can be found in <code>/etc/services</code>,
and the most current version of the list is on the IANA website
at <span class="content_text"><a href="http://www.iana.org/assignments/port-numbers" target="_blank">http://www.iana.org/assignments/port-numbers</a></span>.</p>
<p>In order to distinguish services from domain names in DNS
resource records, components of service type names include underscore
prefixes. The format for Bonjour service type names is thus</p>
<p><code>_</code><em>ApplicationProtocolName</em><code>._</code><em>TransportProtocolName</em><code>.</code></p>
<p>The application protocol name is the official IANA-registered
name for the protocol, for example, <code>ftp</code>, <code>http</code> or <code>printer</code>,
as described above. The transport protocol name is either <code>tcp</code> or <code>udp</code>,
depending on the transport protocol the service uses. An FTP service
running over TCP would have a service type of <code>_ftp._tcp</code>.
Services of this type would register DNS PTR records named <code>_ftp._tcp.local.</code> with
their hosts&#8217; multicast DNS responders.</p>
<a name="//apple_ref/doc/uid/TP30001129-CH204-198719" title="Bonjour Names for New Service Types"></a><a name="//apple_ref/doc/uid/TP30001129-CH204-TPXREF119" title="Bonjour Names for New Service Types"></a><h3>Bonjour Names for New Service Types</h3>
<p>If you are designing a new protocol to advertise as a Bonjour
network service, you should register it with IANA at <span class="content_text"><a href="http://www.iana.org" target="_blank">http://www.iana.org</a></span> or <span class="content_text"><a href="http://www.dns-sd.org/ServiceNames.html" target="_blank">http://www.dns-sd.org/ServiceNames.html</a></span>.</p>
<p>The IANA currently requires that every registered service
be associated with a &#8220;well-known port&#8221; or range of well-known
ports. For example, <code>http</code> is
assigned port <code>80</code>, so that
whenever you visit a website in your web browser, the application
assumes that the HTTP service is running on port <code>80</code> unless
you specify otherwise. This way, the port number for a website need
only be memorized if the website is configured in a non-standard
way.</p>
<p>With Bonjour, however, you don&#8217;t have to know about port
numbers. Because client applications can discover your service with
a simple query for the service type, well-known ports are unnecessary.
At some point in the future, IANA may begin registering protocol
names without requiring an associated well-known port.</p>
<a name="//apple_ref/doc/uid/TP30001129-CH204-198759" title="Bonjour Names for Service Instances"></a><a name="//apple_ref/doc/uid/TP30001129-CH204-TPXREF120" title="Bonjour Names for Service Instances"></a><h3>Bonjour Names for Service Instances</h3>
<p>Service instance names are intended to be human-readable strings.
As such, you should name them descriptively, and let the user override
whatever default name you provide. Because they are intended to
be browsed rather than typed, service instance names can be any
Unicode string encoded with UTF-8, up to 63 octets (bytes) in length.</p>
<p>For example, an application for sharing music over the network
might use the local user&#8217;s name for a music sharing service, such
as <code>Ed's Music Library</code>,
by default. The user could override the default and name the service <code>Zealous
Lizard's Tune Studio</code>, and the application
would register a DNS SRV record named
<code>Zealous Lizard's Tune Studio._music._tcp.local.</code>,
assuming the application&#8217;s music sharing protocol was associated
with the name <code>music</code>.</p>
<p><span class="content_text"><a href="concepts_mach.html#//apple_ref/doc/uid/TP30001129-CH204-198818">Figure 1-3</a></span> illustrates the organization of the name of a Bonjour
service instance. At the top level of the tree is the domain, such
as <code>local.</code> for the local
network. Below the domain is the service type, which consists of
the protocol name preceded by an underscore (<code>_music</code>) and
the transport protocol, also preceded by an underscore (<code>_tcp</code>).
At the bottom of the tree is the human-readable service instance
name, such as <code>Zealous Lizard&#8217;s Tune Studio</code>.
The complete name is a path along the tree from bottom to top, with
each component separated by a dot.</p>
<br/><div><a name="//apple_ref/doc/uid/TP30001129-CH204-198818" title="Figure 1-3Organization of a Bonjour service name"></a><a name="//apple_ref/doc/uid/TP30001129-CH204-CJBGIICF" title="Figure 1-3Organization of a Bonjour service name"></a><p><strong>Figure 1-3&nbsp;&nbsp;</strong>Organization of a Bonjour service
name</p><img src = "../art/names_02services.gif" alt = "" width="412" height="316"></div><br/>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../introduction/intro_mach.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../tasks/tasks_mach.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2001, 2005 Apple Computer, Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2005-04-29<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Networking/Conceptual/dns_discovery_mach/concepts/concepts_mach.html%3Fid%3DTP30001129-3.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Networking/Conceptual/dns_discovery_mach/concepts/concepts_mach.html%3Fid%3DTP30001129-3.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Networking/Conceptual/dns_discovery_mach/concepts/concepts_mach.html%3Fid%3DTP30001129-3.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>