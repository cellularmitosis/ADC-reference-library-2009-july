<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>ClosedCaptionImporter - /EatClosedCaptionSCC.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/QuickTime/index.html">QuickTime</a> &gt; <a href="../../samplecode/QuickTime/idxImportExport-date.html">Import & Export</a> &gt; <A HREF="javascript:location.replace('index.html');">ClosedCaptionImporter</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->


	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">ClosedCaptionImporter</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/EatClosedCaptionSCC.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/EatClosedCaption.c</option>
<option value="listing2.html">/EatClosedCaption.h</option>
<option value="listing3.html">/EatClosedCaption.r</option>
<option value="listing4.html">/EatClosedCaptionDispatch.h</option>
<option value="listing5.html">/EatClosedCaptionSCC.c</option>
<option value="listing6.html">/EatClosedCaptionSCC.h</option>
<option value="listing7.html">/EatClosedCaptionVersion.h</option></select>
				</p>
				</form>
				<p><strong><a href="ClosedCaptionImporter.zip">Download Sample</a></strong> (&#147;ClosedCaptionImporter.zip&#148;, 43.8K)<BR>
<strong><a href="ClosedCaptionImporter.dmg">Download Sample</a></strong> (&#147;ClosedCaptionImporter.dmg&#148;, 90.6K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*File: EatClosedCaptionSCC.cAbstract: Code to read and parse a Scenarist Closed Caption (SCC)          file into a QuickTime Movie Version: 1.0Disclaimer: IMPORTANT:  This Apple software is supplied to you by Apple Inc. (&quot;Apple&quot;) in consideration of your agreement to thefollowing terms, and your use, installation, modification orredistribution of this Apple software constitutes acceptance of theseterms.  If you do not agree with these terms, please do not use,install, modify or redistribute this Apple software.In consideration of your agreement to abide by the following terms, andsubject to these terms, Apple grants you a personal, non-exclusivelicense, under Apple's copyrights in this original Apple software (the&quot;Apple Software&quot;), to use, reproduce, modify and redistribute the AppleSoftware, with or without modifications, in source and/or binary forms;provided that if you redistribute the Apple Software in its entirety andwithout modifications, you must retain this notice and the followingtext and disclaimers in all such redistributions of the Apple Software. Neither the name, trademarks, service marks or logos of Apple Inc. may be used to endorse or promote products derived from the AppleSoftware without specific prior written permission from Apple.  Exceptas expressly stated in this notice, no other rights or licenses, expressor implied, are granted by Apple herein, including but not limited toany patent rights that may be infringed by your derivative works or byother works in which the Apple Software may be incorporated.The Apple Software is provided by Apple on an &quot;AS IS&quot; basis.  APPLEMAKES NO WARRANTIES, EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATIONTHE IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY AND FITNESSFOR A PARTICULAR PURPOSE, REGARDING THE APPLE SOFTWARE OR ITS USE ANDOPERATION ALONE OR IN COMBINATION WITH YOUR PRODUCTS.IN NO EVENT SHALL APPLE BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTALOR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OFSUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESSINTERRUPTION) ARISING IN ANY WAY OUT OF THE USE, REPRODUCTION,MODIFICATION AND/OR DISTRIBUTION OF THE APPLE SOFTWARE, HOWEVER CAUSEDAND WHETHER UNDER THEORY OF CONTRACT, TORT (INCLUDING NEGLIGENCE),STRICT LIABILITY OR OTHERWISE, EVEN IF APPLE HAS BEEN ADVISED OF THEPOSSIBILITY OF SUCH DAMAGE.Copyright (C) 2007 Apple Inc. All Rights Reserved.*/#include &quot;EatClosedCaptionSCC.h&quot;#ifdef MIN  #undef MIN#endif#define MIN(x,y) ((x) &lt; (y) ? (x) : (y))#ifdef MAX  #undef MAX#endif#define MAX(x,y) ((x) &gt; (y) ? (x) : (y))#pragma mark- Declarations// Utility RoutinesComponentResult ParseByte(const char *string, UInt8 *byte, Boolean hex);#pragma mark-#pragma mark- Scenarist Closed Caption Functions// Initialization routine that sets up globalsComponentResult ScenaristClosedCaptionParserInit(EatClosedCaptionGlobals store){  EatScenaristClosedCaptionGlobals globals = NULL;  ComponentResult err = noErr;  store-&gt;parserGlobals = globals = (EatScenaristClosedCaptionGlobals)NewPtrClear(sizeof(EatScenaristClosedCaptionGlobalsRecord));  require_action(store-&gt;parserGlobals, bail, err = memFullErr);  globals-&gt;ccGlobals = store;    globals-&gt;firstSampleDecoded = false;  globals-&gt;firstSampleMediaTime = -1;  globals-&gt;timeCodeDef.flags = 0;  globals-&gt;timeCodeDef.fTimeScale = 30000;  globals-&gt;timeCodeDef.frameDuration = 1001;  globals-&gt;timeCodeDef.numFrames = 30;    globals-&gt;sampleDesc = (SampleDescriptionHandle)NewHandleClear(sizeof(SampleDescription));  require_action(globals-&gt;sampleDesc, bail, err = memFullErr);  globals-&gt;sampleData = NewHandle(0);  require_action(globals-&gt;sampleData, bail, err = memFullErr);    // Compile our regular expressions  require_action(regcomp(&amp;globals-&gt;lineRegEx, kSCCLineRegEx, REG_EXTENDED | REG_NEWLINE) == 0, bail, err = memFullErr);  require_action(regcomp(&amp;globals-&gt;emptyRegEx, kSCCEmptyRegEx, REG_EXTENDED | REG_NEWLINE) == 0, bail, err = memFullErr);  require_action(regcomp(&amp;globals-&gt;headerRegEx, kSCCHeaderRegEx, REG_EXTENDED | REG_NEWLINE) == 0, bail, err = memFullErr);  require_action(regcomp(&amp;globals-&gt;sampleRegEx, kSCCSampleRegEx, REG_EXTENDED | REG_NEWLINE) == 0, bail, err = memFullErr);  // Allocate enough space to hold the maximum number of regmatch_t entries that any of our regular expressions might generate  globals-&gt;regExMatches = (regmatch_t*)calloc(1 + MAX(1, MAX(MAX(globals-&gt;lineRegEx.re_nsub, globals-&gt;emptyRegEx.re_nsub),                    MAX(globals-&gt;headerRegEx.re_nsub, globals-&gt;sampleRegEx.re_nsub))), sizeof(regmatch_t));  require_action(globals-&gt;regExMatches, bail, err = memFullErr);  bail:  // Clean up  if (err != noErr)    ScenaristClosedCaptionParserTerminate(store);    return err;}// Clean-up routinevoid ScenaristClosedCaptionParserTerminate(EatClosedCaptionGlobals store){  if (store)  {    EatScenaristClosedCaptionGlobals globals = (EatScenaristClosedCaptionGlobals)store-&gt;parserGlobals;    // Clean up    if (globals)    {      DisposeHandle((Handle)globals-&gt;sampleDesc);      DisposeHandle(globals-&gt;sampleData);            regfree(&amp;globals-&gt;lineRegEx);      regfree(&amp;globals-&gt;emptyRegEx);      regfree(&amp;globals-&gt;headerRegEx);      regfree(&amp;globals-&gt;sampleRegEx);      free(globals-&gt;regExMatches);            DisposePtr(store-&gt;parserGlobals); store-&gt;parserGlobals = NULL;    }        if (store-&gt;editingClosedCaption)    {      EndMediaEdits(store-&gt;closedCaptionMedia);      store-&gt;editingClosedCaption = false;    }    if (store-&gt;editingTimeCode)    {      EndMediaEdits(store-&gt;timeCodeMedia);      store-&gt;editingTimeCode = false;    }  }}ComponentResult ScenaristClosedCaptionParserDoParse(EatClosedCaptionGlobals store, TimeValue atTime, TimeValue *durationAdded){  EatScenaristClosedCaptionGlobals globals = (EatScenaristClosedCaptionGlobals)store-&gt;parserGlobals;  ComponentResult err = noErr;  Boolean openedForRead = false;  int reResult = 0;  long dataSize = 0, dataOffset = 0;  long bufferSize = 0, bufferUsed = 0, bufferOffset = 0;  Ptr buffer = NULL;  Boolean headerParsed = false;    // Prepare for reading  require_noerr(err = DataHOpenForRead(store-&gt;dataHandler), bail);  openedForRead = true;  // Get the data size  require_noerr(err = DataHGetFileSize(store-&gt;dataHandler, &amp;dataSize), bail);    // Allocate a buffer to read into  bufferSize = 512;  buffer = malloc(bufferSize);  require_action(buffer, bail, err = memFullErr);    // Parse the data  while (dataOffset &lt; dataSize)  {    // Some useful bookkeeping    long bufferAvailable = bufferSize - bufferUsed;    long dataAvailable = dataSize - dataOffset;    long bytesToRead = 0;    // See if we need to increase our buffer size    if (bufferAvailable &lt;= 0)    {      Ptr newBuffer = NULL;            bufferSize *= 2;      newBuffer = realloc(buffer, bufferSize);      require_action(newBuffer, bail, err = memFullErr);      buffer = newBuffer;      bufferAvailable = bufferSize - bufferUsed;    }        // Read some data    bytesToRead = MIN(bufferAvailable, dataAvailable);    require_noerr(err = DataHScheduleData(store-&gt;dataHandler, buffer + bufferUsed, dataOffset, bytesToRead, 0, NULL, NULL), bail);    bufferUsed += bytesToRead;    bufferAvailable -= bytesToRead;    dataOffset += bytesToRead;    dataAvailable -= bytesToRead;        // See if there's enough data to read in one or more lines of caption data    globals-&gt;regExMatches[0].rm_so = bufferOffset;    globals-&gt;regExMatches[0].rm_eo = bufferUsed;    while (regexec(&amp;globals-&gt;lineRegEx, buffer, globals-&gt;lineRegEx.re_nsub + 1, globals-&gt;regExMatches, REG_NOTEOL | REG_STARTEND) == 0)    {      globals-&gt;lastMatchString = buffer;      bufferOffset = globals-&gt;regExMatches[0].rm_eo + 1;            // regexec can't seem to get around cr/lf pairs, so we have to skip the cr if present      if (bufferOffset &lt; bufferSize &amp;&amp; *(char*)(buffer + bufferOffset) == '\r')        ++bufferOffset;      // Read past the header line if we haven't already done so      if (!headerParsed)      {        require_action((reResult = regexec(&amp;globals-&gt;headerRegEx, buffer, globals-&gt;headerRegEx.re_nsub + 1, globals-&gt;regExMatches, REG_STARTEND)) == 0, bail, err = paramErr);        globals-&gt;lastMatchString = buffer;                // Found a valid header        headerParsed = true;      }      else      {        // Skip empty lines and decode caption lines        regoff_t lineStart = globals-&gt;regExMatches[0].rm_so;        regoff_t lineEnd = globals-&gt;regExMatches[0].rm_eo;        if ((reResult = regexec(&amp;globals-&gt;emptyRegEx, buffer, globals-&gt;emptyRegEx.re_nsub + 1, globals-&gt;regExMatches, REG_STARTEND)) == REG_NOMATCH ||          (globals-&gt;regExMatches[0].rm_so != lineStart || globals-&gt;regExMatches[0].rm_eo != lineEnd))        {          globals-&gt;lastMatchString = buffer;          globals-&gt;regExMatches[0].rm_so = lineStart;          globals-&gt;regExMatches[0].rm_eo = lineEnd;          reResult = regexec(&amp;globals-&gt;sampleRegEx, buffer, globals-&gt;sampleRegEx.re_nsub + 1, globals-&gt;regExMatches, REG_STARTEND);          globals-&gt;lastMatchString = buffer;          require_action(reResult == 0, bail, err = paramErr);                    // Found a valid line of sample data... decode it          require_noerr(err = ScenaristClosedCaptionParserDecodeSample(store), bail);        }      }            globals-&gt;regExMatches[0].rm_so = bufferOffset;      globals-&gt;regExMatches[0].rm_eo = bufferUsed;    }        bufferUsed = bufferUsed - bufferOffset;        if (bufferUsed)      memmove(buffer, buffer + bufferOffset, bufferUsed);        bufferOffset = 0;    bufferAvailable = bufferSize - bufferUsed;  }    // Make sure we used it all up  if (dataSize != dataOffset || bufferUsed &gt; 0)    require_noerr(err = paramErr, bail);    // Write out the last sample and the timecode  if (err == noErr &amp;&amp; globals-&gt;firstSampleDecoded)  {    require_noerr(err = ScenaristClosedCaptionParserAddSample(store, -1, true), bail);    require_noerr(err = ScenaristClosedCaptionParserAddTimeCode(store), bail);  }  bail:  // Done reading  if (openedForRead)    DataHCloseForRead(store-&gt;dataHandler);    // Clean up  free(buffer);    return err;}// Decode a caption read from the source data refComponentResult ScenaristClosedCaptionParserDecodeSample(EatClosedCaptionGlobals store){  EatScenaristClosedCaptionGlobals globals = (EatScenaristClosedCaptionGlobals)store-&gt;parserGlobals;  // The need for error checking in this function is minimal, as we would not have made it this far without a regular  //  expression match, whick already validates the data string  ComponentResult err = noErr;  size_t atomHeaderSize = sizeof(long) + sizeof(OSType);  // Timecode  {    TimeCodeRecord newSampleTimeCode = { 0 };    // The entire file must be either drop frame or non-drop frame... no mix and match    if (!globals-&gt;firstSampleDecoded &amp;&amp; globals-&gt;lastMatchString[globals-&gt;regExMatches[kSCCSampleMatchTCDropFrame].rm_so] == ';')      globals-&gt;timeCodeDef.flags |= tcDropFrame;    else      require_action((globals-&gt;timeCodeDef.flags &amp; tcDropFrame == tcDropFrame) == (globals-&gt;lastMatchString[globals-&gt;regExMatches[kSCCSampleMatchTCDropFrame].rm_so] == ';'), bail, err = paramErr);        // Parse all of the timecode fields    ParseByte(globals-&gt;lastMatchString + globals-&gt;regExMatches[kSCCSampleMatchTCHours].rm_so, &amp;newSampleTimeCode.t.hours, false);    ParseByte(globals-&gt;lastMatchString + globals-&gt;regExMatches[kSCCSampleMatchTCMinutes].rm_so, &amp;newSampleTimeCode.t.minutes, false);    ParseByte(globals-&gt;lastMatchString + globals-&gt;regExMatches[kSCCSampleMatchTCSeconds].rm_so, &amp;newSampleTimeCode.t.seconds, false);    ParseByte(globals-&gt;lastMatchString + globals-&gt;regExMatches[kSCCSampleMatchTCFrames].rm_so, &amp;newSampleTimeCode.t.frames, false);        if (globals-&gt;firstSampleDecoded)    {      // Once we've decoded more than one sample, we can calculate the duration of the previous sample      long prevSampleFrameNumber = 0, sampleFrameNumber = 0, sampleSize = 0;      require_noerr(err = TCTimeCodeToFrameNumber(GetMediaHandler(store-&gt;timeCodeMedia), &amp;globals-&gt;timeCodeDef, &amp;globals-&gt;sampleTimeCode, &amp;prevSampleFrameNumber), bail);      require_noerr(err = TCTimeCodeToFrameNumber(GetMediaHandler(store-&gt;timeCodeMedia), &amp;globals-&gt;timeCodeDef, &amp;newSampleTimeCode, &amp;sampleFrameNumber), bail);      sampleSize = GetHandleSize(globals-&gt;sampleData) - atomHeaderSize;      if (sampleSize &gt; (sampleFrameNumber - prevSampleFrameNumber) * 2)      {        // Timecode of current sample overlaps previous sample        require_noerr(err = paramErr, bail);      }      // Add the previous sample using the duration we calculated above      require_noerr(err = ScenaristClosedCaptionParserAddSample(store, (sampleFrameNumber - prevSampleFrameNumber) * 1001, false), bail);    }    else    {      // Save off the first timecode that was encountered      globals-&gt;firstSampleTimeCode = newSampleTimeCode;    }        // Save off the current timecode for use in calculating the duration of this sample next time around    globals-&gt;sampleTimeCode = newSampleTimeCode;  }    // Closed caption  {    const char *sampleString = NULL;    UInt8 *sampleData = NULL;    size_t ndx = 0;    // The sample data string is made up of exactly one substring corresponding to the regular expression match &quot;kSCCSampleMatchLastSampleData&quot; and    //  zero or more substrings corresponding to the regular expression match &quot;kSCCSampleSecondLastSampleData&quot;.  Each of these matches represents    //  two bytes of sample data, so we can calculate the necessary size of our sample buffer    size_t sampleStringLength = globals-&gt;regExMatches[kSCCSampleMatchAllSampleData].rm_eo - globals-&gt;regExMatches[kSCCSampleMatchAllSampleData].rm_so;    size_t lastMatchLength = globals-&gt;regExMatches[kSCCSampleMatchLastSampleData].rm_eo - globals-&gt;regExMatches[kSCCSampleMatchLastSampleData].rm_so;    size_t otherMatchLength = globals-&gt;regExMatches[kSCCSampleMatchSecondLastSampleData].rm_eo - globals-&gt;regExMatches[kSCCSampleMatchSecondLastSampleData].rm_so;    size_t numSampleBytes =  2 * (1 + ((sampleStringLength - lastMatchLength) / (otherMatchLength ? otherMatchLength : 1)));        // Make the sample data handle big enough to hold all of the data plus an atom header    SetHandleSize(globals-&gt;sampleData, atomHeaderSize + numSampleBytes);    sampleString = globals-&gt;lastMatchString + globals-&gt;regExMatches[kSCCSampleMatchAllSampleData].rm_so;    HLock(globals-&gt;sampleData);    sampleData = (UInt8*)*globals-&gt;sampleData;        // Write out the size of the atom    *(long*)sampleData = EndianS32_NtoB(atomHeaderSize + numSampleBytes);    sampleData += sizeof(long);        // Write out the atom type    *(OSType*)sampleData = EndianU32_NtoB('cdat');    sampleData += sizeof(OSType);    // Parse and write the sample data    for (ndx = 0; ndx &lt; numSampleBytes / 2; ndx++)    {      ParseByte(sampleString, (UInt8*)sampleData, true);      ParseByte(sampleString + 2, (UInt8*)sampleData + 1, true);      sampleString += otherMatchLength;      sampleData += 2;    }    HUnlock(globals-&gt;sampleData);  }    // We've decoded a sample  globals-&gt;firstSampleDecoded = true;bail:    return err;}// Add a decoded sample to the MovieComponentResult ScenaristClosedCaptionParserAddSample(EatClosedCaptionGlobals store, TimeValue duration, Boolean lastSample){  EatScenaristClosedCaptionGlobals globals = (EatScenaristClosedCaptionGlobals)store-&gt;parserGlobals;  ComponentResult err = noErr;  TimeRecord sampleDuration = { 0 };    // Setup on the first call  if (!store-&gt;editingClosedCaption)  {    require_noerr(err = BeginMediaEdits(store-&gt;closedCaptionMedia), bail);    store-&gt;editingClosedCaption = true;                (*globals-&gt;sampleDesc)-&gt;descSize = GetHandleSize((Handle)globals-&gt;sampleDesc);    (*globals-&gt;sampleDesc)-&gt;dataFormat = 'c608';    (*globals-&gt;sampleDesc)-&gt;resvd1 = 0;    (*globals-&gt;sampleDesc)-&gt;resvd2 = 0;  }  // Add the caption sample to the media  sampleDuration.base = NULL;  sampleDuration.scale = 30000;  sampleDuration.value.lo = duration &gt;= 0 ? duration : GetHandleSize(globals-&gt;sampleData) / 2 * 1001;  ConvertTimeScale(&amp;sampleDuration, GetMediaTimeScale(store-&gt;closedCaptionMedia));  HLock(globals-&gt;sampleData);  require_noerr(err = AddMediaSample2(store-&gt;closedCaptionMedia, (UInt8*)*(globals-&gt;sampleData), GetHandleSize(globals-&gt;sampleData), sampleDuration.value.lo, 0,                      globals-&gt;sampleDesc, 1, 0, globals-&gt;firstSampleMediaTime &lt; 0 ? &amp;globals-&gt;firstSampleMediaTime : NULL), bail);  HUnlock(globals-&gt;sampleData);    // Teardown on last call  if (lastSample)  {    TimeRecord  captionTrackStart = { 0 };    TimeValue  captionInsertDuration = 0;    require_noerr(err = EndMediaEdits(store-&gt;closedCaptionMedia), bail);    store-&gt;editingClosedCaption = false;    // Insert the media into the track    captionInsertDuration = GetMediaDuration(store-&gt;closedCaptionMedia) - globals-&gt;firstSampleMediaTime;    if (captionInsertDuration &gt; 0)      require_noerr(err = InsertMediaIntoTrack(store-&gt;closedCaptionTrack, captionTrackStart.value.lo, globals-&gt;firstSampleMediaTime, captionInsertDuration, fixed1), bail);  }bail:  if (err)  {    if (store-&gt;editingClosedCaption)    {      EndMediaEdits(store-&gt;closedCaptionMedia);      store-&gt;editingClosedCaption = false;    }  }    return err;}// Add timecode to the MovieComponentResult ScenaristClosedCaptionParserAddTimeCode(EatClosedCaptionGlobals store){  EatScenaristClosedCaptionGlobals globals = (EatScenaristClosedCaptionGlobals)store-&gt;parserGlobals;  ComponentResult err = noErr;  TimeCodeDescriptionHandle timeCodeDesc = NULL;  if (store-&gt;timeCodeTrack)  {    long firstFrameNumber = 0;    long sampleFrameNumber = 0;    long sampleFrames = 0;    TimeValue64 duration = 0;    long sampleData = 0;        require_noerr(err = BeginMediaEdits(store-&gt;timeCodeMedia), bail);    // Use the saved timecode values from the first and last captions (adding the duration of the last sample as well)    TCTimeCodeToFrameNumber(GetMediaHandler(store-&gt;timeCodeMedia), &amp;globals-&gt;timeCodeDef, &amp;globals-&gt;firstSampleTimeCode, &amp;firstFrameNumber);    TCTimeCodeToFrameNumber(GetMediaHandler(store-&gt;timeCodeMedia), &amp;globals-&gt;timeCodeDef, &amp;globals-&gt;sampleTimeCode, &amp;sampleFrameNumber);    sampleFrames = GetHandleSize(globals-&gt;sampleData) / 2;        duration = (sampleFrameNumber - firstFrameNumber + sampleFrames) * 1001;        timeCodeDesc = (TimeCodeDescriptionHandle)NewHandleClear(sizeof(TimeCodeDescription));    HLock((Handle)timeCodeDesc);    (*timeCodeDesc)-&gt;descSize = GetHandleSize((Handle)timeCodeDesc);    (*timeCodeDesc)-&gt;dataFormat = TimeCodeMediaType;    (*timeCodeDesc)-&gt;timeCodeDef = globals-&gt;timeCodeDef;        sampleData = EndianS32_NtoB(firstFrameNumber);    require_noerr(err = AddMediaSample2(store-&gt;timeCodeMedia, (UInt8*)&amp;sampleData, sizeof(sampleData), duration, 0,                      (SampleDescriptionHandle)timeCodeDesc, 1, 0, NULL), bail);        HUnlock((Handle)timeCodeDesc);        // Teardown    {      TimeRecord  timeCodeTrackStart = { 0 };      TimeValue  timeCodeInsertDuration = GetMediaDuration(store-&gt;timeCodeMedia);            // End editing and add media to the track      timeCodeTrackStart.value.lo = 0;      timeCodeTrackStart.scale = GetMediaTimeScale(store-&gt;timeCodeMedia);      timeCodeTrackStart.base = NULL;            require_noerr(err = EndMediaEdits(store-&gt;timeCodeMedia), bail);      if (timeCodeInsertDuration &gt; 0)        require_noerr(err = InsertMediaIntoTrack(store-&gt;timeCodeTrack, timeCodeTrackStart.value.lo, 0, timeCodeInsertDuration, fixed1), bail);    }  }bail:  if (timeCodeDesc);    DisposeHandle((Handle)timeCodeDesc);  return err;}// Utility routine for parsing numerical stringsComponentResult ParseByte(const char *string, UInt8 *byte, Boolean hex){  ComponentResult err = paramErr;  char chars[2];  if (sscanf(string, &quot;%2c&quot;, chars) == 1)  {    chars[0] = (char)tolower(chars[0]);    chars[1] = (char)tolower(chars[1]);    if (((chars[0] &gt;= '0' &amp;&amp; chars[0] &lt;= '9') || (hex &amp;&amp; (chars[0] &gt;= 'a' &amp;&amp; chars[0] &lt;= 'f'))) &amp;&amp;      ((chars[1] &gt;= '0' &amp;&amp; chars[1] &lt;= '9') || (hex &amp;&amp; (chars[1] &gt;= 'a' &amp;&amp; chars[1] &lt;= 'f'))))    {      *byte = 0;      if (chars[0] &gt;= '0' &amp;&amp; chars[0] &lt;= '9')        *byte = (chars[0] - '0') * (hex ? 16 : 10);      else if (chars[0] &gt;= 'a' &amp;&amp; chars[0] &lt;= 'f')        *byte = (chars[0] - 'a' + 10) * 16;            if (chars[1] &gt;= '0' &amp;&amp; chars[1] &lt;= '9')        *byte += (chars[1] - '0');      else if (chars[1] &gt;= 'a' &amp;&amp; chars[1] &lt;= 'f')        *byte += (chars[1] - 'a' + 10);            err = noErr;    }  }    return err;}</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/ClosedCaptionImporter/listing5.html%3Fid%3DDTS10004354-1.3&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/ClosedCaptionImporter/listing5.html%3Fid%3DDTS10004354-1.3&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/ClosedCaptionImporter/listing5.html%3Fid%3DDTS10004354-1.3&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>