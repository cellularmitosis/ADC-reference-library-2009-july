<html><head><title>Mac OS X
 Manual Page For pcap_setnonblock(3)</title>
<style type="text/css"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { font-size: 1px; background: #ffffff; color: #ffffff; } --></style>
<style type="text/css" media="print, aural, braille, embossed, projection, tty"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { display: none; } --></style>
</head><body bgcolor="white">
<a name="//apple_ref/doc/man/3/pcap_setnonblock" title="Mac OS X
 Manual Page for pcap_setnonblock(3)"><!-- headerDoc=man; indexgroup=Section 3; uid="//apple_ref/doc/man/3/pcap_setnonblock"; name=pcap_setnonblock(3) --></a>
<!--#include virtual="/includes/framesetheader"-->
<table width=600><tr><td scope="row">
<!-- begin breadcrumb insert request --><font face="Geneva,Helvetica,Arial" size="1">
 <a target="_top" href="http://developer.apple.com">ADC Home</a> <b>&gt;</b> <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> <b>&gt;</b> <a href="../../../../../reference/index.html#//apple_ref/doc/uid/TP30001281" target="_top">Reference</a> <b>&gt;</b> <!-- a href="" target="_top" -->Mac OS X<!-- /a --> <b>&gt;</b> <a href="../index.html#//apple_ref/doc/framework/manpages" target="_top">Mac OS X Man Pages</a></font>
<!-- end breadcrumb insert request -->
<p>&nbsp;</p>
</td></tr></table>
<!-- end of header -->
<table border="0"  cellpadding="2" cellspacing="2" width="630pt"><tr><td valign="top" height="12" colspan="5" scope="row">
<p style='text-align:justify;'>This document is a Mac OS X manual page.  Manual pages are a command-line technology
for providing documentation.  You can view these manual pages locally using the
<a href="../man1/man.1.html#//apple_ref/doc/man/1/man">man(1)</a> command.
These manual pages come from many different sources, and thus, have a variety of writing
styles.</p>
<p style='text-align:justify;'>For more information about the manual page format, see the manual page for 
<a href="../man5/manpages.5.html#//apple_ref/doc/man/5/manpages">manpages(5)</a>.</p>
</td></tr></table>
<hr />
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row"><pre class="manpages"><tt>
PCAP(3)                                                                                              <!-- a -->PCAP(3)<!-- /a -->



<b>NAME</b>
       pcap - Packet Capture library

<b>SYNOPSIS</b>
       <b>#include</b> <b>&lt;pcap.h&gt;</b>

       <b>char</b> <b>errbuf[PCAP_ERRBUF_SIZE];</b>

       <b>pcap_t</b> <b>*pcap_open_live(const</b> <b>char</b> <b>*device,</b> <b>int</b> <b>snaplen,</b>
               <b>int</b> <b>promisc,</b> <b>int</b> <b>to_ms,</b> <b>char</b> <b>*errbuf)</b>
       <b>pcap_t</b> <b>*pcap_open_dead(int</b> <b>linktype,</b> <b>int</b> <b>snaplen)</b>
       <b>pcap_t</b> <b>*pcap_open_offline(const</b> <b>char</b> <b>*fname,</b> <b>char</b> <b>*errbuf)</b>
       <b>pcap_t</b> <b>*pcap_fopen_offline(FILE</b> <b>*fp,</b> <b>char</b> <b>*errbuf)</b>
       <b>pcap_dumper_t</b> <b>*pcap_dump_open(pcap_t</b> <b>*p,</b> <b>const</b> <b>char</b> <b>*fname)</b>
       <b>pcap_dumper_t</b> <b>*pcap_dump_fopen(pcap_t</b> <b>*p,</b> <b>FILE</b> <b>*fp)</b>

       <b>int</b> <b>pcap_setnonblock(pcap_t</b> <b>*p,</b> <b>int</b> <b>nonblock,</b> <b>char</b> <b>*errbuf);</b>
       <b>int</b> <b>pcap_getnonblock(pcap_t</b> <b>*p,</b> <b>char</b> <b>*errbuf);</b>

       <b>int</b> <b>pcap_findalldevs(pcap_if_t</b> <b>**alldevsp,</b> <b>char</b> <b>*errbuf)</b>
       <b>void</b> <b>pcap_freealldevs(pcap_if_t</b> <b>*alldevs)</b>
       <b>char</b> <b>*pcap_lookupdev(char</b> <b>*errbuf)</b>
       <b>int</b> <b>pcap_lookupnet(const</b> <b>char</b> <b>*device,</b> <b>bpf_u_int32</b> <b>*netp,</b>
               <b>bpf_u_int32</b> <b>*maskp,</b> <b>char</b> <b>*errbuf)</b>

       <b>typedef</b> <b>void</b> <b>(*pcap_handler)(u_char</b> <b>*user,</b> <b>const</b> <b>struct</b> <b>pcap_pkthdr</b> <b>*h,</b>
                                   <b>const</b> <b>u_char</b> <b>*bytes);</b>
       <b>int</b> <b>pcap_dispatch(pcap_t</b> <b>*p,</b> <b>int</b> <b>cnt,</b>
               <b>pcap_handler</b> <b>callback,</b> <b>u_char</b> <b>*user)</b>
       <b>int</b> <b>pcap_loop(pcap_t</b> <b>*p,</b> <b>int</b> <b>cnt,</b>
               <b>pcap_handler</b> <b>callback,</b> <b>u_char</b> <b>*user)</b>
       <b>void</b> <b>pcap_dump(u_char</b> <b>*user,</b> <b>struct</b> <b>pcap_pkthdr</b> <b>*h,</b>
               <b>u_char</b> <b>*sp)</b>

       <b>int</b> <b>pcap_compile(pcap_t</b> <b>*p,</b> <b>struct</b> <b>bpf_program</b> <b>*fp,</b>
               <b>char</b> <b>*str,</b> <b>int</b> <b>optimize,</b> <b>bpf_u_int32</b> <b>netmask)</b>
       <b>int</b> <b>pcap_setfilter(pcap_t</b> <b>*p,</b> <b>struct</b> <b>bpf_program</b> <b>*fp)</b>
       <b>void</b> <b>pcap_freecode(struct</b> <b>bpf_program</b> <b>*)</b>
       <b>int</b> <b>pcap_setdirection(pcap_t</b> <b>*p,</b> <b>pcap_direction_t</b> <b>d)</b>

       <b>const</b> <b>u_char</b> <b>*pcap_next(pcap_t</b> <b>*p,</b> <b>struct</b> <b>pcap_pkthdr</b> <b>*h)</b>
       <b>int</b> <b>pcap_next_ex(pcap_t</b> <b>*p,</b> <b>struct</b> <b>pcap_pkthdr</b> <b>**pkt_header,</b>
               <b>const</b> <b>u_char</b> <b>**pkt_data)</b>

       <b>void</b> <b>pcap_breakloop(pcap_t</b> <b>*)</b>

       <b>int</b> <b>pcap_inject(pcap_t</b> <b>*p,</b> <b>const</b> <b>void</b> <b>*buf,</b> <b>size_t</b> <b>size)</b>
       <b>int</b> <b>pcap_sendpacket(pcap_t</b> <b>*p,</b> <b>const</b> <b>u_char</b> <b>*buf,</b> <b>int</b> <b>size)</b>

       <b>int</b> <b>pcap_datalink(pcap_t</b> <b>*p)</b>
       <b>int</b> <b>pcap_list_datalinks(pcap_t</b> <b>*p,</b> <b>int</b> <b>**dlt_buf);</b>
       <b>int</b> <b>pcap_set_datalink(pcap_t</b> <b>*p,</b> <b>int</b> <b>dlt);</b>
       <b>int</b> <b>pcap_datalink_name_to_val(const</b> <b>char</b> <b>*name);</b>
       <b>const</b> <b>char</b> <b>*pcap_datalink_val_to_name(int</b> <b>dlt);</b>
       <b>const</b> <b>char</b> <b>*pcap_datalink_val_to_description(int</b> <b>dlt);</b>
       <b>int</b> <b>pcap_snapshot(pcap_t</b> <b>*p)</b>
       <b>int</b> <b>pcap_is_swapped(pcap_t</b> <b>*p)</b>
       <b>int</b> <b>pcap_major_version(pcap_t</b> <b>*p)</b>
       <b>int</b> <b>pcap_minor_version(pcap_t</b> <b>*p)</b>
       <b>int</b> <b>pcap_stats(pcap_t</b> <b>*p,</b> <b>struct</b> <b>pcap_stat</b> <b>*ps)</b>
       <b>FILE</b> <b>*pcap_file(pcap_t</b> <b>*p)</b>
       <b>int</b> <b>pcap_fileno(pcap_t</b> <b>*p)</b>
       <b>int</b> <b>pcap_get_selectable_fd(pcap_t</b> <b>*p);</b>
       <b>void</b> <b>pcap_perror(pcap_t</b> <b>*p,</b> <b>char</b> <b>*prefix)</b>
       <b>char</b> <b>*pcap_geterr(pcap_t</b> <b>*p)</b>
       <b>char</b> <b>*pcap_strerror(int</b> <b>error)</b>
       <b>const</b> <b>char</b> <b>*pcap_lib_version(void)</b>

       <b>void</b> <b>pcap_close(pcap_t</b> <b>*p)</b>
       <b>int</b> <b>pcap_dump_flush(pcap_dumper_t</b> <b>*p)</b>
       <b>long</b> <b>pcap_dump_ftell(pcap_dumper_t</b> <b>*p)</b>
       <b>FILE</b> <b>*pcap_dump_file(pcap_dumper_t</b> <b>*p)</b>
       <b>void</b> <b>pcap_dump_close(pcap_dumper_t</b> <b>*p)</b>

<b>DESCRIPTION</b>
       The  Packet Capture library provides a high level interface to packet capture systems. All packets on
       the network, even those destined for other hosts, are accessible through this mechanism.


<b>ROUTINES</b>
       NOTE:  <u>errbuf</u>  in  <b>pcap_open_live()</b>,  <b>pcap_open_dead()</b>,  <b>pcap_open_offline()</b>,   <b>pcap_fopen_offline()</b>,
       <b>pcap_setnonblock()</b>, <b>pcap_getnonblock()</b>, <b>pcap_findalldevs()</b>, <b>pcap_lookupdev()</b>, and <b>pcap_lookupnet()</b> is
       assumed to be able to hold at least <b>PCAP_ERRBUF_SIZE</b> chars.

       <b>pcap_open_live()</b> is used to obtain a packet capture descriptor to look at  packets  on  the  network.
       <u>device</u> is a string that specifies the network device to open; on Linux systems with 2.2 or later ker-<font color="#ffffff" class="whiteout">nels,&nbsp;kernels,</font>
       nels, a <u>device</u> argument of "any" or <b>NULL</b> can be used to capture packets from all interfaces.  <u>snaplen</u>
       specifies  the  maximum  number of bytes to capture.  If this value is less than the size of a packet
       that is captured, only the first <u>snaplen</u> bytes of that packet will be captured and provided as packet
       data.   A  value  of 65535 should be sufficient, on most if not all networks, to capture all the data
       available from the packet.  <u>promisc</u> specifies if the interface is to be put  into  promiscuous  mode.
       (Note  that even if this parameter is false, the interface could well be in promiscuous mode for some
       other reason.)  For now, this doesn't work on the "any" device; if an argument of "any"  or  NULL  is
       supplied,  the  <u>promisc</u> flag is ignored.  <u>to</u><b>_</b><u>ms</u> specifies the read timeout in milliseconds.  The read
       timeout is used to arrange that the read not necessarily return immediately when a  packet  is  seen,
       but that it wait for some amount of time to allow more packets to arrive and to read multiple packets
       from the OS kernel in one operation.  Not all platforms support a read  timeout;  on  platforms  that
       don't,  the  read timeout is ignored.  A zero value for <u>to</u><b>_</b><u>ms</u>, on platforms that support a read time-<font color="#ffffff" class="whiteout">out,&nbsp;timeout,</font>
       out, will cause a read to wait forever to allow enough packets to arrive, with no timeout.  <u>errbuf</u> is
       used  to  return error or warning text.  It will be set to error text when <b>pcap_open_live()</b> fails and
       returns <b>NULL</b>.  <u>errbuf</u> may also be set to warning text when <b>pcap_open_live()</b> succeds; to  detect  this
       case  the caller should store a zero-length string in <u>errbuf</u> before calling <b>pcap_open_live()</b> and dis-<font color="#ffffff" class="whiteout">play&nbsp;display</font>
       play the warning to the user if <u>errbuf</u> is no longer a zero-length string.

       <b>pcap_open_dead()</b> is used for creating a <b>pcap_t</b> structure to use when calling the other  functions  in
       libpcap.  It is typically used when just using libpcap for compiling BPF code.

       <b>pcap_open_offline()</b>  is  called  to open a ``savefile'' for reading.  <u>fname</u> specifies the name of the
       file to open. The file has the same format as those used by <a href="../man1/tcpdump.1.html#//apple_ref/doc/man/1/tcpdump"><b>tcpdump(1)</b></a><b></b> and <!-- a --><b>tcpslice(1)</b><!-- /a --><b></b>.  The name "-"
       in a synonym for <b>stdin</b>.  Alternatively, you may call <b>pcap_fopen_offline()</b> to read dumped data from an
       existing open stream <u>fp</u>.  Note that on Windows, that stream should be opened in binary mode.   <u>errbuf</u>
       is  used  to return error text and is only set when <b>pcap_open_offline()</b> or <b>pcap_fopen_offline()</b> fails
       and returns <b>NULL</b>.

       <b>pcap_dump_open()</b> is called to open a ``savefile'' for writing. The name "-" in a synonym for  <b>stdout</b>.
       <b>NULL</b>   is  returned  on  failure.   <u>p</u>  is  a  <u>pcap</u>  struct  as  returned  by  <b>pcap_open_offline()</b>  or
       <b>pcap_open_live()</b>.  <u>fname</u> specifies the name  of  the  file  to  open.  Alternatively,  you  may  call
       <b>pcap_dump_fopen()</b>  to  write  data  to an existing open stream <u>fp</u>.  Note that on Windows, that stream
       should be opened in binary mode.  If <b>NULL</b> is returned, <b>pcap_geterr()</b> can be used  to  get  the  error
       text.


       <b>pcap_setnonblock()</b>  puts  a  capture  descriptor, opened with <b>pcap_open_live()</b>, into ``non-blocking''
       mode, or takes it out of ``non-blocking'' mode, depending on whether the <u>nonblock</u>  argument  is  non-<font color="#ffffff" class="whiteout">zero&nbsp;nonzero</font>
       zero or zero.  It has no effect on ``savefiles''.  If there is an error, -1 is returned and <u>errbuf</u> is
       filled in with an appropriate error message; otherwise, 0 is returned.  In ``non-blocking'' mode,  an
       attempt  to  read  from the capture descriptor with <b>pcap_dispatch()</b> will, if no packets are currently
       available to be read, return 0 immediately rather  than  blocking  waiting  for  packets  to  arrive.
       <b>pcap_loop()</b> and <b>pcap_next()</b> will not work in ``non-blocking'' mode.

       <b>pcap_getnonblock()</b>  returns  the  current ``non-blocking'' state of the capture descriptor; it always
       returns 0 on ``savefiles''.  If there is an error, -1 is returned and <u>errbuf</u> is  filled  in  with  an
       appropriate error message.

       <b>pcap_findalldevs()</b>  constructs  a  list  of network devices that can be opened with <b>pcap_open_live()</b>.
       (Note that there may be network devices that cannot be opened with <b>pcap_open_live()</b>  by  the  process
       calling  <b>pcap_findalldevs()</b>,  because, for example, that process might not have sufficient privileges
       to open them for capturing; if so, those devices will not appear on the list.)  <u>alldevsp</u>  is  set  to
       point  to  the  first element of the list; each element of the list is of type <b>pcap_if_t</b>, and has the
       following members:

              <b>next</b>   if not <b>NULL</b>, a pointer to the next element in the list; <b>NULL</b> for the  last  element  of
                     the list

              <b>name</b>   a pointer to a string giving a name for the device to pass to <b>pcap_open_live()</b>

              <b>description</b>
                     if not <b>NULL</b>, a pointer to a string giving a human-readable description of the device

              <b>addresses</b>
                     a pointer to the first element of a list of addresses for the interface

              <b>flags</b>  interface flags:

                     <b>PCAP_IF_LOOPBACK</b>
                            set if the interface is a loopback interface

       Each element of the list of addresses is of type <b>pcap_addr_t</b>, and has the following members:

              <b>next</b>   if  not  <b>NULL</b>,  a pointer to the next element in the list; <b>NULL</b> for the last element of
                     the list

              <b>addr</b>   a pointer to a <b>struct</b> <b>sockaddr</b> containing an address

              <b>netmask</b>
                     if not <b>NULL</b>, a pointer to a <b>struct</b> <b>sockaddr</b> that contains the netmask corresponding  to
                     the address pointed to by <b>addr</b>

              <b>broadaddr</b>
                     if  not <b>NULL</b>, a pointer to a <b>struct</b> <b>sockaddr</b> that contains the broadcast address corre-<font color="#ffffff" class="whiteout">sponding&nbsp;corresponding</font>
                     sponding to the address pointed to by <b>addr</b>; may be null if the interface  doesn't  sup-<font color="#ffffff" class="whiteout">port&nbsp;support</font>
                     port broadcasts

              <b>dstaddr</b>
                     if  not <b>NULL</b>, a pointer to a <b>struct</b> <b>sockaddr</b> that contains the destination address cor-<font color="#ffffff" class="whiteout">responding&nbsp;corresponding</font>
                     responding to the address pointed to by <b>addr</b>; may be null  if  the  interface  isn't  a
                     point-to-point interface

       Note that not all the addresses in the list of addresses are necessarily IPv4 or IPv6 addresses - you
       must check the <b>sa_family</b> member of the <b>struct</b>  <b>sockaddr</b>  before  interpreting  the  contents  of  the
       address.

       <b>-1</b>  is returned on failure, in which case <b>errbuf</b> is filled in with an appropriate error message; <b>0</b> is
       returned on success.

       <b>pcap_freealldevs()</b> is used to free a list allocated by <b>pcap_findalldevs()</b>.

       <b>pcap_lookupdev()</b> returns a pointer to a network device suitable for  use  with  <b>pcap_open_live()</b>  and
       <b>pcap_lookupnet()</b>.  If there is an error, <b>NULL</b> is returned and <u>errbuf</u> is filled in with an appropriate
       error message.

       <b>pcap_lookupnet()</b> is used to determine the network number and mask associated with the network  device
       <b>device</b>.   Both  <u>netp</u>  and <u>maskp</u> are <u>bpf</u><b>_</b><u>u</u><b>_</b><u>int32</u> pointers.  A return of -1 indicates an error in which
       case <u>errbuf</u> is filled in with an appropriate error message.

       <b>pcap_dispatch()</b> is used to collect and process packets.  <u>cnt</u> specifies the maximum number of  packets
       to  process  before  returning.   This is not a minimum number; when reading a live capture, only one
       bufferful of packets is read at a time, so fewer than <u>cnt</u> packets may be processed. A <u>cnt</u> of -1  pro-<font color="#ffffff" class="whiteout">cesses&nbsp;processes</font>
       cesses  all the packets received in one buffer when reading a live capture, or all the packets in the
       file when reading a ``savefile''.  <u>callback</u> specifies a routine to be called with three arguments:  a
       <u>u</u><b>_</b><u>char</u>  pointer  which  is  passed  in  from <b>pcap_dispatch()</b>, a <u>const</u> <u>struct</u> <u>pcap</u><b>_</b><u>pkthdr</u> pointer to a
       structure with the following members:

              <b>ts</b>     a <u>struct</u> <u>timeval</u> containing the time when the packet was captured

              <b>caplen</b> a <u>bpf</u><b>_</b><u>u</u><b>_</b><u>int32</u> giving the number of bytes of the packet that are available from the cap-<font color="#ffffff" class="whiteout">ture&nbsp;capture</font>
                     ture

              <b>len</b>    a  <u>bpf</u><b>_</b><u>u</u><b>_</b><u>int32</u>  giving the length of the packet, in bytes (which might be more than the
                     number of bytes available from the capture, if the length of the packet is larger  than
                     the maximum number of bytes to capture)

       and a <u>const</u> <u>u</u><b>_</b><u>char</u> pointer to the first <b>caplen</b> (as given in the <u>struct</u> <u>pcap</u><b>_</b><u>pkthdr</u> a pointer to which
       is passed to the callback routine) bytes of data from the packet  (which  won't  necessarily  be  the
       entire  packet;  to  capture  the entire packet, you will have to provide a value for <u>snaplen</u> in your
       call to <b>pcap_open_live()</b> that is sufficiently large to get all of the packet's  data  -  a  value  of
       65535 should be sufficient on most if not all networks).

       The  number  of  packets read is returned.  0 is returned if no packets were read from a live capture
       (if, for example, they were discarded because they didn't pass the packet filter, or if, on platforms
       that  support  a  read  timeout that starts before any packets arrive, the timeout expires before any
       packets arrive, or if the file descriptor for the capture device is in non-blocking mode and no pack-<font color="#ffffff" class="whiteout">ets&nbsp;packets</font>
       ets  were available to be read) or if no more packets are available in a ``savefile.'' A return of -1
       indicates an error in which case <b>pcap_perror()</b> or <b>pcap_geterr()</b> may be  used  to  display  the  error
       text.  A return of -2 indicates that the loop terminated due to a call to <b>pcap_breakloop()</b> before any
       packets were processed.  <b>If</b> <b>your</b> <b>application</b> <b>uses</b> <b>pcap_breakloop(),</b> <b>make</b>  <b>sure</b>  <b>that</b>  <b>you</b>  <b>explicitly</b>
       <b>check</b> <b>for</b> <b>-1</b> <b>and</b> <b>-2,</b> <b>rather</b> <b>than</b> <b>just</b> <b>checking</b> <b>for</b> <b>a</b> <b>return</b> <b>value</b> <b>&lt;</b> <b>0.</b>

       <b>NOTE</b>:  when  reading  a live capture, <b>pcap_dispatch()</b> will not necessarily return when the read times
       out; on some platforms, the read timeout isn't supported, and, on other platforms, the timer  doesn't
       start until at least one packet arrives.  This means that the read timeout should <b>NOT</b> be used in, for
       example, an interactive application, to allow the packet capture loop  to  ``poll''  for  user  input
       periodically, as there's no guarantee that <b>pcap_dispatch()</b> will return after the timeout expires.

       <b>pcap_loop()</b>  is similar to <b>pcap_dispatch()</b> except it keeps reading packets until <u>cnt</u> packets are pro-
       cessed or an error occurs.  It does <b>not</b> return when live read timeouts occur.  Rather,  specifying  a
       non-zero  read  timeout to <b>pcap_open_live()</b> and then calling <b>pcap_dispatch()</b> allows the reception and
       processing of any packets that arrive when the timeout occurs.  A negative <u>cnt</u> causes <b>pcap_loop()</b>  to
       loop  forever  (or at least until an error occurs).  -1 is returned on an error; 0 is returned if <u>cnt</u>
       is exhausted; -2 is returned if the loop terminated due to a  call  to  <b>pcap_breakloop()</b>  before  any
       packets  were  processed.   <b>If</b>  <b>your</b> <b>application</b> <b>uses</b> <b>pcap_breakloop(),</b> <b>make</b> <b>sure</b> <b>that</b> <b>you</b> <b>explicitly</b>
       <b>check</b> <b>for</b> <b>-1</b> <b>and</b> <b>-2,</b> <b>rather</b> <b>than</b> <b>just</b> <b>checking</b> <b>for</b> <b>a</b> <b>return</b> <b>value</b> <b>&lt;</b> <b>0.</b>

       <b>pcap_next()</b> reads the next packet (by calling <b>pcap_dispatch()</b> with a <u>cnt</u> of 1) and returns  a  <u>u</u><b>_</b><u>char</u>
       pointer  to the data in that packet.  (The <u>pcap</u><b>_</b><u>pkthdr</u> struct for that packet is not supplied.)  <b>NULL</b>
       is returned if an error occured, or if no packets were read from a live  capture  (if,  for  example,
       they  were  discarded  because they didn't pass the packet filter, or if, on platforms that support a
       read timeout that starts before any packets arrive, the timeout expires before any packets arrive, or
       if  the  file descriptor for the capture device is in non-blocking mode and no packets were available
       to be read), or if no more packets are available in a ``savefile.''  Unfortunately, there is  no  way
       to determine whether an error occured or not.

       <b>pcap_next_ex()</b> reads the next packet and returns a success/failure indication:

              1      the packet was read without problems

              0      packets are being read from a live capture, and the timeout expired

              -1     an error occurred while reading the packet

              -2     packets  are being read from a ``savefile'', and there are no more packets to read from
                     the savefile.

       If the packet was read without problems, the pointer pointed to by the <u>pkt</u><b>_</b><u>header</u> argument is set  to
       point  to  the <u>pcap</u><b>_</b><u>pkthdr</u> struct for the packet, and the pointer pointed to by the <u>pkt</u><b>_</b><u>data</u> argument
       is set to point to the data in the packet.

       <b>pcap_breakloop()</b> sets a flag that will force <b>pcap_dispatch()</b> or <b>pcap_loop()</b>  to  return  rather  than
       looping;  they will return the number of packets that have been processed so far, or -2 if no packets
       have been processed so far.

       This routine is safe to use inside a signal handler on UNIX or a console control handler on  Windows,
       as it merely sets a flag that is checked within the loop.

       The  flag  is  checked in loops reading packets from the OS - a signal by itself will not necessarily
       terminate those loops - as well as in loops processing a set of packets returned  by  the  OS.   <b>Note</b>
       <b>that</b> <b>if</b> <b>you</b> <b>are</b> <b>catching</b> <b>signals</b> <b>on</b> <b>UNIX</b> <b>systems</b> <b>that</b> <b>support</b> <b>restarting</b> <b>system</b> <b>calls</b> <b>after</b> <b>a</b> <b>signal,</b>
       <b>and</b> <b>calling</b> <b>pcap_breakloop()</b> <b>in</b> <b>the</b> <b>signal</b> <b>handler,</b> <b>you</b> <b>must</b> <b>specify,</b> <b>when</b>  <b>catching</b>  <b>those</b>  <b>signals,</b>
       <b>that</b>  <b>system</b>  <b>calls</b>  <b>should</b>  <b>NOT</b> <b>be</b> <b>restarted</b> <b>by</b> <b>that</b> <b>signal.</b>  <b>Otherwise,</b> <b>if</b> <b>the</b> <b>signal</b> <b>interrupted</b> <b>a</b>
       <b>call</b> <b>reading</b> <b>packets</b> <b>in</b> <b>a</b> <b>live</b> <b>capture,</b> <b>when</b> <b>your</b> <b>signal</b> <b>handler</b> <b>returns</b>  <b>after</b>  <b>calling</b>  <b>pcap_break-</b>
       <b>loop(),</b> <b>the</b> <b>call</b> <b>will</b> <b>be</b> <b>restarted,</b> <b>and</b> <b>the</b> <b>loop</b> <b>will</b> <b>not</b> <b>terminate</b> <b>until</b> <b>more</b> <b>packets</b> <b>arrive</b> <b>and</b> <b>the</b>
       <b>call</b> <b>completes.</b>

       Note also that, in a multi-threaded  application,  if  one  thread  is  blocked  in  <b>pcap_dispatch()</b>,
       <b>pcap_loop()</b>,  <b>pcap_next()</b>,  or  <b>pcap_next_ex()</b>, a call to <b>pcap_breakloop()</b> in a different thread will
       not unblock that thread; you will need to use whatever mechanism  the  OS  provides  for  breaking  a
       thread  out  of blocking calls in order to unblock the thread, such as thread cancellation in systems
       that support POSIX threads.

       Note that <b>pcap_next()</b> will, on some platforms, loop reading packets from the OS; that loop  will  not
       necessarily  be  terminated  by a signal, so <b>pcap_breakloop()</b> should be used to terminate packet pro-<font color="#ffffff" class="whiteout">cessing&nbsp;processing</font>
       cessing even if <b>pcap_next()</b> is being used.

       <b>pcap_breakloop()</b> does not guarantee that no further packets will be processed by  <b>pcap_dispatch()</b>  or
       <b>pcap_loop()</b> after it is called; at most one more packet might be processed.

       If -2 is returned from <b>pcap_dispatch()</b> or <b>pcap_loop()</b>, the flag is cleared, so a subsequent call will
       resume reading packets.  If a positive number is returned, the flag is not cleared, so  a  subsequent
       call will return -2 and clear the flag.

       <b>pcap_inject()</b> sends a raw packet through the network interface; <u>buf</u> points to the data of the packet,
       including the link-layer header, and <u>size</u> is the number of bytes in the packet.  It returns the  num-<font color="#ffffff" class="whiteout">ber&nbsp;number</font>
       ber  of  bytes  written on success.  A return of -1 indicates an error in which case <b>pcap_perror()</b> or
       <b>pcap_geterr()</b> may be used to display the error text.  Note that, even if you  successfully  open  the
       network interface, you might not have permission to send packets on it, or it might not support send-<font color="#ffffff" class="whiteout">ing&nbsp;sending</font>
       ing packets; as <u>pcap</u><b>_</b><u>open</u><b>_</b><u>live()</u> doesn't have a flag to indicate whether to open for capturing, send-<font color="#ffffff" class="whiteout">ing,&nbsp;sending,</font>
       ing,  or  capturing  and sending, you cannot request an open that supports sending and be notified at
       open time whether sending will be possible.  Note also that some devices might  not  support  sending
       packets.

       Note  that,  on some platforms, the link-layer header of the packet that's sent might not be the same
       as the link-layer header of the packet supplied to <b>pcap_inject()</b>, as the source  link-layer  address,
       if  the header contains such an address, might be changed to be the address assigned to the interface
       on which the packet it sent, if the platform doesn't support sending  completely  raw  and  unchanged
       packets.   Even worse, some drivers on some platforms might change the link-layer type field to what-<font color="#ffffff" class="whiteout">ever&nbsp;whatever</font>
       ever value libpcap used when attaching to the device, even on platforms  that  <u>do</u>  nominally  support
       sending completely raw and unchanged packets.

       <b>pcap_sendpacket()</b>   is  like  <b>pcap_inject()</b>,  but  it  returns  0  on  success  and  -1  on  failure.
       (<b>pcap_inject()</b> comes from OpenBSD; <b>pcap_sendpacket()</b> comes from WinPcap.  Both are provided for  com-<font color="#ffffff" class="whiteout">patibility.)&nbsp;compatibility.)</font>
       patibility.)

       <b>pcap_dump()</b> outputs a packet to the ``savefile'' opened with <b>pcap_dump_open()</b>.  Note that its calling
       arguments are suitable for use with <b>pcap_dispatch()</b> or <b>pcap_loop()</b>.  If  called  directly,  the  <u>user</u>
       parameter is of type <u>pcap</u><b>_</b><u>dumper</u><b>_</b><u>t</u> as returned by <b>pcap_dump_open()</b>.

       <b>pcap_compile()</b>  is  used  to compile the string <u>str</u> into a filter program.  <u>program</u> is a pointer to a
       <u>bpf</u><b>_</b><u>program</u> struct and is filled in by <b>pcap_compile()</b>.  <u>optimize</u> controls whether optimization on the
       resulting  code is performed.  <u>netmask</u> specifies the IPv4 netmask of the network on which packets are
       being captured; it is used only when checking for IPv4 broadcast addresses in the filter program.  If
       the  netmask  of  the  network  on which packets are being captured isn't known to the program, or if
       packets are being captured on the Linux "any" pseudo-interface that can capture on more than one net-<font color="#ffffff" class="whiteout">work,&nbsp;network,</font>
       work,  a  value  of 0 can be supplied; tests for IPv4 broadcast addreses won't be done correctly, but
       all other tests in the filter program will be OK.  A return of -1 indicates an error  in  which  case
       <b>pcap_geterr()</b> may be used to display the error text.

       <b>pcap_compile_nopcap()</b>  is  similar to <b>pcap_compile()</b> except that instead of passing a pcap structure,
       one passes the snaplen and linktype explicitly.  It is intended to be used for compiling filters  for
       direct  BPF usage, without necessarily having called <b>pcap_open()</b>.  A return of -1 indicates an error;
       the error  text  is  unavailable.   (<b>pcap_compile_nopcap()</b>  is  a  wrapper  around  <b>pcap_open_dead()</b>,
       <b>pcap_compile()</b>,  and <b>pcap_close()</b>; the latter three routines can be used directly in order to get the
       error text for a compilation error.)

       <b>pcap_setfilter()</b> is used to specify a filter program.  <u>fp</u> is a pointer to a <u>bpf</u><b>_</b><u>program</u> struct,  usu-<font color="#ffffff" class="whiteout">ally&nbsp;usually</font>
       ally  the result of a call to <b>pcap_compile()</b>.  <b>-1</b> is returned on failure, in which case <b>pcap_geterr()</b>
       may be used to display the error text; <b>0</b> is returned on success.

       <b>pcap_freecode()</b> is used to free up allocated memory pointed to by a <u>bpf</u><b>_</b><u>program</u> struct  generated  by
       <b>pcap_compile()</b> when that BPF program is no longer needed, for example after it has been made the fil-<font color="#ffffff" class="whiteout">ter&nbsp;filter</font>
       ter program for a pcap structure by a call to <b>pcap_setfilter()</b>.

       <b>pcap_setdirection()</b> is used to specify a direction that packets will be  captured.   <u>pcap</u><b>_</b><u>direction</u><b>_</b><u>t</u>
       is  one  of the constants <b>PCAP_D_IN</b>, <b>PCAP_D_OUT</b> or <b>PCAP_D_INOUT</b>.  <b>PCAP_D_IN</b> will only capture packets
       received by the device, <b>PCAP_D_OUT</b> will only capture packets sent by the device and <b>PCAP_D_INOUT</b> will
       capture packets received by or sent by the device.  <b>PCAP_D_INOUT</b> is the default setting if this func-<font color="#ffffff" class="whiteout">tion&nbsp;function</font>
       tion is not called.  This isn't necessarily supported on all platforms; some platforms  might  return
       an  error, and some other platforms might not support <b>PCAP_D_OUT</b>.  This operation is not supported if
       a ``savefile'' is being read.  <b>-1</b> is returned on failure, <b>0</b> is returned on success.

       <b>pcap_datalink()</b> returns the link layer type; link layer types it can return include:


            <b>DLT_NULL</b>
                 BSD loopback encapsulation; the link layer header is a 4-byte field, in  <u>host</u>  byte  order,
                 containing a PF_ value from <b>socket.h</b> for the network-layer protocol of the packet.

                 Note  that  ``host  byte  order'' is the byte order of the machine on which the packets are
                 captured, and the PF_ values are for the OS of the machine on which the  packets  are  cap-<font color="#ffffff" class="whiteout">tured;&nbsp;captured;</font>
                 tured;  if  a  live  capture  is  being  done, ``host byte order'' is the byte order of the
                 machine capturing the packets, and the PF_ values are those of the OS of the  machine  cap-<font color="#ffffff" class="whiteout">turing&nbsp;capturing</font>
                 turing  the packets, but if a ``savefile'' is being read, the byte order and PF_ values are
                 <u>not</u> necessarily those of the machine reading the capture file.

            <b>DLT_EN10MB</b>
                 Ethernet (10Mb, 100Mb, 1000Mb, and up)

            <b>DLT_IEEE802</b>
                 IEEE 802.5 Token Ring

            <b>DLT_ARCNET</b>
                 ARCNET

            <b>DLT_SLIP</b>
                 SLIP; the link layer header contains, in order:

                      a 1-byte flag, which is 0 for packets received by the machine and 1 for  packets  sent
                      by the machine;

                      a  1-byte  field,  the  upper  4 bits of which indicate the type of packet, as per RFC
                      1144:

                           0x40 an unmodified IP datagram (TYPE_IP);

                           0x70 an uncompressed-TCP IP datagram (UNCOMPRESSED_TCP), with that byte being the
                                first  byte of the raw IP header on the wire, containing the connection num-<font color="#ffffff" class="whiteout">ber&nbsp;number</font>
                                ber in the protocol field;

                           0x80 a compressed-TCP IP datagram (COMPRESSED_TCP),  with  that  byte  being  the
                                first byte of the compressed TCP/IP datagram header;

                      for  UNCOMPRESSED_TCP, the rest of the modified IP header, and for COMPRESSED_TCP, the
                      compressed TCP/IP datagram header;

                 for a total of 16 bytes; the uncompressed IP datagram follows the header.

            <b>DLT_PPP</b>
                 PPP; if the first 2 bytes are 0xff and 0x03, it's PPP in HDLC-like framing,  with  the  PPP
                 header following those two bytes, otherwise it's PPP without framing, and the packet begins
                 with the PPP header.

            <b>DLT_FDDI</b>
                 FDDI

            <b>DLT_ATM_RFC1483</b>
                 RFC 1483 LLC/SNAP-encapsulated ATM; the packet begins with an IEEE 802.2 LLC header.

            <b>DLT_RAW</b>
                 raw IP; the packet begins with an IP header.

            <b>DLT_PPP_SERIAL</b>
                 PPP in HDLC-like framing, as per RFC 1662, or Cisco PPP with HDLC framing, as  per  section
                 4.3.1  of  RFC  1547; the first byte will be 0xFF for PPP in HDLC-like framing, and will be
                 0x0F or 0x8F for Cisco PPP with HDLC framing.

            <b>DLT_PPP_ETHER</b>
                 PPPoE; the packet begins with a PPPoE header, as per RFC 2516.

            <b>DLT_C_HDLC</b>
                 Cisco PPP with HDLC framing, as per section 4.3.1 of RFC 1547.

            <b>DLT_IEEE802_11</b>
                 IEEE 802.11 wireless LAN

            <b>DLT_FRELAY</b>
                 Frame Relay

            <b>DLT_LOOP</b>
                 OpenBSD loopback encapsulation; the link layer header is a 4-byte field,  in  <u>network</u>  byte
                 order, containing a PF_ value from OpenBSD's <b>socket.h</b> for the network-layer protocol of the
                 packet.

                 Note that, if a ``savefile'' is being read, those PF_ values are <u>not</u> necessarily  those  of
                 the machine reading the capture file.

            <b>DLT_LINUX_SLL</b>
                 Linux "cooked" capture encapsulation; the link layer header contains, in order:

                      a 2-byte "packet type", in network byte order, which is one of:

                           0    packet was sent to us by somebody else

                           1    packet was broadcast by somebody else

                           2    packet was multicast, but not broadcast, by somebody else

                           3    packet was sent by somebody else to somebody else

                           4    packet was sent by us

                      a  2-byte  field, in network byte order, containing a Linux ARPHRD_ value for the link
                      layer device type;

                      a 2-byte field, in network byte order, containing the length of the link layer address
                      of the sender of the packet (which could be 0);

                      an 8-byte field containing that number of bytes of the link layer header (if there are
                      more than 8 bytes, only the first 8 are present);

                      a 2-byte field containing an Ethernet protocol type, in network byte  order,  or  con-<font color="#ffffff" class="whiteout">taining&nbsp;containing</font>
                      taining  1  for Novell 802.3 frames without an 802.2 LLC header or 4 for frames begin-<font color="#ffffff" class="whiteout">ning&nbsp;beginning</font>
                      ning with an 802.2 LLC header.

            <b>DLT_LTALK</b>
                 Apple LocalTalk; the packet begins with an AppleTalk LLAP header.

            <b>DLT_PFLOG</b>
                 OpenBSD pflog; the link layer header contains, in order:

                      a 1-byte header length, in host byte order;

                      a 4-byte PF_ value, in host byte order;

                      a 2-byte action code, in network byte order, which is one of:

                           0    passed

                           1    dropped

                           2    scrubbed

                      a 2-byte reason code, in network byte order, which is one of:

                           0    match

                           1    bad offset

                           2    fragment

                           3    short

                           4    normalize

                           5    memory

                      a 16-character interface name;

                      a 16-character ruleset name (only meaningful if subrule is set);

                      a 4-byte rule number, in network byte order;

                      a 4-byte subrule number, in network byte order;

                      a 1-byte direction, in network byte order, which is one of:

                           0    incoming or outgoing

                           1    incoming

                           2    outgoing

            <b>DLT_PRISM_HEADER</b>
                 Prism monitor mode information followed by an 802.11 header.

            <b>DLT_IP_OVER_FC</b>
                 RFC 2625 IP-over-Fibre Channel, with the link-layer  header  being  the  Network_Header  as
                 described in that RFC.

            <b>DLT_SUNATM</b>
                 SunATM devices; the link layer header contains, in order:

                      a  1-byte  flag  field, containing a direction flag in the uppermost bit, which is set
                      for packets transmitted by the machine and clear for packets received by the  machine,
                      and a 4-byte traffic type in the low-order 4 bits, which is one of:

                           0    raw traffic

                           1    LANE traffic

                           2    LLC-encapsulated traffic

                           3    MARS traffic

                           4    IFMP traffic

                           5    ILMI traffic

                           6    Q.2931 traffic

                      a 1-byte VPI value;

                      a 2-byte VCI field, in network byte order.

            <b>DLT_IEEE802_11_RADIO</b>
                 link-layer   information   followed   by   an   802.11   header   -  see  <a href="http://www.shaftnet.org/~pizza/software/capturefrm.txt">http://www.shaft-</a>
                 <a href="http://www.shaftnet.org/~pizza/software/capturefrm.txt">net.org/~pizza/software/capturefrm.txt</a> for a description of the link-layer information.

            <b>DLT_ARCNET_LINUX</b>
                 ARCNET, with no exception frames, reassembled packets rather than raw frames, and an  extra
                 16-bit offset field between the destination host and type bytes.

            <b>DLT_LINUX_IRDA</b>
                 Linux-IrDA packets, with a <b>DLT_LINUX_SLL</b> header followed by the IrLAP header.

            <b>DLT_LINUX_LAPD</b>
                 LAPD (Q.921) frames, with a <b>DLT_LINUX_SLL</b> header captured via vISDN.

       <b>pcap_list_datalinks()</b> is used to get a list of the supported data link types of the interface associ-
       ated with the pcap descriptor.  <b>pcap_list_datalinks()</b> allocates an array to hold the  list  and  sets
       <u>*dlt</u><b>_</b><u>buf</u>.   The  caller  is responsible for freeing the array.  <b>-1</b> is returned on failure; otherwise,
       the number of data link types in the array is returned.

       <b>pcap_set_datalink()</b> is used to set the current data link type of the  pcap  descriptor  to  the  type
       specified by <u>dlt</u>.  <b>-1</b> is returned on failure.

       <b>pcap_datalink_name_to_val()</b>  translates  a  data  link  type name, which is a <b>DLT_</b> name with the <b>DLT_</b>
       removed, to the corresponding data link type value.  The  translation  is  case-insensitive.   <b>-1</b>  is
       returned on failure.

       <b>pcap_datalink_val_to_name()</b>  translates  a  data  link type value to the corresponding data link type
       name.  NULL is returned on failure.

       <b>pcap_datalink_val_to_description()</b> translates a data link type value to a short description  of  that
       data link type.  NULL is returned on failure.

       <b>pcap_snapshot()</b> returns the snapshot length specified when <b>pcap_open_live()</b> was called.

       <b>pcap_is_swapped()</b>  returns true if the current ``savefile'' uses a different byte order than the cur-
       rent system.

       <b>pcap_major_version()</b> returns the major number of the file format  of  the  savefile;  <b>pcap_minor_ver</b>-
       <b>sion()</b>  returns the minor number of the file format of the savefile.  The version number is stored in
       the header of the savefile.

       <b>pcap_file()</b> returns the standard I/O stream of the ``savefile,'' if a ``savefile''  was  opened  with
       <b>pcap_open_offline()</b>, or NULL, if a network device was opened with <b>pcap_open_live()</b>.

       <b>pcap_stats()</b>  returns  0 and fills in a <b>pcap_stat</b> struct. The values represent packet statistics from
       the start of the run to the time of the call. If there is an error or the underlying  packet  capture
       doesn't  support  packet statistics, -1 is returned and the error text can be obtained with <b>pcap_per</b>-
       <b>ror()</b> or <b>pcap_geterr()</b>.  <b>pcap_stats()</b> is supported only on live captures, not  on  ``savefiles'';  no
       statistics  are  stored  in ``savefiles'', so no statistics are available when reading from a ``save-
       file''.

       <b>pcap_fileno()</b> returns the file descriptor number from which captured packets are read, if  a  network
       device   was   opened   with   <b>pcap_open_live()</b>,   or   -1,   if   a  ``savefile''  was  opened  with
       <b>pcap_open_offline()</b>.

       <b>pcap_get_selectable_fd()</b> returns, on UNIX, a file descriptor number for a file  descriptor  on  which
       one  can  do  a <b>select()</b> or <b>poll()</b> to wait for it to be possible to read packets without blocking, if
       such a descriptor exists, or -1, if no such descriptor exists.   Some  network  devices  opened  with
       <b>pcap_open_live()</b>  do  not support <b>select()</b> or <b>poll()</b> (for example, regular network devices on FreeBSD
       4.3 and 4.4, and Endace DAG devices), so -1 is returned for those devices.

       Note that on most versions of most BSDs (including Mac OS X) <b>select()</b> and <b>poll()</b>  do  not  work  cor-
       rectly  on  BPF devices; <b>pcap_get_selectable_fd()</b> will return a file descriptor on most of those ver-
       sions (the exceptions being FreeBSD 4.3 and 4.4), a simple <b>select()</b> or <b>poll()</b> will  not  return  even
       after a timeout specified in <b>pcap_open_live()</b> expires.  To work around this, an application that uses
       <b>select()</b> or <b>poll()</b> to wait for packets to arrive must put the <b>pcap_t</b> in non-blocking mode,  and  must
       arrange  that  the  <b>select()</b>  or <b>poll()</b> have a timeout less than or equal to the timeout specified in
       <b>pcap_open_live()</b>, and must try to read packets after that  timeout  expires,  regardless  of  whether
       <b>select()</b>  or  <b>poll()</b>  indicated  that  the file descriptor for the <b>pcap_t</b> is ready to be read or not.
       (That workaround will not work in FreeBSD 4.3 and later; however, in FreeBSD 4.6 and later,  <b>select()</b>
       and  <b>poll()</b>  work  correctly  on  BPF devices, so the workaround isn't necessary, although it does no
       harm.)

       <b>pcap_get_selectable_fd()</b> is not available on Windows.

       <b>pcap_perror()</b> prints the text of the last pcap library error on <b>stderr</b>, prefixed by <u>prefix</u>.

       <b>pcap_geterr()</b> returns the error text pertaining to the last pcap library error.  <b>NOTE</b>: the pointer it
       returns will no longer point to a valid error message string after the <b>pcap_t</b> passed to it is closed;
       you must use or copy the string before closing the <b>pcap_t</b>.

       <b>pcap_strerror()</b> is provided in case <!-- a --><b>strerror</b>(1)<!-- /a --> isn't available.

       <b>pcap_lib_version()</b> returns a pointer to a string giving information about the version of the  libpcap
       library being used; note that it contains more information than just a version number.

       <b>pcap_close()</b> closes the files associated with <u>p</u> and deallocates resources.

       <b>pcap_dump_file()</b> returns the standard I/O stream of the ``savefile'' opened by <b>pcap_dump_open().</b>

       <b>pcap_dump_flush()</b>  flushes  the  output  buffer to the ``savefile,'' so that any packets written with
       <b>pcap_dump()</b> but not yet written to the ``savefile'' will be written.  <b>-1</b> is returned on error,  0  on
       success.

       <b>pcap_dump_ftell()</b>  returns the current file position for the ``savefile'', representing the number of
       bytes written by <b>pcap_dump_open()</b> and <b>pcap_dump()</b>.  <b>-1</b> is returned on error.

       <b>pcap_dump_close()</b> closes the ``savefile.''


<b>SEE</b> <b>ALSO</b>
       <a href="../man1/tcpdump.1.html#//apple_ref/doc/man/1/tcpdump">tcpdump(1)</a>, <!-- a -->tcpslice(1)<!-- /a -->

<b>AUTHORS</b>
       The original authors are:

       Van Jacobson, Craig Leres and Steven McCanne, all of the Lawrence Berkeley National Laboratory,  Uni-
       versity of California, Berkeley, CA.

       The current version is available from "The Tcpdump Group"'s Web site at

              <a href="http://www.tcpdump.org/"><u>http://www.tcpdump.org/</u></a>

<b>BUGS</b>
       Please send problems, bugs, questions, desirable enhancements, etc. to:

              tcpdump-workers@tcpdump.org

       Please send source code contributions, etc. to:

              patches@tcpdump.org



                                              27 February 2004                                       <!-- a -->PCAP(3)<!-- /a -->
</tt></pre>
</td></tr></table>
	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Darwin/Reference/ManPages/man3/pcap_setnonblock.3.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Darwin/Reference/ManPages/man3/pcap_setnonblock.3.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Darwin/Reference/ManPages/man3/pcap_setnonblock.3.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

</body></html>
