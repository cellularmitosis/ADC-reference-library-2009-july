<!-- Generated by Harlequin WebMaker 2.2.3 (30-Apr-1996)
Macintosh Common Lisp Version 3.0kp2p2 [AppGen 3.0b1kp2p2] -->
<HTML> <HEAD>
<TITLE>Segment Management (68K-Based Applications Only) (MacApp PG)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING31></A>


<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="MacAppProgGuide-30.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="MacAppProgGuide-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="MacAppProgGuide-158.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="MacAppProgGuide-32.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="MacAppProgGuide-2.html"><B>Programmer's Guide to MacApp</B></A> / <A HREF="MacAppProgGuide-21.html"><B>Part 1 - MacApp Theory and Architecture</B></A><BR><DD><A HREF="MacAppProgGuide-25.html"><B>Chapter 3 - Core Technologies</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING31-0></A>
<H1><A NAME=MARKER-9-202></A><A NAME=MARKER-2-203></A>Segment Management (68K-Based Applications Only)</H1>
 This section describes the basic issues involved in segmenting an application. These issues apply to 68K-based applications but not to applications built to run native on Power Macintosh computers.<P>
<A NAME=HEADING31-2></A>
<H2>The Power Macintosh Doesn't Require Segmentation</H2>
 Segmentation is not an issue for native Power Macintosh applications because on a Power Macintosh computer there is no segmentation of the application's code--the Virtual Memory Manager and the Process Manager handle the task of keeping required code in memory. MacApp's code to initialize segment handling, described in <A HREF=MacAppProgGuide-30.html#MARKER-9-170>"Initializing MacApp's Segment Management," beginning on page 71</A>, uses the <CODE><A NAME=MARKER-2-240></A>qSegments</CODE> flag to control compilation, ensuring that segmentation code is included only for applications that need it.<P>
<A NAME=HEADING31-4></A>
<H2><A NAME=MARKER-9-205></A>Segmenting a 68K Macintosh Application</H2>
 For the 68K-based Macintosh, segmentation is an important issue. <I><BR>Inside Macintosh: Processes</I> describes the Segment Manager and explains why there is a need to divide an application's code into segments that can be loaded into memory on demand. If your application is running on a Macintosh computer with enough memory, many of your code segments (perhaps even all of them) <A NAME=MARKER-2-206></A>can be resident in memory simultaneously. However, effective segmentation lets your application<P>
<UL>
<LI>run in a smaller memory partition
<LI>run on a greater number of machines
<LI>run more efficiently<P>
</UL>
 If you don't specify otherwise, the segments in your application will use 16-bit addressing and will be limited in size to 32 KB. Global data will also be limited to 32 KB. Sixteen-bit addressing results in a smaller jump table and more efficient code, but it has these potential drawbacks:<P>
<UL>
<LI>You may spend a lot of time adjusting the size of your segments to avoid the 32 KB limit.
<LI>You may run out of space for global data.
<LI>You may run out of space in the jump table. (Once the jump table is full, you cannot declare any new methods.)<P>
</UL>
<A NAME=HEADING31-13></A>
<H3><A NAME=MARKER-9-207></A><A NAME=MARKER-2-208></A>Segmentation Strategies</H3>
 As a result of these trade-offs, there are a number of possible strategies for controlling segmentation in your application.<P>
<A NAME=HEADING31-15></A>
<H4>Using ModelFar Addressing to Create Large Segments</H4>
 If you build your application using the <CODE>-<A NAME=MARKER-2-209></A>ModelFar</CODE> build option (see <BR><A HREF=MacAppProgGuide-148.html#MARKER-9-10>Appendix A</A>), the linker will use 32-bit addressing for code and data segments, eliminating the 32 KB size limitation. Although this approach is simple, it can lead to inefficient code, and should only be used for applications with legitimate size requirements. And even if you build with the <CODE>-ModelFar</CODE> option, you should still follow the strategy described below in <A HREF=#MARKER-9-211>"Putting Related Code in the Same Segment."</A><P>
<A NAME=HEADING31-17></A>
<H4>Avoiding Jump<B>-</B>Table Limits</H4>
 Another way to minimize size limitations is to build your application with the <CODE>-<A NAME=MARKER-2-210></A>CFM68K</CODE> build option. This option specifies that the application will use CFM-68K, the 68K Macintosh equivalent of the Power Macintosh Code Fragment Manager. CFM-68K uses 16-bit addressing, so it creates efficient code, but its implementation allows much more room for jump-table entries and global data.<P>
<A NAME=HEADING31-19></A>
<H4>Creating Segments of Minimal Size</H4>
 Another strategy for segmenting your application is to organize segments so that they are as small as possible. This ensures that the application heap will contain only code that is needed, increasing the amount of memory available. However, using small segments can lead to excessive segment load calls, which are triggered when a needed function is not present in memory.<P>
<A NAME=HEADING31-21></A>
<H4><A NAME=MARKER-9-211></A>Putting Related Code in the Same Segment</H4>
 A strategy used in the MacApp class library is to put functions that are used together in the same segment. For example, routines used only in initializing the application are placed in one segment. That segment is loaded during initialization, but it may later be replaced by another segment, because it won't be needed again until the next time the application is launched.<P>
<A NAME=HEADING31-23></A>
<H3><A NAME=MARKER-2-212></A><A NAME=MARKER-9-213></A>Creating Segments</H3>
 MacApp uses compiler segment directives such as the following to specify the segment for a section of code:<P>
<PRE>
#pragma segment ARes
</PRE>
 This tells the compiler that all code following the directive belongs in the <CODE>ARes</CODE> segment (but see the following section for information on remapping segments). The directive remains in effect until another segment directive is encountered.<P>
<DL>
<DT><B>Note</B>
<DD>Putting a routine in a segment named <CODE>ARes</CODE> does not automatically make the code in that routine resident. See <A HREF=#MARKER-9-225>"The 'res!' Resource," beginning on page 81</A>, for information on how to make a segment resident.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
 MacApp and the sample applications distributed with MacApp use the following segment-naming conventions:<P>
<UL>
<LI>Each method or routine is prefaced with a segment directive, indicating the segment in which the code is to be located.
<LI>A segment name indicates the function of the code segment.
<LI>All routines used for a specific function are included in the same segment. For example, all code for reading files is stored in the segment <CODE>AReadFile</CODE>.<P>
</UL>
 Some of MacApp's segment names are shown in <A HREF=#MARKER-9-215>Table 3-3</A>, with examples of the functions each segment contains. (For more information, see <A HREF=MacAppProgGuide-124.html#MARKER-9-52>"Recipe--Defining Segment Names for Your Application," beginning on page 553</A>.)<P>
<B>Table 3-3  <A NAME=MARKER-2-214></A><A NAME=MARKER-9-215></A><B>Table 3-3 MacApp segment names and descriptions</B>
<TABLE BORDER="0" CELLPADDING=3><TH ALIGN=LEFT><B>Segment name</B><TH>Functions stored in the segment (continued)<TR>
<TD><CODE>AClose</CODE><TD>Routines for closing documents and data structures<TR>
<TD><CODE>ADebug</CODE><TD>Debugging code<TR>
<TD><CODE>ADoCommand</CODE><TD>Commands for performing operations: <CODE>TSketcher::TrackMouse</CODE><TR>
<TD><CODE>AInit</CODE><TD>Functions used only when the application is launched: <CODE>I<I>YourApplication</I></CODE><TR>
<TD><CODE>ANonRes</CODE>,<P><CODE>ANonRes2</CODE>, ...<TD>Most routines should be nonresident, so most applications need more than one segment for nonresident code<TR>
<TD><CODE>AOpen</CODE><TD>Routines for opening documents and data structures: <CODE>DoMakeViews</CODE>, <CODE>DoMakeWindows</CODE>, <CODE>I<I>YourDocument</I></CODE>, <CODE>DoMakeDocument</CODE>, <CODE>I<I>YourView</I></CODE><TR>
<TD><CODE>AReadFile</CODE><TD>Routines for reading from disk: <CODE>DoRead</CODE>, <CODE>DoInitialState</CODE><TR>
<TD><CODE>ARes</CODE>,<CODE> ARes2</CODE>, ...<TD>Resident routines (called often); code should be resident only if calling it must not move memory (for example, <CODE>memcpy</CODE>), or if it is called every time through the event loop (such as <CODE>GetSleepTime</CODE>): <CODE>DoSetCursor</CODE>, <CODE>DoIdle</CODE><TR>
<TD><CODE>ASelCommand</CODE><TD>Code that determines which command to perform in response to an event<TR>
<TD><CODE>ATerminate</CODE><TD>Functions used only when the application is terminated<TR>
<TD><CODE>AWriteFile</CODE><TD>Routines for saving files to disk: <CODE>DoNeedDiskSpace</CODE>, <CODE>DoWrite</CODE><TR>
<TD><CODE>MADebugger</CODE><TD>MacApp debugging code (generated by <CODE>qDebug</CODE>, <CODE>qUserFlag[1-3]</CODE>)<TR>
<TD><CODE>Main</CODE><TD>Main resident segment; contains system library routines and crucial code for starting the application</TABLE>
</B><P>
<A NAME=HEADING31-34></A>
<H3><A NAME=MARKER-2-216></A><A NAME=MARKER-9-217></A>Remapping Segment Names</H3>
 If your application follows the segment-naming convention described in the previous section, you may be surprised to find that a segment name you used is nowhere to be seen in a link map for the application. (The next section describes how to create a link map.) The likely explanation is that, in fine tuning its segmentation, MacApp remapped your segment name.<P>
 Information about how MacApp remaps segment names can be found in the file <CODE>{MADependencies}Definitions_68K</CODE>, which is described in <A HREF=MacAppProgGuide-148.html#MARKER-9-10>Appendix A</A>. For example, <CODE><A NAME=MARKER-2-219></A>Definitions_68K</CODE> contains the following lines:<P>
<PRE>
   -sn AReadFile=GReadFile <img src = "delta.gif" BORDER=NONE>
   -sn MAFileRead=GReadFile <img src = "delta.gif" BORDER=NONE>
</PRE>
 These lines indicate that any functions placed by a <CODE>#pragma</CODE> statement in the segment <CODE>AReadFile</CODE> will be remapped to the segment <CODE>GReadFile</CODE> (or Global Read File), as will any functions placed in the segment <CODE>MAFileRead</CODE>. So any code you place in the <CODE>AReadFile</CODE> segment ends up in the same segment as MacApp's file-reading code.<P>
<DL>
<DT><B>Note</B>
<DD><CODE>{MADependencies}</CODE> is a notation used in the MPW programming environment. When you execute a command line containing "<CODE>{MADependencies}</CODE>" (without the quotation marks) in the MPW worksheet, the expression is expanded to the full directory name of the MacApp Dependencies folder, for example, <CODE>YourHardDisk:MacApp:Tools:Dependencies.</CODE><EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
 Segment remapping can be a source of confusion. For example, you might place a small number of functions in a segment, then get a link error that the segment has overflowed. The explanation may be that your code has been remapped to a segment that was already nearly full with other code.<P>
 On the plus side, you can use segment remapping as a tool to fine tune your code segmentation. It is usually easier to add or change <CODE>-sn</CODE> segment directives (in the <CODE>OtherSegMappings</CODE> section of your application's <CODE>MAMake</CODE> file) than to modify a potentially large number of <CODE>#pragma</CODE> statements located throughout your code. For more information see <A HREF=MacAppProgGuide-124.html#MARKER-9-52>"Recipe--Defining Segment Names for Your Application," beginning on page 553</A>.<P>
<A NAME=HEADING31-42></A>
<H3><A NAME=MARKER-9-220></A>Creating a Link Map</H3>
 To determine the exact segment location of each routine in your application, you can create a link map. With MPW and the MABuild tool, for example, you create a link map by building your application with a line like the following:<P>
<PRE>
MABuild -link -map [other options] YourAppName &gt; YourAppName.map
</PRE>
 The resulting link map file is named <I>YourAppName<CODE>.map</CODE></I>. <A HREF=MacAppProgGuide-148.html#MARKER-9-10>Appendix A</A> describes how to build an application with the MABuild tool. The <I>Macintosh Programmer Workshop Referenc</I>e provides information on link options.<P>
<A NAME=HEADING31-46></A>
<H3><A NAME=MARKER-2-221></A><A NAME=MARKER-9-222></A>The 'seg!' Resource</H3>
 MacApp uses the <CODE>'seg!'</CODE> resource to store information about segmentation. A <CODE>'seg!'</CODE> resource contains a list of the segment names the application has in memory at the point of greatest memory usage. Greatest memory usage usually occurs when printing, or when launching the application to open or print an existing document.<P>
 MacApp uses the information in the <CODE>'seg!'</CODE> resource in calculating the memory requirements for the application (see <A HREF=MacAppProgGuide-44.html#MARKER-9-151>page 65</A>). MacApp defines its own <CODE>'seg!'</CODE> resource in the file <CODE>defaults.r</CODE>:<P>
<PRE>
#if !qPowerPC
resource 'seg!' (kDefaultSegResource,
#if qNames
   &quot;Default seg!&quot;,
#endif
   purgeable) {
   {  &quot;GNonRes&quot;;
      &quot;GClipboard&quot;;
      &quot;GClose&quot;;
      &quot;GFile&quot;;
      &quot;GOpen&quot;;
      &quot;GSelCommand&quot;;
      &quot;GDoCommand&quot;;
      &quot;BBNonRes&quot;;
      &quot;BBOpen&quot;;
      &quot;GNonRes2&quot;;
      &quot;GPrint&quot;;
      &quot;GReadResource&quot;;
   };
};
#endif qPowerPC
</PRE>
 Note that this resource is defined only if the application is <I>not</I> built for a Power Macintosh (<CODE>#if !qPowerPC</CODE>).<P>
 An application can have more than one <CODE>'seg!'</CODE> resource, so you have two options in specifying the segments your application uses at its point of greatest memory usage:<P>
<UL>
<LI>Include MacApp's <CODE>'seg!'</CODE> resource, along with one you define.
<LI>Add the segments from MacApp's <CODE>'seg!'</CODE> resource (or just the ones you know your application needs) to your <CODE>'seg!'</CODE> resource.<A NAME=MARKER-2-223></A><P>
</UL>
<DL>
<DT><B>Note</B>
<DD>When including MacApp segments, be sure to use MacApp's remapped segment names.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
<A NAME=HEADING31-55></A>
<H3><A NAME=MARKER-2-224></A><A NAME=MARKER-9-225></A>The 'res!' Resource</H3>
 The <CODE>'res!'</CODE> resource defines those segments that should <I>always</I> be resident in the heap. (MacApp makes a segment permanently resident with the global routine <CODE>SetResidentSegment</CODE>.) Memory used by resident segments is unavailable for other operations throughout the life of the application, so you should avoid unnecessarily making a segment resident.<P>
<DL>
<DT><B>Note</B>
<DD>Resident segments are loaded into the application's heap during initialization and locked, so that they are always available while the application is running. For this reason it is very likely that every segment present in a <CODE>'res!'</CODE> resource will also be listed in a <CODE>'seg!'</CODE> resource.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
 In general, you put code in a resident segment because you can't afford to have a segment load occur when you call that code or because the code is called frequently (for example, every time through the event loop). You might make a segment resident if it contains functions that are called during interrupt time, when a segment can't be loaded.<P>
 You can minimize the number of resident segments (and avoid segment loading) by putting routines that call each other in the same segment so that the calls will not require the use of a jump table. However, routines declared as <CODE>virtual</CODE> are always dispatched through the jump table.<P>
 MacApp defines a <CODE>'res!'</CODE> resource in the file <CODE>Memory.r</CODE>. An application can have more than one <CODE>'res!'</CODE> resource, so you can add to MacApp's resident segments by adding your own <CODE>'res!'</CODE> resource, as the IconEdit sample application does in the file <CODE>IconEdit.r</CODE>:<P>
<PRE>
#if !qPowerPC
resource 'res!' (kIconEditApp,
#if qNames
   &quot;IconEditApp&quot;,
#endif
   purgeable) {
   {  &quot;ARes&quot;;
   };
};
#endif qPowerPC
</PRE>
<DL>
<DT><B>Note</B>
<DD>A detailed technical discussion of MacApp segmentation issues can be found in the technical note "PT 21--MacApp Segmentation Illuminations," available from Apple Developer Technical Services.<EM></EM><A NAME=MARKER-9-226></A>  <IMG ALIGN = BOTTOM SRC = "graphics/diamond.gif">
</DL>
</BLOCKQUOTE>
<HR>
<center>
<A HREF="MacAppProgGuide-30.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="MacAppProgGuide-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="MacAppProgGuide-158.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="MacAppProgGuide-32.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="MacAppProgGuide-3.html">&copy; Apple Computer, Inc.</A><br>25 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>  
