<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>Resolution Independence Guidelines: Supporting Resolution Independence</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Supporting Resolution Independence"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP40003409-CH5" title="Supporting Resolution Independence"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../index.html#//apple_ref/doc/uid/TP30000440-TP30000437" target="_top">User Experience</a> &gt; <a href="../../../Carbon-date.html#//apple_ref/doc/uid/TP30000440-TP30000437-TP30000494" target="_top">Carbon</a> &gt; <a href="../Introduction/Introduction.html#//apple_ref/doc/uid/TP40003409-CH4-DontLinkElementID_50">Resolution Independence Guidelines</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../HiDPIConcepts/HiDPIConcepts.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../HiDPIArt/HiDPIArt.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP40003409-CH5-SW1" title="Supporting Resolution Independence"></a><h1>Supporting Resolution Independence</h1><p>This chapter describes how to start adapting your application to take advantage of resolution independence.</p>
<!-- This template is being used for both PDF and HTML. -->

    
    <h4>In this section:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="HiDPISupport.html#//apple_ref/doc/uid/TP40003409-CH5-DontLinkElementID_22">Supporting Resolution Independence in Cocoa</a>
				
			<br/>
			
        
			
			
				<a href="HiDPISupport.html#//apple_ref/doc/uid/TP40003409-CH5-DontLinkElementID_28">Supporting Resolution Independence in Carbon</a>
				
			<br/>
			
        
			
			
				<a href="HiDPISupport.html#//apple_ref/doc/uid/TP40003409-CH5-DontLinkElementID_36">Resolution Independence Support in Java</a>
				
			<br/>
			
        
			
			
				<a href="HiDPISupport.html#//apple_ref/doc/uid/TP40003409-CH5-DontLinkElementID_37">Accessing the Scaling Transform</a>
				
			<br/>
			
        
			
			
				<a href="HiDPISupport.html#//apple_ref/doc/uid/TP40003409-CH5-DontLinkElementID_38">Other Issues</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP40003409-CH5-DontLinkElementID_22" title="Supporting Resolution Independence in Cocoa"></a><h2>Supporting Resolution Independence in Cocoa</h2><p>Cocoa applications require little work to support resolution independence because the Cocoa frameworks handle the scaling for you. However, depending on how you manipulate windows and the views within them, you may need to make some changes. Of course, in addition to code changes, you may need to provide higher-resolution versions of any custom artwork.</p><p>Because of scaling, the coordinates of the window frame and its top-level view (the frame view) are not always the same. For example, say you have a window frame view with dimensions 80 x 80 points. If the scale factor is 1.0, there is a 1 : 1 correspondence between the units of the frame view and its owning window; that is, the window is displayed as being 80 x 80 pixels. However, if the scale factor is 1.25, the window size is displayed 25% larger, resulting in a 100 x 100 pixel window. Any calls that return the size of the window return 100 x 100.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40003409-CH5-DontLinkElementID_46" title="Note"></a><p><strong>Note:</strong>&nbsp;In the resolution-independent world, all Cocoa views are scaled if the scale factor is not 1.0; however, if the scaling for a view is due only to the scale factor, the <code>NSView</code> method <code><a href="../../../../Cocoa/Reference/ApplicationKit/Classes/NSView_Class/Reference/NSView.html#//apple_ref/occ/instm/NSView/isRotatedOrScaledFromBase" target="_top">isRotatedOrScaledFromBase</a></code> returns <code>NO</code>. This result minimizes possible overhead from scrolling and similar operations.</p></div><p>An application must not assume that the window frame and the view frames within the window use the same coordinate system. For example, an application that positions a view based on the window frame does not always get correct results. </p><a name="//apple_ref/doc/uid/TP40003409-CH5-DontLinkElementID_23" title="Resolution-Independent Compositing"></a><h3>Resolution-Independent Compositing</h3><p>Historically, compositing was done in the base coordinate system of the image being rendered, regardless of the coordinate system of the owning view. To allow compositing to support resolution independence, you can assume that all base coordinates are transformed by the current scale factor. </p><p>Here are some common cases.</p><ol class="ol"><li class="li"><p>Compositing a 72 dpi 100 x 100 source image in a 1.25 scale factor window.</p><p>A 72 dpi 100 x 100 image (stored in an <code><a href="../../../../Cocoa/Reference/ApplicationKit/Classes/NSImageRep_Class/Reference/Reference.html#//apple_ref/occ/cl/NSImageRep" target="_top">NSImageRep</a></code> object) contains 100 x 100 pixels. When composited into a view in a scaled window, the image is scaled to fill 125 x 125 pixels using the proper interpolation algorithm. Any coordinate transforms on the destination view (aside from the window scaling) are ignored. </p></li><li class="li"><p>Compositing a 90 dpi 100 x 100 source image in a 1.25 scale factor window.</p><p>A 90 dpi 100 x 100 image contains 125 x 125 pixels. When composited into a view in a scaled window, this image (rendered from an <code><a href="../../../../Cocoa/Reference/ApplicationKit/Classes/NSCachedImageRep_Class/Reference/Reference.html#//apple_ref/occ/cl/NSCachedImageRep" target="_top">NSCachedImageRep</a></code> object) contains 125 x 125 pixels, so no interpolation is needed. Any coordinate transforms on the destination view (aside from the window scaling) are ignored. </p></li><li class="li"><p>Creating an <code>NSCachedImageRep</code> object from a 72 dpi 100 x 100 source image to display in a 1.25 scale factor window.</p><p>A 72 dpi 100 x 100 source image contains 100 x 100 pixels. The <code>NSCachedImageRep</code> object is created with a size of 100 x 100, but holds 125 x 125 pixels because of the scale factor. The source image is scaled to fit the required pixel size using the proper interpolation algorithm. When the cached image is drawn, the pixels are copied 1 to 1 from the cached image to the destination window. </p></li></ol><a name="//apple_ref/doc/uid/TP40003409-CH5-DontLinkElementID_24" title="Cocoa Bitmapped Images"></a><h3>Cocoa Bitmapped Images</h3><p>Each <code>NSImageRep</code> object that contains bitmapped data indicates its resolution (dots-per-inch) because the image size is defined in points as well as in pixel width and height. A 72 dpi <code>NSImageRep</code> object  has a 1 : 1 correspondence between points and pixels, while a 144 dpi <code>NSImageRep</code> object  has a 1 : 2 correspondence between points and pixels. <code>NSCachedImageRep</code> objects are stored already scaled to the destination window; for example, a 100 x 100 <code>NSCachedImageRep</code> for a window with a scale factor of 1.25 would report a size of 100 x 100 points, but pixel dimensions of 125 x 125.</p><a name="//apple_ref/doc/uid/TP40003409-CH5-DontLinkElementID_25" title="Detecting the Scale Factor"></a><h3>Detecting the Scale Factor</h3><p>Cocoa supports several methods that your application can use to obtain scale factor information. It should be noted that most Cocoa applications do not need to use these methods.</p><p>To obtain the global scale factor (as set in Quartz Debug), use the <code><a href="../../../../Cocoa/Reference/ApplicationKit/Classes/NSScreen_Class/Reference/Reference.html#//apple_ref/occ/instm/NSScreen/userSpaceScaleFactor" target="_top">userSpaceScaleFactor</a></code> method in the <code><a href="../../../../Cocoa/Reference/ApplicationKit/Classes/NSScreen_Class/Reference/Reference.html#//apple_ref/occ/cl/NSScreen" target="_top">NSScreen</a></code> class:</p><div class="codesample"><table><tr><td scope="row"><pre>@interface NSScreen : NSObject<span></span></pre></td></tr><tr><td scope="row"><pre>...<span></span></pre></td></tr><tr><td scope="row"><pre>- (CGFloat)userSpaceScaleFactor;<span></span></pre></td></tr><tr><td scope="row"><pre>...<span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr></table></div><p>To obtain the scale factor for a particular window, use the <code><a href="../../../../Cocoa/Reference/ApplicationKit/Classes/NSWindow_Class/Reference/Reference.html#//apple_ref/occ/instm/NSWindow/userSpaceScaleFactor" target="_top">userSpaceScaleFactor</a></code> method in the <code><a href="../../../../Cocoa/Reference/ApplicationKit/Classes/NSWindow_Class/Reference/Reference.html#//apple_ref/occ/cl/NSWindow" target="_top">NSWindow</a></code> class:</p><div class="codesample"><table><tr><td scope="row"><pre>@interface NSWindow : NSResponder<span></span></pre></td></tr><tr><td scope="row"><pre>...<span></span></pre></td></tr><tr><td scope="row"><pre>- (CGFloat)userSpaceScaleFactor;<span></span></pre></td></tr><tr><td scope="row"><pre>...<span></span></pre></td></tr><tr><td scope="row"><pre>@end<span></span></pre></td></tr></table></div><p>If you want to create a window that should not be scaled (for example, a custom window), you can specify the <code><a href="../../../../Cocoa/Reference/ApplicationKit/Classes/NSWindow_Class/Reference/Reference.html#//apple_ref/c/econst/NSUnscaledWindowMask" target="_top">NSUnscaledWindowMask</a></code> mask at window creation time. For unscaled windows, the <code>userSpaceScaleFactor</code> method returns 1.0.</p><a name="//apple_ref/doc/uid/TP40003409-CH5-SW2" title="Coordinate Conversion in Cocoa"></a><h3>Coordinate Conversion in Cocoa</h3><p>To support resolution independence, you may need to convert rectangles or points from the coordinate system of one <code>NSView</code> instance to another (typically the superview or subview), or from one <code>NSView</code> instance to the containing window. The <code><a href="../../../../Cocoa/Reference/ApplicationKit/Classes/NSView_Class/Reference/NSView.html#//apple_ref/occ/cl/NSView" target="_top">NSView</a></code> class defines six methods that convert rectangles, points, and sizes in either direction:</p><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Convert to the receiver from the specified view</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Convert from the receiver to the specified view</p></th></tr><tr><td  scope="row"><p><code>convertPoint:fromView:</code></p></td><td ><p><code>convertPoint:toView:</code></p></td></tr><tr><td  scope="row"><p><code>convertRect:fromView:</code></p></td><td ><p><code>convertRect:toView:</code></p></td></tr><tr><td  scope="row"><p><code>convertSize:fromView:</code></p></td><td ><p><code>convertSize:toView:</code></p></td></tr></table></div><p>The <code>convert...:fromView:</code> methods convert the values to the receiver's coordinate system, from the coordinate system of the view passed as the second parameter. If <code>nil</code> is passed as the view, the values are assumed to be in the window's base coordinate system and are converted to the receiver's coordinate system. The <code>convert..:toView:</code> methods do the inverse, converting values in the receiver's coordinate system to the coordinate system of the view passed as a parameter. If the view parameter is <code>nil</code>, the values are converted to the base coordinate system of the receiver's window.</p><p>For converting to and from the screen coordinate system, <code>NSWindow</code> defines the <code>convertBaseToScreen:</code> and <code>convertScreenToBase:</code> methods.</p><p>For more information about coordinate conversion in views, see the chapter <span class="content_text"><a href="../../../../Cocoa/Conceptual/CocoaViewsGuide/WorkingWithAViewHierarchy/WorkingWithAViewHierarchy.html#//apple_ref/doc/uid/TP40002978-CH4" target="_top">Working with the View Hierarchy</a></span> in <em><a href="../../../../Cocoa/Conceptual/CocoaViewsGuide/index.html#//apple_ref/doc/uid/TP40002978" target="_top">View Programming Guide for Cocoa</a></em>. The chapter <span class="content_text"><a href="../../../../Cocoa/Conceptual/CocoaDrawingGuide/Transforms/Transforms.html#//apple_ref/doc/uid/TP40003290-CH204" target="_top">Coordinate Systems and Transforms</a></span>  in <em><a href="../../../../Cocoa/Conceptual/CocoaDrawingGuide/index.html#//apple_ref/doc/uid/TP40003290" target="_top">Cocoa Drawing Guide</a></em> may also be helpful.</p><a name="//apple_ref/doc/uid/TP40003409-CH5-DontLinkElementID_26" title="Coordinate Conversion in Mac OS X v10.5"></a><h4>Coordinate Conversion in Mac OS X v10.5</h4><p>In Mac OS X v10.5, <code>NSView</code> provides a new set of methods that should be used when performing pixel alignment of view content. These methods provide the means to transform geometry to and from a base coordinate space that is pixel-aligned with the backing store into which the view is being drawn.</p><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Convert to the base coordinate system</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Convert from the base coordinate system</p></th></tr><tr><td  scope="row"><p><code>convertPointToBase:</code></p></td><td ><p><code>convertPointFromBase:</code></p></td></tr><tr><td  scope="row"><p><code>convertSizeToBase:</code></p></td><td ><p><code>convertSizeFromBase:</code></p></td></tr><tr><td  scope="row"><p><code>convertRectToBase:</code></p></td><td ><p><code>convertRectFromBase:</code></p></td></tr></table></div><p>These new coordinate transform methods provide a way to abstract view content drawing code from the details of particular backing store configurations, and always achieve correct pixel alignment without having to special-case for layer-backed vs. conventional view rendering mode.</p><p>For more information, see <em><a href="../../../../../releasenotes/Cocoa/AppKit.html#//apple_ref/doc/uid/TP30000741" target="_top">Application Kit Release Notes (10.5)</a></em>.</p><a name="//apple_ref/doc/uid/TP40003409-CH5-DontLinkElementID_27" title="Changes to the deviceDescription Method"></a><h3>Changes to the deviceDescription Method</h3><p>Both the <code>NSWindow</code> and <code>NSScreen</code> classes define a <code>deviceDescription</code> method. This method returns a dictionary containing a <code>NSDeviceResolution</code> key. The <code>NSDeviceResolution</code> key has historically contained an <code>NSSize</code> value of (72.0, 72.0). In Mac OS X v10.4 and later, <code>NSDeviceResolution</code> contains an <code>NSSize</code> value of (72.0 * scale factor, 72.0 * scale factor).</p><a name="//apple_ref/doc/uid/TP40003409-CH5-DontLinkElementID_28" title="Supporting Resolution Independence in Carbon"></a><h2>Supporting Resolution Independence in Carbon</h2><p>Carbon applications have two scaling options: framework-scaled mode and magnified mode. You set these modes on a window-by-window basis by setting the appropriate attribute at window creation time. If you do not select a scale mode, the system assumes magnified mode by default. You can specify the scale mode of a window only at window creation time. </p><a name="//apple_ref/doc/uid/TP40003409-CH5-DontLinkElementID_29" title="Framework-Scaled Mode"></a><h3>Framework-Scaled Mode</h3><p>As described previously, a window can use the framework-scaled mode if it uses HIView-based controls (that is, it uses compositing mode) and draws exclusively with Quartz. At drawing time, a scaling transform is applied to the Quartz context used by the views. Also, in order to support older functions, any window coordinate information (window bounds, mouse position, and so on) is automatically translated to reflect the proper window- or view-centric origin before being passed to the application.</p><p>A major benefit of framework-scaled mode is that windows loaded from nib files automatically work at all scale factors with no need to reposition their contents. </p><p>You specify framework-scaled mode by setting the <code><a href="../../../../Carbon/Reference/Window_Manager/Reference/reference.html#//apple_ref/c/econst/kWindowFrameworkScaledAttribute" target="_top">kWindowFrameworkScaledAttribute</a></code> attribute at window creation time or by choosing Framework Scaled for the Scaling popup button in the window inspector in Interface Builder version 2.5 and later. </p><p>While specifying framework-scaled mode means most of the scaling work is handled for you, you still need to supply higher-resolution versions of any custom artwork, such as icons, background images, and so on.</p><a name="//apple_ref/doc/uid/TP40003409-CH5-DontLinkElementID_30" title="Magnified Mode"></a><h3>Magnified Mode</h3><p>Magnified mode is the default rendering mode. If the scale factor is not 1.0, all windows that are not tagged as being in framework-scaled mode are scaled in magnified mode. As described previously, the window is simply scaled to match the scale factor. </p><div class="importantbox"><a name="//apple_ref/doc/uid/TP40003409-CH5-DontLinkElementID_47" title="Important:"></a><p><strong>Important:</strong>&nbsp;Because magnified windows do not look as crisp as properly scaled windows, you should adopt framework scaling as soon as possible.</p><p></p></div><p>In magnified mode, all onscreen coordinates are mapped to their user space equivalents when passed to the application. For example, if the scale factor is 2.0, a mouse click onscreen at a particular pixel is mapped to its window or view-centric equivalent location when passed in a mouse-down event.</p><a name="//apple_ref/doc/uid/TP40003409-CH5-DontLinkElementID_31" title="Detecting Scale Information"></a><h3>Detecting Scale Information</h3><p>To determine the scale factor for your application, you can use the <code><a href="../../../../Carbon/Reference/HIGeometryRef/Reference/reference.html#//apple_ref/c/func/HIGetScaleFactor" target="_top">HIGetScaleFactor</a></code> function:</p><div class="codesample"><table><tr><td scope="row"><pre>CGFloat HIGetScaleFactor (void);<span></span></pre></td></tr></table></div><p>If you need to determine the scale mode for a particular window (and also the application scale factor), you can call the <code><a href="../../../../Carbon/Reference/Window_Manager/Reference/reference.html#//apple_ref/c/func/HIWindowGetScaleMode" target="_top">HIWindowGetScaleMode</a></code> function:</p><div class="codesample"><table><tr><td scope="row"><pre>OSStatus HIWindowGetScaleMode (<span></span></pre></td></tr><tr><td scope="row"><pre>    HIWindowRef inWindow,<span></span></pre></td></tr><tr><td scope="row"><pre>    HIWindowScaleMode *outMode,<span></span></pre></td></tr><tr><td scope="row"><pre>    CGFloat *outScaleFactor);<span></span></pre></td></tr></table></div><p>On output, <code>outMode</code> returns one of the following values:</p><dl class="termdef">	<dt><code>kHIWindowScaleModeUnscaled</code></dt><dd><p>The window is not scaled at all because the scale factor is 1.0.</p></dd><dt><code>kHIWindowScaleModeMagnified</code></dt><dd><p>The window‘s backing store is being magnified because the scale factor is not equal to 1.0 and because the window was not created with the framework-scaled attribute.</p></dd><dt><code>kHIWindowScaleModeFrameworkScaled</code></dt><dd><p>The window‘s contents are scaled to match the scale factor because the scale factor is not equal to 1.0 and because the window was created with the framework-scaled attribute.</p></dd></dl><div class="notebox"><a name="//apple_ref/doc/uid/TP40003409-CH5-DontLinkElementID_48" title="Note"></a><p><strong>Note:</strong>&nbsp;A fourth scale mode named <code>kHIWindowScaleModeApplicationScaled</code> was available in Mac OS X v10.4 but was never fully implemented and is not supported at all in Mac OS X v10.5 and later.</p></div><a name="//apple_ref/doc/uid/TP40003409-CH5-SW3" title="Coordinate Conversion in Carbon"></a><h3>Coordinate Conversion in Carbon</h3><p>Because the scale mode in Carbon applications can be on a window-by-window basis, you may often need to convert between the various coordinate systems involved. The HIGeometry programming interface (see <em><a href="../../../../Carbon/Reference/HIGeometryRef/index.html#//apple_ref/doc/uid/TP40004402" target="_top">HIGeometry Reference</a></em>) provides three functions that simplify conversion:</p><ul class="spaceabove"><li class="li"><p><code><a href="../../../../Carbon/Reference/HIGeometryRef/Reference/reference.html#//apple_ref/c/func/HIPointConvert" target="_top">HIPointConvert</a></code> to translate an <code><a href="../../../../Carbon/Reference/HIGeometryRef/Reference/reference.html#//apple_ref/c/tdef/HIPoint" target="_top">HIPoint</a></code> structure.</p></li><li class="li"><p><code><a href="../../../../Carbon/Reference/HIGeometryRef/Reference/reference.html#//apple_ref/c/func/HIRectConvert" target="_top">HIRectConvert</a></code> to translate an <code><a href="../../../../Carbon/Reference/HIGeometryRef/Reference/reference.html#//apple_ref/c/tdef/HIRect" target="_top">HIRect</a></code> structure. Note that the <code>HIRect</code> structure has an organization different from that of the older QuickDraw <code>Rect</code> structure.</p></li><li class="li"><p><code><a href="../../../../Carbon/Reference/HIGeometryRef/Reference/reference.html#//apple_ref/c/func/HISizeConvert" target="_top">HISizeConvert</a></code> to translate an <code><a href="../../../../Carbon/Reference/HIGeometryRef/Reference/reference.html#//apple_ref/c/tdef/HISize" target="_top">HISize</a></code> structure. </p></li></ul><p>These conversion functions require you to specify the source and destination coordinate spaces as well as any associated objects, if required. For example, if you wanted to translate a point into view coordinates, you must specify the HIView to which the coordinates refer. You specify the coordinate spaces by passing the following constants:</p><ul class="spaceabove"><li class="li"><p><code>kHICoordSpace72DPIGlobal</code>, which specifies the old global coordinate system defined by QuickDraw. When the scale factor is 1.0, this space is equivalent to <code>kHICoordSpaceScreenPixel</code>.</p></li><li class="li"><p><code>kHICoordSpaceScreenPixel</code>, which is the coordinate space defined by the actual screen pixels. </p></li><li class="li"><p><code>kHICoordSpaceWindow</code>, which specifies a window-centric coordinate system, with the origin (0,0) being the top-left corner of the window's structure region. </p></li><li class="li"><p><code>kHICoordSpaceView</code>, which specifies an HIView-centric coordinate system. The origin (0,0) is the top-left corner of the view. </p></li></ul><p>The conversion functions take floating-point coordinates, which means that rounding may be necessary in certain cases. Which way to round depends on whether the system is more forgiving of overstating or understating the value. For example:</p><ul class="spaceabove"><li class="li"><p>When the coordinate is used to define some sort of maximal area, you should outset the value. That is, round the value so that it defines a larger area rather a smaller one. For example, you should outset coordinate values that define a view's structure shape, because that area defines the maximum bounds into which the view can draw. </p></li><li class="li"><p>When defining a minimal area, you should inset the value. For example, you should inset the coordinate values for a view's opaque region, because that area defines the largest area that can be assumed to be opaque.</p></li></ul><p>You can use the Quartz 2D functions <code><a href="../../../../GraphicsImaging/Reference/CGGeometry/Reference/reference.html#//apple_ref/c/func/CGRectInset" target="_top">CGRectInset</a></code> and <code><a href="../../../../GraphicsImaging/Reference/CGGeometry/Reference/reference.html#//apple_ref/c/func/CGRectIntegral" target="_top">CGRectIntegral</a></code> to simplify inset and outset operations. The BSD Library functions <code>ceil</code> and <code>floor</code> (available in <code>math.h</code>) may also be useful. </p><p>Keep in mind that <code><a href="../../../../Carbon/Reference/HIShape_Reference/Reference/reference.html#//apple_ref/c/tdef/HIShapeRef" target="_top">HIShapeRef</a></code> values take only integer coordinates. If you attempt to create a shape from floating-point coordinates (for example, by calling <code><a href="../../../../Carbon/Reference/HIShape_Reference/Reference/reference.html#//apple_ref/c/func/HIShapeCreateWithRect" target="_top">HIShapeCreateWithRect</a></code> on an <code>HIRect</code> object), the call automatically rounds any non-integer coordinates to outset the shape. To avoid unexpected results, you should round any coordinates appropriately (inset or outset) before creating an HIShape based upon it.</p><a name="//apple_ref/doc/uid/TP40003409-CH5-DontLinkElementID_32" title="Custom Drawing in Carbon"></a><h3>Custom Drawing in Carbon</h3><p>If your application uses custom controls or menus, you may need to make some changes to make them compatible with resolution independence.</p><a name="//apple_ref/doc/uid/TP40003409-CH5-DontLinkElementID_33" title="Custom Controls"></a><h4>Custom Controls</h4><p>If you are still using QuickDraw to draw, you should adopt Quartz. If you are using the Appearance Manager to draw control elements, use HITheme (which is Quartz-savvy) instead. </p><p>In framework-scaled mode, the Quartz context passed to your custom view in the <code>kEventControlDraw</code> event has already been transformed to match the scale factor, so you probably won't need to update your drawing code.</p><a name="//apple_ref/doc/uid/TP40003409-CH5-DontLinkElementID_34" title="Custom Menus"></a><h4>Custom Menus</h4><p>If your application still uses custom MDEFs, the Menu Manager creates windows to hold them and scales them appropriately, so they are effectively in magnified mode. However, you should consider updating your MDEFs to custom HIView-based menus. </p><p>When using view-based menus, the Menu Manager can automatically scale them in framework-scaled mode. Currently a workaround exists that allows <code>kEventMenuDrawItem</code> and <code>kEventMenuDrawItemContent</code> handlers to use QuickDraw calls even in framework-scaled mode. The standard menu view creates a temporary <code>GWorld</code> object and sets it to the current QuickDraw port before sending any menu drawing events. After the draw event, the Menu Manager copies the contents of the graphics world into the view. However, this workaround should be considered a temporary fix and you should plan to update your menu drawing handlers to draw into the supplied <code>CGContext</code> event parameter. </p><a name="//apple_ref/doc/uid/TP40003409-CH5-DontLinkElementID_35" title="Unsupported Technologies"></a><h3>Unsupported Technologies</h3><p>The following Carbon technologies will not be updated to support resolution independence:</p><ul class="spaceabove"><li class="li"><p>TextEdit. Applications should use MLTE, the editable Unicode text control, or HITextView instead.</p></li><li class="li"><p>The edit text control. Applications should use the editable Unicode text control or HITextView instead.</p></li><li class="li"><p>The list box control. Applications should use the data browser control instead.</p></li></ul><a name="//apple_ref/doc/uid/TP40003409-CH5-DontLinkElementID_36" title="Resolution Independence Support in Java"></a><h2>Resolution Independence Support in Java</h2><p>Java SE (Standard Edition) 6 in Mac OS X v10.5 supports resolution independence at runtime. </p><p>All drawing is done in framework-scaled mode. Text, vector drawing, and most system controls are drawn correctly scaled with no additional work on your part. Any bitmap images are magnified to fit the designated space. </p><p>All Java drawing methods (and their associated parameters) interpret coordinates as points, not pixels. Currently, no resolution independence–specific methods exist.</p><a name="//apple_ref/doc/uid/TP40003409-CH5-DontLinkElementID_37" title="Accessing the Scaling Transform"></a><h2>Accessing the Scaling Transform</h2><p>Even if you rely on framework scaling, there may be cases where you want to know in advance how to scale your content. To do so, you can use the Quartz 2D function <code><a href="../../../../GraphicsImaging/Reference/CGContext/Reference/reference.html#//apple_ref/c/func/CGContextGetUserSpaceToDeviceSpaceTransform" target="_top">CGContextGetUserSpaceToDeviceSpaceTransform</a></code>. </p><div class="codesample"><table><tr><td scope="row"><pre>CGAffineTransform CGContextGetUserSpaceToDeviceSpaceTransform (<span></span></pre></td></tr><tr><td scope="row"><pre>    CGContextRef theContext);<span></span></pre></td></tr></table></div><p>This call returns the transform matrix used to resize your window, converting from user space (that is, where you draw into the context) to the coordinate space of the display device. For example, you may want to transform your window to device space to determine the new coordinates of its elements. You can adjust these coordinates to make sure that window elements line up correctly, then do a reverse transform to obtain the user space coordinates needed for the best presentation at that scale factor. </p><div class="notebox"><a name="//apple_ref/doc/uid/TP40003409-CH5-DontLinkElementID_49" title="Note"></a><p><strong>Note:</strong>&nbsp;The transform you receive describes the sum of all the transformations applied to the graphics context, not just the scaling. For example, the transform includes any rotation or translation applied to the context. </p></div><p>For simple conversions between user space and device space, you can also use one of the Quartz conversion functions described in <em><a href="../../../../GraphicsImaging/Reference/CGContext/index.html#//apple_ref/doc/uid/TP30000950" target="_top">CGContext Reference</a></em>. These functions convert only global coordinates, so you need to perform additional calculations to translate the results to view-centric coordinates.</p><a name="//apple_ref/doc/uid/TP40003409-CH5-DontLinkElementID_38" title="Other Issues"></a><h2>Other Issues</h2><a name="//apple_ref/doc/uid/TP40003409-CH5-DontLinkElementID_39" title="Cross-Process Communication"></a><h3>Cross-Process Communication</h3><p>If your application interacts with other applications, you need to make sure that all the applications agree on the coordinate system; otherwise, strange behavior may result.</p><p>Apple’s accessibility interfaces support resolution independence, so you don’t need to worry about translating between coordinate systems when supporting accessibility. The accessibility interfaces always return coordinates in screen pixels.</p><p>For the accessibility Carbon events that have event parameters containing coordinates, an event handler can ask for the parameter value in either screen pixel or 72DPI global coordinates, depending on which parameter type is used. For example, <code>typeHIPoint</code> and <code>typeHIPoint72DPIGlobal</code> return 72DPI global coordinates, while <code>typeHIPointScreenPixel</code> returns screen pixel coordinates. Similar parameter type constants are available for <code>HIRect</code>, <code>HISize</code>, and <code>CGFloat</code>.</p><a name="//apple_ref/doc/uid/TP40003409-CH5-DontLinkElementID_40" title="OpenGL"></a><h3>OpenGL</h3><p>Most OpenGL problems with resolution independence are caused by a mismatch between the screen pixels and the points of the drawing environment. The Cocoa class <code><a href="../../../../Cocoa/Reference/ApplicationKit/Classes/NSOpenGLView_Class/Reference/Reference.html#//apple_ref/occ/cl/NSOpenGLView" target="_top">NSOpenGLView</a></code> has been updated to handle common problems. If you are drawing directly to the screen (that is, on a pixel-by-pixel basis), you need to obtain the current scale factor and scale all your images manually. </p>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../HiDPIConcepts/HiDPIConcepts.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../HiDPIArt/HiDPIArt.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2007 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2007-05-04<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/UserExperience/Conceptual/HiDPIOverview/HiDPISupport/HiDPISupport.html%3Fid%3DTP40003409-1.1&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/UserExperience/Conceptual/HiDPIOverview/HiDPISupport/HiDPISupport.html%3Fid%3DTP40003409-1.1&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/UserExperience/Conceptual/HiDPIOverview/HiDPISupport/HiDPISupport.html%3Fid%3DTP40003409-1.1&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>