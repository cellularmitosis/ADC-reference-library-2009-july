<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>GLUT - /macx_event.m</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/GraphicsImaging/index.html">Graphics & Imaging</a> &gt; <a href="../../samplecode/GraphicsImaging/idxOpenGL-date.html">OpenGL</a> &gt; <A HREF="javascript:location.replace('index.html');">GLUT</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->


	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">GLUT</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/macx_event.m</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/gle/copy.h</option>
<option value="listing2.html">/gle/ex_angle.c</option>
<option value="listing3.html">/gle/ex_cut_round.c</option>
<option value="listing4.html">/gle/ex_raw.c</option>
<option value="listing5.html">/gle/extrude.c</option>
<option value="listing6.html">/gle/extrude.h</option>
<option value="listing7.html">/gle/gle_osx.h</option>
<option value="listing8.html">/gle/gutil.h</option>
<option value="listing9.html">/gle/intersect.c</option>
<option value="listing10.html">/gle/intersect.h</option>
<option value="listing11.html">/gle/port.h</option>
<option value="listing12.html">/gle/rot.h</option>
<option value="listing13.html">/gle/rot_prince.c</option>
<option value="listing14.html">/gle/rotate.c</option>
<option value="listing15.html">/gle/round_cap.c</option>
<option value="listing16.html">/gle/segment.c</option>
<option value="listing17.html">/gle/segment.h</option>
<option value="listing18.html">/gle/texgen.c</option>
<option value="listing19.html">/gle/tube.h</option>
<option value="listing20.html">/gle/tube_gc.h</option>
<option value="listing21.html">/gle/urotate.c</option>
<option value="listing22.html">/gle/view.c</option>
<option value="listing23.html">/gle/vvector.h</option>
<option value="listing24.html">/glsmap/glsmap.h</option>
<option value="listing25.html">/glsmap/glsmapint.h</option>
<option value="listing26.html">/glsmap/smap_buildsmap.c</option>
<option value="listing27.html">/glsmap/smap_context.c</option>
<option value="listing28.html">/glsmap/smap_create.c</option>
<option value="listing29.html">/glsmap/smap_destroy.c</option>
<option value="listing30.html">/glsmap/smap_drawmesh.c</option>
<option value="listing31.html">/glsmap/smap_flag.c</option>
<option value="listing32.html">/glsmap/smap_get.c</option>
<option value="listing33.html">/glsmap/smap_getfunc.c</option>
<option value="listing34.html">/glsmap/smap_gettexdim.c</option>
<option value="listing35.html">/glsmap/smap_gettexobj.c</option>
<option value="listing36.html">/glsmap/smap_getvec.c</option>
<option value="listing37.html">/glsmap/smap_makemesh.c</option>
<option value="listing38.html">/glsmap/smap_nearfar.c</option>
<option value="listing39.html">/glsmap/smap_origin.c</option>
<option value="listing40.html">/glsmap/smap_render.c</option>
<option value="listing41.html">/glsmap/smap_rvec2st.c</option>
<option value="listing42.html">/glsmap/smap_set.c</option>
<option value="listing43.html">/glsmap/smap_setfunc.c</option>
<option value="listing44.html">/glsmap/smap_setvec.c</option>
<option value="listing45.html">/glsmap/smap_texdim.c</option>
<option value="listing46.html">/glsmap/smap_texobj.c</option>
<option value="listing47.html">/glut.h</option>
<option value="listing48.html">/glut_8x13.c</option>
<option value="listing49.html">/glut_9x15.c</option>
<option value="listing50.html">/glut_bitmap.c</option>
<option value="listing51.html">/glut_bwidth.c</option>
<option value="listing52.html">/glut_cindex.c</option>
<option value="listing53.html">/glut_ext.c</option>
<option value="listing54.html">/glut_hel10.c</option>
<option value="listing55.html">/glut_hel12.c</option>
<option value="listing56.html">/glut_hel18.c</option>
<option value="listing57.html">/glut_mroman.c</option>
<option value="listing58.html">/glut_roman.c</option>
<option value="listing59.html">/glut_shapes.c</option>
<option value="listing60.html">/glut_stroke.c</option>
<option value="listing61.html">/glut_swidth.c</option>
<option value="listing62.html">/glut_teapot.c</option>
<option value="listing63.html">/glut_tr10.c</option>
<option value="listing64.html">/glut_tr24.c</option>
<option value="listing65.html">/glut_vidresize.c</option>
<option value="listing66.html">/GLUTApplication.h</option>
<option value="listing67.html">/GLUTApplication.m</option>
<option value="listing68.html">/glutbitmap.h</option>
<option value="listing69.html">/GLUTClipboardController.h</option>
<option value="listing70.html">/GLUTClipboardController.m</option>
<option value="listing71.html">/glutf90.h</option>
<option value="listing72.html">/GLUTMenu.h</option>
<option value="listing73.html">/GLUTMenu.m</option>
<option value="listing74.html">/GLUTMenuItem.h</option>
<option value="listing75.html">/GLUTMenuItem.m</option>
<option value="listing76.html">/GLUTPreferencesController.h</option>
<option value="listing77.html">/GLUTPreferencesController.m</option>
<option value="listing78.html">/glutstroke.h</option>
<option value="listing79.html">/GLUTView.h</option>
<option value="listing80.html">/GLUTView.m</option>
<option value="listing81.html">/GLUTWindow.h</option>
<option value="listing82.html">/GLUTWindow.m</option>
<option value="listing83.html">/HID_Config_Utilities.c</option>
<option value="listing84.html">/HID_Config_Utilities.h</option>
<option value="listing85.html">/HID_Error_Handler.c</option>
<option value="listing86.html">/HID_Error_Handler.h</option>
<option value="listing87.html">/HID_Name_Lookup.c</option>
<option value="listing88.html">/HID_Name_Lookup.h</option>
<option value="listing89.html">/HID_Queue_Utilities.c</option>
<option value="listing90.html">/HID_Queue_Utilities.h</option>
<option value="listing91.html">/HID_Utilities.c</option>
<option value="listing92.html">/HID_Utilities.h</option>
<option value="listing93.html">/HID_Utilities_External.h</option>
<option value="listing94.html">/HID_Utilities_Internal.h</option>
<option value="listing95.html">/libForeground.a</option>
<option value="listing96.html">/macx_cursor.m</option>
<option value="listing97.html">/macx_dials.m</option>
<option value="listing98.html">/macx_dstr.m</option>
<option value="listing99.html">/macx_event.m</option>
<option value="listing100.html">/macx_fortran.m</option>
<option value="listing101.html">/macx_gamemode.m</option>
<option value="listing102.html">/macx_get.m</option>
<option value="listing103.html">/macx_glut.h</option>
<option value="listing104.html">/macx_init.m</option>
<option value="listing105.html">/macx_input.m</option>
<option value="listing106.html">/macx_joy.m</option>
<option value="listing107.html">/macx_key.m</option>
<option value="listing108.html">/macx_menu.m</option>
<option value="listing109.html">/macx_modifier.m</option>
<option value="listing110.html">/macx_overlay.m</option>
<option value="listing111.html">/macx_space.m</option>
<option value="listing112.html">/macx_swap.m</option>
<option value="listing113.html">/macx_tablet.m</option>
<option value="listing114.html">/macx_util.m</option>
<option value="listing115.html">/macx_utilities.h</option>
<option value="listing116.html">/macx_warp.m</option>
<option value="listing117.html">/macx_win.m</option>
<option value="listing118.html">/ReadMe.txt</option></select>
				</p>
				</form>
				<p><strong><a href="glut.zip">Download Sample</a></strong> (&#147;glut.zip&#148;, 374.3K)<BR>
<strong><a href="glut.dmg">Download Sample</a></strong> (&#147;glut.dmg&#148;, 680.7K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/* Copyright (c) Dietmar Planitzer, 2002 - 2003 */

/* This program is freely distributable without licensing fees 
   and is provided without guarantee or warrantee expressed or 
   implied. This program is -not- in the public domain. */

#import &quot;macx_glut.h&quot;
#import &quot;GLUTApplication.h&quot;
#import &quot;GLUTView.h&quot;
#import &quot;GLUTWindow.h&quot;

GLUTidleCB                __glutIdleFunc = NULL;
GLUTidleFCB                 __fglutIdleFunc = NULL; /* fortran callback */
GLUTTimer *                __glutMostRecentTimer = NULL;
static GLUTTimer *        __glutCachedTimers = NULL;
static int                __glutNumCachedTimers = 0;
static GLUTWorkEvent *    __glutWindowWorkList = NULL;
static GLUTWorkEvent *    __glutCachedWorkEvents = NULL;
static int                __glutNumCachedWorkEvents = 0;
unsigned int            __glutMouseFirstModifiers = kMouseFirstModifiers; /* initial values */
static int                __glutMouseFirstButton = GLUT_RIGHT_BUTTON;
unsigned int            __glutMouseSecondModifiers = kMouseSecondModifiers;
static int                __glutMouseSecondButton = GLUT_MIDDLE_BUTTON;
static unsigned int        __glutMouseMiddleModifiers = 0;
BOOL                    __glutEmulateMouseButtons = kEmulateMouseButtons;


/* CENTRY */
void APIENTRY glutIdleFunc(void (*func)(void))
{
   __glutIdleFunc = func;
}
/* ENDCENTRY */


static void __glutTimerCallBack(CFRunLoopTimerRef timer, GLUTTimer* context)
{
   GLUTtimerCB    func = context-&gt;func;
   int            value = context-&gt;value;

   __glutProcessWorkEvents();
   void __glutFreeTimer(GLUTTimer *);
   __glutFreeTimer(context);

   if(func)
      func(value);
      
   if(__glutMostRecentTimer == context) {
      /* Set __glutMostRecentTimer to NULL, if we're the most recent timer.
         If another timer has been created in the meantime, __glutMostRecentTimer
         would now point to that timer and consequently we would not change it. */
      __glutMostRecentTimer = NULL;
   }
   __glutProcessWorkEvents(); // ensure we do not miss glut work events
}

void __glutFreeTimer(GLUTTimer *timer)
{
   CFRunLoopRemoveTimer(CFRunLoopGetCurrent(), timer-&gt;timer, kCFRunLoopCommonModes);
   
   if(__glutNumCachedTimers &lt; GLUT_MAX_CACHED_TIMERS) {
      timer-&gt;next = __glutCachedTimers;
      __glutCachedTimers = timer;
      __glutNumCachedTimers++;
   } else {
      CFRelease(timer-&gt;timer);
      free(timer);
   }
}

static GLUTTimer *__glutAllocateTimer(unsigned int msecs)
{
   GLUTTimer *        timer;
   CFAbsoluteTime    fireTime;
   
   // Compute first/next fire time
   if (msecs) // ensure timers of zero delay fire
      fireTime = CFAbsoluteTimeGetCurrent() + ((CFAbsoluteTime) msecs) / 1000.0;
   else
      fireTime = CFAbsoluteTimeGetCurrent() + 0.00001;
   
   if(__glutNumCachedTimers &gt; 0) {
      /* Recycle one of the cached timers */
      timer = __glutCachedTimers;
      __glutCachedTimers = timer-&gt;next;
      __glutNumCachedTimers--;
      if(__glutNumCachedTimers == 0)
         __glutCachedTimers = NULL;
      CFRunLoopTimerSetNextFireDate(timer-&gt;timer, fireTime);
   } else {
      /* Our cache is empty - allocate a new timer */
      timer = (GLUTTimer *) calloc(1, sizeof(GLUTTimer));
      if(!timer) {
         __glutFatalError(&quot;out of memory&quot;);
      }
      timer-&gt;context.info = timer;
      timer-&gt;timer = CFRunLoopTimerCreate(NULL,
                           fireTime,
                           1.0,     // interval
                           0,         // flags
                           0,         // order
                           (CFRunLoopTimerCallBack) __glutTimerCallBack,
                           (CFRunLoopTimerContext *) timer);
      if(!timer-&gt;timer) {
         free(timer);
         __glutFatalError(&quot;out of memory&quot;);
      }
   }
   
   return timer;
}

/* CENTRY */
void APIENTRY glutTimerFunc(unsigned int msecs, void (*func)(int value), int value)
{
   GLUTTimer *        timer = __glutAllocateTimer(msecs);
   timer-&gt;func = func;
   timer-&gt;value = value;
   CFRunLoopAddTimer(CFRunLoopGetCurrent(), timer-&gt;timer, kCFRunLoopCommonModes);
   
   __glutMostRecentTimer = timer;
}
/* ENDCENTRY */

static inline GLUTWorkEvent *__glutFindEventForWindow(int win)
{
   register GLUTWorkEvent *    evp = __glutWindowWorkList;
   
   while(evp) {
      if(evp-&gt;windowNum == win)
         break;
      evp = evp-&gt;prevWorkEvent;
   }
   return evp;
}

static GLUTWorkEvent *__glutAllocateWorkEvent(void)
{
   register GLUTWorkEvent *    evp;
   
   if(__glutNumCachedWorkEvents &gt; 0) {
      /* Recycle one of the cached work events */
      evp = __glutCachedWorkEvents;
      __glutCachedWorkEvents = evp-&gt;prevWorkEvent;
      __glutNumCachedWorkEvents--;
      if(__glutNumCachedWorkEvents == 0)
         __glutCachedWorkEvents = NULL;
   } else {
      /* Our cache is empty - allocate a new work event */
      evp = (GLUTWorkEvent *) malloc(sizeof(GLUTWorkEvent));
   }
   
   if(!evp) {
      __glutFatalError(&quot;out of memory&quot;);
   }
   
   return evp;
}

static void __glutFreeWorkEvent(GLUTWorkEvent *evt)
{
   if(__glutNumCachedWorkEvents &lt; GLUT_MAX_CACHED_WORK_EVENTS) {
      /* We abuse the prevWorkEvent ptr as a nextWorkEvent ptr... */
      evt-&gt;prevWorkEvent = __glutCachedWorkEvents;
      __glutCachedWorkEvents = evt;
      __glutNumCachedWorkEvents++;
   } else {
      free(evt);
   }
}

void __glutPostWorkEvent(GLUTWorkEvent *event)
{
   register GLUTWorkEvent *    evp;
   
   /* Find out if there is already another event destinated
      for the same window as the event we're supposed to
      send. If so merge both together. */
   evp = __glutFindEventForWindow(event-&gt;windowNum);
   
   if(evp) {
      /* Another event for an already known window - merge
         new event into already existing one */
      evp-&gt;workMask |= event-&gt;workMask;
      if(event-&gt;workMask &amp; (GLUT_MAP_WORK | GLUT_CONFIGURE_WORK)) {
         if(event-&gt;workMask &amp; GLUT_MAP_WORK)
            evp-&gt;desiredMapState = event-&gt;desiredMapState;
         
         if(event-&gt;workMask &amp; GLUT_CONFIGURE_WORK) {
            evp-&gt;desiredConfMask |= event-&gt;desiredConfMask;
            if(event-&gt;desiredConfMask &amp; (CWX | CWY)) {
               evp-&gt;desiredX = event-&gt;desiredX;
               evp-&gt;desiredY = event-&gt;desiredY;
            }
            if(event-&gt;desiredConfMask &amp; (CWWidth | CWHeight)) {
               evp-&gt;desiredWidth = event-&gt;desiredWidth;
               evp-&gt;desiredHeight = event-&gt;desiredHeight;
            }
            if(event-&gt;desiredConfMask &amp; CWStackMode) {
               evp-&gt;desiredStack = event-&gt;desiredStack;
            }
         }
      }
   } else {
      /* An event for an unknown window - allocate a new
         event record and enqueue it */
      evp = __glutAllocateWorkEvent();
      *evp = *event;
      evp-&gt;prevWorkEvent = __glutWindowWorkList;
      __glutWindowWorkList = evp;
   }
   
#if __GLUT_LOG_WORK_EVENTS
   printf(&quot;__glutPostWorkEvent() {\n&quot;);
   __glutPrintWorkMask(evp, event-&gt;windowNum, 0);
   printf(&quot;}\n&quot;);
#endif
}

void __glutPurgeWorkEvents(int win)
{
   GLUTWorkEvent **    pEntry = &amp;__glutWindowWorkList;
   GLUTWorkEvent *    entry = __glutWindowWorkList;
   
   /* Traverse singly-linked work list and look for the window. */
   while(entry) {
      if(entry-&gt;windowNum == win) {
         /* Found it; delete it. */
         *pEntry = entry-&gt;prevWorkEvent;
         __glutFreeWorkEvent(entry);
         return;
      }
      pEntry = &amp;entry-&gt;prevWorkEvent;
      entry = *pEntry;
   }
}

void __glutPostRedisplay(GLUTView * view, int layerMask)
{
   int    shown = [view isShown];
   int    visState = [view visibilityState];
   
   /* Post a redisplay if the window is visible (or the
      visibility of the window is unknown, ie. window-&gt;visState
      == -1) _and_ the layer is known to be shown. */
   if(visState != GLUT_HIDDEN &amp;&amp; visState != GLUT_FULLY_COVERED &amp;&amp; shown) {
      GLUTWorkEvent    event;
      
      INIT_WORK_EVENT(&amp;event);
      event.workMask = layerMask;
      event.windowNum = [view windowID];
      __glutPostWorkEvent(&amp;event);
   }
}

/* CENTRY */
void APIENTRY glutPostRedisplay(void)
{
   GLUTAPI_DECLARATIONS_FAST
   GLUTAPI_BEGIN_FAST
   __glutPostRedisplay(__glutCurrentView, GLUT_REDISPLAY_WORK);
   GLUTAPI_END_FAST
}

/* The advantage of this routine is that it saves the cost of a
   glutSetWindow call (entailing an expensive OpenGL context switch),
   particularly useful when multiple windows need redisplays posted at
   the same times.  See also glutPostWindowOverlayRedisplay. */
void APIENTRY glutPostWindowRedisplay(int win)
{
    GLUTView * view = __glutGetWindowByNum(win);
   
   GLUTAPI_DECLARATIONS_FAST
   GLUTAPI_BEGIN_FAST
     if(view)
        __glutPostRedisplay(view, GLUT_REDISPLAY_WORK);
    else
        __glutWarning(&quot;glutPostWindowRedisplay attempted on bogus window.&quot;);
   GLUTAPI_END_FAST
}
/* ENDCENTRY */


static GLUTWorkEvent **beforeEnd;

static GLUTWorkEvent *processWindowWorkList(GLUTWorkEvent *event)
{
   GLUTView *            view = nil;
   GLUTWorkEvent *    tmpEvt;
   
   if(event-&gt;prevWorkEvent) {
      event-&gt;prevWorkEvent = processWindowWorkList(event-&gt;prevWorkEvent);
   } else {
      beforeEnd = &amp;event-&gt;prevWorkEvent;
   }
   
   view = __glutGetWindowByNum(event-&gt;windowNum);
   if(!view) {
      /* GLUT window died in the meantime - just ignore event */
      tmpEvt = event-&gt;prevWorkEvent;
      __glutFreeWorkEvent(event);
      return tmpEvt;
   }
   
   [view handleWorkEvent: event];
   
   if (event-&gt;workMask) {
      /* Leave on work list. */
      return event;
   } else {
      /* Remove current window from work list. */
      tmpEvt = event-&gt;prevWorkEvent;
      __glutFreeWorkEvent(event);
      return tmpEvt;
   }
}

void __glutProcessWorkEvents(void)
{
   if(__glutWindowWorkList) {
      GLUTWorkEvent *    workRemainder, *work;
      
      work = __glutWindowWorkList;
      __glutWindowWorkList = NULL;
      if(work) {
         workRemainder = processWindowWorkList(work);
         if(workRemainder) {
            *beforeEnd = __glutWindowWorkList;
            __glutWindowWorkList = workRemainder;
         }
      }
   }
}

BOOL __glutHasWorkEvents(void)
{
   return (__glutWindowWorkList != NULL);
}

static int __glutCountWindows(void)
{
   NSArray *        windows = [NSApp windows];
   unsigned int    i, count = [windows count];
   int                num = 0;
   
   for(i = 0; i &lt; count; i++) {
      id    win = [windows objectAtIndex: i];
      
      if([win isKindOfClass: [GLUTWindow class]])
         num++;
   }
   return num;
}

/* CENTRY */
void APIENTRY  glutCheckLoop(void)
{
   GLUTAPI_DECLARATIONS
    GLUTAPI_BEGIN
    if(NSApp == nil) {
        __glutFatalUsage(&quot;main loop entered without proper initialization.&quot;); // will exit
    }

   [NSApp runOnce];
    GLUTAPI_END
}

void APIENTRY glutMainLoop(void)
{
   GLUTAPI_DECLARATIONS
    GLUTAPI_BEGIN 
    if(NSApp == nil) {
        __glutFatalUsage(&quot;main loop entered without proper initialization.&quot;); // will exit
    }
    if(__glutCountWindows() == 0)
        __glutFatalUsage(&quot;main loop entered with no windows created.&quot;); // will exit

    [NSApp run];
    GLUTAPI_END
}
/* ENDCENTRY */

void __glutMapKeyCode(NSEvent *theEvent, char *utf8, int *utf8Length, BOOL *isSpecial)
{
   NSString *        utf16 = [theEvent characters];
   const char *    ptr;
   int                i;
   
   if(*utf8Length &lt; 1)
      return;
   
   *isSpecial = NO;
   if([utf16 length] == 1) {
      /* A single UTF16 character. Do one of the following:
         a) Is it in the range [0, 127] ? -&gt; simply return it as a single UTF8 character.
         b) Is it a special character ? -&gt; simply return it as a special character.
         c) Else -&gt; convert the UTF16 string to a UTF8 string and return it. */
      unichar    ukey = [utf16 characterAtIndex: 0];
      int        savedLength = *utf8Length;

      *utf8Length = 1;
      if(ukey &lt;= 127) {
         utf8[0] = (ukey &amp; 0xFF);
         return;
      }
      
      *isSpecial = YES;
      switch(ukey) {
         case NSF1FunctionKey:
                  utf8[0] = GLUT_KEY_F1;
                  return;
         case NSF2FunctionKey:
                  utf8[0] = GLUT_KEY_F2;
                  return;
         case NSF3FunctionKey:
                  utf8[0] = GLUT_KEY_F3;
                  return;
         case NSF4FunctionKey:
                  utf8[0] = GLUT_KEY_F4;
                  return;
         case NSF5FunctionKey:
                  utf8[0] = GLUT_KEY_F5;
                  return;
         case NSF6FunctionKey:
                  utf8[0] = GLUT_KEY_F6;
                  return;
         case NSF7FunctionKey:
                  utf8[0] = GLUT_KEY_F7;
                  return;
         case NSF8FunctionKey:
                  utf8[0] = GLUT_KEY_F8;
                  return;
         case NSF9FunctionKey:
                  utf8[0] = GLUT_KEY_F9;
                  return;
         case NSF10FunctionKey:
                  utf8[0] = GLUT_KEY_F10;
                  return;
         case NSF11FunctionKey:
                  utf8[0] = GLUT_KEY_F11;
                  return;
         case NSF12FunctionKey:
                  utf8[0] = GLUT_KEY_F12;
                  return;
         case NSUpArrowFunctionKey:
                  utf8[0] = GLUT_KEY_UP;
                  return;
         case NSDownArrowFunctionKey:
                  utf8[0] = GLUT_KEY_DOWN;
                  return;
         case NSLeftArrowFunctionKey:
                  utf8[0] = GLUT_KEY_LEFT;
                  return;
         case NSRightArrowFunctionKey:
                  utf8[0] = GLUT_KEY_RIGHT;
                  return;
         case NSPageUpFunctionKey:
                  utf8[0] = GLUT_KEY_PAGE_UP;
                  return;
         case NSPageDownFunctionKey:
                  utf8[0] = GLUT_KEY_PAGE_DOWN;
                  return;
         case NSHomeFunctionKey:
                  utf8[0] = GLUT_KEY_HOME;
                  return;
         case NSEndFunctionKey:
                  utf8[0] = GLUT_KEY_END;
                  return;
         case NSInsertFunctionKey:
         case NSInsertCharFunctionKey:
                  utf8[0] = GLUT_KEY_INSERT;
                  return;
         case NSDeleteFunctionKey:
         case NSDeleteCharFunctionKey:
                  /* This is actually Backspace */
                  *isSpecial = NO;
                  utf8[0] = 0x08;
                  return;
      }
      *utf8Length = savedLength;
   }

   *isSpecial = NO;
   /* Special handling for non-US keyboards: Some valid ASCII characters
      are generated with the ALT modifier. I.e. on German keyboards,
      the '[' character is generated by entering Alt-5. However,
      generically, we want to ignore the effect which the ALT key
      has on the characters.*/
   utf16 = [theEvent charactersIgnoringModifiers];
   
   /* Still here ? Then either 'utf16' contains more than one UTF16 character
      and thus is most likely a composite character sequence or 'utf16' 
      contains a single 'real' Unicode character. */
   ptr = [utf16 UTF8String];
   i = 0;
   while(i &lt; *utf8Length &amp;&amp; ptr[i] != '\0') {
      utf8[i] = ptr[i];
      i++;
   }
   *utf8Length = i;
}

/**
 * Analyzes the given mouse up/down event and returns in 'buttonID' what mouse
 * button the given event corresponds to. 'modifiers' is set to the modifier
 * flags which should be passed on to the GLUT application.
 */
void __glutMapMouseButton(NSEvent *theEvent, int *buttonID, int *buttonPhysID, unsigned int *modifiers)
{
    unsigned int    mflags = [theEvent modifierFlags];
    if ((__glutEmulateMouseButtons) &amp;&amp; ([theEvent buttonNumber] == 0)) {
        *buttonPhysID = 0; // main mouse button (left) is physically pressed
        if((mflags &amp; __glutMouseFirstModifiers) == __glutMouseFirstModifiers) { // right
            *buttonID = __glutMouseFirstButton;
            *modifiers = mflags &amp; ~__glutMouseFirstModifiers;
        } else if((mflags &amp; __glutMouseSecondModifiers) == __glutMouseSecondModifiers) { // middle
            *buttonID = __glutMouseSecondButton;
            *modifiers = mflags &amp; ~__glutMouseSecondModifiers;
        } else {
            *buttonID = GLUT_LEFT_BUTTON;
            *modifiers = mflags;
        }
    } else { // handle non-emulated button 0 and all other buttons
        switch([theEvent buttonNumber]) {
            case 0:
                *buttonID = GLUT_LEFT_BUTTON;
                break;
            case 1:
                *buttonID = GLUT_RIGHT_BUTTON;
                break;
            case 2:
                *buttonID = GLUT_MIDDLE_BUTTON;
                break;
            default:
                *buttonID = -1;
                break;
        }
        *buttonPhysID = *buttonID;
        *modifiers = mflags;   
    }
}

/**
 * Sorts the given middle &amp; right modifiers so that __glutMapMouseButton() will
 * always prefer the mouse button that has the most modifier flags set.
 */
void __glutSetMouseModifiers(unsigned int middleFlags, unsigned int rightFlags)
{
   int    middleRank = 0, rightRank = 0;
   
   /* Compute ranks for middle &amp; right flags */
   if((middleFlags &amp; NSAlternateKeyMask) == NSAlternateKeyMask)
      middleRank++;
   if((middleFlags &amp; NSControlKeyMask) == NSControlKeyMask)
      middleRank++;
   if((middleFlags &amp; NSShiftKeyMask) == NSShiftKeyMask)
      middleRank++;
   if((middleFlags &amp; NSCommandKeyMask) == NSCommandKeyMask)
      middleRank++;
      
   if((rightFlags &amp; NSAlternateKeyMask) == NSAlternateKeyMask)
      rightRank++;
   if((rightFlags &amp; NSControlKeyMask) == NSControlKeyMask)
      rightRank++;
   if((rightFlags &amp; NSShiftKeyMask) == NSShiftKeyMask)
      rightRank++;
   if((rightFlags &amp; NSCommandKeyMask) == NSCommandKeyMask)
      rightRank++;
      
   if(middleRank == rightRank) {
      /* Always prefer right mouse clicks over middle ones, if both have equal ranks */
      __glutMouseFirstModifiers = rightFlags;
      __glutMouseFirstButton = GLUT_RIGHT_BUTTON;
      __glutMouseSecondModifiers = middleFlags;
      __glutMouseSecondButton = GLUT_MIDDLE_BUTTON;
   } else if(middleRank &gt; rightRank) {
      /* Middle mouse button requires more modifiers, __glutMapMouseButton() should check it first */
      __glutMouseFirstModifiers = middleFlags;
      __glutMouseFirstButton = GLUT_MIDDLE_BUTTON;
      __glutMouseSecondModifiers = rightFlags;
      __glutMouseSecondButton = GLUT_RIGHT_BUTTON;
   } else {
      /* Right mouse button requires more modifiers, __glutMapMouseButton() should check it first */
      __glutMouseFirstModifiers = rightFlags;
      __glutMouseFirstButton = GLUT_RIGHT_BUTTON;
      __glutMouseSecondModifiers = middleFlags;
      __glutMouseSecondButton = GLUT_MIDDLE_BUTTON;
   }
   
   /* Remember middle flags explicitly for two button mices */
   __glutMouseMiddleModifiers = middleFlags;
}
</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/glut/listing99.html%3Fid%3DDTS10000528-2.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/glut/listing99.html%3Fid%3DDTS10000528-2.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/glut/listing99.html%3Fid%3DDTS10000528-2.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>