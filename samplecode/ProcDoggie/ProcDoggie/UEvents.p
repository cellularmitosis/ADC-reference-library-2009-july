{	File:		UEvents.p	Contains:	This file is responsible for responding to events.  The main event loop				in ProcDoggie.p and calls the DoEvent routine for each event it gets.	Written by: Forrest Tanaka		Copyright:	Copyright © 1988-1999 by Apple Computer, Inc., All Rights Reserved.				You may incorporate this Apple sample source code into your program(s) without				restriction. This Apple sample source code has been provided "AS IS" and the				responsibility for its operation is yours. You are not permitted to redistribute				this Apple sample source code as "Apple sample source code" after having made				changes. If you're going to re-distribute the source, we require that you make				it clear in the source that the code was descended from Apple sample source				code, but that you've made changes.	Change History (most recent first):				7/27/1999	Karl Groethe	Updated for Metrowerks Codewarror Pro 2.1				}UNIT UEvents;{[j=20/57/1$] Pasmat Options}INTERFACE	USES		Events;	PROCEDURE DoEvent(anEvent: EventRecord);IMPLEMENTATION	(******************************************************************************** Used Units*******************************************************************************)	USES		AppleEvents		,Fonts		,ToolUtils		,DiskInit		,SegLoad		,GestaltEqu				(* Application *)		,UGlobals		,UEmergMem		,UProcessUtils		,UMenuHandler		,UProcessGuts		;(******************************************************************************** Constants*******************************************************************************)	CONST		kBecomingActive = TRUE; {Pass to DoActivateEvt; indicates becoming active}{$S Main}(******************************************************************************** Public: DoWindowDrag** A rectangle that covers all screen can be retrieved from the desktop region’s* rgnBBox.  The desktop region can be retrieved by calling GetGrayRgn.*******************************************************************************)	PROCEDURE DoWindowDrag (anEvent:       EventRecord;	                        clickedWindow: WindowPtr);		VAR			dragBounds: Rect; {Window can be dragged over this rectangle}	BEGIN		(* GetGrayRgn^^.rgnBBox covers the desktop over all screens *)		dragBounds := GetGrayRgn^^.rgnBBox;		DragWindow (clickedWindow, anEvent.where, dragBounds)	END;{$S Main}(******************************************************************************** Public: DoContentClick** As new kinds of windows are added to this application, this routine will have* to be able to detect the new kind of window and dispatch to the routine that* handles clicks in that kind of window.*******************************************************************************)	PROCEDURE DoContentClick (anEvent:       EventRecord;	                          clickedWindow: WindowPtr);		VAR			currWindow: WindowPtr; {Pointer to the current front window}	BEGIN		currWindow := FrontWindow;		(* Clicked window not in front; activate it *)		IF currWindow <> clickedWindow THEN			SelectWindow (clickedWindow)		ELSE			IF IsProcessListWindow (clickedWindow) THEN				ClickProcessListWindow (clickedWindow, anEvent)	END;{$S Main}(******************************************************************************** Public: DoUpdateEvt** As new kinds of windows are added to this application, this routine will have* to be able to detect the new kind of window and dispatch to the routine that* handles update events in that kind of window.*******************************************************************************)	PROCEDURE DoUpdateEvt (anEvent: EventRecord);		VAR			eventWindow: WindowPtr; {Pointer to the window to update}	BEGIN		eventWindow := WindowPtr(anEvent.message);		(* Update the window that needs it *)		SetPort (eventWindow);		BeginUpdate (eventWindow);		IF IsProcessListWindow (eventWindow) THEN			DrawProcessListWindow (eventWindow)		ELSE IF IsProcessInfoWindow (eventWindow) THEN			DrawProcessInfoWindow (eventWindow);		EndUpdate (eventWindow)	END;{$S Main}(******************************************************************************** Public: DoActivateEvt** As new kinds of windows are added to this application, this routine will have* to be able to detect the new kind of window and dispatch to the routine that* handles activate events in that kind of window.*******************************************************************************)	PROCEDURE DoActivateEvt (eventWind:      WindowPtr;	                         becomingActive: Boolean);	BEGIN		IF IsProcessListWindow (eventWind) THEN			ActivateProcessListWindow (eventWind, becomingActive);	END;{$S Main}(******************************************************************************** DoMouseDown - Mouse-down event dispatcher** When a mouseDown event is received in the main event loop, this routine is* called to determine which area on the screens the mouseDown was, and to* dispatch to the appropriate routine to handle mouseDown events in that area.* The mouseDown event is passed in the anEvent parameter.** See the UMenuHandler unit for routines that handle mouse-down events in the* menu bar, and the UWindowHandler unit for routines that handle mouse-down* events in the windows.*******************************************************************************)	PROCEDURE DoMouseDown (anEvent: EventRecord);		VAR			clickArea: Integer;   {Area of the screen that was clicked}			eventWind: WindowPtr; {Pointer the clicked window, if any}	BEGIN		(* Find clicked area of screen or window *)		clickArea := FindWindow (anEvent.where, (*<*)eventWind);		(* Jump to mouseDown-handling routine appropriate for screen area *)		CASE clickArea OF			inMenuBar:				DoMenuChoice (MenuSelect (anEvent.where));			inContent:				DoContentClick (anEvent, eventWind);			inGoAway:				IF TrackGoAway (eventWind, anEvent.where) THEN					DoWindowClose (eventWind);			inDrag:				DoWindowDrag (anEvent, eventWind)			OTHERWISE				(* do nothing *) ;		END	END;{$S Main}(******************************************************************************** DoKeyDown - Key-down event dispatcher** When a keyDown or autoKey event is received in the main event loop, this* routine is called to determine whether key is a command-key equivalent for a* menu item or not.  If the command key isn’t down, then the key stroke is* ignored.  Otherwise, MenuKey is called to get the menu ID and item number* of the menu item that corresponds to the command key, if any.  Then* DoMenuChoice is called to dispatch to the appropriate routine for the chosen* menu item.  The keyDown or autoKey event is passed in anEvent.** See the UMenuHandler unit for routines that handle menu events.*******************************************************************************)	PROCEDURE DoKeyDown (anEvent: EventRecord);		VAR			theKey: Char; {ASCII code of key that was pressed}	BEGIN		(* Get the ASCII code of the pressed key *)		theKey := CHR (BAND (anEvent.message, charCodeMask));		(* If anEvent was keyDown and command key was down, it’s menu command *)		IF (anEvent.what = keyDown) AND (BAND (anEvent.modifiers, cmdKey) <> 0)				THEN			DoMenuChoice (MenuKey (theKey))	END;{$S Main}(******************************************************************************** DoDiskEvt - Handle a disk-insert event** This routine is called whenever this application receives an event indicating* that a disk was inserted.  If the disk can’t be mounted, the message field of* the event reflects the error, and we call DIBadMount to allow the user to* format the disk.*******************************************************************************)	PROCEDURE DoDiskEvt (anEvent: EventRecord);		CONST			kSysAlertLeft = 80; {Left coord of DIBadMount alert in screen coords}			kSysAlertTop  = 80; {Top coord of DIBadMount alert in screen coords}		VAR			cornerPoint: Point; {Top-left corner of DIBadMount alert}			error:       OSErr;	BEGIN		IF HiWord (anEvent.message) <> noErr THEN			BEGIN				SetPt ((*<*)cornerPoint, kSysAlertLeft, kSysAlertTop);				error := DIBadMount (cornerPoint, anEvent.message)			END	END;{$S Main}(******************************************************************************** Public: DoOSEvt** When an OS Event is received, it can be a suspend or resume event.*******************************************************************************)	PROCEDURE DoOSEvt (anEvent: EventRecord);		VAR			eventWindow: WindowPtr; {Pointer to window being activated/deactivated}			osEvtKind:   Byte;      {Kind of OSEvt; mouse-moved or suspend/resume}	BEGIN		(* Only care if anEvent is suspend/resume event *)		osEvtKind := BAND (BSR (anEvent.message, 24), $00FF);		IF osEvtKind = suspendResumeMessage THEN			BEGIN				(* It’s a suspend/resume event; suspend or resume? *)				eventWindow := FrontWindow;				IF BAND (anEvent.message, 1) <> 0 THEN					BEGIN						(* Resume event; set the cursor and activate front window *)						InitCursor;						IF eventWindow <> NIL THEN							DoActivateEvt (eventWindow, kBecomingActive);					END				ELSE					BEGIN						(* Suspend event; deactivate the front window *)						IF eventWindow <> NIL THEN							DoActivateEvt (eventWindow, NOT kBecomingActive);					END			END	END;{$S Main}(******************************************************************************** DoHighLevelEvent - Handle a high-level event** This routine handles the high-level event specified by anEvent.  The only* high-level events that this application handles are AppleEvents, so I just* pass the high-level event to AEProcessAppleEvent.  AEProcessAppleEvent calls* the appropriate AppleEvent handler routine to handle that particular kind of* AppleEvent.*******************************************************************************)	PROCEDURE DoHighLevelEvent (anEvent: EventRecord);		VAR			error: OSErr;	BEGIN		error := AEProcessAppleEvent (anEvent);	END;{$S Main}(******************************************************************************** DoEvent - Do an event from the main event loop, and elsewhere.********************************************************************************)	PROCEDURE DoEvent(anEvent: EventRecord);	BEGIN		CASE anEvent.what OF			mouseDown:				DoMouseDown (anEvent);			keyDown, autoKey:				DoKeyDown (anEvent);			updateEvt:				DoUpdateEvt (anEvent);			diskEvt:				DoDiskEvt (anEvent);			activateEvt:				DoActivateEvt (WindowPtr(anEvent.message),						BAND (anEvent.modifiers, activeFlag) <> 0);			osEvt:				DoOSEvt (anEvent);			kHighLevelEvent:				DoHighLevelEvent (anEvent)			OTHERWISE				(* do nothing *) ;		END	END;END.