<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>Fragment Tool - /Windows.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/Carbon/index.html">Carbon</a> &gt; <a href="../../samplecode/Carbon/idxRuntimeArchitecture-date.html">Runtime Architecture</a> &gt; <A HREF="javascript:location.replace('index.html');">Fragment Tool</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">Fragment Tool</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/Windows.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/AppleEventStuff.c</option>
<option value="listing2.html">/AppleEventStuff.h</option>
<option value="listing3.html">/DialogStuff.c</option>
<option value="listing4.html">/DialogStuff.h</option>
<option value="listing5.html">/DragStuff.c</option>
<option value="listing6.html">/Fragments.c</option>
<option value="listing7.html">/FragmentStuff.h</option>
<option value="listing8.html">/FragmentTool.c</option>
<option value="listing9.html">/FragmentTool.h</option>
<option value="listing10.html">/Initialize.c</option>
<option value="listing11.html">/Lists.c</option>
<option value="listing12.html">/MenusStuff.c</option>
<option value="listing13.html">/MenuStuff.h</option>
<option value="listing14.html">/Prototypes.h</option>
<option value="listing15.html">/Streams.c</option>
<option value="listing16.html">/Streams.h</option>
<option value="listing17.html">/Utilities.c</option>
<option value="listing18.html">/Utilities.h</option>
<option value="listing19.html">/Windows.c</option></select>
				</p>
				</form>
				<p><strong><a href="Fragment_Tool.zip">Download Sample</a></strong> (&#147;Fragment_Tool.zip&#148;, 86.8K)<BR>
<strong><a href="Fragment_Tool.dmg">Download Sample</a></strong> (&#147;Fragment_Tool.dmg&#148;, 151.7K)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">/*  File:    Windows.c  Contains:  Handle application's windows  Written by: Chris White    Copyright:  Copyright &copy; 1995-1999 by Apple Computer, Inc., All Rights Reserved.        You may incorporate this Apple sample source code into your program(s) without        restriction. This Apple sample source code has been provided &quot;AS IS&quot; and the        responsibility for its operation is yours. You are not permitted to redistribute        this Apple sample source code as &quot;Apple sample source code&quot; after having made        changes. If you're going to re-distribute the source, we require that you make        it clear in the source that the code was descended from Apple sample source        code, but that you've made changes.  Change History (most recent first):        8/5/1999  Karl Groethe  Updated for Metrowerks Codewarror Pro 2.1        */#include &lt;Types.h&gt;#include &lt;Quickdraw.h&gt;#include &lt;QDOffscreen.h&gt;#include &lt;Devices.h&gt;#include &lt;LowMem.h&gt; /* For MemError() */#include &lt;Script.h&gt;#include &lt;TextUtils.h&gt;#include &lt;Dialogs.h&gt;#include &lt;Folders.h&gt;#include &lt;stddef.h&gt;#include &lt;Sound.h&gt;#include &lt;CodeFragments.h&gt;#include &lt;StandardFile.h&gt;#include &lt;Folders.h&gt;#include &quot;FragmentTool.h&quot;#include &quot;FragmentStuff.h&quot;#include &quot;Dialogs.h&quot;#include &quot;Streams.h&quot;#include &quot;Utilities.h&quot;#include &quot;Prototypes.h&quot;static OSErr CreateContentList ( WindowRef theWindow, tContentsProcPtr contentsProc, void* refCon );static void AddContentsToList ( WindowRef theWindow );static void DoDialogItemHit ( DialogRef theDialog, int16 theItem );static int8 GetStageFromItem ( int16 theItem );static int16 GetItemFromStage ( int8 theStage );static OSErr CreateTempAndCopyFragment ( tHeaderHan sourceHeader, FSSpecPtr sourceSpec, int16 sourceIndex,                    tHeaderHan targetHeader );void DoNewDocument ( void ){  OSErr      theErr;  int16      theRef;  int16      theVol;  int32      theDir;  FSSpec      theSpec;  Str255      tmpStr = &quot;\p&quot;;  Str255      theFile = &quot;\pFragmentTool &quot;;  hdrHand      theHeader;  Size      headerSize;      theErr = FindFolder ( kOnSystemDisk, kTemporaryFolderType, kCreateFolder, &amp;theVol, &amp;theDir );  OSTypeToPStr ( TickCount ( ), tmpStr );  ConcatPStr ( theFile, tmpStr, sizeof ( Str255 ) );  theErr = FSMakeFSSpec ( theVol, theDir, theFile, &amp;theSpec );  theErr = FSpCreate ( &amp;theSpec, kFourQuestionMarks, kCFragLibraryFileType, smSystemScript );    // The file has been created with both forks, but it doesn't have a  // resource map yet. If we try to open it now, we'll get an eofErr (-39).  FSpCreateResFile ( &amp;theSpec, kFourQuestionMarks, kCFragLibraryFileType, smSystemScript );  theRef = FSpOpenResFile ( &amp;theSpec, fsRdWrPerm );  if ( theRef == -1 )  {    theErr = ResError ( );    AlertUser ( kGenericErrorStr, theErr, nil );    return;  }    headerSize = offsetof ( cfrgHeader, arrayStart );  theHeader = (hdrHand) NewHandleClear ( headerSize );  (*theHeader)-&gt;version = 1;    // Current version number  AddResource ( (Handle) theHeader, kCFragResourceType, kCFragResourceID, &quot;\p&quot; );  CloseResFile ( theRef );    GetIndString ( tmpStr, 1000, 4 );        // Default document name  theErr = OpenDocument ( &amp;theSpec, tmpStr );  if ( theErr )  {    AlertUser ( kGenericErrorStr, theErr, nil );    return;  }    return;  }void DoOpenDocument ( void ){  OSErr        theErr;  StandardFileReply  theReply;      StandardGetFile ( nil, -1, nil, &amp;theReply );  if ( theReply.sfGood )  {    theErr = OpenDocument ( &amp;theReply.sfFile, nil );        if ( theErr )      AlertUser ( kGenericErrorStr, theErr, nil );  }    return;}OSErr OpenDocument ( FSSpecPtr fileSpec, StringPtr documentName ){  OSErr        theErr;  int16        theFileRef, saveFile;  WindowRef      theWindow;  tWindowInfoPtr    theInfo;  tAddFragmentsRec  theRec;  Str255        theTitle;    if ( documentName )    CopyPStr ( documentName, theTitle, sizeof ( Str255 ) );  else    CopyPStr ( fileSpec-&gt;name, theTitle, sizeof ( Str255 ) );    saveFile = CurResFile ( );  SetResLoad ( false );  theFileRef = FSpOpenResFile ( fileSpec, fsRdPerm );  SetResLoad ( true );  UseResFile ( saveFile );  if ( theFileRef == -1 )    return ResError ( );    theRec.u.out.theFileRef = theFileRef;  theErr = CreateDocumentWindow ( &amp;theWindow, theTitle, AddFragments, (void*) &amp;theRec );  if ( theErr )    return theErr;    theInfo = (tWindowInfoPtr) GetWRefCon ( theWindow );  theInfo-&gt;bUntitled = (documentName) ? true : false;  theInfo-&gt;dataHandle = theRec.u.in.theDataHandle;  BlockMoveData ( fileSpec, &amp;theInfo-&gt;fileSpec, sizeof ( FSSpec ) );    return theErr;}OSErr CreateDocumentWindow ( WindowRef* windowRef, Str255 windowTitle,                tContentsProcPtr contentsProc, void* refCon ){  OSErr    theErr;  WindowRef  theWindow;      theWindow = GetNewCWindow ( kDisplayWindow, nil, (WindowRef) -1L );  if ( theWindow == nil )    return (ResError ( )) ? ResError ( ) : resNotFound;    theErr = CreateWindowInfo ( theWindow, sizeof ( tWindowInfo ) );  if ( theErr )  goto CleanupAndBail;     theErr = CreateContentList ( theWindow, contentsProc, refCon );  if ( theErr )  goto CleanupAndBail;      // Since the application can function without the Drag Manager, an  // error here is not considered fatal.  theErr = InstallDragHandlers ( theWindow );    SetWindowType ( theWindow, kDocumentWindowType );  SetPortWindowPort ( theWindow );  TextFont ( kFontIDGeneva );  TextFace ( normal );  TextSize ( 9 );    SetWTitle ( theWindow, windowTitle );  SelectWindow ( theWindow );  ShowWindow ( theWindow );    *windowRef = theWindow;    return noErr;  CleanupAndBail:    // Don't forget to free any storage we've used so far  DestroyDocumentWindow ( theWindow );    return theErr;}//// This will close the document's file, dispose of any storage we've hung// off the window, remove any drag handlers, and then dispose of the window.//WindowRef DestroyDocumentWindow ( WindowRef windowRef ){  if ( windowRef )  {    tWindowInfoPtr theInfo;        theInfo = (tWindowInfoPtr) GetWRefCon ( windowRef );    if ( theInfo )    {      if ( theInfo-&gt;listRef )        LDispose ( theInfo-&gt;listRef );            if ( theInfo-&gt;dataHandle )        DisposeHandle ( theInfo-&gt;dataHandle );      DisposePtr ( (Ptr) theInfo );    }        RemoveDragHandlers ( windowRef );    DisposeWindow ( windowRef );      }    // Return nil so it can be assigned to the window  // reference which was passed in  return nil;}//////////////////////////////////////////////////////////////////////////////////////// Draw *only* the grow icon//void DrawClippedGrowIcon ( WindowRef theWindow ){  Rect    portRect = theWindow-&gt;portRect;  RgnHandle  oldClip = NULL;  Rect    newClip;      SetPort ( theWindow );  oldClip = NewRgn ( );  GetClip ( oldClip );    newClip = portRect;  newClip.top = newClip.bottom - 15;  newClip.left = newClip.right - 15;  ClipRect ( &amp;newClip );  DrawGrowIcon ( theWindow );    SetClip ( oldClip );  DisposeRgn ( oldClip );    return;}//// This is passed into the CreateDocumentWindow routine// to add the contents to the newly created list.//OSErr AddFragments ( ListRef theList, void* refCon ){  OSErr        theErr;  int16        theFileRef, saveFile;  int          index, itemCount;  Handle        resourceScratch;  tHeaderHan      parsedResource;  tAddFragmentsRec*  theRec;          theRec = (tAddFragmentsRec*) refCon;  theFileRef = theRec-&gt;u.out.theFileRef;    parsedResource = (tHeaderHan) NewHandleClear ( sizeof ( tHeader ) );  theErr = MemError ( );  if ( theErr )    return theErr;    saveFile = CurResFile ( );  UseResFile ( theFileRef );  resourceScratch = Get1Resource ( kCFragResourceType, kCFragResourceID );  theErr = ResError ( );  if ( theErr || resourceScratch == nil)    return (theErr) ? theErr : resNotFound;  UseResFile ( saveFile );      if ( parsedResource )  {    ParseResource ( resourceScratch, parsedResource );        itemCount = (*parsedResource)-&gt;itemCount;    for ( index = 0; index &lt; itemCount; index++ )    {      tItemPtr   dstItem;            dstItem = &amp;(*parsedResource)-&gt;itemList[index];      AddFragToList ( theList, dstItem );          }            theRec-&gt;u.in.theDataHandle = (Handle) parsedResource;  }    ReleaseResource ( resourceScratch );      return noErr;  } // AddFragments//// This returns the Nth document window, ignoring the front-most//WindowRef GetIndexedDocumentWindow ( int theIndex ){  Boolean    bFirst = true;  int      thisIndex = 0;    // Must be zero-based, like the List Manager  WindowRef  currWindow;      currWindow = FrontWindow ( );  while ( currWindow )  {    if ( GetWindowType ( currWindow ) == kDocumentWindowType )    {      // Skip the front-most document since that's the source document      if ( bFirst )        bFirst = false;      else      {        if ( thisIndex == theIndex )          return currWindow;                thisIndex++;      }    }        currWindow = GetNextWindow ( currWindow );  }    return nil;}//// Creates the storage for the data to hang off a window or dialog//OSErr CreateWindowInfo ( WindowRef windowRef, Size infoSize ){  OSErr  theErr;  Ptr    theInfo = nil;      theInfo = NewPtrClear ( infoSize );  theErr = MemError ( );  if ( theErr )    return theErr;    SetWRefCon ( windowRef, (long) theInfo );    return noErr;}//// Closes all the open documents. Called just before a quit, or as// the result of an option click in a windows go away box.//Boolean DoCloseAllDocuments ( void ){  Boolean    bCancelled = false;  WindowRef  aWindow;    aWindow = FrontWindow ( );  while ( aWindow &amp;&amp; !bCancelled )  {    bCancelled = DoCloseDocument ( aWindow );    aWindow = GetNextWindow ( aWindow );  }    return bCancelled;}Boolean DoCloseDocument ( WindowRef theWindow ){  int16  windowType;    if ( theWindow )  {    windowType = GetWindowType ( theWindow );    if ( windowType == kDAWindowType )      CloseDeskAcc ( GetWindowKind ( theWindow ) );    else if ( windowType == kDocumentWindowType )    {      int        i;      tWindowInfoPtr  theInfo;      tHeaderHan    theHeader;      tItemPtr    anItem;                  // Check for any fragments that have temp files      theInfo = (tWindowInfoPtr) GetWRefCon ( theWindow );      if ( theInfo-&gt;bDirty )        if ( DoSaveBeforeClosing ( theWindow ) ) // Did the user cancel?          return kCancelled;                theHeader = (tHeaderHan) theInfo-&gt;dataHandle;      HLock ( (Handle) theHeader );      for ( i = 0; i &lt; GetItemCount ( theHeader ); i++ )      {        anItem = GetNthItem ( theHeader, i );        if ( anItem == nil )          break;                DecrementTempUsageCount ( anItem );      }      HUnlock ( (Handle) theHeader );      DestroyDocumentWindow ( theWindow );    }      else if ( windowType == kListWindowType )      DestroyDialog ( theWindow );          AdjustMenus ( );  }    return kNotCancelled;  } // CloseDocumentBoolean DoSaveBeforeClosing ( WindowRef theWindow ){  int16    theItem;  DialogRef  theDialog;  WindowRef  dialogWindow;  Str255    theTitle, theReason;      theDialog = GetNewDialog ( kSaveDontsaveDialog, nil, (WindowRef) -1 );  dialogWindow = GetDialogWindow ( theDialog );  SetPortWindowPort ( dialogWindow );    GetWTitle ( theWindow, theTitle );  if ( gQuit )    GetIndString ( theReason, 1000, 6 );  else    GetIndString ( theReason, 1000, 7 );  ParamText ( theTitle, theReason, nil, nil );  ShowWindow ( dialogWindow );  SelectWindow ( dialogWindow );    SetDialogDefaultItem ( theDialog, kStdOkItemIndex );  SetDialogCancelItem ( theDialog, kStdCancelItemIndex );      // As long as the only enabled items are the dimissers,   // there is no need to call ModalDialog within a loop.  ModalDialog ( nil, &amp;theItem );  DisposeDialog ( theDialog );    if ( theItem == kStdOkItemIndex )    return DoSave ( theWindow );    return theItem == kStdCancelItemIndex;}    Boolean DoSave ( WindowRef theWindow ){  int16      saveFile, theFileRef;  int        i;  OSErr      theErr;  Handle      resourceScratch;  tWindowInfoPtr  theInfo;  tHeaderHan    theHeader;  tItemPtr    anItem;    theInfo = (tWindowInfoPtr) GetWRefCon ( theWindow );  #if DEBUGGING  if ( theInfo == nil ) DebugStr ( &quot;\p theInfo == nil&quot; );  #endif    if ( theInfo-&gt;bUntitled )    return DoSaveAs ( theWindow );    // Check for any fragments that have been deleted...  theHeader = (tHeaderHan) theInfo-&gt;dataHandle;  HLock ( (Handle) theHeader );  for ( i = 0; i &lt; GetItemCount ( theHeader ); i++ )  {    anItem = GetNthItem ( theHeader, i );    if ( anItem-&gt;bDeleted )    {      if ( anItem-&gt;bExistsInDocument )      {        theErr = DeleteFragment ( theHeader, &amp;theInfo-&gt;fileSpec, i );        if ( theErr )        {          AlertUser ( kGenericErrorStr, theErr, nil );          return kNotCancelled;        }        anItem-&gt;bExistsInDocument = false;      }            DecrementTempUsageCount ( anItem );    }  }    // ...and for any new fragments  for ( i = 0; i &lt; GetItemCount ( theHeader ); i++ )  {    anItem = GetNthItem ( theHeader, i );        if ( anItem-&gt;bDeleted || anItem-&gt;bExistsInDocument )      continue;          anItem-&gt;codeOffset = 0L;    theErr = AppendFileData ( GetTempSpecPtr ( anItem ), &amp;theInfo-&gt;fileSpec, &amp;anItem-&gt;codeOffset, &amp;anItem-&gt;codeLength );    if ( theErr )    {      AlertUser ( kGenericErrorStr, theErr, nil );      return kNotCancelled;    }        anItem-&gt;bExistsInDocument = true;  }    HUnlock ( (Handle) theHeader );      saveFile = CurResFile ( );  theFileRef = FSpOpenResFile ( &amp;theInfo-&gt;fileSpec, fsRdWrPerm );  theErr = ResError ( );  if ( theErr )  {    int16  theIndex;        theIndex = (theErr == opWrErr || theErr == permErr) ? kFileOpenStr : kGenericErrorStr;    AlertUser ( theIndex, (theErr == noErr) ? resNotFound : theErr, nil );    return kNotCancelled;  }  UseResFile ( theFileRef );    resourceScratch = Get1Resource ( kCFragResourceType, kCFragResourceID );  theErr = ResError ( );  if ( theErr || resourceScratch == nil )  {    AlertUser ( kGenericErrorStr, (theErr == noErr) ? resNotFound : theErr, nil );    return kNotCancelled;  }    theErr = BuildResource ( (tHeaderHan) theInfo-&gt;dataHandle, resourceScratch );  if ( theErr )  {    AlertUser ( kGenericErrorStr, theErr, nil );    return kNotCancelled;  }    ChangedResource ( resourceScratch );  UpdateResFile ( theFileRef );  ReleaseResource ( resourceScratch );  CloseResFile ( theFileRef );  UseResFile ( saveFile );    SetDocumentDirty ( theWindow, false );    return kNotCancelled;}Boolean DoSaveAs ( WindowRef theWindow ){  tWindowInfoPtr    theInfo;  StandardFileReply  theReply;  Str255        defaultName;      theInfo = (tWindowInfoPtr) GetWRefCon ( theWindow );  #if DEBUGGING  if ( theInfo == nil ) DebugStr ( &quot;\p theInfo == nil&quot; );  #endif    GetWTitle ( theWindow, defaultName );  StandardPutFile ( &quot;\p&quot;, defaultName, &amp;theReply );  if ( theReply.sfGood )  {    OSErr  theErr;        if ( theInfo-&gt;bUntitled )    {      theInfo-&gt;bUntitled = false;      DoSave ( theWindow );            theErr = FSpCreate ( &amp;theReply.sfFile, kFourQuestionMarks, kCFragLibraryFileType, theReply.sfScript );      theErr = FSpExchangeFiles ( &amp;theInfo-&gt;fileSpec, &amp;theReply.sfFile );      FSpDelete ( &amp;theInfo-&gt;fileSpec );            BlockMoveData ( &amp;theReply.sfFile, &amp;theInfo-&gt;fileSpec, sizeof ( FSSpec ) );            SetWTitle ( theWindow, theReply.sfFile.name );    }    else    // User selected &quot;Save As&quot;    {      int16    theRef, saveFile;      int      i;      FSSpec    oldSpec;      tItemPtr  anItem;      hdrHand    theResource = nil;      tHeaderHan  theHeader;                  BlockMoveData ( &amp;theInfo-&gt;fileSpec, &amp;oldSpec, sizeof ( FSSpec ) );      BlockMoveData ( &amp;theReply.sfFile, &amp;theInfo-&gt;fileSpec, sizeof ( FSSpec ) );      theErr = FSpCreate ( &amp;theInfo-&gt;fileSpec, kFourQuestionMarks, kCFragLibraryFileType, theReply.sfScript );            theHeader = (tHeaderHan) theInfo-&gt;dataHandle;      HLock ( (Handle) theHeader );      // copy each fragment's data fork      for ( i = 0; i &lt; GetItemCount ( theHeader ); i++ )      {        FSSpecPtr  theSpecPtr;        anItem = GetNthItem ( theHeader, i );        if ( anItem-&gt;bDeleted )          continue;                if ( anItem-&gt;bExistsInDocument )          theSpecPtr = &amp;oldSpec;        else        {          theSpecPtr = GetTempSpecPtr ( anItem );          anItem-&gt;codeOffset = 0L;        }                  theErr = AppendFileData ( theSpecPtr, &amp;theInfo-&gt;fileSpec, &amp;anItem-&gt;codeOffset, &amp;anItem-&gt;codeLength );        if ( theErr )        {          AlertUser ( kGenericErrorStr, theErr, nil );          return kNotCancelled;        }                anItem-&gt;bExistsInDocument = true;      }      HUnlock ( (Handle) theHeader );                  FSpCreateResFile ( &amp;theInfo-&gt;fileSpec, kFourQuestionMarks, kCFragLibraryFileType, smSystemScript );      theRef = FSpOpenResFile ( &amp;theInfo-&gt;fileSpec, fsRdWrPerm );            theResource = (hdrHand) NewHandleClear ( offsetof ( cfrgHeader, arrayStart ) );      (*theResource)-&gt;version = 1;    // Current version number            theErr = BuildResource ( (tHeaderHan) theInfo-&gt;dataHandle, (Handle) theResource );            saveFile = CurResFile ( );      theRef = FSpOpenResFile ( &amp;theInfo-&gt;fileSpec, fsRdWrPerm );      // If the file is already open, it may not be the current resource file      UseResFile ( theRef );      AddResource ( (Handle) theResource, kCFragResourceType, kCFragResourceID, &quot;\p&quot; );      UpdateResFile ( theRef );      ReleaseResource ( (Handle) theResource );      CloseResFile ( theRef );      UseResFile ( saveFile );                  SetWTitle ( theWindow, theReply.sfFile.name );            SetDocumentDirty ( theWindow, false );    }        return kNotCancelled;  }    return kCancelled;}static OSErr CreateContentList ( WindowRef theWindow, tContentsProcPtr contentsProc, void* refCon ){  OSErr    theErr;  ListHandle  theList;  Point    cellSize = {0, 32767};  Cell    firstCell = {0, 0};  Rect     dataRect = {0, 0, 0, 1};  Rect    viewRect;      // The width of a cell needs to be 32767 so any hiliting  // doesn't stop short of the window width after it's been resized.    viewRect = theWindow-&gt;portRect;  viewRect.bottom -= 15; viewRect.right -= 15;  theList = LNew ( &amp;viewRect, &amp;dataRect, cellSize, 0, theWindow,             false, false, true, true );  if ( theList )  {    (*theList)-&gt;selFlags = lOnlyOne;    (*theList)-&gt;lClickLoop = gClickLoopUPP;    SetWListRef ( theWindow, theList );        // Since the calling routine is always in the same architecture type as    // the callback routine, we don't need to worry about any Mixed Mode    // complications. We just treat it as a straight forward routine pointer.    if ( contentsProc )    {      theErr = (*contentsProc) ( theList, refCon );      if ( theErr )        return theErr;    }        LSetSelect ( true, firstCell, theList );        // Now the list has been fully prepared, turn the drawing mode on    LSetDrawingMode ( true, theList );  }    return noErr;  } // CreateContentListBoolean IsDocumentDirty ( WindowRef theWindow ){  if ( GetWindowType ( theWindow ) == kDocumentWindowType )  {    tWindowInfoPtr  theInfo;        theInfo = (tWindowInfoPtr) GetWRefCon ( theWindow );    if ( theInfo )      return ( theInfo-&gt;bDirty );  }    return false;}void SetDocumentDirty ( WindowRef theWindow, Boolean bIsDirty ){  if ( GetWindowType ( theWindow ) == kDocumentWindowType )  {    tWindowInfoPtr  theInfo;        theInfo = (tWindowInfoPtr) GetWRefCon ( theWindow );    if ( theInfo )      theInfo-&gt;bDirty = bIsDirty;          AdjustMenus ( );  }    return;}void SetWListRef ( WindowRef theWindow, ListHandle theList ){  ((tWindowInfoPtr) GetWRefCon ( theWindow ))-&gt;listRef = theList;    return;}ListHandle GetWListRef ( WindowRef theWindow ){  return ((tWindowInfoPtr) GetWRefCon ( theWindow ))-&gt;listRef;}void SetWFileSpec ( WindowRef theWindow, FSSpecPtr theSpec ){  BlockMoveData ( theSpec, &amp;((tWindowInfoPtr) GetWRefCon ( theWindow ))-&gt;fileSpec, sizeof ( FSSpec ) );    return;}/*----------------------- Handle window update events ----------------------*/void DoUpdate ( EventRecord* theEvent ){  WindowRef  theWindow;  SInt16    theType;  GrafPtr    savePort;        theWindow = (WindowRef) theEvent-&gt;message;          theType = GetWindowType ( theWindow );  GetPort ( &amp;savePort );  SetPortWindowPort ( theWindow );  BeginUpdate ( theWindow );          // visRgn temporarily = updateRgn  EraseRect ( &amp;theWindow-&gt;portRect );  switch ( theType )  {    case kDocumentWindowType:    {      ListHandle  theList = nil;            theList = GetWListRef ( theWindow );      if ( theList )        LUpdate ( (*theList)-&gt;port-&gt;visRgn, theList );      DrawClippedGrowIcon ( theWindow );    }    break;        case kListWindowType:    {      ListHandle    theList = nil;      tDialogInfoPtr  theInfo;            UpdateDialog ( theWindow, theWindow-&gt;visRgn );      theInfo = (tDialogInfoPtr) GetWRefCon ( theWindow );      theList = theInfo-&gt;listRef;      if ( theList )        LUpdate ( (*theList)-&gt;port-&gt;visRgn, theList );    }    break;    case kGetInfoWindowType:    {      TEHandle    textH;            UpdateDialog ( theWindow, theWindow-&gt;visRgn );      textH = ((DialogPeek) theWindow)-&gt;textH;      if ( textH )        TEUpdate ( &amp;(*textH)-&gt;viewRect, textH );    }    break;  }    EndUpdate ( theWindow );          // restore normal visRgn of grafport  SetPort ( savePort );    return;  } // DoUpdatevoid DoActivate ( EventRecord* theEvent ){  SInt16    itemHit;  SInt16    theType;  ListHandle  theList = nil;  WindowRef  theWindow = (WindowRef) theEvent-&gt;message;  Boolean    bActiveFlag = theEvent-&gt;modifiers &amp; 1;        theType = GetWindowType ( theWindow );  switch ( theType )  {    case kDocumentWindowType:    {      LActivate ( bActiveFlag, GetWListRef ( theWindow ) );      DrawClippedGrowIcon ( theWindow );    }    break;        case kListWindowType:    {      tDialogInfoPtr theInfo = (tDialogInfoPtr) GetWRefCon ( theWindow );      theList = theInfo-&gt;listRef;      if ( theList )        LActivate ( bActiveFlag, theList );      DialogSelect ( theEvent, &amp;theWindow, &amp;itemHit );    }    break;        case kGetInfoWindowType:    {      TEHandle    textH;            textH = ((DialogPeek) theWindow)-&gt;textH;      if ( textH )      {        if ( bActiveFlag )          TEActivate ( textH );        else          TEDeactivate ( textH );      }      DialogSelect ( theEvent, &amp;theWindow, &amp;itemHit );    }    break;  }      AdjustMenus ( );  } // DoActivatevoid DoContentClick ( WindowRef theWindow, EventRecord* theEvent ){  WindowRef  frontWindow;    // If a movable modal is active, ignore click in an inactive   // window, otherwise select it or handle the content click.    frontWindow = FrontWindow ( );  if ( theWindow != frontWindow )  {    if ( IsMovableModal ( frontWindow ) )      SysBeep ( 30 );    else      SelectWindow ( theWindow );  }  else  {    if ( IsMovableModal ( theWindow ) )      DoDialogContentClick ( theWindow, theEvent );    else    {      Boolean  bWasHandled;      bWasHandled = HandleListClick ( theWindow, theEvent );            AdjustMenus ( );    }  }    return;  } // DoContentClickvoid DoGrowWindow ( WindowRef theWindow, EventRecord* theEvent ){  const short kMinDocSize = 64;  const short kMaxDocSize = 32767;    long  newSize;  Rect  limitRect;      // set up the limiting rectangle  SetRect ( &amp;limitRect, kMinDocSize, kMinDocSize, kMaxDocSize, kMaxDocSize );  // call Window Manager to let the user drag size box  newSize = GrowWindow ( theWindow, theEvent-&gt;where, &amp;limitRect );  if ( newSize )          // if the user changed its size  {    short h, v;        h = newSize &amp; 0x0000FFFF;    v = newSize &gt;&gt; 16;    SizeWindow ( theWindow, h, v, true );    h -= 15; v -= 15;    LSize ( h, v, GetWListRef ( theWindow ) );    SetPort ( theWindow );    InvalRect ( &amp;theWindow-&gt;portRect );  }    return;  } // DoGrowWindowvoid DoDragWindow ( WindowRef theWindow, EventRecord* theEvent ){  WindowRef  frontWindow;      // If a movable modal is active, ignore click in an inactive   // title bar, otherwise let the Window Manager handle it.    frontWindow = FrontWindow ( );  if ( theWindow != frontWindow &amp;&amp; IsMovableModal ( frontWindow ) )    SysBeep ( 30 );  else                  {    RgnHandle  theRgn;    Rect    dragRect;        theRgn = GetGrayRgn ( );    dragRect = (*theRgn)-&gt;rgnBBox;    DragWindow ( theWindow, theEvent-&gt;where, &amp;dragRect );  }    return;}Boolean IsMovableModal ( WindowRef theWindow ){  return (GetWVariant ( theWindow ) == movableDBoxProc);}int16 GetWindowType ( WindowRef theWindow ){  int16 theType = 0;    if ( theWindow )  {    theType = GetWindowKind ( theWindow );    if ( theType &lt; 0 )      theType = kDAWindowType;    else if ( theType == kApplicationWindowKind )      theType = kDocumentWindowType;    else    {      tDialogInfoPtr theInfo = (tDialogInfoPtr) GetWRefCon ( theWindow );      if ( theInfo )        theType = theInfo-&gt;windowType;    }  }    return theType;}void SetWindowType ( WindowRef theWindow, int16 theType ){  int16 theKind;  if ( theWindow )  {    theKind = GetWindowKind ( theWindow );    if ( theKind != kApplicationWindowKind )    {      tDialogInfoPtr theInfo = (tDialogInfoPtr) GetWRefCon ( theWindow );      if ( theInfo )        theInfo-&gt;windowType = theType;    }  }    return;}int16 GetWindowSubType ( WindowRef theWindow ){  int16 theKind;  int16 theType = 0;    if ( theWindow )  {    theKind = GetWindowKind ( theWindow );    if ( theKind != kApplicationWindowKind )    {      tDialogInfoPtr theInfo = (tDialogInfoPtr) GetWRefCon ( theWindow );      if ( theInfo )        theType = theInfo-&gt;windowSubType;    }  }    return theType;}void SetWindowSubType ( WindowRef theWindow, int16 theType ){  int16 theKind;  if ( theWindow )  {    theKind = GetWindowKind ( theWindow );    if ( theKind != kApplicationWindowKind )    {      tDialogInfoPtr theInfo = (tDialogInfoPtr) GetWRefCon ( theWindow );      if ( theInfo )        theInfo-&gt;windowSubType = theType;    }  }    return;}void DoZoomWindow ( WindowRef theWindow, EventRecord* theEvent, int16 windowPart ){  Point        globalPt = theEvent-&gt;where;    SetPort ( theWindow );  if ( TrackBox ( theWindow, globalPt, windowPart ) )  {    /*      TO DO:        This doesn't handle multiple screens    */        ZoomWindow ( theWindow, windowPart, true );    InvalRect ( &amp;theWindow-&gt;portRect );  }    return;}OSErr CopyWindowFragment ( WindowRef source, int16 sourceIndex, WindowRef target ){  int16      itemIndex;  OSErr      theErr;  tWindowInfoPtr  sourceInfo = nil;  tWindowInfoPtr  targetInfo = nil;        itemIndex = GetIndexFromNthWindowItem ( source, sourceIndex );    sourceInfo = (tWindowInfoPtr) GetWRefCon ( source );  targetInfo = (tWindowInfoPtr) GetWRefCon ( target );    theErr = CreateTempAndCopyFragment ( (tHeaderHan) sourceInfo-&gt;dataHandle, &amp;sourceInfo-&gt;fileSpec,                      itemIndex, (tHeaderHan) targetInfo-&gt;dataHandle );  if ( theErr == noErr )  {    SignedByte  theState;    tItemPtr  theItem;        theState = HGetState ( sourceInfo-&gt;dataHandle );    HLock ( sourceInfo-&gt;dataHandle );    theItem = GetNthItem ( (tHeaderHan) sourceInfo-&gt;dataHandle, itemIndex );    AddFragToList ( GetWListRef ( target ), theItem );    HSetState ( sourceInfo-&gt;dataHandle, theState );        SetDocumentDirty ( target, true );  }    return theErr;}OSErr MoveWindowFragment ( WindowRef source, int16 sourceIndex, WindowRef target ){  OSErr  theErr = noErr;    theErr = CopyWindowFragment ( source, sourceIndex, target );  if ( !theErr )    theErr = DeleteWindowFragment ( source, sourceIndex );    return theErr;}OSErr DeleteWindowFragment ( WindowRef theWindow, int16 theIndex ){  int16      itemIndex;  OSErr      theErr;  tWindowInfoPtr  theInfo;      // Since we don't support undo just yet, there's no need  // to copy it to a temporary file.    itemIndex = GetIndexFromNthWindowItem ( theWindow, theIndex );    theInfo = (tWindowInfoPtr) GetWRefCon ( theWindow );  theErr = DeleteFragment ( (tHeaderHan) theInfo-&gt;dataHandle, nil, itemIndex );    if ( theErr == noErr )  {    DeleteFromList ( GetWListRef ( theWindow ), theIndex );    SetDocumentDirty ( theWindow, true );  }    return theErr;}OSErr CreateTempAndCopyFragment ( tHeaderHan sourceHeader, FSSpecPtr sourceSpec, int16 sourceIndex,                    tHeaderHan targetHeader ){  SignedByte  sourceState, targetState;  OSErr    theErr;  tItemPtr  sourceItem, targetItem;  FSSpec    tempSpec;      sourceState = HGetState ( (Handle) sourceHeader );  HLock ( (Handle) sourceHeader );  targetState = HGetState ( (Handle) targetHeader );  HLock ( (Handle) targetHeader );    sourceItem = GetNthItem ( sourceHeader, sourceIndex );  // Do we already have a temporary file that contains this fragment  if ( GetTempUsageCount ( sourceItem ) )  {    theErr = CopyFragment ( sourceHeader, nil, sourceIndex, targetHeader, nil );        targetItem = GetLastItem ( targetHeader );    targetItem-&gt;bExistsInDocument = false;    IncrementTempUsageCount ( targetItem );  }  else  {    theErr = CreateTemporaryFile ( &amp;tempSpec );        theErr = CopyFragment ( sourceHeader, sourceSpec, sourceIndex, targetHeader, &amp;tempSpec );    if ( theErr )      // We'll let the system handle the temp file. It may      // be useful for debugging, if nothing else.      return theErr;        sourceItem = GetNthItem ( sourceHeader, sourceIndex );    IncrementTempUsageCount ( sourceItem );    BlockMoveData ( &amp;tempSpec, GetTempSpecPtr ( sourceItem ), sizeof ( FSSpec ) );        targetItem = GetLastItem ( targetHeader );    targetItem-&gt;bExistsInDocument = false;    targetItem-&gt;tempFilePtr = sourceItem-&gt;tempFilePtr;    IncrementTempUsageCount ( targetItem );  }    HSetState ( (Handle) sourceHeader, sourceState );  HSetState ( (Handle) sourceHeader, targetState );    return theErr;}tItemPtr GetNthWindowItem ( WindowRef theWindow, int16 theIndex ){  tWindowInfoPtr  theInfo = nil;      theIndex = GetIndexFromNthWindowItem ( theWindow, theIndex );    theInfo = (tWindowInfoPtr) GetWRefCon ( theWindow );  return GetNthItem ( (tHeaderHan) theInfo-&gt;dataHandle, theIndex );}int16 GetIndexFromNthWindowItem ( WindowRef theWindow, int16 theIndex ){  int16      theSize;  int        i;  Cell      theCell = { 0, 0 };  tWindowInfoPtr  theInfo = nil;  tHeaderHan    theHeader;  Str255      theText;      theInfo = (tWindowInfoPtr) GetWRefCon ( theWindow );    // First, get the text we're looking for. Two fragments with the same name  // but different architectures are quite likely. We need to include the type.    theSize = sizeof ( Str255 );  theCell.v = theIndex;  LGetCell ( &amp;theText[1], &amp;theSize, theCell, theInfo-&gt;listRef );  theText[0] = theSize;    theHeader = (tHeaderHan) theInfo-&gt;dataHandle;  // Now, scan our items looking for a match  for ( i = 0; i &lt; GetItemCount ( theHeader ); i++ )  {    tItemPtr    theItem;    unsigned char  archTypeStr[5];    Str255      itemText;        theItem = GetNthItem ( theHeader, i );    // Since we're looking for an item in the window, ignore deleted items    if ( theItem-&gt;bDeleted )      continue;        CopyPStr ( theItem-&gt;name, itemText, sizeof ( Str255 ) );    ConcatPStr ( itemText, &quot;\p\t&quot;, sizeof ( Str255 ) );    OSTypeToPStr ( theItem-&gt;archType, archTypeStr );    ConcatPStr ( itemText, archTypeStr, sizeof ( Str255 ) );    if ( EqualString ( theText, itemText, true, true ) )      return i;  }      #if DEBUGGING  DebugStr ( &quot;\p GetIndexFromNthWindowItem returning 0&quot; );  #endif  return 0;}void AddFragToList ( ListRef theList, tItemPtr theItem ){  unsigned char  archTypeStr[5];  Str255      theText;      CopyPStr ( theItem-&gt;name, theText, sizeof ( Str255 ) );  ConcatPStr ( theText, &quot;\p\t&quot;, sizeof ( Str255 ) );  OSTypeToPStr ( theItem-&gt;archType, archTypeStr );  ConcatPStr ( theText, archTypeStr, sizeof ( Str255 ) );  AddToList ( theList, theText );    return;}void UpdateFragInList ( WindowRef theWindow, int16 theIndex, StringPtr newName ){  unsigned char  archTypeStr[5];  tItemPtr    theItem;  ListRef      theList;  Str255      theText;      theItem = GetNthWindowItem ( theWindow, theIndex );  theList = GetWListRef ( theWindow );  CopyPStr ( newName, theText, sizeof ( Str255 ) );  ConcatPStr ( theText, &quot;\p\t&quot;, sizeof ( Str255 ) );  OSTypeToPStr ( theItem-&gt;archType, archTypeStr );  ConcatPStr ( theText, archTypeStr, sizeof ( Str255 ) );  UpdateList ( theList, theIndex, theText );    return;}</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/Fragment_Tool/listing19.html%3Fid%3DDTS10000572-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/Fragment_Tool/listing19.html%3Fid%3DDTS10000572-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/Fragment_Tool/listing19.html%3Fid%3DDTS10000572-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>