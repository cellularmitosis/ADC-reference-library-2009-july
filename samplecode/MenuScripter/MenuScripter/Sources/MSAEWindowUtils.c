// MSAEWindowUtils.c//// Original version by Jon Lansdell and Nigel Humphreys.// 4.0 and 3.1 updates by Greg Sutton.// ©Apple Computer Inc 1996, all rights reserved.#include "MSAEWindowUtils.h"#include "MSWindow.h"		// for DPtrFromWindowPtr()#include "MSAEGetData.h"#include "MSAEUtils.h"#include <LowMem.h>	OSErr	GetDescOfNamedWindow( StringPtr nameStr, AEDesc* result ){	WindowToken		theToken;	OSErr			err = noErr;		theToken.tokenWindow = GetNamedWindow( nameStr );		if ( theToken.tokenWindow )		err = AECreateDesc( typeMyWndw, (Ptr)&theToken, sizeof( theToken ), result );	else		err = errAENoSuchObject;	return(err);}	OSErr	GetDescOfNamedDocument( StringPtr nameStr, AEDesc* result ){	WindowToken		theToken;	OSErr			err = noErr;		theToken.tokenWindow = GetNamedDocument( nameStr );		if ( theToken.tokenWindow )		err = AECreateDesc( typeMyDocument, (Ptr)&theToken, sizeof(theToken), result );	else		err = errAENoSuchObject;	return(err);}short CountWindows(void){	WindowPtr aWindow;	short     index;				index = 0;	aWindow = (WindowPtr)LMGetWindowList();	// iterate through windows	while ( aWindow )	{		if ( IsVisible( aWindow ) )			index++;						  	aWindow = (WindowPtr)((WindowPeek)aWindow)->nextWindow;	}		return index;} // CountWindowsOSErr	GetDescOfNthWindow(short index, AEDesc* result){	WindowToken		theToken;	OSErr			err = noErr;		theToken.tokenWindow = GetNthWindow( index );		if (theToken.tokenWindow)		err = AECreateDesc(typeMyWndw, (Ptr)&theToken, sizeof(theToken), result);	else		err = errAEIllegalIndex;	return(err);}OSErr	GetDescOfNthDocument( short index, AEDesc* result ){	WindowToken		theToken;	OSErr			err = noErr;		theToken.tokenWindow = GetNthDocument( index );		if (theToken.tokenWindow)		err = AECreateDesc( typeMyDocument, (Ptr)&theToken, sizeof(theToken), result );	else		err = errAEIllegalIndex;	return(err);}WindowPtr	GetNthWindow( long index ){	long		result = 0;	WindowPtr	aWindow;		aWindow = (WindowPtr)LMGetWindowList();	while (aWindow)	{		if ( IsVisible( aWindow ) )	// Only count visible windows			result++;				if (result == index)			return(aWindow);				aWindow = (WindowPtr)((WindowPeek)aWindow)->nextWindow;	}		return(NULL);}WindowPtr	GetNthDocument( long index ){	long		result = 0;	WindowPtr	aWindow;		aWindow = (WindowPtr)LMGetWindowList();	while (aWindow)	{		if ( IsDocumentWindow( aWindow ) && IsVisible( aWindow ) )			result++;				if (result == index)			return(aWindow);				aWindow = (WindowPtr)((WindowPeek)aWindow)->nextWindow;	}		return(NULL);}WindowPtr	GetNamedWindow( StringPtr theName ){	WindowPtr	aWindow;	Str255		title;		aWindow = (WindowPtr)LMGetWindowList();	while (aWindow)	{		GetWTitle(aWindow, title);				if (EqualString(theName, title, false, false))			return(aWindow);				aWindow = (WindowPtr)((WindowPeek)aWindow)->nextWindow;	}		return(NULL);}WindowPtr	GetNamedDocument( StringPtr theName ){	WindowPtr	aWindow;	Str255		title;		aWindow = (WindowPtr)LMGetWindowList();	while (aWindow)	{		GetWTitle(aWindow, title);				if ( IsDocumentWindow(aWindow)				&& EqualString(theName, title, false, false) )			return(aWindow);				aWindow = (WindowPtr)((WindowPeek)aWindow)->nextWindow;	}		return(NULL);}long	GetWindowIndex( WindowPtr theWindow ){	long		result = 0;	WindowRef	aWindow;		aWindow = (WindowPtr)LMGetWindowList();	while (aWindow)	{		if ( IsVisible( aWindow ) )			result++;				if (theWindow == aWindow)			return(result);				aWindow = (WindowPtr)((WindowPeek)aWindow)->nextWindow;	}		return(0);}OSErr	SetWindowIndex( WindowPtr theWindow, long theIndex ){	long		maxIndex;	WindowPtr	behindWindow;		maxIndex = CountWindows();		if (theIndex < 0)					// Handle negative indexes		theIndex = maxIndex + theIndex + 1;			if (theIndex < 0 || theIndex > maxIndex)		return(errAEIllegalIndex);			if (1 == theIndex)		SelectWindow( theWindow );	else	{		behindWindow = GetNthWindow( theIndex - 1 );		SendBehind( theWindow, behindWindow );	}		return(noErr);}long	GetDocumentIndex( WindowPtr theWindow ){	long		result = 0;	WindowRef	aWindow;		aWindow = (WindowPtr)LMGetWindowList();	while (aWindow)	{		if ( IsDocumentWindow( aWindow ) && IsVisible( aWindow ) )			result++;				if (theWindow == aWindow)			return(result);				aWindow = (WindowPtr)((WindowPeek)aWindow)->nextWindow;	}		return(0);}OSErr	SetDocumentIndex( WindowPtr theWindow, long theIndex ){	long		maxIndex;	WindowPtr	behindWindow;		maxIndex = CountDocuments();		if (theIndex < 0)					// Handle negative indexes		theIndex = maxIndex + theIndex + 1;			if (theIndex < 0 || theIndex > maxIndex)		return(errAEIllegalIndex);			if (1 == theIndex && GetNthDocument(1) == GetNthWindow(1))		SelectWindow( theWindow );	else	{		behindWindow = GetNthDocument(theIndex - 1);		SendBehind(theWindow, behindWindow);	}		return(noErr);}Boolean	IsDocumentWindow( WindowPtr theWindow ){	DPtr		aDoc;	Boolean		result;	if ( ! theWindow )		return false;			aDoc = (DPtr)GetWRefCon( theWindow );		result = ( kOrdinaryWind == aDoc->windowType || kResultsWind == aDoc->windowType );	return true;}Boolean	IsResultsWindow( WindowPtr theWindow ){	DPtr		aDoc;	Boolean		result;	if ( ! theWindow )		return false;			aDoc = (DPtr)GetWRefCon( theWindow );		result = ( kResultsWind == aDoc->windowType );	return result;}short	CountDocuments( void ){	WindowPtr aWindow;	short     index;				index = 0;	aWindow = (WindowPtr)LMGetWindowList();	// iterate through windows	while (aWindow)	{		if ( IsDocumentWindow( aWindow ) && IsVisible( aWindow ) )			index++;							aWindow = (WindowPtr)((WindowPeek)aWindow)->nextWindow;	}		return index;} // CountWindowsBoolean	IsVisible( WindowPtr theWindow ){	return ((WindowPeek)theWindow)->visible;}OSErr	GetWindowBounds( WindowPtr theWindow, Rect* theRect ){	AEDesc			aDesc = { typeNull, NULL };	WindowPropToken	aToken;	OSErr			anErr;		aToken.tokenWindowToken.tokenWindow = theWindow;	aToken.tokenProperty = pBounds;	anErr = GetWindowTokenProperty( &aToken, &aDesc );	if ( noErr != anErr ) goto done;	anErr = GetRectFromDescriptor( &aDesc, theRect );done:	(void)AEDisposeDesc( &aDesc );		return anErr;}