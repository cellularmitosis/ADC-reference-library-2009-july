;;	Apple Macintosh Developer Technical Support;;	MultiFinder-Aware TextEdit Sample Application;;	TESample;;	TESampleGlue.a	-	Assembler Source;;	Copyright © Apple Computer, Inc. 1989-1990;	All rights reserved.;;	Versions:	;				1.00				02/92;;	Change History:;				1/7/93	RRK		Added LAPAddATQFix and LAPRmvATQFix;								routines to use instead of the calls in;								the Interface.o file which has bad glue;								Glue code leaves 2 additional bytes on the;								stack.;;	Components:;				ATQWatcher.p			Feb.  1, 1990;				ATQWatcherGlue.a		Feb.  1, 1990;				ATQWatcher.r			Feb.  1, 1990;				ATQWatcher.h			Feb.  1, 1990;				ATQCGlue.c				Feb.  1, 1990;				ATQFix.c				Jan.  7, 1993;				makefile				Feb.  1, 1990;;;	TESample is an example application that demonstrates how ;	to initialize the commonly used toolbox managers, operate ;	successfully under MultiFinder, handle desk accessories and ;	create, grow, and zoom windows. The fundamental TextEdit ;	toolbox calls and TextEdit autoscroll are demonstrated. It ;	also shows how to create and maintain scrollbar controls.;;	It does not by any means demonstrate all the techniques you ;	need for a large application. In particular, Sample does not ;	cover exception handling, multiple windows/documents, ;	sophisticated memory management, printing, or undo. All of ;	these are vital parts of a normal full-sized application.;;	This application is an example of the form of a Macintosh ;	application; it is NOT a template. It is NOT intended to be ;	used as a foundation for the next world-class, best-selling, ;	600K application. A stick figure drawing of the human body may ;	be a good example of the form for a painting, but that does not ;	mean it should be used as the basis for the next Mona Lisa.;;	We recommend that you review this program or Sample before ;	beginning a new application. Sample is a simple app. which doesnÕt ;	use TextEdit or the Control Manager.;;;	AsmClikLoop;;	This routine gets called by the TextEdit Manager from TEClick.;	It calls the old, default click loop routine that scrolls the;	text, and then calls our own Pascal routine that handles;	tracking the scroll bars to follow along.  It doesn't bother;	with saving registers A0 and D0, because they are trashed;	anyway by TextEdit.;AsmClikLoop	PROC		EXPORT			IMPORT		GETOLDCLIKLOOP			IMPORT		PASCALCLIKLOOP						MOVEM.L		D1-D2/A1,-(SP)		; D0 and A0 need not be saved			CLR.L		-(SP)				; make space for procedure pointer			JSR			GETOLDCLIKLOOP		; get the old clikLoop			MOVEA.L		(SP)+,A0			; into A0			MOVEM.L		(SP)+,D1-D2/A1		; restore the world as it was						JSR			(A0)				; and execute old clikLoop			MOVEM.L		D1-D2/A1,-(SP)		; D0 and A0 need not be saved			JSR			PASCALCLIKLOOP		; do our clikLoop			MOVEM.L		(SP)+,D1-D2/A1		; restore the world as it was			MOVEQ		#1,D0				; clear the zero flag so TextEdit keeps going			RTS			ENDP;	LAPAddATQFix;   pascal OSErr LAPAddATQFix(ATQEntryPtr theATQEntry);;;	This routine correctly processes the call to the LAP Manager;	to add a transition queue entry;LAPAddATQFix	PROC 	EXPORT			 			MOVE.W     	#$0017,D0     	  	; D0 selector $0017 = LAPAddATQ			MOVEA.L     $0004(A7),A0		; A0 -> ATQ Proc			MOVEA.L     $0B18,A1			; Set up to call LAP Manager			MOVE.L      (A7)+,(A7)			; Move return address up 4 bytes			JSR         $0002(A1)			; call LAP Manager			MOVEA.L     (A7)+,A0			; Move return address into A0			MOVE.W      D0,(A7)				; Move result into space reserved on stack			JMP         (A0)				; Return						ENDP;	LAPRmvATQFix;   pascal OSErr LAPAddATQFix(ATQEntryPtr theATQEntry);;;	This routine correctly processes the call to the LAP Manager;	to remove a transition queue entry;LAPRmvATQFix	PROC 	EXPORT			 			MOVE.W     	#$0018,D0     	  	; D0 selector $0018 = LAPRmvATQ			MOVEA.L     $0004(A7),A0		; A0 -> ATQ Proc			MOVEA.L     $0B18,A1			; Set up to call LAP Manager			MOVE.L      (A7)+,(A7)			; Move return address up 4 bytes			JSR         $0002(A1)			; call LAP Manager			MOVEA.L     (A7)+,A0			; Move return address into A0			MOVE.W      D0,(A7)				; Move result into space reserved on stack			JMP         (A0)				; Return						ENDP			END