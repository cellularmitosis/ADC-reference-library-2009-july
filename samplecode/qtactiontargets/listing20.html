<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/1999/REC-html401-19991224/loose.dtd">
<html>
<head>

	<!-- BEGIN META TAG INFO -->
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<link rel="home" href="http://developer.apple.com/">
	<link rel="find" href="http://developer.apple.com/search/">
	<link rel="stylesheet" type="text/css" href="../../documentation/css/adcstyle.css" title="fonts">
	<script language="JavaScript" src="../../documentation/js/adc.js" type="text/javascript"></script>
	<!-- END META TAG INFO -->
	
	<!-- BEGIN TITLE -->
	<title>qtactiontargets - /QTActionTargets.c</title>
	<!-- END TITLE -->
<script language="JavaScript">
function JumpToNewPage() {
	window.location=document.scpopupmenu.gotop.value;
	return true;
}
</script>

</head>

<!-- BEGIN BODY OPEN -->
<body>
<!--END BODY OPEN -->

<!-- START CENTER OPEN -->
<center>
<!-- END CENTER OPEN -->

	<!-- BEGIN LOGO AND SEARCH -->
	<!--#include virtual="/includes/adcnavbar"-->
	<!-- END LOGO AND SEARCH -->
		
		
	<!-- START BREADCRUMB -->
	<div id="breadcrumb">
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td scope="row"><img width="340" height="10" src="images/1dot.gif" alt=""></td>
			<td><img width="340" height="10" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr valign="middle">
			<td align="left" colspan="2">
			<a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../samplecode/index.html">Sample Code</a> &gt; <a href="../../samplecode/QuickTime/index.html">QuickTime</a> &gt; <a href="../../samplecode/QuickTime/idxWiredMoviesandSprites-date.html">Wired Movies and Sprites</a> &gt; <A HREF="javascript:location.replace('index.html');">qtactiontargets</A> &gt; 
			</td>
		</tr>
		<tr>
			<td colspan="2" scope="row"><img width="680" height="35" src="images/1dot.gif" alt=""></td>
		</tr>
	</table>
	</div>
	<!-- END BREADCRUMB -->

	

	<!-- START MAIN CONTENT -->
	
	<!-- START TITLE GRAPHIC AND INTRO-->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td><h1><div id="pagehead">qtactiontargets</div></h1></td>
		</tr>
	</table>
	<!-- END TITLE GRAPHIC AND INTRO -->
	<!-- START WIDE COLUMN -->
	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr align="left" valign="top">
			<td id="scdetails">
				<h2>/QTActionTargets.c</h2>
				<form name="scpopupmenu" onSubmit="return false;" method=post>
				<p><strong>View Source Code:</strong> 
					<select name="gotop" onChange="JumpToNewPage();" style="width:340px"><option selected value="ingnore">Select File</option>
<option value="listing1.html">/Application Files/ComApplication.c</option>
<option value="listing2.html">/Application Files/ComApplication.h</option>
<option value="listing3.html">/Application Files/ComResource.h</option>
<option value="listing4.html">/Common Files/ComFramework.c</option>
<option value="listing5.html">/Common Files/ComFramework.h</option>
<option value="listing6.html">/Common Files/EndianUtilities.c</option>
<option value="listing7.html">/Common Files/EndianUtilities.h</option>
<option value="listing8.html">/Common Files/ImageCompressionUtilities.c</option>
<option value="listing9.html">/Common Files/ImageCompressionUtilities.h</option>
<option value="listing10.html">/Common Files/MacFramework.c</option>
<option value="listing11.html">/Common Files/MacFramework.h</option>
<option value="listing12.html">/Common Files/MacPrefix.h</option>
<option value="listing13.html">/Common Files/QTUtilities.c</option>
<option value="listing14.html">/Common Files/QTUtilities.h</option>
<option value="listing15.html">/Common Files/SpriteUtilities.c</option>
<option value="listing16.html">/Common Files/SpriteUtilities.h</option>
<option value="listing17.html">/Common Files/WinFramework.c</option>
<option value="listing18.html">/Common Files/WinFramework.h</option>
<option value="listing19.html">/Common Files/WinPrefix.h</option>
<option value="listing20.html">/QTActionTargets.c</option>
<option value="listing21.html">/QTActionTargets.h</option>
<option value="listing22.html">/QTActionTargets.r</option>
<option value="listing23.html">/README.txt</option>
<option value="listing24.html">/WiredSpriteUtilities.c</option>
<option value="listing25.html">/WiredSpriteUtilities.h</option></select>
				</p>
				</form>
				<p><strong><a href="qtactiontargets.zip">Download Sample</a></strong> (&#147;qtactiontargets.zip&#148;, 761.2K)<BR>
<strong><a href="qtactiontargets.dmg">Download Sample</a></strong> (&#147;qtactiontargets.dmg&#148;, 1.19M)</p>
				<!--
				<p><strong><a href="#">Download Sample</a></strong> (&#147;filename.sit&#148;, 500K)</p>
				-->
			</td>
		</tr>
		<tr>
			<td scope="row"><img width="680" height="10" src="images/1dot.gif" alt=""><br>
			<img height="1" width="680" src="images/1dot_919699.gif" alt=""><br>
			<img width="680" height="20" src="images/1dot.gif" alt=""></td>
		</tr>
		<tr>
			<td scope="row">
	<!--googleon: index -->
<pre class="sourcecodebox">//////////////  File:    QTActionTargets.c////  Contains:  QuickTime wired sprites target support for QuickTime movies.////  Written by:  Tim Monroe////  Copyright:  &copy; 2001 by Apple Computer, Inc., all rights reserved.////  Change History (most recent first):////     &lt;2&gt;     04/07/01  rtm    added theMovieHasID parameter to QTUtils_GetMovieTargetID//     &lt;1&gt;     02/28/01  rtm    first file; based on existing QTWiredSpritesJr sample code//     ////////////////////////// header files////////////#include &quot;QTActionTargets.h&quot;////////////// global variables////////////extern short         gAppResFile;            // file reference number for this application's resource fileextern ModalFilterUPP    gModalFilterUPP;          // UPP to our custom dialog event filter////////////// QTTarg_GetStringFromUser// Display a dialog box to elicit a string from the user; return a C string that contains the text in the// dialog box when the user clicks the OK button; otherwise, return NULL.//// The caller is responsible for disposing of the pointer returned by this function (by calling free).////////////char *QTTarg_GetStringFromUser (short thePromptStringIndex){  short       myItem;  short       mySavedResFile;  GrafPtr      mySavedPort;  DialogPtr    myDialog = NULL;  short      myItemKind;  Handle      myItemHandle;  Rect      myItemRect;  Str255      myString;  char      *myCString = NULL;  OSErr      myErr = noErr;  //////////  //  // save the current resource file and graphics port  //  //////////  mySavedResFile = CurResFile();  GetPort(&amp;mySavedPort);  // set the application's resource file  UseResFile(gAppResFile);  //////////  //  // create the dialog box in which the user will enter a URL  //  //////////  myDialog = GetNewDialog(kGetStr_DLOGID, NULL, (WindowPtr)-1L);  if (myDialog == NULL)    goto bail;  QTFrame_ActivateController(QTFrame_GetFrontMovieWindow(), false);    MacSetPort(GetDialogPort(myDialog));    SetDialogDefaultItem(myDialog, kGetStr_OKButton);  SetDialogCancelItem(myDialog, kGetStr_CancelButton);    // set the prompt string    GetIndString(myString, kTextKindsResourceID, thePromptStringIndex);  GetDialogItem(myDialog, kGetStr_StrLabelItem, &amp;myItemKind, &amp;myItemHandle, &amp;myItemRect);  SetDialogItemText(myItemHandle, myString);    MacShowWindow(GetDialogWindow(myDialog));    //////////  //  // display and handle events in the dialog box until the user clicks OK or Cancel  //  //////////    do {    ModalDialog(gModalFilterUPP, &amp;myItem);  } while ((myItem != kGetStr_OKButton) &amp;&amp; (myItem != kGetStr_CancelButton));    //////////  //  // handle the selected button  //  //////////    if (myItem != kGetStr_OKButton) {    myErr = userCanceledErr;    goto bail;  }    // retrieve the edited text  GetDialogItem(myDialog, kGetStr_StrTextItem, &amp;myItemKind, &amp;myItemHandle, &amp;myItemRect);  GetDialogItemText(myItemHandle, myString);  myCString = QTUtils_ConvertPascalToCString(myString);  bail:  // restore the previous resource file and graphics port  MacSetPort(mySavedPort);  UseResFile(mySavedResFile);    if (myDialog != NULL)    DisposeDialog(myDialog);  return(myCString);}////////////// QTTarg_ShowStringToUser // Display a string in an alert box.////////////void QTTarg_ShowStringToUser (StringPtr theString){  short     mySavedResFile;  // get the current resource file and set the application's resource file  mySavedResFile = CurResFile();  UseResFile(gAppResFile);  ParamText(theString, NULL, NULL, NULL);  Alert(kQTTargAlertID, NULL);    // restore the original resource file  UseResFile(mySavedResFile);}////////////// QTTarg_CreateTwinSpritesMovie// Create a movie with two sprites that target each other.////////////OSErr QTTarg_CreateTwinSpritesMovie (void){  Movie          myMovie = NULL;  Track          myTrack = NULL;  Media          myMedia = NULL;  FSSpec          myFile;  Boolean          myIsSelected = false;  Boolean          myIsReplacing = false;    Fixed          myHeight = 0;  Fixed          myWidth = 0;  StringPtr         myPrompt = QTUtils_ConvertCToPascalString(kSpriteSavePrompt);  StringPtr         myFileName = QTUtils_ConvertCToPascalString(kSpriteSaveMovieFileName);  long          myFlags = createMovieFileDeleteCurFile | createMovieFileDontCreateResFile;  OSType          myType = FOUR_CHAR_CODE('none');  short          myResRefNum = 0;  short          myResID = movieInDataForkResID;  OSErr          myErr = noErr;  //////////  //  // create a new movie file  //  //////////  // prompt the user for the destination file name  QTFrame_PutFile(myPrompt, myFileName, &amp;myFile, &amp;myIsSelected, &amp;myIsReplacing);  myErr = myIsSelected ? noErr : userCanceledErr;  if (!myIsSelected)    goto bail;  // create a movie file for the destination movie  myErr = CreateMovieFile(&amp;myFile, FOUR_CHAR_CODE('TVOD'), smSystemScript, myFlags, &amp;myResRefNum, &amp;myMovie);  if (myErr != noErr)    goto bail;    // select the &quot;no-interface&quot; movie controller  myType = EndianU32_NtoB(myType);  SetUserDataItem(GetMovieUserData(myMovie), &amp;myType, sizeof(myType), kUserDataMovieControllerType, 1);    //////////  //  // create the sprite track and media  //  //////////    myWidth = Long2Fix(kIconSpriteTrackWidth);  myHeight = Long2Fix(kIconSpriteTrackHeight);  myTrack = NewMovieTrack(myMovie, myWidth, myHeight, kNoVolume);  myMedia = NewTrackMedia(myTrack, SpriteMediaType, kSpriteMediaTimeScale, NULL, 0);  myErr = BeginMediaEdits(myMedia);  if (myErr != noErr)    goto bail;  //////////  //  // add the appropriate samples to the sprite media  //  //////////    myErr = QTTarg_AddIconMovieSamplesToMedia(myMedia);  if (myErr != noErr)    goto bail;    myErr = EndMediaEdits(myMedia);  if (myErr != noErr)    goto bail;    // add the media to the track  InsertMediaIntoTrack(myTrack, 0, 0, GetMediaDuration(myMedia), fixed1);      //////////  //  // set the sprite track properties  //  //////////    QTTarg_SetTrackProperties(myMedia, 1);    //////////  //  // add the movie resource to the movie file  //  //////////    myErr = AddMovieResource(myMovie, myResRefNum, &amp;myResID, myFile.name);    bail:  if (myResRefNum != 0)    CloseMovieFile(myResRefNum);  if (myMovie != NULL)    DisposeMovie(myMovie);      free(myPrompt);  free(myFileName);  return(myErr);}////////////// QTTarg_AddIconMovieSamplesToMedia// Build the key frame for the icon sprites movie.////////////OSErr QTTarg_AddIconMovieSamplesToMedia (Media theMedia){  QTAtomContainer      mySample = NULL;  QTAtomContainer      mySpriteData = NULL;  QTAtom          myActionAtom = 0;  QTAtom          myTargetAtom = 0;  RGBColor        myKeyColor;  Point          myLocation;  short          isVisible, myIndex;  Fixed          myDegrees;  FixedPoint        myPoint;  OSErr          myErr = noErr;    //////////  //  // create a key frame sample containing the sprite images  //  //////////  // create a new, empty key frame sample  myErr = QTNewAtomContainer(&amp;mySample);  if (myErr != noErr)    goto bail;  myKeyColor.red = myKeyColor.green = myKeyColor.blue = 0xffff;    // white    myPoint.x = Long2Fix(kIconDimension / 2);  myPoint.y = Long2Fix(kIconDimension / 2);  // add images to the key frame sample  SpriteUtils_AddPICTImageToKeyFrameSample(mySample, kOldQTIconID, &amp;myKeyColor, kOldQTIconSpriteAtomID, &amp;myPoint, NULL);  SpriteUtils_AddPICTImageToKeyFrameSample(mySample, kNewQTIconID, &amp;myKeyColor, kNewQTIconSpriteAtomID, &amp;myPoint, NULL);  //////////  //  // add the initial sprite properties and actions to the key frame sample  //  //////////    // the old QT icon sprite  myErr = QTNewAtomContainer(&amp;mySpriteData);  if (myErr != noErr)    goto bail;  myLocation.h   = kIconDimension + (kIconDimension / 2);  myLocation.v  = ((kIconSpriteTrackHeight - kIconDimension) / 2) + (kIconDimension / 2);  isVisible    = true;  myIndex      = kOldQTIconImageIndex;    SpriteUtils_SetSpriteData(mySpriteData, &amp;myLocation, &amp;isVisible, NULL, &amp;myIndex, NULL, NULL, NULL);  WiredUtils_AddQTEventAndActionAtoms(mySpriteData, kParentAtomIsContainer, kQTEventMouseClickEndTriggerButton, kActionSpriteRotate, &amp;myActionAtom);  myDegrees = EndianS32_NtoB(FixRatio(90, 1));  WiredUtils_AddActionParameterAtom(mySpriteData, myActionAtom, kFirstParam, sizeof(myDegrees), &amp;myDegrees, NULL);  WiredUtils_AddSpriteIDActionTargetAtom(mySpriteData, myActionAtom, 2, NULL);  SpriteUtils_AddSpriteToSample(mySample, mySpriteData, kOldQTIconSpriteAtomID);    QTDisposeAtomContainer(mySpriteData);    // the new QT icon sprite  myErr = QTNewAtomContainer(&amp;mySpriteData);  if (myErr != noErr)    goto bail;  myLocation.h   = kIconSpriteTrackWidth - (kIconDimension + (kIconDimension / 2));  myLocation.v  = ((kIconSpriteTrackHeight - kIconDimension) / 2) + (kIconDimension / 2);  isVisible    = true;  myIndex      = kNewQTIconImageIndex;    SpriteUtils_SetSpriteData(mySpriteData, &amp;myLocation, &amp;isVisible, NULL, &amp;myIndex, NULL, NULL, NULL);  WiredUtils_AddQTEventAndActionAtoms(mySpriteData, kParentAtomIsContainer, kQTEventMouseClickEndTriggerButton, kActionSpriteRotate, &amp;myActionAtom);  myDegrees = EndianS32_NtoB(FixRatio(90, 1));  WiredUtils_AddActionParameterAtom(mySpriteData, myActionAtom, kFirstParam, sizeof(myDegrees), &amp;myDegrees, NULL);  WiredUtils_AddSpriteIDActionTargetAtom(mySpriteData, myActionAtom, 1, NULL);  SpriteUtils_AddSpriteToSample(mySample, mySpriteData, kNewQTIconSpriteAtomID);    SpriteUtils_AddSpriteSampleToMedia(theMedia, mySample, kSpriteMediaFrameDurationIcon, true, NULL);  bail:    if (mySample != NULL)    QTDisposeAtomContainer(mySample);  if (mySpriteData != NULL)    QTDisposeAtomContainer(mySpriteData);    return(myErr);}////////////// QTTarg_AddVRControllerButtonSamplesToMedia// Build the key frame for the VR controller sprite track.////////////void QTTarg_AddVRControllerButtonSamplesToMedia (Media theMedia, long theTrackWidth, long theTrackHeight, TimeValue theDuration){#pragma unused(theTrackHeight)  QTAtomContainer      mySample = NULL;  QTAtomContainer      myActions = NULL;  QTAtomContainer      myTiltUpButton, myPanRightButton, myTiltDownButton, myZoomInButton, myPanLeftButton, myZoomOutButton;  RGBColor        myKeyColor;  Point          myLocation;  short          isVisible, myIndex, myLayer;  short          myCount;  long          mySixth;  QTAtom          myActionAtom = 0;  QTAtom          myParamAtom = 0;  float          myDeltaAngle = 0;  StringPtr        myMovieNames[2];  OSErr          myErr = noErr;    //////////  //  // set up the two target movie names  //  //////////  myMovieNames[0] = QTUtils_ConvertCToPascalString(kTarget1);  myMovieNames[1] = QTUtils_ConvertCToPascalString(kTarget2);  //////////  //  // create a key frame sample containing the sprite images  //  //////////  // create a new, empty key frame sample  myErr = QTNewAtomContainer(&amp;mySample);  if (myErr != noErr)    goto bail;  myKeyColor.red = myKeyColor.green = myKeyColor.blue = 0xffff;    // white    // add images to the key frame sample  for (myCount = 0; myCount &lt; kNumControllerImages; myCount++)    SpriteUtils_AddPICTImageToKeyFrameSample(mySample, kFirstControllerImageID + myCount, &amp;myKeyColor, myCount + 1, NULL, NULL);  // assign group IDs to the images  SpriteUtils_AssignImageGroupIDsToKeyFrame(mySample);    //////////  //  // add the initial sprite properties and actions to the key frame sample  //  //////////    mySixth = theTrackWidth / kNumControllerButtons;  // the Tilt-Up button sprite  myErr = QTNewAtomContainer(&amp;myTiltUpButton);  if (myErr != noErr)    goto bail;  myLocation.h   = (kTiltPosSpritePosition * mySixth) + ((mySixth - kButtonWidth) / 2);  myLocation.v  = 0;  isVisible    = true;  myIndex      = kTiltPosUpIndex;  myLayer      = 1;  myDeltaAngle  = 1;  EndianUtils_Float_NtoB(&amp;myDeltaAngle);    for (myCount = 0; myCount &lt;= 1; myCount++) {    SpriteUtils_SetSpriteData(myTiltUpButton, &amp;myLocation, &amp;isVisible, &amp;myLayer, &amp;myIndex, NULL, NULL, NULL);    WiredUtils_AddSpriteSetImageIndexAction(myTiltUpButton, kParentAtomIsContainer, kQTEventMouseEnter, 0, NULL, 0, 0, NULL, kTiltPosDownIndex, NULL);    WiredUtils_AddSpriteSetImageIndexAction(myTiltUpButton, kParentAtomIsContainer, kQTEventMouseExit, 0, NULL, 0, 0, NULL, kTiltPosUpIndex, NULL);    WiredUtils_AddSpriteTrackSetVariableAction(myTiltUpButton, kParentAtomIsContainer, kQTEventMouseEnter, kMouseOverTiltUpVariableID, 1, 0, NULL, 0);    WiredUtils_AddSpriteTrackSetVariableAction(myTiltUpButton, kParentAtomIsContainer, kQTEventMouseExit, kMouseOverTiltUpVariableID, 0, 0, NULL, 0);    QTTarg_AddIdleEventVarTestAction(myTiltUpButton, kParentAtomIsContainer, kMouseOverTiltUpVariableID, 1, kActionQTVRSetTiltAngle, &amp;myActionAtom);    WiredUtils_AddActionParameterAtom(myTiltUpButton, myActionAtom, kFirstParam, sizeof(myDeltaAngle), &amp;myDeltaAngle, NULL);    WiredUtils_AddActionParameterOptions(myTiltUpButton, myActionAtom, 1, kActionFlagActionIsDelta, 0, NULL, 0, NULL);    WiredUtils_AddMovieNameActionTargetAtom(myTiltUpButton, myActionAtom, myMovieNames[myCount], NULL);  }    SpriteUtils_AddSpriteToSample(mySample, myTiltUpButton, kTiltPosSpriteAtomID);    // the Pan-Right button sprite  myErr = QTNewAtomContainer(&amp;myPanRightButton);  if (myErr != noErr)    goto bail;  myLocation.h   = (kPanRightSpritePosition * mySixth) + ((mySixth - kButtonWidth) / 2);  myLocation.v  = 0;  isVisible    = true;  myIndex      = kPanRightUpIndex;  myLayer      = 1;  myDeltaAngle  = -3;  EndianUtils_Float_NtoB(&amp;myDeltaAngle);    SpriteUtils_SetSpriteData(myPanRightButton, &amp;myLocation, &amp;isVisible, &amp;myLayer, &amp;myIndex, NULL, NULL, NULL);  for (myCount = 0; myCount &lt;= 1; myCount++) {    WiredUtils_AddSpriteSetImageIndexAction(myPanRightButton, kParentAtomIsContainer, kQTEventMouseEnter, 0, NULL, 0, 0, NULL, kPanRightDownIndex, NULL);    WiredUtils_AddSpriteSetImageIndexAction(myPanRightButton, kParentAtomIsContainer, kQTEventMouseExit, 0, NULL, 0, 0, NULL, kPanRightUpIndex, NULL);    WiredUtils_AddSpriteTrackSetVariableAction(myPanRightButton, kParentAtomIsContainer, kQTEventMouseEnter, kMouseOverPanRightVariableID, 1, 0, NULL, 0);    WiredUtils_AddSpriteTrackSetVariableAction(myPanRightButton, kParentAtomIsContainer, kQTEventMouseExit, kMouseOverPanRightVariableID, 0, 0, NULL, 0);    QTTarg_AddIdleEventVarTestAction(myPanRightButton, kParentAtomIsContainer, kMouseOverPanRightVariableID, 1, kActionQTVRSetPanAngle, &amp;myActionAtom);    WiredUtils_AddActionParameterAtom(myPanRightButton, myActionAtom, kFirstParam, sizeof(myDeltaAngle), &amp;myDeltaAngle, NULL);    WiredUtils_AddActionParameterOptions(myPanRightButton, myActionAtom, 1, kActionFlagActionIsDelta | kActionFlagParameterWrapsAround, 0, NULL, 0, NULL);    WiredUtils_AddMovieNameActionTargetAtom(myPanRightButton, myActionAtom, myMovieNames[myCount], NULL);  }    SpriteUtils_AddSpriteToSample(mySample, myPanRightButton, kPanRightSpriteAtomID);    // the Pan-Left button sprite  myErr = QTNewAtomContainer(&amp;myPanLeftButton);  if (myErr != noErr)    goto bail;  myLocation.h   = (kPanLeftSpritePosition * mySixth) + ((mySixth - kButtonWidth) / 2);  myLocation.v  = 0;  isVisible    = true;  myIndex      = kPanLeftUpIndex;  myLayer      = 1;  myDeltaAngle  = 3;  EndianUtils_Float_NtoB(&amp;myDeltaAngle);    SpriteUtils_SetSpriteData(myPanLeftButton, &amp;myLocation, &amp;isVisible, &amp;myLayer, &amp;myIndex, NULL, NULL, NULL);    for (myCount = 0; myCount &lt;= 1; myCount++) {    WiredUtils_AddSpriteSetImageIndexAction(myPanLeftButton, kParentAtomIsContainer, kQTEventMouseEnter, 0, NULL, 0, 0, NULL, kPanLeftDownIndex, NULL);    WiredUtils_AddSpriteSetImageIndexAction(myPanLeftButton, kParentAtomIsContainer, kQTEventMouseExit, 0, NULL, 0, 0, NULL, kPanLeftUpIndex, NULL);    WiredUtils_AddSpriteTrackSetVariableAction(myPanLeftButton, kParentAtomIsContainer, kQTEventMouseEnter, kMouseOverPanLeftVariableID, 1, 0, NULL, 0);    WiredUtils_AddSpriteTrackSetVariableAction(myPanLeftButton, kParentAtomIsContainer, kQTEventMouseExit, kMouseOverPanLeftVariableID, 0, 0, NULL, 0);    QTTarg_AddIdleEventVarTestAction(myPanLeftButton, kParentAtomIsContainer, kMouseOverPanLeftVariableID, 1, kActionQTVRSetPanAngle, &amp;myActionAtom);    WiredUtils_AddActionParameterAtom(myPanLeftButton, myActionAtom, kFirstParam, sizeof(myDeltaAngle), &amp;myDeltaAngle, NULL);    WiredUtils_AddActionParameterOptions(myPanLeftButton, myActionAtom, 1, kActionFlagActionIsDelta | kActionFlagParameterWrapsAround, 0, NULL, 0, NULL);    WiredUtils_AddMovieNameActionTargetAtom(myPanLeftButton, myActionAtom, myMovieNames[myCount], NULL);  }  SpriteUtils_AddSpriteToSample(mySample, myPanLeftButton, kPanLeftSpriteAtomID);    // the Zoom-Out button sprite  myErr = QTNewAtomContainer(&amp;myZoomOutButton);  if (myErr != noErr)    goto bail;  myLocation.h   = (kZoomOutSpritePosition * mySixth) + ((mySixth - kButtonWidth) / 2);  myLocation.v  = 0;  isVisible    = true;  myIndex      = kZoomOutUpIndex;  myLayer      = 1;  myDeltaAngle  = 1;  EndianUtils_Float_NtoB(&amp;myDeltaAngle);    SpriteUtils_SetSpriteData(myZoomOutButton, &amp;myLocation, &amp;isVisible, &amp;myLayer, &amp;myIndex, NULL, NULL, NULL);    for (myCount = 0; myCount &lt;= 1; myCount++) {    WiredUtils_AddSpriteSetImageIndexAction(myZoomOutButton, kParentAtomIsContainer, kQTEventMouseEnter, 0, NULL, 0, 0, NULL, kZoomOutDownIndex, NULL);    WiredUtils_AddSpriteSetImageIndexAction(myZoomOutButton, kParentAtomIsContainer, kQTEventMouseExit, 0, NULL, 0, 0, NULL, kZoomOutUpIndex, NULL);    WiredUtils_AddSpriteTrackSetVariableAction(myZoomOutButton, kParentAtomIsContainer, kQTEventMouseEnter, kMouseOverZoomOutVariableID, 1, 0, NULL, 0);    WiredUtils_AddSpriteTrackSetVariableAction(myZoomOutButton, kParentAtomIsContainer, kQTEventMouseExit, kMouseOverZoomOutVariableID, 0, 0, NULL, 0);    QTTarg_AddIdleEventVarTestAction(myZoomOutButton, kParentAtomIsContainer, kMouseOverZoomOutVariableID, 1, kActionQTVRSetFieldOfView, &amp;myActionAtom);    WiredUtils_AddActionParameterAtom(myZoomOutButton, myActionAtom, kFirstParam, sizeof(myDeltaAngle), &amp;myDeltaAngle, NULL);    WiredUtils_AddActionParameterOptions(myZoomOutButton, myActionAtom, 1, kActionFlagActionIsDelta, 0, NULL, 0, NULL);    WiredUtils_AddMovieNameActionTargetAtom(myZoomOutButton, myActionAtom, myMovieNames[myCount], NULL);  }  SpriteUtils_AddSpriteToSample(mySample, myZoomOutButton, kZoomOutSpriteAtomID);    // the Tilt-Down button sprite  myErr = QTNewAtomContainer(&amp;myTiltDownButton);  if (myErr != noErr)    goto bail;  myLocation.h   = (kTiltNegSpritePosition * mySixth) + ((mySixth - kButtonWidth) / 2);  myLocation.v  = 0;  isVisible    = true;  myIndex      = kTiltNegUpIndex;  myLayer      = 1;  myDeltaAngle  = -1;  EndianUtils_Float_NtoB(&amp;myDeltaAngle);    SpriteUtils_SetSpriteData(myTiltDownButton, &amp;myLocation, &amp;isVisible, &amp;myLayer, &amp;myIndex, NULL, NULL, NULL);  for (myCount = 0; myCount &lt;= 1; myCount++) {    WiredUtils_AddSpriteSetImageIndexAction(myTiltDownButton, kParentAtomIsContainer, kQTEventMouseEnter, 0, NULL, 0, 0, NULL, kTiltNegDownIndex, NULL);    WiredUtils_AddSpriteSetImageIndexAction(myTiltDownButton, kParentAtomIsContainer, kQTEventMouseExit, 0, NULL, 0, 0, NULL, kTiltNegUpIndex, NULL);    WiredUtils_AddSpriteTrackSetVariableAction(myTiltDownButton, kParentAtomIsContainer, kQTEventMouseEnter, kMouseOverTiltDownVariableID, 1, 0, NULL, 0);    WiredUtils_AddSpriteTrackSetVariableAction(myTiltDownButton, kParentAtomIsContainer, kQTEventMouseExit, kMouseOverTiltDownVariableID, 0, 0, NULL, 0);    QTTarg_AddIdleEventVarTestAction(myTiltDownButton, kParentAtomIsContainer, kMouseOverTiltDownVariableID, 1, kActionQTVRSetTiltAngle, &amp;myActionAtom);    WiredUtils_AddActionParameterAtom(myTiltDownButton, myActionAtom, kFirstParam, sizeof(myDeltaAngle), &amp;myDeltaAngle, NULL);    WiredUtils_AddActionParameterOptions(myTiltDownButton, myActionAtom, 1, kActionFlagActionIsDelta, 0, NULL, 0, NULL);    WiredUtils_AddMovieNameActionTargetAtom(myTiltDownButton, myActionAtom, myMovieNames[myCount], NULL);  }  SpriteUtils_AddSpriteToSample(mySample, myTiltDownButton, kTiltNegSpriteAtomID);    // the Zoom-In button sprite  myErr = QTNewAtomContainer(&amp;myZoomInButton);  if (myErr != noErr)    goto bail;  myLocation.h   = (kZoomInSpritePosition * mySixth) + ((mySixth - kButtonWidth) / 2);  myLocation.v  = 0;  isVisible    = true;  myIndex      = kZoomInUpIndex;  myLayer      = 1;  myDeltaAngle  = -1;  EndianUtils_Float_NtoB(&amp;myDeltaAngle);    SpriteUtils_SetSpriteData(myZoomInButton, &amp;myLocation, &amp;isVisible, &amp;myLayer, &amp;myIndex, NULL, NULL, NULL);    for (myCount = 0; myCount &lt;= 1; myCount++) {    WiredUtils_AddSpriteSetImageIndexAction(myZoomInButton, kParentAtomIsContainer, kQTEventMouseEnter, 0, NULL, 0, 0, NULL, kZoomInDownIndex, NULL);    WiredUtils_AddSpriteSetImageIndexAction(myZoomInButton, kParentAtomIsContainer, kQTEventMouseExit, 0, NULL, 0, 0, NULL, kZoomInUpIndex, NULL);    WiredUtils_AddSpriteTrackSetVariableAction(myZoomInButton, kParentAtomIsContainer, kQTEventMouseEnter, kMouseOverZoomInVariableID, 1, 0, NULL, 0);    WiredUtils_AddSpriteTrackSetVariableAction(myZoomInButton, kParentAtomIsContainer, kQTEventMouseExit, kMouseOverZoomInVariableID, 0, 0, NULL, 0);    QTTarg_AddIdleEventVarTestAction(myZoomInButton, kParentAtomIsContainer, kMouseOverZoomInVariableID, 1, kActionQTVRSetFieldOfView, &amp;myActionAtom);    WiredUtils_AddActionParameterAtom(myZoomInButton, myActionAtom, kFirstParam, sizeof(myDeltaAngle), &amp;myDeltaAngle, NULL);    WiredUtils_AddActionParameterOptions(myZoomInButton, myActionAtom, 1, kActionFlagActionIsDelta, 0, NULL, 0, NULL);    WiredUtils_AddMovieNameActionTargetAtom(myZoomInButton, myActionAtom, myMovieNames[myCount], NULL);  }  SpriteUtils_AddSpriteToSample(mySample, myZoomInButton, kZoomInSpriteAtomID);    SpriteUtils_AddSpriteSampleToMedia(theMedia, mySample, theDuration, true, NULL);  bail:  free(myMovieNames[0]);  free(myMovieNames[1]);  if (mySample != NULL)    QTDisposeAtomContainer(mySample);  if (myTiltUpButton != NULL)    QTDisposeAtomContainer(myTiltUpButton);    if (myPanRightButton != NULL)    QTDisposeAtomContainer(myPanRightButton);    if (myTiltDownButton != NULL)    QTDisposeAtomContainer(myTiltDownButton);    if (myZoomInButton != NULL)    QTDisposeAtomContainer(myZoomInButton);    if (myPanLeftButton != NULL)    QTDisposeAtomContainer(myPanLeftButton);    if (myZoomOutButton != NULL)    QTDisposeAtomContainer(myZoomOutButton);  }////////////// QTTarg_AddTextButtonSamplesToMedia// Build the key frame for the text button sprite track.////////////void QTTarg_AddTextButtonSamplesToMedia (Media theMedia, long theTrackWidth, long theTrackHeight, TimeValue theDuration){#pragma unused(theTrackWidth, theTrackHeight)  QTAtomContainer      mySample = NULL;  QTAtomContainer      myTextButton;  QTAtom          myActionAtom = 0;  RGBColor        myKeyColor;  Point          myLocation;  short          isVisible, myIndex, myLayer;  short          myCount;  OSErr          myErr = noErr;    //////////  //  // create a key frame sample containing the sprite images  //  //////////  // create a new, empty key frame sample  myErr = QTNewAtomContainer(&amp;mySample);  if (myErr != noErr)    goto bail;  myKeyColor.red = myKeyColor.green = myKeyColor.blue = 0xffff;    // white    // add images to the key frame sample  for (myCount = 0; myCount &lt; kNumTextImages; myCount++)    SpriteUtils_AddPICTImageToKeyFrameSample(mySample, kFirstTextImageID + myCount, &amp;myKeyColor, myCount + 1, NULL, NULL);  // assign group IDs to the images  SpriteUtils_AssignImageGroupIDsToKeyFrame(mySample);    //////////  //  // add the initial sprite properties and actions to the key frame sample  //  //////////    // the Text button sprite  myErr = QTNewAtomContainer(&amp;myTextButton);  if (myErr != noErr)    goto bail;  myLocation.h   = kButtonWidth / 2;  myLocation.v  = kButtonHeight / 2;  isVisible    = true;  myIndex      = kTextUpIndex;  myLayer      = 1;    SpriteUtils_SetSpriteData(myTextButton, &amp;myLocation, &amp;isVisible, &amp;myLayer, &amp;myIndex, NULL, NULL, NULL);    WiredUtils_AddSpriteSetImageIndexAction(myTextButton, kParentAtomIsContainer, kQTEventMouseClick, 0, NULL, 0, 0, NULL, kTextDownIndex, NULL);  WiredUtils_AddSpriteSetImageIndexAction(myTextButton, kParentAtomIsContainer, kQTEventMouseClickEnd, 0, NULL, 0, 0, NULL, kTextUpIndex, NULL);  WiredUtils_AddQTEventAndActionAtoms(myTextButton, kParentAtomIsContainer, kQTEventMouseClickEndTriggerButton, kActionTrackSetEnabled, &amp;myActionAtom);  WiredUtils_AddActionParameterOptions(myTextButton, myActionAtom, 1, kActionFlagActionIsToggle, 0, NULL, 0, NULL);  WiredUtils_AddTrackTargetAtom(myTextButton, myActionAtom, kTargetTrackType, (void *)TextMediaType, 1);    SpriteUtils_AddSpriteToSample(mySample, myTextButton, kTextSpriteAtomID);    SpriteUtils_AddSpriteSampleToMedia(theMedia, mySample, theDuration, true, NULL);  bail:    if (mySample != NULL)    QTDisposeAtomContainer(mySample);  if (myTextButton != NULL)    QTDisposeAtomContainer(myTextButton);  }////////////// QTTarg_AddVRSpriteControllerTrack// Add a track to the specified VR movie that contains wired sprites for controlling the movie.//// We add six sprites to the track, which will function like buttons. On mouse over, the image// of the sprite is changed to the &quot;clicked&quot; image; on mouse exit, the image is returned to the// normal &quot;unclicked&quot; image; on idle events we execute an action (for instance kActionMovieGoToBeginning).// No other logic and no sprite track variables are required here.////////////OSErr QTTarg_MakeDualVRControllerMovie (void){  Movie          myMovie = NULL;  Track          myTrack = NULL;  Media          myMedia = NULL;  RGBColor        myKeyColor;  Fixed          myWidth, myHeight;  FSSpec          myFile;  Boolean          myIsSelected = false;  Boolean          myIsReplacing = false;    StringPtr         myPrompt = QTUtils_ConvertCToPascalString(kSpriteSavePrompt);  StringPtr         myFileName = QTUtils_ConvertCToPascalString(kSpriteSaveMovieFileName);  long          myFlags = createMovieFileDeleteCurFile | createMovieFileDontCreateResFile;  short          myResRefNum = 0;  short          myResID = movieInDataForkResID;  OSType          myType = FOUR_CHAR_CODE('none');  OSErr          myErr = noErr;  //////////  //  // create a new movie file  //  //////////  // prompt the user for the destination file name  QTFrame_PutFile(myPrompt, myFileName, &amp;myFile, &amp;myIsSelected, &amp;myIsReplacing);  myErr = myIsSelected ? noErr : userCanceledErr;  if (!myIsSelected)    goto bail;  // create a movie file for the destination movie  myErr = CreateMovieFile(&amp;myFile, FOUR_CHAR_CODE('TVOD'), smSystemScript, myFlags, &amp;myResRefNum, &amp;myMovie);  if (myErr != noErr)    goto bail;    // select the &quot;no-interface&quot; movie controller  myType = EndianU32_NtoB(myType);  SetUserDataItem(GetMovieUserData(myMovie), &amp;myType, sizeof(myType), kUserDataMovieControllerType, 1);  //////////  //  // get some information about the target movie  //  //////////  myWidth = Long2Fix(kVRControlMovieWidth);  myHeight = Long2Fix(kVRControlMovieHeight);    //////////  //  // create a new sprite track in the target movie  //  //////////    myTrack = NewMovieTrack(myMovie, myWidth, myHeight, kNoVolume);  myMedia = NewTrackMedia(myTrack, SpriteMediaType, kVRControlMovieDuration, NULL, 0);  myErr = BeginMediaEdits(myMedia);  if (myErr != noErr)    goto bail;    //////////  //  // add sprite images and sprites to the sprite track; add actions to the sprites  //  //////////    QTTarg_AddVRControllerButtonSamplesToMedia(myMedia, kVRControlMovieWidth, kVRControlMovieHeight, kVRControlMovieDuration);    //////////  //  // insert media into track  //  //////////    myErr = EndMediaEdits(myMedia);  if (myErr != noErr)    goto bail;    // add the media to the track  InsertMediaIntoTrack(myTrack, 0, 0, GetMediaDuration(myMedia), fixed1);      //////////  //  // set the sprite track properties  //  //////////    QTTarg_SetTrackProperties(myMedia, 0);                // idle as fast as possible    myKeyColor.red = myKeyColor.green = myKeyColor.blue = 0xffff;    // white  MediaSetGraphicsMode(GetMediaHandler(myMedia), transparent, &amp;myKeyColor);    //////////  //  // add the movie resource to the movie file  //  //////////    myErr = AddMovieResource(myMovie, myResRefNum, &amp;myResID, myFile.name);    bail:  if (myResRefNum != 0)    CloseMovieFile(myResRefNum);  if (myMovie != NULL)    DisposeMovie(myMovie);      free(myPrompt);  free(myFileName);  return(myErr);}////////////// QTTarg_AddTextToggleButtonTrack// Add a track to the specified movie that contains a wired sprite for toggling the visibility// state of the first text track in the movie.////////////OSErr QTTarg_AddTextToggleButtonTrack (Movie theMovie){  Track          myTrack = NULL;  Media          myMedia = NULL;  MatrixRecord      myMatrix;  RGBColor        myKeyColor;  Fixed          myWidth, myHeight;  TimeValue        myDuration = 0L;  TimeValue        myTimeScale = 0L;  OSErr          myErr = noErr;  //////////  //  // get some information about the target movie  //  //////////  if (theMovie == NULL) {    myErr = paramErr;    goto bail;  }  myWidth = Long2Fix(2 * kButtonWidth);  myHeight = Long2Fix(2 * kButtonHeight);  myDuration = GetMovieDuration(theMovie);  myTimeScale = GetMovieTimeScale(theMovie);    //////////  //  // create a new sprite track in the target movie  //  //////////    myTrack = NewMovieTrack(theMovie, myWidth, myHeight, kNoVolume);  myMedia = NewTrackMedia(myTrack, SpriteMediaType, myTimeScale, NULL, 0);  // set the track matrix to compensate for any existing movie matrix  GetMovieMatrix(theMovie, &amp;myMatrix);  if (InverseMatrix(&amp;myMatrix, &amp;myMatrix))    SetTrackMatrix(myTrack, &amp;myMatrix);  myErr = BeginMediaEdits(myMedia);  if (myErr != noErr)    goto bail;    //////////  //  // add sprite images and sprites to the sprite track; add actions to the sprites  //  //////////    QTTarg_AddTextButtonSamplesToMedia(myMedia, 2 * kButtonWidth, 2 * kButtonHeight, myDuration);    //////////  //  // insert media into track  //  //////////    myErr = EndMediaEdits(myMedia);  if (myErr != noErr)    goto bail;    // add the media to the track  InsertMediaIntoTrack(myTrack, 0, 0, GetMediaDuration(myMedia), fixed1);      //////////  //  // set the sprite track properties  //  //////////    QTTarg_SetTrackProperties(myMedia, kNoQTIdleEvents);        // no idle events    myKeyColor.red = myKeyColor.green = myKeyColor.blue = 0xffff;    // white  MediaSetGraphicsMode(GetMediaHandler(myMedia), transparent, &amp;myKeyColor);    // make sure that the sprite track is in the frontmost layer  SetTrackLayer(myTrack, kMaxLayerNumber);  SetTrackLayer(myTrack, QTTarg_GetLowestLayerInMovie(theMovie) - 1);    bail:  return(myErr);}////////////// QTTarg_SetTrackProperties// Set the track properties for the specified sample sprite movie.////////////void QTTarg_SetTrackProperties (Media theMedia, UInt32 theIdleFrequency){  QTAtomContainer    myTrackProperties;  RGBColor      myBackgroundColor;  Boolean        hasActions;  UInt32        myFrequency;  OSErr        myErr = noErr;      // add a background color to the sprite track  myBackgroundColor.red = EndianU16_NtoB(0xffff);  myBackgroundColor.green = EndianU16_NtoB(0xffff);  myBackgroundColor.blue = EndianU16_NtoB(0xffff);    myErr = QTNewAtomContainer(&amp;myTrackProperties);  if (myErr == noErr) {    QTInsertChild(myTrackProperties, 0, kSpriteTrackPropertyBackgroundColor, 1, 1, sizeof(myBackgroundColor), &amp;myBackgroundColor, NULL);    // tell the movie controller that this sprite track has actions    hasActions = true;    QTInsertChild(myTrackProperties, 0, kSpriteTrackPropertyHasActions, 1, 1, sizeof(hasActions), &amp;hasActions, NULL);      // tell the sprite track to generate QTIdleEvents    myFrequency = EndianU32_NtoB(theIdleFrequency);    QTInsertChild(myTrackProperties, 0, kSpriteTrackPropertyQTIdleEventsFrequency, 1, 1, sizeof(myFrequency), &amp;myFrequency, NULL);    SetMediaPropertyAtom(theMedia, myTrackProperties);        QTDisposeAtomContainer(myTrackProperties);  }}  ////////////// QTTarg_GetLowestLayerInMovie// Return the layer of the frontmost layer in the specified movie.////////////short QTTarg_GetLowestLayerInMovie (Movie theMovie){  long    myCount = 0;  long    myIndex;  short    myLayer = 0;  short    myMinLayer = kMaxLayerNumber;    myCount = GetMovieTrackCount(theMovie);    for (myIndex = 1; myIndex &lt;= myCount; myIndex++) {    myLayer = GetTrackLayer(GetMovieIndTrack(theMovie, myIndex));    if (myLayer &lt; myMinLayer)      myMinLayer = myLayer;  }    return(myMinLayer);}////////////// QTTarg_AddIdleEventVarTestAction// Add, to the specified atom, a conditional atom that executes the specified action if theVariableID = theTrueValue.////////////OSErr QTTarg_AddIdleEventVarTestAction (QTAtomContainer theContainer, QTAtom theAtom, QTAtomID theVariableID, UInt32 theTrueValue, long theActionConstant, QTAtom *theNewActionAtom){  QTAtom    myActionAtom = 0;  QTAtom    myParamAtom = 0;  QTAtom    myConditionalAtom = 0;  QTAtom    myExpressionAtom = 0;  QTAtom    myOperatorAtom = 0;  QTAtom    myActionListAtom = 0;  OSErr    myErr = noErr;    myErr = WiredUtils_AddQTEventAndActionAtoms(theContainer, theAtom, kQTEventIdle, kActionCase, &amp;myActionAtom);  if (myErr != noErr)    goto bail;  // add a parameter atom to the kActionCase action atom; this will serve as a parent to hold the expression and action atoms  myErr = WiredUtils_AddActionParameterAtom(theContainer, myActionAtom, kFirstParam, 0, NULL, &amp;myParamAtom);  if (myErr != noErr)    goto bail;    myErr = WiredUtils_AddConditionalAtom(theContainer, myParamAtom, 1, &amp;myConditionalAtom);  if (myErr != noErr)    goto bail;      myErr = WiredUtils_AddExpressionContainerAtomType(theContainer, myConditionalAtom, &amp;myExpressionAtom);  if (myErr != noErr)    goto bail;      myErr = WiredUtils_AddOperatorAtom(theContainer, myExpressionAtom, kOperatorEqualTo, &amp;myOperatorAtom);  if (myErr != noErr)    goto bail;  myErr = WiredUtils_AddOperandAtom(theContainer, myOperatorAtom, kOperandConstant, 1, NULL, theTrueValue);  if (myErr != noErr)    goto bail;  myErr = WiredUtils_AddVariableOperandAtom(theContainer, myOperatorAtom, 2, 0, NULL, 0, theVariableID);  if (myErr != noErr)    goto bail;      myErr = WiredUtils_AddActionListAtom(theContainer, myConditionalAtom, &amp;myActionListAtom);  if (myErr != noErr)    goto bail;  myErr = WiredUtils_AddActionAtom(theContainer, myActionListAtom, theActionConstant, theNewActionAtom);  if (myErr != noErr)    goto bail;bail:  return(myErr);}/////////////////////////////////////////////////////////////////////////////////////////////////////////////// Target utilities//// Use these functions to get, set, and find wired action movie targets./////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// QTUtils_GetMovieTargetName// Get the movie target name stored in the specified movie.//// The caller is responsible for disposing of the pointer returned by this function (by calling free).////////////char *QTUtils_GetMovieTargetName (Movie theMovie){  UserData    myUserData = NULL;  char       *myString = NULL;    // make sure we've got a movie  if (theMovie == NULL)    goto bail;    // get the movie's user data list  myUserData = GetMovieUserData(theMovie);  if (myUserData == NULL)    goto bail;  // find the &quot;value&quot; of the user data item of type 'plug' that begins with the string &quot;moviename=&quot;  myString = QTUtils_GetUserDataPrefixedValue(myUserData, FOUR_CHAR_CODE('plug'), kMovieNamePrefix);bail:  return(myString);}////////////// QTUtils_SetMovieTargetName// Set the movie target name stored in the specified movie.////////////OSErr QTUtils_SetMovieTargetName (Movie theMovie, char *theTargetName){  UserData    myUserData = NULL;  char       *myString = NULL;  Handle      myHandle = NULL;  OSErr      myErr = noErr;  // make sure we've got a movie and a name  if ((theMovie == NULL) || (theTargetName == NULL))    return(paramErr);      // get the movie's user data list  myUserData = GetMovieUserData(theMovie);  if (myUserData == NULL)    return(paramErr);  // remove any existing movie target name  while (QTUtils_FindUserDataItemWithPrefix(myUserData, FOUR_CHAR_CODE('plug'), kMovieNamePrefix) != 0)    RemoveUserData(myUserData, FOUR_CHAR_CODE('plug'), QTUtils_FindUserDataItemWithPrefix(myUserData, FOUR_CHAR_CODE('plug'), kMovieNamePrefix));  // create the user data item data  myString = malloc(strlen(kMovieNamePrefix) + strlen(theTargetName) + 2 + 1);  // 2 + 1 == '\&quot;' + '\&quot;' + '\0'  if (myString != NULL) {    myString[0] = '\0';    strcat(myString, kMovieNamePrefix);    strcat(myString, &quot;\&quot;&quot;);    strcat(myString, theTargetName);    strcat(myString, &quot;\&quot;&quot;);    // add in a new user data item    PtrToHand(myString, &amp;myHandle, strlen(myString));    if (myHandle != NULL)      myErr = AddUserData(myUserData, myHandle, FOUR_CHAR_CODE('plug'));  } else {    myErr = memFullErr;  }    free(myString);    if (myHandle != NULL)    DisposeHandle(myHandle);  return(myErr);}////////////// QTUtils_GetMovieTargetID// Get the movie target ID stored in the specified movie.////////////long QTUtils_GetMovieTargetID (Movie theMovie, Boolean *theMovieHasID){  UserData    myUserData = NULL;  long      myID = 0;  char       *myString = NULL;  StringPtr     myPString = NULL;  Boolean      myMovieHasID = false;  OSErr      myErr = noErr;    // make sure we've got a movie  if (theMovie == NULL)    goto bail;    // get the movie's user data list  myUserData = GetMovieUserData(theMovie);  if (myUserData == NULL)    goto bail;  // find the &quot;value&quot; of the user data item of type 'plug' that begins with the string &quot;movieid=&quot;  myString = QTUtils_GetUserDataPrefixedValue(myUserData, FOUR_CHAR_CODE('plug'), kMovieIDPrefix);    // convert the string into a number  if (myString != NULL) {    myPString = QTUtils_ConvertCToPascalString(myString);    StringToNum(myPString, &amp;myID);    myMovieHasID = true;  }bail:  free(myString);  free(myPString);  if (theMovieHasID != NULL)    *theMovieHasID = myMovieHasID;      return(myID);}////////////// QTUtils_SetMovieTargetID// Set the movie target ID stored in the specified movie.////////////OSErr QTUtils_SetMovieTargetID (Movie theMovie, long theTargetID){  UserData    myUserData = NULL;  long      myID = 0;  char       *myString = NULL;  Str255       myPString;  char       *myCString = NULL;  Handle      myHandle = NULL;  OSErr      myErr = noErr;  // make sure we've got a movie  if (theMovie == NULL)    return(paramErr);      // get the movie's user data list  myUserData = GetMovieUserData(theMovie);  if (myUserData == NULL)    return(paramErr);  // remove any existing movie target ID  while (QTUtils_FindUserDataItemWithPrefix(myUserData, FOUR_CHAR_CODE('plug'), kMovieIDPrefix) != 0)    RemoveUserData(myUserData, FOUR_CHAR_CODE('plug'), QTUtils_FindUserDataItemWithPrefix(myUserData, FOUR_CHAR_CODE('plug'), kMovieIDPrefix));  // convert the ID into a string  NumToString(theTargetID, myPString);  myCString = QTUtils_ConvertPascalToCString(myPString);  if (myCString == NULL)    return(paramErr);    // create the user data item data  myString = malloc(strlen(kMovieIDPrefix) + strlen(myCString) + 2 + 1);  // 2 + 1 == '\&quot;' + '\&quot;' + '\0'  if (myString != NULL) {    myString[0] = '\0';    strcat(myString, kMovieIDPrefix);    strcat(myString, &quot;\&quot;&quot;);    strcat(myString, myCString);    strcat(myString, &quot;\&quot;&quot;);    // add in a new user data item    PtrToHand(myString, &amp;myHandle, strlen(myString));    if (myHandle != NULL)      myErr = AddUserData(myUserData, myHandle, FOUR_CHAR_CODE('plug'));  } else {    myErr = memFullErr;  }    free(myString);  free(myCString);    if (myHandle != NULL)    DisposeHandle(myHandle);    return(myErr);}////////////// QTUtils_FindUserDataItemWithPrefix// Return the index of the user data item of the specified type whose data begins with the specified string of characters.////////////static long QTUtils_FindUserDataItemWithPrefix (UserData theUserData, OSType theType, char *thePrefix){  Handle      myData = NULL;  long      myCount = 0;  long      myIndex = 0;  long      myItemIndex = 0;  OSErr      myErr = noErr;    // make sure we've got some valid user data  if (theUserData == NULL)    goto bail;    // allocate a handle for GetUserData  myData = NewHandle(0);  if (myData == NULL)    goto bail;  myCount = CountUserDataType(theUserData, theType);  for (myIndex = 1; myIndex &lt;= myCount; myIndex++) {    myErr = GetUserData(theUserData, myData, theType, myIndex);    if (myErr == noErr) {      if (GetHandleSize(myData) &lt; strlen(thePrefix))        continue;      // see if the user data begins with the specified prefix (IdenticalText is case-insensitive)      if (IdenticalText(*myData, thePrefix, strlen(thePrefix), strlen(thePrefix), NULL) == 0) {        myItemIndex = myIndex;        goto bail;      }    }  }bail:  if (myData != NULL)    DisposeHandle(myData);      return(myItemIndex);}////////////// QTUtils_GetUserDataPrefixedValue// Return the string value associated with the specified prefix. The string value may or may not be// enclosed in double quotes, so we need to handle both cases. (With double quotes is preferred.)//// The caller is responsible for disposing of the pointer returned by this function (by calling free).////////////static char *QTUtils_GetUserDataPrefixedValue (UserData theUserData, OSType theType, char *thePrefix){  long      myIndex = 0;  Handle      myData = NULL;  long      myLength = 0;  long      myOffset = 0;  char       *myString = NULL;  OSErr      myErr = noErr;    if (theUserData == NULL)    goto bail;  // allocate a handle for GetUserData  myData = NewHandle(0);  if (myData == NULL)    goto bail;    myIndex = QTUtils_FindUserDataItemWithPrefix(theUserData, theType, thePrefix);  if (myIndex &gt; 0) {    myErr = GetUserData(theUserData, myData, theType, myIndex);    if (myErr == noErr) {      if ((*myData)[strlen(thePrefix)] == '&quot;') {        myLength = GetHandleSize(myData) - strlen(thePrefix) - 2;        myOffset = 1;      } else {        myLength = GetHandleSize(myData) - strlen(thePrefix);        myOffset = 0;      }          myString = malloc(myLength + 1);      if (myString != NULL) {        memcpy(myString, *myData + strlen(thePrefix) + myOffset, myLength);        myString[myLength] = '\0';      }    }  }bail:  if (myData != NULL)    DisposeHandle(myData);  return(myString);}////////////// QTFrame_FindExternalMovieTarget// Find the external movie targeted by theEMRecPtr.////////////void QTFrame_FindExternalMovieTarget (MovieController theMC, QTGetExternalMoviePtr theEMRecPtr){#if ALLOW_SELF_TARGETING#pragma unused(theMC)#endif  WindowReference      myWindow = NULL;  Movie          myTargetMovie = NULL;  MovieController      myTargetMC = NULL;  Boolean          myFoundIt = false;    if (theEMRecPtr == NULL)    return;    // loop through all open movies until we find the one requested  myWindow = QTFrame_GetFrontMovieWindow();  while (myWindow != NULL) {    Movie        myMovie = NULL;    MovieController    myMC = NULL;      myMC = QTFrame_GetMCFromWindow(myWindow);    #if ALLOW_SELF_TARGETING    if (myMC != NULL) {#else    if ((myMC != NULL) &amp;&amp; (myMC != theMC)) {#endif          myMovie = MCGetMovie(myMC);            if (theEMRecPtr-&gt;targetType == kTargetMovieName) {        char     *myStr = NULL;                myStr = QTUtils_GetMovieTargetName(myMovie);        if (myStr != NULL) {          if (IdenticalText(&amp;theEMRecPtr-&gt;movieName[1], myStr, theEMRecPtr-&gt;movieName[0], strlen(myStr), NULL) == 0)            myFoundIt = true;          free(myStr);        }      }            if (theEMRecPtr-&gt;targetType == kTargetMovieID) {        long    myID = 0;        Boolean    myMovieHasID = false;                myID = QTUtils_GetMovieTargetID(myMovie, &amp;myMovieHasID);        if ((theEMRecPtr-&gt;movieID == myID) &amp;&amp; myMovieHasID)          myFoundIt = true;      }            if (myFoundIt) {        myTargetMovie = myMovie;        myTargetMC = myMC;        break;    // break out of while loop      }    }        myWindow = QTFrame_GetNextMovieWindow(myWindow);  }  // while    *theEMRecPtr-&gt;theMovie = myTargetMovie;  *theEMRecPtr-&gt;theController = myTargetMC;}</pre>
	<!--googleoff: index -->
			</td>
		</tr>
	</table>
	<!-- END WIDE COLUMN -->

	<!-- END MAIN CONTENT -->
		<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/samplecode/qtactiontargets/listing20.html%3Fid%3DDTS10001068-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/samplecode/qtactiontargets/listing20.html%3Fid%3DDTS10001068-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/samplecode/qtactiontargets/listing20.html%3Fid%3DDTS10001068-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

	<!-- START BOTTOM APPLE NAVIGATION -->
	<!--#include virtual="/includes/footer"-->
	<!-- END BOTTOM APPLE NAVIGATION -->

<!-- START CENTER CLOSE -->
</center>
<!-- END CENTER CLOSE -->

</body>
</html>