<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>QuickTime Movie Creation Guide: Sequence Grabber Channel Components</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Sequence Grabber Channel Components"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP40000906-SequenceGrabberChannelComponents" title="Sequence Grabber Channel Components"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440-TP30000433" target="_top">QuickTime</a> &gt; <a href="../../../../MovieCreation-date.html#//apple_ref/doc/uid/TP30000440-TP30000433-TP30000501" target="_top">Movie Creation</a> &gt; <a href="../A-Intro/1Introduction.html#//apple_ref/doc/uid/TP40000906-IntroductiontoQuickTimeMovieCreationGuide-DontLinkElementID_142">QuickTime Movie Creation Guide</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../E-Chapter/5SequenceGrabberPane.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../G-Chapter/7UsingSequenceGrabbe.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP40000906-SequenceGrabberChannelComponents-SW1" title="Sequence Grabber Channel Components"></a>
<h1>Sequence Grabber Channel Components</h1>

<p>This chapter describes how to build sequence grabber channel components, also known simply as <strong>channel</strong> <strong>components.</strong> These components are used by higher-level sequence grabber components, and act to isolate the sequence grabber from the details of working with actual data types. Channel components may, in turn, depend on the services of still lower-level components, such as video digitizer components.</p>
<p>For example, a sequence grabber component may provide both audio and video to an application. It may receive the audio and video data from two channel components: an audio channel component and a video channel component. The video channel component may receive its data from a video digitizer component that is specific to a particular manufacturer’s video capture board.</p>
<p>You should read this chapter if you are developing a sequence grabber component, a channel component, and/or a video digitizer component. Application programmers should use the services of a sequence grabber component, and should not need to read this material.</p>



<!-- This template is being used for both PDF and HTML. -->

    
    <h4>In this section:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="6SequenceGrabberChan.html#//apple_ref/doc/uid/TP40000906-SequenceGrabberChannelComponents-DontLinkElementID_75">Creating Sequence Grabber Channel Components</a>
				
			<br/>
			
        
			
			
				<a href="6SequenceGrabberChan.html#//apple_ref/doc/uid/TP40000906-SequenceGrabberChannelComponents-DontLinkElementID_79">A Sample Sequence Grabber Channel Component</a>
				
			<br/>
			
        
			
			
				<a href="6SequenceGrabberChan.html#//apple_ref/doc/uid/TP40000906-SequenceGrabberChannelComponents-DontLinkElementID_90">Support for Sound Capture at Any Sample Rate</a>
				
			<br/>
			
        
			
			
				<a href="6SequenceGrabberChan.html#//apple_ref/doc/uid/TP40000906-SequenceGrabberChannelComponents-DontLinkElementID_91">Channel Source Names</a>
				
			<br/>
			
        
			
			
				<a href="6SequenceGrabberChan.html#//apple_ref/doc/uid/TP40000906-SequenceGrabberChannelComponents-DontLinkElementID_92">Capturing to Multiple Files</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP40000906-SequenceGrabberChannelComponents-DontLinkElementID_75" title="Creating Sequence Grabber Channel Components"></a>
<h2><a name="//apple_ref/doc/uid/TP40000906-SequenceGrabberChannelComponents-CreatingSequenceGrabberChannelComponents" title="Creating Sequence Grabber Channel Components"></a>Creating Sequence Grabber Channel Components</h2>
<p>Sequence grabber channel components are the most convenient mechanism for extending the ability of the sequence grabber component to accommodate new types of source data. For example, if you are developing special-purpose hardware that generates a new kind of data, you should create a channel component for that kind of data.</p>
<p>This section discusses issues you should consider when creating a sequence grabber channel component. It also provides a sample program for the implementation of a sequence grabber channel component.</p>
<a name="//apple_ref/doc/uid/TP40000906-SequenceGrabberChannelComponents-DontLinkElementID_76" title="Component Type and Subtype Values"></a>
<h3><a name="//apple_ref/doc/uid/TP40000906-SequenceGrabberChannelComponents-ComponentTypeandSubtypeValues" title="Component Type and Subtype Values"></a>Component Type and Subtype Values</h3>
<p>Apple has defined a component type value for sequence grabber channel components; that type value is <code>'sgch'</code>. You can use the following constant to specify this type value:</p>

<div class="codesample"><table><tr><td scope="row"><pre>#define SeqGrabChannelType 'sgch';<span></span></pre></td></tr></table></div>

<p>Sequence grabber channel components use their component subtype value to indicate the media type created by the component. For example, a channel component that works with video data would have a subtype of <code><!--a target="_top" -->'vide'<!--/a--></code> (this value is defined by the Movie Toolbox’s <code>VideoMediaType</code> constant).</p>

<a name="//apple_ref/doc/uid/TP40000906-SequenceGrabberChannelComponents-DontLinkElementID_77" title="Required Functions"></a>
<h3><a name="//apple_ref/doc/uid/TP40000906-SequenceGrabberChannelComponents-RequiredFunctions" title="Required Functions"></a>Required Functions</h3>
<p>At a minimum, your channel component should support the following functions:</p>
<ul class="spaceabove">
<li class="li"><p><code><a href="../../../../Reference/QTRef_SequenceGrabber/Reference/reference.html#//apple_ref/c/func/SGGetChannelInfo" target="_top">SGGetChannelInfo</a></code></p></li>
<li class="li"><p><code><a href="../../../../Reference/QTRef_SequenceGrabber/Reference/reference.html#//apple_ref/c/func/SGRelease" target="_top">SGRelease</a></code></p></li>
<li class="li"><p><code><a href="../../../../Reference/QTRef_SequenceGrabber/Reference/reference.html#//apple_ref/c/func/SGGetChannelUsage" target="_top">SGGetChannelUsage</a></code></p></li>
<li class="li"><p><code><a href="../../../../Reference/QTRef_SequenceGrabber/Reference/reference.html#//apple_ref/c/func/SGSetChannelRefCon" target="_top">SGSetChannelRefCon</a></code></p></li>
<li class="li"><p><code><a href="../../../../Reference/QTRef_SequenceGrabber/Reference/reference.html#//apple_ref/c/func/SGGetDataRate" target="_top">SGGetDataRate</a></code></p></li>
<li class="li"><p><code><a href="../../../../Reference/QTRef_SequenceGrabber/Reference/reference.html#//apple_ref/c/func/SGSetChannelUsage" target="_top">SGSetChannelUsage</a></code></p></li>
<li class="li"><p><code><a href="../../../../Reference/QTRef_SequenceGrabber/Reference/reference.html#//apple_ref/c/func/SGIdle" target="_top">SGIdle</a></code></p></li>
<li class="li"><p><code><a href="../../../../Reference/QTRef_SequenceGrabber/Reference/reference.html#//apple_ref/c/func/SGStartPreview" target="_top">SGStartPreview</a></code></p></li>
<li class="li"><p><code><a href="../../../../Reference/QTRef_SequenceGrabber/Reference/reference.html#//apple_ref/c/func/SGInitChannel" target="_top">SGInitChannel</a></code></p></li>
<li class="li"><p><code><a href="../../../../Reference/QTRef_SequenceGrabber/Reference/reference.html#//apple_ref/c/func/SGStartRecord" target="_top">SGStartRecord</a></code></p></li>
<li class="li"><p><code><a href="../../../../Reference/QTRef_SequenceGrabber/Reference/reference.html#//apple_ref/c/func/SGPause" target="_top">SGPause</a></code></p></li>
<li class="li"><p><code><a href="../../../../Reference/QTRef_SequenceGrabber/Reference/reference.html#//apple_ref/c/func/SGStop" target="_top">SGStop</a></code></p></li>
<li class="li"><p><code><a href="../../../../Reference/QTRef_SequenceGrabber/Reference/reference.html#//apple_ref/c/func/SGPrepare" target="_top">SGPrepare</a></code></p></li>
<li class="li"><p><code><a href="../../../../Reference/QTRef_SequenceGrabber/Reference/reference.html#//apple_ref/c/func/SGWriteSamples" target="_top">SGWriteSamples</a></code></p></li>
</ul>
<p>In addition, if your channel component supports visual data, it should support at least the following functions:</p>
<ul class="spaceabove">
<li class="li"><p><code><a href="../../../../Reference/QTRef_SequenceGrabber/Reference/reference.html#//apple_ref/c/func/SGGetChannelBounds" target="_top">SGGetChannelBounds</a></code></p></li>
<li class="li"><p><code><a href="../../../../Reference/QTRef_SequenceGrabber/Reference/reference.html#//apple_ref/c/func/SGSetChannelBounds" target="_top">SGSetChannelBounds</a></code></p></li>
<li class="li"><p><code><a href="../../../../Reference/QTRef_SequenceGrabber/Reference/reference.html#//apple_ref/c/func/SGSetGWorld" target="_top">SGSetGWorld</a></code></p></li>
</ul>
<p>If your channel component supports audio data, it should support the following functions as well:</p>
<ul class="spaceabove">
<li class="li"><p><code><a href="../../../../Reference/QTRef_SequenceGrabber/Reference/reference.html#//apple_ref/c/func/SGGetChannelVolume" target="_top">SGGetChannelVolume</a></code></p></li>
<li class="li"><p><code><a href="../../../../Reference/QTRef_SequenceGrabber/Reference/reference.html#//apple_ref/c/func/SGSetChannelVolume" target="_top">SGSetChannelVolume</a></code></p></li>
</ul>
<p>Other functions mentioned in this chapter are optional. However, your channel component should support as many of these functions as possible, so that your component is more useful to applications and users.</p>

<a name="//apple_ref/doc/uid/TP40000906-SequenceGrabberChannelComponents-DontLinkElementID_78" title="Component Manager Request Codes"></a>
<h3><a name="//apple_ref/doc/uid/TP40000906-SequenceGrabberChannelComponents-ComponentManagerRequestCodes" title="Component Manager Request Codes"></a>Component Manager Request Codes</h3>
<p>As with all components, your channel component receives its requests from the Component Manager in the form of request codes. Apple strongly recommends that you fully support all of the Component Manager’s request codes in your channel component, especially the target request. Developers will want to extend the capabilities of the sequence grabber channel components. The Component Manager’s <code><a href="../../../../../Carbon/Reference/Component_Manager/Reference/reference.html#//apple_ref/c/func/CaptureComponent" target="_top">CaptureComponent</a></code> function, which uses the target request, is the most convenient mechanism for obtaining the services of a component and then extending those services. If your channel component does not support the target request, then it cannot be used by applications or other components in this manner. You can use the following constants to refer to the request codes for each of the functions that your channel component must support.</p>

<div class="codesample"><table><tr><td scope="row"><pre>    /* basic sequence grabber channel component selectors */<span></span></pre></td></tr><tr><td scope="row"><pre>    kSGSetGWorldSelect                      = 0x4;<span></span></pre></td></tr><tr><td scope="row"><pre>    kSGStartPreviewSelect                   = 0x10;<span></span></pre></td></tr><tr><td scope="row"><pre>    kSGStartRecordSelect                    = 0x11;<span></span></pre></td></tr><tr><td scope="row"><pre>    kSGIdleSelect                           = 0x12;<span></span></pre></td></tr><tr><td scope="row"><pre>    kSGStopSelect                           = 0x13;<span></span></pre></td></tr><tr><td scope="row"><pre>    kSGPauseSelect                          = 0x14;<span></span></pre></td></tr><tr><td scope="row"><pre>    kSGPrepareSelect                        = 0x15;<span></span></pre></td></tr><tr><td scope="row"><pre>    kSGReleaseSelect                        = 0x16;<span></span></pre></td></tr><tr><td scope="row"><pre>    kSGUpdateSelect                         = 0x27;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    /* selectors for common channel configuration functions */<span></span></pre></td></tr><tr><td scope="row"><pre>    kSGCSetChannelUsageSelect               = 0x80;<span></span></pre></td></tr><tr><td scope="row"><pre>    kSGCGetChannelUsageSelect               = 0x81;<span></span></pre></td></tr><tr><td scope="row"><pre>    kSGCSetChannelBoundsSelect              = 0x82;<span></span></pre></td></tr><tr><td scope="row"><pre>    kSGCGetChannelBoundsSelect              = 0x83;<span></span></pre></td></tr><tr><td scope="row"><pre>    kSGCSetChannelVolumeSelect              = 0x84;<span></span></pre></td></tr><tr><td scope="row"><pre>    kSGCGetChannelVolumeSelect              = 0x85;<span></span></pre></td></tr><tr><td scope="row"><pre>    kSGCGetChannelInfoSelect                = 0x86;<span></span></pre></td></tr><tr><td scope="row"><pre>    kSGCSetChannelPlayFlagsSelect           = 0x87;<span></span></pre></td></tr><tr><td scope="row"><pre>    kSGCGetChannelPlayFlagsSelect           = 0x88;<span></span></pre></td></tr><tr><td scope="row"><pre>    kSGCSetChannelMaxFramesSelect           = 0x89;<span></span></pre></td></tr><tr><td scope="row"><pre>    kSGCGetChannelMaxFramesSelect           = 0x8a;<span></span></pre></td></tr><tr><td scope="row"><pre>    kSGCSetChannelRefConSelect              = 0x8b;<span></span></pre></td></tr><tr><td scope="row"><pre>    kSGCSetChannelClipSelect                = 0x8C;<span></span></pre></td></tr><tr><td scope="row"><pre>    kSGCGetChannelClipSelect                = 0x8D;<span></span></pre></td></tr><tr><td scope="row"><pre>    kSGCGetChannelSampleDescriptionSelect   = 0x8E;<span></span></pre></td></tr><tr><td scope="row"><pre>    kSGCGetChannelDeviceListSelect          = 0x8F;<span></span></pre></td></tr><tr><td scope="row"><pre>    kSGCSetChannelDeviceSelect              = 0x90;<span></span></pre></td></tr><tr><td scope="row"><pre>    kSGCSetChannelMatrixSelect              = 0x91;<span></span></pre></td></tr><tr><td scope="row"><pre>    kSGCGetChannelMatrixSelect              = 0x92;<span></span></pre></td></tr><tr><td scope="row"><pre>    kSGCGetChannelTimeScaleSelect           = 0x93;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    /* selectors for video channel configuration functions */<span></span></pre></td></tr><tr><td scope="row"><pre>    kSGCGetSrcVideoBoundsSelect             = 0x100;<span></span></pre></td></tr><tr><td scope="row"><pre>    kSGCSetVideoRectSelect                  = 0x101;<span></span></pre></td></tr><tr><td scope="row"><pre>    kSGCGetVideoRectSelect                  = 0x102;<span></span></pre></td></tr><tr><td scope="row"><pre>    kSGCGetVideoCompressorTypeSelect        = 0x103;<span></span></pre></td></tr><tr><td scope="row"><pre>    kSGCSetVideoCompressorTypeSelect        = 0x104;<span></span></pre></td></tr><tr><td scope="row"><pre>    kSGCSetVideoCompressorSelect            = 0x105;<span></span></pre></td></tr><tr><td scope="row"><pre>    kSGCGetVideoCompressorSelect            = 0x106;<span></span></pre></td></tr><tr><td scope="row"><pre>    kSGCGetVideoDigitizerComponentSelect    = 0x107;<span></span></pre></td></tr><tr><td scope="row"><pre>    kSGCSetVideoDigitizerComponentSelect    = 0x108;<span></span></pre></td></tr><tr><td scope="row"><pre>    kSGCVideoDigitizerChangedSelect         = 0x109;<span></span></pre></td></tr><tr><td scope="row"><pre>    kSGCSetVideoBottlenecksSelect           = 0x10a;<span></span></pre></td></tr><tr><td scope="row"><pre>    kSGCGetVideoBottlenecksSelect           = 0x10b;<span></span></pre></td></tr><tr><td scope="row"><pre>    kSGCGrabFrameSelect                     = 0x10c;<span></span></pre></td></tr><tr><td scope="row"><pre>    kSGCGrabFrameCompleteSelect             = 0x10d;<span></span></pre></td></tr><tr><td scope="row"><pre>    kSGCDisplayFrameSelect                  = 0x10e;<span></span></pre></td></tr><tr><td scope="row"><pre>    kSGCCompressFrameSelect                 = 0x10f;<span></span></pre></td></tr><tr><td scope="row"><pre>    kSGCCompressFrameCompleteSelect         = 0x110;<span></span></pre></td></tr><tr><td scope="row"><pre>    kSGCAddFrameSelect                      = 0x111;<span></span></pre></td></tr><tr><td scope="row"><pre>    kSGCTransferFrameForCompressSelect      = 0x112;<span></span></pre></td></tr><tr><td scope="row"><pre>    kSGCSetCompressBufferSelect             = 0x113;<span></span></pre></td></tr><tr><td scope="row"><pre>    kSGCGetCompressBufferSelect             = 0x114;<span></span></pre></td></tr><tr><td scope="row"><pre>    kSGCGetBufferInfoSelect                 = 0x115;<span></span></pre></td></tr><tr><td scope="row"><pre>    kSGCSetUseScreenBufferSelect            = 0x116;<span></span></pre></td></tr><tr><td scope="row"><pre>    kSGCGetUseScreenBufferSelect            = 0x117;<span></span></pre></td></tr><tr><td scope="row"><pre>    kSGCGrabCompressCompleteSelect          = 0x118;<span></span></pre></td></tr><tr><td scope="row"><pre>    kSGCDisplayCompressSelect               = 0x119;<span></span></pre></td></tr><tr><td scope="row"><pre>    kSGCSetFrameRateSelect                  = 0x11A;<span></span></pre></td></tr><tr><td scope="row"><pre>    kSGCGetFrameRateSelect                  = 0x11B;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    /* selectors for sound channel configuration functions */<span></span></pre></td></tr><tr><td scope="row"><pre>    kSGCSetSoundInputDriverSelect           = 0x100;<span></span></pre></td></tr><tr><td scope="row"><pre>    kSGCGetSoundInputDriverSelect           = 0x101;<span></span></pre></td></tr><tr><td scope="row"><pre>    kSGCSoundInputDriverChangedSelect       = 0x102;<span></span></pre></td></tr><tr><td scope="row"><pre>    kSGCSetSoundRecordChunkSizeSelect       = 0x103;<span></span></pre></td></tr><tr><td scope="row"><pre>    kSGCGetSoundRecordChunkSizeSelect       = 0x104;<span></span></pre></td></tr><tr><td scope="row"><pre>    kSGCSetSoundInputRateSelect             = 0x105;<span></span></pre></td></tr><tr><td scope="row"><pre>    kSGCGetSoundInputRateSelect             = 0x106;<span></span></pre></td></tr><tr><td scope="row"><pre>    kSGCSetSoundInputParametersSelect       = 0x107;<span></span></pre></td></tr><tr><td scope="row"><pre>    kSGCGetSoundInputParametersSelect       = 0x108;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    /* selectors for channel control functions */<span></span></pre></td></tr><tr><td scope="row"><pre>    kSGCInitChannelSelect                   = 0x180;<span></span></pre></td></tr><tr><td scope="row"><pre>    kSGCWriteSamplesSelect                  = 0x181;<span></span></pre></td></tr><tr><td scope="row"><pre>    kSGCGetDataRateSelect                   = 0x182;<span></span></pre></td></tr><tr><td scope="row"><pre>    kSGCAlignChannelRectSelect              = 0x183;<span></span></pre></td></tr><tr><td scope="row"><pre>};<span></span></pre></td></tr></table></div>



<a name="//apple_ref/doc/uid/TP40000906-SequenceGrabberChannelComponents-DontLinkElementID_79" title="A Sample Sequence Grabber Channel Component"></a>
<h2><a name="//apple_ref/doc/uid/TP40000906-SequenceGrabberChannelComponents-ASampleSequenceGrabberChannelComponent" title="A Sample Sequence Grabber Channel Component"></a>A Sample Sequence Grabber Channel Component</h2>
<p>This section describes a sample sequence grabber channel component for PICT image data.</p>
<a name="//apple_ref/doc/uid/TP40000906-SequenceGrabberChannelComponents-DontLinkElementID_80" title="Implementing the Required Component Functions"></a>
<h3><a name="//apple_ref/doc/uid/TP40000906-SequenceGrabberChannelComponents-ImplementingtheRequiredComponentFunctions" title="Implementing the Required Component Functions"></a>Implementing the Required Component Functions</h3>
<p>Listing 5-1 supplies the component dispatchers for the sequence grabber channel component together with the required functions.</p>
<a name="//apple_ref/doc/uid/TP40000906-SequenceGrabberChannelComponents-DontLinkElementID_169" title="Listing 5-1Setting up global variables and implementing required functions"></a>
<p class="codesample"><strong>Listing 5-1&nbsp;&nbsp;</strong>Setting up global variables and implementing required functions</p>
<div class="codesample"><table><tr><td scope="row"><pre>#define kMediaTimeScale 600<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>typedef struct {<span></span></pre></td></tr><tr><td scope="row"><pre>    ComponentInstance       self;<span></span></pre></td></tr><tr><td scope="row"><pre>    SeqGrabComponent        grabber;<span></span></pre></td></tr><tr><td scope="row"><pre>    long                    usage;<span></span></pre></td></tr><tr><td scope="row"><pre>    Boolean                 paused;<span></span></pre></td></tr><tr><td scope="row"><pre>    CGrafPtr                destPort;<span></span></pre></td></tr><tr><td scope="row"><pre>    GDHandle                destGD;<span></span></pre></td></tr><tr><td scope="row"><pre>    CGrafPort               tempPort;<span></span></pre></td></tr><tr><td scope="row"><pre>    MatrixRecord            displayMatrix;<span></span></pre></td></tr><tr><td scope="row"><pre>    Rect                    destRect;<span></span></pre></td></tr><tr><td scope="row"><pre>    Rect                    srcRect;<span></span></pre></td></tr><tr><td scope="row"><pre>    RgnHandle               clip;<span></span></pre></td></tr><tr><td scope="row"><pre>    Boolean                 inPreview;<span></span></pre></td></tr><tr><td scope="row"><pre>    Boolean                 inRecord;<span></span></pre></td></tr><tr><td scope="row"><pre>    TimeBase                base;<span></span></pre></td></tr><tr><td scope="row"><pre>    long                    bytesWritten;<span></span></pre></td></tr><tr><td scope="row"><pre>    Boolean                 showTickCount;<span></span></pre></td></tr><tr><td scope="row"><pre>    long                    saveUsage;<span></span></pre></td></tr><tr><td scope="row"><pre>} SGPictGlobalsRecord, *SGPictGlobals;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>pascal ComponentResult SGPICTDispatcher<span></span></pre></td></tr><tr><td scope="row"><pre>                        (ComponentParameters *params, Handle storage)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    OSErr err = badComponentSelector;<span></span></pre></td></tr><tr><td scope="row"><pre>    ComponentFunction componentProc = 0;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    switch (params->what) {<span></span></pre></td></tr><tr><td scope="row"><pre>        case kComponentOpenSelect:<span></span></pre></td></tr><tr><td scope="row"><pre>                componentProc = SGPictOpen; break;<span></span></pre></td></tr><tr><td scope="row"><pre>        case kComponentCloseSelect:<span></span></pre></td></tr><tr><td scope="row"><pre>                componentProc = SGPictClose; break;<span></span></pre></td></tr><tr><td scope="row"><pre>        case kComponentCanDoSelect:<span></span></pre></td></tr><tr><td scope="row"><pre>                componentProc = SGPictCanDo; break;<span></span></pre></td></tr><tr><td scope="row"><pre>        case kComponentVersionSelect:<span></span></pre></td></tr><tr><td scope="row"><pre>                componentProc = SGPictVersion; break;<span></span></pre></td></tr><tr><td scope="row"><pre>        case kSGSetGWorldSelect:<span></span></pre></td></tr><tr><td scope="row"><pre>                componentProc = SGPictSetGWorld; break;<span></span></pre></td></tr><tr><td scope="row"><pre>        case kSGStartPreviewSelect:<span></span></pre></td></tr><tr><td scope="row"><pre>                componentProc = SGPictStartPreview; break;<span></span></pre></td></tr><tr><td scope="row"><pre>        case kSGStartRecordSelect:<span></span></pre></td></tr><tr><td scope="row"><pre>                componentProc = SGPictStartRecord; break;<span></span></pre></td></tr><tr><td scope="row"><pre>        case kSGIdleSelect:<span></span></pre></td></tr><tr><td scope="row"><pre>                componentProc = SGPictIdle; break;<span></span></pre></td></tr><tr><td scope="row"><pre>        case kSGStopSelect:<span></span></pre></td></tr><tr><td scope="row"><pre>                componentProc = SGPictStop; break;<span></span></pre></td></tr><tr><td scope="row"><pre>        case kSGPauseSelect:<span></span></pre></td></tr><tr><td scope="row"><pre>                componentProc = SGPictPause; break;<span></span></pre></td></tr><tr><td scope="row"><pre>        case kSGPrepareSelect:<span></span></pre></td></tr><tr><td scope="row"><pre>                componentProc = SGPictPrepare; break;<span></span></pre></td></tr><tr><td scope="row"><pre>        case kSGReleaseSelect:<span></span></pre></td></tr><tr><td scope="row"><pre>                componentProc = SGPictRelease; break;<span></span></pre></td></tr><tr><td scope="row"><pre>        case kSGCSetChannelUsageSelect:<span></span></pre></td></tr><tr><td scope="row"><pre>                componentProc = SGPictSetChannelUsage; break;<span></span></pre></td></tr><tr><td scope="row"><pre>        case kSGCGetChannelUsageSelect:<span></span></pre></td></tr><tr><td scope="row"><pre>                componentProc = SGPictGetChannelUsage; break;<span></span></pre></td></tr><tr><td scope="row"><pre>        case kSGCSetChannelBoundsSelect:<span></span></pre></td></tr><tr><td scope="row"><pre>                componentProc = SGPictSetChannelBounds; break;<span></span></pre></td></tr><tr><td scope="row"><pre>        case kSGCGetChannelBoundsSelect:<span></span></pre></td></tr><tr><td scope="row"><pre>                componentProc = SGPictGetChannelBounds; break;<span></span></pre></td></tr><tr><td scope="row"><pre>        case kSGCGetChannelInfoSelect:<span></span></pre></td></tr><tr><td scope="row"><pre>                componentProc = SGPictGetChannelInfo; break;<span></span></pre></td></tr><tr><td scope="row"><pre>        case kSGCSetChannelMatrixSelect:<span></span></pre></td></tr><tr><td scope="row"><pre>                componentProc = SGPictSetChannelMatrix; break;<span></span></pre></td></tr><tr><td scope="row"><pre>        case kSGCGetChannelMatrixSelect:<span></span></pre></td></tr><tr><td scope="row"><pre>                componentProc = SGPictGetChannelMatrix; break;<span></span></pre></td></tr><tr><td scope="row"><pre>        case kSGCSetChannelClipSelect:<span></span></pre></td></tr><tr><td scope="row"><pre>                componentProc = SGPictSetChannelClip; break;<span></span></pre></td></tr><tr><td scope="row"><pre>        case kSGCGetChannelClipSelect:<span></span></pre></td></tr><tr><td scope="row"><pre>                componentProc = SGPictGetChannelClip; break;<span></span></pre></td></tr><tr><td scope="row"><pre>        case kSGCGetChannelSampleDescriptionSelect:<span></span></pre></td></tr><tr><td scope="row"><pre>                componentProc = SGPictGetChannelSampleDescription;<span></span></pre></td></tr><tr><td scope="row"><pre>                 break;<span></span></pre></td></tr><tr><td scope="row"><pre>        case kSGCGetChannelDeviceListSelect:<span></span></pre></td></tr><tr><td scope="row"><pre>            componentProc = SGPictGetChannelDeviceList; break;<span></span></pre></td></tr><tr><td scope="row"><pre>        case kSGCSetChannelDeviceSelect:<span></span></pre></td></tr><tr><td scope="row"><pre>            componentProc = SGPictSetChannelDevice; break;<span></span></pre></td></tr><tr><td scope="row"><pre>        case kSGCGetChannelTimeScaleSelect:<span></span></pre></td></tr><tr><td scope="row"><pre>            componentProc = SGPictGetChannelTimeScale; break;<span></span></pre></td></tr><tr><td scope="row"><pre>        case kSGCInitChannelSelect:<span></span></pre></td></tr><tr><td scope="row"><pre>            componentProc = SGPictInitChannel; break;<span></span></pre></td></tr><tr><td scope="row"><pre>        case kSGCWriteSamplesSelect:<span></span></pre></td></tr><tr><td scope="row"><pre>            componentProc = SGPictWriteSamples; break;<span></span></pre></td></tr><tr><td scope="row"><pre>        case kSGCGetDataRateSelect:<span></span></pre></td></tr><tr><td scope="row"><pre>                componentProc = SGPictGetDataRate; break;<span></span></pre></td></tr><tr><td scope="row"><pre>        case kSGCPanelGetDitlSelect:<span></span></pre></td></tr><tr><td scope="row"><pre>                componentProc = SGPictPanelGetDitl; break;<span></span></pre></td></tr><tr><td scope="row"><pre>        case kSGCPanelInstallSelect:<span></span></pre></td></tr><tr><td scope="row"><pre>                componentProc = SGPictPanelInstall; break;<span></span></pre></td></tr><tr><td scope="row"><pre>        case kSGCPanelEventSelect:<span></span></pre></td></tr><tr><td scope="row"><pre>                componentProc = SGPictPanelEvent; break;<span></span></pre></td></tr><tr><td scope="row"><pre>        case kSGCPanelRemoveSelect:<span></span></pre></td></tr><tr><td scope="row"><pre>                componentProc = SGPictPanelRemove; break;<span></span></pre></td></tr><tr><td scope="row"><pre>        case kSGCPanelGetSettingsSelect:<span></span></pre></td></tr><tr><td scope="row"><pre>                componentProc = SGPictPanelGetSettings; break;<span></span></pre></td></tr><tr><td scope="row"><pre>        case kSGCPanelSetSettingsSelect:<span></span></pre></td></tr><tr><td scope="row"><pre>                componentProc = SGPictPanelSetSettings; break;<span></span></pre></td></tr><tr><td scope="row"><pre>        case 0x0100:<span></span></pre></td></tr><tr><td scope="row"><pre>                componentProc = SGPictSetShowTickCount; break;<span></span></pre></td></tr><tr><td scope="row"><pre>        case 0x0101:<span></span></pre></td></tr><tr><td scope="row"><pre>                componentProc = SGPictGetShowTickCount; break;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    if (componentProc)<span></span></pre></td></tr><tr><td scope="row"><pre>        err = CallComponentFunctionWithStorage (storage, params,<span></span></pre></td></tr><tr><td scope="row"><pre>                                                  componentProc);<span></span></pre></td></tr><tr><td scope="row"><pre>    return err;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>pascal ComponentResult SGPictCanDo (SGPictGlobals store,<span></span></pre></td></tr><tr><td scope="row"><pre>                                      short ftnNumber)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    switch (ftnNumber) {<span></span></pre></td></tr><tr><td scope="row"><pre>        case kComponentOpenSelect:<span></span></pre></td></tr><tr><td scope="row"><pre>        case kComponentCloseSelect:<span></span></pre></td></tr><tr><td scope="row"><pre>        case kComponentCanDoSelect:<span></span></pre></td></tr><tr><td scope="row"><pre>        case kComponentVersionSelect:<span></span></pre></td></tr><tr><td scope="row"><pre>        case kSGSetGWorldSelect:<span></span></pre></td></tr><tr><td scope="row"><pre>        case kSGStartPreviewSelect:<span></span></pre></td></tr><tr><td scope="row"><pre>        case kSGStartRecordSelect:<span></span></pre></td></tr><tr><td scope="row"><pre>        case kSGIdleSelect:<span></span></pre></td></tr><tr><td scope="row"><pre>        case kSGStopSelect:<span></span></pre></td></tr><tr><td scope="row"><pre>        case kSGPauseSelect:<span></span></pre></td></tr><tr><td scope="row"><pre>        case kSGPrepareSelect:<span></span></pre></td></tr><tr><td scope="row"><pre>        case kSGReleaseSelect:<span></span></pre></td></tr><tr><td scope="row"><pre>        case kSGCSetChannelUsageSelect:<span></span></pre></td></tr><tr><td scope="row"><pre>        case kSGCGetChannelUsageSelect:<span></span></pre></td></tr><tr><td scope="row"><pre>        case kSGCSetChannelBoundsSelect:<span></span></pre></td></tr><tr><td scope="row"><pre>        case kSGCGetChannelBoundsSelect:<span></span></pre></td></tr><tr><td scope="row"><pre>        case kSGCGetChannelInfoSelect:<span></span></pre></td></tr><tr><td scope="row"><pre>        case kSGCSetChannelMatrixSelect:<span></span></pre></td></tr><tr><td scope="row"><pre>        case kSGCGetChannelMatrixSelect:<span></span></pre></td></tr><tr><td scope="row"><pre>        case kSGCSetChannelClipSelect:<span></span></pre></td></tr><tr><td scope="row"><pre>        case kSGCGetChannelClipSelect:<span></span></pre></td></tr><tr><td scope="row"><pre>        case kSGCGetChannelSampleDescriptionSelect:<span></span></pre></td></tr><tr><td scope="row"><pre>        case kSGCGetChannelDeviceListSelect:<span></span></pre></td></tr><tr><td scope="row"><pre>        case kSGCSetChannelDeviceSelect:<span></span></pre></td></tr><tr><td scope="row"><pre>        case kSGCGetChannelTimeScaleSelect:<span></span></pre></td></tr><tr><td scope="row"><pre>        case kSGCInitChannelSelect:<span></span></pre></td></tr><tr><td scope="row"><pre>        case kSGCWriteSamplesSelect:<span></span></pre></td></tr><tr><td scope="row"><pre>        case kSGCGetDataRateSelect:<span></span></pre></td></tr><tr><td scope="row"><pre>        case kSGCPanelGetDitlSelect:<span></span></pre></td></tr><tr><td scope="row"><pre>        case kSGCPanelInstallSelect:<span></span></pre></td></tr><tr><td scope="row"><pre>        case kSGCPanelEventSelect:<span></span></pre></td></tr><tr><td scope="row"><pre>        case kSGCPanelRemoveSelect:<span></span></pre></td></tr><tr><td scope="row"><pre>        case kSGCPanelGetSettingsSelect:<span></span></pre></td></tr><tr><td scope="row"><pre>        case kSGCPanelSetSettingsSelect:<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        /* private component functions */<span></span></pre></td></tr><tr><td scope="row"><pre>        case 0x0100:<span></span></pre></td></tr><tr><td scope="row"><pre>        case 0x0101:<span></span></pre></td></tr><tr><td scope="row"><pre>            return true;<span></span></pre></td></tr><tr><td scope="row"><pre>        default:<span></span></pre></td></tr><tr><td scope="row"><pre>            return false;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>pascal ComponentResult SGPictVersion (SGPictGlobals store)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    return 0x00020001;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>pascal ComponentResult SGPictOpen (SGPictGlobals store,<span></span></pre></td></tr><tr><td scope="row"><pre>                                     ComponentInstance self)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    OSErr err;<span></span></pre></td></tr><tr><td scope="row"><pre>    GrafPtr savePort;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    /* allocate global variables */<span></span></pre></td></tr><tr><td scope="row"><pre>    store =<span></span></pre></td></tr><tr><td scope="row"><pre>    (SGPictGlobals)NewPtrClear(sizeof(SGPictGlobalsRecord));<span></span></pre></td></tr><tr><td scope="row"><pre>    if (err = MemError()) goto bail;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    /* create a temporary port for drawing during the idle<span></span></pre></td></tr><tr><td scope="row"><pre>        function */<span></span></pre></td></tr><tr><td scope="row"><pre>    GetPort (&amp;savePort);<span></span></pre></td></tr><tr><td scope="row"><pre>    OpenCPort (&amp;store->tempPort);<span></span></pre></td></tr><tr><td scope="row"><pre>    SetPort ((GrafPtr)&amp;store->tempPort);<span></span></pre></td></tr><tr><td scope="row"><pre>    PortSize (4096, 4096);<span></span></pre></td></tr><tr><td scope="row"><pre>    SetRectRgn (store->tempPort.visRgn, 0, 0, 4096, 4096);<span></span></pre></td></tr><tr><td scope="row"><pre>    ClipRgn (store->tempPort.visRgn);<span></span></pre></td></tr><tr><td scope="row"><pre>    SetPort (savePort);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    store->self = self;<span></span></pre></td></tr><tr><td scope="row"><pre>    store->showTickCount = false;<span></span></pre></td></tr><tr><td scope="row"><pre>    SetComponentInstanceStorage (self, (Handle)store);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>bail:<span></span></pre></td></tr><tr><td scope="row"><pre>    return err;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>pascal ComponentResult SGPictClose (SGPictGlobals store,<span></span></pre></td></tr><tr><td scope="row"><pre>                                     ComponentInstance self)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    /* disposal operations */<span></span></pre></td></tr><tr><td scope="row"><pre>    if (store) {<span></span></pre></td></tr><tr><td scope="row"><pre>        if (store->clip) DisposeRgn(store->clip);<span></span></pre></td></tr><tr><td scope="row"><pre>        CloseCPort(&amp;store->tempPort);<span></span></pre></td></tr><tr><td scope="row"><pre>        DisposPtr((Ptr)store);<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    return noErr;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div>


<a name="//apple_ref/doc/uid/TP40000906-SequenceGrabberChannelComponents-DontLinkElementID_81" title="Initializing the Sequence Grabber Channel Component"></a>
<h3><a name="//apple_ref/doc/uid/TP40000906-SequenceGrabberChannelComponents-InitializingtheSequenceGrabberChannelComponent" title="Initializing the Sequence Grabber Channel Component"></a>Initializing the Sequence Grabber Channel Component</h3>
<p>To initialize the channel component, the sequence grabber component calls the <code><a href="../../../../Reference/QTRef_SequenceGrabber/Reference/reference.html#//apple_ref/c/func/SGInitChannel" target="_top">SGInitChannel</a></code> function.</p>
<p>The code in Listing 5-2 initializes channel variables. The grabber component calls the <code>SGPictInitChannel</code> function to initialize a sequence grabber channel component. The <code>SGPictInitChannel</code> function calls QuickDraw’s <code>SetRect</code> routine and QuickTime’s <code><a href="../../../../Reference/QTRef_CompDecomp/Reference/reference.html#//apple_ref/c/func/SetIdentityMatrix" target="_top">SetIdentityMatrix</a></code> function to specify the size of the area (around a mouse-down event) in which the sequence grabber component will capture PICT images.</p>
<a name="//apple_ref/doc/uid/TP40000906-SequenceGrabberChannelComponents-DontLinkElementID_170" title="Listing 5-2Initializing the sequence grabber channel component"></a>
<p class="codesample"><strong>Listing 5-2&nbsp;&nbsp;</strong>Initializing the sequence grabber channel component</p>
<div class="codesample"><table><tr><td scope="row"><pre>pascal ComponentResult SGPictInitChannel (SGPictGlobals store,<span></span></pre></td></tr><tr><td scope="row"><pre>                                            SeqGrabComponent owner)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    /* initialize any variables here */<span></span></pre></td></tr><tr><td scope="row"><pre>    SetRect(&amp;store->srcRect, 0, 0, 160, 120);/* rectangle in which<span></span></pre></td></tr><tr><td scope="row"><pre>                                                capture occurs */<span></span></pre></td></tr><tr><td scope="row"><pre>    SetIdentityMatrix (&amp;store->displayMatrix);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    store->grabber = owner;<span></span></pre></td></tr><tr><td scope="row"><pre>    SGGetTimeBase (owner, &amp;store->base);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    return noErr;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div>


<a name="//apple_ref/doc/uid/TP40000906-SequenceGrabberChannelComponents-DontLinkElementID_82" title="Setting and Retrieving the Channel State"></a>
<h3><a name="//apple_ref/doc/uid/TP40000906-SequenceGrabberChannelComponents-SettingandRetrievingtheChannelState" title="Setting and Retrieving the Channel State"></a>Setting and Retrieving the Channel State</h3>
<p>Listing 5-3 supplies configuration functions that set the usage parameters and storage for the channel component. (See the descriptions of the <code><a href="../../../../Reference/QTRef_SequenceGrabber/Reference/reference.html#//apple_ref/c/func/SGSetChannelUsage" target="_top">SGSetChannelUsage</a></code> and <code><a href="../../../../Reference/QTRef_SequenceGrabber/Reference/reference.html#//apple_ref/c/func/SGGetChannelUsage" target="_top">SGGetChannelUsage</a></code> functions for details.)</p>
<p>The sample code illustrates how to retrieve usage information. In this case, you indicate that the sequence grabber component has spatial boundaries by using the <code>seqGrabHasBounds</code> constant in the <code>channelInfo</code> parameter.</p>
<a name="//apple_ref/doc/uid/TP40000906-SequenceGrabberChannelComponents-DontLinkElementID_171" title="Listing 5-3Determining usage parameters and getting usage data"></a>
<p class="codesample"><strong>Listing 5-3&nbsp;&nbsp;</strong>Determining usage parameters and getting usage data</p>
<div class="codesample"><table><tr><td scope="row"><pre>pascal ComponentResult SGPictSetChannelUsage(SGPictGlobals store, long usage)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    /* remember usage */<span></span></pre></td></tr><tr><td scope="row"><pre>    store->usage = usage;<span></span></pre></td></tr><tr><td scope="row"><pre>    return noErr;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>pascal ComponentResult SGPictGetChannelUsage(SGPictGlobals store, long *usage)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    /* return usage */<span></span></pre></td></tr><tr><td scope="row"><pre>    *usage = store->usage;<span></span></pre></td></tr><tr><td scope="row"><pre>    return noErr;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>pascal ComponentResult SGPictGetChannelInfo (SGPictGlobals store,<span></span></pre></td></tr><tr><td scope="row"><pre>                                                  long *channelInfo)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    /* indicate that you have spatial boundaries */<span></span></pre></td></tr><tr><td scope="row"><pre>    *channelInfo = seqGrabHasBounds;<span></span></pre></td></tr><tr><td scope="row"><pre>    return noErr;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div>


<a name="//apple_ref/doc/uid/TP40000906-SequenceGrabberChannelComponents-DontLinkElementID_83" title="Managing Spatial Properties"></a>
<h3><a name="//apple_ref/doc/uid/TP40000906-SequenceGrabberChannelComponents-ManagingSpatialProperties" title="Managing Spatial Properties"></a>Managing Spatial Properties</h3>
<p>To set up an area in which the channel component displays image data, the sequence grabber should perform these tasks:</p>
<ol class="ol">
<li class="li"><p>Assign the destination graphics world and graphics device for the display of the captured image with the <code><a href="../../../../Reference/QTRef_SequenceGrabber/Reference/reference.html#//apple_ref/c/func/SGSetGWorld" target="_top">SGSetGWorld</a></code> function.</p></li>
<li class="li"><p>Specify a display transformation matrix for a video channel using the <code><a href="../../../../Reference/QTRef_SequenceGrabber/Reference/reference.html#//apple_ref/c/func/SGSetChannelMatrix" target="_top">SGSetChannelMatrix</a></code> function. Your function determines the matrix that is being set, validates it, and updates the matrix and destination rectangle. Your channel uses this matrix to transform its video image into the destination window.</p></li>
<li class="li"><p>Obtain the channel’s display transformation matrix by calling the <code><a href="../../../../Reference/QTRef_SequenceGrabber/Reference/reference.html#//apple_ref/c/func/SGGetChannelMatrix" target="_top">SGGetChannelMatrix</a></code> function.</p></li>
<li class="li"><p>Specify the channel’s display boundary rectangle with the <code><a href="../../../../Reference/QTRef_SequenceGrabber/Reference/reference.html#//apple_ref/c/func/SGSetChannelBounds" target="_top">SGSetChannelBounds</a></code> function. The display boundary rectangle defines the destination for data from this channel and adjusts the channel matrix.</p></li>
<li class="li"><p>Determine the channel’s display boundary rectangle with the <code><a href="../../../../Reference/QTRef_SequenceGrabber/Reference/reference.html#//apple_ref/c/func/SGGetChannelBounds" target="_top">SGGetChannelBounds</a></code> function.</p></li>
<li class="li"><p>Dispose of the old clipping region and apply a new clipping region to the channel’s display region using the <code><a href="../../../../Reference/QTRef_SequenceGrabber/Reference/reference.html#//apple_ref/c/func/SGSetChannelClip" target="_top">SGSetChannelClip</a></code> function.</p></li>
<li class="li"><p>Retrieve the new clipping region by calling the <code><a href="../../../../Reference/QTRef_SequenceGrabber/Reference/reference.html#//apple_ref/c/func/SGGetChannelClip" target="_top">SGGetChannelClip</a></code> function.</p></li>
</ol>
<p>The code in Listing 5-4 provides an example of how to manage the spatial characteristics of the area in which the channel component displays PICT image data.</p>
<a name="//apple_ref/doc/uid/TP40000906-SequenceGrabberChannelComponents-DontLinkElementID_172" title="Listing 5-4Managing spatial characteristics"></a>
<p class="codesample"><strong>Listing 5-4&nbsp;&nbsp;</strong>Managing spatial characteristics</p>
<div class="codesample"><table><tr><td scope="row"><pre>pascal ComponentResult SGPictSetGWorld (SGPictGlobals store,<span></span></pre></td></tr><tr><td scope="row"><pre>                                            CGrafPtr gp, GDHandle gd)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    /* remember the destination graphics world */<span></span></pre></td></tr><tr><td scope="row"><pre>    store->destPort = gp;<span></span></pre></td></tr><tr><td scope="row"><pre>    store->destGD = gd;<span></span></pre></td></tr><tr><td scope="row"><pre>    return noErr;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>pascal ComponentResult SGPictSetChannelMatrix<span></span></pre></td></tr><tr><td scope="row"><pre>                        (SGPictGlobals store, const MatrixRecord *m)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    OSErr err = noErr;<span></span></pre></td></tr><tr><td scope="row"><pre>    MatrixRecord mat;<span></span></pre></td></tr><tr><td scope="row"><pre>    short matType;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    /* determine the matrix being set */<span></span></pre></td></tr><tr><td scope="row"><pre>    if (m)<span></span></pre></td></tr><tr><td scope="row"><pre>        mat = *m;<span></span></pre></td></tr><tr><td scope="row"><pre>    else<span></span></pre></td></tr><tr><td scope="row"><pre>        SetIdentityMatrix (&amp;mat);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    /* validate it */<span></span></pre></td></tr><tr><td scope="row"><pre>    matType = GetMatrixType (&amp;mat);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if ((mat.matrix[0][0] &lt; 0) || (mat.matrix[1][1] &lt; 0) ||<span></span></pre></td></tr><tr><td scope="row"><pre>    (matType >= linearMatrixType))<span></span></pre></td></tr><tr><td scope="row"><pre>        return paramErr;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    /* update the matrix and destination rectangle */<span></span></pre></td></tr><tr><td scope="row"><pre>    store->displayMatrix = mat;<span></span></pre></td></tr><tr><td scope="row"><pre>    store->destRect = store->srcRect;<span></span></pre></td></tr><tr><td scope="row"><pre>    TransformRect (&amp;mat, &amp;store->destRect, nil);<span></span></pre></td></tr><tr><td scope="row"><pre>    return err;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>pascal ComponentResult SGPictGetChannelMatrix<span></span></pre></td></tr><tr><td scope="row"><pre>                         (SGPictGlobals store, MatrixRecord *m)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    /* return current matrix */<span></span></pre></td></tr><tr><td scope="row"><pre>    *m = store->displayMatrix;<span></span></pre></td></tr><tr><td scope="row"><pre>    return noErr;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>pascal ComponentResult SGPictSetChannelBounds<span></span></pre></td></tr><tr><td scope="row"><pre>                           (SGPictGlobals store, const Rect *bounds)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    /* remember destination rect */<span></span></pre></td></tr><tr><td scope="row"><pre>    store->destRect = *bounds;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    /* recalculate display matrix from it */<span></span></pre></td></tr><tr><td scope="row"><pre>    RectMatrix (&amp;store->displayMatrix, &amp;store->srcRect,<span></span></pre></td></tr><tr><td scope="row"><pre>                     &amp;store->destRect);<span></span></pre></td></tr><tr><td scope="row"><pre>    return noErr;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>pascal ComponentResult SGPictGetChannelBounds<span></span></pre></td></tr><tr><td scope="row"><pre>                            (SGPictGlobals store, Rect *bounds)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    /* return current boundaries */<span></span></pre></td></tr><tr><td scope="row"><pre>    *bounds = store->destRect;<span></span></pre></td></tr><tr><td scope="row"><pre>    return noErr;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>pascal ComponentResult SGPictSetChannelClip (SGPictGlobals store,<span></span></pre></td></tr><tr><td scope="row"><pre>                                                RgnHandle theClip)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    OSErr err = noErr;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    /* toss the old channel clipping */<span></span></pre></td></tr><tr><td scope="row"><pre>    if (store->clip) {<span></span></pre></td></tr><tr><td scope="row"><pre>        DisposeRgn (store->clip);<span></span></pre></td></tr><tr><td scope="row"><pre>        store->clip = nil;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    /* and remember the new one */<span></span></pre></td></tr><tr><td scope="row"><pre>    if (theClip) {<span></span></pre></td></tr><tr><td scope="row"><pre>        err = HandToHand ((Handle *)&amp;theClip);<span></span></pre></td></tr><tr><td scope="row"><pre>        store->clip = theClip;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    return err;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>pascal ComponentResult SGPictGetChannelClip<span></span></pre></td></tr><tr><td scope="row"><pre>                         (SGPictGlobals store, RgnHandle *theClip)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    OSErr err = noErr;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    /* return clip, if there is one */<span></span></pre></td></tr><tr><td scope="row"><pre>    if (*theClip = store->clip)<span></span></pre></td></tr><tr><td scope="row"><pre>        err = HandToHand ((Handle *)theClip);<span></span></pre></td></tr><tr><td scope="row"><pre>    return err;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div>


<a name="//apple_ref/doc/uid/TP40000906-SequenceGrabberChannelComponents-DontLinkElementID_84" title="Controlling Previewing and Recording Operations"></a>
<h3><a name="//apple_ref/doc/uid/TP40000906-SequenceGrabberChannelComponents-ControllingPreviewingandRecordingOperations" title="Controlling Previewing and Recording Operations"></a>Controlling Previewing and Recording Operations</h3>
<p>To preview and record image data in the channel component, the code in Listing 5-5 implements these tasks:</p>
<ol class="ol">
<li class="li"><p>The <code><a href="../../../../Reference/QTRef_SequenceGrabber/Reference/reference.html#//apple_ref/c/func/SGStartPreview" target="_top">SGStartPreview</a></code> function instructs the channel to commence processing any source data. In preview mode, the component does not save any of the data it gathers from its source. Your channel component should immediately present the data to the user in the appropriate format for the channel’s configuration and display video data in the destination display region.</p></li>
<li class="li"><p>The <code><a href="../../../../Reference/QTRef_SequenceGrabber/Reference/reference.html#//apple_ref/c/func/SGStartRecord" target="_top">SGStartRecord</a></code> function instructs the channel to begin recording data from its source. The sequence grabber component stores the collected data. The channel component should immediately begin recording data.</p></li>
<li class="li"><p>The <code><a href="../../../../Reference/QTRef_SequenceGrabber/Reference/reference.html#//apple_ref/c/func/SGIdle" target="_top">SGIdle</a></code> function allows the sequence grabber component to grant processing time to the channel component. The <code><a href="../../../../Reference/QTRef_SequenceGrabber/Reference/reference.html#//apple_ref/c/func/SGIdle" target="_top">SGIdle</a></code> function permits the processing time for the previewing and recording operations to take place. In the example shown in  Listing 5-5, the work for the channel consists of getting the current time, adding data to the movie if recording, and showing the preview image if necessary.</p></li>
<li class="li"><p>The <code><a href="../../../../Reference/QTRef_SequenceGrabber/Reference/reference.html#//apple_ref/c/func/SGStop" target="_top">SGStop</a></code> function stops the channel’s preview and recording operations.</p></li>
<li class="li"><p>The <code><a href="../../../../Reference/QTRef_SequenceGrabber/Reference/reference.html#//apple_ref/c/func/SGPause" target="_top">SGPause</a></code> function suspends or restarts the channel’s preview and recording operations.</p></li>
<li class="li"><p>The <code><a href="../../../../Reference/QTRef_SequenceGrabber/Reference/reference.html#//apple_ref/c/func/SGPrepare" target="_top">SGPrepare</a></code> function has the sequence grabber component prepare the channel for subsequent preview or record operations.</p></li>
<li class="li"><p>The <code><a href="../../../../Reference/QTRef_SequenceGrabber/Reference/reference.html#//apple_ref/c/func/SGRelease" target="_top">SGRelease</a></code> function releases any system resources that were allocated during preview or recording operations and that remain thereafter.</p></li>
</ol>
<p>The code in Listing 5-5 illustrates a channel component’s control of the previewing and recording of a PICT image.</p>
<a name="//apple_ref/doc/uid/TP40000906-SequenceGrabberChannelComponents-DontLinkElementID_173" title="Listing 5-5Controlling previewing and recording operations"></a>
<p class="codesample"><strong>Listing 5-5&nbsp;&nbsp;</strong>Controlling previewing and recording operations</p>
<div class="codesample"><table><tr><td scope="row"><pre>pascal ComponentResult SGPictStartPreview (SGPictGlobals store)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    /* into preview mode */<span></span></pre></td></tr><tr><td scope="row"><pre>    store->inPreview = (store->usage &amp; seqGrabPreview) != 0;<span></span></pre></td></tr><tr><td scope="row"><pre>    return noErr;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>pascal ComponentResult SGPictStartRecord (SGPictGlobals store)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    /* into record mode (also preview, if PlayDuringRecord) */<span></span></pre></td></tr><tr><td scope="row"><pre>    store->inRecord = (store->usage &amp; seqGrabRecord) != 0;<span></span></pre></td></tr><tr><td scope="row"><pre>    store->inPreview = (store->usage &amp; seqGrabPlayDuringRecord) !=<span></span></pre></td></tr><tr><td scope="row"><pre>    0;<span></span></pre></td></tr><tr><td scope="row"><pre>    return noErr;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>pascal ComponentResult SGPictIdle (SGPictGlobals store)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    OSErr err = noErr;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    /* this is where the work for preview and record happens */<span></span></pre></td></tr><tr><td scope="row"><pre>    if (!store->paused &amp;&amp; (store->inRecord || store->inPreview)) {<span></span></pre></td></tr><tr><td scope="row"><pre>        Point mouseLoc;<span></span></pre></td></tr><tr><td scope="row"><pre>        Rect r;<span></span></pre></td></tr><tr><td scope="row"><pre>        PicHandle tempPict = nil;<span></span></pre></td></tr><tr><td scope="row"><pre>        TimeRecord tr;<span></span></pre></td></tr><tr><td scope="row"><pre>        CGrafPtr savePort;<span></span></pre></td></tr><tr><td scope="row"><pre>        GDHandle saveGD;<span></span></pre></td></tr><tr><td scope="row"><pre>        Rect maxR;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        GetGWorld (&amp;savePort, &amp;saveGD);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        /* get the current time */<span></span></pre></td></tr><tr><td scope="row"><pre>        GetTimeBaseTime (store->base, kMediaTimeScale, &amp;tr);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        /* figure the current area around the mouse<span></span></pre></td></tr><tr><td scope="row"><pre>            (only on main screen) */<span></span></pre></td></tr><tr><td scope="row"><pre>        SetGWorld (&amp;store->tempPort, GetMainDevice());<span></span></pre></td></tr><tr><td scope="row"><pre>        GetMouse (&amp;mouseLoc);<span></span></pre></td></tr><tr><td scope="row"><pre>        LocalToGlobal (&amp;mouseLoc);<span></span></pre></td></tr><tr><td scope="row"><pre>        r.top = r.bottom = mouseLoc.v;<span></span></pre></td></tr><tr><td scope="row"><pre>        r.left = r.right = mouseLoc.h;<span></span></pre></td></tr><tr><td scope="row"><pre>        InsetRect(&amp;r, -(store->srcRect.right >> 1),<span></span></pre></td></tr><tr><td scope="row"><pre>                         -(store->srcRect.bottom >> 1));<span></span></pre></td></tr><tr><td scope="row"><pre>        maxR = (**GetMainDevice()).gdRect;<span></span></pre></td></tr><tr><td scope="row"><pre>        if (r.left &lt; maxR.left)<span></span></pre></td></tr><tr><td scope="row"><pre>             OffsetRect (&amp;r, -r.left + maxR.left, 0);<span></span></pre></td></tr><tr><td scope="row"><pre>        if (r.top &lt; maxR.top)<span></span></pre></td></tr><tr><td scope="row"><pre>             OffsetRect (&amp;r, 0, -r.top + maxR.top);<span></span></pre></td></tr><tr><td scope="row"><pre>        if (r.right > maxR.right)<span></span></pre></td></tr><tr><td scope="row"><pre>             OffsetRect(&amp;r, maxR.right - r.right, 0);<span></span></pre></td></tr><tr><td scope="row"><pre>        if (r.bottom > maxR.bottom)<span></span></pre></td></tr><tr><td scope="row"><pre>             OffsetRect (&amp;r, 0, maxR.bottom - r.bottom);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        /* copy the screen into a picture */<span></span></pre></td></tr><tr><td scope="row"><pre>        tempPict = OpenPicture(&amp;r);<span></span></pre></td></tr><tr><td scope="row"><pre>            CopyBits ((BitMap *)&amp;store->tempPort.portPixMap,<span></span></pre></td></tr><tr><td scope="row"><pre>                        (BitMap *)&amp;store->tempPort.portPixMap, &amp;r, &amp;r,<span></span></pre></td></tr><tr><td scope="row"><pre>                                     srcCopy, nil);<span></span></pre></td></tr><tr><td scope="row"><pre>            if (store->showTickCount) {<span></span></pre></td></tr><tr><td scope="row"><pre>                /* if users want to see ticks, draw them */<span></span></pre></td></tr><tr><td scope="row"><pre>                Str63 str;<span></span></pre></td></tr><tr><td scope="row"><pre>                NumToString ( TickCount(), str);<span></span></pre></td></tr><tr><td scope="row"><pre>                /* do some magic positioning */<span></span></pre></td></tr><tr><td scope="row"><pre>                r.right = r.left + StringWidth(str) + 4;<span></span></pre></td></tr><tr><td scope="row"><pre>                r.bottom = r.top + 14;<span></span></pre></td></tr><tr><td scope="row"><pre>                EraseRect (&amp;r);<span></span></pre></td></tr><tr><td scope="row"><pre>                MoveTo(r.left + 2, r.bottom - 3);<span></span></pre></td></tr><tr><td scope="row"><pre>                TextSize (12);<span></span></pre></td></tr><tr><td scope="row"><pre>                DrawString (str);<span></span></pre></td></tr><tr><td scope="row"><pre>            }<span></span></pre></td></tr><tr><td scope="row"><pre>        ClosePicture();<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        /* if recording, add data to movie */<span></span></pre></td></tr><tr><td scope="row"><pre>        if (store->inRecord) {<span></span></pre></td></tr><tr><td scope="row"><pre>            long offset;<span></span></pre></td></tr><tr><td scope="row"><pre>            long pictSize = GetHandleSize ((Handle)tempPict);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>            HLock ((Handle)tempPict);<span></span></pre></td></tr><tr><td scope="row"><pre>            err = SGAddMovieData (store->grabber, store->self,<span></span></pre></td></tr><tr><td scope="row"><pre>                                    (Ptr)*tempPict, pictSize, &amp;offset, 0,<span></span></pre></td></tr><tr><td scope="row"><pre>                                    tr.value.lo, seqGrabWriteAppend);<span></span></pre></td></tr><tr><td scope="row"><pre>            store->bytesWritten += pictSize;<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        /* if you need to show the preview image, do that */<span></span></pre></td></tr><tr><td scope="row"><pre>        if (store->inPreview) {<span></span></pre></td></tr><tr><td scope="row"><pre>            RgnHandle saveClip;<span></span></pre></td></tr><tr><td scope="row"><pre>            SetGWorld (store->destPort, store->destGD);<span></span></pre></td></tr><tr><td scope="row"><pre>            if (store->clip) {<span></span></pre></td></tr><tr><td scope="row"><pre>                saveClip = NewRgn();<span></span></pre></td></tr><tr><td scope="row"><pre>                GetClip (saveClip);<span></span></pre></td></tr><tr><td scope="row"><pre>                SetClip (store->clip);<span></span></pre></td></tr><tr><td scope="row"><pre>            }<span></span></pre></td></tr><tr><td scope="row"><pre>            DrawPicture (tempPict, &amp;store->destRect);<span></span></pre></td></tr><tr><td scope="row"><pre>            if (store->clip) {<span></span></pre></td></tr><tr><td scope="row"><pre>                SetClip (saveClip);<span></span></pre></td></tr><tr><td scope="row"><pre>                DisposeRgn (saveClip);<span></span></pre></td></tr><tr><td scope="row"><pre>            }<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        KillPicture (tempPict);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        SetGWorld (savePort, saveGD);<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    return err;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>pascal ComponentResult SGPictStop (SGPictGlobals store)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    /* stop all previewing and recording */<span></span></pre></td></tr><tr><td scope="row"><pre>    store->inRecord = store->inPreview = false;<span></span></pre></td></tr><tr><td scope="row"><pre>    return noErr;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>pascal ComponentResult SGPictPause (SGPictGlobals store,<span></span></pre></td></tr><tr><td scope="row"><pre>                                                Byte pause)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    /* pause */<span></span></pre></td></tr><tr><td scope="row"><pre>    store->paused = pause;<span></span></pre></td></tr><tr><td scope="row"><pre>    return noErr;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>pascal ComponentResult SGPictPrepare (SGPictGlobals store,<span></span></pre></td></tr><tr><td scope="row"><pre>                                             Boolean prepareForPreview,<span></span></pre></td></tr><tr><td scope="row"><pre>                                             Boolean prepareForRecord)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    /* prepare for previewing and recording operations --<span></span></pre></td></tr><tr><td scope="row"><pre>        all you do here is initialize a variable */<span></span></pre></td></tr><tr><td scope="row"><pre>    store->bytesWritten = 0;<span></span></pre></td></tr><tr><td scope="row"><pre>    return noErr;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>pascal ComponentResult SGPictRelease (SGPictGlobals store)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    /* no resources to release after previewing or recording */<span></span></pre></td></tr><tr><td scope="row"><pre>    return noErr;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div>


<a name="//apple_ref/doc/uid/TP40000906-SequenceGrabberChannelComponents-DontLinkElementID_85" title="Managing Channel Devices"></a>
<h3><a name="//apple_ref/doc/uid/TP40000906-SequenceGrabberChannelComponents-ManagingChannelDevices" title="Managing Channel Devices"></a>Managing Channel Devices</h3>
<p>To manage channel devices such as video digitizers or sound input drivers, you should</p>
<ol class="ol">
<li class="li"><p>Let the sequence grabber retrieve a list of devices that are valid for the channel, using the <code><a href="../../../../Reference/QTRef_SequenceGrabber/Reference/reference.html#//apple_ref/c/func/SGGetChannelDeviceList" target="_top">SGGetChannelDeviceList</a></code> function.</p></li>
<li class="li"><p>Assign an appropriate channel device with the <code><a href="../../../../Reference/QTRef_SequenceGrabber/Reference/reference.html#//apple_ref/c/func/SGSetChannelDevice" target="_top">SGSetChannelDevice</a></code> function.</p></li>
</ol>
<p>Listing 5-6 provides examples of these required functions for channel device management. The <code>SGPictGetChannelDeviceList</code> function obtains a list of devices associated with the channel component. The <code>SGPictSetChannelDevice</code> function allows the sequence grabber to specify a channel device. In this code sample, there are no devices associated with the channel component.</p>
<a name="//apple_ref/doc/uid/TP40000906-SequenceGrabberChannelComponents-DontLinkElementID_174" title="Listing 5-6Coordinating devices for the channel component"></a>
<p class="codesample"><strong>Listing 5-6&nbsp;&nbsp;</strong>Coordinating devices for the channel component</p>
<div class="codesample"><table><tr><td scope="row"><pre>pascal ComponentResult SGPictGetChannelDeviceList<span></span></pre></td></tr><tr><td scope="row"><pre>                                (SGPictGlobals store,<span></span></pre></td></tr><tr><td scope="row"><pre>                                 long selectionFlags,<span></span></pre></td></tr><tr><td scope="row"><pre>                                 SGDeviceList *list)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    *list = (SGDeviceList) NewHandleClear<span></span></pre></td></tr><tr><td scope="row"><pre>                        (sizeof (SGDeviceListRecord)); /* no devices */<span></span></pre></td></tr><tr><td scope="row"><pre>    return MemError();<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>pascal ComponentResult SGPictSetChannelDevice<span></span></pre></td></tr><tr><td scope="row"><pre>                                    (SGPictGlobals store, StringPtr name)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    /* you have no devices, so no problem */<span></span></pre></td></tr><tr><td scope="row"><pre>    return noErr;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div>


<a name="//apple_ref/doc/uid/TP40000906-SequenceGrabberChannelComponents-DontLinkElementID_86" title="Utility Functions for Recording Image Data"></a>
<h3><a name="//apple_ref/doc/uid/TP40000906-SequenceGrabberChannelComponents-UtilityFunctionsforRecordingImageData" title="Utility Functions for Recording Image Data"></a>Utility Functions for Recording Image Data</h3>
<p>To record image data, the channel component must allow the sequence grabber to do the following:</p>
<ul class="spaceabove">
<li class="li"><p>Obtain an appropriate time scale with the <code><a href="../../../../Reference/QTRef_SequenceGrabber/Reference/reference.html#//apple_ref/c/func/SGGetChannelTimeScale" target="_top">SGGetChannelTimeScale</a></code> function.</p></li>
<li class="li"><p>Retrieve the sample description of the image that is to be recorded with the <code><a href="../../../../Reference/QTRef_SequenceGrabber/Reference/reference.html#//apple_ref/c/func/SGGetChannelSampleDescription" target="_top">SGGetChannelSampleDescription</a></code> function.</p></li>
<li class="li"><p>Create a track and media in which to record the sample image by calling the <code><a href="../../../../Reference/QTRef_SequenceGrabber/Reference/reference.html#//apple_ref/c/func/SGWriteSamples" target="_top">SGWriteSamples</a></code> function. <code><a href="../../../../Reference/QTRef_SequenceGrabber/Reference/reference.html#//apple_ref/c/func/SGWriteSamples" target="_top">SGWriteSamples</a></code> writes the captured data to a movie file after a record operation.</p></li>
<li class="li"><p>Obtain references from the sequence grabber and add them to the newly created media using the <code><a href="../../../../Reference/QTRef_SequenceGrabber/Reference/reference.html#//apple_ref/c/func/SGGetNextFrameReference" target="_top">SGGetNextFrameReference</a></code> function so that the channel component can retrieve the sample references it stored.</p></li>
<li class="li"><p>Determine how many bytes of captured data the channel is collecting each second using the <code><a href="../../../../Reference/QTRef_SequenceGrabber/Reference/reference.html#//apple_ref/c/func/SGGetDataRate" target="_top">SGGetDataRate</a></code> function.</p></li>
</ul>
<p>The code in Listing 5-7 shows how the channel component uses these utility functions to record PICT image data.</p>
<a name="//apple_ref/doc/uid/TP40000906-SequenceGrabberChannelComponents-DontLinkElementID_175" title="Listing 5-7Recording image data"></a>
<p class="codesample"><strong>Listing 5-7&nbsp;&nbsp;</strong>Recording image data</p>
<div class="codesample"><table><tr><td scope="row"><pre>pascal ComponentResult SGPictGetChannelTimeScale<span></span></pre></td></tr><tr><td scope="row"><pre>                          (SGPictGlobals store, TimeScale *scale)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    *scale = kMediaTimeScale; /* a reasonable default time scale */<span></span></pre></td></tr><tr><td scope="row"><pre>    return noErr;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>pascal ComponentResult SGPictGetChannelSampleDescription<span></span></pre></td></tr><tr><td scope="row"><pre>                          (SGPictGlobals store, Handle sampleDesc)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    OSErr err;<span></span></pre></td></tr><tr><td scope="row"><pre>    SampleDescriptionPtr sdp;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    SetHandleSize (sampleDesc, sizeof(SampleDescription));<span></span></pre></td></tr><tr><td scope="row"><pre>    if (err = MemError()) goto bail;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    /* make up a minimal sample description */<span></span></pre></td></tr><tr><td scope="row"><pre>    sdp = (SampleDescriptionPtr)*sampleDesc;<span></span></pre></td></tr><tr><td scope="row"><pre>    sdp->descSize = sizeof(SampleDescription);<span></span></pre></td></tr><tr><td scope="row"><pre>    sdp->dataFormat = 'PICT';<span></span></pre></td></tr><tr><td scope="row"><pre>    sdp->resvd1 = 0;<span></span></pre></td></tr><tr><td scope="row"><pre>    sdp->resvd2 = 0;<span></span></pre></td></tr><tr><td scope="row"><pre>    sdp->dataRefIndex = 0;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>bail:<span></span></pre></td></tr><tr><td scope="row"><pre>    return err;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>pascal ComponentResult SGPictWriteSamples (SGPictGlobals store,<span></span></pre></td></tr><tr><td scope="row"><pre>                                            Movie m, AliasHandle theFile)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    OSErr err = 0;<span></span></pre></td></tr><tr><td scope="row"><pre>    Track pictT;<span></span></pre></td></tr><tr><td scope="row"><pre>    Media pictM;<span></span></pre></td></tr><tr><td scope="row"><pre>    long i;<span></span></pre></td></tr><tr><td scope="row"><pre>    MatrixRecord aMatrix;<span></span></pre></td></tr><tr><td scope="row"><pre>    Rect from, to;<span></span></pre></td></tr><tr><td scope="row"><pre>    seqGrabFrameInfo fi;<span></span></pre></td></tr><tr><td scope="row"><pre>    TimeRecord tr;<span></span></pre></td></tr><tr><td scope="row"><pre>    TimeValue mediaDuration;<span></span></pre></td></tr><tr><td scope="row"><pre>    SampleDescriptionHandle sampleDesc = 0;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    /* after SGStop, this function creates the track and media */<span></span></pre></td></tr><tr><td scope="row"><pre>    if (!(store->usage &amp; seqGrabRecord))<span></span></pre></td></tr><tr><td scope="row"><pre>        return err;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    /* get the sample description */<span></span></pre></td></tr><tr><td scope="row"><pre>    sampleDesc = (SampleDescriptionHandle)NewHandle(4);<span></span></pre></td></tr><tr><td scope="row"><pre>    if (err = MemError()) goto bail;<span></span></pre></td></tr><tr><td scope="row"><pre>    if (err = SGGetChannelSampleDescription (store->self,<span></span></pre></td></tr><tr><td scope="row"><pre>                                             (Handle)sampleDesc)) goto bail;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    /* figure out the track matrix */<span></span></pre></td></tr><tr><td scope="row"><pre>    SetRect (&amp;from, 0, 0, store->srcRect.right,<span></span></pre></td></tr><tr><td scope="row"><pre>             store->srcRect.bottom);<span></span></pre></td></tr><tr><td scope="row"><pre>    to = from;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    TransformRect (&amp;store->displayMatrix, &amp;to, nil);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    /* create the track and media */<span></span></pre></td></tr><tr><td scope="row"><pre>    pictT = NewMovieTrack (m, (long)from.right &lt;&lt; 16,<span></span></pre></td></tr><tr><td scope="row"><pre>                                 (long)from.bottom &lt;&lt; 16, 0);<span></span></pre></td></tr><tr><td scope="row"><pre>    pictM = NewTrackMedia (pictT, 'PICT', kMediaTimeScale,<span></span></pre></td></tr><tr><td scope="row"><pre>                                 (Handle)theFile, rAliasType);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    /* spin in a loop getting sample references from the<span></span></pre></td></tr><tr><td scope="row"><pre>        sequence grabber and adding them to the media */<span></span></pre></td></tr><tr><td scope="row"><pre>    fi.frameChannel = store->self;<span></span></pre></td></tr><tr><td scope="row"><pre>    i = -1;<span></span></pre></td></tr><tr><td scope="row"><pre>    do {<span></span></pre></td></tr><tr><td scope="row"><pre>        TimeValue frameDuration;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        err = SGGetNextFrameReference (store->grabber,<span></span></pre></td></tr><tr><td scope="row"><pre>                                       &amp;fi, &amp;frameDuration, &amp;i);<span></span></pre></td></tr><tr><td scope="row"><pre>        if (err) {<span></span></pre></td></tr><tr><td scope="row"><pre>            if (err == paramErr)<span></span></pre></td></tr><tr><td scope="row"><pre>                err = 0;<span></span></pre></td></tr><tr><td scope="row"><pre>            break;<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        err = AddMediaSampleReference (pictM,<span></span></pre></td></tr><tr><td scope="row"><pre>                fi.frameOffset, fi.frameSize,<span></span></pre></td></tr><tr><td scope="row"><pre>                frameDuration,<span></span></pre></td></tr><tr><td scope="row"><pre>                sampleDesc, 1,<span></span></pre></td></tr><tr><td scope="row"><pre>                0, 0);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        if (err == invalidDuration) {<span></span></pre></td></tr><tr><td scope="row"><pre>            err = noErr;<span></span></pre></td></tr><tr><td scope="row"><pre>            break;<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>    } while (!err);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>done:<span></span></pre></td></tr><tr><td scope="row"><pre>    if (err) goto bail;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    GetTimeBaseTime (store->base, 0, &amp;tr);<span></span></pre></td></tr><tr><td scope="row"><pre>    ConvertTimeScale (&amp;tr, kMediaTimeScale);<span></span></pre></td></tr><tr><td scope="row"><pre>    /* trim media inserted to not extend beyond end time */<span></span></pre></td></tr><tr><td scope="row"><pre>    mediaDuration = GetMediaDuration(pictM);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    /* add media to track */<span></span></pre></td></tr><tr><td scope="row"><pre>    err = InsertMediaIntoTrack (pictT, 0, 0, tr.value.lo, kFix1);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    /* set track matrix */<span></span></pre></td></tr><tr><td scope="row"><pre>    RectMatrix (&amp;aMatrix, &amp;from, &amp;to);<span></span></pre></td></tr><tr><td scope="row"><pre>    SetTrackMatrix (pictT, &amp;aMatrix);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    /* set track clipping region */<span></span></pre></td></tr><tr><td scope="row"><pre>    SetTrackClipRgn (pictT, store->clip);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>bail:<span></span></pre></td></tr><tr><td scope="row"><pre>    if (sampleDesc) DisposHandle ((Handle)sampleDesc);<span></span></pre></td></tr><tr><td scope="row"><pre>    return err;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>pascal ComponentResult SGPictGetDataRate (SGPictGlobals store,<span></span></pre></td></tr><tr><td scope="row"><pre>                                            long *bytesPerSecond)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    /* take a guess at the data rate */<span></span></pre></td></tr><tr><td scope="row"><pre>    *bytesPerSecond = 24 * 1024;<span></span></pre></td></tr><tr><td scope="row"><pre>    if (store->bytesWritten) {<span></span></pre></td></tr><tr><td scope="row"><pre>        TimeValue timeNow = GetTimeBaseTime (store->base, 8, nil);<span></span></pre></td></tr><tr><td scope="row"><pre>                                /* one-eighth second resolution */<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        if (!timeNow)<span></span></pre></td></tr><tr><td scope="row"><pre>            return seqGrabInfoNotAvailable;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        *bytesPerSecond = (store->bytesWritten / timeNow) * 8;<span></span></pre></td></tr><tr><td scope="row"><pre>                                /* convert back to seconds */<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    return noErr;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div>


<a name="//apple_ref/doc/uid/TP40000906-SequenceGrabberChannelComponents-DontLinkElementID_87" title="Providing Media-Specific Functions"></a>
<h3><a name="//apple_ref/doc/uid/TP40000906-SequenceGrabberChannelComponents-ProvidingMediaSpecificFunctions" title="Providing Media-Specific Functions"></a>Providing Media-Specific Functions</h3>
<p>The channel can provide media-specific functions for a particular channel type. These functions are analogous to the <code><a href="../../../../Reference/QTRef_SequenceGrabber/Reference/reference.html#//apple_ref/c/func/SGSetVideoCompressorType" target="_top">SGSetVideoCompressorType</a></code> and <code><a href="../../../../Reference/QTRef_SequenceGrabber/Reference/reference.html#//apple_ref/c/func/SGGetVideoCompressorType" target="_top">SGGetVideoCompressorType</a></code> functions. These functions allow the sequence grabber to specify and determine the type of image compression the channel component is to apply to the captured video images.</p>
<p>The code in Listing 5-8 provides two specialized channel component functions, <code>SGPictSetShowTickCount</code> and <code>SGPictGetShowTickCount</code>, which set and retrieve the tick count, respectively. Note that both the functions refer to the <code>showTickCount</code> field in the <code>SGPictGlobals</code> structure.</p>
<a name="//apple_ref/doc/uid/TP40000906-SequenceGrabberChannelComponents-DontLinkElementID_176" title="Listing 5-8Showing the tick count"></a>
<p class="codesample"><strong>Listing 5-8&nbsp;&nbsp;</strong>Showing the tick count</p>
<div class="codesample"><table><tr><td scope="row"><pre>pascal ComponentResult SGPictSetShowTickCount<span></span></pre></td></tr><tr><td scope="row"><pre>                         (SGPictGlobals store, Boolean show)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    store->showTickCount = show;<span></span></pre></td></tr><tr><td scope="row"><pre>    return noErr;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>pascal ComponentResult SGPictGetShowTickCount<span></span></pre></td></tr><tr><td scope="row"><pre>                         (SGPictGlobals store, Boolean *show)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    *show = store->showTickCount;<span></span></pre></td></tr><tr><td scope="row"><pre>    return noErr;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div>


<a name="//apple_ref/doc/uid/TP40000906-SequenceGrabberChannelComponents-DontLinkElementID_88" title="Managing the Settings Dialog Box"></a>
<h3><a name="//apple_ref/doc/uid/TP40000906-SequenceGrabberChannelComponents-ManagingtheSettingsDialogBox" title="Managing the Settings Dialog Box"></a>Managing the Settings Dialog Box</h3>
<p>The channel allows the sequence grabber to manage the placement of your channel data in the sequence grabber’s settings dialog box. This is how it works:</p>
<ol class="ol">
<li class="li"><p>To prepare to add the channel component’s items to the settings dialog box, the sequence grabber obtains your item list by calling the sequence grabber panel component’s <code>SGPanelGetDITL</code> function. It retrieves and detaches the dialog box template from the sequence grabber panel component.</p></li>
<li class="li"><p>Once it has installed the items, the sequence grabber uses the <code><a href="../../../../Reference/QTRef_SequenceGrabber/Reference/reference.html#//apple_ref/c/func/SGPanelInstall" target="_top">SGPanelInstall</a></code> function so initial values can be set. This function resets the channel to use the dialog window and preview mode. It also updates the boundaries to match the size of the user item list.</p></li>
<li class="li"><p>To provide idle time in which to draw the channel’s information in the settings dialog box, the sequence grabber uses the <code><a href="../../../../Reference/QTRef_SequenceGrabber/Reference/reference.html#//apple_ref/c/func/SGPanelEvent" target="_top">SGPanelEvent</a></code> function. It allows the sequence grabber component to receive and process dialog events in a manner similar to a modal-dialog filter function. In this example, the information is the tick count.</p></li>
<li class="li"><p>Prior to the removal of items from the settings dialog box, the sequence grabber component calls the <code><a href="../../../../Reference/QTRef_SequenceGrabber/Reference/reference.html#//apple_ref/c/func/SGPanelRemove" target="_top">SGPanelRemove</a></code> function. The sequence grabber supplies information that specifies the channel that the panel is to configure, the dialog box, and the offset of the panel’s items into the dialog box.</p></li>
</ol>
<p>The code in Listing 5-9 calls the sequence grabber panel component and indicates that the channel component will display a tick count checkbox in the panel settings.</p>
<a name="//apple_ref/doc/uid/TP40000906-SequenceGrabberChannelComponents-DontLinkElementID_177" title="Listing 5-9Including a tick count checkbox in a dialog box in the panel component"></a>
<p class="codesample"><strong>Listing 5-9&nbsp;&nbsp;</strong>Including a tick count checkbox in a dialog box in the panel component</p>
<div class="codesample"><table><tr><td scope="row"><pre>pascal ComponentResult SGPictPanelGetDitl (SGPictGlobals store,<span></span></pre></td></tr><tr><td scope="row"><pre>                                               Handle *ditl)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    /* get and detach your dialog template */<span></span></pre></td></tr><tr><td scope="row"><pre>    *ditl = GetResource('DITL', 7000);<span></span></pre></td></tr><tr><td scope="row"><pre>    if (!*ditl) return resNotFound;<span></span></pre></td></tr><tr><td scope="row"><pre>    DetachResource(*ditl);<span></span></pre></td></tr><tr><td scope="row"><pre>    return noErr;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>pascal ComponentResult SGPictPanelInstall (SGPictGlobals store,<span></span></pre></td></tr><tr><td scope="row"><pre>                                                SGChannel c,<span></span></pre></td></tr><tr><td scope="row"><pre>                                                DialogPtr d,<span></span></pre></td></tr><tr><td scope="row"><pre>                                                short itemOffset)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    Rect newBounds;<span></span></pre></td></tr><tr><td scope="row"><pre>    short kind;<span></span></pre></td></tr><tr><td scope="row"><pre>    Handle h;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    /* reset this channel to use the dialog window and be in<span></span></pre></td></tr><tr><td scope="row"><pre>        preview mode with no clip */<span></span></pre></td></tr><tr><td scope="row"><pre>    SGSetGWorld (store->self, (CGrafPtr)d, GetMainDevice());<span></span></pre></td></tr><tr><td scope="row"><pre>    SGGetChannelUsage (store->self, &amp;store->saveUsage);<span></span></pre></td></tr><tr><td scope="row"><pre>    SGSetChannelUsage (store->self, seqGrabPreview);<span></span></pre></td></tr><tr><td scope="row"><pre>    SGSetChannelClip (c, nil);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    /* update boundaries to match size of user item */<span></span></pre></td></tr><tr><td scope="row"><pre>    GetDItem (d, 1 + itemOffset, &amp;kind, &amp;h, &amp;newBounds);<span></span></pre></td></tr><tr><td scope="row"><pre>    SGSetChannelBounds (c, &amp;newBounds);<span></span></pre></td></tr><tr><td scope="row"><pre>    SGStartPreview (store->self);<span></span></pre></td></tr><tr><td scope="row"><pre>    return noErr;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>pascal ComponentResult SGPictPanelEvent (SGPictGlobals store,<span></span></pre></td></tr><tr><td scope="row"><pre>                                            SGChannel c, DialogPtr d,<span></span></pre></td></tr><tr><td scope="row"><pre>                                            short itemOffset,<span></span></pre></td></tr><tr><td scope="row"><pre>                                            EventRecord *theEvent,<span></span></pre></td></tr><tr><td scope="row"><pre>                                            short *itemHit,<span></span></pre></td></tr><tr><td scope="row"><pre>                                            Boolean *handled)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    /* use idle time to draw */<span></span></pre></td></tr><tr><td scope="row"><pre>    if (theEvent->what == nullEvent)<span></span></pre></td></tr><tr><td scope="row"><pre>        return SGIdle (store->self);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    return noErr;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>pascal ComponentResult SGPictPanelRemove (SGPictGlobals store,<span></span></pre></td></tr><tr><td scope="row"><pre>                                            SGChannel c, DialogPtr d,<span></span></pre></td></tr><tr><td scope="row"><pre>                                            short itemOffset)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    /* stop playing */<span></span></pre></td></tr><tr><td scope="row"><pre>    SGStop (store->self);<span></span></pre></td></tr><tr><td scope="row"><pre>    SGRelease (store->self);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    /* note that the clip and bounds are automatically restored<span></span></pre></td></tr><tr><td scope="row"><pre>     for you because you stored them using the SGGetSettings<span></span></pre></td></tr><tr><td scope="row"><pre>     function */<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    /* restore usage */<span></span></pre></td></tr><tr><td scope="row"><pre>    SGSetChannelUsage(store->self, store->saveUsage);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    return noErr;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div>


<a name="//apple_ref/doc/uid/TP40000906-SequenceGrabberChannelComponents-DontLinkElementID_89" title="Displaying Channel Information in the Settings Dialog Box"></a>
<h3><a name="//apple_ref/doc/uid/TP40000906-SequenceGrabberChannelComponents-DisplayingChannelInformationintheSettingsDialogBox" title="Displaying Channel Information in the Settings Dialog Box"></a>Displaying Channel Information in the Settings Dialog Box</h3>
<p>The final step in the implementation of a sequence grabber channel component is the display of the channel preview in the settings dialog box. Two sequence grabber functions, <code><a href="../../../../Reference/QTRef_SequenceGrabber/Reference/reference.html#//apple_ref/c/func/SGSettingsDialog" target="_top">SGSettingsDialog</a></code> and <code>SGGetSettingsDialog</code>, facilitate this process.</p>
<ol class="ol">
<li class="li"><p>The channel component instructs the sequence grabber to display its settings dialog box to the user by calling the sequence grabber component’s <code><a href="../../../../Reference/QTRef_SequenceGrabber/Reference/reference.html#//apple_ref/c/func/SGSettingsDialog" target="_top">SGSettingsDialog</a></code> function. The user can specify the configuration of a sequence grabber channel in this dialog box.</p></li>
<li class="li"><p>To retrieve the current settings of all channels used by the sequence grabber, call the <code><a href="../../../../Reference/QTRef_SequenceGrabber/Reference/reference.html#//apple_ref/c/func/SGGetSettings" target="_top">SGGetSettings</a></code> function. The sequence grabber places all of this configuration information into a Movie Toolbox user data list.</p></li>
</ol>
<p>Listing 5-10 illustrates code that creates a user data list to contain the tick count information for the sequence grabber’s settings dialog box, adds a matrix to the list, and stores clipping information (if any exists). The sample code then restores the clipping and the matrix.</p>
<a name="//apple_ref/doc/uid/TP40000906-SequenceGrabberChannelComponents-DontLinkElementID_178" title="Listing 5-10Displaying channel settings"></a>
<p class="codesample"><strong>Listing 5-10&nbsp;&nbsp;</strong>Displaying channel settings</p>
<div class="codesample"><table><tr><td scope="row"><pre>pascal ComponentResult SGPictPanelGetSettings<span></span></pre></td></tr><tr><td scope="row"><pre>                          (SGPictGlobals store, SGChannel c,<span></span></pre></td></tr><tr><td scope="row"><pre>                           UserData *result, long flags)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    OSErr err = noErr;<span></span></pre></td></tr><tr><td scope="row"><pre>    UserData ud = 0;<span></span></pre></td></tr><tr><td scope="row"><pre>    MatrixRecord matrix;<span></span></pre></td></tr><tr><td scope="row"><pre>    RgnHandle clip;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    /* create a user data list to hold your state */<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if (err = NewUserData (&amp;ud)) goto bail;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    /* add matrix to user data */<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if (SGGetChannelMatrix (c, &amp;matrix) == noErr) {<span></span></pre></td></tr><tr><td scope="row"><pre>        if (err = SetUserDataItem (ud, &amp;matrix, sizeof(matrix),<span></span></pre></td></tr><tr><td scope="row"><pre>                                         sgMatrixType, 1))<span></span></pre></td></tr><tr><td scope="row"><pre>            goto bail;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    /* store clip, if there is one */<span></span></pre></td></tr><tr><td scope="row"><pre>    if (SGGetChannelClip (c, &amp;clip) == noErr) {<span></span></pre></td></tr><tr><td scope="row"><pre>        if (clip)<span></span></pre></td></tr><tr><td scope="row"><pre>            err = AddUserData (ud, (Handle)clip, sgClipType);<span></span></pre></td></tr><tr><td scope="row"><pre>        else<span></span></pre></td></tr><tr><td scope="row"><pre>            err = SetUserDataItem (ud, nil, 0, sgClipType, 1);<span></span></pre></td></tr><tr><td scope="row"><pre>                                    /* add a dummy to indicate none */<span></span></pre></td></tr><tr><td scope="row"><pre>        DisposeRgn(clip);<span></span></pre></td></tr><tr><td scope="row"><pre>        if (err) goto bail;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>bail:<span></span></pre></td></tr><tr><td scope="row"><pre>    if (err) {<span></span></pre></td></tr><tr><td scope="row"><pre>        DisposeUserData (ud);<span></span></pre></td></tr><tr><td scope="row"><pre>        ud = 0;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    *result = ud;<span></span></pre></td></tr><tr><td scope="row"><pre>    return err;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>pascal ComponentResult SGPictPanelSetSettings<span></span></pre></td></tr><tr><td scope="row"><pre>                                    (SGPictGlobals store,<span></span></pre></td></tr><tr><td scope="row"><pre>                                     SGChannel c, UserData ud, long flags)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    OSErr err;<span></span></pre></td></tr><tr><td scope="row"><pre>    RgnHandle clip = NewRgn();<span></span></pre></td></tr><tr><td scope="row"><pre>    MatrixRecord matrix;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    /* restore clip, if one was stored */<span></span></pre></td></tr><tr><td scope="row"><pre>    if (GetUserData (ud, (Handle)clip, sgClipType, 1) == noErr) {<span></span></pre></td></tr><tr><td scope="row"><pre>        if (err = SGSetChannelClip<span></span></pre></td></tr><tr><td scope="row"><pre>                        (c, GetHandleSize ((Handle)clip) ? clip : 0))<span></span></pre></td></tr><tr><td scope="row"><pre>            goto bail;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    /* restore matrix */<span></span></pre></td></tr><tr><td scope="row"><pre>    if (err = GetUserDataItem (ud, &amp;matrix, sizeof(matrix),<span></span></pre></td></tr><tr><td scope="row"><pre>                                         sgMatrixType, 1)) goto bail;<span></span></pre></td></tr><tr><td scope="row"><pre>    if (err = SGSetChannelMatrix (c, &amp;matrix))<span></span></pre></td></tr><tr><td scope="row"><pre>         goto bail;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>bail:<span></span></pre></td></tr><tr><td scope="row"><pre>    DisposeRgn (clip);<span></span></pre></td></tr><tr><td scope="row"><pre>    return err;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div>



<a name="//apple_ref/doc/uid/TP40000906-SequenceGrabberChannelComponents-DontLinkElementID_90" title="Support for Sound Capture at Any Sample Rate"></a>
<h2><a name="//apple_ref/doc/uid/TP40000906-SequenceGrabberChannelComponents-SupportforSoundCaptureatAnySampleRate" title="Support for Sound Capture at Any Sample Rate"></a>Support for Sound Capture at Any Sample Rate</h2>
<p>The sequence grabber sound channel allows sound to be captured at any sample rate. The sample rate is specified by using <code><a href="../../../../Reference/QTRef_SequenceGrabber/Reference/reference.html#//apple_ref/c/func/SGSetSoundInputRate" target="_top">SGSetSoundInputRate</a></code>. If the requested rate is not one of the hardware rates, the sound will be captured using the closest available hardware sample rate and will be rate-converted in software to the requested rate.</p>
<p>In most cases, sound capture hardware does not run at the same clock rate as the motherboard crystal used to generate time stamps. Sound capture hardware also rarely runs on the same clock as video capture hardware. Over time, drift between these clocks can result in the loss of synchronization between sound and video.</p>
<p>QuickTime measures the drift over the duration of the capture and applies an adjustment to the sample rate of the audio to keep things synchronized. In nearly all cases, this is the right thing to do. If your hardware really knows that it always captures at the correct sample rate, it can tell QuickTime not to adjust the sample rate.</p>
<p>To prohibit adjustment of the sample rate, implement the <code>'qtrt'</code> resource in your sound input device’s <code>GetInfo</code> routine. The argument passed is a pointer to a <code>short</code>. Set the <code>short</code> to <code>true</code> to indicate you don’t want sample rate adjustment to be applied.</p>

<a name="//apple_ref/doc/uid/TP40000906-SequenceGrabberChannelComponents-DontLinkElementID_91" title="Channel Source Names"></a>
<h2><a name="//apple_ref/doc/uid/TP40000906-SequenceGrabberChannelComponents-ChannelSourceNames" title="Channel Source Names"></a>Channel Source Names</h2>
<p>The sequence grabber supports two functions, <code><a href="../../../../Reference/QTRef_SequenceGrabber/Reference/reference.html#//apple_ref/c/func/SGChannelSetDataSourceName" target="_top">SGChannelSetDataSourceName</a></code> and <code><a href="../../../../Reference/QTRef_SequenceGrabber/Reference/reference.html#//apple_ref/c/func/SGChannelGetDataSourceName" target="_top">SGChannelGetDataSourceName</a></code>, that allow you to specify the source identification information associated with a sequence grabber channel.</p>

<a name="//apple_ref/doc/uid/TP40000906-SequenceGrabberChannelComponents-DontLinkElementID_92" title="Capturing to Multiple Files"></a>
<h2><a name="//apple_ref/doc/uid/TP40000906-SequenceGrabberChannelComponents-CapturingtoMultipleFiles" title="Capturing to Multiple Files"></a>Capturing to Multiple Files</h2>
<p>In QuickTime, sequence grabber channel components can capture data into multiple files. Capturing to multiple files can improve the performance and flexibility of captures and enable larger total captures.</p>
<a name="//apple_ref/doc/uid/TP40000906-SequenceGrabberChannelComponents-DontLinkElementID_93" title="Creating a Sequence Grabber Component that Captures Multiple Files"></a>
<h3><a name="//apple_ref/doc/uid/TP40000906-SequenceGrabberChannelComponents-CreatingaSequenceGrabberComponentthatCapturesMultipleFiles" title="Creating a Sequence Grabber Component that Captures Multiple Files"></a>Creating a Sequence Grabber Component that Captures Multiple Files</h3>
<p>You can create a sequence grabber component that can capture to multiple files by doing the following in your sequence grabber component:</p>
<ul class="spaceabove">
<li class="li"><p>Use <code><a href="../../../../Reference/QTRef_SequenceGrabber/Reference/reference.html#//apple_ref/c/func/SGAddExtendedMovieData" target="_top">SGAddExtendedMovieData</a></code> rather than <code><a href="../../../../Reference/QTRef_SequenceGrabber/Reference/reference.html#//apple_ref/c/func/SGAddMovieData" target="_top">SGAddMovieData</a></code> to write data.</p></li>
<li class="li"><p>In the <code><a href="../../../../Reference/QTRef_SequenceGrabber/Reference/reference.html#//apple_ref/c/func/SGWriteSamples" target="_top">SGWriteSamples</a></code> routine, instead of using <code><a href="../../../../Reference/QTRef_SequenceGrabber/Reference/reference.html#//apple_ref/c/func/SGGetNextFrameReference" target="_top">SGGetNextFrameReference</a></code>, use <code><a href="../../../../Reference/QTRef_SequenceGrabber/Reference/reference.html#//apple_ref/c/func/SGGetNextExtendedFrameReference" target="_top">SGGetNextExtendedFrameReference</a></code>.</p></li>
</ul>
<p>An example of how to do this is shown in Listing 5-11. This example also shows how to use the <code><a href="../../../../Reference/QTRef_SequenceGrabber/Reference/reference.html#//apple_ref/c/func/SGAddOutputDataRefToMedia" target="_top">SGAddOutputDataRefToMedia</a></code> helper routine to easily manage the multiple files in which the captured data is stored.</p>
<a name="//apple_ref/doc/uid/TP40000906-SequenceGrabberChannelComponents-DontLinkElementID_179" title="Listing 5-11Channel capture and managing multiple output files"></a>
<p class="codesample"><strong>Listing 5-11&nbsp;&nbsp;</strong>Channel capture and managing multiple output files</p>
<div class="codesample"><table><tr><td scope="row"><pre>Track aTrack = NewMovieTrack(theMovie, width, height, 0);<span></span></pre></td></tr><tr><td scope="row"><pre>Media aMedia = NewTrackMedia(aTrack, TextMediaType,<span></span></pre></td></tr><tr><td scope="row"><pre>                        kMediaTimeScale, nil, 0);<span></span></pre></td></tr><tr><td scope="row"><pre>SeqGrabExtendedFrameInfo fi;<span></span></pre></td></tr><tr><td scope="row"><pre>SGOutput lastOutput = nil;<span></span></pre></td></tr><tr><td scope="row"><pre>long i;<span></span></pre></td></tr><tr><td scope="row"><pre>OSErr err;<span></span></pre></td></tr><tr><td scope="row"><pre>fi.frameChannel = store->self;<span></span></pre></td></tr><tr><td scope="row"><pre>i = -1;<span></span></pre></td></tr><tr><td scope="row"><pre>do {<span></span></pre></td></tr><tr><td scope="row"><pre>    TimeValue frameDuration;<span></span></pre></td></tr><tr><td scope="row"><pre>    err = SGGetNextExtendedFrameReference(store->grabber, &amp;fi,<span></span></pre></td></tr><tr><td scope="row"><pre>            &amp;frameDuration, &amp;i);<span></span></pre></td></tr><tr><td scope="row"><pre>            if (err) {<span></span></pre></td></tr><tr><td scope="row"><pre>                if (err == paramErr)<span></span></pre></td></tr><tr><td scope="row"><pre>                err = noErr;<span></span></pre></td></tr><tr><td scope="row"><pre>                break;<span></span></pre></td></tr><tr><td scope="row"><pre>            }<span></span></pre></td></tr><tr><td scope="row"><pre>    // switch to the next data reference<span></span></pre></td></tr><tr><td scope="row"><pre>    if (lastOutput != fi.frameOutput) {<span></span></pre></td></tr><tr><td scope="row"><pre>        err = SGAddOutputDataRefToMedia(store->grabber,<span></span></pre></td></tr><tr><td scope="row"><pre>            fi.frameOutput, aMedia, sampleDescription);<span></span></pre></td></tr><tr><td scope="row"><pre>        if (err) goto exit;<span></span></pre></td></tr><tr><td scope="row"><pre>        lastOutput = fi.frameOutput;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    //note that only the low 32 bits of the file offset are used here<span></span></pre></td></tr><tr><td scope="row"><pre>    err = AddMediaSampleReference(aMedia,<span></span></pre></td></tr><tr><td scope="row"><pre>            fi.frameOffset.lo, fi.frameSize,<span></span></pre></td></tr><tr><td scope="row"><pre>            frameDuration,<span></span></pre></td></tr><tr><td scope="row"><pre>            sampleDescription, 1,<span></span></pre></td></tr><tr><td scope="row"><pre>            0, 0);<span></span></pre></td></tr><tr><td scope="row"><pre>} while (err == noErr);<span></span></pre></td></tr><tr><td scope="row"><pre>exit:<span></span></pre></td></tr><tr><td scope="row"><pre>    if (alias) DisposeHandle((Handle)alias);<span></span></pre></td></tr><tr><td scope="row"><pre>    return err;<span></span></pre></td></tr></table></div>

<p>In this example, the default data reference is not defined when <code><a href="../../../../Reference/QTRef_TrackAndMedia/Reference/reference.html#//apple_ref/c/func/NewTrackMedia" target="_top">NewTrackMedia</a></code> is called. Instead, the default data reference is defined by the first call to <code><a href="../../../../Reference/QTRef_SequenceGrabber/Reference/reference.html#//apple_ref/c/func/SGAddOutputDataRefToMedia" target="_top">SGAddOutputDataRefToMedia</a></code>. This approach provides added flexibility by allowing movies to be captured to data handlers other than the standard file system data handler.</p>





        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../E-Chapter/5SequenceGrabberPane.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../G-Chapter/7UsingSequenceGrabbe.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2005, 2007 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2007-01-08<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/QuickTime/RM/CreatingMovies/MTCreateMovies/F-Chapter/6SequenceGrabberChan.html%3Fid%3DTP40000906-3.1&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/QuickTime/RM/CreatingMovies/MTCreateMovies/F-Chapter/6SequenceGrabberChan.html%3Fid%3DTP40000906-3.1&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/QuickTime/RM/CreatingMovies/MTCreateMovies/F-Chapter/6SequenceGrabberChan.html%3Fid%3DTP40000906-3.1&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>