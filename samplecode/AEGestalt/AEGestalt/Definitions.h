// 	Definitions.h// 	Copyright ©1992 Apple Computer, Inc.//	Kent Sandvik DTS//	This file contains debugger macros//	Version Info (latest first):////	<1>		khs		1.0		First final version#ifndef __DEFINITIONS__#define __DEFINITIONS__#ifndef __TYPES__#include <Types.h>#endif/* 	DEBUGGER FLAGS  MacApp 3.0 has many special flags which could be turned on/off from the  debug menu entry. We are mostly interested in signalling something from  the application to the source code, so we are interested to use:  gIntenseDebugging - turn on intense debugging, it will also signal to the  framework to start tracing many other things, so it's very costly.  gUserFlag1, gUserFlag2, gUserFlag3 - these are better suited for special control  that we know about. In this case we are using gUserFlag1.  WHY DON'T YOU USE MACROS, INSTEAD INLINE FUNCTIONS?  Because I'm sick-n-tired of tracing macro based problems. It should not matter,  we are still inlining code directly instead of calling functions. Also, then  I'm able to use static variables for certain 'macros' which should only do something  based on earlier state.  TMON USE  These macros are defined for MacsBug, i.e. they start with a ';' in the beginning  of the string. If you want to use TMON, change the ';' to a 'ª' and also change the debugger  statement to something suitable in the TMON world. BTW, these macros are based on  MacsBug 6.2.2.*///	GlobalsBoolean gHeapScramble = FALSE;					// heap scramblingBoolean gLeaks = FALSE;							// if Leaks DCMD is installed, test for memory leaksinline void DBOUTPUT(CStr255 a)					//	Call debugger with a string - used for other macros.{	if (gUserFlag1)		DebugStr(a);}inline void DBHEAPCHECK()						//	Heap Check - check for heap status, it stops if something is wrong{	DBOUTPUT(";HC; G");}inline void DBHEAPCHECKLOG()					//	Heap Check variation - log information inside a log file{	DBOUTPUT("Extended Heap Check:; LOG HeapTest; WH; HC; HZ; LOG; G");}inline void DBHEAPSCRAMBLEON()					//	Turn on Heap Scramble{	if (!gHeapScramble)	{		DBOUTPUT("Heap Scramble ON; HS; G");		gHeapScramble = TRUE;	}}inline void DBHEAPSCRAMBLEOFF()					//	Turn off Heap Scramble{	if (gHeapScramble)	{		DBOUTPUT("Heap Scramble OFF; HS; G");		gHeapScramble = FALSE;	}}inline void DBHEAPINFOLOG()						//	Log Heap information into log{	DBOUTPUT("Heap Info:; LOG HeapInfo; WH; HT; HD RS; LOG; G");}inline void DBEVENTRECORDLOG()					// Log Event Records at particular instances{	DBOUTPUT("Event Record:; LOG EventRecordLog; WH; DM 000234C4 EventRecord; LOG; G");}inline void DBLEAKSON()							//	Turn on Leaks dcmd (assume we have it installed, if not it's on Developer CD){	if (!gLeaks)	{		DBOUTPUT("Leaks ON; Leaks On; G");		gLeaks = TRUE;	}}inline void DBLEAKSOFF()						//	Turn off Leaks dcmd{	if (gLeaks)	{		DBOUTPUT("Leaks OFF; Leaks Off; G");		gLeaks = FALSE;	}}//  I think you got the idea now, feel free to create any other MacsBug/low level debugger//	commands which could be used from debug mode (or actually any other Macintosh source code//	which could set a flag dynamically from the Debugger menu).#endif