/*	File:		Color Picker.c	Contains:	This application demonstrates how to use the color						picker package to dynamically change colors in a						custom palette.  The program basically displays 16						squares, each representing a separate entry in the						palette.  Clicking the mouse in any box allows the						user to redefine that box's color with the color						picker package routines.  The trap ActivatePalette						is called after each color change to guarantee the						window is updated with the palette changes.  Without				this safeguard, random results may occur and the						color change may not take affect until the window						has physically changed or moved.  Finally, the first					and last entries in the palette cannot be changed						and are always defined to black and white.  This is						done because ActivatePalette will only update 14						non-b/w Tolerant colors.  The remaining 2 colors						if defined as b/w will be updated, otherwise QD will					return the color in the palette which is the closest					match to the RGB values of these entries.					Written by: EL		Copyright:	Copyright © 1991-1999 by Apple Computer, Inc., All Rights Reserved.				You may incorporate this Apple sample source code into your program(s) without				restriction. This Apple sample source code has been provided "AS IS" and the				responsibility for its operation is yours. You are not permitted to redistribute				this Apple sample source code as "Apple sample source code" after having made				changes. If you're going to re-distribute the source, we require that you make				it clear in the source that the code was descended from Apple sample source				code, but that you've made changes.	Change History (most recent first):				08/2000		JM				Carbonized, non-Carbon code is commented out											for demonstration purposes.				7/8/1999	KG				Updated for Metrowerks Codewarror Pro 2.1				*/#include "CarbonPrefix.h"#include <AppleEvents.h>#include <Errors.h>#include <Events.h>#include <Fonts.h>//#include <GestaltEqu.h>#include <Gestalt.h>#include <Memory.h>#include <Menus.h>#include <OSUtils.h>#include <QDOffscreen.h>#include <QuickDraw.h>#include <Resources.h>#include <Script.h>#include <ToolUtils.h>#include <Windows.h>#include <Palettes.h>#include <TextEdit.h>#include <Dialogs.h>#include <ColorPicker.h>#include <Sound.h>/* Constant Declarations */#define	TOTALCOLORS	16#define	BOXSIZE		75#define	WWIDTH		((TOTALCOLORS / 4) * BOXSIZE)#define	WHEIGHT		((TOTALCOLORS / 4) * BOXSIZE )//#define WLEFT		(((qd.screenBits.bounds.right - qd.screenBits.bounds.left) - WWIDTH) / 2)//#define WTOP		(((qd.screenBits.bounds.bottom - qd.screenBits.bounds.top) - WHEIGHT) / 2)/* Global Variable Definitions */WindowPtr			gWindow;PaletteHandle		gPalette;void initMac();void createWindow();void createPalette();void drawImage();void doEventLoop();void doInContent();void main(void){	initMac();		createWindow();	createPalette();	drawImage();	doEventLoop();	DisposeWindow( gWindow );}void initMac(){	//MaxApplZone();	//InitGraf( &qd.thePort );	//InitFonts();	//InitWindows();	//InitMenus();	//TEInit();	//InitDialogs( nil );	InitCursor();	FlushEvents( 0, everyEvent );}void createWindow(){	Rect wBounds;	int left, top;	BitMap	tempBitMap;		GetQDGlobalsScreenBits(&tempBitMap);		left = (((tempBitMap.bounds.right - tempBitMap.bounds.left) - WWIDTH) / 2);	top = (((tempBitMap.bounds.bottom - tempBitMap.bounds.top) - WWIDTH) / 2);		/* Create a window to display the image. */		//SetRect( &wBounds, WLEFT, WTOP, WLEFT + WWIDTH, WTOP + WHEIGHT );	SetRect( &wBounds, left, top, left + WWIDTH, top + WHEIGHT );		gWindow = NewCWindow( 0L, &wBounds, "\pColor Picker Test", true, documentProc,							(WindowPtr)-1L, true, 0L );								ShowWindow( gWindow );	//SetPort( gWindow );	SetPortWindowPort( gWindow );}void createPalette(){	int	index;	RGBColor aColor;	/* Create the palette of size TOTALCOLORS. */		gPalette = NewPalette( TOTALCOLORS, nil, pmTolerant, 0 );		/* Assign a color to the first 15 palette entries. */	for (index = 0; index < (TOTALCOLORS - 1); index++)	{		aColor.blue = index * (0xffff / (TOTALCOLORS - 2));		aColor.red = aColor.green = 0;		SetEntryColor( gPalette, index, &aColor );	}		/* Set the last entry to white. */		aColor.red = aColor.green = aColor.blue = 0xffff;	SetEntryColor( gPalette, (TOTALCOLORS - 1), &aColor );	/* Attach the new palette to the main window. */		SetPalette( gWindow, gPalette, true );}void drawImage(){	int			i;	int			x, y;	Rect		rect;	RGBColor	aColor;	/* Draw a grid of colors to represent each color entry in the palette. */	for (i = 0; i < TOTALCOLORS; i++)	{		x = (i % 4) * BOXSIZE;		y = (i / 4) * BOXSIZE;				GetEntryColor( gPalette, i, &aColor );		RGBForeColor( &aColor );				SetRect( &rect, x, y, x + BOXSIZE, y + BOXSIZE );		PaintRect( &rect );	}}void doInContent( thePoint )Point thePoint;{	int			paletteIndex = -1;	Point		where;	RGBColor	currentColor, newColor;	Rect		rect;	/* Get the palette entry index for the box drawn at the mouse click. */		paletteIndex = ((thePoint.v / BOXSIZE) * 4) + (thePoint.h / BOXSIZE);		/* If the paletteIndex isn't the first or last entry, do the following. */	if (paletteIndex > 0 && paletteIndex < (TOTALCOLORS - 1))	{		/* Invert the selected box then beep the Mac. */			SetRect( &rect, (paletteIndex % 4) * BOXSIZE,					(paletteIndex / 4) * BOXSIZE,					((paletteIndex % 4) * BOXSIZE) + BOXSIZE,					((paletteIndex / 4) * BOXSIZE) + BOXSIZE );		InvertRect( &rect );		SysBeep( 1 );			/* Get the RGB values for the color stored at this palette index. */				GetEntryColor( gPalette, paletteIndex, &currentColor );				/* Open the color picker dialog to select new RGB values. */				where.h = where.v = -1;		if (GetColor( where, "\pSelect a new palette color.", &currentColor, &newColor ))		{			/* Assign the new RGB values to this entry. */						SetEntryColor( gPalette, paletteIndex, &newColor );						/* Update the palette with the new colors. */						ActivatePalette( gWindow );						/* Redraw the image with the new palette colors. */					drawImage();		}		else		{			/* Invert the rect back to its original state on a Cancel. */						InvertRect( &rect );		}	}}void doEventLoop(){	EventRecord anEvent;	WindowPtr   evtWind;	short       clickArea;	Rect        screenRect;	Point		thePoint;	for (;;)	{		if (WaitNextEvent( everyEvent, &anEvent, 0, nil ))		{			if (anEvent.what == mouseDown)			{				clickArea = FindWindow( anEvent.where, &evtWind );								if (clickArea == inDrag)				{					//screenRect = (**GetGrayRgn ()).rgnBBox;					GetRegionBounds( GetGrayRgn(), &screenRect );					DragWindow( evtWind, anEvent.where, &screenRect );				}				else if (clickArea == inContent)				{					if (evtWind != FrontWindow())						SelectWindow( evtWind );					else					{						thePoint = anEvent.where;						GlobalToLocal( &thePoint );						doInContent( thePoint );					}				}				else if (clickArea == inGoAway)					if (TrackGoAway( evtWind, anEvent.where ))						return;			}			else if (anEvent.what == updateEvt)			{				evtWind = (WindowPtr)anEvent.message;					//SetPort( evtWind );				SetPortWindowPort( evtWind );								BeginUpdate( evtWind );				drawImage();				EndUpdate (evtWind);			}		}	}}