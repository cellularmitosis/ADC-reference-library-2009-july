<html><head><title>Mac OS X
 Manual Page For CGI(3pm)</title>
<style type="text/css"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { font-size: 1px; background: #ffffff; color: #ffffff; } --></style>
<style type="text/css" media="print, aural, braille, embossed, projection, tty"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { display: none; } --></style>
</head><body bgcolor="white">
<a name="//apple_ref/doc/man/3pm/CGI" title="Mac OS X
 Manual Page for CGI(3pm)"><a name="//apple_ref/doc/man/3/CGI" title="Mac OS X
 Manual Page for CGI(3pm)"><!-- headerDoc=man; indexgroup=Section 3pm; uid="//apple_ref/doc/man/3pm/CGI"; name=CGI(3pm) --></a>
<!--#include virtual="/includes/framesetheader"-->
<table width=600><tr><td scope="row">
<!-- begin breadcrumb insert request --><font face="Geneva,Helvetica,Arial" size="1">
 <a target="_top" href="http://developer.apple.com">ADC Home</a> <b>&gt;</b> <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> <b>&gt;</b> <a href="../../../../../reference/index.html#//apple_ref/doc/uid/TP30001281" target="_top">Reference</a> <b>&gt;</b> <!-- a href="" target="_top" -->Mac OS X<!-- /a --> <b>&gt;</b> <a href="../index.html#//apple_ref/doc/framework/manpages" target="_top">Mac OS X Man Pages</a></font>
<!-- end breadcrumb insert request -->
<p>&nbsp;</p>
</td></tr></table>
<!-- end of header -->
<table border="0"  cellpadding="2" cellspacing="2" width="630pt"><tr><td valign="top" height="12" colspan="5" scope="row">
<p style='text-align:justify;'>This document is a Mac OS X manual page.  Manual pages are a command-line technology
for providing documentation.  You can view these manual pages locally using the
<a href="../man1/man.1.html#//apple_ref/doc/man/1/man">man(1)</a> command.
These manual pages come from many different sources, and thus, have a variety of writing
styles.</p>
<p style='text-align:justify;'>For more information about the manual page format, see the manual page for 
<a href="../man5/manpages.5.html#//apple_ref/doc/man/5/manpages">manpages(5)</a>.</p>
</td></tr></table>
<hr />
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row"><pre class="manpages"><tt>
CGI(3pm)                              Perl Programmers Reference Guide                              CGI(3pm)



<b>NAME</b>
       CGI - Simple Common Gateway Interface Class

<b>SYNOPSIS</b>
         # CGI script that creates a fill-out form
         # and echoes back its values.

         use CGI qw/:standard/;
         print header,
               start_html('A Simple Example'),
               h1('A Simple Example'),
               start_form,
               "What's your name? ",textfield('name'),p,
               "What's the combination?", p,
               checkbox_group(-name=&gt;'words',
                              -values=&gt;['eenie','meenie','minie','moe'],
                              -defaults=&gt;['eenie','minie']), p,
               "What's your favorite color? ",
               popup_menu(-name=&gt;'color',
                          -values=&gt;['red','green','blue','chartreuse']),p,
               submit,
               end_form,
               hr;

          if (param()) {
              my $name      = param('name');
              my $keywords  = join ', ',param('words');
              my $color     = param('color');
              print "Your name is",em(escapeHTML($name)),p,
                    "The keywords are: ",em(escapeHTML($keywords)),p,
                    "Your favorite color is ",em(escapeHTML($color)),
                    hr;
          }

<b>ABSTRACT</b>
       This perl library uses perl5 objects to make it easy to create Web fill-out forms and parse their
       contents.  This package defines CGI objects, entities that contain the values of the current query
       string and other state variables.  Using a CGI object's methods, you can examine keywords and parame-<font color="#ffffff" class="whiteout">ters&nbsp;parameters</font>
       ters passed to your script, and create forms whose initial values are taken from the current query
       (thereby preserving state information).  The module provides shortcut functions that produce boiler-<font color="#ffffff" class="whiteout">plate&nbsp;boilerplate</font>
       plate HTML, reducing typing and coding errors. It also provides functionality for some of the more
       advanced features of CGI scripting, including support for file uploads, cookies, cascading style
       sheets, server push, and frames.

       CGI.pm also provides a simple function-oriented programming style for those who don't need its
       object-oriented features.

       The current version of CGI.pm is available at

         <a href="http://www.genome.wi.mit.edu/ftp/pub/software/WWW/cgi_docs.html">http://www.genome.wi.mit.edu/ftp/pub/software/WWW/cgi_docs.html</a>
         <a href="ftp://ftp-genome.wi.mit.edu/pub/software/WWW/">ftp://ftp-genome.wi.mit.edu/pub/software/WWW/</a>

<b>DESCRIPTION</b>
       <b>PROGRAMMING</b> <b>STYLE</b>

       There are two styles of programming with CGI.pm, an object-oriented style and a function-oriented
       style.  In the object-oriented style you create one or more CGI objects and then use object methods
       to create the various elements of the page.  Each CGI object starts out with the list of named param-
       eters that were passed to your CGI script by the server.  You can modify the objects, save them to a
       file or database and recreate them.  Because each object corresponds to the "state" of the CGI
       script, and because each object's parameter list is independent of the others, this allows you to
       save the state of the script and restore it later.

       For example, using the object oriented style, here is how you create a simple "Hello World" HTML
       page:

          #!/usr/local/bin/perl -w
          use CGI;                             # load CGI routines
          $q = new CGI;                        # create new CGI object
          print $q-&gt;header,                    # create the HTTP header
                $q-&gt;start_html('hello world'), # start the HTML
                $q-&gt;h1('hello world'),         # level 1 header
                $q-&gt;end_html;                  # end the HTML

       In the function-oriented style, there is one default CGI object that you rarely deal with directly.
       Instead you just call functions to retrieve CGI parameters, create HTML tags, manage cookies, and so
       on.  This provides you with a cleaner programming interface, but limits you to using one CGI object
       at a time.  The following example prints the same page, but uses the function-oriented interface.
       The main differences are that we now need to import a set of functions into our name space (usually
       the "standard" functions), and we don't need to create the CGI object.

          #!/usr/local/bin/perl
          use CGI qw/:standard/;           # load standard CGI routines
          print header,                    # create the HTTP header
                start_html('hello world'), # start the HTML
                h1('hello world'),         # level 1 header
                end_html;                  # end the HTML

       The examples in this document mainly use the object-oriented style.  See HOW TO IMPORT FUNCTIONS for
       important information on function-oriented programming in CGI.pm

       <b>CALLING</b> <b>CGI.PM</b> <b>ROUTINES</b>

       Most CGI.pm routines accept several arguments, sometimes as many as 20 optional ones!  To simplify
       this interface, all routines use a named argument calling style that looks like this:

          print $q-&gt;header(-type=&gt;'image/gif',-expires=&gt;'+3d');

       Each argument name is preceded by a dash.  Neither case nor order matters in the argument list.
       -type, -Type, and -TYPE are all acceptable.  In fact, only the first argument needs to begin with a
       dash.  If a dash is present in the first argument, CGI.pm assumes dashes for the subsequent ones.

       Several routines are commonly called with just one argument.  In the case of these routines you can
       provide the single argument without an argument name.  <u>header()</u> happens to be one of these routines.
       In this case, the single argument is the document type.

          print $q-&gt;header('text/html');

       Other such routines are documented below.

       Sometimes named arguments expect a scalar, sometimes a reference to an array, and sometimes a refer-
       ence to a hash.  Often, you can pass any type of argument and the routine will do whatever is most
       appropriate.  For example, the <u>param()</u> routine is used to set a CGI parameter to a single or a multi-
       valued value.  The two cases are shown below:

          $q-&gt;param(-name=&gt;'veggie',-value=&gt;'tomato');
          $q-&gt;param(-name=&gt;'veggie',-value=&gt;['tomato','tomahto','potato','potahto']);

       A large number of routines in CGI.pm actually aren't specifically defined in the module, but are gen-
       erated automatically as needed.  These are the "HTML shortcuts," routines that generate HTML tags for
       use in dynamically-generated pages.  HTML tags have both attributes (the attribute="value" pairs
       within the tag itself) and contents (the part between the opening and closing pairs.)  To distinguish
       between attributes and contents, CGI.pm uses the convention of passing HTML attributes as a hash ref-
       erence as the first argument, and the contents, if any, as any subsequent arguments.  It works out
       like this:

          Code                           Generated HTML
          ----                           --------------
          h1()                           &lt;h1&gt;
          h1('some','contents');         &lt;h1&gt;some contents&lt;/h1&gt;
          h1({-align=&gt;left});            &lt;h1 align="LEFT"&gt;
          h1({-align=&gt;left},'contents'); &lt;h1 align="LEFT"&gt;contents&lt;/h1&gt;

       HTML tags are described in more detail later.

       Many newcomers to CGI.pm are puzzled by the difference between the calling conventions for the HTML
       shortcuts, which require curly braces around the HTML tag attributes, and the calling conventions for
       other routines, which manage to generate attributes without the curly brackets.  Don't be confused.
       As a convenience the curly braces are optional in all but the HTML shortcuts.  If you like, you can
       use curly braces when calling any routine that takes named arguments.  For example:

          print $q-&gt;header( {-type=&gt;'image/gif',-expires=&gt;'+3d'} );

       If you use the <b>-w</b> switch, you will be warned that some CGI.pm argument names conflict with built-in
       Perl functions.  The most frequent of these is the -values argument, used to create multi-valued
       menus, radio button clusters and the like.  To get around this warning, you have several choices:

       1.  Use another name for the argument, if one is available.  For example, -value is an alias for
           -values.

       2.  Change the capitalization, e.g. -Values

       3.  Put quotes around the argument name, e.g. '-values'

       Many routines will do something useful with a named argument that it doesn't recognize.  For example,
       you can produce non-standard HTTP header fields by providing them as named arguments:

         print $q-&gt;header(-type  =&gt;  'text/html',
                          -cost  =&gt;  'Three smackers',
                          -annoyance_level =&gt; 'high',
                          -complaints_to   =&gt; 'bit bucket');

       This will produce the following nonstandard HTTP header:

          HTTP/1.0 200 OK
          Cost: Three smackers
          Annoyance-level: high
          Complaints-to: bit bucket
          Content-type: text/html

       Notice the way that underscores are translated automatically into hyphens.  HTML-generating routines
       perform a different type of translation.

       This feature allows you to keep up with the rapidly changing HTTP and HTML "standards".

       <b>CREATING</b> <b>A</b> <b>NEW</b> <b>QUERY</b> <b>OBJECT</b> <b>(OBJECT-ORIENTED</b> <b>STYLE):</b>

            $query = new CGI;

       This will parse the input (from both POST and GET methods) and store it into a perl5 object called
       $query.

       <b>CREATING</b> <b>A</b> <b>NEW</b> <b>QUERY</b> <b>OBJECT</b> <b>FROM</b> <b>AN</b> <b>INPUT</b> <b>FILE</b>

            $query = new CGI(INPUTFILE);

       If you provide a file handle to the <u>new()</u> method, it will read parameters from the file (or STDIN, or
       whatever).  The file can be in any of the forms describing below under debugging (i.e. a series of
       newline delimited TAG=VALUE pairs will work).  Conveniently, this type of file is created by the
       <u>save()</u> method (see below).  Multiple records can be saved and restored.

       Perl purists will be pleased to know that this syntax accepts references to file handles, or even
       references to filehandle globs, which is the "official" way to pass a filehandle:

           $query = new CGI(\*STDIN);

       You can also initialize the CGI object with a FileHandle or IO::File object.

       If you are using the function-oriented interface and want to initialize CGI state from a file handle,
       the way to do this is with <u></u><b><u>r</u></b><u></u><b><u>s</u></b><u></u><b><u>o</u></b><u></u><b><u>e</u></b><b>_</b><u></u><b><u>p</u></b><u></u><b><u>r</u></b><u></u><b><u>m</u></b><u></u><b><u>t</u></b><u></u><b><u>r</u></b><u></u><b><u>(</u></b>.  This will (re)initialize the default CGI object
       from the indicated file handle.

           open (IN,"test.in") || die;
           restore_parameters(IN);
           close IN;

       You can also initialize the query object from an associative array reference:

           $query = new CGI( {'dinosaur'=&gt;'barney',
                              'song'=&gt;'I love you',
                              'friends'=&gt;[qw/Jessica George Nancy/]}
                           );

       or from a properly formatted, URL-escaped query string:

           $query = new CGI('dinosaur=barney&amp;color=purple');

       or from a previously existing CGI object (currently this clones the parameter list, but none of the
       other object-specific fields, such as autoescaping):

           $old_query = new CGI;
           $new_query = new CGI($old_query);

       To create an empty query, initialize it from an empty string or hash:

          $empty_query = new CGI("");

              -or-

          $empty_query = new CGI({});

       <b>FETCHING</b> <b>A</b> <b>LIST</b> <b>OF</b> <b>KEYWORDS</b> <b>FROM</b> <b>THE</b> <b>QUERY:</b>

            @keywords = $query-&gt;keywords

       If the script was invoked as the result of an &lt;ISINDEX&gt; search, the parsed keywords can be obtained
       as an array using the <u>keywords()</u> method.

       <b>FETCHING</b> <b>THE</b> <b>NAMES</b> <b>OF</b> <b>ALL</b> <b>THE</b> <b>PARAMETERS</b> <b>PASSED</b> <b>TO</b> <b>YOUR</b> <b>SCRIPT:</b>

            @names = $query-&gt;param

       If the script was invoked with a parameter list (e.g. "name1=value1&amp;name2=value2&amp;name3=value3"), the
       <u>param()</u> method will return the parameter names as a list.  If the script was invoked as an &lt;ISINDEX&gt;
       script and contains a string without ampersands (e.g. "value1+value2+value3") , there will be a sin-
       gle parameter named "keywords" containing the "+"-delimited keywords.

       NOTE: As of version 1.5, the array of parameter names returned will be in the same order as they were
       submitted by the browser.  Usually this order is the same as the order in which the parameters are
       defined in the form (however, this isn't part of the spec, and so isn't guaranteed).

       <b>FETCHING</b> <b>THE</b> <b>VALUE</b> <b>OR</b> <b>VALUES</b> <b>OF</b> <b>A</b> <b>SINGLE</b> <b>NAMED</b> <b>PARAMETER:</b>

           @values = $query-&gt;param('foo');

                     -or-

           $value = $query-&gt;param('foo');

       Pass the <u>param()</u> method a single argument to fetch the value of the named parameter. If the parameter
       is multivalued (e.g. from multiple selections in a scrolling list), you can ask to receive an array.
       Otherwise the method will return a single value.

       If a value is not given in the query string, as in the queries "name1=&amp;name2=" or "name1&amp;name2", it
       will be returned as an empty string.  This feature is new in 2.63.

       If the parameter does not exist at all, then <u>param()</u> will return undef in a scalar context, and the
       empty list in a list context.

       <b>SETTING</b> <b>THE</b> <!-- a --><b>VALUE(S)</b><!-- /a --><b></b> <b>OF</b> <b>A</b> <b>NAMED</b> <b>PARAMETER:</b>

           $query-&gt;param('foo','an','array','of','values');

       This sets the value for the named parameter 'foo' to an array of values.  This is one way to change
       the value of a field AFTER the script has been invoked once before.  (Another way is with the -over-
       ride parameter accepted by all methods that generate form elements.)

       <u>param()</u> also recognizes a named parameter style of calling described in more detail later:

           $query-&gt;param(-name=&gt;'foo',-values=&gt;['an','array','of','values']);

                                     -or-

           $query-&gt;param(-name=&gt;'foo',-value=&gt;'the value');

       <b>APPENDING</b> <b>ADDITIONAL</b> <b>VALUES</b> <b>TO</b> <b>A</b> <b>NAMED</b> <b>PARAMETER:</b>

          $query-&gt;append(-name=&gt;'foo',-values=&gt;['yet','more','values']);

       This adds a value or list of values to the named parameter.  The values are appended to the end of
       the parameter if it already exists.  Otherwise the parameter is created.  Note that this method only
       recognizes the named argument calling syntax.

       <b>IMPORTING</b> <b>ALL</b> <b>PARAMETERS</b> <b>INTO</b> <b>A</b> <b>NAMESPACE:</b>

          $query-&gt;import_names('R');

       This creates a series of variables in the 'R' namespace.  For example, $R::foo, @R:foo.  For keyword
       lists, a variable @R::keywords will appear.  If no namespace is given, this method will assume 'Q'.
       WARNING:  don't import anything into 'main'; this is a major security risk!!!!

       NOTE 1: Variable names are transformed as necessary into legal Perl variable names.  All non-legal
       characters are transformed into underscores.  If you need to keep the original names, you should use
       the <u>param()</u> method instead to access CGI variables by name.

       NOTE 2: In older versions, this method was called <u></u><b><u>i</u></b><u></u><b><u>p</u></b><u></u><b><u>r</u></b><u></u><b><u>(</u></b>.  As of version 2.20, this name has been
       removed completely to avoid conflict with the built-in Perl module <b>import</b> operator.

       <b>DELETING</b> <b>A</b> <b>PARAMETER</b> <b>COMPLETELY:</b>

           $query-&gt;delete('foo','bar','baz');

       This completely clears a list of parameters.  It sometimes useful for resetting parameters that you
       don't want passed down between script invocations.

       If you are using the function call interface, use "<u>Delete()</u>" instead to avoid conflicts with Perl's
       built-in delete operator.

       <b>DELETING</b> <b>ALL</b> <b>PARAMETERS:</b>

          $query-&gt;delete_all();

       This clears the CGI object completely.  It might be useful to ensure that all the defaults are taken
       when you create a fill-out form.

       Use <u>Delete</u><b>_</b><u>all()</u> instead if you are using the function call interface.

       <b>HANDLING</b> <b>NON-URLENCODED</b> <b>ARGUMENTS</b>

       If POSTed data is not of type application/x-www-form-urlencoded or multipart/form-data, then the
       POSTed data will not be processed, but instead be returned as-is in a parameter named POSTDATA.  To
       retrieve it, use code like this:

          my $data = $query-&gt;param('POSTDATA');

       (If you don't know what the preceding means, don't worry about it.  It only affects people trying to
       use CGI for XML processing and other specialized tasks.)

       <b>DIRECT</b> <b>ACCESS</b> <b>TO</b> <b>THE</b> <b>PARAMETER</b> <b>LIST:</b>

          $q-&gt;param_fetch('address')-&gt;[1] = '1313 Mockingbird Lane';
          unshift @{$q-&gt;param_fetch(-name=&gt;'address')},'George Munster';

       If you need access to the parameter list in a way that isn't covered by the methods above, you can
       obtain a direct reference to it by calling the <u></u><b><u>p</u></b><u></u><b><u>r</u></b><u></u><b><u>m</u></b><b>_</b><u></u><b><u>f</u></b><u></u><b><u>t</u></b><u></u><b><u>h</u></b><u></u><b><u>)</u></b> method with the name of the .  This will
       return an array reference to the named parameters, which you then can manipulate in any way you like.

       You can also use a named argument style using the <b>-name</b> argument.

       <b>FETCHING</b> <b>THE</b> <b>PARAMETER</b> <b>LIST</b> <b>AS</b> <b>A</b> <b>HASH:</b>

           $params = $q-&gt;Vars;
           print $params-&gt;{'address'};
           @foo = split("\0",$params-&gt;{'foo'});
           %params = $q-&gt;Vars;

           use CGI ':cgi-lib';
           $params = Vars;

       Many people want to fetch the entire parameter list as a hash in which the keys are the names of the
       CGI parameters, and the values are the parameters' values.  The <u>Vars()</u> method does this.  Called in a
       scalar context, it returns the parameter list as a tied hash reference.  Changing a key changes the
       value of the parameter in the underlying CGI parameter list.  Called in a list context, it returns
       the parameter list as an ordinary hash.  This allows you to read the contents of the parameter list,
       but not to change it.

       When using this, the thing you must watch out for are multivalued CGI parameters.  Because a hash
       cannot distinguish between scalar and list context, multivalued parameters will be returned as a
       packed string, separated by the "\0" (null) character.  You must split this packed string in order to
       get at the individual values.  This is the convention introduced long ago by Steve Brenner in his
       cgi-lib.pl module for Perl version 4.

       If you wish to use <u>Vars()</u> as a function, import the <u>:cgi-lib</u> set of function calls (also see the sec-
       tion on CGI-LIB compatibility).

       <b>SAVING</b> <b>THE</b> <b>STATE</b> <b>OF</b> <b>THE</b> <b>SCRIPT</b> <b>TO</b> <b>A</b> <b>FILE:</b>

           $query-&gt;save(\*FILEHANDLE)

       This will write the current state of the form to the provided filehandle.  You can read it back in by
       providing a filehandle to the <u>new()</u> method.  Note that the filehandle can be a file, a pipe, or what-
       ever!

       The format of the saved file is:

               NAME1=VALUE1
               NAME1=VALUE1'
               NAME2=VALUE2
               NAME3=VALUE3
               =

       Both name and value are URL escaped.  Multi-valued CGI parameters are represented as repeated names.
       A session record is delimited by a single = symbol.  You can write out multiple records and read them
       back in with several calls to <b>new</b>.  You can do this across several sessions by opening the file in
       append mode, allowing you to create primitive guest books, or to keep a history of users' queries.
       Here's a short example of creating multiple session records:

          use CGI;

          open (OUT,"&gt;&gt;test.out") || die;
          $records = 5;
          foreach (0..$records) {
              my $q = new CGI;
              $q-&gt;param(-name=&gt;'counter',-value=&gt;$_);
              $q-&gt;save(\*OUT);
          }
          close OUT;

          # reopen for reading
          open (IN,"test.out") || die;
          while (!eof(IN)) {
              my $q = new CGI(\*IN);
              print $q-&gt;param('counter'),"\n";
          }

       The file format used for save/restore is identical to that used by the Whitehead Genome Center's data
       exchange format "Boulderio", and can be manipulated and even databased using Boulderio utilities.
       See

         <a href="http://stein.cshl.org/boulder/">http://stein.cshl.org/boulder/</a>

       for further details.

       If you wish to use this method from the function-oriented (non-OO) interface, the exported name for
       this method is <u></u><b><u>s</u></b><u></u><b><u>v</u></b><b>_</b><u></u><b><u>p</u></b><u></u><b><u>r</u></b><u></u><b><u>m</u></b><u></u><b><u>t</u></b><u></u><b><u>r</u></b><u></u><b><u>(</u></b>.

       <b>RETRIEVING</b> <b>CGI</b> <b>ERRORS</b>

       Errors can occur while processing user input, particularly when processing uploaded files.  When
       these errors occur, CGI will stop processing and return an empty parameter list.  You can test for
       the existence and nature of errors using the <u>cgi</u><b>_</b><u>error()</u> function.  The error messages are formatted
       as HTTP status codes. You can either incorporate the error text into an HTML page, or use it as the
       value of the HTTP status:

           my $error = $q-&gt;cgi_error;
           if ($error) {
               print $q-&gt;header(-status=&gt;$error),
                     $q-&gt;start_html('Problems'),
                     $q-&gt;h2('Request not processed'),
                     $q-&gt;strong($error);
               exit 0;
           }

       When using the function-oriented interface (see the next section), errors may only occur the first
       time you call <u>param()</u>. Be ready for this!

       <b>USING</b> <b>THE</b> <b>FUNCTION-ORIENTED</b> <b>INTERFACE</b>

       To use the function-oriented interface, you must specify which CGI.pm routines or sets of routines to
       import into your script's namespace.  There is a small overhead associated with this importation, but
       it isn't much.

          use CGI &lt;list of methods&gt;;

       The listed methods will be imported into the current package; you can call them directly without cre-
       ating a CGI object first.  This example shows how to import the <u></u><b><u>p</u></b><u></u><b><u>r</u></b><u></u><b><u>m</u></b><u></u><b><u>)</u></b> and <u></u><b><u>h</u></b><u></u><b><u>a</u></b><u></u><b><u>e</u></b><u></u><b><u>(</u></b> methods, and
       then use them directly:

          use CGI 'param','header';
          print header('text/plain');
          $zipcode = param('zipcode');

       More frequently, you'll import common sets of functions by referring to the groups by name.  All
       function sets are preceded with a ":" character as in ":html3" (for tags defined in the HTML 3 stan-
       dard).

       Here is a list of the function sets you can import:

       <b>:cgi</b>
           Import all CGI-handling methods, such as <u></u><b><u>p</u></b><u></u><b><u>r</u></b><u></u><b><u>m</u></b><u></u><b><u>)</u></b>, <u></u><b><u>p</u></b><u></u><b><u>t</u></b><b>_</b><u></u><b><u>i</u></b><u></u><b><u>f</u></b><u></u><b><u>(</u></b> and the like.

       <b>:form</b>
           Import all fill-out form generating methods, such as <u></u><b><u>t</u></b><u></u><b><u>x</u></b><u></u><b><u>f</u></b><u></u><b><u>e</u></b><u></u><b><u>d</u></b><u></u><b><u>)</u></b>.

       <b>:html2</b>
           Import all methods that generate HTML 2.0 standard elements.

       <b>:html3</b>
           Import all methods that generate HTML 3.0 elements (such as &lt;table&gt;, &lt;super&gt; and &lt;sub&gt;).

       <b>:html4</b>
           Import all methods that generate HTML 4 elements (such as &lt;abbrev&gt;, &lt;acronym&gt; and &lt;thead&gt;).

       <b>:netscape</b>
           Import all methods that generate Netscape-specific HTML extensions.

       <b>:html</b>
           Import all HTML-generating shortcuts (i.e. 'html2' + 'html3' + 'netscape')...

       <b>:standard</b>
           Import "standard" features, 'html2', 'html3', 'html4', 'form' and 'cgi'.

       <b>:all</b>
           Import all the available methods.  For the full list, see the CGI.pm code, where the variable
           %EXPORT_TAGS is defined.

       If you import a function name that is not part of CGI.pm, the module will treat it as a new HTML tag
       and generate the appropriate subroutine.  You can then use it like any other HTML tag.  This is to
       provide for the rapidly-evolving HTML "standard."  For example, say Microsoft comes out with a new
       tag called &lt;gradient&gt; (which causes the user's desktop to be flooded with a rotating gradient fill
       until his machine reboots).  You don't need to wait for a new version of CGI.pm to start using it
       immediately:

          use CGI qw/:standard :html3 gradient/;
          print gradient({-start=&gt;'red',-end=&gt;'blue'});

       Note that in the interests of execution speed CGI.pm does <b>not</b> use the standard Exporter syntax for
       specifying load symbols.  This may change in the future.

       If you import any of the state-maintaining CGI or form-generating methods, a default CGI object will
       be created and initialized automatically the first time you use any of the methods that require one
       to be present.  This includes <u></u><b><u>p</u></b><u></u><b><u>r</u></b><u></u><b><u>m</u></b><u></u><b><u>)</u></b>, <u></u><b><u>t</u></b><u></u><b><u>x</u></b><u></u><b><u>f</u></b><u></u><b><u>e</u></b><u></u><b><u>d</u></b><u></u><b><u>)</u></b>, <u></u><b><u>s</u></b><u></u><b><u>b</u></b><u></u><b><u>i</u></b><u></u><b><u>(</u></b> and the like.  (If you need direct
       access to the CGI object, you can find it in the global variable <b>$CGI::Q</b>).  By importing CGI.pm meth-
       ods, you can create visually elegant scripts:

          use CGI qw/:standard/;
          print
              header,
              start_html('Simple Script'),
              h1('Simple Script'),
              start_form,
              "What's your name? ",textfield('name'),p,
              "What's the combination?",
              checkbox_group(-name=&gt;'words',
                             -values=&gt;['eenie','meenie','minie','moe'],
                             -defaults=&gt;['eenie','moe']),p,
              "What's your favorite color?",
              popup_menu(-name=&gt;'color',
                         -values=&gt;['red','green','blue','chartreuse']),p,
              submit,
              end_form,
              hr,"\n";

           if (param) {
              print
                  "Your name is ",em(param('name')),p,
                  "The keywords are: ",em(join(", ",param('words'))),p,
                  "Your favorite color is ",em(param('color')),".\n";
           }
           print end_html;

       <b>PRAGMAS</b>

       In addition to the function sets, there are a number of pragmas that you can import.  Pragmas, which
       are always preceded by a hyphen, change the way that CGI.pm functions in various ways.  Pragmas,
       function sets, and individual functions can all be imported in the same <u>use()</u> line.  For example, the
       following use statement imports the standard set of functions and enables debugging mode (pragma
       -debug):

          use CGI qw/:standard -debug/;

       The current list of pragmas is as follows:

       -any
           When you <u>use</u> <u>CGI</u> <u>-any</u>, then any method that the query object doesn't recognize will be inter-
           preted as a new HTML tag.  This allows you to support the next <u>ad</u> <u>hoc</u> Netscape or Microsoft HTML
           extension.  This lets you go wild with new and unsupported tags:

              use CGI qw(-any);
              $q=new CGI;
              print $q-&gt;gradient({speed=&gt;'fast',start=&gt;'red',end=&gt;'blue'});

           Since using &lt;cite&gt;any&lt;/cite&gt; causes any mistyped method name to be interpreted as an HTML tag,
           use it with care or not at all.

       -compile
           This causes the indicated autoloaded methods to be compiled up front, rather than deferred to
           later.  This is useful for scripts that run for an extended period of time under FastCGI or
           mod_perl, and for those destined to be crunched by Malcom Beattie's Perl compiler.  Use it in
           conjunction with the methods or method families you plan to use.

              use CGI qw(-compile :standard :html3);

           or even

              use CGI qw(-compile :all);

           Note that using the -compile pragma in this way will always have the effect of importing the com-
           piled functions into the current namespace.  If you want to compile without importing use the
           <u>compile()</u> method instead:

              use CGI();
              CGI-&gt;compile();

           This is particularly useful in a mod_perl environment, in which you might want to precompile all
           CGI routines in a startup script, and then import the functions individually in each mod_perl
           script.

       -nosticky
           By default the CGI module implements a state-preserving behavior called "sticky" fields.  The way
           this works is that if you are regenerating a form, the methods that generate the form field val-
           ues will interrogate <u>param()</u> to see if similarly-named parameters are present in the query
           string. If they find a like-named parameter, they will use it to set their default values.

           Sometimes this isn't what you want.  The <b>-nosticky</b> pragma prevents this behavior.  You can also
           selectively change the sticky behavior in each element that you generate.

       -tabindex
           Automatically add tab index attributes to each form field. With this option turned off, you can
           still add tab indexes manually by passing a -tabindex option to each field-generating method.

       -no_undef_params
           This keeps CGI.pm from including undef params in the parameter list.

       -no_xhtml
           By default, CGI.pm versions 2.69 and higher emit XHTML (<a href="http://www.w3.org/TR/xhtml1/)">http://www.w3.org/TR/xhtml1/)</a>  The
           -no_xhtml pragma disables this feature.  Thanks to Michalis Kabrianis &lt;kabrianis@hellug.gr&gt; for
           this feature.

           If <u>start</u><b>_</b><u>html()</u>'s -dtd parameter specifies an HTML 2.0 or 3.2 DTD, XHTML will automatically be
           disabled without needing to use this pragma.

       -nph
           This makes CGI.pm produce a header appropriate for an NPH (no parsed header) script.  You may
           need to do other things as well to tell the server that the script is NPH.  See the discussion of
           NPH scripts below.

       -newstyle_urls
           Separate the name=value pairs in CGI parameter query strings with semicolons rather than amper-
           sands.  For example:

              ?name=fred;age=24;favorite_color=3

           Semicolon-delimited query strings are always accepted, but will not be emitted by <u>self</u><b>_</b><u>url()</u> and
           <u>query</u><b>_</b><u>string()</u> unless the -newstyle_urls pragma is specified.

           This became the default in version 2.64.

       -oldstyle_urls
           Separate the name=value pairs in CGI parameter query strings with ampersands rather than semi-
           colons.  This is no longer the default.

       -autoload
           This overrides the autoloader so that any function in your program that is not recognized is
           referred to CGI.pm for possible evaluation.  This allows you to use all the CGI.pm functions
           without adding them to your symbol table, which is of concern for mod_perl users who are worried
           about memory consumption.  <u>Warning:</u> when <u>-autoload</u> is in effect, you cannot use "poetry mode"
           (functions without the parenthesis).  Use <u>hr()</u> rather than <u>hr</u>, or add something like <u>use</u> <u>subs</u>
           <u>qw/hr</u> <u>p</u> <u>header/</u> to the top of your script.

       -no_debug
           This turns off the command-line processing features.  If you want to run a CGI.pm script from the
           command line to produce HTML, and you don't want it to read CGI parameters from the command line
           or STDIN, then use this pragma:

              use CGI qw(-no_debug :standard);

       -debug
           This turns on full debugging.  In addition to reading CGI arguments from the command-line pro-
           cessing, CGI.pm will pause and try to read arguments from STDIN, producing the message "(offline
           mode: enter name=value pairs on standard input)" features.

           See the section on debugging for more details.

       -private_tempfiles
           CGI.pm can process uploaded file. Ordinarily it spools the uploaded file to a temporary direc-
           tory, then deletes the file when done.  However, this opens the risk of eavesdropping as
           described in the file upload section.  Another CGI script author could peek at this data during
           the upload, even if it is confidential information. On Unix systems, the -private_tempfiles
           pragma will cause the temporary file to be unlinked as soon as it is opened and before any data
           is written into it, reducing, but not eliminating the risk of eavesdropping (there is still a
           potential race condition).  To make life harder for the attacker, the program chooses tempfile
           names by calculating a 32 bit checksum of the incoming HTTP headers.

           To ensure that the temporary file cannot be read by other CGI scripts, use suEXEC or a CGI wrap-
           per program to run your script.  The temporary file is created with mode 0600 (neither world nor
           group readable).

           The temporary directory is selected using the following algorithm:

               1. if the current user (e.g. "nobody") has a directory named
               "tmp" in its home directory, use that (Unix systems only).

               2. if the environment variable TMPDIR exists, use the location
               indicated.

               3. Otherwise try the locations /usr/tmp, /var/tmp, C:\temp,
               /tmp, /temp, ::Temporary Items, and \WWW_ROOT.

           Each of these locations is checked that it is a directory and is writable.  If not, the algorithm
           tries the next choice.

       <b>SPECIAL</b> <b>FORMS</b> <b>FOR</b> <b>IMPORTING</b> <b>HTML-TAG</b> <b>FUNCTIONS</b>

       Many of the methods generate HTML tags.  As described below, tag functions automatically generate
       both the opening and closing tags.  For example:

         print h1('Level 1 Header');

       produces

         &lt;h1&gt;Level 1 Header&lt;/h1&gt;

       There will be some times when you want to produce the start and end tags yourself.  In this case, you
       can use the form start_<u>tag</u><b>_</b><u>name</u> and end_<u>tag</u><b>_</b><u>name</u>, as in:

         print start_h1,'Level 1 Header',end_h1;

       With a few exceptions (described below), start_<u>tag</u><b>_</b><u>name</u> and end_<u>tag</u><b>_</b><u>name</u> functions are not generated
       automatically when you <u>use</u> <u>CGI</u>.  However, you can specify the tags you want to generate <u>start/end</u>
       functions for by putting an asterisk in front of their name, or, alternatively, requesting either
       "start_<u>tag</u><b>_</b><u>name</u>" or "end_<u>tag</u><b>_</b><u>name</u>" in the import list.

       Example:

         use CGI qw/:standard *table start_ul/;

       In this example, the following functions are generated in addition to the standard ones:

       1. <u>start</u><b>_</b><u>table()</u> (generates a &lt;table&gt; tag)
       2. <u>end</u><b>_</b><u>table()</u> (generates a &lt;/table&gt; tag)
       3. <u>start</u><b>_</b><u>ul()</u> (generates a &lt;ul&gt; tag)
       4. <u>end</u><b>_</b><u>ul()</u> (generates a &lt;/ul&gt; tag)

<b>GENERATING</b> <b>DYNAMIC</b> <b>DOCUMENTS</b>
       Most of CGI.pm's functions deal with creating documents on the fly.  Generally you will produce the
       HTTP header first, followed by the document itself.  CGI.pm provides functions for generating HTTP
       headers of various types as well as for generating HTML.  For creating GIF images, see the GD.pm mod-
       ule.

       Each of these functions produces a fragment of HTML or HTTP which you can print out directly so that
       it displays in the browser window, append to a string, or save to a file for later use.

       <b>CREATING</b> <b>A</b> <b>STANDARD</b> <b>HTTP</b> <b>HEADER:</b>

       Normally the first thing you will do in any CGI script is print out an HTTP header.  This tells the
       browser what type of document to expect, and gives other optional information, such as the language,
       expiration date, and whether to cache the document.  The header can also be manipulated for special
       purposes, such as server push and pay per view pages.

               print header;

                    -or-

               print header('image/gif');

                    -or-

               print header('text/html','204 No response');

                    -or-

               print header(-type=&gt;'image/gif',
                                    -nph=&gt;1,
                                    -status=&gt;'402 Payment required',
                                    -expires=&gt;'+3d',
                                    -cookie=&gt;$cookie,
                                    -charset=&gt;'utf-7',
                                    -attachment=&gt;'foo.gif',
                                    -Cost=&gt;'$2.00');

       <u>header()</u> returns the Content-type: header.  You can provide your own MIME type if you choose, other-
       wise it defaults to text/html.  An optional second parameter specifies the status code and a human-
       readable message.  For example, you can specify 204, "No response" to create a script that tells the
       browser to do nothing at all.

       The last example shows the named argument style for passing arguments to the CGI methods using named
       parameters.  Recognized parameters are <b>-type</b>, <b>-status</b>, <b>-expires</b>, and <b>-cookie</b>.  Any other named param-
       eters will be stripped of their initial hyphens and turned into header fields, allowing you to spec-
       ify any HTTP header you desire.  Internal underscores will be turned into hyphens:

           print header(-Content_length=&gt;3002);

       Most browsers will not cache the output from CGI scripts.  Every time the browser reloads the page,
       the script is invoked anew.  You can change this behavior with the <b>-expires</b> parameter.  When you
       specify an absolute or relative expiration interval with this parameter, some browsers and proxy
       servers will cache the script's output until the indicated expiration date.  The following forms are
       all valid for the -expires field:

               +30s                              30 seconds from now
               +10m                              ten minutes from now
               +1h                               one hour from now
               -1d                               yesterday (i.e. "ASAP!")
               now                               immediately
               +3M                               in three months
               +10y                              in ten years time
               Thursday, 25-Apr-1999 00:40:33 GMT  at the indicated time &amp; date

       The <b>-cookie</b> parameter generates a header that tells the browser to provide a "magic cookie" during
       all subsequent transactions with your script.  Netscape cookies have a special format that includes
       interesting attributes such as expiration time.  Use the <u>cookie()</u> method to create and retrieve ses-
       sion cookies.

       The <b>-nph</b> parameter, if set to a true value, will issue the correct headers to work with a NPH
       (no-parse-header) script.  This is important to use with certain servers that expect all their
       scripts to be NPH.

       The <b>-charset</b> parameter can be used to control the character set sent to the browser.  If not pro-
       vided, defaults to ISO-8859-1.  As a side effect, this sets the <u>charset()</u> method as well.

       The <b>-attachment</b> parameter can be used to turn the page into an attachment.  Instead of displaying the
       page, some browsers will prompt the user to save it to disk.  The value of the argument is the sug-
       gested name for the saved file.  In order for this to work, you may have to set the <b>-type</b> to "appli-
       cation/octet-stream".

       The <b>-p3p</b> parameter will add a P3P tag to the outgoing header.  The parameter can be an arrayref or a
       space-delimited string of P3P tags.  For example:

          print header(-p3p=&gt;[qw(CAO DSP LAW CURa)]);
          print header(-p3p=&gt;'CAO DSP LAW CURa');

       In either case, the outgoing header will be formatted as:

         P3P: policyref="/w3c/p3p.xml" cp="CAO DSP LAW CURa"

       <b>GENERATING</b> <b>A</b> <b>REDIRECTION</b> <b>HEADER</b>

          print redirect('<a href="http://somewhere.else/in/movie/land">http://somewhere.else/in/movie/land</a>');

       Sometimes you don't want to produce a document yourself, but simply redirect the browser elsewhere,
       perhaps choosing a URL based on the time of day or the identity of the user.

       The <u>redirect()</u> function redirects the browser to a different URL.  If you use redirection like this,
       you should <b>not</b> print out a header as well.

       You should always use full URLs (including the http: or ftp: part) in redirection requests.  Relative
       URLs will not work correctly.

       You can also use named arguments:

           print redirect(-uri=&gt;'<a href="http://somewhere.else/in/movie/land">http://somewhere.else/in/movie/land</a>',
                                  -nph=&gt;1,
                                  -status=&gt;301);

       The <b>-nph</b> parameter, if set to a true value, will issue the correct headers to work with a NPH
       (no-parse-header) script.  This is important to use with certain servers, such as Microsoft IIS,
       which expect all their scripts to be NPH.

       The <b>-status</b> parameter will set the status of the redirect.  HTTP defines three different possible re-
       direction status codes:

            301 Moved Permanently
            302 Found
            303 See Other

       The default if not specified is 302, which means "moved temporarily."  You may change the status to
       another status code if you wish.  Be advised that changing the status to anything other than 301, 302
       or 303 will probably break redirection.

       <b>CREATING</b> <b>THE</b> <b>HTML</b> <b>DOCUMENT</b> <b>HEADER</b>

          print start_html(-title=&gt;'Secrets of the Pyramids',
                                   -author=&gt;'fred@capricorn.org',
                                   -base=&gt;'true',
                                   -target=&gt;'_blank',
                                   -meta=&gt;{'keywords'=&gt;'pharaoh secret mummy',
                                           'copyright'=&gt;'copyright 1996 King Tut'},
                                   -style=&gt;{'src'=&gt;'/styles/style1.css'},
                                   -BGCOLOR=&gt;'blue');

       After creating the HTTP header, most CGI scripts will start writing out an HTML document.  The
       <u>start</u><b>_</b><u>html()</u> routine creates the top of the page, along with a lot of optional information that con-
       trols the page's appearance and behavior.

       This method returns a canned HTML header and the opening &lt;body&gt; tag.  All parameters are optional.
       In the named parameter form, recognized parameters are -title, -author, -base, -xbase, -dtd, -lang
       and -target (see below for the explanation).  Any additional parameters you provide, such as the
       Netscape unofficial BGCOLOR attribute, are added to the &lt;body&gt; tag.  Additional parameters must be
       proceeded by a hyphen.

       The argument <b>-xbase</b> allows you to provide an HREF for the &lt;base&gt; tag different from the current loca-
       tion, as in

           -xbase=&gt;"<a href="http://home.mcom.com/">http://home.mcom.com/</a>"

       All relative links will be interpreted relative to this tag.

       The argument <b>-target</b> allows you to provide a default target frame for all the links and fill-out
       forms on the page.  <b>This</b> <b>is</b> <b>a</b> <b>non-standard</b> <b>HTTP</b> <b>feature</b> <b>which</b> <b>only</b> <b>works</b> <b>with</b> <b>Netscape</b> <b>browsers!</b>  See
       the Netscape documentation on frames for details of how to manipulate this.

           -target=&gt;"answer_window"

       All relative links will be interpreted relative to this tag.  You add arbitrary meta information to
       the header with the <b>-meta</b> argument.  This argument expects a reference to an associative array con-
       taining name/value pairs of meta information.  These will be turned into a series of header &lt;meta&gt;
       tags that look something like this:

           &lt;meta name="keywords" content="pharaoh secret mummy"&gt;
           &lt;meta name="description" content="copyright 1996 King Tut"&gt;

       To create an HTTP-EQUIV type of &lt;meta&gt; tag, use <b>-head</b>, described below.

       The <b>-style</b> argument is used to incorporate cascading stylesheets into your code.  See the section on
       CASCADING STYLESHEETS for more information.

       The <b>-lang</b> argument is used to incorporate a language attribute into the &lt;html&gt; tag.  For example:

           print $q-&gt;start_html(-lang=&gt;'fr-CA');

       The default if not specified is "en-US" for US English, unless the -dtd parameter specifies an HTML
       2.0 or 3.2 DTD, in which case the lang attribute is left off.  You can force the lang attribute to
       left off in other cases by passing an empty string (-lang=&gt;'').

       The <b>-encoding</b> argument can be used to specify the character set for XHTML.  It defaults to iso-8859-1
       if not specified.

       The <b>-declare_xml</b> argument, when used in conjunction with XHTML, will put a &lt;?xml&gt; declaration at the
       top of the HTML header. The sole purpose of this declaration is to declare the character set encod-
       ing. In the absence of -declare_xml, the output HTML will contain a &lt;meta&gt; tag that specifies the
       encoding, allowing the HTML to pass most validators.  The default for -declare_xml is false.

       You can place other arbitrary HTML elements to the &lt;head&gt; section with the <b>-head</b> tag.  For example,
       to place the rarely-used &lt;link&gt; element in the head section, use this:

           print start_html(-head=&gt;Link({-rel=&gt;'next',
                                         -href=&gt;'<a href="http://www.capricorn.com/s2.html">http://www.capricorn.com/s2.html</a>'}));

       To incorporate multiple HTML elements into the &lt;head&gt; section, just pass an array reference:

           print start_html(-head=&gt;[
                                    Link({-rel=&gt;'next',
                                          -href=&gt;'<a href="http://www.capricorn.com/s2.html">http://www.capricorn.com/s2.html</a>'}),
                                    Link({-rel=&gt;'previous',
                                          -href=&gt;'<a href="http://www.capricorn.com/s1.html">http://www.capricorn.com/s1.html</a>'})
                                    ]
                            );

       And here's how to create an HTTP-EQUIV &lt;meta&gt; tag:

             print start_html(-head=&gt;meta({-http_equiv =&gt; 'Content-Type',
                                           -content    =&gt; 'text/html'}))

       JAVASCRIPTING: The <b>-script</b>, <b>-noScript</b>, <b>-onLoad</b>, <b>-onMouseOver</b>, <b>-onMouseOut</b> and <b>-onUnload</b> parameters
       are used to add Netscape JavaScript calls to your pages.  <b>-script</b> should point to a block of text
       containing JavaScript function definitions.  This block will be placed within a &lt;script&gt; block inside
       the HTML (not HTTP) header.  The block is placed in the header in order to give your page a fighting
       chance of having all its JavaScript functions in place even if the user presses the stop button
       before the page has loaded completely.  CGI.pm attempts to format the script in such a way that
       JavaScript-naive browsers will not choke on the code: unfortunately there are some browsers, such as
       Chimera for Unix, that get confused by it nevertheless.

       The <b>-onLoad</b> and <b>-onUnload</b> parameters point to fragments of JavaScript code to execute when the page
       is respectively opened and closed by the browser.  Usually these parameters are calls to functions
       defined in the <b>-script</b> field:

             $query = new CGI;
             print header;
             $JSCRIPT=&lt;&lt;END;
             // Ask a silly question
             function riddle_me_this() {
                var r = prompt("What walks on four legs in the morning, " +
                              "two legs in the afternoon, " +
                              "and three legs in the evening?");
                <!-- a -->response(r)<!-- /a -->;
             }
             // Get a silly answer
             function response(answer) {
                if (answer == "man")
                   alert("Right you are!");
                else
                   alert("Wrong!  Guess again.");
             }
             END
             print start_html(-title=&gt;'The Riddle of the Sphinx',
                                      -script=&gt;$JSCRIPT);

       Use the <b>-noScript</b> parameter to pass some HTML text that will be displayed on browsers that do not
       have JavaScript (or browsers where JavaScript is turned off).

       Netscape 3.0 recognizes several attributes of the &lt;script&gt; tag, including LANGUAGE and SRC.  The lat-
       ter is particularly interesting, as it allows you to keep the JavaScript code in a file or CGI script
       rather than cluttering up each page with the source.  To use these attributes pass a HASH reference
       in the <b>-script</b> parameter containing one or more of -language, -src, or -code:

           print $q-&gt;start_html(-title=&gt;'The Riddle of the Sphinx',
                                -script=&gt;{-language=&gt;'JAVASCRIPT',
                                          -src=&gt;'/javascript/sphinx.js'}
                                );

           print $q-&gt;(-title=&gt;'The Riddle of the Sphinx',
                      -script=&gt;{-language=&gt;'PERLSCRIPT',
                                -code=&gt;'print "hello world!\n;"'}
                      );

       A final feature allows you to incorporate multiple &lt;script&gt; sections into the header.  Just pass the
       list of script sections as an array reference.  this allows you to specify different source files for
       different dialects of JavaScript.  Example:

            print $q-&gt;start_html(-title=&gt;'The Riddle of the Sphinx',
                                 -script=&gt;[
                                           { -language =&gt; 'JavaScript1.0',
                                             -src      =&gt; '/javascript/utilities10.js'
                                           },
                                           { -language =&gt; 'JavaScript1.1',
                                             -src      =&gt; '/javascript/utilities11.js'
                                           },
                                           { -language =&gt; 'JavaScript1.2',
                                             -src      =&gt; '/javascript/utilities12.js'
                                           },
                                           { -language =&gt; 'JavaScript28.2',
                                             -src      =&gt; '/javascript/utilities219.js'
                                           }
                                        ]
                                    );

       If this looks a bit extreme, take my advice and stick with straight CGI scripting.

       See

          <a href="http://home.netscape.com/eng/mozilla/2.0/handbook/javascript/">http://home.netscape.com/eng/mozilla/2.0/handbook/javascript/</a>

       for more information about JavaScript.

       The old-style positional parameters are as follows:

       <b>Parameters:</b>
       1.  The title

       2.  The author's e-mail address (will create a &lt;link rev="MADE"&gt; tag if present

       3.  A 'true' flag if you want to include a &lt;base&gt; tag in the header.  This helps resolve relative
           addresses to absolute ones when the document is moved, but makes the document hierarchy non-por-
           table.  Use with care!

       4, 5, 6...
           Any other parameters you want to include in the &lt;body&gt; tag.  This is a good place to put Netscape
           extensions, such as colors and wallpaper patterns.

       <b>ENDING</b> <b>THE</b> <b>HTML</b> <b>DOCUMENT:</b>

               print end_html

       This ends an HTML document by printing the &lt;/body&gt;&lt;/html&gt; tags.

       <b>CREATING</b> <b>A</b> <b>SELF-REFERENCING</b> <b>URL</b> <b>THAT</b> <b>PRESERVES</b> <b>STATE</b> <b>INFORMATION:</b>

           $myself = self_url;
           print q(&lt;a href="$myself"&gt;I'm talking to myself.&lt;/a&gt;);

       <u>self</u><b>_</b><u>url()</u> will return a URL, that, when selected, will reinvoke this script with all its state
       information intact.  This is most useful when you want to jump around within the document using
       internal anchors but you don't want to disrupt the current contents of the <!-- a -->form(s)<!-- /a -->.  Something like
       this will do the trick.

            $myself = self_url;
            print "&lt;a href=\"$myself#table1\"&gt;See table 1&lt;/a&gt;";
            print "&lt;a href=\"$myself#table2\"&gt;See table 2&lt;/a&gt;";
            print "&lt;a href=\"$myself#yourself\"&gt;See for yourself&lt;/a&gt;";

       If you want more control over what's returned, using the <u></u><b><u>u</u></b><u></u><b><u>l</u></b><u></u><b><u>)</u></b> method instead.

       You can also retrieve the unprocessed query string with <u>query</u><b>_</b><u>string()</u>:

           $the_string = query_string;

       <b>OBTAINING</b> <b>THE</b> <b>SCRIPT'S</b> <b>URL</b>

           $full_url      = url();
           $full_url      = url(-full=&gt;1);  #alternative syntax
           $relative_url  = url(-relative=&gt;1);
           $absolute_url  = url(-absolute=&gt;1);
           $url_with_path = url(-path_info=&gt;1);
           $url_with_path_and_query = url(-path_info=&gt;1,-query=&gt;1);
           $netloc        = url(-base =&gt; 1);

       <u></u><b><u>u</u></b><u></u><b><u>l</u></b><u></u><b><u>)</u></b> returns the script's URL in a variety of formats.  Called without any arguments, it returns the
       full form of the URL, including host name and port number

           <a href="http://your.host.com/path/to/script.cgi">http://your.host.com/path/to/script.cgi</a>

       You can modify this format with the following named arguments:

       <b>-absolute</b>
           If true, produce an absolute URL, e.g.

               /path/to/script.cgi

       <b>-relative</b>
           Produce a relative URL.  This is useful if you want to reinvoke your script with different param-
           eters. For example:

               script.cgi

       <b>-full</b>
           Produce the full URL, exactly as if called without any arguments.  This overrides the -relative
           and -absolute arguments.

       <b>-path</b> (<b>-path_info</b>)
           Append the additional path information to the URL.  This can be combined with <b>-full</b>, <b>-absolute</b> or
           <b>-relative</b>.  <b>-path_info</b> is provided as a synonym.

       <b>-query</b> (<b>-query_string</b>)
           Append the query string to the URL.  This can be combined with <b>-full</b>, <b>-absolute</b> or <b>-relative</b>.
           <b>-query_string</b> is provided as a synonym.

       <b>-base</b>
           Generate just the protocol and net location, as in <a href="http://www.foo.com:8000">http://www.foo.com:8000</a>

       <b>-rewrite</b>
           If Apache's mod_rewrite is turned on, then the script name and path info probably won't match the
           request that the user sent. Set -rewrite=&gt;1 (default) to return URLs that match what the user
           sent (the original request URI). Set -rewrite-&gt;0 to return URLs that match the URL after mod_re-
           write's rules have run. Because the additional path information only makes sense in the context
           of the rewritten URL, -rewrite is set to false when you request path info in the URL.

       <b>MIXING</b> <b>POST</b> <b>AND</b> <b>URL</b> <b>PARAMETERS</b>

          $color = url_param('color');

       It is possible for a script to receive CGI parameters in the URL as well as in the fill-out form by
       creating a form that POSTs to a URL containing a query string (a "?" mark followed by arguments).
       The <u></u><b><u>p</u></b><u></u><b><u>r</u></b><u></u><b><u>m</u></b><u></u><b><u>)</u></b> method will always return the contents of the POSTed fill-out form, ignoring the URL's
       query string.  To retrieve URL parameters, call the <u></u><b><u>u</u></b><u></u><b><u>l</u></b><b>_</b><u></u><b><u>p</u></b><u></u><b><u>r</u></b><u></u><b><u>m</u></b><u></u><b><u>)</u></b> method.  Use it in the same way as
       <u></u><b><u>p</u></b><u></u><b><u>r</u></b><u></u><b><u>m</u></b><u></u><b><u>)</u></b>.  The main difference is that it allows you to read the parameters, but not set them.

       Under no circumstances will the contents of the URL query string interfere with similarly-named CGI
       parameters in POSTed forms.  If you try to mix a URL query string with a form submitted with the GET
       method, the results will not be what you expect.

<b>CREATING</b> <b>STANDARD</b> <b>HTML</b> <b>ELEMENTS:</b>
       CGI.pm defines general HTML shortcut methods for most, if not all of the HTML 3 and HTML 4 tags.
       HTML shortcuts are named after a single HTML element and return a fragment of HTML text that you can
       then print or manipulate as you like.  Each shortcut returns a fragment of HTML code that you can
       append to a string, save to a file, or, most commonly, print out so that it displays in the browser
       window.

       This example shows how to use the HTML methods:

          print $q-&gt;blockquote(
                            "Many years ago on the island of",
                            $q-&gt;a({href=&gt;"<a href="http://crete.org/">http://crete.org/</a>"},"Crete"),
                            "there lived a Minotaur named",
                            $q-&gt;strong("Fred."),
                           ),
              $q-&gt;hr;

       This results in the following HTML code (extra newlines have been added for readability):

          &lt;blockquote&gt;
          Many years ago on the island of
          &lt;a href="<a href="http://crete.org/">http://crete.org/</a>"&gt;Crete&lt;/a&gt; there lived
          a minotaur named &lt;strong&gt;Fred.&lt;/strong&gt;
          &lt;/blockquote&gt;
          &lt;hr&gt;

       If you find the syntax for calling the HTML shortcuts awkward, you can import them into your names-
       pace and dispense with the object syntax completely (see the next section for more details):

          use CGI ':standard';
          print blockquote(
             "Many years ago on the island of",
             a({href=&gt;"<a href="http://crete.org/">http://crete.org/</a>"},"Crete"),
             "there lived a minotaur named",
             strong("Fred."),
             ),
             hr;

       <b>PROVIDING</b> <b>ARGUMENTS</b> <b>TO</b> <b>HTML</b> <b>SHORTCUTS</b>

       The HTML methods will accept zero, one or multiple arguments.  If you provide no arguments, you get a
       single tag:

          print hr;    #  &lt;hr&gt;

       If you provide one or more string arguments, they are concatenated together with spaces and placed
       between opening and closing tags:

          print h1("Chapter","1"); # &lt;h1&gt;Chapter 1&lt;/h1&gt;"

       If the first argument is an associative array reference, then the keys and values of the associative
       array become the HTML tag's attributes:

          print a({-href=&gt;'fred.html',-target=&gt;'_new'},
             "Open a new frame");

                   &lt;a href="fred.html",target="_new"&gt;Open a new frame&lt;/a&gt;

       You may dispense with the dashes in front of the attribute names if you prefer:

          print img {src=&gt;'fred.gif',align=&gt;'LEFT'};

                  &lt;img align="LEFT" src="fred.gif"&gt;

       Sometimes an HTML tag attribute has no argument.  For example, ordered lists can be marked as COM-
       PACT.  The syntax for this is an argument that that points to an undef string:

          print ol({compact=&gt;undef},li('one'),li('two'),li('three'));

       Prior to CGI.pm version 2.41, providing an empty ('') string as an attribute argument was the same as
       providing undef.  However, this has changed in order to accommodate those who want to create tags of
       the form &lt;img alt=""&gt;.  The difference is shown in these two pieces of code:

          CODE                   RESULT
          img({alt=&gt;undef})      &lt;img alt&gt;
          img({alt=&gt;''})         &lt;img alt=""&gt;

       <b>THE</b> <b>DISTRIBUTIVE</b> <b>PROPERTY</b> <b>OF</b> <b>HTML</b> <b>SHORTCUTS</b>

       One of the cool features of the HTML shortcuts is that they are distributive.  If you give them an
       argument consisting of a <b>reference</b> to a list, the tag will be distributed across each element of the
       list.  For example, here's one way to make an ordered list:

          print ul(
                    li({-type=&gt;'disc'},['Sneezy','Doc','Sleepy','Happy'])
                  );

       This example will result in HTML output that looks like this:

          &lt;ul&gt;
            &lt;li type="disc"&gt;Sneezy&lt;/li&gt;
            &lt;li type="disc"&gt;Doc&lt;/li&gt;
            &lt;li type="disc"&gt;Sleepy&lt;/li&gt;
            &lt;li type="disc"&gt;Happy&lt;/li&gt;
          &lt;/ul&gt;

       This is extremely useful for creating tables.  For example:

          print table({-border=&gt;undef},
                  caption('When Should You Eat Your Vegetables?'),
                  Tr({-align=&gt;CENTER,-valign=&gt;TOP},
                  [
                     th(['Vegetable', 'Breakfast','Lunch','Dinner']),
                     td(['Tomatoes' , 'no', 'yes', 'yes']),
                     td(['Broccoli' , 'no', 'no',  'yes']),
                     td(['Onions'   , 'yes','yes', 'yes'])
                  ]
                  )
               );

       <b>HTML</b> <b>SHORTCUTS</b> <b>AND</b> <b>LIST</b> <b>INTERPOLATION</b>

       Consider this bit of code:

          print blockquote(em('Hi'),'mom!'));

       It will ordinarily return the string that you probably expect, namely:

          &lt;blockquote&gt;&lt;em&gt;Hi&lt;/em&gt; mom!&lt;/blockquote&gt;

       Note the space between the element "Hi" and the element "mom!".  CGI.pm puts the extra space there
       using array interpolation, which is controlled by the magic $" variable.  Sometimes this extra space
       is not what you want, for example, when you are trying to align a series of images.  In this case,
       you can simply change the value of $" to an empty string.

          {
             local($") = '';
             print blockquote(em('Hi'),'mom!'));
           }

       I suggest you put the code in a block as shown here.  Otherwise the change to $" will affect all sub-
       sequent code until you explicitly reset it.

       <b>NON-STANDARD</b> <b>HTML</b> <b>SHORTCUTS</b>

       A few HTML tags don't follow the standard pattern for various reasons.

       <u></u><b><u>c</u></b><u></u><b><u>m</u></b><u></u><b><u>e</u></b><u></u><b><u>t</u></b><u></u><b><u>)</u></b> generates an HTML comment (&lt;!-- comment --&gt;).  Call it like

           print comment('here is my comment');

       Because of conflicts with built-in Perl functions, the following functions begin with initial caps:

           Select
           Tr
           Link
           Delete
           Accept
           Sub

       In addition, <u>start</u><b>_</b><u>html()</u>, <u>end</u><b>_</b><u>html()</u>, <u>start</u><b>_</b><u>form()</u>, <u>end</u><b>_</b><u>form()</u>, <u>start</u><b>_</b><u>multipart</u><b>_</b><u>form()</u> and all the
       fill-out form tags are special.  See their respective sections.

       <b>AUTOESCAPING</b> <b>HTML</b>

       By default, all HTML that is emitted by the form-generating functions is passed through a function
       called <u>escapeHTML()</u>:

       $escaped_string = escapeHTML("unescaped string");
           Escape HTML formatting characters in a string.

       Provided that you have specified a character set of ISO-8859-1 (the default), the standard HTML
       escaping rules will be used.  The "&lt;" character becomes "&amp;lt;", "&gt;" becomes "&amp;gt;", "&amp;" becomes
       "&amp;amp;", and the quote character becomes "&amp;quot;".  In addition, the hexadecimal 0x8b and 0x9b char-
       acters, which some browsers incorrectly interpret as the left and right angle-bracket characters, are
       replaced by their numeric character entities ("&amp;#8249" and "&amp;#8250;").  If you manually change the
       charset, either by calling the <u>charset()</u> method explicitly or by passing a -charset argument to
       <u>header()</u>, then <b>all</b> characters will be replaced by their numeric entities, since CGI.pm has no lookup
       table for all the possible encodings.

       The automatic escaping does not apply to other shortcuts, such as <u>h1()</u>.  You should call <u>escapeHTML()</u>
       yourself on untrusted data in order to protect your pages against nasty tricks that people may enter
       into guestbooks, etc..  To change the character set, use <u>charset()</u>.  To turn autoescaping off com-
       pletely, use <u>autoEscape</u>(0):

       $charset = charset([$charset]);
           Get or set the current character set.

       $flag = autoEscape([$flag]);
           Get or set the value of the autoescape flag.

       <b>PRETTY-PRINTING</b> <b>HTML</b>

       By default, all the HTML produced by these functions comes out as one long line without carriage
       returns or indentation. This is yuck, but it does reduce the size of the documents by 10-20%.  To get
       pretty-printed output, please use CGI::Pretty, a subclass contributed by Brian Paulsen.

<b>CREATING</b> <b>FILL-OUT</b> <b>FORMS:</b>
       <u>General</u> <u>note</u>  The various form-creating methods all return strings to the caller, containing the tag
       or tags that will create the requested form element.  You are responsible for actually printing out
       these strings.  It's set up this way so that you can place formatting tags around the form elements.

       <u>Another</u> <u>note</u> The default values that you specify for the forms are only used the <b>first</b> time the
       script is invoked (when there is no query string).  On subsequent invocations of the script (when
       there is a query string), the former values are used even if they are blank.

       If you want to change the value of a field from its previous value, you have two choices:

       (1) call the <u>param()</u> method to set it.

       (2) use the -override (alias -force) parameter (a new feature in version 2.15).  This forces the
       default value to be used, regardless of the previous value:

          print textfield(-name=&gt;'field_name',
                                  -default=&gt;'starting value',
                                  -override=&gt;1,
                                  -size=&gt;50,
                                  -maxlength=&gt;80);

       <u>Yet</u> <u>another</u> <u>note</u> By default, the text and labels of form elements are escaped according to HTML
       rules.  This means that you can safely use "&lt;CLICK ME&gt;" as the label for a button.  However, it also
       interferes with your ability to incorporate special HTML character sequences, such as &amp;Aacute;, into
       your fields.  If you wish to turn off automatic escaping, call the <u>autoEscape()</u> method with a false
       value immediately after creating the CGI object:

          $query = new CGI;
          autoEscape(undef);

       <u>A</u> <u>Lurking</u> <u>Trap!</u> Some of the form-element generating methods return multiple tags.  In a scalar con-
       text, the tags will be concatenated together with spaces, or whatever is the current value of the $"
       global.  In a list context, the methods will return a list of elements, allowing you to modify them
       if you wish.  Usually you will not notice this behavior, but beware of this:

           printf("%s\n",end_form())

       <u>end</u><b>_</b><u>form()</u> produces several tags, and only the first of them will be printed because the format only
       expects one value.

       &lt;p&gt;

       <b>CREATING</b> <b>AN</b> <b>ISINDEX</b> <b>TAG</b>

          print isindex(-action=&gt;$action);

                -or-

          print isindex($action);

       Prints out an &lt;isindex&gt; tag.  Not very exciting.  The parameter -action specifies the URL of the
       script to process the query.  The default is to process the query with the current script.

       <b>STARTING</b> <b>AND</b> <b>ENDING</b> <b>A</b> <b>FORM</b>

           print start_form(-method=&gt;$method,
                           -action=&gt;$action,
                           -enctype=&gt;$encoding);
             &lt;... various form stuff ...&gt;
           print endform;

               -or-

           print start_form($method,$action,$encoding);
             &lt;... various form stuff ...&gt;
           print endform;

       <u>start</u><b>_</b><u>form()</u> will return a &lt;form&gt; tag with the optional method, action and form encoding that you
       specify.  The defaults are:

           method: POST
           action: this script
           enctype: application/x-www-form-urlencoded

       <u>endform()</u> returns the closing &lt;/form&gt; tag.

       <u>Start</u><b>_</b><u>form()</u>'s enctype argument tells the browser how to package the various fields of the form
       before sending the form to the server.  Two values are possible:

       <b>Note:</b> This method was previously named <u>startform()</u>, and <u>startform()</u> is still recognized as an alias.

       <b>application/x-www-form-urlencoded</b>
           This is the older type of encoding used by all browsers prior to Netscape 2.0.  It is compatible
           with many CGI scripts and is suitable for short fields containing text data.  For your conve-
           nience, CGI.pm stores the name of this encoding type in <b>&amp;CGI::URL_ENCODED</b>.

       <b>multipart/form-data</b>
           This is the newer type of encoding introduced by Netscape 2.0.  It is suitable for forms that
           contain very large fields or that are intended for transferring binary data.  Most importantly,
           it enables the "file upload" feature of Netscape 2.0 forms.  For your convenience, CGI.pm stores
           the name of this encoding type in <b>&amp;CGI::MULTIPART</b>

           Forms that use this type of encoding are not easily interpreted by CGI scripts unless they use
           CGI.pm or another library designed to handle them.

           If XHTML is activated (the default), then forms will be automatically created using this type of
           encoding.

       For compatibility, the <u>start</u><b>_</b><u>form()</u> method uses the older form of encoding by default.  If you want
       to use the newer form of encoding by default, you can call <u></u><b><u>s</u></b><u></u><b><u>a</u></b><u></u><b><u>t</u></b><b>_</b><u></u><b><u>m</u></b><u></u><b><u>l</u></b><u></u><b><u>i</u></b><u></u><b><u>a</u></b><u></u><b><u>t</u></b><b>_</b><u></u><b><u>f</u></b><u></u><b><u>r</u></b><u></u><b><u>(</u></b> instead of
       <u></u><b><u>s</u></b><u></u><b><u>a</u></b><u></u><b><u>t</u></b><b>_</b><u></u><b><u>f</u></b><u></u><b><u>r</u></b><u></u><b><u>(</u></b>.

       JAVASCRIPTING: The <b>-name</b> and <b>-onSubmit</b> parameters are provided for use with JavaScript.  The -name
       parameter gives the form a name so that it can be identified and manipulated by JavaScript functions.
       -onSubmit should point to a JavaScript function that will be executed just before the form is submit-
       ted to your server.  You can use this opportunity to check the contents of the form for consistency
       and completeness.  If you find something wrong, you can put up an alert box or maybe fix things up
       yourself.  You can abort the submission by returning false from this function.

       Usually the bulk of JavaScript functions are defined in a &lt;script&gt; block in the HTML header and
       -onSubmit points to one of these function call.  See <u>start</u><b>_</b><u>html()</u> for details.

       <b>FORM</b> <b>ELEMENTS</b>

       After starting a form, you will typically create one or more textfields, popup menus, radio groups
       and other form elements.  Each of these elements takes a standard set of named arguments.  Some ele-
       ments also have optional arguments.  The standard arguments are as follows:

       <b>-name</b>
           The name of the field. After submission this name can be used to retrieve the field's value using
           the <u>param()</u> method.

       <b>-value</b>, <b>-values</b>
           The initial value of the field which will be returned to the script after form submission.  Some
           form elements, such as text fields, take a single scalar -value argument. Others, such as popup
           menus, take a reference to an array of values. The two arguments are synonyms.

       <b>-tabindex</b>
           A numeric value that sets the order in which the form element receives focus when the user
           presses the tab key. Elements with lower values receive focus first.

       <b>-id</b> A string identifier that can be used to identify this element to JavaScript and DHTML.

       <b>-override</b>
           A boolean, which, if true, forces the element to take on the value specified by <b>-value</b>, overrid-
           ing the sticky behavior described earlier for the <b>-no_sticky</b> pragma.

       <b>-onChange</b>, <b>-onFocus</b>, <b>-onBlur</b>, <b>-onMouseOver</b>, <b>-onMouseOut</b>, <b>-onSelect</b>
           These are used to assign JavaScript event handlers. See the JavaScripting section for more
           details.

       Other common arguments are described in the next section. In addition to these, all attributes
       described in the HTML specifications are supported.

       <b>CREATING</b> <b>A</b> <b>TEXT</b> <b>FIELD</b>

           print textfield(-name=&gt;'field_name',
                           -value=&gt;'starting value',
                           -size=&gt;50,
                           -maxlength=&gt;80);
               -or-

           print textfield('field_name','starting value',50,80);

       <u>textfield()</u> will return a text input field.

       <b>Parameters</b>
       1.  The first parameter is the required name for the field (-name).

       2.  The optional second parameter is the default starting value for the field contents (-value, for-
           merly known as -default).

       3.  The optional third parameter is the size of the field in
                 characters (-size).

       4.  The optional fourth parameter is the maximum number of characters the
                 field will accept (-maxlength).

       As with all these methods, the field will be initialized with its previous contents from earlier
       invocations of the script.  When the form is processed, the value of the text field can be retrieved
       with:

              $value = param('foo');

       If you want to reset it from its initial value after the script has been called once, you can do so
       like this:

              param('foo',"I'm taking over this value!");

       <b>CREATING</b> <b>A</b> <b>BIG</b> <b>TEXT</b> <b>FIELD</b>

          print textarea(-name=&gt;'foo',
                                 -default=&gt;'starting value',
                                 -rows=&gt;10,
                                 -columns=&gt;50);

               -or

          print textarea('foo','starting value',10,50);

       <u>textarea()</u> is just like textfield, but it allows you to specify rows and columns for a multiline text
       entry box.  You can provide a starting value for the field, which can be long and contain multiple
       lines.

       <b>CREATING</b> <b>A</b> <b>PASSWORD</b> <b>FIELD</b>

          print password_field(-name=&gt;'secret',
                                       -value=&gt;'starting value',
                                       -size=&gt;50,
                                       -maxlength=&gt;80);
               -or-

          print password_field('secret','starting value',50,80);

       <u>password</u><b>_</b><u>field()</u> is identical to <u>textfield()</u>, except that its contents will be starred out on the web
       page.

       <b>CREATING</b> <b>A</b> <b>FILE</b> <b>UPLOAD</b> <b>FIELD</b>

           print filefield(-name=&gt;'uploaded_file',
                                   -default=&gt;'starting value',
                                   -size=&gt;50,
                                   -maxlength=&gt;80);
               -or-

           print filefield('uploaded_file','starting value',50,80);

       <u>filefield()</u> will return a file upload field for Netscape 2.0 browsers.  In order to take full advan-
       tage of this <u>you</u> <u>must</u> <u>use</u> <u>the</u> <u>new</u> <u>multipart</u> <u>encoding</u> <u>scheme</u> for the form.  You can do this either by
       calling <u></u><b><u>s</u></b><u></u><b><u>a</u></b><u></u><b><u>t</u></b><b>_</b><u></u><b><u>f</u></b><u></u><b><u>r</u></b><u></u><b><u>(</u></b> with an encoding type of <b>&amp;CGI::MULTIPART</b>, or by calling the new method
       <u></u><b><u>s</u></b><u></u><b><u>a</u></b><u></u><b><u>t</u></b><b>_</b><u></u><b><u>m</u></b><u></u><b><u>l</u></b><u></u><b><u>i</u></b><u></u><b><u>a</u></b><u></u><b><u>t</u></b><b>_</b><u></u><b><u>f</u></b><u></u><b><u>r</u></b><u></u><b><u>(</u></b> instead of vanilla <u></u><b><u>s</u></b><u></u><b><u>a</u></b><u></u><b><u>t</u></b><b>_</b><u></u><b><u>f</u></b><u></u><b><u>r</u></b><u></u><b><u>(</u></b>.

       <b>Parameters</b>
       1.  The first parameter is the required name for the field (-name).

       2.  The optional second parameter is the starting value for the field contents to be used as the
           default file name (-default).

           For security reasons, browsers don't pay any attention to this field, and so the starting value
           will always be blank.  Worse, the field loses its "sticky" behavior and forgets its previous con-
           tents.  The starting value field is called for in the HTML specification, however, and possibly
           some browser will eventually provide support for it.

       3.  The optional third parameter is the size of the field in characters (-size).

       4.  The optional fourth parameter is the maximum number of characters the field will accept
           (-maxlength).

       When the form is processed, you can retrieve the entered filename by calling <u>param()</u>:

              $filename = param('uploaded_file');

       Different browsers will return slightly different things for the name.  Some browsers return the
       filename only.  Others return the full path to the file, using the path conventions of the user's
       machine.  Regardless, the name returned is always the name of the file on the <u>user's</u> machine, and is
       unrelated to the name of the temporary file that CGI.pm creates during upload spooling (see below).

       The filename returned is also a file handle.  You can read the contents of the file using standard
       Perl file reading calls:

               # Read a text file and print it out
               while (&lt;$filename&gt;) {
                  print;
               }

               # Copy a binary file to somewhere safe
               open (OUTFILE,"&gt;&gt;/usr/local/web/users/feedback");
               while ($bytesread=read($filename,$buffer,1024)) {
                  print OUTFILE $buffer;
               }

       However, there are problems with the dual nature of the upload fields.  If you "use strict", then
       Perl will complain when you try to use a string as a filehandle.  You can get around this by placing
       the file reading code in a block containing the "no strict" pragma.  More seriously, it is possible
       for the remote user to type garbage into the upload field, in which case what you get from <u>param()</u> is
       not a filehandle at all, but a string.

       To be safe, use the <u>upload()</u> function (new in version 2.47).  When called with the name of an upload
       field, <u>upload()</u> returns a filehandle, or undef if the parameter is not a valid filehandle.

            $fh = upload('uploaded_file');
            while (&lt;$fh&gt;) {
                  print;
            }

       In an list context, <u>upload()</u> will return an array of filehandles.  This makes it possible to create
       forms that use the same name for multiple upload fields.

       This is the recommended idiom.

       When a file is uploaded the browser usually sends along some information along with it in the format
       of headers.  The information usually includes the MIME content type.  Future browsers may send other
       information as well (such as modification date and size). To retrieve this information, call <u>upload</u>-
       <u>Info()</u>.  It returns a reference to an associative array containing all the document headers.

              $filename = param('uploaded_file');
              $type = uploadInfo($filename)-&gt;{'Content-Type'};
              unless ($type eq 'text/html') {
                 die "HTML FILES ONLY!";
              }

       If you are using a machine that recognizes "text" and "binary" data modes, be sure to understand when
       and how to use them (see the Camel book).  Otherwise you may find that binary files are corrupted
       during file uploads.

       There are occasionally problems involving parsing the uploaded file.  This usually happens when the
       user presses "Stop" before the upload is finished.  In this case, CGI.pm will return undef for the
       name of the uploaded file and set <u>cgi</u><b>_</b><u>error()</u> to the string "400 Bad request (malformed multipart
       POST)".  This error message is designed so that you can incorporate it into a status code to be sent
       to the browser.  Example:

          $file = upload('uploaded_file');
          if (!$file &amp;&amp; cgi_error) {
             print header(-status=&gt;cgi_error);
             exit 0;
          }

       You are free to create a custom HTML page to complain about the error, if you wish.

       You can set up a callback that will be called whenever a file upload is being read during the form
       processing. This is much like the UPLOAD_HOOK facility available in Apache::Request, with the excep-
       tion that the first argument to the callback is an Apache::Upload object, here it's the remote file-
       name.

        $q = CGI-&gt;new(\&amp;hook,$data);

        sub hook
        {
               my ($filename, $buffer, $bytes_read, $data) = @_;
               print  "Read $bytes_read bytes of $filename\n";
        }

       If using the function-oriented interface, call the <u>CGI::upload</u><b>_</b><u>hook()</u> method before calling <u>param()</u>
       or any other CGI functions:

         CGI::upload_hook(\&amp;hook,$data);

       This method is not exported by default.  You will have to import it explicitly if you wish to use it
       without the CGI:: prefix.

       If you are using CGI.pm on a Windows platform and find that binary files get slightly larger when
       uploaded but that text files remain the same, then you have forgotten to activate binary mode on the
       output filehandle.  Be sure to call <u>binmode()</u> on any handle that you create to write the uploaded
       file to disk.

       JAVASCRIPTING: The <b>-onChange</b>, <b>-onFocus</b>, <b>-onBlur</b>, <b>-onMouseOver</b>, <b>-onMouseOut</b> and <b>-onSelect</b> parameters
       are recognized.  See <u>textfield()</u> for details.

       <b>CREATING</b> <b>A</b> <b>POPUP</b> <b>MENU</b>

          print popup_menu('menu_name',
                                   ['eenie','meenie','minie'],
                                   'meenie');

             -or-

          %labels = ('eenie'=&gt;'your first choice',
                     'meenie'=&gt;'your second choice',
                     'minie'=&gt;'your third choice');
          %attributes = ('eenie'=&gt;{'class'=&gt;'class of first choice'});
          print popup_menu('menu_name',
                                   ['eenie','meenie','minie'],
                 'meenie',\%labels,\%attributes);

               -or (named parameter style)-

          print popup_menu(-name=&gt;'menu_name',
                                   -values=&gt;['eenie','meenie','minie'],
                                   -default=&gt;'meenie',
                 -labels=&gt;\%labels,
                 -attributes=&gt;\%attributes);

       <u>popup</u><b>_</b><u>menu()</u> creates a menu.

       1.  The required first argument is the menu's name (-name).

       2.  The required second argument (-values) is an array <b>reference</b> containing the list of menu items in
           the menu.  You can pass the method an anonymous array, as shown in the example, or a reference to
           a named array, such as "\@foo".

       3.  The optional third parameter (-default) is the name of the default menu choice.  If not speci-
           fied, the first item will be the default.  The values of the previous choice will be maintained
           across queries.

       4.  The optional fourth parameter (-labels) is provided for people who want to use different values
           for the user-visible label inside the popup menu and the value returned to your script.  It's a
           pointer to an associative array relating menu values to user-visible labels.  If you leave this
           parameter blank, the menu values will be displayed by default.  (You can also leave a label unde-
           fined if you want to).

       5.  The optional fifth parameter (-attributes) is provided to assign any of the common HTML
           attributes to an individual menu item. It's a pointer to an associative array relating menu val-
           ues to another associative array with the attribute's name as the key and the attribute's value
           as the value.

       When the form is processed, the selected value of the popup menu can be retrieved using:

             $popup_menu_value = param('menu_name');

       <b>CREATING</b> <b>AN</b> <b>OPTION</b> <b>GROUP</b>

       Named parameter style

         print popup_menu(-name=&gt;'menu_name',
                         -values=&gt;[qw/eenie meenie minie/,
                                   optgroup(-name=&gt;'optgroup_name',
                                                    -values =&gt; ['moe','catch'],
                                                    -attributes=&gt;{'catch'=&gt;{'class'=&gt;'red'}})],
                         -labels=&gt;{'eenie'=&gt;'one',
                                   'meenie'=&gt;'two',
                                   'minie'=&gt;'three'},
                         -default=&gt;'meenie');

         Old style
         print popup_menu('menu_name',
                         ['eenie','meenie','minie',
                          optgroup('optgroup_name', ['moe', 'catch'],
                                          {'catch'=&gt;{'class'=&gt;'red'}})],'meenie',
                         {'eenie'=&gt;'one','meenie'=&gt;'two','minie'=&gt;'three'});

       <u>optgroup()</u> creates an option group within a popup menu.

       1.  The required first argument (<b>-name</b>) is the label attribute of the optgroup and is <b>not</b> inserted in
           the parameter list of the query.

       2.  The required second argument (<b>-values</b>)  is an array reference containing the list of menu items
           in the menu.  You can pass the method an anonymous array, as shown in the example, or a reference
           to a named array, such as \@foo.  If you pass a HASH reference, the keys will be used for the
           menu values, and the values will be used for the menu labels (see -labels below).

       3.  The optional third parameter (<b>-labels</b>) allows you to pass a reference to an associative array
           containing user-visible labels for one or more of the menu items.  You can use this when you want
           the user to see one menu string, but have the browser return your program a different one.  If
           you don't specify this, the value string will be used instead ("eenie", "meenie" and "minie" in
           this example).  This is equivalent to using a hash reference for the -values parameter.

       4.  An optional fourth parameter (<b>-labeled</b>) can be set to a true value and indicates that the values
           should be used as the label attribute for each option element within the optgroup.

       5.  An optional fifth parameter (-novals) can be set to a true value and indicates to suppress the
           val attribut in each option element within the optgroup.

           See the discussion on optgroup at W3C (<a href="http://www.w3.org/TR/RECact/forms.html#edef-OPTGROUP)">http://www.w3.org/TR/REC-html40/inter-</a>
           <a href="http://www.w3.org/TR/RECact/forms.html#edef-OPTGROUP)">act/forms.html#edef-OPTGROUP)</a> for details.

       6.  An optional sixth parameter (-attributes) is provided to assign any of the common HTML attributes
           to an individual menu item. It's a pointer to an associative array relating menu values to
           another associative array with the attribute's name as the key and the attribute's value as the
           value.

       <b>CREATING</b> <b>A</b> <b>SCROLLING</b> <b>LIST</b>

          print scrolling_list('list_name',
                                       ['eenie','meenie','minie','moe'],
               ['eenie','moe'],5,'true',{'moe'=&gt;{'class'=&gt;'red'}});
             -or-

          print scrolling_list('list_name',
                                       ['eenie','meenie','minie','moe'],
                                       ['eenie','moe'],5,'true',
               \%labels,%attributes);

               -or-

          print scrolling_list(-name=&gt;'list_name',
                                       -values=&gt;['eenie','meenie','minie','moe'],
                                       -default=&gt;['eenie','moe'],
                                       -size=&gt;5,
                                       -multiple=&gt;'true',
               -labels=&gt;\%labels,
               -attributes=&gt;\%attributes);

       <u>scrolling</u><b>_</b><u>list()</u> creates a scrolling list.

       <b>Parameters:</b>
       1.  The first and second arguments are the list name (-name) and values (-values).  As in the popup
           menu, the second argument should be an array reference.

       2.  The optional third argument (-default) can be either a reference to a list containing the values
           to be selected by default, or can be a single value to select.  If this argument is missing or
           undefined, then nothing is selected when the list first appears.  In the named parameter version,
           you can use the synonym "-defaults" for this parameter.

       3.  The optional fourth argument is the size of the list (-size).

       4.  The optional fifth argument can be set to true to allow multiple simultaneous selections (-multi-
           ple).  Otherwise only one selection will be allowed at a time.

       5.  The optional sixth argument is a pointer to an associative array containing long user-visible
           labels for the list items (-labels).  If not provided, the values will be displayed.

       6.  The optional sixth parameter (-attributes) is provided to assign any of the common HTML
           attributes to an individual menu item. It's a pointer to an associative array relating menu val-
           ues to another associative array with the attribute's name as the key and the attribute's value
           as the value.

           When this form is processed, all selected list items will be returned as a list under the parame-
           ter name 'list_name'.  The values of the selected items can be retrieved with:

                 @selected = param('list_name');

       <b>CREATING</b> <b>A</b> <b>GROUP</b> <b>OF</b> <b>RELATED</b> <b>CHECKBOXES</b>

          print checkbox_group(-name=&gt;'group_name',
                                       -values=&gt;['eenie','meenie','minie','moe'],
                                       -default=&gt;['eenie','moe'],
                                       -linebreak=&gt;'true',
               -labels=&gt;\%labels,
               -attributes=&gt;\%attributes);

          print checkbox_group('group_name',
                                       ['eenie','meenie','minie','moe'],
               ['eenie','moe'],'true',\%labels,
               {'moe'=&gt;{'class'=&gt;'red'}});

          HTML3-COMPATIBLE BROWSERS ONLY:

          print checkbox_group(-name=&gt;'group_name',
                                       -values=&gt;['eenie','meenie','minie','moe'],
                                       -rows=2,-columns=&gt;2);

       <u>checkbox</u><b>_</b><u>group()</u> creates a list of checkboxes that are related by the same name.

       <b>Parameters:</b>
       1.  The first and second arguments are the checkbox name and values, respectively (-name and -val-
           ues).  As in the popup menu, the second argument should be an array reference.  These values are
           used for the user-readable labels printed next to the checkboxes as well as for the values passed
           to your script in the query string.

       2.  The optional third argument (-default) can be either a reference to a list containing the values
           to be checked by default, or can be a single value to checked.  If this argument is missing or
           undefined, then nothing is selected when the list first appears.

       3.  The optional fourth argument (-linebreak) can be set to true to place line breaks between the
           checkboxes so that they appear as a vertical list.  Otherwise, they will be strung together on a
           horizontal line.

       The optional b&lt;-labels&gt; argument is a pointer to an associative array relating the checkbox values to
       the user-visible labels that will be printed next to them.  If not provided, the values will be used
       as the default.

       Modern browsers can take advantage of the optional parameters <b>-rows</b>, and <b>-columns</b>.  These parameters
       cause <u>checkbox</u><b>_</b><u>group()</u> to return an HTML3 compatible table containing the checkbox group formatted
       with the specified number of rows and columns.  You can provide just the -columns parameter if you
       wish; checkbox_group will calculate the correct number of rows for you.

       The optional <b>-attributes</b> argument is provided to assign any of the common HTML attributes to an indi-
       vidual menu item. It's a pointer to an associative array relating menu values to another associative
       array with the attribute's name as the key and the attribute's value as the value.

       The optional <b>-tabindex</b> argument can be used to control the order in which radio buttons receive focus
       when the user presses the tab button.  If passed a scalar numeric value, the first element in the
       group will receive this tab index and subsequent elements will be incremented by one.  If given a
       reference to an array of radio button values, then the indexes will be jiggered so that the order
       specified in the array will correspond to the tab order.  You can also pass a reference to a hash in
       which the hash keys are the radio button values and the values are the tab indexes of each button.
       Examples:

         -tabindex =&gt; 100    #  this group starts at index 100 and counts up
         -tabindex =&gt; ['moe','minie','eenie','meenie']  # tab in this order
         -tabindex =&gt; {meenie=&gt;100,moe=&gt;101,minie=&gt;102,eenie=&gt;200} # tab in this order

       When the form is processed, all checked boxes will be returned as a list under the parameter name
       'group_name'.  The values of the "on" checkboxes can be retrieved with:

             @turned_on = param('group_name');

       The value returned by <u>checkbox</u><b>_</b><u>group()</u> is actually an array of button elements.  You can capture them
       and use them within tables, lists, or in other creative ways:

           @h = checkbox_group(-name=&gt;'group_name',-values=&gt;\@values);
           &amp;use_in_creative_way(@h);

       <b>CREATING</b> <b>A</b> <b>STANDALONE</b> <b>CHECKBOX</b>

           print checkbox(-name=&gt;'checkbox_name',
                                  -checked=&gt;1,
                                  -value=&gt;'ON',
                                  -label=&gt;'CLICK ME');

               -or-

           print checkbox('checkbox_name','checked','ON','CLICK ME');

       <u>checkbox()</u> is used to create an isolated checkbox that isn't logically related to any others.

       <b>Parameters:</b>
       1.  The first parameter is the required name for the checkbox (-name).  It will also be used for the
           user-readable label printed next to the checkbox.

       2.  The optional second parameter (-checked) specifies that the checkbox is turned on by default.
           Synonyms are -selected and -on.

       3.  The optional third parameter (-value) specifies the value of the checkbox when it is checked.  If
           not provided, the word "on" is assumed.

       4.  The optional fourth parameter (-label) is the user-readable label to be attached to the checkbox.
           If not provided, the checkbox name is used.

       The value of the checkbox can be retrieved using:

           $turned_on = param('checkbox_name');

       <b>CREATING</b> <b>A</b> <b>RADIO</b> <b>BUTTON</b> <b>GROUP</b>

          print radio_group(-name=&gt;'group_name',
                                    -values=&gt;['eenie','meenie','minie'],
                                    -default=&gt;'meenie',
                                    -linebreak=&gt;'true',
                  -labels=&gt;\%labels,
                  -attributes=&gt;\%attributes);

               -or-

          print radio_group('group_name',['eenie','meenie','minie'],
                   'meenie','true',\%labels,\%attributes);

          HTML3-COMPATIBLE BROWSERS ONLY:

          print radio_group(-name=&gt;'group_name',
                                    -values=&gt;['eenie','meenie','minie','moe'],
                                    -rows=2,-columns=&gt;2);

       <u>radio</u><b>_</b><u>group()</u> creates a set of logically-related radio buttons (turning one member of the group on
       turns the others off)

       <b>Parameters:</b>
       1.  The first argument is the name of the group and is required (-name).

       2.  The second argument (-values) is the list of values for the radio buttons.  The values and the
           labels that appear on the page are identical.  Pass an array <u>reference</u> in the second argument,
           either using an anonymous array, as shown, or by referencing a named array as in "\@foo".

       3.  The optional third parameter (-default) is the name of the default button to turn on. If not
           specified, the first item will be the default.  You can provide a nonexistent button name, such
           as "-" to start up with no buttons selected.

       4.  The optional fourth parameter (-linebreak) can be set to 'true' to put line breaks between the
           buttons, creating a vertical list.

       5.  The optional fifth parameter (-labels) is a pointer to an associative array relating the radio
           button values to user-visible labels to be used in the display.  If not provided, the values
           themselves are displayed.

       All modern browsers can take advantage of the optional parameters <b>-rows</b>, and <b>-columns</b>.  These parame-
       ters cause <u>radio</u><b>_</b><u>group()</u> to return an HTML3 compatible table containing the radio group formatted
       with the specified number of rows and columns.  You can provide just the -columns parameter if you
       wish; radio_group will calculate the correct number of rows for you.

       To include row and column headings in the returned table, you can use the <b>-rowheader</b> and <b>-colheader</b>
       parameters.  Both of these accept a pointer to an array of headings to use.  The headings are just
       decorative.  They don't reorganize the interpretation of the radio buttons -- they're still a single
       named unit.

       The optional <b>-tabindex</b> argument can be used to control the order in which radio buttons receive focus
       when the user presses the tab button.  If passed a scalar numeric value, the first element in the
       group will receive this tab index and subsequent elements will be incremented by one.  If given a
       reference to an array of radio button values, then the indexes will be jiggered so that the order
       specified in the array will correspond to the tab order.  You can also pass a reference to a hash in
       which the hash keys are the radio button values and the values are the tab indexes of each button.
       Examples:

         -tabindex =&gt; 100    #  this group starts at index 100 and counts up
         -tabindex =&gt; ['moe','minie','eenie','meenie']  # tab in this order
         -tabindex =&gt; {meenie=&gt;100,moe=&gt;101,minie=&gt;102,eenie=&gt;200} # tab in this order

       The optional <b>-attributes</b> argument is provided to assign any of the common HTML attributes to an indi-
       vidual menu item. It's a pointer to an associative array relating menu values to another associative
       array with the attribute's name as the key and the attribute's value as the value.

       When the form is processed, the selected radio button can be retrieved using:

             $which_radio_button = param('group_name');

       The value returned by <u>radio</u><b>_</b><u>group()</u> is actually an array of button elements.  You can capture them
       and use them within tables, lists, or in other creative ways:

           @h = radio_group(-name=&gt;'group_name',-values=&gt;\@values);
           &amp;use_in_creative_way(@h);

       <b>CREATING</b> <b>A</b> <b>SUBMIT</b> <b>BUTTON</b>

          print submit(-name=&gt;'button_name',
                               -value=&gt;'value');

               -or-

          print submit('button_name','value');

       <u>submit()</u> will create the query submission button.  Every form should have one of these.

       <b>Parameters:</b>
       1.  The first argument (-name) is optional.  You can give the button a name if you have several sub-
           mission buttons in your form and you want to distinguish between them.

       2.  The second argument (-value) is also optional.  This gives the button a value that will be passed
           to your script in the query string. The name will also be used as the user-visible label.

       3.  You can use -label as an alias for -value.  I always get confused about which of -name and -value
           changes the user-visible label on the button.

       You can figure out which button was pressed by using different values for each one:

            $which_one = param('button_name');

       <b>CREATING</b> <b>A</b> <b>RESET</b> <b>BUTTON</b>

          print reset

       <u>reset()</u> creates the "reset" button.  Note that it restores the form to its value from the last time
       the script was called, NOT necessarily to the defaults.

       Note that this conflicts with the Perl <u>reset()</u> built-in.  Use <u>CORE::reset()</u> to get the original reset
       function.

       <b>CREATING</b> <b>A</b> <b>DEFAULT</b> <b>BUTTON</b>

          print defaults('button_label')

       <u>defaults()</u> creates a button that, when invoked, will cause the form to be completely reset to its
       defaults, wiping out all the changes the user ever made.

       <b>CREATING</b> <b>A</b> <b>HIDDEN</b> <b>FIELD</b>

               print hidden(-name=&gt;'hidden_name',
                                    -default=&gt;['value1','value2'...]);

                       -or-

               print hidden('hidden_name','value1','value2'...);

       <u>hidden()</u> produces a text field that can't be seen by the user.  It is useful for passing state vari-
       able information from one invocation of the script to the next.

       <b>Parameters:</b>
       1.  The first argument is required and specifies the name of this field (-name).

       2.  The second argument is also required and specifies its value (-default).  In the named parameter
           style of calling, you can provide a single value here or a reference to a whole list

       Fetch the value of a hidden field this way:

            $hidden_value = param('hidden_name');

       Note, that just like all the other form elements, the value of a hidden field is "sticky".  If you
       want to replace a hidden field with some other values after the script has been called once you'll
       have to do it manually:

            param('hidden_name','new','values','here');

       <b>CREATING</b> <b>A</b> <b>CLICKABLE</b> <b>IMAGE</b> <b>BUTTON</b>

            print image_button(-name=&gt;'button_name',
                                       -src=&gt;'/source/URL',
                                       -align=&gt;'MIDDLE');

               -or-

            print image_button('button_name','/source/URL','MIDDLE');

       <u>image</u><b>_</b><u>button()</u> produces a clickable image.  When it's clicked on the position of the click is
       returned to your script as "button_name.x" and "button_name.y", where "button_name" is the name
       you've assigned to it.

       <b>Parameters:</b>
       1.  The first argument (-name) is required and specifies the name of this field.

       2.  The second argument (-src) is also required and specifies the URL

       3. The third option (-align, optional) is an alignment type, and may be TOP, BOTTOM or MIDDLE

       Fetch the value of the button this way:
            $x = param('button_name.x');
            $y = param('button_name.y');

       <b>CREATING</b> <b>A</b> <b>JAVASCRIPT</b> <b>ACTION</b> <b>BUTTON</b>

            print button(-name=&gt;'button_name',
                                 -value=&gt;'user visible label',
                                 -onClick=&gt;"do_something()");

               -or-

            print button('button_name',"do_something()");

       <u>button()</u> produces a button that is compatible with Netscape 2.0's JavaScript.  When it's pressed the
       fragment of JavaScript code pointed to by the <b>-onClick</b> parameter will be executed.  On non-Netscape
       browsers this form element will probably not even display.

<b>HTTP</b> <b>COOKIES</b>
       Netscape browsers versions 1.1 and higher, and all versions of Internet Explorer, support a so-called
       "cookie" designed to help maintain state within a browser session.  CGI.pm has several methods that
       support cookies.

       A cookie is a name=value pair much like the named parameters in a CGI query string.  CGI scripts cre-
       ate one or more cookies and send them to the browser in the HTTP header.  The browser maintains a
       list of cookies that belong to a particular Web server, and returns them to the CGI script during
       subsequent interactions.

       In addition to the required name=value pair, each cookie has several optional attributes:

       1. an expiration time
           This is a time/date string (in a special GMT format) that indicates when a cookie expires.  The
           cookie will be saved and returned to your script until this expiration date is reached if the
           user exits the browser and restarts it.  If an expiration date isn't specified, the cookie will
           remain active until the user quits the browser.

       2. a domain
           This is a partial or complete domain name for which the cookie is valid.  The browser will return
           the cookie to any host that matches the partial domain name.  For example, if you specify a
           domain name of ".capricorn.com", then the browser will return the cookie to Web servers running
           on any of the machines "www.capricorn.com", "www2.capricorn.com", "feckless.capricorn.com", etc.
           Domain names must contain at least two periods to prevent attempts to match on top level domains
           like ".edu".  If no domain is specified, then the browser will only return the cookie to servers
           on the host the cookie originated from.

       3. a path
           If you provide a cookie path attribute, the browser will check it against your script's URL
           before returning the cookie.  For example, if you specify the path "/cgi-bin", then the cookie
           will be returned to each of the scripts "/cgi-bin/tally.pl", "/cgi-bin/order.pl", and
           "/cgi-bin/customer_service/complain.pl", but not to the script "/cgi-private/site_admin.pl".  By
           default, path is set to "/", which causes the cookie to be sent to any CGI script on your site.

       4. a "secure" flag
           If the "secure" attribute is set, the cookie will only be sent to your script if the CGI request
           is occurring on a secure channel, such as SSL.

       The interface to HTTP cookies is the <u></u><b><u>c</u></b><u></u><b><u>o</u></b><u></u><b><u>i</u></b><u></u><b><u>(</u></b> method:

           $cookie = cookie(-name=&gt;'sessionID',
                                    -value=&gt;'xyzzy',
                                    -expires=&gt;'+1h',
                                    -path=&gt;'/cgi-bin/database',
                                    -domain=&gt;'.capricorn.org',
                                    -secure=&gt;1);
           print header(-cookie=&gt;$cookie);

       <u></u><b><u>c</u></b><u></u><b><u>o</u></b><u></u><b><u>i</u></b><u></u><b><u>(</u></b> creates a new cookie.  Its parameters include:

       <b>-name</b>
           The name of the cookie (required).  This can be any string at all.  Although browsers limit their
           cookie names to non-whitespace alphanumeric characters, CGI.pm removes this restriction by escap-
           ing and unescaping cookies behind the scenes.

       <b>-value</b>
           The value of the cookie.  This can be any scalar value, array reference, or even associative
           array reference.  For example, you can store an entire associative array into a cookie this way:

                   $cookie=cookie(-name=&gt;'family information',
                                          -value=&gt;\%childrens_ages);

       <b>-path</b>
           The optional partial path for which this cookie will be valid, as described above.

       <b>-domain</b>
           The optional partial domain for which this cookie will be valid, as described above.

       <b>-expires</b>
           The optional expiration date for this cookie.  The format is as described in the section on the
           <u></u><b><u>h</u></b><u></u><b><u>a</u></b><u></u><b><u>e</u></b><u></u><b><u>(</u></b> method:

                   "+1h"  one hour from now

       <b>-secure</b>
           If set to true, this cookie will only be used within a secure SSL session.

       The cookie created by <u>cookie()</u> must be incorporated into the HTTP header within the string returned
       by the <u>header()</u> method:

               print header(-cookie=&gt;$my_cookie);

       To create multiple cookies, give <u>header()</u> an array reference:

               $cookie1 = cookie(-name=&gt;'riddle_name',
                                         -value=&gt;"The Sphynx's Question");
               $cookie2 = cookie(-name=&gt;'answers',
                                         -value=&gt;\%answers);
               print header(-cookie=&gt;[$cookie1,$cookie2]);

       To retrieve a cookie, request it by name by calling <u>cookie()</u> method without the <b>-value</b> parameter:

               use CGI;
               $query = new CGI;
               $riddle = cookie('riddle_name');
               %answers = cookie('answers');

       Cookies created with a single scalar value, such as the "riddle_name" cookie, will be returned in
       that form.  Cookies with array and hash values can also be retrieved.

       The cookie and CGI namespaces are separate.  If you have a parameter named 'answers' and a cookie
       named 'answers', the values retrieved by <u>param()</u> and <u>cookie()</u> are independent of each other.  How-
       ever, it's simple to turn a CGI parameter into a cookie, and vice-versa:

          # turn a CGI parameter into a cookie
          $c=cookie(-name=&gt;'answers',-value=&gt;[param('answers')]);
          # vice-versa
          param(-name=&gt;'answers',-value=&gt;[cookie('answers')]);

       See the <b>cookie.cgi</b> example script for some ideas on how to use cookies effectively.

<b>WORKING</b> <b>WITH</b> <b>FRAMES</b>
       It's possible for CGI.pm scripts to write into several browser panels and windows using the HTML 4
       frame mechanism.  There are three techniques for defining new frames programmatically:

       1. Create a &lt;Frameset&gt; document
           After writing out the HTTP header, instead of creating a standard HTML document using the
           <u>start</u><b>_</b><u>html()</u> call, create a &lt;frameset&gt; document that defines the frames on the page.  Specify
           your <!-- a -->script(s)<!-- /a --> (with appropriate parameters) as the SRC for each of the frames.

           There is no specific support for creating &lt;frameset&gt; sections in CGI.pm, but the HTML is very
           simple to write.  See the frame documentation in Netscape's home pages for details

             <a href="http://home.netscape.com/assist/net_sites/frames.html">http://home.netscape.com/assist/net_sites/frames.html</a>

       2. Specify the destination for the document in the HTTP header
           You may provide a <b>-target</b> parameter to the <u>header()</u> method:

               print header(-target=&gt;'ResultsWindow');

           This will tell the browser to load the output of your script into the frame named "ResultsWin-
           dow".  If a frame of that name doesn't already exist, the browser will pop up a new window and
           load your script's document into that.  There are a number of magic names that you can use for
           targets.  See the frame documents on Netscape's home pages for details.

       3. Specify the destination for the document in the &lt;form&gt; tag
           You can specify the frame to load in the FORM tag itself.  With CGI.pm it looks like this:

               print start_form(-target=&gt;'ResultsWindow');

           When your script is reinvoked by the form, its output will be loaded into the frame named
           "ResultsWindow".  If one doesn't already exist a new window will be created.

       The script "frameset.cgi" in the examples directory shows one way to create pages in which the fill-
       out form and the response live in side-by-side frames.

<b>SUPPORT</b> <b>FOR</b> <b>JAVASCRIPT</b>
       Netscape versions 2.0 and higher incorporate an interpreted language called JavaScript. Internet
       Explorer, 3.0 and higher, supports a closely-related dialect called JScript. JavaScript isn't the
       same as Java, and certainly isn't at all the same as Perl, which is a great pity. JavaScript allows
       you to programatically change the contents of fill-out forms, create new windows, and pop up dialog
       box from within Netscape itself. From the point of view of CGI scripting, JavaScript is quite useful
       for validating fill-out forms prior to submitting them.

       You'll need to know JavaScript in order to use it. There are many good sources in bookstores and on
       the web.

       The usual way to use JavaScript is to define a set of functions in a &lt;SCRIPT&gt; block inside the HTML
       header and then to register event handlers in the various elements of the page. Events include such
       things as the mouse passing over a form element, a button being clicked, the contents of a text field
       changing, or a form being submitted. When an event occurs that involves an element that has regis-
       tered an event handler, its associated JavaScript code gets called.

       The elements that can register event handlers include the &lt;BODY&gt; of an HTML document, hypertext
       links, all the various elements of a fill-out form, and the form itself. There are a large number of
       events, and each applies only to the elements for which it is relevant. Here is a partial list:

       <b>onLoad</b>
           The browser is loading the current document. Valid in:

                + The HTML &lt;BODY&gt; section only.

       <b>onUnload</b>
           The browser is closing the current page or frame. Valid for:

                + The HTML &lt;BODY&gt; section only.

       <b>onSubmit</b>
           The user has pressed the submit button of a form. This event happens just before the form is sub-
           mitted, and your function can return a value of false in order to abort the submission.  Valid
           for:

                + Forms only.

       <b>onClick</b>
           The mouse has clicked on an item in a fill-out form. Valid for:

                + Buttons (including submit, reset, and image buttons)
                + Checkboxes
                + Radio buttons

       <b>onChange</b>
           The user has changed the contents of a field. Valid for:

                + Text fields
                + Text areas
                + Password fields
                + File fields
                + Popup Menus
                + Scrolling lists

       <b>onFocus</b>
           The user has selected a field to work with. Valid for:

                + Text fields
                + Text areas
                + Password fields
                + File fields
                + Popup Menus
                + Scrolling lists

       <b>onBlur</b>
           The user has deselected a field (gone to work somewhere else).  Valid for:

                + Text fields
                + Text areas
                + Password fields
                + File fields
                + Popup Menus
                + Scrolling lists

       <b>onSelect</b>
           The user has changed the part of a text field that is selected.  Valid for:

                + Text fields
                + Text areas
                + Password fields
                + File fields

       <b>onMouseOver</b>
           The mouse has moved over an element.

                + Text fields
                + Text areas
                + Password fields
                + File fields
                + Popup Menus
                + Scrolling lists

       <b>onMouseOut</b>
           The mouse has moved off an element.

                + Text fields
                + Text areas
                + Password fields
                + File fields
                + Popup Menus
                + Scrolling lists

       In order to register a JavaScript event handler with an HTML element, just use the event name as a
       parameter when you call the corresponding CGI method. For example, to have your <u>validateAge()</u>
       JavaScript code executed every time the textfield named "age" changes, generate the field like this:

        print textfield(-name=&gt;'age',-onChange=&gt;"validateAge(this)");

       This example assumes that you've already declared the <u>validateAge()</u> function by incorporating it into
       a &lt;SCRIPT&gt; block. The CGI.pm <u>start</u><b>_</b><u>html()</u> method provides a convenient way to create this section.

       Similarly, you can create a form that checks itself over for consistency and alerts the user if some
       essential value is missing by creating it this way:
         print startform(-onSubmit=&gt;"validateMe(this)");

       See the javascript.cgi script for a demonstration of how this all works.

<b>LIMITED</b> <b>SUPPORT</b> <b>FOR</b> <b>CASCADING</b> <b>STYLE</b> <b>SHEETS</b>
       CGI.pm has limited support for HTML3's cascading style sheets (css).  To incorporate a stylesheet
       into your document, pass the <u>start</u><b>_</b><u>html()</u> method a <b>-style</b> parameter.  The value of this parameter may
       be a scalar, in which case it is treated as the source URL for the stylesheet, or it may be a hash
       reference.  In the latter case you should provide the hash with one or more of <b>-src</b> or <b>-code</b>.  <b>-src</b>
       points to a URL where an externally-defined stylesheet can be found.  <b>-code</b> points to a scalar value
       to be incorporated into a &lt;style&gt; section.  Style definitions in <b>-code</b> override similarly-named ones
       in <b>-src</b>, hence the name "cascading."

       You may also specify the type of the stylesheet by adding the optional <b>-type</b> parameter to the hash
       pointed to by <b>-style</b>.  If not specified, the style defaults to 'text/css'.

       To refer to a style within the body of your document, add the <b>-class</b> parameter to any HTML element:

           print h1({-class=&gt;'Fancy'},'Welcome to the Party');

       Or define styles on the fly with the <b>-style</b> parameter:

           print h1({-style=&gt;'Color: red;'},'Welcome to Hell');

       You may also use the new <u></u><b><u>s</u></b><u></u><b><u>a</u></b><u></u><b><u>(</u></b> element to apply a style to a section of text:

           print span({-style=&gt;'Color: red;'},
                      h1('Welcome to Hell'),
                      "Where did that handbasket get to?"
                      );

       Note that you must import the ":html3" definitions to have the <u></u><b><u>s</u></b><u></u><b><u>a</u></b><u></u><b><u>(</u></b> method available.  Here's a
       quick and dirty example of using CSS's.  See the CSS specification at
       <a href="http://www.w3.org/pub/WWW/TR/Wd-css-1.html">http://www.w3.org/pub/WWW/TR/Wd-css-1.html</a> for more information.

           use CGI qw/:standard :html3/;

           #here's a stylesheet incorporated directly into the page
           $newStyle=&lt;&lt;END;
           &lt;!--
           P.Tip {
               margin-right: 50pt;
               margin-left: 50pt;
               color: red;
           }
           P.Alert {
               font-size: 30pt;
               font-family: sans-serif;
             color: red;
           }
           --&gt;
           END
           print header();
           print start_html( -title=&gt;'CGI with Style',
                             -style=&gt;{-src=&gt;'<a href="http://www.capricorn.com/style/st1.css">http://www.capricorn.com/style/st1.css</a>',
                                      -code=&gt;$newStyle}
                            );
           print h1('CGI with Style'),
                 p({-class=&gt;'Tip'},
                   "Better read the cascading style sheet spec before playing with this!"),
                 span({-style=&gt;'color: magenta'},
                      "Look Mom, no hands!",
                      p(),
                      "Whooo wee!"
                      );
           print end_html;

       Pass an array reference to <b>-code</b> or <b>-src</b> in order to incorporate multiple stylesheets into your docu-
       ment.

       Should you wish to incorporate a verbatim stylesheet that includes arbitrary formatting in the
       header, you may pass a -verbatim tag to the -style hash, as follows:

       print start_html (-STYLE  =&gt;  {-verbatim =&gt; '@import url("/server-common/css/'.$cssFile.'");',
                             -src      =&gt;  '/server-common/css/core.css'}); &lt;/blockquote&gt;&lt;/pre&gt;

       This will generate an HTML header that contains this:

        &lt;link rel="stylesheet" type="text/css"  href="/server-common/css/core.css"&gt;
          &lt;style type="text/css"&gt;
          @import url("/server-common/css/main.css");
          &lt;/style&gt;

       Any additional arguments passed in the -style value will be incorporated into the &lt;link&gt; tag.  For
       example:

        start_html(-style=&gt;{-src=&gt;['/styles/print.css','/styles/layout.css'],
                                 -media =&gt; 'all'});

       This will give:

        &lt;link rel="stylesheet" type="text/css" href="/styles/print.css" media="all"/&gt;
        &lt;link rel="stylesheet" type="text/css" href="/styles/layout.css" media="all"/&gt;

       &lt;p&gt;

       To make more complicated &lt;link&gt; tags, use the <u>Link()</u> function and pass it to <u>start</u><b>_</b><u>html()</u> in the
       -head argument, as in:

         @h = (Link({-rel=&gt;'stylesheet',-type=&gt;'text/css',-src=&gt;'/ss/ss.css',-media=&gt;'all'}),
               Link({-rel=&gt;'stylesheet',-type=&gt;'text/css',-src=&gt;'/ss/fred.css',-media=&gt;'paper'}));
         print start_html({-head=&gt;\@h})

<b>DEBUGGING</b>
       If you are running the script from the command line or in the perl debugger, you can pass the script
       a list of keywords or parameter=value pairs on the command line or from standard input (you don't
       have to worry about tricking your script into reading from environment variables).  You can pass key-
       words like this:

           your_script.pl keyword1 keyword2 keyword3

       or this:

          your_script.pl keyword1+keyword2+keyword3

       or this:

           your_script.pl name1=value1 name2=value2

       or this:

           your_script.pl name1=value1&amp;name2=value2

       To turn off this feature, use the -no_debug pragma.

       To test the POST method, you may enable full debugging with the -debug pragma.  This will allow you
       to feed newline-delimited name=value pairs to the script on standard input.

       When debugging, you can use quotes and backslashes to escape characters in the familiar shell manner,
       letting you place spaces and other funny characters in your parameter=value pairs:

          your_script.pl "name1='I am a long value'" "name2=two\ words"

       Finally, you can set the path info for the script by prefixing the first name/value parameter with
       the path followed by a question mark (?):

           your_script.pl /your/path/here?name1=value1&amp;name2=value2

       <b>DUMPING</b> <b>OUT</b> <b>ALL</b> <b>THE</b> <b>NAME/VALUE</b> <b>PAIRS</b>

       The <u>Dump()</u> method produces a string consisting of all the query's name/value pairs formatted nicely
       as a nested list.  This is useful for debugging purposes:

           print Dump

       Produces something that looks like:

           &lt;ul&gt;
           &lt;li&gt;name1
               &lt;ul&gt;
               &lt;li&gt;value1
               &lt;li&gt;value2
               &lt;/ul&gt;
           &lt;li&gt;name2
               &lt;ul&gt;
               &lt;li&gt;value1
               &lt;/ul&gt;
           &lt;/ul&gt;

       As a shortcut, you can interpolate the entire CGI object into a string and it will be replaced with
       the a nice HTML dump shown above:

           $query=new CGI;
           print "&lt;h2&gt;Current Values&lt;/h2&gt; $query\n";

<b>FETCHING</b> <b>ENVIRONMENT</b> <b>VARIABLES</b>
       Some of the more useful environment variables can be fetched through this interface.  The methods are
       as follows:

       <u></u><b><u>A</u></b><u></u><b><u>c</u></b><u></u><b><u>p</u></b><u></u><b><u>(</u></b>
           Return a list of MIME types that the remote browser accepts. If you give this method a single
           argument corresponding to a MIME type, as in Accept('text/html'), it will return a floating point
           value corresponding to the browser's preference for this type from 0.0 (don't want) to 1.0.  Glob
           types (e.g. text/*) in the browser's accept list are handled correctly.

           Note that the capitalization changed between version 2.43 and 2.44 in order to avoid conflict
           with Perl's <u>accept()</u> function.

       <u></u><b><u>r</u></b><u></u><b><u>w</u></b><b>_</b><u></u><b><u>c</u></b><u></u><b><u>o</u></b><u></u><b><u>i</u></b><u></u><b><u>(</u></b>
           Returns the HTTP_COOKIE variable, an HTTP extension implemented by Netscape browsers version 1.1
           and higher, and all versions of Internet Explorer.  Cookies have a special format, and this
           method call just returns the raw form (?cookie dough).  See <u>cookie()</u> for ways of setting and
           retrieving cooked cookies.

           Called with no parameters, <u>raw</u><b>_</b><u>cookie()</u> returns the packed cookie structure.  You can separate it
           into individual cookies by splitting on the character sequence "; ".  Called with the name of a
           cookie, retrieves the <b>unescaped</b> form of the cookie.  You can use the regular <u>cookie()</u> method to
           get the names, or use the <u>raw</u><b>_</b><u>fetch()</u> method from the CGI::Cookie module.

       <u></u><b><u>u</u></b><u></u><b><u>e</u></b><b>_</b><u></u><b><u>a</u></b><u></u><b><u>e</u></b><u></u><b><u>t</u></b><u></u><b><u>)</u></b>
           Returns the HTTP_USER_AGENT variable.  If you give this method a single argument, it will attempt
           to pattern match on it, allowing you to do something like user_agent(netscape);

       <u></u><b><u>p</u></b><u></u><b><u>t</u></b><b>_</b><u></u><b><u>i</u></b><u></u><b><u>f</u></b><u></u><b><u>(</u></b>
           Returns additional path information from the script URL.  E.G. fetching
           /cgi-bin/your_script/additional/stuff will result in <u>path</u><b>_</b><u>info()</u> returning "/additional/stuff".

           NOTE: The Microsoft Internet Information Server is broken with respect to additional path infor-
           mation.  If you use the Perl DLL library, the IIS server will attempt to execute the additional
           path information as a Perl script.  If you use the ordinary file associations mapping, the path
           information will be present in the environment, but incorrect.  The best thing to do is to avoid
           using additional path information in CGI scripts destined for use with IIS.

       <u></u><b><u>p</u></b><u></u><b><u>t</u></b><b>_</b><u></u><b><u>t</u></b><u></u><b><u>a</u></b><u></u><b><u>s</u></b><u></u><b><u>a</u></b><u></u><b><u>e</u></b><u></u><b><u>(</u></b>
           As per <u>path</u><b>_</b><u>info()</u> but returns the additional path information translated into a physical path,
           e.g.  "/usr/local/etc/httpd/htdocs/additional/stuff".

           The Microsoft IIS is broken with respect to the translated path as well.

       <u></u><b><u>r</u></b><u></u><b><u>m</u></b><u></u><b><u>t</u></b><b>_</b><u></u><b><u>h</u></b><u></u><b><u>s</u></b><u></u><b><u>(</u></b>
           Returns either the remote host name or IP address.  if the former is unavailable.

       <u></u><b><u>s</u></b><u></u><b><u>r</u></b><u></u><b><u>p</u></b><b>_</b><u></u><b><u>n</u></b><u></u><b><u>m</u></b><u></u><b><u>(</u></b> Return the script name as a partial URL, for self-refering scripts.
       <u></u><b><u>r</u></b><u></u><b><u>f</u></b><u></u><b><u>r</u></b><u></u><b><u>r</u></b><u></u><b><u>)</u></b>
           Return the URL of the page the browser was viewing prior to fetching your script.  Not available
           for all browsers.

       <b>auth_type</b> <b>()</b>
           Return the authorization/verification method in use for this script, if any.

       <b>server_name</b> <b>()</b>
           Returns the name of the server, usually the machine's host name.

       <b>virtual_host</b> <b>()</b>
           When using virtual hosts, returns the name of the host that the browser attempted to contact

       <b>server_port</b> <b>()</b>
           Return the port that the server is listening on.

       <b>virtual_port</b> <b>()</b>
           Like <u>server</u><b>_</b><u>port()</u> except that it takes virtual hosts into account.  Use this when running with
           virtual hosts.

       <b>server_software</b> <b>()</b>
           Returns the server software and version number.

       <b>remote_user</b> <b>()</b>
           Return the authorization/verification name used for user verification, if this script is pro-
           tected.

       <b>user_name</b> <b>()</b>
           Attempt to obtain the remote user's name, using a variety of different techniques.  This only
           works with older browsers such as Mosaic.  Newer browsers do not report the user name for privacy
           reasons!

       <u></u><b><u>r</u></b><u></u><b><u>q</u></b><u></u><b><u>e</u></b><u></u><b><u>t</u></b><b>_</b><u></u><b><u>m</u></b><u></u><b><u>t</u></b><u></u><b><u>o</u></b><u></u><b><u>(</u></b>
           Returns the method used to access your script, usually one of 'POST', 'GET' or 'HEAD'.

       <u></u><b><u>c</u></b><u></u><b><u>n</u></b><u></u><b><u>e</u></b><u></u><b><u>t</u></b><b>_</b><u></u><b><u>t</u></b><u></u><b><u>p</u></b><u></u><b><u>(</u></b>
           Returns the content_type of data submitted in a POST, generally multipart/form-data or applica-
           tion/x-www-form-urlencoded

       <u></u><b><u>h</u></b><u></u><b><u>t</u></b><u></u><b><u>(</u></b>
           Called with no arguments returns the list of HTTP environment variables, including such things as
           HTTP_USER_AGENT, HTTP_ACCEPT_LANGUAGE, and HTTP_ACCEPT_CHARSET, corresponding to the like-named
           HTTP header fields in the request.  Called with the name of an HTTP header field, returns its
           value.  Capitalization and the use of hyphens versus underscores are not significant.

           For example, all three of these examples are equivalent:

              $requested_language = http('Accept-language');
              $requested_language = http('Accept_language');
              $requested_language = http('HTTP_ACCEPT_LANGUAGE');

       <u></u><b><u>h</u></b><u></u><b><u>t</u></b><u></u><b><u>s</u></b><u></u><b><u>)</u></b>
           The same as <u>http()</u>, but operates on the HTTPS environment variables present when the SSL protocol
           is in effect.  Can be used to determine whether SSL is turned on.

<b>USING</b> <b>NPH</b> <b>SCRIPTS</b>
       NPH, or "no-parsed-header", scripts bypass the server completely by sending the complete HTTP header
       directly to the browser.  This has slight performance benefits, but is of most use for taking advan-
       tage of HTTP extensions that are not directly supported by your server, such as server push and PICS
       headers.

       Servers use a variety of conventions for designating CGI scripts as NPH.  Many Unix servers look at
       the beginning of the script's name for the prefix "nph-".  The Macintosh WebSTAR server and
       Microsoft's Internet Information Server, in contrast, try to decide whether a program is an NPH
       script by examining the first line of script output.

       CGI.pm supports NPH scripts with a special NPH mode.  When in this mode, CGI.pm will output the nec-
       essary extra header information when the <u>header()</u> and <u>redirect()</u> methods are called.

       The Microsoft Internet Information Server requires NPH mode.  As of version 2.30, CGI.pm will auto-
       matically detect when the script is running under IIS and put itself into this mode.  You do not need
       to do this manually, although it won't hurt anything if you do.  However, note that if you have
       applied Service Pack 6, much of the functionality of NPH scripts, including the ability to redirect
       while setting a cookie, b&lt;do not work at all&gt; on IIS without a special patch from Microsoft.  See
       <a href="http://support.microsoft.com/support/kb/articles/Q280/3/41.ASP:">http://support.microsoft.com/support/kb/articles/Q280/3/41.ASP:</a> Non-Parsed Headers Stripped From CGI
       Applications That Have nph- Prefix in Name.

       In the <b>use</b> statement
           Simply add the "-nph" pragmato the list of symbols to be imported into your script:

                 use CGI qw(:standard -nph)

       By calling the <u></u><b><u>n</u></b><u></u><b><u>h</u></b><u></u><b><u>)</u></b> method:
           Call <u></u><b><u>n</u></b><u></u><b><u>h</u></b><u></u><b><u>)</u></b> with a non-zero parameter at any point after using CGI.pm in your program.

                 CGI-&gt;nph(1)

       By using <b>-nph</b> parameters
           in the <u></u><b><u>h</u></b><u></u><b><u>a</u></b><u></u><b><u>e</u></b><u></u><b><u>(</u></b> and <u></u><b><u>r</u></b><u></u><b><u>d</u></b><u></u><b><u>r</u></b><u></u><b><u>c</u></b><u></u><b><u>(</u></b>  statements:

                 print header(-nph=&gt;1);

<b>Server</b> <b>Push</b>
       CGI.pm provides four simple functions for producing multipart documents of the type needed to imple-
       ment server push.  These functions were graciously provided by Ed Jordan &lt;ed@fidalgo.net&gt;.  To import
       these into your namespace, you must import the ":push" set.  You are also advised to put the script
       into NPH mode and to set $| to 1 to avoid buffering problems.

       Here is a simple script that demonstrates server push:

         #!/usr/local/bin/perl
         use CGI qw/:push -nph/;
         $| = 1;
         print multipart_init(-boundary=&gt;'----here we go!');
         foreach (0 .. 4) {
             print multipart_start(-type=&gt;'text/plain'),
                   "The current time is ",scalar(localtime),"\n";
             if ($_ &lt; 4) {
                     print multipart_end;
             } else {
                     print multipart_final;
             }
             sleep 1;
         }

       This script initializes server push by calling <u></u><b><u>m</u></b><u></u><b><u>l</u></b><u></u><b><u>i</u></b><u></u><b><u>a</u></b><u></u><b><u>t</u></b><b>_</b><u></u><b><u>i</u></b><u></u><b><u>i</u></b><u></u><b><u>(</u></b>.  It then enters a loop in which it
       begins a new multipart section by calling <u></u><b><u>m</u></b><u></u><b><u>l</u></b><u></u><b><u>i</u></b><u></u><b><u>a</u></b><u></u><b><u>t</u></b><b>_</b><u></u><b><u>s</u></b><u></u><b><u>a</u></b><u></u><b><u>t</u></b><u></u><b><u>)</u></b>, prints the current local time, and ends
       a multipart section with <u></u><b><u>m</u></b><u></u><b><u>l</u></b><u></u><b><u>i</u></b><u></u><b><u>a</u></b><u></u><b><u>t</u></b><b>_</b><u></u><b><u>e</u></b><u></u><b><u>d</u></b><u></u><b><u>)</u></b>.  It then sleeps a second, and begins again. On the final
       iteration, it ends the multipart section with <u></u><b><u>m</u></b><u></u><b><u>l</u></b><u></u><b><u>i</u></b><u></u><b><u>a</u></b><u></u><b><u>t</u></b><b>_</b><u></u><b><u>f</u></b><u></u><b><u>n</u></b><u></u><b><u>l</u></b><u></u><b><u>)</u></b> rather than with <u></u><b><u>m</u></b><u></u><b><u>l</u></b><u></u><b><u>i</u></b><u></u><b><u>a</u></b><u></u><b><u>t</u></b><b>_</b><u></u><b><u>e</u></b><u></u><b><u>d</u></b><u></u><b><u>)</u></b>.

       <u>multipart</u><b>_</b><u>init()</u>
             multipart_init(-boundary=&gt;$boundary);

           Initialize the multipart system.  The -boundary argument specifies what MIME boundary string to
           use to separate parts of the document.  If not provided, CGI.pm chooses a reasonable boundary for
           you.

       <u>multipart</u><b>_</b><u>start()</u>
             multipart_start(-type=&gt;$type)

           Start a new part of the multipart document using the specified MIME type.  If not specified,
           text/html is assumed.

       <u>multipart</u><b>_</b><u>end()</u>
             multipart_end()

           End a part.  You must remember to call <u>multipart</u><b>_</b><u>end()</u> once for each <u>multipart</u><b>_</b><u>start()</u>, except at
           the end of the last part of the multipart document when <u>multipart</u><b>_</b><u>final()</u> should be called
           instead of <u>multipart</u><b>_</b><u>end()</u>.

       <u>multipart</u><b>_</b><u>final()</u>
             multipart_final()

           End all parts.  You should call <u>multipart</u><b>_</b><u>final()</u> rather than <u>multipart</u><b>_</b><u>end()</u> at the end of the
           last part of the multipart document.

       Users interested in server push applications should also have a look at the CGI::Push module.

       Only Netscape Navigator supports server push.  Internet Explorer browsers do not.

<b>Avoiding</b> <b>Denial</b> <b>of</b> <b>Service</b> <b>Attacks</b>
       A potential problem with CGI.pm is that, by default, it attempts to process form POSTings no matter
       how large they are.  A wily hacker could attack your site by sending a CGI script a huge POST of many
       megabytes.  CGI.pm will attempt to read the entire POST into a variable, growing hugely in size until
       it runs out of memory.  While the script attempts to allocate the memory the system may slow down
       dramatically.  This is a form of denial of service attack.

       Another possible attack is for the remote user to force CGI.pm to accept a huge file upload.  CGI.pm
       will accept the upload and store it in a temporary directory even if your script doesn't expect to
       receive an uploaded file.  CGI.pm will delete the file automatically when it terminates, but in the
       meantime the remote user may have filled up the server's disk space, causing problems for other pro-
       grams.

       The best way to avoid denial of service attacks is to limit the amount of memory, CPU time and disk
       space that CGI scripts can use.  Some Web servers come with built-in facilities to accomplish this.
       In other cases, you can use the shell <u>limit</u> or <u>ulimit</u> commands to put ceilings on CGI resource usage.

       CGI.pm also has some simple built-in protections against denial of service attacks, but you must
       activate them before you can use them.  These take the form of two global variables in the CGI name
       space:

       <b>$CGI::POST_MAX</b>
           If set to a non-negative integer, this variable puts a ceiling on the size of POSTings, in bytes.
           If CGI.pm detects a POST that is greater than the ceiling, it will immediately exit with an error
           message.  This value will affect both ordinary POSTs and multipart POSTs, meaning that it limits
           the maximum size of file uploads as well.  You should set this to a reasonably high value, such
           as 1 megabyte.

       <b>$CGI::DISABLE_UPLOADS</b>
           If set to a non-zero value, this will disable file uploads completely.  Other fill-out form val-
           ues will work as usual.

       You can use these variables in either of two ways.

       <b>1.</b> <b>On</b> <b>a</b> <b>script-by-script</b> <b>basis</b>
           Set the variable at the top of the script, right after the "use" statement:

               use CGI qw/:standard/;
               use CGI::Carp 'fatalsToBrowser';
               $CGI::POST_MAX=1024 * 100;  # max 100K posts
               $CGI::DISABLE_UPLOADS = 1;  # no uploads

       <b>2.</b> <b>Globally</b> <b>for</b> <b>all</b> <b>scripts</b>
           Open up CGI.pm, find the definitions for $POST_MAX and $DISABLE_UPLOADS, and set them to the
           desired values.  You'll find them towards the top of the file in a subroutine named <u>initial</u>-
           <u>ize</u><b>_</b><u>globals()</u>.

       An attempt to send a POST larger than $POST_MAX bytes will cause <u>param()</u> to return an empty CGI
       parameter list.  You can test for this event by checking <u>cgi</u><b>_</b><u>error()</u>, either after you create the CGI
       object or, if you are using the function-oriented interface, call &lt;<u>param()&gt;</u> for the first time.  If
       the POST was intercepted, then <u>cgi</u><b>_</b><u>error()</u> will return the message "413 POST too large".

       This error message is actually defined by the HTTP protocol, and is designed to be returned to the
       browser as the CGI script's status
        code.  For example:

          $uploaded_file = param('upload');
          if (!$uploaded_file &amp;&amp; cgi_error()) {
             print header(-status=&gt;cgi_error());
             exit 0;
          }

       However it isn't clear that any browser currently knows what to do with this status code.  It might
       be better just to create an HTML page that warns the user of the problem.

<b>COMPATIBILITY</b> <b>WITH</b> <b>CGI-LIB.PL</b>
       To make it easier to port existing programs that use cgi-lib.pl the compatibility routine "ReadParse"
       is provided.  Porting is simple:

       OLD VERSION
           require "cgi-lib.pl";
           &amp;ReadParse;
           print "The value of the antique is $in{antique}.\n";

       NEW VERSION
           use CGI;
           <u>CGI::ReadParse()</u>;
           print "The value of the antique is $in{antique}.\n";

       CGI.pm's <u>ReadParse()</u> routine creates a tied variable named %in, which can be accessed to obtain the
       query variables.  Like ReadParse, you can also provide your own variable.  Infrequently used features
       of ReadParse, such as the creation of @in and $in variables, are not supported.

       Once you use ReadParse, you can retrieve the query object itself this way:

           $q = $in{CGI};
           print textfield(-name=&gt;'wow',
                               -value=&gt;'does this really work?');

       This allows you to start using the more interesting features of CGI.pm without rewriting your old
       scripts from scratch.

<b>AUTHOR</b> <b>INFORMATION</b>
       Copyright 1995-1998, Lincoln D. Stein.  All rights reserved.

       This library is free software; you can redistribute it and/or modify it under the same terms as Perl
       itself.

       Address bug reports and comments to: lstein@cshl.org.  When sending bug reports, please provide the
       version of CGI.pm, the version of Perl, the name and version of your Web server, and the name and
       version of the operating system you are using.  If the problem is even remotely browser dependent,
       please provide information about the affected browers as well.

<b>CREDITS</b>
       Thanks very much to:

       Matt Heffron (heffron@falstaff.css.beckman.com)
       James Taylor (james.taylor@srs.gov)
       Scott Anguish &lt;sanguish@digifix.com&gt;
       Mike Jewell (mlj3u@virginia.edu)
       Timothy Shimmin (tes@kbs.citri.edu.au)
       Joergen Haegg (jh@axis.se)
       Laurent Delfosse (delfosse@delfosse.com)
       Richard Resnick (applepi1@aol.com)
       Craig Bishop (csb@barwonwater.vic.gov.au)
       Tony Curtis (tc@vcpc.univie.ac.at)
       Tim Bunce (Tim.Bunce@ig.co.uk)
       Tom Christiansen (tchrist@convex.com)
       Andreas Koenig (k@franz.ww.TU-Berlin.DE)
       Tim MacKenzie (Tim.MacKenzie@fulcrum.com.au)
       Kevin B. Hendricks (kbhend@dogwood.tyler.wm.edu)
       Stephen Dahmen (joyfire@inxpress.net)
       Ed Jordan (ed@fidalgo.net)
       David Alan Pisoni (david@cnation.com)
       Doug MacEachern (dougm@opengroup.org)
       Robin Houston (robin@oneworld.org)
       ...and many many more...
           for suggestions and bug fixes.

<b>A</b> <b>COMPLETE</b> <b>EXAMPLE</b> <b>OF</b> <b>A</b> <b>SIMPLE</b> <b>FORM-BASED</b> <b>SCRIPT</b>
               #!/usr/local/bin/perl

               use CGI ':standard';

               print header;
               print start_html("Example CGI.pm Form");
               print "&lt;h1&gt; Example CGI.pm Form&lt;/h1&gt;\n";
               print_prompt();
               do_work();
               print_tail();
               print end_html;

               sub print_prompt {
                  print start_form;
                  print "&lt;em&gt;What's your name?&lt;/em&gt;&lt;br&gt;";
                  print textfield('name');
                  print checkbox('Not my real name');

                  print "&lt;p&gt;&lt;em&gt;Where can you find English Sparrows?&lt;/em&gt;&lt;br&gt;";
                  print checkbox_group(
                                        -name=&gt;'Sparrow locations',
                                        -values=&gt;[England,France,Spain,Asia,Hoboken],
                                        -linebreak=&gt;'yes',
                                        -defaults=&gt;[England,Asia]);

                  print "&lt;p&gt;&lt;em&gt;How far can they fly?&lt;/em&gt;&lt;br&gt;",
                       radio_group(
                               -name=&gt;'how far',
                               -values=&gt;['10 ft','1 mile','10 miles','real far'],
                               -default=&gt;'1 mile');

                  print "&lt;p&gt;&lt;em&gt;What's your favorite color?&lt;/em&gt;  ";
                  print popup_menu(-name=&gt;'Color',
                                           -values=&gt;['black','brown','red','yellow'],
                                           -default=&gt;'red');

                  print hidden('Reference','Monty Python and the Holy Grail');

                  print "&lt;p&gt;&lt;em&gt;What have you got there?&lt;/em&gt;&lt;br&gt;";
                  print scrolling_list(
                                -name=&gt;'possessions',
                                -values=&gt;['A Coconut','A Grail','An Icon',
                                          'A Sword','A Ticket'],
                                -size=&gt;5,
                                -multiple=&gt;'true');

                  print "&lt;p&gt;&lt;em&gt;Any parting comments?&lt;/em&gt;&lt;br&gt;";
                  print textarea(-name=&gt;'Comments',
                                         -rows=&gt;10,
                                         -columns=&gt;50);

                  print "&lt;p&gt;",reset;
                  print submit('Action','Shout');
                  print submit('Action','Scream');
                  print endform;
                  print "&lt;hr&gt;\n";
               }

               sub do_work {
                  my(@values,$key);

                  print "&lt;h2&gt;Here are the current settings in this form&lt;/h2&gt;";

                  foreach $key (param) {
                     print "&lt;strong&gt;$key&lt;/strong&gt; -&gt; ";
                     @values = param($key);
                     print join(", ",@values),"&lt;br&gt;\n";
                 }
               }

               sub print_tail {
                  print &lt;&lt;END;
               &lt;hr&gt;
               &lt;address&gt;Lincoln D. Stein&lt;/address&gt;&lt;br&gt;
               &lt;a href="/"&gt;Home Page&lt;/a&gt;
               END
               }

<b>BUGS</b>
       Please report them.

<b>SEE</b> <b>ALSO</b>
       CGI::Carp, CGI::Fast, CGI::Pretty



perl v5.8.8                                      2001-09-21                                         CGI(3pm)
</tt></pre>
</td></tr></table>
	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Darwin/Reference/ManPages/man3/CGI.3pm.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Darwin/Reference/ManPages/man3/CGI.3pm.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Darwin/Reference/ManPages/man3/CGI.3pm.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

</body></html>
