<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"			"http://www.w3.org/TR/REC-html40/loose.dtd"><HTML><!-- Template 01-05-01 --><HEAD><LINK REL="stylesheet" HREF="../../adcstyle.css" TYPE="text/css"><LINK REL="stylesheet" HREF="../../style.css" TYPE="text/css">   <title>Technical Note TN1147: Pending Update Perils</title>       <meta name="keywords" content="Mac OS 8 modal dialog pending update problems filter procedure">    <meta name="Description" content="Technical Note TN1147: This Technical Note discusses potentialproblems when pending update events for windows behind modaldialogs are not serviced. Technical Note demonstrates potentialproblems, and describes a solution by detailing how to writea filter procedure and drawing procedure,  which will handlethese modal dialog update problems."><meta name="categories" content="Human Interface Toolbox"><meta name="week-posted" content="Dec 28, 1998 - Jan 1, 1999"><LINK REL="stylesheet" HREF="../../css/adcstyle.css" TYPE="text/css"><script language="JavaScript" type="text/javascript" src="../../js/adc.js"></script></HEAD><BODY BGCOLOR="#FFFFFF"><a name="//apple_ref/doc/uid/DTS10002986" title="Pending Update Perils"></a><A NAME="top"></A><!-- begin_header_information --><!--#include virtual="/adcnavbar" --><p><a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../technicalnotes/index.html">Technical Notes</a> &gt; <a href="../../technicalnotes/Carbon/index.html">Carbon</a> &gt; <a href="../../technicalnotes/Carbon/idxHumanInterfaceToolbox-date.html">Human Interface Toolbox</a> &gt; </p><div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Not Recommended Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>The information in this document is <strong>Not Recommended</strong> and should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/Carbon/idxHumanInterfaceToolbox-date.html" target="_blank">Carbon > Human Interface Toolbox</a></li>
	</ul>
</div>




</div></div></div><!-- end_header_information --><!-- bottom_of_header_marker_comment --><!-- top_of_titles_marker_comment --><CENTER><table width="600" cellpadding="0" cellspacing="0" border="0">
<tr><td align="left" scope="row">
<h1>
<div id="pagehead">Technical Note TN1147</div>
<div id="pageheadsub">Pending Update Perils</div>
</h1>
</td></tr></table></CENTER><!-- bottom_of_titles_marker_comment --><CENTER><TABLE BORDER=0 CELLSPACING=1 WIDTH=600><TR><td align="left">         <!-- begin_header_box --><table width="600" cellpadding="0" cellspacing="0" border="0">     <tr><td width=300 valign="top" align=left scope="row">    <table border="0" width="300" cellpadding="0" cellspacing="0">			<tr>                        <td width=300 align=left> <img src="images/tnmenutop.gif" alt="" align="bottom" width=300 height=7></td>        </tr>        <tr bgcolor="#e6e6e6">   <td background="images/tnmenubody.gif" width=300 align=left>       <span id="menutitle">CONTENTS   <br>  <br>       </span>   </td>        </tr>        <tr bgcolor="#e6e6e6">   <td background="images/tnmenubody.gif" width=300 align=left>       <!-- begin_toc --><p id="menutext"> <a href="#Section1">Introduction</a><BR><BR><a href="#Section2">The Update and         <CODE>ModalDialog</CODE></a><BR><BR><a href="#Section3">Yuck, that's nasty!</a><BR><BR><a href="#Section4">If you do some, you have to do a little more...</a><BR><BR><a href="#Summary">Conclusion</a><BR><BR><A HREF="#References">References</A><BR><BR><A HREF="#Changes">Change History</A><BR><BR><A HREF="#Downloads">Downloadables</A></p>  <!-- end_toc --></td>        </tr>        <tr>   <td width=300 align=left scope="row">       <img src="images/tnmenubottom.gif" alt="" width=300 height=16>   </td>        </tr>    </table></td>        <td width=300 valign="top" align=left>            <!-- begin_intro_text --><P id = "introtext">This Technical Note discusses potential problems when pending update events forwindows behind modal dialogs are not serviced.</p><!-- end_intro_text --><!-- begin_date --><h3>&nbsp;Updated: [Jan 11 1999]</h3><!-- end_date --></TD>             </TR>          </TABLE> <!-- end_header_box --><BR><BR><hr width=500 align=center><BR><BR><!-- begin_content --><A NAME=Section1></A>                  <H2>Introduction</H2>                  <P>Modal dialog boxes have always caused some problems with         windows behind dialog windows. Since <CODE>ModalDialog</CODE> has its own         event loop which does not by default cooperate with your         application event loop you have always had the potential for         not knowing that updates have occurred for the other windows         in your application when you are in a <code>ModalDialog</code>         loop.</P>                  <P>If you've ever written a filter procedure for a modal         dialog, you've probably seen this for yourself. Your filter         will get a continual stream of update events. These events         are not for the dialog, but are for the window behind the         dialog, which has not been updated since the modal dialog         came up. The event has not come through your normal event         loop, and you have probably not serviced the update since         you are only concerned about events for your dialog. This         causes the update event to keep getting re-sent. The only way         for the update to be stopped is for the update region of the         affected window to be cleared by the <CODE>Begin/EndUpdate</CODE> calls         in your drawing routine (see <a href="http://developer.apple.com/documentation/mac/Toolbox/Toolbox-207.html#HEADING207-47">Handling         Update Events in Inside Macintosh:Macintosh Toolbox         Essentials</A>).</P>                  <P>This situation is exacerbated by screen savers and         Balloon Help. If a screen saver becomes active while a modal         dialog is up, or if your user has Balloon help on and part         of a window behind the dialog is obscured by a balloon, then         an update event will be generated for the window.</P>         <BR><A HREF = "#top">Back to top</A><BR>         <A NAME=Section2></A>                  <H2>The Update and         <CODE>ModalDialog</CODE></H2>                  <P>If there is an update event pending for your application,         no other applications, drivers, control panels, or anything         else, will get time.</P>                  <P>Updates pending for other applications do not generally         cause a problem (unless they too are suffering from pending         updates). They will be handled normally by the application         in the background. Updates <I>must</I> be serviced or other         processes will not get time.</P>                  <P>This is a potential Bad Thing<B>. </B>Many pieces of code         need time to keep living, to maintain network connections,         or just to look good.</P>                  <P>A simple example is the Chooser. Open the Chooser, then         launch an application that you know has a modal dialog.         Position the Chooser so you can see it, and you'll notice         that it refreshes its lists even while it's in the         background.</P>                  <P>Now make sure there is a document window open in the         frontmost application. Turn on Balloon Help from the Help         menu.</P>                  <P>Open a modal dialog in the application (the About box in         most applications will work). Now move the cursor over the         window behind the modal dialog. A balloon will appear saying         something like "This window is not active because a dialog         box is up....", and a piece of the window will be blasted by         the balloon. Now look at the Chooser. It has stopped         running. The window that got zapped by the balloon now has         an update pending for it, that update is going through the         <CODE>ModalDialog</CODE> trap, and not through the program's event loop,         so it is not being serviced. Time stops for all other         applications.</P>         <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>This <B>only</B> happens if the update is for thesame application as the dialog box. If you blast awindow in another application (like the Finder)then that update will be processed normally.</P></TD></TR></TABLE></CENTER><BR><BR><BR><A HREF = "#top">Back to top</A><BR>         <P><A NAME=Section3></A></P>                  <H2>Yuck, that's nasty!</H2>                  <P>You have two choices in your application to prevent this         from happening. The first is to have no other open windows         in your application when you open a modal dialog. Obviously,         this isn't always a realistic solution.</P>                  <P>The second, saner, solution is to provide yourself a         mechanism to refresh all your windows from within your modal         dialog.</P>                  <P>A filter procedure (described in          <a href="http://developer.apple.com/documentation/mac/Toolbox/Toolbox-385.html#HEADING385-63">         Writing an Event Filter Function for Alert and Modal Dialog Boxes in         Inside Macintosh:Macintosh Toolbox Essentials</A>) is the         proper tool to use to fix this problem. You'll need to add a         simple filter procedure to every dialog or alert you bring         up in your application. And, in most cases, it can be the         same filter for every dialog, so it's not a great deal of         extra code.</P>                  <P>However, you're going to have to do a little preparation         to do this. Your filter proc needs to have a way to call the         drawing procedure for any of your windows. There are many         ways to do this, dictated by the specific needs of your         application and your own programming style. You may want to         create a window control object that contains a pointer to         your drawing routine, you may want to include the same check         and dispatch you have in your main event loop, or use         another method which you are comfortable with.</P>                  <P>The simplest, bare bones method, would be to include a         flag for your drawing procedure in your window record         <CODE>refCon</CODE>, and have your drawing routine vector based on the         value in the <CODE>refCon</CODE>, as shown here:</P><BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>    /* Window drawing proc, defined somewhere else*/Boolean MyDrawProc(WindowPtr windowToDraw) {    Boolean returnVal;        /* switch using the value you've stored in        your window earlier. */    switch (GetWRefCon(windowToDraw)) {            /*draw my clipboard*/        case kMyClipboard:            DrawMyClip (windowToDraw);            returnVal = true;            break;            /*document content*/        case kMyDocument:            DrawMyDoc (windowToDraw);            returnVal = true;            break;            /*do nothing for anything else,            to prevent drawing window*/        default:            returnVal = false;            break;    }        /* this return value is used to tell the Dialog        Manager if you've handled the update or not when        this is called from your filter.  In normal uses        (i.e., in response to an updateEvent in your main        event loop) the boolean is unnecessary, but it        doesn't do any harm*/    return returnVal;}</pre></TD></TR></TABLE></CENTER><br><BR>                  <P>Install the flag when you create a window:</P>         <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>myWindowPtr = GetNewWindow(kMyWindowID, nil, (WindowPtr)-1);SetWRefCon(myWindowPtr, (long)myDrawingProcFlag);</pre></TD></TR></TABLE></CENTER><br><br><P>In your filter, the update handling would look something like this:</P>         <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>    /* if the update is for the dialog box, ignore    it since the regular ModalDialog will redraw    it as necessary*/if(theEventIn-&gt;what == updateEvt&amp;&amp; theEventIn-&gt;message != myDialogPtr ) {        /* go to my drawing routine, window will        be redrawn if I own it*/    return (MyDrawProc ((WindowPtr)theEventIn-&gt;message));}</pre></TD></TR></TABLE></CENTER><BR><BR><h3>In MPW Pascal:</h3>         <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>    { The function's result is used to tell the Dialog    Manager if you've handled the update or not when this    is called from your filter. In normal uses (i.e., in    response to an updateEvent in your main event loop)    the boolean is unnecessary, but it doesn't do any harm.    The window drawing procedure is defined somewhere else.}FUNCTION MyDrawProc(windowToDraw WindowPtr): BOOLEAN;BEGIN  CASE GetWRefCon(windowPtr) OF    kMyClipboard:      BEGIN        DrawMyClipboard(windowToDraw);        MyDrawProc := TRUE;      END;    kMyDocument:      BEGIN        DrawMyDocument(windowToDraw);        MyDrawProc := TRUE;      END;    OTHERWISE      MyDrawProc := FALSE;   END; {CASE}END;</pre></TD></TR></TABLE></CENTER><BR><BR>         <P>Install the flag when you create a window:</P>         <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>myWindowPtr := GetNewWindow(kMyWindowID, NIL, WindowPtr(-1));SetWRefCon(myWindowPtr, myDrawingProcFlag);</pre></TD></TR></TABLE></CENTER><BR><BR>         <P>In your filter, the update handling would look something like this:</P>         <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>   { if the update is for the dialog box, ignore    it since the regular ModalDialog function will    redraw it as necessary }FUNCTION MyFilter(currentDialog: DialogPtr;    VAR theEventIn: EventRecord;    VAR theItem: INTEGER): BOOLEAN;BEGIN    IF (theEventIn.what = updateEvt    AND theEventIn.message &lt;&gt; currentDialog) BEGIN        MyFilter := MyDrawProc(currentDialog);    END;END;</pre></TD></TR></TABLE></CENTER><BR><BR>         <BR><A HREF = "#top">Back to top</A><BR><A NAME=Section4></A>                  <H2>If you do some, you have to do a         little more...</H2>                  <P>The only downside to adding your own filter procedure to         a dialog is that the Dialog Manager then assumes that you         are handing more than just updates. Specifically, the Dialog         Manager assumes that you are handling the standard "return         key aliases to item 1" filtering. So, you need to write         keystroke handling in the filter yourself.</P>                  <P>The Dialog Manager in System 7 has some new calls you can         make to ease the load on your program in this situation.         These calls were created and tested too late in System 7's         development cycle to be documented in <I>Inside Macintosh</I>, so         they are presented in <A HREF = "tn1148.html">Technote 1148: Dialog Manager Helper Functions</A>. They allow you to         call on the services of the System to track standard         keystrokes in your dialog.</P>                  <H3>The System 6 Way</H3>                  <P>Of course, under pre-System 7 applications, you can't use         the new calls, so you have to do it yourself. Here's a         sample System 6.0.x filter proc that does roughly the same         thing that a System 7 filter will do.</P>         <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>/* Pre-system 7 dialog filter*/#define kMyButtonDelay 8    /* declared as `pascal' since it's called by the toolbox*/pascal Boolean MyFilter(DialogPtr currentDialog,        EventRecord *theEventIn,        short *theDialogItem) {    Boolean     returnVal;    long        waitTicks;    short       itemKind;    Handle      itemHandle;    Rect        itemRect;    returnVal = false;        /* myDialogPtr is defined where you created the        dialog if the update is for the dialog box,        ignore it since the regular ModalDialog function        will redraw it as necessary*/    if (theEventIn-&gt;what == updateEvt    &amp;&amp; theEventIn-&gt;message != myDialogPtr) {            /* go to my drawing routine*/        returnVal = MyDrawProc (theEventIn-&gt;message);    } else {            /* it wasn't an update, see if it was a keystroke.            Check for the return or enter key, and alias that            as item 1. I also included a check here for the            escape key aliasing as item 2, you may not want            to use that*/        if ((theEventIn-&gt;what == keyDown)        || (theEventIn-&gt;what == autoKey)) {            /* it was a key*/            switch (theEventIn-&gt;message &amp; charCodeMask) {                    /* change whatever the current item is to                    the OK item ok is #defined in Dialogs.h                    as now we need to invert the button so                    the user gets the right feedback*/                case kReturnKey:                case kEnterKey:                    *theDialogItem = ok;                        /* invert the button*/                    GetDItem (currentDialog, ok, &amp;itemKind,                        &amp;itemHandle, &amp;itemRect);                    HiliteControl ((ControlHandle)itemHandle, inButton);                        /* wait about 8 ticks so they can see it*/                    Delay (kMyButtonDelay, &amp;waitTicks);                        /* and back to normal*/                    HiliteControl ((ControlHandle)itemHandle, false);                        /* tell the Dialog Manager we handled this event*/                    returnVal = true;                    break;                    /* This filters the escape key the same                    as item 2 (the cancel button,usually )*/                case kEscKey:                        /* cancel is #defined in Dialogs.h as 2*/                    *theDialogItem = cancel;                        /* invert the button*/                    GetDItem (currentDialog, cancel, &amp;itemKind,                            &amp;itemHandle, &amp;itemRect);                    HiliteControl ((ControlHandle)itemHandle, inButton);                        /* wait about 8 ticks so they can see it*/                    Delay (kMyButtonDelay, &amp;waitTicks);                    HiliteControl ((ControlHandle)itemHandle, false);                        /* tell the Dialog Manager we handled this event*/                    returnVal = true;                    break;            }        }    }    return returnVal;}</pre></TD></TR></TABLE></CENTER><BR><BR>       <h3>MPW Pascal</h3>         <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>{ Your filter for pre-System 7 will look something like this: }FUNCTION MyFilter(currentDialog: DialogPtr; VAR theEventIn:     EventRecord; VAR theItem: INTEGER): BOOLEAN;CONST    kMyButtonDelay = 8;VAR  itemKind: INTEGER;  itemHandle: Handle;  itemRect: Rect;  savePort: GrafPtr;  waitTicks: LONGINT;BEGIN        { if the update is for the dialog box,        ignore it since the regular ModalDialog        function will redraw it as necessary }    IF (theEventIn.what = updateEvt    AND theEventIn.message &lt;&gt; currentDialog) THEN        MyFilter := MyDrawProc(theEventIn.message)    ELSE BEGIN            { it wasn't an update, see if it was a keystroke            Check for the return or enter key, and alias that            as item "ok".  I also included a check here for            the escape key aliasing as item "cancel", you            may not want to use that }        IF ((theEventIn.what = keyDown)        OR (theEventIn.what = autoKey)) THEN BEGIN             { it was a key down }            CASE CHR(BAnd(theEventIn.message, charCodeMask)) OF                kReturnKey, kEnterKey:                    BEGIN                        GetDItem(currentDialog, ok, itemKind,                                itemHandle, itemRect);                        HiliteControl(ControlHandle(itemHandle), TRUE);                            {wait about 8 ticks so they can see it}                        Delay(kMyButtonDelay , waitTicks);                            {and back to normal}                        HiliteControl(ControlHandle(itemHandle), FALSE);                            {tell the Dialog Manager we handled this event}                        MyFilter := TRUE;                    END;                kEscKey:                    BEGIN                        theItem := cancel;                        GetDItem(currentDialog, cancel, itemKind,                                itemHandle, itemRect);                        HiliteControl(ControlHandle(itemHandle), TRUE);                            {wait about 8 ticks so they can see it}                        Delay(kMyButtonDelay , waitTicks);                            {and back to normal}                        HiliteControl(ControlHandle(itemHandle), FALSE);                            {tell the Dialog Manager we handled this event}                        MyFilter := TRUE;                    END;            END; {CASE}        END;    END;END;</pre></TD></TR></TABLE></CENTER><BR><BR><BR><A HREF = "#top">Back to top</A><BR><A NAME=Summary></A>                  <H2>Summary</H2>                  <P>Never-ending updates are not a new problem. It is         imperative that you do something about never-ending updates.         There isn't much extra work involved; just add a simple         filter to all of your dialogs and alerts, and put a flag to         your drawing proc in your window structure.</P>                  <P>The results will allow the system to continue to run         smoothly, and as an added benefit your users will always see         your application's windows the way they should be, instead         of windows with chunks bitten out of them.</P>     <BR><P><A HREF="#top">Back to top</A></P><A NAME=References></A><H2>References</H2><p><a href="http://developer.apple.com/documentation/mac/Toolbox/Toolbox-28.html#HEADING28-0">InsideMacintosh:Macintosh Toolbox Essentials, Chapter 2 - EventManager</A></p>            <p><a href="http://developer.apple.com/documentation/mac/Toolbox/Toolbox-188.html#HEADING188-0">InsideMacintosh:Macintosh Toolbox Essentials, Chapter 4 -Window Manager</A></p>            <p><a href="http://developer.apple.com/documentation/mac/Toolbox/Toolbox-370.html#HEADING370-0">InsideMacintosh:Macintosh Toolbox Essentials, Chapter 6 -Dialog Manager</A></p><BR><A HREF = "#top">Back to top</A><BR><A NAME=Changes></A><H2>Change History</H2>                    <TABLE BORDER=0 CELLPADDING=3 WIDTH=544>            <TR>               <td width=100 align=left>                  <P ALIGN=center>01-October-1991</P>               </TD>               <td align="left">                  <P>Originally written as Technote TB 37.</P>               </TD>            </TR>			<TR>               <td width=100 align=left>                  <P ALIGN=center>1991 and 1999</P>               </TD>               <td align="left">                  <P>Accompanying code written and revised.</P>               </TD>            </TR>		<TR>               <td width=100 align=left>                  <P ALIGN=center>11-January-1999</P>               </TD>               <td align="left">                  <P>Updated to better organize   the ideas presented.</P>               </TD>            </TR>    </table><BR><BR><P><A HREF="#top">Back to top</A></P>        <A NAME="Downloads"></A>         <h2>Downloadables</h2>        <center><TABLE BORDER=0 CELLPADDING=3 WIDTH="600">         <TR>             <td width=50 align=left>               <P ALIGN=center><img src="images/acrobatsmall.gif" align=middle alt="Acrobat" width=22 height=23></P>            </TD>            <td align="left">               <p>Acrobat version of this Note (64K).</P>            </TD>            <td width=60 align=left>               <p><A HREF="pdf/tn1147.pdf">Download</A></P>            </TD>          </TR> </table></center><BR><BR><BR><P><A HREF="#top">Back to top</A></P></TD></TR></TABLE></CENTER><!-- end_content --><!-- begin_footer_information -->	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/technotes/tn/tn1147.html%3Fid%3DDTS10002986-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/technotes/tn/tn1147.html%3Fid%3DDTS10002986-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/technotes/tn/tn1147.html%3Fid%3DDTS10002986-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>
<!--#include virtual="/includes/footer"--><!-- end_footer_information --></BODY></HTML>