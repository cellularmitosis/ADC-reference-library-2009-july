<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>Accessing Hardware From Applications: Finding and Accessing Devices</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Finding and Accessing Devices"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP30000379" title="Finding and Accessing Devices"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../../HardwareDrivers/index.html#//apple_ref/doc/uid/TP30000440-TP40003576" target="_top">Hardware &amp; Drivers</a> &gt; <a href="../AH_Intro/AH_Intro.html#//apple_ref/doc/uid/TP40002714-BAJDAJDJ">Accessing Hardware From Applications</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../AH_Device_Access_IOKit/AH_Device_Access_IOKit.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../AH_IOKitLib_API/AH_IOKitLib_API.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP30000379-BAJDAJDJ" title="Finding and Accessing Devices"></a><h1>Finding and Accessing Devices</h1><p>This chapter assumes you have an application or other user-space code that needs to access one or more specific types of device and that you:</p><ul class="ul"><li class="li"><p>Have determined that your application can’t satisfy its hardware needs with the higher-level APIs described in <span class="content_text"><a href="../AH_Other_APIs/AH_Other_APIs.html#//apple_ref/doc/uid/TP30000377-BAJDAJDJ">“Hardware-Access Options”</a></span></p></li><li class="li"><p>Are familiar with the I/O Kit summary information in <span class="content_text"><a href="../AH_Device_Access_IOKit/AH_Device_Access_IOKit.html#//apple_ref/doc/uid/TP30000378-BAJDAJDJ">“Device Access and the I/O Kit”</a></span></p></li><li class="li"><p>Want to know how to access hardware with an I/O Kit device interface or using the POSIX API</p></li></ul><p>This chapter provides a generic blueprint for accessing devices with I/O Kit device interfaces and device files. It describes several ways to find devices in the I/O Registry and how to examine each device you find. It then describes how to access a device through a device interface or a device file.</p><p>Your code will implement many of the functions discussed in this chapter because some actions, such as getting a Mach port to communicate with the I/O Kit and looking up your devices in the I/O Registry, are common to all applications that use the I/O Kit API to access hardware.</p><div class="importantbox"><a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_2" title="Important:"></a><p><strong>Important:</strong>&nbsp;Bear in mind that individual I/O Kit families are free to define access to their devices as they choose. Although your application will follow the steps this chapter outlines, some of the particulars, such as determining matching keys and values, vary by family. Be sure to consult the documentation for the device family you’ll be working with.</p><p></p></div><p>This chapter describes how to use several I/O Kit and Core Foundation functions. You can view the header file describing the I/O Kit functions in <code>/System/Library/Frameworks/IOKit.framework/Headers/IOKitLib.h</code> and the Core Foundation functions in various files in <code>/System/Library/Frameworks/CoreFoundation.framework/Headers</code>. You can also view header documentation for these files on disk in <code>/Developer/Documentation</code> or on the web in the <span class="content_text"><!--a target="_top" -->Device Drivers Reference Library<!--/a--></span>. Complete sample projects are available in <span class="content_text"><a href="../../../../../samplecode/HardwareDrivers/idxFireWire-date.html#//apple_ref/doc/uid/TP30000925-TP40003576-TP30000511" target="_top">Sample Code > Hardware &amp; Drivers</a></span> and, when you install the Developer package, in <code>/Developer/Examples/IOKit</code>.</p>
<!-- This template is being used for both PDF and HTML. -->

    
    <h4>In this section:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="AH_Finding_Devices.html#//apple_ref/doc/uid/TP30000379-TPXREF108">Finding Devices in the I/O Registry</a>
				
			<br/>
			
        
			
			
				<a href="AH_Finding_Devices.html#//apple_ref/doc/uid/TP30000379-BABECIGF">Examining Matching Objects</a>
				
			<br/>
			
        
			
			
				<a href="AH_Finding_Devices.html#//apple_ref/doc/uid/TP30000379-CJAGHJEJ">Putting It All Together: Accessing a Device</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP30000379-TPXREF108" title="Finding Devices in the I/O Registry"></a><h2>Finding Devices in the I/O Registry</h2><p>Before you can communicate with your device through a device interface or using POSIX functions, you must first find it. If your device is plugged in, it’s represented in the I/O Registry, the dynamically updated database of all I/O Kit objects that make up a running Mac OS X system.</p><p>The I/O Kit provides functions you can use to find devices matching your criteria in the I/O Registry. This section describes the device-matching process in detail, showing how to use I/O Kit functions to create matching dictionaries and look up matching devices in the I/O Registry. </p><div class="importantbox"><a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_3" title="Important:"></a><p><strong>Important:</strong>&nbsp;Be aware that device matching is a family-specific task: Some I/O Kit families define special matching protocols or particular keys and values you must use with the I/O Kit functions this section describes. Family documentation (in header files in the I/O Kit framework) or device-access documents (available in the <span class="content_text"><!--a target="_top" -->Device Drivers Reference Library<!--/a--></span>) can help you determine how to implement device matching for your particular device.</p><p></p></div><a name="//apple_ref/doc/uid/TP30000379-BAJBGGBE" title="Device Matching"></a><h3>Device Matching</h3><p><a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_103"></a>Applications that use the I/O Kit to access hardware are typically looking for a particular device, such as an ATA, USB, FireWire, or other device. In the general case, if the desired device is plugged in to a Mac OS X system, there is an object that represents it attached in the I/O Registry. The process of finding this object is called <strong>device matching</strong>.</p><p>Recall that at boot time (and whenever devices are attached or removed), the I/O Kit:</p><ul class="spaceabove"><li class="li"><p>Instantiates a nub object that represents the device</p></li><li class="li"><p>Attaches the nub to the I/O Registry</p></li><li class="li"><p>Registers the nub</p></li></ul><p>The device family publishes device properties in the nub object, which the I/O Kit uses to find a suitable driver for the device. You can view these properties with the I/O Registry Explorer application (available at <code>/Developer/Applications</code>) or on the command line with <code>ioreg</code>.</p><p>To find devices in the I/O Registry, you perform the following steps:</p><ol class="ol"><li class="li"><p>Get the I/O Kit master port to communicate with the I/O Kit.</p></li><li class="li"><p>Find the appropriate keys and values that sufficiently define the target device or set of devices.</p></li><li class="li"><p>Use the key-value pairs to create a matching dictionary.</p></li><li class="li"><p>Use the matching dictionary to look up matching devices in the I/O Registry.</p></li></ol><p>To perform these steps, you use a combination of I/O Kit and Core Foundation functions. The following sections describe each of these steps in detail.<a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_104"></a></p><a name="//apple_ref/doc/uid/TP30000379-BABGAIHF" title="Getting the I/O Kit Master Port"></a><h3>Getting the I/O Kit Master Port</h3><p><a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_105"></a>When your application uses functions that communicate directly with objects in the kernel, such as objects that represent devices, it does so through a Mach port, namely, the I/O Kit master port. Several I/O Kit functions require you to pass in an argument identifying the port you’re using. Starting with Mac OS X version 10.2, you can fulfill this requirement in either of two ways:</p><ul class="spaceabove"><li class="li"><p>You can get the I/O Kit master port from the function <code><a href="../../../../Darwin/Reference/IOKit/IOKitLib_h/index.html#//apple_ref/c/func/IOMasterPort" target="_top">IOMasterPort</a></code><a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_106"></a><a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_107"></a> and pass that port to the I/O Kit functions that require a port argument.</p></li><li class="li"><p>You can pass the constant <code><a href="../../../../Darwin/Reference/IOKit/IOKitLib_h/index.html#//apple_ref/c/data/kIOMasterPortDefault" target="_top">kIOMasterPortDefault</a></code> to all I/O Kit functions that require a port argument.</p></li></ul><p>In versions of Mac OS X prior to Mac OS X version 10.2, an application was required to use the first option and explicitly request the I/O Kit master port (you will encounter this procedure in older documentation and sample code). If you choose this method, you add code like the following to your application:</p><div class="codesample"><table><tr><td scope="row"><pre>mach_port_t myMasterPort;<span></span></pre></td></tr><tr><td scope="row"><pre>kern_return_t result;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>result = IOMasterPort(MACH_PORT_NULL, &amp;myMasterPort);<span></span></pre></td></tr></table></div><p>Then, in calls to I/O Kit functions that require a port argument, such as <code><a href="../../../../Darwin/Reference/IOKit/IOKitLib_h/index.html#//apple_ref/c/func/IOServiceGetMatchingServices" target="_top">IOServiceGetMatchingServices</a></code><a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_108"></a><a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_109"></a>, you pass in <code>myMasterPort</code>, as in this example:</p><div class="codesample"><table><tr><td scope="row"><pre>IOServiceGetMatchingServices(myMasterPort, myMatchingDictionary,<span></span></pre></td></tr><tr><td scope="row"><pre>                            &amp;myIterator);<span></span></pre></td></tr></table></div><p>When you’re completely finished with the port you received from <a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_110"></a><code><!--a-->IOMasterPort<!--/a--></code>, you should release it, using <a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_111"></a><code><!--a-->mach_port_deallocate<!--/a--></code>. Although multiple calls to <code><!--a-->IOMasterPort<!--/a--></code> will not result in leaking ports (each call to <code><!--a-->IOMasterPort<!--/a--></code> adds another send right to the port), it’s good programming practice to deallocate the port when you’re finished with it.</p><p>Starting with Mac OS X version 10.2, you can bypass this procedure entirely and use instead the convenience constant <code>kIOMasterPortDefault</code> (defined in <code>IOKitLib.h</code> in the I/O Kit framework). This means that when you call a function that requires the I/O Kit master port, such as <code><!--a-->IOServiceGetMatchingServices<!--/a--></code>, you can pass in <code>kIOMasterPortDefault</code> instead of the <code>mach_port_t</code> object you get from <code><!--a-->IOMasterPort<!--/a--></code>, as in this example:</p><div class="codesample"><table><tr><td scope="row"><pre>IOServiceGetMatchingServices(kIOMasterPortDefault, myMatchingDictionary,<span></span></pre></td></tr><tr><td scope="row"><pre>                            &amp;myIterator);<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP30000379-CJAFCEJD" title="Getting Keys and Values for a Device-Matching Dictionary"></a><h3>Getting Keys and Values for a Device-Matching Dictionary</h3><p><a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_112"></a><a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_113"></a><a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_114"></a>An application<a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_115"></a> begins device matching by creating a matching dictionary that defines which device (or set of devices) the application needs to access. A matching dictionary is a Core Foundation <code><a href="../../../../CoreFoundation/Reference/CFMutableDictionaryRef/Reference/reference.html#//apple_ref/c/tdef/CFMutableDictionaryRef" target="_top">CFMutableDictionaryRef</a></code> object, containing a set of key-value pairs that describe particular device properties.</p><p>You have a few options for obtaining keys and values for device matching:</p><ul class="spaceabove"><li class="li"><p>You can obtain matching keys from header files in <code>Kernel.framework</code> or <code>IOKit.framework</code> and you can define constants for property values.</p></li><li class="li"><p>You can examine driver personality information that is stored in on-disk drivers.</p></li><li class="li"><p>You can examine objects in the I/O Registry to obtain property information for the devices they represent.</p></li></ul><p>Each of these options is described in the following sections.</p><a name="//apple_ref/doc/uid/TP30000379-BABIEEED" title="Personality Property Keys and Values"></a><h4>Personality Property Keys and Values</h4><p><a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_116"></a>The file <code>IOKitKeys.h</code> (located in the I/O Kit framework) defines many general matching keys, some of which are shown in <span class="content_text"><a href="AH_Finding_Devices.html#//apple_ref/doc/uid/TP30000379-TPXREF104">Listing 3-1</a></span>.</p><a name="//apple_ref/doc/uid/TP30000379-TPXREF104" title="Listing 3-1Matching keys from IOKitKeys.h"></a><p class="codesample"><strong>Listing 3-1&nbsp;&nbsp;</strong>Matching keys from IOKitKeys.h</p><div class="codesample"><table><tr><td scope="row"><pre>// Keys for matching IOService properties by name<span></span></pre></td></tr><tr><td scope="row"><pre>#define kIOProviderClassKey     "IOProviderClass"<span></span></pre></td></tr><tr><td scope="row"><pre>#define kIONameMatchKey         "IONameMatch"<span></span></pre></td></tr><tr><td scope="row"><pre>#define kIOPropertyMatchKey     "IOPropertyMatch"<span></span></pre></td></tr><tr><td scope="row"><pre>#define kIOPathMatchKey         "IOPathMatch"<span></span></pre></td></tr><tr><td scope="row"><pre>#define kIOLocationMatchKey     "IOLocationMatch"<span></span></pre></td></tr><tr><td scope="row"><pre>#define kIOResourceMatchKey     "IOResourceMatch"<span></span></pre></td></tr></table></div><p><span class="content_text"><a href="AH_Finding_Devices.html#//apple_ref/doc/uid/TP30000379-TPXREF105">Figure 3-1</a></span> shows the AppleUSBComposite driver personality as it appears in I/O Registry Explorer (the AppleUSBComposite driver matches on composite-class USB devices for which there are no vendor-specific drivers). Notice that several of the keys in the AppleUSBComposite personality are defined in <code>IOKitKeys.h</code>.</p><br/><div><a name="//apple_ref/doc/uid/TP30000379-TPXREF105" title="Figure 3-1The I/O Registry Explorer application, showing various keys and values for the AppleUSBComposite driver"></a><p><strong>Figure 3-1&nbsp;&nbsp;</strong>The I/O Registry Explorer application, showing various keys and values for the AppleUSBComposite driver</p><img src = "../art/ah_usb_comp_driver_ioreg.gif" alt = "The I/O Registry Explorer application, showing various keys and values for the AppleUSBComposite driver" width="534" height="303"></div><br/><p>One key of particular importance is the <code>IOProviderClass</code><a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_117"></a> key<a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_118"></a>, which is included in all driver personalities. This key specifies the name of the nub class or nub superclass the driver attaches to. Although all device-matching dictionaries contain this key, few contain only this key because the resulting set of matching devices would be very large.</p><p><a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_119"></a>In most cases, you need to add more key-value pairs to make your matching dictionary more specific. By convention, keys for specific device properties are defined in device header files, such as <code>IOSerialKeys.h</code>, which defines property keys for serial devices, and <code><a href="../../../../Darwin/Reference/IOKit/IOHIDKeys_h/index.html#//apple_ref/doc/header/IOHIDKeys.h" target="_top">IOHIDKeys.h</a></code>, which defines property keys for HID (Human Interface Device) class devices. You can find these header files among the headers in the I/O Kit or Kernel frameworks. A partial listing of <code>IOHIDKeys.h</code> is shown in <span class="content_text"><a href="AH_Finding_Devices.html#//apple_ref/doc/uid/TP30000379-CJAHCCJF">Listing 3-2</a></span>. </p><a name="//apple_ref/doc/uid/TP30000379-CJAHCCJF" title="Listing 3-2HID class device matching keys from IOHIDKeys.h"></a><p class="codesample"><strong>Listing 3-2&nbsp;&nbsp;</strong>HID class device matching keys from IOHIDKeys.h</p><div class="codesample"><table><tr><td scope="row"><pre>#define kIOHIDDeviceKey                     "IOHIDDevice"<span></span></pre></td></tr><tr><td scope="row"><pre>#define kIOHIDTransportKey                  "Transport"<span></span></pre></td></tr><tr><td scope="row"><pre>#define kIOHIDVendorIDKey                   "VendorID"<span></span></pre></td></tr><tr><td scope="row"><pre>#define kIOHIDProductIDKey                  "ProductID"<span></span></pre></td></tr><tr><td scope="row"><pre>#define kIOHIDVersionNumberKey              "VersionNumber"<span></span></pre></td></tr><tr><td scope="row"><pre>#define kIOHIDManufacturerKey               "Manufacturer"<span></span></pre></td></tr><tr><td scope="row"><pre>#define kIOHIDProductKey                    "Product"<span></span></pre></td></tr><tr><td scope="row"><pre>#define kIOHIDSerialNumberKey               "SerialNumber"<span></span></pre></td></tr><tr><td scope="row"><pre>#define kIOHIDLocationIDKey                 "LocationID"<span></span></pre></td></tr><tr><td scope="row"><pre>#define kIOHIDPrimaryUsageKey               "PrimaryUsage"<span></span></pre></td></tr><tr><td scope="row"><pre>#define kIOHIDPrimaryUsagePageKey           "PrimaryUsagePage"<span></span></pre></td></tr></table></div><p>Your application must supply a value for each device-property key it uses in a matching dictionary. You may have access to header files that define values for these keys—for example, you may be working on an application to access a device driver supplied by your own company. If you don’t have predefined header files, you can define your own constants. For example, you can define property value constants for a device whose driver properties you have found with the I/O Registry Explorer application, as described in <span class="content_text"><a href="AH_Finding_Devices.html#//apple_ref/doc/uid/TP30000379-BABFCFBH">“Examining the I/O Registry.”</a></span></p><p>As a further example, suppose you have examined the keys and values for the driver of type IOUSBHIDDriver, in this case a driver for a joystick, shown in <span class="content_text"><a href="AH_Finding_Devices.html#//apple_ref/doc/uid/TP30000379-CJADBIFJ">Figure 3-2</a></span>.</p><br/><div><a name="//apple_ref/doc/uid/TP30000379-CJADBIFJ" title="Figure 3-2Some keys and values for a HID class device, shown in I/O Registry Explorer"></a><p><strong>Figure 3-2&nbsp;&nbsp;</strong>Some keys and values for a HID class device, shown in I/O Registry Explorer</p><img src = "../art/ah_hid_driver_ioreg.gif" alt = "Some keys and values for a HID class device, shown iin I/O Registry Explorer" width="472" height="380"></div><br/><p>To find the device this driver supports, you set up a matching dictionary to look up all HID class devices, using the <code>kIOHIDDeviceKey</code> (shown in <span class="content_text"><a href="AH_Finding_Devices.html#//apple_ref/doc/uid/TP30000379-CJAHCCJF">Listing 3-2</a></span>). Then, you can narrow the search to HID class devices on the USB bus by setting the transport key (identified by the constant <code>kIOHIDTransportKey </code> from <code>IOHIDKeys.h</code>) to the value “USB” as defined by the following constant in your code:</p><div class="codesample"><table><tr><td scope="row"><pre>#define kMyDeviceTransportValue "USB"<span></span></pre></td></tr></table></div><p>For more detail on how to modify a matching dictionary, see <span class="content_text"><a href="AH_Finding_Devices.html#//apple_ref/doc/uid/TP30000379-BABJJEFB">“Setting Up a Matching Dictionary to Find Devices.”</a></span><a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_120"></a><a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_121"></a></p><a name="//apple_ref/doc/uid/TP30000379-BABBHAJC" title="Examining Driver Personality Information"></a><h4>Examining Driver Personality Information</h4><p><a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_122"></a><a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_123"></a><a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_124"></a>Another way to get the keys and values you need to describe a device is to examine the driver personality information in a device’s on-disk driver.</p><p>Before a device driver is loaded, it is stored on disk or in ROM as a kernel extension, or KEXT. KEXTs are usually located in <code>/System/Library/Extensions</code>. A KEXT file on disk is a bundle that contains other files and folders. Each driver KEXT includes an information property list, in XML format, typically in a file named <code>Info.plist</code>. The property list includes one or more driver personalities—dictionaries whose properties specify which devices the driver is suitable to manage.</p><p>A KEXT usually stores its <code>Info.plist</code> file<a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_125"></a> in its <code>Contents</code> directory. You can examine its property list with the Property List Editor application (which is located in <code>/Developer/Applications</code>), by displaying it in the Terminal application (using <code>more</code> or another text-display command), or by opening the property list with an application such as Xcode. <span class="content_text"><a href="AH_Finding_Devices.html#//apple_ref/doc/uid/TP30000379-BABIBIJE">Listing 3-3</a></span> shows a partial dictionary listing for the AppleFWAudio driver. It contains keys such as the class key and the provider class key, as well as values for these keys (the strings “AppleFWAudioDevice” and “IOFireWireAVCUnit,” respectively).</p><a name="//apple_ref/doc/uid/TP30000379-BABIBIJE" title="Listing 3-3A partial listing of the personality dictionary for the AppleFWAudio driver"></a><p class="codesample"><strong>Listing 3-3&nbsp;&nbsp;</strong>A partial listing of the personality dictionary for the AppleFWAudio driver</p><div class="codesample"><table><tr><td scope="row"><pre>    &lt;key>IOKitPersonalities&lt;/key><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;dict><span></span></pre></td></tr><tr><td scope="row"><pre>        &lt;key>AppleFWAudioDevice (AVC)&lt;/key><span></span></pre></td></tr><tr><td scope="row"><pre>        &lt;dict><span></span></pre></td></tr><tr><td scope="row"><pre>            &lt;key>CFBundleIdentifier&lt;/key><span></span></pre></td></tr><tr><td scope="row"><pre>            &lt;string>com.apple.driver.AppleFWAudio&lt;/string><span></span></pre></td></tr><tr><td scope="row"><pre>            &lt;key>IOClass&lt;/key><span></span></pre></td></tr><tr><td scope="row"><pre>            &lt;string>AppleFWAudioDevice&lt;/string><span></span></pre></td></tr><tr><td scope="row"><pre>            &lt;key>IOProviderClass&lt;/key><span></span></pre></td></tr><tr><td scope="row"><pre>            &lt;string>IOFireWireAVCUnit&lt;/string><span></span></pre></td></tr><tr><td scope="row"><pre>            ...<span></span></pre></td></tr><tr><td scope="row"><pre>        &lt;/dict> ...<span></span></pre></td></tr></table></div><p>By examining a driver’s personality dictionary, your application can determine the keys and values to put in a matching dictionary to specify that driver’s device.<a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_126"></a></p><a name="//apple_ref/doc/uid/TP30000379-BABFCFBH" title="Examining the I/O Registry"></a><h4>Examining the I/O Registry</h4><p>You can examine the I/O Registry to obtain driver personality keys and values to use in a matching dictionary. When the I/O Kit loads a driver for a device, it stores a copy of the matching personality information for that device in the I/O Registry. The developer version of Mac OS X includes the I/O Registry Explorer<a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_127"></a><a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_128"></a> application, which displays the I/O Registry for your currently running system. You can see examples of I/O Registry Explorer’s display in <span class="content_text"><a href="AH_Finding_Devices.html#//apple_ref/doc/uid/TP30000379-TPXREF105">Figure 3-1</a></span> and <span class="content_text"><a href="AH_Finding_Devices.html#//apple_ref/doc/uid/TP30000379-CJADBIFJ">Figure 3-2</a></span>.</p><p>The developer version of Mac OS X also includes <code>ioreg</code><a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_129"></a>, a tool you can use to examine the I/O Registry. You run the tool in a Terminal window to display I/O Registry information for your current system. Using the application or the tool, you can examine the personality information of loaded drivers and the property information in device nubs.</p><p>If you find driver personality keys and values you want to use in your application, you may be able to obtain constants for them in Apple or third-party headers, or you may need to define your own constants. For more information, see <span class="content_text"><a href="AH_Finding_Devices.html#//apple_ref/doc/uid/TP30000379-BABIEEED">“Personality Property Keys and Values”</a></span><a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_130"></a>.<a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_131"></a><a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_132"></a><a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_133"></a></p><a name="//apple_ref/doc/uid/TP30000379-BABJJEFB" title="Setting Up a Matching Dictionary to Find Devices"></a><h3>Setting Up a Matching Dictionary to Find Devices</h3><p><a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_134"></a><a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_135"></a>When you’ve determined the keys and values that define your device, you can use that information to set up a matching dictionary to find the device in the I/O Registry. The I/O Kit provides functions that create a CFMutableDictionary object containing a specific key and the value you pass to it. Bear in mind, however, that you are not limited by the dictionaries these functions create. If you require a different or more focused search, you can modify these dictionaries or even create your own, as described later in this section.</p><p><a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_136"></a>You can use any of the following I/O Kit functions to create a matching dictionary:</p><ul class="spaceabove"><li class="li"><p><code><a href="../../../../Darwin/Reference/IOKit/IOKitLib_h/index.html#//apple_ref/c/func/IOServiceMatching" target="_top">IOServiceMatching</a></code> creates<a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_137"></a><a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_138"></a> a dictionary you can use to match on an object’s class or superclass. The dictionary that <code><!--a-->IOServiceMatching<!--/a--></code> creates consists of the <code>IOProviderClass</code> key and the value you pass to <code><!--a-->IOServiceMatching<!--/a--></code>.</p><p>You can initiate a very broad search of the I/O Registry by using <code><!--a-->IOServiceMatching<!--/a--></code> to create a dictionary that matches on a specific object class (and its subclasses). For example, you can create a dictionary to match on all objects of class IOUSBDevice by using code like the following:</p><div class="codesample"><table><tr><td scope="row"><pre>CFMutableDictionaryRef myUSBMatchDictionary = NULL;<span></span></pre></td></tr><tr><td scope="row"><pre>myUSBMatchDictionary = IOServiceMatching(kIOUSBDeviceName);<span></span></pre></td></tr></table></div></li><li class="li"><p><code><a href="../../../../Darwin/Reference/IOKit/IOKitLib_h/index.html#//apple_ref/c/func/IOServiceNameMatching" target="_top">IOServiceNameMatching</a></code> creates<a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_139"></a><a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_140"></a> a dictionary that consists of the key <code>IONameMatch</code> and the value you pass to the function.</p><p>You might use <code><!--a-->IOServiceNameMatching<!--/a--></code> to create a dictionary that matches on a device’s name, rather that its class, perhaps if your company’s device has a unique name. For example:</p><div class="codesample"><table><tr><td scope="row"><pre>CFMutableDictionaryRef myCompanyDeviceMatchDictionary = NULL;<span></span></pre></td></tr><tr><td scope="row"><pre>myCompanyDeviceMatchDictionary = IOServiceNameMatching("MyCompany");<span></span></pre></td></tr></table></div></li><li class="li"><p><code><a href="../../../../Darwin/Reference/IOKit/IOKitLib_h/index.html#//apple_ref/c/func/IOBSDNameMatching" target="_top">IOBSDNameMatching</a></code> creates<a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_141"></a><a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_142"></a> a dictionary you can use to find devices that have device-file representations in the BSD layer, such as storage devices. The dictionary the <code><!--a-->IOBSDNameMatching<!--/a--></code> function creates consists of the <code>kIOBSDNameMatching</code> key (defined in <code><a href="../../../../Darwin/Reference/IOKit/IOKitServer_h/index.html#//apple_ref/doc/header/IOKitServer.h" target="_top">IOKitServer.h</a></code>) and the name of the device file you pass to the function.</p><p>If you’ve determined the device-file name of your device (by, for example, looking in the <code>/dev</code> directory using the Terminal application), you can create a dictionary to match on it using the <code><!--a-->IOBSDNameMatching<!--/a--></code> function, using code like the following:</p><div class="codesample"><table><tr><td scope="row"><pre>CFMutableDictionaryRef myBSDMatchDictionary = NULL;<span></span></pre></td></tr><tr><td scope="row"><pre>myBSDMatchDictionary = IOBSDNameMatching(kIOMasterPortDefault, 0,<span></span></pre></td></tr><tr><td scope="row"><pre>                            "disk1s8");<span></span></pre></td></tr></table></div><p>Note that <code><!--a-->IOBSDNameMatching<!--/a--></code> expects only the device-file name in the last parameter, not the complete path.</p><p>It’s possible for a storage device to receive a different device-file name each time the I/O Kit discovers it, however, so your code should not rely on a device-file name remaining unchanged.</p></li></ul><p>You use the dictionaries these I/O Kit functions create to pass to one of the I/O Kit look-up functions (described in <span class="content_text"><a href="AH_Finding_Devices.html#//apple_ref/doc/uid/TP30000379-BABEEBCJ">“Looking Up Devices in the I/O Registry”</a></span>). The I/O Kit look-up functions each consume one reference<a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_143"></a> to the dictionary. If you use the dictionary in some other way, however, you must use <code><a href="../../../../CoreFoundation/Reference/CFTypeRef/Reference/reference.html#//apple_ref/doc/c_ref/CFRelease" target="_top">CFRelease</a></code><a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_144"></a><a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_145"></a> to release it when you’re finished.</p><p>The I/O Kit dictionary-creation functions each create a dictionary with a single key-value pair. Unless you’re looking for a device that is sufficiently described by such a key-value pair, you probably want to either modify one of these dictionaries or create your own.<a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_146"></a></p><div class="importantbox"><a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_4" title="Important:"></a><p><strong>Important:</strong>&nbsp;Because <code>CFMutableDictionary</code> is a standard Core Foundation data type, you can use Core Foundation functions to modify a matching dictionary or to create your own from scratch. For more information on Core Foundation collection objects, such as dictionaries, see the <span class="content_text"><a href="../../../../../referencelibrary/CoreFoundation/index.html#//apple_ref/doc/uid/TP30000943-TP30000421" target="_top">Core Foundation Reference Library</a></span>.</p><p></p></div><p><a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_147"></a>Many I/O Kit families define matching rules that help you narrow down your search. The USB family, for example, bases its matching rules on the USB Common Class specification. Before you modify an existing dictionary or create one of your own, you should become thoroughly familiar with your device family’s matching rules. This is especially important when you use your matching dictionary to search the I/O Registry. The I/O Kit look-up functions apply family-defined matching rules so it is essential for your matching dictionary to contain the correct combination of properties.</p><p>To modify an existing dictionary, you get a generic dictionary, such as one created by <code><!--a-->IOServiceMatching<!--/a--></code>, and use the Core Foundation function <code><a href="../../../../CoreFoundation/Reference/CFMutableDictionaryRef/Reference/reference.html#//apple_ref/c/func/CFDictionaryAddValue" target="_top">CFDictionaryAddValue</a></code><a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_148"></a><a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_149"></a> to add other key-value pairs. For example, to find a FireWire unit, you can call <code><!--a-->IOServiceMatching<!--/a--></code> to create a dictionary containing the key <code>IOProviderClass</code> and the value <code>IOFireWireUnit</code>. Then, a call to <code><a href="../../../../CoreFoundation/Reference/CFMutableDictionaryRef/Reference/reference.html#//apple_ref/doc/c_ref/CFDictionaryAddValue" target="_top">CFDictionaryAddValue</a></code> modifies the dictionary by adding the IOFireWire family–defined key <code>Unit_SW_Version</code> and the application-defined value <code>myFireWireUnitSWVersionID</code>. <span class="content_text"><a href="AH_Finding_Devices.html#//apple_ref/doc/uid/TP30000379-BABCEBBJ">Listing 3-4</a></span> shows how to do this.</p><a name="//apple_ref/doc/uid/TP30000379-BABCEBBJ" title="Listing 3-4Modifying a matching dictionary"></a><p class="codesample"><strong>Listing 3-4&nbsp;&nbsp;</strong>Modifying a matching dictionary</p><div class="codesample"><table><tr><td scope="row"><pre>CFMutableDictionaryRef  matchingDictionary =<span></span></pre></td></tr><tr><td scope="row"><pre>                                    IOServiceMatching("IOFireWireUnit" );<span></span></pre></td></tr><tr><td scope="row"><pre>UInt32 value;<span></span></pre></td></tr><tr><td scope="row"><pre>CFNumberRef cfValue;<span></span></pre></td></tr><tr><td scope="row"><pre>value = myFireWireUnitSwVersionID;<span></span></pre></td></tr><tr><td scope="row"><pre>cfValue = CFNumberCreate( kCFAllocatorDefault, kCFNumberSInt32Type, &amp;value );<span></span></pre></td></tr><tr><td scope="row"><pre>CFDictionaryAddValue( matchingDictionary, CFSTR( "Unit_SW_Version" ),<span></span></pre></td></tr><tr><td scope="row"><pre>                        cfValue);<span></span></pre></td></tr><tr><td scope="row"><pre>CFRelease( cfValue );<span></span></pre></td></tr></table></div><p>Occasionally, you may find that you must perform a look-up on a handful of properties that don’t follow any device family’s matching rules. Perhaps there are no family-defined matching rules for the device you’re interested in or you’re creating a tool to test device matching. Although you should always follow your device family’s matching rules (when they exist), you can use the special <code>IOPropertyMatch</code> key (defined in <code>IOKitKeys.h</code> in the I/O Kit framework) to create a dictionary containing a set of arbitrary matching properties. </p><p>To do this, you create two dictionaries: one that contains the set of key-value pairs that describe your device and one that contains the <code>IOPropertyMatch</code> key and your first dictionary as its value. You use the Core Foundation function <code><a href="../../../../CoreFoundation/Reference/CFMutableDictionaryRef/Reference/reference.html#//apple_ref/c/func/CFDictionaryCreateMutable" target="_top">CFDictionaryCreateMutable</a></code><a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_150"></a><a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_151"></a> to create both dictionaries. The following code fragment shows how to create the subdictionary (the dictionary containing your key-value pairs that you’ll place in your matching dictionary):</p><div class="codesample"><table><tr><td scope="row"><pre>CFMutableDictionaryRef mySubDictionary;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>mySubDictionary = CFDictionaryCreateMutable(kCFAllocatorDefault, 0,<span></span></pre></td></tr><tr><td scope="row"><pre>                    &amp;kCFTypeDictionaryKeyCallBacks,<span></span></pre></td></tr><tr><td scope="row"><pre>                    &amp;kCFTypeDictionaryValueCallBacks);<span></span></pre></td></tr><tr><td scope="row"><pre>CFDictionarySetValue(mySubDictionary, CFSTR(kMyDevicePropertyKey),<span></span></pre></td></tr><tr><td scope="row"><pre>                    CFSTR(kMyDevicePropertyValue));<span></span></pre></td></tr></table></div><p>Now you use <code><a href="../../../../CoreFoundation/Reference/CFMutableDictionaryRef/Reference/reference.html#//apple_ref/doc/c_ref/CFDictionaryCreateMutable" target="_top">CFDictionaryCreateMutable</a></code> again, this time to create your matching dictionary. The matching dictionary should contain only the key <code>IOPropertyMatch</code> and your subdictionary as its value. The <code>IOPropertyMatch</code> key signals the I/O Kit to match on the set of properties in the subdictionary without regard to any family-defined matching rules. The following code fragment shows how to create your matching dictionary:</p><div class="codesample"><table><tr><td scope="row"><pre>CFMutableDictionaryRef myMatchingDictionary;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>myMatchingDictionary = CFDictionaryCreateMutable(kCFAllocatorDefault, 0,<span></span></pre></td></tr><tr><td scope="row"><pre>                    &amp;kCFTypeDictionaryKeyCallBacks,<span></span></pre></td></tr><tr><td scope="row"><pre>                    &amp;kCFTypeDictionaryValueCallBacks);<span></span></pre></td></tr><tr><td scope="row"><pre>CFDictionarySetValue(myMatchingDictionary, CFSTR(kIOPropertyMatchKey),<span></span></pre></td></tr><tr><td scope="row"><pre>                    mySubDictionary);<span></span></pre></td></tr></table></div><p>The callback constants <code><a href="../../../../CoreFoundation/Reference/CFDictionaryRef/Reference/reference.html#//apple_ref/c/data/kCFTypeDictionaryKeyCallBacks" target="_top">kCFTypeDictionaryKeyCallBacks</a></code> and <code><a href="../../../../CoreFoundation/Reference/CFDictionaryRef/Reference/reference.html#//apple_ref/c/data/kCFTypeDictionaryValueCallBacks" target="_top">kCFTypeDictionaryValueCallBacks</a></code> define Core Foundation callback structures you can use when the keys and values in your dictionary are all CFType-derived objects. You can find documentation about these structures in the <span class="content_text"><a href="../../../../../referencelibrary/CoreFoundation/index.html#//apple_ref/doc/uid/TP30000943-TP30000421" target="_top">Core Foundation Reference Library</a></span>.</p><a name="//apple_ref/doc/uid/TP30000379-TPXREF109" title="Setting Up a Matching Dictionary to Find Device Files"></a><h3>Setting Up a Matching Dictionary to Find Device Files</h3><p><a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_152"></a><a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_153"></a>You set up a matching<a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_154"></a> dictionary to find serial or storage devices<a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_155"></a> using the same I/O Kit dictionary-creation functions you use for other types of matching dictionaries. As with other devices, the provider-class name you use to create a matching dictionary depends on the type of device you’re looking for:</p><ul class="spaceabove"><li class="li"><p>All serial devices<a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_156"></a> can be identified by the provider class IOSerialBSDClient. The <code>IOProviderClass</code> key you send to <code><!--a-->IOServiceMatching<!--/a--></code><a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_157"></a><a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_158"></a> to create a matching dictionary is <code>kIOSerialBSDServiceValue</code>, defined in <code>IOSerialKeys.h</code> in the I/O Kit framework.</p><p>Because each serial device object in the I/O Registry has a property with the key <code>kIOSerialBSDTypeKey</code>, you can refine your dictionary to match on specific types of serial devices. Currently, the possible values for this key (also defined in <code>IOSerialKeys.h</code>) are <code>kIOSerialBSDAllTypes</code>, <code>kIOSerialBSDModemType</code>, or <code>kIOSerialBSDRS232Type</code>. </p></li><li class="li"><p>Storage device<a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_159"></a> objects are members of the Storage family and their provider class is usually IOMedia, but can also depend on the device type. CD devices, for example, are subclasses of IOCDMedia. Check the Storage family header files (available in the I/O Kit framework) for the appropriate provider-class key to pass to <code><!--a-->IOServiceMatching<!--/a--></code>. </p><p>Also check the header files for additional keys and values you can use to refine your matching dictionary, such as the <code>kIOMediaEjectableKey</code>, which identifies whether the media is ejectable.</p></li></ul><p>After you’ve created a matching dictionary, you pass it to one of the I/O Kit look-up functions. If devices matching your criteria exist in the I/O Registry, the look-up function returns an iterator you can use to access each matching object.<a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_160"></a></p><a name="//apple_ref/doc/uid/TP30000379-BABEEBCJ" title="Looking Up Devices in the I/O Registry"></a><h3>Looking Up Devices in the I/O Registry</h3><p><a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_161"></a><a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_162"></a>Device look-up is<a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_163"></a> at the heart of the device-matching process: It consists of searching the I/O Registry for device objects that match the criteria specified in a matching dictionary. The I/O Kit contains a few functions that perform device look-up and provide access to objects that match your matching dictionary:</p><ul class="spaceabove"><li class="li"><p><code><a href="../../../../Darwin/Reference/IOKit/IOKitLib_h/index.html#//apple_ref/c/func/IOServiceGetMatchingServices" target="_top">IOServiceGetMatchingServices</a></code> follows<a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_164"></a><a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_165"></a> the family-defined matching rules (if any) to find registered objects that match the passed-in matching dictionary. It supplies an IOIterator<a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_166"></a><a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_167"></a> object that you can use to access the set of matching objects.</p></li><li class="li"><p><code><a href="../../../../Darwin/Reference/IOKit/IOKitLib_h/index.html#//apple_ref/c/func/IOServiceGetMatchingService" target="_top">IOServiceGetMatchingService</a></code> i<a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_168"></a>s <a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_169"></a>similar to <code><!--a-->IOServiceGetMatchingServices<!--/a--></code> except that it returns only the first IOService object that matches the passed-in matching dictionary. Because it returns the first matching IOService object itself, <code><!--a-->IOServiceGetMatchingService<!--/a--></code> does not give you an iterator that allows you to access other objects that may meet the matching criteria. You might choose to use this function if you’re reasonably certain you can create a matching dictionary that will match only on your device and you want to bypass the code that iterates over a list of matching devices.</p><p><code><!--a-->IOServiceGetMatchingService<!--/a--></code> also strictly follows the matching rules defined by the value of the passed-in <code>IOProviderClass</code> key. </p></li><li class="li"><p><code><a href="../../../../Darwin/Reference/IOKit/IOKitLib_h/index.html#//apple_ref/c/func/IOServiceAddMatchingNotification" target="_top">IOServiceAddMatchingNotification</a></code> follows the<a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_170"></a><a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_171"></a> family-defined matching rules (if any) to find objects matching the passed-in matching dictionary whose state changes in the way you identify. When a matching object’s state change matches the state change you’re interested in (such as being registered or terminated), <code><!--a-->IOServiceAddMatchingNotification<!--/a--></code> notifies the caller and provides an iterator with which to access the set of matching objects.</p><p>Your application can use <code><!--a-->IOServiceAddMatchingNotification<!--/a--></code> to receive notification of when matching devices come or go. This is particularly useful for applications that need to access hot-pluggable devices, such as FireWire or USB devices. For an outline of how to receive notifications about matching devices, see <span class="content_text"><a href="AH_Finding_Devices.html#//apple_ref/doc/uid/TP30000379-BABEACCJ">“Getting Notifications of Device Arrival and Departure.”</a></span></p></li></ul><p>The I/O Kit look-up functions each consume one reference<a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_172"></a> to the matching<a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_173"></a> dictionary you pass to them. If you need to use the dictionary again, be sure to increase its reference count by calling<a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_174"></a><code><a href="../../../../CoreFoundation/Reference/CFTypeRef/Reference/reference.html#//apple_ref/c/func/CFRetain" target="_top">CFRetain</a></code> on it before you send it to a look-up function.</p><p>If<a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_175"></a> you use a look-up function that returns an iterator<a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_176"></a> (<code><!--a-->IOServiceGetMatchingServices<!--/a--></code> or <code><!--a-->IOServiceAddMatchingNotification<!--/a--></code>), your application must release this iterator when it is finished with it. In the case of <code><!--a-->IOServiceAddMatchingNotification<!--/a--></code>, make sure you release the iterator <em>only</em> if you’re also ready to stop receiving notifications: When you release the iterator you receive from <code><!--a-->IOServiceAddMatchingNotification<!--/a--></code>, you also disable the notification. If you use <code><!--a-->IOServiceGetMatchingService<!--/a--></code>, your application is responsible for releasing the object reference it receives.</p><p>Applications typically use these look-up functions to find device nubs whose property information matches the criteria defined in the application’s matching dictionary. Occasionally, however, an application looks for a driver in the I/O Registry, instead of a nub. Your application would look for a driver, for example, if you’re writing both the application and the in-kernel driver and intend for them to work together. A key point is the distinction between drivers and nubs: Nubs are always registered in the I/O Registry (it’s the act of registration that triggers driver matching), but drivers can be attached in the I/O Registry without being registered. This is important, because the I/O Kit look-up functions find only registered objects. To find an unregistered object, you start by finding its registered provider or client and use an I/O Registry traversal function to step to the object you’re looking for.</p><p>If, for example, your application needs to access an unregistered object, you must first identify the object’s immediate parent or child, whichever is easiest to find. Let’s say you can find the registered child of the object you want: You create a matching dictionary that describes the child object and pass it to <code><!--a-->IOServiceGetMatchingServices<!--/a--></code>. You use<a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_177"></a><code><a href="../../../../Darwin/Reference/IOKit/IOKitLib_h/index.html#//apple_ref/c/func/IOIteratorNext" target="_top">IOIteratorNext</a></code> (discussed in <span class="content_text"><a href="AH_Finding_Devices.html#//apple_ref/doc/uid/TP30000379-BABECIGF">“Examining Matching Objects”</a></span>) to get access to the child object and then use the I/O Kit function <code><a href="../../../../Darwin/Reference/IOKit/IOKitLib_h/index.html#//apple_ref/c/func/IORegistryEntryGetParentEntry" target="_top">IORegistryEntryGetParentEntry</a></code><a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_178"></a><a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_179"></a> to get access to its unregistered parent object. For more information on the I/O Registry traversal functions the I/O Kit provides, see <span class="content_text"><a href="../AH_IOKitLib_API/AH_IOKitLib_API.html#//apple_ref/doc/uid/TP30000380-BAJDAJDJ">“The IOKitLib API.”</a></span><a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_180"></a><a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_181"></a><a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_182"></a><a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_183"></a><a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_184"></a><a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_185"></a><a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_186"></a><a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_187"></a></p><a name="//apple_ref/doc/uid/TP30000379-BABEACCJ" title="Getting Notifications of Device Arrival and Departure"></a><h3>Getting Notifications of Device Arrival and Departure</h3><p><a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_188"></a>If you’re working with hot-pluggable devices, such as FireWire or USB devices, you can use I/O Kit and Core Foundation functions to set up a mechanism that notifies<a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_189"></a> you when the devices you’re interested in come or go. To set up such a mechanism, follow these steps:</p><ol class="ol"><li class="li"><p>Use the <code><a href="../../../../Darwin/Reference/IOKit/IOKitLib_h/index.html#//apple_ref/c/func/IONotificationPortCreate" target="_top">IONotificationPortCreate</a></code> function<a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_190"></a><a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_191"></a> to create a notification object that can listen for I/O Kit notifications, either on a run loop or a Mach port (these steps show only the recommended run-loop approach—for a brief description of the functions you use to set up a notification mechanism with a Mach port, see <span class="content_text"><a href="../AH_IOKitLib_API/AH_IOKitLib_API.html#//apple_ref/doc/uid/TP30000380-BAJDAJDJ">“The IOKitLib API”</a></span>):</p><div class="codesample"><table><tr><td scope="row"><pre>IONotificationPortRef notificationObject;<span></span></pre></td></tr><tr><td scope="row"><pre>mach_port_t masterPort; //This is the port you received from IOMasterPort.<span></span></pre></td></tr><tr><td scope="row"><pre>        //Alternatively, you can pass kIOMasterPortDefault to the<span></span></pre></td></tr><tr><td scope="row"><pre>        //IONotificationPortCreate function.<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>notificationObject = IONotificationPortCreate(masterPort);<span></span></pre></td></tr></table></div></li><li class="li"><p>Create a run-loop source for the notification object, using the <code><a href="../../../../Darwin/Reference/IOKit/IOKitLib_h/index.html#//apple_ref/c/func/IONotificationPortGetRunLoopSource" target="_top">IONotificationPortGetRunLoopSource</a></code> function<a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_192"></a><a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_193"></a>:</p><div class="codesample"><table><tr><td scope="row"><pre>CFRunLoopSourceRef notificationRunLoopSource;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>//Use the notification object received from IONotificationPortCreate<span></span></pre></td></tr><tr><td scope="row"><pre>notificationRunLoopSource =<span></span></pre></td></tr><tr><td scope="row"><pre>            IONotificationPortGetRunLoopSource(notificationObject);<span></span></pre></td></tr></table></div></li><li class="li"><p>Add the run-loop source to your run loop (usually, your application’s current run loop), using the Core Foundation <code><a href="../../../../CoreFoundation/Reference/CFRunLoopRef/Reference/reference.html#//apple_ref/c/func/CFRunLoopAddSource" target="_top">CFRunLoopAddSource</a></code> function<a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_194"></a><a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_195"></a>:</p><div class="codesample"><table><tr><td scope="row"><pre>CFRunLoopAddSource(CFRunLoopGetCurrent(), notificationRunLoopSource,<span></span></pre></td></tr><tr><td scope="row"><pre>                    kCFRunLoopDefaultMode);<span></span></pre></td></tr></table></div></li><li class="li"><p><a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_196"></a><a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_197"></a>Call the <code><!--a-->IOServiceAddMatchingNotification<!--/a--></code> function, passing it the following arguments:</p><ul class="ul"><li class="li"><p>The notification object you received from <code><!--a-->IONotificationPortCreate<!--/a--></code></p></li><li class="li"><p>A constant defining the type of event you want notification of, such as device registration or termination (these constants are defined in <code>IOKitKeys.h</code> in the I/O Kit framework)</p></li><li class="li"><p>The Core Foundation matching dictionary you’ve created to define the types of devices you’re interested in</p></li><li class="li"><p>The function you want called when a matching device’s state changes in the way you’ve identified</p></li><li class="li"><p>An optional reference constant for your callback function’s use</p></li><li class="li"><p>An <code>io_iterator_t</code> object to access the list of matching devices</p></li></ul></li><li class="li"><p>Call <code><!--a-->IOIteratorNext<!--/a--></code> (discussed in <span class="content_text"><a href="AH_Finding_Devices.html#//apple_ref/doc/uid/TP30000379-BABECIGF">“Examining Matching Objects”</a></span>) to access the matching devices that are already present in the I/O Registry and to arm the notification mechanism so you will receive notifications of future matching devices as your run loop runs.</p></li><li class="li"><p>Call the Core Foundation <code><a href="../../../../CoreFoundation/Reference/CFRunLoopRef/Reference/reference.html#//apple_ref/c/func/CFRunLoopRun" target="_top">CFRunLoopRun</a></code><a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_198"></a><a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_199"></a> function to start the run loop and receive notifications when new matching devices arrive.<a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_200"></a></p></li></ol><a name="//apple_ref/doc/uid/TP30000379-BABECIGF" title="Examining Matching Objects"></a><h2>Examining Matching Objects</h2><p>After<a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_201"></a><a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_202"></a> you’ve successfully created a matching dictionary and passed it to one of the I/O Kit look-up functions, you receive an iterator you can use to access the list of matching objects. (Of course, if you used <code><!--a-->IOServiceGetMatchingService<!--/a--></code>, you instead receive a reference to the first matching object itself, not an iterator.) The iterator is an object of class IOIterator and this section describes how you use it to examine a set of matching objects.</p><p>When you get an iterator from <code><!--a-->IOServiceGetMatchingServices<!--/a--></code>, you pass it to the I/O Kit function<a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_203"></a><a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_204"></a><code><!--a-->IOIteratorNext<!--/a--></code>, which returns a matching object from the list. With the matching object in hand, you can directly examine the properties it publishes in the I/O Registry. You might do this to determine if an object does, in fact, represent the device you want to access or if you want to display information about the matching device to a user.</p><p>The <code><!--a-->IOIteratorNext<!--/a--></code> function<a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_205"></a> returns an object of type<a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_206"></a><code>io_object_t</code>, which the caller should release when it is finished. Each call to <code><!--a-->IOIteratorNext<!--/a--></code> returns the next object in the list of matching objects or zero if there are no more objects or if the iterator is no longer valid. If you receive zero when you think there may still be more matching objects in the list, you can call the <code><a href="../../../../Darwin/Reference/IOKit/IOKitLib_h/index.html#//apple_ref/c/func/IOIteratorIsValid" target="_top">IOIteratorIsValid</a></code> function<a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_207"></a><a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_208"></a> to make sure the iterator is still valid. In the unlikely case that the iterator is invalid, it’s usually because the I/O Registry has changed in some way. If your iterator has become invalid, the best thing to do is to call the I/O Kit function<a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_209"></a><a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_210"></a><code><a href="../../../../Darwin/Reference/IOKit/IOKitLib_h/index.html#//apple_ref/c/func/IOIteratorReset" target="_top">IOIteratorReset</a></code> and begin iterating again.</p><p>Now that you have an <code>io_object_t</code> object representing one of the matching objects in the list, you can use other I/O Kit functions to examine it more closely. For example, you can call <code><a href="../../../../Darwin/Reference/IOKit/IOKitLib_h/index.html#//apple_ref/c/func/IOObjectGetClass" target="_top">IOObjectGetClass</a></code> to<a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_211"></a><a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_212"></a> see the class name of the passed-in object. To look at a specific property, you can pass the corresponding property key to <code><a href="../../../../Darwin/Reference/IOKit/IOKitLib_h/index.html#//apple_ref/c/func/IORegistryEntryCreateCFProperty" target="_top">IORegistryEntryCreateCFProperty</a></code>, which<a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_213"></a><a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_214"></a> returns a Core Foundation representation of that property’s value. See <span class="content_text"><a href="../AH_IOKitLib_API/AH_IOKitLib_API.html#//apple_ref/doc/uid/TP30000380-BAJDAJDJ">“The IOKitLib API”</a></span> for more object-examination functions.</p><a name="//apple_ref/doc/uid/TP30000379-CJAGHJEJ" title="Putting It All Together: Accessing a Device"></a><h2>Putting It All Together: Accessing a Device</h2><p>Previous sections described how to: </p><ul class="ul"><li class="li"><p>Find keys and values that identify a device’s properties</p></li><li class="li"><p>Use the keys and values to create a matching dictionary</p></li><li class="li"><p>Use the matching dictionary to look up matching devices in the I/O Registry</p></li></ul><p>This section builds on that information to show how to get a device interface (or the pathname for a device file) and begin communicating with a device.</p><p>Let’s assume you used the <code><!--a-->IOServiceGetMatchingServices<!--/a--></code> look-up function to find matching devices. This means that you received an iterator handle you can pass to the <code><!--a-->IOIteratorNext<!--/a--></code> function to access each device object in turn. Whether you iterate over the entire list, examining each device, or just grab the first device in the list, the next step is communication with the device—a step that differs depending on whether you access the device through a device interface or a device file.</p><a name="//apple_ref/doc/uid/TP30000379-TPXREF110" title="Getting a Device Interface"></a><h3>Getting a Device Interface</h3><p><a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_215"></a>As described in <span class="content_text"><a href="../AH_Device_Access_IOKit/AH_Device_Access_IOKit.html#//apple_ref/doc/uid/TP30000378-BAJDAJDJ">“Device Access and the I/O Kit,”</a></span> many I/O Kit families supply device interfaces that provide user-space access to the devices they support. This section presents information that is appropriate for many types of device families but may vary from the specifics of any particular family.</p><p>As always, be sure to check the documentation for your device’s family before implementing the steps outlined in this section.</p><p>When you’ve determined that the <code>io_object_t</code> object you received from <code><!--a-->IOIteratorNext<!--/a--></code> represents a device you want to access, you first create an intermediate Core Foundation plug-in interface for it, using the <code><!--a-->IOCreatePlugInInterfaceForService<!--/a--></code> function<a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_216"></a><a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_217"></a> (defined in <code>IOCFPlugIn.h</code> in the I/O Kit framework). </p><p>Before you get the intermediate plug-in, however, you must know which device interface type you need to get. I/O Kit families that support device interfaces define both an interface type that represents the collection of interfaces they provide and each individual interface in the type. You can get this information from your device family’s header files. For example, <span class="content_text"><a href="AH_Finding_Devices.html#//apple_ref/doc/uid/TP30000379-BABCJHBC">Listing 3-5</a></span> shows the USB family’s definition of the <code>kIOUSBDeviceUserClientTypeID</code> (its library of device interface types) and the <code>kIOUSBDeviceInterfaceID</code> (one of the individual device interfaces it provides).</p><a name="//apple_ref/doc/uid/TP30000379-BABCJHBC" title="Listing 3-5Device interface definitions from IOUSBLib.h"></a><p class="codesample"><strong>Listing 3-5&nbsp;&nbsp;</strong>Device interface definitions from IOUSBLib.h</p><div class="codesample"><table><tr><td scope="row"><pre>#define kIOUSBDeviceUserClientTypeID CFUUIDGetConstantUUIDWithBytes(NULL,   \<span></span></pre></td></tr><tr><td scope="row"><pre>    0x9d, 0xc7, 0xb7, 0x80, 0x9e, 0xc0, 0x11, 0xD4,         \<span></span></pre></td></tr><tr><td scope="row"><pre>    0xa5, 0x4f, 0x00, 0x0a, 0x27, 0x05, 0x28, 0x61)<span></span></pre></td></tr><tr><td scope="row"><pre>...<span></span></pre></td></tr><tr><td scope="row"><pre>#define kIOUSBDeviceInterfaceID CFUUIDGetConstantUUIDWithBytes(NULL,    \<span></span></pre></td></tr><tr><td scope="row"><pre>    0x5c, 0x81, 0x87, 0xd0, 0x9e, 0xf3, 0x11, 0xD4,         \<span></span></pre></td></tr><tr><td scope="row"><pre>    0x8b, 0x45, 0x00, 0x0a, 0x27, 0x05, 0x28, 0x61)<span></span></pre></td></tr></table></div><p>To get an intermediate interface, you pass the following information to <code><!--a-->IOCreatePlugInInterfaceForService<!--/a--></code>:</p><ul class="spaceabove"><li class="li"><p>The device reference (the <code>io_object_t</code> you received from <code><!--a-->IOIteratorNext<!--/a--></code>)</p></li><li class="li"><p>The family’s library type ID (from the family’s header files)</p></li><li class="li"><p>The intermediate plug-in type (always <code>kIOCFPlugInInterfaceID</code>, defined in <code>IOCFPlugIn.h</code>)</p></li><li class="li"><p>The address of an IOCFPlugInInterface object (to contain the intermediate plug-in)</p></li><li class="li"><p>The address of an integer variable (currently unused)</p></li></ul><p><span class="content_text"><a href="AH_Finding_Devices.html#//apple_ref/doc/uid/TP30000379-BABDEIDJ">Listing 3-6</a></span> shows an application using <code><!--a-->IOCreatePlugInInterfaceForService<!--/a--></code> to get an intermediate plug-in interface for the FireWire family’s IOFireWireLib (one of the FireWire family’s device interface libraries).</p><a name="//apple_ref/doc/uid/TP30000379-BABDEIDJ" title="Listing 3-6Getting an intermediate IOCFPlugInInterface object"></a><p class="codesample"><strong>Listing 3-6&nbsp;&nbsp;</strong>Getting an intermediate IOCFPlugInInterface object</p><div class="codesample"><table><tr><td scope="row"><pre>IOCFPlugInInterface** cfPlugInInterface = 0;<span></span></pre></td></tr><tr><td scope="row"><pre>IOReturn result;<span></span></pre></td></tr><tr><td scope="row"><pre>SInt32 theScore;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>// aDevice is the io_object_t from IOIteratorNext.<span></span></pre></td></tr><tr><td scope="row"><pre>result = IOCreatePlugInInterfaceForService( aDevice, kIOFireWireLibTypeID,<span></span></pre></td></tr><tr><td scope="row"><pre>            kIOCFPlugInInterfaceID, &amp;cfPlugInInterface, &amp;theScore );<span></span></pre></td></tr></table></div><p>Now that you have an intermediate interface, you use it to get the specific type of device interface you need. Again, see your device family’s header files for the definitions of specific device interface names. To get a particular device interface, you use the <code><!--a-->QueryInterface<!--/a--></code><a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_218"></a><a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_219"></a> function of the IOCFPlugInInterface, passing it the following arguments:</p><ul class="spaceabove"><li class="li"><p>A reference to the IOCFPlugInInterface (received from the call to <code><!--a-->IOCreatePlugInInterfaceForService<!--/a--></code>)</p></li><li class="li"><p>The UUID of the device interface (you use the Core Foundation function <code><a href="../../../../CoreFoundation/Reference/CFUUIDRef/Reference/reference.html#//apple_ref/doc/c_ref/CFUUIDGetUUIDBytes" target="_top">CFUUIDGetUUIDBytes</a></code> to get the actual UUID from the family’s device interface constant)</p></li><li class="li"><p>The address of the device interface (to contain the new device interface)</p></li></ul><p><span class="content_text"><a href="AH_Finding_Devices.html#//apple_ref/doc/uid/TP30000379-BABCGEHA">Listing 3-7</a></span> shows an application using an intermediate IOCFPlugInInterface object to get the SCSI Architecture Model family’s MMC (Multimedia Commands) device interface (defined in <code>SCSITaskLib.h</code> in the I/O Kit framework).</p><a name="//apple_ref/doc/uid/TP30000379-BABCGEHA" title="Listing 3-7Getting a specific device interface object"></a><p class="codesample"><strong>Listing 3-7&nbsp;&nbsp;</strong>Getting a specific device interface object</p><div class="codesample"><table><tr><td scope="row"><pre>HRESULT herr;<span></span></pre></td></tr><tr><td scope="row"><pre>MMCDeviceInterface **mmcInterface = NULL;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>// plugInInterface is the IOCFPlugInInterface object from<span></span></pre></td></tr><tr><td scope="row"><pre>// IOCFCreatePlugInInterfaceForService.<span></span></pre></td></tr><tr><td scope="row"><pre>herr = ( *plugInInterface )->QueryInterface ( plugInInterface,<span></span></pre></td></tr><tr><td scope="row"><pre>            CFUUIDGetUUIDBytes (<span></span></pre></td></tr><tr><td scope="row"><pre>            kIOMMCDeviceInterfaceID ),<span></span></pre></td></tr><tr><td scope="row"><pre>            ( LPVOID *) &amp;mmcInterface );<span></span></pre></td></tr></table></div><p>The device interface provides you with a wide range of functions you can use to access your device. With an IOFireWireDeviceInterface object, for example, you can perform a FireWire bus reset or create FireWire command object interfaces to perform asynchronous read, write, and lock operations. When you’re finished with the device interface you acquired, you should call the IOCFPlugIn <code><!--a-->Release<!--/a--></code> function to release it.<a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_220"></a></p><p>After you are completely finished with the specific device interface object, you should get rid of the intermediate IOCFPlugInInterface object by calling the <code><!--a-->IODestroyPlugInInterface<!--/a--></code> function<a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_221"></a><a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_222"></a>, defined in <code>IOCFPlugIn.h</code>.</p><a name="//apple_ref/doc/uid/TP30000379-TPXREF111" title="Getting a Device-File Path"></a><h3>Getting a Device-File Path</h3><p><a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_223"></a>Before you can access a serial or storage device, you use I/O Kit functions to extract specific properties from the I/O Registry object that represents it and use them to create the device-file path. As described in <span class="content_text"><a href="../AH_Device_Access_IOKit/AH_Device_Access_IOKit.html#//apple_ref/doc/uid/TP30000378-TPXREF102">“Inside the Device-File Mechanism,”</a></span> device-file paths are usually of the form <code>/dev/</code><em>device_name</em>, where <em>device_name</em> is defined by the type of device. </p><div class="importantbox"><a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_5" title="Important:"></a><p><strong>Important:</strong>&nbsp;The process of getting the pathname of a serial or storage device differs slightly depending on the type of device you’re accessing, however, so be sure to read the documentation for your device type to get specific information on where the device name and path components are defined.</p><p></p></div><p><a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_224"></a><a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_225"></a>In general, you create the device-file path either by getting a C-string representation of a particular property or by concatenating strings defined in various properties or constants. To get the C-string representation for a property, you first use the I/O Kit function <code><!--a-->IORegistryEntryCreateCFProperty<!--/a--></code> to get the property value as a Core Foundation string object. <a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_226"></a><a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_227"></a>Then, you use the Core Foundation function <code><a href="../../../../CoreFoundation/Reference/CFStringRef/Reference/reference.html#//apple_ref/doc/c_ref/CFStringGetCString" target="_top">CFStringGetCString</a></code> to transform the CFString object into a C string. </p><p>For example, <span class="content_text"><a href="AH_Finding_Devices.html#//apple_ref/doc/uid/TP30000379-BABDAFHG">Listing 3-8</a></span> shows how to get the device name of a storage device from the value of the <code>kIOBSDNameKey</code> (defined in <code>IOBSD.h</code>) and use this string, along with a constant string defined in <code>paths.h</code>, to create the full device-file path.</p><a name="//apple_ref/doc/uid/TP30000379-BABDAFHG" title="Listing 3-8Getting the device name of a storage device"></a><p class="codesample"><strong>Listing 3-8&nbsp;&nbsp;</strong>Getting the device name of a storage device</p><div class="codesample"><table><tr><td scope="row"><pre>io_object_t device; //This is the object IOIteratorNext returns<span></span></pre></td></tr><tr><td scope="row"><pre>char deviceFilePath[MAXPATHLEN]; //MAXPATHLEN is defined in sys/param.h<span></span></pre></td></tr><tr><td scope="row"><pre>size_t devPathLength;<span></span></pre></td></tr><tr><td scope="row"><pre>CFTypeRef deviceNameAsCFString;<span></span></pre></td></tr><tr><td scope="row"><pre>Boolean gotString = false;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>deviceNameAsCFString = IORegistryEntryCreateCFProperty (<span></span></pre></td></tr><tr><td scope="row"><pre>            device,<span></span></pre></td></tr><tr><td scope="row"><pre>            CFSTR(kIOBSDNameKey),<span></span></pre></td></tr><tr><td scope="row"><pre>            kCFAllocatorDefault,0);<span></span></pre></td></tr><tr><td scope="row"><pre>if (deviceNameAsCFString) {<span></span></pre></td></tr><tr><td scope="row"><pre>    deviceFilePath = '\0';<span></span></pre></td></tr><tr><td scope="row"><pre>    devPathLength = strlen(_PATH_DEV); //_PATH_DEV is defined in paths.h<span></span></pre></td></tr><tr><td scope="row"><pre>    strcpy(deviceFilePath, _PATH_DEV);<span></span></pre></td></tr><tr><td scope="row"><pre>    //Add "r" before the BSD node name from the I/O Registry<span></span></pre></td></tr><tr><td scope="row"><pre>    //to specify the raw disk node. The raw disk node receives<span></span></pre></td></tr><tr><td scope="row"><pre>    //I/O requests directly and does not go through the<span></span></pre></td></tr><tr><td scope="row"><pre>    //buffer cache.<span></span></pre></td></tr><tr><td scope="row"><pre>    strcat(deviceFilePath, "r");<span></span></pre></td></tr><tr><td scope="row"><pre>    gotString = CFStringGetCString( deviceNameAsCFString,<span></span></pre></td></tr><tr><td scope="row"><pre>             deviceFilePath + strlen(deviceFilePath),<span></span></pre></td></tr><tr><td scope="row"><pre>             MAXPATHLEN - strlen(deviceFilePath),<span></span></pre></td></tr><tr><td scope="row"><pre>            kCFStringEncodingASCII);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if (gotString)<span></span></pre></td></tr><tr><td scope="row"><pre>        printf("Device file path: %s\n", deviceFilePath);<span></span></pre></td></tr><tr><td scope="row"><pre>        //deviceFilePath will look something like /dev/rdisk1<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>Now that you have the device file pathname as a C string, you can use it with standard POSIX<a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_228"></a> functions, such as <code><!--a-->open<!--/a--></code>, <code><!--a-->read<!--/a--></code>, and <code><!--a-->close<!--/a--></code>, to access the device.<a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_229"></a><a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_230"></a><a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_231"></a><a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_232"></a><a name="//apple_ref/doc/uid/TP30000379-DontLinkElementID_233"></a></p>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../AH_Device_Access_IOKit/AH_Device_Access_IOKit.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../AH_IOKitLib_API/AH_IOKitLib_API.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2001, 2007 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2007-02-08<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/DeviceDrivers/Conceptual/AccessingHardware/AH_Finding_Devices/AH_Finding_Devices.html%3Fid%3DTP30000376-2.10&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/DeviceDrivers/Conceptual/AccessingHardware/AH_Finding_Devices/AH_Finding_Devices.html%3Fid%3DTP30000376-2.10&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/DeviceDrivers/Conceptual/AccessingHardware/AH_Finding_Devices/AH_Finding_Devices.html%3Fid%3DTP30000376-2.10&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>