<html><head><title>Mac OS X
 Manual Page For atomic(3)</title>
<style type="text/css"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { font-size: 1px; background: #ffffff; color: #ffffff; } --></style>
<style type="text/css" media="print, aural, braille, embossed, projection, tty"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { display: none; } --></style>
</head><body bgcolor="white">
<a name="//apple_ref/doc/man/3/atomic" title="Mac OS X
 Manual Page for atomic(3)"><!-- headerDoc=man; indexgroup=Section 3; uid="//apple_ref/doc/man/3/atomic"; name=atomic(3) --></a>
<!--#include virtual="/includes/framesetheader"-->
<table width=600><tr><td scope="row">
<!-- begin breadcrumb insert request --><font face="Geneva,Helvetica,Arial" size="1">
 <a target="_top" href="http://developer.apple.com">ADC Home</a> <b>&gt;</b> <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> <b>&gt;</b> <a href="../../../../../reference/index.html#//apple_ref/doc/uid/TP30001281" target="_top">Reference</a> <b>&gt;</b> <!-- a href="" target="_top" -->Mac OS X<!-- /a --> <b>&gt;</b> <a href="../index.html#//apple_ref/doc/framework/manpages" target="_top">Mac OS X Man Pages</a></font>
<!-- end breadcrumb insert request -->
<p>&nbsp;</p>
</td></tr></table>
<!-- end of header -->
<table border="0"  cellpadding="2" cellspacing="2" width="630pt"><tr><td valign="top" height="12" colspan="5" scope="row">
<p style='text-align:justify;'>This document is a Mac OS X manual page.  Manual pages are a command-line technology
for providing documentation.  You can view these manual pages locally using the
<a href="../man1/man.1.html#//apple_ref/doc/man/1/man">man(1)</a> command.
These manual pages come from many different sources, and thus, have a variety of writing
styles.</p>
<p style='text-align:justify;'>For more information about the manual page format, see the manual page for 
<a href="../man5/manpages.5.html#//apple_ref/doc/man/5/manpages">manpages(5)</a>.</p>
</td></tr></table>
<hr />
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row"><pre class="manpages"><tt>
ATOMIC(3)                BSD Library Functions Manual                ATOMIC(3)

<b>NAME</b>
     <b>OSAtomicAdd32</b>, <b>OSAtomicAdd32Barrier</b>, <b>OSAtomicIncrement32</b>, <b>OSAtomicIncrement32Barrier</b>,
     <b>OSAtomicDecrement32</b>, <b>OSAtomicDecrement32Barrier</b>, <b>OSAtomicOr32</b>, <b>OSAtomicOr32Barrier</b>, <b>OSAtomicOr32Orig</b>,
     <b>OSAtomicOr32OrigBarrier</b>, <b>OSAtomicAnd32</b>, <b>OSAtomicAnd32Barrier</b>, <b>OSAtomicAnd32Orig</b>,
     <b>OSAtomicAnd32OrigBarrier</b>, <b>OSAtomicXor32</b>, <b>OSAtomicXor32Barrier</b>, <b>OSAtomicXor32Orig</b>,
     <b>OSAtomicXor32OrigBarrier</b>, <b>OSAtomicAdd64</b>, <b>OSAtomicAdd64Barrier</b>, <b>OSAtomicIncrement64</b>,
     <b>OSAtomicIncrement64Barrier</b>, <b>OSAtomicDecrement64</b>, <b>OSAtomicDecrement64Barrier</b>, <b>OSAtomicCompareAndSwapInt</b>,
     <b>OSAtomicCompareAndSwapIntBarrier</b>, <b>OSAtomicCompareAndSwapLong</b>, <b>OSAtomicCompareAndSwapLongBarrier</b>,
     <b>OSAtomicCompareAndSwapPtr</b>, <b>OSAtomicCompareAndSwapPtrBarrier</b>, <b>OSAtomicCompareAndSwap32</b>,
     <b>OSAtomicCompareAndSwap32Barrier</b>, <b>OSAtomicCompareAndSwap64</b>, <b>OSAtomicCompareAndSwap64Barrier</b>,
     <b>OSAtomicTestAndSet</b>, <b>OSAtomicTestAndSetBarrier</b>, <b>OSAtomicTestAndClear</b>, <b>OSAtomicTestAndClearBarrier</b>,
     <b>OSSpinLockTry</b>, <b>OSSpinLockLock</b>, <b>OSSpinLockUnlock</b>, <b>OSAtomicEnqueue</b>, <b>OSAtomicDequeue</b> -- atomic add, incre-<font color="#ffffff" class="whiteout">ment,&nbsp;increment,</font>
     ment, decrement, or, and, xor, compare and swap, test and set, test and clear, spinlocks, and lockless
     queues

<b>LIBRARY</b>
     Standard C Library (libc, -lc)

<b>SYNOPSIS</b>
     <b>#include</b> <b>&lt;libkern/OSAtomic.h&gt;</b>

     <u>int32</u><b>_</b><u>t</u>
     <b>OSAtomicAdd32</b>(<u>int32</u><b>_</b><u>t</u> <u>theAmount</u>, <u>volatile</u> <u>int32</u><b>_</b><u>t</u> <u>*theValue</u>);

     <u>int32</u><b>_</b><u>t</u>
     <b>OSAtomicAdd32Barrier</b>(<u>int32</u><b>_</b><u>t</u> <u>theAmount</u>, <u>volatile</u> <u>int32</u><b>_</b><u>t</u> <u>*theValue</u>);

     <u>int32</u><b>_</b><u>t</u>
     <b>OSAtomicIncrement32</b>(<u>volatile</u> <u>int32</u><b>_</b><u>t</u> <u>*theValue</u>);

     <u>int32</u><b>_</b><u>t</u>
     <b>OSAtomicIncrement32Barrier</b>(<u>volatile</u> <u>int32</u><b>_</b><u>t</u> <u>*theValue</u>);

     <u>int32</u><b>_</b><u>t</u>
     <b>OSAtomicDecrement32</b>(<u>volatile</u> <u>int32</u><b>_</b><u>t</u> <u>*theValue</u>);

     <u>int32</u><b>_</b><u>t</u>
     <b>OSAtomicDecrement32Barrier</b>(<u>volatile</u> <u>int32</u><b>_</b><u>t</u> <u>*theValue</u>);

     <u>int32</u><b>_</b><u>t</u>
     <b>OSAtomicOr32</b>(<u>uint32</u><b>_</b><u>t</u> <u>theMask</u>, <u>volatile</u> <u>uint32</u><b>_</b><u>t</u> <u>*theValue</u>);

     <u>int32</u><b>_</b><u>t</u>
     <b>OSAtomicOr32Barrier</b>(<u>uint32</u><b>_</b><u>t</u> <u>theMask</u>, <u>volatile</u> <u>uint32</u><b>_</b><u>t</u> <u>*theValue</u>);

     <u>int32</u><b>_</b><u>t</u>
     <b>OSAtomicAnd32</b>(<u>uint32</u><b>_</b><u>t</u> <u>theMask</u>, <u>volatile</u> <u>uint32</u><b>_</b><u>t</u> <u>*theValue</u>);

     <u>int32</u><b>_</b><u>t</u>
     <b>OSAtomicAnd32Barrier</b>(<u>uint32</u><b>_</b><u>t</u> <u>theMask</u>, <u>volatile</u> <u>uint32</u><b>_</b><u>t</u> <u>*theValue</u>);

     <u>int32</u><b>_</b><u>t</u>
     <b>OSAtomicXor32</b>(<u>uint32</u><b>_</b><u>t</u> <u>theMask</u>, <u>volatile</u> <u>uint32</u><b>_</b><u>t</u> <u>*theValue</u>);

     <u>int32</u><b>_</b><u>t</u>
     <b>OSAtomicXor32Barrier</b>(<u>uint32</u><b>_</b><u>t</u> <u>theMask</u>, <u>volatile</u> <u>uint32</u><b>_</b><u>t</u> <u>*theValue</u>);

     <u>int32</u><b>_</b><u>t</u>
     <b>OSAtomicOr32Orig</b>(<u>uint32</u><b>_</b><u>t</u> <u>theMask</u>, <u>volatile</u> <u>uint32</u><b>_</b><u>t</u> <u>*theValue</u>);

     <u>int32</u><b>_</b><u>t</u>
     <b>OSAtomicOr32OrigBarrier</b>(<u>uint32</u><b>_</b><u>t</u> <u>theMask</u>, <u>volatile</u> <u>uint32</u><b>_</b><u>t</u> <u>*theValue</u>);

     <u>int32</u><b>_</b><u>t</u>
     <b>OSAtomicAnd32Orig</b>(<u>uint32</u><b>_</b><u>t</u> <u>theMask</u>, <u>volatile</u> <u>uint32</u><b>_</b><u>t</u> <u>*theValue</u>);

     <u>int32</u><b>_</b><u>t</u>
     <b>OSAtomicAnd32OrigBarrier</b>(<u>uint32</u><b>_</b><u>t</u> <u>theMask</u>, <u>volatile</u> <u>uint32</u><b>_</b><u>t</u> <u>*theValue</u>);

     <u>int32</u><b>_</b><u>t</u>
     <b>OSAtomicXor32Orig</b>(<u>uint32</u><b>_</b><u>t</u> <u>theMask</u>, <u>volatile</u> <u>uint32</u><b>_</b><u>t</u> <u>*theValue</u>);

     <u>int32</u><b>_</b><u>t</u>
     <b>OSAtomicXor32OrigBarrier</b>(<u>uint32</u><b>_</b><u>t</u> <u>theMask</u>, <u>volatile</u> <u>uint32</u><b>_</b><u>t</u> <u>*theValue</u>);

     <u>int64</u><b>_</b><u>t</u>
     <b>OSAtomicAdd64</b>(<u>int64</u><b>_</b><u>t</u> <u>theAmount</u>, <u>volatile</u> <u>int64</u><b>_</b><u>t</u> <u>*theValue</u>);

     <u>int64</u><b>_</b><u>t</u>
     <b>OSAtomicAdd64Barrier</b>(<u>int64</u><b>_</b><u>t</u> <u>theAmount</u>, <u>volatile</u> <u>int64</u><b>_</b><u>t</u> <u>*theValue</u>);

     <u>int64</u><b>_</b><u>t</u>
     <b>OSAtomicIncrement64</b>(<u>volatile</u> <u>int64</u><b>_</b><u>t</u> <u>*theValue</u>);

     <u>int64</u><b>_</b><u>t</u>
     <b>OSAtomicIncrement64Barrier</b>(<u>volatile</u> <u>int64</u><b>_</b><u>t</u> <u>*theValue</u>);

     <u>int64</u><b>_</b><u>t</u>
     <b>OSAtomicDecrement64</b>(<u>volatile</u> <u>int64</u><b>_</b><u>t</u> <u>*theValue</u>);

     <u>int64</u><b>_</b><u>t</u>
     <b>OSAtomicDecrement64Barrier</b>(<u>volatile</u> <u>int64</u><b>_</b><u>t</u> <u>*theValue</u>);

     <u>bool</u>
     <b>OSAtomicCompareAndSwapInt</b>(<u>int</u> <u>oldValue</u>, <u>int</u> <u>newValue</u>, <u>volatile</u> <u>int</u> <u>*theValue</u>);

     <u>bool</u>
     <b>OSAtomicCompareAndSwapIntBarrier</b>(<u>int</u> <u>oldValue</u>, <u>int</u> <u>newValue</u>, <u>volatile</u> <u>int</u> <u>*theValue</u>);

     <u>bool</u>
     <b>OSAtomicCompareAndSwapLong</b>(<u>long</u> <u>oldValue</u>, <u>long</u> <u>newValue</u>, <u>volatile</u> <u>long</u> <u>*theValue</u>);

     <u>bool</u>
     <b>OSAtomicCompareAndSwapLongBarrier</b>(<u>long</u> <u>oldValue</u>, <u>long</u> <u>newValue</u>, <u>volatile</u> <u>long</u> <u>*theValue</u>);

     <u>bool</u>
     <b>OSAtomicCompareAndSwapPtr</b>(<u>void*</u> <u>oldValue</u>, <u>void*</u> <u>newValue</u>, <u>void*</u> <u>volatile</u> <u>*theValue</u>);

     <u>bool</u>
     <b>OSAtomicCompareAndSwapPtrBarrier</b>(<u>void*</u> <u>oldValue</u>, <u>void*</u> <u>newValue</u>, <u>void*</u> <u>volatile</u> <u>*theValue</u>);

     <u>bool</u>
     <b>OSAtomicCompareAndSwap32</b>(<u>int32</u><b>_</b><u>t</u> <u>oldValue</u>, <u>int32</u><b>_</b><u>t</u> <u>newValue</u>, <u>volatile</u> <u>int32</u><b>_</b><u>t</u> <u>*theValue</u>);

     <u>bool</u>
     <b>OSAtomicCompareAndSwap32Barrier</b>(<u>int32</u><b>_</b><u>t</u> <u>oldValue</u>, <u>int32</u><b>_</b><u>t</u> <u>newValue</u>, <u>volatile</u> <u>int32</u><b>_</b><u>t</u> <u>*theValue</u>);

     <u>bool</u>
     <b>OSAtomicCompareAndSwap64</b>(<u>int64</u><b>_</b><u>t</u> <u>oldValue</u>, <u>int64</u><b>_</b><u>t</u> <u>newValue</u>, <u>volatile</u> <u>int64</u><b>_</b><u>t</u> <u>*theValue</u>);

     <u>bool</u>
     <b>OSAtomicCompareAndSwap64Barrier</b>(<u>int64</u><b>_</b><u>t</u> <u>oldValue</u>, <u>int64</u><b>_</b><u>t</u> <u>newValue</u>, <u>volatile</u> <u>int64</u><b>_</b><u>t</u> <u>*theValue</u>);

     <u>bool</u>
     <b>OSAtomicTestAndSet</b>(<u>uint32</u><b>_</b><u>t</u> <u>n</u>, <u>volatile</u> <u>void</u> <u>*theAddress</u>);

     <u>bool</u>
     <b>OSAtomicTestAndSetBarrier</b>(<u>uint32</u><b>_</b><u>t</u> <u>n</u>, <u>volatile</u> <u>void</u> <u>*theAddress</u>);

     <u>bool</u>
     <b>OSAtomicTestAndClear</b>(<u>uint32</u><b>_</b><u>t</u> <u>n</u>, <u>volatile</u> <u>void</u> <u>*theAddress</u>);

     <u>bool</u>
     <b>OSAtomicTestAndClearBarrier</b>(<u>uint32</u><b>_</b><u>t</u> <u>n</u>, <u>volatile</u> <u>void</u> <u>*theAddress</u>);

     <u>bool</u>
     <b>OSSpinLockTry</b>(<u>OSSpinLock</u> <u>*lock</u>);

     <u>void</u>
     <b>OSSpinLockLock</b>(<u>OSSpinLock</u> <u>*lock</u>);

     <u>void</u>
     <b>OSSpinLockUnlock</b>(<u>OSSpinLock</u> <u>*lock</u>);

     <u>void</u>
     <b>OSAtomicEnqueue</b>(<u>OSQueueHead</u> <u>*list</u>, <u>void</u> <u>*new</u>, <u>size</u><b>_</b><u>t</u> <u>offset</u>);

     <u>void*</u>
     <b>OSAtomicDequeue</b>(<u>OSQueueHead</u> <u>*list</u>, <u>size</u><b>_</b><u>t</u> <u>offset</u>);

<b>DESCRIPTION</b>
     These functions are thread and multiprocessor safe.  For each function, there is a version that does
     and another that does not incorporate a memory barrier.  Barriers strictly order memory access on a
     weakly-ordered architecture such as PPC.  All loads and stores executed in sequential program order
     before the barrier will complete before any load or store executed after the barrier.  On a uniproces-<font color="#ffffff" class="whiteout">sor,&nbsp;uniprocessor,</font>
     sor, the barrier operation is typically a nop.  On a multiprocessor, the barrier can be quite expen-<font color="#ffffff" class="whiteout">sive.&nbsp;expensive.</font>
     sive.

     Most code will want to use the barrier functions to insure that memory shared between threads is prop-<font color="#ffffff" class="whiteout">erly&nbsp;properly</font>
     erly synchronized.  For example, if you want to initialize a shared data structure and then atomically
     increment a variable to indicate that the initialization is complete, then you must use OSAtomicIncre-<font color="#ffffff" class="whiteout">ment32Barrier()&nbsp;OSAtomicIncrement32Barrier()</font>
     ment32Barrier() to ensure that the stores to your data structure complete before the atomic add.  Like-<font color="#ffffff" class="whiteout">wise,&nbsp;Likewise,</font>
     wise, the consumer of that data structure must use OSAtomicDecrement32Barrier(), in order to ensure
     that their loads of the structure are not executed before the atomic decrement.  On the other hand, if
     you are simply incrementing a global counter, then it is safe and potentially much faster to use
     OSAtomicIncrement32().  If you are unsure which version to use, prefer the barrier variants as they are
     safer.

     The logical (and, or, xor) and bit test operations are layered on top of the <b>OSAtomicCompareAndSwap</b>()
     primitives.  There are four versions of each logical operation, depending on whether or not there is a
     barrier, and whether the return value is the result of the operation (eg, <b>OSAtomicOr32</b>() ) or the orig-<font color="#ffffff" class="whiteout">inal&nbsp;original</font>
     inal value before the operation (eg, <b>OSAtomicOr32Orig</b>() ).

     The memory address <u>theValue</u> must be naturally aligned, ie 32-bit aligned for 32-bit operations and
     64-bit aligned for 64-bit operations.

     The 64-bit operations are not implemented for 32-bit processes on PPC platforms.

     The <b>OSAtomicCompareAndSwap</b>() operations compare <u>oldValue</u> to <u>*theValue</u>, and set <u>*theValue</u> to <u>newValue</u> if
     the comparison is equal.  The comparison and assignment occur as one atomic operation.

     <b>OSAtomicTestAndSet</b>() and <b>OSAtomicTestAndClear</b>() operate on bit (0x80 &gt;&gt; ( <u>n</u> &amp; 7)) of byte ((char*)
     <u>theAddress</u> + ( <u>n</u> &gt;&gt; 3)).  They set the named bit to either 1 or 0, respectively.  <u>theAddress</u> need not
     be aligned.

     The routines <b>OSAtomicEnqueue</b>() and <b>OSAtomicDequeue</b>() operate on singly linked LIFO queues.  Ie, a
     dequeue operation will return the most recently enqueued element, or NULL if the list is empty.  The
     operations are lockless, and barriers are used as necessary to permit thread-safe access to the queue
     element.  <u>offset</u> is the offset in bytes to the link field in the queue element.  For example:

                   typedef struct elem {
                           long    data1;
                           struct elem *link;
                           int     data2;
                   } elem_t;

                   elem_t fred, mary, *p;

                   OSQueueHead q = OS_ATOMIC_QUEUE_INIT;

                   OSAtomicEnqueue( &amp;q, &amp;fred, offsetof(elem_t,link) );
                   OSAtomicEnqueue( &amp;q, &amp;mary, offsetof(elem_t,link) );

                   p = OSAtomicDequeue( &amp;q, offsetof(elem_t,link) );

     In this example, the call of <b>OSAtomicDequeue</b>() will return a ptr to mary.

<b>RETURN</b> <b>VALUES</b>
     The arithmetic operations return the new value, after the operation has been performed.  The boolean
     operations come in two styles, one of which returns the new value, and one of which (the "Orig" ver-<font color="#ffffff" class="whiteout">sions)&nbsp;versions)</font>
     sions) returns the old.  The compare-and-swap operations return true if the comparison was equal, ie if
     the swap occured.  The bit test and set/clear operations return the original value of the bit.  The
     dequeue operation returns the most recently enqueued element, or NULL if the list in empty.

<b>SEE</b> <b>ALSO</b>
     <a href="spinlock.3.html#//apple_ref/doc/man/3/spinlock">spinlock(3)</a>, <a href="barrier.3.html#//apple_ref/doc/man/3/barrier">barrier(3)</a>

<b>HISTORY</b>
     Most of these functions first appeared in Mac OS 10.4 (Tiger).  The "Orig" forms of the boolean opera-<font color="#ffffff" class="whiteout">tions,&nbsp;operations,</font>
     tions, the "int", "long" and "ptr" forms of compare-and-swap, and lockless enqueue/dequeue first
     appeared in Mac OS 10.5 (Leopard).

Darwin                           May 26, 2004                           Darwin
</tt></pre>
</td></tr></table>
	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Darwin/Reference/ManPages/man3/atomic.3.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Darwin/Reference/ManPages/man3/atomic.3.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Darwin/Reference/ManPages/man3/atomic.3.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

</body></html>
