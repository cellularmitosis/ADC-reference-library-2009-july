<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"			"http://www.w3.org/TR/REC-html40/loose.dtd"><HTML><!-- Template 01-05-01 --><HEAD><LINK REL="stylesheet" HREF="../../adcstyle.css" TYPE="text/css"><LINK REL="stylesheet" HREF="../../style.css" TYPE="text/css"><title>Technical Note TN1117: Open Transport STREAMS FAQ</title><meta name="keywords" content="Mac OS 8 Open Transport STREAMS modules drivers messages DLPI"><meta name="Description" content="Technical Note TN1117: This Technical Note contains collectedlore on writing STREAMS modules and drivers for use withOpen Transport. It is structured as a series of questionand answer pairs, that answer Frequently Asked Questionsabout Open Transport STREAMS. Q&amp;As fall under these categories:STREAMS, STREAMS Modules and Drivers, Messages and MemoryAllocation, Transport Provider Interface (TPI), and DataLink Provider Interface (DLPI)."><meta name="categories" content="Networking"><meta name="week-posted" content="Dec 1, 1997 - Dec 5, 1997"><LINK REL="stylesheet" HREF="../../css/adcstyle.css" TYPE="text/css"><script language="JavaScript" type="text/javascript" src="../../js/adc.js"></script></HEAD><BODY BGCOLOR="#FFFFFF"><a name="//apple_ref/doc/uid/DTS10002957" title="Open Transport STREAMS FAQ"></a><A NAME="top"></A><!-- begin_header_information --><!--#include virtual="/adcnavbar" --><p><a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../technicalnotes/index.html">Technical Notes</a> &gt; <a href="../../technicalnotes/Networking/index.html">Networking</a> &gt; <a href="../../technicalnotes/Networking/idxHardwareDrivers-date.html">Hardware & Drivers</a> &gt; </p><div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Not Recommended Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>The information in this document is <strong>Not Recommended</strong> and should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/Networking/idxHardwareDrivers-date.html" target="_blank">Networking > Hardware & Drivers</a></li>
	</ul>
</div>




</div></div></div><!-- end_header_information --><!-- bottom_of_header_marker_comment --><!-- top_of_titles_marker_comment --><CENTER><table width="600" cellpadding="0" cellspacing="0" border="0">
<tr><td align="left" scope="row">
<h1>
<div id="pagehead">Technical Note TN1117</div>
<div id="pageheadsub">Open Transport STREAMS FAQ</div>
</h1>
</td></tr></table></CENTER><!-- bottom_of_titles_marker_comment --><center><TABLE BORDER=0 CELLSPACING=1 WIDTH=600><TR><td align="left">          <!-- begin_header_box --><table width="600" cellpadding="0" cellspacing="0" border="0">    <tr>        <td width=300 valign="top" align=left scope="row">            <table border="0" width="300" cellpadding="0" cellspacing="0">			<tr>                        <td width=300 align=left> <img src="images/tnmenutop.gif" alt="" align="bottom" width=300 height=7></td>                </tr>                <tr bgcolor="#e6e6e6">                    <td background="images/tnmenubody.gif" width=300 align=left>                        <span id="menutitle">                            CONTENTS                             <br>                            <br>                        </span>                    </td>                </tr>                <tr bgcolor="#e6e6e6">                    <td background="images/tnmenubody.gif" width=300 align=left><!-- begin_toc --><p id="menutext"><A HREF="#GettingStarted">Getting                  Started</A><BR>                  <BR>                  <A HREF="#STREAMSModulesandDrivers">STREAMS                  Modules and Drivers</A><BR>                  <BR>                  <A HREF="#MessagesandMemoryAllocation">Messages                  and Memory                  Allocation</A><BR>                  <BR>                  <A HREF="#TPI">Transport                  Provider Interface                  (TPI)</A><BR>                  <BR>                  <A HREF="#DLPI">Data Link                  Provider Interface                  (DLPI)</A><BR>                  <BR><A HREF="#Summary">Summary</A><BR><BR><A HREF="#References">References</a><BR><BR><A HREF="#Changes">Change History</a><BR><BR><A HREF="#Downloads">Downloadables</A></p>                   <!-- end_toc -->                  </td>                </tr>                <tr>                    <td width=300 align=left scope="row">                        <img src="images/tnmenubottom.gif" alt="" width=300 height=16>                    </td>                </tr>            </table>        </td>        <td width=300 valign="top" align=left>            			<!-- begin_intro_text --><p id="introtext">This                  Technote contains collected lore on writing STREAMS                  modules and drivers for use with Open                  Transport.</P>                                    <p id="introtext">It is structured as a series of question and                  answer pairs, that answer Frequently Asked                  Questions about Open Transport STREAMS. However,                  this isn't just a collection of Q&amp;As; a lot of                  the material is tutorial in nature.</P>                                    <p id="introtext">This Technote is directed at developers who are                  writing OT kernel level plug-ins, such as protocol                  stacks, networking device drivers, and filtering                  and encryption software.</P>               <!-- end_intro_text --><!-- begin_date --><h3>&nbsp;Updated: [Feb 23 1998]</h3><!-- end_date -->        </td>    </tr></table> <!-- end_header_box --><BR><BR><hr width=500 align=center><BR><BR><!-- begin_content -->                  <A NAME=GettingStarted></A>                                    <H2>Getting                  Started</H2>                                    <hr width=500 align=center>                                    <P><B>Q</B> What is                  STREAMS?</P>                                    <P><B>A</B> When written in                  upper case, <B>STREAMS</B> refers to a standard                  environment for loadable networking modules. This                  environment was first introduced as part of                  AT&amp;T UNIX [UNIX is a registered trademark                  of UNIX Systems Laboratory, Inc., in the U.S. and                  other countries], but has since been ported to                  many platforms.</P>                                    <hr width=500 align=center>                                    <P><B>Q</B> So what is Open                  Transport?</P>                                    <P><B>A</B> <B>Open                  Transport</B> is an implementation of STREAMS on                  the Mac OS. OT contains a number of enhancements                  vis-a-vis a traditional STREAMS environment, but                  STREAMS lives at its core.</P>                                    <hr width=500 align=center>                                    <A NAME=MentatPortableStreams></A><P><B>Q</B>                  What is Mentat Portable Streams?</P>                                    <P><B>A</B> <B>Mentat                  Portable Streams</B> (MPS) is a fast, portable                  implementation of STREAMS that is licensed to                  system vendors by <A HREF="http://www.mentat.com">Mentat</A>.                  While MPS is compliant with the AT&amp;T UNIX                  STREAMS at the API level, it contains many                  enhancements, both internal and external. Open                  Transport's STREAMS environment is based on                  MPS.</P>                                    <hr width=500 align=center>                                    <A HREF="#References"></A><P><B>Q</B>                  I'm just getting started with STREAMS. What should                  I read?</P>                                    <P><B>A</B> There are a                  number of useful references that explain the                  STREAMS architecture in general:</P>                                    <UL>                     <LI><CITE>Programmer's Guide: STREAMS, UNIX                     System V Release 4</CITE>, UNIX Press, ISBN                     0-13-02-0660-1</LI>                                          <LI><CITE>STREAMS Modules and Drivers, UNIX                     System V Release 4.2</CITE>, UNIX Press, ISBN                     0-13-066879-6</LI>                                          <LI><CITE>UNIX System V Network                     Programming</CITE>, Stephen Rago,                     Addison-Wesley, ISBN 0-20-156318-5</LI>                  </UL>                                    <P>The "Open Transport Module Developer Note" (part                  of the <a href="http://developer.apple.com/sdk/">Open Transport SDK</A>)                  describes the differences between a standard UNIX                  STREAMS implementation and the one provided by Open                  Transport. In general, the OT implementation is                  very close to UNIX, so if you're an experienced                  UNIX STREAMS programmer you will be in familiar                  territory.</P>                                    <P><a href="http://developer.apple.com/macos/opentransport/OTAdvancedClientProg/index.html">Open                  Transport Advanced Client Programming</A> explains                  many of the low-level client programming interfaces                  required to test and plumb your STREAMS plug-ins                  under Open Transport.</P>                                    <P>Another reference I find useful is UNIX                  <CODE>man</CODE> pages. If you have access to a                  UNIX machine that supports STREAMS, you might find                  that the STREAMS "man" pages are installed. To test                  this out, try typing <CODE>man putmsg</CODE> on the                  UNIX command line.</P>                                    <P>You should also keep on eye on the <a href="http://developer.apple.com/macos/opentransport/">Open                  Transport web page</A>, which contains news and                  information for Open Transport developers. In                  addition, there are a number of non-Apple                  STREAMS-related sites on the Internet,                  including:</P>                                    <UL>                     <LI>the <A HREF="http://www.mentat.com">Mentat                     home page</A>.</LI>                                          <LI>Sun Microsystems' <A HREF="http://docs.sun.com/ab2/coll.156.1/STREAMS/@Ab2TocView?">STREAMS                     Programming Guide</A>.</LI>                                          <LI>Dennis Ritchie's original <A HREF="http://cm.bell-labs.com/cm/cs/who/dmr/st.html">STREAMS                     paper</A>.</LI>                                          <LI>The <A HREF="http://www.tru64unix.compaq.com/faqs/publications/base_doc/DOCUMENTATION/V51_HTML/ARH9UCTE/TITLE.HTM">Compaq                     Tru64 UNIX Network Programmer's Guide</A>.</LI>                  </UL>                                    <P>Finally, you should join the OT mailing list,                  which is a mailing list dedicated to solving Open                  Transport programming questions, at all levels of                  experience. See the Apple mailing lists web page                  for <A HREF="http://lists.apple.com/mailman/listinfo/opentransportdev">instructions                  on how to join</A>.</P>                                    <hr width=500 align=center>                                    <P><B>Q</B> What's the                  relationship between STREAMS and XTI?</P>                                    <P><B>A</B> <B>XTI</B> is a                  standard API for accessing network services.                  STREAMS is a standard way of implementing                  networking services. Traditionally machines running                  STREAMS support an XTI API, although it is possible                  to support other types of APIs. For example, Open                  Transport supports a standard XTI interface, an                  asynchronous XTI interface, and classic networking                  backward compatibility, all on top of STREAMS.                  Also, UNIX STREAMS implementations commonly support                  a Berkeley Sockets API on top of STREAMS.</P>                                    <hr width=500 align=center>                                    <P><B>Q</B> Isn't STREAMS                  slow?</P>                                    <P><B>A</B> A poorly                  implemented STREAMS framework can slow down                  STREAMS-based protocol stacks. This is not true of                  MPS. Actual detailed performance measurements of                  MPS on multiple platforms have shown MPS's overhead                  to be negligible, and have shown that Mentat's                  STREAMS-based TCP outperforms various BSD-based TCP                  implementations.</P><BR><P><A HREF="#top">Back to top</A></P>                  <A NAME=STREAMSModulesandDrivers></A>                                    <H2>STREAMS Modules and                  Drivers</H2>                                    <hr width=500 align=center>                                    <P><B>Q</B> I'm reading the                  STREAMS Modules and                  Driversbook described above and I can't make                  head or tail of it. Any suggestions?</P>                                    <P><B>A</B> I must admit                  that it wasn't until my third attempt at reading                  that book that I made any sense out of it. My                  secret? I found that if you print out a copy of the                  <CODE>mistream.h</CODE> header file and have it at                  hand while you're reading, it helps a lot.</P>                                    <hr width=500 align=center>                                    <P><B>Q</B> What is a                  "stream"?</P>                                    <P><B>A</B> In the most                  general definition, a stream (in lower case) is a                  connection oriented sequence of bytes sent between                  two processes. However, in the STREAMS environment,                  a <B>stream</B> normally refers to a connection                  between a client process and a network provider.                  For example, when you open a URL in a web browser,                  it creates a stream to the TCP module to transport                  connection information and data.</P>                                    <P>A stream carries the implication of instance.                  For example, there is only one Ethernet driver but                  it can support many different streams. One stream                  might be used by AppleTalk, one by TCP, and yet                  another by a network sniffing program.</P>                                    <P>Finally, a stream also implies a chain of                  modules, starting at the stream head and terminated                  at a driver. For example, if you open an endpoint                  "adsp,ddp,enet0", the system creates a new stream                  that looks like the one shown below.</P>                                    <CENTER><img src="images/tn1117_001.gif" width=207 height=225 align=bottom alt="Read/Write Stream"></CENTER>                                    <P>Any data that you write to that endpoint starts                  at the stream head and proceeds first to the "adsp"                  module. That module can pass the data downstream                  (in this case towards the "ddp") with or without                  modifying it, or swallow the data completely, or                  reply to the data with a message sent upstream.</P>                                    <hr width=500 align=center>                                    <P><B>Q</B> What is the stream                  head?</P>                                    <P><B>A</B> The <B>stream                  head</B> is part of the STREAMS kernel. It is                  responsible for managing all interaction between                  the client and the modules. It works in concert                  with client side libraries that implement the                  actual networking APIs.</P>                                    <P>There are two keys areas of interaction: signals                  and memory copying.</P>                                    <P><B>Signals</B> are a mechanism whereby the                  kernel can inform client code of certain events.                  Typically this is used for events like the arrival                  of data, but it is possible for modules to generate                  signals directly by sending the <CODE>M_SIG</CODE>                  message upstream. Obviously there is a connection                  between signals and OT's API-level notifiers.</P>                                    <P>Memory copying is the other main duty of the                  stream head. When you call an API routine (such as                  <CODE>OTSnd</CODE>), you're actually calling the                  Open Transport client-side libraries. These                  libraries take the contents of your call (i.e. the                  data you want to send, or the address you want to                  connect to, etc.) and package it up into an STREAMS                  <STRONG>message</STRONG>. The client then calls the                  kernel to pass this messages to the stream head,                  and the stream head passes it down the stream. Once                  the data is packaged up into messages, no further                  data copying is done as these messages are passed                  around inside the kernel.</P>                                    <P>Because all data is transmitted between client                  and kernel using messages, there is only one point                  of entry between the client and the kernel. This                  means that STREAMS modules are not required to deal                  with client address spaces. This central location                  where the kernel accesses client memory decreases                  the risk of a protection violation on a protected                  memory system, and allows STREAMS modules to run in                  response to an interrupt without requiring a                  context switch.</P>                                    <P>Of course, there are some complications. For                  example, some API routines (especially                  <CODE>OTIoctl</CODE>) pass client addresses in                  message blocks. Modules can only gain access to the                  memory pointed to by these addresses by sending                  special messages up to the stream head. Remember,                  it's the stream head that does all of the                  interaction between client and kernel.</P>                                    <hr width=500 align=center>                                    <P><B>Q</B> What's the                  difference between a module and a driver?</P>                                    <P><B>A</B>I asked this question when I was learning                  STREAMS and got the answer "A module can only be                  pushed, and a driver can only be opened." This                  answer is fundamentally correct, but it didn't help                  a lot at the time.</P>                                    <P>The real answer is that there isn't a lot of                  difference between the two; modules and drivers                  have a very similar structure. In most cases,                  STREAMS documentation says "module" when it mean                  "module or driver".</P>                                    <P>The big difference between a module and a driver                  is that a <B>driver</B> is the base of a stream.                  Streams pass through <B>modules</B>, but terminate                  at drivers. Thus modules must be <B>pushed</B> on                  top of an existing stream (because they need                  someone downstream of them), whereas drivers are                  always <B>opened</B> directly.</P>                                    <P>The following picture shows multiple AppleTalk                  streams all based on top of one Ethernet                  driver.</P>                                    <CENTER><img src="images/tn1117_002.gif" width=131 height=212 alt="Module and driver" align=bottom></CENTER>                                    <P>This is complicated by the existence of                  <B>multiplexing drivers</B>. Multiplexing drivers                  have both upper and lower interfaces. The upper                  interface looks like a driver, that is, it can be                  opened multiple times for multiple streams and                  appears to be the end of those streams. However you                  can also send a special <CODE>ioctl</CODE> call to                  the driver (<CODE>I_LINK</CODE>) to connect streams                  to the lower interface. At the lower interface, the                  multiplexing driver appears to be the stream head                  for those connected streams.</P>                                    <P>For example, you might implement the IP module                  as a multiplexing driver. IP has multiple upper                  streams (i.e. client processes using IP) and                  multiple lower streams (i.e. hardware interfaces                  over which IP is running) but there is no                  one-to-one correspondence between these streams. IP                  uses one algorithm (routing) to determine the                  interface on which to forward outgoing packets. IP                  uses a second algorithm (protocol types) to                  determine which upper stream should receive                  incoming IP packets.</P>                                    <P>The following picture shows three TCP streams                  connected to a IP multiplexing driver, which is in                  turn connected to link layer ports, one run                  directly through an Ethernet driver, and the other                  through another stream that connects a SLIP module                  to a serial port.</P>                                    <CENTER><img src="images/tn1117_003.gif" width=248 height=284 align=bottom alt="Mulitplexing drivers"></CENTER>                  <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>In Open Transport, IP is notstructured as a multiplexing driver,primarily for efficiency reasons. Theabove is just an example of how to thinkabout multiplexing drivers. The nextquestion explains how IP is reallydone.</P></TD></TR></TABLE></CENTER><BR><BR>                  <hr width=500 align=center>                                    <P><B>Q</B> I've noticed Open                  Transport has an "ip" driver and an "ipm" module.                  Why do some modules also appear as drivers?</P>                                    <P><B>A</B> This is an                  implementation decision on the part of the module                  writer. In some cases, it's convenient to access a                  module as a module, and in other cases it's                  convenient to access it as a driver.</P>                                    <P>In this specific case, the MPS IP module behaves                  differently depending on whether it is opened as a                  module or a driver. When OT is bringing up the                  TCP/IP networking stack, it first opens the "ip"                  driver. IP recognizes that this first connection,                  known as the <B>control stream</B>, is special, and                  responds to it in a special way. Later, when OT is                  bringing up interfaces under IP (e.g. an Ethernet                  card and a PPP link), it first opens the link-layer                  driver and then pushes the "ipm" module on top of                  it. Each time OT does this, the IP module                  recognizes this special case and prepares itself to                  handle this new interface. Finally, when a client                  process actually wants to access IP services, OT                  opens the "ip" driver to create a new stream to it                  for the client.</P>                                    <P>STREAMS gives you a lot of flexibility, and the                  designers of MPS IP chose to use it.</P>                                    <hr width=500 align=center>                                    <P><B>Q</B> What is this                  <CODE>q</CODE> parameter that's passed into each of                  my routines?</P>                                    <P><B>A</B> The                  <CODE>q</CODE> parameter (which points to a                  <CODE>queue_t</CODE> data structure) is the                  fundamental data structure within STREAMS. Each                  time a stream is opened, STREAMS allocates a pair                  of queues (a <STRONG>queue pair</STRONG>) for each                  module in the stream. It then hangs all the                  stream-specific information off the queue pair.</P>                                    <P>One queue is designated the <STRONG>write-side                  queue</STRONG>. Data that the client sends to the                  stream is handled on the write-side queue. The                  other queue is the <STRONG>read-side                  queue</STRONG>. Data that the stream generates and                  sends to the client is handled on the read-side                  queue.</P>                                    <P>Each queue has a <STRONG>put routine</STRONG>,                  which is called whenever a message is sent to the                  module. The put routine has the choice of sending                  the message on to the next module (with or without                  modification), temporarily queuing the message on                  the queue for processing later, replying to the                  message by queuing the reply on the other queue in                  the queue pair, or freeing the message.</P>                                    <P>Each queue also has an optional <STRONG>service                  routine</STRONG> that is called when there is                  queued data to be processed. The service routine is                  optional because the module's put routine may be                  written in such a way that it never queues messages                  for later processing.</P>                                    <P>Because these routines are specific to a queue,                  modules tend to contain two routines of each type,                  one for the read side and one for the write side.                  These routines are known as the <STRONG>read put                  routine</STRONG>, <STRONG>read service                  routine</STRONG>, <STRONG>write put                  routine</STRONG>, and <STRONG>write service                  routine</STRONG>.</P>                                    <P>In addition, multiplexing drivers can have both                  <B>upper</B> and <B>lower</B> queue pairs, implying                  a total of eight entry points.</P>                                    <P>When called, each of these routines is passed a                  <CODE>q</CODE> parameter. The read-side routines                  are always passed the read queue and the write side                  routines are always passed the write queue. It's                  important to remember that each queue denotes a                  specific connection to your module and that queues                  are always created in pairs. So the <CODE>q</CODE>                  parameter passed to your module is really just a                  way of distinguishing stream instances.</P>                                    <hr width=500 align=center>                                    <P><B>Q</B> I'm executing in a                  read-side routine (either a put or service routine)                  and I need access to the write-side queue. How do I                  find it?</P>                                    <P><B>A</B> Queue structures                  are actually allocated in memory as pairs, butted                  up right next to each other, with the read queue                  immediately preceding the write queue. Given that                  <CODE>q</CODE> is a pointer to the read queue, you                  can derive the write queue using the C construct                  <CODE>&amp;q[1]</CODE>. However an even                  better solution is to use the macros                  <CODE>RD</CODE>, <CODE>WR</CODE> and                  <CODE>OTHERQ</CODE> defined in "mistream.h".</P>                                    <hr width=500 align=center>                                    <P><B>Q</B> How do I store                  global data in my module?</P>                                    <P><B>A</B>The best way to store globals in your module is                  just to declare global variables. Because modules                  are shared libraries, you don't need to do anything                  special to access these globals. Note that these                  globals are shared across all instances of your                  module, i.e. all streams that run through your                  module.</P>                  <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>                           There is one exception to the above                           statement. If you have two PCI (or PC Card                           3.0) cards installed, OT will create a                           separate instance of the CFM-based driver                           for each card. So the driver will have a                           copy of it's global variables for each                           installed card. The driver distinguishes                           which card its driving by                           <CODE>RegEntryID</CODE>, passed as a                           parameter to its                           <CODE>InitStreamModule</CODE> routine.</P></TD></TR></TABLE></CENTER><BR><BR>                                    <P>If you want to store globals on a per-stream                  basis, you have to do a little more. The following                  snippet demonstrates the recommended technique.</P>                  <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>// First declare a data structure that holds all of the// data you need on a per-stream basis.&nbsp;struct MyLocalData{    OSType magic;           // 'ESK1' for debugging    long   currentState;    // TS_UNBND etc.    [...]};typedef struct MyLocalData MyLocalData, *MyLocalDataPtr;&nbsp;// Then declare a global variable that acts as the head of// the list of all open streams.&nbsp;static char* gModuleList = nil;&nbsp;// In your open routine, call mi_open_comm to create// a copy of the global data for this new stream.&nbsp;static int MyOpen(queue_t* rdq,                            dev_t* dev, int flag,                            int sflag, cred_t* creds){    MyLocalDataPtr locals;&nbsp;    [...]    err = mi_open_comm(&amp;gModuleList,                            sizeof(MyLocalData),                            rdq,                            dev, flag,                            sflag, creds);    if ( err == noErr ) {&nbsp;        // mi_open_comm has put a pointer to our per-stream        // data in the q_ptr field of both the read-side        // and write-side queue.&nbsp;        locals = (MyLocalDataPtr) rdq-&gt;q_ptr;        locals-&gt;magic = 'ESK1';        locals-&gt;currentState = TS_UNBND;        [...]    }    [...]}&nbsp;// In your close routine, use mi_close_comm to destroy// the per-stream globals.  Note that, if you have// any pointers in your data, you must make sure to// dispose of those before calling mi_close_comm.//// As an alternative to mi_close_comm, you might want to// use mi_detach and mi_close_detached.&nbsp;static int MyClose(queue_t* rdq, int flags, cred_t* credP){    [...]    (void) mi_close_comm(&amp;gModuleList, rdq);    [...]}&nbsp;// If you find that you need to loop through all the// streams open through your module, use the mi_next_ptr// routine as shown below.&nbsp;static void MyForEachStream( [...] ){    MyLocalDataPtr aStreamLocals;&nbsp;    aStreamLocals = (MyLocalDataPtr) gModuleList;    while (aStreamLocals != nil) {        [...]        aStreamLocals = (MyLocalDataPtr) mi_next_ptr( (char *) aStreamLocals );    }}</pre></TD></TR></TABLE></CENTER><BR><BR>                  <P><A HREF = "#References">The Open Transport Module                  Developer Note</A> has a full description of the                  routines used in the above snippet.</P>                                    <hr width=500 align=center>                                    <A NAME=HowdoIsynchroniseaccesstomyglobaldata></A><P><B>Q</B>                  How do I synchronize access to my global data?</P>                                    <P><B>A</B> <A HREF="#MentatPortableStreams">MPS</A>                  provides support for synchronizing access to global                  or per-stream data. When you install your module,                  you must fill out the <CODE>install_info</CODE>                  structure. One of the fields in this structure is                  <CODE>install_sqlvl</CODE>, which you set to                  control your module's reentrancy.</P>                  <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>                           When reading this description, it's                           important to keep the following                           abbreviations in mind. In the context of                           MPS, "SQ" stands for <B>synchronization                           queue</B>, which is the key data structure                           that MPS uses to guard against reentrancy.                           Also, "SQLVL" stands for                           <B>synchronization queue level</B>, which                           is the degree of mutual exclusion needed                           by a module.</P></TD></TR></TABLE></CENTER><BR><BR>                                    <P>The legal values for the sync queue level                  are:</P>                                    <DL>                     <DT><CODE>SQLVL_QUEUE</CODE></DT>                                          <DD>Your module can be entered once per read or                     write queue. This means that you must guard your                     global data from access by multiple threads                     running in you module, and you must guard your                     per-stream data from access by threads running                     on the read and write sides of the stream                     simultaneously.</DD>                                          <DT><CODE>SQLVL_QUEUEPAIR</CODE></DT>                                          <DD>Your module can be entered once per queue                     pair. You must still guard your global data from                     access by multiple threads running in your                     module, but your per-stream data is safe from                     simultaneous access by the read and write                     sides.</DD>                                          <DT><CODE>SQLVL_SPLITMODULE</CODE></DT>                                          <DD>[This sync queue level is not yet                     supported in Open Transport, and is documented                     here for completeness only.] Your module can                     be entered once from an upper queue and once                     from a lower queue. With this sync queue level,                     the <CODE>mps_become_writer</CODE> function is                     relatively cheap, and this is the recommended                     sync queue level for network and link-layer                     drivers.</DD>                                          <DT><CODE>SQLVL_MODULE</CODE></DT>                                          <DD>Your module can only be entered once, no                     matter which instance of the module is                     entered.</DD>                                          <DT><CODE>SQLVL_GLOBAL</CODE></DT>                                          <DD>Between all modules that use                     <CODE>SQLVL_GLOBAL</CODE>, only one will be                     entered at a time.</DD>                  </DL>                                    <P>In the above list, sync queue levels are given                  from least exclusive (<CODE>SQLVL_QUEUE</CODE>) to                  most exclusive (<CODE>SQLVL_GLOBAL</CODE>). In                  general, the least exclusive sync queue level also                  yields the best system performance, while the most                  exclusive value leads to the worst system                  performance. However this is not guaranteed. If, by                  setting your sync queue level to                  <CODE>SQLVL_QUEUE</CODE>, you are forced to make a                  significant number of calls to                  <CODE>mps_become_writer</CODE>, you may find better                  performance with a more exclusive sync queue                  level.</P>                  <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>If your module is using sync queue levels<CODE>SQLVL_QUEUE</CODE>,<CODE>SQLVL_QUEUEPAIR</CODE>, or<CODE>SQLVL_SPLITMODULE</CODE>, you canuse the <CODE>mps_become_writer</CODE>function to ensure that only one thread ofexecution is inside a particular part ofyour module at any given time. See the<A HREF = "#References">Open TransportModule Developer Note</A> for adescription of<CODE>mps_become_writer</CODE>.</P></TD></TR></TABLE></CENTER><BR><BR>                                    <P>So, what does this mean in practical terms?                  Before OT calls your module (either the put routine                  or the service routine), it checks to see whether                  there is a thread of execution already running in                  your module. If there is, it checks the sync queue                  level of the module to see whether calling your                  module would be valid at this time. It uses these                  two factors to decide whether to call your module                  immediately, or queue the call for some later task                  to execute.</P>                                    <P>The sync queue levels fall into two                  categories:</P>                                    <OL>                     <LI>Queue-based sync queue levels (i.e.                     <CODE>SQLVL_QUEUE</CODE> and                     <CODE>SQLVL_QUEUEPAIR </CODE>) are centred                     around the queue pairs associated with each                     stream that's opened to your module. If you use                     <CODE>SQLVL_QUEUE</CODE>, your module can be                     reentered as long as the put or service routine                     for <EM>that queue</EM> isn't already running.                     If you use <CODE>SQLVL_QUEUEPAIR</CODE>, your                     module can be reentered as long as a put or                     service routine for <EM>that queue pair</EM>                     (i.e. the stream) isn't already running</LI>                                          <LI>Module-based sync queue levels                     (<CODE>SQLVL_SPLITMODULE</CODE>,                     <CODE>SQLVL_MODULE</CODE> and                     <CODE>SQLVL_GLOBAL</CODE>) work on a                     module-by-module basis. For the moment, you can                     ignore <CODE>SQLVL_SPLITMODULE</CODE>. With                     <CODE>SQLVL_MODULE</CODE>, your module cannot be                     reentered at all. With                     <CODE>SQLVL_GLOBAL</CODE>, your module is                     mutually excluded against all other module that                     are marked as <CODE>SQLVL_GLOBAL</CODE>.                     [This can be useful if you're trying to                     bring up a suite of modules that talk to each                     other.]</LI>                  </OL>                                    <P>Of course, these mutual exclusion guarantees are                  for when STREAMS calls you, i.e. your open, close,                  put and service routines. If you are called by                  other sources (such as a hardware interrupts), you                  have to take additional measures to ensure data                  coherency. Of course, OT provides support for this                  too. See the <A HREF = "#References">Open Transport                  Module Developer Note</A> for a description of the                  routines you can call from your hardware interrupt                  handler.</P>                                    <P>In general, I recommend that you first use                  <CODE>SQLVL_MODULE</CODE> in order to get your                  module working. Then, once you understand the data                  coherence issues in the final code, analyze the                  code to see if you can use a better sync queue                  level.</P>                  <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>IMPORTANT:</B><BR>If you are pushing your module into anexisting protocol stack, you should besure to check the sync queue level of theother modules in the stack. If theexisting modules have a very exclusivesync queue level, there is nothing to gainby engineering your module to have anon-exclusive level. Conversely, if theexisting modules have a non-exclusive syncqueue level, you could affect theperformance of the entire protocol stackby adopting a very exclusive level.</P></TD></TR></TABLE></CENTER><BR><BR>                                    <hr width=500 align=center>                                    <P><B>Q</B> I'm confused by the                  <CODE>qinit</CODE> structures. I need to have two                  <CODE>qinit</CODE> structures, one for the read                  side and one for the write side, but that implies                  two open and close routines. Two open routines                  seems like a recipe for confusion. What the full                  story?</P>                                    <P><B>A</B> For the open and                  close routines, STREAMS only looks at the read-side                  <CODE>qinit</CODE> structure.</P>                                    <hr width=500 align=center>                                    <P><B>Q</B> How should I                  structure my STREAMS module?</P>                                    <P><B>A</B>STREAMS modules have two primary entry points,                  the put routine and the service routine. In                  general, you should try to do all the work you can                  in your put routine. This is contradictory to most                  of the STREAMS documentation, and is an important                  factor in making your modules fast.</P>                                    <P>Every time you use <CODE>putq</CODE> to put a                  message on your queue, STREAMS must schedule a task                  to run your service routine in order to service                  that message. While OT's internal task scheduler is                  fast, it still takes time.</P>                                    <P>The alternative is to process the message in                  your put routine and then immediately send the                  message on to the next module (using                  <CODE>putnext</CODE>) or reply to the message                  (using <CODE>qreply</CODE>). This can make your put                  routine complicated. If you find that your put                  routine is getting too complicated, simply break it                  up into subroutines. The cost a subroutine call is                  much less than the cost of scheduling your service                  routine.</P>                                    <P>Of course you can still use <CODE>putq</CODE> in                  flow control conditions because, if you're flow                  controlled, you don't really care about speed.</P>                                    <hr width=500 align=center>                                    <P><B>Q</B> How does flow                  control work?</P>                                    <P><B>A</B>STREAMS flow control is quite hard to                  understand. The basic tenets of STREAMS flow                  control are:</P>                                    <UL>                     <LI>Your module either takes part in flow                     control, or it doesn't. If it doesn't take part                     in flow control (i.e. it's a simple filter                     module), you should let STREAMS know by having                     no service routine. You can then ignore the                     other rules given below.</LI>                                          <LI>High priority messages are not subject to                     flow control. It's important that your module                     avoid queuing them because of flow control                     because this can cause a deadlock situations                     (i.e. you can't flush the messages out of a                     stream because the stream is flow                     controlled).</LI>                                          <LI>Flow control is governed by two values in                     the queue, the high and low water marks. If the                     number of bytes of messages stored on a queue is                     greater than the <B>high water mark</B>, the                     queue is flow controlled. The queue stays flow                     controlled until the number of bytes of messages                     enqueued falls below the <B>low water                     mark</B>.</LI>                                          <LI>Bytes go on to your queue when you call                     <CODE>putq</CODE>. This has the side effect of                     scheduling your service routine. [You can                     also schedule your service routine directly                     using <CODE>qenable</CODE>.] Your service                     routine only gets run once regardless of how                     many times you schedule it.</LI>                                          <LI>Bytes come off your queue when you call                     <CODE>getq</CODE> in your service routine. When                     you get a message like this, you should call                     <CODE>canputnext</CODE> to see if it's possible                     to put the data on the next queue that has a                     service procedure. If it is, call                     <CODE>putnext</CODE> to put it on the next                     queue. If it isn't, call <CODE>putbq</CODE>                     ("put back on queue") to return the message to                     your queue. Calling <CODE>putbq</CODE> puts the                     data back on to your queue without rescheduling                     your service routine.</LI>                                          <LI>Because your service routine can only be                     scheduled once, it is critical that your service                     routine finish either by calling                     <CODE>putbq</CODE> or by completely draining the                     queue (i.e. <CODE>getq</CODE> returns nil). A                     sample service routine is shown below.</LI>                  </UL>                  <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>// A standard read service routine that follows the// above guidelines.&nbsp;static int MyReadService(queue_t* q){    mblk_t *mp;    while ( (mp = getq(q)) != nil ) {        // Never putbq a high-priority message.&nbsp;        if ((mp-&gt;b_datap-&gt;db_type &lt; QPCTL) &amp;&amp; !canputnext(q)) {            putbq(q, mp);            return (0);        }        // Handle the message then put it on the next queue&nbsp;        [...]&nbsp;        putnext(q, mp);    }    return (0);}&nbsp;</pre></TD></TR></TABLE></CENTER><BR><BR>                                    <UL>                     <LI>When your queue is flow controlled, the                     previous module's read service routine will stop                     being able to put messages on your queue                     (because its calls to <CODE>canputnext</CODE>                     will return false). This causes that module to                     call <CODE>putbq</CODE>, which puts the data on                     their queue without scheduling their read                     service routine. Eventually this causes the                     number of bytes in their queue to exceed their                     high water mark, which causes them to be flow                     controlled as well. This process proceeds up the                     stream until you get to the stream head or the                     driver.</LI>                                          <LI>When the stream head gets flow controlled,                     it stops accepting data from the client, and the                     client blocks waiting for data to be sent.</LI>                                          <LI>When the driver gets flow controlled, it                     either                                          <DL>                        <DD>&nbsp;</DD>                                                <DT>a) starts dropping packets (for                        unreliable services, such as Ethernet),                        or<BR>                        </DT>                                                <DD>&nbsp;</DD>                                                <DT>b) it raises the link-layer flow control                        (for reliable services, such as serial).</DT>                     </DL>                     </LI>                                          <LI>When flow control is lifted (this happens                     when the number of bytes in the flow controlled                     queue drops below the low water mark -- for the                     read side, this is because the client reads some                     data; for the write side, it happens when the                     driver transmits some data), STREAMS                     automatically reschedules the service procedure                     of the previous queue that has a service                     routine. Like the propagation of flow control,                     this <STRONG>back enabling</STRONG> continues                     until it reaches the beginning of the                     stream.</LI>                  </UL>                                    <P>Finally, there is one important hint for using                  flow control. In certain special case situations,                  such as constructing a sequence of messages, it may                  be extremely inconvenient to deal with flow                  control. At times like this, you always have the                  option of ignoring it. While not strictly legal,                  this will work and is unlikely to get you into                  trouble. But it is important that you deal with                  flow control in the general case, otherwise                  messages will pile up on queues, and STREAMS will                  run out of memory.</P>                                    <hr width=500 align=center>                                    <P><B>Q</B> Which should I use,                  <CODE>canputnext</CODE> or                  <CODE>putnext(q-&gt;q_next)</CODE>?</P>                                    <P><B>A</B> <A HREF="#References">STREAMS                  Modules and Drivers</A> contains a number of code                  samples that look like:</P>                  <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>#ifdef MP    if ( canputnext(q, mp) ) {#else    if ( putq(q-&gt;q_next, mp) ) {#endif</pre></TD></TR></TABLE></CENTER><BR><BR>                  <P>This is an anachronism from UNIX STREAMS's support                  of multi-processor (MP) systems. MPS STREAMS has                  full support for MP built-in, so                  <CODE>canputnext</CODE> is always available. In                  addition, MPS automatically handles synchronization                  across multiple processors using sync queues (see                  the question <A HREF="#HowdoIsynchroniseaccesstomyglobaldata">How                  do I synchronize access to my global data?</A>), so                  you do not have to worry about MP issues in your OT                  modules.</P>                                    <hr width=500 align=center>                                    <P><B>Q</B> I've notice that                  some STREAMS routines return <CODE>int</CODE> even                  though there is no defined returned value. When I                  check the returned values, I find that they are                  random. What's going on?</P>                                    <P><B>A</B> The STREAMS                  internal routines were imported wholesale from UNIX                  and, in some cases, the prototypes do not match the                  semantics. In these cases, you should make sure to                  ignore the returned value.</P>                                    <hr width=500 align=center>                                    <P><B>Q</B> <A HREF="#References">STREAMS                  Modules and Drivers</A> talks a lot about                  <STRONG>bands</STRONG>. Is this of any use?</P>                                    <P><B>A</B> Not really. Some                  protocol modules (such as TCP and ADSP) have the                  concept of expedited data and typically these are                  supported using band 0 (normal data) and band 1                  (expedited data). No one has ever found a use for                  all 255 bands!</P>                                    <P>Also, note the band structures inside STREAMS                  are allocated as an array, so if you use more than                  one band, make sure you allocate them sequentially                  from 0. Otherwise you might find yourself using a                  lot more memory than you expect.</P>                                    <P>Finally, you should remember that bands only                  affect the order in which messages are queued, and                  hence the order in which they are returned by                  <CODE>getq</CODE> to the service routine. As an                  efficient STREAMS protocol stack will rarely queue                  messages, bands are rarely useful. One case where                  they have a significant effect is on the stream                  head, where the band affects the order in which                  data is delivered to the client. However, this                  effect may not be the effect you are looking                  for!</P>                                    <hr width=500 align=center>                                    <P><B>Q</B> What fields of the                  <CODE>queue_t</CODE> structure can I modify?</P>                                    <P><B>A</B> There are a                  number of rules related to the fields in a                  queue:</P>                                    <UL>                     <LI>You should only modify your own queues. You                     should not modify the queue of another                     module.</LI>                                          <LI>The <CODE>q_ptr</CODE> field is specifically                     reserved for the module's own use. The module                     can read or write that value at any time. Note,                     however, that if you use                     <CODE>mi_open_comm</CODE> (which I strongly                     recommend), the <CODE>q_ptr</CODE> field of both                     queues in the queue pair contains a pointer to                     your per-stream data, and you should not use if                     for anything else.</LI>                                          <LI>Although it is normally OK to just read the                     queue's fields directly, you really should read                     them using <CODE>strqget</CODE>. This avoids                     some possible synchronization issues.</LI>                                          <LI>You must modify any fields (other than                     <CODE>q_ptr</CODE>) using                     <CODE>strqset</CODE>.</LI>                  </UL>                                    <P><CODE>strqget</CODE> and <CODE>strqset</CODE>                  are defined with the following prototypes in                  "mistream.h":</P>                  <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>extern int strqget(queue_t*, qfields_t what, uchar_p pri, long* valp);extern int strqset(queue_t*, qfields_t what, uchar_p pri, long val);</pre></TD></TR></TABLE></CENTER><BR><BR>                  <P><CODE>strqget</CODE> is used to read a field,                  putting the value in the long pointed to by                  <CODE>valp</CODE>. <CODE>strqset</CODE> is used to                  set a field. The field that is modified is                  determined by the <CODE>what</CODE> parameter,                  whose value can be:</P>                                    <TABLE BORDER=0 WIDTH=500>                     <TR>                        <td width=81 align=left>                           <P><B>qfields_t</B></P>                        </TD>                        <td width=103 align=left>                           <P><B>field in queue_t</B></P>                        </TD>                        <td width=66 align=left>                           <P><B>read-only?</B></P>                        </TD>                     </TR>                     <TR>                        <td width=81 align=left>                           <P>QHIWAT</P>                        </TD>                        <td width=103 align=left>                           <P>q_hiwat</P>                        </TD>                        <td width=66 align=left>                           <P>no</P>                        </TD>                     </TR>                     <TR>                        <td width=81 align=left>                           <P>QLOWAT</P>                        </TD>                        <td width=103 align=left>                           <P>q_lowat</P>                        </TD>                        <td width=66 align=left>                           <P>no</P>                        </TD>                     </TR>                     <TR>                        <td width=81 align=left>                           <P>QMAXPSZ</P>                        </TD>                        <td width=103 align=left>                           <P>q_maxpsz</P>                        </TD>                        <td width=66 align=left>                           <P>no</P>                        </TD>                     </TR>                     <TR>                        <td width=81 align=left>                           <P>QMINPSZ</P>                        </TD>                        <td width=103 align=left>                           <P>q_minpsz</P>                        </TD>                        <td width=66 align=left>                           <P>no</P>                        </TD>                     </TR>                     <TR>                        <td width=81 align=left>                           <P>QCOUNT</P>                        </TD>                        <td width=103 align=left>                           <P>q_count</P>                        </TD>                        <td width=66 align=left>                           <P>yes</P>                        </TD>                     </TR>                     <TR>                        <td width=81 align=left>                           <P>QFIRST</P>                        </TD>                        <td width=103 align=left>                           <P>q_first</P>                        </TD>                        <td width=66 align=left>                           <P>yes</P>                        </TD>                     </TR>                     <TR>                        <td width=81 align=left>                           <P>QLAST</P>                        </TD>                        <td width=103 align=left>                           <P>q_last</P>                        </TD>                        <td width=66 align=left>                           <P>yes</P>                        </TD>                     </TR>                     <TR>                        <td width=81 align=left>                           <P>QFLAG</P>                        </TD>                        <td width=103 align=left>                           <P>q_flag</P>                        </TD>                        <td width=66 align=left>                           <P>yes</P>                        </TD>                     </TR>                  </TABLE>                  <BR>                  <P>The <CODE>pri</CODE> parameter determines which                  priority band is used. A band of 0 indicates the                  value held in the queue itself, a higher value                  refers to the band data structure referenced by the                  queue.</P>                                    <P>The functions can return the following                  errors:</P>                                    <UL>                     <LI><CODE>ENOENT</CODE> if an invalid                     <CODE>what</CODE> is specified</LI>                                          <LI><CODE>EINVAL</CODE> if the specified band is                     not currently defined</LI>                                          <LI><CODE>EPERM</CODE> if you are not allowed to                     modify the specified field</LI>                  </UL>                  <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>IMPORTANT:</B><BR>You should not modify fields that aremarked as read-only in the above table.While it may seem like a convenientshortcut, it will cause you problems inthe long run. This warning appliesspecifically to the <CODE>q_flag</CODE>field.</P></TD></TR></TABLE></CENTER><BR><BR>                                    <hr width=500 align=center>                                    <P><B>Q</B> The standard UNIX                  STREAMS books do not contain any information about                  the routines that begin with the prefix                  <CODE>mi_</CODE>, for example                  <CODE>mi_open_comm</CODE>. Where are these                  documented?</P>                                    <P><B>A</B> These are                  utilities routines provided by Mentat to make                  STREAMS programming easier. They are documented in                  the <A HREF="#References">Open Transport Module                  Developer Note</A>. I strongly recommend that you                  use these routines because they help cut down on                  silly programming errors.</P>                  <BR><P><A HREF="#top">Back to top</A></P>                  <A NAME=MessagesandMemoryAllocation></A>                                    <H2>Messages and Memory                  Allocation</H2>                                    <hr width=500 align=center>                                    <P><B>Q</B> Can I modify the                  message blocks that are passed to my module?</P>                                    <P><B>A</B> Yes, as long as                  you are careful. To start with, you must                  distinguish between message blocks                  (<CODE>mblk_t</CODE>) and data blocks                  (<CODE>dblk_t</CODE>). Message blocks are always                  wholely owned by you. STREAMS passes you the                  message block, and you are expected to remember it,                  free it, or pass it on. No one else has a reference                  to that message block. For this reason, you are                  always allowed to modify the fields in the message                  block, even if you aren't allowed to modify the                  data block.</P>                                    <P>The following fields of the <CODE>mblk_t</CODE>                  are commonly modified: <CODE>b_cont</CODE>,                  <CODE>b_rptr</CODE>, <CODE>b_wptr</CODE>. You                  should not directly change the other fields in the                  <CODE>mblk_t</CODE>; there are STREAMS routines                  that let you change them indirectly.</P>                                    <P>Data blocks are slightly different. A single                  data block can be referenced by multiple message                  blocks, so you are only allowed to modify the                  fields in the data block (or indeed its contents)                  if you are the sole owner of the block. You                  determine this by looking at the                  <CODE>db_ref</CODE> field of the data block. If it                  is set to 1, you are free to modify the data block                  and its contents. If it is greater than one, some                  other message block has a reference to this data                  block, and you should avoid modifying the data                  block or its contents.</P>                                    <P>If you wish to write to a read-only data block,                  you should copy the block using one of the                  allocation functions described below.</P>                                    <P>The only field of the <CODE>dblk_t</CODE> that                  is commonly modified is <CODE>db_type</CODE>. You                  should not directly change the other fields in the                  <CODE>dblk_t</CODE>, although there are STREAMS                  routines that let you change them indirectly.</P>                                    <hr width=500 align=center>                                    <P><B>Q</B> How do I allocate                  new messages within my module?</P>                                    <P><B>A</B> There are a lot                  of techniques. If you just want to allocate a raw                  message along with its data block, use the STREAMS                  function <CODE>allocb</CODE>. Given a size,                  <CODE>allocb</CODE> will create a message that                  pointers to a data buffer of at least that                  size.</P>                                    <P><CODE>copyb</CODE> returns a new message block                  that's identical to the input message block. The                  data block that the message block points to is also                  copied.</P>                                    <P><CODE>copymsg</CODE> returns a new message                  that's identical to the input message. Like                  <CODE>copyb</CODE>, it also copies the data that                  the message block points to. In addition, it copies                  all of the message blocks linked to this message                  through the <CODE>b_cont</CODE> field, and all                  their data blocks.</P>                                    <P><CODE>dupb</CODE> duplicates the message block                  you passed into it without copying the data block                  that the message points to. The new message                  continues to reference the old data block. The                  function also increments the <CODE>db_ref</CODE>                  field of the data block to record the new copy.</P>                                    <P><CODE>dupmsg</CODE> duplicates the message block                  you passed into it without copying the data block                  that the message points to. In addition, it                  duplicates all of the message blocks linked to this                  message through the <CODE>b_cont</CODE> field.</P>                                    <P><CODE>esballoc</CODE> creates a message block                  that references a data block which you provide. You                  also pass in a function that will be called when                  the message is freed. This allows DMA-based network                  drivers to implement no-copy receives by passing                  their real DMA buffers upstream. See <A HREF="#References">Open                  Transport Module Developer Note</A> for more hints                  and tips on <CODE>esballoc</CODE>.</P>                                    <P>There are also a number of utilities routines                  for allocating TPI messages that you might find                  useful. These include:</P>                                    <TABLE BORDER=0 WIDTH=500>                     <TR>                        <td width=149 align=left>                           <P><CODE>mi_tpi_conn_con</CODE></P>                        </TD>                        <td width=146 align=left>                           <P><CODE>mi_tpi_uderror_ind</CODE></P>                        </TD>                     </TR>                     <TR>                        <td width=149 align=left>                           <P><CODE>mi_tpi_conn_ind</CODE></P>                        </TD>                        <td width=146 align=left>                           <P><CODE>mi_tpi_unitdata_ind</CODE></P>                        </TD>                     </TR>                     <TR>                        <td width=149 align=left>                           <P><CODE>mi_tpi_conn_req</CODE></P>                        </TD>                        <td width=146 align=left>                           <P><CODE>mi_tpi_unitdata_req</CODE></P>                        </TD>                     </TR>                     <TR>                        <td width=149 align=left>                           <P><CODE>mi_tpi_data_ind</CODE></P>                        </TD>                        <td width=146 align=left>                           <P><CODE>mi_tpi_exdata_ind</CODE></P>                        </TD>                     </TR>                     <TR>                        <td width=149 align=left>                           <P><CODE>mi_tpi_data_req</CODE></P>                        </TD>                        <td width=146 align=left>                           <P><CODE>mi_tpi_exdata_req</CODE></P>                        </TD>                     </TR>                     <TR>                        <td width=149 align=left>                           <P><CODE>mi_tpi_discon_ind</CODE></P>                        </TD>                        <td width=146 align=left>                           <P><CODE>mi_tpi_ordrel_ind</CODE></P>                        </TD>                     </TR>                     <TR>                        <td width=149 align=left>                           <P><CODE>mi_tpi_discon_req</CODE></P>                        </TD>                        <td width=146 align=left>                           <P><CODE>mi_tpi_ordrel_req</CODE></P>                        </TD>                     </TR>                     <TR>                        <td width=149 align=left>                           <P><CODE>mi_tpi_info_req</CODE></P>                        </TD>                        <td width=146 align=left>                           <P></P>                        </TD>                     </TR>                  </TABLE>                  <BR>                  <P>See the <A HREF="#References">Open Transport Module                  Developer Note</A> for more details on these                  routines.</P>                                    <hr width=500 align=center>                                    <P><B>Q</B> Why do I get a link                  error when I try to use                  <CODE>mi_tpi_data_ind</CODE> from my module?</P>                                    <P><B>A</B> It appears that                  someone forgot to export that routine. Fortunately,                  it's very easy to write you own version:</P>                  <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>static mblk_t* qmi_tpi_data_ind(mblk_t* trailer_mp, int flags, long type){    mblk_t* mp;    mp = mi_tpi_data_req(trailer_mp, flags, type);    if (mp)        ((struct T_data_ind *)mp-&gt;b_rptr)-&gt;PRIM_type = T_DATA_IND;    return mp;}</pre></TD></TR></TABLE></CENTER><BR><BR>                                    <hr width=500 align=center>                                    <A NAME=ReuseMessage></A><P><B>Q</B>                  How do I reuse an existing message?</P>                                    <P><B>A</B> In writing a                  module, you often find yourself in the situation                  where you want to free a message and then allocate                  a new message in reply to the original message. In                  these cases, it's much better to reuse the first                  message rather than suffer the overhead of the                  freeing one message and allocating another.</P>                                    <P>You can reuse a message block as long as both of                  the following conditions are true:</P>                                    <UL>                     <LI>You are the sole owner of the message, i.e.                     the messages's data block field                     <CODE>db_ref</CODE> is 1.</LI>                                          <LI>The message is big enough for your                     needs.</LI>                  </UL>                                    <P>STREAMS guarantees that all control messages                  generated by <CODE>putmsg</CODE> (typically                  <CODE>M_PROTO</CODE> and <CODE>M_PCPROTO</CODE>)                  reference data blocks that are at least 64 bytes                  long.</P>                                    <P>OT provides utility routines for reusing                  messages. The most general purpose one is:</P>                  <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>mblk_t* mi_reuse_proto(mblk_t* toReuse,                       size_t sizeDesired,                       boolean_p keepOnError);</pre></TD></TR></TABLE></CENTER><BR><BR>                  <P>This routine attempts to reuse the message pointed                  to by <CODE>toReuse</CODE>, making sure that the                  message can contain <CODE>sizeDesired</CODE> bytes.                  It return a pointer to the new message, or nil if                  it fails. If <CODE>keepOnError</CODE> is false,                  <CODE>toReuse</CODE> is freed regardless of whether                  we fail or not. Otherwise, <CODE>toReuse</CODE> is                  preserved if we fail.</P>                                    <P>There are also a number of utilities routines                  specific to TPI that you might find useful                  including:</P>                                    <TABLE BORDER=0 WIDTH=500>                     <TR>                        <td width=149 align=left>                           <P><CODE>mi_tpi_ack_alloc</CODE></P>                        </TD>                        <td width=146 align=left>                           <P><CODE>mi_tpi_err_ack_alloc</CODE></P>                        </TD>                     </TR>                     <TR>                        <td width=149 align=left>                           <P><CODE>mi_tpi_ok_ack_alloc</CODE></P>                        </TD>                        <td width=146 align=left>                           <P></P>                        </TD>                     </TR>                  </TABLE>                  <BR>                  <P>See the <A HREF="#References">Open Transport Module                  Developer Note</A> for more details on these                  routines.</P>                  <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>WARNING:</B><BR>                           All of these reuse routines can return nil                           if you run out of memory. The reason is                           that the message you're trying to reuse                           may be read-only, in which case the                           routine is required to create a copy of                           the message. This copy can fail if you run                           out of memory. You must be prepare for                           these routines to fail.</P></TD></TR></TABLE></CENTER><BR><BR>                                    <hr width=500 align=center>                                    <P><B>Q</B> How much data is in                  a message?</P>                                    <P><B>A</B> If you just want                  to know how much data there is in a single message                  block, you can simply calculate <CODE>b_wptr -                  b_rptr</CODE>. If you want to find the total size                  of all the messages in a chain, use the STREAMS                  function <CODE>msgdsize</CODE>. Note that this                  function returns the number of data bytes in the                  message, and does not take into account                  <CODE>M_PROTO</CODE> and <CODE>M_PCPROTO</CODE>                  message blocks.</P>                                    <hr width=500 align=center>                                    <P><B>Q</B> How much space is                  there in a message?</P>                                    <P><B>A</B> If you just want                  to know how much space is available in a single                  message block, you can simply calculate                  <CODE>db_lim - db_base</CODE>. As far as I know,                  there is no way to calculate this for all the                  messages in a chain.</P>                                    <hr width=500 align=center>                                    <P><B>Q</B> Are there any                  invariants that I can use to keep my message blocks                  straight?</P>                                    <P><B>A</B> Yes. The                  invariants are that:</P>                                    <pre>mp-&gt;b_datap-&gt;db_base &lt; mp-&gt;b_datap-&gt;db_limmp-&gt;b_datap-&gt;db_base &lt;= mp-&gt;b_rptr &lt; mp-&gt;b_datap-&gt;db_limmp-&gt;b_datap-&gt;db_base &lt;= mp-&gt;b_wptr &lt;= mp-&gt;b_datap-&gt;db_limmp-&gt;b_rptr &lt;= mp-&gt;b_wptr</pre>                                    <P>These invariants imply that:</P>                                    <UL>                     <LI>there is always at least one byte of space                     in a message</LI>                                          <LI>the read and write pointers always point                     within the data</LI>                                          <LI>the amount of valid data in the message is                     always non-negative</LI>                  </UL>                                    <hr width=500 align=center>                                    <P><B>Q</B> A lot of STREAMS                  allocation functions (e.g. <CODE>allocb</CODE>)                  take a buffer allocation priority value. What                  should I use?</P>                                    <P><B>A</B> At the moment,                  STREAMS is defined to ignore these values. There                  are two reasonable approaches:</P>                                    <OL>                     <LI>Ignore priorities and always pass the                     unspecified priority, i.e. 0.</LI>                                          <LI>Analyze your buffer needs and set your                     priorities appropriately on the assumption that                     one day someone will pay attention to them. For                     example, most data messages would default to                     <CODE>BPRI_MED</CODE>, but high priority control                     messages like TPI ACKs should use                     <CODE>BPRI_HI</CODE>.</LI>                  </OL>                                    <P>I recommend the first approach.</P>                                    <hr width=500 align=center>                                    <P><B>Q</B> What do I do when                  an allocation fails?</P>                                    <P><B>A</B> The approach you                  take depends on the type of module you are writing.                  If you are writing a module that provides an                  unreliable service (such as a DLPI device driver),                  the best thing to do when you run out of memory is                  to just drop the current packet on the floor.                  Because you are providing an unreliable service,                  the upper-layer protocol is required to implement                  some error correction anyway, so there's no point                  complicating your module with intricate error                  handling.</P>                                    <P>If you're writing a reliable service, you must                  be prepared to deal with running out of memory.                  Your primary weapon should be the                  <CODE>mi_bufcall</CODE> routine. This routine                  allows you to stop your current operation and                  schedule your queue's service routine to be called                  when a certain amount of memory is available. You                  then have a flag in your per-stream data that                  allows your service routine to pick up the stalled                  operation before continue on with its normal                  duties.</P>                                    <P>See the <A HREF="#References">Open Transport                  Module Developer Note</A> for more details on                  <CODE>mi_bufcall</CODE>.</P>                  <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>IMPORTANT:</B><BR>You should use <CODE>mi_bufcall</CODE> inpreference to the more traditional<CODE>bufcall</CODE>. See the developernote for the reasons why.</P></TD></TR></TABLE></CENTER><BR><BR>                  <A NAME=TPI></A>                                    <H2>Transport Provider                  Interface (TPI)</H2>                                    <hr width=500 align=center>                                    <P><B>Q</B> I'm writing a                  STREAMS TPI module or driver. Where should I                  start?</P>                                    <P><B>A</B> The best book to                  read is <A HREF="#References">STREAMS Modules and                  Drivers</A>. In terms of sample code, there are a                  number of samples to look at:</P>                                    <UL>                     <LI>TPIFile -- Available on the Developer CDs,                     this sample is a TPI device driver that allows                     you to read a Mac OS file as if it was an OT                     serial port.</LI>                                          <LI>StreamNOP -- Available on the Developer CDs,                     this is a cut down version of TPIFile that                     serves as good starting point for new module                     development.</LI>                                          <LI>tilisten -- Part of the <a href="http://developer.apple.com/sdk/">Open                     Transport SDK</A>, this sample contains the full                     source to the "tilisten" module (a helper module                     used to simplify the listen/accept process for                     clients).</LI>                  </UL>                                    <P>None of these samples are perfect, but they do                  give a flavour of what STREAMS programming is                  like.</P>                                    <hr width=500 align=center>                                    <P><B>Q</B> I'm receiving a TPI                  message. Can I reuse that message to send the                  ACK?</P>                                    <P><B>A</B> See the question                  <A HREF="#ReuseMessage">How do I reuse an existing                  message?</A></P>                                    <hr width=500 align=center>                                    <P><B>Q</B> I'm writing a TPI                  module and I successfully respond to a                  <CODE>T_CONN_REQ</CODE> message by sending a                  <CODE>T_OK_ACK</CODE> message upstream, but my                  client code never leaves <CODE>OTConnect</CODE>.                  What did I do wrong?</P>                                    <P><B>A</B> The short answer                  is that you need to send a connection confirmation                  message (<CODE>T_CONN_CON</CODE>) upstream to                  indicate that the connection is in place.</P>                                    <P>The long answer is that you need to study the                  TPI specification more closely, paying special                  attention to the state diagrams. When your module                  is in <CODE>sta_3 (idle)</CODE> and receives a                  <CODE>conn_req</CODE> event, it should proceed to                  <CODE>sta_5 (w_ack_c_req)</CODE>. When your module                  replies with the <CODE>ok_ack1</CODE>, it proceeds                  to <CODE>sta_6 (w_con_c_req)</CODE>. At this point                  the client is still waiting for a connection                  confirmation message. To complete the connection                  sequence, you need to issue a <CODE>conn_con</CODE>                  event and proceed to <CODE>sta_9                  (data_t)</CODE>.</P>                                    <P>I find it useful to think of the                  <CODE>T_OK_ACK</CODE> as simply saying that the                  primitive being acked was correctly formed; it says                  nothing about whether the request worked. If a                  response is needed, TPI typically has a different                  message (e.g., <CODE>T_BIND_ACK</CODE> or                  <CODE>T_INFO_ACK</CODE>). In the case where                  something needs to be done, like connection setup,                  a distinct message <CODE>T_CONN_CON</CODE> is used                  to 'confirm' the connection is established.</P>                                    <hr width=500 align=center>                                    <P><B>Q</B> The TPI                  specification says that the address to connect to                  is pointed to by the <CODE>DEST_offset</CODE> and                  <CODE>DEST_length</CODE> fields of the                  <CODE>T_CONN_REQ</CODE> message. I know how to find                  the address of this information (using <A HREF="#mi_offset_param"><CODE>mi_offset_paramc</CODE></A>)                  but what is its format?</P>                                    <P><B>A</B> There are two                  aspects to this question. First, how do Open                  Transport clients provide address information.                  Second, how does Open Transport translate that                  client representation into a TPI message.</P>                                    <P>Open Transport uses a standard format for                  address information that's based on the                  <CODE>OTAddress</CODE> type. This type is an                  abstract record that contains only one interesting                  field:</P>                  <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>struct OTAddress{    OTAddressType fAddressType;    UInt8         fAddress[1];};</pre></TD></TR></TABLE></CENTER><BR><BR>                  <P>The <CODE>fAddressType</CODE> field is a two-byte                  quantity that determines the format of the                  remaining fields. All Open Transport addresses are                  derived from this basic structure. For example, in                  the TCP/IP world, OT has two different address                  formats, namely <CODE>InetAddress</CODE> and                  <CODE>DNSAddress</CODE>.</P>                  <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>struct InetAddress{    OTAddressType  fAddressType;  // always AF_INET    InetPort       fPort;         // port number    InetHost       fHost;         // host address in net byte order    UInt8          fUnused[8];    // traditional unused bytes};struct DNSAddress{    OTAddressType  fAddressType;  // always AF_DNS    InetDomainName fName;         // ASCII DNS name};</pre></TD></TR></TABLE></CENTER><BR><BR>                  <P>These are distinguished by the first two bytes. An                  <CODE>InetAddress</CODE> starts with                  <CODE>AF_INET</CODE>, while a                  <CODE>DNSAddress</CODE> starts with                  <CODE>AF_DNS</CODE>. These type bytes are followed                  by an address-format specific number of bytes of                  data. This general layout is common to all address                  formats under OT.</P>                                    <P>When you call an OT API routine and pass in an                  address like this, OT simply copies the entire                  address into a message block without interpreting                  it. When the message reaches the appropriate TPI                  module, that module is responsible for interpreting                  the specified address. It can determine that the                  address is in the appropriate format simply by                  looking at the first two bytes of the address                  buffer. The snippet of code in the next Q&amp;A                  shows how to do this.</P>                                    <hr width=500 align=center>                                    <A NAME="mi_offset_param"></A><P><B>Q</B>                  TPI messages often contain "offset" and "count"                  parameters to reference variable length data. Every                  time I access these, I find myself dying the 'death                  of a thousand pointers'. Is there a better way?</P>                                    <P><B>A</B> I'm glad you                  asked. MPS provides two useful utility routines                  that you can call to access these variable length                  structures. There prototypes are:</P>                  <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>UInt8* mi_offset_param(mblk_t* mp, long offset, long len);UInt8* mi_offset_paramc(mblk_t* mp, long offset, long len);</pre></TD></TR></TABLE></CENTER><BR><BR>                  <P>If you have a simple TPI message (one with a single                  message block), you can call                  <CODE>mi_offset_param</CODE> to get a pointer to                  the structure whose size is <CODE>len</CODE> at the                  given <CODE>offset</CODE> into the message data.                  The routine returns nil if <CODE>offset</CODE> and                  <CODE>len</CODE> are inconsistent with the size of                  the message.</P>                                    <P>If there's a possibility that the data you're                  looking for is not in the first message block of                  the TPI message, you can use                  <CODE>mi_offset_paramc</CODE> to look for it in the                  entire message chain.</P>                                    <P>The following snippet shows how you can use                  <CODE>mi_offset_paramc</CODE> to find the address                  in a <CODE>T_CONN_REQ</CODE> message.</P>                  <BR><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><pre>static void DoConnectRequest(queue_t* q, mblk_t* mp){    T_conn_req *connReq;    OTAddress *connAddr;&nbsp;    [...]&nbsp;    connReq = (T_conn_req *) mp-&gt;b_rptr;&nbsp;    [...]&nbsp;    connAddr = (OTAddress *) mi_offset_paramc(mp,                                connReq-&gt;DEST_offset,                                connReq-&gt;DEST_length);    if (connAddr == nil || connReq-&gt;DEST_length &lt; sizeof(OTAddress)) {        ReplyWithErrorAck(q, mp, TBADADDR, 0);        return;    }    switch ( connAddr-&gt;fAddressType ) {        [...]    }&nbsp;    [...]}</pre></TD></TR></TABLE></CENTER><BR><BR>                                    <hr width=500 align=center>                                    <P><B>Q</B> In my TPI module I                  send data messages but they never arrive on the                  wire/at the client. Any ideas?</P>                                    <P><B>A</B> You have most                  probably forgotten to set the <CODE>b_wptr</CODE>                  field of the message that you are sending. If you                  allocate a new message block, the                  <CODE>b_rptr</CODE> and <CODE>b_wptr</CODE> both                  default to pointing at the start of the data block                  (i.e. <CODE>db_base</CODE>). Given that the amount                  of valid data in the message is defined to be                  <CODE>b_wptr - b_rptr</CODE>, if you forget to set                  the <CODE>b_wptr</CODE> on messages you will find                  that the receiver ignores them.</P><BR><P><A HREF="#top">Back to top</A></P>                  <A NAME=DLPI></A>                                    <H2>Data Link Provider                  Interface (DLPI)</H2>                                    <hr width=500 align=center>                                    <A NAME=DLPIRecommendations></A><P><B>Q</B>                  I'm writing a STREAMS DLPI driver. Where should I                  start?</P>                                    <P><B>A</B> You should start                  with one of the generic STREAMS references                  <A HREF="#References">listed above</A>, then                  continue with the following Open Transport-specific                  material.</P>                                    <UL>                     <LI>If you're writing a Ethernet-style device                     driver (Ethernet, Token Ring, FDDI, Fibre                     Channel, etc.), you should base it on the Apple                     Enet Framework, which is included in <a href="http://developer.apple.com/sdk/">Open                     Transport SDK</A>. This framework significantly                     reduces the amount of work you have to do, and                     guarantees the best performance for high-speed                     devices.</LI>                                          <LI>On the other hand, if you're writing                     something other than an Ethernet-style device                     driver (PPP, SLIP, virtual private network                     (VPN), etc.), you should read the book <a href="http://developer.apple.com/macos/opentransport/OTAdvancedClientProg/index.html">Open                     Transport Advanced Client Programming</A>. The                     <a href="http://developer.apple.com/macos/opentransport/OTAdvancedClientProg/ImplementationNotes.html">Implementation                     Notes</A> chapter gives specific advice for PPP                     and VPN developers.</LI>                  </UL>                                    <hr width=500 align=center>                                    <P><B>Q</B> What's this stuff                  about connection-oriented DLPI drivers?</P>                                    <P><B>A</B> I have no idea!                  As far as the OT mainstream is concerned, all DLPI                  drivers are connection-less                  (<CODE>DL_CLDLS</CODE>). In fact, when OT needs a                  connection-oriented device driver (e.g. serial), it                  uses TPI instead of DLPI. However,                  connection-oriented DLPI drivers may be useful in                  some environments, such as X.25 or ATM.</P>                                    <hr width=500 align=center>                                    <P><B>Q</B> I'm writing the                  code to fill out the <CODE>DL_INFO_ACK</CODE>                  message, and I can't decide what to put in the                  <CODE>dl_provider_style</CODE> field. I'd like to                  use <CODE>DL_STYLE1</CODE> (because then I don't                  have to mess with Physical Points of Attachment                  (PPAs)) but it seems I should be using the later                  <CODE>DL_STYLE2</CODE>. What do you recommend?</P>                                    <P><B>A</B> Unless you have                  an overriding reason to use PPAs, you should return                  <CODE>DL_STYLE1</CODE> in your                  <CODE>DL_INFO_ACK</CODE> message. This will make                  your life easier and there's little need for PPAs                  on the Mac OS.</P>                                    <hr width=500 align=center>                                    <P><B>Q</B> What is this stuff                  about major and minor device numbers?</P>                                    <P><B>A</B> The short answer                  is: an anachronism from UNIX. Major device numbers                  represent the device driver controlling a device.                  This is traditionally an index into a table of                  drivers maintained internally by STREAMS. Under                  Open Transport, drivers are loaded into this table                  on demand, so there's no way you can know what                  major device number your driver is going to                  get.</P>                                    <P>Minor device numbers are used to distinguish                  between multiple functions controlled by a single                  device driver, for example, multiple serial ports                  controlled by the serial port driver. However, this                  definition breaks down in the face of networking,                  even on UNIX systems.</P>                                    <P>It turns out that minor device numbers are used                  to distinguish between different streams connected                  to a driver. Each stream is given a unique minor                  device number by the driver's open routine. This is                  accomplished by means of the <CODE>sflag</CODE>                  parameter. The three possible cases are:</P>                                    <UL>                     <LI><CODE>0</CODE> -- This value indicates that                     the module is being opened as a driver. A                     specific minor device number -- specified by the                     <CODE>devp</CODE> parameter -- is being                     opened.</LI>                                          <LI><CODE>CLONEOPEN</CODE> -- This value                     indicates that the driver is being cloned, i.e.                     the driver should return a unique minor device                     number. You can do this simply by calling                     <CODE>mi_open_comm</CODE>, which does this                     automatically.</LI>                                          <LI><CODE>MODOPEN</CODE> -- This value indicates                     that the module is being pushed; there is no                     minor device number in this case.</LI>                  </UL>                                    <P>So how does this affect you? It doesn't! If you                  call <CODE>mi_open_comm</CODE> in your module's                  open routine, it takes care of all these details.                  Your open routine might also want to check that you                  are being opened as a module (i.e. <CODE>sflag ==                  MODOPEN</CODE>) or as a driver (<CODE>sflag !=                  MODOPEN</CODE>), just to be paranoid. But,                  otherwise, you should not worry about device                  numbers and distinguish your streams using the                  <CODE>q</CODE> parameter.</P><BR><P><A HREF="#top">Back to top</A></P>                  <A NAME=Summary></A>                                    <H2>Summary</H2>                                    <P>Open Transport is based on an industry standard                  STREAMS networking kernel. Open Transport STREAMS                  is documented in a number of <A HREF="#References">UNIX                  books</A>. and in the <A HREF="#References">Open                  Transport Module Developer Note</A> . This Note                  answers some Frequently Asked Questions about                  issues that are not adequately covered in the other                  documentation.</P>         <BR><P><A HREF="#top">Back to top</A></P>                  <A NAME="References"></A>         <H2>References</H2>         <p><CITE>Programmer's Guide: STREAMS, UNIXSystem V Release 4</CITE>, UNIX Press, ISBN0-13-02-0660-1</p><p><CITE>STREAMS Modules and Drivers, UNIXSystem V Release 4.2</CITE>, UNIX Press, ISBN0-13-066879-6</p>                     <p>"Open Transport Module Developer Note" (partof the <a href="http://developer.apple.com/sdk/">Open TransportSDK</A>)</p>                     <p>UNIX "man" pages for "putmsg", "getmsg",etc.</p>                     <p><a href="http://developer.apple.com/macos/opentransport">OpenTransport web page</A></p>                     <p><A HREF="http://lists.apple.com/mailman/listinfo/opentransportdev">OpenTransport programmers mailing list</A></p><BR><P><A HREF="#top">Back to top</A></P>         <P><A NAME=changes></A></P>                  <H2>Change History</H2>                  <TABLE BORDER=0 CELLPADDING=3 WIDTH=544>            <TR>               <td width=100 align=left>                  <P ALIGN=center>06-February-1998</P>               </TD>               <td align="left">                  <P>First published.</P>               </TD>            </TR>            <TR>               <td width=100 align=left>                  <P ALIGN=center>01-February-1999</P>               </TD>               <td align="left">                  <P>Updated to add additional                     <A HREF="#References">references</A>.</P>               </TD>            </TR>            <TR>               <td width=100 align=left>                  <P ALIGN=center>01-March-1999</P>               </TD>               <td align="left">                  <P>Updated to mention "Open                     Transport Advanced Client Programming" in the                     <A HREF="#DLPIRecommendations">recommendation                     for DLPI device driver writers</A>.</P>               </TD>            </TR>                      <TR>               <td width=100 align=left>                  <P ALIGN=center>01-September-2000</P>               </TD>               <td align="left">                  <P>Updated to fix some broken                     links.</P>               </TD>            </TR>         </TABLE><BR><P><A HREF="#top">Back to top</A></P>        <A NAME="Downloads"></A>         <br><h2>Downloadables</h2>        <center><TABLE BORDER=0 CELLPADDING=3 WIDTH="600">          <TR>             <td width=50 align=left>               <P ALIGN=center><img src="images/acrobatsmall.gif" align=middle alt="Acrobat" width=22 height=23></P>            </TD>            <td align="left">               <p>Acrobat version of this Note (184K).</P>            </TD>            <td width=60 align=left>               <p><A HREF="pdf/tn1117.pdf">Download</A></P>            </TD>          </TR>        </TABLE></center><BR><BR>        </td></tr></table></center><!-- end_content --><!-- begin_footer_information -->	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/technotes/tn/tn1117.html%3Fid%3DDTS10002957-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/technotes/tn/tn1117.html%3Fid%3DDTS10002957-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/technotes/tn/tn1117.html%3Fid%3DDTS10002957-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>
<!--#include virtual="/includes/footer"--><!-- end_footer_information --></BODY></HTML>