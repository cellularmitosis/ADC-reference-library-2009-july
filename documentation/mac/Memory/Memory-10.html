<!-- Generated by Harlequin WebMaker 2.2.3 (23-Apr-1996)
LispWorks 3.2.2 -->
<HTML> <HEAD>
<TITLE>About Memory (IM: M)</TITLE>
<LINK REL="stylesheet" TYPE="text/css" HREF="../../Resources/CSS/frameset_styles.css">
<script type="text/javascript" language="JavaScript" src="../../Resources/JavaScript/page.js"></script>
</head>

<BODY BGCOLOR="#FFFFFF" TEXT="#000000">

<div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;">
<div class="legacybox" style="position: relative;">
<h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../Resources/Images/closebutton.png" width="14" height="14" border="0" align="top" alt="close button"></a></span></h1><p><b>Important:</b>
The information in this document is obsolete and should not be used for new development.</p></div></div></div>


<A NAME=HEADING10></A>



<!-- start of header -->

<!--#include virtual="/includes/framesetheader" -->

<!-- end of header -->


<!-- Main Body -->

<CENTER>
<P>
<A HREF="Memory-9.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Memory-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Memory-202.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="Memory-11.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<FONT SIZE=-1><DL><DT><a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><B>Inside Macintosh:</B></A> <A HREF="Memory-2.html"><B>Memory</B></A> / <BR><DD><A HREF="Memory-9.html"><B>Chapter 1 - Introduction to Memory Management</B></A></DL></FONT><P>
<HR>
<BLOCKQUOTE>
<A NAME=HEADING10-0></A>
<H1>About Memory</H1>
 A Macintosh computer's available RAM is used by the Operating System, applications, and other software components, such as device drivers and system extensions. This section describes both the general organization of memory by the Operating System <BR>and the organization of the memory partition allocated to your application when <BR>it is launched. This section also provides a preliminary description of three related <BR>memory topics:<P>
<UL>
<LI>temporary memory
<LI>virtual memory
<LI>24- and 32-bit addressing<P>
</UL>
 For more complete information on these three topics, you need to read the remaining chapters in this book.<P>
<A NAME=HEADING10-6></A>
<H2>Organization of Memory by the Operating System<A NAME=MARKER-2-36></A></H2>
 <A NAME=MARKER-2-25></A>When the Macintosh Operating System starts up, it divides the available RAM into two broad sections. It reserves for itself a zone or <B>partition</B> of memory known as the <B>system partition.</B> The system partition always begins at the lowest addressable byte of memory (memory address 0) and extends upward. The system partition contains a system heap and a set of global variables, described in the next two sections.<A NAME=MARKER-2-38></A><A NAME=MARKER-2-16></A><A NAME=MARKER-2-15></A><A NAME=MARKER-2-41></A><P>
 All memory outside the system partition is available for allocation to applications or other software components. In system software version 7.0 and later (or when MultiFinder is running in system software versions 5.0 and 6.0), the user can have multiple applications open at once. When an application is launched, the Operating System assigns it a section of memory known as its<B> application partition.</B> In general, an application uses only the memory contained in its own application partition.<A NAME=MARKER-2-43></A><P>
 <A HREF=#MARKER-9-44>Figure 1-1</A> illustrates the organization of memory when several applications are open at the same time. The system partition occupies the lowest position in memory. Application partitions occupy part of the remaining space. Note that application partitions are loaded into the top part of memory first.<P>
<B>Figure 1-1  <A NAME=MARKER-9-44></A>Memory organization with several applications open</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/IMM-01.jpg">
 In <A HREF=#MARKER-9-44>Figure 1-1</A>, three applications are open, each with its own application partition. The application labeled Application 1 is the active application. (The labels on the right side of the figure are system global variables, explained in <A HREF=#MARKER-9-48>"The System Global Variables" on page 1-6</A>.)<P>
<A NAME=HEADING10-13></A>
<H3>The System Heap</H3>
 <A NAME=MARKER-2-45></A>The main part of the system partition is an area of memory known as the <B>system heap.</B> In general, the system heap is reserved for exclusive use by the Operating System and other system software components, which load into it various items such as system resources, system code segments, and system data structures. All system buffers and queues, for example, are allocated in the system heap.<A NAME=MARKER-2-210></A><P>
 The system heap is also used for code and other resources that do not belong to specific applications, such as code resources that add features to the Operating System or that provide control of special-purpose peripheral equipment. System patches and system extensions (stored as code resources of type <CODE>'INIT'</CODE>) are loaded into the system heap during the system startup process. Hardware device drivers (stored as code resources of type <CODE>'DRVR'</CODE>) are loaded into the system heap when the driver is opened.<P>
 Most applications don't need to load anything into the system heap. In certain cases, however, you might need to load resources or code segments into the system heap. For example, if you want a vertical retrace task to continue to execute even when your application is in the background, you need to load the task and any data associated with it into the system heap. Otherwise, the Vertical Retrace Manager ignores the task when your application is in the background.<A NAME=MARKER-2-47></A><P>
<A NAME=HEADING10-17></A>
<H3><A NAME=MARKER-9-48></A>The System Global Variables</H3>
 <A NAME=MARKER-2-229></A>The lowest part of memory is occupied by a collection of global variables called <B>system global variables</B> (or<B> low-memory</B> <B>system global variables</B>). The Operating System uses these variables to maintain different kinds of information about the operating environment. For example, the <CODE>Ticks</CODE> global variable contains the number of ticks (sixtieths of a second) that have elapsed since the system was most recently started up. Similar variables contain, for example, the height of the menu bar (<CODE>MBarHeight</CODE>) and pointers to the heads of various operating-system queues (<CODE>DTQueue</CODE>, <CODE>FSQHdr</CODE>, <CODE>VBLQueue</CODE>, and so forth). Most low-memory global variables are of this variety: they contain information that is generally useful only to the Operating System or other system software components.<P>
 Other low-memory global variables contain information about the current application. For example, the <CODE>ApplZone</CODE> global variable contains the address of the first byte <BR>of the active application's partition. The <CODE>ApplLimit</CODE> global variable contains the <BR>address of the last byte the active application's heap can expand to include. The <CODE>CurrentA5</CODE> global variable contains the address of the boundary between the active application's global variables and its application parameters. Because these global variables contain information about the active application, the Operating System changes the values of these variables whenever a context switch occurs.<P>
 In general, it is best to avoid reading or writing low-memory system global variables. Most of these variables are undocumented, and the results of changing their values can be unpredictable. Usually, when the value of a low-memory global variable is likely to be useful to applications, the system software provides a routine that you can use to read or write that value. For example, you can get the current value of the <CODE>Ticks</CODE> global variable by calling the <CODE>TickCount</CODE> function.<P>
 In rare instances, there is no routine that reads or writes the value of a documented global variable. In those cases, you might need to read or write that value directly. See the chapter "Memory Manager" in this book for instructions on reading and writing the values of low-memory global variables from a high-level language.<A NAME=MARKER-2-50></A><A NAME=MARKER-2-26></A><P>
<A NAME=HEADING10-22></A>
<H2>Organization of Memory in an Application Partition</H2>
 <A NAME=MARKER-2-52></A>When your application is launched, the Operating System allocates for it a partition of memory called its <B>application partition.</B> That partition contains required segments of the application's code as well as other data associated with the application. <A HREF=#MARKER-9-53>Figure 1-2</A> illustrates the general organization of an application partition.<P>
<B>Figure 1-2  <A NAME=MARKER-9-53></A>Organization of an application partition</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/IMM-02.jpg">
 Your application partition is divided into three major parts:<P>
<UL>
<LI>the application stack
<LI>the application heap
<LI>the application global variables and A5 world<P>
</UL>
 The heap is located at the low-memory end of your application partition and always expands (when necessary) toward high memory. The A5 world is located at the high-memory end of your application partition and is of fixed size. The stack begins <BR>at the low-memory end of the A5 world and expands downward, toward the top of <BR>the heap.<P>
 As you can see in <A HREF=#MARKER-9-53>Figure 1-2</A>, there is usually an unused area of memory between the stack and the heap. This unused area provides space for the stack to grow without encroaching upon the space assigned to the application heap. In some cases, however, the stack might grow into space reserved for the application heap. If this happens, it is very likely that data in the heap will become corrupted.<P>
 <A NAME=MARKER-9-52></A>The <CODE>ApplLimit</CODE> global variable marks the upper limit to which your heap can grow. If you call the <CODE>MaxApplZone</CODE> procedure at the beginning of your program, the heap immediately extends all the way up to this limit. If you were to use all of the heap's free space, the Memory Manager would not allow you to allocate additional blocks above <CODE>ApplLimit</CODE>. If you do not call <CODE>MaxApplZone</CODE>, the heap grows toward <CODE>ApplLimit</CODE> whenever the Memory Manager finds that there is not enough memory in the heap to fill a request. However, once the heap grows up to <CODE>ApplLimit</CODE>, it can grow no further. Thus, whether you maximize your application heap or not, you can use only the space between the bottom of the heap and <CODE>ApplLimit</CODE>.<A NAME=MARKER-2-146></A><P>
 Unlike the heap, the stack is not bounded by <CODE>ApplLimit</CODE>. If your application uses heavily nested procedures with many local variables or uses extensive recursion, the stack could grow downward beyond <CODE>ApplLimit</CODE>. Because you do not use Memory Manager routines to allocate memory on the stack, the Memory Manager cannot stop your stack from growing beyond <CODE>ApplLimit</CODE> and possibly encroaching upon space reserved for the heap. However, a vertical retrace task checks approximately 60 times each second to see if the stack has moved into the heap. If it has, the task, known as the "stack sniffer," generates a system error. This system error alerts you that you have allowed the stack to grow too far, so that you can make adjustments. See <A HREF=Memory-12.html#MARKER-9-246>"Changing the Size of the Stack" on page 1-39</A> for instructions on how to change the size of your application stack.<A NAME=MARKER-2-56></A><A NAME=MARKER-2-148></A><A NAME=MARKER-2-149></A><P>
<DL>
<DT><B>Note</B>
<DD><A NAME=MARKER-9-59></A>To ensure during debugging that your application generates this system error if the stack extends beyond <CODE>ApplLimit</CODE>, you should call <CODE>MaxApplZone</CODE> at the beginning of your program to expand the heap to <CODE>ApplLimit</CODE>. For more information on expanding the heap, see <A HREF=Memory-12.html#MARKER-9-244>"Setting Up the Application Heap"</A> beginning on <A HREF=Memory-12.html#MARKER-9-244>page 1-38</A>.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
<A NAME=HEADING10-35></A>
<H3>The Application Stack</H3>
 The <B>stack</B> is an area of memory in your application partition that can grow or shrink at one end while the other end remains fixed. This means that space on the stack is always allocated and released in LIFO (last-in, first-out) order. The last item allocated is always the first to be released. It also means that the allocated area of the stack is always contiguous. Space is released only at the top of the stack, never in the middle, so there can never be any unallocated "holes" in the stack.<A NAME=MARKER-2-416></A><P>
 By convention, the stack grows from high memory toward low memory addresses. The end of the stack that grows or shrinks is usually referred to as the "top" of the stack, even though it's actually at the lower end of memory occupied by the stack.<P>
 Because of its LIFO nature, the stack is especially useful for memory allocation connected with the execution of functions or procedures. When your application calls a routine, space is automatically allocated on the stack for a stack frame. A <B>stack frame</B> contains the routine's parameters, local variables, and return address. <A HREF=#MARKER-9-62>Figure 1-3</A> illustrates how the stack expands and shrinks during a function call. The leftmost diagram shows the stack just before the function is called. The middle diagram shows the stack expanded to hold the stack frame. Once the function is executed, the local variables and function parameters are popped off the stack. If the function is a Pascal function, all that remains is the previous stack with the function result on top.<A NAME=MARKER-2-61></A><P>
<B>Figure 1-3  The application stack<A NAME=MARKER-9-62></A></B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/IMM-06.jpg">
<DL>
<DT><B>Note</B>
<DD>Dynamic memory allocation on the stack is usually handled automatically if you are using a high-level development language such as Pascal. The compiler generates the code that creates and deletes stack frames for each function or procedure call.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
<A NAME=HEADING10-42></A>
<H3>The Application Heap</H3>
 <A NAME=MARKER-2-63></A>An <B>application heap</B> is the area of memory in your application partition in which space is dynamically allocated and released on demand. The heap begins at the low-memory end of your application partition and extends upward in memory. The heap contains virtually all items that are not allocated on the stack. For instance, your application heap contains the application's code segments and resources that are currently loaded into memory. The heap also contains other dynamically allocated items such as window records, dialog records, document data, and so forth.<A NAME=MARKER-2-158></A><A NAME=MARKER-2-58></A><P>
 <A NAME=MARKER-2-147></A>You allocate space within your application's heap by making calls to the Memory Manager, either directly (for instance, using the <CODE>NewHandle</CODE> function) or indirectly <BR>(for instance, using a routine such as <CODE>NewWindow</CODE>, which calls Memory Manager routines). Space in the heap is allocated in <B>blocks,</B> which can be of any size needed <BR>for a particular object.<A NAME=MARKER-2-123></A><P>
 The Memory Manager does all the necessary housekeeping to keep track of blocks in the heap as they are allocated and released. Because these operations can occur in any order, the heap doesn't usually grow and shrink in an orderly way, as the stack does. Instead, after your application has been running for a while, the heap can tend to become fragmented into a patchwork of allocated and free blocks, as shown in <A HREF=#MARKER-9-69>Figure 1-4</A>. This fragmentation is known as <B>heap fragmentation.<A NAME=MARKER-2-111></A></B><P>
<B>Figure 1-4  <A NAME=MARKER-9-69></A>A fragmented heap</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/IMM-03.jpg"><P></P>
 One result of heap fragmentation is that the Memory Manager might not be able to satisfy your application's request to allocate a block of a particular size. Even though there is enough free space available, the space is broken up into blocks smaller than the requested size. When this happens, the Memory Manager tries to create the needed space by moving allocated blocks together, thus collecting the free space in a single larger block. This operation is known as <B>heap compaction.</B> <A HREF=#MARKER-9-72>Figure 1-5</A> shows the results of compacting the fragmented heap shown in <A HREF=#MARKER-9-69>Figure 1-4</A>.<A NAME=MARKER-9-131></A><A NAME=MARKER-2-108></A><P>
<B>Figure 1-5  <A NAME=MARKER-9-72></A>A compacted heap</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/IMM-04.jpg"><P></P>
 Heap fragmentation is generally not a problem as long as the blocks of memory you allocate are free to move during heap compaction. There are, however, two situations in which a block is not free to move: when it is a nonrelocatable block, and when it is a locked, relocatable block. To minimize heap fragmentation, you should use nonrelocatable blocks sparingly, and you should lock relocatable blocks only when absolutely necessary. See <A HREF=Memory-11.html#MARKER-9-98>"Relocatable and Nonrelocatable Blocks"</A> starting on <A HREF=Memory-11.html#MARKER-9-98>page 1-16</A> for a description of relocatable and nonrelocatable blocks, and <A HREF=Memory-11.html#MARKER-9-139>"Heap Fragmentation" on page 1-24</A> for a description of how best to avoid fragmenting your heap.<A NAME=MARKER-2-236></A><A NAME=MARKER-2-24></A><P>
<A NAME=HEADING10-52></A>
<H3>The Application Global Variables and A5 World</H3>
 Your application's global variables are stored in an area of memory near the top of your application partition known as the application <B>A5 world.</B> The A5 world contains four kinds of data:<A NAME=MARKER-2-74></A><P>
<UL>
<LI>application global variables<A NAME=MARKER-2-76></A>
<LI>application QuickDraw global variables
<LI>application parameters
<LI>the application's jump table<P>
</UL>
 Each of these items is of fixed size, although the sizes of the global variables and of the jump table may vary from application to application. <A HREF=#MARKER-9-77>Figure 1-6</A> shows the standard organization of the A5 world.<P>
<B>Figure 1-6  <A NAME=MARKER-9-77></A>Organization of an application's A5 world</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/IMM-05.jpg">
<DL>
<DT><B>Note</B>
<DD>An application's global variables may appear either above or below the QuickDraw global variables. The relative locations of these two items are determined by your development system's linker. In addition, part of the jump table might appear below the boundary pointed to by <CODE>CurrentA5</CODE>.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
 <A NAME=MARKER-2-78></A>The system global variable <CODE>CurrentA5</CODE> points to the boundary between the <BR>current application's global variables and its application parameters. For this reason, <BR>the application's global variables are found as negative offsets from the value of <CODE>CurrentA5</CODE>. This boundary is important because the Operating System uses it to access the following information from your application: its global variables, its QuickDraw global variables, the application parameters, and the jump table. This information is known collectively as the A5 world because the Operating System uses the microprocessor's A5 register to point to that boundary.<A NAME=MARKER-9-167></A><A NAME=MARKER-2-80></A><P>
 Your application's <B>QuickDraw global variables</B> contain information about its drawing environment. For example, among these variables is a pointer to the current <BR>graphics port.<A NAME=MARKER-2-81></A><P>
 Your application's <B>jump table</B> contains an entry for each of your application's routines that is called by code in another segment. The Segment Manager uses the jump table to determine the address of any externally referenced routines called by a code segment. For more information on jump tables, see the chapter "Segment Manager" in <I><A HREF="../Processes/Processes-2.html">Inside Macintosh: Processes</A></I>.<A NAME=MARKER-2-72></A><P>
 The <B>application parameters</B> are 32 bytes of memory located above the application global variables; they're reserved for use by the Operating System. The first long word of those parameters is a pointer to your application's QuickDraw global variables.<A NAME=MARKER-2-73></A><A NAME=MARKER-2-84></A><A NAME=MARKER-2-85></A><P>
<A NAME=HEADING10-66></A>
<H2>Temporary Memory</H2>
 In the Macintosh multitasking environment, each application is limited to a particular memory partition (whose size is determined by information in the <CODE>'SIZE'</CODE> resource of that application). The size of your application's partition places certain limits on the size of your application heap and hence on the sizes of the buffers and other data structures that your application uses. In general, you specify an application partition size that is large enough to hold all the buffers, resources, and other data that your application is likely to need during its execution.<A NAME=MARKER-2-181></A><A NAME=MARKER-2-69></A><P>
 If for some reason you need more memory than is currently available in your application heap, you can ask the Operating System to let you use any available memory that is not yet allocated to any other application. This memory, known as <B>temporary memory,</B> is allocated from the available unused RAM; usually, that memory is not contiguous with the memory in your application's zone. <A HREF=#MARKER-9-89>Figure 1-7</A> shows an application using some temporary memory.<A NAME=MARKER-2-90></A><P>
<B>Figure 1-7  <A NAME=MARKER-9-89></A><A NAME=MARKER-21-90></A>Using temporary memory allocated from unused RAM</B><P>
<IMG ALIGN = BOTTOM SRC = "graphics/IMM-07.jpg">
 In <A HREF=#MARKER-9-89>Figure 1-7</A>, Application 1 has almost exhausted its application heap. As a result, it has requested and received a large block of temporary memory, extending from the top of Application 2's partition to the top of the allocatable space. Application 1 can use the temporary memory in whatever manner it desires.<P>
 Your application should use temporary memory only for occasional short-term purposes that could be accomplished in less space, though perhaps less efficiently. For example, if you want to copy a large file, you might try to allocate a fairly large buffer of temporary memory. If you receive the temporary memory, you can copy data from the source file into the destination file using the large buffer. If, however, the request for temporary memory fails, you can instead use a smaller buffer within your application heap. Although using the smaller buffer might prolong the copying operation, the file is nonetheless copied.<P>
 One good reason for using temporary memory only occasionally is that you cannot assume that you will always receive the temporary memory you request. For example, in <A HREF=#MARKER-9-89>Figure 1-7</A>, all the available memory is allocated to the two open applications; any further requests by either one for some temporary memory would fail. For complete details on using temporary memory, see the chapter "Memory Manager" in this book.<P>
<A NAME=HEADING10-74></A>
<H2>Virtual Memory</H2>
 In system software version 7.0 and later, suitably equipped Macintosh computers can take advantage of a feature of the Operating System known as <B>virtual memory,</B> by which the machines have a logical address space that extends beyond the limits of the available physical memory. Because of virtual memory, a user can load more programs and data into the logical address space than would fit in the computer's physical RAM.<A NAME=MARKER-2-186></A><P>
 The Operating System extends the address space by using part of the available secondary storage (that is, part of a hard disk) to hold portions of applications and data that are not currently needed in RAM. When some of those portions of memory are needed, the Operating System swaps out unneeded parts of applications or data to the secondary storage, thereby making room for the parts that are needed.<P>
 It is important to realize that virtual memory operates transparently to most applications. Unless your application has time-critical needs that might be adversely affected by the operation of virtual memory or installs routines that execute at interrupt time, you do not need to know whether virtual memory is operating. For complete details on virtual memory, see the chapter "Virtual Memory Manager" later in this book.<P>
<A NAME=HEADING10-78></A>
<H2>Addressing Modes</H2>
 On suitably equipped Macintosh computers, the Operating System supports <B>32-bit addressing</B>, that is, the ability to use 32 bits to determine memory addresses. Earlier versions of system software use 24-bit addressing, where the upper 8 bits of memory addresses are ignored or used as flag bits. In a 24-bit addressing scheme, the logical address space has a size of 16 MB. Because 8 MB of this total are reserved for I/O space, ROM, and slot space, the largest contiguous program address space is 8 MB. When 32-bit addressing is in operation, the maximum program address space is 1 GB.<A NAME=MARKER-2-92></A><A NAME=MARKER-2-192></A><P>
 <A NAME=MARKER-2-422></A><A NAME=MARKER-2-237></A>The ability to operate with 32-bit addressing is available only on certain Macintosh models, namely those with systems that contain a 32-bit Memory Manager. (For compatibility reasons, these systems also contain a 24-bit Memory Manager.) In order for your application to work when the machine is using 32-bit addressing, it must be <B>32-bit clean</B>, that is, able to run in an environment where all 32 bits of a memory address are significant. Fortunately, writing applications that are 32-bit clean is relatively easy if you follow the guidelines in <a href="../../macos8/mac8.html" onmouseover="window.status='Macintosh Documentation'; return true"><I>Inside Macintosh</I></A>. In general, applications are not 32-bit clean because they manipulate flag bits in master pointers directly (for instance, to mark the associated memory blocks as locked or purgeable) instead of using Memory Manager routines to achieve the desired result. See <A HREF=Memory-11.html#MARKER-9-98>"Relocatable and Nonrelocatable Blocks" on page 1-16</A> for a description of master pointers.<A NAME=MARKER-2-198></A><P>
<DL>
<DT><B>WARNING</B>
<DD><A NAME=MARKER-9-97></A>You should never make assumptions about the contents of Memory Manager data structures, including master pointers and zone headers. These structures have changed in the past and they are likely to change again in the future.<EM></EM>  <IMG ALIGN = BOTTOM SRC = "graphics/triangle.gif">
</DL>
 Occasionally, an application running when 24-bit addressing is enabled might need to modify memory addresses to make them compatible with the 24-bit Memory Manager. In addition, drivers or other code might need to use 32-bit addresses, even when running in 24-bit mode. See the descriptions of the routines <CODE>StripAddress</CODE> and <CODE>Translate24to32</CODE> in the chapter "Memory Management Utilities" for details.<P>

</BLOCKQUOTE>
<HR>
<center>
<A HREF="Memory-9.html"><IMG ALIGN = BOTTOM SRC = "prev.gif" border=none hspace=20 alt="Previous"></A> <A HREF="Memory-2.html"><IMG ALIGN = BOTTOM SRC = "content.gif" border=none hspace=20 alt="Book Contents"></A> <A HREF="Memory-202.html"><IMG ALIGN = BOTTOM SRC = "index.gif" border=none hspace=20 alt="Book Index"></A> <A HREF="Memory-11.html"><IMG ALIGN = BOTTOM SRC = "next.gif" border=none hspace=20 alt="Next"></A> </CENTER><P>
<center><font size=-1><A HREF="Memory-3.html">&copy; Apple Computer, Inc.</A><br>3 JUL 1996</center></font><P>

<!-- start of footer  -->

<!--#include virtual="/includes/framesetfooter" -->

<!-- end of footer -->


</BODY>
</HTML>  
