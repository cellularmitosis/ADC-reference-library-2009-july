<html><head><title>Mac OS X
 Manual Page For perlfaq9(1)</title>
<style type="text/css"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { font-size: 1px; background: #ffffff; color: #ffffff; } --></style>
<style type="text/css" media="print, aural, braille, embossed, projection, tty"><!-- @import "../../../../adcstyle.css"; .char {background: #ffffff; color:#0000ff;}.comment {background:#ffffff; color:#236e25}.function {background:#ffffff; color:#000000;}.keyword {background:#ffffff; color:#761550;}.number {background: #ffffff; color:#0000ff;}.param {background:#ffffff; color:#000000;}.preprocessor {background:#ffffff; color:#236e25}.string {background: #ffffff; color:#891315;}.template {background:#ffffff; color:#761550;}.type {background:#ffffff; color:#761550;}.var {background:#ffffff; color:#000000;} pre.manpages {font-size: 10pt;} .graybox { border-top: 1px solid #919699; border-left: 1px solid #919699; margin-bottom: 10px; } .graybox th { padding: 4px 8px 4px 8px; background: #E2E2E2; font-size: 12px; font-weight: bold; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .graybox td { padding: 8px; font-size: 12px; text-align: left; vertical-align: top; border-bottom: 1px solid #919699; border-right: 1px solid #919699; } .whiteout { display: none; } --></style>
</head><body bgcolor="white">
<a name="//apple_ref/doc/man/1/perlfaq9" title="Mac OS X
 Manual Page for perlfaq9(1)"><!-- headerDoc=man; indexgroup=Section 1; uid="//apple_ref/doc/man/1/perlfaq9"; name=perlfaq9(1) --></a>
<!--#include virtual="/includes/framesetheader"-->
<table width=600><tr><td scope="row">
<!-- begin breadcrumb insert request --><font face="Geneva,Helvetica,Arial" size="1">
 <a target="_top" href="http://developer.apple.com">ADC Home</a> <b>&gt;</b> <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> <b>&gt;</b> <a href="../../../../../reference/index.html#//apple_ref/doc/uid/TP30001281" target="_top">Reference</a> <b>&gt;</b> <!-- a href="" target="_top" -->Mac OS X<!-- /a --> <b>&gt;</b> <a href="../index.html#//apple_ref/doc/framework/manpages" target="_top">Mac OS X Man Pages</a></font>
<!-- end breadcrumb insert request -->
<p>&nbsp;</p>
</td></tr></table>
<!-- end of header -->
<table border="0"  cellpadding="2" cellspacing="2" width="630pt"><tr><td valign="top" height="12" colspan="5" scope="row">
<p style='text-align:justify;'>This document is a Mac OS X manual page.  Manual pages are a command-line technology
for providing documentation.  You can view these manual pages locally using the
<a href="man.1.html#//apple_ref/doc/man/1/man">man(1)</a> command.
These manual pages come from many different sources, and thus, have a variety of writing
styles.</p>
<p style='text-align:justify;'>For more information about the manual page format, see the manual page for 
<a href="../man5/manpages.5.html#//apple_ref/doc/man/5/manpages">manpages(5)</a>.</p>
</td></tr></table>
<hr />
<table border="0"  cellpadding="2" cellspacing="2" width="300"><tr><td valign="top" height="12" colspan="5" scope="row"><pre class="manpages"><tt>
PERLFAQ9(1)                           Perl Programmers Reference Guide                           PERLFAQ9(1)



<b>NAME</b>
       perlfaq9 - Networking ($Revision: 1.28 $, $Date: 2005/12/31 00:54:37 $)

<b>DESCRIPTION</b>
       This section deals with questions related to networking, the internet, and a few on the web.

       <b>What</b> <b>is</b> <b>the</b> <b>correct</b> <b>form</b> <b>of</b> <b>response</b> <b>from</b> <b>a</b> <b>CGI</b> <b>script?</b>

       (Alan Flavell &lt;flavell+www@a5.ph.gla.ac.uk&gt; answers...)

       The Common Gateway Interface (CGI) specifies a software interface between a program ("CGI script")
       and a web server (HTTPD). It is not specific to Perl, and has its own FAQs and tutorials, and usenet
       group, comp.infosystems.www.authoring.cgi

       The CGI specification is outlined in an informational RFC: <a href="http://www.ietf.org/rfc/rfc3875">http://www.ietf.org/rfc/rfc3875</a>

       Other relevant documentation listed in: <a href="http://www.perl.org/CGI_MetaFAQ.html">http://www.perl.org/CGI_MetaFAQ.html</a>

       These Perl FAQs very selectively cover some CGI issues. However, Perl programmers are strongly
       advised to use the CGI.pm module, to take care of the details for them.

       The similarity between CGI response headers (defined in the CGI specification) and HTTP response
       headers (defined in the HTTP specification, RFC2616) is intentional, but can sometimes be confusing.

       The CGI specification defines two kinds of script: the "Parsed Header" script, and the "Non Parsed
       Header" (NPH) script. Check your server documentation to see what it supports. "Parsed Header"
       scripts are simpler in various respects. The CGI specification allows any of the usual newline repre-
       sentations in the CGI response (it's the server's job to create an accurate HTTP response based on
       it). So "\n" written in text mode is technically correct, and recommended. NPH scripts are more
       tricky: they must put out a complete and accurate set of HTTP transaction response headers; the HTTP
       specification calls for records to be terminated with carriage-return and line-feed, i.e ASCII
       \015\012 written in binary mode.

       Using CGI.pm gives excellent platform independence, including EBCDIC systems. CGI.pm selects an
       appropriate newline representation ($CGI::CRLF) and sets binmode as appropriate.

       <b>My</b> <b>CGI</b> <b>script</b> <b>runs</b> <b>from</b> <b>the</b> <b>command</b> <b>line</b> <b>but</b> <b>not</b> <b>the</b> <b>browser.</b>  <b>(500</b> <b>Server</b> <b>Error)</b>

       Several things could be wrong.  You can go through the "Troubleshooting Perl CGI scripts" guide at

               <a href="http://www.perl.org/troubleshooting_CGI.html">http://www.perl.org/troubleshooting_CGI.html</a>

       If, after that, you can demonstrate that you've read the FAQs and that your problem isn't something
       simple that can be easily answered, you'll probably receive a courteous and useful reply to your
       question if you post it on comp.infosystems.www.authoring.cgi (if it's something to do with HTTP or
       the CGI protocols).  Questions that appear to be Perl questions but are really CGI ones that are
       posted to comp.lang.perl.misc are not so well received.

       The useful FAQs, related documents, and troubleshooting guides are listed in the CGI Meta FAQ:

               <a href="http://www.perl.org/CGI_MetaFAQ.html">http://www.perl.org/CGI_MetaFAQ.html</a>

       <b>How</b> <b>can</b> <b>I</b> <b>get</b> <b>better</b> <b>error</b> <b>messages</b> <b>from</b> <b>a</b> <b>CGI</b> <b>program?</b>

       Use the CGI::Carp module.  It replaces "warn" and "die", plus the normal Carp modules "carp",
       "croak", and "confess" functions with more verbose and safer versions.  It still sends them to the
       normal server error log.

           use CGI::Carp;
           warn "This is a complaint";
           die "But this one is serious";

       The following use of CGI::Carp also redirects errors to a file of your choice, placed in a BEGIN
       block to catch compile-time warnings as well:

           BEGIN {
               use CGI::Carp qw(carpout);
               open(LOG, "&gt;&gt;/var/local/cgi-logs/mycgi-log")
                   or die "Unable to append to mycgi-log: $!\n";
               carpout(*LOG);
           }

       You can even arrange for fatal errors to go back to the client browser, which is nice for your own
       debugging, but might confuse the end user.

           use CGI::Carp qw(fatalsToBrowser);
           die "Bad error here";

       Even if the error happens before you get the HTTP header out, the module will try to take care of
       this to avoid the dreaded server 500 errors.  Normal warnings still go out to the server error log
       (or wherever you've sent them with "carpout") with the application name and date stamp prepended.

       <b>How</b> <b>do</b> <b>I</b> <b>remove</b> <b>HTML</b> <b>from</b> <b>a</b> <b>string?</b>

       The most correct way (albeit not the fastest) is to use HTML::Parser from CPAN.  Another mostly cor-
       rect way is to use HTML::FormatText which not only removes HTML but also attempts to do a little sim-
       ple formatting of the resulting plain text.

       Many folks attempt a simple-minded regular expression approach, like "s/&lt;.*?&gt;//g", but that fails in
       many cases because the tags may continue over line breaks, they may contain quoted angle-brackets, or
       HTML comment may be present.  Plus, folks forget to convert entities--like "&amp;lt;" for example.

       Here's one "simple-minded" approach, that works for most files:

           #!/usr/bin/perl -p0777
           s/&lt;(?:[^&gt;'"]*|(['"]).*?\1)*&gt;//gs

       If you want a more complete solution, see the 3-stage striphtml program in
       <a href="http://www.cpan.org/authors/Tom_Christiansen/scripts/striphtml.gz">http://www.cpan.org/authors/Tom_Christiansen/scripts/striphtml.gz</a> .

       Here are some tricky cases that you should think about when picking a solution:

           &lt;IMG SRC = "foo.gif" ALT = "A &gt; B"&gt;

           &lt;IMG SRC = "foo.gif"
                ALT = "A &gt; B"&gt;

           &lt;!-- &lt;A comment&gt; --&gt;

           &lt;script&gt;if (a&lt;b &amp;&amp; a&gt;c)&lt;/script&gt;

           &lt;# Just data #&gt;

           &lt;![INCLUDE CDATA [ &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ]]&gt;

       If HTML comments include other tags, those solutions would also break on text like this:

           &lt;!-- This section commented out.
               &lt;B&gt;You can't see me!&lt;/B&gt;
           --&gt;

       <b>How</b> <b>do</b> <b>I</b> <b>extract</b> <b>URLs?</b>

       You can easily extract all sorts of URLs from HTML with "HTML::SimpleLinkExtor" which handles
       anchors, images, objects, frames, and many other tags that can contain a URL.  If you need anything
       more complex, you can create your own subclass of "HTML::LinkExtor" or "HTML::Parser".  You might
       even use "HTML::SimpleLinkExtor" as an example for something specifically suited to your needs.

       You can use URI::Find to extract URLs from an arbitrary text document.

       Less complete solutions involving regular expressions can save you a lot of processing time if you
       know that the input is simple.  One solution from Tom Christiansen runs 100 times faster than most
       module based approaches but only extracts URLs from anchors where the first attribute is HREF and
       there are no other attributes.

               #!/usr/bin/perl -n00
               # qxurl - tchrist@perl.com
               print "$2\n" while m{
                   &lt; \s*
                     A \s+ HREF \s* = \s* (["']) (.*?) \1
                   \s* &gt;
               }gsix;

       <b>How</b> <b>do</b> <b>I</b> <b>download</b> <b>a</b> <b>file</b> <b>from</b> <b>the</b> <b>user's</b> <b>machine?</b>  <b>How</b> <b>do</b> <b>I</b> <b>open</b> <b>a</b> <b>file</b> <b>on</b> <b>another</b> <b>machine?</b>

       In this case, download means to use the file upload feature of HTML forms.  You allow the web surfer
       to specify a file to send to your web server.  To you it looks like a download, and to the user it
       looks like an upload.  No matter what you call it, you do it with what's known as <b>multipart/form-data</b>
       encoding.  The CGI.pm module (which comes with Perl as part of the Standard Library) supports this in
       the <u>start</u><b>_</b><u>multipart</u><b>_</b><u>form()</u> method, which isn't the same as the <u>startform()</u> method.

       See the section in the CGI.pm documentation on file uploads for code examples and details.

       <b>How</b> <b>do</b> <b>I</b> <b>make</b> <b>a</b> <b>pop-up</b> <b>menu</b> <b>in</b> <b>HTML?</b>

       Use the <b>&lt;SELECT&gt;</b> and <b>&lt;OPTION&gt;</b> tags.  The CGI.pm module (available from CPAN) supports this widget, as
       well as many others, including some that it cleverly synthesizes on its own.

       <b>How</b> <b>do</b> <b>I</b> <b>fetch</b> <b>an</b> <b>HTML</b> <b>file?</b>

       One approach, if you have the lynx text-based HTML browser installed on your system, is this:

           $html_code = `lynx -source $url`;
           $text_data = `lynx -dump $url`;

       The libwww-perl (LWP) modules from CPAN provide a more powerful way to do this.  They don't require
       lynx, but like lynx, can still work through proxies:

           # simplest version
           use LWP::Simple;
           $content = get($URL);

           # or print HTML from a URL
           use LWP::Simple;
           getprint "<a href="http://www.linpro.no/lwp/">http://www.linpro.no/lwp/</a>";

           # or print ASCII from HTML from a URL
           # also need HTML-Tree package from CPAN
           use LWP::Simple;
           use HTML::Parser;
           use HTML::FormatText;
           my ($html, $ascii);
           $html = get("<a href="http://www.perl.com/">http://www.perl.com/</a>");
           defined $html
               or die "Can't fetch HTML from <a href="http://www.perl.com/">http://www.perl.com/</a>";
           $ascii = HTML::FormatText-&gt;new-&gt;format(parse_html($html));
           print $ascii;

       <b>How</b> <b>do</b> <b>I</b> <b>automate</b> <b>an</b> <b>HTML</b> <b>form</b> <b>submission?</b>

       If you are doing something complex, such as moving through many pages and forms or a web site, you
       can use "WWW::Mechanize".  See its documentation for all the details.

       If you're submitting values using the GET method, create a URL and encode the form using the
       "query_form" method:

           use LWP::Simple;
           use URI::URL;

           my $url = url('<a href="http://www.perl.com/cgi-bin/cpan_mod">http://www.perl.com/cgi-bin/cpan_mod</a>');
           $url-&gt;query_form(module =&gt; 'DB_File', readme =&gt; 1);
           $content = get($url);

       If you're using the POST method, create your own user agent and encode the content appropriately.

           use HTTP::Request::Common qw(POST);
           use LWP::UserAgent;

           $ua = LWP::UserAgent-&gt;new();
           my $req = POST '<a href="http://www.perl.com/cgi-bin/cpan_mod">http://www.perl.com/cgi-bin/cpan_mod</a>',
                          [ module =&gt; 'DB_File', readme =&gt; 1 ];
           $content = $ua-&gt;request($req)-&gt;as_string;

       <b>How</b> <b>do</b> <b>I</b> <b>decode</b> <b>or</b> <b>create</b> <b>those</b> <b>%-encodings</b> <b>on</b> <b>the</b> <b>web?</b>

       If you are writing a CGI script, you should be using the CGI.pm module that comes with perl, or some
       other equivalent module.  The CGI module automatically decodes queries for you, and provides an
       <u>escape()</u> function to handle encoding.

       The best source of detailed information on URI encoding is RFC 2396.  Basically, the following sub-
       stitutions do it:

           s/([^\w()'*~!.-])/sprintf '%%%02x', ord $1/eg;   # encode

           s/%([A-Fa-f\d]{2})/chr hex $1/eg;                # decode
               s/%([[:xdigit:]]{2})/chr hex $1/eg;          # same thing

       However, you should only apply them to individual URI components, not the entire URI, otherwise
       you'll lose information and generally mess things up.  If that didn't explain it, don't worry.  Just
       go read section 2 of the RFC, it's probably the best explanation there is.

       RFC 2396 also contains a lot of other useful information, including a regexp for breaking any arbi-
       trary URI into components (Appendix B).

       <b>How</b> <b>do</b> <b>I</b> <b>redirect</b> <b>to</b> <b>another</b> <b>page?</b>

       Specify the complete URL of the destination (even if it is on the same server). This is one of the
       two different kinds of CGI "Location:" responses which are defined in the CGI specification for a
       Parsed Headers script. The other kind (an absolute URLpath) is resolved internally to the server
       without any HTTP redirection. The CGI specifications do not allow relative URLs in either case.

       Use of CGI.pm is strongly recommended.  This example shows redirection with a complete URL. This re-
       direction is handled by the web browser.

             use CGI qw/:standard/;

             my $url = '<a href="http://www.cpan.org/">http://www.cpan.org/</a>';
             print redirect($url);

       This example shows a redirection with an absolute URLpath.  This redirection is handled by the local
       web server.

             my $url = '/CPAN/index.html';
             print redirect($url);

       But if coded directly, it could be as follows (the final "\n" is shown separately, for clarity),
       using either a complete URL or an absolute URLpath.

             print "Location: $url\n";   # CGI response header
             print "\n";                 # end of headers

       <b>How</b> <b>do</b> <b>I</b> <b>put</b> <b>a</b> <b>password</b> <b>on</b> <b>my</b> <b>web</b> <b>pages?</b>

       To enable authentication for your web server, you need to configure your web server.  The configura-
       tion is different for different sorts of web servers---apache does it differently from iPlanet which
       does it differently from IIS.  Check your web server documentation for the details for your particu-
       lar server.

       <b>How</b> <b>do</b> <b>I</b> <b>edit</b> <b>my</b> <b>.htpasswd</b> <b>and</b> <b>.htgroup</b> <b>files</b> <b>with</b> <b>Perl?</b>

       The HTTPD::UserAdmin and HTTPD::GroupAdmin modules provide a consistent OO interface to these files,
       regardless of how they're stored.  Databases may be text, dbm, Berkeley DB or any database with a DBI
       compatible driver.  HTTPD::UserAdmin supports files used by the "Basic" and "Digest" authentication
       schemes.  Here's an example:

           use HTTPD::UserAdmin ();
           HTTPD::UserAdmin
                 -&gt;new(DB =&gt; "/foo/.htpasswd")
                 -&gt;add($username =&gt; $password);

       <b>How</b> <b>do</b> <b>I</b> <b>make</b> <b>sure</b> <b>users</b> <b>can't</b> <b>enter</b> <b>values</b> <b>into</b> <b>a</b> <b>form</b> <b>that</b> <b>cause</b> <b>my</b> <b>CGI</b> <b>script</b> <b>to</b> <b>do</b> <b>bad</b> <b>things?</b>

       See the security references listed in the CGI Meta FAQ

               <a href="http://www.perl.org/CGI_MetaFAQ.html">http://www.perl.org/CGI_MetaFAQ.html</a>

       <b>How</b> <b>do</b> <b>I</b> <b>parse</b> <b>a</b> <b>mail</b> <b>header?</b>

       For a quick-and-dirty solution, try this solution derived from "split" in perlfunc:

           $/ = '';
           $header = &lt;MSG&gt;;
           $header =~ s/\n\s+/ /g;      # merge continuation lines
           %head = ( UNIX_FROM_LINE, split /^([-\w]+):\s*/m, $header );

       That solution doesn't do well if, for example, you're trying to maintain all the Received lines.  A
       more complete approach is to use the Mail::Header module from CPAN (part of the MailTools package).

       <b>How</b> <b>do</b> <b>I</b> <b>decode</b> <b>a</b> <b>CGI</b> <b>form?</b>

       (contributed by brian d foy)

       Use the CGI.pm module that comes with Perl.  It's quick, it's easy, and it actually does quite a bit
       of work to ensure things happen correctly.  It handles GET, POST, and HEAD requests, multipart forms,
       multivalued fields, query string and message body combinations, and many other things you probably
       don't want to think about.

       It doesn't get much easier: the CGI module automatically parses the input and makes each value avail-
       able through the "param()" function.

               use CGI qw(:standard);

               my $total = param( 'price' ) + param( 'shipping' );

               my @items = param( 'item' ); # multiple values, same field name

       If you want an object-oriented approach, CGI.pm can do that too.

               use CGI;

               my $cgi = CGI-&gt;new();

               my $total = $cgi-&gt;param( 'price' ) + $cgi-&gt;param( 'shipping' );

               my @items = $cgi-&gt;param( 'item' );

       You might also try CGI::Minimal which is a lightweight version of the same thing.  Other CGI::* mod-
       ules on CPAN might work better for you, too.

       Many people try to write their own decoder (or copy one from another program) and then run into one
       of the many "gotchas" of the task.  It's much easier and less hassle to use CGI.pm.

       <b>How</b> <b>do</b> <b>I</b> <b>check</b> <b>a</b> <b>valid</b> <b>mail</b> <b>address?</b>

       You can't, at least, not in real time.  Bummer, eh?

       Without sending mail to the address and seeing whether there's a human on the other end to answer
       you, you cannot determine whether a mail address is valid.  Even if you apply the mail header stan-
       dard, you can have problems, because there are deliverable addresses that aren't RFC-822 (the mail
       header standard) compliant, and addresses that aren't deliverable which are compliant.

       You can use the Email::Valid or RFC::RFC822::Address which check the format of the address, although
       they cannot actually tell you if it is a deliverable address (i.e. that mail to the address will not
       bounce).  Modules like Mail::CheckUser and Mail::EXPN try to interact with the domain name system or
       particular mail servers to learn even more, but their methods do not work everywhere---especially for
       security conscious administrators.

       Many are tempted to try to eliminate many frequently-invalid mail addresses with a simple regex, such
       as "/^[\w.-]+\@(?:[\w-]+\.)+\w+$/".  It's a very bad idea.  However, this also throws out many valid
       ones, and says nothing about potential deliverability, so it is not suggested.  Instead, see
       <a href="http://www.cpan.org/authors/Tom_Christiansen/scripts/ckaddr.gz">http://www.cpan.org/authors/Tom_Christiansen/scripts/ckaddr.gz</a> , which actually checks against the
       full RFC spec (except for nested comments), looks for addresses you may not wish to accept mail to
       (say, Bill Clinton or your postmaster), and then makes sure that the hostname given can be looked up
       in the DNS MX records.  It's not fast, but it works for what it tries to do.

       Our best advice for verifying a person's mail address is to have them enter their address twice, just
       as you normally do to change a password.  This usually weeds out typos.  If both versions match, send
       mail to that address with a personal message that looks somewhat like:

           Dear someuser@host.com,

           Please confirm the mail address you gave us Wed May  6 09:38:41
           MDT 1998 by replying to this message.  Include the string
           "Rumpelstiltskin" in that reply, but spelled in reverse; that is,
           start with "Nik...".  Once this is done, your confirmed address will
           be entered into our records.

       If you get the message back and they've followed your directions, you can be reasonably assured that
       it's real.

       A related strategy that's less open to forgery is to give them a PIN (personal ID number).  Record
       the address and PIN (best that it be a random one) for later processing.  In the mail you send, ask
       them to include the PIN in their reply.  But if it bounces, or the message is included via a "vaca-
       tion" script, it'll be there anyway.  So it's best to ask them to mail back a slight alteration of
       the PIN, such as with the characters reversed, one added or subtracted to each digit, etc.

       <b>How</b> <b>do</b> <b>I</b> <b>decode</b> <b>a</b> <b>MIME/BASE64</b> <b>string?</b>

       The MIME-Base64 package (available from CPAN) handles this as well as the MIME/QP encoding.  Decoding
       BASE64 becomes as simple as:

           use MIME::Base64;
           $decoded = decode_base64($encoded);

       The MIME-Tools package (available from CPAN) supports extraction with decoding of BASE64 encoded
       attachments and content directly from email messages.

       If the string to decode is short (less than 84 bytes long) a more direct approach is to use the
       <u>unpack()</u> function's "u" format after minor transliterations:

           tr#A-Za-z0-9+/##cd;                   # remove non-base64 chars
           tr#A-Za-z0-9+/# -_#;                  # convert to uuencoded format
           $len = pack("c", 32 + 0.75*length);   # compute length byte
           print unpack("u", $len . $_);         # uudecode and print

       <b>How</b> <b>do</b> <b>I</b> <b>return</b> <b>the</b> <b>user's</b> <b>mail</b> <b>address?</b>

       On systems that support getpwuid, the $&lt; variable, and the Sys::Hostname module (which is part of the
       standard perl distribution), you can probably try using something like this:

           use Sys::Hostname;
           $address = sprintf('%s@%s', scalar getpwuid($&lt;), hostname);

       Company policies on mail address can mean that this generates addresses that the company's mail sys-
       tem will not accept, so you should ask for users' mail addresses when this matters.  Furthermore, not
       all systems on which Perl runs are so forthcoming with this information as is Unix.

       The Mail::Util module from CPAN (part of the MailTools package) provides a <u>mailaddress()</u> function
       that tries to guess the mail address of the user.  It makes a more intelligent guess than the code
       above, using information given when the module was installed, but it could still be incorrect.
       Again, the best way is often just to ask the user.

       <b>How</b> <b>do</b> <b>I</b> <b>send</b> <b>mail?</b>

       Use the "sendmail" program directly:

           open(SENDMAIL, "|/usr/lib/sendmail -oi -t -odq")
                               or die "Can't fork for sendmail: $!\n";
           print SENDMAIL &lt;&lt;"EOF";
           From: User Originating Mail &lt;me\@host&gt;
           To: Final Destination &lt;you\@otherhost&gt;
           Subject: A relevant subject line

           Body of the message goes here after the blank line
           in as many lines as you like.
           EOF
           close(SENDMAIL)     or warn "sendmail didn't close nicely";

       The <b>-oi</b> option prevents sendmail from interpreting a line consisting of a single dot as "end of mes-
       sage".  The <b>-t</b> option says to use the headers to decide who to send the message to, and <b>-odq</b> says to
       put the message into the queue.  This last option means your message won't be immediately delivered,
       so leave it out if you want immediate delivery.

       Alternate, less convenient approaches include calling mail (sometimes called mailx) directly or sim-
       ply opening up port 25 have having an intimate conversation between just you and the remote SMTP dae-
       mon, probably sendmail.

       Or you might be able use the CPAN module Mail::Mailer:

           use Mail::Mailer;

           $mailer = Mail::Mailer-&gt;new();
           $mailer-&gt;open({ From    =&gt; $from_address,
                           To      =&gt; $to_address,
                           Subject =&gt; $subject,
                         })
               or die "Can't open: $!\n";
           print $mailer $body;
           $mailer-&gt;close();

       The Mail::Internet module uses Net::SMTP which is less Unix-centric than Mail::Mailer, but less reli-
       able.  Avoid raw SMTP commands.  There are many reasons to use a mail transport agent like sendmail.
       These include queuing, MX records, and security.

       <b>How</b> <b>do</b> <b>I</b> <b>use</b> <b>MIME</b> <b>to</b> <b>make</b> <b>an</b> <b>attachment</b> <b>to</b> <b>a</b> <b>mail</b> <b>message?</b>

       This answer is extracted directly from the MIME::Lite documentation.  Create a multipart message
       (i.e., one with attachments).

           use MIME::Lite;

           ### Create a new multipart message:
           $msg = MIME::Lite-&gt;new(
                        From    =&gt;'me@myhost.com',
                        To      =&gt;'you@yourhost.com',
                        Cc      =&gt;'some@other.com, some@more.com',
                        Subject =&gt;'A message with 2 parts...',
                        Type    =&gt;'multipart/mixed'
                        );

           ### Add parts (each "attach" has same arguments as "new"):
           $msg-&gt;attach(Type     =&gt;'TEXT',
                        Data     =&gt;"Here's the GIF file you wanted"
                        );
           $msg-&gt;attach(Type     =&gt;'image/gif',
                        Path     =&gt;'aaa000123.gif',
                        Filename =&gt;'logo.gif'
                        );

           $text = $msg-&gt;as_string;

       MIME::Lite also includes a method for sending these things.

           $msg-&gt;send;

       This defaults to using sendmail but can be customized to use SMTP via Net::SMTP.

       <b>How</b> <b>do</b> <b>I</b> <b>read</b> <b>mail?</b>

       While you could use the Mail::Folder module from CPAN (part of the MailFolder package) or the
       Mail::Internet module from CPAN (part of the MailTools package), often a module is overkill.  Here's
       a mail sorter.

           #!/usr/bin/perl

           my(@msgs, @sub);
           my $msgno = -1;
           $/ = '';                    # paragraph reads
           while (&lt;&gt;) {
               if (/^From /m) {
                   /^Subject:\s*(?:Re:\s*)*(.*)/mi;
                   $sub[++$msgno] = lc($1) || '';
               }
               $msgs[$msgno] .= $_;
           }
           for my $i (sort { $sub[$a] cmp $sub[$b] || $a &lt;=&gt; $b } (0 .. $#msgs)) {
               print $msgs[$i];
           }

       Or more succinctly,

           #!/usr/bin/perl -n00
           # bysub2 - awkish sort-by-subject
           BEGIN { $msgno = -1 }
           $sub[++$msgno] = (/^Subject:\s*(?:Re:\s*)*(.*)/mi)[0] if /^From/m;
           $msg[$msgno] .= $_;
           END { print @msg[ sort { $sub[$a] cmp $sub[$b] || $a &lt;=&gt; $b } (0 .. $#msg) ] }

       <b>How</b> <b>do</b> <b>I</b> <b>find</b> <b>out</b> <b>my</b> <b>hostname,</b> <b>domainname,</b> <b>or</b> <b>IP</b> <b>address?</b>

       gethostbyname, Socket, Net::Domain, Sys::Hostname" (contributed by brian d foy)

       The Net::Domain module, which is part of the standard distribution starting in perl5.7.3, can get you
       the fully qualified domain name (FQDN), the host name, or the domain name.

               use Net::Domain qw(hostname hostfqdn hostdomain);

               my $host = hostfqdn();

       The "Sys::Hostname" module, included in the standard distribution since perl5.6, can also get the
       hostname.

               use Sys::Hostname;

               $host = hostname();

       To get the IP address, you can use the "gethostbyname" built-in function to turn the name into a num-
       ber. To turn that number into the dotted octet form (a.b.c.d) that most people expect, use the
       "inet_ntoa" function from the &lt;Socket&gt; module, which also comes with perl.

           use Socket;

           my $address = inet_ntoa(
               scalar gethostbyname( $host || 'localhost' )
               );

       <b>How</b> <b>do</b> <b>I</b> <b>fetch</b> <b>a</b> <b>news</b> <b>article</b> <b>or</b> <b>the</b> <b>active</b> <b>newsgroups?</b>

       Use the Net::NNTP or News::NNTPClient modules, both available from CPAN.  This can make tasks like
       fetching the newsgroup list as simple as

           perl -MNews::NNTPClient
             -e 'print News::NNTPClient-&gt;new-&gt;list("newsgroups")'

       <b>How</b> <b>do</b> <b>I</b> <b>fetch/put</b> <b>an</b> <b>FTP</b> <b>file?</b>

       LWP::Simple (available from CPAN) can fetch but not put.  Net::FTP (also available from CPAN) is more
       complex but can put as well as fetch.

       <b>How</b> <b>can</b> <b>I</b> <b>do</b> <b>RPC</b> <b>in</b> <b>Perl?</b>

       (Contributed by brian d foy)

       Use one of the RPC modules you can find on CPAN ( <a href="http://search.cpan.org/search?query=RPC&amp;mode=all">http://search.cpan.org/search?query=RPC&amp;mode=all</a> ).

<b>AUTHOR</b> <b>AND</b> <b>COPYRIGHT</b>
       Copyright (c) 1997-2006 Tom Christiansen, Nathan Torkington, and other authors as noted. All rights
       reserved.

       This documentation is free; you can redistribute it and/or modify it under the same terms as Perl
       itself.

       Irrespective of its distribution, all code examples in this file are hereby placed into the public
       domain.  You are permitted and encouraged to use this code in your own programs for fun or for profit
       as you see fit.  A simple comment in the code giving credit would be courteous but is not required.



perl v5.8.8                                      2006-01-07                                      PERLFAQ9(1)
</tt></pre>
</td></tr></table>
	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/Darwin/Reference/ManPages/man1/perlfaq9.1.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/Darwin/Reference/ManPages/man1/perlfaq9.1.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/Darwin/Reference/ManPages/man1/perlfaq9.1.html%3Fid%3DTP40000894-7.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

</body></html>
