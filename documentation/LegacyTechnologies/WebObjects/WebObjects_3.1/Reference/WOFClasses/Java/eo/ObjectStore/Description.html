<html>

<body bgcolor="#FFFFFF">

<CENTER><H1>Class next.eo.ObjectStore</H1></CENTER>

<a name="description"></a><CENTER><H2>CLASS DESCRIPTION</H2></CENTER>

<!-- extends:next.util.NextObject -->

<DL>

<DT><B>Extends:</B></DT><DD>next.util.NextObject</DD>

</DL>

<P>

ObjectStore is an abstract class defining the interface for an "intelligent" repository of objects, whether one based on external data or one that manages objects entirely in memory. An ObjectStore is responsible for constructing and registering objects, servicing object faults, and saving changes made to objects. EditingContext is the principal subclass used for managing objects in memory-in fact, the primary purpose of the ObjectStore interface is to service EditingContexts, not to define a completely general interface. The access layer's DatabaseContext class, a subclass of ObjectStore, provides objects from relational databases. DatabaseContexts, and other ObjectStores based on external data, are often shared by several EditingContexts.
<P>
An ObjectStore identifies its objects in two ways: by <B>id</B> for identification within a specific EditingContext, and by EOGlobalID for universal identification of the same record among multiple stores. ObjectStores perform uniquing of their objects based on EOGlobalIDs, and use the IDs to coordinate changes among separate ObjectStores-both within and, potentially, across applications-and between nested stores (as illustrated in the EditingContext class specification).
<!--
For external repositories, an ObjectStore may delay actually fetching an object's data, instead creating an EOFault as a placeholder. When an EOFault is accessed (sent a message), it triggers its ObjectStore to fetch its data and transform it into an instance of the appropriate object class. This preserves both the object's id and its EOGlobalID, while saving the cost of fetching data that may not be used. EOFaults are typically created for the destinations of relationships for objects that are explicitly fetched. See the EOFault and EOFaultHandler class specifications for more information.

Subclasses of ObjectStore
As noted above, EditingContext is the principal subclass of ObjectStore, used for managing objects in memory. <!--For stores based on external data, there are several subclasses. EOCooperatingObjectStore defines stores that work together to manage data from several distinct sources (such as different databases). DatabaseContext is actually a subclass of this class. A group of EOCooperatingObjectStores is managed by another subclass of ObjectStore, called ObjectStoreCoordinator. If you're defining a subclass of ObjectStore, it's probably one based on an external data repository, and it should therefore inherit from EOCooperatingObjectStore so as to work well with an ObjectStoreCoordinator-though this isn't required.
A subclass of ObjectStore must implement all of its methods. The default method implementations raise exceptions.-->
<hr>

</body>

</html><html>

<body bgcolor="#FFFFFF"><!-- constructors -->

<a name="constructors"><CENTER><H2>CONSTRUCTORS</H2></CENTER></a>

<!-- consKey:ObjectStore(public) cons:ObjectStore descr:<TT>public  <B>ObjectStore</B>()</TT> -->

<H3><a name="ObjectStore(public)">ObjectStore</a></H3>

   <TT>public  <B>ObjectStore</B>()</TT>

<P>

Returns a newly-allocated and initialized ObjectStore object.

<P>

<!-- <B>See Also: </B>[See Also's go here] -->

<hr>

</body>

</html>