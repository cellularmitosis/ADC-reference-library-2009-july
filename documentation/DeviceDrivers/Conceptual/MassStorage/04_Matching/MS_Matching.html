<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>Mass Storage Device Driver Programming Guide: Mass Storage Driver Matching and Loading</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Mass Storage Driver Matching and Loading"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP30000736" title="Mass Storage Driver Matching and Loading"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../../HardwareDrivers/index.html#//apple_ref/doc/uid/TP30000440-TP40003576" target="_top">Hardware &amp; Drivers</a> &gt; <a href="../../../../HardwareDrivers/MassStorageDevices-date.html#//apple_ref/doc/uid/TP30000440-TP40003576-TP30001039" target="_top">Storage</a> &gt; <a href="../01_Introduction/Introduction.html#//apple_ref/doc/uid/TP30000733-TPXREF101">Mass Storage Device Driver Programming Guide</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../03_Compliance/MS_Compliance.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../05_Universal_Binary/MS_UniversalBinary.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP30000736-BBHIFIDJ" title="Mass Storage Driver Matching and Loading"></a><h1>Mass Storage Driver Matching and Loading</h1><p>Before a mass storage device can be used, the I/O Kit must find and load several drivers for it. In the transport driver layer, the required drivers are a protocol services driver and a logical unit driver. The only required driver in the device services layer is the generic block storage driver but if there is media present in the device, there may be partition and filter-scheme drivers, as well. Like all I/O Kit drivers, these drivers must declare what devices they are suited to drive by placing device-specific or device type-specific information in special dictionaries called personalities. In a process called driver matching, the I/O Kit compares this information to values reported by the device to find the most suitable driver.</p><p>This chapter first describes the driver matching process in general and then focuses on the matching semantics of the protocol services drivers, the logical unit drivers, and the optional filter-scheme drivers.</p>
<!-- This template is being used for both PDF and HTML. -->

    
    <h4>In this section:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="MS_Matching.html#//apple_ref/doc/uid/TP30000736-BBIDJJGD">Driver Personalities and the Matching Process</a>
				
			<br/>
			
        
			
			
				<a href="MS_Matching.html#//apple_ref/doc/uid/TP30000736-BBIIJIBD">Protocol Services Driver Matching</a>
				
			<br/>
			
        
			
			
				<a href="MS_Matching.html#//apple_ref/doc/uid/TP30000736-BBIFHFBG">Logical Unit Driver Matching</a>
				
			<br/>
			
        
			
			
				<a href="MS_Matching.html#//apple_ref/doc/uid/TP30000736-BCIBACGH">Filter-Scheme Driver Matching</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP30000736-BBIDJJGD" title="Driver Personalities and the Matching Process"></a><h2>Driver Personalities and the Matching Process</h2><p><a name="//apple_ref/doc/uid/TP30000736-DontLinkElementID_170"></a><a name="//apple_ref/doc/uid/TP30000736-DontLinkElementID_171"></a>The I/O Kit finds and loads device drivers in a three-stage matching process that excludes unsuitable drivers from the pool of candidates until one or more eligible drivers are left. The most eligible of the remaining drivers is then given the first opportunity to drive the device.</p><p><a name="//apple_ref/doc/uid/TP30000736-DontLinkElementID_172"></a><a name="//apple_ref/doc/uid/TP30000736-DontLinkElementID_173"></a><a name="//apple_ref/doc/uid/TP30000736-DontLinkElementID_174"></a>This process makes use of matching dictionaries that are in every driver’s information property list. Each dictionary, consisting of XML key-value pairs, specifies a personality of the driver, which declares its suitability for a particular device or device type. A driver may have more than one personality if it can drive different devices or device types.</p><p>This section presents a brief overview of driver personalities and matching (for a more in-depth description of these topics, see <em><a href="../../IOKitFundamentals/index.html#//apple_ref/doc/uid/TP0000011" target="_top">I/O Kit Fundamentals</a></em>.) The subsequent sections, <span class="content_text"><a href="MS_Matching.html#//apple_ref/doc/uid/TP30000736-BBIIJIBD">“Protocol Services Driver Matching,”</a></span> <span class="content_text"><a href="MS_Matching.html#//apple_ref/doc/uid/TP30000736-BBIFHFBG">“Logical Unit Driver Matching,”</a></span> and <span class="content_text"><a href="MS_Matching.html#//apple_ref/doc/uid/TP30000736-BCIBACGH">“Filter-Scheme Driver Matching”</a></span> describe how this process is implemented by specific mass storage drivers.</p><a name="//apple_ref/doc/uid/TP30000736-TPXREF101" title="Driver Personalities"></a><h3>Driver Personalities</h3><p><a name="//apple_ref/doc/uid/TP30000736-DontLinkElementID_175"></a>Every device driver must declare one or more personalities that define the types of devices it can support. These personalities are in the form of XML dictionaries contained in the information property list<a name="//apple_ref/doc/uid/TP30000736-DontLinkElementID_176"></a><a name="//apple_ref/doc/uid/TP30000736-DontLinkElementID_177"></a> (<code>Info.plist</code><a name="//apple_ref/doc/uid/TP30000736-DontLinkElementID_178"></a> file) in the driver’s kernel extension (KEXT) bundle.</p><p>Each entry in the matching dictionary<a name="//apple_ref/doc/uid/TP30000736-DontLinkElementID_179"></a> is made up of a key-value pair in which the XML tags <code>&lt;key></code> and <code>&lt;/key></code> enclose the key and the associated value is enclosed by XML tags that indicate its data type.<a name="//apple_ref/doc/uid/TP30000736-DontLinkElementID_180"></a></p><p>At minimum, all driver personalities contain the following two keys:</p><ul class="spaceabove"><li class="li"><p>The <code>IOClass</code><a name="//apple_ref/doc/uid/TP30000736-DontLinkElementID_181"></a> key declares the name of the class the I/O Kit instantiates when probing. For example, </p><div class="codesample"><table><tr><td scope="row"><pre>&lt;key>IOClass&lt;/key><span></span></pre></td></tr><tr><td scope="row"><pre>&lt;string>IOATAPIProtocolTransport&lt;/string><span></span></pre></td></tr></table></div><p>tells the I/O Kit to instantiate the <code>IOATAPIProtocolTransport</code> driver when probing the device for this personality.</p></li><li class="li"><p>The <code>IOProviderClass</code><a name="//apple_ref/doc/uid/TP30000736-DontLinkElementID_182"></a> key declares the name of the nub class a driver personality attaches to. For example,</p><div class="codesample"><table><tr><td scope="row"><pre>&lt;key>IOProviderClass&lt;/key><span></span></pre></td></tr><tr><td scope="row"><pre>&lt;string>IOFireWireSBP2LUN&lt;/string><span></span></pre></td></tr></table></div><p>tells the I/O Kit that this driver personality attaches to an <code>IOFireWireSBP2LUN</code> nub.</p><p>The provider class defines the family-specific matching keys used in the passive matching step, described in <span class="content_text"><a href="MS_Matching.html#//apple_ref/doc/uid/TP30000736-BBICIBDC">“Driver Matching.”</a></span></p></li></ul><p><a name="//apple_ref/doc/uid/TP30000736-DontLinkElementID_183"></a>Most driver personalities also contain the <code>IOProbeScore</code> key, which declares the initial probe score for a personality. For example,<a name="//apple_ref/doc/uid/TP30000736-DontLinkElementID_184"></a><a name="//apple_ref/doc/uid/TP30000736-DontLinkElementID_185"></a></p><div class="codesample"><table><tr><td scope="row"><pre>&lt;key>IOProbeScore&lt;/key><span></span></pre></td></tr><tr><td scope="row"><pre>&lt;integer>5000&lt;/integer><span></span></pre></td></tr></table></div><p>declares a base probe score of 5000, which can be increased or decreased during the matching process, reflecting the driver’s suitability for the device.<a name="//apple_ref/doc/uid/TP30000736-DontLinkElementID_186"></a><a name="//apple_ref/doc/uid/TP30000736-DontLinkElementID_187"></a><a name="//apple_ref/doc/uid/TP30000736-DontLinkElementID_188"></a></p><a name="//apple_ref/doc/uid/TP30000736-BBICIBDC" title="Driver Matching"></a><h3>Driver Matching</h3><p><a name="//apple_ref/doc/uid/TP30000736-DontLinkElementID_189"></a>Driver matching occurs when a device is discovered. Each candidate driver has a probe score that reflects how well suited it is to drive the device. During the matching process, the family can increase the probe score with each property match. The driver with the highest probe score is given the first opportunity to drive the device.</p><p>The driver matching process consists of three phases<a name="//apple_ref/doc/uid/TP30000736-DontLinkElementID_190"></a>:</p><ol class="ol"><li class="li"><p>In the class matching phase, the I/O Kit eliminates drivers of the wrong class. For example, the I/O Kit eliminates drivers that descend from a SCSI class when searching for a USB driver.</p></li><li class="li"><p>In the passive matching phase, the I/O Kit examines the personality of the driver for family-specific properties. In the SCSI Architecture Model family, the more matching properties found, the higher the driver’s probe score. For example, a driver that matches on both vendor name and product name has a higher probe score than a driver that matches only on vendor name. The Storage family, on the other hand, does not influence a driver’s probe score during matching.</p><p>Often this step is sufficient to determine if a driver is suitable for a device. If there is no family-specific matching, however, the next step is automatically invoked.</p></li><li class="li"><p><a name="//apple_ref/doc/uid/TP30000736-DontLinkElementID_191"></a>In the active matching phase, the candidate driver is allowed to communicate with the device and verify that it can drive it. The I/O Kit loads the drivers remaining after the passive matching phase and each driver’s <code>probe</code> function is called with reference to the device it is being matched against. The <code>probe</code> method can examine the device in any way it chooses, as long as it leaves the device in the same state in which it was found.</p><p>For example, a vendor may use certain bits of a property value to signify the presence of a particular device component. A logical unit driver for that device can implement a <code>probe</code> method that examines those bits to determine if the component is indeed present.</p><p>Depending on the results of the probe, the driver increases or decreases its probe score to indicate its suitability to drive the device.</p></li></ol><p>The I/O Kit chooses the driver with the highest probe score and starts it. If the driver starts successfully, any remaining driver candidates are discarded. If it is not successful, the driver with the next highest probe score is started and the process continues until a successful driver is found.<a name="//apple_ref/doc/uid/TP30000736-DontLinkElementID_192"></a></p><a name="//apple_ref/doc/uid/TP30000736-TPXREF102" title="Driver Starting"></a><h3>Driver Starting</h3><a name="//apple_ref/doc/uid/TP30000736-DontLinkElementID_193"></a><p>When probing, a driver can perform a detailed examination of the device, including, if necessary, memory allocations, but it must leave the device in the same state in which it found it. If a driver starts successfully, it can reuse the memory it allocated in its <code>probe</code> method but if it is unsuccessful, it must be sure to deallocate the memory in its <code>free</code> method.</p><p>When a driver starts, it should call its superclass’s <code>start</code> method before doing anything else. If the superclass’s <code>start</code> method succeeds, the driver can then perform its initializations or allocations. Because a driver may not be able to perform initializations or allocations safely after it starts, it should perform such tasks in its <code>start</code> method. If the driver is unable to complete its tasks, it can notify the I/O Kit and the driver with the next highest probe score starts.<a name="//apple_ref/doc/uid/TP30000736-DontLinkElementID_194"></a><a name="//apple_ref/doc/uid/TP30000736-DontLinkElementID_195"></a></p><a name="//apple_ref/doc/uid/TP30000736-BBIIJIBD" title="Protocol Services Driver Matching"></a><h2>Protocol Services Driver Matching</h2><p>During the building of the mass storage driver stack, objects in the physical interconnect layer discover a mass storage device and publish a nub representing it in the I/O Registry. The I/O Kit finds a protocol services driver<a name="//apple_ref/doc/uid/TP30000736-DontLinkElementID_196"></a> by performing driver matching on this nub.</p><p>The protocol services drivers rely on matching semantics that are specific to the family of the bus they communicate with. The following sections describe the matching properties and process for each Apple-provided protocol services driver.</p><a name="//apple_ref/doc/uid/TP30000736-TPXREF103" title="The FireWire SBP-2 Protocol Services Driver"></a><h3>The FireWire SBP-2 Protocol Services Driver</h3><p><a name="//apple_ref/doc/uid/TP30000736-DontLinkElementID_197"></a><a name="//apple_ref/doc/uid/TP30000736-DontLinkElementID_198"></a><a name="//apple_ref/doc/uid/TP30000736-DontLinkElementID_199"></a>As described in <span class="content_text"><a href="../02_Overview/MS_Overview.html#//apple_ref/doc/uid/TP30000734-BJGFJIJA">“Construction of a Mass Storage Driver Stack,”</a></span> the protocol services driver for a FireWire SBP-2 mass storage device<a name="//apple_ref/doc/uid/TP30000736-DontLinkElementID_200"></a> must match on the <code>IOFireWireSBP2LUN</code> nub published by the <code>IOFireWireTarget</code> object in the physical interconnect layer. The <code>IOFireWireSBP2LUN</code> object contains the following seven keys:</p><ul class="spaceabove"><li class="li"><p><code>Command_Set</code></p></li><li class="li"><p><code>Command_Set_Spec_ID</code></p></li><li class="li"><p><code>Vendor_ID</code></p></li><li class="li"><p><code>Command_Set_Revision</code></p></li><li class="li"><p><code>IOUnit</code></p></li><li class="li"><p><code>Firmware_Revision</code></p></li><li class="li"><p><code>Device_Type</code></p></li></ul><p>The <code>IOFireWireTarget</code> object scans the device’s configuration ROM and fills in the values for these keys. If the device doesn’t declare one or more of these properties in its configuration ROM, the <code>IOFireWireSPB2LUN</code> publishes the corresponding key with a zero value.</p><p><a name="//apple_ref/doc/uid/TP30000736-DontLinkElementID_201"></a>To match on the <code>IOFireWireSBP2LUN</code>, the <code>IOFireWireSerialBusProtocolTransport</code> driver personality includes the keys shown in <span class="content_text"><a href="MS_Matching.html#//apple_ref/doc/uid/TP30000736-BBIJGFBD">Listing 3-1</a></span>.</p><a name="//apple_ref/doc/uid/TP30000736-BBIJGFBD" title="Listing 3-1The IOFireWireSerialBusProtocolTransport driver personality dictionary"></a><p class="codesample"><strong>Listing 3-1&nbsp;&nbsp;</strong>The IOFireWireSerialBusProtocolTransport driver personality dictionary</p><div class="codesample"><table><tr><td scope="row"><pre>&lt;dict><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;!-- CFBundleIdentifier denotes the name of the driver in<span></span></pre></td></tr><tr><td scope="row"><pre>     -- reverse DNS notation. --><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;key>CFBundleIdentifier&lt;/key><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;string>com.apple.iokit.IOFireWireSerialBusProtocolTransport&lt;/string><span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;!-- Command_Set refers to the organization responsible<span></span></pre></td></tr><tr><td scope="row"><pre>     -- for the definition of the command set. --><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;key>Command_Set&lt;/key><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;integer>66776&lt;/integer><span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;!-- Command_Set_Spec_ID specifies the commands<span></span></pre></td></tr><tr><td scope="row"><pre>     -- understood by the device. --><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;key>Command_Set_Spec_ID&lt;/key><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;integer>24734&lt;/integer><span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;!-- The name of the class the I/O Kit instantiates<span></span></pre></td></tr><tr><td scope="row"><pre>     -- when probing. --><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;key>IOClass&lt;/key><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;string>IOFireWireSerialBusProtocolTransport&lt;/string><span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;!-- The initial probe score for this personality. --><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;key>IOProbeScore&lt;/key><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;integer>4096&lt;/integer><span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;!-- The provider class is the name of the nub class this<span></span></pre></td></tr><tr><td scope="row"><pre>     -- driver personality attaches to. --><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;key>IOProviderClass&lt;/key><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;string>IOFireWireSBP2LUN&lt;/string><span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;!-- The next two keys describe which<span></span></pre></td></tr><tr><td scope="row"><pre>     -- bus the device is on and whether it is<span></span></pre></td></tr><tr><td scope="row"><pre>     -- internal or external.--><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;key>Physical Interconnect&lt;/key><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;string>FireWire&lt;/string><span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;key>Physical Interconnect Location&lt;/key><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;string>External&lt;/string><span></span></pre></td></tr><tr><td scope="row"><pre>&lt;/dict><span></span></pre></td></tr></table></div><p><a name="//apple_ref/doc/uid/TP30000736-DontLinkElementID_202"></a><a name="//apple_ref/doc/uid/TP30000736-DontLinkElementID_203"></a>A subclass of the <code>IOFireWireSerialBusProtocolTransport</code> driver can use more of the seven keys in the <code>IOFireWireSBP2LUN</code> object to more narrowly define the device it is suited to drive. It can also examine the property values in its <code>probe</code> method to further determine its suitability. For example, a vendor can use some of the bits in a property value to declare the presence of a device component. A driver that needs to determine the presence of this component can examine those bits in its <code>probe</code> method. <span class="content_text"><a href="MS_Matching.html#//apple_ref/doc/uid/TP30000736-BBIEAJIC">Listing 3-2</a></span> shows how this can be done for a subclass of the <code>IOFireWireSerialBusProtocolTransport</code> driver.<a name="//apple_ref/doc/uid/TP30000736-DontLinkElementID_204"></a></p><a name="//apple_ref/doc/uid/TP30000736-BBIEAJIC" title="Listing 3-2Example FireWire protocol services driver probe method"></a><p class="codesample"><strong>Listing 3-2&nbsp;&nbsp;</strong>Example FireWire protocol services driver probe method</p><a name="//apple_ref/doc/uid/TP30000736-DontLinkElementID_205"></a><a name="//apple_ref/doc/uid/TP30000736-DontLinkElementID_206"></a><div class="codesample"><table><tr><td scope="row"><pre>// This example probe method tests the Firmware_Revision value.<span></span></pre></td></tr><tr><td scope="row"><pre>IOService *com_MySoftwareCompany_driver_MyFWProtocolLayerDriver::probe(<span></span></pre></td></tr><tr><td scope="row"><pre>                IOService *provider, SInt32 *score )<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    IOFireWireSBP2LUN *fwSBP2LUN = NULL;<span></span></pre></td></tr><tr><td scope="row"><pre>    OSObject *firmwareObject;<span></span></pre></td></tr><tr><td scope="row"><pre>    IOService *returnValue = 0;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Override probe method inherited from IOFireWireSBP2LUN.<span></span></pre></td></tr><tr><td scope="row"><pre>    // Incorporate additional matching based on bits within<span></span></pre></td></tr><tr><td scope="row"><pre>    // firmware revision data.<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Allow superclass first chance at probe<span></span></pre></td></tr><tr><td scope="row"><pre>    if ( !IOFireWireSerialBusProtocolTransport::probe( provider, score ) )<span></span></pre></td></tr><tr><td scope="row"><pre>        goto ErrorExit;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    fwSBP2LUN = OSDynamicCast( IOFireWireSBP2LUN, provider );<span></span></pre></td></tr><tr><td scope="row"><pre>    if ( fwSBP2LUN == NULL )<span></span></pre></td></tr><tr><td scope="row"><pre>        goto ErrorExit;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Get key from registry that IOFireWireSBP2LUN published<span></span></pre></td></tr><tr><td scope="row"><pre>    firmwareObject = provider->getProperty( "Firmware_Revision" );<span></span></pre></td></tr><tr><td scope="row"><pre>    if ( firmwareObject )<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        OSNumber *firmwareNumberObject;<span></span></pre></td></tr><tr><td scope="row"><pre>        UInt32 firmwareValue = 0;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        // Translate the Firmware_Revision property<span></span></pre></td></tr><tr><td scope="row"><pre>        // into an OSNumber value for inspection.<span></span></pre></td></tr><tr><td scope="row"><pre>        firmwareNumberObject = OSDynamicCast( OSNumber, firmwareObject );<span></span></pre></td></tr><tr><td scope="row"><pre>        if ( firmwareNumberObject )<span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>            firmwareValue = firmwareNumberObject->unsigned32BitValue( );<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        // Check bits 8 through 23 of the Firmware_Revision value by<span></span></pre></td></tr><tr><td scope="row"><pre>        // comparing them with the constants kMyConstant1 and<span></span></pre></td></tr><tr><td scope="row"><pre>        // kMyConstant2.<span></span></pre></td></tr><tr><td scope="row"><pre>        // These constants represent identification codes and<span></span></pre></td></tr><tr><td scope="row"><pre>        // would be defined earlier in the driver's code.<span></span></pre></td></tr><tr><td scope="row"><pre>        if ( ( ( ( firmwareValue >> 8 ) &amp; 0x000FFF ) == kMyConstant1 )<span></span></pre></td></tr><tr><td scope="row"><pre>        ||<span></span></pre></td></tr><tr><td scope="row"><pre>         ( ( ( firmwareValue >> 8 ) &amp; 0x000FFF ) == kMyConstant2 ) )<span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>            IOLog( "%s: Device component detected\n", getName( ) );<span></span></pre></td></tr><tr><td scope="row"><pre>            returnValue = this;<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>ErrorExit:<span></span></pre></td></tr><tr><td scope="row"><pre>    return returnValue;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP30000736-BBIFJHAH" title="The USB Mass Storage Class Protocol Services Driver"></a><h3>The USB Mass Storage Class Protocol Services Driver</h3><p><a name="//apple_ref/doc/uid/TP30000736-DontLinkElementID_207"></a><a name="//apple_ref/doc/uid/TP30000736-DontLinkElementID_208"></a><a name="//apple_ref/doc/uid/TP30000736-DontLinkElementID_209"></a><a name="//apple_ref/doc/uid/TP30000736-DontLinkElementID_210"></a><a name="//apple_ref/doc/uid/TP30000736-DontLinkElementID_211"></a><a name="//apple_ref/doc/uid/TP30000736-DontLinkElementID_212"></a>When a USB mass storage class device<a name="//apple_ref/doc/uid/TP30000736-DontLinkElementID_213"></a> is discovered, the USB family abstracts the contents of the device descriptor into an I/O Kit nub object called <code>IOUSBDevice</code>. The device descriptor includes information such as the device’s class and subclass, vendor and product numbers, and the number of configurations.</p><p>Because USB mass storage class devices are defined as composite class devices, the <code>AppleUSBComposite</code> driver matches against the <code>IOUSBDevice</code> nub object and sets the first configuration in the device. This causes the USB family to abstract each interface descriptor in the configuration into an <code>IOUSBInterface</code> nub object. The <code>IOUSBMassStorageClass</code> driver then matches on the mass storage class-compliant interface nub objects.</p><p><a name="//apple_ref/doc/uid/TP30000736-DontLinkElementID_214"></a>The Apple-provided <code>IOUSBMassStorageClass</code> driver contains six personalities that correspond to the six mass storage subclasses. Each subclass represents the type of command block set the device’s interfaces use. If the device is compliant with the USB mass storage class specification, its interface descriptor contains its subclass and protocol in the <code>bInterfaceSubClass</code> and <code>bInterfaceProtocol</code> fields, respectively.</p><p>The subclass code in the <code>bInterfaceSubClass</code> field refers to one of the subclasses listed in <span class="content_text"><a href="MS_Matching.html#//apple_ref/doc/uid/TP30000736-BBIGEHBA">Table 3-1</a></span>. These codes denote industry-standard specifications that describe the command block definitions used by the interfaces of USB mass storage class devices. They do <em>not</em> refer to specific device types since most USB mass storage class devices can choose to comply with any command block specification.</p><a name="//apple_ref/doc/uid/TP30000736-BBIGEHBA" title="Table 3-1USB mass storage class subclasses"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 3-1&nbsp;&nbsp;</strong>USB mass storage class subclasses</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Subclass code</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Command block specification</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Typical usage</p></th></tr><tr><td  scope="row"><p>0x01</p></td><td ><p>Reduced Block Commands (RBC)</p></td><td ><p>Flash device, other mass storage class devices</p></td></tr><tr><td  scope="row"><p>0x02</p></td><td ><p>SFF8020I</p></td><td ><p>CD-ROM device, other mass storage devices</p></td></tr><tr><td  scope="row"><p>0x03</p></td><td ><p>QIC-157</p></td><td ><p>Tape device</p></td></tr><tr><td  scope="row"><p>0x04</p></td><td ><p>UFI</p></td><td ><p>Floppy disk device</p></td></tr><tr><td  scope="row"><p>0x05</p></td><td ><p>SFF8070I</p></td><td ><p>Floppy disk device, other mass storage devices</p></td></tr><tr><td  scope="row"><p>0x06</p></td><td ><p>SCSI transparent command set</p></td><td ><p>Any device that complies with a SCSI-defined command set</p></td></tr></table></div><p>The <code>bInterfaceProtocol</code> field in the interface descriptor denotes the transport protocol the interface uses. The <code>IOUSBMassStorageClass</code> driver supports the interface protocols shown in <span class="content_text"><a href="MS_Matching.html#//apple_ref/doc/uid/TP30000736-BBHGACCG">Table 3-2</a></span>.</p><a name="//apple_ref/doc/uid/TP30000736-BBHGACCG" title="Table 3-2USB mass storage class protocols"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 3-2&nbsp;&nbsp;</strong>USB mass storage class protocols</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Protocol code</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Protocol implementation</p></th></tr><tr><td  scope="row"><p>0x0</p></td><td ><p>Control/Bulk/Interrupt protocol <em>with</em> command completion interrupt</p></td></tr><tr><td  scope="row"><p>0x01</p></td><td ><p>Control/Bulk/Interrupt protocol <em>without</em> command completion interrupt</p></td></tr><tr><td  scope="row"><p>0x50</p></td><td ><p>Bulk-only transport</p></td></tr></table></div><p>If the device is mass storage class compliant, one of the <code>IOUSBMassStorageClass</code> driver’s personalities matches on the device’s interface subclass. <span class="content_text"><a href="MS_Matching.html#//apple_ref/doc/uid/TP30000736-BBIGBDHI">Listing 3-3</a></span> shows the first personality in the <code>IOUSBMassStorageClass</code> driver’s personality dictionary.</p><a name="//apple_ref/doc/uid/TP30000736-BBIGBDHI" title="Listing 3-3One of the IOUSBMassStorageClass driver&acirc;&#128;&#153;s personalities"></a><p class="codesample"><strong>Listing 3-3&nbsp;&nbsp;</strong>One of the IOUSBMassStorageClass driver’s personalities</p><div class="codesample"><table><tr><td scope="row"><pre>&lt;dict><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;!-- CFBundleIdentifier denotes the name of the driver in<span></span></pre></td></tr><tr><td scope="row"><pre>     -- reverse DNS notation. --><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;key>CFBundleIdentifier&lt;/key><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;string>com.apple.iokit.IOUSBMassStorageClass&lt;/string><span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;!-- IOUSBMassStorageClass is the name of the class the I/O Kit<span></span></pre></td></tr><tr><td scope="row"><pre>     -- instantiates. --><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;key>IOClass&lt;/key><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;string>IOUSBMassStorageClass&lt;/string><span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;!-- IOUSBInterface is the name of the nub class this<span></span></pre></td></tr><tr><td scope="row"><pre>     -- personality attaches to. --><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;key>IOProviderClass&lt;/key><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;string>IOUSBInterface&lt;/string><span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;!-- The next two keys describe which bus<span></span></pre></td></tr><tr><td scope="row"><pre>     -- the device is on and whether it is internal<span></span></pre></td></tr><tr><td scope="row"><pre>     -- or external.--><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;key>Physical Interconnect&lt;/key><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;string>USB&lt;/string><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;key>Physical Interconnect Location&lt;/key><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;string>External&lt;/string><span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;!-- The interface class this driver matches on.--><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;key>bInterfaceClass&lt;/key><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;integer>8&lt;/integer><span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;!-- Interface subclass 1 refers to the Reduced Block Commands<span></span></pre></td></tr><tr><td scope="row"><pre>     -- subclass.--><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;key>bInterfaceSubClass&lt;/key><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;integer>1&lt;/integer><span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP30000736-TPXREF104" title="Vendor-Specific Mass Storage Class Compliant Devices"></a><h4>Vendor-Specific Mass Storage Class Compliant Devices</h4><p><a name="//apple_ref/doc/uid/TP30000736-DontLinkElementID_215"></a>Occasionally, a device is compliant with the USB mass storage specification but declares its device class to be vendor specific instead of mass storage. In this case, you need to induce the I/O Kit to load the <code>IOUSBMassStorageClass</code> driver for your device even though the driver matches on only mass storage class interfaces.</p><p><a name="//apple_ref/doc/uid/TP30000736-DontLinkElementID_216"></a>You do this by creating a KEXT that consists solely of an information property list that contains a personality for your device. Like any vendor-specific interface driver, this KEXT matches on the configuration value, interface number, and vendor and product numbers the <code>IOUSBInterface</code> nub supplies. Unlike most vendor-specific drivers, however, this KEXT sets its <code>IOClass</code> key to <code>IOUSBMassStorageClass</code> and includes a dictionary named “USB Mass Storage Characteristics” containing the subclass and protocol information that reflects how the device should be treated. The <code>IOUSBMassStorageClass</code> driver then uses those keys to determine the subclass and protocol of the device instead of relying on the information supplied by the device.</p><p><span class="content_text"><a href="MS_Matching.html#//apple_ref/doc/uid/TP30000736-BBIIEDGA">Listing 3-4</a></span> shows the personality for a device that complies with the USB mass storage class specification but belongs to the vendor-specific class.</p><a name="//apple_ref/doc/uid/TP30000736-BBIIEDGA" title="Listing 3-4Partial listing of an Info.plist file for a vendor-specific device"></a><p class="codesample"><strong>Listing 3-4&nbsp;&nbsp;</strong>Partial listing of an Info.plist file for a vendor-specific device</p><a name="//apple_ref/doc/uid/TP30000736-DontLinkElementID_217"></a><a name="//apple_ref/doc/uid/TP30000736-DontLinkElementID_218"></a><div class="codesample"><table><tr><td scope="row"><pre>&lt;dict><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;key>CFBundleIdentifier&lt;/key><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;string>com.apple.iokit.IOUSBMassStorageClass&lt;/string><span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;!-- IOUSBMassStorageClass is the name of the class the<span></span></pre></td></tr><tr><td scope="row"><pre>     -- I/O Kit instantiates when probing. --><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;key>IOClass&lt;/key><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;string>IOUSBMassStorageClass&lt;/string><span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;!-- IOUSBInterface is the name of the nub class<span></span></pre></td></tr><tr><td scope="row"><pre>    &lt; -- the driver attaches to. --><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;key>IOProviderClass&lt;/key><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;string>IOUSBInterface&lt;/string><span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;!-- The following two keys describe<span></span></pre></td></tr><tr><td scope="row"><pre>     -- which bus the device is on and whether it<span></span></pre></td></tr><tr><td scope="row"><pre>     -- is internal or external. --><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;key>Physical Interconnect&lt;/key><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;string>USB&lt;/string<span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;key>Physical Interconnect Location&lt;/key><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;string>External&lt;/string><span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;key>USB Mass Storage Characteristics&lt;/key><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;dict><span></span></pre></td></tr><tr><td scope="row"><pre>        &lt;!-- The bInterfaceProtocol value is Control/Bulk/Interrupt<span></span></pre></td></tr><tr><td scope="row"><pre>         -- with command completion interrupt. --><span></span></pre></td></tr><tr><td scope="row"><pre>        &lt;key>Preferred Protocol&lt;/key><span></span></pre></td></tr><tr><td scope="row"><pre>        &lt;integer>1&lt;/integer><span></span></pre></td></tr><tr><td scope="row"><pre>        &lt;!-- The bInterfaceSubclass value is SFF8070I. --><span></span></pre></td></tr><tr><td scope="row"><pre>        &lt;key>Preferred Subclass&lt;/key><span></span></pre></td></tr><tr><td scope="row"><pre>        &lt;integer>5&lt;/integer><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;/dict><span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;!-- The following four keys are used for interface<span></span></pre></td></tr><tr><td scope="row"><pre>     -- matching. --><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;key>bConfigurationValue&lt;/key><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;integer>MyConfigurationValue&lt;/integer><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;key>bInterfaceNumber&lt;/key><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;integer>MyInterfaceNumber&lt;/integer><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;key>idProduct&lt;/key><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;integer>MyProductID&lt;/integer><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;key>idVendor&lt;/key><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;integer>MyVendorID&lt;/integer><span></span></pre></td></tr><tr><td scope="row"><pre>&lt;/dict><span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP30000736-TPXREF105" title="Matching for a Subclass of the USB Protocol Services Driver"></a><h4>Matching for a Subclass of the USB Protocol Services Driver</h4><p><a name="//apple_ref/doc/uid/TP30000736-DontLinkElementID_219"></a>If your device is not compliant with the USB mass storage class specification, you need to develop a subclass of the <code>IOUSBMassStorageClass</code><a name="//apple_ref/doc/uid/TP30000736-DontLinkElementID_220"></a> driver to support the differences. In order to ensure that your driver loads in favor of the generic <code>IOUSBMassStorageClass</code> driver you must use the keys defined for interface matching in the Universal Serial Bus Common Class Specification, Revision 1.0 (available for download from <span class="content_text"><a href="http://www.usb.org/developers/devclass_docs/usbccs10.pdf" target="_blank">http://www.usb.org/developers/devclass_docs/usbccs10.pdf</a></span>.)</p><p>The interface-matching keys defined in the USB Common Class Specification consist of specific combinations of property keys. For a successful match, you must include the property keys defined by exactly one interface-matching key in your <code>Info.plist</code> file. If you use a combination of property keys <em>not</em> defined by any interface-matching key, your driver will not match. For example, if you use the property keys for vendor, product, and interface protocol, your driver will not match. This is because there is no key that combines the property keys of vendor, product, and interface protocol.</p><p><span class="content_text"><a href="MS_Matching.html#//apple_ref/doc/uid/TP30000736-BAJCJCFD">Table 3-3</a></span> lists the keys in order of specificity: The interface-matching key for the most specific match (and highest probe score) is listed first.</p><a name="//apple_ref/doc/uid/TP30000736-DontLinkElementID_221"></a><a name="//apple_ref/doc/uid/TP30000736-DontLinkElementID_222"></a><a name="//apple_ref/doc/uid/TP30000736-BAJCJCFD" title="Table 3-3Interface-matching keys from the USB Common Class Specification"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 3-3&nbsp;&nbsp;</strong>Interface-matching keys from the USB Common Class Specification</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Interface-matching key</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Comment</p></th></tr><tr><td  scope="row"><p><code>idVendor</code> + <code>idProduct</code> + <code>bInterfaceNumber</code> + <code>bConfigurationValue</code> + <code>bcdDevice</code></p></td><td ><p></p></td></tr><tr><td  scope="row"><p><code>idVendor</code> + <code>idProduct</code> + <code>bInterfaceNumber</code> + <code>bConfigurationValue</code></p></td><td ><p></p></td></tr><tr><td  scope="row"><p><code>idVendor</code> + <code>bInterfaceSubClass</code> + <code>bInterfaceProtocol</code></p></td><td ><p>Only if <code>bInterfaceClass</code> is0xFF</p></td></tr><tr><td  scope="row"><p><code>idVendor</code> + <code>bInterfaceSubClass</code></p></td><td ><p>Only if <code>bInterfaceClass</code> is 0xFF</p></td></tr><tr><td  scope="row"><p><code>bInterfaceClass</code> + <code>bInterfaceSubClass</code> + <code>bInterfaceProtocol</code></p></td><td ><p>Only if <code>bInterfaceClass</code> is not 0xFF</p></td></tr><tr><td  scope="row"><p><code>bInterfaceClass</code> + <code>bInterfaceSubClass</code></p></td><td ><p>Only if <code>bInterfaceClass</code> is not 0xFF<a name="//apple_ref/doc/uid/TP30000736-DontLinkElementID_223"></a><a name="//apple_ref/doc/uid/TP30000736-DontLinkElementID_224"></a><a name="//apple_ref/doc/uid/TP30000736-DontLinkElementID_225"></a></p></td></tr></table></div><a name="//apple_ref/doc/uid/TP30000736-TPXREF106" title="The ATAPI Protocol Services Driver"></a><h3>The ATAPI Protocol Services Driver</h3><p><a name="//apple_ref/doc/uid/TP30000736-DontLinkElementID_226"></a><a name="//apple_ref/doc/uid/TP30000736-DontLinkElementID_227"></a><a name="//apple_ref/doc/uid/TP30000736-DontLinkElementID_228"></a><a name="//apple_ref/doc/uid/TP30000736-DontLinkElementID_229"></a>When an ATAPI mass storage device<a name="//apple_ref/doc/uid/TP30000736-DontLinkElementID_230"></a> is discovered, the ATAPI bus controller publishes an ATA device nub that is a concrete subclass of <code>IOATADevice</code>. The ATA family defines no family-specific matching so all matching is active. This means the driver probes the device to determine if it is suited to drive it.</p><p><a name="//apple_ref/doc/uid/TP30000736-DontLinkElementID_231"></a>In its <code>start</code> method during active matching, the <code>IOATAPIProtocolTransport</code> driver compares the properties in its personality to the device’s properties. In particular, if the device’s ATA device type is ATAPI, the driver loads for that device. <span class="content_text"><a href="MS_Matching.html#//apple_ref/doc/uid/TP30000736-BBIGHGIH">Listing 3-5</a></span> shows the personality for the <code>IOATAPIProtocolTransport</code> driver.</p><a name="//apple_ref/doc/uid/TP30000736-BBIGHGIH" title="Listing 3-5The IOATAPIProtocolTransport driver personality dictionary"></a><p class="codesample"><strong>Listing 3-5&nbsp;&nbsp;</strong>The IOATAPIProtocolTransport driver personality dictionary</p><div class="codesample"><table><tr><td scope="row"><pre>&lt;dict><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;!-- CFBundleIdentifier denotes the name of the driver in<span></span></pre></td></tr><tr><td scope="row"><pre>     -- reverse DNS notation. --><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;key>CFBundleIdentifier&lt;/key><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;string>com.apple.iokit.IOATAPIProtocolTransport&lt;/string><span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;!-- IOATAPIProtocolTransport is the class the I/O Kit<span></span></pre></td></tr><tr><td scope="row"><pre>     -- instantiates when probing. --><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;key>IOClass&lt;/key><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;string>IOATAPIProtocolTransport&lt;/string><span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;!-- IOATADevice is the nub this driver attaches to. --><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;key>IOProviderClass&lt;/key><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;string>IOATADevice&lt;/string><span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;!-- The next two keys describe which bus the<span></span></pre></td></tr><tr><td scope="row"><pre>     -- device is on and whether it is internal<span></span></pre></td></tr><tr><td scope="row"><pre>     -- or external.--><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;key>Physical Interconnect&lt;/key><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;string>ATAPI&lt;/string><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;key>Physical Interconnect Location&lt;/key><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;string>Internal&lt;string><span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;!-- The value of this key is compared to the ATA device type<span></span></pre></td></tr><tr><td scope="row"><pre>     -- of the device. --><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;key>ata device type&lt;/key><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;string>atapi&lt;/string><span></span></pre></td></tr><tr><td scope="row"><pre>&lt;/dict><span></span></pre></td></tr></table></div><p><a name="//apple_ref/doc/uid/TP30000736-DontLinkElementID_232"></a><a name="//apple_ref/doc/uid/TP30000736-DontLinkElementID_233"></a>A subclass of the <code>IOATAPIProtocolTransport</code> driver should include the same keys shown in <span class="content_text"><a href="MS_Matching.html#//apple_ref/doc/uid/TP30000736-BBIGHGIH">Listing 3-5</a></span> in its personality dictionary. If you need to address ATAPI-specific issues such as a device that needs to do a hard reset after a particular event, you need to develop a subclass of <code>IOATAPIProtocolTransport</code> that overrides the appropriate methods. To ensure that your subclass driver loads, you should implement the <code>probe</code> method and increase the probe score after determining that your driver can, in fact, drive the device.</p><p>In order to change a device’s DMA or UDMA modes, however, you can take advantage of a feature in the <code>IOATAPIProtocolTransport</code> driver that allows a subclass to override the mode the device reports. You enable this feature by creating a KEXT that consists of an <code>Info.plist</code> file containing a dictionary named “<a name="//apple_ref/doc/uid/TP30000736-DontLinkElementID_234"></a>ATAPI Mass Storage Characteristics” in addition to the keys shown in <span class="content_text"><a href="MS_Matching.html#//apple_ref/doc/uid/TP30000736-BBIGHGIH">Listing 3-5</a></span>. This dictionary contains the device model name and the DMA and UDMA mode values you choose. The device model name is the string the device returns when it responds to the ATA <code>Identify</code> command. The DMA and UDMA mode values are bitmasks defined in the ATA/ATAPI-5 specification (available at <span class="content_text"><a href="http://www.t13.org" target="_blank">http://www.t13.org</a></span>). <span class="content_text"><a href="MS_Matching.html#//apple_ref/doc/uid/TP30000736-BBIEEHIE">Listing 3-6</a></span> shows an example personality dictionary that overrides the DMA and UDMA values returned by the device.</p><a name="//apple_ref/doc/uid/TP30000736-BBIEEHIE" title="Listing 3-6A personality dictionary that overrides DMA and UDMA values"></a><p class="codesample"><strong>Listing 3-6&nbsp;&nbsp;</strong>A personality dictionary that overrides DMA and UDMA values</p><div class="codesample"><table><tr><td scope="row"><pre>&lt;dict><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;key>ATAPI Mass Storage Characteristics&lt;/key><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;dict><span></span></pre></td></tr><tr><td scope="row"><pre>        &lt;key>DMA Mode&lt;/key><span></span></pre></td></tr><tr><td scope="row"><pre>        &lt;integer>0&lt;/integer><span></span></pre></td></tr><tr><td scope="row"><pre>        &lt;key>UDMA Mode&lt;/key><span></span></pre></td></tr><tr><td scope="row"><pre>        &lt;integer>0&lt;/integer><span></span></pre></td></tr><tr><td scope="row"><pre>        &lt;key>device model&lt;/key><span></span></pre></td></tr><tr><td scope="row"><pre>        &lt;string>MyDeviceModel&lt;/string><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;/dict><span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;key>CFBundleIdentifier&lt;/key><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;string>com.apple.iokit.IOATAPIProtocolTransport&lt;/string><span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;key>IOClass&lt;/key><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;string>IOATAPIProtocolTransport&lt;/string><span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;key>IOProbeScore&lt;/key><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;integer>5000&lt;/integer><span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;key>IOProviderClass&lt;/key><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;string>IOATADevice&lt;/string><span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;key>Physical Interconnect&lt;/key><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;string>ATAPI&lt;/string><span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;key>Physical Interconnect Location&lt;/key><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;string>Internal&lt;/string><span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;key>ata device type&lt;/key><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;string>atapi&lt;/string><span></span></pre></td></tr><tr><td scope="row"><pre>&lt;/dict><span></span></pre></td></tr></table></div><p>In this example, when this device is discovered, the I/O Kit allows all KEXTs with the key-value pair<a name="//apple_ref/doc/uid/TP30000736-DontLinkElementID_235"></a></p><div class="codesample"><table><tr><td scope="row"><pre>&lt;key>ata device type&lt;/key><span></span></pre></td></tr><tr><td scope="row"><pre>&lt;string>atapi&lt;/string><span></span></pre></td></tr></table></div><p>to probe the device. If a KEXT’s personality contains the ATAPI Mass Storage Characteristics dictionary, the I/O Kit compares the value of the <code>device model</code> string with the device model name reported by the device. If they match, the I/O Kit loads the <code>IOATAPIProtocolTransport</code> driver and applies the DMA and UDMA overrides declared in the ATAPI Mass Storage Characteristics dictionary<a name="//apple_ref/doc/uid/TP30000736-DontLinkElementID_236"></a><a name="//apple_ref/doc/uid/TP30000736-DontLinkElementID_237"></a>.<a name="//apple_ref/doc/uid/TP30000736-DontLinkElementID_238"></a><a name="//apple_ref/doc/uid/TP30000736-DontLinkElementID_239"></a><a name="//apple_ref/doc/uid/TP30000736-DontLinkElementID_240"></a><a name="//apple_ref/doc/uid/TP30000736-DontLinkElementID_241"></a><a name="//apple_ref/doc/uid/TP30000736-DontLinkElementID_242"></a></p><a name="//apple_ref/doc/uid/TP30000736-BBIFHFBG" title="Logical Unit Driver Matching"></a><h2>Logical Unit Driver Matching</h2><p><a name="//apple_ref/doc/uid/TP30000736-DontLinkElementID_243"></a><a name="//apple_ref/doc/uid/TP30000736-DontLinkElementID_244"></a>After the protocol services driver loads, the peripheral device nub queries the device and publishes its device type in the I/O Registry. The I/O Kit then finds and loads the appropriate logical unit driver for the device. Unlike the bus-specific perspective of the protocol services drivers, the logical unit drivers view a mass storage device in terms of its device type as defined by the SCSI Architecture Model specifications. Thus, all four in-kernel logical unit drivers use the same matching language.</p><p><a name="//apple_ref/doc/uid/TP30000736-DontLinkElementID_245"></a>The following four properties in the personality of a logical unit driver determine which devices or device types the driver is suited for:</p><ul class="ul"><li class="li"><p>The peripheral device type property</p></li><li class="li"><p>The vendor property</p></li><li class="li"><p>The product or model property</p></li><li class="li"><p>The product or software revision property</p></li></ul><p>These four properties vary from the general to the specific. Each specified property narrows the range of devices the driver is suitable for. The more properties the driver includes in its personality, the more specific the device it is suited to manage. The presence of the more specific properties does not make up for the absence of the peripheral device type property, however. If you do not include the peripheral device type property in your logical unit driver’s personality, it will not be considered for loading.</p><p>During the passive matching phase, the properties are examined in the order listed and the driver’s probe score is increased with each match. Every property in the driver’s personality must match in order for the driver to be considered a candidate for the device. In other words, if a driver specifies a property, it must match for that driver to be considered. If one of the more specific properties is absent, however, it does not affect the probe score because that means the driver can manage a broader range of devices.</p><p>For example, of the four listed properties, the <code>IOSCSIPeripheralDeviceType00</code><a name="//apple_ref/doc/uid/TP30000736-DontLinkElementID_246"></a> driver lists only the peripheral device type property in its personality because it can drive any device that complies with the SCSI Architecture Model specification for block storage devices. The personality dictionary for the <code>IOSCSIPeripheralDeviceType00</code> driver is shown in <span class="content_text"><a href="MS_Matching.html#//apple_ref/doc/uid/TP30000736-BBJCABBG">Listing 3-7</a></span>.</p><a name="//apple_ref/doc/uid/TP30000736-BBJCABBG" title="Listing 3-7The IOSCSIPeripheralDeviceType00 driver personality dictionary"></a><p class="codesample"><strong>Listing 3-7&nbsp;&nbsp;</strong>The IOSCSIPeripheralDeviceType00 driver personality dictionary</p><div class="codesample"><table><tr><td scope="row"><pre>&lt;dict><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;!-- The CFBundleIdentifier gives the name of this KEXT in<span></span></pre></td></tr><tr><td scope="row"><pre>     -- reverse-DNS notation. --><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;key>CFBundleIdentifier&lt;/key><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;string>com.apple.iokit.IOSCSIBlockCommandsDevice&lt;/string><span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;!-- IOSCSIPeripheralDeviceType00 is the name of the class<span></span></pre></td></tr><tr><td scope="row"><pre>     -- the I/O Kit instantiates. --><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;key>IOClass&lt;/key><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;string>IOSCSIPeripheralDeviceType00&lt;/string><span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;!-- IOSCSIPeripheralDeviceNub is the name of the nub<span></span></pre></td></tr><tr><td scope="row"><pre>     -- class this personality attaches to. --><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;key>IOProviderClass&lt;/key><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;string>IOSCSIPeripheralDeviceNub&lt;/string><span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;!-- This personality is suited to drive devices of peripheral<span></span></pre></td></tr><tr><td scope="row"><pre>     -- device type 0. -><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;key>Peripheral Device Type&lt;/key><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;integer>0&lt;/integer><span></span></pre></td></tr><tr><td scope="row"><pre>&lt;/dict><span></span></pre></td></tr></table></div><p><a name="//apple_ref/doc/uid/TP30000736-DontLinkElementID_247"></a>If you subclass a logical unit driver to address a device’s differently implemented command or added feature, you must ensure that your driver’s probe score is higher than that of a more generic driver. To do this, you add as many of the four logical unit driver personality properties as necessary to uniquely identify your device.</p><p>For example, a driver can use both vendor and product information to ensure that it gets loaded in favor of one of the Apple-provided logical unit drivers. <span class="content_text"><a href="MS_Matching.html#//apple_ref/doc/uid/TP30000736-BBJCAIFD">Listing 3-8</a></span> shows the personality dictionary for a driver competing with the <code>IOSCSIPeripheralDeviceType05</code> driver.<a name="//apple_ref/doc/uid/TP30000736-DontLinkElementID_248"></a></p><a name="//apple_ref/doc/uid/TP30000736-BBJCAIFD" title="Listing 3-8Example logical unit driver personality dictionary"></a><p class="codesample"><strong>Listing 3-8&nbsp;&nbsp;</strong>Example logical unit driver personality dictionary</p><a name="//apple_ref/doc/uid/TP30000736-DontLinkElementID_249"></a><a name="//apple_ref/doc/uid/TP30000736-DontLinkElementID_250"></a><a name="//apple_ref/doc/uid/TP30000736-DontLinkElementID_251"></a><div class="codesample"><table><tr><td scope="row"><pre>&lt;dict><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;!-- The CFBundleIdentifier value is the name of<span></span></pre></td></tr><tr><td scope="row"><pre>     -- this KEXT. --><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;key>CFBundleIdentifier&lt;/key><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;string>com.MySoftwareCompany.driver.MyLogicalUnitDriver&lt;/string><span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;!-- The IOClass value is the name of the class<span></span></pre></td></tr><tr><td scope="row"><pre>     -- the I/O Kit instantiates. --><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;key>IOClass&lt;/key><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;string>com_MySoftwareCompany_iokit_MyLogicalUnitDriver&lt;/string><span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;!-- The IOProviderClass value is the name of the<span></span></pre></td></tr><tr><td scope="row"><pre>     -- nub this driver attaches to. --><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;key>IOProviderClass&lt;/key><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;string>IOSCSIPeripheralDeviceNub&lt;/string><span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;!-- The next three keys determine the device this<span></span></pre></td></tr><tr><td scope="row"><pre>     -- driver is suited to drive. --><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;key>Peripheral Device Type&lt;/key><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;integer>5&lt;/integer><span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;key>Product Identification&lt;/key><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;string>MyProductID&lt;/string><span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;key>Vendor Identification&lt;/key><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;string>MyVendorID&lt;/string><span></span></pre></td></tr><tr><td scope="row"><pre>&lt;/dict><span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP30000736-BCIBACGH" title="Filter-Scheme Driver Matching"></a><h2>Filter-Scheme Driver Matching</h2><p><a name="//apple_ref/doc/uid/TP30000736-DontLinkElementID_252"></a><a name="//apple_ref/doc/uid/TP30000736-DontLinkElementID_253"></a><a name="//apple_ref/doc/uid/TP30000736-DontLinkElementID_254"></a>After the logical unit driver loads, it publishes the appropriate device services nub with the device’s type in the I/O Registry. The I/O Kit initiates matching on this nub object and finds the appropriate generic block storage driver. The block storage driver then publishes an <code>IOMedia</code> object that represents the whole device. If the disk is Apple-formatted, the <code>IOApplePartitionScheme</code> matches on the <code>IOMedia</code> object and publishes new <code>IOMedia</code> objects for each partition.</p><p>Filter-scheme drivers must match on the properties the <code>IOMedia</code> objects publish. The standard set of properties for <code>IOMedia</code> objects include the following:</p><a name="//apple_ref/doc/uid/TP30000736-TPXREF107" title="Table 3-4IOMedia properties"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><strong>Table 3-4&nbsp;&nbsp;</strong>IOMedia properties</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Key</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Type</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Description</p></th></tr><tr><td  scope="row"><p><code>kIOMediaEjectableKey</code></p></td><td ><p>Boolean</p></td><td ><p>Is the media ejectable?</p></td></tr><tr><td  scope="row"><p><code>kIOMediaPreferredBlockSizeKey</code></p></td><td ><p>Number</p></td><td ><p>The media’s natural block size in bytes.</p></td></tr><tr><td  scope="row"><p><code>kIOMediaSizeKey</code></p></td><td ><p>Number</p></td><td ><p>The media’s entire size in bytes.</p></td></tr><tr><td  scope="row"><p><code>kIOMediaWholeKey</code></p></td><td ><p>Boolean</p></td><td ><p>Is the media at the root of the media tree? This is true for the physical media representation, a RAID media representation, etc.</p></td></tr><tr><td  scope="row"><p><code>kIOMediaWritableKey</code></p></td><td ><p>Boolean</p></td><td ><p>Is the media writable?</p></td></tr><tr><td  scope="row"><p><code>kIOMediaContentHintKey</code></p></td><td ><p>String</p></td><td ><p>The media’s content description, as hinted at the time of the object’s creation. The string is of the <em>MyCompany_MyContent</em> format.</p></td></tr><tr><td  scope="row"><p><code>kIOBSDNameKey</code></p></td><td ><p>String</p></td><td ><p>The media’s BSD device node name, which is dynamically assigned at the object’s creation.</p></td></tr></table></div><p><a name="//apple_ref/doc/uid/TP30000736-DontLinkElementID_255"></a>You can choose any subset of these properties to include in your driver’s personality dictionary, but all properties in the personality must match for your driver to be considered for loading.</p><p>The <code>kIOMediaContentHintKey</code> is the most useful property because it matches on the unique content-hint string<a name="//apple_ref/doc/uid/TP30000736-DontLinkElementID_256"></a> your disk utility program places in the media’s partition (for more information on this process, see <span class="content_text"><a href="../02_Overview/MS_Overview.html#//apple_ref/doc/uid/TP30000734-BJGFJIJA">“Construction of a Mass Storage Driver Stack”</a></span>). You define the content-hint string your disk utility program uses, you place the same content-hint string in the <code>kIOMediaContentHintKey</code> property of your driver’s personality, and your filter-scheme driver is the only candidate to match on that media.</p><p>Unlike the SCSI Architecture Model family, the Storage family does not increase a driver’s probe score with each successful property match during the passive matching phase. If a filter-scheme driver’s personality matches successfully on an <code>IOMedia</code> object’s properties, the I/O Kit allows it to probe<a name="//apple_ref/doc/uid/TP30000736-DontLinkElementID_257"></a> the media during the active matching phase. If the filter-scheme driver implements its own <code>probe</code> method, it can increase or decrease its probe score according to its ability to drive the media. However, because the filter-scheme driver that matches on the content-hint string is almost certainly the only driver candidate, it is seldom necessary to override the <code>probe</code> method. By default, the <code>probe</code> method returns <code>true</code> and the active matching phase ends as the I/O Kit chooses the one filter-scheme driver that matched on the content-hint string property.</p><p>If you develop your own filter-scheme driver, you must ensure that your driver’s personality can match on your content as identified by your content-hint string. <span class="content_text"><a href="MS_Matching.html#//apple_ref/doc/uid/TP30000736-BCIGBFFG">Listing 3-9</a></span> shows the personality dictionary of a filter-scheme driver that matches on the content-hint string <code>MySoftwareCompany_MyContent</code>.</p><a name="//apple_ref/doc/uid/TP30000736-BCIGBFFG" title="Listing 3-9Example filter-scheme driver personality"></a><p class="codesample"><strong>Listing 3-9&nbsp;&nbsp;</strong>Example filter-scheme driver personality</p><a name="//apple_ref/doc/uid/TP30000736-DontLinkElementID_258"></a><a name="//apple_ref/doc/uid/TP30000736-DontLinkElementID_259"></a><a name="//apple_ref/doc/uid/TP30000736-DontLinkElementID_260"></a><a name="//apple_ref/doc/uid/TP30000736-DontLinkElementID_261"></a><div class="codesample"><table><tr><td scope="row"><pre>&lt;dict><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;key>IOStorage&lt;/key><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;dict><span></span></pre></td></tr><tr><td scope="row"><pre>        &lt;!-- The CFBundleIdentifier gives the name of this KEXT in<span></span></pre></td></tr><tr><td scope="row"><pre>         -- reverse-DNS notation. --><span></span></pre></td></tr><tr><td scope="row"><pre>        &lt;key>CFBundleIdentifier&lt;/key><span></span></pre></td></tr><tr><td scope="row"><pre>        &lt;string>com.MySoftwareCompany.driver.MyFilterScheme&lt;/string><span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        &lt;!-- The Content Hint value must be identical to the content hint<span></span></pre></td></tr><tr><td scope="row"><pre>         -- string your disk utility program places in the partition. --><span></span></pre></td></tr><tr><td scope="row"><pre>        &lt;key>Content Hint&lt;/key><span></span></pre></td></tr><tr><td scope="row"><pre>        &lt;string>MySoftwareCompany_MyContent&lt;/string><span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        &lt;!-- The IOClass value is the name of the class<span></span></pre></td></tr><tr><td scope="row"><pre>         -- the I/O Kit instantiates. --><span></span></pre></td></tr><tr><td scope="row"><pre>        &lt;key>IOClass&lt;/key><span></span></pre></td></tr><tr><td scope="row"><pre>        &lt;string>com_MySoftwareCompany_driver_MyFilterScheme&lt;/string><span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        &lt;!-- The IOMatchCategory key is a special key that allows<span></span></pre></td></tr><tr><td scope="row"><pre>         -- multiple clients to match on an IOMedia object. --><span></span></pre></td></tr><tr><td scope="row"><pre>        &lt;key>IOMatchCategory&lt;/key><span></span></pre></td></tr><tr><td scope="row"><pre>        &lt;string>IOStorage&lt;/string><span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        &lt;!-- The IOProviderClass is the name of the<span></span></pre></td></tr><tr><td scope="row"><pre>         -- nub this driver attaches to. --><span></span></pre></td></tr><tr><td scope="row"><pre>        &lt;key>IOProviderClass&lt;/key><span></span></pre></td></tr><tr><td scope="row"><pre>        &lt;string>IOMedia&lt;/string><span></span></pre></td></tr><tr><td scope="row"><pre>    &lt;/dict><span></span></pre></td></tr><tr><td scope="row"><pre>&lt;/dict><span></span></pre></td></tr></table></div>

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../03_Compliance/MS_Compliance.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../05_Universal_Binary/MS_UniversalBinary.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2002, 2007 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2007-04-03<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/DeviceDrivers/Conceptual/MassStorage/04_Matching/MS_Matching.html%3Fid%3DTP40000974-4.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/DeviceDrivers/Conceptual/MassStorage/04_Matching/MS_Matching.html%3Fid%3DTP40000974-4.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/DeviceDrivers/Conceptual/MassStorage/04_Matching/MS_Matching.html%3Fid%3DTP40000974-4.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>