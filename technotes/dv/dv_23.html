<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"			"http://www.w3.org/TR/REC-html40/loose.dtd"><HTML><!-- Template 01-August-01 --><!-- Includes revisions to graphics tags --><HEAD><LINK REL="stylesheet" HREF="../../adcstyle.css" TYPE="text/css"><LINK REL="stylesheet" HREF="../../style.css" TYPE="text/css"><title>Technical Note DV23: Driver Education</title><meta name="keywords" content="Mac OS 8 Device Manager driver JIODone Unit Table DCE"><meta name="Description" content="Technical Note DV23: This Technical Note describes in detailthe operation of the Device Manager and its interaction withdevice drivers. It provides the background needed (synchronous/asynchronouscalls,read,write,status etc.,) for correct operation of third-partydevice drivers and also presents a method for finding anentry in the Unit Table for a driver.">                                      <meta name="categories" content="Devices"><meta name="week-posted" content="Jul 30, 1990 - Aug 3, 1990"><LINK REL="stylesheet" HREF="../../css/adcstyle.css" TYPE="text/css"><script language="JavaScript" type="text/javascript" src="../../js/adc.js"></script></HEAD><BODY BGCOLOR="#FFFFFF"><a name="//apple_ref/doc/uid/DTS10002412" title="Driver Education"></a><A NAME="top"></A><!-- top_of_header_marker_comment --><!-- begin_header_information --><!--#include virtual="/adcnavbar" --><p><a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../technicalnotes/index.html">Technical Notes</a> &gt; <a href="../../technicalnotes/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../technicalnotes/LegacyTechnologies/idxHardwareDrivers-date.html">Hardware & Drivers</a> &gt; </p><div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="http://developer.apple.com/referencelibrary/HardwareDrivers/index.html" target="_blank">Reference Library > Hardware & Drivers</a></li>
	</ul>
</div>




</div></div></div><!-- end_header_information --><!-- bottom_of_header_marker_comment --><!-- top_of_titles_marker_comment --><CENTER><table width="600" cellpadding="0" cellspacing="0" border="0">
<tr><td align="left" scope="row">
<h1>
<div id="pagehead">Technical Note DV23</div>
<div id="pageheadsub">Driver Education</div>
</h1>
</td></tr></table></CENTER><!-- bottom_of_titles_marker_comment --><CENTER><TABLE BORDER=0 CELLSPACING=1 WIDTH=600><TR><td align="left"><!-- begin_header_box --><table width="600" cellpadding="0" cellspacing="0" border="0">    <tr>        <td width=300 valign="top" align=left scope="row">            <table border="0" width="300" cellpadding="0" cellspacing="0">			<tr>                        <td width=300 align=left> <img src="images/tnmenutop.gif" alt="" align="bottom" width=300 height=7></td>                </tr>                <tr bgcolor="#e6e6e6">                    <td background="images/tnmenubody.gif" width=300 align=left>                                         <span id="menutitle">                            CONTENTS                             <br>                            <br>                        </span>                    </td>                </tr>                <tr bgcolor="#e6e6e6">                    <td background="images/tnmenubody.gif" width=300 align=left>					<!-- begin_toc -->										<p id="menutext"> <A HREF="#Section1">Caveat--Low Memory and System Data Structures</A><BR><BR> <A HREF="#driven">Driven to Tears</A><BR><BR>  <A HREF="#Section2">Routine Maintenance</A><BR><BR>   <A HREF="#Section3">What the Glue Do</A><BR><BR>    <A HREF="#Section4">Yes, We're Open</A><BR><BR>     <A HREF="#Section5">That's Great, But What Are You Driving At?</A><BR><BR>      <A HREF="#Section6">Immediate Asynchronicity</A><BR><BR>       <A HREF="#Section7">You Can Feel It When You Drive</A><BR><BR>        <A HREF="#Section8">Sorry, We're Closed</A><BR><BR><A HREF="#Section9">Get Outta the Way, Ya Sunday Driver</A><BR><BR>  <A HREF="#Section10">What the Heck Does JIODone Do, Anyway?</A><BR><BR>  <A HREF="#Section11">Driving the Point Home</A><BR><BR> <A HREF="#Section12">Crucial References for Writing a Macintosh SCSI Disk Driver</A><BR><BR> <A HREF="#references">References</A><BR>                  <BR>                                    <A HREF="#downloads">Downloadables</A></P>                   <!-- end_toc -->                  </td>                </tr>                <tr>                    <td width=300 align=left scope="row">                        <img src="images/tnmenubottom.gif" alt="" width=300 height=16>                    </td>                </tr>            </table>        </td>        <td width=300 valign="top" align=left><!-- begin_intro_text --><P id = "introtext">This Technical Note describes in detail the operation of the Device Manager andits interaction with device drivers. It provides the background needed for correct operation of third-party device drivers and also presents a method for finding an entry in the Unit Table for a driver.</p><P id = "introtext">Many aspects of the Device Manager remain mysterious to even the most studious of Macintosh developers, especially those who might wish to accomplish tasks not directlysupported by the current offering of calls. For example, developers might wishto install their own driver at INIT time or wish to manage their own I/O queuesfor processing. A solid knowledge of the Device Manager helps in these tasks,as well as in simply writing a normal, no-frills device driver.</p><P id = "introtext">A general-usage driver, which is best installed at INIT time, provides servicesto software that might run on a Macintosh at any time. This type of driver istypically implemented by having a file of type INIT, cdev, or RDEV that usersmove into their System Folder. This file contains <code>'INIT'</code> and<code>'DRVR'</code> resources, among others. The <code>'INIT'</code> resource getsloaded into memory and executed, at which time it installs the driver.</p><!-- end_intro_text --><!-- begin_date --><h3 align=center>[Aug 01 1990]</h3><!-- end_date -->                </TD>             </TR>          </TABLE>          <!-- end_table_box --> <BR><BR>          <hr width=500 align=center>          <BR><BR>          <!-- begin_content -->          <P><A NAME=Section1></A></P><h2>Caveat--Low Memory and System Data Structures</h2><p><b>Warning:</b>    This Note involves the discussion and use of low-memory globalsand operating system internal data structures. It is a plain fact that usingthese puts software at a compatibility risk; therefore, DTS recommends youapproach the information in this Note in the following manner:</p><ol type="1">	<li>If you do not have to use a low-memory global or system data structure, then don't.</li>	<li>If you do have to use a low-memory global or system data structure, use it only as described in this Note, or in other, authorized Apple Computer, Inc., technical documentation.</li>	<li>When using a low-memory global or system data structure in an authorized manner, do so in a way that encapsulates and isolates this dependency from the rest of this software. This way, if Apple alters the structure of space-time out from under you, there is one nice, tidy spot that you have to modify.</li>	<li>When Apple provides a system-independent manner by which you can obtain the same information, modify your code to use this method.</li></ol><p>An example of points three and four would be using a module that returns alow-memory global instead of always reaching into low-memory directly. Forexample, when this Note references the low-memory global <code>UTableBase</code>,the software that needs the value stored there should call a routine like the following:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>              FUNCTION GetUTableBase : Ptr;              CONST                  UTableBase = $11C;              TYPE                  LongPtr = ^LongInt;              BEGIN                  GetUTableBase := POINTER(LongPtr(UTableBase)^);              END;</pre>	</TD></TR></TABLE></CENTER>              <p>Then, if Apple were to provide a <code>Gestalt</code> call to get the same value,only this one module would (and should) be changed. If you are blessed enoughto be using a high-level or, better yet, an object-oriented language, you caneven further isolate the dependency by encapsulating a whole mechanism thatrelies on low-memory globals and system data structures into a module that canbe completely replaced if needed.</p><p>It should go without saying that simply because this Note uses some low-memoryglobals and system data structures, it does not mean Apple has gone soft on software that uses them, especially when they violate the aforementioned guidelines.</p><P><A HREF="#top">Back to top</A></P><a name="driven"></a><h2>Driven to Tears</h2><p>A solid understanding of the Device Manager begins with knowledge of its datastructures. Although much of the following is described in <i>InsideMacintosh</i>, Apple has made some changes since its publication.</p><p>First, there is the structure of the unit table. It is a non-relocatable blockin the system heap that is pointed to by the low-memory global<code>UTableBase</code> (<code>$11C</code>). The unit table is a contiguous table ofhandles to Device Control Entry (DCE) records. The offset of a handle withinthe unit table (its entry, or "slot") determines the unit number for thedriver, as well as the <code>refnum</code> for that handle, since a unit numberrelates to a <code>refnum</code> in the following way:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>    refnum = ~( unit number )</pre>	</TD></TR></TABLE></CENTER><p>If the handle at a particular slot is <code>NIL</code>, there is no DCE and thus nodriver installed for that <code>refnum</code>. There is another low-memory global,<code>UnitNtryCnt</code> (<code>$1D2</code>), which is the count of entries in the unittable. This low-memory global can be used to know when to stop searching theunit table.</p><p>Many of the slots in the unit table are committed to certain devices due to thefact that the corresponding reference numbers are committed to those devices.For example, the <code>refnum</code> -3 is reserved for the .Print driver;therefore, unit number <code>-(-3)-1=2 </code>is reserved, which means that theslot at offset <code>8 (4 bytes per handle * 2) </code>in the unit table isreserved for the handle to the DCE of the .Print driver. This relationship istrue even if the slot is currently <code>NIL</code>, because a lot of the operatingsystem, Toolbox, and applications make heavy assumptions about the<code>refnum</code> of a particular device. There are more detailed lists in<i>Inside Macintosh</i>, but following is a summary list of what unit numbersare committed to what device types:</p><p><b>Unit Number Range    Refnum Range Usage</b></p><p>0 through 11 -1 through -12    Serial, disk, AppleTalk, printer, and so on</p><p>12 through 31 -13 through -32    Desk accessories</p><p>32 through 39 -33 through -40    SCSI devices</p><p>40 through 47 -41 through -48    AppleShare and other reserved for Apple</p><p>48 through 63, 127 -49 through -64, -128 Slot drivers--open for other drivers as well</p><p>The entry for unit numbers 48 and above requires some explanation. First, onthe Macintosh 512KE and Macintosh Plus, the unit table does not go past unitnumber 47; this point is addressed later. On the Macintosh SE, the unit tableis large enough to hold up to unit number 63. On the Macintosh II family ofmachines, the unit table is large enough to hold up to unit number 127;<code>UnitNtryCnt</code> is probably lower, though not lower than 64.</p><p>After documenting the device control entry blocks in <i>Inside Macintosh</i>,Volume II, Apple has expanded them to deal with new features like the SlotManager. The new DCE looks the same as the old DCE, but contains a fewadditional fields:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>    TYPE AuxDCE = PACKED RECORD                     dCtlDriver:    Ptr;                     dCtlFlags:     INTEGER;                     dCtlQHdr:      QHdr;                     dCtlPosition:  LONGINT;                     dCtlStorage:   Handle;                     dCtlRefnum:    INTEGER;                     dCtlCurTicks:  LONGINT;                     dCtlWindow:    Ptr;                     dCtlDelay:     INTEGER;                     dCtlEMask:     INTEGER;                     dCtlMenu:      INTEGER;</pre>	</TD></TR></TABLE></CENTER>                     <p>The following fields are the additions for the new DCE record:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>                     dCtlSlot:      Byte;                     dCtlSlotId:    Byte;                     dCtlDevBase:   LONGINT;                     reserved:      LONGINT;                     dCtlExtDev:    Byte;                     fillByte:      Byte;                  END;</pre>	</TD></TR></TABLE></CENTER>                  <p>The core structure of parameter blocks has remained the same as described in<i>Inside Macintosh</i>. They begin with the standard I/O queue fields:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>    TYPE ParamBlockRec = RECORD                            qLink:         QElemPtr;                            qType:         INTEGER;                            ioTrap:        INTEGER;                            ioCmdAddr:     Ptr;                            ioCompletion:  ProcPtr;                            ioResult:      OSErr;                            ioNamePtr:     StringPtr;                            ioVRefNum:     INTEGER;                            ioRefNum:      INTEGER;                            ...                         END;</pre>	</TD></TR></TABLE></CENTER>                         <p>The rest of the parameter block is heavily dependent on the device driver thatuses it and what kind of driver call is being made.</p><p>The Unit Table, the DCE, and the Parameter Block all work together to provideall the information necessary for the application, Device Manager, and devicedriver to communicate with one another. For example, the structure of aRAM-based driver that has been opened and called asynchronously a few timesmight look like that shown in Figure 1.</p><CENTER><TABLE BORDER=0 CELLPADDING=0>            <TR>               <td align="left">                  <img src="images/dv_23_001.gif" alt="Basic Device Manager Data Structures" width=448 height=335>                  <BR>                  <P><B>Figure 1</B>. Basic Device Manager Data Structures.</P>               </TD>            </TR>         </TABLE></CENTER><P><A HREF="#top">Back to top</A></P><a name="Section2"></a><h2>Routine Maintenance</h2><p>A device driver is a block of data composed of a header followed by executablecode. The header contains flags, a delay amount, an event mask, a menu ID, anoptional name of the driver, and offsets to the routines that are in theexecutable code. <i>Inside Macintosh</i> describes device drivers as being<code>'DRVR' </code>resources. Although this is typically the case, it should benoted that this is not necessarily a requirement, as long as certain rules arefollowed. Details of these rules are discussed later in this Note.</p><p>A device driver can implement five routines. The Device Manager calls theseroutines when certain operating system traps are executed. The traps are calledwith register <code>A0</code> pointing to the parameter block. Some of these trapscan be called in one of two different modes: immediate and asynchronous. If bit9 of the trap word is set, the call is immediate, while if bit 10 is set, thecall is asynchronous. The device driver should be able to respond to every callby the Device Manager in at least some fashion, even if just to return. Thedevice driver routines, the traps that cause the Device Manager to call theroutines, and the various modes in which the calls can be made are as follows:</p><p><b>Routine Trap Modes</b></p><p><code>Open</code> <code>_Open</code>Immediate</p><p><code>Prime</code> <code>_Read</code>, <code>_Write</code> Immediate, Asynchronous</p><p><code>Control</code>    <code>_Control</code> Immediate, Asynchronous</p><p><code>Control</code>    <code>_KillIO</code> Immediate</p><p><code>Status</code> <code>_Status</code> Immediate, Asynchronous</p><p><code>Close</code> <code>_Close</code> Immediate</p><p><code>_Open</code>, <code>_Close</code>, and <code>_KillIO</code> are always immediate becauseof the way they are handled by the Device Manager. Do not make asynchronous<code>_Open</code>, <code>_Close</code>, or <code>_KillIO</code> calls, and do not specifythe <code>IMMED</code> bit for them explicitly. It is extremely rare that a driverwill support immediate <code>_Read</code> and <code>_Write</code> calls properly. Thesecalls should be used only when specifically allowed according to thedocumentation for a driver.</p><p>From the driver's point of view, <code>KillIO</code> is handled as a_<code>Control</code> call with a <code>csCode</code> = 1. However, this is afacade produced artificially by the Device Manager. Calling a driverwith <code>_Control</code> and <code>csCode</code> = 1 is <i>not</i> the same thing asa <code>KillIO</code> and none of the normal dequeueing action will take place.</p><p>Especially important:</p><p>Developers should <i>never</i> make a Device Manager call at interrupt time,including VBLs, Time Manager tasks, deferred tasks, and so on, unless the callis asynchronous and the underlying driver is capable of returning to the callerbefore the I/O completes. Deviations from this practice will result in severeinterrupt latency or even system hangs.</p><P><A HREF="#top">Back to top</A></P><a name="Section3"></a><h2>What the Glue Do</h2><p>High-level languages often come with libraries that provide an easy-to-useinterface ("glue") to the machine-level Device Manager traps. Many of thesecalls are documented in <i>Inside Macintosh</i>. These routines are furtherdivided into two groups. The first group is composed of "low-level" routines;these routines take an already complete parameter block passed to them, pointregister <code>A0</code> at it, and execute the proper trap with the correct mode.The second group is composed of "high-level" routines, which set up a parameterblock and required registers with data provided in the call parameters, thenexecute the Device Manager traps. For example, the <code>OpenDriver</code> callcreates a parameter block on the stack, completes the required fields, pointsregister <code>A0</code> to the block, and executes the <code>_Open</code> trap.</p><p>Following is a list of high-level routines and the trap glue they execute:</p><p><b>Routine    Trap</b></p><p><code>OpenDriver</code> <code>_Open</code></p><p><code>CloseDriver</code>    <code>_Close</code></p><p><code>FSRead</code>    <code>_Read</code></p><p><code>FSWrite</code>    <code>_Write</code></p><p><code>Control</code>    <code>_Control</code></p><p><code>Status</code>    <code>_Status</code></p><p><code>KillIO</code>    <code>_KillIO</code></p><P><A HREF="#top">Back to top</A></P><a name="Section4"></a><h2>Yes, We're Open</h2><p>The <code>Open</code> routine of a device driver is called as a result of an<code>_Open</code> trap being executed. What <code>_Open</code> does depends on whatmachine is running, but is fairly consistent across the machine models, withthe exception of NuBus(TM) slot drivers on a Macintosh with a Slot Manager. Thefollowing is a pseudo-code description followed by a narrative:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>IF call is NOT from _OpenDeskAcc AND filename does NOT begin with "." THEN    pass control to file systemELSE [    IF driver is for slot device THEN [    {explained in narrative below}        search unit table from 48 through UnitNtryCnt for match        IF NOT found THEN            call _GetNamedResource for driver name type 'DRVR'        IF NOT successful THEN            call _SGetDriver for driver        IF NOT successful THEN            return error        {found the driver}        search unit table from 48 through UnitNtryCnt for NIL DCE handle        IF NOT found THEN [            bump up UnitNtryCnt by 4            IF maximum UnitNtryCnt exceeded THEN                return error ]        {found a slot}        install driver ]    ELSE [        search unit table from 0 through UnitNtryCnt for match        IF NOT found THEN            call _GetNamedResource for driver name type 'DRVR'        IF NOT successful THEN            return error        {found driver}        get resource ID of 'DRVR' resource        IF unit number not already in use THEN            install driver ]    {otherwise, leave old driver there}    IF driver NOT already open THEN [        move Drvr fields into corresponding DCE fields        IF driver is RAM-based THEN            set RAM-based flag in dCtlFlags field of DCE        IF driver is for slot device THEN            call _SFindDevBase and put result into DCE ]    IF driver needsLock THEN        lock driver and DCE    IF driver NOT already open OR called from _OpenDeskAcc THEN        call Open routine of driver    IF any error resulted THEN [        clear ioRefnum field        clear driverOpen bit of dCtlFlags        unlock driver and DCE ]    ELSE        unlock driver and DCE if allowed    set ioResult field to result ]</pre>	</TD></TR></TABLE></CENTER><p>First, <code>_Open</code> checks to see if the call is from <code>_OpenDeskAcc</code>.This check is made by looking for a special value in the <code>ioFileType</code>field of the parameter block, which <code>_OpenDeskAcc</code> sets. The filenameshould also begin with a null byte ($00), but this is not checked. If the callis not from <code>_OpenDeskAcc</code>, <code>_Open</code> checks to see if the filenamein the parameter block begins with a period (.). If the filename does not beginwith a period, control is passed to the file system. Otherwise, if the machineis a Macintosh with the Slot Manager, then a check is made to see if the driveris for a slot device. If bit 9 of the <code>_Open</code> trap word is set and bit 0of the <code>ioFlags</code> word is set or the <code>ioSlot</code> field of theparameter block is not 0, then the driver is assumed to be for a slot device.</p><p>If the driver is for a slot device, the unit table is searched, starting atunit number 48 and ending at <code>UnitNtryCnt</code>. If the <code>dCtlSlot</code>,<code>dCtlSlotID</code>, and <code>dCtlExtDev</code> fields of none of the DCEs of theunit numbers match the fields of the parameter block, then <code>_GetNamedResource</code> is called, using the name of the driver and type <code>'DRVR'</code>. If that fails, then <code>_SGetDriver</code> is called to load the driver from the card's ROM. If that attempt fails, an error is reported. In the case where one of the attempts succeeds, the unit table is searched after loading the new driver, starting at unit number 48 and ending at<code>UnitNtryCnt</code>, for an unused (<code>NIL</code>) slot. If none are found, thevalue of <code>UnitNtryCnt</code> is incremented by four. If the value exceeds 128,then an error is reported. Otherwise driver uses the newly created slot.</p><p>If the driver is not for a slot device or has been determined to be a deskaccessory, the unit table is searched, starting at unit number 0 and ending at<code>UnitNtryCnt</code>. If none of the names for the installed drivers in thetable matches the filename of the parameter block, then <code>_GetNamedResource</code> is called, using the name of the driver and type <code>'DRVR'</code>. If that attempt fails, an error is reported. If the attempt succeeds, the ID of the resource is assumed to be the unit number of the driver and is mapped into the equivalent <code>refnum</code>. If the slot for that <code>refnum</code> is already occupied, then the driver that is already thereremains there.</p><p>Once the device driver is installed, or it has been determined that a driveralready occupies the slot in the unit table, the driver is checked to see if ithas already been opened. If it has not, the driver is checked to see if it isRAM-based or and the <code>dCtlFlags</code> field of the driver's DCE is setaccordingly, along with being combined with the rest of the <code>DrvrFlags</code>field of the driver header. The <code>DrvrDelay</code>, <code>DrvrEMask</code>, and<code>DrvrMenu</code> fields from the driver header are also moved into thecorresponding fields of the DCE. If the driver is for a slot device,<code>_SFindDevBase</code> is called for the slot and ID of the driver's device andthe result is put into the DCE.</p><p>Once the DCE fields have been completed, or it is determined that the driver isalready open, the driver and DCE are locked if needed. The permissions are thenchecked, returning an error if incorrect, and the <code>Open</code> routine of thedriver is called if the driver is not already open or if the call was from<code>_OpenDeskAcc</code>. If the driver returns any error, then the<code>ioResult</code> field of the parameter block and the <code>driverOpen</code> bitof the <code>dCtlFlags</code> field are cleared, and the driver and its DCE areunlocked. If the driver returns no errors, then it and the DCE are unlocked, ifallowed. In either case, the result from the driver's <code>Open</code> routine isput in the <code>ioResult</code> field of the parameter block.</p><P><A HREF="#top">Back to top</A></P><a name="Section5"></a><h2>That's Great, But What Are You Driving At?</h2><p>So, of what practical value is all this? If you are trying to provide a nonslotdriver that can be installed at INIT time and used later by other software, thebest method for finding a unit number in the unit table is the way the<code>_Open</code> trap on the Macintosh II family finds a unit number in the unittable for slot device drivers. Unfortunately, you may want to run on otherMacintosh models, and it would be a bit kludgy to fake being a slot devicedriver, so you cannot just call <code>_Open</code> and pretend to be a slot devicedriver. Additionally, it is likely that you may wish that the driver's<code>Open</code> routine not be called until it is actually opened with the<code>_Open</code> trap by software that really wants to use it; therefore, yourINIT code must mimic the pertinent code of the <code>_Open</code> trap.</p><p>The first action should be to call <code>_GetNamedResource</code> with the name ofthe driver and its resource type (typically <code>'DRVR'</code>, although it is notrequired, since you are loading it). The resource that contains your drivermust have the system heap bit set in its resource attributes, so it is loadedinto the system heap where it can continue to exist, long after the INIT hasgone away. Note that if for some incredible reason, your driver is greater than16K, you might want to include a <code>'sysz'</code> resource to increase theavailable space in the system heap.</p><p>Next, you must call <code>_DetachResource</code> with the handle to your resource,so it is not removed when your INIT file is closed. Now you are ready to find aslot in the unit table for your driver. First check if unit numbers 48 andhigher are even available by checking <code>UnitNtryCnt</code>.</p><p>If <code>UnitNtryCnt</code> is 48, you have a bit of a problem in that there are noempty slots available in the unit table. You can rectify this, however, byresizing the unit table. DTS recommends you accomplish that task by creating anew unit table that is larger than the old one.</p><p>To resize the unit table, first create a new, nonrelocatable block in thesystem heap that is the new size you want, and clear it to zeros. The followingassembly-language code fragment gives an example:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>    MOVE.W     D1,D0                    ;D1 = requested # slots    MULU.W     #4,D0                    ;turn it into size    _NewPtr,SYS,CLEAR                   ;create clear block in system heap    BNE        Error                    ;check for errors!</pre>	</TD></TR></TABLE></CENTER><p>Next, you must copy the contents of the old unit table into the new unit table,point <code>UTableBase</code> to the new unit table, and adjust the value of<code>UnitNtryCnt</code>. While doing all of that, it would be most inconvenient ifan interrupt occurred; therefore, you must turn off interrupts during theprocess. The following assembly-language code fragment, which would follow theprevious code, gives an example:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>    MOVE       SR,-(SP)                 ;save old interrupt status    OR           #0700,SR               ;disable all maskable interrupts    MOVEA.L    A0,A1                    ;A0 (address new unit table) -&gt; A1    MOVEA.L    UTableBase,A0            ;old unit table -&gt; A0    MOVE.W     UnitNtryCnt,D0           ;number of entries -&gt; D0    MULU.W     #4,D0                    ;size of old table -&gt; D0    _BlockMove                          ;copy old table to new table    _DisposPtr                          ;get rid of old table    MOVE.L     A1,UTableBase            ;make us new unit table    MOVE.W     D1,UnitNtryCnt           ;update number of entries    MOVE       (SP)+,SR                 ;restore old interrupt status</pre>	</TD></TR></TABLE></CENTER><p>DTS suggests that if <code>UnitNtryCnt</code> was originally 48, you increase it to64, adjusting the table size as shown.</p><p>At this point, with the unit table resized or already at a size to hold morethan 48 unit numbers, it may be searched for an empty slot, starting at unitnumber 48 and ending at <code>UnitNtryCnt</code>. If, in the case where the unittable already held more than 48 unit numbers, no empty slot was found, then theunit table might be able to be expanded as was described previously. This time,however, the process can be a bit more complicated.</p><p>It could very well be that the unit table itself is already larger than what<code>UnitNtryCnt</code> would indicate, either because the machine is a MacintoshII-class machine or somebody else has changed things ahead of your INIT. Thebest action to take would be to call <code>_GetPtrSize</code> on the unit table,divide the result by four, rounding down, and compare that number to <code>UnitNtryCnt</code>. If <code>UnitNtryCnt</code> is lower than that result, you can increment <code>UnitNtryCnt</code> by any amount that keeps it less than or equal to the maximum allowable size that the unit table can handle. Four is a good number, because it reduces the need for someone else to do the same check later on without also making the search for a given driver. Once <code>UnitNtryCnt</code>has been incremented, you know you have an empty slot waiting.</p><p>If <code>UnitNtryCnt</code> is already equal to the size of the unit table dividedby four, you should expand the unit table as described previously, choosing asize around 16 or 32 bytes greater than the old size. Remember always to checkthe result of the <code>_NewPtr</code> call; it would be catastrophic to copy theold unit table into the low-memory global area.</p><p>Once you have found a slot for the driver in the unit table, call<code>_DriverInstall</code> with the corresponding <code>refnum</code> and pointer tothe driver. This call creates a DCE for the driver and sets up the correct<code>refnum</code> in the DCE. Next, move the handle to the driver into the<code>dCtlDriver</code> field of the DCE, then move the <code>DrvrFlags</code>,<code>DrvrDelay</code>, <code>DrvrEMask</code>, and <code>DrvrMenu</code> fields of thedriver header into the <code>dCtlFlags</code>, <code>dCtlDelay</code>, <code>dCtlEMask</code>, and <code>dCtlMenu</code> fields of the DCE. Finally, set the <code>dRamBased</code> bit in the <code>dCtlFlags</code> field of the DCE. That's all there is to it.</p><P><A HREF="#top">Back to top</A></P><a name="Section6"></a><h2>Immediate Asynchronicity</h2><p>The <code>_Read</code>, <code>_Write</code>, <code>_Status</code>, and <code>_Control</code>traps differ from <code>_Open</code>, <code>_Close</code>, and <code>_KillIO </code>in thata request can be "queued," (that is, inserted into a waiting list of requestsfor that device driver). This queue allows requests to be saved for processinglater if the driver is busy handling another request. As the device driverfinishes servicing each request, the next request in line is passed to thedriver until no more requests remain. Calls made to <code>_Open</code>,<code>_Close</code>, and <code>_KillIO</code>, however, must be handled immediately, sothey are never queued. This behavior is not a problem with <code>Open</code>requests, since there are usually no requests already queued. What happens with<code>Close</code> requests is described later in this Note.</p><p>As noted earlier, these traps can be optionally executed immediately,asynchronously, or both. Normally, when a trap is executed, it means thatcontrol should not return to the caller until the request has been completed.That is, the requested task completely finishes doing whatever was asked andneeds to do no further action. For example, assume a <code>_Read</code> trap iscalled for a serial driver. If called normally, control would not return to thecaller until a character was received.</p><p>An asynchronously executed trap should return to the caller as soon aspossible, even if the request cannot be completed before returning. In theprevious example, if <code>_Read</code> were executed asynchronously, it wouldreturn control as soon as the request was noted rather than waiting until acharacter was received. When a character finally was received, the<code>ioResult</code> of the parameter block would reflect that fact, and any<code>ioCompletion</code> routine would be executed.</p><p>When a trap is executed immediately, it means that the request is not queued,but rather sent immediately to the driver, whether or not it is busy handlinganother request. Immediate requests are typically not I/O-related in nature. Ifthe example call were to have been executed immediately, it is not clear whatthe proper response of the driver should be; should it wait until a characteris available, thereby accomplishing the task but violating the concept of"immediateness," or if no character is available, should it just returnimmediately without ever completing the task? A better use for immediate callsis for checking the status of a driver, using the <code>_Status</code> trap. Notethat the <code>_KillIO</code> trap, used for aborting all processes the drivermight be involved in, doesn't need the immediate bit set. <code>_KillIO</code> isalways executed immediately.</p><p>Note that <i>Inside Macintosh</i>states that it is the caller's responsibilityto know if a driver can handle a particular call being made immediately.</p><P><A HREF="#top">Back to top</A></P><a name="Section7"></a><h2>You Can Feel It When You Drive</h2><p>When <code>_Read</code> or <code>_Write</code> is executed, the Device Manager checksthe <code>refnum</code>. If it is not negative, it is assumed that it is a filereference number and control passes to the file system. When <code>_Status</code>is executed, the Device Manager first checks if the <code>csCode</code> is one (1).If it is, then the DCE handle is calculated and returned in the <code>csParam</code> field and control is returned to the caller.</p><p>Beyond this special handling, the Device Manager processes <code>_Read</code>,<code>_Write</code>, <code>_Status</code> and <code>_Control</code> traps in much the sameway. First, however, it checks if the call was a <code>_Read</code> or <code>_Write</code>. If it was either of these, then the <code>ioActCount</code> field of the parameter block is cleared to indicate that no bytes have been read or written yet.</p><p>Next, the <code>ioResult</code> field of the parameter block is set to one (1) toindicate the call is "in progress." The <code>ioTrap</code> field is filled withthe trap word that was executed and the <code>qType</code> is set to <code>ioQType</code>, <code>2</code>. The Device Manager checks to see if the driver is open and if it is capable of handling the kind of call made. If either of these tests fail, it returns an error. Otherwise, it checks the "immediate" bit (bit 9) of the trap word, and if set, it goes straight to the code that calls the appropriate driver routine. If the call was not immediate, the Device Manager checks the "asynchronous" bit (bit 10) of the trap word, and if set, it passes control via a <code>BRA</code> to the code that queues the request and calls the appropriate driver routine. If this bit is clear, the <code>ioCompletion</code>field of the parameter block is cleared and the same code is called via a <code>BSR</code>.On returning from that code, the Device Manager executes a loop (the infamous <code>_SyncWait</code>) that tests the <code>ioResult</code> field and exits when it is less than or equal to 0.</p><p>To further clarify the difference between asynchronous and synchronous calls:by doing a <code>BSR</code> call in the synchronous case, the Device Manager leavesits return address on the stack, thus regaining control after the driverroutine it called returns. This allows the Device Manager to keep control,waiting until the call has completed (the <code>ioResult</code> field becomesnonpositive), before returning control to the code that executed the<code>_Read</code>, <code>_Write</code>, <code>_Status</code>, or <code>_Control</code> trap.In the asynchronous case, no return address is left on the stack; therefore,control returns to the code that executed the trap when the driver routinereturns. It is very important to recognize that the Device Manager is doing thework in handling the difference between asynchronous and synchronous calls. Foralmost every conceivable case, the driver routine does not have to worry aboutthat difference.</p><p>The Device Manager gives control to the driver routine during an asynchronousor synchronous trap (not an immediate trap) with the following process. Itsaves the interrupt level, disables interrupts, and adds the request to thehead of the driver's queue. Next, it checks the <code>drvrActive</code> bit of thedriver's <code>dCtlFlags</code> field of the device control entry. If this bit isset, the driver is busy handling another request. In this case, the DeviceManager restores the interrupt level, exits the code, and returns control toeither the code that waits for the <code>ioResult</code> field to become less thanor equal to 0 (the synchronous case) or the code that executed the trap (theasynchronous case). If the <code>drvrActive</code> bit is not set, the DeviceManager sets it to indicate the driver is busy and the interrupt level isrestored.</p><p>This is now the point at which an immediate call would have entered as well aswhere the code continues for synchronous and asynchronous calls. Notice hownone of the processing described in the previous paragraph was done in the caseof an immediate call; the request was not added to the driver queue and nocheck was made for whether the driver was busy.</p><p>At this point, if the trap is <code>_Read</code> or <code>_Write</code>, the DeviceManager checks the <code>ioByteCount</code> field; if it is 0, it is assumed thatthe call is complete and control is passed to <code>IODone</code>, which is described later. In addition, it adjusts the <code>dCtlPosition</code> field to reflect the <code>ioPosMode</code> and <code>ioPosOffset</code> values in the parameter block.</p><p>At this point, the Device Manager checks to make sure the driver is loaded bydoing a <code>_LoadResource</code> if it finds the driver has been purged. It thenlocks the driver and calls the correct routine within the driver by using theoffsets given in the driver header.</p><P><A HREF="#top">Back to top</A></P><a name="Section8"></a><h2>Sorry, We're Closed</h2><p>When the <code>_Close</code> trap is called, the first thing the Device Managerdoes is check the <code>refnum</code>. If it is not negative, it passes control tothe file system. Otherwise, it searches the unit table and checks if the driveris open and exists if it is not. If the driver is open, the Device Managerwaits in a loop until the <code>drvrActive</code> bit of the <code>dCtlFlags</code>field is clear, indicating the driver is no longer busy. Once the driver is notbusy, the Device Manager calls the driver's <code>Close</code> routine. If no erroris returned, the <code>dOpened</code> flag is cleared. If the driver is for a slotdevice, then the <code>refnum</code> in the Slot Resource Table is cleared with acall to <code>_SUpdateSRT</code>.</p><p>Note that the device driver is not removed from the unit table, nor is thedriver or its device control entry disposed. To remove a driver and dispose ofits device control entry, you must call <code>_DrvrRemove</code>. The driver itselfis usually removed by getting purged (it must be purgeable).</p><P><A HREF="#top">Back to top</A></P><a name="Section9"></a><h2>Get Outta the Way, Ya Sunday Driver</h2><p>The driver's <code>Open</code>, <code>Prime</code>, <code>Status</code>, <code>Control</code>,and <code>Close</code> routines are called under different circumstances and needto respond correctly to these situations.</p><p>The routines can be broken into two groups:</p><p><code>Open</code> and <code>Close</code>    These routines are called only one way and must becompleted before returning.</p><p><code>Prime</code>, <code>Status</code>, and <code>Control</code>    These routines can be calledin different ways and might be able to defer completion of a request.</p><p>Handling <code>Open</code> and <code>Close</code> is simple; you must complete all theprocessing that is to be done before returning, and you do so by simplyreturning with a result code in register <code>D0</code>.</p><p>In the case of <code>Prime</code>, <code>Status</code>, and <code>Control</code>, thingsget a bit more complicated. If called with the immediate bit of the trap wordset, the routine must complete the request and simply return with register<code>D0</code> containing the result code. If not called with this bit of the trapword set, the routine should, if possible, complete the request and return viaa <code>JMP</code> to <code>JIODone</code>. If the request cannot be completedimmediately, the routine should simply return with register <code>D0</code> set to<code>noErr</code>. Since the request cannot be completed immediately, it isimplied that some mechanism is used to indicate deferred completion of therequest. This might be through an interrupt being generated that itself signalsthe completion of the request, or it might be an interrupt that allows aperiodic function to poll something that would indicate the completion of therequest. Whatever the case, once the request has been completed, the coderesponsible for completing it should perform a <code>JMP</code> to <code>JIODone</code>with register <code>A1</code> pointing to the device control entry for the driverand register <code>D0</code> containing the result code.</p><P><A HREF="#top">Back to top</A></P><a name="Section10"></a><h2>What the Heck Does JIODone Do, Anyway?</h2><p><code>JIODone</code> is nothing more than a utility provided by the Device Manager foruse by device drivers when they wish to indicate the completion of a queuedrequest. Since it is only used for queued requests, it is inappropriate to use<code>JIODone</code> in completing <code>Open</code>, <code>Close</code> and "immediate"<code>Prime</code>, <code>Status</code>, and <code>Control</code> requests.</p><p>What <code>JIODone</code> does is first look at the queue header of the devicecontrol entry. It assumes that the queue header points to the request that isbeing completed. If it is <code>NIL</code>, it exits immediately after unlockingthe driver, if the driver can be unlocked. Otherwise, the interrupt level issaved, interrupts are disabled, and the <code>drvrActive</code> flag is cleared, toindicate the driver is no longer busy. Then the driver is unlocked, if allowed,the request is removed from the driver's queue, and the interrupt level isrestored. Next, register D0 (the result code) is stuffed into the <code>ioResult</code> field of the request, then if a completion routine was specified (<code>ioCompletion</code> is non-<code>NIL</code>), it gets called. At this point, interrupts are disabled once again, and if any more requests are pending for the driver, the driver is called again at the point where the Device Manager checks to see if the driver is busy. If no more requests are pending,<code>JIODone</code> restores the interrupt level again and returns.</p><p>If you call <code>JIODone</code> when there is not an appropriate I/O requestpending in the queue, very strange and mysterious things occur. When debuggingdifficult device driver bugs, be absolutely certain that <code>JIODone</code> isnot being called inappropriately.</p><P><A HREF="#top">Back to top</A></P><a name="Section11"></a><h2>Driving the Point Home</h2><p>In summary, the following concepts are important to recognize:</p><p>1.    Since the <code>Open</code> routine of a driver is only called once from the<code>_Open</code> trap, and when it is called, the parameter block is not attachedto a queue, the <code>Open</code> routine of the driver should only perform actionssuch as validating opening the driver and doing data initialization. Do notattempt to use the <code>Open</code> routine in the capacity of something like a<code>_Control</code> call.</p><p>2.    Likewise, since the <code>Close</code> routine of a driver is called only onceby the <code>_Close</code> trap, the <code>Close</code> routine should only performactions that undo the actions of the <code>Open</code> routine, such asdeallocation of data structures, and so on.</p><p>3.    <code>_Read</code>, <code>_Write</code>, <code>_Status</code> and <code>_Control</code> allact very similar with just a few minor differences. During <code>_Read</code> and<code>_Write</code> calls, the <code>ioActCount</code> field automatically gets clearedand the <code>dCtlPosition</code> field gets updated in accordance with <code>ioPosOffset</code> and <code>ioPosMode</code>. A <code>_Status</code> call with <code>csCode = 1 </code>automatically results in the Device Manager returning the device control entry handle. Other than this difference and the fact that the <code>_Read</code> and <code>_Write</code> traps call the driver's <code>Prime</code> routine, the <code>_Status</code> trap calls the <code>Status</code> routine, and the<code>_Control</code> trap calls the <code>Control</code> routine, these traps behave the same.</p><p>4.    Because the Device Manager takes care of the different processingrequirements of asynchronous and synchronous calls, the <code>Prime</code>,<code>Status</code>, and <code>Control</code> routines of a driver can ignore thedifference and handle both kinds of calls in the same way. That is, when thecall is completed, jump through <code>JIODone</code>. If the call cannot becompleted immediately, just return.</p><p>5.    Because immediate calls to the <code>Prime</code>, <code>Status</code>, and<code>Control</code> routines of a driver do not have the parameter block added tothe head of the queue, you should not exit to <code>JIODone</code> when the call iscompleted, but rather just return.</p><P><A HREF="#top">Back to top</A></P><a name="Section12"></a><h2>Crucial References for Writing a Macintosh SCSI Disk Driver</h2><p>The following is a partial list of specific references that we've found handyfor writing SCSI related drivers. Some of the information enclosed is SCSIspecific. Some relates to device drivers on the Macintosh. Some relates toother system level programming usually found necessary when writing systemlevel software. Thanks go to Craig Prouse, formerly of DTS, who compiled theoriginal list on which this list is based.</p><p><b>SCSI Development Package</b></p><p>This provides a package of written documentation from DTS including full samplecode for an existing driver. Version 1.0 was in assembly language and supportedonly the old (now unsupported) partition map format. Version 2.0 is rewritten mostly in C,and is available in the snippets folder on the <i>Developer CD Series.</i></p><p><b>Standards</b></p><p>These official standards, while difficult reading, are indispensable fordetermining proper operation of low-level SCSI Manager code. Don't go anyfurther without them.</p><p>SCSI-1:    ANSI X3.131-1986</p><p>CCS:    X3T9.2/85-52, 1986 (Revision 4.B)</p><p>SCSI-2:    ANSW X3.131-1992 (Revision 10h)</p><p>SCSI-3:    ANSI X3.131-199x</p><p>Available from:</p><p>SCSI Bulletin Board System: (719) 574-0424 or (316) 636-8700<br>anonymous ftp from rex.cs.tulane.edu</p><p>SCSI-1 and CCS:</p><p>American National Standards Institute</p><p>1430 Broadway<br>New York, NY 10018<br>SCSI-2 and most other standards:<br>Global Engineering Documents<br>2805 McGraw<br>Irvine, CA 92714<br>(800) 854-7179 or (714) 261-1455</p><p><b>Inside Macintosh, Volume II</b></p> <p>Chapter 6: The Device Manager</p><p>The developer should be thoroughly familiar with all aspects of this chapterand should begin by writing a simple device driver shell that can be installedby a system extension. Once this is accomplished the desired specific featuresmay be implemented.</p><p>Chapter 11: The Vertical Retrace Manager</p><p>Drivers supporting removable media as a rule use a VBL task to occasionallypoll the device to check for a disk insertion. If a disk insertion is sensed,then the driver calls PostEvent to notify the Finder or Standard File. There ismore, and better information about VBL tasks as well. The best example of howto write a VBL is in MultiFinder Technote #180. There is supplementalinformation on VBLs is in the Time Manager chapter of <i>Inside Macintosh</i>Volume VI, and there are virtual memory considerations for VBLs in Technote#285.</p><p><b>Inside Macintosh, Volume IV</b></p><p>Chapter 19: The File Manager</p><p>Interestingly enough, one does not need a great deal of familiarity with HFS inorder to write a disk driver. Nevertheless, it can't hurt to be familiar withthis chapter. There is one poorly documented fact that bears mentioning here:HFS always calls the disk driver with a drive number in the vRefNum field ofthe parameter block. It does not pass an actual vRefNum to the driver.</p><p>Chapter 20: The Device Manager</p><p>With the Mac Plus and later, the unit table expanded to accommodate SCSIdrivers. There are reserved slots in the unit table for SCSI devices and theseunit numbers have a simple correspondence to their reserved SCSI IDs. This isdocumented only very briefly. Blink and you'll miss it. The driver for SCSI IDn must be installed at unit number (32+n). Do not install it anywhere else orother drivers may not recognize your existence and this can lead to conflicts.</p><p>Chapter 31: SCSI Manager</p><p>Most of the basic information here is still valid, but there are a couple ofcaveats. First, the SCSIStat call returns hardware information about the 5380SCSI chip. Newer Macintoshes may not use the 5380 and SCSIStat may thereforenot return the type of information that's documented here. See the "Fear NoSCSI" tech note for more details. Also, the Device Partition Map documented onpage 292 is no longer supported. Refer to <i>Inside Macintosh</i> Volume V forlater information. The old format may be supported optionally but is notrequired. The new partition map format is required.</p><p><b>Inside Macintosh, Volume V</b></p><p>Chapter 31: SCSI Manager</p><p><i>Inside Macintosh</i> Volume V defines the new partition map structure that isrequired of all new drivers. It also gives good documentation on the polled vs.the blind SCSI transfer modes.</p><p><b>Inside Macintosh, Volume VI</b></p><p>Chapter 23: Time Manager</p><p>This chapter provides just a bit more documentation on VBLs and perhaps offers a few alternatives.</p><p>Chapter 28: Memory Management</p><p>This is the chapter that finally explains A5 and virtual memory. It isextremely important for SCSI driver developers to understand at least howvirtual memory works, and for removable drives, also how to work with A5.</p><p><b>Guide to the Macintosh Family Hardware</b></p><p>Chapter 9: The SCSI Manager</p><p>This chapter gives the definitive description of polled vs. blind transfermodes for those who are curious and really want to understand what's going onin hardware and why blink mode is so much faster.</p><p><b>Macintosh Technical Notes</b></p><p>#36</p><p><u><A HREF = "dv_05.html">Drive Queue Elements</a></u></p><p>This Technote contains an explanation of the drive queue and example code forhow to add a drive to the queue. For drives containing multiple partitions,it's mostly a matter of searching beyond the first valid HFS partition in thepartition map and adding more than one drive to the drive queue. Where it getsdifficult is when a single driver then has to provide control for all of thosemounted volumes.</p><p>#71</p><p><u><A HREF = "dv_06.html">Finding Drivers in the Unit Table</a></u></p><p>The key to avoiding conflicts between different drivers installed in the samesystem is giving drivers the ability to sense the presence of other driverswhen installing. For example, if a driver is stored on a removable cartridgeand loads at system boot time, then the driver in the Extensions folder wouldnot be necessary. That driver should be able to see that there is already adriver installed in its unit table slot and it should not install over theexisting driver. Other similar situations are possible. Technote #71 givessome ideas about how drivers can become aware of other drivers by searching theunit table. Use this information in conjunction with the information in Chapter20 of <i>Inside Macintosh</i> Volume IV.</p><p>#108</p><p><u><A HREF = "dv_02.html">_AddDrive, _DrvrInstall, and _DrvrRemove</a></u></p><p>The most reliable way to install a driver, particularly a SCSI driver that isnot stored as a resource and the unit number for which must be determined atruntime, is to do it manually. Rather than depending on OpenDriver, load theresource into the system heap explicitly. Call _DrvrInstall to allocate itsDevice Control Entry and fill out the DCE by hand, setting up all the pointersyourself. It's not as difficult as it sounds, it's reliable, and DTS providesfull sample code showing how to do it. See the SCSI Development Package.</p><p>#180</p><p><u><A HREF = "../tb/tb_35.html">MultiFinder Miscellanea</a></u><br>Somehow, the best example of how to write a VBL is hidden in a MultiFinder Tech Note.</p><p>#187</p><p><u><A HREF = "../fl/fl_24.html">Don't Look at ioPosOffset</a></u></p><p>This is a very short and concise Technote that helps explain what to do in onevery small but very confusing part of your device driver, where read and writecalls are converted into logical block addresses for SCSI. Don't miss this one,and see the example code as well.</p><p>#285</p><p><u><A HREF = "../me/me_09.html">Coping With VM and Memory Mappings</a></u></p><p>Because virtual memory depends on the SCSI bus to perform paging, SCSI driverwriters must understand how virtual memory and the SCSI manager interact.Virtual memory also affects how VBLs are run, which may affect everything fromchecking for disk insertions, to displaying progress indicators during diskformatting.</p><p><u><A HREF = "dv_24.html">M.HD.Fear No SCSI</a></u></p><p>This excellent tech note by Colleen Delgadillo includes answers to frequentlyasked SCSI questions; a sample of how to call the SCSI manager; informationabout differences between the Quadra class machines and their new SCSI chip;and other valuable new information about the SCSI manager. As Colleen says,"the target controls the bus."</p><P><A HREF="#top">Back to top</A></P><a name="references"></a><h2>References</h2><P>   <i>Inside Macintosh</i>, Volumes II, IV, and V, The Device Manager</p><P>   <i>Inside Macintosh</i>, Volume I, The Desk Manager</p><P>   Technical Note #71, <u><A HREF = "dv_06.html">Finding Drivers in the Unit Table</a></u></p><P>   Technical Note #108, <u><A HREF = "dv_02.html">_AddDrive, _DrvrInstall, and _DrvrRemove</a></u></p><p>NuBus is a trademark of Texas Instruments.</p><P><A HREF="#top">Back to top</A></P>         <a name="downloads"></a>         <H2>Downloadables</H2>                  <TABLE BORDER=0 CELLPADDING=3 WIDTH="100%">            <TR>               <td width=50 align=left>                  <P ALIGN=center>                                    <img src="images/acrobatsmall.gif" width=22 height=23 align=middle alt="Acrobat gif"></P>               </TD>               <td align="left">                  <P>Acrobat version of this Note (164K)</P>               </TD>               <td width=60 align=left>                  <P><A HREF="pdf/dv_23.pdf">Download</A></P>               </TD>            </TR>         </TABLE>         <BR><P><A HREF="#top">Back to top</A></P></TD></TR></TABLE></CENTER><!-- end_content --><!-- begin_footer_information -->	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/technotes/dv/dv_23.html%3Fid%3DDTS10002412-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/technotes/dv/dv_23.html%3Fid%3DDTS10002412-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/technotes/dv/dv_23.html%3Fid%3DDTS10002412-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>
<!--#include virtual="/includes/footer"--><!-- end_footer_information --></BODY></HTML>