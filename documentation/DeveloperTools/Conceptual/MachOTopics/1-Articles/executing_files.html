<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>Mach-O Programming Topics: Executing Mach-O Files</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Executing Mach-O Files"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP40001829" title="Executing Mach-O Files"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../index.html#//apple_ref/doc/uid/TP30000440-TP30000436" target="_top">Tools</a> &gt; <a href="../../../CompilersDebuggers-date.html#//apple_ref/doc/uid/TP30000440-TP30000436-TP30001025" target="_top">Compiling &amp; Debugging</a> &gt; <a href="../index.html" target="_top">Mach-O Programming Topics</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="building_files.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="loading_code.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>
        
        
        <a name="//apple_ref/doc/uid/TP40001829-SW1" title="Executing Mach-O Files"></a><hr /><H1>Executing Mach-O Files</H1><p>To perform their objectives, programs must execute processes and link to dynamic shared libraries. To work with other libraries or modules, your application must define references to symbols in those modules; those references are resolved at runtime. At runtime the symbol names of all the modules your application uses live in a shared namespace, similar to a directory. To allow for future enhancements to applications as well as the libraries they use, application and library developers must ensure the names they choose for their functions and data do not conflict with the names used in other modules.</p><p>The two-level namespace feature of Mac OS X v10.1 and later adds the module name as part of the symbol name of the symbols defined within it. This approach ensures a module’s symbol names don’t conflict with the names used in other modules. To perform special tasks or to provide an enhanced user experience, your application may need to launch other applications or create processes to run command-line tools. To maintain a high degree of interoperability and provide a consistent user experience, your applications should use specific system functions and frameworks to execute processes and launch applications.</p><p>This article provides an overview of the Mac OS X dynamic loading process. The process of loading and linking a program in Mac OS X mainly involves two entities: the Mac OS X kernel and the dynamic linker<a name="//apple_ref/doc/uid/TP40001829-DontLinkElementID_20"></a><a name="//apple_ref/doc/uid/TP40001829-DontLinkElementID_21"></a>. When you execute a program, the kernel creates a process for the program, and loads the program and the dynamic linker shared library, usually <code>/usr/lib/dyld</code>, in the program’s address space. The kernel then executes code in the dynamic linker that loads the libraries the program references. This article also describes the visibility symbols in a module get depending on how they are defined and the process of resolving symbol references at runtime.</p>
<!-- This template is being used for both PDF and HTML. -->

    
    <!-- TopicBook.pm uses this template for its miniTOCs, but needs a different title. -->
    <h4>Contents:</h4>
    
    
    <p class="blockquote">
    
        
			
			
				<a href="executing_files.html#//apple_ref/doc/uid/TP40001829-98172-TPXREF108">Launching an Application</a>
				
			<br/>
			
        
			
			
				<a href="executing_files.html#//apple_ref/doc/uid/TP40001829-96913-TPXREF103">Forking and Executing the Process</a>
				
			<br/>
			
        
			
			
				<a href="executing_files.html#//apple_ref/doc/uid/TP40001829-97021-TPXREF121">Finding Imported Symbols</a>
				
			<br/>
			
        
			
			
				<a href="executing_files.html#//apple_ref/doc/uid/TP40001829-98432-TPXREF120">Scope and Treatment of Symbol Definitions</a>
				
			<br/>
			
        

    </p><br/>

<a name="//apple_ref/doc/uid/TP40001829-98172" title="Launching an Application"></a><a name="//apple_ref/doc/uid/TP40001829-98172-TPXREF108" title="Launching an Application"></a><h2>Launching an Application</h2><p>When you launch an application from the Finder or the Dock, or when you run a program in a shell, the system ultimately calls two functions on your behalf, <code><!--a-->fork<!--/a--></code><a name="//apple_ref/doc/uid/TP40001829-DontLinkElementID_22"></a> and <code><!--a-->execve<!--/a--></code><a name="//apple_ref/doc/uid/TP40001829-DontLinkElementID_23"></a>. The <code>fork</code> function creates a process; the <code>execve</code> function loads and executes the program. There are several variant exec functions, such as <code><!--a-->execl<!--/a--></code>, <code><!--a-->execv<!--/a--></code>, and <code><!--a-->exect<!--/a--></code>, each providing a slightly different way of passing arguments and environment variables to the program. In Mac OS X, each of these other exec routines eventually calls the kernel routine <code><!--a-->execve<!--/a--></code>.</p><p>When writing a Mac OS X application, you should use the Launch Services framework to launch other applications. Launch Services understands application packages, and you can use it to open both applications and documents. The Finder and the Dock use Launch Services to maintain the database of mappings from document types to the applications that can open them. Cocoa<a name="//apple_ref/doc/uid/TP40001829-DontLinkElementID_24"></a> applications can use the class <code>NSWorkspace</code> to launch applications and documents; <code>NSWorkspace</code> itself uses Launch Services. Launch Services ultimately calls <code><!--a-->fork<!--/a--></code> and <code><!--a-->execve<!--/a--></code> to do the actual work of creating and executing the new process. For more information on Launch Services, see <em><a href="../../../../Carbon/Conceptual/LaunchServicesConcepts/index.html#//apple_ref/doc/uid/TP30000999" target="_top">Launch Services Programming Guide</a></em>.</p><a name="//apple_ref/doc/uid/TP40001829-96913" title="Forking and Executing the Process"></a><a name="//apple_ref/doc/uid/TP40001829-96913-TPXREF103" title="Forking and Executing the Process"></a><h2>Forking and Executing the Process</h2><p>To create a process using BSD system calls, your process must call the <code><!--a-->fork<!--/a--></code> system call. The <code><!--a-->fork<!--/a--></code> call creates a logical copy of your process, then returns the ID of the new process to your process. Both the original process and the new process continue executing from the call to <code>fork</code>; the only difference is that <code>fork</code> returns the ID of the new process to the original process and zero to the new process. (The <code><!--a-->fork<!--/a--></code> function returns <code>-1</code> to the original process and sets <code>errno</code><a name="//apple_ref/doc/uid/TP40001829-DontLinkElementID_25"></a> to a specific error value if the new process could not be created.)</p><p>To run a different executable, your process must call the <code><!--a-->execve<!--/a--></code> system call with a pathname specifying the location of the alternate executable. The <code><!--a-->execve<!--/a--></code> call replaces the program currently in memory with a different executable file.</p><p>A Mach-O executable file contains a header consisting of a set of load commands<a name="//apple_ref/doc/uid/TP40001829-DontLinkElementID_26"></a>. For programs that use shared libraries or frameworks, one of these commands specifies the location of the linker to be used to load the program. If you use Xcode, this is always <code>/usr/lib/dyld</code>, the standard Mac OS X dynamic linker<a name="//apple_ref/doc/uid/TP40001829-DontLinkElementID_27"></a>.</p><p>When you call the <code>execve</code> routine, the kernel first loads the specified program file and examines the <code>mach_header</code><a name="//apple_ref/doc/uid/TP40001829-DontLinkElementID_28"></a> structure at the start of the file. The kernel verifies that the file appear to be a valid Mach-O file and interprets the load commands stored in the header. The kernel then loads the dynamic linker specified by the load commands into memory and executes the dynamic linker on the program file.</p><p>The dynamic linker loads all the shared libraries that the main program links against (the <a name="//apple_ref/doc/uid/TP40001829-DontLinkElementID_29"></a><strong>dependent libraries</strong>) and binds enough of the symbols to start the program. It then calls the entry point function. At build time, the static linker adds the standard entry point function to the main executable file from the object file <a name="//apple_ref/doc/uid/TP40001829-DontLinkElementID_30"></a><code>/usr/lib/crt1.o</code>. This function sets up the runtime environment state for the kernel and calls static initializers for C++ objects, initializes the Objective-C runtime, and then calls the program’s <code>main</code> function<a name="//apple_ref/doc/uid/TP40001829-DontLinkElementID_31"></a>.</p><a name="//apple_ref/doc/uid/TP40001829-97021" title="Finding Imported Symbols"></a><a name="//apple_ref/doc/uid/TP40001829-97021-TPXREF121" title="Finding Imported Symbols"></a><h2>Finding Imported Symbols</h2><p>When the dynamic linker loads a Mach-O file (which, for the purposes of this section, is called the <strong>client program</strong>), it connects the file’s imported symbols to their definitions in a shared library or framework. This section describes the process of binding the imported symbols in one Mach-O file to their definitions in other Mach-O files. It also explains the process of finding a symbol. See also <span class="content_text"><a href="loading_code.html#//apple_ref/doc/uid/TP40001830-97384">“Loading Plug-in Code With Bundles”</a></span> in <span class="content_text"><a href="loading_code.html#//apple_ref/doc/uid/TP40001830-SW1" target="_self">Loading Code at Runtime</a></span> for information on finding symbols in plug-ins.</p><a name="//apple_ref/doc/uid/TP40001829-97047" title="Binding Symbols"></a><a name="//apple_ref/doc/uid/TP40001829-97047-TPXREF111" title="Binding Symbols"></a><h3>Binding Symbols</h3><p><strong>Binding</strong><a name="//apple_ref/doc/uid/TP40001829-DontLinkElementID_32"></a> is the process of resolving a module’s references to functions and data in other modules (the <strong>undefined external symbols</strong>, sometimes called <strong>imported symbols</strong>). The modules may be in the same Mach-O file or in different Mach-O files; the semantics are identical in either case. When the application is first loaded, the dynamic linker loads the imported shared libraries into the address space of the program. When binding is performed, the linker replaces each of the program’s imported references with the address of the actual definition from one of the shared libraries.</p><p>The dynamic linker can bind a program at several stages during loading and execution, depending on the options you specify at build time:</p><ul class="spaceabove"><li class="li"><a name="//apple_ref/doc/uid/TP40001829-DontLinkElementID_33"></a><a name="//apple_ref/doc/uid/TP40001829-DontLinkElementID_34"></a><p>With <strong>just-in-time binding</strong> (also called lazy binding), the dynamic linker binds a reference (and all the other references in the same module) when the program first uses the reference. The dynamic linker loads the shared libraries the client program depends on when the program is loaded. However, the dynamic linker doesn’t bind the program’s references to symbols within the shared libraries until the symbols are used.</p></li><li class="li"><a name="//apple_ref/doc/uid/TP40001829-DontLinkElementID_35"></a><p>With <strong>load-time binding</strong>, the dynamic linker binds all the imported references immediately upon loading the program, or, for bundles, upon loading the bundle. To use load-time binding with the standard tools, specify the<code> -bind_at_load</code> option to <code>ld</code> to indicate that the dynamic linker must immediately bind all external references when the file is loaded. Without this option, <code>ld</code> sets up the output file for just-in-time binding.</p></li><li class="li"><a name="//apple_ref/doc/uid/TP40001829-DontLinkElementID_36"></a><p>With <strong>prebinding</strong>, a form of load-time binding, the shared libraries referenced by the program are each prebound at a specified address. The static linker sets the address of each undefined reference in the program to default to these addresses. At runtime, the dynamic linker needs only to verify that none of the addresses have changed since the program was built (or since the prebinding was recomputed). If the addresses have changed, the dynamic linker must undo the prebinding by clearing the prebound addresses for all the undefined references and then proceed as if the program had been just-in-time bound. Otherwise, it does not need to perform any action to bind the program.</p><p>Prebinding requires that each framework specify its desired base virtual memory address and that none of the prebound addresses of the loaded frameworks overlap. To prebind a file with the standard tools, specify the <code>-prebind</code> option to <code>ld</code>.</p></li><li class="li"><a name="//apple_ref/doc/uid/TP40001829-DontLinkElementID_37"></a><p><strong>Weak references</strong>, a feature introduced in Mac OS X v10.2, is useful for selectively implementing features that may be available on some systems, but not on others. This mode of binding allows a program to optionally bind to specified shared libraries. If the dynamic linker cannot find definitions for weak references, it sets them to <code>NULL</code> and continues to load the program. The program can check at runtime to find out whether or not a reference is null and, if so, avoid using the reference. You can specify both libraries and individual symbols to be weakly referenced.</p></li></ul><div class="notebox"><a name="//apple_ref/doc/uid/TP40001829-SW2" title="Note"></a><p><strong>Note:</strong>&nbsp;The Mac OS X weak linking design is derived from the classic Mac OS Code Fragment Manager implementation of weak linking. If you are familiar with the ELF executable format, you may be used to a different meaning for the terms <em>weak symbol</em> or <em>weak linking</em>, where a weak symbol may be overridden by a nonweak symbol. The equivalent Mac OS X feature is the <em>weak definition</em>—see <span class="content_text"><a href="executing_files.html#//apple_ref/doc/uid/TP40001829-98432">“Scope and Treatment of Symbol Definitions”</a></span> for more information</p></div><p>If no other type of binding is specified for a given library, the static linker sets up the program’s undefined references to that library to use just-in-time binding.</p><a name="//apple_ref/doc/uid/TP40001829-97182" title="Searching for Symbols"></a><a name="//apple_ref/doc/uid/TP40001829-97182-TPXREF112" title="Searching for Symbols"></a><h3>Searching for Symbols</h3><p>A <strong>symbol</strong><a name="//apple_ref/doc/uid/TP40001829-DontLinkElementID_38"></a> is a generic representation of the location of a function, data variable, or constant in an executable file. References to functions and data in a program are references to symbols. To refer to a symbol when using the dynamic linking routines, you usually pass the name of the symbol, although some functions also accept a number representing the ordering of the symbol in the executable file. The name of a symbol representing a function that conforms to standard C calling conventions is the name of the function with an underscore prefix. Thus, the name of the symbol representing the function <code>main</code> would be <code>_main</code>.</p><p>Programs created by the Mac OS X v10.0 development tools add all symbols from all loaded shared libraries into a single global list. Any symbol that your program references can be located in any shared library, as long as that shared library is one of the program’s dependent libraries (or one of the dependent libraries of the dependent libraries).</p><p>Mac OS X v10.1 introduced the two-level symbol namespace<a name="//apple_ref/doc/uid/TP40001829-DontLinkElementID_39"></a> feature. The first level of the two-level namespace is the name of the library that contains the symbol, and the second is the name of the symbol. With the two-level namespace feature enabled, when the static linker records references to imported symbols, it records a reference to the name of the library that contains the symbol and the name of the symbol<a name="//apple_ref/doc/uid/TP40001829-DontLinkElementID_40"></a>. Linking your programs with the two level namespace feature offers two benefits over the flat namespace:</p><ul class="spaceabove"><li class="li"><p><strong>Enhanced performance when searching for symbols.</strong> With the two-level namespace, the dynamic linker knows exactly where to start looking for the implementation of a symbol. With a flat namespace, the dynamic linker must search all the loaded libraries for the one that contains the symbol.</p></li><li class="li"><p><strong>Enhanced forward compatibility.</strong> In the flat namespace, two or more libraries cannot contain symbols with different implementations that share the same name because the dynamic linker cannot know which library contains the preferred implementation. This is not initially a problem, because the static linker catches any such problems when you first build the application. However, if the vendor of one of your dependent shared libraries later releases a new version of the library that contains a symbol with the same name as one in your program or in another dependent shared library, your program will fail to run.</p></li></ul><p>Your application must link directly to the shared library that contains the symbol (or, if the library is part of an umbrella framework, to the umbrella framework that contains it).</p><p>When obtaining symbols in a program built with the two-level namespace feature enabled, you must specify a reference to the shared library that contains the symbols.</p><p>By default, the static linker in Mac OS X v10.1 and later uses a two-level namespace for all Mach-O files.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40001829-SW3" title="Note"></a><p><strong>Note:</strong>&nbsp;The Mac OS X two-level namespace feature is loosely based on the design of the Code Fragment Manager’s namespace. A two-level namespace is approximately equivalent to the namespace used to look up symbols in code fragments. Because Code Fragment Manager always requires an explicit reference to the library in which a symbol should be found, there is no Code Fragment Manager equivalent to a flat namespace search.</p></div><p>For programs that do not have a two-level namespace<a name="//apple_ref/doc/uid/TP40001829-DontLinkElementID_41"></a>, you can tell the linker to define references to undefined symbols even if the linker cannot find the library that contains them. When you build an executable with such undefined symbols, you are making the assumption that one of the other files loaded as part of the executable file at runtime contains those symbols. Bundles and shared libraries sometimes use this option to reference symbols defined in the main executable. However, this causes you to lose the performance and compatibility benefits of two-level namespaces. It’s usually better to explicitly link against an executable that defines the references. However, if you must link with undefined references, you can do it by enabling the flat namespace feature and suppressing undefined reference warnings, using the options <code>-flat_namespace</code> and <code>-undefined suppress</code> as in the following command line:</p><div class="codesample"><table><tr><td scope="row"><pre>ld -o my_tool -flat_namespace -undefined suppress peace.o love.o<span></span></pre></td></tr></table></div><p>When building executables with a two-level namespace, you can allow the remaining undefined symbols to be looked up by the dynamic linker if the program is targeted for Mac OS X v10.3 and later (the <code>MACOSX_DEPLOYMENT_TARGET</code> environment variable is set to <code>10.3</code> or higher). To take advantage of this feature, use the <code>-undefined dynamic_lookup</code> option.</p><p>To build executables with a two-level namespace, the static linker must be able to find the source library for each symbol. This can present difficulties for authors of bundles and dynamic shared libraries that assume a flat, global symbol namespace. To build successfully with the two-level namespace, keep the following points in mind:</p><ul class="spaceabove"><li class="li"><p>Bundles that need to reference symbols defined in the program’s main executable must use the <code>-bundle_loader</code> static linker option. The static linker can then search the main executable for the undefined symbols.</p></li><li class="li"><p>Shared libraries that need to reference symbols defined in the program’s main executable must load the symbol dynamically using a function that does not require a library reference, such as <code>dlsym</code> or <code><a href="../../../Reference/MachOReference/Reference/reference.html#//apple_ref/c/func/NSLookupSymbolInImage" target="_top">NSLookupSymbolInImage</a></code> (<em><a href="../../../Reference/MachOReference/index.html#//apple_ref/doc/uid/TP40001398" target="_top">Mac OS X ABI Dynamic Loader Reference</a></em>).</p></li></ul><div class="notebox"><a name="//apple_ref/doc/uid/TP40001829-SW4" title="Note"></a><p><strong>Note:</strong>&nbsp;A two-level symbol namespace can be searched using functions for doing flat symbol searches.</p></div><a name="//apple_ref/doc/uid/TP40001829-98432" title="Scope and Treatment of Symbol Definitions"></a><a name="//apple_ref/doc/uid/TP40001829-98432-TPXREF120" title="Scope and Treatment of Symbol Definitions"></a><h2>Scope and Treatment of Symbol Definitions</h2><p>Symbols in an object file may exist at several levels of scope. This section describes each of the possible scopes that a symbol may be defined at, and provides samples of C code used to create each symbol type. These samples work with the standard developer tools; a third party tool set may have different conventions.</p><p>A <strong>defined external symbol</strong> is any symbol defined in the current object file, including functions and data. The following C code defines external symbols:</p><div class="codesample"><table><tr><td scope="row"><pre>int x = 0;<span></span></pre></td></tr><tr><td scope="row"><pre>double y = 99 __attribute__((visibility("default")));   // GCC 4.0 only<span></span></pre></td></tr></table></div><p>An <strong>undefined external symbol</strong><a name="//apple_ref/doc/uid/TP40001829-DontLinkElementID_42"></a> is any symbol defined in a file outside of the current file. The following C code defines two external symbols, a variable and a function:</p><div class="codesample"><table><tr><td scope="row"><pre>extern int x;<span></span></pre></td></tr><tr><td scope="row"><pre>extern void SomeFunction(void);<span></span></pre></td></tr></table></div><p>A <strong>common symbol</strong><a name="//apple_ref/doc/uid/TP40001829-DontLinkElementID_43"></a> is a symbol that may appear in multiple intermediate object files. The static linker permits multiple common symbol definitions with the same name in input files, and copies the one with the largest size to the final product. If there is another symbol with the same name as a common symbol, the static linker ignores the common symbol instead.</p><p>The standard C compiler generates a common symbol when it sees a <strong>tentative definition</strong>—a global variable that has no initializer and is not marked <code>extern</code>. The following line is an example of a tentative definition:</p><div class="codesample"><table><tr><td scope="row"><pre>int x;<span></span></pre></td></tr></table></div><p>A multi-module shared library, which <code>ld</code> builds by default, cannot have common symbols. However, you can build a shared library as a single module with the <code>-single_module</code> flag. To eliminate common symbols in an existing shared library, you must either explicitly define the symbol (with an initialized value, for example) in one of the modules in the shared library, or pass the <code>-fno-common</code> flag to the compiler.</p><p>A <strong>private defined symbol</strong><a name="//apple_ref/doc/uid/TP40001829-DontLinkElementID_44"></a> is a symbol that is not visible to other modules. The following C code defines a private symbol:</p><div class="codesample"><table><tr><td scope="row"><pre>static int x;<span></span></pre></td></tr></table></div><p>A <strong>private external symbol</strong> is a defined external symbol that is visible only to other modules within the same object file as the module that contains it. The standard static linker changes private external symbols into private defined symbols unless you specify otherwise (using the <code>-keep_private_externs</code> flag).</p><p>You can mark a symbol as private external by using the <code>__private_extern__</code> keyword (which works only in C) or the <code>visibility("hidden")</code> attribute (which works both in C and C++ with GCC 4.0), as in this example:</p><div class="codesample"><table><tr><td scope="row"><pre>__private_extern__ int x = 0;                       // C only<span></span></pre></td></tr><tr><td scope="row"><pre>int y = 99 __attribute__((visibility("hidden")));   // C and C++, GCC 4.0 only<span></span></pre></td></tr></table></div><p>A <strong>coalesced symbol</strong><a name="//apple_ref/doc/uid/TP40001829-DontLinkElementID_45"></a> is a symbol that may be defined in multiple object files but that the static linker generates only one copy of in the output file. This can save a lot of memory with certain C++ language features that the compiler must generate for each individual object file, such as virtual function tables, runtime type information (RTTI), and C++ template instantiations. The compiler determines which constructs should be coalesced; no work on your part is required.</p><p>A <strong>weak reference</strong> is an undefined external symbol that need not be found in order for the client program to successfully link. If the symbol does not exist, the dynamic linker sets the address of the symbol to zero. Files with weak references can be used only in Mac OS X v10.2 and later. The following C code demonstrates conditionalizing an API call using a weak reference:</p><div class="codesample"><table><tr><td scope="row"><pre>/* Only call this API if it exists */<span></span></pre></td></tr><tr><td scope="row"><pre>if ( SomeNewFunction != NULL )<span></span></pre></td></tr><tr><td scope="row"><pre>        SomeNewFunction();<span></span></pre></td></tr></table></div><p>To specify that a function should be treated as a weak reference, use the <code>weak_import</code> attribute on a function prototype, as demonstrated by the following code:</p><div class="codesample"><table><tr><td scope="row"><pre>void SomeNewFunction(void) __attribute__((weak_import));<span></span></pre></td></tr></table></div><p>A <strong>coalesced weak reference</strong> is an undefined external reference to a symbol defined in multiple object files. In Mac OS X v10.4 and later (with GCC 4.0 and later), you can specify that a symbol be made into a coalesced weak reference by adding the weak attribute to the symbol’s declaration. For example: </p><div class="codesample"><table><tr><td scope="row"><pre>void SomeNewFunction(void) __attribute__((weak));<span></span></pre></td></tr></table></div><div class="notebox"><a name="//apple_ref/doc/uid/TP40001829-SW5" title="Note"></a><p><strong>Note:</strong>&nbsp;Programmers who use other operating systems may be familiar with the concept of symbols that are marked with a COMDAT flag; a coalesced symbol is the Mac OS X equivalent feature.</p></div><p>A <strong>weak definition</strong> is a symbol that is ignored by the linker if an otherwise identical but nonweak definition exists. This is used by the standard C++ compiler to support C++ template instantiations. The compiler marks implicit—and not explicit—template instantiations as weak definitions. The static linker then prefers any explicit template instantiation to an implicit one for the same symbol, which provides correct C++ linking semantics. As with coalesced symbols, the compiler determines the constructs that require the weak definitions feature; no work on your part is required.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP40001829-SW6" title="Note"></a><p><strong>Note:</strong>&nbsp;Files with weak definitions can be used only in Mac OS X v10.2 and later. The static linker changes any weak definitions into nonweak definitions, so this is only a concern for intermediate object files and static libraries that you wish to deploy on earlier versions of Mac OS X.</p></div><p>A <strong>debugging symbol</strong> is a symbol generated by the compiler that allows the debugger to map from addresses in machine code to locations in source code. The standard compilers generate debugging symbols using either the Stabs format or the DWARF format (supported in Xcode 2.4 and later). When using the Stabs format, debugging symbols, like other symbols, are stored in the symbol table (see <em><a href="../../MachORuntime/index.html#//apple_ref/doc/uid/TP40000895" target="_top">Mac OS X ABI Mach-O File Format Reference</a></em>). But with the DWARF format, debugging symbols are stored in a specialized segment: the <code>__DWARF</code> segment. With DWARF you also have the option of storing debugging symbols in a separate debug-information file, which reduces the size of the binary files while permitting a full debugging experience when the corresponding debug-information files are available.</p>

        <br/><br/> 

        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="building_files.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="loading_code.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2003, 2009 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2009-02-04<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/DeveloperTools/Conceptual/MachOTopics/1-Articles/executing_files.html%3Fid%3DTP40001519-3.1&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/DeveloperTools/Conceptual/MachOTopics/1-Articles/executing_files.html%3Fid%3DTP40001519-3.1&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/DeveloperTools/Conceptual/MachOTopics/1-Articles/executing_files.html%3Fid%3DTP40001519-3.1&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>
