<HTML><HEAD><META NAME="GENERATOR" CONTENT="Adobe FrameMaker 5.5/HTML Export Filter"><script language="JavaScript" src="frametest.js"></script><TITLE> Mac OS &amp; Services That Maximize PCI Throughput</TITLE></HEAD><BODY BGCOLOR="#ffffff"><DIV><a name="top"></a><!-- start of banner --><!--#include virtual="/includes/framesetheader" --><!-- end of banner --><!-- start of path --><font face="Geneva,Helvetica,Arial" size="1"><b><br>PATH<spacer type="horizontal" size="5">&nbsp;</b><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Documentation</a> &gt; <!-- a href="" target="_top" -->Hardware<!-- /a -->  <b>&gt; </b><a href="../../devicemgrs.html" target="_top">Device Managers and Drivers</a> <b>&gt; </b><a href="../pci_srvcs.html" target="_top">PCI Card Services</a> <b>&gt; </b>Designing PCI Cards and Drivers for Power Macintosh Computers</font><br><br><!-- end of path --><A HREF="PCI_BOOK.11.html"><img src="images/up.gif" border="0" width="36" height="16"></A><nobr>&nbsp;</nobr><A HREF="PCI_BOOK.14.html"><img src="images/previous.gif" border="0" width="66" height="16"></A><nobr>&nbsp;</nobr><A HREF="PCI_BOOK.16.html"><img src="images/next.gif" border="0" width="49" height="16"></A><!-- insert Show/Hide frames --><a href="javascript:testFrame()"><script><!--document.write(frameLink);//--></script><!-- end Show/Hide frames --></A><HR></DIV><H1 CLASS="H2.Heading2"><A NAME="pgfId=4021"> </A>Mac OS &amp; Services That Maximize PCI Throughput</H1><P CLASS="T1.Text1"><A NAME="pgfId=4022"> </A>This section discusses the Mac OS services available to maximize PCI throughput. </P><P CLASS="T1.Text1"><A NAME="pgfId=4023"> </A>Beginning with the Mac OS version 7.5.2 release, a DSL (Driver Services Library) that implements all programming interface services is available for drivers. The complete API for the DSL is documented in <A HREF="PCI_BOOK.140.html#12320" CLASS="XRef">Driver Services Library</A>.</P><P CLASS="T1.Text1"><A NAME="pgfId=4024"> </A>To coordinate I/O operations that transfer buffers between system memory and PCI address space, the Macintosh OS provides two functions with the DSL: <TT CLASS="cv">PrepareMemoryForIO</TT>, and <TT CLASS="cv">CheckpointIO</TT>. The <TT CLASS="cv">PrepareMemoryForIO</TT> function allocates resident system memory to buffers, provides logical and physical address information, and in conjunction with <TT CLASS="cv">CheckpointIO</TT> manages coherency between system memory and the PowerPC caches. <TT CLASS="cv">CheckpointIO</TT> is called after the buffer transfer is complete and either relinquishes the memory back to the OS and adjusts the processor caches for coherency, or prepares for another IO transfer.</P><DIV><blockquote><p CLASS="NoteHead"><b><A NAME="pgfId=14781"> </A>Note</b></p><P CLASS="Note"><A NAME="pgfId=4025"> </A><TT CLASS="cv">PrepareMemoryForIO</TT> should not be confused with PCI I/O space. It is for buffers whether they are located in PCI memory or PCI I/O space. </P></blockquote><P CLASS="T1.Text1"><A NAME="pgfId=4026"> </A><TT CLASS="cv">PrepareMemoryForIO</TT> is an example of a service in the DSL; PCI cards that have DMA hardware should use <TT CLASS="cv">PrepareMemoryForIO</TT> to locate physical addresses in system memory. Older I/O expansion cards would typically use the toolbox call <TT CLASS="cv">GetPhysical</TT> to locate physical addresses in system memory. To be fully compatible with the present and future Mac OS releases, drivers should only use the DSL services described in <A HREF="PCI_BOOK.140.html#12320" CLASS="XRef">Driver Services Library</A></P><P CLASS="T1.Text1"><A NAME="pgfId=4027"> </A>Remembering that PCI address space defaults to cache inhibit mode, to enable the PowerPC to burst to areas of PCI memory space, that area must be set to cacheable. This can be done with the <TT CLASS="cv">SetProcessorCacheMode</TT> function described in <A HREF="PCI_BOOK.15e.html#16060" CLASS="XRef">SetProcessorCacheMode</A>. Set the desired PCI address space to <TT CLASS="cv">kProcessorCacheModeCopyBack</TT> for cache line writes and <TT CLASS="cv">kProcessorCacheModeWriteThrough</TT> for cache line reads.</P></DIV><DIV><blockquote><p CLASS="ImportantHead"><b><A NAME="pgfId=14783"> </A>IMPORTANT</b></p><P CLASS="I.Important"><A NAME="pgfId=4028"> </A>Extreme care must be taken for burst writes to PCI address space to perform appropriate cache flushing. </P></blockquote><P CLASS="T1.Text1"><A NAME="pgfId=4029"> </A>Be advised that the <TT CLASS="cv">SetProcessorCacheMode</TT> has an undocumented limitation. The PowerPC address space is divided into sixteen 256-Mbyte segments that are distinguished by the upper 4-bits of the effective address. The <TT CLASS="cv">SetProcessorCacheMode</TT> is only capable of changing the cache setting for one contiguous section of memory per 256-Mbyte segment. Therefore, if two PCI cards are configured where they both have PCI address assignments in the same segment only one card can change its address space cache setting.</P><P CLASS="T1.Text1"><A NAME="pgfId=4030"> </A>For example, if two cards (card x and card y) have addresses mapped into segment 8, one at 0x80800000 and another at 0x80801000, the first call to <TT CLASS="cv">SetProcessorCacheMode</TT> from the driver of card x to make a cacheable address space in segment 8 will work. A second call, say from the driver of card y, to modify the cache setting in segment 8 will not work nor will it report an error. This scenario will most likely result in a lower than expected performance for card y, because card y address space is actually cache inhibited which disables PCI transactions of 32-byte cache lines. If the two cards are mapped into different segments, such as 8 and A, then they both can modify the cache settings within their perspective segments. This limitation will be relaxed in the future.</P><P CLASS="T1.Text1"><A NAME="pgfId=4031"> </A>Extensions to the <TT CLASS="cv">BlockMove</TT> routine have been incorporated in the DSL that optimize performance on the PowerPC CPU family. In particular, <TT CLASS="cv">BlockMoveData</TT> has been optimized for data that is cacheable and <TT CLASS="cv">BlockMoveDataUncached</TT> for data that is cache inhibited. The difference between the cached and uncached versions of these instructions is that, for <TT CLASS="cv">BlockMoveData</TT>, the PPC dcbz instruction is used to avoid the logically unnecessary read of the destination cache blocks. <TT CLASS="cv">BlockMoveDataUncached</TT> does not use the dcbz instruction because dcbz is extremely slow for address space marked cache inhibited or cache write thru.</P><P CLASS="T1.Text1"><A NAME="pgfId=4032"> </A>The difference between <TT CLASS="cv">BlockMove</TT> and <TT CLASS="cv">BlockMoveData</TT> versions is whether or not the block being moved contains 68K instructions. If the data does contain 68K instructions <TT CLASS="cv">BlockMove</TT> must be called which also flushes the DR (Dynamic Recompilation) Emulator's cache. This is costly time-wise, so if the block does not contain 68K instructions, be sure to use <TT CLASS="cv">BlockMoveData</TT> or <TT CLASS="cv">BlockMoveDataUncached</TT>. Also with performance in mind, when appropriate the BlockMove routines will align the source and destination address to utilize floating-point load and store instructions.</P><P CLASS="T1.Text1"><A NAME="pgfId=4033"> </A>For transfers of large buffers between PCI cards the <TT CLASS="cv">BlockMoveData</TT> or <TT CLASS="cv">BlockMoveDataUncached</TT> functions should be used, depending if the destination address space is marked write back cacheable or not. Native PCI drivers most likely will not need to consider the non-Data variant of the <TT CLASS="cv">BlockMove</TT> routines because destination buffers either in PCI address space or system memory will probably not need to execute 68K code.</P><P CLASS="T1.Text1"><A NAME="pgfId=4034"> </A>To initiate a PCI burst of a cache line, use the <TT CLASS="cv">BlockMoveData</TT> function. Provided the PCI address space is marked cacheable as explained earlier, the <TT CLASS="cv">BockMoveData</TT> function forces the IB chip to burst 32-byte cache lines -- eight-beat data phases per PCI command transaction.</P><P CLASS="T1.Text1"><A NAME="pgfId=4035"> </A>To read or write PCI I/O space, the Expansion Bus Manager provides routines to transfer data -- byte, word, or long word (8, 16, or 32 bits, respectively) -- using PCI I/O Read and I/O Write commands. The Expansion Bus Manager is part of the ROM firmware in PCI Power Macintosh CPUs. These routines also perform appropriate byte swapping. For a further description, refer to <A HREF="PCI_BOOK.1b1.html#27578" CLASS="XRef">Expansion Bus Manager</A>. PCI cards that are limited to I/O space, and do not incorporate PCI memory space, are limited to PCI I/O Read and I/O Write commands to transfer data between the PowerPC processor and PCI target. If PCI I/O data needs to be processed quickly, note there is a significant performance hit using Expansion Manager Routines. These routines are intended for PCI targets that have I/O registers or low bandwidth I/O buffers. The IB chip does not burst PCI I/O Read nor burst PCI I/O Write commands.</P><P CLASS="T1.Text1"><A NAME="pgfId=4036"> </A>As described in <A HREF="PCI_BOOK.1ba.html#14782" CLASS="XRef">Fast I/O Space Cycle Generation</A>, the PCI property <TT CLASS="cv">assigned-addresses</TT> provides vector entries that represent physical addresses on PCI cards. Using the <TT CLASS="cv">APPL,address</TT> property, a driver can locate a logical address of a physical I/O resource. By accessing the logical I/O address, the IB chip generates the appropriate PCI I/O command. Therefore a driver can generate PCI I/O commands without using the Expansion Bus Manager Routines; the same way it accesses PCI memory space. This provides the fastest way to access I/O space, but note it does not perform the byte swapping provided by the Expansion Bus Manager routines.</P><P CLASS="T1.Text1"><A NAME="pgfId=4037"> </A>Also note, the Expansion Bus Manager provides OS services to generate PCI Configuration Read, Configuration Write, Interrupt Acknowledge, and Special Cycle commands. </P><P CLASS="T1.Text1"><A NAME="pgfId=4038"> </A>To maximize bus performance, utilize the services available in the Driver Services Library, and pay close attention to PCI chip selection, in particular, chips that can execute cache line burst transactions with Memory Read Line, Memory Read Multiple, and Memory Write and Invalidate commands. </P><P CLASS="T1.Text1"><A NAME="pgfId=4039"> </A>To maximize your PCI card's performance on the Power Macintosh platform. As a PCI target, your card should</P><UL><LI CLASS="B1.Bullet1"><A NAME="pgfId=4040"> </A>minimize the number of wait states</LI><LI CLASS="B1.Bullet1"><A NAME="pgfId=4042"> </A>accept <A NAME="marker=4041"> </A>burst transactions of cache line size without disconnecting</LI><LI CLASS="B1.Bullet1"><A NAME="pgfId=4043"> </A>support 8-byte burst transactions if it cannot support cache line size burst transactions </LI></UL><P CLASS="T1.Text1"><A NAME="pgfId=4044"> </A>As a PCI master, your card should</P><UL><LI CLASS="B1.Bullet1"><A NAME="pgfId=4045"> </A>minimize the number of wait states for transactions and arbitration</LI><LI CLASS="B1.Bullet1"><A NAME="pgfId=4046"> </A>support linear burst ordering and be able to read or write at least one whole cache line of data</LI><LI CLASS="B1.Bullet1"><A NAME="pgfId=4047"> </A>support the memory read line or memory read multiple cycle types for read transactions</LI><LI CLASS="B1.Bullet1"><A NAME="pgfId=4048"> </A>support the memory write and invalidate cycle type for write transactions</LI></UL></DIV><HR>&#169 1999 Apple Computer, Inc. &#150 (Last Updated 26 March 99)<P><A HREF="PCI_BOOK.11.html"><img src="images/up.gif" border="0" width="36" height="16"></A><nobr>&nbsp;</nobr><A HREF="PCI_BOOK.14.html"><img src="images/previous.gif" border="0" width="66" height="16"></A><nobr>&nbsp;</nobr><A HREF="PCI_BOOK.16.html"><img src="images/next.gif" border="0" width="49" height="16"></A><!-- insert Show/Hide frames --><a href="javascript:testFrame()"><script><!--document.write(frameLink);//--></script><!-- end Show/Hide frames --></A><!-- start of footer --><!--#include virtual="/includes/framesetfooter" --><!-- end of footer --></body></HTML>