<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>WebObjects Enterprise Objects Programming Guide: Fetching Data</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="Fetching Data"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP30001011-CH206" title="Fetching Data"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../InternetWeb/index.html#//apple_ref/doc/uid/TP30000440-TP30000469" target="_top">Internet &amp; Web</a> &gt; <a href="../../../InternetWeb/WebObjects-date.html#//apple_ref/doc/uid/TP30000440-TP30000469-TP30000592" target="_top">WebObjects</a> &gt; <a href="../About/About.html#//apple_ref/doc/uid/TP30001011-CH201-DontLinkElementID_1">WebObjects Enterprise Objects Programming Guide</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../Geography/Geography.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../Managing/Managing.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP30001011-CH206-DontLinkElementID_35" title="Fetching Data"></a><h1><a name="//apple_ref/doc/uid/TP30001011-CH206-TP1" title="Fetching Data"></a>Fetching Data</h1><p>This chapter discusses the mechanics of retrieving data using Enterprise Objects. </p><p>It is divided into the following sections:</p><ul class="ul"><li class="li"><p><span class="content_text"><a href="Fetching.html#//apple_ref/doc/uid/TP30001011-CH206-BADIACBC">“Objects Involved in Fetching”</a></span> describes the objects involved in retrieving data.</p></li><li class="li"><p><span class="content_text"><a href="Fetching.html#//apple_ref/doc/uid/TP30001011-CH206-BADCEFIF">“Flow of Data During a Fetch”</a></span> discusses the flow of data during a fetch.</p></li><li class="li"><p><span class="content_text"><a href="Fetching.html#//apple_ref/doc/uid/TP30001011-CH206-BADBHACJ">“Enterprise Object Initialization”</a></span> discusses how enterprise objects instances are initialized.</p></li><li class="li"><p><span class="content_text"><a href="Fetching.html#//apple_ref/doc/uid/TP30001011-CH206-BADGBHAJ">“Faulting and Relationship Resolution”</a></span> describes how Enterprise Objects resolves relationships and uses faulting to improve performance.</p></li><li class="li"><p><span class="content_text"><a href="Fetching.html#//apple_ref/doc/uid/TP30001011-CH206-BADHCCEE">“Data Integrity Mechanisms”</a></span> discusses some of the data integrity mechanisms Enterprise Objects uses while fetching data, including uniquing, faulting, and snapshotting.</p></li><li class="li"><p><span class="content_text"><a href="Fetching.html#//apple_ref/doc/uid/TP30001011-CH206-BADDGFAG">“Ensuring Fresh Data”</a></span> discusses how Enterprise Objects caches fetched data, when it uses cached data, how to refetch data, how to clear the cache, and in general how to ensure that the enterprise object instances in your application contain fresh data.</p></li><li class="li"><p><span class="content_text"><a href="Fetching.html#//apple_ref/doc/uid/TP30001011-CH206-TPXREF151">“Advanced Faulting”</a></span> discusses advanced faulting topics such as deferred faulting and batch faulting.</p></li><li class="li"><p><span class="content_text"><a href="Fetching.html#//apple_ref/doc/uid/TP30001011-CH206-TPXREF152">“Advanced Fetching”</a></span> discusses advanced fetching topics such as raw row fetching and prefetching.</p></li><li class="li"><p><span class="content_text"><a href="Fetching.html#//apple_ref/doc/uid/TP30001011-CH206-TPXREF150">“Common Delegate Usage”</a></span> discusses delegates that are commonly implemented to customize fetching.</p></li><li class="li"><p><span class="content_text"><a href="Fetching.html#//apple_ref/doc/uid/TP30001011-CH206-TPXREF153">“Constructing Fetch Specifications”</a></span> teaches you how to build fetch specifications and how to construct qualifiers.</p></li><li class="li"><p><span class="content_text"><a href="Fetching.html#//apple_ref/doc/uid/TP30001011-CH206-TPXREF156">“Filtering Fetch Results in Memory”</a></span> teaches you how to filter the results of a fetch in memory.</p></li><li class="li"><p><span class="content_text"><a href="Fetching.html#//apple_ref/doc/uid/TP30001011-CH206-TPXREF172">“Sorting Fetch Results in Memory”</a></span> teaches you how to sort the results of a fetch in memory.</p></li><li class="li"><p><span class="content_text"><a href="Fetching.html#//apple_ref/doc/uid/TP30001011-CH206-BIECEEAB">“Accessing Database Keys”</a></span> discusses how to access an entity’s primary and foreign keys when they are not class properties.</p></li></ul><a name="//apple_ref/doc/uid/TP30001011-CH206-BADIACBC" title="Objects Involved in Fetching"></a><h2>Objects Involved in Fetching</h2><p>There are many objects involved in retrieving data in an Enterprise Objects application. The ones you’ll most commonly work with are introduced here.</p><dl class="termdef">	<dt>EOFetchSpecification<a name="//apple_ref/doc/uid/TP30001011-CH206-DontLinkElementID_374"></a></dt><dd><p>A fetch specification provides a description of what data to retrieve from a data source. A fetch specification always includes the name of an entity—in Enterprise Objects, a single database fetch operation is always done from the perspective of a particular entity. A fetch specification usually includes a qualifier—specific criteria to look for when searching the database. A fetch specification can also include a sort ordering, which specifies that the result set should be sorted in a particular way.</p></dd><dt>EOQualifier<a name="//apple_ref/doc/uid/TP30001011-CH206-DontLinkElementID_375"></a></dt><dd><p>A qualifier is often included in a fetch specification to provide criteria for a particular database fetch. There are a number of different kinds of qualifiers, some of which map to a SQL expression such as AND or OR. A qualifier is commonly compound—that is, a qualifier often consists of multiple qualifiers.</p></dd><dt>EOSortOrdering<a name="//apple_ref/doc/uid/TP30001011-CH206-DontLinkElementID_376"></a></dt><dd><p>A sort ordering is often included in a fetch specification to specify that the fetch’s result set should be sorted in a particular way.</p></dd><dt>EOEditingContext<a name="//apple_ref/doc/uid/TP30001011-CH206-DontLinkElementID_377"></a></dt><dd><p>In Enterprise Objects, a fetch almost always takes place within an object workspace called an editing context.</p></dd></dl><p>Other objects are involved in a fetch specification, such as EODatabaseContext and EOAdaptorChannel, but you rarely need to interact with these objects programmatically.</p><a name="//apple_ref/doc/uid/TP30001011-CH206-BADCEFIF" title="Flow of Data During a Fetch"></a><h2>Flow of Data During a Fetch</h2><p>A fetch begins with the construction of a fetch specification. You can create fetch specifications programmatically, but they are also created by various components within a WebObjects application such as display groups. You can also use EOModeler to build fetch specifications. </p><p>Once a fetch specification is created, the fetch must be initiated. Again, you commonly do this programmatically by invoking <code>objectsWithFetchSpecification</code><a name="//apple_ref/doc/uid/TP30001011-CH206-DontLinkElementID_378"></a> on an EOEditingContext, but it is also often done automatically by objects such as display groups.</p><p><span class="content_text">Figure 6-1</span> illustrates the flow<a name="//apple_ref/doc/uid/TP30001011-CH206-DontLinkElementID_379"></a> of data during a fetch.</p><br/><div><a name="//apple_ref/doc/uid/TP30001011-CH206-DontLinkElementID_36" title="Figure 5-1Flow of data during a fetch"></a><p><a name="//apple_ref/doc/uid/TP30001011-CH206-TPXREF169" title="Figure 5-1Flow of data during a fetch"></a><strong>Figure 5-1&nbsp;&nbsp;</strong>Flow of data during a fetch</p><img src = "../Art/flowduringfetch.gif" alt = "Flow of data during a fetch" width="366" height="319"></div><br/><p>Once a fetch is initiated, the following sequence occurs to retrieve data from a data source:</p><ol class="ol"><li class="li"><p>When <code>objectsWithFetchSpecification<a name="//apple_ref/doc/uid/TP30001011-CH206-DontLinkElementID_380"></a></code> is invoked on an EOEditingContext, that editing context forwards the invocation on to its parent object store. The parent object store again forwards the invocation on to its parent object store until the root object store is reached (the root object store is usually an instance of EOObjectStoreCoordinator).</p></li><li class="li"><p>The root object store (EOObjectStoreCoordinator) determines which of its EOCooperatingObjectStores should service the fetch specification. It forwards the <code>objectsWithFetchSpecification</code> invocation to the determined cooperating object store to ask it to retrieve data from the data source.</p></li></ol><p>How does an EOObjectStoreCoordinator<a name="//apple_ref/doc/uid/TP30001011-CH206-DontLinkElementID_381"></a> determine which of its EOCooperatingObjectStores should service a particular fetch specification? Remember that within an EOModelGroup, entity names must be unique. Also remember that fetch specifications are entity-centric—every fetch specification is specified on the basis of a particular entity. So an object store coordinator simply looks for the list of entities registered within its cooperating object stores to match an entity name to particular cooperating object store.</p><p>When an EOCooperatingObjectStore<a name="//apple_ref/doc/uid/TP30001011-CH206-DontLinkElementID_382"></a> receives a request to fetch data from a data source, it invokes <code>objectsWithFetchSpecification<a name="//apple_ref/doc/uid/TP30001011-CH206-DontLinkElementID_383"></a></code> on its EODatabaseContext object to do the work. When a database context receives this fetch request, it fetches a number of rows from the database, transforms them into enterprise objects (in most cases), and registers them as needed with the EOEditingContext that initiated the chain of <code>objectsWithFetchSpecification</code> invocations.</p><p>A database context uses an EODatabaseChannel to do all this. That object in turn uses an EOAdaptorChannel object to communicate directly with data sources and model-level objects—EOEntity, EOAttribute, EORelationship—that are necessary to perform the fetch.</p><p>Within EODatabaseContext, fetching occurs in two major steps:</p><ol class="ol"><li class="li"><p>A database context uses a database channel to select the rows in the database for which objects are being fetched. It does this using the EODatabaseChannel method <code>selectObjectsWithFetchSpecification</code><a name="//apple_ref/doc/uid/TP30001011-CH206-DontLinkElementID_384"></a>, which takes as an argument the fetch specification that originated in the editing context.</p></li><li class="li"><p>The database channel fetches each enterprise object, one at a time, as the database context repeatedly invokes on it the method <code>fetchObject<a name="//apple_ref/doc/uid/TP30001011-CH206-DontLinkElementID_385"></a></code>. This method uses state built up in the first step to get data from the object, create an enterprise object instance if necessary, and register the new instance with the fetch’s editing context. The database channel uses the entity name specified in the fetch specification to know which enterprise object class to instantiate for every fetched object.</p></li></ol><p>When an EODatabaseChannel<a name="//apple_ref/doc/uid/TP30001011-CH206-DontLinkElementID_386"></a> receives an invocation of <code>fetchObject</code> from an EODatabaseContext<a name="//apple_ref/doc/uid/TP30001011-CH206-DontLinkElementID_387"></a>, the following sequence of events occurs:</p><ol class="ol"><li class="li"><p>The database channel uses an EOAdaptorChannel<a name="//apple_ref/doc/uid/TP30001011-CH206-DontLinkElementID_388"></a> to retrieve a record for the requested entity. The record retrieved includes the record’s primary key, class properties and client-side class properties, attributes used for locking, and any foreign keys used by the entity’s relationships.</p></li><li class="li"><p>The database channel then assigns an EOGlobalID<a name="//apple_ref/doc/uid/TP30001011-CH206-DontLinkElementID_389"></a> to the row by invoking <code>globalIDForRow<a name="//apple_ref/doc/uid/TP30001011-CH206-DontLinkElementID_390"></a></code>.</p></li><li class="li"><p>The database channel records a snapshot for the fetched row. A global ID<a name="//apple_ref/doc/uid/TP30001011-CH206-DontLinkElementID_391"></a> may already have a recorded snapshot, but if this is not the case, the method <code>recordSnapshotForGlobalID<a name="//apple_ref/doc/uid/TP30001011-CH206-DontLinkElementID_392"></a></code> is invoked on EODatabase. However, if a snapshot is already recorded for the given global ID, the database context delegate method <code>databaseContextShouldUpdateCurrentSnapshot<a name="//apple_ref/doc/uid/TP30001011-CH206-DontLinkElementID_393"></a></code> is instead invoked. The default behavior does not update the already recorded snapshot with the new one, but you can change this by implementing the delegate method.</p><p>At this point in the fetch, if the fetch specification is set to refresh refetched objects, an ObjectsChangedInStoreNotification is posted to invalidate (refault) any existing enterprise object instances that correspond to this global ID.</p></li><li class="li"><p>The database channel records whether the object was locked when it was selected. This would be the case only if you enable pessimistic locking (row-level locking) in your application.</p></li><li class="li"><p>The database channel then checks with the editing context in which the fetch originated to see whether a copy of the object already exists in that editing context. It uses the EOEditingContext method <code>objectForGlobalID<a name="//apple_ref/doc/uid/TP30001011-CH206-DontLinkElementID_394"></a></code> to do this.</p></li><li class="li"><p>If the editing context contains an enterprise object for the global ID and if that enterprise object is not a fault, the editing context returns the enterprise object. Otherwise, the enterprise object returns <code>null</code>.</p></li><li class="li"><p>If the editing context doesn’t return an enterprise object for the global ID, the database channel invokes the EOEntityClassDescription<a name="//apple_ref/doc/uid/TP30001011-CH206-DontLinkElementID_395"></a> method <code>createInstanceWithEditingContext<a name="//apple_ref/doc/uid/TP30001011-CH206-DontLinkElementID_396"></a></code>, which determines the object’s class based on the fetch specification’s entity and instantiates an object of that class.</p></li><li class="li"><p>The database channel invokes the method <code>recordObject<a name="//apple_ref/doc/uid/TP30001011-CH206-DontLinkElementID_397"></a></code> on the editing context to unique the newly created object. This is discussed in more detail in <span class="content_text"><a href="Fetching.html#//apple_ref/doc/uid/TP30001011-CH206-TPXREF147">“Uniquing.”</a></span></p></li><li class="li"><p>If the editing context has a fault for the global ID, the fault is cleared and initialization proceeds just as if an empty enterprise object had been created and registered.</p></li><li class="li"><p>To initialize the object, the database channel invokes the method <code>initializeObject<a name="//apple_ref/doc/uid/TP30001011-CH206-DontLinkElementID_398"></a></code> on the editing context, which is passed down the object store hierarchy. If the editing context is nested, it passes the message to its parent editing context. If the parent editing context contains an object with a matching global ID, that object is used to initialize the object in the child editing context. </p><p>Otherwise, the <code>initializeObject<a name="//apple_ref/doc/uid/TP30001011-CH206-DontLinkElementID_399"></a></code> invocation is forwarded down to the editing context’s EODatabaseContext, which initializes the new instance from the appropriate snapshot and creates faults for its relationships. <code>initializeObject</code> in EODatabaseContext sets the values of the newly instantiated enterprise object’s properties using <code>takeStoredValueForKey<a name="//apple_ref/doc/uid/TP30001011-CH206-DontLinkElementID_400"></a></code>. This is described in more detail in <span class="content_text"><a href="Fetching.html#//apple_ref/doc/uid/TP30001011-CH206-BADBHACJ">“Enterprise Object Initialization.”</a></span></p></li><li class="li"><p>The database channel invokes <code>awakeFromFetch<a name="//apple_ref/doc/uid/TP30001011-CH206-DontLinkElementID_401"></a></code> on the new enterprise object. Custom enterprise object classes can override this method to perform additional initialization after an object has been created from a database row and initialized with database values, as described in <span class="content_text"><a href="../BusinessLogic/BusinessLogic.html#//apple_ref/doc/uid/TP30001011-CH204-TPXREF140">“Providing Initial Values.”</a></span></p></li></ol><a name="//apple_ref/doc/uid/TP30001011-CH206-BADBHACJ" title="Enterprise Object Initialization"></a><h2>Enterprise Object Initialization</h2><p>The following sequence<a name="//apple_ref/doc/uid/TP30001011-CH206-DontLinkElementID_402"></a> of events occurs when an object is fetched from the database:</p><ol class="ol"><li class="li"><p>A database row is fetched as raw binary data.</p></li><li class="li"><p>The values retrieved from that row are converted from their database-specific types to instances of standard value classes. A sample mapping of this conversion appears in <span class="content_text">Table 6-1</span>. An application’s EOModel<a name="//apple_ref/doc/uid/TP30001011-CH206-DontLinkElementID_403"></a><a name="//apple_ref/doc/uid/TP30001011-CH206-DontLinkElementID_404"></a> specifies the mapping from external data types (database type) to internal data types (Java value type).</p><a name="//apple_ref/doc/uid/TP30001011-CH206-DontLinkElementID_37" title="Table 5-1Database type to Java value type mapping"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><a name="//apple_ref/doc/uid/TP30001011-CH206-BADCJFGD" title="Table 5-1Database type to Java value type mapping"></a><strong>Table 5-1&nbsp;&nbsp;</strong>Database type to Java value type mapping</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Database type</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Java value type</p></th></tr><tr><td  scope="row"><p><code>char</code></p></td><td ><p>String</p></td></tr><tr><td  scope="row"><p><code>date</code></p></td><td ><p>NSTimestamp</p></td></tr><tr><td  scope="row"><p><code>blob</code></p></td><td ><p>NSData</p></td></tr><tr><td  scope="row"><p><code>int</code></p></td><td ><p>Integer</p></td></tr></table></div><p><code>null</code> values in the database are mapped to an instance of NSKeyValueCoding.NullValue.</p></li><li class="li"><p>Once the data has been converted to objects, these objects are put in an NSDictionary. The elements of the dictionary correspond to columns in the database table: Their names are the names of the attributes they map to in the EOModel and their values are the values retrieved from the database.</p><p>The dictionary provides a snapshot of the database row and is eventually used to initialize an enterprise object. This snapshot also participates in optimistic locking.</p><p>The dictionary contains an entry for all of a row’s columns, but an enterprise object initialized from the dictionary contains only the attributes that are defined as class properties or client-side class properties in the entity’s EOModel.</p></li><li class="li"><p>A new enterprise object is instantiated by an EOEntityClassDescription object.</p></li><li class="li"><p>The enterprise object is initialized from a row snapshot. Only objects that are class properties or client-side class properties are included. Faults are created for any references to relationships defined in the EOModel.</p></li></ol><p><span class="content_text">Figure 6-2</span> illustrates the relationship between database rows, database context snapshots, and enterprise object instances.</p><br/><div><a name="//apple_ref/doc/uid/TP30001011-CH206-DontLinkElementID_38" title="Figure 5-2Relationship between rows, snapshots, and enterprise objects"></a><p><a name="//apple_ref/doc/uid/TP30001011-CH206-TPXREF170" title="Figure 5-2Relationship between rows, snapshots, and enterprise objects"></a><strong>Figure 5-2&nbsp;&nbsp;</strong>Relationship between rows, snapshots, and enterprise objects</p><img src = "../Art/snapshotstoeos.gif" alt = "Relationship between rows, snapshots, and enterprise objects" width="451" height="390"></div><br/><a name="//apple_ref/doc/uid/TP30001011-CH206-BADGBHAJ" title="Faulting and Relationship Resolution"></a><h2>Faulting and Relationship Resolution</h2><p>One of the most powerful and useful features of Enterprise Objects is that it automatically resolves the relationships defined in a model. It does this in part by delaying the actual retrieval of data—and delaying communicating with the database—until the data is needed, a feature of Enterprise Objects called faulting. Faulting<a name="//apple_ref/doc/uid/TP30001011-CH206-DontLinkElementID_405"></a> happens in two phases: the creation of a placeholder object (a fault) for the data to be fetched, and fetching the data when it’s needed (firing a fault).</p><p>When Enterprise Objects fetches an object, it examines the object’s relationships as defined in the EOModel in which the object (entity) is defined. It then creates objects (faults) representing the destinations of the fetched object’s relationships. For example, if you fetch a Listing object that has an <code>agent</code> relationship and an <code>address</code> relationship, faults are created for the destination of those relationships, which are an Agent object and an Address object. The Agent and Address objects are not fetched (their rows in the database are not accessed) until their data is actually needed. <span class="content_text">Figure 6-3</span> illustrates this example.</p><br/><div><a name="//apple_ref/doc/uid/TP30001011-CH206-DontLinkElementID_39" title="Figure 5-3Enterprise object as a fault and as fully formed"></a><p><a name="//apple_ref/doc/uid/TP30001011-CH206-BADCJHCC" title="Figure 5-3Enterprise object as a fault and as fully formed"></a><strong>Figure 5-3&nbsp;&nbsp;</strong>Enterprise object as a fault and as fully formed</p><img src = "../Art/fault.gif" alt = "Enterprise object as a fault and as fully formed" width="468" height="302"></div><br/><p>Fetching is resource-intensive and often recursive—fetching the destination object of one enterprise object may require fetching that destination object’s destination objects, and so on until all of the interrelated rows in the database have been retrieved. To avoid this waste of time and resources, the destination objects are created as stand-ins, which are referred to as faults.</p><p>There are two kinds of faults<a name="//apple_ref/doc/uid/TP30001011-CH206-DontLinkElementID_406"></a>: single-object faults for to-one relationships and array faults for to-many relationships. A single-object fault is an enterprise object instance that is associated with a particular editing context, class description, and global ID. However, the enterprise object’s data hasn’t yet been fetched from the database—you can think of a single-object fault as a shell of an enterprise object.</p><p>Array<a name="//apple_ref/doc/uid/TP30001011-CH206-DontLinkElementID_407"></a><a name="//apple_ref/doc/uid/TP30001011-CH206-DontLinkElementID_408"></a> faults are instances of NSMutableArray and are triggered to fire their faults by any request for a member object or for the number of objects in the array (the number of objects in a to-many relationship can’t be determined without actually fetching them all). More specifically, array faults may start out as deferred faults, which are very small and cheap and contain little information. They may then become NSMutableArrays, which have more information about their state and contents. If an object in the relationship is then directly accessed (if an element in the array is accessed), the array fault fully fires, filling the array with enterprise objects.</p><p>You can find more information about faults in these places:</p><ul class="ul"><li class="li"><p><span class="content_text"><a href="../EnterpriseObjects/EnterpriseObjects.html#//apple_ref/doc/uid/TP30001011-CH203-CEHFCDGG">“Change Notification”</a></span></p></li><li class="li"><p><span class="content_text"><a href="../EnterpriseObjects/EnterpriseObjects.html#//apple_ref/doc/uid/TP30001011-CH203-TPXREF140">“Faulting”</a></span></p></li><li class="li"><p><span class="content_text"><a href="Fetching.html#//apple_ref/doc/uid/TP30001011-CH206-TPXREF157">“Deferred Faulting”</a></span></p></li><li class="li"><p><span class="content_text"><a href="Fetching.html#//apple_ref/doc/uid/TP30001011-CH206-TPXREF158">“Batch Faulting”</a></span></p></li></ul><a name="//apple_ref/doc/uid/TP30001011-CH206-BADHCCEE" title="Data Integrity Mechanisms"></a><h2>Data Integrity Mechanisms</h2><p>When you work with an object graph rather than directly with data in a database, you are working with copies of that data. While working with those copies, the integrity of the data within an object graph is crucial. Enterprise Objects uses several mechanisms to ensure the integrity of the data it fetches and manages in its object graphs. These mechanisms are:</p><ul class="ul"><li class="li"><p><strong>Uniquing</strong>—Enterprise Objects maintains the mapping of each enterprise object to its corresponding database row and uses this information to ensure that an object graph does not have multiple objects representing the same database row—that each enterprise object is unique within a given object graph.</p></li><li class="li"><p><strong>Snapshotting</strong>—When Enterprise Objects fetches data, it records the state of the fetched database row in a snapshot. The information in a snapshot is used to support Enterprise Object’s optimistic locking mechanism. It is also used when changes are committed back to a data source to update only the attributes that were changed since the last fetch.</p></li><li class="li"><p><strong>Faults</strong>—The data in the objects at the destination of a fetched object’s relationships doesn’t need to be fetched until it’s actually needed. Until that point, however, a reference to those destination objects may be necessary. These references that don’t contain data are called faults.</p></li></ul><p>These topics are discussed in more detail in the following sections.</p><a name="//apple_ref/doc/uid/TP30001011-CH206-TPXREF147" title="Uniquing"></a><h3>Uniquing</h3><p>Uniquing<a name="//apple_ref/doc/uid/TP30001011-CH206-DontLinkElementID_409"></a> is the mechanism in which Enterprise Objects ensures that a row in a database is associated with only one enterprise object in a given editing context in an application. The uniquing of enterprise objects limits memory usage and guarantees that the enterprise objects you work with represent the state of their associated database rows as they were last fetched into the object graph.</p><p>Without uniquing, a new enterprise object would be created every time you fetch its corresponding row, whether explicitly or through the resolution of relationships. For example, consider the case of a simple relationship between employees and a manager. Bodhi, Brent, and Ernest are represented by employee enterprise objects and Katherine is represented by a manager enterprise object that is the destination of the employee’s <code>manager</code> relationship.</p><p>Without uniquing, when the database row representing Bodhi is fetched, an object representing Bodhi’s manager, Katherine, is created to resolve his <code>manager</code> relationship. Then, when the database row representing Ernest is fetched, another object representing Katherine is created to resolve his <code>manager</code> relationship. If the row representing Katherine is itself explicitly fetched, yet another enterprise object representing Katherine is created. In this scenario, Katherine’s row in the database can be altered by multiple enterprise object instances, resulting in objects that represent the same row but that may contain different and conflicting data.</p><p>With uniquing, however, in a given editing context, only one object representing Katherine is ever created. All the enterprise objects in a given editing context that refer to Katherine’s enterprise object refer to the same instance—they have a single view of Katherine’s data. So within a given editing context, there is no ambiguity with regard to the data in Katherine’s enterprise object. These two scenarios are illustrated in <span class="content_text">Figure 6-4</span>.</p><br/><div><a name="//apple_ref/doc/uid/TP30001011-CH206-DontLinkElementID_40" title="Figure 5-4Unique enterprise objects in an editing context"></a><p><a name="//apple_ref/doc/uid/TP30001011-CH206-TPXREF171" title="Figure 5-4Unique enterprise objects in an editing context"></a><strong>Figure 5-4&nbsp;&nbsp;</strong>Unique enterprise objects in an editing context</p><img src = "../Art/uniquing.gif" alt = "Unique enterprise objects in an editing context" width="444" height="456"></div><br/><p>How does uniquing work? Objects are uniqued based on their global ID. A global ID (<code>com.webobjects.eocontrol.EOGlobalID</code>) is formed from an object’s primary key and its associated entity. When a row is fetched to create an object in a particular editing context, its global ID is checked against the objects already in the editing context. If a match is found, the newly fetched object isn’t added to the context.</p><p>A single enterprise object instance exists in one and only one EOEditingContext, but multiple copies of an object can exist in different editing contexts. In other words, the scope of object uniquing is a particular editing context.</p><a name="//apple_ref/doc/uid/TP30001011-CH206-TPXREF148" title="Snapshotting"></a><h3>Snapshotting</h3><p>When an EODatabaseContext fetches objects from a database, a snapshot is recorded of the state of the fetched database row. A snapshot<a name="//apple_ref/doc/uid/TP30001011-CH206-DontLinkElementID_410"></a> is a dictionary of a row’s primary keys, class properties, foreign keys used in relationships that are class properties, and the attributes of an entity that participate in optimistic locking. To learn how snapshots participate in optimistic locking, see <span class="content_text"><a href="../UpdateStrategies/UpdateStrategies.html#//apple_ref/doc/uid/TP30001011-CH209-TPXREF168">“Inside Optimistic Locking.”</a></span></p><p>You can imagine that an application that fetches hundreds of rows of data builds up a large cache of snapshots. Theoretically, if enough fetches are performed, an Enterprise Objects application can contain all the contents of a database in memory. Clearly, snapshots must be managed in order to prevent this situation.</p><p>So how are snapshots cleaned up? This is the responsibility of a mechanism called snapshot reference counting. This mechanism keeps track of the enterprise objects that are associated with a particular snapshot—enterprise objects that contain data from a particular snapshot. When there are no remaining enterprise object instances associated with a particular snapshot (which Enterprise Objects determines by maintaining a list of these references), that snapshot is released.</p><p>Snapshot reference counting is handled automatically by the framework, so you don’t need to think about it.</p><a name="//apple_ref/doc/uid/TP30001011-CH206-TPXREF149" title="Uniquing and Faulting"></a><h3>Uniquing and Faulting</h3><p>When a fault is constructed for a to-one relationship, the global ID for that fault is checked to see if the fault or its fully initialized enterprise object counterpart already exists in a given editing context. If so, that object is used to immediately resolve the relationship. This preserves the uniqueness requirement for enterprise objects by ensuring that there’s never more than one global ID representing the same row in the database. Whether that global ID represents an actual enterprise object or a fault doesn’t matter, since the data is fetched when it’s needed.</p><p>If Enterprise Objects fetches data for an object that’s already been created as a fault, that fault is fired and the enterprise object finishes initializing.</p><a name="//apple_ref/doc/uid/TP30001011-CH206-BADDGFAG" title="Ensuring Fresh Data"></a><h2>Ensuring Fresh Data</h2><p>When developing Enterprise Objects applications, one of the most common challenges is providing users with the freshest<a name="//apple_ref/doc/uid/TP30001011-CH206-DontLinkElementID_411"></a> possible data while maintaining reasonable application performance. In a multiuser database environment, there is a risk of update conflicts occurring in which multiple users access and attempt to change the same set of data simultaneously. Providing fresher data to users can help alleviate update conflicts. The philosophy of update conflicts is discussed in <span class="content_text"><a href="../UpdateStrategies/UpdateStrategies.html#//apple_ref/doc/uid/TP30001011-CH209-TP1">“Update Strategies.”</a></span> </p><p>This section helps you understand when and how Enterprise Objects uses cached data and how you can influence the caching architecture.</p><a name="//apple_ref/doc/uid/TP30001011-CH206-TPXREF173" title="When Does Database Fetching Occur?"></a><h3>When Does Database Fetching Occur?</h3><p>The first thing to understand when dealing with the issue of data freshness is to understand when Enterprise Objects uses cached data and when it fetches<a name="//apple_ref/doc/uid/TP30001011-CH206-DontLinkElementID_412"></a> data from a database. In most cases, if an editing context asks an enterprise object for its data, it receives cached data unless:</p><ul class="spaceabove"><li class="li"><p>the timestamp of the snapshots of enterprise objects are older than the editing context’s timestamp</p></li><li class="li"><p>the enterprise object has been invalidated</p></li><li class="li"><p>the enterprise object is a fault (its data hasn’t yet been fetched)</p></li></ul><p>When multiple users access the same data source by sharing an application instance, they most often share data caches. <em>This means that one user’s data query may not actually invoke a fetch from the data source if the data requested has already been fetched by another user and so exists in the cache.</em> A common design pattern for this situation is to provide each user with a separate snapshot cache, as discussed in <span class="content_text"><a href="../Geography/Geography.html#//apple_ref/doc/uid/TP30001011-CH205-TPXREF146">“Providing Separate Stacks.”</a></span> But even in this scenario, a user’s fetch request may not actually trigger a fetch from the database if the requested data has already been retrieved by an earlier fetch made by that user.</p><a name="//apple_ref/doc/uid/TP30001011-CH206-TPXREF174" title="Distributed Change Notification?"></a><h3>Distributed Change Notification?</h3><p>Often, the issue of fresh data occurs when multiple users are using different application instances that all access the same data source. You want to ensure that changes one user makes are reflected in other user’s applications. Unfortunately, Enterprise Objects does not include a distributed change notification<a name="//apple_ref/doc/uid/TP30001011-CH206-DontLinkElementID_413"></a> mechanism to help you with this problem (though third parties have developed solutions). </p><p>But a distributed change notification mechanism isn’t necessarily the solution. In any multiwriter database environment in which multiple users have concurrent write access to the same database, it is fundamentally impossible to guarantee fresh data. In this scenario, recovery is a better mechanism than prevention.</p><p>That is, instrumenting your applications to be resilient when update conflicts occur is a more reasonable approach than trying to prevent update conflicts altogether. Strategies for implementing resiliency are discussed in <span class="content_text"><a href="../UpdateStrategies/UpdateStrategies.html#//apple_ref/doc/uid/TP30001011-CH209-TP1">“Update Strategies.”</a></span> That said, a mix of prevention and recovery is probably the best solution for most cases. The following sections discuss the built-in prevention mechanisms provided by the Enterprise Object frameworks.</p><a name="//apple_ref/doc/uid/TP30001011-CH206-TPXREF175" title="Fetch Timestamp"></a><h3>Fetch Timestamp</h3><p>Each editing context in an application includes a fetch timestamp that it uses to tell its parent object store that it wants cached data or fresh data from the database. An editing context prefers data that was fetched on or after an absolute time that is tracked by an editing context’s <a name="//apple_ref/doc/uid/TP30001011-CH206-DontLinkElementID_414"></a><a name="//apple_ref/doc/uid/TP30001011-CH206-DontLinkElementID_415"></a><strong>fetch timestamp</strong>. (Ultimately, an editing context’s parent object store decides when to perform database fetches. In the default case, an editing context’s parent object store does honor its editing context’s fetch timestamps, but this may not be the case for all object stores).</p><p>When enterprise objects are requested from an editing context, the editing context sends this request along with a fetch timestamp to its parent object store. If the requested enterprise objects have already been fetched, the parent object store finds the snapshots of those enterprise objects and compares their fetch timestamps with the fetch timestamp sent by the editing context that requested the objects.</p><p>If the timestamp of the snapshots from which the requested enterprise objects were formed is older than the editing context’s fetch timestamp, the snapshots are considered stale and fresh values for those enterprise objects are requested from the database. Otherwise, cached enterprise object values are used (these cached values are in the database context’s snapshots).</p><a name="//apple_ref/doc/uid/TP30001011-CH206-TPXREF176" title="Timestamp Lag"></a><h3>Timestamp Lag</h3><p>An editing context’s fetch timestamp is set to the time of a fetch minus the default timestamp lag<a name="//apple_ref/doc/uid/TP30001011-CH206-DontLinkElementID_416"></a><a name="//apple_ref/doc/uid/TP30001011-CH206-DontLinkElementID_417"></a>. The default lag is sixty minutes so the default fetch timestamp on an application’s editing contexts is one hour before a fetch occurred. So, if the timestamp of an enterprise object’s snapshots in the database context are within an hour of the fetch timestamp of the object’s editing context, a fetch returns the cached data in those snapshots rather than refetching from the database. However, if the timestamp of the snapshots in the database context are older than an hour (or older than the editing context’s fetch timestamp), the snapshots are discarded and data is refetched from the database.</p><p>A common design pattern is to set the default timestamp lag to a smaller number to encourage more refetching from the database. You can change the default timestamp lag for all the editing contexts in an application using the static method on EOEditingContext called <code>setDefaultFetchTimestampLag<a name="//apple_ref/doc/uid/TP30001011-CH206-DontLinkElementID_418"></a></code>. In some cases, you may want to explicitly set the fetch timestamp of a particular editing context to encourage refetching of its data. You can do this by invoking <code>setFetchTimestamp<a name="//apple_ref/doc/uid/TP30001011-CH206-DontLinkElementID_419"></a></code> on an editing context. </p><p>Nested editing contexts use the fetch timestamp of their parent, so applications that make heavy use of nested editing contexts may have to take additional measures to ensure fresh data.</p><a name="//apple_ref/doc/uid/TP30001011-CH206-TPXREF177" title="Other Mechanisms to Ensure Freshness"></a><h3>Other Mechanisms to Ensure Freshness</h3><p>Enterprise Objects provides other mechanisms to ensure the freshness of data in enterprise objects. By using the method <code>refreshesRefetchedObjects<a name="//apple_ref/doc/uid/TP30001011-CH206-DontLinkElementID_420"></a></code>, you force data values to be updated with fresh values from the data source when those objects are refetched. Using <code>refreshesRefetchedObjects</code> is described in <span class="content_text"><a href="../Managing/Managing.html#//apple_ref/doc/uid/TP30001011-CH207-BBBDJJGJ">“Refreshing Cached Data.”</a></span></p><p>Another, more severe mechanism to ensure fresh data is the method <code>invalidateObjectsWithGlobalIDs<a name="//apple_ref/doc/uid/TP30001011-CH206-DontLinkElementID_421"></a></code> on EOEditingContext, which flushes all the snapshots corresponding to the given global IDs and refetches those snapshot’s rows. It has an even more severe counterpart, <code>invalidateAllObjects<a name="//apple_ref/doc/uid/TP30001011-CH206-DontLinkElementID_422"></a></code>. These are rather drastic measures that you should use cautiously. See <span class="content_text"><a href="../Managing/Managing.html#//apple_ref/doc/uid/TP30001011-CH207-BBBFEHHF">“Discarding Cached Objects”</a></span> for more information.</p><p>As an alternative to both, you should instead consider using the method <code>setFetchTimestampLag</code> along with <code>refaultAllObjects<a name="//apple_ref/doc/uid/TP30001011-CH206-DontLinkElementID_423"></a></code> or <code>refreshAllObjects<a name="//apple_ref/doc/uid/TP30001011-CH206-DontLinkElementID_424"></a></code> on an editing context to update the data in enterprise objects in a given editing context.</p><a name="//apple_ref/doc/uid/TP30001011-CH206-TPXREF151" title="Advanced Faulting"></a><h2>Advanced Faulting</h2><p>This section discusses the advanced faulting techniques available in Enterprise Objects.</p><a name="//apple_ref/doc/uid/TP30001011-CH206-TPXREF157" title="Deferred Faulting"></a><h3>Deferred Faulting</h3><p>As described in <span class="content_text"><a href="Fetching.html#//apple_ref/doc/uid/TP30001011-CH206-BADGBHAJ">“Faulting and Relationship Resolution,”</a></span> Enterprise Objects uses faults to improve application performance. Fault creation is much faster than enterprise object creation and faults consume fewer resources than whole enterprise object instances. However, fault instantiation still takes time. To improve performance even further, Enterprise Objects uses <strong>deferred faults</strong><a name="//apple_ref/doc/uid/TP30001011-CH206-DontLinkElementID_425"></a><a name="//apple_ref/doc/uid/TP30001011-CH206-DontLinkElementID_426"></a>.</p><p>In an enterprise object class that can use deferred faulting, the object’s relationships are initialized as deferred faults. For a particular relationship, a single deferred fault is shared between all instances of an enterprise object class. This sharing can significantly reduce the number of faults that need to be created and usually reduces the overhead of fault creation during a fetch.</p><p>For example, consider a Listing entity that has an <code>agent</code> relationship. Assuming the worst case in which each Listing enterprise object has a different Agent enterprise object, without deferred faulting, a fetch of twenty Listing objects results in the creation of twenty faults for the <code>agent</code> relationship—a fault for each Listing. With deferred faulting, only one fault is created—a deferred fault that is shared by all the Listing objects.</p><p>If you use EOGenericRecord subclasses for your custom enterprise object classes as described in <span class="content_text"><a href="../EnterpriseObjects/EnterpriseObjects.html#//apple_ref/doc/uid/TP30001011-CH203-CEHDAFBJ">“Which Enterprise Object Class?,”</a></span> those classes automatically use deferred faulting. If your custom enterprise object classes instead inherit from EOCustomObject and you want to enable deferred faulting in them, override the method <code>usesDeferredFaultCreation</code><a name="//apple_ref/doc/uid/TP30001011-CH206-DontLinkElementID_427"></a> to return <code>true</code> in those classes, as <span class="content_text"><a href="../EnterpriseObjects/EnterpriseObjects.html#//apple_ref/doc/uid/TP30001011-CH203-CEHHIGII">Listing 3-2</a></span> does. In those classes, you must also invoke <code>willReadRelationship</code><a name="//apple_ref/doc/uid/TP30001011-CH206-DontLinkElementID_428"></a> before accessing a relationship that might be a deferred fault.</p><div class="notebox"><a name="//apple_ref/doc/uid/TP30001011-CH206-DontLinkElementID_41" title="Note"></a><p><strong>Note:</strong>&nbsp;If your custom classes inhert from EOCustomObject and those classes use entity inheritance, they <em>must</em> use deferred faulting. A relationship whose destination entity is an inherited entity must be deferred.</p></div><a name="//apple_ref/doc/uid/TP30001011-CH206-TPXREF158" title="Batch Faulting"></a><h3>Batch Faulting</h3><p>Another advanced faulting feature is <strong>batch faulting</strong><a name="//apple_ref/doc/uid/TP30001011-CH206-DontLinkElementID_429"></a><a name="//apple_ref/doc/uid/TP30001011-CH206-DontLinkElementID_430"></a>. When a fault is fired, its data is fetched from the database. However, firing one fault has no effect on other faults—firing one fault just fetches the object or objects for the one fault. By batching fault firings together, you can more efficiently use the round trip to the database that is necessary when a single fault is fired.</p><p>For example, given an array of Employee enterprise objects, you can fetch all of the objects that are the destination of their <code>department</code> relationship with one round trip to the server. Without batch faulting, a round trip to the database is made to resolve each Employee’s <code>department</code> relationship.</p><p>There are a number of ways to implement batch faulting. You can configure batch faulting in three contexts: on entities, on relationships, and on relationships under certain circumstances.</p><p>You configure batch faulting for an entity in EOModeler in an entity’s advanced inspector, as shown in <span class="content_text">Figure 6-5</span>. The integer you specify in the Batch Faulting Size field specifies the number of faults to fire the first time a fault is fired for any relationship in that entity. You can set this size programmatically using the method in EOEntity called <code>setMaxNumberOfInstancesToBatchFetch<a name="//apple_ref/doc/uid/TP30001011-CH206-DontLinkElementID_431"></a></code>. </p><br/><div><a name="//apple_ref/doc/uid/TP30001011-CH206-DontLinkElementID_42" title="Figure 5-5Configure batch faulting for an entity"></a><p><a name="//apple_ref/doc/uid/TP30001011-CH206-BADFDHFE" title="Figure 5-5Configure batch faulting for an entity"></a><strong>Figure 5-5&nbsp;&nbsp;</strong>Configure batch faulting for an entity</p><img src = "../Art/batchfaultingonentity.gif" alt = "Configure batch faulting for an entity" width="294" height="392"></div><br/><p>You can also specify a batch faulting size for a particular relationship. The easiest and most common way to do this is in EOModeler using the advanced relationship inspector, which is shown in <span class="content_text">Figure 6-6</span>. The batch size specifies the number of faults to fire when the first fault in the relationship is fired.</p><br/><div><a name="//apple_ref/doc/uid/TP30001011-CH206-DontLinkElementID_43" title="Figure 5-6Configure batch faulting for a relationship"></a><p><a name="//apple_ref/doc/uid/TP30001011-CH206-BADBEDAG" title="Figure 5-6Configure batch faulting for a relationship"></a><strong>Figure 5-6&nbsp;&nbsp;</strong>Configure batch faulting for a relationship</p><img src = "../Art/modelerbatchfaulting.gif" alt = "Configure batch faulting for a relationship" width="294" height="393"></div><br/><p>Finally, you can take more precise control of batch faulting by explicitly batching together faults for particular objects. When you specify the batch size in EOModeler for all of an entity’s relationships or for particular relationships, you don’t actually control which faults are fired. The method <code>batchFetchRelationship<a name="//apple_ref/doc/uid/TP30001011-CH206-DontLinkElementID_432"></a></code> in EODatabaseContext allows you to batch fetch all of the faults in a particular relationship. The method <code>databaseContextShouldFetchArrayFault<a name="//apple_ref/doc/uid/TP30001011-CH206-DontLinkElementID_433"></a></code> in EODatabaseContext.Delegate allows you to turn batch faulting on and off arbitrarily. See the API reference for EODatabaseContext and EODatabaseContext.Delegate for more details.</p><a name="//apple_ref/doc/uid/TP30001011-CH206-TPXREF152" title="Advanced Fetching"></a><h2>Advanced Fetching</h2><p>Enterprise Objects supports a number of advanced fetching techniques.</p><a name="//apple_ref/doc/uid/TP30001011-CH206-TPXREF159" title="Prefetching"></a><h3>Prefetching</h3><p>As described in <span class="content_text"><a href="Fetching.html#//apple_ref/doc/uid/TP30001011-CH206-BADGBHAJ">“Faulting and Relationship Resolution,”</a></span> when Enterprise Objects fetches an enterprise object, it creates faults for the object’s relationships. Each time a fault is fired, a round trip is made to the database to retrieve the fault’s data. You can batch together fault firing as described in <span class="content_text"><a href="Fetching.html#//apple_ref/doc/uid/TP30001011-CH206-TPXREF158">“Batch Faulting”</a></span> to reduce the number of round trips to the database. However, you can go even further in reducing the number of round trips to the database by <strong>prefetching</strong><a name="//apple_ref/doc/uid/TP30001011-CH206-DontLinkElementID_434"></a> all the objects in a particular relationship. Prefetching allows you to anticipate that some of an enterprise object’s relationships will be fetched and provides a mechanism to preload them; it provides a performance opportunity. </p><p>For example, consider a Listing entity that has an <code>agent</code> relationship. When you fetch twenty Listing objects, faults are created for each Listing’s <code>agent</code> relationship. When the data in the <code>agent</code> relationship is accessed for a particular Listing object, a fault is fired to retrieve the relationship’s data, which invokes a round trip to the database. Implementing batch faulting reduces the number of round trips but you can further reduce the number of round trips by simply prefetching <em>all</em> of the agent data in the database. With prefetching, when a fetch is performed for a particular entity, the objects in the relationships specified by the prefetching key paths (<code>agent</code> in this case) are immediately fetched.</p><p>You instrument your application for prefetching<a name="//apple_ref/doc/uid/TP30001011-CH206-DontLinkElementID_435"></a> by configuring certain fetch specifications for prefetching. You can use the Prefetching pane of EOModeler’s fetch specification builder to configure it for a particular fetch specification or you can invoke <code>setPrefetchingRelationshipKeyPaths</code><a name="//apple_ref/doc/uid/TP30001011-CH206-DontLinkElementID_436"></a> on a fetch specification, which takes an array of strings representing the relationships to prefetch.</p><p>There are a few guidelines to consider when using prefetching. First, if memory usage is an issue for your application rather than database performance, don’t use prefetching as it consumes more memory. In fact, prefetching can consume an inordinate amount of memory depending on the size of the data set, so it’s probably more appropriate to prefetch only those relationships that have a small number of destination objects.</p><p>Second, don’t use prefetching on a fetch specification that uses a fetch limit. The prefetching hint ignores the fetch limit. </p><p>Third, don’t use prefetching when performing multiple queries that return the same records. The performance benefits of prefetching are negated by the overhead of re-creating enterprise objects of the same rows of data multiple times.</p><a name="//apple_ref/doc/uid/TP30001011-CH206-TPXREF160" title="Entity Caching"></a><h3>Entity Caching</h3><p>Many applications have read-only entities that contain static data such as lists of states and countries, building names, or department names. Since many users of an application use the data in these entities, it makes sense to cache<a name="//apple_ref/doc/uid/TP30001011-CH206-DontLinkElementID_437"></a> the data in memory to reduce the number of fetches to the database. In Enterprise Objects, you can cache an entire table in memory, thereby eliminating unnecessary fetches for the same static data by multiple users.</p><p>To enable entity caching for an entity, select the Cache In Memory option in EOModeler’s advanced entity inspector for a particular entity, as shown in <span class="content_text">Figure 6-7</span>. You can enable this option programmatically using the method <code>setCachesObjects</code><a name="//apple_ref/doc/uid/TP30001011-CH206-DontLinkElementID_438"></a> on EOEntity.</p><br/><div><a name="//apple_ref/doc/uid/TP30001011-CH206-DontLinkElementID_44" title="Figure 5-7Enable entity caching"></a><p><a name="//apple_ref/doc/uid/TP30001011-CH206-BADDCFGC" title="Figure 5-7Enable entity caching"></a><strong>Figure 5-7&nbsp;&nbsp;</strong>Enable entity caching</p><img src = "../Art/modelercacheentity.gif" alt = "Enable entity caching" width="292" height="393"></div><br/><p>When entity caching is enabled for a particular entity, the first fetch of that entity’s table causes the whole table to be fetched into memory. Clearly, this option is appropriate only for tables with a small number of rows.</p><p>An entity’s cache of objects is maintained by an EODatabaseContext. If you provide a separate access layer stack for each user as described in <span class="content_text"><a href="../Geography/Geography.html#//apple_ref/doc/uid/TP30001011-CH205-TPXREF146">“Providing Separate Stacks,”</a></span> each session has its own EODatabaseContext, so bear in mind that entity caching in this scenario may consume a lot of memory.</p><a name="//apple_ref/doc/uid/TP30001011-CH206-TPXREF161" title="Raw Row Fetching"></a><h3>Raw Row Fetching</h3><p>Fetch specifications provide an option to fetch<a name="//apple_ref/doc/uid/TP30001011-CH206-DontLinkElementID_439"></a><a name="//apple_ref/doc/uid/TP30001011-CH206-DontLinkElementID_440"></a><a name="//apple_ref/doc/uid/TP30001011-CH206-DontLinkElementID_441"></a> raw rows. When you use raw row fetching, database rows that are fetched are not automatically transformed into enterprise object instances. There are a number of reasons why you’d want to specify raw row fetching for a particular fetch specification. These include:</p><ul class="spaceabove"><li class="li"><p>reducing memory usage when fetching large data sets</p></li><li class="li"><p>improving application performance when fetching large data sets</p></li><li class="li"><p>reducing the general overhead of an application instance</p></li></ul><p>You can specify raw row fetching for a particular fetch specification either in EOModeler’s fetch specification builder or by invoking the method <code>setFetchesRawRows<a name="//apple_ref/doc/uid/TP30001011-CH206-DontLinkElementID_442"></a></code> on a fetch specification. You can more closely control which rows are fetched as raw rows using the method <code>setRawRowKeyPaths<a name="//apple_ref/doc/uid/TP30001011-CH206-DontLinkElementID_443"></a></code> on a fetch specification.</p><p>When you fetch raw rows, you lose many of the benefits of using full-fledged enterprise object instances such as the object graph, change notifications, and so forth. But many of the cases in which you need to fetch raw rows involve fetching large data sets that don’t need the benefits of the object graph, so this is an acceptable trade-off in light of the performance benefits of raw row fetching.</p><p>Plus, you can always instantiate an enterprise object of that row using the method <code>faultForRawRow<a name="//apple_ref/doc/uid/TP30001011-CH206-DontLinkElementID_444"></a></code> on an EOEditingContext.</p><a name="//apple_ref/doc/uid/TP30001011-CH206-TPXREF162" title="Raw SQL Fetching"></a><h3>Raw SQL Fetching</h3><p>Although fetch specifications are the most common type of objects used to fetch data in Enterprise Objects applications, a lighter-weight mechanism is also provided that fetches raw rows based on an SQL<a name="//apple_ref/doc/uid/TP30001011-CH206-DontLinkElementID_445"></a><a name="//apple_ref/doc/uid/TP30001011-CH206-DontLinkElementID_446"></a> expression you provide. This mechanism is provided as a method called <code>rawRowsForSQL</code><a name="//apple_ref/doc/uid/TP30001011-CH206-DontLinkElementID_447"></a> on the EOUtilities class. You pass to the method as arguments an editing context, a String representing the model that contains the entities on which to perform to the fetch, and a valid SQL expression. The results are returned as raw rows rather than as full-fledged enterprise objects.</p><a name="//apple_ref/doc/uid/TP30001011-CH206-TPXREF150" title="Common Delegate Usage"></a><h2>Common Delegate Usage</h2><div class="notebox"><a name="//apple_ref/doc/uid/TP30001011-CH206-DontLinkElementID_45" title="Note"></a><p><strong>Note:</strong>&nbsp;This section is intended for experts.</p></div><p>A number of control points are provided that let you customize fetch operations in Enterprise Objects applications. <span class="content_text">Table 6-2</span> lists the delegate methods in EODatabaseContext that you can use to customize fetch operations. </p><p>You can set the delegate of EODatabaseContext by invoking the class method <code>EODatabaseContext.setDefaultDelegate</code>.</p><a name="//apple_ref/doc/uid/TP30001011-CH206-DontLinkElementID_46" title="Table 5-2EODatabaseContext delegate methods"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><a name="//apple_ref/doc/uid/TP30001011-CH206-BADHGFAB" title="Table 5-2EODatabaseContext delegate methods"></a><strong>Table 5-2&nbsp;&nbsp;</strong>EODatabaseContext delegate methods</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Method</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Description</p></th></tr><tr><td  scope="row"><p><code>databaseContextShouldSelectObjects</code></p></td><td ><p>Invoked just before a <code>SELECT</code> operation occurs. Use this delegate method to return <code>false</code> to tell the adaptor channel to skip the <code>SELECT</code>. You might want to do this to issue your own custom SQL to the adaptor.</p></td></tr><tr><td  scope="row"><p><code>databaseContextShouldUsePessimisticLock</code></p></td><td ><p>Use this delegate method to selectively turn off the locking of rows when you’re using a pessimistic locking strategy.</p></td></tr><tr><td  scope="row"><p><code>databaseContextDidSelectObjects</code></p></td><td ><p>Invoked immediately after a <code>SELECT</code> operation occurs. You can use it to log diagnostic information or initialize internal state for subsequent fetches.</p></td></tr><tr><td  scope="row"><p><code>databaseContextShouldFetchObjects</code></p></td><td ><p>Use this method to satisfy an editing context’s fetch request from its snapshot cache.</p></td></tr><tr><td  scope="row"><p><code>databaseContextDidFetchObjects</code></p></td><td ><p>Invoked after an EODatabaseContext fetches objects. Use it to record in a local cache the results of a fetch.</p></td></tr><tr><td  scope="row"><p><code>databaseContextFailedToFetchObject</code></p></td><td ><p>Invoked when a to-one fault cannot find its data in the database. Use this method to immediately throw an exception.</p></td></tr><tr><td  scope="row"><p><code>databaseContextShouldLockObjectWithGlobalID</code></p></td><td ><p>Invoked from <code>lockObjectWithGlobalID</code>. Use it to implement custom locking.</p></td></tr><tr><td  scope="row"><p><code>databaseContextShouldRaiseExceptionForLockFailure</code></p></td><td ><p>Use this method to suppress an exception that occurs when EODatabaseContext attempts to lock an object.</p></td></tr><tr><td  scope="row"><p><code>databaseContextShouldUpdateCurrentSnapshot</code></p></td><td ><p>Invoked when an EODatabaseContext already has a snapshot for a row fetched from the database. Use it to compare the snapshots and possibly resolve conflicts.</p></td></tr></table></div><a name="//apple_ref/doc/uid/TP30001011-CH206-TPXREF153" title="Constructing Fetch Specifications"></a><h2>Constructing Fetch Specifications</h2><p>You commonly create and configure fetch<a name="//apple_ref/doc/uid/TP30001011-CH206-DontLinkElementID_448"></a> specifications using EOModeler’s fetch specification builder. This is described in the chapter “Working With Fetch Specifications” in <em><a href="../../UsingEOModeler/index.html#//apple_ref/doc/uid/TP30001018" target="_top">EOModeler User Guide</a></em>. However, you also commonly create and configure fetch specifications programmatically, as this section describes.</p><p>As discussed in <span class="content_text"><a href="Fetching.html#//apple_ref/doc/uid/TP30001011-CH206-BADIACBC">“Objects Involved in Fetching,”</a></span> a fetch specification includes an entity name, a qualifier (optional), and a sort ordering (optional). The trickiest part of building a fetch specification programmatically is building qualifiers. The code samples here assume that you’re using the Real Estate model and database.</p><a name="//apple_ref/doc/uid/TP30001011-CH206-TPXREF166" title="Qualifiers"></a><h3>Qualifiers</h3><p>There are many ways to programmatically create a qualifier<a name="//apple_ref/doc/uid/TP30001011-CH206-DontLinkElementID_449"></a>. One of the most common ways is to provide a format string to a qualifier. A format string is a logical expression that specifies parameters for performing a comparison. In a format string, you specify a data attribute to compare and a value with which to compare it. Enterprise Objects supports comparisons of equality, greater than, less than, greater than or equal to, less than or equal to, not equal, like<a name="//apple_ref/doc/uid/TP30001011-CH206-DontLinkElementID_450"></a>, and case–insensitive like<a name="//apple_ref/doc/uid/TP30001011-CH206-DontLinkElementID_451"></a>.</p><p>A format string<a name="//apple_ref/doc/uid/TP30001011-CH206-DontLinkElementID_452"></a><a name="//apple_ref/doc/uid/TP30001011-CH206-DontLinkElementID_453"></a> also includes a conversion character, which specifies the data type of the value in the comparison. <span class="content_text">Table 6-3</span> lists the available conversion characters.</p><a name="//apple_ref/doc/uid/TP30001011-CH206-DontLinkElementID_47" title="Table 5-3Format string conversion characters"></a><div class="tableholder"><table class="graybox" border = "0" cellspacing="0" cellpadding="5"><caption class="tablecaption"><a name="//apple_ref/doc/uid/TP30001011-CH206-BADHFCFD" title="Table 5-3Format string conversion characters"></a><strong>Table 5-3&nbsp;&nbsp;</strong>Format string conversion characters</caption><tr><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Conversion character</p></th><th scope="col" align="left" style="font-weight: bold" bgcolor="#CCCCCC"><p>Expected value or result</p></th></tr><tr><td  scope="row"><p>%s</p></td><td ><p>A String object, or the result of the method <code>toString</code>.</p></td></tr><tr><td  scope="row"><p>%d</p></td><td ><p>An Integer object or something that can be converted to an Integer.</p></td></tr><tr><td  scope="row"><p>%f</p></td><td ><p>A Double object or something that can be converted to a Double.</p></td></tr><tr><td  scope="row"><p>%@</p></td><td ><p>An arbitrary object (like an EOEnterpriseObject). No conversions are performed.</p></td></tr><tr><td  scope="row"><p>%K</p></td><td ><p>Similar to %@ except the argument is coerced into a String with the method <code>toString</code> and is treated as a key that can determine whether the resulting qualifier is an EOKeyValueQualifier or an EOKeyComparisonQualifier.</p></td></tr><tr><td  scope="row"><p>%%</p></td><td ><p>Results in a literal % character.</p></td></tr></table></div><p>The following are examples of qualifier strings:</p><ul class="spaceabove"><li class="li"><p><code>agent.firstName caseInsensitiveLike %@</code></p></li><li class="li"><p><code>bedrooms >= %d</code></p></li><li class="li"><p><code>bathrooms &lt;= %d AND bedrooms = %d</code></p></li></ul><p>The following sections provide code examples that teach you how to build format strings. Many types of format strings are possible; only a few are presented here. See the API reference for <code>com.webobjects.eocontrol.EOQualifier</code> for more information. The following sections provide concrete code examples that show you how to build different kinds of qualifiers, after a section introducing qualifiers.</p><a name="//apple_ref/doc/uid/TP30001011-CH206-BADHFFAI" title="Simple String Qualifier"></a><h3>Simple String Qualifier</h3><p>The code below constructs a qualifier to find the listings associated with a particular agent, based on the agent’s last name.</p><div class="codesample"><table><tr><td scope="row"><pre>EOQualifier.qualifierWithQualifierFormat("agent.lastName = %s", new           NSArray(new Object[] {"Basset", "Travers"}));<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP30001011-CH206-BADCDGCF" title="Simple Integer Qualifier"></a><h3>Simple Integer Qualifier</h3><p>The code below constructs a qualifier to find the listings with at least 3 bedrooms.</p><div class="codesample"><table><tr><td scope="row"><pre>EOQualifier.qualifierWithQualifierFormat("bedrooms >= %d", new NSArray(new Object[] {3}));<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP30001011-CH206-TPXREF167" title="Wildcard Qualifiers"></a><h3>Wildcard Qualifiers</h3><p>The code below constructs a qualifier to find the Listings associated with Agents whose first names begins with the letter b.</p><div class="codesample"><table><tr><td scope="row"><pre>EOQualifier.qualifierWithQualifierFormat("agent.lastName caseInsensitiveLike %@", new           NSArray(new Object[] {"B*"}));<span></span></pre></td></tr></table></div>	<a name="//apple_ref/doc/uid/TP30001011-CH206-TPXREF168" title="Compound Qualifiers"></a><h3>Compound Qualifiers</h3><p>Providing<a name="//apple_ref/doc/uid/TP30001011-CH206-DontLinkElementID_454"></a> a fetch specification with a single qualifier often doesn’t provide the precision you need for search criteria. Fortunately, you can easily form boolean combinations of qualifiers. These types of qualifiers, qualifiers composed of other qualifiers, are called compound qualifiers. Enterprise Objects supports AND, OR, and NOT boolean combinations of qualifiers.</p><p>This code builds a compound qualifier that combines the qualifiers constructed in <span class="content_text"><a href="Fetching.html#//apple_ref/doc/uid/TP30001011-CH206-BADHFFAI">“Simple String Qualifier”</a></span> and in <span class="content_text"><a href="Fetching.html#//apple_ref/doc/uid/TP30001011-CH206-TPXREF167">“Wildcard Qualifiers”</a></span>:</p><div class="codesample"><table><tr><td scope="row"><pre>EOQualifier compoundQualifier = new EOAndQualifier(new NSArray(new Object[]<span></span></pre></td></tr><tr><td scope="row"><pre>     {EOQualifier.qualifierWithQualifierFormat("agent.lastName = %s", new NSArray(new<span></span></pre></td></tr><tr><td scope="row"><pre>       Object[] {"Basset", "Travers"})),<span></span></pre></td></tr><tr><td scope="row"><pre>      EOQualifier.qualifierWithQualifierFormat("agent.lastName caseInsensitiveLike %s",<span></span></pre></td></tr><tr><td scope="row"><pre>        new NSArray(new Object[] {"B*"}))}));<span></span></pre></td></tr></table></div>	<p>This creates a qualifier that searches for the criteria specified in both qualifiers.</p><a name="//apple_ref/doc/uid/TP30001011-CH206-TPXREF156" title="Filtering Fetch Results in Memory"></a><h2>Filtering Fetch Results in Memory</h2><p>A common task related to fetching data is filtering<a name="//apple_ref/doc/uid/TP30001011-CH206-DontLinkElementID_455"></a><a name="//apple_ref/doc/uid/TP30001011-CH206-DontLinkElementID_456"></a> fetch results in memory. Given an array of objects to filter and a qualifier that specifies how to filter them, you can use static methods on EOQualifier<a name="//apple_ref/doc/uid/TP30001011-CH206-DontLinkElementID_457"></a> to sort enterprise objects in memory. The qualifier you use to filter objects in memory is the same type of qualifier you use when fetching data. The method invocation to filter fetch results in memory is:</p><div class="codesample"><table><tr><td scope="row"><pre>EOQualifier.filteredArrayWithQualifier(objects, qualifier);<span></span></pre></td></tr></table></div><p>If you write custom EOQualifier subclasses, they must implement the EOQualifierEvaluation interface if you want them to participate in in-memory filtering.</p><a name="//apple_ref/doc/uid/TP30001011-CH206-TPXREF172" title="Sorting Fetch Results in Memory"></a><h2>Sorting Fetch Results in Memory</h2><p>Another common task related to fetching data is sorting<a name="//apple_ref/doc/uid/TP30001011-CH206-DontLinkElementID_458"></a><a name="//apple_ref/doc/uid/TP30001011-CH206-DontLinkElementID_459"></a> fetch results in memory. Given an array of objects to filter and a sort ordering that specifies how to sort the array, you can use static methods in EOSortOrdering to sort enterprise objects in memory. The qualifier you use to sort objects in memory is the same type of qualifier you use when fetching data.</p><p>For example, to sort an array of enterprise objects in ascending order based on a <code>sellingPrice</code> property, you can use the code in <span class="content_text">Listing 6-1</span>.</p><a name="//apple_ref/doc/uid/TP30001011-CH206-DontLinkElementID_48" title="Listing 5-1Sort fetch results in memory"></a><p class="codesample"><a name="//apple_ref/doc/uid/TP30001011-CH206-BADCDIDC" title="Listing 5-1Sort fetch results in memory"></a><strong>Listing 5-1&nbsp;&nbsp;</strong>Sort fetch results in memory</p><div class="codesample"><table><tr><td scope="row"><pre>NSArray sortedObjects = EOSortOrdering.sortedArrayUsingKeyOrderArray(objectsToSort, new<span></span></pre></td></tr><tr><td scope="row"><pre> NSArray(new Object[] {EOSortOrdering.sortOrderingWithKey("sellingPrice",<span></span></pre></td></tr><tr><td scope="row"><pre> EOSortOrdering.CompareAscending)}));<span></span></pre></td></tr></table></div>	<p><span class="content_text">Listing 6-1</span> illustrates the four objects required for sorting: an array of enterprise objects to sort (<code>objectsToSort</code>), a String representing the property of the enterprise object to sort on (<code>sellingPrice</code>), an NSSelector object representing how to sort the array (<code>EOSortOrdering.CompareAscending</code>), and an EOSortOrdering object that is made up of the <code>sellingPrice</code> String and the <code>EOSortOrdering.CompareAscending</code> NSSelector. You then invoke <code>EOSortOrdering.sortedArrayUsingKeyOrderArray</code> and pass in the array of objects to sort and the EOSortOrdering object. That method returns an array that is sorted with the specified criteria.</p><a name="//apple_ref/doc/uid/TP30001011-CH206-BIECEEAB" title="Accessing Database Keys"></a><h2>Accessing Database Keys</h2><p>One of the great benefits of the Enterprise Objects frameworks is that they insulate you from the complexities of relational databases. It does this in part by managing things like primary and foreign keys for you, automatically.</p><p>However, while developing applications, you may need to access a particular entity’s primary and foreign keys for debugging and other purposes. There are a number of facilities within the frameworks that help you do this. The recommended way is to use a fetch specification to fetch certain rows of data and set that fetch specification to fetch raw rows rather than enterprise objects. The results of the fetch return an array of dictionaries; each dictionary represents one row of data and includes keys for all of an entity’s attributes, whether or not they are class properties.</p><p>For example, consider the Listing entity in the Real Estate model. Perhaps you need to determine the primary key (the <code>listingID</code> attribute) of all the listings in the database and the foreign key for the agent who is responsible for each listing (the <code>agentID</code> attribute). Neither of these properties are class properties in the Listing entity, so invoking the key-value coding method <code>valueForKey("listingID")</code> or <code>valueForKey("agentID")</code> on a Listing enterprise object results in an exception. However, if you construct a fetch specification and set it to fetch raw rows, you can easily retrieve the values for each of these keys.</p><p>The code in <span class="content_text">Listing 6-2</span> provides an example of fetching all Listing records as raw rows and extracting the <code>listingID</code> primary key and the <code>agentID</code> foreign key.</p><a name="//apple_ref/doc/uid/TP30001011-CH206-DontLinkElementID_49" title="Listing 5-2Fetch Listing records as raw rows"></a><p class="codesample"><a name="//apple_ref/doc/uid/TP30001011-CH206-CHHCEBBC" title="Listing 5-2Fetch Listing records as raw rows"></a><strong>Listing 5-2&nbsp;&nbsp;</strong>Fetch Listing records as raw rows</p><div class="codesample"><table><tr><td scope="row"><pre>EOFetchSpecification fs = new EOFetchSpecification("Listing", null, null);<span></span></pre></td></tr><tr><td scope="row"><pre>    fs.setFetchesRawRows(true);<span></span></pre></td></tr><tr><td scope="row"><pre>    NSArray rawRows = editingContext.objectsWithFetchSpecification(fs,         editingContext);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    java.util.Enumeration enum = rawRows.objectEnumerator();<span></span></pre></td></tr><tr><td scope="row"><pre>    while (enum.hasMoreElements()) {<span></span></pre></td></tr><tr><td scope="row"><pre>      NSDictionary row = (NSDictionary)enum.nextElement();<span></span></pre></td></tr><tr><td scope="row"><pre>      if (row != null) {<span></span></pre></td></tr><tr><td scope="row"><pre>        NSLog.out.appendln("\nlistingID pk: " + row.valueForKey("listingID"));<span></span></pre></td></tr><tr><td scope="row"><pre>        NSLog.out.appendln("\nagentID fk: " + row.valueForKey("agentID"));<span></span></pre></td></tr><tr><td scope="row"><pre>      }<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr></table></div>	

        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <a href="../Geography/Geography.html">&lt; Previous Page</a><span style="margin-left: 8px"><a href="../Managing/Managing.html">Next Page &gt;</a></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2002, 2007 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2007-07-11<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/WebObjects/Enterprise_Objects/Fetching/Fetching.html%3Fid%3DTP30001011-3.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/WebObjects/Enterprise_Objects/Fetching/Fetching.html%3Fid%3DTP30001011-3.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/WebObjects/Enterprise_Objects/Fetching/Fetching.html%3Fid%3DTP30001011-3.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>