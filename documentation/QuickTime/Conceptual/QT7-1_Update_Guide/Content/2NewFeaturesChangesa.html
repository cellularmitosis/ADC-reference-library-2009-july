<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
	<title>QuickTime 7.1 Update Guide: New Features, Changes and Enhancements in QuickTime 7.1</title>
	<meta id="Generator" name="Generator" content="Gutenberg"/>
	<meta id="GeneratorVersion" name="GeneratorVersion" content="v132"/>
	<meta http-equiv="content-type" content="text/html;charset=utf-8"/>
	<meta id="Copyright" name="Copyright" content="Copyright 2009 Apple Inc. All Rights Reserved."/>
	<meta id="IndexTitle" name="IndexTitle" content="New Features, Changes and Enhancements in QuickTime 7.1"/>
	<meta id="xcode-display" name="xcode-display" content="render"/>
	<meta id="toc-file" name="toc-file" content="../toc.html"/>
	<meta id="RESOURCES" content="../../../../Resources" />
	
	<link rel="stylesheet" type="text/css" href="../../../../Resources/CSS/frameset_styles.css"/>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/prototype.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/lib/scriptaculous.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/page.js"></script>
	<script language="JavaScript" type="text/javascript" src="../../../../Resources/JavaScript/pedia.js"></script>
	<!--[if lte IE 6]>
		<style type="text/css">
			/*<![CDATA[*/ 
			html {overflow-x:auto; overflow-y:hidden;  }
			/*]]>*/
		</style>
	<![endif]-->
</head>    
<body bgcolor="#ffffff" onload="initialize_page();"><a name="//apple_ref/doc/uid/TP40003543-NewFeaturesChangesandEnhancementsinQuickTime71" title="New Features, Changes and Enhancements in QuickTime 7.1"></a>
    <noscript>
    <div id="tocMenu">
        <iframe id="toc_content" name="toc_content" SRC="../toc.html" width="210" height="100%" align="left" frameborder="0">This document set is best viewed in a browser that supports iFrames.</iframe>
    </div>
    </noscript>
    <div id="bodyText">
        <a name="top"></a>
        <div class="hideOnPrint hideInXcode">
        <!-- start of header -->
        <!--#include virtual="/includes/framesetheader" -->
        <!-- end of header -->
        </div>
        
        <!-- start of path -->
<div class="breadcrumb hideOnPrint hideInXcode"><a href="http://developer.apple.com/" target="_top">ADC Home</a> &gt; <a href="../../../../../referencelibrary/index.html#//apple_ref/doc/uid/TP30000943" target="_top">Reference Library</a> &gt; <a href="../../../../index.html#//apple_ref/doc/uid/TP30000440" target="_top">Guides</a> &gt; <a href="../../../index.html#//apple_ref/doc/uid/TP30000440-TP30000433" target="_top">QuickTime</a> &gt; </div><br class="hideInXcode"/><!-- end of path -->
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <!-- Previous button --><span style="margin-left: 8px"><!-- Next button --></span>
        </span>
        <span id="showHideTOCUpperSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" hideText="Hide TOC" showText="Show TOC" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <hr />
        
        
        <a name="//apple_ref/doc/uid/TP40003543-NewFeaturesChangesandEnhancementsinQuickTime71-SW1" title="New Features, Changes and Enhancements in QuickTime 7.1"></a>
<h1>New Features, Changes and Enhancements in QuickTime 7.1</h1>
<a name="//apple_ref/doc/uid/TP40003543-NewFeaturesChangesandEnhancementsinQuickTime71-DontLinkElementID_4" title="Overview"></a><h2>Overview</h2><p>If you are a developer, the QuickTime Software Development Kit (SDK) allows you to incorporate QuickTime capabilities into your applications developed directly for the Mac OS X and Windows platforms. If you are a Macintosh developer, the SDK provides you with the tools you need to port the QuickTime-based functionality of your application to Windows. This chapter discusses some of the fundamental concepts you need to understand in order to work with QuickTime on both platforms.</p><p>In addition, the chapter describes the new and enhanced features available in QuickTime 7.1. It is intended to provide developers with a conceptual overview, along with code samples and illustrations of usage, so that developers can take advantage of these new features in QuickTime 7.1 in their applications.</p><p>If you are a QuickTime API-level developer, content author, multimedia producer, or Webmaster who is currently working with QuickTime, you should read this chapter.</p><a name="//apple_ref/doc/uid/TP40003543-NewFeaturesChangesandEnhancementsinQuickTime71-QuickTimeinPerspective" title="QuickTime in Perspective"></a>
<h2>QuickTime in Perspective</h2>
<p>The QuickTime API is dedicated to extending the reach of application developers by letting them invoke the full range of multimedia’s capabilities. It supports a wide range of standards-based formats, in addition to proprietary formats from Apple and others. The QuickTime API is not static, however, and has evolved over the course of the last decade to adopt new idioms, new data structures, and new ways of doing things.</p>
<p>The C/C++ portion of the QuickTime API comprises more than 2700 functions that provide services to applications. These services include audio and video capture and playback; movie editing, composition, and streaming; still image import, export, and display; audio-visual interactivity, and more.</p>
<p>A new Cocoa (Objective-C) API for QuickTime, available in Mac OS X v10.4 and v10.3, provides a much less complex programmer interface, and represents a distillation and abstraction of the most essential QuickTime functions as a small set of classes and methods. A great deal of functionality has been packed into a relatively small objective API.</p>
<a name="//apple_ref/doc/uid/TP40003543-NewFeaturesChangesandEnhancementsinQuickTime71-DirectionsandShiftsofEmphasisinQuickTime7" title="Directions and Shifts of Emphasis in QuickTime 7"></a>
<h3>Directions and Shifts of Emphasis in QuickTime 7</h3>
<p>QuickTime 7 includes a number of major new features for users, developers, and content creators, including improvements in the QuickTime architecture, file format, user interface, and API. There are significant improvements in the audio, video, and metadata capabilities, as well as a new Cocoa API, and numerous other enhancements.</p><p>The QuickTime software architecture has been revised to expose platform-native interfaces on Windows to application developers. On Windows, this includes exposing QuickTime framework APIs via COM interfaces (ActiveX).</p><div class="importantbox"><a name="//apple_ref/doc/uid/TP40003543-NewFeaturesChangesandEnhancementsinQuickTime71-DontLinkElementID_19" title="Important:"></a><p><strong>Important:</strong>&nbsp;For developers to take advantage of this revised architecture, QuickTime 7 for Windows has been rewritten from a cross-platform API (QTML) to a Windows-native implementation. This new implementation takes full advantage of the QuickTime COM ActiveX control. Ultimately, QuickTime 7 for Windows replaces the cross-platform application and framework that shipped as QuickTime 6.5 and its predecessors.</p><p></p></div>
<p>Some of the key areas of change in QuickTime 7 include:</p>
<ul class="spaceabove">
<li class="li"><p>A shift of emphasis toward a Core Audio approach to sound, and away from the Sound Manager approach, throughout QuickTime.</p></li>
<li class="li"><p>A shift of emphasis toward configuring components using component properties and an abstraction layer, or context, and away from the exclusive use of standard dialogs supplemented by direct access to low-level components.</p></li>
<li class="li"><p>A shift of emphasis toward a more object-oriented organization, with more high-level functionality in QuickTime itself supporting lighter-weight applications.</p></li>
</ul>

<a name="//apple_ref/doc/uid/TP40003543-NewFeaturesChangesandEnhancementsinQuickTime71-WhatDevelopersNeedToDo" title="What Developers Need To Do"></a>
<h3>What Developers Need To Do</h3>
<p>If you work with audio at a relatively low level, you should become familiar with the Mac OS X Core Audio framework and learn how it differs from the older Sound Manager. The use of Core Audio concepts and data structures has become ubiquitous in QuickTime for both Mac OS X and Windows. For details, see Apple’s <span class="content_text"><a href="http://developer.apple.com/documentation/MusicAudio/Reference/CAFSpec/index.html" target="_top">Core Audio Format Specification</a></span> and the suite of <span class="content_text"><a href="http://developer.apple.com/documentation/MusicAudio/index.html" target="_top">Core Audio Documentation</a></span>.</p><p>For more details, see Apple’s <span class="content_text"><a href="http://developer.apple.com/documentation/MusicAudio/Reference/CoreAudio/index.html" target="_top">Core Audio</a></span> documentation, specifically the in-line comments and documentation in the header file <code>CoreAudioTypes.h</code>. In particular, developers should look closely at the following structures for audio in <code>CoreAudioTypes.h</code>: </p><ul class="spaceabove"><li class="li"><p><code>AudioStreamBasicDescription</code>. This structure encapsulates all the information for describing the basic format properties of a stream of audio data.</p></li><li class="li"><p><code>AudioChannelLayout</code>. This structure is used to specify channel layouts in files and hardware.</p></li><li class="li"><p><code>AudioBufferList</code>. A variable length array of AudioBuffer structures.</p></li></ul>
<p>If you work directly with components, you should become familiar with the API for discovering, getting, and setting component properties. While standard dialogs for configuration are still common, there are often times when either no dialog or an application-specific dialog is preferable, as well as cases where low-level control or device-specific configuration is needed that a standard dialog cannot supply. </p><p>For example, the component property API allows configuration at any level of detail without requiring a user interface dialog or direct communication with low-level components. In many cases, an abstraction layer, or <strong>context</strong> (either visual or audio) can be created, allowing transparent connection to different kinds of low-level components, devices, or rendering engines.</p>
<p>A new extensible QuickTime metadata format uses a similar method of configuration through an abstract set of properties, as a means of “future-proofing” the architecture. The same is true of the new API for working with QuickTime sample tables.</p>
<a name="//apple_ref/doc/uid/TP40003543-NewFeaturesChangesandEnhancementsinQuickTime71-DontLinkElementID_5" title="Advantages For Windows Developers"></a><h3>Advantages For Windows Developers</h3><p>QuickTime 7 for Windows includes a new QuickTime COM/ActiveX control. This new control is fully scriptable from Visual Basic, C#, JavaScript, C++, and other applications that can host COM objects. This allows you to build stand-alone Windows applications that use QuickTime without needing to master QuickTime’s C/C++ API. Note that this new COM control is included in addition to the QuickTime ActiveX browser plug-in. They are not the same thing.</p><p>The new QuickTime COM control, discussed in greater detail in the <em><a href="../../QT7Win_Update_Guide/index.html#//apple_ref/doc/uid/TP40002476" target="_top">QuickTime 7 for Windows Update Guide</a></em> with code samples illustrating usage, has an API that will be familiar to Visual Basic programmers and others used to working with COM objects. It is intended to make it easy to create stand-alone Windows applications that use QuickTime. The new COM control is not a browser plug-in, and will not run in a browser or other Web-based application.</p><p>For Web-based applications, you can use the QuickTime ActiveX browser plug-in; it is scriptable using JavaScript from most browsers using the same platform-independent API as the QuickTime browser plug-ins for Netscape and Safari. The QuickTime browser plug-in is the cross-platform solution for writing Web pages that interact with QuickTime.</p><p>If you are a Visual Basic programmer or enterprise software developer doing in-house development, the COM control implementation offers a number of important advantages:</p><ul class="spaceabove"><li class="li"><p>You can build Windows desktop applications more easily with Visual Basic or C#, combining QuickTime with the rich and powerful .NET Framework.</p></li><li class="li"><p>You can write useful utility scripts for working with QuickTime in either JavaScript or VBScript. These scripts can be run within the Windows Scripting Host environment by simply double-clicking the .js or .vbs script files, or from the command line using cscript.</p></li><li class="li"><p>You don’t have to access the low-level functionality provided by the full QuickTime API in order to use QuickTime in your application development.</p></li></ul><p>For example, if your Windows server can run a Visual Basic, C#, or .js application that uses QuickTime, you have the possibility to create custom QuickTime content interactively, delivering that content over the Web. As long as your clients have QuickTime installed, your content will work with Windows and non-Windows clients, Internet Explorer and non-Internet Explorer browsers.</p><p>QuickTime Player itself uses the new QuickTime COM control for virtually all of its access to QuickTime. Note that the QuickTime 7 ActiveX browser plug-in is not scriptable via Visual Basic. It is scriptable, however, in JavaScript using the same syntax as the Netscape-style plug-in, and works the same on all browsers for Windows or Mac OS X.</p><p>The new COM control is comprised of two separate DLLs: </p><ul class="spaceabove"><li class="li"><p>An COM/ActiveX control (<code>QTOControl.dll</code>) that “knows” how to open a movie and manage the interaction with the operating system and the host application.</p></li><li class="li"><p>A COM library (<code>QTOLibrary.dll</code>) which provides a COM interface to a movie and to QuickTime itself.</p></li></ul><p>The COM library is a very thin layer that sits on top of the low-level QuickTime APIs and provides a COM wrapper object for each logical QuickTime object. Each COM object exposes the properties, methods, and notifications of the QuickTime object it wraps.</p><p>If you are a Windows developer, you know that the Component Object Model (COM) specification defines how a host application accesses the component, how the component notifies the host application of events, standard data types for data exchange with the OS or other components. A COM control is a type of COM component that has a visual display of some kind, restricting its placement to visual containers such as a form or dialog box. COM controls typically manage their own window.</p><p>In the .NET environment, the new QuickTime COM control is accessed via the .NET Framework’s COM Interop layer. Primary Interop Assemblies (<code>.NET</code> wrappers for COM objects) will be provided with the QuickTime 7 SDK.</p><p>Note that the COM control does not provide a native managed code interface to QuickTime.</p>
<a name="//apple_ref/doc/uid/TP40003543-NewFeaturesChangesandEnhancementsinQuickTime71-ObjectModelEvolution" title="Object Model Evolution"></a>
<h3>Object Model Evolution</h3>
<p>A substantial reorganization of the QuickTime engine has taken place “under the hood” in the QuickTime 7 software release. This reorganization is intended to allow increased access to QuickTime functionality from object-oriented frameworks such as Cocoa (Objective-C).</p>
<p>As the QuickTime document object model continues to evolve, the goal is to provide developers with easier access to the more powerful parts of the QuickTime engine using relatively lightweight object-oriented applications or even scripts, without having to delve into the large and sometimes complex procedural C/C++ QuickTime API. If you haven’t experimented with Cocoa and the Xcode tools yet, this is a good time to get started. And if you are a Windows developer, you can take advantage of the new COM/ActiveX control implementation in QuickTIme 7 using the tools available in Visual Basic .NET, C# and Visual Basic 6. </p>

<a name="//apple_ref/doc/uid/TP40003543-NewFeaturesChangesandEnhancementsinQuickTime71-BriefSummaryandReviewofChangesinQuickTime7" title="Brief Summary and Review of Changes in QuickTime 7"></a>
<h3>Brief Summary and Review of Changes in QuickTime 7</h3>
<p>Some of the important changes in QuickTime 7 include</p>
<ul class="spaceabove">
<li class="li"><p>A new user interface for QuickTime Player and QuickTime Pro.</p></li><li class="li"><p>A new COM/ActiveX Control that lets you take advantage of the control using the tools available in Visual Basic .NET, C# and Visual Basic 6.</p></li>
<li class="li"><p>A new Cocoa (Objective-C) framework, <code>QTKit.framework</code>, for developing QuickTime applications. This new API opens the world of QuickTime programming to a new group of developers without requiring them to learn the large, complex C/C++ QuickTime API. The new framework encapsulates a tremendous amount of QuickTime functionality in a small, easily-mastered API with a handful of new objects, classes, and methods.</p></li>
<li class="li"><p>Many new audio features and enhancements, including support for multichannel sound, playback, capture, compression, and export of high-resolution audio, a new sound description, and new functions for movie audio control, audio conversion configuration, audio extraction, movie export, and level and frequency metering.</p></li>
<li class="li"><p>A number of new video enhancements, including support for frame reordering video compression and the H.264 codec. Frame reordering support is a major advance that involves new sample tables for video, allowing video frames to have independent decode and display times. This allows improved display, editing, and compression of H.264 and other advanced video codecs. A new set of functions and structures are introduced to allow developers to work with samples that have independent decode and display times.</p></li>
<li class="li"><p>New abstractions layers for OpenGL rendering and the new Visual Context, an abstraction layer that eliminates dependence on graphics worlds (GWorlds) and supports rendering directly to engines such as OpenGL on Mac OS X and Direct3D on Windows, beginning with QuickTime 7.1.</p></li>
<li class="li"><p>Replacement of <code>NewMovieFrom</code>... functions, which allows you to set up properties before creating a movie. This function also allows you to create movies that are not necessarily associated with a graphics world, movies that can render their output to a visual context, such as an OpenGL texture buffer, and movies that play to a particular audio device.</p></li>
<li class="li"><p>A new QuickTime extensible metadata format, allowing developers to efficiently reference text, audio, video, or other material that describes a movie, a track, or a media. Support is also added for including metadata from other file types in native format; the QuickTime 7 release includes native support for iTunes metadata.</p></li>
<li class="li"><p>QuickTime Sample Table API, a new API for working with QT Sample Tables, which is a logical replacement for arrays of media sample references. The new API greatly extends the functionality of media sample references, and supports frame reordering compressed media.</p></li><li class="li"><p>A new default install location for QuickTime in Windows, which has been moved from the directory <code>\Windows\System32\QuickTime</code> to  <code>\Program Files\QuickTime</code>. A number of new APIs have been created to allow developers to locate the various directories created by the QuickTime installer. New updates and fixes to QuickTime for Java are also included.</p></li>
<li class="li"><p>JavaScript support and accessibility in Safari, including JavaScript support for the Safari browser. This means you can now use JavaScript to control QuickTime when web pages are viewed using Safari.</p></li>
<li class="li"><p>A new persistent cache option, which is important for web authors and content developers to understand because it may impact the way that QuickTime content is downloaded and saved from their websites. New updates and fixes to QuickTime for Java are also included.</p></li>
</ul>


<a name="//apple_ref/doc/uid/TP40003543-NewFeaturesChangesandEnhancementsinQuickTime71-ChangestoQuickTimePlayer" title="Changes to QuickTime Player"></a>
<h2>Changes to QuickTime Player</h2>
<p>QuickTime 7.1 includes a number of changes to the QuickTime Player, discussed in this section.</p>
<a name="//apple_ref/doc/uid/TP40003543-NewFeaturesChangesandEnhancementsinQuickTime71-NewHintTrackPropertyPanel" title="New Hint Track Property Panel"></a>
<h3>New Hint Track Property Panel</h3>
<p>QuickTime Player includes a new hint track property panel for displaying hinted sound and video information to a QuickTime Pro user. Follow these steps:</p><ol class="ol"><li class="li"><p>Launch QuickTime Pro and open a movie with hinted sound and video tracks.</p></li><li class="li"><p>Choose Window > Show Movie Properties.</p></li><li class="li"><p>Select the Streaming Hints tab for a Hinted Sound Track in the track property panel. </p></li></ol>
<p>The following new fields, with corresponding sound and video information, are displayed, as shown in <span class="content_text"><a href="2NewFeaturesChangesa.html#//apple_ref/doc/uid/TP40003543-NewFeaturesChangesandEnhancementsinQuickTime71-SW10">Figure 1-1</a></span>:</p>
<ul class="spaceabove">
<li class="li"><p>Maximum packet duration, in milliseconds</p></li>
<li class="li"><p>Average bit rate, specified in bits per second</p></li><li class="li"><p>Payload type</p></li>
<li class="li"><p>Packet count</p></li>
<li class="li"><p>Maximum packet size, specified in bytes</p></li>
<li class="li"><p>Maximum bit rate, specified in bits per second</p></li>
</ul><br/><div><a name="//apple_ref/doc/uid/TP40003543-NewFeaturesChangesandEnhancementsinQuickTime71-SW10" title="Figure 1-1The new hint track property panel"></a><p><strong>Figure 1-1&nbsp;&nbsp;</strong>The new hint track property panel</p><img src = "../Art/streaming_hints.jpg" alt = "The new hint track property panel" ></div><br/>
<a name="//apple_ref/doc/uid/TP40003543-NewFeaturesChangesandEnhancementsinQuickTime71-DontLinkElementID_6" title="New User Selections for Aperture Mode Support"></a><h3>New User Selections for Aperture Mode Support</h3><p>QuickTime 7.1 provides QuickTime Pro users with the capability of exporting new video content from one size to another while also maintaining––that is, <em>preserving</em>––the aspect ratio for that content, or performing a scaling operation on existing content. Users may choose various export settings to accomplish this. </p><p>The source content may also be tagged with a <strong>clean aperture</strong>, as discussed in the next section, <span class="content_text"><a href="2NewFeaturesChangesa.html#//apple_ref/doc/uid/TP40003543-NewFeaturesChangesandEnhancementsinQuickTime71-SW3">“Improved Visual Quality and New Aperture Mode APIs.”</a></span> The source content may include a clean aperture, or simply be the clean image. The export source dimensions are controlled by the actual dimensions of the source movie while taking into account its aperture mode. </p><p>Follow these steps to export new or existing video content:</p><ol class="ol"><li class="li"><p>Launch QuickTime Pro and open a QuickTime movie.</p></li><li class="li"><p>Choose File > Export.</p></li><li class="li"><p>When the “Save exported file as” dialog appears, select Export: Movie to QuickTime from the items in the list. </p></li><li class="li"><p>Click the Options button and when the Movie Settings dialog appears, click the Size button. The new Export size settings dialog appears, as shown in <span class="content_text">Figure 1-2</span>. This is the default setting. </p></li></ol><br/><div><a name="//apple_ref/doc/uid/TP40003543-NewFeaturesChangesandEnhancementsinQuickTime71-SW12" title="Figure 1-2Export size settings with compressor native dimensions selected"></a><p><strong>Figure 1-2&nbsp;&nbsp;</strong>Export size settings with compressor native dimensions selected</p><img src = "../Art/export_size_comp_native.jpg" alt = "Export size settings with compressor native dimensions selected" ></div><br/><p>In this dialog (<span class="content_text">Figure 1-2</span>), with the compressor native size item selected, the codec has a single active enforced dimension. The size is indicated in the text fields (129 x 103), which are not editable. The Preserve aspect ratio checkbox is not enabled.</p><p>Next, follow these steps:</p><ol class="ol"><li class="li"><p>Click the Video Settings button in the Movie Settings dialog and the Standard Video Compression Settings dialog (shown in <span class="content_text">Figure 1-3</span>) appears.  </p></li><li class="li"><p>Select the compression type from the list of compression displayed, in this case DV/DVCPro - NTSC. </p></li></ol><br/><div><a name="//apple_ref/doc/uid/TP40003543-NewFeaturesChangesandEnhancementsinQuickTime71-SW6" title="Figure 1-3The compression type selected"></a><p><strong>Figure 1-3&nbsp;&nbsp;</strong>The compression type selected</p><img src = "../Art/compression_type_settings.jpg" alt = "The compression type selected" ></div><br/><p>After selecting the compression type, click the Size button in the Movie Settings dialog. The new Export size settings dialog appears (shown in <span class="content_text">Figure 1-4</span>). Note that the NTSC 4:3 aspect ratio is displayed to the right of the text fields. The Preserve aspect ratio box is checked, and the Letterbox menu item appears and can be selected.  </p><br/><div><a name="//apple_ref/doc/uid/TP40003543-NewFeaturesChangesandEnhancementsinQuickTime71-SW11" title="Figure 1-4Export size settings with the NTSC 4:3 aspect ratio displayed"></a><p><strong>Figure 1-4&nbsp;&nbsp;</strong>Export size settings with the NTSC 4:3 aspect ratio displayed</p><img src = "../Art/export_ntsc_aspect_ratio.jpg" alt = "Export size settings with the NTSC 4:3 aspect ratio displayed" ></div><br/><br/><div><a name="//apple_ref/doc/uid/TP40003543-NewFeaturesChangesandEnhancementsinQuickTime71-SW4" title="Figure 1-5Export size settings with current dimensions selected"></a><p><strong>Figure 1-5&nbsp;&nbsp;</strong>Export size settings with current dimensions selected</p><img src = "../Art/export_size_current.jpg" alt = "Export size settings with current dimensions selected" ></div><br/><p>In this dialog (<span class="content_text">Figure 1-5</span>), the current mode is selected from the pulldown menu. The Preserve aspect ratio checkbox is disabled. The current size (129 x 103) is shown in the text fields but cannot be edited.</p><br/><div><a name="//apple_ref/doc/uid/TP40003543-NewFeaturesChangesandEnhancementsinQuickTime71-SW5" title="Figure 1-6Export size settings with custom dimensions selected"></a><p><strong>Figure 1-6&nbsp;&nbsp;</strong>Export size settings with custom dimensions selected</p><img src = "../Art/export_size_custom.jpg" alt = "Export size settings with custom dimensions selected" ></div><br/><p>In this dialog (<span class="content_text">Figure 1-6</span>), the custom mode is selected from the pulldown menu. The Preserve aspect ratio checkbox is enabled and can be selected. All scaling modes are supported. The size fields are editable.</p><br/><div><a name="//apple_ref/doc/uid/TP40003543-NewFeaturesChangesandEnhancementsinQuickTime71-SW7" title="Figure 1-7Export size settings with preserve aspect ratio checkbox and letterbox selected"></a><p><strong>Figure 1-7&nbsp;&nbsp;</strong>Export size settings with preserve aspect ratio checkbox and letterbox selected</p><img src = "../Art/export_size_letterbox.jpg" alt = "Export size settings with preserve aspect ratio checkbox and letterbox selected" ></div><br/><p>In this dialog (<span class="content_text">Figure 1-7</span>), the custom dimensions item is selected. The size (720 x 480) is editable in the text fields. The Preserve aspect ratio checkbox is enabled, and can be selected. All scaling modes, including Letterbox, Crop, and Fit within dimensions, are supported. </p><p>The following options are provided: </p><ul class="spaceabove"><li class="li"><p><strong>Preserve aspect ratio</strong>. When this item is checked, the picture aspect ratio of the source movie is preserved by choosing one of three options:</p><ul class="nested"><li class="nested li"><p><strong>Letterbox</strong>. This scales the source proportionally to fit in the clean aperture of the destination, adding black bars on the top/bottom or left/right as necessary.</p></li><li class="nested li"><p><strong>Crop</strong>. Scales the source and trims to fit the clean aperture of the destination, centered.</p></li><li class="nested li"><p><strong>Fit within dimensions</strong>. Adjusts the destination size so that the source fits within the selected dimensions by fitting to the shortest side, and scales the source to the destination.</p></li></ul><p>Note that when the Preserve aspect ratio checkbox is not checked, the source image is stretched to fit the destination size. </p></li></ul><br/><div><a name="//apple_ref/doc/uid/TP40003543-NewFeaturesChangesandEnhancementsinQuickTime71-SW8" title="Figure 1-8Selecting the NTSC aspect ratio "></a><p><strong>Figure 1-8&nbsp;&nbsp;</strong>Selecting the NTSC aspect ratio </p><img src = "../Art/export_size_ntsc.jpg" alt = "Selecting the NTSC aspect ratio" ></div><br/><p>In this dialog (<span class="content_text">Figure 1-8</span>), with the current dimensions item selected, the user may select the dimensions and the aspect ratio, in this case NTSC 720 x 480 16:9. </p><br/><div><a name="//apple_ref/doc/uid/TP40003543-NewFeaturesChangesandEnhancementsinQuickTime71-SW9" title="Figure 1-9MPEG-4 export settings dialog with a Preserve aspect ratio checkbox"></a><p><strong>Figure 1-9&nbsp;&nbsp;</strong>MPEG-4 export settings dialog with a Preserve aspect ratio checkbox</p><img src = "../Art/mpeg4_preserve_aspect.jpg" alt = "MPEG-4 export settings dialog with a Preserve aspect ratio checkbox" ></div><br/><p>When the Save exported file as... dialog opens, you select Export: Movie to MPEG-4 and click the Options button. The MPEG-4 export setting dialog appears with the video tab selected (<span class="content_text">Figure 1-9</span>). If you click the Preserve aspect ratio checkbox, the Letterbox menu item is hilited, and you have the choice of selecting the Letterbox, Crop, or Fit within size items. </p>
<a name="//apple_ref/doc/uid/TP40003543-NewFeaturesChangesandEnhancementsinQuickTime71-SW3" title="Improved Visual Quality and New Aperture Mode APIs"></a><h2>Improved Visual Quality and New Aperture Mode APIs</h2><p>Before discussing the new aperture mode APIs available in QuickTime 7.1, it may be useful to understand a few key terms: </p><ul class="ul"><li class="li"><p><strong>Clean aperture</strong>. The region of video that is clean of transition artifacts due to the encoding of the signal. This is the region of video that should be displayed to users.</p></li><li class="li"><p><strong>Pixel aspect ratio</strong>. The aspect ratio of the raw pixels in the source media. Typical picture aspect ratios are square (1:1), 10:11, and so on.</p></li><li class="li"><p><strong>Picture aspect ratio</strong>. The aspect ratio of the picture. Some typical picture aspect ratios are 4:3 and 16:9.</p></li><li class="li"><p><strong>Conforming</strong>. The process of adding or adjusting a movie to allow for video correction.</p></li></ul><p>Typically, QuickTime tracks have a specified width and height in pixels. They are transformed into the movie coordinate system by a matrix and clip. The movie box is the bounding box of all the transformed tracks. A QuickTime movie is transformed into the display coordinate system by another matrix and clip. Both the movie and the display coordinate system are to be square.</p><p>An implicit scaling occurs between the image description width and height and the track width and height. Multiple image descriptions may exist in one track; each sample is scaled appropriately from the sample dimensions to the track dimensions.</p><p>There is no correction for the pixel aspect ratio or clean aperture between the sample and the track. Information about pixel aspect ratios and clean aperture may be stored in the sample description but is generally ignored. For example, DV movies are saved as 720 x 480 (non-square) pixels and displayed as 720 x 480 (square) pixels. This results in distorted playback of content. (If the pixel aspect ratio and clean aperture were obeyed, the movie would use 640 x 480 square pixels on the screen.)</p><a name="//apple_ref/doc/uid/TP40003543-NewFeaturesChangesandEnhancementsinQuickTime71-DontLinkElementID_7" title="Improved Quality of Video Playback in QuickTime 7.1"></a><h3>Improved Quality of Video Playback in QuickTime 7.1</h3><p>Typically, QuickTime video content may be tagged with two image description extensions, one that describes the pixel aspect ratio (<code>'pasp'</code>), and the other that describes the clean aperture (<code>'clap'</code>) of the video frame. The clean aperture is the region free of edge-encoding artifacts. Together, these extensions define the correct way to scale non-square pixel content to square-pixel computer displays.</p><p>QuickTime 7.1 now provides improved quality of video playback in QuickTime by <em>correcting</em> for non-square pixels and the clean aperture. The visual quality of DV (and other Pro media) playback is maximized in QuickTime Player by displaying DV at the correct aspect ratio, including PAL and 16 x 9 content, and by cropping to the clean aperture.</p><p>This enhanced visual quality is performed on new as well as existing QuickTime media content. By default, existing content appears as before in all applications. New content includes information to correct for the clean aperture and aspect ratio for use in supporting applications. The behavior of non-supporting applications is not affected.</p><p>QuickTime 7.1 provides a number of new APIs, described briefly in this document in the section <span class="content_text">“New Aperture Mode APIs”</span> and more completely in the <em><a href="../../../Reference/QT7-1_Update_Reference/index.html#//apple_ref/doc/uid/TP40004221" target="_top">QuickTime 7.1 Update Reference</a></em>. These APIs let you set the aperture mode for a movie. The aperture mode is not stored in the movie, but is specified as a rendering preference. QuickTime Player also lets you set the current mode.</p><p>Tracks store additional width and height information that are used when cropping and scaling. These are <strong>aperture mode dimensions</strong>. Conforming scans the media to generate the aperture mode dimensions. New content is created automatically with this information. QuickTime Player allows users to add this information by conforming the movie. </p><a name="//apple_ref/doc/uid/TP40003543-NewFeaturesChangesandEnhancementsinQuickTime71-DontLinkElementID_8" title="Impact on QuickTime Users and Professional Applications"></a><h3>Impact on QuickTime Users and Professional Applications</h3><p>QuickTime 7.1 users are impacted by the new aperture mode implementation in several ways, as discussed in this section. </p><p>Both new and existing QuickTime applications may behave differently when rendering images. For example, in the following aperture modes, you find this:</p><ul class="spaceabove"><li class="li"><p><strong>Classic</strong>. Content appears as it did in QuickTime 7. The existing track dimensions are respected. A DV NTSC (4:3 or 16:9) track appears as 720 x 480.</p></li><li class="li"><p><strong>Clean</strong>. Content may appear different than in QuickTime 7. Conformed tracks are cropped to the clean aperture mode and scaled according to the pixel aspect ratio. The resulting movie composition may be different, as may the movie box. This is the new default for consumer applications. A 4:3 DV NTSC track appears as 640 x 480; a 16:9 DV NTSC track appears as 853 x 480.</p></li><li class="li"><p><strong>Production</strong>. Content may appear different than in QuickTime 7. Conformed tracks are not cropped to the clean aperture mode, but they are scaled according to the pixel aspect ratio. The resulting movie composition may be different, as may the movie box. This would be typically used for professional applications wanting to see all the pixels, but with the correct aspect ratio. A 4:3 DV NTSC track appears as 654 x 480; a 16:9 DV NTSC track appears as 873 x 480.</p></li><li class="li"><p><strong>Encoded pixels</strong>. Content typically appears the same as QuickTime 7. Conformed tracks are not cropped to the clean aperture mode, and are not scaled according to the pixel aspect ratio. The encoded dimensions of the image description are displayed. This would be typically used to preview rendering (where you want all pixels) in a professional application. A DV NTSC (4:3 or 16:9) track appears as 720 x 480.</p></li></ul><a name="//apple_ref/doc/uid/TP40003543-NewFeaturesChangesandEnhancementsinQuickTime71-DontLinkElementID_9" title="Displaying Content Correctly According to Aperture Mode"></a><h4>Displaying Content Correctly According to Aperture Mode</h4><p>When opened in QuickTime Player, a movie appears corrected if it has aperture mode dimensions. QuickTime Player respects the other aperture modes as well. The user can toggle the aperture modes to see how the content is displayed in these modes. The default mode is clean.</p><p>Existing QuickTime movies can be viewed correctly by conforming the movie. QuickTime Pro users can modify their content so that it displays correctly according to the aperture mode. </p><p>Other applications will default to show the classic mode, respecting the existing behavior. Those applications that want to leverage this new feature can opt in to using the clean mode (or other mode) and could call the new APIs to conform content. </p><a name="//apple_ref/doc/uid/TP40003543-NewFeaturesChangesandEnhancementsinQuickTime71-DontLinkElementID_10" title="Supported Formats"></a><h4>Supported Formats</h4><p>Supported file formats to be tagged at capture and on export include:</p><ul class="spaceabove"><li class="li"><p>DV / DVCPro NTSC</p></li><li class="li"><p>DVPAL</p></li><li class="li"><p>DVCPro PAL</p></li><li class="li"><p>DVCPro 50 NTSC</p></li><li class="li"><p>DVCPro 50 PAL</p></li><li class="li"><p>DVCPro HD 1080i 60</p></li><li class="li"><p>DVCPro HD 1080i 50</p></li><li class="li"><p>DVCPro HD 720p 30</p></li></ul><p>File formats with existing tagged content that have aperture mode enabled when conformed include: </p><ul class="spaceabove"><li class="li"><p>HDV 1080i 60</p></li><li class="li"><p>HDV 720p 30</p></li><li class="li"><p>iCodec 1080i 60</p></li><li class="li"><p>iCodec 720p 30</p></li><li class="li"><p>Uncompressed formats, including Apple 2vuy, Apple v210, and Pinnacle CineWave</p></li></ul><a name="//apple_ref/doc/uid/TP40003543-NewFeaturesChangesandEnhancementsinQuickTime71-SW2" title="New Aperture Mode APIs"></a><h3>New Aperture Mode APIs</h3><p>Nine new aperture mode APIs are available in QuickTime 7.1. The complete description of each API, with its function prototype, parameters, and discussion of usage is available in the <em><a href="../../../Reference/QT7-1_Update_Reference/index.html#//apple_ref/doc/uid/TP40004221" target="_top">QuickTime 7.1 Update Reference</a></em>. The new APIs include</p><ul class="spaceabove"><li class="li"><p><code><a href="../../../Reference/QT7-1_Update_Reference/Functions/Functions.html#//apple_ref/c/func/SetTrackApertureModeDimensionsUsingSampleDescription" target="_top">SetTrackApertureModeDimensionsUsingSampleDescription</a></code>. Sets a track’s aperture mode dimensions using values calculated using a sample description.</p></li><li class="li"><p><code><a href="../../../Reference/QT7-1_Update_Reference/Functions/Functions.html#//apple_ref/c/func/GenerateMovieApertureModeDimensions" target="_top">GenerateMovieApertureModeDimensions</a></code>. Examines a movie and sets up track aperture mode dimensions.</p></li><li class="li"><p><code><a href="../../../Reference/QT7-1_Update_Reference/Functions/Functions.html#//apple_ref/c/func/GenerateTrackApertureModeDimensions" target="_top">GenerateTrackApertureModeDimensions</a></code>. Examines a track and sets up aperture mode dimensions.</p></li><li class="li"><p><code><a href="../../../Reference/QT7-1_Update_Reference/Functions/Functions.html#//apple_ref/c/func/RemoveMovieApertureModeDimensions" target="_top">RemoveMovieApertureModeDimensions</a></code>. Removes aperture mode dimension information from a movie.</p></li><li class="li"><p><code><a href="../../../Reference/QT7-1_Update_Reference/Functions/Functions.html#//apple_ref/c/func/RemoveTrackApertureModeDimensions" target="_top">RemoveTrackApertureModeDimensions</a></code>. Removes aperture mode dimension information from a track.</p></li><li class="li"><p><code><a href="../../../Reference/QT7-1_Update_Reference/Functions/Functions.html#//apple_ref/c/func/MediaSetTrackApertureModeDimensionsUsingSampleDescription" target="_top">MediaSetTrackApertureModeDimensionsUsingSampleDescription</a></code>. Sets the three aperture mode dimension properties on the track, calculating the values using the provided sample description.</p></li><li class="li"><p><code><a href="../../../Reference/QT7-1_Update_Reference/Functions/Functions.html#//apple_ref/c/func/MediaGetApertureModeClipRectForSampleDescriptionIndex" target="_top">MediaGetApertureModeClipRectForSampleDescriptionIndex</a></code>. Calculates a source clip rectangle appropriate for the current aperture mode and the given sample description.</p></li><li class="li"><p><code><a href="../../../Reference/QT7-1_Update_Reference/Functions/Functions.html#//apple_ref/c/func/MediaGetApertureModeMatrixForSampleDescriptionIndex" target="_top">MediaGetApertureModeMatrixForSampleDescriptionIndex</a></code>. Calculates a matrix appropriate for the current aperture mode and the given sample description.</p></li><li class="li"><p><code><a href="../../../Reference/QT7-1_Update_Reference/Functions/Functions.html#//apple_ref/c/func/MediaGenerateApertureModeDimensions" target="_top">MediaGenerateApertureModeDimensions</a></code>. Examines media and sets up track aperture mode dimensions.</p></li></ul><a name="//apple_ref/doc/uid/TP40003543-NewFeaturesChangesandEnhancementsinQuickTime71-DontLinkElementID_11" title="Code Demonstrating How to Set an Aperture Mode"></a><h3>Code Demonstrating How to Set an Aperture Mode</h3><p>The following code snippet demonstrates how to set an aperture mode, using the <code>SetMovieApertureMode</code> routine. The routine is called to set the specified movie aperture mode in a movie. At that time, do conforming if the specified movie does not have the aperture mode dimensions in order to make sure that the video correction is performed correctly.</p><div class="codesample"><table><tr><td scope="row"><pre>OSErr SetMovieApertureMode(Movie theMovie, OSType theApertureMode)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>     OSErr err;<span></span></pre></td></tr><tr><td scope="row"><pre>     if ( theApertureMode != kQTApertureMode_Classic ) {<span></span></pre></td></tr><tr><td scope="row"><pre>            Boolean hasApertureModeDimensions;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>            err = QTGetMovieProperty(theMovie,<span></span></pre></td></tr><tr><td scope="row"><pre>                                              kQTPropertyClass_Visual,<span></span></pre></td></tr><tr><td scope="row"><pre>                                              kQTVisualPropertyID_HasApertureModeDimensions,<span></span></pre></td></tr><tr><td scope="row"><pre>                                              sizeof(hasApertureModeDimensions),<span></span></pre></td></tr><tr><td scope="row"><pre>                                              &amp;hasApertureModeDimensions,<span></span></pre></td></tr><tr><td scope="row"><pre>                                              NULL);<span></span></pre></td></tr><tr><td scope="row"><pre>            if ( err ) goto bail;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>            if ( !hasApertureModeDimensions ) {<span></span></pre></td></tr><tr><td scope="row"><pre>                   err = GenerateMovieApertureModeDimensions(theMovie);<span></span></pre></td></tr><tr><td scope="row"><pre>                   if ( err ) goto bail;<span></span></pre></td></tr><tr><td scope="row"><pre>            }<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    err = QTSetMovieProperty(theMovie, kQTPropertyClass_Visual, kQTVisualPropertyID_ApertureMode, sizeof(theApertureMode), &amp;theApertureMode);<span></span></pre></td></tr><tr><td scope="row"><pre>bail:<span></span></pre></td></tr><tr><td scope="row"><pre>     return err;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><a name="//apple_ref/doc/uid/TP40003543-NewFeaturesChangesandEnhancementsinQuickTime71-DontLinkElementID_12" title="QuickTime Kit Support for Aperture Mode"></a><h3>QuickTime Kit Support for Aperture Mode</h3><p>QuickTime 7.1 provides an Objective-C (Cocoa) version of the new aperture mode support introduced in QuickTime, available in the <em><a href="../../../Reference/QTCocoaObjCKit/index.html#//apple_ref/doc/uid/TP40001164" target="_top">QTKit Framework Reference</a></em>.</p><p>In order to allow QTKit clients to select different aperture modes for viewing and other operations (such as export), new methods, attribute types, and notifications have been added. Existing applications default to classic mode, which provides compatibility with behavior in QuickTime 7.0.x and earlier. </p><p>The new QTKit APIs are discussed briefly in this section. For more detailed explanations, refer specifically to the <em><a href="../../../Reference/QTKitFramework/Classes/QTMovie_Class/index.html#//apple_ref/doc/uid/TP40003799" target="_top">QTMovie Class Reference</a></em> and the <em><a href="../../../Reference/QTKitFramework/Classes/QTTrack_Class/index.html#//apple_ref/doc/uid/TP40003801" target="_top">QTTrack Class Reference</a></em>. </p><a name="//apple_ref/doc/uid/TP40003543-NewFeaturesChangesandEnhancementsinQuickTime71-DontLinkElementID_13" title="New Attributes, Notifications and Methods Added to the QTMovie Class"></a><h4>New Attributes, Notifications and Methods Added to the QTMovie Class</h4><p>The following attributes are new to the QTMovie class:</p><div class="codesample"><table><tr><td scope="row"><pre>QTMovieApertureModeAttribute<span></span></pre></td></tr><tr><td scope="row"><pre>QTMovieHasApertureModeDimensionsAttribute // NSNumber (BOOL)<span></span></pre></td></tr></table></div><p>You can set the aperture mode attribute on a QTMovie object to indicate whether aspect ratio and clean aperture correction should be performed. When a movie is in clean, production, or encoded pixels aperture mode, the dimensions of each track are overridden by special dimensions for that mode. The original track dimensions are preserved and can be restored by setting the movie into classic aperture mode. Note that aperture modes are <em>not</em> saved in movies.</p><p>You can get the value of the attribute to determine whether aperture mode dimensions have been set on any track in this QTMovie object, even if those dimensions are all identical to the classic dimensions (as is the case for content with square pixels and no edge-processing region).</p><p>The following notification has been added to the QTMovie class:</p><div class="codesample"><table><tr><td scope="row"><pre>QTMovieApertureModeDidChangeNotification<span></span></pre></td></tr></table></div><p>This notification is issued when the aperture mode of the target QTMovie object changes. </p><p>Two new methods are added:    </p><div class="codesample"><table><tr><td scope="row"><pre>- (void)generateApertureModeDimensions<span></span></pre></td></tr><tr><td scope="row"><pre>- (void)removeApertureModeDimensions<span></span></pre></td></tr></table></div><p>The <code>generateApertureModeDimensions</code> method adds information to a QTMovie needed to support aperture modes for tracks created with applications and/or versions of QuickTime that did not support aperture mode dimensions. </p><p>If the image descriptions in video tracks lack tags describing clean aperture and pixel aspect ratio information, the media data is scanned to see if the correct values can be divined and attached. Then the aperture mode dimensions are calculated and set. </p><p>Afterwards, the <code>QTTrackHasApertureModeDimensionsAttribute</code> property will be set to <code>YES</code> for those tracks. Tracks that do not support aperture modes are not changed. </p><p>The <code>removeApertureModeDimensions</code> method removes aperture mode dimension information from a movie's tracks. It does not attempt to modify sample descriptions, so it may not completely reverse the effects of <code>generateApertureModeDimensions</code>. It sets the <code>QTMovieHasApertureModeDimensionsAttribute</code> property to <code>NO</code>. </p><a name="//apple_ref/doc/uid/TP40003543-NewFeaturesChangesandEnhancementsinQuickTime71-DontLinkElementID_14" title="New Attributes and Methods Added to the QTTrack Class"></a><h4>New Attributes and Methods Added to the QTTrack Class</h4><p>The following attribute is new to the QTTrack class:</p><div class="codesample"><table><tr><td scope="row"><pre>QTTrackHasApertureModeDimensionsAttribute  // NSNumber (BOOL)<span></span></pre></td></tr></table></div><p>You can get the value of this attribute to determine whether aperture mode dimensions have been set on a track, even if they are all identical to the classic dimensions (as is the case for content with square pixels and no edge-processing region).</p><p>Four new methods are added: </p><div class="codesample"><table><tr><td scope="row"><pre>- (NSSize)apertureModeDimensionsForMode:(NSString *)mode<span></span></pre></td></tr><tr><td scope="row"><pre>- (void)setApertureModeDimensions:(NSSize)dimensions forMode:(NSString *)mode<span></span></pre></td></tr><tr><td scope="row"><pre>- (void)generateApertureModeDimensions<span></span></pre></td></tr><tr><td scope="row"><pre>- (void)removeApertureModeDimensions<span></span></pre></td></tr></table></div><p>The <code>apertureModeDimensionsForMode:</code> method returns an NSSize value that indicates the dimensions of the target track for the specified movie aperture mode. For instance, passing a mode of <code>QTMovieApertureModeClean</code> would cause <code>apertureModeDimensionsForMode:</code> to return the track dimensions to use in clean aperture mode.  </p><p>The <code>setApertureModeDimensions:forMode:</code> method sets the dimensions of the target track for the specified movie aperture mode.  </p><p>The <code>generateApertureModeDimensions</code> method adds information to a QTTrack needed to support aperture modes for tracks created with applications and/or versions of QuickTime that did not support aperture mode dimensions. </p><p>If the image descriptions in the track lack tags describing clean aperture and pixel aspect ratio information, the media data is scanned to see if the correct values can be divined and attached. Then the aperture mode dimensions are calculated and set. </p><p>Afterwards, the <code>QTTrackHasApertureModeDimensionsAttribute</code> property will be set to <code>YES</code> for this track. Tracks that do not support aperture modes are not changed.  </p><p>The <code>removeApertureModeDimensions</code> method removes the aperture mode dimension information from the target track. It does not attempt to modify sample descriptions, so it may not completely reverse the effects of <code>generateApertureModeDimensions</code>. It sets the <code>QTTrackHasApertureModeDimensionsAttribute</code> property to <code>NO</code>.</p>
<a name="//apple_ref/doc/uid/TP40003543-NewFeaturesChangesandEnhancementsinQuickTime71-VisualContextSupportonWindows" title="Visual Context Support on Windows"></a>
<h2>Visual Context Support on Windows</h2>
<p>QuickTime 7.1 supports using visual contexts for playing video through Direct3D textures, mirroring the visual context support for OpenGL available on Mac OS X, beginning with QuickTime 7.</p><p>This support is very useful for applications that want to play video to textures and do further image manipulation in hardware, or for applications that want to take advantage of more efficient playback paths for certain media types.</p><p>Applications can take advantage of this by using the ActiveX Control or by coding to the visual context APIs directly.</p><div class="importantbox"><a name="//apple_ref/doc/uid/TP40003543-NewFeaturesChangesandEnhancementsinQuickTime71-DontLinkElementID_20" title="Important:"></a><p><strong>Important:</strong>&nbsp;The visual context implementation in QuickTime 7.1 for Windows that plays video through Direct3D requires DirectX9.0c. If DirectX9.0c is not installed, QuickTime Player and the ActiveX Control will fall back to the GWorld playback path.</p><p></p></div><p>With Direct3D texture visual contexts, the application is responsible for creating the Direct3DDevice9 which the visual context will use to allocate and manage textures. Since QuickTime 7.1 does not require DirectX9 on users’ systems, it is left up to applications to test for its presence before attempting to use visual contexts. Even if DirectX9 is installed, the graphics hardware might be underpowered; in this case, <code>QTDirect3DTextureContextCreate</code> will return an error indicating that visual contexts are not supported. It will also return this error if the user disables video acceleration in the QuickTime control panel.</p><p>In order to support visual contexts, the graphics hardware must not be restricted to power-of-2 texture sizes; it must support at least version 1.1 pixel-shaders, and have at least 32MB free texture memory.</p><p>When faced with insufficient graphics hardware, the application can either fall back to QuickDraw by providing a GWorld to <code>SetMovieGWorld</code> or handle the failure in some other way (for example, failing to run, and so on).</p>
<p>As with the Mac OS X implementation, some types of media may not perform well with visual contexts.  QuickTime Player and the ActiveX Control will fall back to using QuickDraw for media such as MPEG-1, MPEG-2, interactive sprites, Flash, VR, QT effects and some other obscure types of media. Applications can examine the movie to determine if such media exists.</p>
<p>As for basic usage, the movie frames will arrive from the <code>QTVisualContextCopyImageForTime</code> function as CVDirect3DTextureRefs. Similar to Mac OS X, you query this <code>CVDirect3DTextureRef</code> with <code>CVDirect3DTextureGetName</code>, and it will return the texture as a <code>LPDIRECT3DTEXTURE9</code> pointer. Querying the CVDirect3DTextureRef with <code>CVDirect3DTextureGetCleanTexCoords</code> will return texture coordinates ready to be sent into your VertexBuffer. QuickTime generates these buffers as single level (that is, not mip-mapped) textures, allocated in either the <code>D3DPOOL_MANAGED</code> or <code>D3DPOOL_DEFAULT</code> Direct3D memory pools.</p>
<a name="//apple_ref/doc/uid/TP40003543-NewFeaturesChangesandEnhancementsinQuickTime71-UnderstandingandUsingaVisualContext" title="Understanding the Visual Context Abstraction"></a>
<h3>Understanding the Visual Context Abstraction</h3>
<p>Visual context is an abstraction that represents a visual output destination for a movie, and is intended to decouple QuickTime from graphics worlds (GWorlds). This decoupling allows programmers to work in QuickTime without needing to understand QuickDraw, and to more easily render QuickTime directly using engines such as OpenGL on Mac OS X or Direct3D on Windows.</p>
<p>A visual context can act as a virtual output device, rendering the movie’s visual output, streaming it, storing it, or processing it in any number of ways.</p>
<p>A visual context can also act as a bridge between a QuickTime movie and an application’s visual rendering environment. For example, you can set up a visual context for OpenGL or Direct3D textures. This causes a movie to produce its visual output as a series of OpenGL textures. You can then pass the textures to OpenGL or Direct3D for rendering, without having to copy the contents of a <code>GWorld</code> and transform it into an OpenGL or Direct3D texture yourself. In this case, the visual context performs the transformation from pixel buffers to OpenGL or Direct3D textures and delivers the visual output to your application.</p>
<p>A <code><!--a target="_top" -->QTVisualContextRef<!--/a--></code> is an opaque token that represents a drawing destination for a movie. The visual context is, in object-oriented terms, a base class for other concrete implementations of visual rendering environments. The output of the visual context depends entirely on the implementation. The implementation supplied with QuickTime 7.1 produces a series of OpenGL or Direct3D textures, but the list of possible outputs is extensible.</p>
<p>You create a visual context by calling a function that instantiates a context of a particular type, such as <code><a href="../../QT7Win_Update_Guide/Chapter03/03QT7_Update_Guide.html#//apple_ref/c/func/QTOpenGLTextureContextCreate" target="_top">QTOpenGLTextureContextCreate</a></code> on Mac OS X. This allocates a context object suitable for passing to functions such as <code><a href="../../QT7UpdateGuide/Chapter03/03QT7_Update_Guide.html#//apple_ref/c/func/SetMovieVisualContext" target="_top">SetMovieVisualContext</a></code> or <code><a href="../../QT7Win_Update_Guide/Chapter03/03QT7_Update_Guide.html#//apple_ref/c/func/NewMovieFromProperties" target="_top">NewMovieFromProperties</a></code>, which target the visual output of the movie to the specified context.</p>
<p>To use a visual context with a QuickTime movie, you should instantiate the movie using the <code><a href="../../QT7Win_Update_Guide/Chapter03/03QT7_Update_Guide.html#//apple_ref/c/func/NewMovieFromProperties" target="_top">NewMovieFromProperties</a></code> function. This creates a movie that can accept a visual context. You can either specify the desired visual context when you instantiate the movie, or set the initial visual context to <code>NIL</code> (to prevent the movie from inheriting the current <code>GWorld</code>), and set the visual context later using <code><a href="../../QT7UpdateGuide/Chapter03/03QT7_Update_Guide.html#//apple_ref/c/func/SetMovieVisualContext" target="_top">SetMovieVisualContext</a></code>.</p>
<p>It is also possible to set a visual context for a movie that was instantiated using an older function, such as <code><a href="../../../Reference/QTRef_MovieToolkit/Reference/reference.html#//apple_ref/c/func/NewMovieFromFile" target="_top">NewMovieFromFile</a></code>. Such a movie will be associated with a <code>GWorld</code>. You change this to a visual context by first calling <code><a href="../../QT7UpdateGuide/Chapter03/03QT7_Update_Guide.html#//apple_ref/c/func/SetMovieVisualContext" target="_top">SetMovieVisualContext</a></code> on the movie with the visual context set to <code>NIL</code>. This dissociates the movie from its <code>GWorld</code> (or any previous visual context). You can then call <code><a href="../../QT7UpdateGuide/Chapter03/03QT7_Update_Guide.html#//apple_ref/c/func/SetMovieVisualContext" target="_top">SetMovieVisualContext</a></code> a second time, this time passing in a <code><!--a target="_top" -->QTVisualContextRef<!--/a--></code>.</p>

<a name="//apple_ref/doc/uid/TP40003543-NewFeaturesChangesandEnhancementsinQuickTime71-TheVisualContextAPIsAvailableforWindows" title="The Visual Context APIs Available for Windows"></a>
<h3>The Visual Context APIs Available for Windows</h3>
<p>Windows developers can now use the following visual context APIs available in QuickTime 7.1, described briefly in this section. A complete description of these APIs is available in the <em><a href="../../../Reference/QT7-1_Update_Reference/index.html#//apple_ref/doc/uid/TP40004221" target="_top">QuickTime 7.1 Update Reference</a></em>. </p><ul class="spaceabove"><li class="li"><p><code><a href="../../QT7UpdateGuide/Chapter03/03QT7_Update_Guide.html#//apple_ref/c/func/GetMovieVisualContext" target="_top">GetMovieVisualContext</a></code>. Returns the <code>QTVisualContext</code> object associated with the movie. It was introduced in QuickTime 7 for Mac OS X, and is now available for Windows..</p></li><li class="li"><p><code><a href="../../QT7Win_Update_Guide/Chapter03/03QT7_Update_Guide.html#//apple_ref/c/func/ICMDecompressionSessionCreateForVisualContext" target="_top">ICMDecompressionSessionCreateForVisualContext</a></code>. Creates a session for decompressing video frames. Frames will be output to a visual context. If desired, the <code>trackingCallback</code> may attach additional data to pixel buffers before they are sent to the visual context.</p></li><li class="li"><p><code><a href="../../../Reference/QT7-1_Update_Reference/Functions/Functions.html#//apple_ref/c/func/QTDirect3DTextureContextCreate" target="_top">QTDirect3DTextureContextCreate</a></code>. New in QuickTime 7.1 and intended for use by Windows developers who want to do 3D texture rendering in their applications. Given a Direct3D device, you create a visual context to draw into it. This routine works similar to <code><a href="../../QT7Win_Update_Guide/Chapter03/03QT7_Update_Guide.html#//apple_ref/c/func/QTOpenGLTextureContextCreate" target="_top">QTOpenGLTextureContextCreate</a></code> on Mac OS X.</p></li><li class="li"><p><code><a href="../../QT7UpdateGuide/Chapter03/03QT7_Update_Guide.html#//apple_ref/c/func/QTVisualContextCopyImageForTime" target="_top">QTVisualContextCopyImageForTime</a></code>. Retrieves an image buffer from the visual context, indexed by the provided time. You should not request image buffers further ahead of the current time than the read-ahead time specified with the <code>kQTVisualContextExpectedReadAheadKey</code> attribute. You may skip images by passing later times, but you may not pass an earlier time than passed to a previous call to this function.</p></li><li class="li"><p><code><a href="../../QT7UpdateGuide/Chapter03/03QT7_Update_Guide.html#//apple_ref/c/func/QTVisualContextGetAttribute" target="_top">QTVisualContextGetAttribute</a></code>. Returns a visual context attribute.</p></li><li class="li"><p><code><a href="../../QT7UpdateGuide/Chapter03/03QT7_Update_Guide.html#//apple_ref/c/func/QTVisualContextGetTypeID" target="_top">QTVisualContextGetTypeID</a></code>. Returns the <code>CFTypeID</code> for <code><!--a target="_top" -->QTVisualContextRef<!--/a--></code>. You can use this function to test whether a <code>CFTypeRef</code> that extracted from a CF container such as a <code>CFArray</code> was a <code><!--a target="_top" -->QTVisualContextRef<!--/a--></code>.</p></li><li class="li"><p><code><a href="../../QT7UpdateGuide/Chapter03/03QT7_Update_Guide.html#//apple_ref/c/func/QTVisualContextIsNewImageAvailable" target="_top">QTVisualContextIsNewImageAvailable</a></code>. Queries whether a new image is available for a given time. This function returns <code>TRUE</code> if there is a image available for the specified time that is different from the last image retrieved from <code><a href="../../QT7UpdateGuide/Chapter03/03QT7_Update_Guide.html#//apple_ref/c/func/QTVisualContextCopyImageForTime" target="_top">QTVisualContextCopyImageForTime</a></code>.</p></li><li class="li"><p><code><a href="../../QT7UpdateGuide/Chapter03/03QT7_Update_Guide.html#//apple_ref/c/func/QTVisualContextSetAttribute" target="_top">QTVisualContextSetAttribute</a></code>. Sets a visual context attribute.</p></li><li class="li"><p><code><a href="../../QT7UpdateGuide/Chapter03/03QT7_Update_Guide.html#//apple_ref/c/func/QTVisualContextSetImageAvailableCallback" target="_top">QTVisualContextSetImageAvailableCallback</a></code>. Installs a user-defined callback to receive notifications when a new image becomes available. Due to unpredictable activity, such as user seeks or the arrival of streaming video packets from a network, new images may become available for times supposedly occupied by previous images. Applications using the CoreVideo display link to drive rendering probably do not need to install a callback of this type, since they will already be checking for new images at a sufficient rate.</p></li><li class="li"><p><code><a href="../../QT7UpdateGuide/Chapter03/03QT7_Update_Guide.html#//apple_ref/c/func/QTVisualContextRelease" target="_top">QTVisualContextRelease</a></code>. Releases a visual context object. When the retain count decreases to zero the visual context is disposed.</p></li><li class="li"><p><code><a href="../../QT7UpdateGuide/Chapter03/03QT7_Update_Guide.html#//apple_ref/c/func/QTVisualContextRetain" target="_top">QTVisualContextRetain</a></code>. Retains a visual context object.</p></li><li class="li"><p><code><a href="../../QT7UpdateGuide/Chapter03/03QT7_Update_Guide.html#//apple_ref/c/func/QTVisualContextTask" target="_top">QTVisualContextTask</a></code>. Enables the visual context to release internally held resources for later re-use. For optimal resource management, call this function in every rendering pass, after old images have been released, and new images have been used and all rendering has been flushed to the screen. This call is not mandatory.</p></li><li class="li"><p><code><a href="../../QT7UpdateGuide/Chapter03/03QT7_Update_Guide.html#//apple_ref/c/func/SetMovieVisualContext" target="_top">SetMovieVisualContext</a></code>. This routine targets a movie to render into a visual context. When <code><a href="../../QT7UpdateGuide/Chapter03/03QT7_Update_Guide.html#//apple_ref/c/func/SetMovieVisualContext" target="_top">SetMovieVisualContext</a></code> succeeds, it will retain the <code>QTVisualContext</code> object for its own use. If <code>visualContext</code> is <code>NULL</code>, the movie will not render any visual media. The <code><a href="../../QT7UpdateGuide/Chapter03/03QT7_Update_Guide.html#//apple_ref/c/func/SetMovieVisualContext" target="_top">SetMovieVisualContext</a></code> routine will fail if a different movie is already using the visual context, so you should first <code>disassociate</code> the other movie by calling <code><a href="../../QT7UpdateGuide/Chapter03/03QT7_Update_Guide.html#//apple_ref/c/func/SetMovieVisualContext" target="_top">SetMovieVisualContext</a></code> with a NULL <code>visualContext</code>.</p><p>Note that calling <code><a href="../../../Reference/QTRef_MovieManager/Reference/reference.html#//apple_ref/c/func/SetMovieGWorld" target="_top">SetMovieGWorld</a></code> on a movie that is connected to a visual context will work, but it may still keep a reference to the visual context. If you wish to completely disconnect the visual context, make sure to first call <code><a href="../../QT7UpdateGuide/Chapter03/03QT7_Update_Guide.html#//apple_ref/c/func/SetMovieVisualContext" target="_top">SetMovieVisualContext</a></code> with a NULL <code>visualContext</code>.</p></li></ul>
<a name="//apple_ref/doc/uid/TP40003543-NewFeaturesChangesandEnhancementsinQuickTime71-DontLinkElementID_15" title="Visual Context for Windows Sample Code"></a><h3>Visual Context for Windows Sample Code</h3><p>The Windows D3DVisualContext sample demonstrates how to use visual context in a Direct3D application. It lets you do simple movie playback, but also more complex tasks, such as tracking mouse drags to allow rotation of a playing movie. </p><p>The code sample, which is reproduced in full here and commented in some detail, demonstrates how to </p><ul class="spaceabove"><li class="li"><p>set up your d3ddevice</p></li><li class="li"><p>create a visual context</p></li><li class="li"><p>set the movie</p></li><li class="li"><p>pull textures from the visual context</p></li></ul><a name="//apple_ref/doc/uid/TP40003543-NewFeaturesChangesandEnhancementsinQuickTime71-DontLinkElementID_21" title="Listing 1-1Windows D3DVisualContext sample application"></a><p class="codesample"><strong>Listing 1-1&nbsp;&nbsp;</strong>Windows D3DVisualContext sample application</p><div class="codesample"><table><tr><td scope="row"><pre>#include &lt;Windows.h><span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;mmsystem.h><span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;d3dx9.h><span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;process.h><span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;stdio.h><span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;QTML.h><span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;Movies.h><span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;ImageCompression.h><span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;CoreFoundation.h><span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>#ifndef WM_MOUSEWHEEL<span></span></pre></td></tr><tr><td scope="row"><pre>#define WM_MOUSEWHEEL 0x020A<span></span></pre></td></tr><tr><td scope="row"><pre>#endif<span></span></pre></td></tr><tr><td scope="row"><pre>#ifndef WHEEL_DELTA<span></span></pre></td></tr><tr><td scope="row"><pre>#define WHEEL_DELTA 120<span></span></pre></td></tr><tr><td scope="row"><pre>#endif<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>// Global variables<span></span></pre></td></tr><tr><td scope="row"><pre>HWND                    hWnd;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>// Movie variables<span></span></pre></td></tr><tr><td scope="row"><pre>QTVisualContextRef        d3dContext = NULL;<span></span></pre></td></tr><tr><td scope="row"><pre>Movie                    textureMovie = NULL;<span></span></pre></td></tr><tr><td scope="row"><pre>UInt32                    movieHeight = 720;<span></span></pre></td></tr><tr><td scope="row"><pre>UInt32                    movieWidth = 1280;<span></span></pre></td></tr><tr><td scope="row"><pre>TimeValue                movieDuration = 0;<span></span></pre></td></tr><tr><td scope="row"><pre>CVImageBufferRef        cvImage = NULL;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>// D3D variables<span></span></pre></td></tr><tr><td scope="row"><pre>LPDIRECT3D9             pD3D = NULL;<span></span></pre></td></tr><tr><td scope="row"><pre>LPDIRECT3DDEVICE9       gD3DDevice = NULL;<span></span></pre></td></tr><tr><td scope="row"><pre>LPDIRECT3DVERTEXBUFFER9 vertexBuffer = NULL;<span></span></pre></td></tr><tr><td scope="row"><pre>LPDIRECT3DTEXTURE9      movieTexture = NULL;<span></span></pre></td></tr><tr><td scope="row"><pre>FLOAT                    currZRotation = 0;<span></span></pre></td></tr><tr><td scope="row"><pre>FLOAT                    currYRotation = 0;<span></span></pre></td></tr><tr><td scope="row"><pre>FLOAT                    currXRotation = 0;<span></span></pre></td></tr><tr><td scope="row"><pre>FLOAT                    gEyePtX = 0.0f;<span></span></pre></td></tr><tr><td scope="row"><pre>FLOAT                    gEyePtY = 0.0f;<span></span></pre></td></tr><tr><td scope="row"><pre>FLOAT                    gEyePtZ = -2.39f;<span></span></pre></td></tr><tr><td scope="row"><pre>int                        gLastMouseXPos = 0;<span></span></pre></td></tr><tr><td scope="row"><pre>int                        gLastMouseYPos = 0;<span></span></pre></td></tr><tr><td scope="row"><pre>float                    topLeft[2], topRight[2], bottomRight[2], bottomLeft[2];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>// Render thread variables<span></span></pre></td></tr><tr><td scope="row"><pre>HANDLE                    fastRenderThread = NULL;<span></span></pre></td></tr><tr><td scope="row"><pre>unsigned int            fastRenderThreadID = 0;<span></span></pre></td></tr><tr><td scope="row"><pre>HANDLE                    renderCondition = NULL;<span></span></pre></td></tr><tr><td scope="row"><pre>Boolean                    fastRenderThreadRunning = false;<span></span></pre></td></tr><tr><td scope="row"><pre>Boolean                    quitFastRenderThread = false;<span></span></pre></td></tr><tr><td scope="row"><pre>UInt32                    renderWaitTime;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>// Prototypes<span></span></pre></td></tr><tr><td scope="row"><pre>void Render(CVImageBufferRef newCVImageRef);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>struct CUSTOMVERTEX<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    FLOAT        x, y, z; // The position<span></span></pre></td></tr><tr><td scope="row"><pre>    FLOAT       tu, tv;   // The texture coordinates<span></span></pre></td></tr><tr><td scope="row"><pre>};<span></span></pre></td></tr><tr><td scope="row"><pre>#define D3DFVF_CUSTOMVERTEX (D3DFVF_XYZ|D3DFVF_TEX1)<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>//-----------------------------------------------------------------------------<span></span></pre></td></tr><tr><td scope="row"><pre>// Name: InitD3D()<span></span></pre></td></tr><tr><td scope="row"><pre>// Desc: Initializes Direct3D<span></span></pre></td></tr><tr><td scope="row"><pre>//-----------------------------------------------------------------------------<span></span></pre></td></tr><tr><td scope="row"><pre>HRESULT InitD3D( HWND hWnd )<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    CVReturn cvErr = noErr;<span></span></pre></td></tr><tr><td scope="row"><pre>    OSStatus err = noErr;<span></span></pre></td></tr><tr><td scope="row"><pre>    UInt32 displayRefreshRate = 0;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Create the D3D object.<span></span></pre></td></tr><tr><td scope="row"><pre>    if( NULL == ( pD3D = Direct3DCreate9( D3D_SDK_VERSION ) ) )<span></span></pre></td></tr><tr><td scope="row"><pre>        return E_FAIL;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Set up the structure used to create the D3DDevice. Since we are now<span></span></pre></td></tr><tr><td scope="row"><pre>    // using more complex geometry, we will create a device with a zbuffer.<span></span></pre></td></tr><tr><td scope="row"><pre>    D3DPRESENT_PARAMETERS d3dpp;<span></span></pre></td></tr><tr><td scope="row"><pre>    ZeroMemory( &amp;d3dpp, sizeof(d3dpp) );<span></span></pre></td></tr><tr><td scope="row"><pre>    d3dpp.Windowed = TRUE;<span></span></pre></td></tr><tr><td scope="row"><pre>    d3dpp.SwapEffect = D3DSWAPEFFECT_DISCARD;<span></span></pre></td></tr><tr><td scope="row"><pre>    d3dpp.BackBufferFormat = D3DFMT_A8R8G8B8;<span></span></pre></td></tr><tr><td scope="row"><pre>    d3dpp.EnableAutoDepthStencil = TRUE;<span></span></pre></td></tr><tr><td scope="row"><pre>    d3dpp.AutoDepthStencilFormat = D3DFMT_D16;<span></span></pre></td></tr><tr><td scope="row"><pre>    d3dpp.PresentationInterval = D3DPRESENT_INTERVAL_ONE;<span></span></pre></td></tr><tr><td scope="row"><pre>    d3dpp.hDeviceWindow = hWnd;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Create the D3DDevice.<span></span></pre></td></tr><tr><td scope="row"><pre>    // It is essential that the D3DCREATE_MULTITHREADED flag be set when we create<span></span></pre></td></tr><tr><td scope="row"><pre>    // the device, because QuickTime will want to access textures to decompress video into<span></span></pre></td></tr><tr><td scope="row"><pre>    // them on a background thread, and be able to provide those textures to the app to be<span></span></pre></td></tr><tr><td scope="row"><pre>    // rendered on yet another thread if the app so desires.<span></span></pre></td></tr><tr><td scope="row"><pre>    // It is also important to request that Direct3D not alter the precision of the floating-point processor<span></span></pre></td></tr><tr><td scope="row"><pre>    // by passing the D3DCREATE_FPU_PRESERVE flag when creating the device.<span></span></pre></td></tr><tr><td scope="row"><pre>    // Without this flag, Direct3D will change the FPU to single-precision on the thread<span></span></pre></td></tr><tr><td scope="row"><pre>    // on which the Direct3DDevice is created. QuickTime may behave unexpectedly if called<span></span></pre></td></tr><tr><td scope="row"><pre>    // on threads which are not set to double-precision FPU state.<span></span></pre></td></tr><tr><td scope="row"><pre>    if( FAILED( pD3D->CreateDevice( D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL, hWnd,<span></span></pre></td></tr><tr><td scope="row"><pre>                                     D3DCREATE_HARDWARE_VERTEXPROCESSING | D3DCREATE_MULTITHREADED | D3DCREATE_FPU_PRESERVE,<span></span></pre></td></tr><tr><td scope="row"><pre>                                      &amp;d3dpp, &amp;gD3DDevice ) ) )<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        return E_FAIL;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Turn off culling<span></span></pre></td></tr><tr><td scope="row"><pre>    gD3DDevice->SetRenderState( D3DRS_CULLMODE, D3DCULL_NONE );<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Turn off D3D lighting<span></span></pre></td></tr><tr><td scope="row"><pre>    gD3DDevice->SetRenderState( D3DRS_LIGHTING, FALSE );<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Turn on the zbuffer<span></span></pre></td></tr><tr><td scope="row"><pre>    gD3DDevice->SetRenderState( D3DRS_ZENABLE, TRUE );<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    gD3DDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );<span></span></pre></td></tr><tr><td scope="row"><pre>    gD3DDevice->SetRenderState( D3DRS_SRCBLEND, D3DBLEND_SRCALPHA );<span></span></pre></td></tr><tr><td scope="row"><pre>    gD3DDevice->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA );<span></span></pre></td></tr><tr><td scope="row"><pre>    gD3DDevice->SetRenderState( D3DRS_ALPHATESTENABLE, FALSE );<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // This may fail if the video hardware doesn't support VC<span></span></pre></td></tr><tr><td scope="row"><pre>    err = QTDirect3DTextureContextCreate( NULL, (void*)gD3DDevice, D3DFMT_A8R8G8B8, NULL, &amp;d3dContext );<span></span></pre></td></tr><tr><td scope="row"><pre>    if (noErr != err)<span></span></pre></td></tr><tr><td scope="row"><pre>        return E_FAIL;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Get the refresh rate of the display. We want to poll for new textures from the VisualContext<span></span></pre></td></tr><tr><td scope="row"><pre>    // at this rate.<span></span></pre></td></tr><tr><td scope="row"><pre>    D3DDISPLAYMODE displayMode;<span></span></pre></td></tr><tr><td scope="row"><pre>    ZeroMemory( &amp;displayMode, sizeof(displayMode) );<span></span></pre></td></tr><tr><td scope="row"><pre>    pD3D->GetAdapterDisplayMode(D3DADAPTER_DEFAULT, &amp;displayMode);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if (displayMode.RefreshRate != 0)<span></span></pre></td></tr><tr><td scope="row"><pre>        displayRefreshRate = displayMode.RefreshRate;<span></span></pre></td></tr><tr><td scope="row"><pre>    else<span></span></pre></td></tr><tr><td scope="row"><pre>        displayRefreshRate = 60;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Convert display refresh to the number of milliseconds between refreshes to use for<span></span></pre></td></tr><tr><td scope="row"><pre>    // our WaitNextEvent timer on the render thread.<span></span></pre></td></tr><tr><td scope="row"><pre>    renderWaitTime = (1000/displayRefreshRate);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    return S_OK;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>// Open the movie.<span></span></pre></td></tr><tr><td scope="row"><pre>void makeMovie(Handle sourceMovieDataRef, OSType sourceMovieDataRefType)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    OSStatus err = noErr;<span></span></pre></td></tr><tr><td scope="row"><pre>    DataReferenceRecord dataRefRec;<span></span></pre></td></tr><tr><td scope="row"><pre>    Boolean movieActive = true;<span></span></pre></td></tr><tr><td scope="row"><pre>    QTNewMoviePropertyElement newMovieProperties[3] = {0};<span></span></pre></td></tr><tr><td scope="row"><pre>    Rect    movieRect;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    dataRefRec.dataRef = sourceMovieDataRef;<span></span></pre></td></tr><tr><td scope="row"><pre>    dataRefRec.dataRefType = sourceMovieDataRefType;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    newMovieProperties[0].propClass = kQTPropertyClass_DataLocation;<span></span></pre></td></tr><tr><td scope="row"><pre>    newMovieProperties[0].propID = kQTDataLocationPropertyID_DataReference;<span></span></pre></td></tr><tr><td scope="row"><pre>    newMovieProperties[0].propValueSize = sizeof(dataRefRec);<span></span></pre></td></tr><tr><td scope="row"><pre>    newMovieProperties[0].propValueAddress = &amp;dataRefRec;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    newMovieProperties[1].propClass = kQTPropertyClass_Context;<span></span></pre></td></tr><tr><td scope="row"><pre>    newMovieProperties[1].propID = kQTContextPropertyID_VisualContext;<span></span></pre></td></tr><tr><td scope="row"><pre>    newMovieProperties[1].propValueSize = sizeof(d3dContext);<span></span></pre></td></tr><tr><td scope="row"><pre>    newMovieProperties[1].propValueAddress = &amp;d3dContext;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    newMovieProperties[2].propClass = kQTPropertyClass_NewMovieProperty;<span></span></pre></td></tr><tr><td scope="row"><pre>    newMovieProperties[2].propID = kQTNewMoviePropertyID_Active;<span></span></pre></td></tr><tr><td scope="row"><pre>    newMovieProperties[2].propValueSize = sizeof(movieActive);<span></span></pre></td></tr><tr><td scope="row"><pre>    newMovieProperties[2].propValueAddress = &amp;movieActive;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Create our movie with NewMovieFromProperties so that we can associate it with a<span></span></pre></td></tr><tr><td scope="row"><pre>    // VisualContext from the start and not have it associated with a GWorld.<span></span></pre></td></tr><tr><td scope="row"><pre>    // Alternately, we could create the movie using NewMovieFromProperties without providing<span></span></pre></td></tr><tr><td scope="row"><pre>    // a VisualContext and later set the VisualContext for the movie with SetMovieVisualContext().<span></span></pre></td></tr><tr><td scope="row"><pre>    err = NewMovieFromProperties( 3, newMovieProperties, 0, NULL, &amp;textureMovie );<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    movieDuration = GetMovieDuration(textureMovie);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    Rect    box;<span></span></pre></td></tr><tr><td scope="row"><pre>    GetMovieBox(textureMovie, &amp;box);<span></span></pre></td></tr><tr><td scope="row"><pre>    MacOffsetRect(&amp;box, -box.left, -box.top);<span></span></pre></td></tr><tr><td scope="row"><pre>    SetMovieBox(textureMovie, &amp;box);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    MoviesTask(textureMovie, 0);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    GetMovieBox(textureMovie, &amp;movieRect);<span></span></pre></td></tr><tr><td scope="row"><pre>    movieHeight = movieRect.bottom - movieRect.top;<span></span></pre></td></tr><tr><td scope="row"><pre>    movieWidth = movieRect.right - movieRect.left;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>//-----------------------------------------------------------------------------<span></span></pre></td></tr><tr><td scope="row"><pre>// Name: InitGeometry()<span></span></pre></td></tr><tr><td scope="row"><pre>// Desc: Create the textures and vertex buffers<span></span></pre></td></tr><tr><td scope="row"><pre>//-----------------------------------------------------------------------------<span></span></pre></td></tr><tr><td scope="row"><pre>HRESULT InitGeometry()<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    // Create the vertex buffer for Rectangular view.<span></span></pre></td></tr><tr><td scope="row"><pre>    if( FAILED( gD3DDevice->CreateVertexBuffer( 4*sizeof(CUSTOMVERTEX),<span></span></pre></td></tr><tr><td scope="row"><pre>                                                0, D3DFVF_CUSTOMVERTEX,<span></span></pre></td></tr><tr><td scope="row"><pre>                                                D3DPOOL_DEFAULT, &amp;vertexBuffer, NULL ) ) )<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        return E_FAIL;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    return S_OK;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>VOID SetupVertices()<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    // Map the textures onto scene coordinates. Rather than mapping 1.0f to 0.0f from the<span></span></pre></td></tr><tr><td scope="row"><pre>    // texture, we just want to map the CleanTextureCoordinates we got from CoreVideo for the<span></span></pre></td></tr><tr><td scope="row"><pre>    // texture into the destination.<span></span></pre></td></tr><tr><td scope="row"><pre>    CUSTOMVERTEX* pVerticesRect;<span></span></pre></td></tr><tr><td scope="row"><pre>    if( FAILED( vertexBuffer->Lock( 0, 0, (void**)&amp;pVerticesRect, 0 ) ) )<span></span></pre></td></tr><tr><td scope="row"><pre>        return;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Top left<span></span></pre></td></tr><tr><td scope="row"><pre>    pVerticesRect[0].x        = -1.0f;<span></span></pre></td></tr><tr><td scope="row"><pre>    pVerticesRect[0].y        = 1.0f;<span></span></pre></td></tr><tr><td scope="row"><pre>    pVerticesRect[0].z        = 0.0f;<span></span></pre></td></tr><tr><td scope="row"><pre>    pVerticesRect[0].tu       = topLeft[0];<span></span></pre></td></tr><tr><td scope="row"><pre>    pVerticesRect[0].tv       = topLeft[1];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Bottom left<span></span></pre></td></tr><tr><td scope="row"><pre>    pVerticesRect[1].x        = -1.0f;<span></span></pre></td></tr><tr><td scope="row"><pre>    pVerticesRect[1].y        = -1.0f;<span></span></pre></td></tr><tr><td scope="row"><pre>    pVerticesRect[1].z        = 0.0f;<span></span></pre></td></tr><tr><td scope="row"><pre>    pVerticesRect[1].tu       = bottomLeft[0];<span></span></pre></td></tr><tr><td scope="row"><pre>    pVerticesRect[1].tv       = bottomLeft[1];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Top right<span></span></pre></td></tr><tr><td scope="row"><pre>     pVerticesRect[2].x        = 1.0f;<span></span></pre></td></tr><tr><td scope="row"><pre>    pVerticesRect[2].y        = 1.0f;<span></span></pre></td></tr><tr><td scope="row"><pre>    pVerticesRect[2].z        = 0.0f;<span></span></pre></td></tr><tr><td scope="row"><pre>    pVerticesRect[2].tu       = topRight[0];<span></span></pre></td></tr><tr><td scope="row"><pre>    pVerticesRect[2].tv       = topRight[1];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Bottom right<span></span></pre></td></tr><tr><td scope="row"><pre>    pVerticesRect[3].x        = 1.0f;<span></span></pre></td></tr><tr><td scope="row"><pre>    pVerticesRect[3].y        = -1.0f;<span></span></pre></td></tr><tr><td scope="row"><pre>    pVerticesRect[3].z        = 0.0f;<span></span></pre></td></tr><tr><td scope="row"><pre>    pVerticesRect[3].tu       = bottomRight[0];<span></span></pre></td></tr><tr><td scope="row"><pre>    pVerticesRect[3].tv       = bottomRight[1];<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    vertexBuffer->Unlock();<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>// The render thread. It wakes at the refresh rate of the display and checks for new<span></span></pre></td></tr><tr><td scope="row"><pre>// video frames.<span></span></pre></td></tr><tr><td scope="row"><pre>// This could be made more efficient if it only rendered either when there<span></span></pre></td></tr><tr><td scope="row"><pre>// was a new frame or when the view geometry has changed.<span></span></pre></td></tr><tr><td scope="row"><pre>DWORD __stdcall fastRenderThreadProc(void *arg)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    while (!quitFastRenderThread)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        Boolean needToTaskVC = false;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        // Check to see if there is a new frame of video available.<span></span></pre></td></tr><tr><td scope="row"><pre>        // Passing NULL for a time to QTVisualContextIsNewImageAvailable checks for the<span></span></pre></td></tr><tr><td scope="row"><pre>        // current time.<span></span></pre></td></tr><tr><td scope="row"><pre>        if (QTVisualContextIsNewImageAvailable(d3dContext, NULL))<span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>            OSStatus myErr = noErr;<span></span></pre></td></tr><tr><td scope="row"><pre>            CVImageBufferRef    newCVImageRef = NULL;<span></span></pre></td></tr><tr><td scope="row"><pre>            if (noErr == (myErr = QTVisualContextCopyImageForTime(d3dContext, NULL, NULL, &amp;newCVImageRef))) {<span></span></pre></td></tr><tr><td scope="row"><pre>                LPDIRECT3DTEXTURE9 newTexture = NULL;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>                // Get the LPDIRECT3DTEXTURE9 for this CVDirect3DTextureRef<span></span></pre></td></tr><tr><td scope="row"><pre>                newTexture = (LPDIRECT3DTEXTURE9)CVDirect3DTextureGetName((CVDirect3DTextureRef)newCVImageRef);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>                // Get the texture coordinates to use in the vertex buffer for this texture<span></span></pre></td></tr><tr><td scope="row"><pre>                CVDirect3DTextureGetCleanTexCoords(newCVImageRef, bottomLeft, bottomRight, topRight, topLeft);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>                // Release the last frame we got from the VisualContext. This will release<span></span></pre></td></tr><tr><td scope="row"><pre>                // of the associated LPDIRECT3DTEXTURE9 we received from CVDirect3DTextureGetName<span></span></pre></td></tr><tr><td scope="row"><pre>                // for the previous frame.<span></span></pre></td></tr><tr><td scope="row"><pre>                if (movieTexture != NULL )<span></span></pre></td></tr><tr><td scope="row"><pre>                        CVDirect3DTextureRelease(cvImage);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>                movieTexture = newTexture;<span></span></pre></td></tr><tr><td scope="row"><pre>                cvImage = newCVImageRef;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>                // We need to remember to task the VC to give it a chance to recycle the resources we have freed<span></span></pre></td></tr><tr><td scope="row"><pre>                needToTaskVC = true;<span></span></pre></td></tr><tr><td scope="row"><pre>            }<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        // We want to render even if we didn't get a new frame of video, since there may have been<span></span></pre></td></tr><tr><td scope="row"><pre>        // some user input that changed the texture position.<span></span></pre></td></tr><tr><td scope="row"><pre>        Render(cvImage);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        if (needToTaskVC)<span></span></pre></td></tr><tr><td scope="row"><pre>            QTVisualContextTask(d3dContext);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        WaitForSingleObject( renderCondition, renderWaitTime ); // wake up about 60 times per second<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>//bail:<span></span></pre></td></tr><tr><td scope="row"><pre>    _endthreadex( 0 );<span></span></pre></td></tr><tr><td scope="row"><pre>    return NULL;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>VOID SetupMatrices()<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    // For our world matrix, we will just leave it as the identity.<span></span></pre></td></tr><tr><td scope="row"><pre>    D3DXMATRIXA16 matWorld;<span></span></pre></td></tr><tr><td scope="row"><pre>    D3DXMATRIXA16 matTemp;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    D3DXMatrixIdentity( &amp;matWorld );<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    D3DXMatrixRotationZ( &amp;matWorld, currZRotation);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    D3DXMatrixIdentity( &amp;matTemp );<span></span></pre></td></tr><tr><td scope="row"><pre>    D3DXMatrixRotationY( &amp;matTemp, currYRotation);<span></span></pre></td></tr><tr><td scope="row"><pre>    D3DXMatrixMultiply(&amp;matWorld, &amp;matWorld, &amp;matTemp);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    D3DXMatrixIdentity( &amp;matTemp );<span></span></pre></td></tr><tr><td scope="row"><pre>    D3DXMatrixRotationX( &amp;matTemp, currXRotation);<span></span></pre></td></tr><tr><td scope="row"><pre>    D3DXMatrixMultiply(&amp;matWorld, &amp;matWorld, &amp;matTemp);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    gD3DDevice->SetTransform( D3DTS_WORLD, &amp;matWorld );<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    D3DXVECTOR3 vEyePt( gEyePtX, gEyePtY, gEyePtZ );<span></span></pre></td></tr><tr><td scope="row"><pre>    D3DXVECTOR3 vLookatPt( 0.0f, 0.0f, 0.0f );<span></span></pre></td></tr><tr><td scope="row"><pre>    D3DXVECTOR3 vUpVec( 0.0f, 1.0f, 0.0f );<span></span></pre></td></tr><tr><td scope="row"><pre>    D3DXMATRIXA16 matView;<span></span></pre></td></tr><tr><td scope="row"><pre>    D3DXMatrixLookAtLH( &amp;matView, &amp;vEyePt, &amp;vLookatPt, &amp;vUpVec );<span></span></pre></td></tr><tr><td scope="row"><pre>    gD3DDevice->SetTransform( D3DTS_VIEW, &amp;matView );<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    D3DXMATRIXA16 matProj;<span></span></pre></td></tr><tr><td scope="row"><pre>    D3DXMatrixPerspectiveFovLH( &amp;matProj, D3DX_PI/4, 1.0f, 1.0f, 100.0f );<span></span></pre></td></tr><tr><td scope="row"><pre>    gD3DDevice->SetTransform( D3DTS_PROJECTION, &amp;matProj );<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>void Render(CVImageBufferRef newCVImageRef)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    HRESULT hresult = S_OK;<span></span></pre></td></tr><tr><td scope="row"><pre>    Boolean newImageAvailable = false;<span></span></pre></td></tr><tr><td scope="row"><pre>    Boolean needToendScene = false;<span></span></pre></td></tr><tr><td scope="row"><pre>    D3DMATRIX saveWorld, saveView, saveProj;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Clear the backbuffer and the zbuffer.<span></span></pre></td></tr><tr><td scope="row"><pre>    gD3DDevice->Clear( 0, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER,<span></span></pre></td></tr><tr><td scope="row"><pre>                        D3DCOLOR_XRGB(15,15,15), 1.0f, 0 );<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    gD3DDevice->GetTransform( D3DTS_WORLD, &amp;saveWorld );<span></span></pre></td></tr><tr><td scope="row"><pre>    gD3DDevice->GetTransform( D3DTS_VIEW, &amp;saveView );<span></span></pre></td></tr><tr><td scope="row"><pre>    gD3DDevice->GetTransform( D3DTS_PROJECTION, &amp;saveProj );<span></span></pre></td></tr><tr><td scope="row"><pre>    SetupMatrices();<span></span></pre></td></tr><tr><td scope="row"><pre>    SetupVertices();<span></span></pre></td></tr><tr><td scope="row"><pre>    // Begin the scene.<span></span></pre></td></tr><tr><td scope="row"><pre>    if( (hresult = gD3DDevice->BeginScene() ) == D3D_OK )<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        needToendScene = true;<span></span></pre></td></tr><tr><td scope="row"><pre>        if (movieTexture != NULL) {<span></span></pre></td></tr><tr><td scope="row"><pre>            gD3DDevice->SetTexture( 0, movieTexture );<span></span></pre></td></tr><tr><td scope="row"><pre>            gD3DDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_SELECTARG1 );<span></span></pre></td></tr><tr><td scope="row"><pre>            gD3DDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>            // Render the vertex buffer contents.<span></span></pre></td></tr><tr><td scope="row"><pre>            hresult = gD3DDevice->SetStreamSource( 0, vertexBuffer, 0, sizeof(CUSTOMVERTEX) );<span></span></pre></td></tr><tr><td scope="row"><pre>            gD3DDevice->SetFVF( D3DFVF_CUSTOMVERTEX );<span></span></pre></td></tr><tr><td scope="row"><pre>            hresult = gD3DDevice->DrawPrimitive( D3DPT_TRIANGLESTRIP, 0, 2 );<span></span></pre></td></tr><tr><td scope="row"><pre>            if (hresult != D3D_OK) goto bail;<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        // End the scene.<span></span></pre></td></tr><tr><td scope="row"><pre>        gD3DDevice->EndScene();<span></span></pre></td></tr><tr><td scope="row"><pre>        needToendScene = false;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        // Present the backbuffer contents to the display.<span></span></pre></td></tr><tr><td scope="row"><pre>        hresult = gD3DDevice->Present( NULL, NULL, NULL, NULL );<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>bail:<span></span></pre></td></tr><tr><td scope="row"><pre>    if (needToendScene)<span></span></pre></td></tr><tr><td scope="row"><pre>        gD3DDevice->EndScene();<span></span></pre></td></tr><tr><td scope="row"><pre>    gD3DDevice->SetTransform( D3DTS_WORLD, &amp;saveWorld );<span></span></pre></td></tr><tr><td scope="row"><pre>    gD3DDevice->SetTransform( D3DTS_VIEW, &amp;saveView );<span></span></pre></td></tr><tr><td scope="row"><pre>    gD3DDevice->SetTransform( D3DTS_PROJECTION, &amp;saveProj );<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>//-----------------------------------------------------------------------------<span></span></pre></td></tr><tr><td scope="row"><pre>// Name: Cleanup()<span></span></pre></td></tr><tr><td scope="row"><pre>// Desc: Releases all previously initialized objects<span></span></pre></td></tr><tr><td scope="row"><pre>//-----------------------------------------------------------------------------<span></span></pre></td></tr><tr><td scope="row"><pre>VOID Cleanup()<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if (fastRenderThreadRunning) {<span></span></pre></td></tr><tr><td scope="row"><pre>        DWORD waitResult;<span></span></pre></td></tr><tr><td scope="row"><pre>        quitFastRenderThread = TRUE;<span></span></pre></td></tr><tr><td scope="row"><pre>        SetEvent(renderCondition);<span></span></pre></td></tr><tr><td scope="row"><pre>        waitResult = WaitForSingleObject( fastRenderThread, 5000 ); // give it a bit to kill itself<span></span></pre></td></tr><tr><td scope="row"><pre>        if (waitResult == WAIT_TIMEOUT) {<span></span></pre></td></tr><tr><td scope="row"><pre>            // The thread didn't terminate itself. Kill it.<span></span></pre></td></tr><tr><td scope="row"><pre>            TerminateThread(fastRenderThread, 0);<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>        CloseHandle(renderCondition);<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if (cvImage) {<span></span></pre></td></tr><tr><td scope="row"><pre>        CVDirect3DTextureRelease(cvImage);<span></span></pre></td></tr><tr><td scope="row"><pre>        cvImage = NULL;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if( vertexBuffer != NULL ) {<span></span></pre></td></tr><tr><td scope="row"><pre>        vertexBuffer->Release();<span></span></pre></td></tr><tr><td scope="row"><pre>        vertexBuffer = NULL;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if (gD3DDevice) {<span></span></pre></td></tr><tr><td scope="row"><pre>        gD3DDevice->Release();<span></span></pre></td></tr><tr><td scope="row"><pre>        gD3DDevice = NULL;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if( pD3D != NULL ) {<span></span></pre></td></tr><tr><td scope="row"><pre>        pD3D->Release();<span></span></pre></td></tr><tr><td scope="row"><pre>        pD3D = NULL;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>void startStopMovie() {<span></span></pre></td></tr><tr><td scope="row"><pre>    Fixed rate;<span></span></pre></td></tr><tr><td scope="row"><pre>    TimeValue currentTime = 0;<span></span></pre></td></tr><tr><td scope="row"><pre>    rate = GetMovieRate(textureMovie);<span></span></pre></td></tr><tr><td scope="row"><pre>    currentTime = GetMovieTime(textureMovie, NULL);<span></span></pre></td></tr><tr><td scope="row"><pre>    if (currentTime == movieDuration) {<span></span></pre></td></tr><tr><td scope="row"><pre>        // If we are at the end of the movie, make sure the movie is stopped and then<span></span></pre></td></tr><tr><td scope="row"><pre>        // set it back to the beginning before starting it again.<span></span></pre></td></tr><tr><td scope="row"><pre>        if (rate != 0) {<span></span></pre></td></tr><tr><td scope="row"><pre>            SetMovieRate(textureMovie, 0);<span></span></pre></td></tr><tr><td scope="row"><pre>            rate = 0;<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>        SetMovieTimeValue(textureMovie, 0);<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    if (rate == 0) {<span></span></pre></td></tr><tr><td scope="row"><pre>        SetMovieRate(textureMovie, fixed1);<span></span></pre></td></tr><tr><td scope="row"><pre>    } else<span></span></pre></td></tr><tr><td scope="row"><pre>        SetMovieRate(textureMovie, 0);<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>//<span></span></pre></td></tr><tr><td scope="row"><pre>//  FUNCTION: WndProc(HWND, unsigned, WORD, LONG)<span></span></pre></td></tr><tr><td scope="row"><pre>//<span></span></pre></td></tr><tr><td scope="row"><pre>//  PURPOSE:  Processes messages for the main window.<span></span></pre></td></tr><tr><td scope="row"><pre>//<span></span></pre></td></tr><tr><td scope="row"><pre>//  WM_COMMAND    - process the application menu<span></span></pre></td></tr><tr><td scope="row"><pre>//  WM_PAINT    - Paint the main window<span></span></pre></td></tr><tr><td scope="row"><pre>//  WM_DESTROY    - post a quit message and return<span></span></pre></td></tr><tr><td scope="row"><pre>//<span></span></pre></td></tr><tr><td scope="row"><pre>//<span></span></pre></td></tr><tr><td scope="row"><pre>LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>//    int wmId, wmEvent;<span></span></pre></td></tr><tr><td scope="row"><pre>//    PAINTSTRUCT ps;<span></span></pre></td></tr><tr><td scope="row"><pre>//    HDC hdc;<span></span></pre></td></tr><tr><td scope="row"><pre>    RECT wRect;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    switch (message)<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        case WM_DESTROY:<span></span></pre></td></tr><tr><td scope="row"><pre>            Cleanup();<span></span></pre></td></tr><tr><td scope="row"><pre>            PostQuitMessage(0);<span></span></pre></td></tr><tr><td scope="row"><pre>            break;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        case WM_LBUTTONDBLCLK:<span></span></pre></td></tr><tr><td scope="row"><pre>            startStopMovie();<span></span></pre></td></tr><tr><td scope="row"><pre>            break;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        case WM_KEYDOWN:<span></span></pre></td></tr><tr><td scope="row"><pre>            switch(wParam)<span></span></pre></td></tr><tr><td scope="row"><pre>            {<span></span></pre></td></tr><tr><td scope="row"><pre>                case VK_SPACE:<span></span></pre></td></tr><tr><td scope="row"><pre>                    startStopMovie();<span></span></pre></td></tr><tr><td scope="row"><pre>                    break;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>                // re-center movie<span></span></pre></td></tr><tr><td scope="row"><pre>                case 'C':<span></span></pre></td></tr><tr><td scope="row"><pre>                    {<span></span></pre></td></tr><tr><td scope="row"><pre>                        currXRotation = 0;<span></span></pre></td></tr><tr><td scope="row"><pre>                        currYRotation = 0;<span></span></pre></td></tr><tr><td scope="row"><pre>                        currZRotation = 0;<span></span></pre></td></tr><tr><td scope="row"><pre>                        gEyePtX = 0.0f;<span></span></pre></td></tr><tr><td scope="row"><pre>                        gEyePtY = 0.0f;<span></span></pre></td></tr><tr><td scope="row"><pre>                        gEyePtZ = -2.5f;<span></span></pre></td></tr><tr><td scope="row"><pre>                    }<span></span></pre></td></tr><tr><td scope="row"><pre>                    break;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>                // single size<span></span></pre></td></tr><tr><td scope="row"><pre>                case '1':<span></span></pre></td></tr><tr><td scope="row"><pre>                    GetWindowRect(hWnd, &amp;wRect);<span></span></pre></td></tr><tr><td scope="row"><pre>                    SetWindowPos(hWnd, HWND_TOP, wRect.top, wRect.left, movieWidth, movieHeight + 16, SWP_SHOWWINDOW );<span></span></pre></td></tr><tr><td scope="row"><pre>                    break;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>                // double-size<span></span></pre></td></tr><tr><td scope="row"><pre>                case '2':<span></span></pre></td></tr><tr><td scope="row"><pre>                    GetWindowRect(hWnd, &amp;wRect);<span></span></pre></td></tr><tr><td scope="row"><pre>                    SetWindowPos(hWnd, HWND_TOP, wRect.top, wRect.left, (2 * movieWidth), (2*movieHeight) + 16, SWP_SHOWWINDOW );<span></span></pre></td></tr><tr><td scope="row"><pre>                    break;<span></span></pre></td></tr><tr><td scope="row"><pre>            }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        case WM_MOUSEWHEEL:<span></span></pre></td></tr><tr><td scope="row"><pre>            {<span></span></pre></td></tr><tr><td scope="row"><pre>                int mouseWheelDelta = (short) HIWORD(wParam);<span></span></pre></td></tr><tr><td scope="row"><pre>                gEyePtZ += (0.01f * (mouseWheelDelta/10));<span></span></pre></td></tr><tr><td scope="row"><pre>            }<span></span></pre></td></tr><tr><td scope="row"><pre>            break;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        case WM_LBUTTONDOWN:<span></span></pre></td></tr><tr><td scope="row"><pre>            {<span></span></pre></td></tr><tr><td scope="row"><pre>                gLastMouseXPos = (short)LOWORD(lParam);<span></span></pre></td></tr><tr><td scope="row"><pre>                gLastMouseYPos = (short)HIWORD(lParam);<span></span></pre></td></tr><tr><td scope="row"><pre>            }<span></span></pre></td></tr><tr><td scope="row"><pre>            break;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        case WM_MOUSEMOVE:<span></span></pre></td></tr><tr><td scope="row"><pre>            {<span></span></pre></td></tr><tr><td scope="row"><pre>                int newXPos = (short)LOWORD(lParam);<span></span></pre></td></tr><tr><td scope="row"><pre>                int newYPos = (short)HIWORD(lParam);<span></span></pre></td></tr><tr><td scope="row"><pre>                int nMouseButtonState = LOWORD(wParam);<span></span></pre></td></tr><tr><td scope="row"><pre>                bool bLeftButton  = ((nMouseButtonState &amp; MK_LBUTTON) != 0);<span></span></pre></td></tr><tr><td scope="row"><pre>                bool bRightButton = ((nMouseButtonState &amp; MK_RBUTTON) != 0);<span></span></pre></td></tr><tr><td scope="row"><pre>                if (bLeftButton) {<span></span></pre></td></tr><tr><td scope="row"><pre>                    currYRotation -= (0.01f * ((newXPos - gLastMouseXPos)));<span></span></pre></td></tr><tr><td scope="row"><pre>                    currXRotation -= (0.01f * ((newYPos - gLastMouseYPos)));<span></span></pre></td></tr><tr><td scope="row"><pre>                    if (currYRotation > D3DX_PI)<span></span></pre></td></tr><tr><td scope="row"><pre>                        currYRotation -= 2*D3DX_PI;<span></span></pre></td></tr><tr><td scope="row"><pre>                    if (currYRotation &lt; -D3DX_PI)<span></span></pre></td></tr><tr><td scope="row"><pre>                        currYRotation += 2*D3DX_PI;<span></span></pre></td></tr><tr><td scope="row"><pre>                    if (currXRotation > D3DX_PI)<span></span></pre></td></tr><tr><td scope="row"><pre>                        currXRotation -= 2*D3DX_PI;<span></span></pre></td></tr><tr><td scope="row"><pre>                    if (currXRotation &lt; -D3DX_PI)<span></span></pre></td></tr><tr><td scope="row"><pre>                        currXRotation += 2*D3DX_PI;<span></span></pre></td></tr><tr><td scope="row"><pre>                }<span></span></pre></td></tr><tr><td scope="row"><pre>                if (bRightButton) {<span></span></pre></td></tr><tr><td scope="row"><pre>                    currZRotation -= (0.01f * ((newXPos - gLastMouseXPos)));<span></span></pre></td></tr><tr><td scope="row"><pre>                    if (currZRotation > D3DX_PI)<span></span></pre></td></tr><tr><td scope="row"><pre>                        currZRotation -= 2*D3DX_PI;<span></span></pre></td></tr><tr><td scope="row"><pre>                    if (currZRotation &lt; -D3DX_PI)<span></span></pre></td></tr><tr><td scope="row"><pre>                        currZRotation += 2*D3DX_PI;<span></span></pre></td></tr><tr><td scope="row"><pre>                }<span></span></pre></td></tr><tr><td scope="row"><pre>                gLastMouseXPos = newXPos;<span></span></pre></td></tr><tr><td scope="row"><pre>                gLastMouseYPos = newYPos;<span></span></pre></td></tr><tr><td scope="row"><pre>            }<span></span></pre></td></tr><tr><td scope="row"><pre>            break;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>        default:<span></span></pre></td></tr><tr><td scope="row"><pre>            return DefWindowProc(hWnd, message, wParam, lParam);<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    return 0;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>INT WINAPI WinMain( HINSTANCE hInst, HINSTANCE, LPSTR argStr, INT numArgs )<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    OSErr        err = noErr;<span></span></pre></td></tr><tr><td scope="row"><pre>    FSSpec        sourceFSSpec;<span></span></pre></td></tr><tr><td scope="row"><pre>    Handle        sourceMovieDataRef = NULL;<span></span></pre></td></tr><tr><td scope="row"><pre>    OSType        sourceMovieDataRefType;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // register window class<span></span></pre></td></tr><tr><td scope="row"><pre>    WNDCLASSEX wc = { sizeof(WNDCLASSEX), CS_CLASSDC, WndProc, 0L, 0L,<span></span></pre></td></tr><tr><td scope="row"><pre>                      GetModuleHandle(NULL), NULL, NULL, NULL, NULL,<span></span></pre></td></tr><tr><td scope="row"><pre>                      "WinVCPlayerWindow", NULL };<span></span></pre></td></tr><tr><td scope="row"><pre>    RegisterClassEx( &amp;wc );<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Create the application's window.<span></span></pre></td></tr><tr><td scope="row"><pre>    hWnd = CreateWindow( "WinVCPlayerWindow", "WinVCPlayer",<span></span></pre></td></tr><tr><td scope="row"><pre>                              WS_OVERLAPPEDWINDOW, 100, 100, movieWidth, movieHeight,<span></span></pre></td></tr><tr><td scope="row"><pre>                              GetDesktopWindow(), NULL, wc.hInstance, NULL );<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    InitializeQTML(0);<span></span></pre></td></tr><tr><td scope="row"><pre>    EnterMovies();<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    err = NativePathNameToFSSpec(argStr, &amp;sourceFSSpec, 0);<span></span></pre></td></tr><tr><td scope="row"><pre>    if( err ) {<span></span></pre></td></tr><tr><td scope="row"><pre>        fprintf( stderr, "NativePathNameToFSSpec(\"%s\") failed (%d)\n", argStr, err );<span></span></pre></td></tr><tr><td scope="row"><pre>        goto bail;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    err = QTNewDataReferenceFromFSSpec( &amp;sourceFSSpec, 0, &amp;sourceMovieDataRef, &amp;sourceMovieDataRefType );<span></span></pre></td></tr><tr><td scope="row"><pre>    if( err ) {<span></span></pre></td></tr><tr><td scope="row"><pre>        fprintf( stderr, "QTNewDataReferenceFromFSSpec(\"%s\") failed (%d)\n", argStr, err );<span></span></pre></td></tr><tr><td scope="row"><pre>        goto bail;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    // Initialize Direct3D and create a VisualContext associated with the Direct3DDevice.<span></span></pre></td></tr><tr><td scope="row"><pre>    if( SUCCEEDED( InitD3D( hWnd ) ) )<span></span></pre></td></tr><tr><td scope="row"><pre>    {<span></span></pre></td></tr><tr><td scope="row"><pre>        // Create a movie and point it at the VisualContext.<span></span></pre></td></tr><tr><td scope="row"><pre>        makeMovie( sourceMovieDataRef, sourceMovieDataRefType);<span></span></pre></td></tr><tr><td scope="row"><pre>        // Create the scene geometry<span></span></pre></td></tr><tr><td scope="row"><pre>        if( SUCCEEDED( InitGeometry() ) )<span></span></pre></td></tr><tr><td scope="row"><pre>        {<span></span></pre></td></tr><tr><td scope="row"><pre>             DWORD lastTaskTime = 0;<span></span></pre></td></tr><tr><td scope="row"><pre>           // Show the window.<span></span></pre></td></tr><tr><td scope="row"><pre>            SetWindowPos(hWnd, HWND_TOP, 100, 100, movieWidth, movieHeight + 16, SWP_SHOWWINDOW );<span></span></pre></td></tr><tr><td scope="row"><pre>            UpdateWindow( hWnd );<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>            MoviesTask(textureMovie, 0);<span></span></pre></td></tr><tr><td scope="row"><pre>            fastRenderThread = (HANDLE)_beginthreadex(NULL,0,(unsigned int (__stdcall *)(void*))fastRenderThreadProc,NULL,0,&amp;(fastRenderThreadID));<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>            if (!fastRenderThread || !fastRenderThreadID) {<span></span></pre></td></tr><tr><td scope="row"><pre>                err = memFullErr;<span></span></pre></td></tr><tr><td scope="row"><pre>                goto bail;<span></span></pre></td></tr><tr><td scope="row"><pre>            }<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>            fastRenderThreadRunning = TRUE;<span></span></pre></td></tr><tr><td scope="row"><pre>            // Enter the message loop.<span></span></pre></td></tr><tr><td scope="row"><pre>            MSG msg;<span></span></pre></td></tr><tr><td scope="row"><pre>            ZeroMemory( &amp;msg, sizeof(msg) );<span></span></pre></td></tr><tr><td scope="row"><pre>            while( msg.message!=WM_QUIT )<span></span></pre></td></tr><tr><td scope="row"><pre>            {<span></span></pre></td></tr><tr><td scope="row"><pre>                DWORD currTime = timeGetTime();<span></span></pre></td></tr><tr><td scope="row"><pre>                if( PeekMessage( &amp;msg, NULL, 0U, 0U, PM_REMOVE ) )<span></span></pre></td></tr><tr><td scope="row"><pre>                {<span></span></pre></td></tr><tr><td scope="row"><pre>                    TranslateMessage( &amp;msg );<span></span></pre></td></tr><tr><td scope="row"><pre>                    DispatchMessage( &amp;msg );<span></span></pre></td></tr><tr><td scope="row"><pre>                }<span></span></pre></td></tr><tr><td scope="row"><pre>                // Task the movie once in a while.<span></span></pre></td></tr><tr><td scope="row"><pre>                if (currTime >= (lastTaskTime + 100)) {<span></span></pre></td></tr><tr><td scope="row"><pre>                    MoviesTask(textureMovie, 0);<span></span></pre></td></tr><tr><td scope="row"><pre>                    lastTaskTime = currTime;<span></span></pre></td></tr><tr><td scope="row"><pre>                }<span></span></pre></td></tr><tr><td scope="row"><pre>           }<span></span></pre></td></tr><tr><td scope="row"><pre>        }<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>bail:<span></span></pre></td></tr><tr><td scope="row"><pre>    Cleanup();<span></span></pre></td></tr><tr><td scope="row"><pre>    TerminateQTML();<span></span></pre></td></tr><tr><td scope="row"><pre>    UnregisterClass( "WinVCPlayerWindow", wc.hInstance );<span></span></pre></td></tr><tr><td scope="row"><pre>    return 0;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div>

<a name="//apple_ref/doc/uid/TP40003543-NewFeaturesChangesandEnhancementsinQuickTime71-AudioEnhancementsandChanges" title="Audio Enhancements and Changes"></a>
<h2>Audio Enhancements and Changes</h2>
<p>QuickTime 7.1 now provides Windows developers with a modern, thread-safe API, <code><a href="../../../Reference/QT7-1_Update_Reference/Functions/Functions.html#//apple_ref/c/func/SCAudioFillBuffer" target="_top">SCAudioFillBuffer</a></code>, for doing compression. As the Sound Manager API is in the process of being deprecated, using this new API is the preferred method for dealing with compression on Windows, rather than using Sound Converter. A complete description of this API is available in the <em><a href="../../../Reference/QT7-1_Update_Reference/index.html#//apple_ref/doc/uid/TP40004221" target="_top">QuickTime 7.1 Update Reference</a></em>.</p><p><code><a href="../../../Reference/QT7-1_Update_Reference/Functions/Functions.html#//apple_ref/c/func/SCAudioFillBuffer" target="_top">SCAudioFillBuffer</a></code> preserves the same style API as the Core Audio <code><a href="../../../../MusicAudio/Reference/CAAudioTooboxRef/AudioConverter/CompositePage.html#//apple_ref/c/func/AudioConverterFillComplexBuffer" target="_top">AudioConverterFillComplexBuffer</a></code> API, which is part of the AudioToolbox framework and resides in AudioConverter.h. </p><p><code><a href="../../../Reference/QT7-1_Update_Reference/Functions/Functions.html#//apple_ref/c/func/SCAudioFillBuffer" target="_top">SCAudioFillBuffer</a></code> has the same parameters as <code><a href="../../../../MusicAudio/Reference/CAAudioTooboxRef/AudioConverter/CompositePage.html#//apple_ref/c/func/AudioConverterFillComplexBuffer" target="_top">AudioConverterFillComplexBuffer</a></code>, but internally it has an audio converter, a matrix mixer, and another audio converter. It’s based on a <em>“pull”</em> model: You pull on the audio converter for some output, and specify the buffer in which you want to place it. You've already configured the format that it is going to return to you. You also provide audio converter with an input proc, so it will call back that input proc and specify however many samples of audio you have. </p><p>For example, if you want five packets of AAC coming out the back end, and at the front end you happen to have PCM de-interleaved, the routine will ask you for the samples. The difference is you can now have different numbers of channels going in or out. For example, at the same time you're doing the compression from PCM to AAC, you can also go from 5.1 to stereo.</p><p><code><a href="../../../Reference/QT7-1_Update_Reference/Functions/Functions.html#//apple_ref/c/func/SCAudioFillBuffer" target="_top">SCAudioFillBuffer</a></code> is used to pull compressed frames from the StdAudio component in <code>kQTSCAudioPropertyID_BasicDescription</code> format. The StdAudio component can perform any combination of decompression/mixing/compression, combining the facilities of Core Audio AudioConverters and Matrix Mixer AudioUnits. The behavior of the <code>SCAudioFillBuffer</code> call (signalling end of data, and so on) is identical to the AudioConverter's <code>AudioConverterFillComplexBuffer</code> API.</p><p>One important difference between the AudioConverter and SCAudio component is that the SCAudio compression APIs can do mixing as well as n -> n channels conversion. If you want to compress, decompress, or transcode audio using the <code>SCAudioFillBuffer</code> interface, you configure the <code>StandardCompressionSubTypeAudio</code> component with the desired input and output formats (or use the <code>SCRequestImageSettings</code> API to present a dialog and let a user pick an output format), then you call <code><a href="../../../Reference/QT7-1_Update_Reference/Functions/Functions.html#//apple_ref/c/func/SCAudioFillBuffer" target="_top">SCAudioFillBuffer</a></code>, providing an <code>SCAudioInputDataProc</code> callback, which will be called for audio in the specified source format.</p>

<a name="//apple_ref/doc/uid/TP40003543-NewFeaturesChangesandEnhancementsinQuickTime71-SupportforPitchandRateChangesAPIDuringMoviePlayback" title="Support for Pitch and Rate Changes API During Movie Playback"></a>
<h2>Support for Pitch and Rate Changes API During Movie Playback</h2>
<p>The QuickTime audio context now provides support for pitch as well as rate changes during the playback of a QuickTime movie. An interface is provided for controlling the render quality of the TimePitch AU that performs both pitch and rate adjustments. The APIs are available in QuickTime 7.1 and allow your application to</p>
<ul class="ul">
<li class="li"><p>hold the rate constant and change the pitch, as needed</p></li>
<li class="li"><p>set the varispeed and TimePitch AU Render Quality</p></li>
<li class="li"><p>set the pitch/rate converter quality setting from the StdAudio dialog, so exports from scaled edits will have improved quality.</p></li>
</ul>
<a name="//apple_ref/doc/uid/TP40003543-NewFeaturesChangesandEnhancementsinQuickTime71-AUTimePitch" title="AUTimePitch"></a>
<h3>AUTimePitch</h3>
<p>The AUTimePitch operates in one of three different modes, depending on its Render Quality setting:</p>
<ul class="spaceabove">
<li class="li"><p>Minimum Quality - Time-Domain: not expensive, but with lower quality results</p></li>
<li class="li"><p>Medium Quality - Frequency-Domain: expensive enough not to be the default, but better quality</p></li>
<li class="li"><p>High Quality - Frequency-Domain: too expensive for real-time processing on most G4 machines, but appropriate for Export</p></li>
</ul>
<p>The Core Audio API allows programmatic control of this Render Quality parameter for playback. It also offers control over the Render Quality for extraction and export, since those operations don’t necessarily require realtime performance.</p>

<a name="//apple_ref/doc/uid/TP40003543-NewFeaturesChangesandEnhancementsinQuickTime71-kQTAudioPropertyID_Pitch" title="Using the kQTAudioPropertyID_Pitch Property"></a>
<h3>Using the kQTAudioPropertyID_Pitch Property</h3>
<p>This is a <code>Float32</code> value indicating the pitch change in “cents”, where 0.0 indicates no change of pitch, +1.0 is raised one cent, +100.0 is raised one semi-tone, -100.0 is lowered one semi-tone. The most useful range is +/-1200. (one octave). This property is listenable.</p>
<p>When this property is set on a movie, it alters the playback pitch of all audio tracks that mix into the Movie Audio Context (currently, Music, MPEG, and Streaming tracks will be unaffected). This property will fail with <code>kQTMessageNotHandledErr</code> if set on a movie that has not been opened with the <code>RateChangesPreservePitch</code> property set.</p>
<p>When this property is set on a track, it alters the playback pitch of only that track. It has no effect when set on tracks that do not mix into the Audio Context.</p>
<a name="//apple_ref/doc/uid/TP40003543-NewFeaturesChangesandEnhancementsinQuickTime71-DontLinkElementID_16" title="New Audio Properties in QuickTime 7.1"></a><h3>New Audio Properties in QuickTime 7.1</h3><p>The following is a list of the new audio properties available in QuickTime 7.1. For more information, refer to the QuickTime 7.1 Update Reference. </p>
<a name="//apple_ref/doc/uid/TP40003543-NewFeaturesChangesandEnhancementsinQuickTime71-kQTAudioRenderQuality_PlaybackDefault" title="kQTAudioRenderQuality_PlaybackDefault"></a>
<h3>kQTAudioRenderQuality_PlaybackDefault</h3>
<p>The AudioEngine is initially configured with default render quality settings that are appropriate to the individual AudioUnits, chosen to give an optimal trade-off between performance and sound quality. For instance, the Sample Rate Converter defaults to Medium Quality, while the TimePitch unit defaults to Low Quality (in order to ensure that the CPU-intensive spectral algorithms are not used).</p>
<p>Since the movie render quality property is a single value that takes effect for the entire AudioEngine, there is no simple way to restore these default quality settings once they have been changed. A new property value (<code>kQTAudioRenderQuality_PlaybackDefault</code> ) is defined that does not conflict with the stated range of AudioUnit render quality properties (0 - 0x7F) that will be recognized to mean “reset to the playback defaults”.</p>

<a name="//apple_ref/doc/uid/TP40003543-NewFeaturesChangesandEnhancementsinQuickTime71-kQTAudioPropertyID_RenderQuality" title="kQTAudioPropertyID_RenderQuality"></a>
<h3>kQTAudioPropertyID_RenderQuality</h3>
<p>The value is <code>UInt32</code>, identical in range to the corresponding AudioUnit render quality values (defined in AudioUnitProperties.h): <code>kRenderQuality_Max</code>, <code>kRenderQuality_High</code>, <code>kRenderQuality_Medium</code>, kRenderQuality_Low, <code>kRenderQuality_Min</code>, plus the QuickTime-defined value: <code>kQTAudioRenderQuality_PlaybackDefault</code>.</p>
<p>When this property is set on a movie, it alters the Render Quality parameter for all the AudioUnits in the Movie-level audio context. This includes any VariSpeed and/or TimePitch units. The Render Quality property is propagated down to all the Track audio contexts, current and future, where it may alter the Render Quality parameter for any VariSpeed and/or TimePitch units, as well as the Sample Rate Converter (when needed) and Bass/Treble Filters. It has no effect on tracks that do not mix into the audio context.</p>

<a name="//apple_ref/doc/uid/TP40003543-NewFeaturesChangesandEnhancementsinQuickTime71-kQTMovieAudioExtractionAudioPropertyID_RenderQuality" title="kQTMovieAudioExtractionAudioPropertyID_RenderQuality"></a>
<h3>kQTMovieAudioExtractionAudioPropertyID_RenderQuality</h3>
<p>The value is <code>UInt32</code>, identical in range to the corresponding AudioUnit render quality values (defined in AudioUnitProperties.h): <code>kRenderQuality_Max</code>, <code>kRenderQuality_High</code>, <code>kRenderQuality_Medium</code>, <code>kRenderQuality_Low</code>, <code>kRenderQuality_Min</code>, plus the QuickTime-defined value: <code>kQTAudioRenderQuality_PlaybackDefault</code>.</p>
<p>When this property is set on a MovieAudioExtraction session, it alters the Render Quality parameter for all the AudioUnits involved in rendering the audio for the movie’s audio context. This includes any VariSpeed, TimePitch, and/or Sample Rate Converter units. It has no effect on tracks that do not mix into the audio context.</p>

<a name="//apple_ref/doc/uid/TP40003543-NewFeaturesChangesandEnhancementsinQuickTime71-StdAudioRenderQuality" title="StdAudio Render Quality"></a>
<h3>StdAudio Render Quality</h3>
<p>The value is <code>UInt32</code>, identical in range to the corresponding AudioUnit render quality values (defined in AudioUnitProperties.h): <code>kRenderQuality_Max</code>, kRenderQuality_High, <code>kRenderQuality_Medium</code>, kRenderQuality_Low, <code>kRenderQuality_Min</code>.</p>
<p>StdAudio will not recognize the special value <code>kQTAudioRenderQuality_PlaybackDefault</code>.</p>
<p><code>kQTSCAudioPropertyID_RenderQuality</code>, a read-write-listenable property of the <code>StdAudio</code> component, specifies the quality with which QuickTime should render the audio stream during the compression/decompression/transcode operation.</p>

<a name="//apple_ref/doc/uid/TP40003543-NewFeaturesChangesandEnhancementsinQuickTime71-MovieExportRenderQuality" title="Movie Export Render Quality"></a>
<h3>Movie Export Render Quality</h3>
<p>Movie Export must be able to pass the render quality from StdAudio to both MovieAudioExtraction and to the Converter and Mixer AudioUnits. This communication is accomplished through the <code>getPropertyProc</code> interface and so requires an internal property for that communication.</p>
<p>Movie Export implements the <code>movieExportAudioRenderQuality</code> property, used in the <code>getPropertyProc</code> interface to transfer the information from StdAudio to the extraction and conversion components. If you want to take advantage of this feature, use StdAudio and pass the StdAudio settings to the exporter.</p><p>The following is a list of the new audio properties in QuickTime 7.1, available in <code>Movies.h</code>. A complete description of these properties is available in the <em><a href="../../../Reference/QT7-1_Update_Reference/index.html#//apple_ref/doc/uid/TP40004221" target="_top">QuickTime 7.1 Update Reference</a></em>. </p>

<div class="codesample"><table><tr><td scope="row"><pre>kQTAudioPropertyID_DeviceASBD = 'dasd', /* value is AudioStreamBasicDescription. Gettable.*/<span></span></pre></td></tr></table></div>

<p>This is a get-only property and returns the <code>AudioStreamBasicDescription</code> of the device the movie is playing to. The interesting fields are the sample rate, which reflects device’s current state, and the number of channels, which matches what is reported by <code>kQTAudioPropertyID_DeviceChannelLayout</code>.</p>

<div class="codesample"><table><tr><td scope="row"><pre>kQTAudioPropertyID_SummaryASBD = 'sasd', /* value is AudioStreamBasicDescription. Gettable.*/<span></span></pre></td></tr></table></div>

<p>Get-only. Returns the <code>AudioStreamBasicDescription</code> corresponding to the Summary Mix of a movie. This describes non-interleaved, <code>Float32</code> linear PCM data, with a sample rate equal to the highest audio sample rate found among the sound tracks contributing to the AudioContext mix, and a number of channels that matches what is reported by <code>kQTAudioPropertyID_SummaryChannelLayout</code>.</p>

<div class="codesample"><table><tr><td scope="row"><pre>kQTAudioPropertyID_RateChangesPreservePitch = 'aucp', /* value is Boolean. Gettable/Settable.*/<span></span></pre></td></tr></table></div>

<p>This property was introduced in QuickTime 7 and must be set in order for pitch changes to take effect. When the playback rate is not unity, audio must be resampled in order to play at the new rate. The default resampling affects the pitch of the audio (for example, playing at 2x speed raises the pitch by an octave, 1/2x lowers an octave). If this property is set on the Movie, an alternative algorithm may be used, which alters the speed without changing the pitch. Because this is more computationally expensive, this property may be silently ignored on some slow CPUs. Media handlers may query this movie property and honor it when performing Scaled Edits. This property can be specified as a property to the <code><a href="../../QT7Win_Update_Guide/Chapter03/03QT7_Update_Guide.html#//apple_ref/c/func/NewMovieFromProperties" target="_top">NewMovieFromProperties</a></code> API. Currently, it has no effect when set on an open movie.</p>

<div class="codesample"><table><tr><td scope="row"><pre>kQTAudioPropertyID_Pitch  = 'pitc', /* value is Float32. Get/Set/Listenable.*/<span></span></pre></td></tr></table></div>

<p>The movie pitch adjustment. This adjusts the pitch of all audio tracks that contribute to the AudioContext mix. Pitch control takes effect only if <code>kQTAudioPropertyID_RateChangesPreservePitch</code> is in effect; otherwise, returns <code>kQTMessageNotHandledErr</code>. The <code>Float32</code> value is specified in cents: 0.0 == no change, 1.0 == one cent up, 100.0 == one semi-tone up, -1.0 == one cent down. The most useful ranges for pitch are +/- 1200, that is, one octave.</p>
<p>The property is new in QuickTime 7.1 and available in <code>Movies.h</code>.</p>

<div class="codesample"><table><tr><td scope="row"><pre>kQTAudioPropertyID_RenderQuality = 'qual', /* value is UInt32. Gettable/Settable.*/<span></span></pre></td></tr></table></div>

<p>Movie audio render quality takes effect for movie playback. <code>UInt32</code> values are as defined in AudioUnit/AudioUnitProperties.h and vary from 0x00 (<code>kRenderQuality_Min</code>) to 0x7F (<code>kRenderQuality_Max</code>). A special value <code>kQTAudioRenderQuality_PlaybackDefault</code>) is also defined which resets the quality settings of the playback processing chain to values that are chosen to be an optimal balance of performance and quality.</p>
<p>The property is new in QuickTime 7.1 and available in <code>Movies.h</code>.</p>

<div class="codesample"><table><tr><td scope="row"><pre>kQTAudioRenderQuality_PlaybackDefault = 0x8000, /* defined to be outside the CoreAudio valid range*/;<span></span></pre></td></tr></table></div>


<div class="codesample"><table><tr><td scope="row"><pre>kQTMovieAudioExtractionAudioPropertyID_RenderQuality = 'qual' /* value is UInt32. Gettable/Settable.*/<span></span></pre></td></tr></table></div>

<p>Sets the render quality to be used for this audio extraction session. <code>UInt32</code> values are as defined in AudioUnit/AudioUnitProperties.h and vary from 0x00(<code>kRenderQuality_Min</code>) to 0x7F (<code>kRenderQuality_Max</code>). A special value (<code>kQTAudioRenderQuality_PlaybackDefault</code>) is also defined which resets the quality settings to the same values that were chosen by default for playback.</p>
<p>The property is new in QuickTime 7.1 and available in <code>Movies.h</code>.</p>

<div class="codesample"><table><tr><td scope="row"><pre>kQTSCAudioPropertyID_RenderQuality = 'qlty', /* UInt32, Read/Write/Listen*/<span></span></pre></td></tr></table></div>

<p>The property is new in QuickTime 7.1 and available in QuickTimeComponents.h.</p>


<a name="//apple_ref/doc/uid/TP40003543-NewFeaturesChangesandEnhancementsinQuickTime71-UsefulSampleCode" title="Useful Sample Code"></a>
<h2>Useful Sample Code</h2>
<p>Two notable examples of sample code that let you work with QuickTime audio in QuickTime 7 are:</p>
<ul class="ul">
<li class="li"><p><code>QTSetMovieAudioDevice</code>, which is available for download at <span class="content_text"><a href="http://developer.apple.com/samplecode/QTSetMovieAudioDevice/index.html" target="_top">http://developer.apple.com/samplecode/QTSetMovieAudioDevice/QTSetMovieAudioDevice.html</a></span></p></li>
<li class="li"><p><code>ExtractMovieAudioToAIFF</code>, available for download at <span class="content_text"><a href="http://developer.apple.com/samplecode/ExtractMovieAudioToAIFF/index.html" target="_top">http://developer.apple.com/samplecode/ExtractMovieAudioToAIFF/ExtractMovieAudioToAIFF.html</a></span></p></li>
</ul>
<a name="//apple_ref/doc/uid/TP40003543-NewFeaturesChangesandEnhancementsinQuickTime71-QTSetMovieAudioDeviceCodeSample" title="QTSetMovieAudioDevice Code Sample"></a>
<h3>QTSetMovieAudioDevice Code Sample</h3>
<p>The <code>QTSetMovieAudioDevice</code> code sample demonstrates how to create a <code>QTAudioContext</code> for a given audio output device and then target a movie to render to this audio context.</p>
<p>To accomplish this, you first use native Windows DirectX APIs to enumerate a list of all available sound output devices. Next, you call the QuickTime <code>QTAudioContextCreateForAudioDevice</code> API to create a QuickTime Audio Context (QTAudioContext) from either a device GUID or device name.</p>
<p>Note that you must have QT 7.0.4 or better installed to create a QuickTime Audio Context from a GUID.</p>
<p>Finally, you call <code>SetMovieAudioContext</code> to target the movie to render to the QuickTime Audio Context.</p>
<p>This sample lets you create a QT audio context for an audio output device and target a movie to render to the context.</p>
<p>You simply launch the application and do the following:</p>
<ol class="ol">
<li class="li"><p>Use the popup to select the desired sound output device</p></li>
<li class="li"><p>Choose a QuickTime movie file to play</p></li>
<li class="li"><p>Select the “Play Movie” button to play the movie through the selected sound output device</p></li>
</ol>

<a name="//apple_ref/doc/uid/TP40003543-NewFeaturesChangesandEnhancementsinQuickTime71-ExtractMovieAudioToAIFFCodeSample" title="ExtractMovieAudioToAIFF Code Sample"></a>
<h3>ExtractMovieAudioToAIFF Code Sample</h3>
<p>The <code>ExtractMovieAudioToAIFF</code> sample contains a simple class called <code>AIFFWriter</code> that encapsulates the functionality of two sets of APIs: QuickTime’s Audio Extraction APIs and Core Audio’s Audio File APIs.</p>
<p>The project builds a Universal Binary target and demonstrates how to extract audio from QuickTime Movies and write the data to an AIFF file.</p>
<p>The <code>AIFFWriter</code> class will either perform the extraction and file writing on a separate thread if it can, or do so on the main thread in slices thereby not blocking the UI. It also implements a progress callback similar to a movie export progress <code>proc</code>, so clients of the class can drive some user interface element similar to a progress bar.</p>
<p>The sample application uses an instance of the <code>AIFFWriter</code> class to easily perform audio extraction from a QTKit <code>QTMovie</code> to an AIFF file.</p>
<p>The <code>AIFFWriter</code> class uses the default extraction channel layout which is the aggregate channel layout of the movie (for example, all Rights mixed together, all Left Surrounds mixed together, and so on).</p>
<p>The output stream description for the file is 16-bit, interleaved big endian with the sample rate set to the highest sample rate found in the movie.</p>

<a name="//apple_ref/doc/uid/TP40003543-NewFeaturesChangesandEnhancementsinQuickTime71-DontLinkElementID_17" title="Miscellaneous Changes and Enhancements"></a><h2>Miscellaneous Changes and Enhancements</h2><p>The following are some of the other changes and enhancements available in QuickTime 7.1:</p><ul class="ul"><li class="li"><p>Updated JPEG 2000 file format support on Windows.</p></li><li class="li"><p>Multi-channel audio support for 7.1 and 8.0 channel layouts.</p></li><li class="li"><p>New and additional metadata constants. A complete description of these metadata constant is available in the <em><a href="../../../Reference/QT7-1_Update_Reference/index.html#//apple_ref/doc/uid/TP40004221" target="_top">QuickTime 7.1 Update Reference</a></em>. </p></li></ul>



        <br /><br /> 
        
        <div class="mini_nav_text" align="left">
        <span class="navButtons">
        <!-- Previous button --><span style="margin-left: 8px"><!-- Next button --></span>
        </span>
        <span id="showHideTOCLowerSpan">
        <a href="#" onclick="showHideTOC();"><img src="../../../../Resources/Images/show_toc_icon.gif" width="15" height="14" border="0" style="margin-bottom: -2px;" alt="" /></a> <a href="#" onclick="showHideTOC();">Hide TOC</a>
        </span>
        </div>

        <br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> <!--#if expr="0=1" -->&#x00a9; 2006, 2007 Apple Inc. All Rights Reserved. &#40;<!--#endif -->Last updated: 2007-03-06<!--#if expr="0=1" -->&#041;<!--#endif --></p></div>

        
        <div class="hideOnPrint hideInXcode">
        <!-- start of footer -->
        	<table width="100%" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/documentation/QuickTime/Conceptual/QT7-1_Update_Guide/Content/2NewFeaturesChangesa.html%3Fid%3DTP40003543-1.1&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/documentation/QuickTime/Conceptual/QT7-1_Update_Guide/Content/2NewFeaturesChangesa.html%3Fid%3DTP40003543-1.1&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/documentation/QuickTime/Conceptual/QT7-1_Update_Guide/Content/2NewFeaturesChangesa.html%3Fid%3DTP40003543-1.1&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>

        <!--#include virtual="/includes/framesetfooter" -->
        <!-- end of footer -->
        </div>
    </div>
</body>
</html>