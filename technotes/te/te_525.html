<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"			"http://www.w3.org/TR/REC-html40/loose.dtd"><html><head><LINK REL="stylesheet" HREF="../../adcstyle.css" TYPE="text/css"><LINK REL="stylesheet" HREF="../../style.css" TYPE="text/css"><title>Technical Note TE525: TextEdit Q&amp;As</title>                                       <meta name="categories" content="Text"><meta name="week-posted" content="Oct 1, 1990 - Oct 5, 1990"><LINK REL="stylesheet" HREF="../../css/adcstyle.css" TYPE="text/css"><script language="JavaScript" type="text/javascript" src="../../js/adc.js"></script></HEAD><BODY BGCOLOR="#FFFFFF"><a name="//apple_ref/doc/uid/DTS10002840" title="TextEdit Q&As"></a><a name="top"></A><!-- top_of_header_marker_comment --><!-- begin_header_information --><!--#include virtual="/adcnavbar" --><p><a href="http://developer.apple.com/">ADC Home</a> &gt; <a href="../../referencelibrary/index.html">Reference Library</a> &gt; <a href="../../technicalnotes/index.html">Technical Notes</a> &gt; <a href="../../technicalnotes/LegacyTechnologies/index.html">Legacy Documents</a> &gt; <a href="../../technicalnotes/LegacyTechnologies/idxTextFonts-date.html">Text & Fonts</a> &gt; </p><div style="width:100%; position:fixed;"><div align="center" id="watermark" style="position: relative; margin-left:auto; margin-right:auto; z-index:20; width:500px;"><div class="legacybox"><h1>Legacy Document<span class=closebutton><a href="javascript:closeWatermark()"><img src="../../images/closebutton.png" width="14" height="14" border="0"  alt="close button"></a></span></h1>

<p><strong>Important: </strong>This document is part of the Legacy section of the ADC Reference Library. This information should not be used for new development.</p>

<div class="reflibtopic">
	<p>Current information on this Reference Library topic can be found here:</p>
	<ul>
				<li><a href="../../referencelibrary/TextFonts/index.html" target="_blank">Reference Library > Text & Fonts</a></li>
	</ul>
</div>




</div></div></div><!-- end_header_information --><!-- bottom_of_header_marker_comment --><!-- top_of_titles_marker_comment --><CENTER><table width="600" cellpadding="0" cellspacing="0" border="0">
<tr><td align="left" scope="row">
<h1>
<div id="pagehead">Technical Note TE525</div>
<div id="pageheadsub">TextEdit Q&amp;As</div>
</h1>
</td></tr></table></CENTER><!-- bottom_of_titles_marker_comment --><CENTER><TABLE BORDER=0 CELLSPACING=1 WIDTH=600><TR><td align="left"><!-- begin_header_box --><table width="600" cellpadding="0" cellspacing="0" border="0">    <tr>        <td width=300 valign="top" align=left scope="row">            <table border="0" width="300" cellpadding="0" cellspacing="0">			<tr>                        <td width=300 align=left> <img src="images/tnmenutop.gif" alt="" align="bottom" width=300 height=7></td>                </tr>                <tr bgcolor="#e6e6e6">                    <td background="images/tnmenubody.gif" width=300 align=left>                                         <span id="menutitle">                            CONTENTS                             <br>                            <br>                        </span>                    </td>                </tr>                <tr bgcolor="#e6e6e6">                    <td background="images/tnmenubody.gif" width=300 align=left>					<!-- begin_toc -->										<p id="menutext"><A HREF="#Downloads">Downloadables</A></P>                   <!-- end_toc -->                  </td>                </tr>                <tr>                    <td width=300 align=left scope="row">                        <img src="images/tnmenubottom.gif" alt="" width=300 height=16>                    </td>                </tr>            </table>        </td>        <td width=300 valign="top" align=left><!-- begin_intro_text --><P id = "introtext">This Technical Note contains a collection of archived Q&amp;As relating to a specifictopic - questions sent the Developer Support Center (DSC) along withanswers from the DSC engineers. Current Q&amp;A's can be found on the <A HREF = "../../qa/index.html">Macintosh Technical Q&amp;A's web site</a>.</p><!-- end_intro_text --><!-- begin_date --><h3 align=center>[Oct 01 1990]</h3><!-- end_date -->                </TD>             </TR>          </TABLE>          <!-- end_table_box --> <BR><BR>          <hr width=500 align=center>          <BR><BR>          <!-- begin_content --><a name=Section1></A><h2>Introduction</h2><h2>SetStylHandle bug and workaround</h2><p><code>SetStylHandle</code> appears to dispose of only the <code>TEStyleHandle</code> in the TextEditrecord and not the handles in the <code>TEStyleRec</code> in system software version 7.0.1.Since my application calls <code>SetStylHandle</code> often, I'm leaving lots of littlehandles around in my heap. Can I safely dispose of the handles in the current<code>TEStyleRec</code> before calling <code>SetStylHandle</code>?</p>___<P><code>SetStylHandle</code> does indeed orphan the related handles in your heap, a potentialproblem for applications using <code>SetStylHandle</code>. This won't be fixed in theforeseeable future. Your application will be fine disposing of the handlesitself. Here's a routine you can use instead of <code>SetStylHandle</code>; it correctlydisposes of the substructures in the <code>TEStylRec</code> before calling <code>SetStylHandle</code>:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>void FixedSetStylHandle(TEStyleHandle newstyle, TEHandle hte)/*    This function avoids orphaning the substructures of a    TEStyleRec by disposing of them before calling SetStylHandle.*/{    register TEStyleHandle oldstyle;    /* Get the old-style handle so that we can clean it up. */    oldstyle = GetStylHandle(hte);    /* Dispose of the substructures first. */    DisposeHandle((**oldstyle).styleTab);    DisposeHandle((**oldstyle).lhTab);    DisposeHandle((**(**oldstyle).nullStyle).nullScrap);    DisposeHandle((**oldstyle).nullStyle);    /* Now we can install the new style. */    SetStylHandle(newstyle, hte);</pre>	</TD></TR></TABLE></CENTER><P><A HREF="#top">Back to top</A></p><h2>Extending TextEdit beyond 32K limit</h2><P>Date Written:  9/16/92</P><P>Last reviewed:  11/1/92</P><P>How do I get around the 32K limit in TextEdit? For example, if I have a 64Ktext file and I want to read it in and display it in a window, I can only readthe first 32K. How do I make the text display smoothly when I need to read thenext block of text in?</p>___<P>Unfortunately, there's no supported way of doing this. In the early days,TextEdit was designed for use primarily with the Dialog Manager, for displayingand editing small amounts of text at a time. Since then, many developers haveused it, or wanted to use it for much more than it was intended. See theTechnical Note <A HREF = "../ov/ov_08.html">"Don't Abuse the Managers,"</a> available on the Developer's CD(path: Technical Documentation: Macintosh Technical Notes: Overview: ManagerialAbuse).</p><p>The Word Solution Engine by DataPak is a replacement for TextEdit that allowsyou to go beyond the 32K limit, as well as including many other features. Otherpackages are available as well. Check the Redgate Macintosh Directory onAppleLink or publications such as <i>MacTutor</i> magazine to find them.</p><P><A HREF="#top">Back to top</A></p><h2>Controlling TEIdle's insertion point color</h2><P>Date Written:  7/6/92</P><P>Last reviewed:  6/14/93</P><P>Is it possible to control the color of the insertion point when I use <code>TEIdle</code>?If I have a light blue background color, the caret is always the invert of thatbackground color and doesn't have enough contrast to see it. I want to make thecolor of the caret black if possible.</p>___<P>As is often the case, some of the seemingly simplest questions tend to yieldthe most interesting answers. Succinctly, your question stabs at the wobblyknees of QuickDraw's color model. Sample code to change the color of the caretin a TextEdit record is in the Snippets folder. Here's how to implement thecolor caret.</p><p>You can use the <code>caretHook</code> field of the TextEdit record (IM I-379). Basically,this procedure is called repeatedly by <code>TEIdle</code> to draw the caret. The functioncalls <code>InvertRect </code>each time. It draws the caret, and then it erases the caret.Unfortunately, this function needs to be implemented in assembly. So there area few gotchas:</p><ul type="disc">	<li>The pointer to the rectangle for the caret is passed on the stack (not the whole rectangle).</li>	<li>The function <code>InvertRect</code> becomes <code>_InverRect</code> in assembly.</li>	<li>You can only use A4 for scratch (A0 and A1 are blown away by <code>PaintRect</code>), and then only if you saved and restore it.</li>	<li>Make sure you pop off the rectangle pointer if you do not use it.</li></ul><p>The default system function is simply <code>_InverRect </code>because the rectangle pointeris on the stack and <code>_InverRect</code> pops it off. For color, inverting is not thebest idea, as you have noted. Inversion, if it isn't black and white, does notgive you the most contrast. Thus, we need another idea.</p><p>But, remember, we have a requirement to paint once, and then erase on the nextpass. Inversion works nicely this way. To meet this requirement, use Xor modewith <code>PaintRect</code>. As you know, Xor mode is "or" mode with the double 1s being setto 0 instead of 1. This trait is ideal in your situation because, always havingthe same caret pattern, drawing a second time obliterates the previous drawingof the caret. Thus, we get the blinking behavior. And, with the Macintosh IIand Color QuickDraw, we get these cool things called pixel patterns (IM V-55).You can use your own pixel pattern as the pen pattern, bring it in from theresource, and then use <code>PaintRect</code> in the patXor mode to achieve the desiredeffect. Done, right? </p><P>Unfortunately, here we run into a major flaw of QuickDraw: It is based on twocolor models, indexed and direct. And, arithmetic operations are performed onthe pixel values, and not the colors. In the indexed model, a pixel value of0x00 is white. (The pixel value in the indexed color model is really an indexinto a color table.) If you Xor it with 0xFF, you'll get 0xFF, or black. If youXor 0xFF with 0xFF, you'll get 0x00 or white again. On the other hand (in thedirect color model), a pixel value of 0x00 is black. If you Xor it with 0xFF,you'll get 0xFF, or white. This is a problem.</p><p>So, you'll need to perform conditional caret coloring (sounds like a disease).Depending on the depth, you'll need to use a different pixel pattern. One goodway is to use <code>DeviceLoop</code> (<i>Inside Macintosh</i> Volume VI, pages 21-23).Though it's included with System 7.0, there's a simulated one as described inthe article "Multiple Screens Revealed" on page 57 of <i>develop</i> #10.DeviceLoop lets you provide a routine that is called for each screen that thedrawing area touches. In this case, the drawing routine is your <code>PaintRect</code>routine for the caret. This drawing routine gets passed the depth of thescreen. So, based on the depth of the screen, you can use a different pixelpattern to draw with. For pixel depth of 32 or direct color mode, you can useone pattern, and for the rest you can use a different pattern.</p><BR><CENTER><TABLE BORDER=0 WIDTH=550><TR><td bgcolor="#E6E6E6" align=left><P><B>Note:</B><BR>The drawing routine used by <code>DeviceLoop</code> allows you to pass in a <code>LONGINT</code> ofuserdata. With this longint, you can pass in the pointer to the rectangle fromthe assembly routine.</P></TD></TR></TABLE></CENTER><BR><P><A HREF="#top">Back to top</A></p><h2>Resizing a Macintosh edit field for TEPaste</h2><P>Date Written:  11/27/91</p><P>Last reviewed:  6/14/93</p><p>I have a small edit field and when I call <code>TEPaste</code>, the edit field contentsscroll up. How can I calculate what the height of the edit field would be afterthe paste, resize the edit field to be that size, and then do the paste?</p>___<P>There are a couple of ways to implement this:</p><p>Method #1:</p><ol type="1" start="1">	<li>Set the clip region to something other than the <code>viewRect</code> of the edit field.</li>	<li>Call <code>TEPaste</code> or <code>TEStylPaste</code> to insert the clipboard text.</li>	<li>Call <code>TEGetHeight</code> to get the new height of the text.</li>	<li>Set the <code>viewRect</code> of the <code>TERec</code> to the new height. Call TECal<code></code>Text for good measure (and good <code>lineStarts</code>).</li>	<li>Finally, set the clip region back to normal and call <code>TEUpdate</code>.</li></ol><p>Method #2:</p><ol type="1" start="1">	<li>Call <code>TENew</code> or <code>TEStylNew</code> to allocate a brand spankin' new temporary <code>TERec</code>, and give it a <code>viewRect</code> and <code>destRect</code> that's off the screen but that has the same width as the original <code>TERec</code>.</li>	<li>Next, copy the <code>hText</code> handle of the window's <code>TERec</code> into the <code>hText</code> field of the temporary <code>TERec</code> (good job for <code>BlockMove</code> [IM II-44]).</li>	<li>Call <code>TECalText</code> and <code>TEActivate</code> on it; then paste the clipboard text into the temporary <code>TERec</code>. Since the view and dest <code>Rects</code> are off the screen, none of this will be seen by the user.</li>	<li>Call <code>TEGetHeight</code> to get the new height, then copy the text back into the original <code>TERec</code>.</li>	<li>Finally, call <code>TECalText</code>, then <code>TEUpdate</code> and <code>TEActivate</code> on the original <code>TERec</code>.</li></ol><p>Method #1 has less overhead and is a little easier to implement. However, ifyou have any custom hooks installed in your <code>TERec</code>, then you probably want tolet TextEdit do as much of the work as possible. In this case, method #2 is abetter way.</p><P><A HREF="#top">Back to top</A></p><h2>Saving and restoring styled Macintosh TextEdit records</h2><P>Date Written:  11/26/90</p><P>Last reviewed:  6/14/93</p><p>How do I save and restore Macintosh records created with TextEdit that containstyles? Where can I find additional information or sample code?</p>___<P>There's no standard for saving text with styles created by TextEdit, so all wecan offer is a recommendation that's modeled after the way that <code>TECopy</code> works onstyled text. In styled TextEdit, the style information is stored separatelyfrom the text rather than embedded within it. <code>TECopy</code> maintains this separationwhen styled text is copied, so our recommendation maintains this separation,too.</p><p>To save the text part, you could make a file of type TEXT and save the text inthe data fork of the file, like TeachText does. You could also save it in aresource of type TEXT.</p><p>The best way to save the style information is to use the <code>StScrpRec</code> record.Other records used by styled TextEdit contain references to other structures orthey contain only a part of the style information, and that makes saving themawkward. The <code>StScrpRec</code> doesn't contain references to any other structures, andit contains enough information to rebuild the entire tree of TextEditstructures. When you call <code>TECopy</code> on styled text, both a <code>'TEXT'</code> and <code>'styl'</code> scraptype is placed into the desk scrap. The <code>'TEXT'</code> type just contains the text. The<code>'styl'</code> type contains a <code>StScrpRec</code> containing all of the style information forthe copied text. TextEdit doesn't maintain a <code>StScrpRec</code> for the entire textbuffer, so you have to tell TextEdit to do this for you when you're ready tosave the style information.</p><p>Fortunately, one call does it all. <i>Inside Macintosh</i> Volume V, page 268,documents the <code>GetStylScrap</code> routine. It creates a new <code>StScrpRec</code> record, placesall the style information of the selected text into it, and returns a handle tothis <code>StScrpRec</code>. First, select the text you want to save either by calling<code>TESetSelect</code> or by setting the <code>selStart</code> and <code>selEnd</code> fields of the TextEdit recordif you don't want the selection to be visible to the user. (If you do this,remember to restore the old values of <code>selStart</code> and <code>selEnd</code> after you get the<code>StScrpHandle</code>.) Next, call <code>GetStylScrap</code> to construct the <code>StScrpRec</code>. You can nowsave the resulting <code>StScrpRec</code>, perhaps in a resource of type <code>'styl'</code> or inwhatever way you see fit.</p><p>Reading the text and styles back into a TextEdit record isn't much morecomplicated. First, read the text back into a buffer and read the <code>'styl'</code>resource (or however you saved it) into a <code>StScrpRec</code>. Create a styled TextEditrecord (or use an old one), then call <code>TEStylInsert</code>, passing it a pointer to thetext buffer and a handle to the <code>StScrpRec</code>. Your TextEdit record should thencontain and display your original styled text. That's all! </p><P><A HREF="#top">Back to top</A></p><h2>Macintosh SetClikLoop procedure and TERec clikLoop field</h2><P>Date Written:  7/30/91</p><P>Last reviewed:  6/14/93</p><p>I have had some problems with the <code>SetClikLoop</code> procedure that don't appear whenI set the <code>clikLoop</code> field directly (in C). Why does TextEdit's <code>SetClikLoop</code>procedure create a special procedure to call my <code>clikLoop</code> routine, rather thatjust installing the <code>clikLoop</code> directly? <i>Inside Macintosh</i> says you can setthe <code>clikLoop</code> field directly in assembly. Why not in C?</p>___<P>The short answer is that the special procedure is a glue routine for shuttlinga result between the stack and the register D0. The larger question is why doesinstalling <code>clikLoop</code> directly work? C, I think, is the culprit.</p><p>But, before I get ahead of myself, let me explain the <code>SetClikLoop</code> procedure. Asyou know, the click loop routine has no parameters but it does return a Booleanresult (IM I-380).</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>FUNCTION MyClikLoop : Boolean; { Pascal declaration }</pre>	</TD></TR></TABLE></CENTER><p>Now, <code>MyClikLoop</code> is called by the TextEdit Manager from inside the <code>TEClick</code>routine. The way the code was written, TEClick expects to get the Booleanresult from D0. For assembly programmers, this is no problem. In Pascal, thereturn value is placed on the stack. So, D0 does not contain your routines'Boolean and what <code>TEClick</code> grabs will be "who knows what" and your program shouldcrash. <code>SetClikLoop</code> will install a glue routine that calls <code>MyClikLoop</code>. The glueroutine will move the result from the stack to D0. By the way, this informationis documented on pages 237-238 of Volume Two of <i>Macintosh Revealed,</i>Second Edition, by Stephen Chernicoff.</p><p>Now why is your program causing problems when you use <code>SetClikLoop</code>? You mighthave declared your <code>MyClikLoop</code> as a C function. Since <code>MyClikLoop</code> takes noparameters, nothing is put on the stack. But C, unlike Pascal, places itsreturn value in D0. So, for C, the glue routine is not needed. On the otherhand, if you use the <code>SetClikLoop</code> routine with a C routine, you will take thetop 2 bytes off the stack and clobber D0 with the wrong answer. Thus, you mightget problems.</p><p>Though the C routine may work by setting it directly to the <code>clikLoop</code> field,doing it that way is not the supported method. You should declare your<code>MyClikLoop</code> function as a Pascal function and use <code>SetClikLoop</code>.</p><P><A HREF="#top">Back to top</A></p><h2>Special handling for Control-P keyboard input in a Mac dialog</h2><P>Date Written:  6/5/91</p><P>Last reviewed:  6/14/93</p><p>Under System 6, when Control-P is pressed, a DLE character (hex 10) appears ina Macintosh dialog's editText field. Under System 7, pressing Control-Pproduces no change in the editText box. The character is fed in via a normal(unaltered) <code>keyDown</code> event fed to DialogSelect. Does Control-P have some specialmeaning to <code>DialogSelect</code> or TextEdit now?</p>___<P>Believe it or not, and it took several of us scratching our heads to figurethis out; yes, it does, and this is by design! What you are running into is theDialog Manager and TextEdit working together to make Cut, Copy, and Pastefunction keys work on an extended keyboard. The function keys on the top of anextended keyboard return $10 as their ASCII keycode. Thus, when <code>TEKey</code> detectsthat it is being called from dialog select, and the key you pass is a $10, itthen looks for the event record on the stack and gets the raw keycode todetermine which edit operation to perform. The bottom line is that it will notthen enter the $10 in the edit field.</p><p>There is a simple workaround, and that is to install a filter proc in yourdialog that detects keystrokes (actually it could always just look for thiscertain keystroke) and passes them to <code>TEKey</code> itself, thus skirting the wholeissue.</p><P><A HREF="#top">Back to top</A></p><h2>Dimming and disabling a specific TEditText object</h2><P>Date Written:  8/8/91</p><P>Last reviewed:  8/13/91</p><p>How can I dim and disable a specific TEditText object in my TDialogView so thefield is not editable? </p>___<P>The trick is to use the <code>TView</code> methods <code>Dimstate</code> and <code>ViewEnable</code> to disable anddim the <code>TEditText</code> Views, and then do a TEditText.StopEdit (which disablesediting in the <code>TEditText</code> box), and in the other case enable dimming and theview itself and use the TEditText.StartEdit (which enables editing in the<code>TEditText</code> box), as shown in the C++ example below:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>            anEditText2-&gt;DimState(TRUE,kDontRedraw);        // disable            anEditText2-&gt;ViewEnable(FALSE,kRedraw);            anEditText2-&gt;StopEdit();            anEditText1-&gt;DimState(FALSE,kDontRedraw);        // enable            anEditText1-&gt;ViewEnable(TRUE,kRedraw);</pre>	</TD></TR></TABLE></CENTER><p>MacApp sample code using this technique is included with DTS's Snippetsfiles.</p><P><A HREF="#top">Back to top</A></p><h2>Get TEHandle from DialogPeek, not GetDItem</h2><P>Date Written:  1/17/92</P><P>Last reviewed:  6/14/93</p><p>I want to show all characters in my Macintosh control panel as bullets wherethe password is typed in. I cannot get the <code>TECustomHook</code> to work properly, itcrashes before it gets to my hook routine. In the following Think C example,<code>CPtr</code> is dereferenced from the handle used in the control panel's cdevValuefield:</p><CENTER><TABLE BORDER=0 CELLPADDING=5 WIDTH=550><TR>	<td bgcolor="#E6E6E6" align=left><pre>   GetDItem(DPtr, ADMINPWTE+NumItems, &amp;theType, &amp;theItem, &amp;theRect);   CPtr-&gt;myTEProc = (ProcPtr)TEPWHook;</pre>	</TD></TR></TABLE></CENTER>___<P>GetDItem does NOT return a <code>TEHandle</code>; it returns a handle to the current text ofthe edit item. You must get <code>TEHandle</code> from <code>DialogPeek</code> and must always monitorand change the <code>TECustomHook</code> on the fly. There is only one <code>TEHandle</code> for adialog, no matter how many edit items are associated with the dialog. See thedescription of the <code>DialogRecord</code> data type in <i>Inside Macintosh.</i></p><P><A HREF="#top">Back to top</A></p><h2>Cursor flicker while using Macintosh TextEdit</h2><P>Date Written:  5/6/92</P><P>Last reviewed:  6/14/93</p><p>The cursor flashes when the user types in TextEdit fields in my Macintoshapplication. This is done in <code>TEKey</code>. I notice that most programs hide the cursoronce a key is pressed. I don't care for this because then I have to move themouse to see where I am. Is this a typical fix for this problem and an acceptedpractice?</p>___<P>There's very little you can do to avoid this. The problem is that every timeyou draw anything to the screen, if the cursor's position intersects therectangle of the drawing being done, QuickDraw hides the cursor while it doesthe drawing, and then shows it again to keep it from affecting the image beingdrawn beneath it. Every time you enter a character in TextEdit, the nearbycharacters are redrawn. Usually this is invisible because the characters justline up on top of their old images, but if the cursor is nearby and visible, itwill flicker while it's hidden to draw the text. This is why virtually allprograms call <code>ObscureCursor</code> when the user types. Also, most users don't wantthe image of the cursor obscuring text they might be referring to, yet theydon't want to have to move it away and then move it back to make selections.Because it's so commonplace, hiding the cursor probably won't bother yourusers; in fact, they might very well prefer the cursor hidden. This, combinedwith the fact that there's very little you can do to help the flickering,suggests that you should obscure the cursor while the user types.</p>         <a name="Downloads"></a>       <P><A HREF="#top">Back to top</A></p><h2>Downloadables</H2>                  <TABLE BORDER=0 CELLPADDING=3 WIDTH="100%">            <TR>               <td width=50 align=left>                  <P ALIGN=center><img src="images/acrobatsmall.gif" width=22 height=23 align=middle alt="Acrobat gif"></P>               </TD>               <td align="left">                  <P>Acrobat version of this Note (52K).</P>               </TD>               <td width=60 align=left>                  <P><A HREF="pdf/te_525.pdf">Download</A></P>               </TD>            </TR>                    </TABLE>         <BR></TD></TR></table></center><!-- begin_footer_information -->	<table width="680" border="0" cellpadding="0" cellspacing="0">
		<tr>
			<td><div style="width: 100%; height: 1px; background-color: #919699; margin-top: 5px; margin-bottom: 15px"></div></td>
		</tr>
		<tr>
			<td align="center"><br/>
				<table border="0" cellpadding="0" cellspacing="0" class="graybox">
					<tr>
						<th>Did this document help you?</th>
					</tr>
					<tr>
						<td>
						    <div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=1&url=/technotes/te/te_525.html%3Fid%3DDTS10002840-1.0&media=dvd" target=_new>Yes</a>:  Tell us what works for you.</div>
							<div style="margin-bottom: 8px"><a href="http://developer.apple.com/feedback/?v=2&url=/technotes/te/te_525.html%3Fid%3DDTS10002840-1.0&media=dvd" target=_new>It&#8217;s good, but:</a> Report typos, inaccuracies, and so forth.</div>
							<div><a href="http://developer.apple.com/feedback/?v=3&url=/technotes/te/te_525.html%3Fid%3DDTS10002840-1.0&media=dvd" target=_new>It wasn&#8217;t helpful</a>: Tell us what would have helped.</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
	</table>
<!--#include virtual="/includes/footer"--><!-- end_footer_information --></BODY></HTML>